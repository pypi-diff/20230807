# Comparing `tmp/CoolProp-6.4.3.post1-cp39-cp39-win_amd64.whl.zip` & `tmp/CoolProp-6.5.0-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl.zip`

## zipinfo {}

```diff
@@ -1,88 +1,97 @@
-Zip file size: 1833422 bytes, number of entries: 86
--rw-rw-rw-  2.0 fat    10226 b- defN 22-Dec-16 13:20 CoolProp/AbstractState.pxd
--rw-rw-rw-  2.0 fat     8586 b- defN 22-Dec-16 13:20 CoolProp/BibtexParser.py
--rw-rw-rw-  2.0 fat  4576768 b- defN 22-Dec-16 13:27 CoolProp/CoolProp.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat     1419 b- defN 22-Dec-16 13:20 CoolProp/CoolProp.pxd
--rw-rw-rw-  2.0 fat   135898 b- defN 22-Dec-16 13:20 CoolProp/CoolPropBibTeXLibrary.bib
--rw-rw-rw-  2.0 fat       95 b- defN 22-Dec-16 13:20 CoolProp/HumidAirProp.py
--rw-rw-rw-  2.0 fat       45 b- defN 22-Dec-16 13:20 CoolProp/State.pxd
--rw-rw-rw-  2.0 fat      167 b- defN 22-Dec-16 13:20 CoolProp/State.py
--rw-rw-rw-  2.0 fat     2841 b- defN 22-Dec-16 13:20 CoolProp/__init__.py
--rw-rw-rw-  2.0 fat    43520 b- defN 22-Dec-16 13:27 CoolProp/_constants.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat    12246 b- defN 22-Dec-16 13:20 CoolProp/cAbstractState.pxd
--rw-rw-rw-  2.0 fat     7695 b- defN 22-Dec-16 13:22 CoolProp/constants.py
--rw-rw-rw-  2.0 fat     3498 b- defN 22-Dec-16 13:22 CoolProp/constants_header.pxd
--rw-rw-rw-  2.0 fat       27 b- defN 22-Dec-16 13:20 CoolProp/typedefs.pxd
--rw-rw-rw-  2.0 fat    16858 b- defN 22-Dec-16 13:20 CoolProp/GUI/CoolPropGUI.py
--rw-rw-rw-  2.0 fat     1242 b- defN 22-Dec-16 13:20 CoolProp/GUI/PsychScript.py
--rw-rw-rw-  2.0 fat        0 b- defN 22-Dec-16 13:20 CoolProp/GUI/__init__.py
--rw-rw-rw-  2.0 fat    46523 b- defN 22-Dec-16 13:20 CoolProp/Plots/Common.py
--rw-rw-rw-  2.0 fat    23075 b- defN 22-Dec-16 13:20 CoolProp/Plots/ConsistencyPlots.py
--rw-rw-rw-  2.0 fat    25864 b- defN 22-Dec-16 13:20 CoolProp/Plots/ConsistencyPlots_pcsaft.py
--rw-rw-rw-  2.0 fat    16729 b- defN 22-Dec-16 13:20 CoolProp/Plots/Plots.py
--rw-rw-rw-  2.0 fat     6387 b- defN 22-Dec-16 13:20 CoolProp/Plots/PsychChart.py
--rw-rw-rw-  2.0 fat     2069 b- defN 22-Dec-16 13:20 CoolProp/Plots/PsychScript.py
--rw-rw-rw-  2.0 fat    28221 b- defN 22-Dec-16 13:20 CoolProp/Plots/SimpleCycles.py
--rw-rw-rw-  2.0 fat     8468 b- defN 22-Dec-16 13:20 CoolProp/Plots/SimpleCyclesCompression.py
--rw-rw-rw-  2.0 fat     6256 b- defN 22-Dec-16 13:20 CoolProp/Plots/SimpleCyclesExpansion.py
--rw-rw-rw-  2.0 fat      617 b- defN 22-Dec-16 13:20 CoolProp/Plots/Tests.py
--rw-rw-rw-  2.0 fat      638 b- defN 22-Dec-16 13:20 CoolProp/Plots/__init__.py
--rw-rw-rw-  2.0 fat    17844 b- defN 22-Dec-16 13:20 CoolProp/Plots/psy.py
--rw-rw-rw-  2.0 fat     1404 b- defN 22-Dec-16 13:20 CoolProp/Plots/psyrc
--rw-rw-rw-  2.0 fat      116 b- defN 22-Dec-16 13:20 CoolProp/include/.gitignore
--rw-rw-rw-  2.0 fat    84149 b- defN 22-Dec-16 13:20 CoolProp/include/AbstractState.h
--rw-rw-rw-  2.0 fat     9808 b- defN 22-Dec-16 13:20 CoolProp/include/Ancillaries.h
--rw-rw-rw-  2.0 fat     1216 b- defN 22-Dec-16 13:20 CoolProp/include/CPfilepaths.h
--rw-rw-rw-  2.0 fat      441 b- defN 22-Dec-16 13:20 CoolProp/include/CPmsgpack.h
--rw-rw-rw-  2.0 fat    23606 b- defN 22-Dec-16 13:20 CoolProp/include/CPnumerics.h
--rw-rw-rw-  2.0 fat     5088 b- defN 22-Dec-16 13:20 CoolProp/include/CPstrings.h
--rw-rw-rw-  2.0 fat     1900 b- defN 22-Dec-16 13:20 CoolProp/include/CachedElement.h
--rw-rw-rw-  2.0 fat    18903 b- defN 22-Dec-16 13:20 CoolProp/include/Configuration.h
--rw-rw-rw-  2.0 fat     9976 b- defN 22-Dec-16 13:20 CoolProp/include/CoolProp.h
--rw-rw-rw-  2.0 fat    24306 b- defN 22-Dec-16 13:20 CoolProp/include/CoolPropFluid.h
--rw-rw-rw-  2.0 fat    43387 b- defN 22-Dec-16 13:20 CoolProp/include/CoolPropLib.h
--rw-rw-rw-  2.0 fat     5891 b- defN 22-Dec-16 13:20 CoolProp/include/CoolPropTools.h
--rw-rw-rw-  2.0 fat    21363 b- defN 22-Dec-16 13:20 CoolProp/include/DataStructures.h
--rw-rw-rw-  2.0 fat     2274 b- defN 22-Dec-16 13:20 CoolProp/include/Exceptions.h
--rw-rw-rw-  2.0 fat    58572 b- defN 22-Dec-16 13:20 CoolProp/include/Helmholtz.h
--rw-rw-rw-  2.0 fat     1438 b- defN 22-Dec-16 13:20 CoolProp/include/HumidAirProp.h
--rw-rw-rw-  2.0 fat      379 b- defN 22-Dec-16 13:20 CoolProp/include/Ice.h
--rw-rw-rw-  2.0 fat     4667 b- defN 22-Dec-16 13:20 CoolProp/include/IdealCurves.h
--rw-rw-rw-  2.0 fat    16564 b- defN 22-Dec-16 13:20 CoolProp/include/IncompressibleFluid.h
--rw-rw-rw-  2.0 fat    36247 b- defN 22-Dec-16 13:20 CoolProp/include/MatrixMath.h
--rw-rw-rw-  2.0 fat     1781 b- defN 22-Dec-16 13:20 CoolProp/include/ODEIntegrators.h
--rw-rw-rw-  2.0 fat     2197 b- defN 22-Dec-16 13:20 CoolProp/include/PCSAFTFluid.h
--rw-rw-rw-  2.0 fat     6051 b- defN 22-Dec-16 13:20 CoolProp/include/PhaseEnvelope.h
--rw-rw-rw-  2.0 fat      465 b- defN 22-Dec-16 13:20 CoolProp/include/PlatformDetermination.h
--rw-rw-rw-  2.0 fat    57383 b- defN 22-Dec-16 13:20 CoolProp/include/PolyMath.h
--rw-rw-rw-  2.0 fat     4302 b- defN 22-Dec-16 13:20 CoolProp/include/Solvers.h
--rw-rw-rw-  2.0 fat      272 b- defN 22-Dec-16 13:20 CoolProp/include/SpeedTest.h
--rw-rw-rw-  2.0 fat      646 b- defN 22-Dec-16 13:20 CoolProp/include/TestObjects.h
--rw-rw-rw-  2.0 fat      229 b- defN 22-Dec-16 13:20 CoolProp/include/Tests.h
--rw-rw-rw-  2.0 fat      111 b- defN 22-Dec-16 13:22 CoolProp/include/cpversion.h
--rw-rw-rw-  2.0 fat      611 b- defN 22-Dec-16 13:20 CoolProp/include/crossplatform_shared_ptr.h
--rw-rw-rw-  2.0 fat      148 b- defN 22-Dec-16 13:22 CoolProp/include/gitrevision.h
--rw-rw-rw-  2.0 fat   278751 b- defN 22-Dec-16 13:20 CoolProp/include/miniz.h
--rw-rw-rw-  2.0 fat    13493 b- defN 22-Dec-16 13:20 CoolProp/include/rapidjson_include.h
--rw-rw-rw-  2.0 fat     3686 b- defN 22-Dec-16 13:20 CoolProp/include/fmt/CMakeLists.txt
--rw-rw-rw-  2.0 fat     2048 b- defN 22-Dec-16 13:20 CoolProp/include/fmt/container.h
--rw-rw-rw-  2.0 fat    16453 b- defN 22-Dec-16 13:20 CoolProp/include/fmt/format.cc
--rw-rw-rw-  2.0 fat   131883 b- defN 22-Dec-16 13:20 CoolProp/include/fmt/format.h
--rw-rw-rw-  2.0 fat      928 b- defN 22-Dec-16 13:20 CoolProp/include/fmt/ostream.cc
--rw-rw-rw-  2.0 fat     3103 b- defN 22-Dec-16 13:20 CoolProp/include/fmt/ostream.h
--rw-rw-rw-  2.0 fat     7059 b- defN 22-Dec-16 13:20 CoolProp/include/fmt/posix.cc
--rw-rw-rw-  2.0 fat     9850 b- defN 22-Dec-16 13:20 CoolProp/include/fmt/posix.h
--rw-rw-rw-  2.0 fat      784 b- defN 22-Dec-16 13:20 CoolProp/include/fmt/printf.cc
--rw-rw-rw-  2.0 fat    17470 b- defN 22-Dec-16 13:20 CoolProp/include/fmt/printf.h
--rw-rw-rw-  2.0 fat     3595 b- defN 22-Dec-16 13:20 CoolProp/include/fmt/string.h
--rw-rw-rw-  2.0 fat     3899 b- defN 22-Dec-16 13:20 CoolProp/include/fmt/time.h
--rw-rw-rw-  2.0 fat        0 b- defN 22-Dec-16 13:20 CoolProp/tests/__init__.py
--rw-rw-rw-  2.0 fat      284 b- defN 22-Dec-16 13:20 CoolProp/tests/runner.py
--rw-rw-rw-  2.0 fat     5197 b- defN 22-Dec-16 13:20 CoolProp/tests/test_CoolPropState.py
--rw-rw-rw-  2.0 fat     1031 b- defN 22-Dec-16 13:20 CoolProp/tests/test_Props.py
--rw-rw-rw-  2.0 fat     4759 b- defN 22-Dec-16 13:20 CoolProp/tests/test_plots.py
--rw-rw-rw-  2.0 fat      576 b- defN 22-Dec-16 13:27 CoolProp-6.4.3.post1.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 22-Dec-16 13:27 CoolProp-6.4.3.post1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        9 b- defN 22-Dec-16 13:27 CoolProp-6.4.3.post1.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     7377 b- defN 22-Dec-16 13:27 CoolProp-6.4.3.post1.dist-info/RECORD
-86 files, 5962048 bytes uncompressed, 1821804 bytes compressed:  69.4%
+Zip file size: 6539703 bytes, number of entries: 95
+drwxr-xr-x  2.0 unx        0 b- stor 23-Aug-06 21:27 CoolProp-6.5.0.dist-info/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Aug-06 21:27 CoolProp/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Aug-06 21:27 CoolProp.libs/
+-rw-r--r--  2.0 unx        9 b- defN 23-Aug-06 21:27 CoolProp-6.5.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     7545 b- defN 23-Aug-06 21:27 CoolProp-6.5.0.dist-info/RECORD
+-rw-r--r--  2.0 unx      555 b- defN 23-Aug-06 21:27 CoolProp-6.5.0.dist-info/METADATA
+-rw-r--r--  2.0 unx      150 b- defN 23-Aug-06 21:27 CoolProp-6.5.0.dist-info/WHEEL
+drwxr-xr-x  2.0 unx        0 b- stor 23-Aug-06 21:27 CoolProp/include/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Aug-06 21:27 CoolProp/GUI/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Aug-06 21:27 CoolProp/tests/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Aug-06 21:27 CoolProp/Plots/
+-rw-r--r--  2.0 unx     8369 b- defN 23-Aug-06 21:27 CoolProp/BibtexParser.py
+-rw-r--r--  2.0 unx    12018 b- defN 23-Aug-06 21:27 CoolProp/cAbstractState.pxd
+-rw-r--r--  2.0 unx       27 b- defN 23-Aug-06 21:27 CoolProp/typedefs.pxd
+-rwxr-xr-x  2.0 unx 22728864 b- defN 23-Aug-06 21:27 CoolProp/CoolProp.cpython-39-aarch64-linux-gnu.so
+-rw-r--r--  2.0 unx       43 b- defN 23-Aug-06 21:27 CoolProp/State.pxd
+-rwxr-xr-x  2.0 unx   491384 b- defN 23-Aug-06 21:27 CoolProp/_constants.cpython-39-aarch64-linux-gnu.so
+-rw-r--r--  2.0 unx     3327 b- defN 23-Aug-06 21:27 CoolProp/constants_header.pxd
+-rw-r--r--  2.0 unx      164 b- defN 23-Aug-06 21:27 CoolProp/State.py
+-rw-r--r--  2.0 unx   133306 b- defN 23-Aug-06 21:27 CoolProp/CoolPropBibTeXLibrary.bib
+-rw-r--r--  2.0 unx     7530 b- defN 23-Aug-06 21:27 CoolProp/constants.py
+-rw-r--r--  2.0 unx     1384 b- defN 23-Aug-06 21:27 CoolProp/CoolProp.pxd
+-rw-r--r--  2.0 unx     9989 b- defN 23-Aug-06 21:27 CoolProp/AbstractState.pxd
+-rw-r--r--  2.0 unx       93 b- defN 23-Aug-06 21:27 CoolProp/HumidAirProp.py
+-rw-r--r--  2.0 unx     2759 b- defN 23-Aug-06 21:27 CoolProp/__init__.py
+drwxr-xr-x  2.0 unx        0 b- stor 23-Aug-06 21:27 CoolProp/include/fmt/
+-rw-r--r--  2.0 unx    16305 b- defN 23-Aug-06 21:27 CoolProp/include/IncompressibleFluid.h
+-rw-r--r--  2.0 unx     4528 b- defN 23-Aug-06 21:27 CoolProp/include/IdealCurves.h
+-rw-r--r--  2.0 unx     9782 b- defN 23-Aug-06 21:27 CoolProp/include/CoolProp.h
+-rw-r--r--  2.0 unx      109 b- defN 23-Aug-06 21:27 CoolProp/include/cpversion.h
+-rw-r--r--  2.0 unx    82538 b- defN 23-Aug-06 21:27 CoolProp/include/AbstractState.h
+-rw-r--r--  2.0 unx      112 b- defN 23-Aug-06 21:27 CoolProp/include/.gitignore
+-rw-r--r--  2.0 unx      626 b- defN 23-Aug-06 21:27 CoolProp/include/TestObjects.h
+-rw-r--r--  2.0 unx    13153 b- defN 23-Aug-06 21:27 CoolProp/include/rapidjson_include.h
+-rw-r--r--  2.0 unx     1811 b- defN 23-Aug-06 21:27 CoolProp/include/CachedElement.h
+-rw-r--r--  2.0 unx      421 b- defN 23-Aug-06 21:27 CoolProp/include/CPmsgpack.h
+-rw-r--r--  2.0 unx    24487 b- defN 23-Aug-06 21:27 CoolProp/include/CoolPropFluid.h
+-rw-r--r--  2.0 unx      218 b- defN 23-Aug-06 21:27 CoolProp/include/Tests.h
+-rw-r--r--  2.0 unx      366 b- defN 23-Aug-06 21:27 CoolProp/include/Ice.h
+-rw-r--r--  2.0 unx     4193 b- defN 23-Aug-06 21:27 CoolProp/include/Solvers.h
+-rw-r--r--  2.0 unx    22902 b- defN 23-Aug-06 21:27 CoolProp/include/CPnumerics.h
+-rw-r--r--  2.0 unx     9546 b- defN 23-Aug-06 21:27 CoolProp/include/Ancillaries.h
+-rw-r--r--  2.0 unx     1391 b- defN 23-Aug-06 21:27 CoolProp/include/HumidAirProp.h
+-rw-r--r--  2.0 unx     1181 b- defN 23-Aug-06 21:27 CoolProp/include/CPfilepaths.h
+-rw-r--r--  2.0 unx     4881 b- defN 23-Aug-06 21:27 CoolProp/include/CPstrings.h
+-rw-r--r--  2.0 unx    35306 b- defN 23-Aug-06 21:27 CoolProp/include/MatrixMath.h
+-rw-r--r--  2.0 unx    21622 b- defN 23-Aug-06 21:27 CoolProp/include/DataStructures.h
+-rw-r--r--  2.0 unx      146 b- defN 23-Aug-06 21:27 CoolProp/include/gitrevision.h
+-rw-r--r--  2.0 unx      261 b- defN 23-Aug-06 21:27 CoolProp/include/SpeedTest.h
+-rw-r--r--  2.0 unx   273457 b- defN 23-Aug-06 21:27 CoolProp/include/miniz.h
+-rw-r--r--  2.0 unx    57162 b- defN 23-Aug-06 21:27 CoolProp/include/Helmholtz.h
+-rw-r--r--  2.0 unx     2114 b- defN 23-Aug-06 21:27 CoolProp/include/PCSAFTFluid.h
+-rw-r--r--  2.0 unx      591 b- defN 23-Aug-06 21:27 CoolProp/include/crossplatform_shared_ptr.h
+-rw-r--r--  2.0 unx    18547 b- defN 23-Aug-06 21:27 CoolProp/include/Configuration.h
+-rw-r--r--  2.0 unx     2199 b- defN 23-Aug-06 21:27 CoolProp/include/Exceptions.h
+-rw-r--r--  2.0 unx      446 b- defN 23-Aug-06 21:27 CoolProp/include/PlatformDetermination.h
+-rw-r--r--  2.0 unx    56395 b- defN 23-Aug-06 21:27 CoolProp/include/PolyMath.h
+-rw-r--r--  2.0 unx     1742 b- defN 23-Aug-06 21:27 CoolProp/include/ODEIntegrators.h
+-rw-r--r--  2.0 unx    42671 b- defN 23-Aug-06 21:27 CoolProp/include/CoolPropLib.h
+-rw-r--r--  2.0 unx     5727 b- defN 23-Aug-06 21:27 CoolProp/include/CoolPropTools.h
+-rw-r--r--  2.0 unx     5911 b- defN 23-Aug-06 21:27 CoolProp/include/PhaseEnvelope.h
+-rw-r--r--  2.0 unx    21233 b- defN 23-Aug-06 21:27 CoolProp/include/fmt/printf.h
+-rw-r--r--  2.0 unx    13081 b- defN 23-Aug-06 21:27 CoolProp/include/fmt/os.h
+-rw-r--r--  2.0 unx     7420 b- defN 23-Aug-06 21:27 CoolProp/include/fmt/args.h
+-rw-r--r--  2.0 unx    10012 b- defN 23-Aug-06 21:27 CoolProp/include/fmt/xchar.h
+-rw-r--r--  2.0 unx    74109 b- defN 23-Aug-06 21:27 CoolProp/include/fmt/chrono.h
+-rw-r--r--  2.0 unx    24288 b- defN 23-Aug-06 21:27 CoolProp/include/fmt/color.h
+-rw-r--r--  2.0 unx    73518 b- defN 23-Aug-06 21:27 CoolProp/include/fmt/format-inl.h
+-rw-r--r--  2.0 unx   173982 b- defN 23-Aug-06 21:27 CoolProp/include/fmt/format.h
+-rw-r--r--  2.0 unx    21087 b- defN 23-Aug-06 21:27 CoolProp/include/fmt/compile.h
+-rw-r--r--  2.0 unx    10723 b- defN 23-Aug-06 21:27 CoolProp/include/fmt/std.h
+-rw-r--r--  2.0 unx    24107 b- defN 23-Aug-06 21:27 CoolProp/include/fmt/ranges.h
+-rw-r--r--  2.0 unx     6589 b- defN 23-Aug-06 21:27 CoolProp/include/fmt/ostream.h
+-rw-r--r--  2.0 unx    99583 b- defN 23-Aug-06 21:27 CoolProp/include/fmt/core.h
+-rw-r--r--  2.0 unx     1207 b- defN 23-Aug-06 21:27 CoolProp/GUI/PsychScript.py
+-rw-r--r--  2.0 unx    16381 b- defN 23-Aug-06 21:27 CoolProp/GUI/CoolPropGUI.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Aug-06 21:27 CoolProp/GUI/__init__.py
+-rw-r--r--  2.0 unx      271 b- defN 23-Aug-06 21:27 CoolProp/tests/runner.py
+-rw-r--r--  2.0 unx     4596 b- defN 23-Aug-06 21:27 CoolProp/tests/test_plots.py
+-rw-r--r--  2.0 unx     5066 b- defN 23-Aug-06 21:27 CoolProp/tests/test_CoolPropState.py
+-rw-r--r--  2.0 unx     1001 b- defN 23-Aug-06 21:27 CoolProp/tests/test_Props.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Aug-06 21:27 CoolProp/tests/__init__.py
+-rw-r--r--  2.0 unx    22553 b- defN 23-Aug-06 21:27 CoolProp/Plots/ConsistencyPlots.py
+-rw-r--r--  2.0 unx     6200 b- defN 23-Aug-06 21:27 CoolProp/Plots/PsychChart.py
+-rw-r--r--  2.0 unx    27454 b- defN 23-Aug-06 21:27 CoolProp/Plots/SimpleCycles.py
+-rw-r--r--  2.0 unx     1331 b- defN 23-Aug-06 21:27 CoolProp/Plots/psyrc
+-rw-r--r--  2.0 unx     2020 b- defN 23-Aug-06 21:27 CoolProp/Plots/PsychScript.py
+-rw-r--r--  2.0 unx    17336 b- defN 23-Aug-06 21:27 CoolProp/Plots/psy.py
+-rw-r--r--  2.0 unx     8229 b- defN 23-Aug-06 21:27 CoolProp/Plots/SimpleCyclesCompression.py
+-rw-r--r--  2.0 unx    45356 b- defN 23-Aug-06 21:27 CoolProp/Plots/Common.py
+-rw-r--r--  2.0 unx      598 b- defN 23-Aug-06 21:27 CoolProp/Plots/Tests.py
+-rw-r--r--  2.0 unx    25309 b- defN 23-Aug-06 21:27 CoolProp/Plots/ConsistencyPlots_pcsaft.py
+-rw-r--r--  2.0 unx    16368 b- defN 23-Aug-06 21:27 CoolProp/Plots/Plots.py
+-rw-r--r--  2.0 unx      620 b- defN 23-Aug-06 21:27 CoolProp/Plots/__init__.py
+-rw-r--r--  2.0 unx     6080 b- defN 23-Aug-06 21:27 CoolProp/Plots/SimpleCyclesExpansion.py
+95 files, 24898071 bytes uncompressed, 6527117 bytes compressed:  73.8%
```

## zipnote {}

```diff
@@ -1,259 +1,286 @@
-Filename: CoolProp/AbstractState.pxd
+Filename: CoolProp-6.5.0.dist-info/
 Comment: 
 
-Filename: CoolProp/BibtexParser.py
+Filename: CoolProp/
 Comment: 
 
-Filename: CoolProp/CoolProp.cp39-win_amd64.pyd
+Filename: CoolProp.libs/
 Comment: 
 
-Filename: CoolProp/CoolProp.pxd
+Filename: CoolProp-6.5.0.dist-info/top_level.txt
 Comment: 
 
-Filename: CoolProp/CoolPropBibTeXLibrary.bib
+Filename: CoolProp-6.5.0.dist-info/RECORD
 Comment: 
 
-Filename: CoolProp/HumidAirProp.py
+Filename: CoolProp-6.5.0.dist-info/METADATA
 Comment: 
 
-Filename: CoolProp/State.pxd
+Filename: CoolProp-6.5.0.dist-info/WHEEL
 Comment: 
 
-Filename: CoolProp/State.py
+Filename: CoolProp/include/
 Comment: 
 
-Filename: CoolProp/__init__.py
+Filename: CoolProp/GUI/
 Comment: 
 
-Filename: CoolProp/_constants.cp39-win_amd64.pyd
+Filename: CoolProp/tests/
 Comment: 
 
-Filename: CoolProp/cAbstractState.pxd
+Filename: CoolProp/Plots/
 Comment: 
 
-Filename: CoolProp/constants.py
+Filename: CoolProp/BibtexParser.py
 Comment: 
 
-Filename: CoolProp/constants_header.pxd
+Filename: CoolProp/cAbstractState.pxd
 Comment: 
 
 Filename: CoolProp/typedefs.pxd
 Comment: 
 
-Filename: CoolProp/GUI/CoolPropGUI.py
+Filename: CoolProp/CoolProp.cpython-39-aarch64-linux-gnu.so
 Comment: 
 
-Filename: CoolProp/GUI/PsychScript.py
+Filename: CoolProp/State.pxd
 Comment: 
 
-Filename: CoolProp/GUI/__init__.py
+Filename: CoolProp/_constants.cpython-39-aarch64-linux-gnu.so
 Comment: 
 
-Filename: CoolProp/Plots/Common.py
+Filename: CoolProp/constants_header.pxd
 Comment: 
 
-Filename: CoolProp/Plots/ConsistencyPlots.py
+Filename: CoolProp/State.py
 Comment: 
 
-Filename: CoolProp/Plots/ConsistencyPlots_pcsaft.py
+Filename: CoolProp/CoolPropBibTeXLibrary.bib
 Comment: 
 
-Filename: CoolProp/Plots/Plots.py
+Filename: CoolProp/constants.py
 Comment: 
 
-Filename: CoolProp/Plots/PsychChart.py
+Filename: CoolProp/CoolProp.pxd
 Comment: 
 
-Filename: CoolProp/Plots/PsychScript.py
+Filename: CoolProp/AbstractState.pxd
 Comment: 
 
-Filename: CoolProp/Plots/SimpleCycles.py
+Filename: CoolProp/HumidAirProp.py
 Comment: 
 
-Filename: CoolProp/Plots/SimpleCyclesCompression.py
+Filename: CoolProp/__init__.py
 Comment: 
 
-Filename: CoolProp/Plots/SimpleCyclesExpansion.py
+Filename: CoolProp/include/fmt/
 Comment: 
 
-Filename: CoolProp/Plots/Tests.py
+Filename: CoolProp/include/IncompressibleFluid.h
 Comment: 
 
-Filename: CoolProp/Plots/__init__.py
+Filename: CoolProp/include/IdealCurves.h
 Comment: 
 
-Filename: CoolProp/Plots/psy.py
+Filename: CoolProp/include/CoolProp.h
 Comment: 
 
-Filename: CoolProp/Plots/psyrc
+Filename: CoolProp/include/cpversion.h
+Comment: 
+
+Filename: CoolProp/include/AbstractState.h
 Comment: 
 
 Filename: CoolProp/include/.gitignore
 Comment: 
 
-Filename: CoolProp/include/AbstractState.h
+Filename: CoolProp/include/TestObjects.h
 Comment: 
 
-Filename: CoolProp/include/Ancillaries.h
+Filename: CoolProp/include/rapidjson_include.h
 Comment: 
 
-Filename: CoolProp/include/CPfilepaths.h
+Filename: CoolProp/include/CachedElement.h
 Comment: 
 
 Filename: CoolProp/include/CPmsgpack.h
 Comment: 
 
-Filename: CoolProp/include/CPnumerics.h
+Filename: CoolProp/include/CoolPropFluid.h
 Comment: 
 
-Filename: CoolProp/include/CPstrings.h
+Filename: CoolProp/include/Tests.h
 Comment: 
 
-Filename: CoolProp/include/CachedElement.h
+Filename: CoolProp/include/Ice.h
 Comment: 
 
-Filename: CoolProp/include/Configuration.h
+Filename: CoolProp/include/Solvers.h
 Comment: 
 
-Filename: CoolProp/include/CoolProp.h
+Filename: CoolProp/include/CPnumerics.h
 Comment: 
 
-Filename: CoolProp/include/CoolPropFluid.h
+Filename: CoolProp/include/Ancillaries.h
 Comment: 
 
-Filename: CoolProp/include/CoolPropLib.h
+Filename: CoolProp/include/HumidAirProp.h
 Comment: 
 
-Filename: CoolProp/include/CoolPropTools.h
+Filename: CoolProp/include/CPfilepaths.h
 Comment: 
 
-Filename: CoolProp/include/DataStructures.h
+Filename: CoolProp/include/CPstrings.h
 Comment: 
 
-Filename: CoolProp/include/Exceptions.h
+Filename: CoolProp/include/MatrixMath.h
 Comment: 
 
-Filename: CoolProp/include/Helmholtz.h
+Filename: CoolProp/include/DataStructures.h
 Comment: 
 
-Filename: CoolProp/include/HumidAirProp.h
+Filename: CoolProp/include/gitrevision.h
 Comment: 
 
-Filename: CoolProp/include/Ice.h
+Filename: CoolProp/include/SpeedTest.h
 Comment: 
 
-Filename: CoolProp/include/IdealCurves.h
+Filename: CoolProp/include/miniz.h
 Comment: 
 
-Filename: CoolProp/include/IncompressibleFluid.h
+Filename: CoolProp/include/Helmholtz.h
 Comment: 
 
-Filename: CoolProp/include/MatrixMath.h
+Filename: CoolProp/include/PCSAFTFluid.h
 Comment: 
 
-Filename: CoolProp/include/ODEIntegrators.h
+Filename: CoolProp/include/crossplatform_shared_ptr.h
 Comment: 
 
-Filename: CoolProp/include/PCSAFTFluid.h
+Filename: CoolProp/include/Configuration.h
 Comment: 
 
-Filename: CoolProp/include/PhaseEnvelope.h
+Filename: CoolProp/include/Exceptions.h
 Comment: 
 
 Filename: CoolProp/include/PlatformDetermination.h
 Comment: 
 
 Filename: CoolProp/include/PolyMath.h
 Comment: 
 
-Filename: CoolProp/include/Solvers.h
+Filename: CoolProp/include/ODEIntegrators.h
 Comment: 
 
-Filename: CoolProp/include/SpeedTest.h
+Filename: CoolProp/include/CoolPropLib.h
 Comment: 
 
-Filename: CoolProp/include/TestObjects.h
+Filename: CoolProp/include/CoolPropTools.h
 Comment: 
 
-Filename: CoolProp/include/Tests.h
+Filename: CoolProp/include/PhaseEnvelope.h
 Comment: 
 
-Filename: CoolProp/include/cpversion.h
+Filename: CoolProp/include/fmt/printf.h
 Comment: 
 
-Filename: CoolProp/include/crossplatform_shared_ptr.h
+Filename: CoolProp/include/fmt/os.h
 Comment: 
 
-Filename: CoolProp/include/gitrevision.h
+Filename: CoolProp/include/fmt/args.h
 Comment: 
 
-Filename: CoolProp/include/miniz.h
+Filename: CoolProp/include/fmt/xchar.h
 Comment: 
 
-Filename: CoolProp/include/rapidjson_include.h
+Filename: CoolProp/include/fmt/chrono.h
 Comment: 
 
-Filename: CoolProp/include/fmt/CMakeLists.txt
+Filename: CoolProp/include/fmt/color.h
 Comment: 
 
-Filename: CoolProp/include/fmt/container.h
+Filename: CoolProp/include/fmt/format-inl.h
 Comment: 
 
-Filename: CoolProp/include/fmt/format.cc
+Filename: CoolProp/include/fmt/format.h
 Comment: 
 
-Filename: CoolProp/include/fmt/format.h
+Filename: CoolProp/include/fmt/compile.h
 Comment: 
 
-Filename: CoolProp/include/fmt/ostream.cc
+Filename: CoolProp/include/fmt/std.h
+Comment: 
+
+Filename: CoolProp/include/fmt/ranges.h
 Comment: 
 
 Filename: CoolProp/include/fmt/ostream.h
 Comment: 
 
-Filename: CoolProp/include/fmt/posix.cc
+Filename: CoolProp/include/fmt/core.h
 Comment: 
 
-Filename: CoolProp/include/fmt/posix.h
+Filename: CoolProp/GUI/PsychScript.py
 Comment: 
 
-Filename: CoolProp/include/fmt/printf.cc
+Filename: CoolProp/GUI/CoolPropGUI.py
 Comment: 
 
-Filename: CoolProp/include/fmt/printf.h
+Filename: CoolProp/GUI/__init__.py
 Comment: 
 
-Filename: CoolProp/include/fmt/string.h
+Filename: CoolProp/tests/runner.py
+Comment: 
+
+Filename: CoolProp/tests/test_plots.py
 Comment: 
 
-Filename: CoolProp/include/fmt/time.h
+Filename: CoolProp/tests/test_CoolPropState.py
+Comment: 
+
+Filename: CoolProp/tests/test_Props.py
 Comment: 
 
 Filename: CoolProp/tests/__init__.py
 Comment: 
 
-Filename: CoolProp/tests/runner.py
+Filename: CoolProp/Plots/ConsistencyPlots.py
 Comment: 
 
-Filename: CoolProp/tests/test_CoolPropState.py
+Filename: CoolProp/Plots/PsychChart.py
 Comment: 
 
-Filename: CoolProp/tests/test_Props.py
+Filename: CoolProp/Plots/SimpleCycles.py
 Comment: 
 
-Filename: CoolProp/tests/test_plots.py
+Filename: CoolProp/Plots/psyrc
+Comment: 
+
+Filename: CoolProp/Plots/PsychScript.py
+Comment: 
+
+Filename: CoolProp/Plots/psy.py
+Comment: 
+
+Filename: CoolProp/Plots/SimpleCyclesCompression.py
+Comment: 
+
+Filename: CoolProp/Plots/Common.py
 Comment: 
 
-Filename: CoolProp-6.4.3.post1.dist-info/METADATA
+Filename: CoolProp/Plots/Tests.py
 Comment: 
 
-Filename: CoolProp-6.4.3.post1.dist-info/WHEEL
+Filename: CoolProp/Plots/ConsistencyPlots_pcsaft.py
 Comment: 
 
-Filename: CoolProp-6.4.3.post1.dist-info/top_level.txt
+Filename: CoolProp/Plots/Plots.py
 Comment: 
 
-Filename: CoolProp-6.4.3.post1.dist-info/RECORD
+Filename: CoolProp/Plots/__init__.py
+Comment: 
+
+Filename: CoolProp/Plots/SimpleCyclesExpansion.py
 Comment: 
 
 Zip file comment:
```

## filetype from file(1)

```diff
@@ -1 +1 @@
-Zip archive data, at least v2.0 to extract, compression method=deflate
+Zip archive data, at least v2.0 to extract, compression method=store
```

## CoolProp/AbstractState.pxd

```diff
@@ -1,227 +1,227 @@
-from libcpp cimport bool
-from libcpp.string cimport string
-
-# A header defining the AbstractState class
-from . cimport cAbstractState
-
-from .typedefs cimport *
-from . cimport constants_header
-
-#ctypedef fused string_t:
-#    cython.p_char
-#    bytes
-#    unicode
-#    string
-#
-#ctypedef fused string_or_size_t:
-#    string_t
-#    cython.integral
-
-ctypedef fused string_or_size_t:
-    cython.p_char
-    bytes
-    unicode
-    string
-    short
-    int
-    long
-
-cdef class PyPhaseEnvelopeData:
-    cpdef public bool TypeI
-    cpdef public size_t iTsat_max, ipsat_max, icrit
-    cpdef public list T, p, lnT, lnp, rhomolar_liq, rhomolar_vap, lnrhomolar_liq, lnrhomolar_vap, hmolar_liq, hmolar_vap, smolar_liq, smolar_vap, Q
-    cpdef public list x, y, K
-
-cdef class PyGuessesStructure:
-    cpdef public double T, p, rhomolar, hmolar, smolar
-    cpdef public double rhomolar_liq, rhomolar_vap
-    cpdef public list x, y
-
-cdef class PyCriticalState:
-    cpdef public double T, p, rhomolar, hmolar, smolar
-    cpdef public bool stable
-
-cdef class PySpinodalData:
-    cpdef public vector[double] tau, delta, M1
-
-cdef class AbstractState:
-    cdef cAbstractState.AbstractState *thisptr     # hold a C++ instance which we're wrapping
-    cpdef update(self, constants_header.input_pairs iInput1, double Value1, double Value2)
-    cpdef update_with_guesses(self, constants_header.input_pairs iInput1, double Value1, double Value2, PyGuessesStructure guesses)
-    cpdef set_mole_fractions(self, vector[double] z)
-    cpdef set_mass_fractions(self, vector[double] z)
-    cpdef set_volu_fractions(self, vector[double] z)
-
-    cpdef set_binary_interaction_double(self, string_or_size_t CAS1, string_or_size_t CAS2, string parameter, double val)
-    cpdef double get_binary_interaction_double(self, string_or_size_t CAS1, string_or_size_t CAS2, string parameter) except *
-    cpdef set_binary_interaction_string(self, string_or_size_t CAS1, string_or_size_t CAS2, string parameter, string val)
-    cpdef string get_binary_interaction_string(self, string CAS1, string CAS2, string parameter) except *
-    cpdef apply_simple_mixing_rule(self, size_t, size_t, string)
-
-    cpdef name(self)
-    cpdef backend_name(self)
-    cpdef fluid_names(self)
-    cpdef fluid_param_string(self, string key)
-    cpdef set_fluid_parameter_double(self, size_t i, string parameter, double value)
-    cpdef double get_fluid_parameter_double(self, size_t i, string parameter) except *
-    cpdef change_EOS(self, size_t, string)
-
-    cpdef constants_header.phases phase(self) except *
-    cpdef specify_phase(self, constants_header.phases phase)
-    cpdef unspecify_phase(self)
-
-    ## Limits
-    cpdef double Tmin(self) except *
-    cpdef double Tmax(self) except *
-    cpdef double pmax(self) except *
-    cpdef double Ttriple(self) except *
-
-    ## Critical point
-    cpdef double T_critical(self) except *
-    cpdef double rhomass_critical(self) except *
-    cpdef double rhomolar_critical(self) except *
-    cpdef double p_critical(self) except *
-    cpdef list all_critical_points(self)
-    cpdef tuple criticality_contour_values(self)
-
-    ## Spinodal curve(s)
-    cpdef build_spinodal(self)
-    cpdef PySpinodalData get_spinodal_data(self)
-
-    ## Reducing point
-    cpdef double T_reducing(self) except *
-    cpdef double rhomolar_reducing(self) except *
-    cpdef double rhomass_reducing(self) except *
-
-    ## Tangent plane distance
-    cpdef double tangent_plane_distance(self, double T, double p, vector[double] w, double rhomolar_guess=*) except *
-
-    ## ----------------------------------------
-    ##        Fluid property accessors
-    ## ----------------------------------------
-
-    cpdef double T(self) except *
-    cpdef double p(self) except *
-    cpdef double Q(self) except *
-    cpdef double compressibility_factor(self) except *
-    cpdef double rhomolar(self) except *
-    cpdef double hmolar(self) except *
-    cpdef double smolar(self) except *
-    cpdef double umolar(self) except *
-    cpdef double cpmolar(self) except *
-    cpdef double cp0molar(self) except *
-    cpdef double cvmolar(self) except *
-    cpdef double rhomass(self) except *
-    cpdef double hmass(self) except *
-    cpdef double smass(self) except *
-    cpdef double umass(self) except *
-    cpdef double cpmass(self) except *
-    cpdef double cp0mass(self) except *
-    cpdef double cvmass(self) except *
-    cpdef double gibbsmass(self) except *
-    cpdef double gibbsmolar(self) except *
-    cpdef double helmholtzmass(self) except *
-    cpdef double helmholtzmolar(self) except *
-    cpdef double speed_sound(self) except *
-    cpdef double gas_constant(self) except *
-    cpdef double tau(self) except *
-    cpdef double delta(self) except *
-    cpdef double viscosity(self) except *
-    cpdef double conductivity(self) except *
-    cpdef dict conformal_state(self, string, CoolPropDbl, CoolPropDbl)
-    cpdef dict conductivity_contributions(self)
-    cpdef dict viscosity_contributions(self)
-    cpdef double surface_tension(self) except *
-    cpdef double Prandtl(self) except *
-    cpdef double Bvirial(self) except *
-    cpdef double Cvirial(self) except *
-    cpdef double PIP(self) except *
-    cpdef double fundamental_derivative_of_gas_dynamics(self) except *
-    cpdef double isothermal_compressibility(self) except *
-    cpdef double isobaric_expansion_coefficient(self) except *
-    cpdef double fugacity(self, size_t) except *
-    cpdef double fugacity_coefficient(self, size_t) except *
-    cpdef double chemical_potential(self, size_t) except *
-
-    cpdef double gibbsmolar_excess(self) except *
-    cpdef double gibbsmass_excess(self) except *
-    cpdef double hmolar_excess(self) except *
-    cpdef double hmass_excess(self) except *
-    cpdef double smolar_excess(self) except *
-    cpdef double smass_excess(self) except *
-    cpdef double umolar_excess(self) except *
-    cpdef double umass_excess(self) except *
-    cpdef double volumemolar_excess(self) except *
-    cpdef double volumemass_excess(self) except *
-    cpdef double helmholtzmolar_excess(self) except *
-    cpdef double helmholtzmass_excess(self) except *
-
-    cpdef double gibbsmolar_residual(self) except *
-    cpdef double hmolar_residual(self) except *
-    cpdef double smolar_residual(self) except *
-
-
-
-
-    cpdef double molar_mass(self) except *
-    cpdef double acentric_factor(self) except*
-    cpdef tuple true_critical_point(self)
-    cpdef double get_fluid_constant(self,size_t,constants_header.parameters) except*
-    cpdef double keyed_output(self, constants_header.parameters) except *
-    cpdef double trivial_keyed_output(self, constants_header.parameters) except *
-    cpdef double saturated_liquid_keyed_output(self, constants_header.parameters) except *
-    cpdef double saturated_vapor_keyed_output(self, constants_header.parameters) except *
-
-    cpdef tuple ideal_curve(self, string)
-
-    ## ----------------------------------------
-    ##        Derivatives
-    ## ----------------------------------------
-
-    cpdef CoolPropDbl first_partial_deriv(self, constants_header.parameters, constants_header.parameters, constants_header.parameters) except *
-    cpdef CoolPropDbl second_partial_deriv(self, constants_header.parameters, constants_header.parameters, constants_header.parameters, constants_header.parameters, constants_header.parameters) except *
-    cpdef CoolPropDbl first_saturation_deriv(self, constants_header.parameters, constants_header.parameters) except *
-    cpdef CoolPropDbl second_saturation_deriv(self, constants_header.parameters, constants_header.parameters, constants_header.parameters) except *
-
-    cpdef double first_two_phase_deriv(self, constants_header.parameters Of, constants_header.parameters Wrt, constants_header.parameters Constant) except *
-    cpdef double second_two_phase_deriv(self, constants_header.parameters Of, constants_header.parameters Wrt1, constants_header.parameters Constant1, constants_header.parameters Wrt2, constants_header.parameters Constant2) except *
-    cpdef double first_two_phase_deriv_splined(self ,constants_header.parameters Of, constants_header.parameters Wrt, constants_header.parameters Constant, double x_end) except *
-
-    cpdef double melting_line(self, int, int, double) except *
-    cpdef bool has_melting_line(self) except *
-    cpdef double saturation_ancillary(self, constants_header.parameters, int, constants_header.parameters, double) except *
-
-    cpdef build_phase_envelope(self, string)
-    cpdef PyPhaseEnvelopeData get_phase_envelope_data(self)
-
-    cpdef mole_fractions_liquid(self)
-    cpdef mole_fractions_vapor(self)
-    cpdef get_mass_fractions(self)
-    cpdef get_mole_fractions(self)
-
-    cpdef CoolPropDbl alpha0(self) except *
-    cpdef CoolPropDbl dalpha0_dDelta(self) except *
-    cpdef CoolPropDbl dalpha0_dTau(v) except *
-    cpdef CoolPropDbl d2alpha0_dDelta2(self) except *
-    cpdef CoolPropDbl d2alpha0_dDelta_dTau(self) except *
-    cpdef CoolPropDbl d2alpha0_dTau2(self) except *
-    cpdef CoolPropDbl d3alpha0_dTau3(self) except *
-    cpdef CoolPropDbl d3alpha0_dDelta_dTau2(self) except *
-    cpdef CoolPropDbl d3alpha0_dDelta2_dTau(self) except *
-    cpdef CoolPropDbl d3alpha0_dDelta3(self) except *
-
-    cpdef CoolPropDbl alphar(self) except *
-    cpdef CoolPropDbl dalphar_dDelta(self) except *
-    cpdef CoolPropDbl dalphar_dTau(self) except *
-    cpdef CoolPropDbl d2alphar_dDelta2(self) except *
-    cpdef CoolPropDbl d2alphar_dDelta_dTau(self) except *
-    cpdef CoolPropDbl d2alphar_dTau2(self) except *
-    cpdef CoolPropDbl d3alphar_dDelta3(self) except *
-    cpdef CoolPropDbl d3alphar_dDelta2_dTau(self) except *
-    cpdef CoolPropDbl d3alphar_dDelta_dTau2(self) except *
-    cpdef CoolPropDbl d3alphar_dTau3(self) except *
-    cpdef CoolPropDbl d4alphar_dDelta4(self) except *
-    cpdef CoolPropDbl d4alphar_dDelta3_dTau(self) except *
-    cpdef CoolPropDbl d4alphar_dDelta2_dTau2(self) except *
-    cpdef CoolPropDbl d4alphar_dDelta_dTau3(self) except *
-    cpdef CoolPropDbl d4alphar_dTau4(self) except *
+from libcpp cimport bool
+from libcpp.string cimport string
+
+# A header defining the AbstractState class
+from . cimport cAbstractState
+
+from .typedefs cimport *
+from . cimport constants_header
+
+#ctypedef fused string_t:
+#    cython.p_char
+#    bytes
+#    unicode
+#    string
+#
+#ctypedef fused string_or_size_t:
+#    string_t
+#    cython.integral
+
+ctypedef fused string_or_size_t:
+    cython.p_char
+    bytes
+    unicode
+    string
+    short
+    int
+    long
+
+cdef class PyPhaseEnvelopeData:
+    cdef public bool TypeI
+    cdef public size_t iTsat_max, ipsat_max, icrit
+    cdef public list T, p, lnT, lnp, rhomolar_liq, rhomolar_vap, lnrhomolar_liq, lnrhomolar_vap, hmolar_liq, hmolar_vap, smolar_liq, smolar_vap, Q
+    cdef public list x, y, K
+
+cdef class PyGuessesStructure:
+    cdef public double T, p, rhomolar, hmolar, smolar
+    cdef public double rhomolar_liq, rhomolar_vap
+    cdef public list x, y
+
+cdef class PyCriticalState:
+    cdef public double T, p, rhomolar, hmolar, smolar
+    cdef public bool stable
+
+cdef class PySpinodalData:
+    cdef public vector[double] tau, delta, M1
+
+cdef class AbstractState:
+    cdef cAbstractState.AbstractState *thisptr     # hold a C++ instance which we're wrapping
+    cpdef update(self, constants_header.input_pairs iInput1, double Value1, double Value2)
+    cpdef update_with_guesses(self, constants_header.input_pairs iInput1, double Value1, double Value2, PyGuessesStructure guesses)
+    cpdef set_mole_fractions(self, vector[double] z)
+    cpdef set_mass_fractions(self, vector[double] z)
+    cpdef set_volu_fractions(self, vector[double] z)
+
+    cpdef set_binary_interaction_double(self, string_or_size_t CAS1, string_or_size_t CAS2, string parameter, double val)
+    cpdef double get_binary_interaction_double(self, string_or_size_t CAS1, string_or_size_t CAS2, string parameter) except *
+    cpdef set_binary_interaction_string(self, string_or_size_t CAS1, string_or_size_t CAS2, string parameter, string val)
+    cpdef string get_binary_interaction_string(self, string CAS1, string CAS2, string parameter) except *
+    cpdef apply_simple_mixing_rule(self, size_t, size_t, string)
+
+    cpdef name(self)
+    cpdef backend_name(self)
+    cpdef fluid_names(self)
+    cpdef fluid_param_string(self, string key)
+    cpdef set_fluid_parameter_double(self, size_t i, string parameter, double value)
+    cpdef double get_fluid_parameter_double(self, size_t i, string parameter) except *
+    cpdef change_EOS(self, size_t, string)
+
+    cpdef constants_header.phases phase(self) except *
+    cpdef specify_phase(self, constants_header.phases phase)
+    cpdef unspecify_phase(self)
+
+    ## Limits
+    cpdef double Tmin(self) except *
+    cpdef double Tmax(self) except *
+    cpdef double pmax(self) except *
+    cpdef double Ttriple(self) except *
+
+    ## Critical point
+    cpdef double T_critical(self) except *
+    cpdef double rhomass_critical(self) except *
+    cpdef double rhomolar_critical(self) except *
+    cpdef double p_critical(self) except *
+    cpdef list all_critical_points(self)
+    cpdef tuple criticality_contour_values(self)
+
+    ## Spinodal curve(s)
+    cpdef build_spinodal(self)
+    cpdef PySpinodalData get_spinodal_data(self)
+
+    ## Reducing point
+    cpdef double T_reducing(self) except *
+    cpdef double rhomolar_reducing(self) except *
+    cpdef double rhomass_reducing(self) except *
+
+    ## Tangent plane distance
+    cpdef double tangent_plane_distance(self, double T, double p, vector[double] w, double rhomolar_guess=*) except *
+
+    ## ----------------------------------------
+    ##        Fluid property accessors
+    ## ----------------------------------------
+
+    cpdef double T(self) except *
+    cpdef double p(self) except *
+    cpdef double Q(self) except *
+    cpdef double compressibility_factor(self) except *
+    cpdef double rhomolar(self) except *
+    cpdef double hmolar(self) except *
+    cpdef double smolar(self) except *
+    cpdef double umolar(self) except *
+    cpdef double cpmolar(self) except *
+    cpdef double cp0molar(self) except *
+    cpdef double cvmolar(self) except *
+    cpdef double rhomass(self) except *
+    cpdef double hmass(self) except *
+    cpdef double smass(self) except *
+    cpdef double umass(self) except *
+    cpdef double cpmass(self) except *
+    cpdef double cp0mass(self) except *
+    cpdef double cvmass(self) except *
+    cpdef double gibbsmass(self) except *
+    cpdef double gibbsmolar(self) except *
+    cpdef double helmholtzmass(self) except *
+    cpdef double helmholtzmolar(self) except *
+    cpdef double speed_sound(self) except *
+    cpdef double gas_constant(self) except *
+    cpdef double tau(self) except *
+    cpdef double delta(self) except *
+    cpdef double viscosity(self) except *
+    cpdef double conductivity(self) except *
+    cpdef dict conformal_state(self, string, CoolPropDbl, CoolPropDbl)
+    cpdef dict conductivity_contributions(self)
+    cpdef dict viscosity_contributions(self)
+    cpdef double surface_tension(self) except *
+    cpdef double Prandtl(self) except *
+    cpdef double Bvirial(self) except *
+    cpdef double Cvirial(self) except *
+    cpdef double PIP(self) except *
+    cpdef double fundamental_derivative_of_gas_dynamics(self) except *
+    cpdef double isothermal_compressibility(self) except *
+    cpdef double isobaric_expansion_coefficient(self) except *
+    cpdef double fugacity(self, size_t) except *
+    cpdef double fugacity_coefficient(self, size_t) except *
+    cpdef double chemical_potential(self, size_t) except *
+
+    cpdef double gibbsmolar_excess(self) except *
+    cpdef double gibbsmass_excess(self) except *
+    cpdef double hmolar_excess(self) except *
+    cpdef double hmass_excess(self) except *
+    cpdef double smolar_excess(self) except *
+    cpdef double smass_excess(self) except *
+    cpdef double umolar_excess(self) except *
+    cpdef double umass_excess(self) except *
+    cpdef double volumemolar_excess(self) except *
+    cpdef double volumemass_excess(self) except *
+    cpdef double helmholtzmolar_excess(self) except *
+    cpdef double helmholtzmass_excess(self) except *
+
+    cpdef double gibbsmolar_residual(self) except *
+    cpdef double hmolar_residual(self) except *
+    cpdef double smolar_residual(self) except *
+
+
+
+
+    cpdef double molar_mass(self) except *
+    cpdef double acentric_factor(self) except*
+    cpdef tuple true_critical_point(self)
+    cpdef double get_fluid_constant(self,size_t,constants_header.parameters) except*
+    cpdef double keyed_output(self, constants_header.parameters) except *
+    cpdef double trivial_keyed_output(self, constants_header.parameters) except *
+    cpdef double saturated_liquid_keyed_output(self, constants_header.parameters) except *
+    cpdef double saturated_vapor_keyed_output(self, constants_header.parameters) except *
+
+    cpdef tuple ideal_curve(self, string)
+
+    ## ----------------------------------------
+    ##        Derivatives
+    ## ----------------------------------------
+
+    cpdef CoolPropDbl first_partial_deriv(self, constants_header.parameters, constants_header.parameters, constants_header.parameters) except *
+    cpdef CoolPropDbl second_partial_deriv(self, constants_header.parameters, constants_header.parameters, constants_header.parameters, constants_header.parameters, constants_header.parameters) except *
+    cpdef CoolPropDbl first_saturation_deriv(self, constants_header.parameters, constants_header.parameters) except *
+    cpdef CoolPropDbl second_saturation_deriv(self, constants_header.parameters, constants_header.parameters, constants_header.parameters) except *
+
+    cpdef double first_two_phase_deriv(self, constants_header.parameters Of, constants_header.parameters Wrt, constants_header.parameters Constant) except *
+    cpdef double second_two_phase_deriv(self, constants_header.parameters Of, constants_header.parameters Wrt1, constants_header.parameters Constant1, constants_header.parameters Wrt2, constants_header.parameters Constant2) except *
+    cpdef double first_two_phase_deriv_splined(self ,constants_header.parameters Of, constants_header.parameters Wrt, constants_header.parameters Constant, double x_end) except *
+
+    cpdef double melting_line(self, int, int, double) except *
+    cpdef bool has_melting_line(self) except *
+    cpdef double saturation_ancillary(self, constants_header.parameters, int, constants_header.parameters, double) except *
+
+    cpdef build_phase_envelope(self, string)
+    cpdef PyPhaseEnvelopeData get_phase_envelope_data(self)
+
+    cpdef mole_fractions_liquid(self)
+    cpdef mole_fractions_vapor(self)
+    cpdef get_mass_fractions(self)
+    cpdef get_mole_fractions(self)
+
+    cpdef CoolPropDbl alpha0(self) except *
+    cpdef CoolPropDbl dalpha0_dDelta(self) except *
+    cpdef CoolPropDbl dalpha0_dTau(v) except *
+    cpdef CoolPropDbl d2alpha0_dDelta2(self) except *
+    cpdef CoolPropDbl d2alpha0_dDelta_dTau(self) except *
+    cpdef CoolPropDbl d2alpha0_dTau2(self) except *
+    cpdef CoolPropDbl d3alpha0_dTau3(self) except *
+    cpdef CoolPropDbl d3alpha0_dDelta_dTau2(self) except *
+    cpdef CoolPropDbl d3alpha0_dDelta2_dTau(self) except *
+    cpdef CoolPropDbl d3alpha0_dDelta3(self) except *
+
+    cpdef CoolPropDbl alphar(self) except *
+    cpdef CoolPropDbl dalphar_dDelta(self) except *
+    cpdef CoolPropDbl dalphar_dTau(self) except *
+    cpdef CoolPropDbl d2alphar_dDelta2(self) except *
+    cpdef CoolPropDbl d2alphar_dDelta_dTau(self) except *
+    cpdef CoolPropDbl d2alphar_dTau2(self) except *
+    cpdef CoolPropDbl d3alphar_dDelta3(self) except *
+    cpdef CoolPropDbl d3alphar_dDelta2_dTau(self) except *
+    cpdef CoolPropDbl d3alphar_dDelta_dTau2(self) except *
+    cpdef CoolPropDbl d3alphar_dTau3(self) except *
+    cpdef CoolPropDbl d4alphar_dDelta4(self) except *
+    cpdef CoolPropDbl d4alphar_dDelta3_dTau(self) except *
+    cpdef CoolPropDbl d4alphar_dDelta2_dTau2(self) except *
+    cpdef CoolPropDbl d4alphar_dDelta_dTau3(self) except *
+    cpdef CoolPropDbl d4alphar_dTau4(self) except *
```

## CoolProp/BibtexParser.py

 * *Ordering differences only*

```diff
@@ -1,217 +1,217 @@
-#!/usr/bin/env python
-# -*- coding: utf8 -*-
-
-from __future__ import division, absolute_import, print_function
-from __future__ import generators
-import pybtex.plugin, pybtex.database.input.bibtex, pybtex.errors
-import io
-import codecs, latexcodec
-import os
-import six
-
-# Here we are going to simply hack the formatting of the article class such that it preserves the
-# desired spacing and capitalization.  Probably this problem could be better solved with new styles,
-# but this seems to work...
-import pybtex.style.formatting as formatting
-from pybtex.style.template import node, join
-# Create our new function
-
-
-@node
-def toplevel(children, data):
-    return join(sep=' ')[children].format_data(data)
-
-
-# And now, we over-write the function with our desired function.  Et voila! It works!
-formatting.toplevel = toplevel
-
-
-class BibTeXerClass(object):
-    """
-    A base class that defines all the variables needed
-    to print a very basic bibliography.
-    """
-
-    def __init__(self, fName=u'../../../CoolPropBibTeXLibrary.bib'):
-        self.loadLibrary(fName)
-
-    def loadLibrary(self, path, keys=[], encoding="latex"):
-        """Open a BibTex file and do some initial parsing.
-        The path to the file has to be provided, otherwise an exception is raised.
-
-        Optionally, you can provide an array of keys to reduce the amount of
-        processed entries immediately.
-
-        By default, the Bibtex file gets scanned with the artificial \"latex\"
-        encoding, which translates Latex commands to their unicode equivalents.
-        If you need Latex output, you can skip this step by passing another
-        codec to the \"encoding\" parameter, for example \"ascii\" or \"utf-8\".
-        """
-
-        if path is None:
-            raise ValueError("You have to provide a path to a bibtex file.")
-
-        # Create the parser object
-        if len(keys) > 0:
-            bib_parser = pybtex.database.input.bibtex.Parser(wanted_entries=keys)
-        else:
-            bib_parser = pybtex.database.input.bibtex.Parser()
-
-        # TODO: not needed anymore?
-        oldLatexCodec = False
-        if oldLatexCodec:
-            # Do not print that many warnings
-            pybtex.errors.set_strict_mode(enable=False)
-
-            # TODO: Remove empty lines to keep Pybtex from choking
-            with open(path, "r") as f:
-                lines = f.readlines()
-                cleaned = [l.strip() for l in lines if l.strip()]
-
-            path = path + ".filtered.bib"
-            with open(path, "w") as f:
-                f.writelines('\n'.join(cleaned))
-
-        # Open the file and convert it according to the encoding
-        with codecs.open(path, encoding=encoding) as stream:
-            self.library = bib_parser.parse_stream(stream)
-
-        # os.remove(path)
-
-        # Do some post-processing if encoding was latex
-        if encoding == "latex":
-            for tag in self.library.entries:
-                entry = self.library.entries[tag]
-                for key, value in six.iteritems(entry.fields):
-                    entry.fields[key] = self.stripCurls(value)
-                    if key == 'Title':
-                        entry.fields[key] = u'{' + entry.fields[key] + '}'
-                for key in entry.persons.keys():
-                    for i in range(len(entry.persons[key])):
-                        entry.persons[key][i]._first = self.stripCurls(entry.persons[key][i].first())
-                        entry.persons[key][i]._middle = self.stripCurls(entry.persons[key][i].middle())
-                        entry.persons[key][i]._prelast = self.stripCurls(entry.persons[key][i].prelast())
-                        entry.persons[key][i]._last = self.stripCurls(entry.persons[key][i].last())
-                        entry.persons[key][i]._lineage = self.stripCurls(entry.persons[key][i].lineage())
-
-    def stripCurls(self, text):
-        """Remove curly brackets from processed Latex code
-
-        A function that always returns unicode. It also tries to recurse into
-        lists and dicts, but be careful this is not thoroughly tested.
-        """
-        table = {ord(u'{'): None, ord(u'}'): None}
-
-        if isinstance(text, str):  # ordinary string
-            pass
-        else:
-            try:
-                for k in text.keys():
-                    text[k] = self.stripCurls(text[k])
-            except AttributeError:
-                pass
-            # Check for list
-            if isinstance(text, type([])):
-                for i in range(len(text)):
-                    text[i] = self.stripCurls(text[i])
-            # return the plain object
-            return text
-
-        stripped = text.translate(table)
-        return stripped
-
-    def getBibliography(self, keys=None, fmt="plaintext", style="unsrtalpha", enc=None, objects=False):
-        """This function creates a formatted bibliography according to the
-        defined parameters using Pybtex.
-        Specify your desired output format using the \"fmt\" parameter. Supported
-        formats are defined by Pybtex and the parameter is only passed on to the
-        plugin search function: latex, html, plaintext and markdown.
-        The \"style\" parameter is handled similarly. At the moment, Pybtex partly
-        supports the styles: alpha, plain, unsrt and unsrtalpha.
-        Use the objects parameter to obtain the formatted bibliography and the
-        backend renderer instead of the unicode object.
-        """
-
-        if self.library is None:
-            raise ValueError("No library has been loaded, yet.")
-
-        style_cls = pybtex.plugin.find_plugin('pybtex.style.formatting', style)
-        style = style_cls()
-        data = self.library
-        biblio = style.format_bibliography(data, citations=keys)
-
-        backend_cls = pybtex.plugin.find_plugin('pybtex.backends', fmt)
-        backend = backend_cls(encoding=enc)
-
-        if objects:
-            return biblio, backend
-
-        stream = io.StringIO()
-        backend.write_to_stream(biblio, stream)
-        contents = stream.getvalue()
-        stream.close()
-        return contents
-
-    def getEntry(self, key, label=False, fmt="plaintext", style="unsrtalpha", enc=None):
-        """If you only want a single entry from your bibliography and not the
-        whole thing, this function is for you.
-        It uses Pybtex, but removes the prologue and the epilogue and optionally
-        deletes the label.
-        For the other parameters, have a look at :func:`getBibliography`.
-        """
-        # TODO: What is this for?
-        if key.startswith('__'):
-            return None
-
-        biblio, backend = self.getBibliography(keys=[key], fmt=fmt, style=style, enc=enc, objects=True)
-
-        # Disable prologue and the epilogue
-        backend.write_prologue = lambda: None
-        backend.write_epilogue = lambda: None
-
-        stream = io.StringIO()
-        backend.write_to_stream(biblio, stream)
-        contents = stream.getvalue()
-        stream.close()
-
-        if label:
-            return contents
-
-        label_table = {
-            'latex': '}',
-            'html': '</dt>',
-            'markdown': ']',
-            'plaintext': ']',
-            }  # How do we find the end of the label?
-
-        end_of_label = contents.index(label_table[fmt])
-        contents = contents[end_of_label + len(label_table[fmt]):].strip()
-
-        # {} are needed to preserve capitalization, but we don't want them in the final output, so remove them
-        contents = contents.replace('{', '').replace('}', '')
-
-        if fmt == "latex":
-            contents = contents.replace(u"\\newblock ", "")
-            contents = codecs.encode(contents, "latex")
-        elif fmt == "html":
-            contents = contents.replace(u"<dd>", "")
-            contents = contents.replace(u"</dd>", "")
-
-        contents = contents.replace(u"\n", "")
-
-        return contents
-
-
-# getEntry(self, key, label=False, fmt="markdown", style="unsrtalpha", enc=None):
-
-
-if __name__ == '__main__':
-    B = BibTeXerClass('../../../CoolPropBibTeXLibrary.bib')
-    print("\nLatex:")
-    print(B.getEntry(key='Mulero-JPCRD-2012', fmt='latex'))
-    print("\nHTML:")
-    print(B.getEntry(key='Mulero-JPCRD-2012', fmt='html'))
-    print("\nMarkdown:")
-    print(B.getEntry(key='Mulero-JPCRD-2012', fmt='markdown'))
-    print("\nText:")
-    print(B.getEntry(key='Mulero-JPCRD-2012', fmt='plaintext'))
+#!/usr/bin/env python
+# -*- coding: utf8 -*-
+
+from __future__ import division, absolute_import, print_function
+from __future__ import generators
+import pybtex.plugin, pybtex.database.input.bibtex, pybtex.errors
+import io
+import codecs, latexcodec
+import os
+import six
+
+# Here we are going to simply hack the formatting of the article class such that it preserves the
+# desired spacing and capitalization.  Probably this problem could be better solved with new styles,
+# but this seems to work...
+import pybtex.style.formatting as formatting
+from pybtex.style.template import node, join
+# Create our new function
+
+
+@node
+def toplevel(children, data):
+    return join(sep=' ')[children].format_data(data)
+
+
+# And now, we over-write the function with our desired function.  Et voila! It works!
+formatting.toplevel = toplevel
+
+
+class BibTeXerClass(object):
+    """
+    A base class that defines all the variables needed
+    to print a very basic bibliography.
+    """
+
+    def __init__(self, fName=u'../../../CoolPropBibTeXLibrary.bib'):
+        self.loadLibrary(fName)
+
+    def loadLibrary(self, path, keys=[], encoding="latex"):
+        """Open a BibTex file and do some initial parsing.
+        The path to the file has to be provided, otherwise an exception is raised.
+
+        Optionally, you can provide an array of keys to reduce the amount of
+        processed entries immediately.
+
+        By default, the Bibtex file gets scanned with the artificial \"latex\"
+        encoding, which translates Latex commands to their unicode equivalents.
+        If you need Latex output, you can skip this step by passing another
+        codec to the \"encoding\" parameter, for example \"ascii\" or \"utf-8\".
+        """
+
+        if path is None:
+            raise ValueError("You have to provide a path to a bibtex file.")
+
+        # Create the parser object
+        if len(keys) > 0:
+            bib_parser = pybtex.database.input.bibtex.Parser(wanted_entries=keys)
+        else:
+            bib_parser = pybtex.database.input.bibtex.Parser()
+
+        # TODO: not needed anymore?
+        oldLatexCodec = False
+        if oldLatexCodec:
+            # Do not print that many warnings
+            pybtex.errors.set_strict_mode(enable=False)
+
+            # TODO: Remove empty lines to keep Pybtex from choking
+            with open(path, "r") as f:
+                lines = f.readlines()
+                cleaned = [l.strip() for l in lines if l.strip()]
+
+            path = path + ".filtered.bib"
+            with open(path, "w") as f:
+                f.writelines('\n'.join(cleaned))
+
+        # Open the file and convert it according to the encoding
+        with codecs.open(path, encoding=encoding) as stream:
+            self.library = bib_parser.parse_stream(stream)
+
+        # os.remove(path)
+
+        # Do some post-processing if encoding was latex
+        if encoding == "latex":
+            for tag in self.library.entries:
+                entry = self.library.entries[tag]
+                for key, value in six.iteritems(entry.fields):
+                    entry.fields[key] = self.stripCurls(value)
+                    if key == 'Title':
+                        entry.fields[key] = u'{' + entry.fields[key] + '}'
+                for key in entry.persons.keys():
+                    for i in range(len(entry.persons[key])):
+                        entry.persons[key][i]._first = self.stripCurls(entry.persons[key][i].first())
+                        entry.persons[key][i]._middle = self.stripCurls(entry.persons[key][i].middle())
+                        entry.persons[key][i]._prelast = self.stripCurls(entry.persons[key][i].prelast())
+                        entry.persons[key][i]._last = self.stripCurls(entry.persons[key][i].last())
+                        entry.persons[key][i]._lineage = self.stripCurls(entry.persons[key][i].lineage())
+
+    def stripCurls(self, text):
+        """Remove curly brackets from processed Latex code
+
+        A function that always returns unicode. It also tries to recurse into
+        lists and dicts, but be careful this is not thoroughly tested.
+        """
+        table = {ord(u'{'): None, ord(u'}'): None}
+
+        if isinstance(text, str):  # ordinary string
+            pass
+        else:
+            try:
+                for k in text.keys():
+                    text[k] = self.stripCurls(text[k])
+            except AttributeError:
+                pass
+            # Check for list
+            if isinstance(text, type([])):
+                for i in range(len(text)):
+                    text[i] = self.stripCurls(text[i])
+            # return the plain object
+            return text
+
+        stripped = text.translate(table)
+        return stripped
+
+    def getBibliography(self, keys=None, fmt="plaintext", style="unsrtalpha", enc=None, objects=False):
+        """This function creates a formatted bibliography according to the
+        defined parameters using Pybtex.
+        Specify your desired output format using the \"fmt\" parameter. Supported
+        formats are defined by Pybtex and the parameter is only passed on to the
+        plugin search function: latex, html, plaintext and markdown.
+        The \"style\" parameter is handled similarly. At the moment, Pybtex partly
+        supports the styles: alpha, plain, unsrt and unsrtalpha.
+        Use the objects parameter to obtain the formatted bibliography and the
+        backend renderer instead of the unicode object.
+        """
+
+        if self.library is None:
+            raise ValueError("No library has been loaded, yet.")
+
+        style_cls = pybtex.plugin.find_plugin('pybtex.style.formatting', style)
+        style = style_cls()
+        data = self.library
+        biblio = style.format_bibliography(data, citations=keys)
+
+        backend_cls = pybtex.plugin.find_plugin('pybtex.backends', fmt)
+        backend = backend_cls(encoding=enc)
+
+        if objects:
+            return biblio, backend
+
+        stream = io.StringIO()
+        backend.write_to_stream(biblio, stream)
+        contents = stream.getvalue()
+        stream.close()
+        return contents
+
+    def getEntry(self, key, label=False, fmt="plaintext", style="unsrtalpha", enc=None):
+        """If you only want a single entry from your bibliography and not the
+        whole thing, this function is for you.
+        It uses Pybtex, but removes the prologue and the epilogue and optionally
+        deletes the label.
+        For the other parameters, have a look at :func:`getBibliography`.
+        """
+        # TODO: What is this for?
+        if key.startswith('__'):
+            return None
+
+        biblio, backend = self.getBibliography(keys=[key], fmt=fmt, style=style, enc=enc, objects=True)
+
+        # Disable prologue and the epilogue
+        backend.write_prologue = lambda: None
+        backend.write_epilogue = lambda: None
+
+        stream = io.StringIO()
+        backend.write_to_stream(biblio, stream)
+        contents = stream.getvalue()
+        stream.close()
+
+        if label:
+            return contents
+
+        label_table = {
+            'latex': '}',
+            'html': '</dt>',
+            'markdown': ']',
+            'plaintext': ']',
+            }  # How do we find the end of the label?
+
+        end_of_label = contents.index(label_table[fmt])
+        contents = contents[end_of_label + len(label_table[fmt]):].strip()
+
+        # {} are needed to preserve capitalization, but we don't want them in the final output, so remove them
+        contents = contents.replace('{', '').replace('}', '')
+
+        if fmt == "latex":
+            contents = contents.replace(u"\\newblock ", "")
+            contents = codecs.encode(contents, "latex")
+        elif fmt == "html":
+            contents = contents.replace(u"<dd>", "")
+            contents = contents.replace(u"</dd>", "")
+
+        contents = contents.replace(u"\n", "")
+
+        return contents
+
+
+# getEntry(self, key, label=False, fmt="markdown", style="unsrtalpha", enc=None):
+
+
+if __name__ == '__main__':
+    B = BibTeXerClass('../../../CoolPropBibTeXLibrary.bib')
+    print("\nLatex:")
+    print(B.getEntry(key='Mulero-JPCRD-2012', fmt='latex'))
+    print("\nHTML:")
+    print(B.getEntry(key='Mulero-JPCRD-2012', fmt='html'))
+    print("\nMarkdown:")
+    print(B.getEntry(key='Mulero-JPCRD-2012', fmt='markdown'))
+    print("\nText:")
+    print(B.getEntry(key='Mulero-JPCRD-2012', fmt='plaintext'))
```

## CoolProp/CoolProp.pxd

```diff
@@ -1,42 +1,42 @@
-from libcpp.string cimport string
-import cython
-cimport cython
-
-from libcpp.vector cimport vector
-
-from .typedefs cimport *
-
-include "AbstractState.pxd"
-       
-cdef class State:
-    cdef AbstractState pAS
-    cdef readonly bytes Fluid, phase
-    cdef int iFluid,iParam1,iParam2,iOutput
-    cdef double T_, rho_, p_
-    
-    cpdef set_Fluid(self, string Fluid, string backend)
-    cpdef speed_test(self, int N)
-    cpdef update(self, dict params)
-    cpdef update_ph(self, double p, double h)
-    cpdef update_Trho(self, double T, double rho)
-    cpdef State copy(self)
-    cpdef double Props(self, constants_header.parameters iOutput) except *
-    cpdef long Phase(self) except *
-    cpdef double get_Q(self) except *
-    cpdef double get_T(self) except *
-    cpdef double get_p(self) except *
-    cpdef double get_h(self) except *
-    cpdef double get_rho(self) except *
-    cpdef double get_s(self) except *
-    cpdef double get_u(self) except *
-    cpdef double get_visc(self) except *
-    cpdef double get_cond(self) except *
-    cpdef double get_cp(self) except *
-    cpdef double get_cp0(self) except *
-    cpdef double get_cv(self) except *
-    cpdef double get_MM(self) except *
-    cpdef double get_dpdT(self) except *
-    cpdef double get_speed_sound(self) except *
-    cpdef get_Tsat(self, double Q = *)
-    cpdef get_subcooling(self)
-    cpdef get_superheat(self)
+from libcpp.string cimport string
+import cython
+cimport cython
+
+from libcpp.vector cimport vector
+
+from .typedefs cimport *
+
+include "AbstractState.pxd"
+       
+cdef class State:
+    cdef public AbstractState pAS
+    cdef readonly bytes Fluid, phase
+    cdef int iFluid,iParam1,iParam2,iOutput
+    cdef double T_, rho_, p_
+    
+    cpdef set_Fluid(self, string Fluid, string backend)
+    cpdef speed_test(self, int N)
+    cpdef update(self, dict params)
+    cpdef update_ph(self, double p, double h)
+    cpdef update_Trho(self, double T, double rho)
+    cpdef State copy(self)
+    cpdef double Props(self, constants_header.parameters iOutput) except *
+    cpdef long Phase(self) except *
+    cpdef double get_Q(self) except *
+    cpdef double get_T(self) except *
+    cpdef double get_p(self) except *
+    cpdef double get_h(self) except *
+    cpdef double get_rho(self) except *
+    cpdef double get_s(self) except *
+    cpdef double get_u(self) except *
+    cpdef double get_visc(self) except *
+    cpdef double get_cond(self) except *
+    cpdef double get_cp(self) except *
+    cpdef double get_cp0(self) except *
+    cpdef double get_cv(self) except *
+    cpdef double get_MM(self) except *
+    cpdef double get_dpdT(self) except *
+    cpdef double get_speed_sound(self) except *
+    cpdef get_Tsat(self, double Q = *)
+    cpdef get_subcooling(self)
+    cpdef get_superheat(self)
```

## CoolProp/CoolPropBibTeXLibrary.bib

```diff
@@ -1,3261 +1,3281 @@
-% Encoding: US-ASCII
-
-@Book{Cengel2007,
-  Title                    = {{Thermodynamics, An Engineering Approach}},
-  Author                   = {Yunus A. \c{C}engel and Michael A. Boles},
-  Publisher                = {McGraw-Hill},
-  Year                     = {2007},
-
-  Address                  = {New York},
-  Edition                  = {6th edition},
-
-  Owner                    = {jowr},
-  Timestamp                = {2014.12.16}
-}
-
-@Article{Abramson-HPR-2011,
-  Title                    = {{Melting curves of argon and methane}},
-  Author                   = {Evan H. Abramson},
-  Journal                  = {High Pressure Research},
-  Year                     = {2011},
-  Number                   = {4},
-  Pages                    = {549-554},
-  Volume                   = {31},
-
-  Doi                      = {10.1080/08957959.2011.629617},
-  Owner                    = {Belli},
-  Timestamp                = {2014.06.09}
-}
-
-@Article{Akasaka-JCED-2019,
-  Title                    = {{New Fundamental Equations of State for cis-1,3,3,3-Tetrafluoropropene [R-1234ze(Z)] and 3,3,3-Trifluoropropene (R-1243zf)}},
-  Author                   = {Ryo Akasaka and Eric Lemmon},
-  Journal                  = {J. Chem. Eng. Data},
-  Year                     = {2019, submitted},
-}
-
-@InProceedings{Akasaka-Purdue-2014,
-  Title                    = {{A Thermodynamic Property Model for the R-134a/245fa Mixtures}},
-  Author                   = {Ryo Akasaka},
-  Booktitle                = {15th International Refrigeration and Air Conditioning Conference at Purdue, July 14-17, 2014},
-  Year                     = {2014},
-
-  Owner                    = {Belli},
-  Timestamp                = {2014.09.27}
-}
-
-@Article{Akasaka-FPE-2013,
-  Title                    = {{Thermodynamic property models for the difluoromethane (R-32) + trans-1,3,3,3-tetrafluoropropene (R-1234ze(E)) and difluoromethane + 2,3,3,3-tetrafluoropropene (R-1234yf) mixtures}},
-  Author                   = {Ryo Akasaka},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {2013},
-  Pages                    = {98-104},
-  Volume                   = {358},
-
-  Doi                      = {10.1016/j.fluid.2013.07.057},
-  Owner                    = {Belli},
-  Timestamp                = {2014.09.27}
-}
-
-@Article{Akasaka-2008,
-  Title                    = {{A Reliable and Useful Method to Determine the Saturation State from Helmholtz Energy Equations of State}},
-  Author                   = {Ryo Akasaka},
-  Journal                  = {Journal of Thermal Science and Technology},
-  Year                     = {2008},
-  Pages                    = {442-451},
-  Volume                   = {3},
-
-  Doi                      = {10.1299/jtst.3.442},
-  Owner                    = {Belli},
-  Timestamp                = {2013.03.19}
-}
-
-@InProceedings{Akasaka-PU-2014,
-  Title                    = {{A Thermodynamic Property Model for the R-134a/245fa Mixtures}},
-  Author                   = {Ryo Akasaka and Yukihiro Higashi},
-  Booktitle                = {15 th International Refrigeration and Air Conditioning Conference at Purdue, July 14-17, 2014},
-  Year                     = {2014},
-
-  Owner                    = {Belli},
-  Timestamp                = {2014.07.22}
-}
-
-@InProceedings{Akasaka-DELFT-2013,
-  Title                    = {{A Fundamental Equation of State For Low-GWP Refrigerant HFO-1234ze(Z)}},
-  Author                   = {Ryo Akasaka and Yukihiro Higashi and Shigeru Koyama},
-  Booktitle                = {4th IIR Conference on ThermophysicalProperties and Transfer Processes of Refrigerants, Delft, The Netherlands, 2013},
-  Year                     = {2013},
-  Pages                    = {TP-052},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.08.05}
-}
-
-@Article{Akasaka-IJR-2012,
-  Title                    = {{A fundamental equation of state for trifluoromethyl methyl ether (HFE-143m) and its application to refrigeration cycle analysis}},
-  Author                   = {Ryo Akasaka and Yohei Kayukawa},
-  Journal                  = {Int. J. Refrig.},
-  Year                     = {2012},
-  Pages                    = {1003-1013},
-  Volume                   = {35},
-
-  Doi                      = {10.1016/j.ijrefrig.2012.01.003},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.10}
-}
-
-@Article{Akasaka-JPCRD-2015-R245fa,
-  Title                    = {{A Fundamental Equation of State for 1,1,1,3,3-Pentafluoropropane (R-245fa)}},
-  Author                   = {Ryo Akasaka and Yong Zhou and Eric W. Lemmon},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2015},
-  Pages                    = {013104},
-  Volume                   = {44},
-
-  Doi                      = {10.1063/1.4913493},
-  Owner                    = {Belli},
-  Timestamp                = {2014.08.09}
-}
-
-@Article{Aleksandrov-TE-2011,
-  Title                    = {{Using Fundamental Equations of State for Calculating the Thermodynamic Properties of Normal Undecane}},
-  Author                   = {I. S. Aleksandrov and A. A. Gerasimov and B. A. Grigor'ev},
-  Journal                  = {Thermal Engineering},
-  Year                     = {2011},
-  Number                   = {8},
-  Pages                    = {691-698},
-  Volume                   = {58},
-
-  Doi                      = {10.1134/S0040601511080027},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.11}
-}
-
-@Article{Allal-PRE-2001,
-  Title                    = {{Free-volume viscosity model for fluids in the dense and gaseous states}},
-  Author                   = {A. Allal and C. Boned and A. Baylaucq},
-  Journal                  = {Physical Review E},
-  Year                     = {2001},
-  Pages                    = {011203-1:10},
-  Volume                   = {64},
-
-  Doi                      = {10.1103/PhysRevE.64.011203},
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.07}
-}
-
-@Article{Aly-FPE-1981,
-  Title                    = {{Self-Consistent Equations for Calculating the Ideal Gas Specific Heat Capacity, Enthalpy, and Entropy}},
-  Author                   = {Fouad A. Aly and Lloyd L. Lee},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {1981},
-  Pages                    = {169-179},
-  Volume                   = {6},
-
-  Doi                      = {10.1016/0378-3812(81)85002-9},
-  Owner                    = {Belli},
-  Timestamp                = {2013.08.05}
-}
-
-@Book{ASHRAE2001,
-  Title                    = {{2001 ASHRAE Handbook: Fundamentals}},
-  Author                   = {{American Society of Heating, Refrigerating and Air-Conditioning Engineers}},
-  Publisher                = {{ASHRAE}},
-  Year                     = {2001},
-  Volume                   = {111},
-
-  ISBN                     = {9781883413880},
-  Owner                    = {jowr},
-  Timestamp                = {2014.09.17}
-}
-
-@TechReport{Arp-NIST-1998,
-  Title                    = {{Thermophysical Properties of Helium-4 from 0.8 to 1500 K with Pressures to 2000 MPa - NIST Technical Note 1334 (revised)}},
-  Author                   = {V.D. Arp and R.D. McCarty and D.G Friend},
-  Institution              = {NIST},
-  Year                     = {1998},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.08.05}
-}
-
-@Article{Assael-JPCRD-2012-Benzene,
-  Title                    = {{Reference Correlation of the Thermal Conductivity of Benzene from the Triple Point to 725 K and up to 500 MPa}},
-  Author                   = {M.J. Assael and E. Mihailidou and M.L. Huber and R.A. Perkins},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2012},
-  Pages                    = {043102-1:9},
-  Volume                   = {41},
-
-  Doi                      = {10.1063/1.4755781},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.10}
-}
-
-@Article{Assael-JPCRD-2011-Hydrogen,
-  Title                    = {{Correlation of the Thermal Conductivity of Normal and Parahydrogen from the Triple Point to 1000 K and up to 100 MPa}},
-  Author                   = {M. J. Assael and J.-A. M. Assael and M. L. Huber and R. A. Perkins and Y. Takata},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2011},
-  Number                   = {3},
-  Pages                    = {033101-1:13},
-  Volume                   = {40},
-
-  Doi                      = {10.1063/1.3606499},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.09}
-}
-
-@Article{Assael-JPCRD-2013-Heptane,
-  Title                    = {{Reference Correlation of the Thermal Conductivity of n-Heptane from the Triple Point to 600 K and up to 250 MPa}},
-  Author                   = {M. J. Assael and I. Bogdanou and S. K. Mylona and M. L. Huber and R. A. Perkins and V. Vesovic},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2013},
-  Number                   = {2},
-  Pages                    = {023101-1:9},
-  Volume                   = {42},
-
-  Doi                      = {10.1063/1.4794091},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.28}
-}
-
-@Article{Assael-JPCRD-2012-SF6,
-  author    = {M. J. Assael and I. A. Koini and K. D. Antoniadis and M. L. Huber and I. M. Abdulagatov and R. A. Perkins},
-  title     = {{Reference Correlation of the Thermal Conductivity of Sulfur Hexafluoride from the Triple Point to 1000 K and up to 150 MPa}},
-  journal   = {J. Phys. Chem. Ref. Data},
-  year      = {2012},
-  volume    = {41},
-  number    = {2},
-  pages     = {023104-1:9},
-  comment   = {Errata: To get the correct values in REFPROP for the residual part they use a molar reducing density of 5.046 mol/L or 5046*0.1460554192 = 736.9956452832 kg/m^3},
-  doi       = {10.1063/1.4708620},
-  owner     = {Belli},
-  timestamp = {2013.04.08},
-}
-
-@Article{Assael-JPCRD-2012-Toluene,
-  Title                    = {{Reference Correlation of the Thermal Conductivity of Toluene from the Triple Point to 1000 K and up to 1000 MPa}},
-  Author                   = {M. J. Assael and S. K. Mylona and M. L. Huber and R. A. Perkins},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2012},
-  Number                   = {2},
-  Pages                    = {023101-1:12},
-  Volume                   = {41},
-
-  Doi                      = {10.1063/1.3700155},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.10}
-}
-
-@Article{Assael-JPCRD-2013-Hexane,
-  Title                    = {{Reference Correlation of the Thermal Conductivity of n-Hexane from the Triple Point to 600 K and up to 500 MPa}},
-  Author                   = {M. J. Assael and S. K. Mylona and Ch. A. Tsiglifisi and M. L. Huber and R. A. Perkins},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2013},
-  Number                   = {1},
-  Pages                    = {013106-1:8},
-  Volume                   = {42},
-
-  Doi                      = {10.1063/1.4793335},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.28}
-}
-
-@Article{Assael-JPCRD-2013-Ethanol,
-  Title                    = {{Reference Correlation of the Thermal Conductivity of Ethanol from the Triple Point to 600 K and up to 245 MPa}},
-  Author                   = {M. J. Assael and E. A. Sykioti and M. L. Huber and R. A. Perkins},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2013},
-  Number                   = {2},
-  Pages                    = {023102-1:10},
-  Volume                   = {42},
-
-  Doi                      = {10.1063/1.4797368},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.28}
-}
-
-@Article{Avgeri-JPCRD-2015-Toluene,
-  Title                    = {{Reference Correlation of the Viscosity of Toluene from the Triple Point to 675 K and up to 500 MPa}},
-  Author                   = {S. Avgeri and M. J. Assael and M. L. Huber and R. A. Perkins},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2015},
-  Pages                    = {033101},
-  Volume                   = {44},
-
-  Doi                      = {10.1063/1.4926955},
-  Owner                    = {Belli},
-  Timestamp                = {2015.08.21}
-}
-
-@Article{Avgeri-JPCRD-2014-Benzene,
-  Title                    = {{Reference Correlation of the Viscosity of Benzene from the Triple Point to 675 K and up to 300 MPa}},
-  Author                   = {S. Avgeri and M. J. Assael and M. L. Huber and R. A. Perkins},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2014},
-  Pages                    = {033103},
-  Volume                   = {43},
-
-  Doi                      = {10.1063/1.4892935},
-  Owner                    = {Belli},
-  Timestamp                = {2014.09.02}
-}
-
-@Article{Balogun-JPCRD-2015-pxylene,
-  Title                    = {{Reference Correlation of the Viscosity of para-Xylene from the Triple Point to 673 K and up to 110 MPa}},
-  Author                   = {B. Balogun and N. Riesco and V. Vesovic},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2015},
-  Pages                    = {013103},
-  Volume                   = {44},
-
-  Doi                      = {10.1063/1.4908048},
-  Owner                    = {Belli},
-  Timestamp                = {2016.07.03}
-}
-
-@Article{Barreiros-JCT-1982,
-  Title                    = {{The Melting Curves of Carbon Monoxide}},
-  Author                   = {Susane F. Barreiros and Jorge C. G. Calado and Manuel Nunes da Ponte},
-  Journal                  = {J. Chem. Thermodyn.},
-  Year                     = {1982},
-  Pages                    = {1197-1198},
-  Volume                   = {14},
-
-  Doi                      = {10.1016/0021-9614(82)90044-1},
-  Owner                    = {Belli},
-  Timestamp                = {2014.10.02}
-}
-
-@InProceedings{Bell-PURDUE-2016-ETA,
-  Title                    = {{Viscosity of refrigerants and other working fluids from residual entropy scaling }},
-  Author                   = {Ian H. Bell and Arno Laesecke},
-  Booktitle                = {16th International Refrigeration and Air Conditioning Conference at Purdue, July 11-14, 2016},
-  Year                     = {2016}
-}
-
-@Article{Bell-JCED-2016,
-  Title                    = {{Automatic fitting of binary interaction parameters for multi-fluid Helmholtz-energy-explicit mixture models}},
-  Author                   = {Bell, Ian H. and Lemmon, Eric W.},
-  Journal                  = {J. Chem. Eng. Data},
-  Volume                   = {61},
-  Doi                      = {10.1021/acs.jced.6b00257},
-  Year                     = {2016}
-}
-
-@Article{Bell-JRN-2016,
-  Title                    = {{Helmholtz Energy Transformations of Common Cubic Equations of State for Use with Pure Fluids and Mixtures}},
-  Author                   = {Ian H. Bell and Andreas J{\"a}ger},
-  Journal                  = {J. Res. NIST},
-  Volume                   = {121},
-  Doi                      = {10.6028/jres.121.011},
-  Year                     = {2016}
-}
-
-@Article{Bell-IECR-2014,
-  Title                    = {{Pure and Pseudo-pure Fluid Thermophysical Property Evaluation and the Open-Source Thermophysical Property Library CoolProp}},
-  Author                   = {Bell, Ian H. and Wronski, Jorrit and Quoilin, Sylvain and Lemort, Vincent},
-  Journal                  = {Ind. Eng. Chem. Res.},
-  Year                     = {2014},
-  Number                   = {6},
-  Pages                    = {2498-2508},
-  Volume                   = {53},
-
-  Doi                      = {10.1021/ie4033999},
-  Eprint                   = {http://pubs.acs.org/doi/pdf/10.1021/ie4033999}
-}
-
-@Conference{Bender-1970,
-  Title                    = {{Equations of state exactly representing the phase behavior of pure substances}},
-  Author                   = {E. Bender},
-  Booktitle                = {Proc. 5th Symp. Thermophys. Prop.},
-  Year                     = {1970},
-  Pages                    = {227-235},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.05.04}
-}
-
-@Article{Boned-2003,
-  Title                    = {{High-pressure dynamic viscosity and density of two synthetic hydrocarbon mixtures representative of some heavy petroleum distillation cuts}},
-  Author                   = {C. Boned and C.K. Z{\'e}berg-Mikkelsen and A. Baylaucq and P. Daug{\'e}},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {2003},
-  Pages                    = {143-164},
-  Volume                   = {212},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.03}
-}
-
-@InBook{Brent-1973,
-  Title                    = {{Algorithms for Minimization without Derivatives}},
-  Author                   = {R.P. Brent},
-  Chapter                  = {4},
-  Publisher                = {Prentice-Hall},
-  Year                     = {1973},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.23}
-}
-
-@Article{Buecker-JPCRD-2006,
-  Title                    = {{A Reference Equation of State for the Thermodynamic Properties of Ethane for Temperatures from the Melting Line to 675 K and Pressures up to 900 MPa}},
-  Author                   = {D. Buecker and W. Wagner},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2006},
-  Number                   = {1},
-  Pages                    = {205-266},
-  Volume                   = {35},
-
-  Doi                      = {10.1063/1.1859286},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Buecker-JPCRD-2006B,
-  Title                    = {{Reference Equations of State for the Thermodynamic Properties of Fluid Phase n-Butane and Isobutane}},
-  Author                   = {D. Buecker and W. Wagner},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2006},
-  Number                   = {2},
-  Pages                    = {929-1019},
-  Volume                   = {35},
-
-  Doi                      = {10.1063/1.1901687},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.30}
-}
-
-@Article{Cao-JPCRD-2016-mxylene,
-  Title                    = {{Reference Correlation of the Viscosity of meta-Xylene from 273 to 673 K and up to 200 MPa}},
-  Author                   = {F. L. Cao and X. Y. Meng and J. T. Wu and V. Vesovic},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2016},
-  Pages                    = {013103},
-  Volume                   = {45},
-
-  Doi                      = {10.1063/1.4941241},
-  Owner                    = {Belli},
-  Timestamp                = {2016.07.03}
-}
-
-@Article{Cao-JPCRD-2016-oxylene,
-  Title                    = {{Reference Correlation of the Viscosity of ortho-Xylene from 273 to 673 K and up to 110 MPa}},
-  Author                   = {F. L. Cao and X. Y. Meng and J. T. Wu and V. Vesovic},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2016},
-  Pages                    = {023102},
-  Volume                   = {45},
-
-  Doi                      = {10.1063/1.4945663},
-  Owner                    = {Belli},
-  Timestamp                = {2016.07.03}
-}
-
-@Conference{Casella-2008,
-  Title                    = {{ExternalMedia: A Library for Easy Re-Use of External Fluid Property Code in Modelica}},
-  Author                   = {Francesco Casella and Christoph Richter},
-  Booktitle                = {Modelica 2008, March 3rd-4th, 2008},
-  Year                     = {2008},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.03.28}
-}
-
-@TechReport{Chichester-NIST-2008,
-  Title                    = {{NISTIR 6650: Documentation and Assessment of the Transport Property Model for Mixtures Implemented in NIST REFPROP (Version 8.0)}},
-  Author                   = {Justin C. Chichester and Marcia L. Huber},
-  Institution              = {National Institute of Standards and Technology (NIST)},
-  Year                     = {June 2008},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Chung-IECR-1988,
-  Title                    = {{Generalized multiparameter correlation for nonpolar and polar fluid transport properties}},
-  Author                   = {Chung, Ting Horng and Ajlan, Mohammad and Lee, Lloyd L and Starling, Kenneth E},
-  Journal                  = {Ind. Eng. Chem. Res.},
-  Year                     = {1988},
-  Number                   = {4},
-  Pages                    = {671--679},
-  Volume                   = {27},
-
-  Doi                      = {10.1021/ie00076a024},
-  Publisher                = {ACS Publications}
-}
-
-@Article{Colonna-FPE-2008,
-  Title                    = {{Multiparameter equations of state for siloxanes: [(CH3)3-Si-O1/2]2-[O-Si-(CH3)2]i=1,...,3, and [O-Si-(CH3)2]6}},
-  Author                   = {P. Colonna and N.R. Nannan and A. Guardone},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {2008},
-  Pages                    = {115-130},
-  Volume                   = {263},
-
-  Doi                      = {10.1016/j.fluid.2007.10.001},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Colonna-FPE-2006,
-  Title                    = {{Multiparameter equations of state for selected siloxanes}},
-  Author                   = {P. Colonna and N.R. Nannan and A. Guardone and E.W. Lemmon},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {2006},
-  Pages                    = {193-211},
-  Volume                   = {244},
-
-  Doi                      = {10.1016/j.fluid.2006.04.015},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Datchi-PRB-2000,
-  Title                    = {{Extended and accurate determination of the melting curves of argon, helium, ice (H$_2$O) and hydrogen (H$_2$)}},
-  Author                   = {Fr{\'e}d{\'e}ric Datchi and Paul Loubeyre and Ren{\'e} LeToullec},
-  Journal                  = {Physical Review B},
-  Year                     = {2000},
-  Number                   = {10},
-  Pages                    = {6535-6546},
-  Volume                   = {61},
-
-  Doi                      = {10.1103/PhysRevB.61.6535},
-  Owner                    = {Belli},
-  Timestamp                = {2014.10.02}
-}
-
-@Misc{Therminol2007,
-  Title                    = {{Therminol Heat Transfer Reference Disk, Version 5.0}},
-
-  Author                   = {{Eastman Chemical Company}}
-}
-
-@Article{EstellaUribe-2003,
-  Title                    = {{Extended corresponding states model for fluids and fluid mixtures I. Shape factor model for pure fluids}},
-  Author                   = {J.F. Estela-Uribe and J.P.M. Trusler},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {2003},
-  Pages                    = {15-40},
-  Volume                   = {204},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.05.29}
-}
-
-@Article{Fenghour-JPCRD-1998,
-  author    = {A. Fenghour and W.A. Wakeham and V. Vesovic},
-  title     = {{The Viscosity of Carbon Dioxide}},
-  journal   = {J. Phys. Chem. Ref. Data},
-  year      = {1998},
-  volume    = {27},
-  number    = {1},
-  pages     = {31-44},
-  note      = {5},
-  comment   = {Units of density in paper are mol/L, poorly documented},
-  doi       = {10.1063/1.556013},
-  owner     = {Belli},
-  timestamp = {2013.04.08},
-}
-
-@Article{Fenghour-JPCRD-1995,
-  author    = {A. Fenghour and W.A. Wakeham and V. Vesovic and J.T.R. Watson and J. Millat and E. Vogel},
-  title     = {{The Viscosity of Ammonia}},
-  journal   = {J. Phys. Chem. Ref. Data},
-  year      = {1995},
-  volume    = {24},
-  pages     = {1649-1667},
-  note      = {5},
-  comment   = {Units of density in paper are mol/L, poorly documented},
-  doi       = {10.1063/1.555961},
-  owner     = {Belli},
-  timestamp = {2013.04.08},
-}
-
-@Article{Froeba-2000,
-  Title                    = {{Saturated Liquid Viscosity and Surface Tension of Alternative Refrigerants}},
-  Author                   = {A.P. Fr\"{o}ba and S. Will and A. Leipertz},
-  Journal                  = {Int. J. Thermophys.},
-  Year                     = {2000},
-  Note                     = {10.1023/A:1006689724974},
-  Pages                    = {1225-1253},
-  Volume                   = {21},
-
-  Doi                      = {10.1023/A:1006689724974},
-  ISSN                     = {0195-928X},
-  Issue                    = {6},
-  Keyword                  = {Physics and Astronomy},
-  Owner                    = {ibell},
-  Publisher                = {Springer Netherlands},
-  Timestamp                = {2011.04.17}
-}
-
-@Article{Friend-JPCRD-1989,
-  Title                    = {{Thermophysical Properties of Methane}},
-  Author                   = {Daniel G. Friend and James F. Ely and Hepburn Ingham},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {1989},
-  Volume                   = {18},
-
-  Doi                      = {10.1063/1.555828},
-  Owner                    = {Belli},
-  Timestamp                = {2015.04.27}
-}
-
-@Article{Friend-JPCRD-1991,
-  Title                    = {{Thermophysical Properties of Ethane}},
-  Author                   = {Daniel G. Friend and Hepburn Ingham and James F. Ely},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {1991},
-  Number                   = {2},
-  Pages                    = {275-347},
-  Volume                   = {20},
-
-  Doi                      = {10.1063/1.555881},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Fuchs-IECR-2006,
-	Title = {{Solubility of Amino Acids: Influence of the pH value and the Addition of Alcoholic Cosolvents on Aqueous Solubility}},
-	Volume = {45},
-	Url = {https://doi.org/10.1021/ie0602097},
-	Doi = {10.1021/ie0602097},
-	Number = {19},
-	Journal = {Industrial \& Engineering Chemistry Research},
-	Author = {Fuchs, Dominik and Fischer, Jan and Tumakaka, Feelly and Sadowski, Gabriele},
-	Month = {sep},
-	Year = {2006},
-	Pages = {6578--6584},
-}
-
-@Article{Gao-JCED-2016,
-  Title                    = {{A Helmholtz Energy Equation of State for Sulfur Dioxide}},
-  Author                   = {Kehui Gao and Jiangtao Wu and Penggang Zhang and Eric W. Lemmon},
-  Journal                  = {J. Chem. Eng. Data},
-  Year                     = {2016},
-
-  Owner                    = {Belli},
-  Timestamp                = {2016.01.15}
-}
-
-@Article{Gao-JPCRD-2020,
-  Title                    = {{Thermodynamic Properties of Ammonia for Temperatures from the Melting Line to 725 K and Pressures to 1000 MPa}},
-  Author                   = {K. Gao and J. Wu and I. H. Bell and E. W. Lemmon},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2020},
-}
-
-@Article{Gedanitz-JCED-2015,
-  Title                    = {{Speed of sound measurements and a fundamental equation of state for cyclopentane}},
-  Author                   = {Holger Gedanitz and Mar{\'i}a J. D{\'a}vila and Eric W. Lemmon},
-  Journal                  = {J. Chem. Eng. Data},
-  Year                     = {2015},
-  Number                   = {5},
-  Pages                    = {1331-1337},
-  Volume                   = {60},
-
-  Doi                      = {10.1021/je5010164},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.10}
-}
-
-@InProceedings{Geller-PURDUE-2000,
-  Title                    = {{Viscosity of Mixed Refrigerants R404A, R407C, R410A, and R507A}},
-  Author                   = {V. Geller},
-  Booktitle                = {2000 International Refrigeration Conferences at Purdue University},
-  Year                     = {2000},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Geller-IJT-2001,
-  Title                    = {{Thermal Conductivity of the Refrigerant mixtures R404A, R407C, R410A, and R507A}},
-  Author                   = {V.Z. Geller and B.Z. Nemzer and U.V. Cheremnykh},
-  Journal                  = {Int. J. Thermophys.},
-  Year                     = {2001},
-  Pages                    = {1034-1043},
-  Volume                   = {22},
-
-  Doi                      = {10.1023/A:1010691504352},
-  Owner                    = {ibell},
-  Timestamp                = {2010.06.30}
-}
-
-@PhdThesis{Gernert-Thesis-2013,
-  Title                    = {{A New Helmholtz Energy Model for Humid Gases and CCS Mixtures}},
-  Author                   = {Georg Johannes Gernert},
-  School                   = {Ruhr-Universit{\"a}t Bochum},
-  Year                     = {2013},
-
-  Owner                    = {Belli},
-  Timestamp                = {2014.09.27}
-}
-
-@Article{Gernert-FPE-2014,
-  Title                    = {{Calculation of phase equilibria for multi-component mixtures using highly accurate Helmholtz energy equations of state}},
-  Author                   = {Johannes Gernert and Andreas J{\"a}ger and Roland Span},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {2014},
-  Pages                    = {209-218},
-  Volume                   = {375},
-
-  Doi                      = {10.1016/j.fluid.2014.05.012},
-  Owner                    = {Belli},
-  Timestamp                = {2014.07.21}
-}
-
-@Article{Gernert-JCT-2015,
-  Title                    = {{EOS-CG: A Helmholtz energy mixture model for humid gases and CCS mixtures}},
-  Author                   = {Gernert, Johannes and Span, Roland},
-  Journal                  = {J. Chem. Thermodyn.},
-  Year                     = {2016},
-  Pages                    = {274--293},
-  Volume                   = {93},
-
-  Doi                      = {10.1016/j.jct.2015.05.015},
-  Publisher                = {Elsevier}
-}
-
-@Article{Ghosh-FPE-2003,
-	Title = {Gas solubility in hydrocarbons-a SAFT-based approach},
-	Volume = {209},
-	Url = {https://www.sciencedirect.com/science/article/pii/S037838120300147X},
-	Doi = {10.1016/S0378-3812(03)00147-X},
-	Number = {2},
-	Journal = {Fluid Phase Equilibria},
-	Author = {Ghosh, Auleen and Chapman, Walter G and French, Ray N},
-	Month = jul,
-	Year = {2003},
-	Pages = {229--243},
-}
-
-@Article{Gross-IECR-2001,
-	Title = {{Perturbed-Chain SAFT:  An Equation of State Based on a Perturbation Theory for Chain Molecules}},
-	Volume = {40},
-	Url = {https://doi.org/10.1021/ie0003887},
-	Doi = {10.1021/ie0003887},
-	Number = {4},
-	Journal = {Industrial \& Engineering Chemistry Research},
-	Author = {Gross, Joachim and Sadowski, Gabriele},
-	Month = {feb},
-	Year = {2001},
-	Pages = {1244--1260},
-}
-
-@Article{Gross-IECR-2002,
-	Title = {{Application of the Perturbed-Chain SAFT Equation of State to Associating Systems}},
-	Volume = {41},
-	Url = {https://doi.org/10.1021/ie010954d},
-	Doi = {10.1021/ie010954d},
-	Number = {22},
-	Journal = {Industrial \& Engineering Chemistry Research},
-	Author = {Gross, Joachim and Sadowski, Gabriele},
-	Month = {oct},
-	year = {2002},
-	pages = {5510--5515},
-}
-
-@Article{Guder-JPCRD-2009,
-  Title                    = {{A Reference Equation of State for the Thermodynamic Properties of Sulfur Hexafluoride SF6 for Temperatures from the Melting Line to 625 K and Pressures up to 150 MPa}},
-  Author                   = {C. Guder and W. Wagner},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2009},
-  Number                   = {1},
-  Pages                    = {33-94},
-  Volume                   = {38},
-
-  Doi                      = {10.1063/1.3037344},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Guo-1997,
-  Title                    = {{Viscosity model based on equations of state for hydrocarbon liquids and gases}},
-  Author                   = {X.-Q. Guo and L.-S. Wang and S.-X. Rong and T.-M. Guo},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {1997},
-  Pages                    = {405-421},
-  Volume                   = {139},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.03}
-}
-
-@Article{Hands-CRYO-1981,
-  Title                    = {{A Correlation of Thermal Conductivity Data for Helium}},
-  Author                   = {B.A. Hands and V.D. Arp},
-  Journal                  = {Cryogenics},
-  Year                     = {1981},
-  Number                   = {12},
-  Pages                    = {697-703},
-  Volume                   = {21},
-
-  Doi                      = {10.1016/0011-2275(81)90211-3},
-  Owner                    = {Belli},
-  Timestamp                = {2013.08.05}
-}
-
-@Article{Heide-IJR-1997,
-  Title                    = {{The surface tension of HFC refrigerants and mixtures}},
-  Author                   = {R. Heide},
-  Journal                  = {Int. J. Refrig.},
-  Year                     = {1997},
-  Pages                    = {496-503},
-  Volume                   = {20},
-
-  Doi                      = {10.1016/S0140-7007(97)00044-3},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Held-CERD-2014,
-	Title = {{ePC-SAFT revised}},
-	Volume = {92},
-	Url = {https://www.sciencedirect.com/science/article/pii/S0263876214002469},
-	Doi = {10.1016/j.cherd.2014.05.017},
-	Number = {12},
-	Journal = {Chemical Engineering Research and Design},
-	Author = {Held, Christoph and Reschke, Thomas and Mohammad, Sultan and Luza, Armando and Sadowski, Gabriele},
-	Month = {dec},
-	Year = {2014},
-	Pages = {2884--2897},
-}
-
-@Article{Herrig-JPCRD-2019,
-  Title                    = {{A Reference Equation of State for Heavy Water}},
-  Author                   = {S. Herrig and M. Thol and R. Span and A.H. Harvey and E.W. Lemmon},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2019},
-}
-
-@TechReport{Herrmann-2009,
-  Title                    = {ASHRAE RP-1485: Thermodynamic Properties of Real Moist Air, Dry Air, Steam, Water, and Ice},
-  Author                   = {S. Herrmann and H.-J. Kretzschmar and D.P. Gatley},
-  Institution              = {ASHRAE},
-  Year                     = {2009},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.05.29}
-}
-
-@Article{Herrmann2009,
-  Title                    = {{Thermodynamic Properties of Real Moist Air, Dry Air, Steam, Water, and Ice (RP-1485)}},
-  Author                   = {Herrmann, Sebastian and Kretzschmar, Hans-Joachim and Gatley, Donald P.},
-  Journal                  = {{HVAC\&R Research}},
-  Year                     = {2009},
-  Number                   = {5},
-  Pages                    = {961--986},
-  Volume                   = {15},
-
-  Doi                      = {10.1080/10789669.2009.10390874},
-  Eprint                   = { http://www.tandfonline.com/doi/pdf/10.1080/10789669.2009.10390874 },
-  Owner                    = {jowr},
-  Timestamp                = {2014.10.09}
-}
-
-@Article{Holland-JPCRD-1983,
-  Title                    = {{A Correlation of the Viscosity and Thermal Conductivity Data of Gaseous and Liquid Ethylene}},
-  Author                   = {P.M. Holland and B.E. Eaton and H.J.M. Hanley},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {1983},
-  Number                   = {4},
-  Pages                    = {917-932},
-  Volume                   = {12},
-
-  Doi                      = {10.1063/1.555701},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@InBook{Huber-1996,
-  Title                    = {{The Corresponding-States Principle: Dense Fluids}},
-  Author                   = {M.L. Huber and H.J.M. Hanley},
-  Chapter                  = {12},
-  Editor                   = {Jurgen Millat and J.H. Dymond and C.A. Nieto de Castro},
-  Pages                    = {283-309},
-  Publisher                = {Cambridge University Press},
-  Year                     = {1996},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.05.29}
-}
-
-@Article{Huber-FPE-2005,
-  Title                    = {{Thermal conductivity correlations for minor constituent fluids in natural gas: n-octane, n-nonane and n-decane}},
-  Author                   = {M.L. Huber and R.A. Perkins},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {2005},
-  Pages                    = {47-55},
-  Volume                   = {227},
-
-  Doi                      = {10.1016/j.fluid.2004.10.031},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.14}
-}
-
-@Article{Huber-JPCRD-2009,
-  Title                    = {{New International Formulation for the Viscosity of H2O}},
-  Author                   = {M.L. Huber and R.A. Perkins and A. Laesecke and D.G. Friend and J.V. Sengers and M.J Assael and I.M. Metaxa and E. Vogel and R. Mare{\v s} and K. Miyagawa},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2009},
-  Number                   = {2},
-  Pages                    = {101-125},
-  Volume                   = {38},
-
-  Doi                      = {10.1063/1.3088050},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Huber-FPE-1992,
-  Title                    = {{Prediction of Viscosity of Refrigerants and Refrigerant Mixtures}},
-  Author                   = {Marcia L. Huber and James F. Ely},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {1992},
-  Pages                    = {239-248},
-  Volume                   = {80},
-
-  Doi                      = {10.1016/0378-3812(92)87071-T},
-  Owner                    = {Belli},
-  Timestamp                = {2013.05.29}
-}
-
-@Article{Huber-IECR-2006,
-  Title                    = {{Correlation for the Viscosity of Pentafluoroethane (R125) from the Triple Point to 500 K at Pressures up to 60 MPa}},
-  Author                   = {Marcia L. Huber and Arno Laesecke},
-  Journal                  = {Ind. Eng. Chem. Res.},
-  Year                     = {2006},
-  Pages                    = {4447-4453},
-  Volume                   = {45},
-
-  Doi                      = {10.1021/ie051367l},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.13}
-}
-
-@Article{Huber-EF-2004,
-  Title                    = {{Transport Properties of n-Dodecane}},
-  Author                   = {Marcia L. Huber and Arno Laesecke and Richard Perkins},
-  Journal                  = {Energy \& Fuels},
-  Year                     = {2004},
-  Pages                    = {968-975},
-  Volume                   = {18},
-
-  Doi                      = {10.1021/ef034109e},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.10}
-}
-
-@Article{Huber-IECR-2003,
-  Title                    = {{Model for the Viscosity and Thermal Conductivity of Refrigerants, Including a New Correlation for the Viscosity of R134a}},
-  Author                   = {Marcia L. Huber and Arno Laesecke and Richard A. Perkins},
-  Journal                  = {Ind. Eng. Chem. Res.},
-  Year                     = {2003},
-  Pages                    = {3163-3178},
-  Volume                   = {42},
-
-  Doi                      = {10.1021/ie0300880},
-  Owner                    = {ibell},
-  Timestamp                = {2010.07.06}
-}
-
-@Article{Huber-FPE-2004,
-  Title                    = {{Viscosity correlations for minor constituent fluids in natural gas: n-octane, n-nonane and n-decane}},
-  Author                   = {Marcia L. Huber and Arno Laesecke and Hong Wei Xiang},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {2004},
-  Pages                    = {263-270},
-  Volume                   = {224},
-
-  Doi                      = {10.1016/j.fluid.2004.07.012},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.14}
-}
-
-@Article{Huber-EF-2009,
-  Title                    = {{Model for the Thermodynamic Properties of a Biodiesel Fuel}},
-  Author                   = {Marcia L. Huber and Eric W. Lemmon and Andrei Kazakov and Lisa S. Ott and Thomas J. Bruno},
-  Journal                  = {Energy \& Fuels},
-  Year                     = {2009},
-  Pages                    = {3790-3797},
-  Volume                   = {23},
-
-  Doi                      = {10.1021/ef900159g},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Huber-JPCRD-2012,
-  Title                    = {{New International Formulation for the Thermal Conductivity of H2O}},
-  Author                   = {M. L. Huber and R. A. Perkins and D. G. Friend and J. V. Sengers and M. J. Assael and I. N. Metaxa and K. Miyagawa and R. Hellmann and E. Vogel},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2012},
-  Number                   = {3},
-  Pages                    = {033102-1:23},
-  Volume                   = {41},
-
-  Doi                      = {10.1063/1.4738955},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Misc{IAPWS-Melting-2011,
-  Title                    = {{2011 Revised Release on the Pressure along the Melting and Sublimation Curves of Ordinary Water Substance}},
-
-  Author                   = {IAPWS},
-  Year                     = {2011},
-
-  Institution              = {{IAPWS}},
-  Organization             = {{IAPWS}},
-  Owner                    = {Belli},
-  Timestamp                = {2014.10.02}
-}
-
-@Misc{IAPWS-D2O-2007-Transport,
-  Title                    = {Revised Release on Viscosity and Thermal Conductivity of Heavy Water Substance},
-
-  Author                   = {IAPWS},
-  Year                     = {2007},
-
-  Owner                    = {Belli},
-  Timestamp                = {2015.05.01}
-}
-
-@Misc{IAPWS-IF97-2012,
-  author = {IAPWS},
-  title  = {{Revised Release on the IAPWS Industrial Formulation 1997 for the Thermodynamic Properties of Water and Steam, revision 7}},
-  year   = {2012},
-}
-
-@Article{Jacobsen-FPE-1992,
-  Title                    = {{A Fundamental Equation for Trichlorofluoromethane (R-11)}},
-  Author                   = {R.T Jacobsen and S.G. Penoncello and E.W. Lemmon},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {1992},
-  Pages                    = {45-56},
-  Volume                   = {80},
-
-  Doi                      = {10.1016/0378-3812(92)87054-Q},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.10}
-}
-
-@Article{Jaeschke-IJT-1995,
-  Title                    = {{Ideal-Gas Thermodynamic Properties for Natural-Gas Applications}},
-  Author                   = {M. Jaeschke and P. Schley},
-  Journal                  = {Int. J. Thermophys.},
-  Year                     = {1995},
-  Number                   = {6},
-  Pages                    = {1381-1392},
-  Volume                   = {16},
-
-  Doi                      = {10.1007/BF02083547},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Manual{Jones2001,
-  Title                    = {{SciPy}: Open source scientific tools for {Python}},
-  Author                   = {Eric Jones and Travis Oliphant and Pearu Peterson and others},
-  Year                     = {2001--},
-
-  Owner                    = {jowr},
-  Timestamp                = {2014.09.24},
-  Url                      = {http://www.scipy.org/}
-}
-
-@Article{Kamei-IJT-1995,
-  Title                    = {{Application of Nonlinear Regression in the Development of a Wide Range Formulation for HCFC-22}},
-  Author                   = {A. Kamei and S. W. Beyerlein and R. T Jacobsen},
-  Journal                  = {Int. J. Thermophys.},
-  Year                     = {1995},
-  Number                   = {5},
-  Pages                    = {1155-1164},
-  Volume                   = {16},
-
-  Doi                      = {10.1007/BF02081283},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Katti-ACE-1986,
-  Title                    = {{Thermodynamic Properties of Neon for Temperatures from the Triple Point to 700 K at Pressures to 700 MPa}},
-  Author                   = {R. Katti and R.T. Jacobsen and R.B. Stewart and M. Jehangiri},
-  Journal                  = {Advances in Cryogenic Engineering},
-  Year                     = {1986},
-  Pages                    = {1189-1197},
-  Volume                   = {31},
-
-  Doi                      = {10.1007/978-1-4613-2213-9_132},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.30}
-}
-
-@TechReport{Kauffeld2001,
-  Title                    = {{RP-1166---Behavior of Ice Slurries in Thermal Storage Systems}},
-  Author                   = {Michael Kauffeld},
-  Institution              = {{Danish Technological Institute}},
-  Year                     = {2001},
-  Note                     = {{Sponsored by ASHRAE Technical Committee 6.9 Thermal Storage}},
-
-  Owner                    = {jowr},
-  Timestamp                = {2014.09.22}
-}
-
-@Article{Kim-IJR-2008,
-  Title                    = {{Cooling performance of several CO2/propane mixtures and glide matching with secondary heat transfer fluid}},
-  Author                   = {Ju Hyok Kim and Jin Min Cho and Min Soo Kim},
-  Journal                  = {Int. J. Refrig.},
-  Year                     = {2008},
-  Pages                    = {800-806},
-  Volume                   = {31},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.10}
-}
-
-@Article{Kiselev-1998,
-  Title                    = {{Transport properties of carbon dioxide+ethane and methane+ethane mixtures in the extended critical region}},
-  Author                   = {S.B. Kiselev and M.L. Huber},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {1998},
-  Pages                    = {253-280},
-  Volume                   = {142},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.03}
-}
-
-@Article{Kiselev-1999,
-  Title                    = {{Transport properties of refrigerants R32, R125, R134a, and R125+R32 mixtures in and beyond the critical region}},
-  Author                   = {S.B. Kiselev and R.A. Perkins and M.L. Huber},
-  Journal                  = {Int. J. Refrig.},
-  Year                     = {1999},
-  Pages                    = {509-520},
-  Volume                   = {22},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.03}
-}
-
-@Article{Kiselev-IECR-2005,
-  Title                    = {{Generalized SAFT-DFT/DMT Model for the Thermodynamic, Interfacial, and Transport Properties of Associating Fluids: Application for n-Alkanols}},
-  Author                   = {S. B. Kiselev and J. F. Ely and I. M. Abdulagatov and M. L. Huber},
-  Journal                  = {Ind. Eng. Chem. Res.},
-  Year                     = {2005},
-  Pages                    = {6916-6927},
-  Volume                   = {44},
-
-  Doi                      = {10.1021/ie050010e},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.14}
-}
-
-@Article{Kiselev-1997,
-  Title                    = {{Thermodynamic and Transport Properties of Fluids and Fluid Mixtures in the Extended Critical Region}},
-  Author                   = {S. B. Kiselev and V. D. Kulikov},
-  Journal                  = {lnternational Journal of Thermophysics},
-  Year                     = {1997},
-  Number                   = {5},
-  Pages                    = {1143-1182},
-  Volume                   = {18},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.03}
-}
-
-@Article{Klein-IJR-1997,
-  Title                    = {{An improved extended corresponding states method for estimation of viscosity of pure refrigerants and mixtures}},
-  Author                   = {S.A. Klein and M.O. McLinden and A. Laesecke},
-  Journal                  = {Int. J. Refrig.},
-  Year                     = {1997},
-  Pages                    = {208-217},
-  Volume                   = {20},
-
-  Doi                      = {10.1016/S0140-7007(96)00073-4},
-  Owner                    = {Belli},
-  Timestamp                = {2014.12.06}
-}
-
-@Article{Kleiner-JPCC-2007,
-	Title = {{Modeling of Polar Systems Using PCP-SAFT: An Approach to Account for Induced-Association Interactions}},
-	Volume = {111},
-	Url = {https://doi.org/10.1021/jp072640v},
-	Doi = {10.1021/jp072640v},
-	Number = {43},
-	Journal = {The Journal of Physical Chemistry C},
-	Author = {Kleiner, Matthias and Sadowski, Gabriele},
-	Month = {nov},
-	Year = {2007},
-	Pages = {15544--15553},
-}
-
-@Article{Kondou-IJR-2015,
-  Title                    = {{Surface tension of low GWP refrigerants R1243zf, R1234ze(Z), and R1233zd(E)}},
-  Author                   = {Chieko Kondou and Ryuichi Nagata and Noriko Nii and Shigeru Koyama and Yukihiro Higashi},
-  Journal                  = {Int. J. Refrig.},
-  Year                     = {2015},
-  Pages                    = {80-89},
-  Volume                   = {53},
-
-  Doi                      = {10.1016/j.ijrefrig.2015.01.005},
-  Owner                    = {Belli},
-  Timestamp                = {2015.07.20}
-}
-
-@Article{Kostic2006,
-  Title                    = {{Analysis of Enthalpy Approximation for Compressed Liquid Water}},
-  Author                   = {Milivoje M. Kostic},
-  Journal                  = {Journal of Heat Transfer},
-  Year                     = {2006},
-  Number                   = {5},
-  Pages                    = {421--426},
-  Volume                   = {128},
-
-  Doi                      = {10.1115/1.2175090},
-  Owner                    = {jowr},
-  Timestamp                = {2014.12.16}
-}
-
-@Article{Krauss-IJT-1996,
-  Title                    = {{Transport Properties of 1,1-Difluoroethane (R152a)}},
-  Author                   = {R. Krauss and I V. C. Weiss and T. A. Edison and J. V. Sengers and K. Stephan},
-  Journal                  = {Int. J. Thermophys},
-  Year                     = {1996},
-  Pages                    = {731-757},
-  Volume                   = {17},
-
-  Doi                      = {10.1007/BF01439187},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.28}
-}
-
-@Unpublished{ZITTAU,
-  Title                    = {{Hochschule Zittau Thermophysical Property Libraries}},
-  Author                   = {Hans-Joachim Kretzschmar and Ines St{\"o}cker},
-  Note                     = {http://thermodynamik.hs-zigr.de/cmsfg/Stoffwertbibliothek/index.php},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.08.05}
-}
-
-@InProceedings{Kretzschmar-PWS-1990,
-  Title                    = {{An Alternative Method for the Numerical Calculation of the Maxwell Criterion in Vapour Pressure Computations}},
-  Author                   = {H.-J. Kretzschmar and T. Zschunke and J. Klinger and A. Dittman},
-  Booktitle                = {Properties Of Water And Steam: Proceedings Of The 11th International conference},
-  Year                     = {1990},
-
-  Owner                    = {ihb},
-  Timestamp                = {2015.07.20}
-}
-
-@Book{Kunz-BOOK-2007,
-  Title                    = {{The GERG-2004 Wide-Range Equation of State for Natural Gases and Other Mixtures}},
-  Author                   = {O. Kunz and R. Klimeck and W. Wagner and M. Jaeschke},
-  Publisher                = {VDI Verlag GmbH, D{\"u}sseldorf},
-  Year                     = {2007},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.07}
-}
-
-@Article{Kunz-JCED-2012,
-  Title                    = {{The GERG-2008 Wide-Range Equation of State for Natural Gases and Other Mixtures: An Expansion of GERG-2004}},
-  Author                   = {O. Kunz and W. Wagner},
-  Journal                  = {J. Chem. Eng. Data},
-  Year                     = {2012},
-  Pages                    = {3032-3091},
-  Volume                   = {57},
-
-  Doi                      = {10.1021/je300655b},
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.07}
-}
-
-@Article{Laesecke-2001,
-  Title                    = {{Saturated-Liquid Viscosity of Ten Binary and Ternary Alternative Refrigerant Mixtures. Part I: Measurements}},
-  Author                   = {Arno Laesecke and Richard F. Hafer and Dylan J. Morris},
-  Journal                  = {J. Chem. Eng. Data},
-  Year                     = {2001},
-  Pages                    = {433-445},
-  Volume                   = {46},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.03}
-}
-
-@Article{Laesecke-IJR-1996,
-  Title                    = {{An improved correlation for the thermal conductivity of HCFC123 (2,2-dichloro-1,1,1-trifluoroethane)}},
-  Author                   = {Arno Laesecke and Richard A. Perkins and John B. Howley},
-  Journal                  = {Int. J. Refrig.},
-  Year                     = {1996},
-  Number                   = {4},
-  Pages                    = {231-238},
-  Volume                   = {19},
-
-  Doi                      = {10.1016/0140-7007(96)00019-9},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.13}
-}
-
-@Article{Latini-1999,
-  Title                    = {{A New Approach to the Evaluation of Transport Properties of Azeotropic and Quasi-Azeotropic Refrigerant Mixtures}},
-  Author                   = {G. Latini and G. Passerini and F. Polonara},
-  Journal                  = {Int. J. Thermophys},
-  Year                     = {1999},
-  Number                   = {1},
-  Pages                    = {73-84},
-  Volume                   = {20},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.03}
-}
-
-@Article{Leachman-JPCRD-2009,
-  Title                    = {{Fundamental Equations of State for Parahydrogen, Normal Hydrogen, and Orthohydrogen}},
-  Author                   = {J.W. Leachman and R.T. Jacobsen and S.G. Penoncello and E.W. Lemmon},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2009},
-  Number                   = {3},
-  Pages                    = {721-748},
-  Volume                   = {38},
-
-  Doi                      = {10.1063/1.3160306},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.09}
-}
-
-@Article{Lemmon-IJT-2003,
-  Title                    = {{Pseudo-Pure Fluid Equations of State for the Refrigerant Blends R-410A, R-404A, R-507A, and R-407C}},
-  Author                   = {E.W. Lemmon},
-  Journal                  = {Int. J. Thermophys.},
-  Year                     = {2003},
-  Number                   = {4},
-  Pages                    = {991-1006},
-  Volume                   = {24},
-
-  Doi                      = {10.1023/A:1025048800563},
-  File                     = {:D\:\\My_Documents\\Library\\Papers\\Lemmon 2003.pdf:PDF},
-  Keywords                 = {EOS},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Misc{Lemmon-RP-2010,
-  Title                    = {{NIST Standard Reference Database 23: Reference Fluid Thermodynamic and Transport Properties-REFPROP, Version 9.0}},
-
-  Author                   = {E.W. Lemmon and M.L. Huber and M.O. McLinden},
-  Year                     = {2010},
-
-  Owner                    = {ibell},
-  Timestamp                = {2011.03.05}
-}
-
-@Article{Lemmon-JPCRD-2000,
-  Title                    = {{Thermodynamic Properties of Air and Mixtures of Nitrogen, Argon, and Oxygen from 60 to 2000 K at Pressures to 2000 MPa}},
-  Author                   = {Eric W. Lemmon and Richard T. Jacobsen and Steven G. Penoncello and Daniel G. Friend},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2000},
-  Number                   = {3},
-  Pages                    = {331-385},
-  Volume                   = {29},
-
-  Doi                      = {10.1063/1.1285884},
-  File                     = {:D\:\\My_Documents\\Library\\Papers\\Lemmon 2000.pdf:PDF},
-  Keywords                 = {EOS},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Unpublished{Lemmon-PROPYLENE-2013,
-  Title                    = {{Equation of state for propylene}},
-  Author                   = {E.W. Lemmon and U. Overhoff and M.O. McLinden and W. Wagner},
-  Note                     = {Personal communication with Eric Lemmon},
-  Year                     = {2010},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.10}
-}
-
-@Article{Lemmon-JCED-2006,
-  Title                    = {{Short Fundamental Equations of State for 20 Industrial Fluids}},
-  Author                   = {E.W. Lemmon and R. Span},
-  Journal                  = {J. Chem. Eng. Data},
-  Year                     = {2006},
-  Pages                    = {785-850},
-  Volume                   = {51},
-
-  Doi                      = {10.1021/je050186n},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@PhdThesis{Lemmon-THESIS-1996,
-  Title                    = {{A Generalized Model for the Prediction of the Thermodynamic Properties of Mixtures Including Vapor-Liquid Equilibrium}},
-  Author                   = {Eric W. Lemmon},
-  School                   = {University of Idaho, Moscow},
-  Year                     = {1996},
-
-  Owner                    = {ihb},
-  Timestamp                = {2015.07.20}
-}
-
-@Article{Lemmon-EF-2004,
-  Title                    = {{Thermodynamic Properties of n-Dodecane}},
-  Author                   = {Eric W. Lemmon and Marcia L. Huber},
-  Journal                  = {Energy \& Fuels},
-  Year                     = {2004},
-  Pages                    = {960-967},
-  Volume                   = {18},
-
-  Doi                      = {10.1021/ef0341062},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.09}
-}
-
-@Article{Lemmon-FPE-2005,
-  Title                    = {{Thermodynamic properties of the butenes Part II. Short fundamental equations of state}},
-  Author                   = {Eric W. Lemmon and E. Christian Ihmels},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {2005},
-  Pages                    = {173-187},
-  Volume                   = {228-229},
-
-  Doi                      = {10.1016/j.fluid.2004.09.004},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Lemmon-JPCRD-2005,
-  Title                    = {{A New Functional Form and New Fitting Techniques for Equations of State with Application to Pentafluoroethane (HFC-125)}},
-  Author                   = {Eric W. Lemmon and Richard T Jacobsen},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2005},
-  Number                   = {1},
-  Pages                    = {69-108},
-  Volume                   = {34},
-
-  Doi                      = {10.1063/1.1797813},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.13}
-}
-
-@Article{Lemmon-IJT-2004,
-  Title                    = {{Viscosity and Thermal Conductivity Equations for Nitrogen, Oxygen, Argon, and Air}},
-  Author                   = {E. W. Lemmon and R. T Jacobsen},
-  Journal                  = {Int. J. Thermophys.},
-  Year                     = {2004},
-  Number                   = {1},
-  Pages                    = {21-69},
-  Volume                   = {25},
-
-  Comment                  = {Critical enhancement included},
-  Doi                      = {10.1023/B:IJOT.0000022327.04529.f3},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Lemmon-JPCRD-2004,
-  Title                    = {{Equations of State for Mixtures of R-32, R-125, R-134a, R-143a, and R-152a}},
-  Author                   = {Eric W. Lemmon and Richard T. Jacobsen},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2004},
-  Number                   = {2},
-  Pages                    = {593-620},
-  Volume                   = {33},
-
-  Doi                      = {10.1063/1.1649997},
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.07}
-}
-
-@Article{LemmonJacobsen-JPCRD-2000,
-  Title                    = {{An International Standard Formulation for the Thermodynamic Properties of 1,1,1-Trifluoroethane (HFC-143a) for Temperatures From 161 to 450 K and Pressures to 50 MPa}},
-  Author                   = {Eric W. Lemmon and Richard T. Jacobsen},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2000},
-  Number                   = {4},
-  Pages                    = {521-552},
-  Volume                   = {29},
-
-  Doi                      = {10.1063/1.1318909},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.09}
-}
-
-@Article{Lemmon-IJT-1999,
-  Title                    = {{A Generalized Model for the Thermodynamic Properties of Mixtures}},
-  Author                   = {E. W. Lemmon and R. T Jacobsen},
-  Journal                  = {Int. J. Thermophys.},
-  Year                     = {1999},
-  Number                   = {3},
-  Pages                    = {825-835},
-  Volume                   = {20},
-
-  Doi                      = {10.1023/A:1022627001338},
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.07}
-}
-
-@InProceedings{Lemmon-Paderborn-2001,
-  Title                    = {{Method for Estimating Mixture Equation of State Parameters}},
-  Author                   = {Eric W. Lemmon and Mark O. McLinden},
-  Booktitle                = {Thermophysical Properties and Transfer Processes of New Refrigerants, Paderborn, Germany},
-  Year                     = {2001},
-
-  Owner                    = {ihb},
-  Timestamp                = {2015.07.20}
-}
-
-@Article{Lemmon-JCED-2009,
-  Title                    = {{Thermodynamic Properties of Propane. III. A Reference Equation of State for Temperatures from the Melting Line to 650 K and Pressures up to 1000 MPa}},
-  Author                   = {Eric W. Lemmon and Mark O. McLinden and Wolfgang Wagner},
-  Journal                  = {J. Chem. Eng. Data},
-  Year                     = {2009},
-  Pages                    = {3141-3180},
-  Volume                   = {54},
-
-  Doi                      = {10.1021/je900217v},
-  Owner                    = {Belli},
-  Timestamp                = {2013.03.19}
-}
-
-@Article{Lemmon-JCED-2016-365227,
-  Title                    = {{Thermodynamic Properties of R-227ea, R-365mfc, R-115, and R13I1}},
-  Author                   = {Eric W. Lemmon and Roland Span},
-  Journal                  = {J. Chem. Eng. Data},
-  Year                     = {2016, submitted},
-
-  Doi                      = {10.1021/acs.jced.5b00684},
-  Owner                    = {Belli},
-  Timestamp                = {2015.11.24}
-}
-
-@Article{Lemmon-FPE-1999,
-  author    = {Eric W. Lemmon and Reiner Tillner-Roth},
-  journal   = {Fluid Phase Equilib.},
-  title     = {{A Helmholtz energy equation of state for calculating the thermodynamic properties of fluid mixtures}},
-  year      = {1999},
-  pages     = {1-21},
-  volume    = {165},
-  doi       = {10.1016/S0378-3812(99)00262-9},
-  owner     = {ihb},
-  timestamp = {2015.07.20},
-}
-
-@Article{Llovell-JPCB-2013,
-  Title                    = {{Transport Properties of Mixtures by the Soft-SAFT + Free-Volume Theory: Application to Mixtures of n-Alkanes and Hydrofluorocarbons}},
-  Author                   = {F. Llovell and R. M. Marcos and L. F. Vega},
-  Journal                  = {J. Phys. Chem. B},
-  Year                     = {2013},
-  Pages                    = {5195-5205},
-  Volume                   = {117},
-
-  Doi                      = {10.1021/jp401754r},
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.07}
-}
-
-@Article{Marsh-JCED-2002,
-  Title                    = {{Measurement and Correlation of the Thermal Conductivity of Propane from 86 K to 600 K at Pressures to 70 MPa}},
-  Author                   = {Kenneth N. Marsh and Richard A. Perkins and Maria L. V. Ramires},
-  Journal                  = {J. Chem. Eng. Data},
-  Year                     = {2002},
-  Pages                    = {932-940},
-  Volume                   = {47},
-
-  Doi                      = {10.1021/je010001m},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Book{Marx-BOOK-1992,
-  Title                    = {{Neue Zustandsgleichung f\"{u}r R 12, R 22, R 11 und R 113 - Beschreibung des therodynamischen Zustandsverhaltens bei Temperaturen bis 525 K und Dru\"{u}cken bis 200 MPa}},
-  Author                   = {Volker Marx and Andreas Pruss and Wolfgang Wagner},
-  Publisher                = {VDI Verlag},
-  Year                     = {1992},
-  Number                   = {57},
-  Volume                   = {19},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.05.20}
-}
-
-@Article{McLinden-IJR-2000,
-  Title                    = {{An extended corresponding states model for the thermal conductivity of refrigerants and refrigerant mixtures}},
-  Author                   = {Mark O. McLinden and Sanford A. Klein and Richard A. Perkins},
-  Journal                  = {Int. J. Refrig.},
-  Year                     = {2000},
-  Pages                    = {43-63},
-  Volume                   = {23},
-
-  Doi                      = {10.1016/S0140-7007(99)00024-9},
-  Owner                    = {ibell},
-  Timestamp                = {2010.07.06}
-}
-
-@Article{McLinden-JCED-2015-Novec649,
-  Title                    = {{Thermodynamic Properties of 1,1,1,2,2,4,5,5,5-nonafluoro-4-(trifluoromethyl)-3-pentanone: Vapor Pressure, (p, $\rho$, T) Behavior, and Speed of Sound Measurements, and Equation of State}},
-  Author                   = {Mark O. McLinden and Richard A. Perkins and Eric W. Lemmon and Tara J. Fortin},
-  Journal                  = {J. Chem. Eng. Data},
-  Year                     = {2015},
-  Number                   = {12},
-  Pages                    = {3646-3659},
-  Volume                   = {60},
-
-  Doi                      = {10.1021/acs.jced.5b00623},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.09}
-}
-
-@InProceedings{McLinden-PURDUE-2010,
-  Title                    = {{Thermodynamic Properties of trans-1,3,3,3-tetrafluoropropene [R1234ze(E)]: Measurements of Density and Vapor Pressure and a Comprehensive Equation of State}},
-  Author                   = {Mark O. McLinden and Monika Thol and Eric W. Lemmon},
-  Booktitle                = {International Refrigeration and Air Conditioning Conference at Purdue, July 12-15, 2010},
-  Year                     = {2010},
-
-  Comment                  = {The constants as written in the paper are not the most up-to-date EOS constants. REFPROP 9.1 contains the updated coefficients and they are used with permission. Also the sign of the terms for eta_k and beta_k should be inverted in the table},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Book{Melinder2010,
-  Title                    = {{Properties of Secondary Working Fluids for Indirect Systems}},
-  Author                   = {{\AA}ke Melinder},
-  Publisher                = {IIF-IIR Publishing},
-  Year                     = {2010},
-
-  Owner                    = {jowr},
-  Timestamp                = {2014.09.17}
-}
-
-@Book{Melinder-BOOK-2010,
-  Title                    = {{Properties of Secondary Working Fluids for Indirect Systems}},
-  Author                   = {{\r{A}}ke Melinder},
-  Publisher                = {IIF-IIR Publishing},
-  Year                     = {2010}
-}
-
-@Article{Meng-JCED-2012,
-  Title                    = {{Experimental Measurement and Modeling of the Viscosity of Dimethyl Ether}},
-  Author                   = {Xianyang Meng and Jianbo Zhang and Jiangtao Wu and Zhigang Liu},
-  Journal                  = {J. Chem. Eng. Data},
-  Year                     = {2012},
-  Pages                    = {988-993},
-  Volume                   = {57},
-
-  Comment                  = {Erratum: Limits for deltaeta_r sums should be 0-3 and 4-9. The correct order of terms based on the original indices are 0,1,7,9,2,3,4,5,6,8},
-  Doi                      = {10.1021/je201297j},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.09}
-}
-
-@Article{Michailidou-JPCRD-2014-Heptane,
-  Title                    = {{Reference Correlation of the Viscosity of n-Heptane from the Triple Point to 600 K and up to 248 MPa}},
-  Author                   = {E. K. Michailidou and M. J. Assael and M. L. Huber and I. M. Abdulagatov and R. A. Perkins},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2014},
-  Pages                    = {023103},
-  Volume                   = {43},
-
-  Doi                      = {10.1063/1.4875930},
-  Owner                    = {Belli},
-  Timestamp                = {2014.06.10}
-}
-
-@Article{Michailidou-JPCRD-2013-Hexane,
-  Title                    = {{Reference Correlation of the Viscosity of n-Hexane from the Triple Point to 600 K and up to 100 MPa}},
-  Author                   = {E. K. Michailidou and M. J. Assael and M. L. Huber and R. A. Perkins},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2013},
-  Number                   = {3},
-  Pages                    = {033104:1-12},
-  Volume                   = {42},
-
-  Doi                      = {10.1063/1.4818980},
-  Owner                    = {Belli},
-  Timestamp                = {2013.09.21}
-}
-
-@Article{Michels-PHYSICA-1962,
-  Title                    = {{The Melting Lines of Argon, Krypton and Xenon up to 1500 atm; Representation of the Results by a Law of Corresponding States}},
-  Author                   = {A. Michels and C. Prins},
-  Journal                  = {Physica},
-  Year                     = {1962},
-  Pages                    = {101-116},
-  Volume                   = {28},
-
-  Doi                      = {10.1016/0031-8914(62)90096-4},
-  Owner                    = {Belli},
-  Timestamp                = {2014.10.02}
-}
-
-@Book{Michelsen-BOOK-2007,
-  Title                    = {{Thermodynamic Models: Fundamentals \& Computational Aspects}},
-  Author                   = {Michael L. Michelsen and J{\o}rgen M. Mollerup},
-  Publisher                = {Tie-Line Publications},
-  Year                     = {2007},
-
-  Owner                    = {ihb},
-  Timestamp                = {2015.05.01}
-}
-
-@Article{Miqueu-2000,
-  Title                    = {{An extended scaled equation for the temperature dependence of the surface tension of pure compounds inferred from an analysis of experimental data}},
-  Author                   = {C. Miqueu and D. Broseta and J. Satherley and B. Mendiboure and J. Lachaise and A. Graciaa},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {2000},
-  Pages                    = {169-182},
-  Volume                   = {172},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.23}
-}
-
-@Article{Mondejar-JCED-2015-R1233zdE,
-  Title                    = {{Thermodynamic Properties of trans-1-Chloro-3,3,3-trifluoropropene (R1233zd(E)): Vapor Pressure, ($p$, $\rho$, $T$) Behavior, and Speed of Sound Measurements, and Equation of State}},
-  Author                   = {Mar{\'i}a E. Mondej{\'a}r and Mark O. McLinden and Eric W. Lemmon},
-  Journal                  = {J. Chem. Eng. Data},
-  Year                     = {2015},
-  Pages                    = {2477-2489},
-  Volume                   = {60},
-
-  Doi                      = {10.1021/acs.jced.5b00348},
-  Owner                    = {Belli},
-  Timestamp                = {2015.10.23}
-}
-
-@Article{Monsalvo-2006,
-  Title                    = {{High-pressure viscosity behavior of x 1,1,1,2-tetrafluoroethane (HFC-134a)+(1-x) triethylene glycol dimethylether (TriEGDME) mixtures: Measurements and modeling}},
-  Author                   = {Mat{\'i}as A. Monsalvo and Antoine Baylaucq and Sergio E. Qui{\~n}ones-Cisneros and Christian Boned},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {2006},
-  Pages                    = {70-79},
-  Volume                   = {247},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.03}
-}
-
-@Article{Monsalvo-2005,
-  Title                    = {{Viscosity measurements and correlations of binary mixtures: 1,1,1,2-tetrafluoroethane (HFC-134a)+tetraethylene glycol dimethylether (TEGDME)}},
-  Author                   = {M.A. Monsalvo and A. Baylaucq and P. Reghem and S.E. Qui{\~n}ones-Cisnerosa and C. Boned},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {2005},
-  Pages                    = {1-8},
-  Volume                   = {233},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.03}
-}
-
-@Article{Mulero-JPCRD-2014,
-  Title                    = {{Recommended Correlations for the Surface Tension of Several Fluids Included in the REFPROP Program}},
-  Author                   = {A. Mulero and I. Cachadi{\~n}a},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2014},
-  Pages                    = {023104-1:8},
-  Volume                   = {43},
-
-  Doi                      = {10.1063/1.4878755},
-  Owner                    = {Belli},
-  Timestamp                = {2014.06.10}
-}
-
-@Article{Mulero-JPCRD-2012,
-  Title                    = {{Recommended Correlations for the Surface Tension of Common Fluids}},
-  Author                   = {A. Mulero and I. Cachadi{\~n}a and M. I. Parra},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2012},
-  Number                   = {4},
-  Pages                    = {043105-1:13},
-  Volume                   = {41},
-
-  Doi                      = {10.1063/1.4768782},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Muzny-JCED-2013,
-  author    = {Chris D. Muzny and Marcia L. Huber and Andrei F. Kazakov},
-  title     = {{Correlation for the Viscosity of Normal Hydrogen Obtained from Symbolic Regression}},
-  journal   = {J. Chem. Eng. Data},
-  year      = {2013},
-  comment   = {Errata : In equation 7, the exponent should be -i rather than -1. Equation 6 is missing Avogadro's number},
-  doi       = {10.1021/je301273j},
-  owner     = {Belli},
-  timestamp = {2013.04.10},
-}
-
-@Article{Mylona-JPCRD-2014-xylenes,
-  Title                    = {{Reference Correlations of the Thermal Conductivity of o-Xylene, m-Xylene, p-Xylene, and Ethylbenzene from the Triple Point to 700 K and Moderate Pressures}},
-  Author                   = {S. K. Mylona and K. D. Antoniadis and M. J. Assael and M. L. Huber and R. A. Perkins},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2014},
-  Pages                    = {043104},
-  Volume                   = {43},
-
-  Doi                      = {10.1063/1.4901166},
-  Owner                    = {Belli},
-  Timestamp                = {2014.12.10}
-}
-
-@Article{Nabizadeh-1999,
-  Title                    = {{Viscosity of Gaseous R404A, R407C, R410A, and R507}},
-  Author                   = {H. Nabizadeh and F. Mayinger},
-  Journal                  = {Int. J. Thermophys.},
-  Year                     = {1999},
-  Number                   = {3},
-  Pages                    = {777-790},
-  Volume                   = {20},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.03}
-}
-
-@Article{Neufeld-1972,
-  Title                    = {{Empirical Equations to Calculate 16 of the Transport Collision Integrals $\Omega^{(l,s)*}$ for the Lennard-Jones (12-6) Potential}},
-  Author                   = {Philip D. Neufeld and A. R. Janzen and R. A. Aziz},
-  Journal                  = {J. Chem. Phys.},
-  Year                     = {1972},
-  Number                   = {3},
-  Pages                    = {1100-1102},
-  Volume                   = {57},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.25}
-}
-
-@Article{Okada-IJT-1999,
-  Title                    = {{Surface Tension of HFC Refrigerant Mixtures}},
-  Author                   = {M. Okada and T. Shibata and Y. Sato and Y. Higashi},
-  Journal                  = {Int. J. Thermophys.},
-  Year                     = {1999},
-  Number                   = {1},
-  Pages                    = {119-127},
-  Volume                   = {20},
-
-  Doi                      = {10.1023/A:1021482231102},
-  Owner                    = {Belli},
-  Timestamp                = {2014.12.08}
-}
-
-@Article{Olchowy-IJT-1989,
-  Title                    = {{A Simplified Representation for the Thermal Conductivity of Fluids in the Critical Region}},
-  Author                   = {G. A. Olchowy and J. V. Sengers},
-  Journal                  = {Int. J. Thermophys.},
-  Year                     = {1989},
-  Number                   = {2},
-  Pages                    = {417-426},
-  Volume                   = {10},
-
-  Doi                      = {10.1007/BF01133538},
-  Owner                    = {Belli},
-  Timestamp                = {2013.05.27}
-}
-
-@Unpublished{OrtizVega-JPCRD-2019,
-  Title                    = {{Equation of state for Helium-4}},
-  Author                   = {D. O. Ortiz-Vega and K. R. Hall and J. C. Holste and V. D. Arp and A. H. Harvey and E. W. Lemmon},
-  Note                     = {Unpublished - coefficients from REPROP 10 with permission},
-  Year                     = {2019}
-}
-
-@Unpublished{OrtizVega-2010,
-  Title                    = {{Equation of state for Helium}},
-  Author                   = {D.O. Ortiz-Vega and K.R. Hall and V.D. Arp and E.W. Lemmon},
-  Note                     = {Unpublished - coefficients from REPROP with permission},
-  Year                     = {2013},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.08.05}
-}
-
-@Article{Outcalt-JPCRD-1996-R152A,
-  Title                    = {{A Modified Benedict-Webb-Rubin Equation of State for the Thermodynamic Properties of R152a (1,1-difluoroethane)}},
-  Author                   = {Stephanie L. Outcalt and Mark O. McLinden},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {1996},
-  Number                   = {2},
-  Pages                    = {605-636},
-  Volume                   = {25},
-
-  Doi                      = {10.1063/1.555979},
-  Owner                    = {Belli},
-  Timestamp                = {2014.10.02}
-}
-
-@Article{Patek2006,
-  Title                    = {{A computationally effective formulation of the thermodynamic properties of LiBr-H2O solutions from 273 to 500 K over full composition range}},
-  Author                   = {Jaroslav P\'atek and Jaroslav Klomfar},
-  Journal                  = {Int. J. Refrig.},
-  Year                     = {2006},
-
-  Month                    = {June},
-  Number                   = {4},
-  Pages                    = {566--578},
-  Volume                   = {29},
-
-  Doi                      = {10.1016/j.ijrefrig.2005.10.007},
-  Owner                    = {jowr},
-  Timestamp                = {2013.11.22}
-}
-
-@Article{Pan-FPE-2012,
-  Title                    = {{An equation of state for the thermodynamic properties of 1,1,1,3,3,3-hexafluoropropane (HFC-236fa)}},
-  Author                   = {Jiang Pan and Xinfang Rui and Xiaodong Zhao and Liming Qiu},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {2012},
-  Pages                    = {10-16},
-  Volume                   = {321},
-
-  Doi                      = {10.1016/j.fluid.2012.02.012},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.10}
-}
-
-@Article{Peng-IECF-1976,
-  Title                    = {{A New Two-Constant Equation of State}},
-  Author                   = {Ding-Yu Peng and Donald B. Robinson},
-  Journal                  = {Ind. Eng. Chem. Fundamen.},
-  Year                     = {1976},
-  Number                   = {1},
-  Pages                    = {59-64},
-  Volume                   = {15},
-
-  Doi                      = {10.1021/i160057a011},
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.07}
-}
-
-@Article{Penoncello-IJT-1995,
-  Title                    = {{A Thermodynamic Property Formulation for Cyclohexane}},
-  Author                   = {S. G. Penoncello and R. T Jacobsen and A. R. H. Goodwin},
-  Journal                  = {Int. J. Thermophys.},
-  Year                     = {1995},
-  Number                   = {2},
-  Pages                    = {519-531},
-  Volume                   = {16},
-
-  Doi                      = {10.1007/BF01441918},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Penoncello-JPCRD-2003,
-  Title                    = {{A Fundamental Equation for Trifluoromethane (R-23)}},
-  Author                   = {Steven G. Penoncello and Eric W. Lemmon and Richard T Jacobsen and Zhengjun Shan},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2003},
-  Number                   = {4},
-  Pages                    = {1473-1499},
-  Volume                   = {32},
-
-  Doi                      = {10.1063/1.1559671},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.09}
-}
-
-@Article{Perkins-JCED-2002-Isobutane,
-  Title                    = {{Measurement and Correlation of the Thermal Conductivity of Isobutane from 114 K to 600 K at Pressures to 70 MPa}},
-  Author                   = {R.A. Perkins},
-  Journal                  = {J. Chem. Eng. Data},
-  Year                     = {2002},
-  Number                   = {5},
-  Pages                    = {1272-1279},
-  Volume                   = {47},
-
-  Doi                      = {10.1021/je010121u},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Perkins-JCED-2011,
-  Title                    = {{Measurement and Correlation of the Thermal Conductivity of 2,3,3,3-Tetrafluoroprop-1-ene (R1234yf) and trans-1,3,3,3-Tetrafluoropropene (R1234ze(E))}},
-  Author                   = {Richard A. Perkins and Marcia L. Huber},
-  Journal                  = {J. Chem. Eng. Data},
-  Year                     = {2011},
-  Pages                    = {4868-4874},
-  Volume                   = {56},
-
-  Doi                      = {10.1021/je200811n},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.09}
-}
-
-@Article{Perkins-JCED-2006,
-  Title                    = {{Measurement and Correlation of the Thermal Conductivity of Pentafluoroethane (R125) from 190 K to 512 K at Pressures to 70 MPa}},
-  Author                   = {Richard A. Perkins and Marcia L. Huber},
-  Journal                  = {J. Chem. Eng. Data},
-  Year                     = {2006},
-  Pages                    = {898-904},
-  Volume                   = {51},
-
-  Doi                      = {10.1021/je050372t},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.13}
-}
-
-@Article{Perkins-JCED-2002-nButane,
-  Title                    = {{Measurement and Correlation of the Thermal Conductivity of Butane from 135 K to 600 K at Pressures to 70 MPa}},
-  Author                   = {R.A. Perkins and M.L.V. Ramires and C.A. Nieto de Castro and L. Cusco},
-  Journal                  = {J. Chem. Eng. Data},
-  Year                     = {2002.},
-  Number                   = {5},
-  Pages                    = {1263-1271},
-  Volume                   = {47},
-
-  Doi                      = {10.1021/je0101202},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Piazza-FPE-2013,
-  Title                    = {{An equation of state for methanol including the association term of SAFT}},
-  Author                   = {L. Piazza and R. Span},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {2013},
-  Pages                    = {12-24},
-  Volume                   = {349},
-
-  Doi                      = {10.1016/j.fluid.2013.03.024},
-  Owner                    = {Belli},
-  Timestamp                = {2014.02.02}
-}
-
-@Article{Piazza-FPE-2011,
-  Title                    = {{An equation of state for acetic acid including the association term of SAFT}},
-  Author                   = {L. Piazza and R. Span},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {2011},
-  Pages                    = {134-149},
-  Volume                   = {303},
-
-  Doi                      = {10.1016/j.fluid.2011.01.008},
-  Owner                    = {Belli},
-  Timestamp                = {2014.02.27}
-}
-
-@Book{Platzer-BOOK-1990,
-  Title                    = {{Thermophysical Properties of Refrigerants}},
-  Author                   = {B. Platzer and A. Polt and G. Maurer},
-  Publisher                = {Springer-Verlag},
-  Year                     = {1990},
-
-  Doi                      = {10.1007/978-3-662-02608-3},
-  Owner                    = {Belli},
-  Timestamp                = {2013.05.20}
-}
-
-@Book{Poling-BOOK-2001,
-  Title                    = {{The Properties of Gases and Liquids, 5th edition}},
-  Author                   = {Bruce E. Poling and John M. Prausnitz and John P. O'Connell},
-  Publisher                = {McGraw Hill},
-  Year                     = {2001},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Polt-CT-1992,
-  Title                    = {{Parameter der thermischen Zustandsgleichung von Bender f{\"u}r 14 mehratomige reine Stoffe}},
-  Author                   = {Axel Polt and Bernhard Platzer and Gerd Maurer},
-  Journal                  = {Chem. Technik},
-  Year                     = {1992},
-  Pages                    = {216-224},
-  Volume                   = {22},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.29}
-}
-
-@InBook{Preisegger2010,
-  Title                    = {{VDI Heat Atlas}},
-  Author                   = {Ewald Preisegger and Felix Flohr and Gernot Krakat and Andreas Gl{\"u}ck and Dietmar Hunold},
-  Chapter                  = {D4 Properties of Industrial Heat Transfer Media},
-  Editor                   = {Peter Stephan},
-  Pages                    = {419--512},
-  Publisher                = {Springer},
-  Year                     = {2010},
-
-  Address                  = {Berlin Heidelberg},
-  Edition                  = {2nd},
-
-  Doi                      = {10.1007/978-3-540-77877-6_20},
-  Owner                    = {jowr},
-  Timestamp                = {2013.06.18}
-}
-
-@Article{QuinonesCisneros-JPCRD-2012,
-  Title                    = {{Correlation for the Viscosity of Sulfur Hexafluoride (SF6) from the Triple Point to 1000 K and Pressures to 50 MPa}},
-  Author                   = {S.E. Qui{\~n}ones-Cisneros and M.L. Huber and U.K. Deiters},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2012},
-  Number                   = {2},
-  Pages                    = {023102-1:11},
-  Volume                   = {41},
-
-  Doi                      = {10.1063/1.3702441},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{QuinonesCisneros-JPCB-2006,
-  Title                    = {{Generalization of the Friction Theory for Viscosity Modeling}},
-  Author                   = {Sergio E. Qui{\~n}ones-Cisneros and Ulrich K. Deiters},
-  Journal                  = {J. Phys. Chem. B},
-  Year                     = {2006},
-  Pages                    = {12820-12834},
-  Volume                   = {110},
-
-  Doi                      = {10.1021/jp0618577},
-  Owner                    = {Belli},
-  Timestamp                = {2015.04.10}
-}
-
-@Article{QuinonesCisneros-JCED-2012,
-  Title                    = {{Reference Correlation for the Viscosity Surface of Hydrogen Sulfide}},
-  Author                   = {Sergio E. Qui{\~n}ones-Cisneros and Kurt A. G. Schmidt and Binod R. Giri and Pierre Blais and Robert A. Marriott},
-  Journal                  = {J. Chem. Eng. Data},
-  Year                     = {2012},
-  Pages                    = {3014-3018},
-  Volume                   = {57},
-
-  Doi                      = {10.1021/je300601h},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.14}
-}
-
-@Article{QuinonesCisneros-FPE-2001,
-  Title                    = {{One parameter friction theory models for viscosity}},
-  Author                   = {Sergio E. Qui{\~n}ones-Cisneros and Claus K. Z{\'e}berg-Mikkelsen and Erling H. Stenby},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {2001},
-  Pages                    = {1-16},
-  Volume                   = {176},
-
-  Doi                      = {10.1016/S0378-3812(00)00474-X},
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.07}
-}
-
-@Article{QuinonesCisneros-FPE-2000,
-  Title                    = {{The friction theory (f-theory) for viscosity modeling}},
-  Author                   = {Sergio E. Qui{\~n}ones-Cisneros and Claus K. Zeberg-Mikkelsen and Erling H. Stenby},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {2000},
-  Pages                    = {249-276},
-  Volume                   = {169},
-
-  Doi                      = {10.1016/S0378-3812(00)00310-1},
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.07}
-}
-
-@PhdThesis{Quoilin-2011,
-  Title                    = {{Sustainable energy conversion through the use of Organic Rankine Cycles for waste heat recovery and solar applications}},
-  Author                   = {Sylvain Quoilin},
-  School                   = {University of Li\`{e}ge},
-  Year                     = {2011},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.03.30}
-}
-
-@Article{Reeves-JCP-1964,
-  Title                    = {{Melting Curves of Pressure Transmitting Fluids}},
-  Author                   = {Larry E. Reeves and Gene J. Scott and Stanley E. Babb Jr.},
-  Journal                  = {J. Chem. Phys.},
-  Year                     = {1964},
-  Pages                    = {3662-3666},
-  Volume                   = {40},
-
-  Doi                      = {10.1063/1.1725068},
-  Owner                    = {Belli},
-  Timestamp                = {2014.10.02}
-}
-
-@Book{deReuck-BOOK-1990,
-  Title                    = {{Fluorine: International Thermodynamic Tables of the Fluid State - 11}},
-  Author                   = {K.M. de Reuck},
-  Publisher                = {Blackwell Scientific Publications},
-  Year                     = {1990},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.05.17}
-}
-
-@Book{deReuck-BOOK-1993,
-  Title                    = {{Methanol: International Thermodynamic Tables of the Fluid State - 12}},
-  Author                   = {K.M. de Reuck and R.J.B. Craven},
-  Publisher                = {Blackwell Scientific Publications},
-  Year                     = {1993},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.05.17}
-}
-
-@Article{Richardson-JPCRD-2013,
-  Title                    = {{Fundamental Equation of State for Deuterium}},
-  Author                   = {I.A. Richardson and J.W. Leachman and E.W. Lemmon},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2014},
-  Pages                    = {013103},
-  Volume                   = {43},
-
-  Doi                      = {10.1063/1.4864752},
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.28}
-}
-
-@Article{Richter-JCED-2011,
-  Title                    = {{Thermodynamic Properties of 2,3,3,3-Tetrafluoroprop-1-ene (R1234yf): Vapor Pressure and $p$-$\rho$-$T$ Measurements and an Equation of State}},
-  Author                   = {M. Richter and M. O. McLinden and E. W. Lemmon},
-  Journal                  = {J. Chem. Eng. Data},
-  Year                     = {2011},
-  Pages                    = {3254-3264},
-  Volume                   = {56},
-
-  Doi                      = {10.1021/je200369m},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Royal-2005,
-  author    = {D.D. Royal and V. Vesovic and J.P.M. Trusler and W.A. Wakeham},
-  title     = {{Predicting the viscosity of liquid refrigerant blends: comparison with experimental data}},
-  journal   = {Int. J. Refrig.},
-  year      = {2005},
-  volume    = {28},
-  pages     = {311?319},
-  comment   = {Only includes liquid mixtures},
-  owner     = {Belli},
-  timestamp = {2013.07.03},
-}
-
-@Article{Rui-FPE-2013,
-  Title                    = {{An equation of state for the thermodynamic properties of 1,1,1,2,3,3-hexafluoropropane (R236ea)}},
-  Author                   = {Xinfang Rui and Jiang Pan and Yugang Wang},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {2013},
-  Pages                    = {78-85},
-  Volume                   = {341},
-
-  Comment                  = {Erratum in paper: a1 should be -17.5983849 and a2 should be 8.87150449},
-  Doi                      = {10.1016/j.fluid.2012.12.026},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.10}
-}
-
-@Article{SantamariaPerez-PRB-2010,
-  Title                    = {{High-pressure melting curve of helium and neon: Deviations from corresponding states theory}},
-  Author                   = {David Santamar{\'i}a-P{\'e}rez and Goutam Dev Mukherjee and Beate Schwager and Reinhard Boehler},
-  Journal                  = {Physical Review B},
-  Year                     = {2010},
-  Pages                    = {214101:1-5},
-  Volume                   = {81},
-
-  Doi                      = {10.1103/PhysRevB.81.214101},
-  Owner                    = {Belli},
-  Timestamp                = {2014.06.09}
-}
-
-@Article{Scalbrin-2002,
-  Title                    = {{A corresponding states predictive viscosity model based on a new scaling parameter: application to hydrocarbons, halocarbons and mixtures}},
-  Author                   = {G. Scalabrin and G. Cristofoli and M. Grigiante},
-  Journal                  = {Int. J. Energy Res.},
-  Year                     = {2002},
-  Pages                    = {1-26},
-  Volume                   = {26},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.03}
-}
-
-@Article{Scalabrin-JPCRD-2006-CO2,
-  Title                    = {{A Reference Multiparameter Thermal Conductivity Equation for Carbon Dioxide with an Optimized Functional Form}},
-  Author                   = {G. Scalabrin and P. Marchi and F. Finezzo and R. Span},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2006},
-  Number                   = {4},
-  Pages                    = {1549-1575},
-  Volume                   = {35},
-
-  Doi                      = {10.1063/1.2213631},
-  Owner                    = {Belli},
-  Timestamp                = {2014.05.30}
-}
-
-@Book{Schmidt1979,
-  Title                    = {{Properties of Water and Steam in SI-Units}},
-  Author                   = {Ernst Schmidt},
-  Publisher                = {Springer},
-  Year                     = {1979},
-  Edition                  = {2nd},
-
-  Owner                    = {jowr},
-  Timestamp                = {2014.09.22}
-}
-
-@Article{Schmidt-FPE-1985,
-  Title                    = {{A New Form of the Equation of State for Pure Substances and its Application to Oxygen}},
-  Author                   = {Schmidt, R. and Wagner, W.},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {1985},
-  Number                   = {3},
-  Pages                    = {175-200},
-  Volume                   = {19},
-
-  Doi                      = {10.1016/0378-3812(85)87016-3},
-  Owner                    = {Belli},
-  Timestamp                = {2016.01.06}
-}
-
-@MastersThesis{Schroeder-MSTHESIS-2011,
-  Title                    = {{A New Fundamental Equation for Ethanol}},
-  Author                   = {Jacob Armin Schroeder},
-  School                   = {University of Idaho},
-  Year                     = {2011},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.13}
-}
-
-@Article{Schroeder-JPCRD-2014,
-  Title                    = {{A Fundamental Equation of State for Ethanol}},
-  Author                   = {Schroeder, J. A. and Penoncello, S. G. and Schroeder, J. S.},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2014},
-  Number                   = {4},
-  Pages                    = {043102},
-  Volume                   = {43},
-
-  Doi                      = {10.1063/1.4895394},
-  Eid                      = {043102}
-}
-
-@Article{Setzmann-JPCRD-1991,
-  Title                    = {{A New Equation of State and Tables of Thermodynamic Properties for Methane Covering the Range from the Melting Line to 625 K at Pressures up to 1000 MPa}},
-  Author                   = {U. Setzmann and W. Wagner},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {1991},
-  Number                   = {6},
-  Pages                    = {1061-1151},
-  Volume                   = {20},
-
-  Doi                      = {10.1063/1.555898},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Shan-ASHRAE-2000,
-  Title                    = {{A generalized model for viscosity and thermal conductivity of trifluoromethane (R-23)}},
-  Author                   = {Shan, Zhengjun and Penoncello, Steven G and Jacobsen, Richard T},
-  Journal                  = {ASHRAE Transactions},
-  Year                     = {2000},
-  Pages                    = {757},
-  Volume                   = {106},
-
-  Publisher                = {American Society of Heating, Refrigeration and Air Conditioning Engineers, Inc.}
-}
-
-@Article{Sharqawy2010,
-  Title                    = {Thermophysical properties of seawater: A review of existing correlations and data},
-  Author                   = {Mostafa H. Sharqawy and John H. Lienhard V and Syed M. Zubair},
-  Journal                  = {Desalination and Water Treatment},
-  Year                     = {2010},
-  Pages                    = {354--380},
-  Volume                   = {16},
-
-  Doi                      = {10.5004/dwt.2010.1079},
-  Owner                    = {jowr},
-  Timestamp                = {2015.09.02}
-}
-
-@Manual{Skovrup2013,
-  Title                    = {{SecCool Properties v1.33}},
-  Author                   = {Morten Juel Skovrup},
-  Organization             = {IPU Refrigeration and Energy Technology},
-  Year                     = {2013},
-
-  Owner                    = {jowr},
-  Timestamp                = {2014.09.17},
-  Url                      = {http://en.ipu.dk/Indhold/refrigeration-and-energy-technology/seccool.aspx}
-}
-
-@TechReport{Skovrup1999,
-  Title                    = {{Beregning af termodynamiske st{\o}rrelser for k{\o}lemidler -- Tilstandsligninger for rene stoffer og blandinger}},
-  Author                   = {Morten Juel Skovrup},
-  Institution              = {{Institut for Energiteknik, Danmarks Tekniske Universitet}},
-  Year                     = {1999},
-
-  Owner                    = {jowr},
-  Timestamp                = {2014.12.17}
-}
-
-@Article{Smukala-JPCRD-2000,
-  Title                    = {{New Equation of State for Ethylene Covering the Fluid Region for Temperatures From the Melting Line to 450 K at Pressures up to 300 MPa}},
-  Author                   = {J. Smukala and R. Span and W. Wagner},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2000},
-  Number                   = {5},
-  Pages                    = {1053-1121},
-  Volume                   = {29},
-
-  Doi                      = {10.1063/1.1329318},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Book{Span-BOOK-2000,
-  Title                    = {{Multiparameter Equations of State - An Accurate Source of Thermodynamic Property Data}},
-  Author                   = {Roland Span},
-  Publisher                = {Springer-Verlag, Berlin},
-  Year                     = {2000},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.03.18}
-}
-
-@Article{Span-JPCRD-2000,
-  Title                    = {{A Reference Equation of State for the Thermodynamic Properties of Nitrogen for Temperatures from 63.151 to 1000 K and Pressures to 2200 MPa}},
-  Author                   = {Roland Span and Eric W. Lemmon and Richard T. Jacobsen and Wolfgang Wagner and Akimichi Yokozeki},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2000},
-  Pages                    = {1361-1433},
-  Volume                   = {29},
-
-  Doi                      = {10.1063/1.1349047},
-  File                     = {:D\:\\My_Documents\\Library\\Papers\\Span Lemmon et al 2000.pdf:PDF},
-  Keywords                 = {EOS},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Span-IJT-2003B,
-  Title                    = {{Equations of State for Technical Applications. II. Results for Nonpolar Fluids}},
-  Author                   = {R. Span and W. Wagner},
-  Journal                  = {Int. J. Thermophys.},
-  Year                     = {2003},
-  Pages                    = {41-109},
-  Volume                   = {24},
-
-  Doi                      = {10.1023/A:1022310214958},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Span-IJT-2003C,
-  Title                    = {{Equations of State for Technical Applications. III. Results for Polar Fluids}},
-  Author                   = {R. Span and W. Wagner},
-  Journal                  = {Int. J. Thermophys.},
-  Year                     = {2003},
-  Pages                    = {111-162},
-  Volume                   = {24},
-
-  Doi                      = {10.1023/A:1022362231796},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Span-JPCRD-1996,
-  Title                    = {{A New Equation of State for Carbon Dioxide Covering the Fluid Region from the Triple Point Temperature to 1100 K at Pressures up to 800 MPa}},
-  Author                   = {R. Span and W. Wagner},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {1996},
-  Pages                    = {1509-1596},
-  Volume                   = {25},
-
-  Doi                      = {10.1063/1.555991},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Span-FPE-2001,
-  Title                    = {{Multiparameter equations of state - recent trends and future challenges}},
-  Author                   = {R. Span and W. Wagner and E.W. Lemmon and R.T. Jacobsen},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {2001},
-  Pages                    = {1-20},
-  Volume                   = {183-184},
-
-  Doi                      = {10.1016/S0378-3812(01)00416-2},
-  Owner                    = {Belli},
-  Timestamp                = {2013.08.18}
-}
-
-@Article{Stewart-JPCRD-1991,
-  Title                    = {{Thermodynamic Properties of Oxygen from the Triple Point to 300 K with Pressures to 80 MPa}},
-  Author                   = {Richard B. Stewart and Richard T. Jacobsen and W. Wagner},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {1991},
-  Number                   = {5},
-  Pages                    = {917-1021},
-  Volume                   = {20},
-
-  Doi                      = {10.1063/1.555897},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Sun-BBPC-1988,
-  Title                    = {{Accurate Measurement of the Melting Line of Methanol and Ethanol at Pressures up to 270 MPa}},
-  Author                   = {T. F. Sun and J. A. Schouten and N. J. Trappeniers and S. N. Biswas},
-  Journal                  = {Ber. Bunsenges. Phys. Chem.},
-  Year                     = {1988},
-  Pages                    = {652--655},
-  Volume                   = {92},
-
-  Doi                      = {10.1002/bbpc.198800153},
-  Owner                    = {Belli},
-  Timestamp                = {2014.07.07}
-}
-
-@Article{Sykioti-JPCRD-2013-Methanol,
-  Title                    = {{Reference Correlation of the Thermal Conductivity of Methanol from the Triple Point to 660 K and up to 245 MPa}},
-  Author                   = {E. A. Sykioti and M. J. Assael and M. L. Huber and R. A. Perkins},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2013},
-  Pages                    = {043101},
-  Volume                   = {42},
-
-  Doi                      = {10.1063/1.4829449},
-  Owner                    = {Belli},
-  Timestamp                = {2016.06.19}
-}
-
-@Article{Tanaka-IJT-1996,
-  Title                    = {{Thermal Conductivity and Viscosity of 2,2-Dichloro-1,1,1-Trifluoroethane (HCFC-123)}},
-  Author                   = {Y. Tanaka and T. Sotani},
-  Journal                  = {Int. J. Thermophys.},
-  Year                     = {1996},
-  Number                   = {2},
-  Pages                    = {293-328},
-  Volume                   = {17},
-
-  Doi                      = {10.1007/BF01443394},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.13}
-}
-
-@Article{Tariq-JPCRD-2014-Cyclohexane,
-  Title                    = {{Reference Correlation of the Viscosity of Cyclohexane from the Triple Point to 700 K and up to 110 MPa}},
-  Author                   = {U. Tariq and A. R. B. Jusoh and N. Riesco and V. Vesovic},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2014},
-  Number                   = {3},
-  Pages                    = {033101-1:18},
-  Volume                   = {43},
-
-  Doi                      = {10.1063/1.4891103},
-  Owner                    = {Belli},
-  Timestamp                = {2014.08.21}
-}
-
-@Article{Tegeler-JPCRD-1999,
-  Title                    = {{A New Equation of State for Argon Covering the Fluid Region for Temperatures From the Melting Line to 700 K at Pressures up to 1000 MPa}},
-  Author                   = {Ch. Tegeler and R. Span and W. Wagner},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {1999},
-  Pages                    = {779-850},
-  Volume                   = {28},
-
-  Doi                      = {10.1063/1.556037},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Thol-FPE-2016-MM,
-  Title                    = {{Fundamental equation of state correlation for hexamethyldisiloxane based on experimental and molecular simulation data}},
-  Author                   = {Monika Thol},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {2015},
-
-  Doi                      = {10.1016/j.fluid.2015.09.047},
-  Owner                    = {Belli},
-  Timestamp                = {2014.11.21}
-}
-
-@PhdThesis{Thol-THESIS-2015,
-  Title                    = {{Empirical Multiparameter Equations of State Based on Molecular Simulation and Hybrid Data Sets}},
-  Author                   = {Monika Thol},
-  School                   = {Ruhr-Universit{\"a}t Bochum},
-  Year                     = {2015},
-
-  Owner                    = {Belli}
-}
-
-@Article{Thol-HTHP-2012,
-  Title                    = {{Equation of state for benzene for temperatures from the melting line up to 725 K with pressures up to 500 MPa}},
-  Author                   = {M. Thol and E.W. Lemmon and R. Span},
-  Journal                  = {High Temperatures-High Pressures},
-  Year                     = {2012},
-  Pages                    = {81-97},
-  Volume                   = {41},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.10}
-}
-
-@Article{Thol-IJT-2016-R1234zeE,
-  Title                    = {{Equation of State for the Thermodynamic Properties of trans-1,3,3,3-Tetrafluoropropene [R-1234ze(E)]}},
-  Author                   = {Monika Thol and Eric W. Lemmon},
-  Journal                  = {Int. J. Thermophys},
-  Year                     = {2016},
-  Number                   = {3},
-  Pages                    = {1--16},
-  Volume                   = {37},
-
-  Doi                      = {10.1007/s10765-016-2040-6},
-  Owner                    = {Belli},
-  Timestamp                = {2016.01.25}
-}
-
-@Unpublished{Thol-2012,
-  Title                    = {{Equation of State for a Refrigerant Mixture of R365mfc (1,1,1,3,3-Pentafluorobutane) and Galden HT 55 (Perfluoropolyether)}},
-  Author                   = {Monika Thol and Eric W. Lemmon and Roland Span},
-  Note                     = {Unpublished},
-  Year                     = {2012},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.08.05}
-}
-
-@Article{Thol-IJT-2014,
-  Title                    = {{A New Functional Form for Equations of State for Some Weakly Associating Fluids}},
-  Author                   = {Thol, Monika and Piazza, Lorenzo and Span, Roland},
-  Journal                  = {Int. J. Thermophys.},
-  Year                     = {2014},
-  Number                   = {5},
-  Pages                    = {783-811},
-  Volume                   = {35},
-
-  Doi                      = {10.1007/s10765-014-1633-1},
-  ISSN                     = {0195-928X},
-  Keywords                 = {Diethyl ether; Equation of state; Functional form; Helmholtz energy; Hydrogen chloride; Methyl chloride; Thermodynamic properties},
-  Language                 = {English},
-  Owner                    = {Belli},
-  Publisher                = {Springer US},
-  Timestamp                = {2016.01.04},
-  Url                      = {http://dx.doi.org/10.1007/s10765-014-1633-1}
-}
-
-@Article{Thol-CES-2015,
-  Title                    = {{Fundamental equation of state for ethylene oxide based on a hybrid dataset}},
-  Author                   = {Monika Thol and G{\'a}bor Rutkai and Andreas K{\"o}ster and Mirco Kortmann and Roland Span and Jadran Vrabec},
-  Journal                  = {Chem. Eng. Sci.},
-  Year                     = {2015},
-  Pages                    = {87--99},
-  Volume                   = {121},
-
-  Doi                      = {10.1016/j.ces.2014.07.051},
-  Owner                    = {Belli},
-  Timestamp                = {2016.01.18}
-}
-
-@Article{Thol-CES-2015-CORR,
-  Title                    = {{Corrigendum to 'Fundamental equation of state for ethylene oxide based on a hybrid dataset'}},
-  Author                   = {Monika Thol and G{\'a}bor Rutkai and Andreas K{\"o}ster and Mirco Kortmann and Roland Span and Jadran Vrabec},
-  Journal                  = {Chem. Eng. Sci.},
-  Year                     = {2015},
-  Pages                    = {887--890},
-  Volume                   = {134},
-
-  Doi                      = {10.1016/j.ces.2015.06.020},
-  Owner                    = {Belli},
-  Timestamp                = {2016.01.18}
-}
-
-@InProceedings{HelmholtzMedia,
-  Title                    = {HelmholtzMedia - A Fluid Properties Library},
-  Author                   = {Thorade, Matthis and Saadat, Ali},
-  Note                     = {https://github.com/thorade/HelmholtzMedia},
-  Booktitle                = {Proceedings of the 9th International Modelica Conference},
-  Pages                    = {63--70},
-  Year                     = 2012,
-  ISSN                     = {1650-3740},
-
-  Doi                      = {10.3384/ecp1207663},
-  Owner                    = {Belli},
-  Timestamp                = {2013.05.29}
-}
-
-@Article{Thorade-EES-2013,
-  Title                    = {{Partial derivatives of thermodynamic state properties for dynamic simulation}},
-  Author                   = {Thorade, Matthis and Saadat, Ali},
-  Journal                  = {Environmental Earth Sciences},
-  Year                     = {2013},
-
-  Month                    = apr,
-
-  Doi                      = {10.1007/s12665-013-2394-z},
-  ISSN                     = {1866-6280},
-  Keywords                 = {defined by specifying any,energy \'{a} partial derivatives,in fluid cycle,nation of two independent,other combi-,state can also be,state properties,thermodynamic properties \'{a} helmholtz,\'{a} dynamic simulation},
-  Owner                    = {jowr},
-  Timestamp                = {2013.05.01},
-  Url                      = {http://link.springer.com/10.1007/s12665-013-2394-z}
-}
-
-@Article{TillnerRoth-IJT-1995,
-  Title                    = {{A Fundamental Equation of State for 1,1-Difluoroethane (HFC-152a)}},
-  Author                   = {R. Tillner-Roth},
-  Journal                  = {Int. J. Thermophys.},
-  Year                     = {1995},
-  Number                   = {1},
-  Pages                    = {91-100},
-  Volume                   = {16},
-
-  Doi                      = {10.1007/BF01438960},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{TillnerRoth-JPCRD-1994,
-  Title                    = {{A International Standard Formulation for the Thermodynamic Properties of 1,1,1,2-Tetrafluoroethane (HFC-134a) for Temperatures from 170 K to 455 K and Pressures up to 70 MPa}},
-  Author                   = {Reiner Tillner-Roth and Hans Dieter Baehr},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {1994},
-  Pages                    = {657-729},
-  Volume                   = {23},
-
-  Doi                      = {10.1063/1.555958},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@InProceedings{TillnerRoth-DKV-1993,
-  Title                    = {{Eine neue Fundamentalgleichung fur Ammoniak (A new Fundamental Equation of State for Ammonia)}},
-  Author                   = {R. Tillner-Roth and F. Harms-Watzenberg and H.D. Baehr},
-  Booktitle                = {Deutscher Kaelte- und Klimatechnischer Verein Tagung 1993},
-  Year                     = {1993},
-
-  Journal                  = {Deutscher Kaelte- und Klimatechnischer Verein Tagung 1993},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{TillnerRoth-JPCRD-1997,
-  Title                    = {{An international standard equation of state for difluoromethane (R-32) for temperatures from the triple point at 136.34 K to 435 K and pressures up to 70 MPa}},
-  Author                   = {R. Tillner-Roth and A. Yokozeki},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {1997},
-  Number                   = {6},
-  Pages                    = {1273-1328},
-  Volume                   = {26},
-
-  Doi                      = {10.1063/1.556002},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Tournier-2008,
-  Title                    = {{Properties of noble gases and binary mixtures for closed Brayton Cycle applications}},
-  Author                   = {Jean-Michel P. Tournier and Mohamed S. El-Genk},
-  Journal                  = {Energy Conversion and Management},
-  Year                     = {2008},
-  Pages                    = {469-492},
-  Volume                   = {49},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.03}
-}
-
-@Article{Tufeu-BBPC-1984,
-  Title                    = {{Thermal Conductivity of Ammonia in a Large Temperature and Pressure Range Including the Critical Region}},
-  Author                   = {R. Tufeu and D.Y. Ivanov and Y. Garrabos and B. Le Neindre},
-  Journal                  = {Bereicht der Bunsengesellschaft Phys. Chem.},
-  Year                     = {1984},
-  Pages                    = {422-427},
-  Volume                   = {88},
-
-  Doi                      = {10.1002/bbpc.19840880421},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Valderrama-IECR-2003,
-  Title                    = {{The State of the Cubic Equations of State}},
-  Author                   = {Jos{\'e} Valderrama},
-  Journal                  = {Ind. Eng. Chem. Res.},
-  Year                     = {2003},
-  Pages                    = {1603-1618},
-  Volume                   = {42},
-
-  Owner                    = {ihb},
-  Timestamp                = {2015.07.20}
-}
-
-@Article{Vassiliou-JPCRD-2015-pentanes,
-  Title                    = {{Reference Correlations of the Thermal Conductivity of Cyclopentane, iso-Pentane, and n-Pentane}},
-  Author                   = {Vassiliou, C-M and Assael, MJ and Huber, ML and Perkins, RA},
-  Journal                  = {Journal of Physical and Chemical Reference Data},
-  Year                     = {2015},
-  Number                   = {3},
-  Pages                    = {033102},
-  Volume                   = {44},
-
-  Publisher                = {AIP Publishing}
-}
-
-@Article{Vesovic-2002,
-  Title                    = {{Predicting the viscosity of halogenated hydrocarbon mixtures}},
-  Author                   = {V. Vesovic},
-  Journal                  = {Fluid Phase Equilib.},
-  Year                     = {2002},
-  Pages                    = {295-306},
-  Volume                   = {199},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.03}
-}
-
-@Article{Vesovic-JPCRD-1990,
-  Title                    = {{The Transport Properties of Carbon Dioxide}},
-  Author                   = {V. Vesovic and W.A. Wakeham and G.A. Olchowy and J.V. Sengers and J.T.R. Watson and J. Millat},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {1990},
-  Pages                    = {763--808},
-  Volume                   = {19},
-
-  Doi                      = {10.1063/1.555875},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Vogel-JPCRD-1998,
-  Title                    = {{Reference Correlation of the Viscosity of Propane}},
-  Author                   = {E. Vogel and C. K{\"u}chenmeister and E. Bich and A. Laesecke},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {1998},
-  Note                     = {5},
-  Pages                    = {947-970},
-  Volume                   = {27},
-
-  Doi                      = {10.1063/1.556025},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Vogel-IJT-2000,
-  Title                    = {{Viscosity Correlation for Isobutane over Wide Ranges of the Fluid Region}},
-  Author                   = {E. Vogel and C. Kuechenmeister and E. Bich},
-  Journal                  = {Int. J. Thermophys},
-  Year                     = {2000},
-  Number                   = {2},
-  Pages                    = {343-356},
-  Volume                   = {21},
-
-  Doi                      = {10.1023/A:1006623310780},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Vogel-HTHP-1999,
-  Title                    = {{Viscosity for n-Butane in the Fluid Region}},
-  Author                   = {E. Vogel and C. Kuechenmeister and E. Bich},
-  Journal                  = {High Temp. - High Pressures},
-  Year                     = {1999},
-  Number                   = {2},
-  Pages                    = {173-186},
-  Volume                   = {31},
-
-  Doi                      = {10.1068/htrt154},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@InProceedings{deVries-ICR-1995,
-  Title                    = {{Thermodynamic Properties of HCFC 124}},
-  Author                   = {B. de Vries and R. Tillner-Roth and H.D. Baehr},
-  Booktitle                = {19th International Congress of Refrigeration, The Hague, The Netherlands},
-  Year                     = {1995},
-  Pages                    = {582-589},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.05.01}
-}
-
-@Unpublished{FLUIDCAL,
-  Title                    = {FLUIDCAL: Software FLUIDCAL for the Calculation of Thermodynamic Properties for a Great Number of Substances},
-  Author                   = {W. Wagner},
-  Note                     = {http://www.thermo.rub.de/en/prof-w-wagner/software/fluidcal.html},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.05.29}
-}
-
-@Article{Wagner-JPCRD-2002,
-  Title                    = {{The IAPWS Formulation 1995 for the Thermodynamic Properties of Ordinary Water Substance for General and Scientific Use}},
-  Author                   = {W. Wagner and A. Pru\ss},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2002},
-  Pages                    = {387--535},
-  Volume                   = {31},
-
-  Doi                      = {10.1063/1.1461829},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Wei-AICHEJ-2000,
-  Title                    = {{Equations of State for the Calculation of Fluid-Phase Equilibria}},
-  Author                   = {Ya Song Wei and Richard J. Sadus},
-  Journal                  = {AIChE Journal},
-  Year                     = {2000},
-  Number                   = {1},
-  Pages                    = {169-196},
-  Volume                   = {46},
-
-  Owner                    = {ihb},
-  Timestamp                = {2015.07.20}
-}
-
-@Article{Wu-IJT-2012,
-  Title                    = {{An Equation of State for Fluoroethane (R161)}},
-  Author                   = {Jiangtao Wu and Yong Zhou},
-  Journal                  = {Int. J. Thermophys.},
-  Year                     = {2012},
-  Pages                    = {220-234},
-  Volume                   = {33},
-
-  Doi                      = {10.1007/s10765-011-1151-3},
-  Owner                    = {Belli},
-  Timestamp                = {2014.01.22}
-}
-
-@Article{Wu-JPCRD-2011,
-  Title                    = {{An Equation of State for the Thermodynamic Properties of Dimethyl Ether}},
-  Author                   = {Jiangtao Wu and Yong Zhou and Eric W. Lemmon},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2011},
-  Number                   = {2},
-  Pages                    = {023104-1:16},
-  Volume                   = {40},
-
-  Doi                      = {10.1063/1.3582533},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.09}
-}
-
-@Article{Xiang-JPCRD-2006,
-  Title                    = {{A New Reference Correlation for the Viscosity of Methanol}},
-  Author                   = {Hong Wei Xiang and Arno Laesecke and Marcia L. Huber},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2006},
-  Number                   = {4},
-  Pages                    = {1597-1:24},
-  Volume                   = {35},
-
-  Doi                      = {10.1063/1.2360605},
-  Owner                    = {Belli},
-  Timestamp                = {2014.08.26}
-}
-
-@Article{Yokoyama-2006,
-  Title                    = {{Viscosity of Gaseous Mixtures of HFC-125 + Propane from 298.15 to 423.15K at Pressures to 6.7 MPa}},
-  Author                   = {C. Yokoyama and T. Nishino and M. Takahashi},
-  Journal                  = {Int. J. Thermophys.},
-  Year                     = {2006},
-  Number                   = {3},
-  Pages                    = {714-728},
-  Volume                   = {27},
-
-  Owner                    = {Belli},
-  Timestamp                = {2013.07.03}
-}
-
-@Article{Younglove-JPCRD-1994,
-  Title                    = {{An International Standard Equation of State for the Thermodynamic Properties of Refrigerant 123 (2,2-Dichloro-1,1,1-Trifluoroethane)}},
-  Author                   = {Ben A. Younglove},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {1994},
-  Number                   = {5},
-  Pages                    = {731-779},
-  Volume                   = {23},
-
-  Doi                      = {10.1063/1.555950},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@TechReport{Younglove-NIST-1982,
-  Title                    = {{Thermophysical properties of fluids. I. Argon, ethylene, parahydrogen, nitrogen, nitrogen trifluoride, and oxygen}},
-  Author                   = {Younglove, Ben A},
-  Institution              = {DTIC Document},
-  Year                     = {1982}
-}
-
-@TechReport{Zavoico2001,
-  Title                    = {{Solar Power Tower Design Basis Document}},
-  Author                   = {Alexis B. Zavoico},
-  Institution              = {Sandia National Laboratories},
-  Year                     = {2001},
-  Month                    = {July},
-
-  Doi                      = {10.2172/786629},
-  Owner                    = {jowr},
-  Timestamp                = {2013.10.23},
-  Url                      = {http://prod.sandia.gov/techlib/access-control.cgi/2001/012100.pdf}
-}
-
-@Article{Zhou-IJT-2016-R245ca,
-  Title                    = {{Equation of State for the Thermodynamic Properties of 1,1,2,2,3-Pentafluoropropane (R-245ca)}},
-  Author                   = {Yong Zhou & Eric W. Lemmon},
-  Journal                  = {Int. J. Thermophys.},
-  Year                     = {2016},
-  Pages                    = {1--11},
-  Volume                   = {37},
-  Doi                      = {10.1007/s10765-016-2039-z},
-}
-
-@Article{Zhou-JPCRD-2014,
-  Title                    = {{An Equation of State for the Thermodynamic Properties of Cyclohexane}},
-  Author                   = {Yong Zhou and Jun Liu and Steven G. Penoncello and Eric W. Lemmon},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2014},
-  Pages                    = {043105-1:12},
-  Volume                   = {43},
-
-  Abstract                 = {Erratum: Reference values for enthalpy and entropy in the homogeneous phase are incorrect as published},
-  Doi                      = {10.1063/1.4900538},
-  Owner                    = {Belli},
-  Timestamp                = {2014.12.06}
-}
-
-@Article{Zhou-JPCRD-2012,
-  Title                    = {{Thermodynamic Properties of o-Xylene, m-Xylene, p-Xylene, and Ethylbenzene}},
-  Author                   = {Yong Zhou and Jiangtao Wu and Eric W. Lemmon},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2012},
-  Number                   = {2},
-  Pages                    = {023103-1 -- 023103-26},
-  Volume                   = {41},
-
-  Doi                      = {10.1063/1.3703506},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.08}
-}
-
-@Article{Zhou-JPCRD-2011,
-  Title                    = {{Thermodynamic Properties of Dimethyl Carbonate}},
-  Author                   = {Yong Zhou and Jiangtao Wu and Eric W. Lemmon},
-  Journal                  = {J. Phys. Chem. Ref. Data},
-  Year                     = {2011},
-  Number                   = {4},
-  Pages                    = {043106-1:11},
-  Volume                   = {40},
-
-  Doi                      = {10.1063/1.3664084},
-  Owner                    = {Belli},
-  Timestamp                = {2013.04.09}
-}
-
-@Manual{Dynalene2014,
-  Title                    = {{Technical Data Sheet}},
-  Organization             = {{Dynalene Inc.}},
-  Year                     = {2014},
-
-  Owner                    = {jowr},
-  Timestamp                = {2014.09.22}
-}
-
-@Manual{Therminol2014,
-  Title                    = {{Therminol Heat Transfer Reference Disk v5.1}},
-  Organization             = {{Eastman Chemical Company}},
-  Year                     = {2014},
-
-  Owner                    = {jowr},
-  Timestamp                = {2014.09.17},
-  Url                      = {http://www.therminol.com/resources/therminol-reference-disk}
-}
-
-@Manual{Paratherm2013,
-  Title                    = {{Thermal Properties Calculator v6.4}},
-  Organization             = {{Paratherm Ltd.}},
-  Year                     = {2013},
-
-  Owner                    = {jowr},
-  Timestamp                = {2014.09.22},
-  Url                      = {http://paracalc.paratherm.com}
-}
-
-@Manual{Arteco2010,
-  Title                    = {{Technical Information}},
-  Organization             = {{Arteco NV/SA}},
-  Year                     = {2010},
-
-  Owner                    = {jowr},
-  Timestamp                = {2014.09.22}
-}
-
-@Manual{3M2007,
-  Title                    = {{Technical Information}},
-  Organization             = {{3M Company}},
-  Year                     = {2007},
-
-  Owner                    = {jowr},
-  Timestamp                = {2014.09.22}
-}
-
-@Manual{PKS2005,
-  Title                    = {{Technical Data Sheet}},
-  Organization             = {{pro K{\"u}hlsole GmbH}},
-  Year                     = {2005},
-
-  Owner                    = {jowr},
-  Timestamp                = {2014.09.22}
-}
-
-@Manual{Chevron2004,
-  Title                    = {{Technical Data Sheet}},
-  Organization             = {{Chevron Products Company}},
-  Year                     = {2004},
-
-  Owner                    = {jowr},
-  Timestamp                = {2014.09.22}
-}
-
-@Manual{Aspen2001,
-  Title                    = {{Technical Data Sheet}},
-  Organization             = {{Aspen Petroleum AB}},
-  Year                     = {2001},
-
-  Owner                    = {jowr},
-  Timestamp                = {2014.09.22}
-}
-
-@Manual{Clariant2000,
-  Title                    = {{Technical Data Sheet}},
-  Organization             = {{Clariant GmbH}},
-  Year                     = {2000},
-
-  Owner                    = {jowr},
-  Timestamp                = {2014.09.22}
-}
-
-@Manual{Hydro2000,
-  Title                    = {{Technical Information}},
-  Organization             = {{Hydro Chemicals}},
-  Year                     = {2000},
-
-  Owner                    = {jowr},
-  Timestamp                = {2014.09.22}
-}
-
-@Manual{Sulzer1999,
-  Title                    = {{Technical Information}},
-  Organization             = {{Sulzer Chemtech AG}},
-  Year                     = {1999},
-
-  Owner                    = {jowr},
-  Timestamp                = {2014.09.22}
-}
-
-@Manual{Tyfoprop1999,
-  Title                    = {{Technical Information}},
-  Organization             = {{Tyforop Chemie Gmbh}},
-  Year                     = {1999},
-
-  Owner                    = {jowr},
-  Timestamp                = {2014.09.22}
-}
-
-@Manual{Kemira1998,
-  Title                    = {{Technical Data Sheet}},
-  Organization             = {{Kemira Chemicals OY}},
-  Year                     = {1998},
-
-  Owner                    = {jowr},
-  Timestamp                = {2014.09.22}
-}
-
-@Manual{Dow1997,
-  Title                    = {{Technical Data Sheet}},
-  Organization             = {{The Dow Chemical Company}},
-  Year                     = {1997},
-
-  Owner                    = {jowr},
-  Timestamp                = {2014.09.22}
-}
-
-@Manual{Hoechst1995,
-  Title                    = {{Technical Information}},
-  Organization             = {{Hoechst AG}},
-  Year                     = {1995},
-
-  Owner                    = {jowr},
-  Timestamp                = {2014.09.22}
-}
-
-@Article{Thol-JCED-2017-siloxanes,
-  author    = {Monika Thol and Frithjof H. Dubberke and Elmar Baumh{\"o}gger and Jadran Vrabec and Roland Span},
-  title     = {Speed of Sound Measurements and Fundamental Equations of State for Octamethyltrisiloxane and Decamethyltetrasiloxane},
-  journal   = {J. Chem. Eng. Data},
-  year      = {2017},
-  volume    = {62},
-  number    = {9},
-  pages     = {2633--2648},
-  month     = {jul},
-  doi       = {10.1021/acs.jced.7b00092},
-  publisher = {American Chemical Society ({ACS})},
-}
-
-@Article{Thol-JCED-2018-HCl,
-  author    = {Monika Thol and Frithjof H. Dubberke and Elmar Baumh{\"o}gger and Roland Span and Jadran Vrabec},
-  title     = {Speed of Sound Measurements and a Fundamental Equation of State for Hydrogen Chloride},
-  journal   = {J. Chem. Eng. Data},
-  year      = {2018},
-  volume    = {63},
-  number    = {7},
-  pages     = {2533--2547},
-  doi       = {10.1021/acs.jced.7b01031},
-  publisher = {American Chemical Society ({ACS})},
-}
-
-@Article{Thol-JPCRD-2019-Neon,
-  author  = {M. Thol and R. Beckm{\"u}ller and R. Weiss and A.H. Harvey and E.W. Lemmon and R.T. Jacobsen and R. Span},
-  title   = {{Thermodynamic Properties for Neon for Temperatures from the Triple Point to 700 K at Pressures to 700 MPa}},
-  journal = {J. Phys. Chem Ref. Data},
-  year    = {2019, Submitted},
-}
-
-@Article{Thol-FPE-2019-siloxanes,
-  author  = {M. Thol and M.A. Javed and E. Baumhoegger and R. Span and J. Vrabec},
-  title   = {{Thermodynamic Properties of Dodecamethylpentasiloxane, Tetradecamethylhexasiloxane, and Decamethylcyclopentasiloxane}},
-  journal = {Fluid Phase Equilib.},
-  year    = {2019},
-}
-
-@Article{Thol-FPE-2019-alkanes-pentane,
-  author  = {M. Thol and T. Uhde and E.W. Lemmon and R. Span},
-  title   = {{Fundamental Equations of State for Hydrocarbons.  Part I. n-Pentane}},
-  journal = {Fluid Phase Equilib.},
-  year    = {2019},
-}
-
-@Article{Thol-FPE-2019-alkanes-hexane,
-  author  = {M. Thol and Y. Wang and E.W. Lemmon and R. Span},
-  title   = {{Fundamental Equations of State for Hydrocarbons.  Part II. n-Hexane}},
-  journal = {Fluid Phase Equilib.},
-  year    = {2019},
-}
-
-@Article{Beckmueller-IJT-2019-octane,
-  author  = {R. Beckmueller and M. Thol and E.W. Lemmon and R. Span},
-  title   = {{Fundamental Equation of State for n-Octane}},
-  journal = {Int. J. Therrmophys.},
-  year    = {2019},
-}
-
-@Misc{IAPWS-SurfaceTension-1994,
-  Title                    = {IAPWS Release on Surface Tension of Heavy Water Substance},
-
-  Author                   = {IAPWS},
-  Year                     = {1994}
-}
-
-@Comment{jabref-meta: databaseType:bibtex;}
+% Encoding: US-ASCII
+
+@Book{Cengel2007,
+  Title                    = {{Thermodynamics, An Engineering Approach}},
+  Author                   = {Yunus A. \c{C}engel and Michael A. Boles},
+  Publisher                = {McGraw-Hill},
+  Year                     = {2007},
+
+  Address                  = {New York},
+  Edition                  = {6th edition},
+
+  Owner                    = {jowr},
+  Timestamp                = {2014.12.16}
+}
+
+@Article{Abramson-HPR-2011,
+  Title                    = {{Melting curves of argon and methane}},
+  Author                   = {Evan H. Abramson},
+  Journal                  = {High Pressure Research},
+  Year                     = {2011},
+  Number                   = {4},
+  Pages                    = {549-554},
+  Volume                   = {31},
+
+  Doi                      = {10.1080/08957959.2011.629617},
+  Owner                    = {Belli},
+  Timestamp                = {2014.06.09}
+}
+
+@Article{Akasaka-JCED-2019,
+  Title                    = {{New Fundamental Equations of State for cis-1,3,3,3-Tetrafluoropropene [R-1234ze(Z)] and 3,3,3-Trifluoropropene (R-1243zf)}},
+  Author                   = {Ryo Akasaka and Eric Lemmon},
+  Journal                  = {J. Chem. Eng. Data},
+  Year                     = {2019, submitted},
+}
+
+@InProceedings{Akasaka-Purdue-2014,
+  Title                    = {{A Thermodynamic Property Model for the R-134a/245fa Mixtures}},
+  Author                   = {Ryo Akasaka},
+  Booktitle                = {15th International Refrigeration and Air Conditioning Conference at Purdue, July 14-17, 2014},
+  Year                     = {2014},
+
+  Owner                    = {Belli},
+  Timestamp                = {2014.09.27}
+}
+
+@Article{Akasaka-FPE-2013,
+  Title                    = {{Thermodynamic property models for the difluoromethane (R-32) + trans-1,3,3,3-tetrafluoropropene (R-1234ze(E)) and difluoromethane + 2,3,3,3-tetrafluoropropene (R-1234yf) mixtures}},
+  Author                   = {Ryo Akasaka},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {2013},
+  Pages                    = {98-104},
+  Volume                   = {358},
+
+  Doi                      = {10.1016/j.fluid.2013.07.057},
+  Owner                    = {Belli},
+  Timestamp                = {2014.09.27}
+}
+
+@Article{Akasaka-2008,
+  Title                    = {{A Reliable and Useful Method to Determine the Saturation State from Helmholtz Energy Equations of State}},
+  Author                   = {Ryo Akasaka},
+  Journal                  = {Journal of Thermal Science and Technology},
+  Year                     = {2008},
+  Pages                    = {442-451},
+  Volume                   = {3},
+
+  Doi                      = {10.1299/jtst.3.442},
+  Owner                    = {Belli},
+  Timestamp                = {2013.03.19}
+}
+
+@InProceedings{Akasaka-PU-2014,
+  Title                    = {{A Thermodynamic Property Model for the R-134a/245fa Mixtures}},
+  Author                   = {Ryo Akasaka and Yukihiro Higashi},
+  Booktitle                = {15 th International Refrigeration and Air Conditioning Conference at Purdue, July 14-17, 2014},
+  Year                     = {2014},
+
+  Owner                    = {Belli},
+  Timestamp                = {2014.07.22}
+}
+
+@InProceedings{Akasaka-DELFT-2013,
+  Title                    = {{A Fundamental Equation of State For Low-GWP Refrigerant HFO-1234ze(Z)}},
+  Author                   = {Ryo Akasaka and Yukihiro Higashi and Shigeru Koyama},
+  Booktitle                = {4th IIR Conference on ThermophysicalProperties and Transfer Processes of Refrigerants, Delft, The Netherlands, 2013},
+  Year                     = {2013},
+  Pages                    = {TP-052},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.08.05}
+}
+
+@Article{Akasaka-IJR-2012,
+  Title                    = {{A fundamental equation of state for trifluoromethyl methyl ether (HFE-143m) and its application to refrigeration cycle analysis}},
+  Author                   = {Ryo Akasaka and Yohei Kayukawa},
+  Journal                  = {Int. J. Refrig.},
+  Year                     = {2012},
+  Pages                    = {1003-1013},
+  Volume                   = {35},
+
+  Doi                      = {10.1016/j.ijrefrig.2012.01.003},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.10}
+}
+
+@Article{Akasaka-JPCRD-2015-R245fa,
+  Title                    = {{A Fundamental Equation of State for 1,1,1,3,3-Pentafluoropropane (R-245fa)}},
+  Author                   = {Ryo Akasaka and Yong Zhou and Eric W. Lemmon},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2015},
+  Pages                    = {013104},
+  Volume                   = {44},
+
+  Doi                      = {10.1063/1.4913493},
+  Owner                    = {Belli},
+  Timestamp                = {2014.08.09}
+}
+
+@Article{Aleksandrov-TE-2011,
+  Title                    = {{Using Fundamental Equations of State for Calculating the Thermodynamic Properties of Normal Undecane}},
+  Author                   = {I. S. Aleksandrov and A. A. Gerasimov and B. A. Grigor'ev},
+  Journal                  = {Thermal Engineering},
+  Year                     = {2011},
+  Number                   = {8},
+  Pages                    = {691-698},
+  Volume                   = {58},
+
+  Doi                      = {10.1134/S0040601511080027},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.11}
+}
+
+@Article{Allal-PRE-2001,
+  Title                    = {{Free-volume viscosity model for fluids in the dense and gaseous states}},
+  Author                   = {A. Allal and C. Boned and A. Baylaucq},
+  Journal                  = {Physical Review E},
+  Year                     = {2001},
+  Pages                    = {011203-1:10},
+  Volume                   = {64},
+
+  Doi                      = {10.1103/PhysRevE.64.011203},
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.07}
+}
+
+@Article{Aly-FPE-1981,
+  Title                    = {{Self-Consistent Equations for Calculating the Ideal Gas Specific Heat Capacity, Enthalpy, and Entropy}},
+  Author                   = {Fouad A. Aly and Lloyd L. Lee},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {1981},
+  Pages                    = {169-179},
+  Volume                   = {6},
+
+  Doi                      = {10.1016/0378-3812(81)85002-9},
+  Owner                    = {Belli},
+  Timestamp                = {2013.08.05}
+}
+
+@Book{ASHRAE2001,
+  Title                    = {{2001 ASHRAE Handbook: Fundamentals}},
+  Author                   = {{American Society of Heating, Refrigerating and Air-Conditioning Engineers}},
+  Publisher                = {{ASHRAE}},
+  Year                     = {2001},
+  Volume                   = {111},
+
+  ISBN                     = {9781883413880},
+  Owner                    = {jowr},
+  Timestamp                = {2014.09.17}
+}
+
+@TechReport{Arp-NIST-1998,
+  Title                    = {{Thermophysical Properties of Helium-4 from 0.8 to 1500 K with Pressures to 2000 MPa - NIST Technical Note 1334 (revised)}},
+  Author                   = {V.D. Arp and R.D. McCarty and D.G Friend},
+  Institution              = {NIST},
+  Year                     = {1998},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.08.05}
+}
+
+@Article{Assael-JPCRD-2012-Benzene,
+  Title                    = {{Reference Correlation of the Thermal Conductivity of Benzene from the Triple Point to 725 K and up to 500 MPa}},
+  Author                   = {M.J. Assael and E. Mihailidou and M.L. Huber and R.A. Perkins},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2012},
+  Pages                    = {043102-1:9},
+  Volume                   = {41},
+
+  Doi                      = {10.1063/1.4755781},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.10}
+}
+
+@Article{Assael-JPCRD-2011-Hydrogen,
+  Title                    = {{Correlation of the Thermal Conductivity of Normal and Parahydrogen from the Triple Point to 1000 K and up to 100 MPa}},
+  Author                   = {M. J. Assael and J.-A. M. Assael and M. L. Huber and R. A. Perkins and Y. Takata},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2011},
+  Number                   = {3},
+  Pages                    = {033101-1:13},
+  Volume                   = {40},
+
+  Doi                      = {10.1063/1.3606499},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.09}
+}
+
+@Article{Assael-JPCRD-2013-Heptane,
+  Title                    = {{Reference Correlation of the Thermal Conductivity of n-Heptane from the Triple Point to 600 K and up to 250 MPa}},
+  Author                   = {M. J. Assael and I. Bogdanou and S. K. Mylona and M. L. Huber and R. A. Perkins and V. Vesovic},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2013},
+  Number                   = {2},
+  Pages                    = {023101-1:9},
+  Volume                   = {42},
+
+  Doi                      = {10.1063/1.4794091},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.28}
+}
+
+@Article{Assael-JPCRD-2012-SF6,
+  author    = {M. J. Assael and I. A. Koini and K. D. Antoniadis and M. L. Huber and I. M. Abdulagatov and R. A. Perkins},
+  title     = {{Reference Correlation of the Thermal Conductivity of Sulfur Hexafluoride from the Triple Point to 1000 K and up to 150 MPa}},
+  journal   = {J. Phys. Chem. Ref. Data},
+  year      = {2012},
+  volume    = {41},
+  number    = {2},
+  pages     = {023104-1:9},
+  comment   = {Errata: To get the correct values in REFPROP for the residual part they use a molar reducing density of 5.046 mol/L or 5046*0.1460554192 = 736.9956452832 kg/m^3},
+  doi       = {10.1063/1.4708620},
+  owner     = {Belli},
+  timestamp = {2013.04.08},
+}
+
+@Article{Assael-JPCRD-2012-Toluene,
+  Title                    = {{Reference Correlation of the Thermal Conductivity of Toluene from the Triple Point to 1000 K and up to 1000 MPa}},
+  Author                   = {M. J. Assael and S. K. Mylona and M. L. Huber and R. A. Perkins},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2012},
+  Number                   = {2},
+  Pages                    = {023101-1:12},
+  Volume                   = {41},
+
+  Doi                      = {10.1063/1.3700155},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.10}
+}
+
+@Article{Assael-JPCRD-2013-Hexane,
+  Title                    = {{Reference Correlation of the Thermal Conductivity of n-Hexane from the Triple Point to 600 K and up to 500 MPa}},
+  Author                   = {M. J. Assael and S. K. Mylona and Ch. A. Tsiglifisi and M. L. Huber and R. A. Perkins},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2013},
+  Number                   = {1},
+  Pages                    = {013106-1:8},
+  Volume                   = {42},
+
+  Doi                      = {10.1063/1.4793335},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.28}
+}
+
+@Article{Assael-JPCRD-2013-Ethanol,
+  Title                    = {{Reference Correlation of the Thermal Conductivity of Ethanol from the Triple Point to 600 K and up to 245 MPa}},
+  Author                   = {M. J. Assael and E. A. Sykioti and M. L. Huber and R. A. Perkins},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2013},
+  Number                   = {2},
+  Pages                    = {023102-1:10},
+  Volume                   = {42},
+
+  Doi                      = {10.1063/1.4797368},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.28}
+}
+
+@Article{Avgeri-JPCRD-2015-Toluene,
+  Title                    = {{Reference Correlation of the Viscosity of Toluene from the Triple Point to 675 K and up to 500 MPa}},
+  Author                   = {S. Avgeri and M. J. Assael and M. L. Huber and R. A. Perkins},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2015},
+  Pages                    = {033101},
+  Volume                   = {44},
+
+  Doi                      = {10.1063/1.4926955},
+  Owner                    = {Belli},
+  Timestamp                = {2015.08.21}
+}
+
+@Article{Avgeri-JPCRD-2014-Benzene,
+  Title                    = {{Reference Correlation of the Viscosity of Benzene from the Triple Point to 675 K and up to 300 MPa}},
+  Author                   = {S. Avgeri and M. J. Assael and M. L. Huber and R. A. Perkins},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2014},
+  Pages                    = {033103},
+  Volume                   = {43},
+
+  Doi                      = {10.1063/1.4892935},
+  Owner                    = {Belli},
+  Timestamp                = {2014.09.02}
+}
+
+@Article{Balogun-JPCRD-2015-pxylene,
+  Title                    = {{Reference Correlation of the Viscosity of para-Xylene from the Triple Point to 673 K and up to 110 MPa}},
+  Author                   = {B. Balogun and N. Riesco and V. Vesovic},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2015},
+  Pages                    = {013103},
+  Volume                   = {44},
+
+  Doi                      = {10.1063/1.4908048},
+  Owner                    = {Belli},
+  Timestamp                = {2016.07.03}
+}
+
+@Article{Barreiros-JCT-1982,
+  Title                    = {{The Melting Curves of Carbon Monoxide}},
+  Author                   = {Susane F. Barreiros and Jorge C. G. Calado and Manuel Nunes da Ponte},
+  Journal                  = {J. Chem. Thermodyn.},
+  Year                     = {1982},
+  Pages                    = {1197-1198},
+  Volume                   = {14},
+
+  Doi                      = {10.1016/0021-9614(82)90044-1},
+  Owner                    = {Belli},
+  Timestamp                = {2014.10.02}
+}
+
+@InProceedings{Bell-PURDUE-2016-ETA,
+  Title                    = {{Viscosity of refrigerants and other working fluids from residual entropy scaling }},
+  Author                   = {Ian H. Bell and Arno Laesecke},
+  Booktitle                = {16th International Refrigeration and Air Conditioning Conference at Purdue, July 11-14, 2016},
+  Year                     = {2016}
+}
+
+@Article{Bell-JCED-2016,
+  Title                    = {{Automatic fitting of binary interaction parameters for multi-fluid Helmholtz-energy-explicit mixture models}},
+  Author                   = {Bell, Ian H. and Lemmon, Eric W.},
+  Journal                  = {J. Chem. Eng. Data},
+  Volume                   = {61},
+  Doi                      = {10.1021/acs.jced.6b00257},
+  Year                     = {2016}
+}
+
+@Article{Bell-JRN-2016,
+  Title                    = {{Helmholtz Energy Transformations of Common Cubic Equations of State for Use with Pure Fluids and Mixtures}},
+  Author                   = {Ian H. Bell and Andreas J{\"a}ger},
+  Journal                  = {J. Res. NIST},
+  Volume                   = {121},
+  Doi                      = {10.6028/jres.121.011},
+  Year                     = {2016}
+}
+
+@Article{Bell-IECR-2014,
+  Title                    = {{Pure and Pseudo-pure Fluid Thermophysical Property Evaluation and the Open-Source Thermophysical Property Library CoolProp}},
+  Author                   = {Bell, Ian H. and Wronski, Jorrit and Quoilin, Sylvain and Lemort, Vincent},
+  Journal                  = {Ind. Eng. Chem. Res.},
+  Year                     = {2014},
+  Number                   = {6},
+  Pages                    = {2498-2508},
+  Volume                   = {53},
+
+  Doi                      = {10.1021/ie4033999},
+  Eprint                   = {http://pubs.acs.org/doi/pdf/10.1021/ie4033999}
+}
+
+@Conference{Bender-1970,
+  Title                    = {{Equations of state exactly representing the phase behavior of pure substances}},
+  Author                   = {E. Bender},
+  Booktitle                = {Proc. 5th Symp. Thermophys. Prop.},
+  Year                     = {1970},
+  Pages                    = {227-235},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.05.04}
+}
+
+@Article{Boned-2003,
+  Title                    = {{High-pressure dynamic viscosity and density of two synthetic hydrocarbon mixtures representative of some heavy petroleum distillation cuts}},
+  Author                   = {C. Boned and C.K. Z{\'e}berg-Mikkelsen and A. Baylaucq and P. Daug{\'e}},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {2003},
+  Pages                    = {143-164},
+  Volume                   = {212},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.03}
+}
+
+@InBook{Brent-1973,
+  Title                    = {{Algorithms for Minimization without Derivatives}},
+  Author                   = {R.P. Brent},
+  Chapter                  = {4},
+  Publisher                = {Prentice-Hall},
+  Year                     = {1973},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.23}
+}
+
+@Article{Buecker-JPCRD-2006,
+  Title                    = {{A Reference Equation of State for the Thermodynamic Properties of Ethane for Temperatures from the Melting Line to 675 K and Pressures up to 900 MPa}},
+  Author                   = {D. Buecker and W. Wagner},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2006},
+  Number                   = {1},
+  Pages                    = {205-266},
+  Volume                   = {35},
+
+  Doi                      = {10.1063/1.1859286},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Buecker-JPCRD-2006B,
+  Title                    = {{Reference Equations of State for the Thermodynamic Properties of Fluid Phase n-Butane and Isobutane}},
+  Author                   = {D. Buecker and W. Wagner},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2006},
+  Number                   = {2},
+  Pages                    = {929-1019},
+  Volume                   = {35},
+
+  Doi                      = {10.1063/1.1901687},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.30}
+}
+
+@Article{Cao-JPCRD-2016-mxylene,
+  Title                    = {{Reference Correlation of the Viscosity of meta-Xylene from 273 to 673 K and up to 200 MPa}},
+  Author                   = {F. L. Cao and X. Y. Meng and J. T. Wu and V. Vesovic},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2016},
+  Pages                    = {013103},
+  Volume                   = {45},
+
+  Doi                      = {10.1063/1.4941241},
+  Owner                    = {Belli},
+  Timestamp                = {2016.07.03}
+}
+
+@Article{Cao-JPCRD-2016-oxylene,
+  Title                    = {{Reference Correlation of the Viscosity of ortho-Xylene from 273 to 673 K and up to 110 MPa}},
+  Author                   = {F. L. Cao and X. Y. Meng and J. T. Wu and V. Vesovic},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2016},
+  Pages                    = {023102},
+  Volume                   = {45},
+
+  Doi                      = {10.1063/1.4945663},
+  Owner                    = {Belli},
+  Timestamp                = {2016.07.03}
+}
+
+@Conference{Casella-2008,
+  Title                    = {{ExternalMedia: A Library for Easy Re-Use of External Fluid Property Code in Modelica}},
+  Author                   = {Francesco Casella and Christoph Richter},
+  Booktitle                = {Modelica 2008, March 3rd-4th, 2008},
+  Year                     = {2008},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.03.28}
+}
+
+@TechReport{Chichester-NIST-2008,
+  Title                    = {{NISTIR 6650: Documentation and Assessment of the Transport Property Model for Mixtures Implemented in NIST REFPROP (Version 8.0)}},
+  Author                   = {Justin C. Chichester and Marcia L. Huber},
+  Institution              = {National Institute of Standards and Technology (NIST)},
+  Year                     = {June 2008},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Chung-IECR-1988,
+  Title                    = {{Generalized multiparameter correlation for nonpolar and polar fluid transport properties}},
+  Author                   = {Chung, Ting Horng and Ajlan, Mohammad and Lee, Lloyd L and Starling, Kenneth E},
+  Journal                  = {Ind. Eng. Chem. Res.},
+  Year                     = {1988},
+  Number                   = {4},
+  Pages                    = {671--679},
+  Volume                   = {27},
+
+  Doi                      = {10.1021/ie00076a024},
+  Publisher                = {ACS Publications}
+}
+
+@Article{Colonna-FPE-2008,
+  Title                    = {{Multiparameter equations of state for siloxanes: [(CH3)3-Si-O1/2]2-[O-Si-(CH3)2]i=1,...,3, and [O-Si-(CH3)2]6}},
+  Author                   = {P. Colonna and N.R. Nannan and A. Guardone},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {2008},
+  Pages                    = {115-130},
+  Volume                   = {263},
+
+  Doi                      = {10.1016/j.fluid.2007.10.001},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Colonna-FPE-2006,
+  Title                    = {{Multiparameter equations of state for selected siloxanes}},
+  Author                   = {P. Colonna and N.R. Nannan and A. Guardone and E.W. Lemmon},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {2006},
+  Pages                    = {193-211},
+  Volume                   = {244},
+
+  Doi                      = {10.1016/j.fluid.2006.04.015},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Datchi-PRB-2000,
+  Title                    = {{Extended and accurate determination of the melting curves of argon, helium, ice (H$_2$O) and hydrogen (H$_2$)}},
+  Author                   = {Fr{\'e}d{\'e}ric Datchi and Paul Loubeyre and Ren{\'e} LeToullec},
+  Journal                  = {Physical Review B},
+  Year                     = {2000},
+  Number                   = {10},
+  Pages                    = {6535-6546},
+  Volume                   = {61},
+
+  Doi                      = {10.1103/PhysRevB.61.6535},
+  Owner                    = {Belli},
+  Timestamp                = {2014.10.02}
+}
+
+@Misc{Therminol2007,
+  Title                    = {{Therminol Heat Transfer Reference Disk, Version 5.0}},
+
+  Author                   = {{Eastman Chemical Company}}
+}
+
+@Article{EstellaUribe-2003,
+  Title                    = {{Extended corresponding states model for fluids and fluid mixtures I. Shape factor model for pure fluids}},
+  Author                   = {J.F. Estela-Uribe and J.P.M. Trusler},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {2003},
+  Pages                    = {15-40},
+  Volume                   = {204},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.05.29}
+}
+
+@Article{Fenghour-JPCRD-1998,
+  author    = {A. Fenghour and W.A. Wakeham and V. Vesovic},
+  title     = {{The Viscosity of Carbon Dioxide}},
+  journal   = {J. Phys. Chem. Ref. Data},
+  year      = {1998},
+  volume    = {27},
+  number    = {1},
+  pages     = {31-44},
+  note      = {5},
+  comment   = {Units of density in paper are mol/L, poorly documented},
+  doi       = {10.1063/1.556013},
+  owner     = {Belli},
+  timestamp = {2013.04.08},
+}
+
+@Article{Fenghour-JPCRD-1995,
+  author    = {A. Fenghour and W.A. Wakeham and V. Vesovic and J.T.R. Watson and J. Millat and E. Vogel},
+  title     = {{The Viscosity of Ammonia}},
+  journal   = {J. Phys. Chem. Ref. Data},
+  year      = {1995},
+  volume    = {24},
+  pages     = {1649-1667},
+  note      = {5},
+  comment   = {Units of density in paper are mol/L, poorly documented},
+  doi       = {10.1063/1.555961},
+  owner     = {Belli},
+  timestamp = {2013.04.08},
+}
+
+@Article{Froeba-2000,
+  Title                    = {{Saturated Liquid Viscosity and Surface Tension of Alternative Refrigerants}},
+  Author                   = {A.P. Fr\"{o}ba and S. Will and A. Leipertz},
+  Journal                  = {Int. J. Thermophys.},
+  Year                     = {2000},
+  Note                     = {10.1023/A:1006689724974},
+  Pages                    = {1225-1253},
+  Volume                   = {21},
+
+  Doi                      = {10.1023/A:1006689724974},
+  ISSN                     = {0195-928X},
+  Issue                    = {6},
+  Keyword                  = {Physics and Astronomy},
+  Owner                    = {ibell},
+  Publisher                = {Springer Netherlands},
+  Timestamp                = {2011.04.17}
+}
+
+@Article{Friend-JPCRD-1989,
+  Title                    = {{Thermophysical Properties of Methane}},
+  Author                   = {Daniel G. Friend and James F. Ely and Hepburn Ingham},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {1989},
+  Volume                   = {18},
+
+  Doi                      = {10.1063/1.555828},
+  Owner                    = {Belli},
+  Timestamp                = {2015.04.27}
+}
+
+@Article{Friend-JPCRD-1991,
+  Title                    = {{Thermophysical Properties of Ethane}},
+  Author                   = {Daniel G. Friend and Hepburn Ingham and James F. Ely},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {1991},
+  Number                   = {2},
+  Pages                    = {275-347},
+  Volume                   = {20},
+
+  Doi                      = {10.1063/1.555881},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Fuchs-IECR-2006,
+	Title = {{Solubility of Amino Acids: Influence of the pH value and the Addition of Alcoholic Cosolvents on Aqueous Solubility}},
+	Volume = {45},
+	Url = {https://doi.org/10.1021/ie0602097},
+	Doi = {10.1021/ie0602097},
+	Number = {19},
+	Journal = {Industrial \& Engineering Chemistry Research},
+	Author = {Fuchs, Dominik and Fischer, Jan and Tumakaka, Feelly and Sadowski, Gabriele},
+	Month = {sep},
+	Year = {2006},
+	Pages = {6578--6584},
+}
+
+@Article{Gao-JCED-2016,
+  Title                    = {{A Helmholtz Energy Equation of State for Sulfur Dioxide}},
+  Author                   = {Kehui Gao and Jiangtao Wu and Penggang Zhang and Eric W. Lemmon},
+  Journal                  = {J. Chem. Eng. Data},
+  Year                     = {2016},
+
+  Owner                    = {Belli},
+  Timestamp                = {2016.01.15}
+}
+
+@Article{Gao-JPCRD-2020,
+  Title                    = {{Thermodynamic Properties of Ammonia for Temperatures from the Melting Line to 725 K and Pressures to 1000 MPa}},
+  Author                   = {K. Gao and J. Wu and I. H. Bell and E. W. Lemmon},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2020},
+}
+
+@Article{Gedanitz-JCED-2015,
+  Title                    = {{Speed of sound measurements and a fundamental equation of state for cyclopentane}},
+  Author                   = {Holger Gedanitz and Mar{\'i}a J. D{\'a}vila and Eric W. Lemmon},
+  Journal                  = {J. Chem. Eng. Data},
+  Year                     = {2015},
+  Number                   = {5},
+  Pages                    = {1331-1337},
+  Volume                   = {60},
+
+  Doi                      = {10.1021/je5010164},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.10}
+}
+
+@InProceedings{Geller-PURDUE-2000,
+  Title                    = {{Viscosity of Mixed Refrigerants R404A, R407C, R410A, and R507A}},
+  Author                   = {V. Geller},
+  Booktitle                = {2000 International Refrigeration Conferences at Purdue University},
+  Year                     = {2000},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Geller-IJT-2001,
+  Title                    = {{Thermal Conductivity of the Refrigerant mixtures R404A, R407C, R410A, and R507A}},
+  Author                   = {V.Z. Geller and B.Z. Nemzer and U.V. Cheremnykh},
+  Journal                  = {Int. J. Thermophys.},
+  Year                     = {2001},
+  Pages                    = {1034-1043},
+  Volume                   = {22},
+
+  Doi                      = {10.1023/A:1010691504352},
+  Owner                    = {ibell},
+  Timestamp                = {2010.06.30}
+}
+
+@PhdThesis{Gernert-Thesis-2013,
+  Title                    = {{A New Helmholtz Energy Model for Humid Gases and CCS Mixtures}},
+  Author                   = {Georg Johannes Gernert},
+  School                   = {Ruhr-Universit{\"a}t Bochum},
+  Year                     = {2013},
+
+  Owner                    = {Belli},
+  Timestamp                = {2014.09.27}
+}
+
+@Article{Gernert-FPE-2014,
+  Title                    = {{Calculation of phase equilibria for multi-component mixtures using highly accurate Helmholtz energy equations of state}},
+  Author                   = {Johannes Gernert and Andreas J{\"a}ger and Roland Span},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {2014},
+  Pages                    = {209-218},
+  Volume                   = {375},
+
+  Doi                      = {10.1016/j.fluid.2014.05.012},
+  Owner                    = {Belli},
+  Timestamp                = {2014.07.21}
+}
+
+@Article{Gernert-JCT-2015,
+  Title                    = {{EOS-CG: A Helmholtz energy mixture model for humid gases and CCS mixtures}},
+  Author                   = {Gernert, Johannes and Span, Roland},
+  Journal                  = {J. Chem. Thermodyn.},
+  Year                     = {2016},
+  Pages                    = {274--293},
+  Volume                   = {93},
+
+  Doi                      = {10.1016/j.jct.2015.05.015},
+  Publisher                = {Elsevier}
+}
+
+@Article{Ghosh-FPE-2003,
+	Title = {Gas solubility in hydrocarbons-a SAFT-based approach},
+	Volume = {209},
+	Url = {https://www.sciencedirect.com/science/article/pii/S037838120300147X},
+	Doi = {10.1016/S0378-3812(03)00147-X},
+	Number = {2},
+	Journal = {Fluid Phase Equilibria},
+	Author = {Ghosh, Auleen and Chapman, Walter G and French, Ray N},
+	Month = jul,
+	Year = {2003},
+	Pages = {229--243},
+}
+
+@Article{Gross-IECR-2001,
+	Title = {{Perturbed-Chain SAFT:  An Equation of State Based on a Perturbation Theory for Chain Molecules}},
+	Volume = {40},
+	Url = {https://doi.org/10.1021/ie0003887},
+	Doi = {10.1021/ie0003887},
+	Number = {4},
+	Journal = {Industrial \& Engineering Chemistry Research},
+	Author = {Gross, Joachim and Sadowski, Gabriele},
+	Month = {feb},
+	Year = {2001},
+	Pages = {1244--1260},
+}
+
+@Article{Gross-IECR-2002,
+	Title = {{Application of the Perturbed-Chain SAFT Equation of State to Associating Systems}},
+	Volume = {41},
+	Url = {https://doi.org/10.1021/ie010954d},
+	Doi = {10.1021/ie010954d},
+	Number = {22},
+	Journal = {Industrial \& Engineering Chemistry Research},
+	Author = {Gross, Joachim and Sadowski, Gabriele},
+	Month = {oct},
+	year = {2002},
+	pages = {5510--5515},
+}
+
+@Article{Guder-JPCRD-2009,
+  Title                    = {{A Reference Equation of State for the Thermodynamic Properties of Sulfur Hexafluoride SF6 for Temperatures from the Melting Line to 625 K and Pressures up to 150 MPa}},
+  Author                   = {C. Guder and W. Wagner},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2009},
+  Number                   = {1},
+  Pages                    = {33-94},
+  Volume                   = {38},
+
+  Doi                      = {10.1063/1.3037344},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Guo-1997,
+  Title                    = {{Viscosity model based on equations of state for hydrocarbon liquids and gases}},
+  Author                   = {X.-Q. Guo and L.-S. Wang and S.-X. Rong and T.-M. Guo},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {1997},
+  Pages                    = {405-421},
+  Volume                   = {139},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.03}
+}
+
+@Article{Hands-CRYO-1981,
+  Title                    = {{A Correlation of Thermal Conductivity Data for Helium}},
+  Author                   = {B.A. Hands and V.D. Arp},
+  Journal                  = {Cryogenics},
+  Year                     = {1981},
+  Number                   = {12},
+  Pages                    = {697-703},
+  Volume                   = {21},
+
+  Doi                      = {10.1016/0011-2275(81)90211-3},
+  Owner                    = {Belli},
+  Timestamp                = {2013.08.05}
+}
+
+@Article{Heide-IJR-1997,
+  Title                    = {{The surface tension of HFC refrigerants and mixtures}},
+  Author                   = {R. Heide},
+  Journal                  = {Int. J. Refrig.},
+  Year                     = {1997},
+  Pages                    = {496-503},
+  Volume                   = {20},
+
+  Doi                      = {10.1016/S0140-7007(97)00044-3},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Held-CERD-2014,
+	Title = {{ePC-SAFT revised}},
+	Volume = {92},
+	Url = {https://www.sciencedirect.com/science/article/pii/S0263876214002469},
+	Doi = {10.1016/j.cherd.2014.05.017},
+	Number = {12},
+	Journal = {Chemical Engineering Research and Design},
+	Author = {Held, Christoph and Reschke, Thomas and Mohammad, Sultan and Luza, Armando and Sadowski, Gabriele},
+	Month = {dec},
+	Year = {2014},
+	Pages = {2884--2897},
+}
+
+@Article{Herrig-JPCRD-2019,
+  Title                    = {{A Reference Equation of State for Heavy Water}},
+  Author                   = {S. Herrig and M. Thol and R. Span and A.H. Harvey and E.W. Lemmon},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2019},
+}
+
+@TechReport{Herrmann-2009,
+  Title                    = {ASHRAE RP-1485: Thermodynamic Properties of Real Moist Air, Dry Air, Steam, Water, and Ice},
+  Author                   = {S. Herrmann and H.-J. Kretzschmar and D.P. Gatley},
+  Institution              = {ASHRAE},
+  Year                     = {2009},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.05.29}
+}
+
+@Article{Herrmann2009,
+  Title                    = {{Thermodynamic Properties of Real Moist Air, Dry Air, Steam, Water, and Ice (RP-1485)}},
+  Author                   = {Herrmann, Sebastian and Kretzschmar, Hans-Joachim and Gatley, Donald P.},
+  Journal                  = {{HVAC\&R Research}},
+  Year                     = {2009},
+  Number                   = {5},
+  Pages                    = {961--986},
+  Volume                   = {15},
+
+  Doi                      = {10.1080/10789669.2009.10390874},
+  Eprint                   = { http://www.tandfonline.com/doi/pdf/10.1080/10789669.2009.10390874 },
+  Owner                    = {jowr},
+  Timestamp                = {2014.10.09}
+}
+
+@Article{Holland-JPCRD-1983,
+  Title                    = {{A Correlation of the Viscosity and Thermal Conductivity Data of Gaseous and Liquid Ethylene}},
+  Author                   = {P.M. Holland and B.E. Eaton and H.J.M. Hanley},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {1983},
+  Number                   = {4},
+  Pages                    = {917-932},
+  Volume                   = {12},
+
+  Doi                      = {10.1063/1.555701},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@InBook{Huber-1996,
+  Title                    = {{The Corresponding-States Principle: Dense Fluids}},
+  Author                   = {M.L. Huber and H.J.M. Hanley},
+  Chapter                  = {12},
+  Editor                   = {Jurgen Millat and J.H. Dymond and C.A. Nieto de Castro},
+  Pages                    = {283-309},
+  Publisher                = {Cambridge University Press},
+  Year                     = {1996},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.05.29}
+}
+
+@Article{Huber-FPE-2005,
+  Title                    = {{Thermal conductivity correlations for minor constituent fluids in natural gas: n-octane, n-nonane and n-decane}},
+  Author                   = {M.L. Huber and R.A. Perkins},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {2005},
+  Pages                    = {47-55},
+  Volume                   = {227},
+
+  Doi                      = {10.1016/j.fluid.2004.10.031},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.14}
+}
+
+@Article{Huber-JPCRD-2009,
+  Title                    = {{New International Formulation for the Viscosity of H2O}},
+  Author                   = {M.L. Huber and R.A. Perkins and A. Laesecke and D.G. Friend and J.V. Sengers and M.J Assael and I.M. Metaxa and E. Vogel and R. Mare{\v s} and K. Miyagawa},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2009},
+  Number                   = {2},
+  Pages                    = {101-125},
+  Volume                   = {38},
+
+  Doi                      = {10.1063/1.3088050},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Huber-FPE-1992,
+  Title                    = {{Prediction of Viscosity of Refrigerants and Refrigerant Mixtures}},
+  Author                   = {Marcia L. Huber and James F. Ely},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {1992},
+  Pages                    = {239-248},
+  Volume                   = {80},
+
+  Doi                      = {10.1016/0378-3812(92)87071-T},
+  Owner                    = {Belli},
+  Timestamp                = {2013.05.29}
+}
+
+@Article{Huber-IECR-2006,
+  Title                    = {{Correlation for the Viscosity of Pentafluoroethane (R125) from the Triple Point to 500 K at Pressures up to 60 MPa}},
+  Author                   = {Marcia L. Huber and Arno Laesecke},
+  Journal                  = {Ind. Eng. Chem. Res.},
+  Year                     = {2006},
+  Pages                    = {4447-4453},
+  Volume                   = {45},
+
+  Doi                      = {10.1021/ie051367l},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.13}
+}
+
+@Article{Huber-EF-2004,
+  Title                    = {{Transport Properties of n-Dodecane}},
+  Author                   = {Marcia L. Huber and Arno Laesecke and Richard Perkins},
+  Journal                  = {Energy \& Fuels},
+  Year                     = {2004},
+  Pages                    = {968-975},
+  Volume                   = {18},
+
+  Doi                      = {10.1021/ef034109e},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.10}
+}
+
+@Article{Huber-IECR-2003,
+  Title                    = {{Model for the Viscosity and Thermal Conductivity of Refrigerants, Including a New Correlation for the Viscosity of R134a}},
+  Author                   = {Marcia L. Huber and Arno Laesecke and Richard A. Perkins},
+  Journal                  = {Ind. Eng. Chem. Res.},
+  Year                     = {2003},
+  Pages                    = {3163-3178},
+  Volume                   = {42},
+
+  Doi                      = {10.1021/ie0300880},
+  Owner                    = {ibell},
+  Timestamp                = {2010.07.06}
+}
+
+@Article{Huber-FPE-2004,
+  Title                    = {{Viscosity correlations for minor constituent fluids in natural gas: n-octane, n-nonane and n-decane}},
+  Author                   = {Marcia L. Huber and Arno Laesecke and Hong Wei Xiang},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {2004},
+  Pages                    = {263-270},
+  Volume                   = {224},
+
+  Doi                      = {10.1016/j.fluid.2004.07.012},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.14}
+}
+
+@Article{Huber-EF-2009,
+  Title                    = {{Model for the Thermodynamic Properties of a Biodiesel Fuel}},
+  Author                   = {Marcia L. Huber and Eric W. Lemmon and Andrei Kazakov and Lisa S. Ott and Thomas J. Bruno},
+  Journal                  = {Energy \& Fuels},
+  Year                     = {2009},
+  Pages                    = {3790-3797},
+  Volume                   = {23},
+
+  Doi                      = {10.1021/ef900159g},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Huber-JPCRD-2012,
+  Title                    = {{New International Formulation for the Thermal Conductivity of H2O}},
+  Author                   = {M. L. Huber and R. A. Perkins and D. G. Friend and J. V. Sengers and M. J. Assael and I. N. Metaxa and K. Miyagawa and R. Hellmann and E. Vogel},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2012},
+  Number                   = {3},
+  Pages                    = {033102-1:23},
+  Volume                   = {41},
+
+  Doi                      = {10.1063/1.4738955},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Misc{IAPWS-Melting-2011,
+  Title                    = {{2011 Revised Release on the Pressure along the Melting and Sublimation Curves of Ordinary Water Substance}},
+
+  Author                   = {IAPWS},
+  Year                     = {2011},
+
+  Institution              = {{IAPWS}},
+  Organization             = {{IAPWS}},
+  Owner                    = {Belli},
+  Timestamp                = {2014.10.02}
+}
+
+@Misc{IAPWS-D2O-2007-Transport,
+  Title                    = {Revised Release on Viscosity and Thermal Conductivity of Heavy Water Substance},
+
+  Author                   = {IAPWS},
+  Year                     = {2007},
+
+  Owner                    = {Belli},
+  Timestamp                = {2015.05.01}
+}
+
+@Misc{IAPWS-IF97-2012,
+  author = {IAPWS},
+  title  = {{Revised Release on the IAPWS Industrial Formulation 1997 for the Thermodynamic Properties of Water and Steam, revision 7}},
+  year   = {2012},
+}
+
+@Article{Jacobsen-FPE-1992,
+  Title                    = {{A Fundamental Equation for Trichlorofluoromethane (R-11)}},
+  Author                   = {R.T Jacobsen and S.G. Penoncello and E.W. Lemmon},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {1992},
+  Pages                    = {45-56},
+  Volume                   = {80},
+
+  Doi                      = {10.1016/0378-3812(92)87054-Q},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.10}
+}
+
+@Article{Jaeschke-IJT-1995,
+  Title                    = {{Ideal-Gas Thermodynamic Properties for Natural-Gas Applications}},
+  Author                   = {M. Jaeschke and P. Schley},
+  Journal                  = {Int. J. Thermophys.},
+  Year                     = {1995},
+  Number                   = {6},
+  Pages                    = {1381-1392},
+  Volume                   = {16},
+
+  Doi                      = {10.1007/BF02083547},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Manual{Jones2001,
+  Title                    = {{SciPy}: Open source scientific tools for {Python}},
+  Author                   = {Eric Jones and Travis Oliphant and Pearu Peterson and others},
+  Year                     = {2001--},
+
+  Owner                    = {jowr},
+  Timestamp                = {2014.09.24},
+  Url                      = {http://www.scipy.org/}
+}
+
+@Article{Kamei-IJT-1995,
+  Title                    = {{Application of Nonlinear Regression in the Development of a Wide Range Formulation for HCFC-22}},
+  Author                   = {A. Kamei and S. W. Beyerlein and R. T Jacobsen},
+  Journal                  = {Int. J. Thermophys.},
+  Year                     = {1995},
+  Number                   = {5},
+  Pages                    = {1155-1164},
+  Volume                   = {16},
+
+  Doi                      = {10.1007/BF02081283},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Katti-ACE-1986,
+  Title                    = {{Thermodynamic Properties of Neon for Temperatures from the Triple Point to 700 K at Pressures to 700 MPa}},
+  Author                   = {R. Katti and R.T. Jacobsen and R.B. Stewart and M. Jehangiri},
+  Journal                  = {Advances in Cryogenic Engineering},
+  Year                     = {1986},
+  Pages                    = {1189-1197},
+  Volume                   = {31},
+
+  Doi                      = {10.1007/978-1-4613-2213-9_132},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.30}
+}
+
+@TechReport{Kauffeld2001,
+  Title                    = {{RP-1166---Behavior of Ice Slurries in Thermal Storage Systems}},
+  Author                   = {Michael Kauffeld},
+  Institution              = {{Danish Technological Institute}},
+  Year                     = {2001},
+  Note                     = {{Sponsored by ASHRAE Technical Committee 6.9 Thermal Storage}},
+
+  Owner                    = {jowr},
+  Timestamp                = {2014.09.22}
+}
+
+@Article{Kim-IJR-2008,
+  Title                    = {{Cooling performance of several CO2/propane mixtures and glide matching with secondary heat transfer fluid}},
+  Author                   = {Ju Hyok Kim and Jin Min Cho and Min Soo Kim},
+  Journal                  = {Int. J. Refrig.},
+  Year                     = {2008},
+  Pages                    = {800-806},
+  Volume                   = {31},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.10}
+}
+
+@Article{Kiselev-1998,
+  Title                    = {{Transport properties of carbon dioxide+ethane and methane+ethane mixtures in the extended critical region}},
+  Author                   = {S.B. Kiselev and M.L. Huber},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {1998},
+  Pages                    = {253-280},
+  Volume                   = {142},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.03}
+}
+
+@Article{Kiselev-1999,
+  Title                    = {{Transport properties of refrigerants R32, R125, R134a, and R125+R32 mixtures in and beyond the critical region}},
+  Author                   = {S.B. Kiselev and R.A. Perkins and M.L. Huber},
+  Journal                  = {Int. J. Refrig.},
+  Year                     = {1999},
+  Pages                    = {509-520},
+  Volume                   = {22},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.03}
+}
+
+@Article{Kiselev-IECR-2005,
+  Title                    = {{Generalized SAFT-DFT/DMT Model for the Thermodynamic, Interfacial, and Transport Properties of Associating Fluids: Application for n-Alkanols}},
+  Author                   = {S. B. Kiselev and J. F. Ely and I. M. Abdulagatov and M. L. Huber},
+  Journal                  = {Ind. Eng. Chem. Res.},
+  Year                     = {2005},
+  Pages                    = {6916-6927},
+  Volume                   = {44},
+
+  Doi                      = {10.1021/ie050010e},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.14}
+}
+
+@Article{Kiselev-1997,
+  Title                    = {{Thermodynamic and Transport Properties of Fluids and Fluid Mixtures in the Extended Critical Region}},
+  Author                   = {S. B. Kiselev and V. D. Kulikov},
+  Journal                  = {lnternational Journal of Thermophysics},
+  Year                     = {1997},
+  Number                   = {5},
+  Pages                    = {1143-1182},
+  Volume                   = {18},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.03}
+}
+
+@Article{Klein-IJR-1997,
+  Title                    = {{An improved extended corresponding states method for estimation of viscosity of pure refrigerants and mixtures}},
+  Author                   = {S.A. Klein and M.O. McLinden and A. Laesecke},
+  Journal                  = {Int. J. Refrig.},
+  Year                     = {1997},
+  Pages                    = {208-217},
+  Volume                   = {20},
+
+  Doi                      = {10.1016/S0140-7007(96)00073-4},
+  Owner                    = {Belli},
+  Timestamp                = {2014.12.06}
+}
+
+@Article{Kleiner-JPCC-2007,
+	Title = {{Modeling of Polar Systems Using PCP-SAFT: An Approach to Account for Induced-Association Interactions}},
+	Volume = {111},
+	Url = {https://doi.org/10.1021/jp072640v},
+	Doi = {10.1021/jp072640v},
+	Number = {43},
+	Journal = {The Journal of Physical Chemistry C},
+	Author = {Kleiner, Matthias and Sadowski, Gabriele},
+	Month = {nov},
+	Year = {2007},
+	Pages = {15544--15553},
+}
+
+@Article{Kondou-IJR-2015,
+  Title                    = {{Surface tension of low GWP refrigerants R1243zf, R1234ze(Z), and R1233zd(E)}},
+  Author                   = {Chieko Kondou and Ryuichi Nagata and Noriko Nii and Shigeru Koyama and Yukihiro Higashi},
+  Journal                  = {Int. J. Refrig.},
+  Year                     = {2015},
+  Pages                    = {80-89},
+  Volume                   = {53},
+
+  Doi                      = {10.1016/j.ijrefrig.2015.01.005},
+  Owner                    = {Belli},
+  Timestamp                = {2015.07.20}
+}
+
+@Article{Kostic2006,
+  Title                    = {{Analysis of Enthalpy Approximation for Compressed Liquid Water}},
+  Author                   = {Milivoje M. Kostic},
+  Journal                  = {Journal of Heat Transfer},
+  Year                     = {2006},
+  Number                   = {5},
+  Pages                    = {421--426},
+  Volume                   = {128},
+
+  Doi                      = {10.1115/1.2175090},
+  Owner                    = {jowr},
+  Timestamp                = {2014.12.16}
+}
+
+@Article{Krauss-IJT-1996,
+  Title                    = {{Transport Properties of 1,1-Difluoroethane (R152a)}},
+  Author                   = {R. Krauss and I V. C. Weiss and T. A. Edison and J. V. Sengers and K. Stephan},
+  Journal                  = {Int. J. Thermophys},
+  Year                     = {1996},
+  Pages                    = {731-757},
+  Volume                   = {17},
+
+  Doi                      = {10.1007/BF01439187},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.28}
+}
+
+@Unpublished{ZITTAU,
+  Title                    = {{Hochschule Zittau Thermophysical Property Libraries}},
+  Author                   = {Hans-Joachim Kretzschmar and Ines St{\"o}cker},
+  Note                     = {http://thermodynamik.hs-zigr.de/cmsfg/Stoffwertbibliothek/index.php},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.08.05}
+}
+
+@InProceedings{Kretzschmar-PWS-1990,
+  Title                    = {{An Alternative Method for the Numerical Calculation of the Maxwell Criterion in Vapour Pressure Computations}},
+  Author                   = {H.-J. Kretzschmar and T. Zschunke and J. Klinger and A. Dittman},
+  Booktitle                = {Properties Of Water And Steam: Proceedings Of The 11th International conference},
+  Year                     = {1990},
+
+  Owner                    = {ihb},
+  Timestamp                = {2015.07.20}
+}
+
+@Book{Kunz-BOOK-2007,
+  Title                    = {{The GERG-2004 Wide-Range Equation of State for Natural Gases and Other Mixtures}},
+  Author                   = {O. Kunz and R. Klimeck and W. Wagner and M. Jaeschke},
+  Publisher                = {VDI Verlag GmbH, D{\"u}sseldorf},
+  Year                     = {2007},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.07}
+}
+
+@Article{Kunz-JCED-2012,
+  Title                    = {{The GERG-2008 Wide-Range Equation of State for Natural Gases and Other Mixtures: An Expansion of GERG-2004}},
+  Author                   = {O. Kunz and W. Wagner},
+  Journal                  = {J. Chem. Eng. Data},
+  Year                     = {2012},
+  Pages                    = {3032-3091},
+  Volume                   = {57},
+
+  Doi                      = {10.1021/je300655b},
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.07}
+}
+
+@Article{Laesecke-2001,
+  Title                    = {{Saturated-Liquid Viscosity of Ten Binary and Ternary Alternative Refrigerant Mixtures. Part I: Measurements}},
+  Author                   = {Arno Laesecke and Richard F. Hafer and Dylan J. Morris},
+  Journal                  = {J. Chem. Eng. Data},
+  Year                     = {2001},
+  Pages                    = {433-445},
+  Volume                   = {46},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.03}
+}
+
+@Article{Laesecke-IJR-1996,
+  Title                    = {{An improved correlation for the thermal conductivity of HCFC123 (2,2-dichloro-1,1,1-trifluoroethane)}},
+  Author                   = {Arno Laesecke and Richard A. Perkins and John B. Howley},
+  Journal                  = {Int. J. Refrig.},
+  Year                     = {1996},
+  Number                   = {4},
+  Pages                    = {231-238},
+  Volume                   = {19},
+
+  Doi                      = {10.1016/0140-7007(96)00019-9},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.13}
+}
+
+@Article{Latini-1999,
+  Title                    = {{A New Approach to the Evaluation of Transport Properties of Azeotropic and Quasi-Azeotropic Refrigerant Mixtures}},
+  Author                   = {G. Latini and G. Passerini and F. Polonara},
+  Journal                  = {Int. J. Thermophys},
+  Year                     = {1999},
+  Number                   = {1},
+  Pages                    = {73-84},
+  Volume                   = {20},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.03}
+}
+
+@Article{Leachman-JPCRD-2009,
+  Title                    = {{Fundamental Equations of State for Parahydrogen, Normal Hydrogen, and Orthohydrogen}},
+  Author                   = {J.W. Leachman and R.T. Jacobsen and S.G. Penoncello and E.W. Lemmon},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2009},
+  Number                   = {3},
+  Pages                    = {721-748},
+  Volume                   = {38},
+
+  Doi                      = {10.1063/1.3160306},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.09}
+}
+
+@Article{Lemmon-IJT-2003,
+  Title                    = {{Pseudo-Pure Fluid Equations of State for the Refrigerant Blends R-410A, R-404A, R-507A, and R-407C}},
+  Author                   = {E.W. Lemmon},
+  Journal                  = {Int. J. Thermophys.},
+  Year                     = {2003},
+  Number                   = {4},
+  Pages                    = {991-1006},
+  Volume                   = {24},
+
+  Doi                      = {10.1023/A:1025048800563},
+  File                     = {:D\:\\My_Documents\\Library\\Papers\\Lemmon 2003.pdf:PDF},
+  Keywords                 = {EOS},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Misc{Lemmon-RP-2010,
+  Title                    = {{NIST Standard Reference Database 23: Reference Fluid Thermodynamic and Transport Properties-REFPROP, Version 9.0}},
+
+  Author                   = {E.W. Lemmon and M.L. Huber and M.O. McLinden},
+  Year                     = {2010},
+
+  Owner                    = {ibell},
+  Timestamp                = {2011.03.05}
+}
+
+@Article{Lemmon-JPCRD-2000,
+  Title                    = {{Thermodynamic Properties of Air and Mixtures of Nitrogen, Argon, and Oxygen from 60 to 2000 K at Pressures to 2000 MPa}},
+  Author                   = {Eric W. Lemmon and Richard T. Jacobsen and Steven G. Penoncello and Daniel G. Friend},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2000},
+  Number                   = {3},
+  Pages                    = {331-385},
+  Volume                   = {29},
+
+  Doi                      = {10.1063/1.1285884},
+  File                     = {:D\:\\My_Documents\\Library\\Papers\\Lemmon 2000.pdf:PDF},
+  Keywords                 = {EOS},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Unpublished{Lemmon-PROPYLENE-2013,
+  Title                    = {{Equation of state for propylene}},
+  Author                   = {E.W. Lemmon and U. Overhoff and M.O. McLinden and W. Wagner},
+  Note                     = {Personal communication with Eric Lemmon},
+  Year                     = {2010},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.10}
+}
+
+@Article{Lemmon-JCED-2006,
+  Title                    = {{Short Fundamental Equations of State for 20 Industrial Fluids}},
+  Author                   = {E.W. Lemmon and R. Span},
+  Journal                  = {J. Chem. Eng. Data},
+  Year                     = {2006},
+  Pages                    = {785-850},
+  Volume                   = {51},
+
+  Doi                      = {10.1021/je050186n},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@PhdThesis{Lemmon-THESIS-1996,
+  Title                    = {{A Generalized Model for the Prediction of the Thermodynamic Properties of Mixtures Including Vapor-Liquid Equilibrium}},
+  Author                   = {Eric W. Lemmon},
+  School                   = {University of Idaho, Moscow},
+  Year                     = {1996},
+
+  Owner                    = {ihb},
+  Timestamp                = {2015.07.20}
+}
+
+@Article{Lemmon-EF-2004,
+  Title                    = {{Thermodynamic Properties of n-Dodecane}},
+  Author                   = {Eric W. Lemmon and Marcia L. Huber},
+  Journal                  = {Energy \& Fuels},
+  Year                     = {2004},
+  Pages                    = {960-967},
+  Volume                   = {18},
+
+  Doi                      = {10.1021/ef0341062},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.09}
+}
+
+@Article{Lemmon-FPE-2005,
+  Title                    = {{Thermodynamic properties of the butenes Part II. Short fundamental equations of state}},
+  Author                   = {Eric W. Lemmon and E. Christian Ihmels},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {2005},
+  Pages                    = {173-187},
+  Volume                   = {228-229},
+
+  Doi                      = {10.1016/j.fluid.2004.09.004},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Lemmon-JPCRD-2005,
+  Title                    = {{A New Functional Form and New Fitting Techniques for Equations of State with Application to Pentafluoroethane (HFC-125)}},
+  Author                   = {Eric W. Lemmon and Richard T Jacobsen},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2005},
+  Number                   = {1},
+  Pages                    = {69-108},
+  Volume                   = {34},
+
+  Doi                      = {10.1063/1.1797813},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.13}
+}
+
+@Article{Lemmon-IJT-2004,
+  Title                    = {{Viscosity and Thermal Conductivity Equations for Nitrogen, Oxygen, Argon, and Air}},
+  Author                   = {E. W. Lemmon and R. T Jacobsen},
+  Journal                  = {Int. J. Thermophys.},
+  Year                     = {2004},
+  Number                   = {1},
+  Pages                    = {21-69},
+  Volume                   = {25},
+
+  Comment                  = {Critical enhancement included},
+  Doi                      = {10.1023/B:IJOT.0000022327.04529.f3},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Lemmon-JPCRD-2004,
+  Title                    = {{Equations of State for Mixtures of R-32, R-125, R-134a, R-143a, and R-152a}},
+  Author                   = {Eric W. Lemmon and Richard T. Jacobsen},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2004},
+  Number                   = {2},
+  Pages                    = {593-620},
+  Volume                   = {33},
+
+  Doi                      = {10.1063/1.1649997},
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.07}
+}
+
+@Article{LemmonJacobsen-JPCRD-2000,
+  Title                    = {{An International Standard Formulation for the Thermodynamic Properties of 1,1,1-Trifluoroethane (HFC-143a) for Temperatures From 161 to 450 K and Pressures to 50 MPa}},
+  Author                   = {Eric W. Lemmon and Richard T. Jacobsen},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2000},
+  Number                   = {4},
+  Pages                    = {521-552},
+  Volume                   = {29},
+
+  Doi                      = {10.1063/1.1318909},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.09}
+}
+
+@Article{Lemmon-IJT-1999,
+  Title                    = {{A Generalized Model for the Thermodynamic Properties of Mixtures}},
+  Author                   = {E. W. Lemmon and R. T Jacobsen},
+  Journal                  = {Int. J. Thermophys.},
+  Year                     = {1999},
+  Number                   = {3},
+  Pages                    = {825-835},
+  Volume                   = {20},
+
+  Doi                      = {10.1023/A:1022627001338},
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.07}
+}
+
+@InProceedings{Lemmon-Paderborn-2001,
+  Title                    = {{Method for Estimating Mixture Equation of State Parameters}},
+  Author                   = {Eric W. Lemmon and Mark O. McLinden},
+  Booktitle                = {Thermophysical Properties and Transfer Processes of New Refrigerants, Paderborn, Germany},
+  Year                     = {2001},
+
+  Owner                    = {ihb},
+  Timestamp                = {2015.07.20}
+}
+
+@Article{Lemmon-JCED-2009,
+  Title                    = {{Thermodynamic Properties of Propane. III. A Reference Equation of State for Temperatures from the Melting Line to 650 K and Pressures up to 1000 MPa}},
+  Author                   = {Eric W. Lemmon and Mark O. McLinden and Wolfgang Wagner},
+  Journal                  = {J. Chem. Eng. Data},
+  Year                     = {2009},
+  Pages                    = {3141-3180},
+  Volume                   = {54},
+
+  Doi                      = {10.1021/je900217v},
+  Owner                    = {Belli},
+  Timestamp                = {2013.03.19}
+}
+
+@Article{Lemmon-JCED-2016-365227,
+  Title                    = {{Thermodynamic Properties of R-227ea, R-365mfc, R-115, and R13I1}},
+  Author                   = {Eric W. Lemmon and Roland Span},
+  Journal                  = {J. Chem. Eng. Data},
+  Year                     = {2016, submitted},
+
+  Doi                      = {10.1021/acs.jced.5b00684},
+  Owner                    = {Belli},
+  Timestamp                = {2015.11.24}
+}
+
+@Article{Lemmon-FPE-1999,
+  author    = {Eric W. Lemmon and Reiner Tillner-Roth},
+  journal   = {Fluid Phase Equilib.},
+  title     = {{A Helmholtz energy equation of state for calculating the thermodynamic properties of fluid mixtures}},
+  year      = {1999},
+  pages     = {1-21},
+  volume    = {165},
+  doi       = {10.1016/S0378-3812(99)00262-9},
+  owner     = {ihb},
+  timestamp = {2015.07.20},
+}
+
+@Article{Llovell-JPCB-2013,
+  Title                    = {{Transport Properties of Mixtures by the Soft-SAFT + Free-Volume Theory: Application to Mixtures of n-Alkanes and Hydrofluorocarbons}},
+  Author                   = {F. Llovell and R. M. Marcos and L. F. Vega},
+  Journal                  = {J. Phys. Chem. B},
+  Year                     = {2013},
+  Pages                    = {5195-5205},
+  Volume                   = {117},
+
+  Doi                      = {10.1021/jp401754r},
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.07}
+}
+
+@Article{Marsh-JCED-2002,
+  Title                    = {{Measurement and Correlation of the Thermal Conductivity of Propane from 86 K to 600 K at Pressures to 70 MPa}},
+  Author                   = {Kenneth N. Marsh and Richard A. Perkins and Maria L. V. Ramires},
+  Journal                  = {J. Chem. Eng. Data},
+  Year                     = {2002},
+  Pages                    = {932-940},
+  Volume                   = {47},
+
+  Doi                      = {10.1021/je010001m},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Book{Marx-BOOK-1992,
+  Title                    = {{Neue Zustandsgleichung f\"{u}r R 12, R 22, R 11 und R 113 - Beschreibung des therodynamischen Zustandsverhaltens bei Temperaturen bis 525 K und Dru\"{u}cken bis 200 MPa}},
+  Author                   = {Volker Marx and Andreas Pruss and Wolfgang Wagner},
+  Publisher                = {VDI Verlag},
+  Year                     = {1992},
+  Number                   = {57},
+  Volume                   = {19},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.05.20}
+}
+
+@Article{McLinden-IJR-2000,
+  Title                    = {{An extended corresponding states model for the thermal conductivity of refrigerants and refrigerant mixtures}},
+  Author                   = {Mark O. McLinden and Sanford A. Klein and Richard A. Perkins},
+  Journal                  = {Int. J. Refrig.},
+  Year                     = {2000},
+  Pages                    = {43-63},
+  Volume                   = {23},
+
+  Doi                      = {10.1016/S0140-7007(99)00024-9},
+  Owner                    = {ibell},
+  Timestamp                = {2010.07.06}
+}
+
+@Article{McLinden-JCED-2015-Novec649,
+  Title                    = {{Thermodynamic Properties of 1,1,1,2,2,4,5,5,5-nonafluoro-4-(trifluoromethyl)-3-pentanone: Vapor Pressure, (p, $\rho$, T) Behavior, and Speed of Sound Measurements, and Equation of State}},
+  Author                   = {Mark O. McLinden and Richard A. Perkins and Eric W. Lemmon and Tara J. Fortin},
+  Journal                  = {J. Chem. Eng. Data},
+  Year                     = {2015},
+  Number                   = {12},
+  Pages                    = {3646-3659},
+  Volume                   = {60},
+
+  Doi                      = {10.1021/acs.jced.5b00623},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.09}
+}
+
+@InProceedings{McLinden-PURDUE-2010,
+  Title                    = {{Thermodynamic Properties of trans-1,3,3,3-tetrafluoropropene [R1234ze(E)]: Measurements of Density and Vapor Pressure and a Comprehensive Equation of State}},
+  Author                   = {Mark O. McLinden and Monika Thol and Eric W. Lemmon},
+  Booktitle                = {International Refrigeration and Air Conditioning Conference at Purdue, July 12-15, 2010},
+  Year                     = {2010},
+
+  Comment                  = {The constants as written in the paper are not the most up-to-date EOS constants. REFPROP 9.1 contains the updated coefficients and they are used with permission. Also the sign of the terms for eta_k and beta_k should be inverted in the table},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Book{Melinder2010,
+  Title                    = {{Properties of Secondary Working Fluids for Indirect Systems}},
+  Author                   = {{\AA}ke Melinder},
+  Publisher                = {IIF-IIR Publishing},
+  Year                     = {2010},
+
+  Owner                    = {jowr},
+  Timestamp                = {2014.09.17}
+}
+
+@Book{Melinder-BOOK-2010,
+  Title                    = {{Properties of Secondary Working Fluids for Indirect Systems}},
+  Author                   = {{\r{A}}ke Melinder},
+  Publisher                = {IIF-IIR Publishing},
+  Year                     = {2010}
+}
+
+@Article{Meng-JCED-2012,
+  Title                    = {{Experimental Measurement and Modeling of the Viscosity of Dimethyl Ether}},
+  Author                   = {Xianyang Meng and Jianbo Zhang and Jiangtao Wu and Zhigang Liu},
+  Journal                  = {J. Chem. Eng. Data},
+  Year                     = {2012},
+  Pages                    = {988-993},
+  Volume                   = {57},
+
+  Comment                  = {Erratum: Limits for deltaeta_r sums should be 0-3 and 4-9. The correct order of terms based on the original indices are 0,1,7,9,2,3,4,5,6,8},
+  Doi                      = {10.1021/je201297j},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.09}
+}
+
+@Article{Michailidou-JPCRD-2014-Heptane,
+  Title                    = {{Reference Correlation of the Viscosity of n-Heptane from the Triple Point to 600 K and up to 248 MPa}},
+  Author                   = {E. K. Michailidou and M. J. Assael and M. L. Huber and I. M. Abdulagatov and R. A. Perkins},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2014},
+  Pages                    = {023103},
+  Volume                   = {43},
+
+  Doi                      = {10.1063/1.4875930},
+  Owner                    = {Belli},
+  Timestamp                = {2014.06.10}
+}
+
+@Article{Michailidou-JPCRD-2013-Hexane,
+  Title                    = {{Reference Correlation of the Viscosity of n-Hexane from the Triple Point to 600 K and up to 100 MPa}},
+  Author                   = {E. K. Michailidou and M. J. Assael and M. L. Huber and R. A. Perkins},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2013},
+  Number                   = {3},
+  Pages                    = {033104:1-12},
+  Volume                   = {42},
+
+  Doi                      = {10.1063/1.4818980},
+  Owner                    = {Belli},
+  Timestamp                = {2013.09.21}
+}
+
+@Article{Michels-PHYSICA-1962,
+  Title                    = {{The Melting Lines of Argon, Krypton and Xenon up to 1500 atm; Representation of the Results by a Law of Corresponding States}},
+  Author                   = {A. Michels and C. Prins},
+  Journal                  = {Physica},
+  Year                     = {1962},
+  Pages                    = {101-116},
+  Volume                   = {28},
+
+  Doi                      = {10.1016/0031-8914(62)90096-4},
+  Owner                    = {Belli},
+  Timestamp                = {2014.10.02}
+}
+
+@Book{Michelsen-BOOK-2007,
+  Title                    = {{Thermodynamic Models: Fundamentals \& Computational Aspects}},
+  Author                   = {Michael L. Michelsen and J{\o}rgen M. Mollerup},
+  Publisher                = {Tie-Line Publications},
+  Year                     = {2007},
+
+  Owner                    = {ihb},
+  Timestamp                = {2015.05.01}
+}
+
+@Article{Miqueu-2000,
+  Title                    = {{An extended scaled equation for the temperature dependence of the surface tension of pure compounds inferred from an analysis of experimental data}},
+  Author                   = {C. Miqueu and D. Broseta and J. Satherley and B. Mendiboure and J. Lachaise and A. Graciaa},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {2000},
+  Pages                    = {169-182},
+  Volume                   = {172},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.23}
+}
+
+@Article{Mondejar-JCED-2015-R1233zdE,
+  Title                    = {{Thermodynamic Properties of trans-1-Chloro-3,3,3-trifluoropropene (R1233zd(E)): Vapor Pressure, ($p$, $\rho$, $T$) Behavior, and Speed of Sound Measurements, and Equation of State}},
+  Author                   = {Mar{\'i}a E. Mondej{\'a}r and Mark O. McLinden and Eric W. Lemmon},
+  Journal                  = {J. Chem. Eng. Data},
+  Year                     = {2015},
+  Pages                    = {2477-2489},
+  Volume                   = {60},
+
+  Doi                      = {10.1021/acs.jced.5b00348},
+  Owner                    = {Belli},
+  Timestamp                = {2015.10.23}
+}
+
+@Article{Monsalvo-2006,
+  Title                    = {{High-pressure viscosity behavior of x 1,1,1,2-tetrafluoroethane (HFC-134a)+(1-x) triethylene glycol dimethylether (TriEGDME) mixtures: Measurements and modeling}},
+  Author                   = {Mat{\'i}as A. Monsalvo and Antoine Baylaucq and Sergio E. Qui{\~n}ones-Cisneros and Christian Boned},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {2006},
+  Pages                    = {70-79},
+  Volume                   = {247},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.03}
+}
+
+@Article{Monsalvo-2005,
+  Title                    = {{Viscosity measurements and correlations of binary mixtures: 1,1,1,2-tetrafluoroethane (HFC-134a)+tetraethylene glycol dimethylether (TEGDME)}},
+  Author                   = {M.A. Monsalvo and A. Baylaucq and P. Reghem and S.E. Qui{\~n}ones-Cisnerosa and C. Boned},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {2005},
+  Pages                    = {1-8},
+  Volume                   = {233},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.03}
+}
+
+@Article{Mulero-JPCRD-2014,
+  Title                    = {{Recommended Correlations for the Surface Tension of Several Fluids Included in the REFPROP Program}},
+  Author                   = {A. Mulero and I. Cachadi{\~n}a},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2014},
+  Pages                    = {023104-1:8},
+  Volume                   = {43},
+
+  Doi                      = {10.1063/1.4878755},
+  Owner                    = {Belli},
+  Timestamp                = {2014.06.10}
+}
+
+@Article{Mulero-JPCRD-2012,
+  Title                    = {{Recommended Correlations for the Surface Tension of Common Fluids}},
+  Author                   = {A. Mulero and I. Cachadi{\~n}a and M. I. Parra},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2012},
+  Number                   = {4},
+  Pages                    = {043105-1:13},
+  Volume                   = {41},
+
+  Doi                      = {10.1063/1.4768782},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Muzny-JCED-2013,
+  author    = {Chris D. Muzny and Marcia L. Huber and Andrei F. Kazakov},
+  title     = {{Correlation for the Viscosity of Normal Hydrogen Obtained from Symbolic Regression}},
+  journal   = {J. Chem. Eng. Data},
+  year      = {2013},
+  comment   = {Errata : In equation 7, the exponent should be -i rather than -1. Equation 6 is missing Avogadro's number},
+  doi       = {10.1021/je301273j},
+  owner     = {Belli},
+  timestamp = {2013.04.10},
+}
+
+@Article{Mylona-JPCRD-2014-xylenes,
+  Title                    = {{Reference Correlations of the Thermal Conductivity of o-Xylene, m-Xylene, p-Xylene, and Ethylbenzene from the Triple Point to 700 K and Moderate Pressures}},
+  Author                   = {S. K. Mylona and K. D. Antoniadis and M. J. Assael and M. L. Huber and R. A. Perkins},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2014},
+  Pages                    = {043104},
+  Volume                   = {43},
+
+  Doi                      = {10.1063/1.4901166},
+  Owner                    = {Belli},
+  Timestamp                = {2014.12.10}
+}
+
+@Article{Nabizadeh-1999,
+  Title                    = {{Viscosity of Gaseous R404A, R407C, R410A, and R507}},
+  Author                   = {H. Nabizadeh and F. Mayinger},
+  Journal                  = {Int. J. Thermophys.},
+  Year                     = {1999},
+  Number                   = {3},
+  Pages                    = {777-790},
+  Volume                   = {20},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.03}
+}
+
+@Article{Neufeld-1972,
+  Title                    = {{Empirical Equations to Calculate 16 of the Transport Collision Integrals $\Omega^{(l,s)*}$ for the Lennard-Jones (12-6) Potential}},
+  Author                   = {Philip D. Neufeld and A. R. Janzen and R. A. Aziz},
+  Journal                  = {J. Chem. Phys.},
+  Year                     = {1972},
+  Number                   = {3},
+  Pages                    = {1100-1102},
+  Volume                   = {57},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.25}
+}
+
+@Article{Okada-IJT-1999,
+  Title                    = {{Surface Tension of HFC Refrigerant Mixtures}},
+  Author                   = {M. Okada and T. Shibata and Y. Sato and Y. Higashi},
+  Journal                  = {Int. J. Thermophys.},
+  Year                     = {1999},
+  Number                   = {1},
+  Pages                    = {119-127},
+  Volume                   = {20},
+
+  Doi                      = {10.1023/A:1021482231102},
+  Owner                    = {Belli},
+  Timestamp                = {2014.12.08}
+}
+
+@Article{Olchowy-IJT-1989,
+  Title                    = {{A Simplified Representation for the Thermal Conductivity of Fluids in the Critical Region}},
+  Author                   = {G. A. Olchowy and J. V. Sengers},
+  Journal                  = {Int. J. Thermophys.},
+  Year                     = {1989},
+  Number                   = {2},
+  Pages                    = {417-426},
+  Volume                   = {10},
+
+  Doi                      = {10.1007/BF01133538},
+  Owner                    = {Belli},
+  Timestamp                = {2013.05.27}
+}
+
+@Unpublished{OrtizVega-JPCRD-2019,
+  Title                    = {{Equation of state for Helium-4}},
+  Author                   = {D. O. Ortiz-Vega and K. R. Hall and J. C. Holste and V. D. Arp and A. H. Harvey and E. W. Lemmon},
+  Note                     = {Unpublished - coefficients from REPROP 10 with permission},
+  Year                     = {2019}
+}
+
+@Unpublished{OrtizVega-2010,
+  Title                    = {{Equation of state for Helium}},
+  Author                   = {D.O. Ortiz-Vega and K.R. Hall and V.D. Arp and E.W. Lemmon},
+  Note                     = {Unpublished - coefficients from REPROP with permission},
+  Year                     = {2013},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.08.05}
+}
+
+@Article{Outcalt-JPCRD-1996-R152A,
+  Title                    = {{A Modified Benedict-Webb-Rubin Equation of State for the Thermodynamic Properties of R152a (1,1-difluoroethane)}},
+  Author                   = {Stephanie L. Outcalt and Mark O. McLinden},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {1996},
+  Number                   = {2},
+  Pages                    = {605-636},
+  Volume                   = {25},
+
+  Doi                      = {10.1063/1.555979},
+  Owner                    = {Belli},
+  Timestamp                = {2014.10.02}
+}
+
+@Article{Patek2006,
+  Title                    = {{A computationally effective formulation of the thermodynamic properties of LiBr-H2O solutions from 273 to 500 K over full composition range}},
+  Author                   = {Jaroslav P\'atek and Jaroslav Klomfar},
+  Journal                  = {Int. J. Refrig.},
+  Year                     = {2006},
+
+  Month                    = {June},
+  Number                   = {4},
+  Pages                    = {566--578},
+  Volume                   = {29},
+
+  Doi                      = {10.1016/j.ijrefrig.2005.10.007},
+  Owner                    = {jowr},
+  Timestamp                = {2013.11.22}
+}
+
+@Article{Pan-FPE-2012,
+  Title                    = {{An equation of state for the thermodynamic properties of 1,1,1,3,3,3-hexafluoropropane (HFC-236fa)}},
+  Author                   = {Jiang Pan and Xinfang Rui and Xiaodong Zhao and Liming Qiu},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {2012},
+  Pages                    = {10-16},
+  Volume                   = {321},
+
+  Doi                      = {10.1016/j.fluid.2012.02.012},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.10}
+}
+
+@Article{Peng-IECF-1976,
+  Title                    = {{A New Two-Constant Equation of State}},
+  Author                   = {Ding-Yu Peng and Donald B. Robinson},
+  Journal                  = {Ind. Eng. Chem. Fundamen.},
+  Year                     = {1976},
+  Number                   = {1},
+  Pages                    = {59-64},
+  Volume                   = {15},
+
+  Doi                      = {10.1021/i160057a011},
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.07}
+}
+
+@Article{Penoncello-IJT-1995,
+  Title                    = {{A Thermodynamic Property Formulation for Cyclohexane}},
+  Author                   = {S. G. Penoncello and R. T Jacobsen and A. R. H. Goodwin},
+  Journal                  = {Int. J. Thermophys.},
+  Year                     = {1995},
+  Number                   = {2},
+  Pages                    = {519-531},
+  Volume                   = {16},
+
+  Doi                      = {10.1007/BF01441918},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Penoncello-JPCRD-2003,
+  Title                    = {{A Fundamental Equation for Trifluoromethane (R-23)}},
+  Author                   = {Steven G. Penoncello and Eric W. Lemmon and Richard T Jacobsen and Zhengjun Shan},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2003},
+  Number                   = {4},
+  Pages                    = {1473-1499},
+  Volume                   = {32},
+
+  Doi                      = {10.1063/1.1559671},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.09}
+}
+
+@Article{Perkins-JCED-2002-Isobutane,
+  Title                    = {{Measurement and Correlation of the Thermal Conductivity of Isobutane from 114 K to 600 K at Pressures to 70 MPa}},
+  Author                   = {R.A. Perkins},
+  Journal                  = {J. Chem. Eng. Data},
+  Year                     = {2002},
+  Number                   = {5},
+  Pages                    = {1272-1279},
+  Volume                   = {47},
+
+  Doi                      = {10.1021/je010121u},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Perkins-JCED-2011,
+  Title                    = {{Measurement and Correlation of the Thermal Conductivity of 2,3,3,3-Tetrafluoroprop-1-ene (R1234yf) and trans-1,3,3,3-Tetrafluoropropene (R1234ze(E))}},
+  Author                   = {Richard A. Perkins and Marcia L. Huber},
+  Journal                  = {J. Chem. Eng. Data},
+  Year                     = {2011},
+  Pages                    = {4868-4874},
+  Volume                   = {56},
+
+  Doi                      = {10.1021/je200811n},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.09}
+}
+
+@Article{Perkins-JCED-2006,
+  Title                    = {{Measurement and Correlation of the Thermal Conductivity of Pentafluoroethane (R125) from 190 K to 512 K at Pressures to 70 MPa}},
+  Author                   = {Richard A. Perkins and Marcia L. Huber},
+  Journal                  = {J. Chem. Eng. Data},
+  Year                     = {2006},
+  Pages                    = {898-904},
+  Volume                   = {51},
+
+  Doi                      = {10.1021/je050372t},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.13}
+}
+
+@Article{Perkins-JCED-2002-nButane,
+  Title                    = {{Measurement and Correlation of the Thermal Conductivity of Butane from 135 K to 600 K at Pressures to 70 MPa}},
+  Author                   = {R.A. Perkins and M.L.V. Ramires and C.A. Nieto de Castro and L. Cusco},
+  Journal                  = {J. Chem. Eng. Data},
+  Year                     = {2002.},
+  Number                   = {5},
+  Pages                    = {1263-1271},
+  Volume                   = {47},
+
+  Doi                      = {10.1021/je0101202},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Piazza-FPE-2013,
+  Title                    = {{An equation of state for methanol including the association term of SAFT}},
+  Author                   = {L. Piazza and R. Span},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {2013},
+  Pages                    = {12-24},
+  Volume                   = {349},
+
+  Doi                      = {10.1016/j.fluid.2013.03.024},
+  Owner                    = {Belli},
+  Timestamp                = {2014.02.02}
+}
+
+@Article{Piazza-FPE-2011,
+  Title                    = {{An equation of state for acetic acid including the association term of SAFT}},
+  Author                   = {L. Piazza and R. Span},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {2011},
+  Pages                    = {134-149},
+  Volume                   = {303},
+
+  Doi                      = {10.1016/j.fluid.2011.01.008},
+  Owner                    = {Belli},
+  Timestamp                = {2014.02.27}
+}
+
+@Book{Platzer-BOOK-1990,
+  Title                    = {{Thermophysical Properties of Refrigerants}},
+  Author                   = {B. Platzer and A. Polt and G. Maurer},
+  Publisher                = {Springer-Verlag},
+  Year                     = {1990},
+
+  Doi                      = {10.1007/978-3-662-02608-3},
+  Owner                    = {Belli},
+  Timestamp                = {2013.05.20}
+}
+
+@Book{Poling-BOOK-2001,
+  Title                    = {{The Properties of Gases and Liquids, 5th edition}},
+  Author                   = {Bruce E. Poling and John M. Prausnitz and John P. O'Connell},
+  Publisher                = {McGraw Hill},
+  Year                     = {2001},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Polt-CT-1992,
+  Title                    = {{Parameter der thermischen Zustandsgleichung von Bender f{\"u}r 14 mehratomige reine Stoffe}},
+  Author                   = {Axel Polt and Bernhard Platzer and Gerd Maurer},
+  Journal                  = {Chem. Technik},
+  Year                     = {1992},
+  Pages                    = {216-224},
+  Volume                   = {22},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.29}
+}
+
+@InBook{Preisegger2010,
+  Title                    = {{VDI Heat Atlas}},
+  Author                   = {Ewald Preisegger and Felix Flohr and Gernot Krakat and Andreas Gl{\"u}ck and Dietmar Hunold},
+  Chapter                  = {D4 Properties of Industrial Heat Transfer Media},
+  Editor                   = {Peter Stephan},
+  Pages                    = {419--512},
+  Publisher                = {Springer},
+  Year                     = {2010},
+
+  Address                  = {Berlin Heidelberg},
+  Edition                  = {2nd},
+
+  Doi                      = {10.1007/978-3-540-77877-6_20},
+  Owner                    = {jowr},
+  Timestamp                = {2013.06.18}
+}
+
+@Article{QuinonesCisneros-JPCRD-2012,
+  Title                    = {{Correlation for the Viscosity of Sulfur Hexafluoride (SF6) from the Triple Point to 1000 K and Pressures to 50 MPa}},
+  Author                   = {S.E. Qui{\~n}ones-Cisneros and M.L. Huber and U.K. Deiters},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2012},
+  Number                   = {2},
+  Pages                    = {023102-1:11},
+  Volume                   = {41},
+
+  Doi                      = {10.1063/1.3702441},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{QuinonesCisneros-JPCB-2006,
+  Title                    = {{Generalization of the Friction Theory for Viscosity Modeling}},
+  Author                   = {Sergio E. Qui{\~n}ones-Cisneros and Ulrich K. Deiters},
+  Journal                  = {J. Phys. Chem. B},
+  Year                     = {2006},
+  Pages                    = {12820-12834},
+  Volume                   = {110},
+
+  Doi                      = {10.1021/jp0618577},
+  Owner                    = {Belli},
+  Timestamp                = {2015.04.10}
+}
+
+@Article{QuinonesCisneros-JCED-2012,
+  Title                    = {{Reference Correlation for the Viscosity Surface of Hydrogen Sulfide}},
+  Author                   = {Sergio E. Qui{\~n}ones-Cisneros and Kurt A. G. Schmidt and Binod R. Giri and Pierre Blais and Robert A. Marriott},
+  Journal                  = {J. Chem. Eng. Data},
+  Year                     = {2012},
+  Pages                    = {3014-3018},
+  Volume                   = {57},
+
+  Doi                      = {10.1021/je300601h},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.14}
+}
+
+@Article{QuinonesCisneros-FPE-2001,
+  Title                    = {{One parameter friction theory models for viscosity}},
+  Author                   = {Sergio E. Qui{\~n}ones-Cisneros and Claus K. Z{\'e}berg-Mikkelsen and Erling H. Stenby},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {2001},
+  Pages                    = {1-16},
+  Volume                   = {176},
+
+  Doi                      = {10.1016/S0378-3812(00)00474-X},
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.07}
+}
+
+@Article{QuinonesCisneros-FPE-2000,
+  Title                    = {{The friction theory (f-theory) for viscosity modeling}},
+  Author                   = {Sergio E. Qui{\~n}ones-Cisneros and Claus K. Zeberg-Mikkelsen and Erling H. Stenby},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {2000},
+  Pages                    = {249-276},
+  Volume                   = {169},
+
+  Doi                      = {10.1016/S0378-3812(00)00310-1},
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.07}
+}
+
+@PhdThesis{Quoilin-2011,
+  Title                    = {{Sustainable energy conversion through the use of Organic Rankine Cycles for waste heat recovery and solar applications}},
+  Author                   = {Sylvain Quoilin},
+  School                   = {University of Li\`{e}ge},
+  Year                     = {2011},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.03.30}
+}
+
+@Article{Reeves-JCP-1964,
+  Title                    = {{Melting Curves of Pressure Transmitting Fluids}},
+  Author                   = {Larry E. Reeves and Gene J. Scott and Stanley E. Babb Jr.},
+  Journal                  = {J. Chem. Phys.},
+  Year                     = {1964},
+  Pages                    = {3662-3666},
+  Volume                   = {40},
+
+  Doi                      = {10.1063/1.1725068},
+  Owner                    = {Belli},
+  Timestamp                = {2014.10.02}
+}
+
+@Book{deReuck-BOOK-1990,
+  Title                    = {{Fluorine: International Thermodynamic Tables of the Fluid State - 11}},
+  Author                   = {K.M. de Reuck},
+  Publisher                = {Blackwell Scientific Publications},
+  Year                     = {1990},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.05.17}
+}
+
+@Book{deReuck-BOOK-1993,
+  Title                    = {{Methanol: International Thermodynamic Tables of the Fluid State - 12}},
+  Author                   = {K.M. de Reuck and R.J.B. Craven},
+  Publisher                = {Blackwell Scientific Publications},
+  Year                     = {1993},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.05.17}
+}
+
+@Article{Richardson-JPCRD-2013,
+  Title                    = {{Fundamental Equation of State for Deuterium}},
+  Author                   = {I.A. Richardson and J.W. Leachman and E.W. Lemmon},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2014},
+  Pages                    = {013103},
+  Volume                   = {43},
+
+  Doi                      = {10.1063/1.4864752},
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.28}
+}
+
+@Article{Richter-JCED-2011,
+  Title                    = {{Thermodynamic Properties of 2,3,3,3-Tetrafluoroprop-1-ene (R1234yf): Vapor Pressure and $p$-$\rho$-$T$ Measurements and an Equation of State}},
+  Author                   = {M. Richter and M. O. McLinden and E. W. Lemmon},
+  Journal                  = {J. Chem. Eng. Data},
+  Year                     = {2011},
+  Pages                    = {3254-3264},
+  Volume                   = {56},
+
+  Doi                      = {10.1021/je200369m},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Royal-2005,
+  author    = {D.D. Royal and V. Vesovic and J.P.M. Trusler and W.A. Wakeham},
+  title     = {{Predicting the viscosity of liquid refrigerant blends: comparison with experimental data}},
+  journal   = {Int. J. Refrig.},
+  year      = {2005},
+  volume    = {28},
+  pages     = {311?319},
+  comment   = {Only includes liquid mixtures},
+  owner     = {Belli},
+  timestamp = {2013.07.03},
+}
+
+@Article{Rui-FPE-2013,
+  Title                    = {{An equation of state for the thermodynamic properties of 1,1,1,2,3,3-hexafluoropropane (R236ea)}},
+  Author                   = {Xinfang Rui and Jiang Pan and Yugang Wang},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {2013},
+  Pages                    = {78-85},
+  Volume                   = {341},
+
+  Comment                  = {Erratum in paper: a1 should be -17.5983849 and a2 should be 8.87150449},
+  Doi                      = {10.1016/j.fluid.2012.12.026},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.10}
+}
+
+@Article{SantamariaPerez-PRB-2010,
+  Title                    = {{High-pressure melting curve of helium and neon: Deviations from corresponding states theory}},
+  Author                   = {David Santamar{\'i}a-P{\'e}rez and Goutam Dev Mukherjee and Beate Schwager and Reinhard Boehler},
+  Journal                  = {Physical Review B},
+  Year                     = {2010},
+  Pages                    = {214101:1-5},
+  Volume                   = {81},
+
+  Doi                      = {10.1103/PhysRevB.81.214101},
+  Owner                    = {Belli},
+  Timestamp                = {2014.06.09}
+}
+
+@Article{Scalbrin-2002,
+  Title                    = {{A corresponding states predictive viscosity model based on a new scaling parameter: application to hydrocarbons, halocarbons and mixtures}},
+  Author                   = {G. Scalabrin and G. Cristofoli and M. Grigiante},
+  Journal                  = {Int. J. Energy Res.},
+  Year                     = {2002},
+  Pages                    = {1-26},
+  Volume                   = {26},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.03}
+}
+
+@Article{Scalabrin-JPCRD-2006-CO2,
+  Title                    = {{A Reference Multiparameter Thermal Conductivity Equation for Carbon Dioxide with an Optimized Functional Form}},
+  Author                   = {G. Scalabrin and P. Marchi and F. Finezzo and R. Span},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2006},
+  Number                   = {4},
+  Pages                    = {1549-1575},
+  Volume                   = {35},
+
+  Doi                      = {10.1063/1.2213631},
+  Owner                    = {Belli},
+  Timestamp                = {2014.05.30}
+}
+
+@Book{Schmidt1979,
+  Title                    = {{Properties of Water and Steam in SI-Units}},
+  Author                   = {Ernst Schmidt},
+  Publisher                = {Springer},
+  Year                     = {1979},
+  Edition                  = {2nd},
+
+  Owner                    = {jowr},
+  Timestamp                = {2014.09.22}
+}
+
+@Article{Schmidt-FPE-1985,
+  Title                    = {{A New Form of the Equation of State for Pure Substances and its Application to Oxygen}},
+  Author                   = {Schmidt, R. and Wagner, W.},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {1985},
+  Number                   = {3},
+  Pages                    = {175-200},
+  Volume                   = {19},
+
+  Doi                      = {10.1016/0378-3812(85)87016-3},
+  Owner                    = {Belli},
+  Timestamp                = {2016.01.06}
+}
+
+@MastersThesis{Schroeder-MSTHESIS-2011,
+  Title                    = {{A New Fundamental Equation for Ethanol}},
+  Author                   = {Jacob Armin Schroeder},
+  School                   = {University of Idaho},
+  Year                     = {2011},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.13}
+}
+
+@Article{Schroeder-JPCRD-2014,
+  Title                    = {{A Fundamental Equation of State for Ethanol}},
+  Author                   = {Schroeder, J. A. and Penoncello, S. G. and Schroeder, J. S.},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2014},
+  Number                   = {4},
+  Pages                    = {043102},
+  Volume                   = {43},
+
+  Doi                      = {10.1063/1.4895394},
+  Eid                      = {043102}
+}
+
+@Article{Setzmann-JPCRD-1991,
+  Title                    = {{A New Equation of State and Tables of Thermodynamic Properties for Methane Covering the Range from the Melting Line to 625 K at Pressures up to 1000 MPa}},
+  Author                   = {U. Setzmann and W. Wagner},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {1991},
+  Number                   = {6},
+  Pages                    = {1061-1151},
+  Volume                   = {20},
+
+  Doi                      = {10.1063/1.555898},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Shan-ASHRAE-2000,
+  Title                    = {{A generalized model for viscosity and thermal conductivity of trifluoromethane (R-23)}},
+  Author                   = {Shan, Zhengjun and Penoncello, Steven G and Jacobsen, Richard T},
+  Journal                  = {ASHRAE Transactions},
+  Year                     = {2000},
+  Pages                    = {757},
+  Volume                   = {106},
+
+  Publisher                = {American Society of Heating, Refrigeration and Air Conditioning Engineers, Inc.}
+}
+
+@Article{Sharqawy2010,
+  Title                    = {Thermophysical properties of seawater: A review of existing correlations and data},
+  Author                   = {Mostafa H. Sharqawy and John H. Lienhard V and Syed M. Zubair},
+  Journal                  = {Desalination and Water Treatment},
+  Year                     = {2010},
+  Pages                    = {354--380},
+  Volume                   = {16},
+
+  Doi                      = {10.5004/dwt.2010.1079},
+  Owner                    = {jowr},
+  Timestamp                = {2015.09.02}
+}
+
+@Manual{Skovrup2013,
+  Title                    = {{SecCool Properties v1.33}},
+  Author                   = {Morten Juel Skovrup},
+  Organization             = {IPU Refrigeration and Energy Technology},
+  Year                     = {2013},
+
+  Owner                    = {jowr},
+  Timestamp                = {2014.09.17},
+  Url                      = {http://en.ipu.dk/Indhold/refrigeration-and-energy-technology/seccool.aspx}
+}
+
+@TechReport{Skovrup1999,
+  Title                    = {{Beregning af termodynamiske st{\o}rrelser for k{\o}lemidler -- Tilstandsligninger for rene stoffer og blandinger}},
+  Author                   = {Morten Juel Skovrup},
+  Institution              = {{Institut for Energiteknik, Danmarks Tekniske Universitet}},
+  Year                     = {1999},
+
+  Owner                    = {jowr},
+  Timestamp                = {2014.12.17}
+}
+
+@Article{Smukala-JPCRD-2000,
+  Title                    = {{New Equation of State for Ethylene Covering the Fluid Region for Temperatures From the Melting Line to 450 K at Pressures up to 300 MPa}},
+  Author                   = {J. Smukala and R. Span and W. Wagner},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2000},
+  Number                   = {5},
+  Pages                    = {1053-1121},
+  Volume                   = {29},
+
+  Doi                      = {10.1063/1.1329318},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Book{Span-BOOK-2000,
+  Title                    = {{Multiparameter Equations of State - An Accurate Source of Thermodynamic Property Data}},
+  Author                   = {Roland Span},
+  Publisher                = {Springer-Verlag, Berlin},
+  Year                     = {2000},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.03.18}
+}
+
+@Article{Span-JPCRD-2000,
+  Title                    = {{A Reference Equation of State for the Thermodynamic Properties of Nitrogen for Temperatures from 63.151 to 1000 K and Pressures to 2200 MPa}},
+  Author                   = {Roland Span and Eric W. Lemmon and Richard T. Jacobsen and Wolfgang Wagner and Akimichi Yokozeki},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2000},
+  Pages                    = {1361-1433},
+  Volume                   = {29},
+
+  Doi                      = {10.1063/1.1349047},
+  File                     = {:D\:\\My_Documents\\Library\\Papers\\Span Lemmon et al 2000.pdf:PDF},
+  Keywords                 = {EOS},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Span-IJT-2003B,
+  Title                    = {{Equations of State for Technical Applications. II. Results for Nonpolar Fluids}},
+  Author                   = {R. Span and W. Wagner},
+  Journal                  = {Int. J. Thermophys.},
+  Year                     = {2003},
+  Pages                    = {41-109},
+  Volume                   = {24},
+
+  Doi                      = {10.1023/A:1022310214958},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Span-IJT-2003C,
+  Title                    = {{Equations of State for Technical Applications. III. Results for Polar Fluids}},
+  Author                   = {R. Span and W. Wagner},
+  Journal                  = {Int. J. Thermophys.},
+  Year                     = {2003},
+  Pages                    = {111-162},
+  Volume                   = {24},
+
+  Doi                      = {10.1023/A:1022362231796},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Span-JPCRD-1996,
+  Title                    = {{A New Equation of State for Carbon Dioxide Covering the Fluid Region from the Triple Point Temperature to 1100 K at Pressures up to 800 MPa}},
+  Author                   = {R. Span and W. Wagner},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {1996},
+  Pages                    = {1509-1596},
+  Volume                   = {25},
+
+  Doi                      = {10.1063/1.555991},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Span-FPE-2001,
+  Title                    = {{Multiparameter equations of state - recent trends and future challenges}},
+  Author                   = {R. Span and W. Wagner and E.W. Lemmon and R.T. Jacobsen},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {2001},
+  Pages                    = {1-20},
+  Volume                   = {183-184},
+
+  Doi                      = {10.1016/S0378-3812(01)00416-2},
+  Owner                    = {Belli},
+  Timestamp                = {2013.08.18}
+}
+
+@Article{Stewart-JPCRD-1991,
+  Title                    = {{Thermodynamic Properties of Oxygen from the Triple Point to 300 K with Pressures to 80 MPa}},
+  Author                   = {Richard B. Stewart and Richard T. Jacobsen and W. Wagner},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {1991},
+  Number                   = {5},
+  Pages                    = {917-1021},
+  Volume                   = {20},
+
+  Doi                      = {10.1063/1.555897},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Sun-BBPC-1988,
+  Title                    = {{Accurate Measurement of the Melting Line of Methanol and Ethanol at Pressures up to 270 MPa}},
+  Author                   = {T. F. Sun and J. A. Schouten and N. J. Trappeniers and S. N. Biswas},
+  Journal                  = {Ber. Bunsenges. Phys. Chem.},
+  Year                     = {1988},
+  Pages                    = {652--655},
+  Volume                   = {92},
+
+  Doi                      = {10.1002/bbpc.198800153},
+  Owner                    = {Belli},
+  Timestamp                = {2014.07.07}
+}
+
+@Article{Sykioti-JPCRD-2013-Methanol,
+  Title                    = {{Reference Correlation of the Thermal Conductivity of Methanol from the Triple Point to 660 K and up to 245 MPa}},
+  Author                   = {E. A. Sykioti and M. J. Assael and M. L. Huber and R. A. Perkins},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2013},
+  Pages                    = {043101},
+  Volume                   = {42},
+
+  Doi                      = {10.1063/1.4829449},
+  Owner                    = {Belli},
+  Timestamp                = {2016.06.19}
+}
+
+@Article{Tanaka-IJT-1996,
+  Title                    = {{Thermal Conductivity and Viscosity of 2,2-Dichloro-1,1,1-Trifluoroethane (HCFC-123)}},
+  Author                   = {Y. Tanaka and T. Sotani},
+  Journal                  = {Int. J. Thermophys.},
+  Year                     = {1996},
+  Number                   = {2},
+  Pages                    = {293-328},
+  Volume                   = {17},
+
+  Doi                      = {10.1007/BF01443394},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.13}
+}
+
+@Article{Tariq-JPCRD-2014-Cyclohexane,
+  Title                    = {{Reference Correlation of the Viscosity of Cyclohexane from the Triple Point to 700 K and up to 110 MPa}},
+  Author                   = {U. Tariq and A. R. B. Jusoh and N. Riesco and V. Vesovic},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2014},
+  Number                   = {3},
+  Pages                    = {033101-1:18},
+  Volume                   = {43},
+
+  Doi                      = {10.1063/1.4891103},
+  Owner                    = {Belli},
+  Timestamp                = {2014.08.21}
+}
+
+@Article{Tegeler-JPCRD-1999,
+  Title                    = {{A New Equation of State for Argon Covering the Fluid Region for Temperatures From the Melting Line to 700 K at Pressures up to 1000 MPa}},
+  Author                   = {Ch. Tegeler and R. Span and W. Wagner},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {1999},
+  Pages                    = {779-850},
+  Volume                   = {28},
+
+  Doi                      = {10.1063/1.556037},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Thol-FPE-2016-MM,
+  Title                    = {{Fundamental equation of state correlation for hexamethyldisiloxane based on experimental and molecular simulation data}},
+  Author                   = {Monika Thol},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {2015},
+
+  Doi                      = {10.1016/j.fluid.2015.09.047},
+  Owner                    = {Belli},
+  Timestamp                = {2014.11.21}
+}
+
+@PhdThesis{Thol-THESIS-2015,
+  Title                    = {{Empirical Multiparameter Equations of State Based on Molecular Simulation and Hybrid Data Sets}},
+  Author                   = {Monika Thol},
+  School                   = {Ruhr-Universit{\"a}t Bochum},
+  Year                     = {2015},
+
+  Owner                    = {Belli}
+}
+
+@Article{Thol-HTHP-2012,
+  Title                    = {{Equation of state for benzene for temperatures from the melting line up to 725 K with pressures up to 500 MPa}},
+  Author                   = {M. Thol and E.W. Lemmon and R. Span},
+  Journal                  = {High Temperatures-High Pressures},
+  Year                     = {2012},
+  Pages                    = {81-97},
+  Volume                   = {41},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.10}
+}
+
+@Article{Thol-IJT-2016-R1234zeE,
+  Title                    = {{Equation of State for the Thermodynamic Properties of trans-1,3,3,3-Tetrafluoropropene [R-1234ze(E)]}},
+  Author                   = {Monika Thol and Eric W. Lemmon},
+  Journal                  = {Int. J. Thermophys},
+  Year                     = {2016},
+  Number                   = {3},
+  Pages                    = {1--16},
+  Volume                   = {37},
+
+  Doi                      = {10.1007/s10765-016-2040-6},
+  Owner                    = {Belli},
+  Timestamp                = {2016.01.25}
+}
+
+@Unpublished{Thol-2012,
+  Title                    = {{Equation of State for a Refrigerant Mixture of R365mfc (1,1,1,3,3-Pentafluorobutane) and Galden HT 55 (Perfluoropolyether)}},
+  Author                   = {Monika Thol and Eric W. Lemmon and Roland Span},
+  Note                     = {Unpublished},
+  Year                     = {2012},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.08.05}
+}
+
+@Article{Thol-IJT-2014,
+  Title                    = {{A New Functional Form for Equations of State for Some Weakly Associating Fluids}},
+  Author                   = {Thol, Monika and Piazza, Lorenzo and Span, Roland},
+  Journal                  = {Int. J. Thermophys.},
+  Year                     = {2014},
+  Number                   = {5},
+  Pages                    = {783-811},
+  Volume                   = {35},
+
+  Doi                      = {10.1007/s10765-014-1633-1},
+  ISSN                     = {0195-928X},
+  Keywords                 = {Diethyl ether; Equation of state; Functional form; Helmholtz energy; Hydrogen chloride; Methyl chloride; Thermodynamic properties},
+  Language                 = {English},
+  Owner                    = {Belli},
+  Publisher                = {Springer US},
+  Timestamp                = {2016.01.04},
+  Url                      = {http://dx.doi.org/10.1007/s10765-014-1633-1}
+}
+
+@Article{Thol-CES-2015,
+  Title                    = {{Fundamental equation of state for ethylene oxide based on a hybrid dataset}},
+  Author                   = {Monika Thol and G{\'a}bor Rutkai and Andreas K{\"o}ster and Mirco Kortmann and Roland Span and Jadran Vrabec},
+  Journal                  = {Chem. Eng. Sci.},
+  Year                     = {2015},
+  Pages                    = {87--99},
+  Volume                   = {121},
+
+  Doi                      = {10.1016/j.ces.2014.07.051},
+  Owner                    = {Belli},
+  Timestamp                = {2016.01.18}
+}
+
+@Article{Thol-CES-2015-CORR,
+  Title                    = {{Corrigendum to 'Fundamental equation of state for ethylene oxide based on a hybrid dataset'}},
+  Author                   = {Monika Thol and G{\'a}bor Rutkai and Andreas K{\"o}ster and Mirco Kortmann and Roland Span and Jadran Vrabec},
+  Journal                  = {Chem. Eng. Sci.},
+  Year                     = {2015},
+  Pages                    = {887--890},
+  Volume                   = {134},
+
+  Doi                      = {10.1016/j.ces.2015.06.020},
+  Owner                    = {Belli},
+  Timestamp                = {2016.01.18}
+}
+
+@InProceedings{HelmholtzMedia,
+  Title                    = {HelmholtzMedia - A Fluid Properties Library},
+  Author                   = {Thorade, Matthis and Saadat, Ali},
+  Note                     = {https://github.com/thorade/HelmholtzMedia},
+  Booktitle                = {Proceedings of the 9th International Modelica Conference},
+  Pages                    = {63--70},
+  Year                     = 2012,
+  ISSN                     = {1650-3740},
+
+  Doi                      = {10.3384/ecp1207663},
+  Owner                    = {Belli},
+  Timestamp                = {2013.05.29}
+}
+
+@Article{Thorade-EES-2013,
+  Title                    = {{Partial derivatives of thermodynamic state properties for dynamic simulation}},
+  Author                   = {Thorade, Matthis and Saadat, Ali},
+  Journal                  = {Environmental Earth Sciences},
+  Year                     = {2013},
+
+  Month                    = apr,
+
+  Doi                      = {10.1007/s12665-013-2394-z},
+  ISSN                     = {1866-6280},
+  Keywords                 = {defined by specifying any,energy \'{a} partial derivatives,in fluid cycle,nation of two independent,other combi-,state can also be,state properties,thermodynamic properties \'{a} helmholtz,\'{a} dynamic simulation},
+  Owner                    = {jowr},
+  Timestamp                = {2013.05.01},
+  Url                      = {http://link.springer.com/10.1007/s12665-013-2394-z}
+}
+
+@Article{TillnerRoth-IJT-1995,
+  Title                    = {{A Fundamental Equation of State for 1,1-Difluoroethane (HFC-152a)}},
+  Author                   = {R. Tillner-Roth},
+  Journal                  = {Int. J. Thermophys.},
+  Year                     = {1995},
+  Number                   = {1},
+  Pages                    = {91-100},
+  Volume                   = {16},
+
+  Doi                      = {10.1007/BF01438960},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{TillnerRoth-JPCRD-1994,
+  Title                    = {{A International Standard Formulation for the Thermodynamic Properties of 1,1,1,2-Tetrafluoroethane (HFC-134a) for Temperatures from 170 K to 455 K and Pressures up to 70 MPa}},
+  Author                   = {Reiner Tillner-Roth and Hans Dieter Baehr},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {1994},
+  Pages                    = {657-729},
+  Volume                   = {23},
+
+  Doi                      = {10.1063/1.555958},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@InProceedings{TillnerRoth-DKV-1993,
+  Title                    = {{Eine neue Fundamentalgleichung fur Ammoniak (A new Fundamental Equation of State for Ammonia)}},
+  Author                   = {R. Tillner-Roth and F. Harms-Watzenberg and H.D. Baehr},
+  Booktitle                = {Deutscher Kaelte- und Klimatechnischer Verein Tagung 1993},
+  Year                     = {1993},
+
+  Journal                  = {Deutscher Kaelte- und Klimatechnischer Verein Tagung 1993},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{TillnerRoth-JPCRD-1997,
+  Title                    = {{An international standard equation of state for difluoromethane (R-32) for temperatures from the triple point at 136.34 K to 435 K and pressures up to 70 MPa}},
+  Author                   = {R. Tillner-Roth and A. Yokozeki},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {1997},
+  Number                   = {6},
+  Pages                    = {1273-1328},
+  Volume                   = {26},
+
+  Doi                      = {10.1063/1.556002},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Tournier-2008,
+  Title                    = {{Properties of noble gases and binary mixtures for closed Brayton Cycle applications}},
+  Author                   = {Jean-Michel P. Tournier and Mohamed S. El-Genk},
+  Journal                  = {Energy Conversion and Management},
+  Year                     = {2008},
+  Pages                    = {469-492},
+  Volume                   = {49},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.03}
+}
+
+@Article{Tufeu-BBPC-1984,
+  Title                    = {{Thermal Conductivity of Ammonia in a Large Temperature and Pressure Range Including the Critical Region}},
+  Author                   = {R. Tufeu and D.Y. Ivanov and Y. Garrabos and B. Le Neindre},
+  Journal                  = {Bereicht der Bunsengesellschaft Phys. Chem.},
+  Year                     = {1984},
+  Pages                    = {422-427},
+  Volume                   = {88},
+
+  Doi                      = {10.1002/bbpc.19840880421},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Valderrama-IECR-2003,
+  Title                    = {{The State of the Cubic Equations of State}},
+  Author                   = {Jos{\'e} Valderrama},
+  Journal                  = {Ind. Eng. Chem. Res.},
+  Year                     = {2003},
+  Pages                    = {1603-1618},
+  Volume                   = {42},
+
+  Owner                    = {ihb},
+  Timestamp                = {2015.07.20}
+}
+
+@Article{Vassiliou-JPCRD-2015-pentanes,
+  Title                    = {{Reference Correlations of the Thermal Conductivity of Cyclopentane, iso-Pentane, and n-Pentane}},
+  Author                   = {Vassiliou, C-M and Assael, MJ and Huber, ML and Perkins, RA},
+  Journal                  = {Journal of Physical and Chemical Reference Data},
+  Year                     = {2015},
+  Number                   = {3},
+  Pages                    = {033102},
+  Volume                   = {44},
+
+  Publisher                = {AIP Publishing}
+}
+
+@Article{Vesovic-2002,
+  Title                    = {{Predicting the viscosity of halogenated hydrocarbon mixtures}},
+  Author                   = {V. Vesovic},
+  Journal                  = {Fluid Phase Equilib.},
+  Year                     = {2002},
+  Pages                    = {295-306},
+  Volume                   = {199},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.03}
+}
+
+@Article{Vesovic-JPCRD-1990,
+  Title                    = {{The Transport Properties of Carbon Dioxide}},
+  Author                   = {V. Vesovic and W.A. Wakeham and G.A. Olchowy and J.V. Sengers and J.T.R. Watson and J. Millat},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {1990},
+  Pages                    = {763--808},
+  Volume                   = {19},
+
+  Doi                      = {10.1063/1.555875},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Vogel-JPCRD-1998,
+  Title                    = {{Reference Correlation of the Viscosity of Propane}},
+  Author                   = {E. Vogel and C. K{\"u}chenmeister and E. Bich and A. Laesecke},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {1998},
+  Note                     = {5},
+  Pages                    = {947-970},
+  Volume                   = {27},
+
+  Doi                      = {10.1063/1.556025},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Vogel-IJT-2000,
+  Title                    = {{Viscosity Correlation for Isobutane over Wide Ranges of the Fluid Region}},
+  Author                   = {E. Vogel and C. Kuechenmeister and E. Bich},
+  Journal                  = {Int. J. Thermophys},
+  Year                     = {2000},
+  Number                   = {2},
+  Pages                    = {343-356},
+  Volume                   = {21},
+
+  Doi                      = {10.1023/A:1006623310780},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Vogel-HTHP-1999,
+  Title                    = {{Viscosity for n-Butane in the Fluid Region}},
+  Author                   = {E. Vogel and C. Kuechenmeister and E. Bich},
+  Journal                  = {High Temp. - High Pressures},
+  Year                     = {1999},
+  Number                   = {2},
+  Pages                    = {173-186},
+  Volume                   = {31},
+
+  Doi                      = {10.1068/htrt154},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@InProceedings{deVries-ICR-1995,
+  Title                    = {{Thermodynamic Properties of HCFC 124}},
+  Author                   = {B. de Vries and R. Tillner-Roth and H.D. Baehr},
+  Booktitle                = {19th International Congress of Refrigeration, The Hague, The Netherlands},
+  Year                     = {1995},
+  Pages                    = {582-589},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.05.01}
+}
+
+@Unpublished{FLUIDCAL,
+  Title                    = {FLUIDCAL: Software FLUIDCAL for the Calculation of Thermodynamic Properties for a Great Number of Substances},
+  Author                   = {W. Wagner},
+  Note                     = {http://www.thermo.rub.de/en/prof-w-wagner/software/fluidcal.html},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.05.29}
+}
+
+@Article{Wagner-JPCRD-2002,
+  Title                    = {{The IAPWS Formulation 1995 for the Thermodynamic Properties of Ordinary Water Substance for General and Scientific Use}},
+  Author                   = {W. Wagner and A. Pru\ss},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2002},
+  Pages                    = {387--535},
+  Volume                   = {31},
+
+  Doi                      = {10.1063/1.1461829},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Wei-AICHEJ-2000,
+  Title                    = {{Equations of State for the Calculation of Fluid-Phase Equilibria}},
+  Author                   = {Ya Song Wei and Richard J. Sadus},
+  Journal                  = {AIChE Journal},
+  Year                     = {2000},
+  Number                   = {1},
+  Pages                    = {169-196},
+  Volume                   = {46},
+
+  Owner                    = {ihb},
+  Timestamp                = {2015.07.20}
+}
+
+@Article{Wu-IJT-2012,
+  Title                    = {{An Equation of State for Fluoroethane (R161)}},
+  Author                   = {Jiangtao Wu and Yong Zhou},
+  Journal                  = {Int. J. Thermophys.},
+  Year                     = {2012},
+  Pages                    = {220-234},
+  Volume                   = {33},
+
+  Doi                      = {10.1007/s10765-011-1151-3},
+  Owner                    = {Belli},
+  Timestamp                = {2014.01.22}
+}
+
+@Article{Wu-JPCRD-2011,
+  Title                    = {{An Equation of State for the Thermodynamic Properties of Dimethyl Ether}},
+  Author                   = {Jiangtao Wu and Yong Zhou and Eric W. Lemmon},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2011},
+  Number                   = {2},
+  Pages                    = {023104-1:16},
+  Volume                   = {40},
+
+  Doi                      = {10.1063/1.3582533},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.09}
+}
+
+@Article{Xiang-JPCRD-2006,
+  Title                    = {{A New Reference Correlation for the Viscosity of Methanol}},
+  Author                   = {Hong Wei Xiang and Arno Laesecke and Marcia L. Huber},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2006},
+  Number                   = {4},
+  Pages                    = {1597-1:24},
+  Volume                   = {35},
+
+  Doi                      = {10.1063/1.2360605},
+  Owner                    = {Belli},
+  Timestamp                = {2014.08.26}
+}
+
+@Article{Yokoyama-2006,
+  Title                    = {{Viscosity of Gaseous Mixtures of HFC-125 + Propane from 298.15 to 423.15K at Pressures to 6.7 MPa}},
+  Author                   = {C. Yokoyama and T. Nishino and M. Takahashi},
+  Journal                  = {Int. J. Thermophys.},
+  Year                     = {2006},
+  Number                   = {3},
+  Pages                    = {714-728},
+  Volume                   = {27},
+
+  Owner                    = {Belli},
+  Timestamp                = {2013.07.03}
+}
+
+@Article{Younglove-JPCRD-1994,
+  Title                    = {{An International Standard Equation of State for the Thermodynamic Properties of Refrigerant 123 (2,2-Dichloro-1,1,1-Trifluoroethane)}},
+  Author                   = {Ben A. Younglove},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {1994},
+  Number                   = {5},
+  Pages                    = {731-779},
+  Volume                   = {23},
+
+  Doi                      = {10.1063/1.555950},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@TechReport{Younglove-NIST-1982,
+  Title                    = {{Thermophysical properties of fluids. I. Argon, ethylene, parahydrogen, nitrogen, nitrogen trifluoride, and oxygen}},
+  Author                   = {Younglove, Ben A},
+  Institution              = {DTIC Document},
+  Year                     = {1982}
+}
+
+@TechReport{Zavoico2001,
+  Title                    = {{Solar Power Tower Design Basis Document}},
+  Author                   = {Alexis B. Zavoico},
+  Institution              = {Sandia National Laboratories},
+  Year                     = {2001},
+  Month                    = {July},
+
+  Doi                      = {10.2172/786629},
+  Owner                    = {jowr},
+  Timestamp                = {2013.10.23},
+  Url                      = {http://prod.sandia.gov/techlib/access-control.cgi/2001/012100.pdf}
+}
+
+@Article{Zhou-IJT-2016-R245ca,
+  Title                    = {{Equation of State for the Thermodynamic Properties of 1,1,2,2,3-Pentafluoropropane (R-245ca)}},
+  Author                   = {Yong Zhou & Eric W. Lemmon},
+  Journal                  = {Int. J. Thermophys.},
+  Year                     = {2016},
+  Pages                    = {1--11},
+  Volume                   = {37},
+  Doi                      = {10.1007/s10765-016-2039-z},
+}
+
+@Article{Zhou-JPCRD-2014,
+  Title                    = {{An Equation of State for the Thermodynamic Properties of Cyclohexane}},
+  Author                   = {Yong Zhou and Jun Liu and Steven G. Penoncello and Eric W. Lemmon},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2014},
+  Pages                    = {043105-1:12},
+  Volume                   = {43},
+
+  Abstract                 = {Erratum: Reference values for enthalpy and entropy in the homogeneous phase are incorrect as published},
+  Doi                      = {10.1063/1.4900538},
+  Owner                    = {Belli},
+  Timestamp                = {2014.12.06}
+}
+
+@Article{Zhou-JPCRD-2012,
+  Title                    = {{Thermodynamic Properties of o-Xylene, m-Xylene, p-Xylene, and Ethylbenzene}},
+  Author                   = {Yong Zhou and Jiangtao Wu and Eric W. Lemmon},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2012},
+  Number                   = {2},
+  Pages                    = {023103-1 -- 023103-26},
+  Volume                   = {41},
+
+  Doi                      = {10.1063/1.3703506},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.08}
+}
+
+@Article{Zhou-JPCRD-2011,
+  Title                    = {{Thermodynamic Properties of Dimethyl Carbonate}},
+  Author                   = {Yong Zhou and Jiangtao Wu and Eric W. Lemmon},
+  Journal                  = {J. Phys. Chem. Ref. Data},
+  Year                     = {2011},
+  Number                   = {4},
+  Pages                    = {043106-1:11},
+  Volume                   = {40},
+
+  Doi                      = {10.1063/1.3664084},
+  Owner                    = {Belli},
+  Timestamp                = {2013.04.09}
+}
+
+@Manual{Dynalene2014,
+  Title                    = {{Technical Data Sheet}},
+  Organization             = {{Dynalene Inc.}},
+  Year                     = {2014},
+
+  Owner                    = {jowr},
+  Timestamp                = {2014.09.22}
+}
+
+@Manual{Therminol2014,
+  Title                    = {{Therminol Heat Transfer Reference Disk v5.1}},
+  Organization             = {{Eastman Chemical Company}},
+  Year                     = {2014},
+
+  Owner                    = {jowr},
+  Timestamp                = {2014.09.17},
+  Url                      = {http://www.therminol.com/resources/therminol-reference-disk}
+}
+
+@Manual{Paratherm2013,
+  Title                    = {{Thermal Properties Calculator v6.4}},
+  Organization             = {{Paratherm Ltd.}},
+  Year                     = {2013},
+
+  Owner                    = {jowr},
+  Timestamp                = {2014.09.22},
+  Url                      = {http://paracalc.paratherm.com}
+}
+
+@Manual{Arteco2010,
+  Title                    = {{Technical Information}},
+  Organization             = {{Arteco NV/SA}},
+  Year                     = {2010},
+
+  Owner                    = {jowr},
+  Timestamp                = {2014.09.22}
+}
+
+@Manual{3M2007,
+  Title                    = {{Technical Information}},
+  Organization             = {{3M Company}},
+  Year                     = {2007},
+
+  Owner                    = {jowr},
+  Timestamp                = {2014.09.22}
+}
+
+@Manual{PKS2005,
+  Title                    = {{Technical Data Sheet}},
+  Organization             = {{pro K{\"u}hlsole GmbH}},
+  Year                     = {2005},
+
+  Owner                    = {jowr},
+  Timestamp                = {2014.09.22}
+}
+
+@Manual{Chevron2004,
+  Title                    = {{Technical Data Sheet}},
+  Organization             = {{Chevron Products Company}},
+  Year                     = {2004},
+
+  Owner                    = {jowr},
+  Timestamp                = {2014.09.22}
+}
+
+@Manual{Aspen2001,
+  Title                    = {{Technical Data Sheet}},
+  Organization             = {{Aspen Petroleum AB}},
+  Year                     = {2001},
+
+  Owner                    = {jowr},
+  Timestamp                = {2014.09.22}
+}
+
+@Manual{Clariant2000,
+  Title                    = {{Technical Data Sheet}},
+  Organization             = {{Clariant GmbH}},
+  Year                     = {2000},
+
+  Owner                    = {jowr},
+  Timestamp                = {2014.09.22}
+}
+
+@Manual{Hydro2000,
+  Title                    = {{Technical Information}},
+  Organization             = {{Hydro Chemicals}},
+  Year                     = {2000},
+
+  Owner                    = {jowr},
+  Timestamp                = {2014.09.22}
+}
+
+@Manual{Sulzer1999,
+  Title                    = {{Technical Information}},
+  Organization             = {{Sulzer Chemtech AG}},
+  Year                     = {1999},
+
+  Owner                    = {jowr},
+  Timestamp                = {2014.09.22}
+}
+
+@Manual{Tyfoprop1999,
+  Title                    = {{Technical Information}},
+  Organization             = {{Tyforop Chemie Gmbh}},
+  Year                     = {1999},
+
+  Owner                    = {jowr},
+  Timestamp                = {2014.09.22}
+}
+
+@Manual{Kemira1998,
+  Title                    = {{Technical Data Sheet}},
+  Organization             = {{Kemira Chemicals OY}},
+  Year                     = {1998},
+
+  Owner                    = {jowr},
+  Timestamp                = {2014.09.22}
+}
+
+@Manual{Dow1997,
+  Title                    = {{Technical Data Sheet}},
+  Organization             = {{The Dow Chemical Company}},
+  Year                     = {1997},
+
+  Owner                    = {jowr},
+  Timestamp                = {2014.09.22}
+}
+
+@Manual{Hoechst1995,
+  Title                    = {{Technical Information}},
+  Organization             = {{Hoechst AG}},
+  Year                     = {1995},
+
+  Owner                    = {jowr},
+  Timestamp                = {2014.09.22}
+}
+
+@Article{Thol-JCED-2017-siloxanes,
+  author    = {Monika Thol and Frithjof H. Dubberke and Elmar Baumh{\"o}gger and Jadran Vrabec and Roland Span},
+  title     = {Speed of Sound Measurements and Fundamental Equations of State for Octamethyltrisiloxane and Decamethyltetrasiloxane},
+  journal   = {J. Chem. Eng. Data},
+  year      = {2017},
+  volume    = {62},
+  number    = {9},
+  pages     = {2633--2648},
+  month     = {jul},
+  doi       = {10.1021/acs.jced.7b00092},
+  publisher = {American Chemical Society ({ACS})},
+}
+
+@Article{Thol-JCED-2018-HCl,
+  author    = {Monika Thol and Frithjof H. Dubberke and Elmar Baumh{\"o}gger and Roland Span and Jadran Vrabec},
+  title     = {Speed of Sound Measurements and a Fundamental Equation of State for Hydrogen Chloride},
+  journal   = {J. Chem. Eng. Data},
+  year      = {2018},
+  volume    = {63},
+  number    = {7},
+  pages     = {2533--2547},
+  doi       = {10.1021/acs.jced.7b01031},
+  publisher = {American Chemical Society ({ACS})},
+}
+
+@Article{Thol-JPCRD-2019-Neon,
+  author  = {M. Thol and R. Beckm{\"u}ller and R. Weiss and A.H. Harvey and E.W. Lemmon and R.T. Jacobsen and R. Span},
+  title   = {{Thermodynamic Properties for Neon for Temperatures from the Triple Point to 700 K at Pressures to 700 MPa}},
+  journal = {J. Phys. Chem Ref. Data},
+  year    = {2019, Submitted},
+}
+
+@Article{Thol-FPE-2019-siloxanes,
+  author  = {M. Thol and M.A. Javed and E. Baumhoegger and R. Span and J. Vrabec},
+  title   = {{Thermodynamic Properties of Dodecamethylpentasiloxane, Tetradecamethylhexasiloxane, and Decamethylcyclopentasiloxane}},
+  journal = {Fluid Phase Equilib.},
+  year    = {2019},
+}
+
+@Article{Thol-FPE-2019-alkanes-pentane,
+  author  = {M. Thol and T. Uhde and E.W. Lemmon and R. Span},
+  title   = {{Fundamental Equations of State for Hydrocarbons.  Part I. n-Pentane}},
+  journal = {Fluid Phase Equilib.},
+  year    = {2019},
+}
+
+@Article{Thol-FPE-2019-alkanes-hexane,
+  author  = {M. Thol and Y. Wang and E.W. Lemmon and R. Span},
+  title   = {{Fundamental Equations of State for Hydrocarbons.  Part II. n-Hexane}},
+  journal = {Fluid Phase Equilib.},
+  year    = {2019},
+}
+
+@Article{Beckmueller-IJT-2019-octane,
+  author  = {R. Beckmueller and M. Thol and E.W. Lemmon and R. Span},
+  title   = {{Fundamental Equation of State for n-Octane}},
+  journal = {Int. J. Therrmophys.},
+  year    = {2019},
+}
+
+@Misc{IAPWS-SurfaceTension-1994,
+  Title                    = {IAPWS Release on Surface Tension of Heavy Water Substance},
+
+  Author                   = {IAPWS},
+  Year                     = {1994}
+}
+
+@article{Huber-JPCRD-2016-CO2,
+	title = {{Reference Correlation of the Thermal Conductivity of Carbon Dioxide from the Triple Point to 1100 K and up to 200 MPa}},
+	volume = {45},
+	doi = {10.1063/1.4940892},
+	number = {1},
+	year = {2016},
+	journal = {Journal of Physical and Chemical Reference Data},
+	author = {M. L. Huber and E. A. Sykioti and M. J. Assael and  R. A. Perkins},
+}
+
+@article{Laesecke-JPCRD-2017-CO2,
+	title = {{Reference Correlation for the Viscosity of Carbon Dioxide}},
+	volume = {46},
+	doi = {10.1063/1.4977429},
+	number = {1},
+	journal = {Journal of Physical and Chemical Reference Data},
+	author = {A. Laesecke and C. D. Muzny},
+	year = {2017},
+}
+
+@Comment{jabref-meta: databaseType:bibtex;}
```

## CoolProp/HumidAirProp.py

 * *Ordering differences only*

```diff
@@ -1,2 +1,2 @@
-from __future__ import absolute_import
-from .CoolProp import HAPropsSI, HAProps, HAProps_Aux
+from __future__ import absolute_import
+from .CoolProp import HAPropsSI, HAProps, HAProps_Aux
```

## CoolProp/State.pxd

 * *Ordering differences only*

```diff
@@ -1,3 +1,3 @@
-
-from .CoolProp cimport State as State
+
+from .CoolProp cimport State as State
```

## CoolProp/State.py

 * *Ordering differences only*

```diff
@@ -1,3 +1,3 @@
-from __future__ import absolute_import
-# We made everything build into one module for simplicity as it makes the code much nicer to compile
-from .CoolProp import *
+from __future__ import absolute_import
+# We made everything build into one module for simplicity as it makes the code much nicer to compile
+from .CoolProp import *
```

## CoolProp/__init__.py

 * *Ordering differences only*

```diff
@@ -1,82 +1,82 @@
-from __future__ import absolute_import
-
-# If there is a constants.[pyd|so|dylib] in the main directory, it will be imported instead of the constants.py file.
-# It should be removed as it is from the older version of CoolProp
-from . import constants
-if constants.__file__.rsplit('.', 1)[1] not in ['pyc', 'pyo', 'py']:
-
-    import os
-    try:
-        os.remove(constants.__file__)
-        print("constants shared library has been removed.  Please restart your python code")
-    except:
-        print("Unable to remove" + constants.__file__ + ". Please manually remove it")
-    quit()
-
-from .CoolProp import AbstractState
-from . import CoolProp
-from . import HumidAirProp
-from . import State
-from .constants import *
-
-__fluids__ = CoolProp.get_global_param_string('fluids_list').split(',')
-__incompressibles_pure__ = CoolProp.get_global_param_string('incompressible_list_pure').split(',')
-__incompressibles_solution__ = CoolProp.get_global_param_string('incompressible_list_solution').split(',')
-__version__ = CoolProp.get_global_param_string('version')
-__gitrevision__ = CoolProp.get_global_param_string('gitrevision')
-
-def get(s):
-    """
-    This is just a shorthand function for getting a parameter from
-    ``CoolProp.get_global_param_string``
-    """
-    return CoolProp.get_global_param_string(s)
-
-
-def test():
-    """
-    Run the tests in the test folder
-    """
-    from .tests import runner
-    runner.run()
-
-
-def get_include_directory():
-    """
-    Get the include directory for CoolProp header files that are needed if you want
-    to compile anything else that uses the CoolProp Cython extension type
-
-    Returns
-    -------
-    include_directory: The path to the include folder for CoolProp
-    """
-    import os
-    head, file = os.path.split(__file__)
-    return os.path.join(head, 'include')
-
-
-def copy_BibTeX_library(file=None, folder=None):
-    """
-    Copy the CoolProp BibTeX library file to the file given by ``file``, or the folder given by ``folder``
-
-    If no inputs are provided, the file will be copied to the current working
-    directory
-
-    Parameters
-    ----------
-    file : string
-        Provide if you want to put the file into a given file
-    folder : string
-        Provide if you want to put the CoolPropBibTeXLibrary.bib file into the given folder
-
-    """
-    import os, shutil
-    path_to_bib = os.path.join(os.path.split(__file__)[0], 'CoolPropBibTeXLibrary.bib')
-    if file is None and folder is None:
-        shutil.copy2(path_to_bib, os.path.abspath(os.curdir))
-    elif file and folder is None:
-        shutil.copy2(path_to_bib, file)
-    elif folder and file is None:
-        shutil.copy2(path_to_bib, os.path.join(folder, file))
-    else:
-        raise ValueError('can only provide one of file or folder')
+from __future__ import absolute_import
+
+# If there is a constants.[pyd|so|dylib] in the main directory, it will be imported instead of the constants.py file.
+# It should be removed as it is from the older version of CoolProp
+from . import constants
+if constants.__file__.rsplit('.', 1)[1] not in ['pyc', 'pyo', 'py']:
+
+    import os
+    try:
+        os.remove(constants.__file__)
+        print("constants shared library has been removed.  Please restart your python code")
+    except:
+        print("Unable to remove" + constants.__file__ + ". Please manually remove it")
+    quit()
+
+from .CoolProp import AbstractState
+from . import CoolProp
+from . import HumidAirProp
+from . import State
+from .constants import *
+
+__fluids__ = CoolProp.get_global_param_string('fluids_list').split(',')
+__incompressibles_pure__ = CoolProp.get_global_param_string('incompressible_list_pure').split(',')
+__incompressibles_solution__ = CoolProp.get_global_param_string('incompressible_list_solution').split(',')
+__version__ = CoolProp.get_global_param_string('version')
+__gitrevision__ = CoolProp.get_global_param_string('gitrevision')
+
+def get(s):
+    """
+    This is just a shorthand function for getting a parameter from
+    ``CoolProp.get_global_param_string``
+    """
+    return CoolProp.get_global_param_string(s)
+
+
+def test():
+    """
+    Run the tests in the test folder
+    """
+    from .tests import runner
+    runner.run()
+
+
+def get_include_directory():
+    """
+    Get the include directory for CoolProp header files that are needed if you want
+    to compile anything else that uses the CoolProp Cython extension type
+
+    Returns
+    -------
+    include_directory: The path to the include folder for CoolProp
+    """
+    import os
+    head, file = os.path.split(__file__)
+    return os.path.join(head, 'include')
+
+
+def copy_BibTeX_library(file=None, folder=None):
+    """
+    Copy the CoolProp BibTeX library file to the file given by ``file``, or the folder given by ``folder``
+
+    If no inputs are provided, the file will be copied to the current working
+    directory
+
+    Parameters
+    ----------
+    file : string
+        Provide if you want to put the file into a given file
+    folder : string
+        Provide if you want to put the CoolPropBibTeXLibrary.bib file into the given folder
+
+    """
+    import os, shutil
+    path_to_bib = os.path.join(os.path.split(__file__)[0], 'CoolPropBibTeXLibrary.bib')
+    if file is None and folder is None:
+        shutil.copy2(path_to_bib, os.path.abspath(os.curdir))
+    elif file and folder is None:
+        shutil.copy2(path_to_bib, file)
+    elif folder and file is None:
+        shutil.copy2(path_to_bib, os.path.join(folder, file))
+    else:
+        raise ValueError('can only provide one of file or folder')
```

## CoolProp/cAbstractState.pxd

 * *Ordering differences only*

```diff
@@ -1,228 +1,228 @@
-from libcpp cimport bool
-from libcpp.string cimport string
-from libcpp.vector cimport vector
-
-from . cimport constants_header
-
-from .typedefs cimport CoolPropDbl
-
-cdef extern from "PhaseEnvelope.h" namespace "CoolProp":
-    cdef cppclass PhaseEnvelopeData:
-        bool TypeI
-        size_t iTsat_max, ipsat_max, icrit
-        vector[double] T, p, lnT, lnp, rhomolar_liq, rhomolar_vap, lnrhomolar_liq, lnrhomolar_vap, hmolar_liq, hmolar_vap, smolar_liq, smolar_vap, Q
-        vector[vector[double]] x, y, K
-
-cdef extern from "DataStructures.h" namespace "CoolProp":
-    cdef cppclass CriticalState:
-        double T, p, rhomolar, hmolar, smolar
-        bool stable
-
-cdef extern from "AbstractState.h" namespace "CoolProp":
-
-    cdef cppclass GuessesStructure:
-        double T, p, rhomolar, hmolar, smolar
-        double rhomolar_liq, rhomolar_vap
-        double _rhomolar_liq, _rhomolar_vap
-        vector[double] x, y
-
-    cdef cppclass SpinodalData:
-        vector[double] tau, delta, M1
-
-    cdef cppclass AbstractState:
-
-        ## Nullary Constructor
-        AbstractState() except +ValueError
-
-        ## Constructor with fluid name
-        AbstractState(string FluidName) except +ValueError
-
-        void set_mole_fractions(vector[double]) except+ValueError
-        void set_mass_fractions(vector[double]) except+ValueError
-        void set_volu_fractions(vector[double]) except+ValueError
-
-        vector[CoolPropDbl] mole_fractions_liquid() except +ValueError
-        vector[CoolPropDbl] mole_fractions_vapor() except +ValueError
-        vector[CoolPropDbl] get_mole_fractions() except +ValueError
-        vector[CoolPropDbl] get_mass_fractions() except +ValueError
-
-        constants_header.phases phase() except +ValueError
-        void specify_phase(constants_header.phases phase) except +ValueError
-        void unspecify_phase() except +ValueError
-
-        void change_EOS(const size_t, const string &) except +ValueError
-
-        void set_binary_interaction_double(const string, const string &, const string &, const double s) except +ValueError
-        void set_binary_interaction_string(const string &, const string &, const string &, const string &) except +ValueError
-        double get_binary_interaction_double(const string &, const string &, const string &) except +ValueError
-        string get_binary_interaction_string(const string &, const string &, const string &) except +ValueError
-        void set_binary_interaction_string(const size_t, const size_t, const string &, const string &) except +ValueError
-        void apply_simple_mixing_rule(size_t, size_t, const string &) except +ValueError
-
-        double get_binary_interaction_double(const size_t, const size_t, const string &) except +ValueError
-        void set_binary_interaction_double(const size_t, const size_t, const string &, const double s) except +ValueError
-
-        string name() except +ValueError
-        string backend_name() except +ValueError
-        vector[string] fluid_names() except +ValueError
-        string fluid_param_string(const string &) except +ValueError
-        void set_fluid_parameter_double(const size_t, const string&, const double) except +ValueError
-        double get_fluid_parameter_double(const size_t, const string&) except +ValueError
-
-        bool clear()
-
-        ## Limits
-        double Tmin() except +ValueError
-        double Tmax() except +ValueError
-        double pmax() except +ValueError
-        double Ttriple() except +ValueError
-
-        ## Critical point
-        double T_critical() except +ValueError
-        double rhomass_critical() except +ValueError
-        double rhomolar_critical() except +ValueError
-        double p_critical() except +ValueError
-        vector[CriticalState] all_critical_points() except +ValueError
-        void criticality_contour_values(double &L1star, double &M1star) except +ValueError
-
-        ## Spinodal curve
-        void build_spinodal() except +ValueError
-        SpinodalData get_spinodal_data() except +ValueError
-
-        ## Tangent plane analysis
-        double tangent_plane_distance(const double, const double, const vector[double], const double) except +ValueError
-
-        ## Reducing point
-        double T_reducing() except +ValueError
-        double rhomolar_reducing() except +ValueError
-        double rhomass_reducing() except +ValueError
-
-        void ideal_curve(const string &, vector[double] &T, vector[double] &p) except +ValueError
-
-        ## Property updater
-        ## Uses the indices in CoolProp for the input parameters
-        void update(constants_header.input_pairs iInput1, double Value1, double Value2) except +ValueError
-        ## Uses the indices in CoolProp for the input parameters
-        void update_with_guesses(constants_header.input_pairs iInput1, double Value1, double Value2, GuessesStructure) except +ValueError
-
-        ## Bulk properties accessors - temperature, pressure and density are directly calculated every time
-        ## All other parameters are calculated on an as-needed basis
-        ## If single-phase, just plug into the EOS, otherwise need to do two-phase analysis
-        double T() except +ValueError
-        double rhomolar() except +ValueError
-        double rhomass() except +ValueError
-        double p() except +ValueError
-        double compressibility_factor() except +ValueError
-        double Q() except +ValueError
-        double hmolar() except +ValueError
-        double hmass() except +ValueError
-        double smolar() except +ValueError
-        double smass() except +ValueError
-        double umolar() except +ValueError
-        double umass() except +ValueError
-        double cpmolar() except +ValueError
-        double cpmass() except +ValueError
-        double cp0molar() except +ValueError
-        double cp0mass() except +ValueError
-        double cvmolar() except +ValueError
-        double cvmass() except +ValueError
-        double gibbsmolar() except +ValueError
-        double gibbsmass() except +ValueError
-        double helmholtzmolar() except +ValueError
-        double helmholtzmass() except +ValueError
-        double speed_sound() except +ValueError
-        double tau() except +ValueError
-        double delta() except +ValueError
-        double viscosity() except+ValueError
-        double conductivity() except+ValueError
-        void conformal_state(const string &, CoolPropDbl &, CoolPropDbl &) except +ValueError
-        void conductivity_contributions(CoolPropDbl &dilute, CoolPropDbl &initial_density, CoolPropDbl &residual, CoolPropDbl &critical) except +ValueError
-        void viscosity_contributions(CoolPropDbl &dilute, CoolPropDbl &initial_density, CoolPropDbl &residual, CoolPropDbl &critical) except +ValueError
-
-        double gibbsmolar_excess() except +ValueError
-        double gibbsmass_excess() except +ValueError
-        double hmolar_excess() except +ValueError
-        double hmass_excess() except +ValueError
-        double smolar_excess() except +ValueError
-        double smass_excess() except +ValueError
-        double umolar_excess() except +ValueError
-        double umass_excess() except +ValueError
-        double volumemolar_excess() except +ValueError
-        double volumemass_excess() except +ValueError
-        double helmholtzmolar_excess() except +ValueError
-        double helmholtzmass_excess() except +ValueError
-
-        double gibbsmolar_residual() except +ValueError
-        double hmolar_residual() except +ValueError
-        double smolar_residual() except +ValueError
-
-        double surface_tension() except +ValueError
-        double Prandtl() except +ValueError
-        double Bvirial() except +ValueError
-        double Cvirial() except +ValueError
-        double PIP() except +ValueError
-        double fundamental_derivative_of_gas_dynamics() except +ValueError
-        double isothermal_compressibility() except +ValueError
-        double isobaric_expansion_coefficient() except +ValueError
-        double fugacity(size_t) except +ValueError
-        double fugacity_coefficient(size_t) except +ValueError
-        double chemical_potential(size_t) except +ValueError
-
-        double get_fluid_constant(size_t,constants_header.parameters) except+ValueError
-        double keyed_output(constants_header.parameters) except+ValueError
-        double trivial_keyed_output(constants_header.parameters) except+ValueError
-        double saturated_liquid_keyed_output(constants_header.parameters) except+ValueError
-        double saturated_vapor_keyed_output(constants_header.parameters) except+ValueError
-
-        double molar_mass() except+ValueError
-        double acentric_factor() except+ValueError
-        double gas_constant() except+ValueError
-
-        CoolPropDbl first_partial_deriv(constants_header.parameters, constants_header.parameters, constants_header.parameters) except+ValueError
-        CoolPropDbl second_partial_deriv(constants_header.parameters, constants_header.parameters, constants_header.parameters, constants_header.parameters, constants_header.parameters) except+ValueError
-        CoolPropDbl first_saturation_deriv(constants_header.parameters, constants_header.parameters) except+ValueError
-        CoolPropDbl second_saturation_deriv(constants_header.parameters, constants_header.parameters, constants_header.parameters) except+ValueError
-        double first_two_phase_deriv(constants_header.parameters Of, constants_header.parameters Wrt, constants_header.parameters Constant) except+ValueError
-        double second_two_phase_deriv(constants_header.parameters Of, constants_header.parameters Wrt1, constants_header.parameters Constant1, constants_header.parameters Wrt2, constants_header.parameters Constant2) except+ValueError
-        double first_two_phase_deriv_splined(constants_header.parameters Of, constants_header.parameters Wrt, constants_header.parameters Constant, double x_end) except+ValueError
-        void true_critical_point(double &T, double &rho) except +ValueError
-
-        double melting_line(int,int,double) except+ValueError
-        bool has_melting_line() except+ValueError
-        double saturation_ancillary(constants_header.parameters, int, constants_header.parameters, double) except +ValueError
-
-        double build_phase_envelope() except+ValueError
-        void build_phase_envelope(string) except+ValueError
-        PhaseEnvelopeData get_phase_envelope_data() except+ValueError
-
-        CoolPropDbl alpha0() except+ValueError
-        CoolPropDbl dalpha0_dDelta() except+ValueError
-        CoolPropDbl dalpha0_dTau() except+ValueError
-        CoolPropDbl d2alpha0_dDelta2() except+ValueError
-        CoolPropDbl d2alpha0_dDelta_dTau() except+ValueError
-        CoolPropDbl d2alpha0_dTau2() except+ValueError
-        CoolPropDbl d3alpha0_dTau3() except+ValueError
-        CoolPropDbl d3alpha0_dDelta_dTau2() except+ValueError
-        CoolPropDbl d3alpha0_dDelta2_dTau() except+ValueError
-        CoolPropDbl d3alpha0_dDelta3() except+ValueError
-
-        CoolPropDbl alphar() except+ValueError
-        CoolPropDbl dalphar_dDelta() except+ValueError
-        CoolPropDbl dalphar_dTau() except+ValueError
-        CoolPropDbl d2alphar_dDelta2() except+ValueError
-        CoolPropDbl d2alphar_dDelta_dTau() except+ValueError
-        CoolPropDbl d2alphar_dTau2() except+ValueError
-        CoolPropDbl d3alphar_dDelta3() except+ValueError
-        CoolPropDbl d3alphar_dDelta2_dTau() except+ValueError
-        CoolPropDbl d3alphar_dDelta_dTau2() except+ValueError
-        CoolPropDbl d3alphar_dTau3() except+ValueError
-        CoolPropDbl d4alphar_dDelta4() except+ValueError
-        CoolPropDbl d4alphar_dDelta3_dTau() except+ValueError
-        CoolPropDbl d4alphar_dDelta2_dTau2() except+ValueError
-        CoolPropDbl d4alphar_dDelta_dTau3() except+ValueError
-        CoolPropDbl d4alphar_dTau4() except+ValueError
-
-
-# The static factory method for the AbstractState
-cdef extern from "AbstractState.h" namespace "CoolProp::AbstractState":
-    AbstractState* factory(const string &backend, const string &fluid_string) except+ValueError
+from libcpp cimport bool
+from libcpp.string cimport string
+from libcpp.vector cimport vector
+
+from . cimport constants_header
+
+from .typedefs cimport CoolPropDbl
+
+cdef extern from "PhaseEnvelope.h" namespace "CoolProp":
+    cdef cppclass PhaseEnvelopeData:
+        bool TypeI
+        size_t iTsat_max, ipsat_max, icrit
+        vector[double] T, p, lnT, lnp, rhomolar_liq, rhomolar_vap, lnrhomolar_liq, lnrhomolar_vap, hmolar_liq, hmolar_vap, smolar_liq, smolar_vap, Q
+        vector[vector[double]] x, y, K
+
+cdef extern from "DataStructures.h" namespace "CoolProp":
+    cdef cppclass CriticalState:
+        double T, p, rhomolar, hmolar, smolar
+        bool stable
+
+cdef extern from "AbstractState.h" namespace "CoolProp":
+
+    cdef cppclass GuessesStructure:
+        double T, p, rhomolar, hmolar, smolar
+        double rhomolar_liq, rhomolar_vap
+        double _rhomolar_liq, _rhomolar_vap
+        vector[double] x, y
+
+    cdef cppclass SpinodalData:
+        vector[double] tau, delta, M1
+
+    cdef cppclass AbstractState:
+
+        ## Nullary Constructor
+        AbstractState() except +ValueError
+
+        ## Constructor with fluid name
+        AbstractState(string FluidName) except +ValueError
+
+        void set_mole_fractions(vector[double]) except+ValueError
+        void set_mass_fractions(vector[double]) except+ValueError
+        void set_volu_fractions(vector[double]) except+ValueError
+
+        vector[CoolPropDbl] mole_fractions_liquid() except +ValueError
+        vector[CoolPropDbl] mole_fractions_vapor() except +ValueError
+        vector[CoolPropDbl] get_mole_fractions() except +ValueError
+        vector[CoolPropDbl] get_mass_fractions() except +ValueError
+
+        constants_header.phases phase() except +ValueError
+        void specify_phase(constants_header.phases phase) except +ValueError
+        void unspecify_phase() except +ValueError
+
+        void change_EOS(const size_t, const string &) except +ValueError
+
+        void set_binary_interaction_double(const string, const string &, const string &, const double s) except +ValueError
+        void set_binary_interaction_string(const string &, const string &, const string &, const string &) except +ValueError
+        double get_binary_interaction_double(const string &, const string &, const string &) except +ValueError
+        string get_binary_interaction_string(const string &, const string &, const string &) except +ValueError
+        void set_binary_interaction_string(const size_t, const size_t, const string &, const string &) except +ValueError
+        void apply_simple_mixing_rule(size_t, size_t, const string &) except +ValueError
+
+        double get_binary_interaction_double(const size_t, const size_t, const string &) except +ValueError
+        void set_binary_interaction_double(const size_t, const size_t, const string &, const double s) except +ValueError
+
+        string name() except +ValueError
+        string backend_name() except +ValueError
+        vector[string] fluid_names() except +ValueError
+        string fluid_param_string(const string &) except +ValueError
+        void set_fluid_parameter_double(const size_t, const string&, const double) except +ValueError
+        double get_fluid_parameter_double(const size_t, const string&) except +ValueError
+
+        bool clear()
+
+        ## Limits
+        double Tmin() except +ValueError
+        double Tmax() except +ValueError
+        double pmax() except +ValueError
+        double Ttriple() except +ValueError
+
+        ## Critical point
+        double T_critical() except +ValueError
+        double rhomass_critical() except +ValueError
+        double rhomolar_critical() except +ValueError
+        double p_critical() except +ValueError
+        vector[CriticalState] all_critical_points() except +ValueError
+        void criticality_contour_values(double &L1star, double &M1star) except +ValueError
+
+        ## Spinodal curve
+        void build_spinodal() except +ValueError
+        SpinodalData get_spinodal_data() except +ValueError
+
+        ## Tangent plane analysis
+        double tangent_plane_distance(const double, const double, const vector[double], const double) except +ValueError
+
+        ## Reducing point
+        double T_reducing() except +ValueError
+        double rhomolar_reducing() except +ValueError
+        double rhomass_reducing() except +ValueError
+
+        void ideal_curve(const string &, vector[double] &T, vector[double] &p) except +ValueError
+
+        ## Property updater
+        ## Uses the indices in CoolProp for the input parameters
+        void update(constants_header.input_pairs iInput1, double Value1, double Value2) except +ValueError
+        ## Uses the indices in CoolProp for the input parameters
+        void update_with_guesses(constants_header.input_pairs iInput1, double Value1, double Value2, GuessesStructure) except +ValueError
+
+        ## Bulk properties accessors - temperature, pressure and density are directly calculated every time
+        ## All other parameters are calculated on an as-needed basis
+        ## If single-phase, just plug into the EOS, otherwise need to do two-phase analysis
+        double T() except +ValueError
+        double rhomolar() except +ValueError
+        double rhomass() except +ValueError
+        double p() except +ValueError
+        double compressibility_factor() except +ValueError
+        double Q() except +ValueError
+        double hmolar() except +ValueError
+        double hmass() except +ValueError
+        double smolar() except +ValueError
+        double smass() except +ValueError
+        double umolar() except +ValueError
+        double umass() except +ValueError
+        double cpmolar() except +ValueError
+        double cpmass() except +ValueError
+        double cp0molar() except +ValueError
+        double cp0mass() except +ValueError
+        double cvmolar() except +ValueError
+        double cvmass() except +ValueError
+        double gibbsmolar() except +ValueError
+        double gibbsmass() except +ValueError
+        double helmholtzmolar() except +ValueError
+        double helmholtzmass() except +ValueError
+        double speed_sound() except +ValueError
+        double tau() except +ValueError
+        double delta() except +ValueError
+        double viscosity() except+ValueError
+        double conductivity() except+ValueError
+        void conformal_state(const string &, CoolPropDbl &, CoolPropDbl &) except +ValueError
+        void conductivity_contributions(CoolPropDbl &dilute, CoolPropDbl &initial_density, CoolPropDbl &residual, CoolPropDbl &critical) except +ValueError
+        void viscosity_contributions(CoolPropDbl &dilute, CoolPropDbl &initial_density, CoolPropDbl &residual, CoolPropDbl &critical) except +ValueError
+
+        double gibbsmolar_excess() except +ValueError
+        double gibbsmass_excess() except +ValueError
+        double hmolar_excess() except +ValueError
+        double hmass_excess() except +ValueError
+        double smolar_excess() except +ValueError
+        double smass_excess() except +ValueError
+        double umolar_excess() except +ValueError
+        double umass_excess() except +ValueError
+        double volumemolar_excess() except +ValueError
+        double volumemass_excess() except +ValueError
+        double helmholtzmolar_excess() except +ValueError
+        double helmholtzmass_excess() except +ValueError
+
+        double gibbsmolar_residual() except +ValueError
+        double hmolar_residual() except +ValueError
+        double smolar_residual() except +ValueError
+
+        double surface_tension() except +ValueError
+        double Prandtl() except +ValueError
+        double Bvirial() except +ValueError
+        double Cvirial() except +ValueError
+        double PIP() except +ValueError
+        double fundamental_derivative_of_gas_dynamics() except +ValueError
+        double isothermal_compressibility() except +ValueError
+        double isobaric_expansion_coefficient() except +ValueError
+        double fugacity(size_t) except +ValueError
+        double fugacity_coefficient(size_t) except +ValueError
+        double chemical_potential(size_t) except +ValueError
+
+        double get_fluid_constant(size_t,constants_header.parameters) except+ValueError
+        double keyed_output(constants_header.parameters) except+ValueError
+        double trivial_keyed_output(constants_header.parameters) except+ValueError
+        double saturated_liquid_keyed_output(constants_header.parameters) except+ValueError
+        double saturated_vapor_keyed_output(constants_header.parameters) except+ValueError
+
+        double molar_mass() except+ValueError
+        double acentric_factor() except+ValueError
+        double gas_constant() except+ValueError
+
+        CoolPropDbl first_partial_deriv(constants_header.parameters, constants_header.parameters, constants_header.parameters) except+ValueError
+        CoolPropDbl second_partial_deriv(constants_header.parameters, constants_header.parameters, constants_header.parameters, constants_header.parameters, constants_header.parameters) except+ValueError
+        CoolPropDbl first_saturation_deriv(constants_header.parameters, constants_header.parameters) except+ValueError
+        CoolPropDbl second_saturation_deriv(constants_header.parameters, constants_header.parameters, constants_header.parameters) except+ValueError
+        double first_two_phase_deriv(constants_header.parameters Of, constants_header.parameters Wrt, constants_header.parameters Constant) except+ValueError
+        double second_two_phase_deriv(constants_header.parameters Of, constants_header.parameters Wrt1, constants_header.parameters Constant1, constants_header.parameters Wrt2, constants_header.parameters Constant2) except+ValueError
+        double first_two_phase_deriv_splined(constants_header.parameters Of, constants_header.parameters Wrt, constants_header.parameters Constant, double x_end) except+ValueError
+        void true_critical_point(double &T, double &rho) except +ValueError
+
+        double melting_line(int,int,double) except+ValueError
+        bool has_melting_line() except+ValueError
+        double saturation_ancillary(constants_header.parameters, int, constants_header.parameters, double) except +ValueError
+
+        double build_phase_envelope() except+ValueError
+        void build_phase_envelope(string) except+ValueError
+        PhaseEnvelopeData get_phase_envelope_data() except+ValueError
+
+        CoolPropDbl alpha0() except+ValueError
+        CoolPropDbl dalpha0_dDelta() except+ValueError
+        CoolPropDbl dalpha0_dTau() except+ValueError
+        CoolPropDbl d2alpha0_dDelta2() except+ValueError
+        CoolPropDbl d2alpha0_dDelta_dTau() except+ValueError
+        CoolPropDbl d2alpha0_dTau2() except+ValueError
+        CoolPropDbl d3alpha0_dTau3() except+ValueError
+        CoolPropDbl d3alpha0_dDelta_dTau2() except+ValueError
+        CoolPropDbl d3alpha0_dDelta2_dTau() except+ValueError
+        CoolPropDbl d3alpha0_dDelta3() except+ValueError
+
+        CoolPropDbl alphar() except+ValueError
+        CoolPropDbl dalphar_dDelta() except+ValueError
+        CoolPropDbl dalphar_dTau() except+ValueError
+        CoolPropDbl d2alphar_dDelta2() except+ValueError
+        CoolPropDbl d2alphar_dDelta_dTau() except+ValueError
+        CoolPropDbl d2alphar_dTau2() except+ValueError
+        CoolPropDbl d3alphar_dDelta3() except+ValueError
+        CoolPropDbl d3alphar_dDelta2_dTau() except+ValueError
+        CoolPropDbl d3alphar_dDelta_dTau2() except+ValueError
+        CoolPropDbl d3alphar_dTau3() except+ValueError
+        CoolPropDbl d4alphar_dDelta4() except+ValueError
+        CoolPropDbl d4alphar_dDelta3_dTau() except+ValueError
+        CoolPropDbl d4alphar_dDelta2_dTau2() except+ValueError
+        CoolPropDbl d4alphar_dDelta_dTau3() except+ValueError
+        CoolPropDbl d4alphar_dTau4() except+ValueError
+
+
+# The static factory method for the AbstractState
+cdef extern from "AbstractState.h" namespace "CoolProp::AbstractState":
+    AbstractState* factory(const string &backend, const string &fluid_string) except+ValueError
```

## CoolProp/constants.py

 * *Ordering differences only*

```diff
@@ -1,165 +1,165 @@
-# This file is automatically generated by the generate_constants_module.py script in wrappers/Python.
-# DO NOT MODIFY THE CONTENTS OF THIS FILE!
-from __future__ import absolute_import
-
-from . import _constants
-
-INVALID_PARAMETER = _constants.INVALID_PARAMETER
-igas_constant = _constants.igas_constant
-imolar_mass = _constants.imolar_mass
-iacentric_factor = _constants.iacentric_factor
-irhomolar_reducing = _constants.irhomolar_reducing
-irhomolar_critical = _constants.irhomolar_critical
-iT_reducing = _constants.iT_reducing
-iT_critical = _constants.iT_critical
-irhomass_reducing = _constants.irhomass_reducing
-irhomass_critical = _constants.irhomass_critical
-iP_critical = _constants.iP_critical
-iP_reducing = _constants.iP_reducing
-iT_triple = _constants.iT_triple
-iP_triple = _constants.iP_triple
-iT_min = _constants.iT_min
-iT_max = _constants.iT_max
-iP_max = _constants.iP_max
-iP_min = _constants.iP_min
-idipole_moment = _constants.idipole_moment
-iT = _constants.iT
-iP = _constants.iP
-iQ = _constants.iQ
-iTau = _constants.iTau
-iDelta = _constants.iDelta
-iDmolar = _constants.iDmolar
-iHmolar = _constants.iHmolar
-iSmolar = _constants.iSmolar
-iCpmolar = _constants.iCpmolar
-iCp0molar = _constants.iCp0molar
-iCvmolar = _constants.iCvmolar
-iUmolar = _constants.iUmolar
-iGmolar = _constants.iGmolar
-iHelmholtzmolar = _constants.iHelmholtzmolar
-iHmolar_residual = _constants.iHmolar_residual
-iSmolar_residual = _constants.iSmolar_residual
-iGmolar_residual = _constants.iGmolar_residual
-iDmass = _constants.iDmass
-iHmass = _constants.iHmass
-iSmass = _constants.iSmass
-iCpmass = _constants.iCpmass
-iCp0mass = _constants.iCp0mass
-iCvmass = _constants.iCvmass
-iUmass = _constants.iUmass
-iGmass = _constants.iGmass
-iHelmholtzmass = _constants.iHelmholtzmass
-iviscosity = _constants.iviscosity
-iconductivity = _constants.iconductivity
-isurface_tension = _constants.isurface_tension
-iPrandtl = _constants.iPrandtl
-ispeed_sound = _constants.ispeed_sound
-iisothermal_compressibility = _constants.iisothermal_compressibility
-iisobaric_expansion_coefficient = _constants.iisobaric_expansion_coefficient
-iisentropic_expansion_coefficient = _constants.iisentropic_expansion_coefficient
-ifundamental_derivative_of_gas_dynamics = _constants.ifundamental_derivative_of_gas_dynamics
-ialphar = _constants.ialphar
-idalphar_dtau_constdelta = _constants.idalphar_dtau_constdelta
-idalphar_ddelta_consttau = _constants.idalphar_ddelta_consttau
-ialpha0 = _constants.ialpha0
-idalpha0_dtau_constdelta = _constants.idalpha0_dtau_constdelta
-idalpha0_ddelta_consttau = _constants.idalpha0_ddelta_consttau
-id2alpha0_ddelta2_consttau = _constants.id2alpha0_ddelta2_consttau
-id3alpha0_ddelta3_consttau = _constants.id3alpha0_ddelta3_consttau
-iBvirial = _constants.iBvirial
-iCvirial = _constants.iCvirial
-idBvirial_dT = _constants.idBvirial_dT
-idCvirial_dT = _constants.idCvirial_dT
-iZ = _constants.iZ
-iPIP = _constants.iPIP
-ifraction_min = _constants.ifraction_min
-ifraction_max = _constants.ifraction_max
-iT_freeze = _constants.iT_freeze
-iGWP20 = _constants.iGWP20
-iGWP100 = _constants.iGWP100
-iGWP500 = _constants.iGWP500
-iFH = _constants.iFH
-iHH = _constants.iHH
-iPH = _constants.iPH
-iODP = _constants.iODP
-iPhase = _constants.iPhase
-iundefined_parameter = _constants.iundefined_parameter
-INPUT_PAIR_INVALID = _constants.INPUT_PAIR_INVALID
-QT_INPUTS = _constants.QT_INPUTS
-PQ_INPUTS = _constants.PQ_INPUTS
-QSmolar_INPUTS = _constants.QSmolar_INPUTS
-QSmass_INPUTS = _constants.QSmass_INPUTS
-HmolarQ_INPUTS = _constants.HmolarQ_INPUTS
-HmassQ_INPUTS = _constants.HmassQ_INPUTS
-DmolarQ_INPUTS = _constants.DmolarQ_INPUTS
-DmassQ_INPUTS = _constants.DmassQ_INPUTS
-PT_INPUTS = _constants.PT_INPUTS
-DmassT_INPUTS = _constants.DmassT_INPUTS
-DmolarT_INPUTS = _constants.DmolarT_INPUTS
-HmolarT_INPUTS = _constants.HmolarT_INPUTS
-HmassT_INPUTS = _constants.HmassT_INPUTS
-SmolarT_INPUTS = _constants.SmolarT_INPUTS
-SmassT_INPUTS = _constants.SmassT_INPUTS
-TUmolar_INPUTS = _constants.TUmolar_INPUTS
-TUmass_INPUTS = _constants.TUmass_INPUTS
-DmassP_INPUTS = _constants.DmassP_INPUTS
-DmolarP_INPUTS = _constants.DmolarP_INPUTS
-HmassP_INPUTS = _constants.HmassP_INPUTS
-HmolarP_INPUTS = _constants.HmolarP_INPUTS
-PSmass_INPUTS = _constants.PSmass_INPUTS
-PSmolar_INPUTS = _constants.PSmolar_INPUTS
-PUmass_INPUTS = _constants.PUmass_INPUTS
-PUmolar_INPUTS = _constants.PUmolar_INPUTS
-HmassSmass_INPUTS = _constants.HmassSmass_INPUTS
-HmolarSmolar_INPUTS = _constants.HmolarSmolar_INPUTS
-SmassUmass_INPUTS = _constants.SmassUmass_INPUTS
-SmolarUmolar_INPUTS = _constants.SmolarUmolar_INPUTS
-DmassHmass_INPUTS = _constants.DmassHmass_INPUTS
-DmolarHmolar_INPUTS = _constants.DmolarHmolar_INPUTS
-DmassSmass_INPUTS = _constants.DmassSmass_INPUTS
-DmolarSmolar_INPUTS = _constants.DmolarSmolar_INPUTS
-DmassUmass_INPUTS = _constants.DmassUmass_INPUTS
-DmolarUmolar_INPUTS = _constants.DmolarUmolar_INPUTS
-FLUID_TYPE_PURE = _constants.FLUID_TYPE_PURE
-FLUID_TYPE_PSEUDOPURE = _constants.FLUID_TYPE_PSEUDOPURE
-FLUID_TYPE_REFPROP = _constants.FLUID_TYPE_REFPROP
-FLUID_TYPE_INCOMPRESSIBLE_LIQUID = _constants.FLUID_TYPE_INCOMPRESSIBLE_LIQUID
-FLUID_TYPE_INCOMPRESSIBLE_SOLUTION = _constants.FLUID_TYPE_INCOMPRESSIBLE_SOLUTION
-FLUID_TYPE_UNDEFINED = _constants.FLUID_TYPE_UNDEFINED
-iphase_liquid = _constants.iphase_liquid
-iphase_supercritical = _constants.iphase_supercritical
-iphase_supercritical_gas = _constants.iphase_supercritical_gas
-iphase_supercritical_liquid = _constants.iphase_supercritical_liquid
-iphase_critical_point = _constants.iphase_critical_point
-iphase_gas = _constants.iphase_gas
-iphase_twophase = _constants.iphase_twophase
-iphase_unknown = _constants.iphase_unknown
-iphase_not_imposed = _constants.iphase_not_imposed
-NORMALIZE_GAS_CONSTANTS = _constants.NORMALIZE_GAS_CONSTANTS
-CRITICAL_WITHIN_1UK = _constants.CRITICAL_WITHIN_1UK
-CRITICAL_SPLINES_ENABLED = _constants.CRITICAL_SPLINES_ENABLED
-SAVE_RAW_TABLES = _constants.SAVE_RAW_TABLES
-ALTERNATIVE_TABLES_DIRECTORY = _constants.ALTERNATIVE_TABLES_DIRECTORY
-ALTERNATIVE_REFPROP_PATH = _constants.ALTERNATIVE_REFPROP_PATH
-ALTERNATIVE_REFPROP_HMX_BNC_PATH = _constants.ALTERNATIVE_REFPROP_HMX_BNC_PATH
-ALTERNATIVE_REFPROP_LIBRARY_PATH = _constants.ALTERNATIVE_REFPROP_LIBRARY_PATH
-REFPROP_DONT_ESTIMATE_INTERACTION_PARAMETERS = _constants.REFPROP_DONT_ESTIMATE_INTERACTION_PARAMETERS
-REFPROP_IGNORE_ERROR_ESTIMATED_INTERACTION_PARAMETERS = _constants.REFPROP_IGNORE_ERROR_ESTIMATED_INTERACTION_PARAMETERS
-REFPROP_USE_GERG = _constants.REFPROP_USE_GERG
-REFPROP_ERROR_THRESHOLD = _constants.REFPROP_ERROR_THRESHOLD
-REFPROP_USE_PENGROBINSON = _constants.REFPROP_USE_PENGROBINSON
-MAXIMUM_TABLE_DIRECTORY_SIZE_IN_GB = _constants.MAXIMUM_TABLE_DIRECTORY_SIZE_IN_GB
-DONT_CHECK_PROPERTY_LIMITS = _constants.DONT_CHECK_PROPERTY_LIMITS
-HENRYS_LAW_TO_GENERATE_VLE_GUESSES = _constants.HENRYS_LAW_TO_GENERATE_VLE_GUESSES
-PHASE_ENVELOPE_STARTING_PRESSURE_PA = _constants.PHASE_ENVELOPE_STARTING_PRESSURE_PA
-R_U_CODATA = _constants.R_U_CODATA
-VTPR_UNIFAC_PATH = _constants.VTPR_UNIFAC_PATH
-SPINODAL_MINIMUM_DELTA = _constants.SPINODAL_MINIMUM_DELTA
-OVERWRITE_FLUIDS = _constants.OVERWRITE_FLUIDS
-OVERWRITE_DEPARTURE_FUNCTION = _constants.OVERWRITE_DEPARTURE_FUNCTION
-OVERWRITE_BINARY_INTERACTION = _constants.OVERWRITE_BINARY_INTERACTION
-USE_GUESSES_IN_PROPSSI = _constants.USE_GUESSES_IN_PROPSSI
-ASSUME_CRITICAL_POINT_STABLE = _constants.ASSUME_CRITICAL_POINT_STABLE
-VTPR_ALWAYS_RELOAD_LIBRARY = _constants.VTPR_ALWAYS_RELOAD_LIBRARY
-FLOAT_PUNCTUATION = _constants.FLOAT_PUNCTUATION
-LIST_STRING_DELIMITER = _constants.LIST_STRING_DELIMITER
+# This file is automatically generated by the generate_constants_module.py script in wrappers/Python.
+# DO NOT MODIFY THE CONTENTS OF THIS FILE!
+from __future__ import absolute_import
+
+from . import _constants
+
+INVALID_PARAMETER = _constants.INVALID_PARAMETER
+igas_constant = _constants.igas_constant
+imolar_mass = _constants.imolar_mass
+iacentric_factor = _constants.iacentric_factor
+irhomolar_reducing = _constants.irhomolar_reducing
+irhomolar_critical = _constants.irhomolar_critical
+iT_reducing = _constants.iT_reducing
+iT_critical = _constants.iT_critical
+irhomass_reducing = _constants.irhomass_reducing
+irhomass_critical = _constants.irhomass_critical
+iP_critical = _constants.iP_critical
+iP_reducing = _constants.iP_reducing
+iT_triple = _constants.iT_triple
+iP_triple = _constants.iP_triple
+iT_min = _constants.iT_min
+iT_max = _constants.iT_max
+iP_max = _constants.iP_max
+iP_min = _constants.iP_min
+idipole_moment = _constants.idipole_moment
+iT = _constants.iT
+iP = _constants.iP
+iQ = _constants.iQ
+iTau = _constants.iTau
+iDelta = _constants.iDelta
+iDmolar = _constants.iDmolar
+iHmolar = _constants.iHmolar
+iSmolar = _constants.iSmolar
+iCpmolar = _constants.iCpmolar
+iCp0molar = _constants.iCp0molar
+iCvmolar = _constants.iCvmolar
+iUmolar = _constants.iUmolar
+iGmolar = _constants.iGmolar
+iHelmholtzmolar = _constants.iHelmholtzmolar
+iHmolar_residual = _constants.iHmolar_residual
+iSmolar_residual = _constants.iSmolar_residual
+iGmolar_residual = _constants.iGmolar_residual
+iDmass = _constants.iDmass
+iHmass = _constants.iHmass
+iSmass = _constants.iSmass
+iCpmass = _constants.iCpmass
+iCp0mass = _constants.iCp0mass
+iCvmass = _constants.iCvmass
+iUmass = _constants.iUmass
+iGmass = _constants.iGmass
+iHelmholtzmass = _constants.iHelmholtzmass
+iviscosity = _constants.iviscosity
+iconductivity = _constants.iconductivity
+isurface_tension = _constants.isurface_tension
+iPrandtl = _constants.iPrandtl
+ispeed_sound = _constants.ispeed_sound
+iisothermal_compressibility = _constants.iisothermal_compressibility
+iisobaric_expansion_coefficient = _constants.iisobaric_expansion_coefficient
+iisentropic_expansion_coefficient = _constants.iisentropic_expansion_coefficient
+ifundamental_derivative_of_gas_dynamics = _constants.ifundamental_derivative_of_gas_dynamics
+ialphar = _constants.ialphar
+idalphar_dtau_constdelta = _constants.idalphar_dtau_constdelta
+idalphar_ddelta_consttau = _constants.idalphar_ddelta_consttau
+ialpha0 = _constants.ialpha0
+idalpha0_dtau_constdelta = _constants.idalpha0_dtau_constdelta
+idalpha0_ddelta_consttau = _constants.idalpha0_ddelta_consttau
+id2alpha0_ddelta2_consttau = _constants.id2alpha0_ddelta2_consttau
+id3alpha0_ddelta3_consttau = _constants.id3alpha0_ddelta3_consttau
+iBvirial = _constants.iBvirial
+iCvirial = _constants.iCvirial
+idBvirial_dT = _constants.idBvirial_dT
+idCvirial_dT = _constants.idCvirial_dT
+iZ = _constants.iZ
+iPIP = _constants.iPIP
+ifraction_min = _constants.ifraction_min
+ifraction_max = _constants.ifraction_max
+iT_freeze = _constants.iT_freeze
+iGWP20 = _constants.iGWP20
+iGWP100 = _constants.iGWP100
+iGWP500 = _constants.iGWP500
+iFH = _constants.iFH
+iHH = _constants.iHH
+iPH = _constants.iPH
+iODP = _constants.iODP
+iPhase = _constants.iPhase
+iundefined_parameter = _constants.iundefined_parameter
+INPUT_PAIR_INVALID = _constants.INPUT_PAIR_INVALID
+QT_INPUTS = _constants.QT_INPUTS
+PQ_INPUTS = _constants.PQ_INPUTS
+QSmolar_INPUTS = _constants.QSmolar_INPUTS
+QSmass_INPUTS = _constants.QSmass_INPUTS
+HmolarQ_INPUTS = _constants.HmolarQ_INPUTS
+HmassQ_INPUTS = _constants.HmassQ_INPUTS
+DmolarQ_INPUTS = _constants.DmolarQ_INPUTS
+DmassQ_INPUTS = _constants.DmassQ_INPUTS
+PT_INPUTS = _constants.PT_INPUTS
+DmassT_INPUTS = _constants.DmassT_INPUTS
+DmolarT_INPUTS = _constants.DmolarT_INPUTS
+HmolarT_INPUTS = _constants.HmolarT_INPUTS
+HmassT_INPUTS = _constants.HmassT_INPUTS
+SmolarT_INPUTS = _constants.SmolarT_INPUTS
+SmassT_INPUTS = _constants.SmassT_INPUTS
+TUmolar_INPUTS = _constants.TUmolar_INPUTS
+TUmass_INPUTS = _constants.TUmass_INPUTS
+DmassP_INPUTS = _constants.DmassP_INPUTS
+DmolarP_INPUTS = _constants.DmolarP_INPUTS
+HmassP_INPUTS = _constants.HmassP_INPUTS
+HmolarP_INPUTS = _constants.HmolarP_INPUTS
+PSmass_INPUTS = _constants.PSmass_INPUTS
+PSmolar_INPUTS = _constants.PSmolar_INPUTS
+PUmass_INPUTS = _constants.PUmass_INPUTS
+PUmolar_INPUTS = _constants.PUmolar_INPUTS
+HmassSmass_INPUTS = _constants.HmassSmass_INPUTS
+HmolarSmolar_INPUTS = _constants.HmolarSmolar_INPUTS
+SmassUmass_INPUTS = _constants.SmassUmass_INPUTS
+SmolarUmolar_INPUTS = _constants.SmolarUmolar_INPUTS
+DmassHmass_INPUTS = _constants.DmassHmass_INPUTS
+DmolarHmolar_INPUTS = _constants.DmolarHmolar_INPUTS
+DmassSmass_INPUTS = _constants.DmassSmass_INPUTS
+DmolarSmolar_INPUTS = _constants.DmolarSmolar_INPUTS
+DmassUmass_INPUTS = _constants.DmassUmass_INPUTS
+DmolarUmolar_INPUTS = _constants.DmolarUmolar_INPUTS
+FLUID_TYPE_PURE = _constants.FLUID_TYPE_PURE
+FLUID_TYPE_PSEUDOPURE = _constants.FLUID_TYPE_PSEUDOPURE
+FLUID_TYPE_REFPROP = _constants.FLUID_TYPE_REFPROP
+FLUID_TYPE_INCOMPRESSIBLE_LIQUID = _constants.FLUID_TYPE_INCOMPRESSIBLE_LIQUID
+FLUID_TYPE_INCOMPRESSIBLE_SOLUTION = _constants.FLUID_TYPE_INCOMPRESSIBLE_SOLUTION
+FLUID_TYPE_UNDEFINED = _constants.FLUID_TYPE_UNDEFINED
+iphase_liquid = _constants.iphase_liquid
+iphase_supercritical = _constants.iphase_supercritical
+iphase_supercritical_gas = _constants.iphase_supercritical_gas
+iphase_supercritical_liquid = _constants.iphase_supercritical_liquid
+iphase_critical_point = _constants.iphase_critical_point
+iphase_gas = _constants.iphase_gas
+iphase_twophase = _constants.iphase_twophase
+iphase_unknown = _constants.iphase_unknown
+iphase_not_imposed = _constants.iphase_not_imposed
+NORMALIZE_GAS_CONSTANTS = _constants.NORMALIZE_GAS_CONSTANTS
+CRITICAL_WITHIN_1UK = _constants.CRITICAL_WITHIN_1UK
+CRITICAL_SPLINES_ENABLED = _constants.CRITICAL_SPLINES_ENABLED
+SAVE_RAW_TABLES = _constants.SAVE_RAW_TABLES
+ALTERNATIVE_TABLES_DIRECTORY = _constants.ALTERNATIVE_TABLES_DIRECTORY
+ALTERNATIVE_REFPROP_PATH = _constants.ALTERNATIVE_REFPROP_PATH
+ALTERNATIVE_REFPROP_HMX_BNC_PATH = _constants.ALTERNATIVE_REFPROP_HMX_BNC_PATH
+ALTERNATIVE_REFPROP_LIBRARY_PATH = _constants.ALTERNATIVE_REFPROP_LIBRARY_PATH
+REFPROP_DONT_ESTIMATE_INTERACTION_PARAMETERS = _constants.REFPROP_DONT_ESTIMATE_INTERACTION_PARAMETERS
+REFPROP_IGNORE_ERROR_ESTIMATED_INTERACTION_PARAMETERS = _constants.REFPROP_IGNORE_ERROR_ESTIMATED_INTERACTION_PARAMETERS
+REFPROP_USE_GERG = _constants.REFPROP_USE_GERG
+REFPROP_ERROR_THRESHOLD = _constants.REFPROP_ERROR_THRESHOLD
+REFPROP_USE_PENGROBINSON = _constants.REFPROP_USE_PENGROBINSON
+MAXIMUM_TABLE_DIRECTORY_SIZE_IN_GB = _constants.MAXIMUM_TABLE_DIRECTORY_SIZE_IN_GB
+DONT_CHECK_PROPERTY_LIMITS = _constants.DONT_CHECK_PROPERTY_LIMITS
+HENRYS_LAW_TO_GENERATE_VLE_GUESSES = _constants.HENRYS_LAW_TO_GENERATE_VLE_GUESSES
+PHASE_ENVELOPE_STARTING_PRESSURE_PA = _constants.PHASE_ENVELOPE_STARTING_PRESSURE_PA
+R_U_CODATA = _constants.R_U_CODATA
+VTPR_UNIFAC_PATH = _constants.VTPR_UNIFAC_PATH
+SPINODAL_MINIMUM_DELTA = _constants.SPINODAL_MINIMUM_DELTA
+OVERWRITE_FLUIDS = _constants.OVERWRITE_FLUIDS
+OVERWRITE_DEPARTURE_FUNCTION = _constants.OVERWRITE_DEPARTURE_FUNCTION
+OVERWRITE_BINARY_INTERACTION = _constants.OVERWRITE_BINARY_INTERACTION
+USE_GUESSES_IN_PROPSSI = _constants.USE_GUESSES_IN_PROPSSI
+ASSUME_CRITICAL_POINT_STABLE = _constants.ASSUME_CRITICAL_POINT_STABLE
+VTPR_ALWAYS_RELOAD_LIBRARY = _constants.VTPR_ALWAYS_RELOAD_LIBRARY
+FLOAT_PUNCTUATION = _constants.FLOAT_PUNCTUATION
+LIST_STRING_DELIMITER = _constants.LIST_STRING_DELIMITER
```

## CoolProp/constants_header.pxd

 * *Ordering differences only*

```diff
@@ -1,171 +1,171 @@
-# This file is automatically generated by the generate_constants_module.py script in wrappers/Python.
-# DO NOT MODIFY THE CONTENTS OF THIS FILE!
-
-cdef extern from "DataStructures.h" namespace "CoolProp":
-	ctypedef enum parameters:
-		INVALID_PARAMETER
-		igas_constant
-		imolar_mass
-		iacentric_factor
-		irhomolar_reducing
-		irhomolar_critical
-		iT_reducing
-		iT_critical
-		irhomass_reducing
-		irhomass_critical
-		iP_critical
-		iP_reducing
-		iT_triple
-		iP_triple
-		iT_min
-		iT_max
-		iP_max
-		iP_min
-		idipole_moment
-		iT
-		iP
-		iQ
-		iTau
-		iDelta
-		iDmolar
-		iHmolar
-		iSmolar
-		iCpmolar
-		iCp0molar
-		iCvmolar
-		iUmolar
-		iGmolar
-		iHelmholtzmolar
-		iHmolar_residual
-		iSmolar_residual
-		iGmolar_residual
-		iDmass
-		iHmass
-		iSmass
-		iCpmass
-		iCp0mass
-		iCvmass
-		iUmass
-		iGmass
-		iHelmholtzmass
-		iviscosity
-		iconductivity
-		isurface_tension
-		iPrandtl
-		ispeed_sound
-		iisothermal_compressibility
-		iisobaric_expansion_coefficient
-		iisentropic_expansion_coefficient
-		ifundamental_derivative_of_gas_dynamics
-		ialphar
-		idalphar_dtau_constdelta
-		idalphar_ddelta_consttau
-		ialpha0
-		idalpha0_dtau_constdelta
-		idalpha0_ddelta_consttau
-		id2alpha0_ddelta2_consttau
-		id3alpha0_ddelta3_consttau
-		iBvirial
-		iCvirial
-		idBvirial_dT
-		idCvirial_dT
-		iZ
-		iPIP
-		ifraction_min
-		ifraction_max
-		iT_freeze
-		iGWP20
-		iGWP100
-		iGWP500
-		iFH
-		iHH
-		iPH
-		iODP
-		iPhase
-		iundefined_parameter
-	ctypedef enum input_pairs:
-		INPUT_PAIR_INVALID
-		QT_INPUTS
-		PQ_INPUTS
-		QSmolar_INPUTS
-		QSmass_INPUTS
-		HmolarQ_INPUTS
-		HmassQ_INPUTS
-		DmolarQ_INPUTS
-		DmassQ_INPUTS
-		PT_INPUTS
-		DmassT_INPUTS
-		DmolarT_INPUTS
-		HmolarT_INPUTS
-		HmassT_INPUTS
-		SmolarT_INPUTS
-		SmassT_INPUTS
-		TUmolar_INPUTS
-		TUmass_INPUTS
-		DmassP_INPUTS
-		DmolarP_INPUTS
-		HmassP_INPUTS
-		HmolarP_INPUTS
-		PSmass_INPUTS
-		PSmolar_INPUTS
-		PUmass_INPUTS
-		PUmolar_INPUTS
-		HmassSmass_INPUTS
-		HmolarSmolar_INPUTS
-		SmassUmass_INPUTS
-		SmolarUmolar_INPUTS
-		DmassHmass_INPUTS
-		DmolarHmolar_INPUTS
-		DmassSmass_INPUTS
-		DmolarSmolar_INPUTS
-		DmassUmass_INPUTS
-		DmolarUmolar_INPUTS
-	ctypedef enum fluid_types:
-		FLUID_TYPE_PURE
-		FLUID_TYPE_PSEUDOPURE
-		FLUID_TYPE_REFPROP
-		FLUID_TYPE_INCOMPRESSIBLE_LIQUID
-		FLUID_TYPE_INCOMPRESSIBLE_SOLUTION
-		FLUID_TYPE_UNDEFINED
-	ctypedef enum phases:
-		iphase_liquid
-		iphase_supercritical
-		iphase_supercritical_gas
-		iphase_supercritical_liquid
-		iphase_critical_point
-		iphase_gas
-		iphase_twophase
-		iphase_unknown
-		iphase_not_imposed
-
-
-cdef extern from "Configuration.h":
-	ctypedef enum configuration_keys:
-		NORMALIZE_GAS_CONSTANTS
-		CRITICAL_WITHIN_1UK
-		CRITICAL_SPLINES_ENABLED
-		SAVE_RAW_TABLES
-		ALTERNATIVE_TABLES_DIRECTORY
-		ALTERNATIVE_REFPROP_PATH
-		ALTERNATIVE_REFPROP_HMX_BNC_PATH
-		ALTERNATIVE_REFPROP_LIBRARY_PATH
-		REFPROP_DONT_ESTIMATE_INTERACTION_PARAMETERS
-		REFPROP_IGNORE_ERROR_ESTIMATED_INTERACTION_PARAMETERS
-		REFPROP_USE_GERG
-		REFPROP_ERROR_THRESHOLD
-		REFPROP_USE_PENGROBINSON
-		MAXIMUM_TABLE_DIRECTORY_SIZE_IN_GB
-		DONT_CHECK_PROPERTY_LIMITS
-		HENRYS_LAW_TO_GENERATE_VLE_GUESSES
-		PHASE_ENVELOPE_STARTING_PRESSURE_PA
-		R_U_CODATA
-		VTPR_UNIFAC_PATH
-		SPINODAL_MINIMUM_DELTA
-		OVERWRITE_FLUIDS
-		OVERWRITE_DEPARTURE_FUNCTION
-		OVERWRITE_BINARY_INTERACTION
-		USE_GUESSES_IN_PROPSSI
-		ASSUME_CRITICAL_POINT_STABLE
-		VTPR_ALWAYS_RELOAD_LIBRARY
-		FLOAT_PUNCTUATION
-		LIST_STRING_DELIMITER
+# This file is automatically generated by the generate_constants_module.py script in wrappers/Python.
+# DO NOT MODIFY THE CONTENTS OF THIS FILE!
+
+cdef extern from "DataStructures.h" namespace "CoolProp":
+	ctypedef enum parameters:
+		INVALID_PARAMETER
+		igas_constant
+		imolar_mass
+		iacentric_factor
+		irhomolar_reducing
+		irhomolar_critical
+		iT_reducing
+		iT_critical
+		irhomass_reducing
+		irhomass_critical
+		iP_critical
+		iP_reducing
+		iT_triple
+		iP_triple
+		iT_min
+		iT_max
+		iP_max
+		iP_min
+		idipole_moment
+		iT
+		iP
+		iQ
+		iTau
+		iDelta
+		iDmolar
+		iHmolar
+		iSmolar
+		iCpmolar
+		iCp0molar
+		iCvmolar
+		iUmolar
+		iGmolar
+		iHelmholtzmolar
+		iHmolar_residual
+		iSmolar_residual
+		iGmolar_residual
+		iDmass
+		iHmass
+		iSmass
+		iCpmass
+		iCp0mass
+		iCvmass
+		iUmass
+		iGmass
+		iHelmholtzmass
+		iviscosity
+		iconductivity
+		isurface_tension
+		iPrandtl
+		ispeed_sound
+		iisothermal_compressibility
+		iisobaric_expansion_coefficient
+		iisentropic_expansion_coefficient
+		ifundamental_derivative_of_gas_dynamics
+		ialphar
+		idalphar_dtau_constdelta
+		idalphar_ddelta_consttau
+		ialpha0
+		idalpha0_dtau_constdelta
+		idalpha0_ddelta_consttau
+		id2alpha0_ddelta2_consttau
+		id3alpha0_ddelta3_consttau
+		iBvirial
+		iCvirial
+		idBvirial_dT
+		idCvirial_dT
+		iZ
+		iPIP
+		ifraction_min
+		ifraction_max
+		iT_freeze
+		iGWP20
+		iGWP100
+		iGWP500
+		iFH
+		iHH
+		iPH
+		iODP
+		iPhase
+		iundefined_parameter
+	ctypedef enum input_pairs:
+		INPUT_PAIR_INVALID
+		QT_INPUTS
+		PQ_INPUTS
+		QSmolar_INPUTS
+		QSmass_INPUTS
+		HmolarQ_INPUTS
+		HmassQ_INPUTS
+		DmolarQ_INPUTS
+		DmassQ_INPUTS
+		PT_INPUTS
+		DmassT_INPUTS
+		DmolarT_INPUTS
+		HmolarT_INPUTS
+		HmassT_INPUTS
+		SmolarT_INPUTS
+		SmassT_INPUTS
+		TUmolar_INPUTS
+		TUmass_INPUTS
+		DmassP_INPUTS
+		DmolarP_INPUTS
+		HmassP_INPUTS
+		HmolarP_INPUTS
+		PSmass_INPUTS
+		PSmolar_INPUTS
+		PUmass_INPUTS
+		PUmolar_INPUTS
+		HmassSmass_INPUTS
+		HmolarSmolar_INPUTS
+		SmassUmass_INPUTS
+		SmolarUmolar_INPUTS
+		DmassHmass_INPUTS
+		DmolarHmolar_INPUTS
+		DmassSmass_INPUTS
+		DmolarSmolar_INPUTS
+		DmassUmass_INPUTS
+		DmolarUmolar_INPUTS
+	ctypedef enum fluid_types:
+		FLUID_TYPE_PURE
+		FLUID_TYPE_PSEUDOPURE
+		FLUID_TYPE_REFPROP
+		FLUID_TYPE_INCOMPRESSIBLE_LIQUID
+		FLUID_TYPE_INCOMPRESSIBLE_SOLUTION
+		FLUID_TYPE_UNDEFINED
+	ctypedef enum phases:
+		iphase_liquid
+		iphase_supercritical
+		iphase_supercritical_gas
+		iphase_supercritical_liquid
+		iphase_critical_point
+		iphase_gas
+		iphase_twophase
+		iphase_unknown
+		iphase_not_imposed
+
+
+cdef extern from "Configuration.h":
+	ctypedef enum configuration_keys:
+		NORMALIZE_GAS_CONSTANTS
+		CRITICAL_WITHIN_1UK
+		CRITICAL_SPLINES_ENABLED
+		SAVE_RAW_TABLES
+		ALTERNATIVE_TABLES_DIRECTORY
+		ALTERNATIVE_REFPROP_PATH
+		ALTERNATIVE_REFPROP_HMX_BNC_PATH
+		ALTERNATIVE_REFPROP_LIBRARY_PATH
+		REFPROP_DONT_ESTIMATE_INTERACTION_PARAMETERS
+		REFPROP_IGNORE_ERROR_ESTIMATED_INTERACTION_PARAMETERS
+		REFPROP_USE_GERG
+		REFPROP_ERROR_THRESHOLD
+		REFPROP_USE_PENGROBINSON
+		MAXIMUM_TABLE_DIRECTORY_SIZE_IN_GB
+		DONT_CHECK_PROPERTY_LIMITS
+		HENRYS_LAW_TO_GENERATE_VLE_GUESSES
+		PHASE_ENVELOPE_STARTING_PRESSURE_PA
+		R_U_CODATA
+		VTPR_UNIFAC_PATH
+		SPINODAL_MINIMUM_DELTA
+		OVERWRITE_FLUIDS
+		OVERWRITE_DEPARTURE_FUNCTION
+		OVERWRITE_BINARY_INTERACTION
+		USE_GUESSES_IN_PROPSSI
+		ASSUME_CRITICAL_POINT_STABLE
+		VTPR_ALWAYS_RELOAD_LIBRARY
+		FLOAT_PUNCTUATION
+		LIST_STRING_DELIMITER
```

## CoolProp/GUI/CoolPropGUI.py

 * *Ordering differences only*

```diff
@@ -1,477 +1,477 @@
-import wx
-import wx.grid
-from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as WXCanvas
-from matplotlib.backends.backend_wxagg import NavigationToolbar2Wx as WXToolbar
-import matplotlib as mpl
-import CoolProp as CP
-from CoolProp.Plots.Plots import Ph, Ts
-from CoolProp.Plots import PsychChart
-import numpy as np
-
-# Munge the system path if necessary to add the lib folder (only really needed
-# for packaging using cx_Freeze)
-# if os.path.exists('lib') and os.path.abspath(os.path.join(os.curdir,'lib')) not in os.:
-
-
-class PlotPanel(wx.Panel):
-    def __init__(self, parent, **kwargs):
-        wx.Panel.__init__(self, parent, **kwargs)
-        sizer = wx.BoxSizer(wx.VERTICAL)
-        self.figure = mpl.figure.Figure(dpi=100)
-        self.canvas = WXCanvas(self, -1, self.figure)
-        self.ax = self.figure.add_axes((0.15, 0.15, 0.8, 0.8))
-        #self.toolbar = WXToolbar(self.canvas)
-        # self.toolbar.Realize()
-        sizer.Add(self.canvas, 1, wx.EXPAND)
-        # sizer.Add(self.toolbar)
-        self.SetSizer(sizer)
-        sizer.Layout()
-
-
-class TSPlotFrame(wx.Frame):
-    def __init__(self, Fluid):
-        wx.Frame.__init__(self, None, title='T-s plot: ' + Fluid)
-
-        sizer = wx.BoxSizer(wx.HORIZONTAL)
-        self.PP = PlotPanel(self, size=(-1, -1))
-
-        sizer.Add(self.PP, 1, wx.EXPAND)
-        self.SetSizer(sizer)
-        Ts(str(Fluid),
-           axis=self.PP.ax,
-           Tmin=CP.CoolProp.Props(str(Fluid), 'Ttriple') + 0.01)
-        sizer.Layout()
-
-        self.add_menu()
-
-    def add_menu(self):
-        # Menu Bar
-        self.MenuBar = wx.MenuBar()
-        self.File = wx.Menu()
-
-        mnuItem = wx.MenuItem(self.File, -1, "Edit...", "", wx.ITEM_NORMAL)
-
-        self.File.AppendItem(mnuItem)
-        self.MenuBar.Append(self.File, "File")
-
-        self.SetMenuBar(self.MenuBar)
-
-
-class PsychOptions(wx.Dialog):
-    def __init__(self, parent):
-        wx.Dialog.__init__(self, parent)
-
-        self.build_contents()
-        self.layout()
-
-    def build_contents(self):
-        self.p_label = wx.StaticText(self, label='Pressure [kPa (absolute)]')
-        self.p = wx.TextCtrl(self, value='101.325')
-        self.Tmin_label = wx.StaticText(self, label='Minimum dry bulb temperature [\xb0 C]')
-        self.Tmin = wx.TextCtrl(self, value='-10')
-        self.Tmax_label = wx.StaticText(self, label='Maximum dry bulb temperature [\xb0 C]')
-        self.Tmax = wx.TextCtrl(self, value='60')
-        self.GoButton = wx.Button(self, label='Accept')
-        self.GoButton.Bind(wx.EVT_BUTTON, self.OnAccept)
-
-    def OnAccept(self, event):
-        self.EndModal(wx.ID_OK)
-
-    def layout(self):
-        sizer = wx.FlexGridSizer(cols=2)
-        sizer.AddMany([self.p_label, self.p, self.Tmin_label, self.Tmin, self.Tmax_label, self.Tmax])
-        sizer.Add(self.GoButton)
-        sizer.Layout()
-        self.Fit()
-
-
-class PsychPlotFrame(wx.Frame):
-    def __init__(self, Tmin=263.15, Tmax=333.15, p=101.325, **kwargs):
-
-        wx.Frame.__init__(self, None, title='Psychrometric plot', **kwargs)
-
-        sizer = wx.BoxSizer(wx.HORIZONTAL)
-        self.PP = PlotPanel(self)
-
-        self.PP.figure.delaxes(self.PP.ax)
-        self.PP.ax = self.PP.figure.add_axes((0.1, 0.1, 0.85, 0.85))
-
-        sizer.Add(self.PP, 1, wx.EXPAND)
-        self.SetSizer(sizer)
-
-        PsychChart.p = p
-        PsychChart.Tdb = np.linspace(Tmin, Tmax)
-
-        SL = PsychChart.SaturationLine()
-        SL.plot(self.PP.ax)
-
-        RHL = PsychChart.HumidityLines([0.05, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
-        RHL.plot(self.PP.ax)
-
-        HL = PsychChart.EnthalpyLines(range(-20, 100, 10))
-        HL.plot(self.PP.ax)
-
-        PF = PsychChart.PlotFormatting()
-        PF.plot(self.PP.ax)
-
-        sizer.Layout()
-
-        self.add_menu()
-
-        self.PP.toolbar = WXToolbar(self.PP.canvas)
-        self.PP.toolbar.Realize()
-        self.PP.GetSizer().Add(self.PP.toolbar)
-
-        self.PP.Layout()
-
-    def add_menu(self):
-        # Menu Bar
-        self.MenuBar = wx.MenuBar()
-        self.File = wx.Menu()
-
-        mnuItem = wx.MenuItem(self.File, -1, "Edit...", "", wx.ITEM_NORMAL)
-
-        self.File.AppendItem(mnuItem)
-        self.MenuBar.Append(self.File, "File")
-
-        self.SetMenuBar(self.MenuBar)
-
-
-class PHPlotFrame(wx.Frame):
-    def __init__(self, Fluid):
-        wx.Frame.__init__(self, None, title='p-h plot: ' + Fluid)
-
-        sizer = wx.BoxSizer(wx.HORIZONTAL)
-        self.PP = PlotPanel(self, size=(-1, -1))
-
-        sizer.Add(self.PP, 1, wx.EXPAND)
-        self.SetSizer(sizer)
-        Ph(str(Fluid),
-           axis=self.PP.ax,
-           Tmin=CP.CoolProp.Props(str(Fluid), 'Ttriple') + 0.01)
-        sizer.Layout()
-
-        self.add_menu()
-
-    def add_menu(self):
-        # Menu Bar
-        self.MenuBar = wx.MenuBar()
-        self.File = wx.Menu()
-
-        mnuItem = wx.MenuItem(self.File, -1, "Edit...", "", wx.ITEM_NORMAL)
-
-        self.File.AppendItem(mnuItem)
-        self.MenuBar.Append(self.File, "File")
-
-        self.SetMenuBar(self.MenuBar)
-
-    def overlay_points(self):
-        pass
-
-    def overlay_cycle(self):
-        pass
-
-
-class SimpleGrid(wx.grid.Grid):
-    def __init__(self, parent, ncol=20, nrow=8):
-        wx.grid.Grid.__init__(self, parent)
-
-        self.CreateGrid(ncol, nrow)
-        [self.SetCellValue(i, j, '0.0') for i in range(20) for j in range(8)]
-
-
-class SaturationTableDialog(wx.Dialog):
-    def __init__(self, parent):
-        wx.Dialog.__init__(self, parent)
-
-        self.FluidLabel = wx.StaticText(self, label="Fluid")
-        self.FluidCombo = wx.ComboBox(self)
-        self.FluidCombo.AppendItems(sorted(CP.__fluids__))
-        self.FluidCombo.SetEditable(False)
-        self.TtripleLabel = wx.StaticText(self, label="Critical Temperature [K]")
-        self.TtripleValue = wx.TextCtrl(self)
-        self.TtripleValue.Enable(False)
-        self.TcritLabel = wx.StaticText(self, label="Critical Temperature [K]")
-        self.TcritValue = wx.TextCtrl(self)
-        self.TcritValue.Enable(False)
-        self.NvalsLabel = wx.StaticText(self, label="Number of values")
-        self.NvalsValue = wx.TextCtrl(self)
-        self.TminLabel = wx.StaticText(self, label="Minimum Temperature [K]")
-        self.TminValue = wx.TextCtrl(self)
-        self.TmaxLabel = wx.StaticText(self, label="Maximum Temperature [K]")
-        self.TmaxValue = wx.TextCtrl(self)
-
-        self.Accept = wx.Button(self, label="Accept")
-
-        sizer = wx.FlexGridSizer(cols=2)
-        sizer.AddMany([self.FluidLabel, self.FluidCombo,
-                       self.TtripleLabel, self.TtripleValue,
-                       self.TcritLabel, self.TcritValue])
-        sizer.AddSpacer(10)
-        sizer.AddSpacer(10)
-        sizer.AddMany([self.NvalsLabel, self.NvalsValue,
-                       self.TminLabel, self.TminValue,
-                       self.TmaxLabel, self.TmaxValue])
-        sizer.Add(self.Accept)
-
-        self.Bind(wx.EVT_COMBOBOX, self.OnSelectFluid)
-        self.Bind(wx.EVT_BUTTON, self.OnAccept)
-
-        self.SetSizer(sizer)
-        sizer.Layout()
-        self.Fit()
-
-        # Bind a key-press event to all objects to get Esc
-        children = self.GetChildren()
-        for child in children:
-            child.Bind(wx.EVT_KEY_UP, self.OnKeyPress)
-
-    def OnKeyPress(self, event=None):
-        """ cancel if Escape key is pressed """
-        event.Skip()
-        if event.GetKeyCode() == wx.WXK_ESCAPE:
-            self.EndModal(wx.ID_CANCEL)
-
-    def get_values(self):
-        Fluid = str(self.FluidCombo.GetStringSelection())
-        if Fluid:
-            N = float(self.NvalsValue.GetValue())
-            Tmin = float(self.TminValue.GetValue())
-            Tmax = float(self.TmaxValue.GetValue())
-            Tvals = np.linspace(Tmin, Tmax, N)
-            return Fluid, Tvals
-        else:
-            return '', []
-
-    def OnCheckTmin(self):
-        pass
-
-    def OnCheckTmax(self):
-        pass
-
-    def OnAccept(self, event=None):
-        self.EndModal(wx.ID_OK)
-
-    def OnSelectFluid(self, event=None):
-        Fluid = str(self.FluidCombo.GetStringSelection())
-        if Fluid:
-            Tcrit = CP.CoolProp.Props(Fluid, 'Tcrit')
-            Ttriple = CP.CoolProp.Props(Fluid, 'Ttriple')
-            self.TcritValue.SetValue(str(Tcrit))
-            self.TtripleValue.SetValue(str(Ttriple))
-            self.NvalsValue.SetValue('100')
-            self.TminValue.SetValue(str(Ttriple + 0.01))
-            self.TmaxValue.SetValue(str(Tcrit - 0.01))
-
-
-class SaturationTable(wx.Frame):
-    def __init__(self, parent):
-        wx.Frame.__init__(self, parent)
-        self.Fluid, self.Tvals = self.OnSelect()
-        if self.Fluid:
-            self.tbl = SimpleGrid(self,
-                                  ncol=len(self.Tvals)
-                                  )
-            sizer = wx.BoxSizer(wx.VERTICAL)
-            sizer.Add(self.tbl, 1, wx.EXPAND)
-            self.SetSizer(sizer)
-            sizer.Layout()
-            self.build()
-            self.add_menu()
-        else:
-            self.Destroy()
-
-    def OnSelect(self, event=None):
-        dlg = SaturationTableDialog(None)
-        if dlg.ShowModal() == wx.ID_OK:
-            Fluid, Tvals = dlg.get_values()
-            cancel = False
-        else:
-            cancel = True
-        dlg.Destroy()
-        if not cancel:
-            return Fluid, Tvals
-        else:
-            return None, None
-
-    def build(self):
-        self.SetTitle('Saturation Table: ' + self.Fluid)
-        self.tbl.SetColLabelValue(0, "Temperature\n[K]")
-        self.tbl.SetColLabelValue(1, "Liquid Pressure\n[kPa]")
-        self.tbl.SetColLabelValue(2, "Vapor Pressure\n[kPa]")
-        self.tbl.SetColLabelValue(3, "Liquid Density\n[kg/m3]")
-        self.tbl.SetColLabelValue(4, "Vapor Density\n[kg/m3]")
-
-        for i, T in enumerate(self.Tvals):
-            Fluid = self.Fluid
-            pL = CP.CoolProp.Props('P', 'T', T, 'Q', 0, Fluid)
-            pV = CP.CoolProp.Props('P', 'T', T, 'Q', 1, Fluid)
-            rhoL = CP.CoolProp.Props('D', 'T', T, 'Q', 0, Fluid)
-            rhoV = CP.CoolProp.Props('D', 'T', T, 'Q', 1, Fluid)
-
-            self.tbl.SetCellValue(i, 0, str(T))
-            self.tbl.SetCellValue(i, 1, str(pL))
-            self.tbl.SetCellValue(i, 2, str(pV))
-            self.tbl.SetCellValue(i, 3, str(rhoL))
-            self.tbl.SetCellValue(i, 4, str(rhoV))
-
-    def add_menu(self):
-        # Menu Bar
-        self.MenuBar = wx.MenuBar()
-        self.File = wx.Menu()
-
-        mnuItem0 = wx.MenuItem(self.File, -1, "Select All \tCtrl+A", "", wx.ITEM_NORMAL)
-        mnuItem1 = wx.MenuItem(self.File, -1, "Copy selected data \tCtrl+C", "", wx.ITEM_NORMAL)
-        mnuItem2 = wx.MenuItem(self.File, -1, "Copy table w/ headers \tCtrl+H", "", wx.ITEM_NORMAL)
-
-        self.File.AppendItem(mnuItem0)
-        self.File.AppendItem(mnuItem1)
-        self.File.AppendItem(mnuItem2)
-        self.MenuBar.Append(self.File, "Edit")
-        self.Bind(wx.EVT_MENU, lambda event: self.tbl.SelectAll(), mnuItem0)
-        self.Bind(wx.EVT_MENU, self.OnCopy, mnuItem1)
-        self.Bind(wx.EVT_MENU, self.OnCopyHeaders, mnuItem2)
-
-        self.SetMenuBar(self.MenuBar)
-
-    def OnCopy(self, event=None):
-
-        # Number of rows and cols
-        rows = self.tbl.GetSelectionBlockBottomRight()[0][0] - self.tbl.GetSelectionBlockTopLeft()[0][0] + 1
-        cols = self.tbl.GetSelectionBlockBottomRight()[0][1] - self.tbl.GetSelectionBlockTopLeft()[0][1] + 1
-
-        # data variable contain text that must be set in the clipboard
-        data = ''
-
-        # For each cell in selected range append the cell value in the data variable
-        # Tabs '\t' for cols and '\r' for rows
-        for r in range(rows):
-            for c in range(cols):
-                data = data + str(self.tbl.GetCellValue(self.tbl.GetSelectionBlockTopLeft()[0][0] + r, self.tbl.GetSelectionBlockTopLeft()[0][1] + c))
-                if c < cols - 1:
-                    data = data + '\t'
-            data = data + '\n'
-        # Create text data object
-        clipboard = wx.TextDataObject()
-        # Set data object value
-        clipboard.SetText(data)
-        # Put the data in the clipboard
-        if wx.TheClipboard.Open():
-            wx.TheClipboard.SetData(clipboard)
-            wx.TheClipboard.Close()
-        else:
-            wx.MessageBox("Can't open the clipboard", "Error")
-        event.Skip()
-
-    def OnCopyHeaders(self, event=None):
-        self.tbl.SelectAll()
-        # Number of rows and cols
-        rows = self.tbl.GetSelectionBlockBottomRight()[0][0] - self.tbl.GetSelectionBlockTopLeft()[0][0] + 1
-        cols = self.tbl.GetSelectionBlockBottomRight()[0][1] - self.tbl.GetSelectionBlockTopLeft()[0][1] + 1
-
-        # data variable contain text that must be set in the clipboard
-        data = ''
-
-        # Add the headers
-        for c in range(cols):
-            data += str(self.tbl.GetColLabelValue(c).replace('\n', ' '))
-            if c < cols - 1:
-                data += '\t'
-        data = data + '\n'
-        # For each cell in selected range append the cell value in the data variable
-        # Tabs '\t' for cols and '\r' for rows
-        for r in range(rows):
-            for c in range(cols):
-                data = data + str(self.tbl.GetCellValue(self.tbl.GetSelectionBlockTopLeft()[0][0] + r, self.tbl.GetSelectionBlockTopLeft()[0][1] + c))
-                if c < cols - 1:
-                    data = data + '\t'
-            data = data + '\n'
-        # Create text data object
-        clipboard = wx.TextDataObject()
-        # Set data object value
-        clipboard.SetText(data)
-        # Put the data in the clipboard
-        if wx.TheClipboard.Open():
-            wx.TheClipboard.SetData(clipboard)
-            wx.TheClipboard.Close()
-        else:
-            wx.MessageBox("Can't open the clipboard", "Error")
-        event.Skip()
-
-
-class MainFrame(wx.Frame):
-
-    def __init__(self):
-        wx.Frame.__init__(self, None)
-
-        self.build()
-
-    def build(self):
-        # Menu Bar
-        self.MenuBar = wx.MenuBar()
-
-        self.plots = wx.Menu()
-        self.PHPlot = wx.Menu()
-        self.TSPlot = wx.Menu()
-        self.tables = wx.Menu()
-        self.PsychPlot = wx.MenuItem(self.plots, -1, 'Psychrometric Plot')
-        self.SatTable = wx.MenuItem(self.tables, -1, ' Saturation Table', "", wx.ITEM_NORMAL)
-
-        for Fluid in sorted(CP.__fluids__):
-            mnuItem = wx.MenuItem(self.PHPlot, -1, Fluid, "", wx.ITEM_NORMAL)
-            self.PHPlot.AppendItem(mnuItem)
-            self.Bind(wx.EVT_MENU, lambda event: self.OnPHPlot(event, mnuItem), mnuItem)
-
-            mnuItem = wx.MenuItem(self.TSPlot, -1, Fluid, "", wx.ITEM_NORMAL)
-            self.TSPlot.AppendItem(mnuItem)
-            self.Bind(wx.EVT_MENU, lambda event: self.OnTSPlot(event, mnuItem), mnuItem)
-
-        self.MenuBar.Append(self.plots, "Plots")
-        self.plots.AppendItem(self.PsychPlot)
-        self.plots.AppendMenu(-1, 'p-h plot', self.PHPlot)
-        self.plots.AppendMenu(-1, 'T-s plot', self.TSPlot)
-        self.MenuBar.Append(self.tables, "Tables")
-        self.tables.AppendItem(self.SatTable)
-        self.Bind(wx.EVT_MENU, self.OnSatTable, self.SatTable)
-        self.Bind(wx.EVT_MENU, self.OnPsychPlot, self.PsychPlot)
-
-        self.SetMenuBar(self.MenuBar)
-
-    def OnPsychPlot(self, event=None):
-
-        # Load the options
-        dlg = PsychOptions(None)
-        if dlg.ShowModal() == wx.ID_OK:
-            Tmin = float(dlg.Tmin.GetValue()) + 273.15
-            Tmax = float(dlg.Tmax.GetValue()) + 273.15
-            p = float(dlg.p.GetValue())
-            PPF = PsychPlotFrame(Tmin=Tmin, Tmax=Tmax, p=p, size=(1000, 700))
-            PPF.Show()
-        dlg.Destroy()
-
-    def OnSatTable(self, event):
-        TBL = SaturationTable(None)
-        TBL.Show()
-
-    def OnPHPlot(self, event, mnuItem):
-        # Make a p-h plot instance in a new frame
-        # Get the label (Fluid name)
-        Fluid = self.PHPlot.FindItemById(event.Id).Label
-        PH = PHPlotFrame(Fluid)
-        PH.Show()
-
-    def OnTSPlot(self, event, mnuItem):
-        # Make a p-h plot instance in a new frame
-        # Get the label (Fluid name)
-        Fluid = self.TSPlot.FindItemById(event.Id).Label
-        TS = TSPlotFrame(Fluid)
-        TS.Show()
-
-
-if __name__ == '__main__':
-    app = wx.App(False)
-    wx.InitAllImageHandlers()
-
-    frame = MainFrame()
-    frame.Show(True)
-    app.MainLoop()
+import wx
+import wx.grid
+from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as WXCanvas
+from matplotlib.backends.backend_wxagg import NavigationToolbar2Wx as WXToolbar
+import matplotlib as mpl
+import CoolProp as CP
+from CoolProp.Plots.Plots import Ph, Ts
+from CoolProp.Plots import PsychChart
+import numpy as np
+
+# Munge the system path if necessary to add the lib folder (only really needed
+# for packaging using cx_Freeze)
+# if os.path.exists('lib') and os.path.abspath(os.path.join(os.curdir,'lib')) not in os.:
+
+
+class PlotPanel(wx.Panel):
+    def __init__(self, parent, **kwargs):
+        wx.Panel.__init__(self, parent, **kwargs)
+        sizer = wx.BoxSizer(wx.VERTICAL)
+        self.figure = mpl.figure.Figure(dpi=100)
+        self.canvas = WXCanvas(self, -1, self.figure)
+        self.ax = self.figure.add_axes((0.15, 0.15, 0.8, 0.8))
+        #self.toolbar = WXToolbar(self.canvas)
+        # self.toolbar.Realize()
+        sizer.Add(self.canvas, 1, wx.EXPAND)
+        # sizer.Add(self.toolbar)
+        self.SetSizer(sizer)
+        sizer.Layout()
+
+
+class TSPlotFrame(wx.Frame):
+    def __init__(self, Fluid):
+        wx.Frame.__init__(self, None, title='T-s plot: ' + Fluid)
+
+        sizer = wx.BoxSizer(wx.HORIZONTAL)
+        self.PP = PlotPanel(self, size=(-1, -1))
+
+        sizer.Add(self.PP, 1, wx.EXPAND)
+        self.SetSizer(sizer)
+        Ts(str(Fluid),
+           axis=self.PP.ax,
+           Tmin=CP.CoolProp.Props(str(Fluid), 'Ttriple') + 0.01)
+        sizer.Layout()
+
+        self.add_menu()
+
+    def add_menu(self):
+        # Menu Bar
+        self.MenuBar = wx.MenuBar()
+        self.File = wx.Menu()
+
+        mnuItem = wx.MenuItem(self.File, -1, "Edit...", "", wx.ITEM_NORMAL)
+
+        self.File.AppendItem(mnuItem)
+        self.MenuBar.Append(self.File, "File")
+
+        self.SetMenuBar(self.MenuBar)
+
+
+class PsychOptions(wx.Dialog):
+    def __init__(self, parent):
+        wx.Dialog.__init__(self, parent)
+
+        self.build_contents()
+        self.layout()
+
+    def build_contents(self):
+        self.p_label = wx.StaticText(self, label='Pressure [kPa (absolute)]')
+        self.p = wx.TextCtrl(self, value='101.325')
+        self.Tmin_label = wx.StaticText(self, label='Minimum dry bulb temperature [\xb0 C]')
+        self.Tmin = wx.TextCtrl(self, value='-10')
+        self.Tmax_label = wx.StaticText(self, label='Maximum dry bulb temperature [\xb0 C]')
+        self.Tmax = wx.TextCtrl(self, value='60')
+        self.GoButton = wx.Button(self, label='Accept')
+        self.GoButton.Bind(wx.EVT_BUTTON, self.OnAccept)
+
+    def OnAccept(self, event):
+        self.EndModal(wx.ID_OK)
+
+    def layout(self):
+        sizer = wx.FlexGridSizer(cols=2)
+        sizer.AddMany([self.p_label, self.p, self.Tmin_label, self.Tmin, self.Tmax_label, self.Tmax])
+        sizer.Add(self.GoButton)
+        sizer.Layout()
+        self.Fit()
+
+
+class PsychPlotFrame(wx.Frame):
+    def __init__(self, Tmin=263.15, Tmax=333.15, p=101.325, **kwargs):
+
+        wx.Frame.__init__(self, None, title='Psychrometric plot', **kwargs)
+
+        sizer = wx.BoxSizer(wx.HORIZONTAL)
+        self.PP = PlotPanel(self)
+
+        self.PP.figure.delaxes(self.PP.ax)
+        self.PP.ax = self.PP.figure.add_axes((0.1, 0.1, 0.85, 0.85))
+
+        sizer.Add(self.PP, 1, wx.EXPAND)
+        self.SetSizer(sizer)
+
+        PsychChart.p = p
+        PsychChart.Tdb = np.linspace(Tmin, Tmax)
+
+        SL = PsychChart.SaturationLine()
+        SL.plot(self.PP.ax)
+
+        RHL = PsychChart.HumidityLines([0.05, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
+        RHL.plot(self.PP.ax)
+
+        HL = PsychChart.EnthalpyLines(range(-20, 100, 10))
+        HL.plot(self.PP.ax)
+
+        PF = PsychChart.PlotFormatting()
+        PF.plot(self.PP.ax)
+
+        sizer.Layout()
+
+        self.add_menu()
+
+        self.PP.toolbar = WXToolbar(self.PP.canvas)
+        self.PP.toolbar.Realize()
+        self.PP.GetSizer().Add(self.PP.toolbar)
+
+        self.PP.Layout()
+
+    def add_menu(self):
+        # Menu Bar
+        self.MenuBar = wx.MenuBar()
+        self.File = wx.Menu()
+
+        mnuItem = wx.MenuItem(self.File, -1, "Edit...", "", wx.ITEM_NORMAL)
+
+        self.File.AppendItem(mnuItem)
+        self.MenuBar.Append(self.File, "File")
+
+        self.SetMenuBar(self.MenuBar)
+
+
+class PHPlotFrame(wx.Frame):
+    def __init__(self, Fluid):
+        wx.Frame.__init__(self, None, title='p-h plot: ' + Fluid)
+
+        sizer = wx.BoxSizer(wx.HORIZONTAL)
+        self.PP = PlotPanel(self, size=(-1, -1))
+
+        sizer.Add(self.PP, 1, wx.EXPAND)
+        self.SetSizer(sizer)
+        Ph(str(Fluid),
+           axis=self.PP.ax,
+           Tmin=CP.CoolProp.Props(str(Fluid), 'Ttriple') + 0.01)
+        sizer.Layout()
+
+        self.add_menu()
+
+    def add_menu(self):
+        # Menu Bar
+        self.MenuBar = wx.MenuBar()
+        self.File = wx.Menu()
+
+        mnuItem = wx.MenuItem(self.File, -1, "Edit...", "", wx.ITEM_NORMAL)
+
+        self.File.AppendItem(mnuItem)
+        self.MenuBar.Append(self.File, "File")
+
+        self.SetMenuBar(self.MenuBar)
+
+    def overlay_points(self):
+        pass
+
+    def overlay_cycle(self):
+        pass
+
+
+class SimpleGrid(wx.grid.Grid):
+    def __init__(self, parent, ncol=20, nrow=8):
+        wx.grid.Grid.__init__(self, parent)
+
+        self.CreateGrid(ncol, nrow)
+        [self.SetCellValue(i, j, '0.0') for i in range(20) for j in range(8)]
+
+
+class SaturationTableDialog(wx.Dialog):
+    def __init__(self, parent):
+        wx.Dialog.__init__(self, parent)
+
+        self.FluidLabel = wx.StaticText(self, label="Fluid")
+        self.FluidCombo = wx.ComboBox(self)
+        self.FluidCombo.AppendItems(sorted(CP.__fluids__))
+        self.FluidCombo.SetEditable(False)
+        self.TtripleLabel = wx.StaticText(self, label="Critical Temperature [K]")
+        self.TtripleValue = wx.TextCtrl(self)
+        self.TtripleValue.Enable(False)
+        self.TcritLabel = wx.StaticText(self, label="Critical Temperature [K]")
+        self.TcritValue = wx.TextCtrl(self)
+        self.TcritValue.Enable(False)
+        self.NvalsLabel = wx.StaticText(self, label="Number of values")
+        self.NvalsValue = wx.TextCtrl(self)
+        self.TminLabel = wx.StaticText(self, label="Minimum Temperature [K]")
+        self.TminValue = wx.TextCtrl(self)
+        self.TmaxLabel = wx.StaticText(self, label="Maximum Temperature [K]")
+        self.TmaxValue = wx.TextCtrl(self)
+
+        self.Accept = wx.Button(self, label="Accept")
+
+        sizer = wx.FlexGridSizer(cols=2)
+        sizer.AddMany([self.FluidLabel, self.FluidCombo,
+                       self.TtripleLabel, self.TtripleValue,
+                       self.TcritLabel, self.TcritValue])
+        sizer.AddSpacer(10)
+        sizer.AddSpacer(10)
+        sizer.AddMany([self.NvalsLabel, self.NvalsValue,
+                       self.TminLabel, self.TminValue,
+                       self.TmaxLabel, self.TmaxValue])
+        sizer.Add(self.Accept)
+
+        self.Bind(wx.EVT_COMBOBOX, self.OnSelectFluid)
+        self.Bind(wx.EVT_BUTTON, self.OnAccept)
+
+        self.SetSizer(sizer)
+        sizer.Layout()
+        self.Fit()
+
+        # Bind a key-press event to all objects to get Esc
+        children = self.GetChildren()
+        for child in children:
+            child.Bind(wx.EVT_KEY_UP, self.OnKeyPress)
+
+    def OnKeyPress(self, event=None):
+        """ cancel if Escape key is pressed """
+        event.Skip()
+        if event.GetKeyCode() == wx.WXK_ESCAPE:
+            self.EndModal(wx.ID_CANCEL)
+
+    def get_values(self):
+        Fluid = str(self.FluidCombo.GetStringSelection())
+        if Fluid:
+            N = float(self.NvalsValue.GetValue())
+            Tmin = float(self.TminValue.GetValue())
+            Tmax = float(self.TmaxValue.GetValue())
+            Tvals = np.linspace(Tmin, Tmax, N)
+            return Fluid, Tvals
+        else:
+            return '', []
+
+    def OnCheckTmin(self):
+        pass
+
+    def OnCheckTmax(self):
+        pass
+
+    def OnAccept(self, event=None):
+        self.EndModal(wx.ID_OK)
+
+    def OnSelectFluid(self, event=None):
+        Fluid = str(self.FluidCombo.GetStringSelection())
+        if Fluid:
+            Tcrit = CP.CoolProp.Props(Fluid, 'Tcrit')
+            Ttriple = CP.CoolProp.Props(Fluid, 'Ttriple')
+            self.TcritValue.SetValue(str(Tcrit))
+            self.TtripleValue.SetValue(str(Ttriple))
+            self.NvalsValue.SetValue('100')
+            self.TminValue.SetValue(str(Ttriple + 0.01))
+            self.TmaxValue.SetValue(str(Tcrit - 0.01))
+
+
+class SaturationTable(wx.Frame):
+    def __init__(self, parent):
+        wx.Frame.__init__(self, parent)
+        self.Fluid, self.Tvals = self.OnSelect()
+        if self.Fluid:
+            self.tbl = SimpleGrid(self,
+                                  ncol=len(self.Tvals)
+                                  )
+            sizer = wx.BoxSizer(wx.VERTICAL)
+            sizer.Add(self.tbl, 1, wx.EXPAND)
+            self.SetSizer(sizer)
+            sizer.Layout()
+            self.build()
+            self.add_menu()
+        else:
+            self.Destroy()
+
+    def OnSelect(self, event=None):
+        dlg = SaturationTableDialog(None)
+        if dlg.ShowModal() == wx.ID_OK:
+            Fluid, Tvals = dlg.get_values()
+            cancel = False
+        else:
+            cancel = True
+        dlg.Destroy()
+        if not cancel:
+            return Fluid, Tvals
+        else:
+            return None, None
+
+    def build(self):
+        self.SetTitle('Saturation Table: ' + self.Fluid)
+        self.tbl.SetColLabelValue(0, "Temperature\n[K]")
+        self.tbl.SetColLabelValue(1, "Liquid Pressure\n[kPa]")
+        self.tbl.SetColLabelValue(2, "Vapor Pressure\n[kPa]")
+        self.tbl.SetColLabelValue(3, "Liquid Density\n[kg/m3]")
+        self.tbl.SetColLabelValue(4, "Vapor Density\n[kg/m3]")
+
+        for i, T in enumerate(self.Tvals):
+            Fluid = self.Fluid
+            pL = CP.CoolProp.Props('P', 'T', T, 'Q', 0, Fluid)
+            pV = CP.CoolProp.Props('P', 'T', T, 'Q', 1, Fluid)
+            rhoL = CP.CoolProp.Props('D', 'T', T, 'Q', 0, Fluid)
+            rhoV = CP.CoolProp.Props('D', 'T', T, 'Q', 1, Fluid)
+
+            self.tbl.SetCellValue(i, 0, str(T))
+            self.tbl.SetCellValue(i, 1, str(pL))
+            self.tbl.SetCellValue(i, 2, str(pV))
+            self.tbl.SetCellValue(i, 3, str(rhoL))
+            self.tbl.SetCellValue(i, 4, str(rhoV))
+
+    def add_menu(self):
+        # Menu Bar
+        self.MenuBar = wx.MenuBar()
+        self.File = wx.Menu()
+
+        mnuItem0 = wx.MenuItem(self.File, -1, "Select All \tCtrl+A", "", wx.ITEM_NORMAL)
+        mnuItem1 = wx.MenuItem(self.File, -1, "Copy selected data \tCtrl+C", "", wx.ITEM_NORMAL)
+        mnuItem2 = wx.MenuItem(self.File, -1, "Copy table w/ headers \tCtrl+H", "", wx.ITEM_NORMAL)
+
+        self.File.AppendItem(mnuItem0)
+        self.File.AppendItem(mnuItem1)
+        self.File.AppendItem(mnuItem2)
+        self.MenuBar.Append(self.File, "Edit")
+        self.Bind(wx.EVT_MENU, lambda event: self.tbl.SelectAll(), mnuItem0)
+        self.Bind(wx.EVT_MENU, self.OnCopy, mnuItem1)
+        self.Bind(wx.EVT_MENU, self.OnCopyHeaders, mnuItem2)
+
+        self.SetMenuBar(self.MenuBar)
+
+    def OnCopy(self, event=None):
+
+        # Number of rows and cols
+        rows = self.tbl.GetSelectionBlockBottomRight()[0][0] - self.tbl.GetSelectionBlockTopLeft()[0][0] + 1
+        cols = self.tbl.GetSelectionBlockBottomRight()[0][1] - self.tbl.GetSelectionBlockTopLeft()[0][1] + 1
+
+        # data variable contain text that must be set in the clipboard
+        data = ''
+
+        # For each cell in selected range append the cell value in the data variable
+        # Tabs '\t' for cols and '\r' for rows
+        for r in range(rows):
+            for c in range(cols):
+                data = data + str(self.tbl.GetCellValue(self.tbl.GetSelectionBlockTopLeft()[0][0] + r, self.tbl.GetSelectionBlockTopLeft()[0][1] + c))
+                if c < cols - 1:
+                    data = data + '\t'
+            data = data + '\n'
+        # Create text data object
+        clipboard = wx.TextDataObject()
+        # Set data object value
+        clipboard.SetText(data)
+        # Put the data in the clipboard
+        if wx.TheClipboard.Open():
+            wx.TheClipboard.SetData(clipboard)
+            wx.TheClipboard.Close()
+        else:
+            wx.MessageBox("Can't open the clipboard", "Error")
+        event.Skip()
+
+    def OnCopyHeaders(self, event=None):
+        self.tbl.SelectAll()
+        # Number of rows and cols
+        rows = self.tbl.GetSelectionBlockBottomRight()[0][0] - self.tbl.GetSelectionBlockTopLeft()[0][0] + 1
+        cols = self.tbl.GetSelectionBlockBottomRight()[0][1] - self.tbl.GetSelectionBlockTopLeft()[0][1] + 1
+
+        # data variable contain text that must be set in the clipboard
+        data = ''
+
+        # Add the headers
+        for c in range(cols):
+            data += str(self.tbl.GetColLabelValue(c).replace('\n', ' '))
+            if c < cols - 1:
+                data += '\t'
+        data = data + '\n'
+        # For each cell in selected range append the cell value in the data variable
+        # Tabs '\t' for cols and '\r' for rows
+        for r in range(rows):
+            for c in range(cols):
+                data = data + str(self.tbl.GetCellValue(self.tbl.GetSelectionBlockTopLeft()[0][0] + r, self.tbl.GetSelectionBlockTopLeft()[0][1] + c))
+                if c < cols - 1:
+                    data = data + '\t'
+            data = data + '\n'
+        # Create text data object
+        clipboard = wx.TextDataObject()
+        # Set data object value
+        clipboard.SetText(data)
+        # Put the data in the clipboard
+        if wx.TheClipboard.Open():
+            wx.TheClipboard.SetData(clipboard)
+            wx.TheClipboard.Close()
+        else:
+            wx.MessageBox("Can't open the clipboard", "Error")
+        event.Skip()
+
+
+class MainFrame(wx.Frame):
+
+    def __init__(self):
+        wx.Frame.__init__(self, None)
+
+        self.build()
+
+    def build(self):
+        # Menu Bar
+        self.MenuBar = wx.MenuBar()
+
+        self.plots = wx.Menu()
+        self.PHPlot = wx.Menu()
+        self.TSPlot = wx.Menu()
+        self.tables = wx.Menu()
+        self.PsychPlot = wx.MenuItem(self.plots, -1, 'Psychrometric Plot')
+        self.SatTable = wx.MenuItem(self.tables, -1, ' Saturation Table', "", wx.ITEM_NORMAL)
+
+        for Fluid in sorted(CP.__fluids__):
+            mnuItem = wx.MenuItem(self.PHPlot, -1, Fluid, "", wx.ITEM_NORMAL)
+            self.PHPlot.AppendItem(mnuItem)
+            self.Bind(wx.EVT_MENU, lambda event: self.OnPHPlot(event, mnuItem), mnuItem)
+
+            mnuItem = wx.MenuItem(self.TSPlot, -1, Fluid, "", wx.ITEM_NORMAL)
+            self.TSPlot.AppendItem(mnuItem)
+            self.Bind(wx.EVT_MENU, lambda event: self.OnTSPlot(event, mnuItem), mnuItem)
+
+        self.MenuBar.Append(self.plots, "Plots")
+        self.plots.AppendItem(self.PsychPlot)
+        self.plots.AppendMenu(-1, 'p-h plot', self.PHPlot)
+        self.plots.AppendMenu(-1, 'T-s plot', self.TSPlot)
+        self.MenuBar.Append(self.tables, "Tables")
+        self.tables.AppendItem(self.SatTable)
+        self.Bind(wx.EVT_MENU, self.OnSatTable, self.SatTable)
+        self.Bind(wx.EVT_MENU, self.OnPsychPlot, self.PsychPlot)
+
+        self.SetMenuBar(self.MenuBar)
+
+    def OnPsychPlot(self, event=None):
+
+        # Load the options
+        dlg = PsychOptions(None)
+        if dlg.ShowModal() == wx.ID_OK:
+            Tmin = float(dlg.Tmin.GetValue()) + 273.15
+            Tmax = float(dlg.Tmax.GetValue()) + 273.15
+            p = float(dlg.p.GetValue())
+            PPF = PsychPlotFrame(Tmin=Tmin, Tmax=Tmax, p=p, size=(1000, 700))
+            PPF.Show()
+        dlg.Destroy()
+
+    def OnSatTable(self, event):
+        TBL = SaturationTable(None)
+        TBL.Show()
+
+    def OnPHPlot(self, event, mnuItem):
+        # Make a p-h plot instance in a new frame
+        # Get the label (Fluid name)
+        Fluid = self.PHPlot.FindItemById(event.Id).Label
+        PH = PHPlotFrame(Fluid)
+        PH.Show()
+
+    def OnTSPlot(self, event, mnuItem):
+        # Make a p-h plot instance in a new frame
+        # Get the label (Fluid name)
+        Fluid = self.TSPlot.FindItemById(event.Id).Label
+        TS = TSPlotFrame(Fluid)
+        TS.Show()
+
+
+if __name__ == '__main__':
+    app = wx.App(False)
+    wx.InitAllImageHandlers()
+
+    frame = MainFrame()
+    frame.Show(True)
+    app.MainLoop()
```

## CoolProp/GUI/PsychScript.py

 * *Ordering differences only*

```diff
@@ -1,35 +1,35 @@
-
-import numpy as np
-import matplotlib.pyplot as plt
-from CoolProp.HumidAirProp import HAProps
-
-Tdb = np.linspace(-10, 55, 100) + 273.15
-
-# Make the figure and the axes
-fig = plt.figure(figsize=(10, 8))
-ax = fig.add_axes((0.15, 0.15, 0.8, 0.8))
-ax.set_xlim(Tdb[0] - 273.15, Tdb[-1] - 273.15)
-ax.set_ylim(0, 0.03)
-ax.set_xlabel(r"Dry bulb temperature [$^{\circ}$C]")
-ax.set_ylabel(r"Humidity ratio ($m_{water}/m_{dry\ air}$) [-]")
-
-# Saturation line
-w = [HAProps('W', 'T', T, 'P', 101.325, 'R', 1.0) for T in Tdb]
-ax.plot(Tdb - 273.15, w, lw=2)
-
-# Humidity lines
-RHValues = [0.05, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]
-for RH in RHValues:
-    w = [HAProps('W', 'T', T, 'P', 101.325, 'R', RH) for T in Tdb]
-    ax.plot(Tdb - 273.15, w, 'r', lw=1)
-
-# Humidity lines
-for H in [-20, -10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90]:
-    # Line goes from saturation to zero humidity ratio for this enthalpy
-    T1 = HAProps('T', 'H', H, 'P', 101.325, 'R', 1.0) - 273.15
-    T0 = HAProps('T', 'H', H, 'P', 101.325, 'R', 0.0) - 273.15
-    w1 = HAProps('W', 'H', H, 'P', 101.325, 'R', 1.0)
-    w0 = HAProps('W', 'H', H, 'P', 101.325, 'R', 0.0)
-    ax.plot(np.r_[T1, T0], np.r_[w1, w0], 'r', lw=1)
-
-plt.show()
+
+import numpy as np
+import matplotlib.pyplot as plt
+from CoolProp.HumidAirProp import HAProps
+
+Tdb = np.linspace(-10, 55, 100) + 273.15
+
+# Make the figure and the axes
+fig = plt.figure(figsize=(10, 8))
+ax = fig.add_axes((0.15, 0.15, 0.8, 0.8))
+ax.set_xlim(Tdb[0] - 273.15, Tdb[-1] - 273.15)
+ax.set_ylim(0, 0.03)
+ax.set_xlabel(r"Dry bulb temperature [$^{\circ}$C]")
+ax.set_ylabel(r"Humidity ratio ($m_{water}/m_{dry\ air}$) [-]")
+
+# Saturation line
+w = [HAProps('W', 'T', T, 'P', 101.325, 'R', 1.0) for T in Tdb]
+ax.plot(Tdb - 273.15, w, lw=2)
+
+# Humidity lines
+RHValues = [0.05, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]
+for RH in RHValues:
+    w = [HAProps('W', 'T', T, 'P', 101.325, 'R', RH) for T in Tdb]
+    ax.plot(Tdb - 273.15, w, 'r', lw=1)
+
+# Humidity lines
+for H in [-20, -10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90]:
+    # Line goes from saturation to zero humidity ratio for this enthalpy
+    T1 = HAProps('T', 'H', H, 'P', 101.325, 'R', 1.0) - 273.15
+    T0 = HAProps('T', 'H', H, 'P', 101.325, 'R', 0.0) - 273.15
+    w1 = HAProps('W', 'H', H, 'P', 101.325, 'R', 1.0)
+    w0 = HAProps('W', 'H', H, 'P', 101.325, 'R', 0.0)
+    ax.plot(np.r_[T1, T0], np.r_[w1, w0], 'r', lw=1)
+
+plt.show()
```

## CoolProp/Plots/Common.py

 * *Ordering differences only*

```diff
@@ -1,1167 +1,1167 @@
-# -*- coding: utf-8 -*-
-from __future__ import print_function, division, absolute_import
-
-import matplotlib.pyplot as plt
-import numpy as np
-from abc import ABCMeta
-from six import with_metaclass
-import warnings
-
-import CoolProp
-from CoolProp import AbstractState
-from CoolProp import CoolProp as CP
-from CoolProp.CoolProp import PropsSI, extract_backend, extract_fractions, PyCriticalState
-
-
-def get_critical_point(state):
-    crit_state = PyCriticalState()
-    crit_state.T = np.nan
-    crit_state.p = np.nan
-    crit_state.rhomolar = np.nan
-    crit_state.rhomolar = np.nan
-    crit_state.stable = False
-    try:
-        crit_state.T = state.T_critical()
-        crit_state.p = state.p_critical()
-        crit_state.rhomolar = state.rhomolar_critical()
-        crit_state.stable = True
-    except:
-        try:
-            for crit_state_tmp in state.all_critical_points():
-                if crit_state_tmp.stable and (crit_state_tmp.T > crit_state.T or not np.isfinite(crit_state.T)):
-                    crit_state.T = crit_state_tmp.T
-                    crit_state.p = crit_state_tmp.p
-                    crit_state.rhomolar = crit_state_tmp.rhomolar
-                    crit_state.stable = crit_state_tmp.stable
-        except:
-            raise ValueError("Could not calculate the critical point data.")
-    new_state = AbstractState(state.backend_name(), '&'.join(state.fluid_names()))
-    masses = state.get_mass_fractions()
-    if len(masses) > 1:
-        new_state.set_mass_fractions(masses)  # Uses mass fraction to work with incompressibles
-        # try: new_state.build_phase_envelope("dummy")
-        # except: pass
-    msg = ""
-    if np.isfinite(crit_state.p) and np.isfinite(crit_state.T):
-        try:
-            new_state.specify_phase(CoolProp.iphase_critical_point)
-            new_state.update(CoolProp.PT_INPUTS, crit_state.p, crit_state.T)
-            return new_state
-        except Exception as e:
-            msg += str(e) + " - "
-            pass
-        try:
-            new_state.update(CoolProp.PT_INPUTS, crit_state.p, crit_state.T)
-            return new_state
-        except Exception as e:
-            msg += str(e) + " - "
-            pass
-    if np.isfinite(crit_state.rhomolar) and np.isfinite(crit_state.T):
-        try:
-            new_state.specify_phase(CoolProp.iphase_critical_point)
-            new_state.update(CoolProp.DmolarT_INPUTS, crit_state.rhomolar, crit_state.T)
-            return new_state
-        except Exception as e:
-            msg += str(e) + " - "
-            pass
-        try:
-            new_state.update(CoolProp.DmolarT_INPUTS, crit_state.rhomolar, crit_state.T)
-            return new_state
-        except Exception as e:
-            msg += str(e) + " - "
-            pass
-    raise ValueError("Could not calculate the critical point data. " + msg)
-
-
-def interpolate_values_1d(x, y, x_points=None, kind='linear'):
-    try:
-        from scipy.interpolate.interpolate import interp1d
-        if x_points is None:
-            return interp1d(x, y, kind=kind)(x[np.isfinite(x)])
-        else:
-            return interp1d(x, y, kind=kind)(x_points)
-    except ImportError:
-        if kind != 'linear':
-            warnings.warn(
-              "You requested a non-linear interpolation, but SciPy is not available. Falling back to linear interpolation.",
-              UserWarning)
-        if x_points is None:
-            return np.interp((x[np.isfinite(x)]), x, y)
-        else:
-            return np.interp(x_points, x, y)
-
-
-def is_string(in_obj):
-    try:
-        return isinstance(in_obj, basestring)
-    except NameError:
-        return isinstance(in_obj, str)
-    # except:
-    #    return False
-
-
-def process_fluid_state(fluid_ref, fractions='mole'):
-    """Check input for state object or fluid string
-
-    Parameters
-    ----------
-        fluid_ref : str, CoolProp.AbstractState
-        fractions : str, switch to set mass, volu or mole fractions
-
-    Returns
-    -------
-        CoolProp.AbstractState
-    """
-    # Process the fluid and set self._state
-    if is_string(fluid_ref):
-        backend, fluids = extract_backend(fluid_ref)
-        fluids, fractions = extract_fractions(fluids)
-        state = AbstractState(backend, '&'.join(fluids))
-        if len(fluids) > 1 and len(fluids) == len(fractions):
-            if fractions == 'mass': state.set_mass_fractions(fractions)
-            elif fractions == 'volu': state.set_volu_fractions(fractions)
-            else: state.set_mole_fractions(fractions)
-        return state
-    elif isinstance(fluid_ref, AbstractState):
-        return fluid_ref
-    raise TypeError("Invalid fluid_ref input, expected a string or an abstract state instance.")
-
-
-def _get_index(prop):
-    if is_string(prop):
-        return CP.get_parameter_index(prop)
-    elif isinstance(prop, int):
-        return prop
-    else:
-        raise ValueError("Invalid input, expected a string or an int, not {0:s}.".format(str(prop)))
-
-
-class BaseQuantity(object):
-    """A very basic property that can convert an input to and from a
-    given unit system, note that the conversion from SI units starts
-    with a multiplication. If you need to remove an offset, use the
-    off_SI property.
-    Examples with temperature:
-    celsius = BaseQuantity(add_SI=-273.15)
-    fahrenheit = BaseQuantity(add_SI=32.0, mul_SI=1.8, off_SI=-273.15)
-    Examples with pressure:
-    bar = BaseQuantity(mul_SI=1e-5)
-    psi = BaseQuantity(mul_SI=0.000145037738)
-    """
-
-    def __init__(self, add_SI=0.0, mul_SI=1.0, off_SI=0.0):
-        self._add_SI = add_SI
-        self._mul_SI = mul_SI
-        self._off_SI = off_SI
-
-    @property
-    def add_SI(self): return self._add_SI
-
-    @add_SI.setter
-    def add_SI(self, value): self._add_SI = value
-
-    @property
-    def mul_SI(self): return self._mul_SI
-
-    @mul_SI.setter
-    def mul_SI(self, value): self._mul_SI = value
-
-    @property
-    def off_SI(self): return self._off_SI
-
-    @off_SI.setter
-    def off_SI(self, value): self._off_SI = value
-
-    def from_SI(self, value): return ((value + self.off_SI) * self.mul_SI) + self.add_SI
-
-    def to_SI(self, value): return (value - self.add_SI) / self.mul_SI - self.off_SI
-
-
-class BaseDimension(BaseQuantity):
-    """A dimension is a class that extends the BaseQuantity and adds a label, a symbol and a unit label"""
-
-    def __init__(self, add_SI=0.0, mul_SI=1.0, off_SI=0.0, label='', symbol='', unit=''):
-        self._label = label
-        self._symbol = symbol
-        self._unit = unit
-        super(BaseDimension, self).__init__(add_SI=add_SI, mul_SI=mul_SI, off_SI=off_SI)
-
-    @property
-    def label(self): return self._label
-
-    @label.setter
-    def label(self, value): self._label = value
-
-    @property
-    def symbol(self): return self._symbol
-
-    @symbol.setter
-    def symbol(self, value): self._symbol = value
-
-    @property
-    def unit(self): return self._unit
-
-    @unit.setter
-    def unit(self, value): self._unit = value
-
-
-class PropertyDict(with_metaclass(ABCMeta), object):
-    """A collection of dimensions for all the required quantities"""
-
-    def __init__(self):
-        self._D = None
-        self._H = None
-        self._P = None
-        self._S = None
-        self._T = None
-        self._U = None
-        self._Q = None
-
-    @property
-    def D(self): return self._D
-
-    @D.setter
-    def D(self, value): self._D = value
-
-    @property
-    def H(self): return self._H
-
-    @H.setter
-    def H(self, value): self._H = value
-
-    @property
-    def P(self): return self._P
-
-    @P.setter
-    def P(self, value): self._P = value
-
-    @property
-    def S(self): return self._S
-
-    @S.setter
-    def S(self, value): self._S = value
-
-    @property
-    def T(self): return self._T
-
-    @T.setter
-    def T(self, value): self._T = value
-
-    @property
-    def U(self): return self._U
-
-    @U.setter
-    def U(self, value): self._U = value
-
-    @property
-    def Q(self): return self._Q
-
-    @Q.setter
-    def Q(self, value): self._Q = value
-
-    @property
-    def dimensions(self):
-        return {
-      CoolProp.iDmass: self._D,
-      CoolProp.iHmass: self._H,
-      CoolProp.iP: self._P,
-      CoolProp.iSmass: self._S,
-      CoolProp.iT: self._T,
-      CoolProp.iUmass: self._U,
-      CoolProp.iQ: self._Q
-    }
-
-    def __getitem__(self, index):
-        """Allow for property access via square brackets"""
-        idx = _get_index(index)
-        if idx == CoolProp.iDmass: return self.D
-        elif idx == CoolProp.iHmass: return self.H
-        elif idx == CoolProp.iP: return self.P
-        elif idx == CoolProp.iSmass: return self.S
-        elif idx == CoolProp.iT: return self.T
-        elif idx == CoolProp.iUmass: return self.U
-        elif idx == CoolProp.iQ: return self.Q
-        else: raise IndexError("Unknown index \"{0:s}\".".format(str(index)))
-
-    def __setitem__(self, index, value):
-        """Allow for property access via square brackets"""
-        idx = _get_index(index)
-        if idx == CoolProp.iDmass: self.D = value
-        elif idx == CoolProp.iHmass: self.H = value
-        elif idx == CoolProp.iP: self.P = value
-        elif idx == CoolProp.iSmass: self.S = value
-        elif idx == CoolProp.iT: self.T = value
-        elif idx == CoolProp.iUmass: self.U = value
-        elif idx == CoolProp.iQ: self.Q = value
-        else: raise IndexError("Unknown index \"{0:s}\".".format(str(index)))
-
-
-class SIunits(PropertyDict):
-    def __init__(self):
-        self._D = BaseDimension(add_SI=0.0, mul_SI=1.0, off_SI=0.0, label='Density', symbol=u'd', unit=u'kg/m3')
-        self._H = BaseDimension(add_SI=0.0, mul_SI=1.0, off_SI=0.0, label='Specific Enthalpy', symbol=u'h', unit=u'J/kg')
-        self._P = BaseDimension(add_SI=0.0, mul_SI=1.0, off_SI=0.0, label='Pressure', symbol=u'p', unit=u'Pa')
-        self._S = BaseDimension(add_SI=0.0, mul_SI=1.0, off_SI=0.0, label='Specific Entropy', symbol=u's', unit=u'J/kg/K')
-        self._T = BaseDimension(add_SI=0.0, mul_SI=1.0, off_SI=0.0, label='Temperature', symbol=u'T', unit=u'K')
-        self._U = BaseDimension(add_SI=0.0, mul_SI=1.0, off_SI=0.0, label='Specific Internal Energy', symbol=u'u', unit=u'J/kg')
-        self._Q = BaseDimension(add_SI=0.0, mul_SI=1.0, off_SI=0.0, label='Vapour Quality', symbol=u'x', unit=u'')
-
-
-class KSIunits(SIunits):
-    def __init__(self):
-        super(KSIunits, self).__init__()
-        self.H.mul_SI = 1e-3
-        self.H.unit = u'kJ/kg'
-        self.P.mul_SI = 1e-3
-        self.P.unit = u'kPa'
-        self.S.mul_SI = 1e-3
-        self.S.unit = u'kJ/kg/K'
-        self.U.mul_SI = 1e-3
-        self.U.unit = u'kJ/kg'
-
-
-class EURunits(KSIunits):
-    def __init__(self):
-        super(EURunits, self).__init__()
-        self.P.mul_SI = 1e-5
-        self.P.unit = u'bar'
-        self.T.add_SI = -273.15
-        self.T.unit = u'deg C'
-
-
-class Base2DObject(with_metaclass(ABCMeta), object):
-    """A container for shared settings and constants for the
-    isolines and the property plots."""
-
-    # A list of supported plot
-    TS = CoolProp.iT * 10 + CoolProp.iSmass
-    PH = CoolProp.iP * 10 + CoolProp.iHmass
-    HS = CoolProp.iHmass * 10 + CoolProp.iSmass
-    PS = CoolProp.iP * 10 + CoolProp.iSmass
-    PD = CoolProp.iP * 10 + CoolProp.iDmass
-    TD = CoolProp.iT * 10 + CoolProp.iDmass
-    PT = CoolProp.iP * 10 + CoolProp.iT
-    PU = CoolProp.iP * 10 + CoolProp.iUmass
-
-    PLOTS = {
-      'TS': TS,
-      'PH': PH,
-      'HS': HS,
-      'PS': PS,
-      'PD': PD,
-      'TD': TD,
-      'PT': PT,
-    }
-
-    PLOTS_INV = {v: k for k, v in PLOTS.items()}
-
-#     # A list of supported plot
-#     @property
-#     def TS(self): return type(self).TS
-#     @property
-#     def PH(self): return CoolProp.iP*10     + CoolProp.iHmass
-#     @property
-#     def HS(self): return CoolProp.iHmass*10 + CoolProp.iSmass
-#     @property
-#     def PS(self): return CoolProp.iP*10     + CoolProp.iSmass
-#     @property
-#     def PD(self): return CoolProp.iP*10     + CoolProp.iDmass
-#     @property
-#     def TD(self): return CoolProp.iT*10     + CoolProp.iDmass
-#     @property
-#     def PT(self): return CoolProp.iP*10     + CoolProp.iT
-#     @property
-#     def PU(self): return CoolProp.iP*10     + CoolProp.iUmass
-
-    def __init__(self, x_type, y_type, state=None, small=None):
-        self._x_index = _get_index(x_type)
-        self._y_index = _get_index(y_type)
-        self._critical_state = None
-        if small is not None: self._small = small
-        else: self._small = 1e-7
-        if state is not None: self.state = state
-        else: self._state = None
-
-    # A list of supported plot
-    @property
-    def x_index(self): return self._x_index
-
-    @property
-    def y_index(self): return self._y_index
-
-    @property
-    def critical_state(self):
-        if self._critical_state is None and self._state is not None:
-            self._critical_state = get_critical_point(self._state)
-        return self._critical_state
-
-    @property
-    def state(self): return self._state
-
-    @state.setter
-    def state(self, value):
-        self._state = process_fluid_state(value)
-        # try: self._state.build_phase_envelope("dummy")
-        # except: pass
-        self._critical_state = None
-        #self._T_small = self._state.trivial_keyed_output(CoolProp.iT_critical)*self._small
-        #self._P_small = self._state.trivial_keyed_output(CoolProp.iP_critical)*self._small
-        self._T_small = self.critical_state.keyed_output(CoolProp.iT) * self._small
-        self._P_small = self.critical_state.keyed_output(CoolProp.iP) * self._small
-
-    def _get_sat_bounds(self, kind, smin=None, smax=None):
-        """Generates limits for the saturation line in either T or p determined
-        by 'kind'. If smin or smax are provided, values will be checked
-        against the allowable range for the EOS and a warning might be
-        generated. Returns a tuple containing (xmin, xmax)"""
-
-        # TODO: REFPROP backend does not have ptriple.
-        T_triple = self._state.trivial_keyed_output(CoolProp.iT_triple)
-        try:
-            T_min = self._state.trivial_keyed_output(CoolProp.iT_min)
-        except:
-            T_min = T_triple
-        self._state.update(CoolProp.QT_INPUTS, 0, max([T_triple, T_min]) + self._T_small)
-        kind = _get_index(kind)
-        if kind == CoolProp.iP:
-            fluid_min = self._state.keyed_output(CoolProp.iP) + self._P_small
-            fluid_max = self.critical_state.keyed_output(CoolProp.iP) - self._P_small
-        elif kind == CoolProp.iT:
-            fluid_min = self._state.keyed_output(CoolProp.iT) + self._T_small
-            fluid_max = self.critical_state.keyed_output(CoolProp.iT) - self._T_small
-        else:
-            raise ValueError("Saturation boundaries have to be defined in T or P, but not in {0:s}".format(str(kind)))
-
-        if smin is not None:
-            if fluid_min < smin < fluid_max:
-                sat_min = smin
-            else:
-                warnings.warn(
-                  "Your minimum {0:s} has been ignored, {1:f} is not between {2:f} and {3:f}".format(self.PROPERTIES[kind], smin, fluid_min, fluid_max),
-                  UserWarning)
-                sat_min = fluid_min
-        else:
-            sat_min = fluid_min
-
-        if smax is not None:
-            if fluid_min < smax < fluid_max:
-                sat_max = smax
-            else:
-                warnings.warn(
-                  "Your maximum {0:s} has been ignored, {1:f} is not between {2:f} and {3:f}".format(self.PROPERTIES[kind], smax, fluid_min, fluid_max),
-                  UserWarning)
-                sat_max = fluid_max
-        else:
-            sat_max = fluid_max
-
-        return sat_min, sat_max
-
-
-class IsoLine(Base2DObject):
-    """An object that holds the functions to calculate a line of
-    a constant property in the dimensions of a property plot. This
-    class only uses SI units."""
-
-    # Normally we calculate a sweep in x-dimensions, but
-    # sometimes a sweep in y-dimensions is better.
-    XY_SWITCH = {
-      CoolProp.iDmass: {Base2DObject.TS: True, Base2DObject.PH: True, Base2DObject.HS: False, Base2DObject.PS: True, Base2DObject.PD: None, Base2DObject.TD: None, Base2DObject.PT: False},
-      CoolProp.iHmass: {Base2DObject.TS: False, Base2DObject.PH: None, Base2DObject.HS: None, Base2DObject.PS: True, Base2DObject.PD: True, Base2DObject.TD: False, Base2DObject.PT: False},
-      CoolProp.iP: {Base2DObject.TS: False, Base2DObject.PH: None, Base2DObject.HS: False, Base2DObject.PS: None, Base2DObject.PD: None, Base2DObject.TD: False, Base2DObject.PT: None},
-      CoolProp.iSmass: {Base2DObject.TS: None, Base2DObject.PH: True, Base2DObject.HS: None, Base2DObject.PS: None, Base2DObject.PD: True, Base2DObject.TD: False, Base2DObject.PT: True},
-      CoolProp.iT: {Base2DObject.TS: None, Base2DObject.PH: True, Base2DObject.HS: False, Base2DObject.PS: False, Base2DObject.PD: False, Base2DObject.TD: None, Base2DObject.PT: None},
-      CoolProp.iQ: {Base2DObject.TS: True, Base2DObject.PH: True, Base2DObject.HS: True, Base2DObject.PS: True, Base2DObject.PD: True, Base2DObject.TD: True, Base2DObject.PT: False}
-    }
-
-    # Abort interpolation if there are not enough
-    # valid entries.
-    VALID_REQ = 5.0 / 100.0
-
-    def __init__(self, i_index, x_index, y_index, value=0.0, state=None):
-        super(IsoLine, self).__init__(x_index, y_index, state)
-        self._i_index = _get_index(i_index)
-        if value is not None: self.value = value
-        else: self._value = None
-        self._x = None
-        self._y = None
-
-    @property
-    def i_index(self): return self._i_index
-
-    @property
-    def value(self): return self._value
-
-    @value.setter
-    def value(self, value): self._value = float(value)
-
-    @property
-    def x(self): return self._x
-
-    @x.setter
-    def x(self, value): self._x = np.array(value)
-
-    @property
-    def y(self): return self._y
-
-    @y.setter
-    def y(self, value): self._y = np.array(value)
-
-    def get_update_pair(self):
-        """Processes the values for the isoproperty and the graph dimensions
-        to figure which should be used as inputs to the state update. Returns
-        a tuple with the indices for the update call and the property constant.
-        For an isobar in a Ts-diagram it returns the default order and the
-        correct constant for the update pair:
-        get_update_pair(CoolProp.iP,CoolProp.iSmass,CoolProp.iT) -> (0,1,2,CoolProp.PSmass_INPUTS)
-        other values require switching and swapping.
-        """
-        # Figure out if x or y-dimension should be used
-        switch = self.XY_SWITCH[self.i_index][self.y_index * 10 + self.x_index]
-
-        if switch is None:
-            raise ValueError("This isoline cannot be calculated!")
-        elif switch is False:
-            pair, out1, _ = CP.generate_update_pair(self.i_index, 0.0, self.x_index, 1.0)
-        elif switch is True:
-            pair, out1, _ = CP.generate_update_pair(self.i_index, 0.0, self.y_index, 1.0)
-        else:
-            raise ValueError("Unknown error!")
-
-        if out1 == 0.0:  # Correct order
-            swap = False
-        else:  # Wrong order
-            swap = True
-
-        if not switch and not swap:
-            return 0, 1, 2, pair
-        elif switch and not swap:
-            return 0, 2, 1, pair
-        elif not switch and swap:
-            return 1, 0, 2, pair
-        elif switch and swap:
-            return 1, 2, 0, pair
-        else:
-            raise ValueError("Check the code, this should not happen!")
-
-    def calc_sat_range(self, Trange=None, Prange=None, num=200):
-        if Trange is not None:
-            two = np.array(Trange)
-            one = np.resize(np.array(self.value), two.shape)
-            pair = CoolProp.QT_INPUTS
-        elif Prange is not None:
-            one = np.array(Prange)
-            two = np.resize(np.array(self.value), one.shape)
-            pair = CoolProp.PQ_INPUTS
-        else:
-            T_lo, T_hi = self._get_sat_bounds(CoolProp.iT)
-            two = np.linspace(T_lo, T_hi, num)
-            one = np.resize(np.array(self.value), two.shape)
-            pair = CoolProp.QT_INPUTS
-
-        Tcrit = self.critical_state.keyed_output(CoolProp.iT)
-        Pcrit = self.critical_state.keyed_output(CoolProp.iP)
-        Dcrit = self.critical_state.keyed_output(CoolProp.iDmass)
-        try:
-            #self.state.update(CoolProp.DmassT_INPUTS, Dcrit, Tcrit)
-            #xcrit = self.state.keyed_output(self._x_index)
-            #ycrit = self.state.keyed_output(self._y_index)
-            xcrit = self.critical_state.keyed_output(self._x_index)
-            ycrit = self.critical_state.keyed_output(self._y_index)
-        except:
-            warnings.warn(
-              "An error occurred for the critical inputs, skipping it.",
-              UserWarning)
-            xcrit = np.NaN
-            ycrit = np.NaN
-
-        X = np.empty_like(one)
-        Y = np.empty_like(one)
-
-        err = False
-        for index, _ in np.ndenumerate(one):
-            try:
-                self.state.update(pair, one[index], two[index])
-                X[index] = self.state.keyed_output(self._x_index)
-                Y[index] = self.state.keyed_output(self._y_index)
-            except Exception as e:
-                if (pair == CoolProp.QT_INPUTS and abs(two[index] - Tcrit) < 1e0) or \
-                   (pair == CoolProp.PQ_INPUTS and abs(one[index] - Pcrit) < 1e2):
-                    X[index] = xcrit
-                    Y[index] = ycrit
-                    warnings.warn(
-                  "An error occurred for near critical inputs {0:f}, {1:f} with index {2:s}: {3:s}".format(one[index], two[index], str(index), str(e)),
-                  UserWarning)
-                    pass
-
-                warnings.warn(
-                  "An error occurred for inputs {0:f}, {1:f} with index {2:s}: {3:s}".format(one[index], two[index], str(index), str(e)),
-                  UserWarning)
-                X[index] = np.NaN
-                Y[index] = np.NaN
-                err = True
-        self.x = X; self.y = Y
-        return
-
-    def calc_range(self, xvals=None, yvals=None):
-
-        if self.i_index == CoolProp.iQ:
-            warnings.warn(
-                "Please use \"calc_sat_range\" to calculate saturation and isoquality lines. Input ranges are discarded.",
-                UserWarning)
-            if xvals is not None: self.calc_sat_range(num=xvals.size)
-            elif yvals is not None: self.calc_sat_range(num=yvals.size)
-            else: self.calc_sat_range()
-            return
-
-        ipos, xpos, ypos, pair = self.get_update_pair()
-
-        order = [ipos, xpos, ypos]
-        idxs = [v for (_, v) in sorted(zip(order, [self.i_index, self.x_index, self.y_index]))]
-        vals = [v for (_, v) in sorted(zip(order, [np.array(self.value), xvals, yvals]))]
-        if vals[0] is None or vals[1] is None:
-            raise ValueError("One required input is missing, make sure to supply the correct xvals ({0:s}) or yvals ({1:s}).".format(str(xvals), str(yvals)))
-
-        if vals[0].size > vals[1].size:
-            vals[1] = np.resize(vals[1], vals[0].shape)
-        elif vals[0].size < vals[1].size:
-            vals[0] = np.resize(vals[0], vals[1].shape)
-
-        vals[2] = np.empty_like(vals[0])
-        err = False
-        guesses = CoolProp.CoolProp.PyGuessesStructure()
-        # Only use the guesses for selected inputs
-        if pair == CoolProp.HmolarP_INPUTS \
-          or pair == CoolProp.HmassP_INPUTS:
-            # or pair == CoolProp.HmassSmass_INPUTS \
-            # or pair == CoolProp.HmolarSmolar_INPUTS \
-            # or pair == CoolProp.PSmass_INPUTS \
-            # or pair == CoolProp.PSmolar_INPUTS:
-            use_guesses = True
-        else:
-            use_guesses = False
-        for index, _ in np.ndenumerate(vals[0]):
-            try:
-                if use_guesses:
-                    if np.isfinite(guesses.rhomolar):
-                        self.state.update_with_guesses(pair, vals[0][index], vals[1][index], guesses)
-                    else:
-                        self.state.update(pair, vals[0][index], vals[1][index])
-                    guesses.rhomolar = self.state.rhomolar()
-                    guesses.T = self.state.T()
-                else:
-                    self.state.update(pair, vals[0][index], vals[1][index])
-                vals[2][index] = self.state.keyed_output(idxs[2])
-            except Exception as e:
-                warnings.warn(
-                  "An error occurred for inputs {0:f}, {1:f} with index {2:s}: {3:s}".format(vals[0][index], vals[1][index], str(index), str(e)),
-                  UserWarning)
-                vals[2][index] = np.NaN
-                guesses.rhomolar = np.NaN
-                guesses.T = np.NaN
-                err = True
-
-        for i, v in enumerate(idxs):
-            if v == self.x_index: self.x = vals[i]
-            if v == self.y_index: self.y = vals[i]
-
-    def sanitize_data(self):
-        """Fill the series via interpolation"""
-        validx = None; validy = None
-        countx = None; county = None
-        if self.x is not None:
-            validx = np.isfinite(self.x)
-            countx = float(self.x.size)
-        else:
-            raise ValueError("The x-axis is not populated, calculate values before you interpolate.")
-        if self.y is not None:
-            validy = np.isfinite(self.y)
-            county = float(self.y.size)
-        else:
-            raise ValueError("The y-axis is not populated, calculate values before you interpolate.")
-
-        if min([np.sum(validx) / countx, np.sum(validy) / county]) < self.VALID_REQ:
-            warnings.warn(
-              "Poor data quality, there are not enough valid entries for x ({0:f}/{1:f}) or y ({2:f}/{3:f}).".format(np.sum(validx), countx, np.sum(validy), county),
-              UserWarning)
-        # TODO: use filter and cubic splines!
-        #filter = np.logical_and(np.isfinite(self.x),np.isfinite(self.y))
-        if np.sum(validy) > np.sum(validx):
-            self.x = interpolate_values_1d(self.y, self.x, x_points=self.y[validy])
-            self.y = self.y[validy]
-        else:
-            self.y = interpolate_values_1d(self.x, self.y, x_points=self.x[validx])
-            self.x = self.x[validx]
-
-
-class BasePlot(Base2DObject):
-    """The base class for all plots. It can be instantiated itself, but provides many
-    general facilities to be used in the different plots. """
-
-    # Define the iteration keys
-    PROPERTIES = {
-      CoolProp.iDmass: 'density',
-      CoolProp.iHmass: 'specific enthalpy',
-      CoolProp.iP: 'pressure',
-      CoolProp.iSmass: 'specific entropy',
-      CoolProp.iT: 'temperature',
-      CoolProp.iUmass: 'specific internal energy'
-    }
-
-    # Define the unit systems
-    UNIT_SYSTEMS = {
-      'SI': SIunits(),
-      'KSI': KSIunits(),
-      'EUR': EURunits()
-    }
-
-    LINE_PROPS = {
-      CoolProp.iT: dict(color='Darkred', lw=0.25),
-      CoolProp.iP: dict(color='DarkCyan', lw=0.25),
-      CoolProp.iHmass: dict(color='DarkGreen', lw=0.25),
-      CoolProp.iDmass: dict(color='DarkBlue', lw=0.25),
-      CoolProp.iSmass: dict(color='DarkOrange', lw=0.25),
-      CoolProp.iQ: dict(color='black', lw=0.25)
-    }
-
-    ID_FACTOR = 10.0  # Values below this number are interpreted as factors
-    HI_FACTOR = 2.25  # Upper default limits: HI_FACTOR*T_crit and HI_FACTOR*p_crit
-    LO_FACTOR = 1.01  # Lower default limits: LO_FACTOR*T_triple and LO_FACTOR*p_triple
-
-    TP_LIMITS = {
-      'NONE': [None, None, None, None],
-      'DEF': [LO_FACTOR, HI_FACTOR, LO_FACTOR, HI_FACTOR],
-      'ACHP': [173.15, 493.15, 0.25e5, HI_FACTOR],
-      'ORC': [273.15, 673.15, 0.25e5, HI_FACTOR]
-    }
-
-    def __init__(self, fluid_ref, graph_type, unit_system='KSI', tp_limits='DEF', **kwargs):
-
-        # Process the graph_type and set self._x_type and self._y_type
-        graph_type = graph_type.upper()
-        graph_type = graph_type.replace(r'RHO', r'D')
-        if graph_type not in Base2DObject.PLOTS:
-            raise ValueError("Invalid graph_type input, expected a string from {0:s}".format(str(self.PLOTS)))
-
-        # Process the unit_system and set self._system
-        self.system = unit_system
-        # Process the plotting range based on T and p
-        self.limits = tp_limits
-        # Other properties
-        self.figure = kwargs.pop('figure', plt.figure(tight_layout=True))
-        self.axis = kwargs.pop('axis', self.figure.add_subplot(111))
-        self.props = kwargs.pop('props', None)
-
-        # call the base class
-        state = process_fluid_state(fluid_ref)
-        Base2DObject.__init__(self, graph_type[1], graph_type[0], state, **kwargs)
-
-    @property
-    def system(self): return self._system
-
-    @system.setter
-    def system(self, value):
-        value = value.upper()
-        if value in self.UNIT_SYSTEMS: self._system = self.UNIT_SYSTEMS[value]
-        else: raise ValueError("Invalid input, expected a string from {0:s}".format(str(self.UNIT_SYSTEMS.keys())))
-
-    @property
-    def limits(self):
-        """Returns [Tmin,Tmax,pmin,pmax] as value or factors"""
-        return self._limits
-
-    @limits.setter
-    def limits(self, value):
-        if is_string(value):
-            value = value.upper()
-        if value in self.TP_LIMITS:
-            self._limits = self.TP_LIMITS[value]
-        elif len(value) == 4:
-            self._limits = value
-        else:
-            raise ValueError("Invalid input, expected a list with 4 items or a string from {0:s}".format(str(self.TP_LIMITS.keys())))
-
-    @property
-    def figure(self): return self._figure
-
-    @figure.setter
-    def figure(self, value): self._figure = value
-
-    @property
-    def axis(self): return self._axis
-
-    @axis.setter
-    def axis(self, value): self._axis = value
-
-    @property
-    def props(self): return self._props
-
-    @props.setter
-    def props(self, value):
-        self._props = self.LINE_PROPS.copy()
-        if value is not None:
-            self._props.update(value)
-
-    def __sat_bounds(self, kind, smin=None, smax=None):
-        warnings.warn(
-          "You called the deprecated function \"__sat_bounds\", \
-consider replacing it with \"_get_sat_bounds\".",
-          DeprecationWarning)
-        return self._get_sat_bounds(kind, smin, smax)
-
-    def _get_iso_label(self, isoline, unit=True):
-        if self._system is not None:
-            dim = self._system[isoline.i_index]
-            return str(r"$" + dim.symbol + "=" + str(dim.from_SI(isoline.value)) + "$ " + dim.unit if unit else "$").strip()
-        return str(isoline.value).strip()
-
-    # def _get_phase_envelope(self):
-    #
-    #HEOS = CoolProp.AbstractState("HEOS", fluid)
-    # HEOS.build_phase_envelope("")
-    #PED = HEOS.get_phase_envelope_data()
-    #plt.plot(PED.T, np.log(PED.p))
-    # plt.show()
-
-    def _plot_default_annotations(self):
-#         def filter_fluid_ref(fluid_ref):
-#             fluid_ref_string = fluid_ref
-#             if fluid_ref.startswith('REFPROP-MIX'):
-#                 end = 0
-#                 fluid_ref_string = ''
-#                 while fluid_ref.find('[', end + 1) != -1:
-#                     start = fluid_ref.find('&', end + 1)
-#                     if end == 0:
-#                         start = fluid_ref.find(':', end + 1)
-#                     end = fluid_ref.find('[', end + 1)
-#                     fluid_ref_string = ' '.join([fluid_ref_string,
-#                                                 fluid_ref[start+1:end], '+'])
-#                 fluid_ref_string = fluid_ref_string[0:len(fluid_ref_string)-2]
-#             return fluid_ref_string
-#
-#         if len(self.graph_type) == 2:
-#             y_axis_id = self.graph_type[0]
-#             x_axis_id = self.graph_type[1]
-#         else:
-#             y_axis_id = self.graph_type[0]
-#             x_axis_id = self.graph_type[1:len(self.graph_type)]
-#
-#         tl_str = "%s - %s Graph for %s"
-#         if not self.axis.get_title():
-#             self.axis.set_title(tl_str % (self.AXIS_LABELS[self.unit_system][y_axis_id][0],
-#                                           self.AXIS_LABELS[self.unit_system][x_axis_id][0],
-#                                           filter_fluid_ref(self.fluid_ref)))
-        if self._x_index in [CoolProp.iDmass, CoolProp.iP]:
-            self.axis.set_xscale('log')
-        if self._y_index in [CoolProp.iDmass, CoolProp.iP]:
-            self.axis.set_yscale('log')
-
-        if not self.axis.get_xlabel():
-            dim = self._system[self._x_index]
-            self.xlabel((dim.label + u" $" + dim.symbol + u"$ / " + dim.unit).strip())
-        if not self.axis.get_ylabel():
-            dim = self._system[self._y_index]
-            self.ylabel((dim.label + u" $" + dim.symbol + u"$ / " + dim.unit).strip())
-
-    def title(self, title):
-        self.axis.set_title(title)
-
-    def xlabel(self, xlabel):
-        self.axis.set_xlabel(xlabel)
-
-    def ylabel(self, ylabel):
-        self.axis.set_ylabel(ylabel)
-
-    def grid(self, b=None, **kwargs):
-        g_map = {'on': True, 'off': False}
-        if b is not None:
-            b = g_map[b.lower()]
-        if not kwargs:  # len=0
-            self.axis.grid(b)
-        else:
-            self.axis.grid(kwargs)
-
-    def set_Tp_limits(self, limits):
-        """Set the limits for the graphs in temperature and pressure, based on
-        the active units: [Tmin, Tmax, pmin, pmax]"""
-        dim = self._system[CoolProp.iT]
-        limits[0] = dim.to_SI(limits[0])
-        limits[1] = dim.to_SI(limits[1])
-        dim = self._system[CoolProp.iP]
-        limits[2] = dim.to_SI(limits[2])
-        limits[3] = dim.to_SI(limits[3])
-        self.limits = limits
-
-    def get_Tp_limits(self):
-        """Get the limits for the graphs in temperature and pressure, based on
-        the active units: [Tmin, Tmax, pmin, pmax]"""
-        limits = self._get_Tp_limits()
-        dim = self._system[CoolProp.iT]
-        limits[0] = dim.from_SI(limits[0])
-        limits[1] = dim.from_SI(limits[1])
-        dim = self._system[CoolProp.iP]
-        limits[2] = dim.from_SI(limits[2])
-        limits[3] = dim.from_SI(limits[3])
-        return limits
-
-    def _get_Tp_limits(self):
-        """Get the limits for the graphs in temperature and pressure, based on
-        SI units: [Tmin, Tmax, pmin, pmax]"""
-        T_lo, T_hi, P_lo, P_hi = self.limits
-        Ts_lo, Ts_hi = self._get_sat_bounds(CoolProp.iT)
-        Ps_lo, Ps_hi = self._get_sat_bounds(CoolProp.iP)
-
-        if T_lo is None: T_lo = 0.0
-        elif T_lo < self.ID_FACTOR: T_lo *= Ts_lo
-        if T_hi is None: T_hi = 1e6
-        elif T_hi < self.ID_FACTOR: T_hi *= Ts_hi
-        if P_lo is None: P_lo = 0.0
-        elif P_lo < self.ID_FACTOR: P_lo *= Ps_lo
-        if P_hi is None: P_hi = 1e10
-        elif P_hi < self.ID_FACTOR: P_hi *= Ps_hi
-
-        try: T_lo = np.nanmax([T_lo, self._state.trivial_keyed_output(CoolProp.iT_min)])
-        except: pass
-        try: T_hi = np.nanmin([T_hi, self._state.trivial_keyed_output(CoolProp.iT_max)])
-        except: pass
-        try: P_lo = np.nanmax([P_lo, self._state.trivial_keyed_output(CoolProp.iP_min)])
-        except: pass
-        try: P_hi = np.nanmin([P_hi, self._state.trivial_keyed_output(CoolProp.iP_max)])
-        except: pass
-
-        return [T_lo, T_hi, P_lo, P_hi]
-
-    def set_axis_limits(self, limits):
-        """Set the limits of the internal axis object based on the active units,
-        takes [xmin, xmax, ymin, ymax]"""
-        self.axis.set_xlim([limits[0], limits[1]])
-        self.axis.set_ylim([limits[2], limits[3]])
-
-    def _set_axis_limits(self, limits):
-        """Set the limits of the internal axis object based on SI units,
-        takes [xmin, xmax, ymin, ymax]"""
-        dim = self._system[self._x_index]
-        self.axis.set_xlim([dim.from_SI(limits[0]), dim.from_SI(limits[1])])
-        dim = self._system[self._y_index]
-        self.axis.set_ylim([dim.from_SI(limits[2]), dim.from_SI(limits[3])])
-
-    def get_axis_limits(self, x_index=None, y_index=None):
-        """Returns the previously set limits or generates them and
-        converts the default values to the selected unit system.
-        Returns a list containing [xmin, xmax, ymin, ymax]"""
-        if x_index is None: x_index = self._x_index
-        if y_index is None: y_index = self._y_index
-
-        if x_index != self.x_index or y_index != self.y_index or \
-          self.axis.get_autoscalex_on() or self.axis.get_autoscaley_on():
-            # One of them is not set or we work on a different set of axes
-            T_lo, T_hi, P_lo, P_hi = self._get_Tp_limits()
-
-            X = [0.0] * 4; Y = [0.0] * 4
-            i = -1
-            for T in [T_lo, T_hi]:
-                for P in [P_lo, P_hi]:
-                    i += 1
-                    try:
-                        self._state.update(CoolProp.PT_INPUTS, P, T)
-                        # TODO: include a check for P and T?
-                        X[i] = self._state.keyed_output(x_index)
-                        Y[i] = self._state.keyed_output(y_index)
-                    except:
-                        X[i] = np.nan; Y[i] = np.nan
-            # Figure out what to update
-            dim = self._system[x_index]
-            x_lim = [dim.from_SI(np.nanmin(X)), dim.from_SI(np.nanmax(X))]
-            dim = self._system[y_index]
-            y_lim = [dim.from_SI(np.nanmin(Y)), dim.from_SI(np.nanmax(Y))]
-            # Either update the axes limits or get them
-            if x_index == self._x_index:
-                if self.axis.get_autoscalex_on():
-                    self.axis.set_xlim(x_lim)
-                else:
-                    x_lim = self.axis.get_xlim()
-            if y_index == self._y_index:
-                if self.axis.get_autoscaley_on():
-                    self.axis.set_ylim(y_lim)
-                else:
-                    y_lim = self.axis.get_ylim()
-        else:  # We only asked for the real axes limits and they are set already
-            x_lim = self.axis.get_xlim()
-            y_lim = self.axis.get_ylim()
-
-        return [x_lim[0], x_lim[1], y_lim[0], y_lim[1]]
-
-    def _get_axis_limits(self, x_index=None, y_index=None):
-        """Get the limits of the internal axis object in SI units
-        Returns a list containing [xmin, xmax, ymin, ymax]"""
-        if x_index is None: x_index = self._x_index
-        if y_index is None: y_index = self._y_index
-        limits = self.get_axis_limits(x_index, y_index)
-        dim = self._system[x_index]
-        limits[0] = dim.to_SI(limits[0])
-        limits[1] = dim.to_SI(limits[1])
-        dim = self._system[y_index]
-        limits[2] = dim.to_SI(limits[2])
-        limits[3] = dim.to_SI(limits[3])
-        return limits
-
-    @staticmethod
-    def generate_ranges(itype, imin, imax, num):
-        """Generate a range for a certain property"""
-        if itype in [CoolProp.iP, CoolProp.iDmass]:
-            return np.logspace(np.log2(imin), np.log2(imax), num=num, base=2.)
-        return np.linspace(imin, imax, num=num)
-
-    def _get_conversion_data(self):
-        [Axmin, Axmax, Aymin, Aymax] = self._get_axis_limits()
-        DELTAX_axis = Axmax - Axmin
-        DELTAY_axis = Aymax - Aymin
-        width = self.figure.get_figwidth()
-        height = self.figure.get_figheight()
-        pos = self.axis.get_position().get_points()
-        [[Fxmin, Fymin], [Fxmax, Fymax]] = pos
-        DELTAX_fig = width * (Fxmax - Fxmin)
-        DELTAY_fig = height * (Fymax - Fymin)
-        return [[Axmin, Axmax, Aymin, Aymax, Fxmin, Fxmax, Fymin, Fymax], [DELTAX_axis, DELTAY_axis, DELTAX_fig, DELTAY_fig]]
-
-    def _to_pixel_coords(self, xv, yv):
-        [[Axmin, Axmax, Aymin, Aymax, Fxmin, Fxmax, Fymin, Fymax], [DELTAX_axis, DELTAY_axis, DELTAX_fig, DELTAY_fig]] = self._get_conversion_data()
-        # Convert coords to pixels
-        x = (xv - Axmin) / DELTAX_axis * DELTAX_fig + Fxmin
-        y = (yv - Aymin) / DELTAY_axis * DELTAY_fig + Fymin
-        return x, y
-
-    def _to_data_coords(self, xv, yv):
-        [[Axmin, Axmax, Aymin, Aymax, Fxmin, Fxmax, Fymin, Fymax], [DELTAX_axis, DELTAY_axis, DELTAX_fig, DELTAY_fig]] = self._get_conversion_data()
-        # Convert back to measurements
-        x = (xv - Fxmin) / DELTAX_fig * DELTAX_axis + Axmin
-        y = (yv - Fymin) / DELTAY_fig * DELTAY_axis + Aymin
-        return x, y
-
-    @staticmethod
-    def get_x_y_dydx(xv, yv, x):
-        """Get x and y coordinates and the linear interpolation derivative"""
-        # Old implementation:
-        # Get the rotation angle
-        #f = interp1d(xv, yv)
-        #y = f(x)
-        #h = 0.00001*x
-        #dy_dx = (f(x+h)-f(x-h))/(2*h)
-        # return x,y,dy_dx
-        if len(xv) == len(yv) and len(yv) > 1:  # assure same length
-            if len(xv) == len(yv) and len(yv) == 2:  # only two points
-                if np.min(xv) < x < np.max(xv):
-                    dx = xv[1] - xv[0]
-                    dy = yv[1] - yv[0]
-                    dydx = dy / dx
-                    y = yv[0] + dydx * (x - xv[0])
-                    return x, y, dydx
-                else:
-                    raise ValueError("Your coordinate has to be between the input values.")
-            else:
-                limit = 1e-10                    # avoid hitting a point directly
-                diff = np.array(xv) - x        # get differences
-                index = np.argmin(diff * diff)  # nearest neighbour
-                if (xv[index] < x < xv[index + 1]      # nearest below, positive inclination
-                  or xv[index] > x > xv[index + 1]):   # nearest above, negative inclination
-                    if diff[index] < limit:
-                        index = [index - 1, index + 1]
-                    else:
-                        index = [index, index + 1]
-                elif (xv[index - 1] < x < xv[index]    # nearest above, positive inclination
-                  or xv[index - 1] > x > xv[index]):   # nearest below, negative inclination
-                    if diff[index] < limit:
-                        index = [index - 1, index + 1]
-                    else:
-                        index = [index - 1, index]
-                xvnew = xv[index]
-                yvnew = yv[index]
-                return BasePlot.get_x_y_dydx(xvnew, yvnew, x)  # Allow for a single recursion
-        else:
-            raise ValueError("You have to provide the same amount of x- and y-pairs with at least two entries each.")
-
-    def _inline_label(self, xv, yv, x=None, y=None):
-        """
-        This will give the coordinates and rotation required to align a label with
-        a line on a plot in SI units.
-        """
-        if y is None and x is not None:
-            trash = 0
-            (xv, yv) = self._to_pixel_coords(xv, yv)
-            # x is provided but y isn't
-            (x, trash) = self._to_pixel_coords(x, trash)
-
-            # Get the rotation angle and y-value
-            x, y, dy_dx = BasePlot.get_x_y_dydx(xv, yv, x)
-            rot = np.arctan(dy_dx) / np.pi * 180.
-
-        elif x is None and y is not None:
-            # y is provided, but x isn't
-            _xv = xv[::-1]
-            _yv = yv[::-1]
-            # Find x by interpolation
-            x = interpolate_values_1d(yv, xv, x_points=y)
-            trash = 0
-            (xv, yv) = self._to_pixel_coords(xv, yv)
-            (x, trash) = self._to_pixel_coords(x, trash)
-
-            # Get the rotation angle and y-value
-            x, y, dy_dx = BasePlot.get_x_y_dydx(xv, yv, x)
-            rot = np.arctan(dy_dx) / np.pi * 180.
-        (x, y) = self._to_data_coords(x, y)
-        return (x, y, rot)
-
-    def inline_label(self, xv, yv, x=None, y=None):
-        """
-        This will give the coordinates and rotation required to align a label with
-        a line on a plot in axis units.
-        """
-        dimx = self._system[self._x_index]
-        xv = dimx.to_SI(xv)
-        if x is not None: x = dimx.to_SI(x)
-        dimy = self._system[self._y_index]
-        yv = dimy.to_SI(yv)
-        if y is not None: y = dimy.to_SI(y)
-        (x, y, rot) = self._inline_label(xv, yv, x, y)
-        x = dimx.from_SI(x)
-        y = dimy.from_SI(y)
-        return (x, y, rot)
-
-    def show(self):
-        plt.show()
-
-    def savefig(self, *args, **kwargs):
-        self.figure.savefig(*args, **kwargs)
-
-
-if __name__ == "__main__":
-    for sys in [SIunits(), KSIunits(), EURunits()]:
-        print(sys.H.label)
-        print(sys.H.to_SI(20))
-        print(sys.P.label)
-        print(sys.P.to_SI(20))
-
-    # i_index, x_index, y_index, value=None, state=None)
-    iso = IsoLine('T', 'H', 'P')
-    print(iso.get_update_pair())
-
-    state = AbstractState("HEOS", "water")
-    iso = IsoLine('T', 'H', 'P', 300.0, state)
-    hr = PropsSI("H", "T", [290, 310], "P", [1e5, 1e5], "water")
-    pr = np.linspace(0.9e5, 1.1e5, 3)
-    iso.calc_range(hr, pr)
-    print(iso.x, iso.y)
-
-    iso = IsoLine('Q', 'H', 'P', 0.0, state)
-    iso.calc_range(hr, pr); print(iso.x, iso.y)
-    iso = IsoLine('Q', 'H', 'P', 1.0, state)
-    iso.calc_range(hr, pr); print(iso.x, iso.y)
-
-    # bp = BasePlot(fluid_ref, graph_type, unit_system = 'KSI', **kwargs):
-    bp = BasePlot('n-Pentane', 'PH', unit_system='EUR')
-    # print(bp._get_sat_bounds('P'))
-    # print(bp._get_iso_label(iso))
-    print(bp.get_axis_limits())
-
-        # get_update_pair(CoolProp.iP,CoolProp.iSmass,CoolProp.iT) -> (0,1,2,CoolProp.PSmass_INPUTS)
-        # other values require switching and swapping
-        # get_update_pair(CoolProp.iSmass,CoolProp.iP,CoolProp.iHmass) -> (1,0,2,CoolProp.PSmass_INPUTS)
+# -*- coding: utf-8 -*-
+from __future__ import print_function, division, absolute_import
+
+import matplotlib.pyplot as plt
+import numpy as np
+from abc import ABCMeta
+from six import with_metaclass
+import warnings
+
+import CoolProp
+from CoolProp import AbstractState
+from CoolProp import CoolProp as CP
+from CoolProp.CoolProp import PropsSI, extract_backend, extract_fractions, PyCriticalState
+
+
+def get_critical_point(state):
+    crit_state = PyCriticalState()
+    crit_state.T = np.nan
+    crit_state.p = np.nan
+    crit_state.rhomolar = np.nan
+    crit_state.rhomolar = np.nan
+    crit_state.stable = False
+    try:
+        crit_state.T = state.T_critical()
+        crit_state.p = state.p_critical()
+        crit_state.rhomolar = state.rhomolar_critical()
+        crit_state.stable = True
+    except:
+        try:
+            for crit_state_tmp in state.all_critical_points():
+                if crit_state_tmp.stable and (crit_state_tmp.T > crit_state.T or not np.isfinite(crit_state.T)):
+                    crit_state.T = crit_state_tmp.T
+                    crit_state.p = crit_state_tmp.p
+                    crit_state.rhomolar = crit_state_tmp.rhomolar
+                    crit_state.stable = crit_state_tmp.stable
+        except:
+            raise ValueError("Could not calculate the critical point data.")
+    new_state = AbstractState(state.backend_name(), '&'.join(state.fluid_names()))
+    masses = state.get_mass_fractions()
+    if len(masses) > 1:
+        new_state.set_mass_fractions(masses)  # Uses mass fraction to work with incompressibles
+        # try: new_state.build_phase_envelope("dummy")
+        # except: pass
+    msg = ""
+    if np.isfinite(crit_state.p) and np.isfinite(crit_state.T):
+        try:
+            new_state.specify_phase(CoolProp.iphase_critical_point)
+            new_state.update(CoolProp.PT_INPUTS, crit_state.p, crit_state.T)
+            return new_state
+        except Exception as e:
+            msg += str(e) + " - "
+            pass
+        try:
+            new_state.update(CoolProp.PT_INPUTS, crit_state.p, crit_state.T)
+            return new_state
+        except Exception as e:
+            msg += str(e) + " - "
+            pass
+    if np.isfinite(crit_state.rhomolar) and np.isfinite(crit_state.T):
+        try:
+            new_state.specify_phase(CoolProp.iphase_critical_point)
+            new_state.update(CoolProp.DmolarT_INPUTS, crit_state.rhomolar, crit_state.T)
+            return new_state
+        except Exception as e:
+            msg += str(e) + " - "
+            pass
+        try:
+            new_state.update(CoolProp.DmolarT_INPUTS, crit_state.rhomolar, crit_state.T)
+            return new_state
+        except Exception as e:
+            msg += str(e) + " - "
+            pass
+    raise ValueError("Could not calculate the critical point data. " + msg)
+
+
+def interpolate_values_1d(x, y, x_points=None, kind='linear'):
+    try:
+        from scipy.interpolate.interpolate import interp1d
+        if x_points is None:
+            return interp1d(x, y, kind=kind)(x[np.isfinite(x)])
+        else:
+            return interp1d(x, y, kind=kind)(x_points)
+    except ImportError:
+        if kind != 'linear':
+            warnings.warn(
+              "You requested a non-linear interpolation, but SciPy is not available. Falling back to linear interpolation.",
+              UserWarning)
+        if x_points is None:
+            return np.interp((x[np.isfinite(x)]), x, y)
+        else:
+            return np.interp(x_points, x, y)
+
+
+def is_string(in_obj):
+    try:
+        return isinstance(in_obj, basestring)
+    except NameError:
+        return isinstance(in_obj, str)
+    # except:
+    #    return False
+
+
+def process_fluid_state(fluid_ref, fractions='mole'):
+    """Check input for state object or fluid string
+
+    Parameters
+    ----------
+        fluid_ref : str, CoolProp.AbstractState
+        fractions : str, switch to set mass, volu or mole fractions
+
+    Returns
+    -------
+        CoolProp.AbstractState
+    """
+    # Process the fluid and set self._state
+    if is_string(fluid_ref):
+        backend, fluids = extract_backend(fluid_ref)
+        fluids, fractions = extract_fractions(fluids)
+        state = AbstractState(backend, '&'.join(fluids))
+        if len(fluids) > 1 and len(fluids) == len(fractions):
+            if fractions == 'mass': state.set_mass_fractions(fractions)
+            elif fractions == 'volu': state.set_volu_fractions(fractions)
+            else: state.set_mole_fractions(fractions)
+        return state
+    elif isinstance(fluid_ref, AbstractState):
+        return fluid_ref
+    raise TypeError("Invalid fluid_ref input, expected a string or an abstract state instance.")
+
+
+def _get_index(prop):
+    if is_string(prop):
+        return CP.get_parameter_index(prop)
+    elif isinstance(prop, int):
+        return prop
+    else:
+        raise ValueError("Invalid input, expected a string or an int, not {0:s}.".format(str(prop)))
+
+
+class BaseQuantity(object):
+    """A very basic property that can convert an input to and from a
+    given unit system, note that the conversion from SI units starts
+    with a multiplication. If you need to remove an offset, use the
+    off_SI property.
+    Examples with temperature:
+    celsius = BaseQuantity(add_SI=-273.15)
+    fahrenheit = BaseQuantity(add_SI=32.0, mul_SI=1.8, off_SI=-273.15)
+    Examples with pressure:
+    bar = BaseQuantity(mul_SI=1e-5)
+    psi = BaseQuantity(mul_SI=0.000145037738)
+    """
+
+    def __init__(self, add_SI=0.0, mul_SI=1.0, off_SI=0.0):
+        self._add_SI = add_SI
+        self._mul_SI = mul_SI
+        self._off_SI = off_SI
+
+    @property
+    def add_SI(self): return self._add_SI
+
+    @add_SI.setter
+    def add_SI(self, value): self._add_SI = value
+
+    @property
+    def mul_SI(self): return self._mul_SI
+
+    @mul_SI.setter
+    def mul_SI(self, value): self._mul_SI = value
+
+    @property
+    def off_SI(self): return self._off_SI
+
+    @off_SI.setter
+    def off_SI(self, value): self._off_SI = value
+
+    def from_SI(self, value): return ((value + self.off_SI) * self.mul_SI) + self.add_SI
+
+    def to_SI(self, value): return (value - self.add_SI) / self.mul_SI - self.off_SI
+
+
+class BaseDimension(BaseQuantity):
+    """A dimension is a class that extends the BaseQuantity and adds a label, a symbol and a unit label"""
+
+    def __init__(self, add_SI=0.0, mul_SI=1.0, off_SI=0.0, label='', symbol='', unit=''):
+        self._label = label
+        self._symbol = symbol
+        self._unit = unit
+        super(BaseDimension, self).__init__(add_SI=add_SI, mul_SI=mul_SI, off_SI=off_SI)
+
+    @property
+    def label(self): return self._label
+
+    @label.setter
+    def label(self, value): self._label = value
+
+    @property
+    def symbol(self): return self._symbol
+
+    @symbol.setter
+    def symbol(self, value): self._symbol = value
+
+    @property
+    def unit(self): return self._unit
+
+    @unit.setter
+    def unit(self, value): self._unit = value
+
+
+class PropertyDict(with_metaclass(ABCMeta), object):
+    """A collection of dimensions for all the required quantities"""
+
+    def __init__(self):
+        self._D = None
+        self._H = None
+        self._P = None
+        self._S = None
+        self._T = None
+        self._U = None
+        self._Q = None
+
+    @property
+    def D(self): return self._D
+
+    @D.setter
+    def D(self, value): self._D = value
+
+    @property
+    def H(self): return self._H
+
+    @H.setter
+    def H(self, value): self._H = value
+
+    @property
+    def P(self): return self._P
+
+    @P.setter
+    def P(self, value): self._P = value
+
+    @property
+    def S(self): return self._S
+
+    @S.setter
+    def S(self, value): self._S = value
+
+    @property
+    def T(self): return self._T
+
+    @T.setter
+    def T(self, value): self._T = value
+
+    @property
+    def U(self): return self._U
+
+    @U.setter
+    def U(self, value): self._U = value
+
+    @property
+    def Q(self): return self._Q
+
+    @Q.setter
+    def Q(self, value): self._Q = value
+
+    @property
+    def dimensions(self):
+        return {
+      CoolProp.iDmass: self._D,
+      CoolProp.iHmass: self._H,
+      CoolProp.iP: self._P,
+      CoolProp.iSmass: self._S,
+      CoolProp.iT: self._T,
+      CoolProp.iUmass: self._U,
+      CoolProp.iQ: self._Q
+    }
+
+    def __getitem__(self, index):
+        """Allow for property access via square brackets"""
+        idx = _get_index(index)
+        if idx == CoolProp.iDmass: return self.D
+        elif idx == CoolProp.iHmass: return self.H
+        elif idx == CoolProp.iP: return self.P
+        elif idx == CoolProp.iSmass: return self.S
+        elif idx == CoolProp.iT: return self.T
+        elif idx == CoolProp.iUmass: return self.U
+        elif idx == CoolProp.iQ: return self.Q
+        else: raise IndexError("Unknown index \"{0:s}\".".format(str(index)))
+
+    def __setitem__(self, index, value):
+        """Allow for property access via square brackets"""
+        idx = _get_index(index)
+        if idx == CoolProp.iDmass: self.D = value
+        elif idx == CoolProp.iHmass: self.H = value
+        elif idx == CoolProp.iP: self.P = value
+        elif idx == CoolProp.iSmass: self.S = value
+        elif idx == CoolProp.iT: self.T = value
+        elif idx == CoolProp.iUmass: self.U = value
+        elif idx == CoolProp.iQ: self.Q = value
+        else: raise IndexError("Unknown index \"{0:s}\".".format(str(index)))
+
+
+class SIunits(PropertyDict):
+    def __init__(self):
+        self._D = BaseDimension(add_SI=0.0, mul_SI=1.0, off_SI=0.0, label='Density', symbol=u'd', unit=u'kg/m3')
+        self._H = BaseDimension(add_SI=0.0, mul_SI=1.0, off_SI=0.0, label='Specific Enthalpy', symbol=u'h', unit=u'J/kg')
+        self._P = BaseDimension(add_SI=0.0, mul_SI=1.0, off_SI=0.0, label='Pressure', symbol=u'p', unit=u'Pa')
+        self._S = BaseDimension(add_SI=0.0, mul_SI=1.0, off_SI=0.0, label='Specific Entropy', symbol=u's', unit=u'J/kg/K')
+        self._T = BaseDimension(add_SI=0.0, mul_SI=1.0, off_SI=0.0, label='Temperature', symbol=u'T', unit=u'K')
+        self._U = BaseDimension(add_SI=0.0, mul_SI=1.0, off_SI=0.0, label='Specific Internal Energy', symbol=u'u', unit=u'J/kg')
+        self._Q = BaseDimension(add_SI=0.0, mul_SI=1.0, off_SI=0.0, label='Vapour Quality', symbol=u'x', unit=u'')
+
+
+class KSIunits(SIunits):
+    def __init__(self):
+        super(KSIunits, self).__init__()
+        self.H.mul_SI = 1e-3
+        self.H.unit = u'kJ/kg'
+        self.P.mul_SI = 1e-3
+        self.P.unit = u'kPa'
+        self.S.mul_SI = 1e-3
+        self.S.unit = u'kJ/kg/K'
+        self.U.mul_SI = 1e-3
+        self.U.unit = u'kJ/kg'
+
+
+class EURunits(KSIunits):
+    def __init__(self):
+        super(EURunits, self).__init__()
+        self.P.mul_SI = 1e-5
+        self.P.unit = u'bar'
+        self.T.add_SI = -273.15
+        self.T.unit = u'deg C'
+
+
+class Base2DObject(with_metaclass(ABCMeta), object):
+    """A container for shared settings and constants for the
+    isolines and the property plots."""
+
+    # A list of supported plot
+    TS = CoolProp.iT * 10 + CoolProp.iSmass
+    PH = CoolProp.iP * 10 + CoolProp.iHmass
+    HS = CoolProp.iHmass * 10 + CoolProp.iSmass
+    PS = CoolProp.iP * 10 + CoolProp.iSmass
+    PD = CoolProp.iP * 10 + CoolProp.iDmass
+    TD = CoolProp.iT * 10 + CoolProp.iDmass
+    PT = CoolProp.iP * 10 + CoolProp.iT
+    PU = CoolProp.iP * 10 + CoolProp.iUmass
+
+    PLOTS = {
+      'TS': TS,
+      'PH': PH,
+      'HS': HS,
+      'PS': PS,
+      'PD': PD,
+      'TD': TD,
+      'PT': PT,
+    }
+
+    PLOTS_INV = {v: k for k, v in PLOTS.items()}
+
+#     # A list of supported plot
+#     @property
+#     def TS(self): return type(self).TS
+#     @property
+#     def PH(self): return CoolProp.iP*10     + CoolProp.iHmass
+#     @property
+#     def HS(self): return CoolProp.iHmass*10 + CoolProp.iSmass
+#     @property
+#     def PS(self): return CoolProp.iP*10     + CoolProp.iSmass
+#     @property
+#     def PD(self): return CoolProp.iP*10     + CoolProp.iDmass
+#     @property
+#     def TD(self): return CoolProp.iT*10     + CoolProp.iDmass
+#     @property
+#     def PT(self): return CoolProp.iP*10     + CoolProp.iT
+#     @property
+#     def PU(self): return CoolProp.iP*10     + CoolProp.iUmass
+
+    def __init__(self, x_type, y_type, state=None, small=None):
+        self._x_index = _get_index(x_type)
+        self._y_index = _get_index(y_type)
+        self._critical_state = None
+        if small is not None: self._small = small
+        else: self._small = 1e-7
+        if state is not None: self.state = state
+        else: self._state = None
+
+    # A list of supported plot
+    @property
+    def x_index(self): return self._x_index
+
+    @property
+    def y_index(self): return self._y_index
+
+    @property
+    def critical_state(self):
+        if self._critical_state is None and self._state is not None:
+            self._critical_state = get_critical_point(self._state)
+        return self._critical_state
+
+    @property
+    def state(self): return self._state
+
+    @state.setter
+    def state(self, value):
+        self._state = process_fluid_state(value)
+        # try: self._state.build_phase_envelope("dummy")
+        # except: pass
+        self._critical_state = None
+        #self._T_small = self._state.trivial_keyed_output(CoolProp.iT_critical)*self._small
+        #self._P_small = self._state.trivial_keyed_output(CoolProp.iP_critical)*self._small
+        self._T_small = self.critical_state.keyed_output(CoolProp.iT) * self._small
+        self._P_small = self.critical_state.keyed_output(CoolProp.iP) * self._small
+
+    def _get_sat_bounds(self, kind, smin=None, smax=None):
+        """Generates limits for the saturation line in either T or p determined
+        by 'kind'. If smin or smax are provided, values will be checked
+        against the allowable range for the EOS and a warning might be
+        generated. Returns a tuple containing (xmin, xmax)"""
+
+        # TODO: REFPROP backend does not have ptriple.
+        T_triple = self._state.trivial_keyed_output(CoolProp.iT_triple)
+        try:
+            T_min = self._state.trivial_keyed_output(CoolProp.iT_min)
+        except:
+            T_min = T_triple
+        self._state.update(CoolProp.QT_INPUTS, 0, max([T_triple, T_min]) + self._T_small)
+        kind = _get_index(kind)
+        if kind == CoolProp.iP:
+            fluid_min = self._state.keyed_output(CoolProp.iP) + self._P_small
+            fluid_max = self.critical_state.keyed_output(CoolProp.iP) - self._P_small
+        elif kind == CoolProp.iT:
+            fluid_min = self._state.keyed_output(CoolProp.iT) + self._T_small
+            fluid_max = self.critical_state.keyed_output(CoolProp.iT) - self._T_small
+        else:
+            raise ValueError("Saturation boundaries have to be defined in T or P, but not in {0:s}".format(str(kind)))
+
+        if smin is not None:
+            if fluid_min < smin < fluid_max:
+                sat_min = smin
+            else:
+                warnings.warn(
+                  "Your minimum {0:s} has been ignored, {1:f} is not between {2:f} and {3:f}".format(self.PROPERTIES[kind], smin, fluid_min, fluid_max),
+                  UserWarning)
+                sat_min = fluid_min
+        else:
+            sat_min = fluid_min
+
+        if smax is not None:
+            if fluid_min < smax < fluid_max:
+                sat_max = smax
+            else:
+                warnings.warn(
+                  "Your maximum {0:s} has been ignored, {1:f} is not between {2:f} and {3:f}".format(self.PROPERTIES[kind], smax, fluid_min, fluid_max),
+                  UserWarning)
+                sat_max = fluid_max
+        else:
+            sat_max = fluid_max
+
+        return sat_min, sat_max
+
+
+class IsoLine(Base2DObject):
+    """An object that holds the functions to calculate a line of
+    a constant property in the dimensions of a property plot. This
+    class only uses SI units."""
+
+    # Normally we calculate a sweep in x-dimensions, but
+    # sometimes a sweep in y-dimensions is better.
+    XY_SWITCH = {
+      CoolProp.iDmass: {Base2DObject.TS: True, Base2DObject.PH: True, Base2DObject.HS: False, Base2DObject.PS: True, Base2DObject.PD: None, Base2DObject.TD: None, Base2DObject.PT: False},
+      CoolProp.iHmass: {Base2DObject.TS: False, Base2DObject.PH: None, Base2DObject.HS: None, Base2DObject.PS: True, Base2DObject.PD: True, Base2DObject.TD: False, Base2DObject.PT: False},
+      CoolProp.iP: {Base2DObject.TS: False, Base2DObject.PH: None, Base2DObject.HS: False, Base2DObject.PS: None, Base2DObject.PD: None, Base2DObject.TD: False, Base2DObject.PT: None},
+      CoolProp.iSmass: {Base2DObject.TS: None, Base2DObject.PH: True, Base2DObject.HS: None, Base2DObject.PS: None, Base2DObject.PD: True, Base2DObject.TD: False, Base2DObject.PT: True},
+      CoolProp.iT: {Base2DObject.TS: None, Base2DObject.PH: True, Base2DObject.HS: False, Base2DObject.PS: False, Base2DObject.PD: False, Base2DObject.TD: None, Base2DObject.PT: None},
+      CoolProp.iQ: {Base2DObject.TS: True, Base2DObject.PH: True, Base2DObject.HS: True, Base2DObject.PS: True, Base2DObject.PD: True, Base2DObject.TD: True, Base2DObject.PT: False}
+    }
+
+    # Abort interpolation if there are not enough
+    # valid entries.
+    VALID_REQ = 5.0 / 100.0
+
+    def __init__(self, i_index, x_index, y_index, value=0.0, state=None):
+        super(IsoLine, self).__init__(x_index, y_index, state)
+        self._i_index = _get_index(i_index)
+        if value is not None: self.value = value
+        else: self._value = None
+        self._x = None
+        self._y = None
+
+    @property
+    def i_index(self): return self._i_index
+
+    @property
+    def value(self): return self._value
+
+    @value.setter
+    def value(self, value): self._value = float(value)
+
+    @property
+    def x(self): return self._x
+
+    @x.setter
+    def x(self, value): self._x = np.array(value)
+
+    @property
+    def y(self): return self._y
+
+    @y.setter
+    def y(self, value): self._y = np.array(value)
+
+    def get_update_pair(self):
+        """Processes the values for the isoproperty and the graph dimensions
+        to figure which should be used as inputs to the state update. Returns
+        a tuple with the indices for the update call and the property constant.
+        For an isobar in a Ts-diagram it returns the default order and the
+        correct constant for the update pair:
+        get_update_pair(CoolProp.iP,CoolProp.iSmass,CoolProp.iT) -> (0,1,2,CoolProp.PSmass_INPUTS)
+        other values require switching and swapping.
+        """
+        # Figure out if x or y-dimension should be used
+        switch = self.XY_SWITCH[self.i_index][self.y_index * 10 + self.x_index]
+
+        if switch is None:
+            raise ValueError("This isoline cannot be calculated!")
+        elif switch is False:
+            pair, out1, _ = CP.generate_update_pair(self.i_index, 0.0, self.x_index, 1.0)
+        elif switch is True:
+            pair, out1, _ = CP.generate_update_pair(self.i_index, 0.0, self.y_index, 1.0)
+        else:
+            raise ValueError("Unknown error!")
+
+        if out1 == 0.0:  # Correct order
+            swap = False
+        else:  # Wrong order
+            swap = True
+
+        if not switch and not swap:
+            return 0, 1, 2, pair
+        elif switch and not swap:
+            return 0, 2, 1, pair
+        elif not switch and swap:
+            return 1, 0, 2, pair
+        elif switch and swap:
+            return 1, 2, 0, pair
+        else:
+            raise ValueError("Check the code, this should not happen!")
+
+    def calc_sat_range(self, Trange=None, Prange=None, num=200):
+        if Trange is not None:
+            two = np.array(Trange)
+            one = np.resize(np.array(self.value), two.shape)
+            pair = CoolProp.QT_INPUTS
+        elif Prange is not None:
+            one = np.array(Prange)
+            two = np.resize(np.array(self.value), one.shape)
+            pair = CoolProp.PQ_INPUTS
+        else:
+            T_lo, T_hi = self._get_sat_bounds(CoolProp.iT)
+            two = np.linspace(T_lo, T_hi, num)
+            one = np.resize(np.array(self.value), two.shape)
+            pair = CoolProp.QT_INPUTS
+
+        Tcrit = self.critical_state.keyed_output(CoolProp.iT)
+        Pcrit = self.critical_state.keyed_output(CoolProp.iP)
+        Dcrit = self.critical_state.keyed_output(CoolProp.iDmass)
+        try:
+            #self.state.update(CoolProp.DmassT_INPUTS, Dcrit, Tcrit)
+            #xcrit = self.state.keyed_output(self._x_index)
+            #ycrit = self.state.keyed_output(self._y_index)
+            xcrit = self.critical_state.keyed_output(self._x_index)
+            ycrit = self.critical_state.keyed_output(self._y_index)
+        except:
+            warnings.warn(
+              "An error occurred for the critical inputs, skipping it.",
+              UserWarning)
+            xcrit = np.NaN
+            ycrit = np.NaN
+
+        X = np.empty_like(one)
+        Y = np.empty_like(one)
+
+        err = False
+        for index, _ in np.ndenumerate(one):
+            try:
+                self.state.update(pair, one[index], two[index])
+                X[index] = self.state.keyed_output(self._x_index)
+                Y[index] = self.state.keyed_output(self._y_index)
+            except Exception as e:
+                if (pair == CoolProp.QT_INPUTS and abs(two[index] - Tcrit) < 1e0) or \
+                   (pair == CoolProp.PQ_INPUTS and abs(one[index] - Pcrit) < 1e2):
+                    X[index] = xcrit
+                    Y[index] = ycrit
+                    warnings.warn(
+                  "An error occurred for near critical inputs {0:f}, {1:f} with index {2:s}: {3:s}".format(one[index], two[index], str(index), str(e)),
+                  UserWarning)
+                    pass
+
+                warnings.warn(
+                  "An error occurred for inputs {0:f}, {1:f} with index {2:s}: {3:s}".format(one[index], two[index], str(index), str(e)),
+                  UserWarning)
+                X[index] = np.NaN
+                Y[index] = np.NaN
+                err = True
+        self.x = X; self.y = Y
+        return
+
+    def calc_range(self, xvals=None, yvals=None):
+
+        if self.i_index == CoolProp.iQ:
+            warnings.warn(
+                "Please use \"calc_sat_range\" to calculate saturation and isoquality lines. Input ranges are discarded.",
+                UserWarning)
+            if xvals is not None: self.calc_sat_range(num=xvals.size)
+            elif yvals is not None: self.calc_sat_range(num=yvals.size)
+            else: self.calc_sat_range()
+            return
+
+        ipos, xpos, ypos, pair = self.get_update_pair()
+
+        order = [ipos, xpos, ypos]
+        idxs = [v for (_, v) in sorted(zip(order, [self.i_index, self.x_index, self.y_index]))]
+        vals = [v for (_, v) in sorted(zip(order, [np.array(self.value), xvals, yvals]))]
+        if vals[0] is None or vals[1] is None:
+            raise ValueError("One required input is missing, make sure to supply the correct xvals ({0:s}) or yvals ({1:s}).".format(str(xvals), str(yvals)))
+
+        if vals[0].size > vals[1].size:
+            vals[1] = np.resize(vals[1], vals[0].shape)
+        elif vals[0].size < vals[1].size:
+            vals[0] = np.resize(vals[0], vals[1].shape)
+
+        vals[2] = np.empty_like(vals[0])
+        err = False
+        guesses = CoolProp.CoolProp.PyGuessesStructure()
+        # Only use the guesses for selected inputs
+        if pair == CoolProp.HmolarP_INPUTS \
+          or pair == CoolProp.HmassP_INPUTS:
+            # or pair == CoolProp.HmassSmass_INPUTS \
+            # or pair == CoolProp.HmolarSmolar_INPUTS \
+            # or pair == CoolProp.PSmass_INPUTS \
+            # or pair == CoolProp.PSmolar_INPUTS:
+            use_guesses = True
+        else:
+            use_guesses = False
+        for index, _ in np.ndenumerate(vals[0]):
+            try:
+                if use_guesses:
+                    if np.isfinite(guesses.rhomolar):
+                        self.state.update_with_guesses(pair, vals[0][index], vals[1][index], guesses)
+                    else:
+                        self.state.update(pair, vals[0][index], vals[1][index])
+                    guesses.rhomolar = self.state.rhomolar()
+                    guesses.T = self.state.T()
+                else:
+                    self.state.update(pair, vals[0][index], vals[1][index])
+                vals[2][index] = self.state.keyed_output(idxs[2])
+            except Exception as e:
+                warnings.warn(
+                  "An error occurred for inputs {0:f}, {1:f} with index {2:s}: {3:s}".format(vals[0][index], vals[1][index], str(index), str(e)),
+                  UserWarning)
+                vals[2][index] = np.NaN
+                guesses.rhomolar = np.NaN
+                guesses.T = np.NaN
+                err = True
+
+        for i, v in enumerate(idxs):
+            if v == self.x_index: self.x = vals[i]
+            if v == self.y_index: self.y = vals[i]
+
+    def sanitize_data(self):
+        """Fill the series via interpolation"""
+        validx = None; validy = None
+        countx = None; county = None
+        if self.x is not None:
+            validx = np.isfinite(self.x)
+            countx = float(self.x.size)
+        else:
+            raise ValueError("The x-axis is not populated, calculate values before you interpolate.")
+        if self.y is not None:
+            validy = np.isfinite(self.y)
+            county = float(self.y.size)
+        else:
+            raise ValueError("The y-axis is not populated, calculate values before you interpolate.")
+
+        if min([np.sum(validx) / countx, np.sum(validy) / county]) < self.VALID_REQ:
+            warnings.warn(
+              "Poor data quality, there are not enough valid entries for x ({0:f}/{1:f}) or y ({2:f}/{3:f}).".format(np.sum(validx), countx, np.sum(validy), county),
+              UserWarning)
+        # TODO: use filter and cubic splines!
+        #filter = np.logical_and(np.isfinite(self.x),np.isfinite(self.y))
+        if np.sum(validy) > np.sum(validx):
+            self.x = interpolate_values_1d(self.y, self.x, x_points=self.y[validy])
+            self.y = self.y[validy]
+        else:
+            self.y = interpolate_values_1d(self.x, self.y, x_points=self.x[validx])
+            self.x = self.x[validx]
+
+
+class BasePlot(Base2DObject):
+    """The base class for all plots. It can be instantiated itself, but provides many
+    general facilities to be used in the different plots. """
+
+    # Define the iteration keys
+    PROPERTIES = {
+      CoolProp.iDmass: 'density',
+      CoolProp.iHmass: 'specific enthalpy',
+      CoolProp.iP: 'pressure',
+      CoolProp.iSmass: 'specific entropy',
+      CoolProp.iT: 'temperature',
+      CoolProp.iUmass: 'specific internal energy'
+    }
+
+    # Define the unit systems
+    UNIT_SYSTEMS = {
+      'SI': SIunits(),
+      'KSI': KSIunits(),
+      'EUR': EURunits()
+    }
+
+    LINE_PROPS = {
+      CoolProp.iT: dict(color='Darkred', lw=0.25),
+      CoolProp.iP: dict(color='DarkCyan', lw=0.25),
+      CoolProp.iHmass: dict(color='DarkGreen', lw=0.25),
+      CoolProp.iDmass: dict(color='DarkBlue', lw=0.25),
+      CoolProp.iSmass: dict(color='DarkOrange', lw=0.25),
+      CoolProp.iQ: dict(color='black', lw=0.25)
+    }
+
+    ID_FACTOR = 10.0  # Values below this number are interpreted as factors
+    HI_FACTOR = 2.25  # Upper default limits: HI_FACTOR*T_crit and HI_FACTOR*p_crit
+    LO_FACTOR = 1.01  # Lower default limits: LO_FACTOR*T_triple and LO_FACTOR*p_triple
+
+    TP_LIMITS = {
+      'NONE': [None, None, None, None],
+      'DEF': [LO_FACTOR, HI_FACTOR, LO_FACTOR, HI_FACTOR],
+      'ACHP': [173.15, 493.15, 0.25e5, HI_FACTOR],
+      'ORC': [273.15, 673.15, 0.25e5, HI_FACTOR]
+    }
+
+    def __init__(self, fluid_ref, graph_type, unit_system='KSI', tp_limits='DEF', **kwargs):
+
+        # Process the graph_type and set self._x_type and self._y_type
+        graph_type = graph_type.upper()
+        graph_type = graph_type.replace(r'RHO', r'D')
+        if graph_type not in Base2DObject.PLOTS:
+            raise ValueError("Invalid graph_type input, expected a string from {0:s}".format(str(self.PLOTS)))
+
+        # Process the unit_system and set self._system
+        self.system = unit_system
+        # Process the plotting range based on T and p
+        self.limits = tp_limits
+        # Other properties
+        self.figure = kwargs.pop('figure', plt.figure(tight_layout=True))
+        self.axis = kwargs.pop('axis', self.figure.add_subplot(111))
+        self.props = kwargs.pop('props', None)
+
+        # call the base class
+        state = process_fluid_state(fluid_ref)
+        Base2DObject.__init__(self, graph_type[1], graph_type[0], state, **kwargs)
+
+    @property
+    def system(self): return self._system
+
+    @system.setter
+    def system(self, value):
+        value = value.upper()
+        if value in self.UNIT_SYSTEMS: self._system = self.UNIT_SYSTEMS[value]
+        else: raise ValueError("Invalid input, expected a string from {0:s}".format(str(self.UNIT_SYSTEMS.keys())))
+
+    @property
+    def limits(self):
+        """Returns [Tmin,Tmax,pmin,pmax] as value or factors"""
+        return self._limits
+
+    @limits.setter
+    def limits(self, value):
+        if is_string(value):
+            value = value.upper()
+        if value in self.TP_LIMITS:
+            self._limits = self.TP_LIMITS[value]
+        elif len(value) == 4:
+            self._limits = value
+        else:
+            raise ValueError("Invalid input, expected a list with 4 items or a string from {0:s}".format(str(self.TP_LIMITS.keys())))
+
+    @property
+    def figure(self): return self._figure
+
+    @figure.setter
+    def figure(self, value): self._figure = value
+
+    @property
+    def axis(self): return self._axis
+
+    @axis.setter
+    def axis(self, value): self._axis = value
+
+    @property
+    def props(self): return self._props
+
+    @props.setter
+    def props(self, value):
+        self._props = self.LINE_PROPS.copy()
+        if value is not None:
+            self._props.update(value)
+
+    def __sat_bounds(self, kind, smin=None, smax=None):
+        warnings.warn(
+          "You called the deprecated function \"__sat_bounds\", \
+consider replacing it with \"_get_sat_bounds\".",
+          DeprecationWarning)
+        return self._get_sat_bounds(kind, smin, smax)
+
+    def _get_iso_label(self, isoline, unit=True):
+        if self._system is not None:
+            dim = self._system[isoline.i_index]
+            return str(r"$" + dim.symbol + "=" + str(dim.from_SI(isoline.value)) + "$ " + dim.unit if unit else "$").strip()
+        return str(isoline.value).strip()
+
+    # def _get_phase_envelope(self):
+    #
+    #HEOS = CoolProp.AbstractState("HEOS", fluid)
+    # HEOS.build_phase_envelope("")
+    #PED = HEOS.get_phase_envelope_data()
+    #plt.plot(PED.T, np.log(PED.p))
+    # plt.show()
+
+    def _plot_default_annotations(self):
+#         def filter_fluid_ref(fluid_ref):
+#             fluid_ref_string = fluid_ref
+#             if fluid_ref.startswith('REFPROP-MIX'):
+#                 end = 0
+#                 fluid_ref_string = ''
+#                 while fluid_ref.find('[', end + 1) != -1:
+#                     start = fluid_ref.find('&', end + 1)
+#                     if end == 0:
+#                         start = fluid_ref.find(':', end + 1)
+#                     end = fluid_ref.find('[', end + 1)
+#                     fluid_ref_string = ' '.join([fluid_ref_string,
+#                                                 fluid_ref[start+1:end], '+'])
+#                 fluid_ref_string = fluid_ref_string[0:len(fluid_ref_string)-2]
+#             return fluid_ref_string
+#
+#         if len(self.graph_type) == 2:
+#             y_axis_id = self.graph_type[0]
+#             x_axis_id = self.graph_type[1]
+#         else:
+#             y_axis_id = self.graph_type[0]
+#             x_axis_id = self.graph_type[1:len(self.graph_type)]
+#
+#         tl_str = "%s - %s Graph for %s"
+#         if not self.axis.get_title():
+#             self.axis.set_title(tl_str % (self.AXIS_LABELS[self.unit_system][y_axis_id][0],
+#                                           self.AXIS_LABELS[self.unit_system][x_axis_id][0],
+#                                           filter_fluid_ref(self.fluid_ref)))
+        if self._x_index in [CoolProp.iDmass, CoolProp.iP]:
+            self.axis.set_xscale('log')
+        if self._y_index in [CoolProp.iDmass, CoolProp.iP]:
+            self.axis.set_yscale('log')
+
+        if not self.axis.get_xlabel():
+            dim = self._system[self._x_index]
+            self.xlabel((dim.label + u" $" + dim.symbol + u"$ / " + dim.unit).strip())
+        if not self.axis.get_ylabel():
+            dim = self._system[self._y_index]
+            self.ylabel((dim.label + u" $" + dim.symbol + u"$ / " + dim.unit).strip())
+
+    def title(self, title):
+        self.axis.set_title(title)
+
+    def xlabel(self, xlabel):
+        self.axis.set_xlabel(xlabel)
+
+    def ylabel(self, ylabel):
+        self.axis.set_ylabel(ylabel)
+
+    def grid(self, b=None, **kwargs):
+        g_map = {'on': True, 'off': False}
+        if b is not None:
+            b = g_map[b.lower()]
+        if not kwargs:  # len=0
+            self.axis.grid(b)
+        else:
+            self.axis.grid(kwargs)
+
+    def set_Tp_limits(self, limits):
+        """Set the limits for the graphs in temperature and pressure, based on
+        the active units: [Tmin, Tmax, pmin, pmax]"""
+        dim = self._system[CoolProp.iT]
+        limits[0] = dim.to_SI(limits[0])
+        limits[1] = dim.to_SI(limits[1])
+        dim = self._system[CoolProp.iP]
+        limits[2] = dim.to_SI(limits[2])
+        limits[3] = dim.to_SI(limits[3])
+        self.limits = limits
+
+    def get_Tp_limits(self):
+        """Get the limits for the graphs in temperature and pressure, based on
+        the active units: [Tmin, Tmax, pmin, pmax]"""
+        limits = self._get_Tp_limits()
+        dim = self._system[CoolProp.iT]
+        limits[0] = dim.from_SI(limits[0])
+        limits[1] = dim.from_SI(limits[1])
+        dim = self._system[CoolProp.iP]
+        limits[2] = dim.from_SI(limits[2])
+        limits[3] = dim.from_SI(limits[3])
+        return limits
+
+    def _get_Tp_limits(self):
+        """Get the limits for the graphs in temperature and pressure, based on
+        SI units: [Tmin, Tmax, pmin, pmax]"""
+        T_lo, T_hi, P_lo, P_hi = self.limits
+        Ts_lo, Ts_hi = self._get_sat_bounds(CoolProp.iT)
+        Ps_lo, Ps_hi = self._get_sat_bounds(CoolProp.iP)
+
+        if T_lo is None: T_lo = 0.0
+        elif T_lo < self.ID_FACTOR: T_lo *= Ts_lo
+        if T_hi is None: T_hi = 1e6
+        elif T_hi < self.ID_FACTOR: T_hi *= Ts_hi
+        if P_lo is None: P_lo = 0.0
+        elif P_lo < self.ID_FACTOR: P_lo *= Ps_lo
+        if P_hi is None: P_hi = 1e10
+        elif P_hi < self.ID_FACTOR: P_hi *= Ps_hi
+
+        try: T_lo = np.nanmax([T_lo, self._state.trivial_keyed_output(CoolProp.iT_min)])
+        except: pass
+        try: T_hi = np.nanmin([T_hi, self._state.trivial_keyed_output(CoolProp.iT_max)])
+        except: pass
+        try: P_lo = np.nanmax([P_lo, self._state.trivial_keyed_output(CoolProp.iP_min)])
+        except: pass
+        try: P_hi = np.nanmin([P_hi, self._state.trivial_keyed_output(CoolProp.iP_max)])
+        except: pass
+
+        return [T_lo, T_hi, P_lo, P_hi]
+
+    def set_axis_limits(self, limits):
+        """Set the limits of the internal axis object based on the active units,
+        takes [xmin, xmax, ymin, ymax]"""
+        self.axis.set_xlim([limits[0], limits[1]])
+        self.axis.set_ylim([limits[2], limits[3]])
+
+    def _set_axis_limits(self, limits):
+        """Set the limits of the internal axis object based on SI units,
+        takes [xmin, xmax, ymin, ymax]"""
+        dim = self._system[self._x_index]
+        self.axis.set_xlim([dim.from_SI(limits[0]), dim.from_SI(limits[1])])
+        dim = self._system[self._y_index]
+        self.axis.set_ylim([dim.from_SI(limits[2]), dim.from_SI(limits[3])])
+
+    def get_axis_limits(self, x_index=None, y_index=None):
+        """Returns the previously set limits or generates them and
+        converts the default values to the selected unit system.
+        Returns a list containing [xmin, xmax, ymin, ymax]"""
+        if x_index is None: x_index = self._x_index
+        if y_index is None: y_index = self._y_index
+
+        if x_index != self.x_index or y_index != self.y_index or \
+          self.axis.get_autoscalex_on() or self.axis.get_autoscaley_on():
+            # One of them is not set or we work on a different set of axes
+            T_lo, T_hi, P_lo, P_hi = self._get_Tp_limits()
+
+            X = [0.0] * 4; Y = [0.0] * 4
+            i = -1
+            for T in [T_lo, T_hi]:
+                for P in [P_lo, P_hi]:
+                    i += 1
+                    try:
+                        self._state.update(CoolProp.PT_INPUTS, P, T)
+                        # TODO: include a check for P and T?
+                        X[i] = self._state.keyed_output(x_index)
+                        Y[i] = self._state.keyed_output(y_index)
+                    except:
+                        X[i] = np.nan; Y[i] = np.nan
+            # Figure out what to update
+            dim = self._system[x_index]
+            x_lim = [dim.from_SI(np.nanmin(X)), dim.from_SI(np.nanmax(X))]
+            dim = self._system[y_index]
+            y_lim = [dim.from_SI(np.nanmin(Y)), dim.from_SI(np.nanmax(Y))]
+            # Either update the axes limits or get them
+            if x_index == self._x_index:
+                if self.axis.get_autoscalex_on():
+                    self.axis.set_xlim(x_lim)
+                else:
+                    x_lim = self.axis.get_xlim()
+            if y_index == self._y_index:
+                if self.axis.get_autoscaley_on():
+                    self.axis.set_ylim(y_lim)
+                else:
+                    y_lim = self.axis.get_ylim()
+        else:  # We only asked for the real axes limits and they are set already
+            x_lim = self.axis.get_xlim()
+            y_lim = self.axis.get_ylim()
+
+        return [x_lim[0], x_lim[1], y_lim[0], y_lim[1]]
+
+    def _get_axis_limits(self, x_index=None, y_index=None):
+        """Get the limits of the internal axis object in SI units
+        Returns a list containing [xmin, xmax, ymin, ymax]"""
+        if x_index is None: x_index = self._x_index
+        if y_index is None: y_index = self._y_index
+        limits = self.get_axis_limits(x_index, y_index)
+        dim = self._system[x_index]
+        limits[0] = dim.to_SI(limits[0])
+        limits[1] = dim.to_SI(limits[1])
+        dim = self._system[y_index]
+        limits[2] = dim.to_SI(limits[2])
+        limits[3] = dim.to_SI(limits[3])
+        return limits
+
+    @staticmethod
+    def generate_ranges(itype, imin, imax, num):
+        """Generate a range for a certain property"""
+        if itype in [CoolProp.iP, CoolProp.iDmass]:
+            return np.logspace(np.log2(imin), np.log2(imax), num=num, base=2.)
+        return np.linspace(imin, imax, num=num)
+
+    def _get_conversion_data(self):
+        [Axmin, Axmax, Aymin, Aymax] = self._get_axis_limits()
+        DELTAX_axis = Axmax - Axmin
+        DELTAY_axis = Aymax - Aymin
+        width = self.figure.get_figwidth()
+        height = self.figure.get_figheight()
+        pos = self.axis.get_position().get_points()
+        [[Fxmin, Fymin], [Fxmax, Fymax]] = pos
+        DELTAX_fig = width * (Fxmax - Fxmin)
+        DELTAY_fig = height * (Fymax - Fymin)
+        return [[Axmin, Axmax, Aymin, Aymax, Fxmin, Fxmax, Fymin, Fymax], [DELTAX_axis, DELTAY_axis, DELTAX_fig, DELTAY_fig]]
+
+    def _to_pixel_coords(self, xv, yv):
+        [[Axmin, Axmax, Aymin, Aymax, Fxmin, Fxmax, Fymin, Fymax], [DELTAX_axis, DELTAY_axis, DELTAX_fig, DELTAY_fig]] = self._get_conversion_data()
+        # Convert coords to pixels
+        x = (xv - Axmin) / DELTAX_axis * DELTAX_fig + Fxmin
+        y = (yv - Aymin) / DELTAY_axis * DELTAY_fig + Fymin
+        return x, y
+
+    def _to_data_coords(self, xv, yv):
+        [[Axmin, Axmax, Aymin, Aymax, Fxmin, Fxmax, Fymin, Fymax], [DELTAX_axis, DELTAY_axis, DELTAX_fig, DELTAY_fig]] = self._get_conversion_data()
+        # Convert back to measurements
+        x = (xv - Fxmin) / DELTAX_fig * DELTAX_axis + Axmin
+        y = (yv - Fymin) / DELTAY_fig * DELTAY_axis + Aymin
+        return x, y
+
+    @staticmethod
+    def get_x_y_dydx(xv, yv, x):
+        """Get x and y coordinates and the linear interpolation derivative"""
+        # Old implementation:
+        # Get the rotation angle
+        #f = interp1d(xv, yv)
+        #y = f(x)
+        #h = 0.00001*x
+        #dy_dx = (f(x+h)-f(x-h))/(2*h)
+        # return x,y,dy_dx
+        if len(xv) == len(yv) and len(yv) > 1:  # assure same length
+            if len(xv) == len(yv) and len(yv) == 2:  # only two points
+                if np.min(xv) < x < np.max(xv):
+                    dx = xv[1] - xv[0]
+                    dy = yv[1] - yv[0]
+                    dydx = dy / dx
+                    y = yv[0] + dydx * (x - xv[0])
+                    return x, y, dydx
+                else:
+                    raise ValueError("Your coordinate has to be between the input values.")
+            else:
+                limit = 1e-10                    # avoid hitting a point directly
+                diff = np.array(xv) - x        # get differences
+                index = np.argmin(diff * diff)  # nearest neighbour
+                if (xv[index] < x < xv[index + 1]      # nearest below, positive inclination
+                  or xv[index] > x > xv[index + 1]):   # nearest above, negative inclination
+                    if diff[index] < limit:
+                        index = [index - 1, index + 1]
+                    else:
+                        index = [index, index + 1]
+                elif (xv[index - 1] < x < xv[index]    # nearest above, positive inclination
+                  or xv[index - 1] > x > xv[index]):   # nearest below, negative inclination
+                    if diff[index] < limit:
+                        index = [index - 1, index + 1]
+                    else:
+                        index = [index - 1, index]
+                xvnew = xv[index]
+                yvnew = yv[index]
+                return BasePlot.get_x_y_dydx(xvnew, yvnew, x)  # Allow for a single recursion
+        else:
+            raise ValueError("You have to provide the same amount of x- and y-pairs with at least two entries each.")
+
+    def _inline_label(self, xv, yv, x=None, y=None):
+        """
+        This will give the coordinates and rotation required to align a label with
+        a line on a plot in SI units.
+        """
+        if y is None and x is not None:
+            trash = 0
+            (xv, yv) = self._to_pixel_coords(xv, yv)
+            # x is provided but y isn't
+            (x, trash) = self._to_pixel_coords(x, trash)
+
+            # Get the rotation angle and y-value
+            x, y, dy_dx = BasePlot.get_x_y_dydx(xv, yv, x)
+            rot = np.arctan(dy_dx) / np.pi * 180.
+
+        elif x is None and y is not None:
+            # y is provided, but x isn't
+            _xv = xv[::-1]
+            _yv = yv[::-1]
+            # Find x by interpolation
+            x = interpolate_values_1d(yv, xv, x_points=y)
+            trash = 0
+            (xv, yv) = self._to_pixel_coords(xv, yv)
+            (x, trash) = self._to_pixel_coords(x, trash)
+
+            # Get the rotation angle and y-value
+            x, y, dy_dx = BasePlot.get_x_y_dydx(xv, yv, x)
+            rot = np.arctan(dy_dx) / np.pi * 180.
+        (x, y) = self._to_data_coords(x, y)
+        return (x, y, rot)
+
+    def inline_label(self, xv, yv, x=None, y=None):
+        """
+        This will give the coordinates and rotation required to align a label with
+        a line on a plot in axis units.
+        """
+        dimx = self._system[self._x_index]
+        xv = dimx.to_SI(xv)
+        if x is not None: x = dimx.to_SI(x)
+        dimy = self._system[self._y_index]
+        yv = dimy.to_SI(yv)
+        if y is not None: y = dimy.to_SI(y)
+        (x, y, rot) = self._inline_label(xv, yv, x, y)
+        x = dimx.from_SI(x)
+        y = dimy.from_SI(y)
+        return (x, y, rot)
+
+    def show(self):
+        plt.show()
+
+    def savefig(self, *args, **kwargs):
+        self.figure.savefig(*args, **kwargs)
+
+
+if __name__ == "__main__":
+    for sys in [SIunits(), KSIunits(), EURunits()]:
+        print(sys.H.label)
+        print(sys.H.to_SI(20))
+        print(sys.P.label)
+        print(sys.P.to_SI(20))
+
+    # i_index, x_index, y_index, value=None, state=None)
+    iso = IsoLine('T', 'H', 'P')
+    print(iso.get_update_pair())
+
+    state = AbstractState("HEOS", "water")
+    iso = IsoLine('T', 'H', 'P', 300.0, state)
+    hr = PropsSI("H", "T", [290, 310], "P", [1e5, 1e5], "water")
+    pr = np.linspace(0.9e5, 1.1e5, 3)
+    iso.calc_range(hr, pr)
+    print(iso.x, iso.y)
+
+    iso = IsoLine('Q', 'H', 'P', 0.0, state)
+    iso.calc_range(hr, pr); print(iso.x, iso.y)
+    iso = IsoLine('Q', 'H', 'P', 1.0, state)
+    iso.calc_range(hr, pr); print(iso.x, iso.y)
+
+    # bp = BasePlot(fluid_ref, graph_type, unit_system = 'KSI', **kwargs):
+    bp = BasePlot('n-Pentane', 'PH', unit_system='EUR')
+    # print(bp._get_sat_bounds('P'))
+    # print(bp._get_iso_label(iso))
+    print(bp.get_axis_limits())
+
+        # get_update_pair(CoolProp.iP,CoolProp.iSmass,CoolProp.iT) -> (0,1,2,CoolProp.PSmass_INPUTS)
+        # other values require switching and swapping
+        # get_update_pair(CoolProp.iSmass,CoolProp.iP,CoolProp.iHmass) -> (1,0,2,CoolProp.PSmass_INPUTS)
```

## CoolProp/Plots/ConsistencyPlots.py

 * *Ordering differences only*

```diff
@@ -1,522 +1,522 @@
-# -*- coding: utf-8 -*-
-from __future__ import print_function, division, absolute_import
-
-
-import matplotlib.pyplot as plt
-import numpy as np
-import time, timeit
-import six
-import pandas
-import CoolProp as CP
-
-CP.CoolProp.set_debug_level(00)
-from matplotlib.backends.backend_pdf import PdfPages
-
-all_solvers = ['PT', 'DmolarT', 'HmolarP', 'PSmolar', 'SmolarT', 'PUmolar', 'DmolarP', 'DmolarHmolar', 'DmolarSmolar', 'DmolarUmolar', 'HmolarSmolar', 'HmolarT', 'TUmolar', 'SmolarUmolar', 'HmolarUmolar']
-not_implemented_solvers = ['SmolarUmolar', 'HmolarUmolar', 'TUmolar', 'HmolarT']
-no_two_phase_solvers = ['PT']
-
-implemented_solvers = [pair for pair in all_solvers if pair not in not_implemented_solvers]
-
-param_labels = dict(Hmolar='Enthalpy [J/mol]/1000',
-                    Smolar='Entropy [J/mol/K]/1000',
-                    Umolar='Int. Ener. [J/mol]/1000',
-                    T='Temperature [K]',
-                    Dmolar='Density [mol/m3]/1000',
-                    P='Pressure [Pa]/1000')
-
-
-def split_pair(pair):
-    for key in ['Dmolar', 'Hmolar', 'Smolar', 'P', 'T', 'Umolar']:
-        if pair.startswith(key):
-            return key, pair.replace(key, '')
-
-
-def split_pair_xy(pair):
-    if pair == 'HmolarP':
-        return 'Hmolar', 'P'
-    elif pair == 'PSmolar':
-        return 'Smolar', 'P'
-    elif pair == 'PUmolar':
-        return 'Umolar', 'P'
-    elif pair == 'PT':
-        return 'T', 'P'
-    elif pair == 'DmolarT':
-        return 'Dmolar', 'T'
-    elif pair == 'SmolarT':
-        return 'Smolar', 'T'
-    elif pair == 'TUmolar':
-        return 'Umolar', 'T'
-    elif pair == 'HmolarT':
-        return 'Hmolar', 'T'
-    elif pair == 'DmolarP':
-        return 'Dmolar', 'P'
-    elif pair == 'DmolarHmolar':
-        return 'Dmolar', 'Hmolar'
-    elif pair == 'DmolarSmolar':
-        return 'Dmolar', 'Smolar'
-    elif pair == 'DmolarUmolar':
-        return 'Dmolar', 'Umolar'
-    elif pair == 'HmolarSmolar':
-        return 'Smolar', 'Hmolar'
-    elif pair == 'SmolarUmolar':
-        return 'Smolar', 'Umolar'
-    elif pair == 'HmolarUmolar':
-        return 'Hmolar', 'Umolar'
-    else:
-        raise ValueError(pair)
-
-
-DEBUG_LEVEL = 1
-
-
-def myprint(level, *args, **kwargs):
-    if level > DEBUG_LEVEL:
-        print(*args, **kwargs)
-
-
-class ConsistencyFigure(object):
-    def __init__(self, fluid, figsize=(15, 23), backend='HEOS', additional_skips=[], mole_fractions=None, p_limits_1phase=None, T_limits_1phase=None, NT_1phase=40, Np_1phase=40, NT_2phase=20, NQ_2phase=20):
-
-        self.fluid = fluid
-        self.backend = backend
-        print('***********************************************************************************')
-        print('*************** ' + backend + '::' + fluid + ' ************************')
-        print('***********************************************************************************')
-        self.fig, self.axes = plt.subplots(nrows=5, ncols=3, figsize=figsize)
-        self.pairs = all_solvers
-        pairs_generator = iter(self.pairs)
-
-        states = [CP.AbstractState(backend, fluid) for _ in range(3)]
-        if mole_fractions is not None:
-            for state in states:
-                state.set_mole_fractions(mole_fractions)
-        self.axes_list = []
-        for row in self.axes:
-            for ax in row:
-                pair = six.next(pairs_generator)
-                kwargs = dict(p_limits_1phase=p_limits_1phase, T_limits_1phase=T_limits_1phase, NT_1phase=NT_1phase, Np_1phase=Np_1phase,
-                              NT_2phase=NT_2phase, NQ_2phase=NQ_2phase)
-                self.axes_list.append(ConsistencyAxis(ax, self, pair, self.fluid, self.backend, *states, **kwargs))
-                ax.set_title(pair)
-
-        self.calc_saturation_curves()
-        self.plot_saturation_curves()
-
-        self.calc_Tmax_curve()
-        self.plot_Tmax_curve()
-
-        self.calc_melting_curve()
-        self.plot_melting_curve()
-
-        self.tight_layout()
-
-        self.fig.subplots_adjust(top=0.95)
-        self.fig.suptitle('Consistency plots for ' + self.fluid, size=14)
-
-        errors = []
-        for i, (ax, pair) in enumerate(zip(self.axes_list, self.pairs)):
-            if pair not in not_implemented_solvers and pair not in additional_skips:
-                errors.append(ax.consistency_check_singlephase())
-                if pair not in no_two_phase_solvers:
-                    ax.consistency_check_twophase()
-            else:
-                ax.cross_out_axis()
-
-        self.errors = pandas.concat(errors, sort=True)
-
-    def calc_saturation_curves(self):
-        """
-        Calculate all the saturation curves in one shot using the state class to save computational time
-        """
-        HEOS = CP.AbstractState(self.backend, self.fluid)
-        self.dictL, self.dictV = {}, {}
-        for Q, dic in zip([0, 1], [self.dictL, self.dictV]):
-            rhomolar, smolar, hmolar, T, p, umolar = [], [], [], [], [], []
-            for _T in np.logspace(np.log10(HEOS.keyed_output(CP.iT_triple)), np.log10(HEOS.keyed_output(CP.iT_critical)), 500):
-                try:
-                    HEOS.update(CP.QT_INPUTS, Q, _T)
-                    if (HEOS.p() < 0): raise ValueError('P is negative:' + str(HEOS.p()))
-                    HEOS.T(), HEOS.p(), HEOS.rhomolar(), HEOS.hmolar(), HEOS.smolar()
-                    HEOS.umolar()
-
-                    T.append(HEOS.T())
-                    p.append(HEOS.p())
-                    rhomolar.append(HEOS.rhomolar())
-                    hmolar.append(HEOS.hmolar())
-                    smolar.append(HEOS.smolar())
-                    umolar.append(HEOS.umolar())
-                except ValueError as VE:
-                    myprint(1, 'satT error:', VE, '; T:', '{T:0.16g}'.format(T=_T), 'T/Tc:', _T / HEOS.keyed_output(CP.iT_critical))
-
-            dic.update(dict(T=np.array(T),
-                            P=np.array(p),
-                            Dmolar=np.array(rhomolar),
-                            Hmolar=np.array(hmolar),
-                            Smolar=np.array(smolar),
-                            Umolar=np.array(umolar)))
-
-    def plot_saturation_curves(self):
-        for ax in self.axes_list:
-            ax.label_axes()
-            ax.plot_saturation_curves()
-
-    def calc_Tmax_curve(self):
-        HEOS = CP.AbstractState(self.backend, self.fluid)
-        rhomolar, smolar, hmolar, T, p, umolar = [], [], [], [], [], []
-
-        for _p in np.logspace(np.log10(HEOS.keyed_output(CP.iP_min) * 1.01), np.log10(HEOS.keyed_output(CP.iP_max)), 300):
-            try:
-                HEOS.update(CP.PT_INPUTS, _p, HEOS.keyed_output(CP.iT_max))
-            except ValueError as VE:
-                myprint(1, 'Tmax', _p, VE)
-                continue
-
-            try:
-                T.append(HEOS.T())
-                p.append(HEOS.p())
-                rhomolar.append(HEOS.rhomolar())
-                hmolar.append(HEOS.hmolar())
-                smolar.append(HEOS.smolar())
-                umolar.append(HEOS.umolar())
-            except ValueError as VE:
-                myprint(1, 'Tmax access', VE)
-
-        self.Tmax = dict(T=np.array(T),
-                         P=np.array(p),
-                         Dmolar=np.array(rhomolar),
-                         Hmolar=np.array(hmolar),
-                         Smolar=np.array(smolar),
-                         Umolar=np.array(umolar))
-
-    def plot_Tmax_curve(self):
-        for ax in self.axes_list:
-            ax.plot_Tmax_curve()
-
-    def calc_melting_curve(self):
-        state = CP.AbstractState('HEOS', self.fluid)
-        rhomolar, smolar, hmolar, T, p, umolar = [], [], [], [], [], []
-
-        # Melting line if it has it
-        if state.has_melting_line():
-            pmelt_min = max(state.melting_line(CP.iP_min, -1, -1), state.keyed_output(CP.iP_triple)) * 1.01
-            pmelt_max = min(state.melting_line(CP.iP_max, -1, -1), state.keyed_output(CP.iP_max)) * 0.99
-
-            for _p in np.logspace(np.log10(pmelt_min), np.log10(pmelt_max), 100):
-                try:
-                    Tm = state.melting_line(CP.iT, CP.iP, _p)
-                    state.update(CP.PT_INPUTS, _p, Tm)
-                    T.append(state.T())
-                    p.append(state.p())
-                    rhomolar.append(state.rhomolar())
-                    hmolar.append(state.hmolar())
-                    smolar.append(state.smolar())
-                    umolar.append(state.umolar())
-                except ValueError as VE:
-                    myprint(1, 'melting', VE)
-
-        self.melt = dict(T=np.array(T),
-                         P=np.array(p),
-                         Dmolar=np.array(rhomolar),
-                         Hmolar=np.array(hmolar),
-                         Smolar=np.array(smolar),
-                         Umolar=np.array(umolar))
-
-    def plot_melting_curve(self):
-        for ax in self.axes_list:
-            ax.plot_melting_curve()
-
-    def tight_layout(self):
-        self.fig.tight_layout()
-
-    def add_to_pdf(self, pdf):
-        """ Add this figure to the pdf instance """
-        pdf.savefig(self.fig)
-
-    def savefig(self, fname, **kwargs):
-        self.fig.savefig(fname, **kwargs)
-
-
-class ConsistencyAxis(object):
-    def __init__(self, axis, fig, pair, fluid, backend, state1, state2, state3,
-                 p_limits_1phase=None, T_limits_1phase=None, NT_1phase=40, Np_1phase=40,
-                 NT_2phase=20, NQ_2phase=20
-                 ):
-        self.ax = axis
-        self.fig = fig
-        self.pair = pair
-        self.fluid = fluid
-        self.backend = backend
-        self.state = state1
-        self.state_PT = state2
-        self.state_QT = state3
-        self.p_limits_1phase = p_limits_1phase
-        self.T_limits_1phase = T_limits_1phase
-        self.NT_1phase = NT_1phase
-        self.Np_1phase = Np_1phase
-        self.NQ_2phase = NQ_2phase
-        self.NT_2phase = NT_2phase
-        # self.saturation_curves()
-
-    def label_axes(self):
-        """ Label the axes for the given pair """
-        xparam, yparam = split_pair_xy(self.pair)
-        self.ax.set_xlabel(param_labels[xparam])
-        self.ax.set_ylabel(param_labels[yparam])
-
-        if xparam in ['P', 'Dmolar']:
-            self.ax.set_xscale('log')
-        if yparam in ['P', 'Dmolar']:
-            self.ax.set_yscale('log')
-
-    def plot_saturation_curves(self):
-        xparam, yparam = split_pair_xy(self.pair)
-        xL = self.to_axis_units(xparam, self.fig.dictL[xparam])
-        yL = self.to_axis_units(yparam, self.fig.dictL[yparam])
-        xV = self.to_axis_units(xparam, self.fig.dictV[xparam])
-        yV = self.to_axis_units(yparam, self.fig.dictV[yparam])
-        self.ax.plot(xL, yL, 'k', lw=1)
-        self.ax.plot(xV, yV, 'k', lw=1)
-
-    def plot_Tmax_curve(self):
-        xparam, yparam = split_pair_xy(self.pair)
-        x = self.to_axis_units(xparam, self.fig.Tmax[xparam])
-        y = self.to_axis_units(yparam, self.fig.Tmax[yparam])
-        self.ax.plot(x, y, 'r', lw=1)
-
-    def plot_melting_curve(self):
-        xparam, yparam = split_pair_xy(self.pair)
-        x = self.to_axis_units(xparam, self.fig.melt[xparam])
-        y = self.to_axis_units(yparam, self.fig.melt[yparam])
-        self.ax.plot(x, y, 'b', lw=1)
-
-    def to_axis_units(self, label, vals):
-        """ Convert to the units used in the plot """
-        if label in ['Hmolar', 'Smolar', 'Umolar', 'Dmolar', 'P']:
-            return vals / 1000
-        elif label in ['T']:
-            return vals
-        else:
-            raise ValueError(label)
-
-    def consistency_check_singlephase(self):
-
-        tic = time.time()
-
-        # Update the state given the desired set of inputs
-        param1, param2 = split_pair(self.pair)
-        key1 = getattr(CP, 'i' + param1)
-        key2 = getattr(CP, 'i' + param2)
-        pairkey = getattr(CP, self.pair + '_INPUTS')
-
-        # Get the keys and indices and values for the inputs needed
-        xparam, yparam = split_pair_xy(self.pair)
-        xkey = getattr(CP, 'i' + xparam)
-        ykey = getattr(CP, 'i' + yparam)
-
-        data = []
-
-        if self.p_limits_1phase is not None:
-            # User-specified limits were provided, use them
-            p_min, p_max = self.p_limits_1phase
-        else:
-            # No user-specified limits were provided, use the defaults
-            p_min = self.state.keyed_output(CP.iP_min) * 1.01
-            p_max = self.state.keyed_output(CP.iP_max)
-
-        for p in np.logspace(np.log10(p_min), np.log10(p_max), self.Np_1phase):
-
-            if self.T_limits_1phase is None:
-                # No user-specified limits were provided, using the defaults
-                Tmin = self.state.keyed_output(CP.iT_triple)
-                if self.state.has_melting_line():
-                    try:
-                        pmelt_min = self.state.melting_line(CP.iP_min, -1, -1)
-                        if p < pmelt_min:
-                            T0 = Tmin
-                        else:
-                            T0 = self.state.melting_line(CP.iT, CP.iP, p)
-                    except Exception as E:
-                        T0 = Tmin + 1.1
-                        data.append(dict(err=str(E), type="melting", input=p))
-                        myprint(1, 'MeltingLine:', E)
-                else:
-                    T0 = Tmin + 1.1
-                Tvec = np.linspace(T0, self.state.keyed_output(CP.iT_max), self.NT_1phase)
-            else:
-                # Use the provided limits for T
-                Tvec = np.linspace(self.T_limits_1phase[0], self.T_limits_1phase[1], self.NT_1phase)
-
-            for T in Tvec:
-
-                try:
-                    # Update the state using PT inputs in order to calculate all the remaining inputs
-                    self.state_PT.update(CP.PT_INPUTS, p, T)
-                except ValueError as VE:
-                    data.append(dict(err=str(VE), cls="EXCEPTION", type="update", in1="P", val1=p, in2="T", val2=T))
-                    myprint(1, 'consistency', VE)
-                    continue
-
-                _exception = False
-                tic2 = timeit.default_timer()
-                try:
-                    val1, val2 = self.state_PT.keyed_output(key1), self.state_PT.keyed_output(key2)
-                    self.state.update(pairkey, val1, val2)
-                    toc2 = timeit.default_timer()
-                except ValueError as VE:
-                    data.append(dict(err=str(VE), cls="EXCEPTION", type="update", in1=param1, val1=val1, in2=param2, val2=val2))
-                    myprint(1, 'update(1p)', self.pair, 'P', p, 'T', T, 'D', self.state_PT.keyed_output(CP.iDmolar), '{0:18.16g}, {1:18.16g}'.format(self.state_PT.keyed_output(key1), self.state_PT.keyed_output(key2)), VE)
-                    _exception = True
-
-                x = self.to_axis_units(xparam, self.state_PT.keyed_output(xkey))
-                y = self.to_axis_units(yparam, self.state_PT.keyed_output(ykey))
-
-                if not _exception:
-                    # Check the error on the density
-                    if abs(self.state_PT.rhomolar() / self.state.rhomolar() - 1) < 1e-3 and abs(self.state_PT.p() / self.state.p() - 1) < 1e-3 and abs(self.state_PT.T() - self.state.T()) < 1e-3:
-                        data.append(dict(cls="GOOD", x=x, y=y, elapsed=toc2 - tic2))
-                        if 'REFPROP' not in self.backend:
-                            if self.state_PT.phase() != self.state.phase():
-                                myprint(1, 'bad phase', self.pair, '{0:18.16g}, {1:18.16g}'.format(self.state_PT.keyed_output(key1), self.state_PT.keyed_output(key2)), self.state.phase(), 'instead of', self.state_PT.phase())
-                    else:
-                        data.append(dict(cls="INCONSISTENT", type="update", in1=param1, val1=val1, in2=param2, val2=val2, x=x, y=y))
-                        myprint(1, 'bad', self.pair, '{0:18.16g}, {1:18.16g}'.format(self.state_PT.keyed_output(key1), self.state_PT.keyed_output(key2)), 'T:', self.state_PT.T(), 'Drho:', abs(self.state_PT.rhomolar() / self.state.rhomolar() - 1), abs(self.state_PT.p() / self.state.p() - 1), 'DT:', abs(self.state_PT.T() - self.state.T()))
-
-        toc = time.time()
-        df = pandas.DataFrame(data)
-        bad = df[df.cls == 'INCONSISTENT']
-        good = df[df.cls == 'GOOD']
-        slowgood = good[good.elapsed > 0.01]
-        excep = df[df.cls == 'EXCEPTION']
-        badphase = df[df.cls == 'BAD_PHASE']
-
-        self.ax.plot(bad.x, bad.y, 'r+', ms=3)
-        self.ax.plot(good.x, good.y, 'k.', ms=1)
-        self.ax.plot(excep.x, excep.y, 'rx', ms=3)
-        self.ax.plot(slowgood.x, slowgood.y, 'b*', ms=6)
-        self.ax.plot(badphase.x, badphase.y, 'o', ms=3, mfc='none')
-
-        print('1-phase took ' + str(toc - tic) + ' s for ' + self.pair)
-
-        if self.pair == 'HmolarSmolar':
-            # plt.plot(good.elapsed)
-            # plt.title(self.pair)
-            # plt.show()
-
-            good.to_excel('times_water.xlsx')
-        return df[df.cls != 'GOOD']
-
-    def consistency_check_twophase(self):
-
-        tic = time.time()
-        state = self.state
-
-        try:
-            if state.fluid_param_string('pure') == 'false':
-                print("Not a pure-fluid, skipping two-phase evaluation")
-                return
-        except:
-            pass
-
-        # Update the state given the desired set of inputs
-        param1, param2 = split_pair(self.pair)
-        key1 = getattr(CP, 'i' + param1)
-        key2 = getattr(CP, 'i' + param2)
-        pairkey = getattr(CP, self.pair + '_INPUTS')
-
-        # Get the keys and indices and values for the inputs needed
-        xparam, yparam = split_pair_xy(self.pair)
-        xkey = getattr(CP, 'i' + xparam)
-        ykey = getattr(CP, 'i' + yparam)
-
-        data = []
-        for q in np.linspace(0, 1, self.NQ_2phase):
-
-            Tmin = state.keyed_output(CP.iT_triple) + 1
-
-            for T in np.linspace(Tmin, state.keyed_output(CP.iT_critical) - 1, self.NT_2phase):
-
-                try:
-                    # Update the state using QT inputs in order to calculate all the remaining inputs
-                    self.state_QT.update(CP.QT_INPUTS, q, T)
-                except ValueError as VE:
-                    data.append(dict(err=str(VE), cls="EXCEPTION", type="update", in1="Q", val1=q, in2="T", val2=T))
-                    myprint(1, 'consistency', VE)
-                    continue
-
-                _exception = False
-                try:
-                    val1, val2 = self.state_QT.keyed_output(key1), self.state_QT.keyed_output(key2)
-                    state.update(pairkey, val1, val2)
-                except ValueError as VE:
-                    data.append(dict(err=str(VE), cls="EXCEPTION", type="update", in1=param1, val1=val1, in2=param2, val2=val2))
-                    myprint(1, 'update_QT', T, q)
-                    myprint(1, 'update', param1, self.state_QT.keyed_output(key1), param2, self.state_QT.keyed_output(key2), VE)
-                    _exception = True
-
-                x = self.to_axis_units(xparam, self.state_QT.keyed_output(xkey))
-                y = self.to_axis_units(yparam, self.state_QT.keyed_output(ykey))
-
-                if not _exception:
-                    # Check the error on the density
-                    if abs(self.state_QT.rhomolar() / self.state.rhomolar() - 1) < 1e-3 and abs(self.state_QT.p() / self.state.p() - 1) < 1e-3 and abs(self.state_QT.T() - self.state.T()) < 1e-3:
-                        data.append(dict(cls="GOOD", x=x, y=y))
-                        if 'REFPROP' not in self.backend:
-                            if self.state_QT.phase() != self.state.phase():
-                                myprint(1, 'bad phase (2phase)', self.pair, '{0:18.16g}, {1:18.16g}'.format(self.state_QT.keyed_output(key1), self.state_QT.keyed_output(key2)), self.state.phase(), 'instead of', self.state_QT.phase())
-
-                    else:
-                        myprint(1, 'Q', q)
-                        myprint(1, 'bad(2phase)', self.pair, '{0:18.16g}, {1:18.16g}'.format(self.state_QT.keyed_output(key1), self.state_QT.keyed_output(key2)), 'pnew:', self.state.p(), 'pold:', self.state_QT.p(), 'Tnew:', self.state.T(), 'T:', self.state_QT.T(), 'Drho:', abs(self.state_QT.rhomolar() / self.state.rhomolar() - 1), 'DP', abs(self.state_QT.p() / self.state.p() - 1), 'DT:', abs(self.state_QT.T() - self.state.T()))
-                        data.append(dict(cls="INCONSISTENT", type="update", in1=param1, val1=val1, in2=param2, val2=val2, x=x, y=y))
-
-        toc = time.time()
-        df = pandas.DataFrame(data)
-        bad = df[df.cls == 'INCONSISTENT']
-        good = df[df.cls == 'GOOD']
-        excep = df[df.cls == 'EXCEPTION']
-        badphase = df[df.cls == 'BAD_PHASE']
-
-        self.ax.plot(bad.x, bad.y, 'r+', ms=3)
-        self.ax.plot(good.x, good.y, 'k.', ms=1)
-        self.ax.plot(excep.x, excep.y, 'rx', ms=3)
-        self.ax.plot(badphase.x, badphase.y, 'o', ms=3, mfc='none')
-        print('2-phase took ' + str(toc - tic) + ' s for ' + self.pair)
-
-    def cross_out_axis(self):
-        xlims = self.ax.get_xlim()
-        ylims = self.ax.get_ylim()
-        self.ax.plot([xlims[0], xlims[1]], [ylims[0], ylims[1]], lw=3, c='r')
-        self.ax.plot([xlims[0], xlims[1]], [ylims[1], ylims[0]], lw=3, c='r')
-
-        xparam, yparam = split_pair_xy(self.pair)
-        x = 0.5 * xlims[0] + 0.5 * xlims[1]
-        y = 0.5 * ylims[0] + 0.5 * ylims[1]
-        if xparam in ['P', 'Dmolar']:
-            x = (xlims[0] * xlims[1])**0.5
-        if yparam in ['P', 'Dmolar']:
-            y = (ylims[0] * ylims[1])**0.5
-
-        self.ax.text(x, y, 'Not\nImplemented', ha='center', va='center', bbox=dict(fc='white'))
-
-
-if __name__ == '__main__':
-    PVT = PdfPages('Consistency.pdf')
-    CP.CoolProp.set_debug_level(0)
-    open('timelog.txt', 'w')
-    with open('timelog.txt', 'a+', buffering=1) as fp:
-        for fluid in ['METHANOL']:  # CP.__fluids__:
-            tic = timeit.default_timer()
-            skips = ['DmolarHmolar', 'DmolarSmolar', 'DmolarUmolar', 'HmolarSmolar']
-            skips = []
-            ff = ConsistencyFigure(fluid, backend='HEOS', additional_skips=skips)  # , NT_1phase = 10, Np_1phase = 10, NT_2phase = 100, NQ_2phase = 0)
-            ff.errors.to_excel('Errors' + fluid + '.xlsx')
-            toc = timeit.default_timer()
-            print('Time to build:', toc - tic, 'seconds')
-            ff.add_to_pdf(PVT)
-            ff.savefig(fluid + '.png')
-            ff.savefig(fluid + '.pdf')
-            plt.close()
-            fp.write('Time to build: {0} seconds for {1}\n'.format(toc - tic, fluid))
-            del ff
-    PVT.close()
+# -*- coding: utf-8 -*-
+from __future__ import print_function, division, absolute_import
+
+
+import matplotlib.pyplot as plt
+import numpy as np
+import time, timeit
+import six
+import pandas
+import CoolProp as CP
+
+CP.CoolProp.set_debug_level(00)
+from matplotlib.backends.backend_pdf import PdfPages
+
+all_solvers = ['PT', 'DmolarT', 'HmolarP', 'PSmolar', 'SmolarT', 'PUmolar', 'DmolarP', 'DmolarHmolar', 'DmolarSmolar', 'DmolarUmolar', 'HmolarSmolar', 'HmolarT', 'TUmolar', 'SmolarUmolar', 'HmolarUmolar']
+not_implemented_solvers = ['SmolarUmolar', 'HmolarUmolar', 'TUmolar', 'HmolarT']
+no_two_phase_solvers = ['PT']
+
+implemented_solvers = [pair for pair in all_solvers if pair not in not_implemented_solvers]
+
+param_labels = dict(Hmolar='Enthalpy [J/mol]/1000',
+                    Smolar='Entropy [J/mol/K]/1000',
+                    Umolar='Int. Ener. [J/mol]/1000',
+                    T='Temperature [K]',
+                    Dmolar='Density [mol/m3]/1000',
+                    P='Pressure [Pa]/1000')
+
+
+def split_pair(pair):
+    for key in ['Dmolar', 'Hmolar', 'Smolar', 'P', 'T', 'Umolar']:
+        if pair.startswith(key):
+            return key, pair.replace(key, '')
+
+
+def split_pair_xy(pair):
+    if pair == 'HmolarP':
+        return 'Hmolar', 'P'
+    elif pair == 'PSmolar':
+        return 'Smolar', 'P'
+    elif pair == 'PUmolar':
+        return 'Umolar', 'P'
+    elif pair == 'PT':
+        return 'T', 'P'
+    elif pair == 'DmolarT':
+        return 'Dmolar', 'T'
+    elif pair == 'SmolarT':
+        return 'Smolar', 'T'
+    elif pair == 'TUmolar':
+        return 'Umolar', 'T'
+    elif pair == 'HmolarT':
+        return 'Hmolar', 'T'
+    elif pair == 'DmolarP':
+        return 'Dmolar', 'P'
+    elif pair == 'DmolarHmolar':
+        return 'Dmolar', 'Hmolar'
+    elif pair == 'DmolarSmolar':
+        return 'Dmolar', 'Smolar'
+    elif pair == 'DmolarUmolar':
+        return 'Dmolar', 'Umolar'
+    elif pair == 'HmolarSmolar':
+        return 'Smolar', 'Hmolar'
+    elif pair == 'SmolarUmolar':
+        return 'Smolar', 'Umolar'
+    elif pair == 'HmolarUmolar':
+        return 'Hmolar', 'Umolar'
+    else:
+        raise ValueError(pair)
+
+
+DEBUG_LEVEL = 1
+
+
+def myprint(level, *args, **kwargs):
+    if level > DEBUG_LEVEL:
+        print(*args, **kwargs)
+
+
+class ConsistencyFigure(object):
+    def __init__(self, fluid, figsize=(15, 23), backend='HEOS', additional_skips=[], mole_fractions=None, p_limits_1phase=None, T_limits_1phase=None, NT_1phase=40, Np_1phase=40, NT_2phase=20, NQ_2phase=20):
+
+        self.fluid = fluid
+        self.backend = backend
+        print('***********************************************************************************')
+        print('*************** ' + backend + '::' + fluid + ' ************************')
+        print('***********************************************************************************')
+        self.fig, self.axes = plt.subplots(nrows=5, ncols=3, figsize=figsize)
+        self.pairs = all_solvers
+        pairs_generator = iter(self.pairs)
+
+        states = [CP.AbstractState(backend, fluid) for _ in range(3)]
+        if mole_fractions is not None:
+            for state in states:
+                state.set_mole_fractions(mole_fractions)
+        self.axes_list = []
+        for row in self.axes:
+            for ax in row:
+                pair = six.next(pairs_generator)
+                kwargs = dict(p_limits_1phase=p_limits_1phase, T_limits_1phase=T_limits_1phase, NT_1phase=NT_1phase, Np_1phase=Np_1phase,
+                              NT_2phase=NT_2phase, NQ_2phase=NQ_2phase)
+                self.axes_list.append(ConsistencyAxis(ax, self, pair, self.fluid, self.backend, *states, **kwargs))
+                ax.set_title(pair)
+
+        self.calc_saturation_curves()
+        self.plot_saturation_curves()
+
+        self.calc_Tmax_curve()
+        self.plot_Tmax_curve()
+
+        self.calc_melting_curve()
+        self.plot_melting_curve()
+
+        self.tight_layout()
+
+        self.fig.subplots_adjust(top=0.95)
+        self.fig.suptitle('Consistency plots for ' + self.fluid, size=14)
+
+        errors = []
+        for i, (ax, pair) in enumerate(zip(self.axes_list, self.pairs)):
+            if pair not in not_implemented_solvers and pair not in additional_skips:
+                errors.append(ax.consistency_check_singlephase())
+                if pair not in no_two_phase_solvers:
+                    ax.consistency_check_twophase()
+            else:
+                ax.cross_out_axis()
+
+        self.errors = pandas.concat(errors, sort=True)
+
+    def calc_saturation_curves(self):
+        """
+        Calculate all the saturation curves in one shot using the state class to save computational time
+        """
+        HEOS = CP.AbstractState(self.backend, self.fluid)
+        self.dictL, self.dictV = {}, {}
+        for Q, dic in zip([0, 1], [self.dictL, self.dictV]):
+            rhomolar, smolar, hmolar, T, p, umolar = [], [], [], [], [], []
+            for _T in np.logspace(np.log10(HEOS.keyed_output(CP.iT_triple)), np.log10(HEOS.keyed_output(CP.iT_critical)), 500):
+                try:
+                    HEOS.update(CP.QT_INPUTS, Q, _T)
+                    if (HEOS.p() < 0): raise ValueError('P is negative:' + str(HEOS.p()))
+                    HEOS.T(), HEOS.p(), HEOS.rhomolar(), HEOS.hmolar(), HEOS.smolar()
+                    HEOS.umolar()
+
+                    T.append(HEOS.T())
+                    p.append(HEOS.p())
+                    rhomolar.append(HEOS.rhomolar())
+                    hmolar.append(HEOS.hmolar())
+                    smolar.append(HEOS.smolar())
+                    umolar.append(HEOS.umolar())
+                except ValueError as VE:
+                    myprint(1, 'satT error:', VE, '; T:', '{T:0.16g}'.format(T=_T), 'T/Tc:', _T / HEOS.keyed_output(CP.iT_critical))
+
+            dic.update(dict(T=np.array(T),
+                            P=np.array(p),
+                            Dmolar=np.array(rhomolar),
+                            Hmolar=np.array(hmolar),
+                            Smolar=np.array(smolar),
+                            Umolar=np.array(umolar)))
+
+    def plot_saturation_curves(self):
+        for ax in self.axes_list:
+            ax.label_axes()
+            ax.plot_saturation_curves()
+
+    def calc_Tmax_curve(self):
+        HEOS = CP.AbstractState(self.backend, self.fluid)
+        rhomolar, smolar, hmolar, T, p, umolar = [], [], [], [], [], []
+
+        for _p in np.logspace(np.log10(HEOS.keyed_output(CP.iP_min) * 1.01), np.log10(HEOS.keyed_output(CP.iP_max)), 300):
+            try:
+                HEOS.update(CP.PT_INPUTS, _p, HEOS.keyed_output(CP.iT_max))
+            except ValueError as VE:
+                myprint(1, 'Tmax', _p, VE)
+                continue
+
+            try:
+                T.append(HEOS.T())
+                p.append(HEOS.p())
+                rhomolar.append(HEOS.rhomolar())
+                hmolar.append(HEOS.hmolar())
+                smolar.append(HEOS.smolar())
+                umolar.append(HEOS.umolar())
+            except ValueError as VE:
+                myprint(1, 'Tmax access', VE)
+
+        self.Tmax = dict(T=np.array(T),
+                         P=np.array(p),
+                         Dmolar=np.array(rhomolar),
+                         Hmolar=np.array(hmolar),
+                         Smolar=np.array(smolar),
+                         Umolar=np.array(umolar))
+
+    def plot_Tmax_curve(self):
+        for ax in self.axes_list:
+            ax.plot_Tmax_curve()
+
+    def calc_melting_curve(self):
+        state = CP.AbstractState('HEOS', self.fluid)
+        rhomolar, smolar, hmolar, T, p, umolar = [], [], [], [], [], []
+
+        # Melting line if it has it
+        if state.has_melting_line():
+            pmelt_min = max(state.melting_line(CP.iP_min, -1, -1), state.keyed_output(CP.iP_triple)) * 1.01
+            pmelt_max = min(state.melting_line(CP.iP_max, -1, -1), state.keyed_output(CP.iP_max)) * 0.99
+
+            for _p in np.logspace(np.log10(pmelt_min), np.log10(pmelt_max), 100):
+                try:
+                    Tm = state.melting_line(CP.iT, CP.iP, _p)
+                    state.update(CP.PT_INPUTS, _p, Tm)
+                    T.append(state.T())
+                    p.append(state.p())
+                    rhomolar.append(state.rhomolar())
+                    hmolar.append(state.hmolar())
+                    smolar.append(state.smolar())
+                    umolar.append(state.umolar())
+                except ValueError as VE:
+                    myprint(1, 'melting', VE)
+
+        self.melt = dict(T=np.array(T),
+                         P=np.array(p),
+                         Dmolar=np.array(rhomolar),
+                         Hmolar=np.array(hmolar),
+                         Smolar=np.array(smolar),
+                         Umolar=np.array(umolar))
+
+    def plot_melting_curve(self):
+        for ax in self.axes_list:
+            ax.plot_melting_curve()
+
+    def tight_layout(self):
+        self.fig.tight_layout()
+
+    def add_to_pdf(self, pdf):
+        """ Add this figure to the pdf instance """
+        pdf.savefig(self.fig)
+
+    def savefig(self, fname, **kwargs):
+        self.fig.savefig(fname, **kwargs)
+
+
+class ConsistencyAxis(object):
+    def __init__(self, axis, fig, pair, fluid, backend, state1, state2, state3,
+                 p_limits_1phase=None, T_limits_1phase=None, NT_1phase=40, Np_1phase=40,
+                 NT_2phase=20, NQ_2phase=20
+                 ):
+        self.ax = axis
+        self.fig = fig
+        self.pair = pair
+        self.fluid = fluid
+        self.backend = backend
+        self.state = state1
+        self.state_PT = state2
+        self.state_QT = state3
+        self.p_limits_1phase = p_limits_1phase
+        self.T_limits_1phase = T_limits_1phase
+        self.NT_1phase = NT_1phase
+        self.Np_1phase = Np_1phase
+        self.NQ_2phase = NQ_2phase
+        self.NT_2phase = NT_2phase
+        # self.saturation_curves()
+
+    def label_axes(self):
+        """ Label the axes for the given pair """
+        xparam, yparam = split_pair_xy(self.pair)
+        self.ax.set_xlabel(param_labels[xparam])
+        self.ax.set_ylabel(param_labels[yparam])
+
+        if xparam in ['P', 'Dmolar']:
+            self.ax.set_xscale('log')
+        if yparam in ['P', 'Dmolar']:
+            self.ax.set_yscale('log')
+
+    def plot_saturation_curves(self):
+        xparam, yparam = split_pair_xy(self.pair)
+        xL = self.to_axis_units(xparam, self.fig.dictL[xparam])
+        yL = self.to_axis_units(yparam, self.fig.dictL[yparam])
+        xV = self.to_axis_units(xparam, self.fig.dictV[xparam])
+        yV = self.to_axis_units(yparam, self.fig.dictV[yparam])
+        self.ax.plot(xL, yL, 'k', lw=1)
+        self.ax.plot(xV, yV, 'k', lw=1)
+
+    def plot_Tmax_curve(self):
+        xparam, yparam = split_pair_xy(self.pair)
+        x = self.to_axis_units(xparam, self.fig.Tmax[xparam])
+        y = self.to_axis_units(yparam, self.fig.Tmax[yparam])
+        self.ax.plot(x, y, 'r', lw=1)
+
+    def plot_melting_curve(self):
+        xparam, yparam = split_pair_xy(self.pair)
+        x = self.to_axis_units(xparam, self.fig.melt[xparam])
+        y = self.to_axis_units(yparam, self.fig.melt[yparam])
+        self.ax.plot(x, y, 'b', lw=1)
+
+    def to_axis_units(self, label, vals):
+        """ Convert to the units used in the plot """
+        if label in ['Hmolar', 'Smolar', 'Umolar', 'Dmolar', 'P']:
+            return vals / 1000
+        elif label in ['T']:
+            return vals
+        else:
+            raise ValueError(label)
+
+    def consistency_check_singlephase(self):
+
+        tic = time.time()
+
+        # Update the state given the desired set of inputs
+        param1, param2 = split_pair(self.pair)
+        key1 = getattr(CP, 'i' + param1)
+        key2 = getattr(CP, 'i' + param2)
+        pairkey = getattr(CP, self.pair + '_INPUTS')
+
+        # Get the keys and indices and values for the inputs needed
+        xparam, yparam = split_pair_xy(self.pair)
+        xkey = getattr(CP, 'i' + xparam)
+        ykey = getattr(CP, 'i' + yparam)
+
+        data = []
+
+        if self.p_limits_1phase is not None:
+            # User-specified limits were provided, use them
+            p_min, p_max = self.p_limits_1phase
+        else:
+            # No user-specified limits were provided, use the defaults
+            p_min = self.state.keyed_output(CP.iP_min) * 1.01
+            p_max = self.state.keyed_output(CP.iP_max)
+
+        for p in np.logspace(np.log10(p_min), np.log10(p_max), self.Np_1phase):
+
+            if self.T_limits_1phase is None:
+                # No user-specified limits were provided, using the defaults
+                Tmin = self.state.keyed_output(CP.iT_triple)
+                if self.state.has_melting_line():
+                    try:
+                        pmelt_min = self.state.melting_line(CP.iP_min, -1, -1)
+                        if p < pmelt_min:
+                            T0 = Tmin
+                        else:
+                            T0 = self.state.melting_line(CP.iT, CP.iP, p)
+                    except Exception as E:
+                        T0 = Tmin + 1.1
+                        data.append(dict(err=str(E), type="melting", input=p))
+                        myprint(1, 'MeltingLine:', E)
+                else:
+                    T0 = Tmin + 1.1
+                Tvec = np.linspace(T0, self.state.keyed_output(CP.iT_max), self.NT_1phase)
+            else:
+                # Use the provided limits for T
+                Tvec = np.linspace(self.T_limits_1phase[0], self.T_limits_1phase[1], self.NT_1phase)
+
+            for T in Tvec:
+
+                try:
+                    # Update the state using PT inputs in order to calculate all the remaining inputs
+                    self.state_PT.update(CP.PT_INPUTS, p, T)
+                except ValueError as VE:
+                    data.append(dict(err=str(VE), cls="EXCEPTION", type="update", in1="P", val1=p, in2="T", val2=T))
+                    myprint(1, 'consistency', VE)
+                    continue
+
+                _exception = False
+                tic2 = timeit.default_timer()
+                try:
+                    val1, val2 = self.state_PT.keyed_output(key1), self.state_PT.keyed_output(key2)
+                    self.state.update(pairkey, val1, val2)
+                    toc2 = timeit.default_timer()
+                except ValueError as VE:
+                    data.append(dict(err=str(VE), cls="EXCEPTION", type="update", in1=param1, val1=val1, in2=param2, val2=val2))
+                    myprint(1, 'update(1p)', self.pair, 'P', p, 'T', T, 'D', self.state_PT.keyed_output(CP.iDmolar), '{0:18.16g}, {1:18.16g}'.format(self.state_PT.keyed_output(key1), self.state_PT.keyed_output(key2)), VE)
+                    _exception = True
+
+                x = self.to_axis_units(xparam, self.state_PT.keyed_output(xkey))
+                y = self.to_axis_units(yparam, self.state_PT.keyed_output(ykey))
+
+                if not _exception:
+                    # Check the error on the density
+                    if abs(self.state_PT.rhomolar() / self.state.rhomolar() - 1) < 1e-3 and abs(self.state_PT.p() / self.state.p() - 1) < 1e-3 and abs(self.state_PT.T() - self.state.T()) < 1e-3:
+                        data.append(dict(cls="GOOD", x=x, y=y, elapsed=toc2 - tic2))
+                        if 'REFPROP' not in self.backend:
+                            if self.state_PT.phase() != self.state.phase():
+                                myprint(1, 'bad phase', self.pair, '{0:18.16g}, {1:18.16g}'.format(self.state_PT.keyed_output(key1), self.state_PT.keyed_output(key2)), self.state.phase(), 'instead of', self.state_PT.phase())
+                    else:
+                        data.append(dict(cls="INCONSISTENT", type="update", in1=param1, val1=val1, in2=param2, val2=val2, x=x, y=y))
+                        myprint(1, 'bad', self.pair, '{0:18.16g}, {1:18.16g}'.format(self.state_PT.keyed_output(key1), self.state_PT.keyed_output(key2)), 'T:', self.state_PT.T(), 'Drho:', abs(self.state_PT.rhomolar() / self.state.rhomolar() - 1), abs(self.state_PT.p() / self.state.p() - 1), 'DT:', abs(self.state_PT.T() - self.state.T()))
+
+        toc = time.time()
+        df = pandas.DataFrame(data)
+        bad = df[df.cls == 'INCONSISTENT']
+        good = df[df.cls == 'GOOD']
+        slowgood = good[good.elapsed > 0.01]
+        excep = df[df.cls == 'EXCEPTION']
+        badphase = df[df.cls == 'BAD_PHASE']
+
+        self.ax.plot(bad.x, bad.y, 'r+', ms=3)
+        self.ax.plot(good.x, good.y, 'k.', ms=1)
+        self.ax.plot(excep.x, excep.y, 'rx', ms=3)
+        self.ax.plot(slowgood.x, slowgood.y, 'b*', ms=6)
+        self.ax.plot(badphase.x, badphase.y, 'o', ms=3, mfc='none')
+
+        print('1-phase took ' + str(toc - tic) + ' s for ' + self.pair)
+
+        if self.pair == 'HmolarSmolar':
+            # plt.plot(good.elapsed)
+            # plt.title(self.pair)
+            # plt.show()
+
+            good.to_excel('times_water.xlsx')
+        return df[df.cls != 'GOOD']
+
+    def consistency_check_twophase(self):
+
+        tic = time.time()
+        state = self.state
+
+        try:
+            if state.fluid_param_string('pure') == 'false':
+                print("Not a pure-fluid, skipping two-phase evaluation")
+                return
+        except:
+            pass
+
+        # Update the state given the desired set of inputs
+        param1, param2 = split_pair(self.pair)
+        key1 = getattr(CP, 'i' + param1)
+        key2 = getattr(CP, 'i' + param2)
+        pairkey = getattr(CP, self.pair + '_INPUTS')
+
+        # Get the keys and indices and values for the inputs needed
+        xparam, yparam = split_pair_xy(self.pair)
+        xkey = getattr(CP, 'i' + xparam)
+        ykey = getattr(CP, 'i' + yparam)
+
+        data = []
+        for q in np.linspace(0, 1, self.NQ_2phase):
+
+            Tmin = state.keyed_output(CP.iT_triple) + 1
+
+            for T in np.linspace(Tmin, state.keyed_output(CP.iT_critical) - 1, self.NT_2phase):
+
+                try:
+                    # Update the state using QT inputs in order to calculate all the remaining inputs
+                    self.state_QT.update(CP.QT_INPUTS, q, T)
+                except ValueError as VE:
+                    data.append(dict(err=str(VE), cls="EXCEPTION", type="update", in1="Q", val1=q, in2="T", val2=T))
+                    myprint(1, 'consistency', VE)
+                    continue
+
+                _exception = False
+                try:
+                    val1, val2 = self.state_QT.keyed_output(key1), self.state_QT.keyed_output(key2)
+                    state.update(pairkey, val1, val2)
+                except ValueError as VE:
+                    data.append(dict(err=str(VE), cls="EXCEPTION", type="update", in1=param1, val1=val1, in2=param2, val2=val2))
+                    myprint(1, 'update_QT', T, q)
+                    myprint(1, 'update', param1, self.state_QT.keyed_output(key1), param2, self.state_QT.keyed_output(key2), VE)
+                    _exception = True
+
+                x = self.to_axis_units(xparam, self.state_QT.keyed_output(xkey))
+                y = self.to_axis_units(yparam, self.state_QT.keyed_output(ykey))
+
+                if not _exception:
+                    # Check the error on the density
+                    if abs(self.state_QT.rhomolar() / self.state.rhomolar() - 1) < 1e-3 and abs(self.state_QT.p() / self.state.p() - 1) < 1e-3 and abs(self.state_QT.T() - self.state.T()) < 1e-3:
+                        data.append(dict(cls="GOOD", x=x, y=y))
+                        if 'REFPROP' not in self.backend:
+                            if self.state_QT.phase() != self.state.phase():
+                                myprint(1, 'bad phase (2phase)', self.pair, '{0:18.16g}, {1:18.16g}'.format(self.state_QT.keyed_output(key1), self.state_QT.keyed_output(key2)), self.state.phase(), 'instead of', self.state_QT.phase())
+
+                    else:
+                        myprint(1, 'Q', q)
+                        myprint(1, 'bad(2phase)', self.pair, '{0:18.16g}, {1:18.16g}'.format(self.state_QT.keyed_output(key1), self.state_QT.keyed_output(key2)), 'pnew:', self.state.p(), 'pold:', self.state_QT.p(), 'Tnew:', self.state.T(), 'T:', self.state_QT.T(), 'Drho:', abs(self.state_QT.rhomolar() / self.state.rhomolar() - 1), 'DP', abs(self.state_QT.p() / self.state.p() - 1), 'DT:', abs(self.state_QT.T() - self.state.T()))
+                        data.append(dict(cls="INCONSISTENT", type="update", in1=param1, val1=val1, in2=param2, val2=val2, x=x, y=y))
+
+        toc = time.time()
+        df = pandas.DataFrame(data)
+        bad = df[df.cls == 'INCONSISTENT']
+        good = df[df.cls == 'GOOD']
+        excep = df[df.cls == 'EXCEPTION']
+        badphase = df[df.cls == 'BAD_PHASE']
+
+        self.ax.plot(bad.x, bad.y, 'r+', ms=3)
+        self.ax.plot(good.x, good.y, 'k.', ms=1)
+        self.ax.plot(excep.x, excep.y, 'rx', ms=3)
+        self.ax.plot(badphase.x, badphase.y, 'o', ms=3, mfc='none')
+        print('2-phase took ' + str(toc - tic) + ' s for ' + self.pair)
+
+    def cross_out_axis(self):
+        xlims = self.ax.get_xlim()
+        ylims = self.ax.get_ylim()
+        self.ax.plot([xlims[0], xlims[1]], [ylims[0], ylims[1]], lw=3, c='r')
+        self.ax.plot([xlims[0], xlims[1]], [ylims[1], ylims[0]], lw=3, c='r')
+
+        xparam, yparam = split_pair_xy(self.pair)
+        x = 0.5 * xlims[0] + 0.5 * xlims[1]
+        y = 0.5 * ylims[0] + 0.5 * ylims[1]
+        if xparam in ['P', 'Dmolar']:
+            x = (xlims[0] * xlims[1])**0.5
+        if yparam in ['P', 'Dmolar']:
+            y = (ylims[0] * ylims[1])**0.5
+
+        self.ax.text(x, y, 'Not\nImplemented', ha='center', va='center', bbox=dict(fc='white'))
+
+
+if __name__ == '__main__':
+    PVT = PdfPages('Consistency.pdf')
+    CP.CoolProp.set_debug_level(0)
+    open('timelog.txt', 'w')
+    with open('timelog.txt', 'a+', buffering=1) as fp:
+        for fluid in ['METHANOL']:  # CP.__fluids__:
+            tic = timeit.default_timer()
+            skips = ['DmolarHmolar', 'DmolarSmolar', 'DmolarUmolar', 'HmolarSmolar']
+            skips = []
+            ff = ConsistencyFigure(fluid, backend='HEOS', additional_skips=skips)  # , NT_1phase = 10, Np_1phase = 10, NT_2phase = 100, NQ_2phase = 0)
+            ff.errors.to_excel('Errors' + fluid + '.xlsx')
+            toc = timeit.default_timer()
+            print('Time to build:', toc - tic, 'seconds')
+            ff.add_to_pdf(PVT)
+            ff.savefig(fluid + '.png')
+            ff.savefig(fluid + '.pdf')
+            plt.close()
+            fp.write('Time to build: {0} seconds for {1}\n'.format(toc - tic, fluid))
+            del ff
+    PVT.close()
```

## CoolProp/Plots/ConsistencyPlots_pcsaft.py

 * *Ordering differences only*

```diff
@@ -1,555 +1,555 @@
-# -*- coding: utf-8 -*-
-from __future__ import print_function, division, absolute_import
-
-
-import matplotlib.pyplot as plt
-import numpy as np
-import time, timeit
-import six
-import pandas
-import CoolProp as CP
-from math import ceil
-
-CP.CoolProp.set_debug_level(00)
-from matplotlib.backends.backend_pdf import PdfPages
-
-# all_solvers = ['PT', 'DmolarT', 'HmolarP', 'PSmolar', 'SmolarT', 'DmolarP', 'DmolarHmolar', 'DmolarSmolar', 'HmolarSmolar', 'HmolarT']
-# not_implemented_solvers = ['HmolarP', 'PSmolar', 'SmolarT', 'DmolarP', 'DmolarHmolar', 'DmolarSmolar', 'HmolarSmolar', 'HmolarT']
-all_solvers = ['PT', 'DmolarT']
-not_implemented_solvers = []
-no_two_phase_solvers = ['PT']
-
-implemented_solvers = [pair for pair in all_solvers if pair not in not_implemented_solvers]
-
-param_labels = dict(Hmolar='Enthalpy [J/mol]/1000',
-                    Smolar='Entropy [J/mol/K]/1000',
-                    Umolar='Int. Ener. [J/mol]/1000',
-                    T='Temperature [K]',
-                    Dmolar='Density [mol/m3]/1000',
-                    P='Pressure [Pa]/1000')
-
-
-def split_pair(pair):
-    for key in ['Dmolar', 'Hmolar', 'Smolar', 'P', 'T', 'Umolar']:
-        if pair.startswith(key):
-            return key, pair.replace(key, '')
-
-
-def split_pair_xy(pair):
-    if pair == 'HmolarP':
-        return 'Hmolar', 'P'
-    elif pair == 'PSmolar':
-        return 'Smolar', 'P'
-    elif pair == 'PUmolar':
-        return 'Umolar', 'P'
-    elif pair == 'PT':
-        return 'T', 'P'
-    elif pair == 'DmolarT':
-        return 'Dmolar', 'T'
-    elif pair == 'SmolarT':
-        return 'Smolar', 'T'
-    elif pair == 'TUmolar':
-        return 'Umolar', 'T'
-    elif pair == 'HmolarT':
-        return 'Hmolar', 'T'
-    elif pair == 'DmolarP':
-        return 'Dmolar', 'P'
-    elif pair == 'DmolarHmolar':
-        return 'Dmolar', 'Hmolar'
-    elif pair == 'DmolarSmolar':
-        return 'Dmolar', 'Smolar'
-    elif pair == 'DmolarUmolar':
-        return 'Dmolar', 'Umolar'
-    elif pair == 'HmolarSmolar':
-        return 'Smolar', 'Hmolar'
-    elif pair == 'SmolarUmolar':
-        return 'Smolar', 'Umolar'
-    elif pair == 'HmolarUmolar':
-        return 'Hmolar', 'Umolar'
-    else:
-        raise ValueError(pair)
-
-
-DEBUG_LEVEL = 1
-
-
-def myprint(level, *args, **kwargs):
-    if level > DEBUG_LEVEL:
-        print(*args, **kwargs)
-
-
-class ConsistencyFigure(object):
-    def __init__(self, fluid, figsize=(15, 23), backend='PCSAFT', additional_skips=[], mole_fractions=None, p_limits_1phase=None, T_limits_1phase=None, NT_1phase=40, Np_1phase=40, NT_2phase=20, NQ_2phase=20):
-
-        self.fluid = fluid
-        self.backend = backend
-        self.additional_backend = 'HEOS' # the PCSAFT backend does not currently have all the constants and functions for calculating the boundaries of the phase diagram
-        print('***********************************************************************************')
-        print('*************** ' + backend + '::' + fluid + ' ************************')
-        print('***********************************************************************************')
-        self.fig, self.axes = plt.subplots(nrows=ceil(len(all_solvers)/2), ncols=2, figsize=figsize)
-        self.pairs = all_solvers
-        pairs_generator = iter(self.pairs)
-
-        states = [CP.AbstractState(self.additional_backend, fluid) for _ in range(3)]
-        states_pcsaft = [CP.AbstractState(backend, fluid) for _ in range(3)]
-        if mole_fractions is not None:
-            for state in states:
-                state.set_mole_fractions(mole_fractions)
-            for state in states_pcsaft:
-                state.set_mole_fractions(mole_fractions)
-        self.axes_list = []
-        if len(self.axes.shape) > 1:
-            for row in self.axes:
-                for ax in row:
-                    pair = six.next(pairs_generator)
-                    kwargs = dict(p_limits_1phase=p_limits_1phase, T_limits_1phase=T_limits_1phase, NT_1phase=NT_1phase, Np_1phase=Np_1phase,
-                                  NT_2phase=NT_2phase, NQ_2phase=NQ_2phase)
-                    self.axes_list.append(ConsistencyAxis(ax, self, pair, self.fluid, self.backend, self.additional_backend, *states, *states_pcsaft, **kwargs))
-                    ax.set_title(pair)
-        else:
-            for ax in self.axes:
-                pair = six.next(pairs_generator)
-                kwargs = dict(p_limits_1phase=p_limits_1phase, T_limits_1phase=T_limits_1phase, NT_1phase=NT_1phase, Np_1phase=Np_1phase,
-                              NT_2phase=NT_2phase, NQ_2phase=NQ_2phase)
-                self.axes_list.append(ConsistencyAxis(ax, self, pair, self.fluid, self.backend, self.additional_backend, *states, *states_pcsaft, **kwargs))
-                ax.set_title(pair)
-
-        self.calc_saturation_curves()
-        self.plot_saturation_curves()
-
-        # self.calc_Tmax_curve()
-        # self.plot_Tmax_curve()
-        #
-        # self.calc_melting_curve()
-        # self.plot_melting_curve()
-
-        self.tight_layout()
-
-        self.fig.subplots_adjust(top=0.95)
-        self.fig.suptitle('Consistency plots for ' + self.fluid, size=14)
-
-        errors = []
-        for i, (ax, pair) in enumerate(zip(self.axes_list, self.pairs)):
-            if pair not in not_implemented_solvers and pair not in additional_skips:
-                errors.append(ax.consistency_check_singlephase())
-                if pair not in no_two_phase_solvers:
-                    ax.consistency_check_twophase()
-            else:
-                ax.cross_out_axis()
-
-        self.errors = pandas.concat(errors, sort=True)
-
-    def calc_saturation_curves(self):
-        """
-        Calculate all the saturation curves in one shot using the state class to save computational time
-        """
-        HEOS = CP.AbstractState(self.additional_backend, self.fluid)
-        PCSAFT = CP.AbstractState(self.backend, self.fluid)
-        self.dictL, self.dictV = {}, {}
-        for Q, dic in zip([0, 1], [self.dictL, self.dictV]):
-            # rhomolar, smolar, hmolar, T, p, umolar = [], [], [], [], [], []
-            rhomolar, T, p = [], [], []
-            for _T in np.logspace(np.log10(HEOS.keyed_output(CP.iT_triple)), np.log10(HEOS.keyed_output(CP.iT_critical)), 500):
-                try:
-                    PCSAFT.update(CP.QT_INPUTS, Q, _T)
-                    # print('T', PCSAFT.T())
-                    # print('p', PCSAFT.p())
-                    # print('rhomolar', PCSAFT.rhomolar())
-                    if (PCSAFT.p() < 0): raise ValueError('P is negative:' + str(PCSAFT.p()))
-                    PCSAFT.T(), PCSAFT.p(), PCSAFT.rhomolar()
-                    # PCSAFT.hmolar(), PCSAFT.smolar(), PCSAFT.umolar()
-
-                    T.append(PCSAFT.T())
-                    p.append(PCSAFT.p())
-                    rhomolar.append(PCSAFT.rhomolar())
-                    # hmolar.append(PCSAFT.hmolar())
-                    # smolar.append(PCSAFT.smolar())
-                    # umolar.append(PCSAFT.umolar())
-                except ValueError as VE:
-                    myprint(1, 'satT error:', VE, '; T:', '{T:0.16g}'.format(T=_T), 'T/Tc:', _T / HEOS.keyed_output(CP.iT_critical))
-
-            dic.update(dict(T=np.array(T),
-                            P=np.array(p),
-                            Dmolar=np.array(rhomolar)))
-                            # Hmolar=np.array(hmolar),
-                            # Smolar=np.array(smolar)))
-                            # Umolar=np.array(umolar)))
-
-    def plot_saturation_curves(self):
-        for ax in self.axes_list:
-            ax.label_axes()
-            ax.plot_saturation_curves()
-
-    def calc_Tmax_curve(self):
-        HEOS = CP.AbstractState(self.additional_backend, self.fluid)
-        PCSAFT = CP.AbstractState(self.backend, self.fluid)
-        # rhomolar, smolar, hmolar, T, p, umolar = [], [], [], [], [], []
-        rhomolar, T, p = [], [], []
-
-        for _p in np.logspace(np.log10(HEOS.keyed_output(CP.iP_min) * 1.01), np.log10(HEOS.keyed_output(CP.iP_max)), 300):
-            try:
-                PCSAFT.update(CP.PT_INPUTS, _p, HEOS.keyed_output(CP.iT_max))
-            except ValueError as VE:
-                print(1, 'Tmax', _p, VE)
-                print('T', PCSAFT.T())
-                print('p', PCSAFT.p())
-                print('rhomolar', PCSAFT.rhomolar())
-                myprint(1, 'Tmax', _p, VE)
-                continue
-
-            try:
-                T.append(PCSAFT.T())
-                p.append(PCSAFT.p())
-                rhomolar.append(PCSAFT.rhomolar())
-                # hmolar.append(PCSAFT.hmolar())
-                # smolar.append(PCSAFT.smolar())
-                # umolar.append(PCSAFT.umolar())
-            except ValueError as VE:
-                myprint(1, 'Tmax access', VE)
-
-        self.Tmax = dict(T=np.array(T),
-                         P=np.array(p),
-                         Dmolar=np.array(rhomolar))
-                         # Hmolar=np.array(hmolar),
-                         # Smolar=np.array(smolar))
-                         # Umolar=np.array(umolar))
-
-    def plot_Tmax_curve(self):
-        for ax in self.axes_list:
-            ax.plot_Tmax_curve()
-
-    def calc_melting_curve(self):
-        state = CP.AbstractState('HEOS', self.fluid)
-        # rhomolar, smolar, hmolar, T, p, umolar = [], [], [], [], [], []
-        rhomolar, T, p = [], [], []
-
-        # Melting line if it has it
-        if state.has_melting_line():
-            pmelt_min = max(state.melting_line(CP.iP_min, -1, -1), state.keyed_output(CP.iP_triple)) * 1.01
-            pmelt_max = min(state.melting_line(CP.iP_max, -1, -1), state.keyed_output(CP.iP_max)) * 0.99
-
-            for _p in np.logspace(np.log10(pmelt_min), np.log10(pmelt_max), 100):
-                try:
-                    Tm = state.melting_line(CP.iT, CP.iP, _p)
-                    state.update(CP.PT_INPUTS, _p, Tm)
-                    T.append(state.T())
-                    p.append(state.p())
-                    rhomolar.append(state.rhomolar())
-                    # hmolar.append(state.hmolar())
-                    # smolar.append(state.smolar())
-                    # umolar.append(state.umolar())
-                except ValueError as VE:
-                    myprint(1, 'melting', VE)
-
-        self.melt = dict(T=np.array(T),
-                         P=np.array(p),
-                         Dmolar=np.array(rhomolar))
-                         # Hmolar=np.array(hmolar),
-                         # Smolar=np.array(smolar))
-                         # Umolar=np.array(umolar))
-
-    def plot_melting_curve(self):
-        for ax in self.axes_list:
-            ax.plot_melting_curve()
-
-    def tight_layout(self):
-        self.fig.tight_layout()
-
-    def add_to_pdf(self, pdf):
-        """ Add this figure to the pdf instance """
-        pdf.savefig(self.fig)
-
-    def savefig(self, fname, **kwargs):
-        self.fig.savefig(fname, **kwargs)
-
-
-class ConsistencyAxis(object):
-    def __init__(self, axis, fig, pair, fluid, backend, additional_backend, state1, state2, state3,
-                 state4, state5, state6, p_limits_1phase=None, T_limits_1phase=None, NT_1phase=40, Np_1phase=40,
-                 NT_2phase=20, NQ_2phase=20
-                 ):
-        self.ax = axis
-        self.fig = fig
-        self.pair = pair
-        self.fluid = fluid
-        self.backend = backend
-        self.additional_backend = additional_backend
-        self.state = state1
-        self.state_PT = state2
-        self.state_QT = state3
-        self.state_pcsaft = state4
-        self.state_pcsaft_PT = state5
-        self.state_pcsaft_QT = state6
-        self.p_limits_1phase = p_limits_1phase
-        self.T_limits_1phase = T_limits_1phase
-        self.NT_1phase = NT_1phase
-        self.Np_1phase = Np_1phase
-        self.NQ_2phase = NQ_2phase
-        self.NT_2phase = NT_2phase
-        # self.saturation_curves()
-
-    def label_axes(self):
-        """ Label the axes for the given pair """
-        xparam, yparam = split_pair_xy(self.pair)
-        self.ax.set_xlabel(param_labels[xparam])
-        self.ax.set_ylabel(param_labels[yparam])
-
-        if xparam in ['P', 'Dmolar']:
-            self.ax.set_xscale('log')
-        if yparam in ['P', 'Dmolar']:
-            self.ax.set_yscale('log')
-
-    def plot_saturation_curves(self):
-        xparam, yparam = split_pair_xy(self.pair)
-        xL = self.to_axis_units(xparam, self.fig.dictL[xparam])
-        yL = self.to_axis_units(yparam, self.fig.dictL[yparam])
-        xV = self.to_axis_units(xparam, self.fig.dictV[xparam])
-        yV = self.to_axis_units(yparam, self.fig.dictV[yparam])
-        self.ax.plot(xL, yL, 'k', lw=1)
-        self.ax.plot(xV, yV, 'k', lw=1)
-
-    def plot_Tmax_curve(self):
-        xparam, yparam = split_pair_xy(self.pair)
-        x = self.to_axis_units(xparam, self.fig.Tmax[xparam])
-        y = self.to_axis_units(yparam, self.fig.Tmax[yparam])
-        self.ax.plot(x, y, 'r', lw=1) # !!! start here: ValueError: x and y must have same first dimension, but have shapes (0,) and (65,)
-
-    def plot_melting_curve(self):
-        xparam, yparam = split_pair_xy(self.pair)
-        x = self.to_axis_units(xparam, self.fig.melt[xparam])
-        y = self.to_axis_units(yparam, self.fig.melt[yparam])
-        self.ax.plot(x, y, 'b', lw=1)
-
-    def to_axis_units(self, label, vals):
-        """ Convert to the units used in the plot """
-        if label in ['Hmolar', 'Smolar', 'Umolar', 'Dmolar', 'P']:
-            return vals / 1000
-        elif label in ['T']:
-            return vals
-        else:
-            raise ValueError(label)
-
-    def consistency_check_singlephase(self):
-
-        tic = time.time()
-
-        # Update the state given the desired set of inputs
-        param1, param2 = split_pair(self.pair)
-        key1 = getattr(CP, 'i' + param1)
-        key2 = getattr(CP, 'i' + param2)
-        pairkey = getattr(CP, self.pair + '_INPUTS')
-
-        # Get the keys and indices and values for the inputs needed
-        xparam, yparam = split_pair_xy(self.pair)
-        xkey = getattr(CP, 'i' + xparam)
-        ykey = getattr(CP, 'i' + yparam)
-
-        data = []
-
-        if self.p_limits_1phase is not None:
-            # User-specified limits were provided, use them
-            p_min, p_max = self.p_limits_1phase
-        else:
-            # No user-specified limits were provided, use the defaults
-            p_min = self.state.keyed_output(CP.iP_min) * 1.01
-            p_max = self.state.keyed_output(CP.iP_max)
-
-        for p in np.logspace(np.log10(p_min), np.log10(p_max), self.Np_1phase):
-            if self.T_limits_1phase is None:
-                # No user-specified limits were provided, using the defaults
-                Tmin = self.state.keyed_output(CP.iT_triple)
-                if self.state.has_melting_line():
-                    try:
-                        pmelt_min = self.state.melting_line(CP.iP_min, -1, -1)
-                        if p < pmelt_min:
-                            T0 = Tmin
-                        else:
-                            T0 = self.state.melting_line(CP.iT, CP.iP, p)
-                    except Exception as E:
-                        T0 = Tmin + 1.1
-                        data.append(dict(err=str(E), type="melting", input=p))
-                        myprint(1, 'MeltingLine:', E)
-                else:
-                    T0 = Tmin + 1.1
-                Tvec = np.linspace(T0, self.state.keyed_output(CP.iT_max), self.NT_1phase)
-            else:
-                # Use the provided limits for T
-                Tvec = np.linspace(self.T_limits_1phase[0], self.T_limits_1phase[1], self.NT_1phase)
-
-            for T in Tvec:
-                try:
-                    # Update the state using PT inputs in order to calculate all the remaining inputs
-                    self.state_pcsaft_PT.update(CP.PT_INPUTS, p, T)
-                except ValueError as VE:
-                    print(self.state_pcsaft_PT.get_mole_fractions())
-                    print(self.state_PT.get_mole_fractions())
-                    data.append(dict(err=str(VE), cls="EXCEPTION", type="update", in1="P", val1=p, in2="T", val2=T))
-                    myprint(1, 'consistency', VE)
-                    continue
-
-                _exception = False
-                tic2 = timeit.default_timer()
-                try:
-                    val1, val2 = self.state_pcsaft_PT.keyed_output(key1), self.state_pcsaft_PT.keyed_output(key2)
-                    self.state_pcsaft.update(pairkey, val1, val2)
-                    toc2 = timeit.default_timer()
-                except ValueError as VE:
-                    data.append(dict(err=str(VE), cls="EXCEPTION", type="update", in1=param1, val1=val1, in2=param2, val2=val2))
-                    myprint(1, 'update(1p)', self.pair, 'P', p, 'T', T, 'D', self.state_pcsaft_PT.keyed_output(CP.iDmolar), '{0:18.16g}, {1:18.16g}'.format(self.state_pcsaft_PT.keyed_output(key1), self.state_pcsaft_PT.keyed_output(key2)), VE)
-                    _exception = True
-
-                x = self.to_axis_units(xparam, self.state_pcsaft_PT.keyed_output(xkey))
-                y = self.to_axis_units(yparam, self.state_pcsaft_PT.keyed_output(ykey))
-
-                if not _exception:
-                    # Check the error on the density
-                    if abs(self.state_pcsaft_PT.rhomolar() / self.state_pcsaft.rhomolar() - 1) < 1e-3 and abs(self.state_pcsaft_PT.p() / self.state_pcsaft.p() - 1) < 1e-3 and abs(self.state_pcsaft_PT.T() - self.state_pcsaft.T()) < 1e-3:
-                        data.append(dict(cls="GOOD", x=x, y=y, elapsed=toc2 - tic2))
-                        if 'REFPROP' not in self.backend:
-                            if self.state_pcsaft_PT.phase() != self.state_pcsaft.phase():
-                                myprint(1, 'bad phase', self.pair, '{0:18.16g}, {1:18.16g}'.format(self.state_pcsaft_PT.keyed_output(key1), self.state_pcsaft_PT.keyed_output(key2)), self.state_pcsaft.phase(), 'instead of', self.state_pcsaft_PT.phase())
-                    else:
-                        data.append(dict(cls="INCONSISTENT", type="update", in1=param1, val1=val1, in2=param2, val2=val2, x=x, y=y))
-                        myprint(1, 'bad', self.pair, '{0:18.16g}, {1:18.16g}'.format(self.state_pcsaft_PT.keyed_output(key1), self.state_pcsaft_PT.keyed_output(key2)), 'T:', self.state_pcsaft_PT.T(), 'Drho:', abs(self.state_pcsaft_PT.rhomolar() / self.state_pcsaft.rhomolar() - 1), abs(self.state_pcsaft_PT.p() / self.state_pcsaft.p() - 1), 'DT:', abs(self.state_pcsaft_PT.T() - self.state_pcsaft.T()))
-
-        toc = time.time()
-        df = pandas.DataFrame(data)
-        bad = df[df.cls == 'INCONSISTENT']
-        good = df[df.cls == 'GOOD']
-        slowgood = good[good.elapsed > 0.01]
-        excep = df[df.cls == 'EXCEPTION']
-        badphase = df[df.cls == 'BAD_PHASE']
-
-        self.ax.plot(bad.x, bad.y, 'r+', ms=3)
-        self.ax.plot(good.x, good.y, 'k.', ms=1)
-        self.ax.plot(excep.x, excep.y, 'rx', ms=3)
-        self.ax.plot(slowgood.x, slowgood.y, 'b*', ms=6)
-        self.ax.plot(badphase.x, badphase.y, 'o', ms=3, mfc='none')
-
-        print('1-phase took ' + str(toc - tic) + ' s for ' + self.pair)
-
-        if self.pair == 'HmolarSmolar':
-            # plt.plot(good.elapsed)
-            # plt.title(self.pair)
-            # plt.show()
-
-            good.to_csv('times_water', sep=';')
-            # good.to_excel('times_water.xlsx') # !!! uncomment
-        return df[df.cls != 'GOOD']
-
-    def consistency_check_twophase(self):
-
-        tic = time.time()
-        state = self.state
-
-        try:
-            if state_pcsaft.fluid_param_string('pure') == 'false':
-                print("Not a pure-fluid, skipping two-phase evaluation")
-                return
-        except:
-            pass
-
-        # Update the state given the desired set of inputs
-        param1, param2 = split_pair(self.pair)
-        key1 = getattr(CP, 'i' + param1)
-        key2 = getattr(CP, 'i' + param2)
-        pairkey = getattr(CP, self.pair + '_INPUTS')
-
-        # Get the keys and indices and values for the inputs needed
-        xparam, yparam = split_pair_xy(self.pair)
-        xkey = getattr(CP, 'i' + xparam)
-        ykey = getattr(CP, 'i' + yparam)
-
-        data = []
-        for q in np.linspace(0, 1, self.NQ_2phase):
-
-            Tmin = state.keyed_output(CP.iT_triple) + 1
-
-            for T in np.linspace(Tmin, state.keyed_output(CP.iT_critical) - 1, self.NT_2phase):
-
-                try:
-                    # Update the state using QT inputs in order to calculate all the remaining inputs
-                    self.state_pcsaft_QT.update(CP.QT_INPUTS, q, T)
-                except ValueError as VE:
-                    data.append(dict(err=str(VE), cls="EXCEPTION", type="update", in1="Q", val1=q, in2="T", val2=T))
-                    myprint(1, 'consistency', VE)
-                    continue
-
-                _exception = False
-                try:
-                    val1, val2 = self.state_pcsaft_QT.keyed_output(key1), self.state_pcsaft_QT.keyed_output(key2)
-                    self.state_pcsaft.update(pairkey, val1, val2)
-                except ValueError as VE:
-                    data.append(dict(err=str(VE), cls="EXCEPTION", type="update", in1=param1, val1=val1, in2=param2, val2=val2))
-                    myprint(1, 'update_QT', T, q)
-                    myprint(1, 'update', param1, self.state_pcsaft_QT.keyed_output(key1), param2, self.state_pcsaft_QT.keyed_output(key2), VE)
-                    _exception = True
-
-                x = self.to_axis_units(xparam, self.state_pcsaft_QT.keyed_output(xkey))
-                y = self.to_axis_units(yparam, self.state_pcsaft_QT.keyed_output(ykey))
-
-                if not _exception:
-                    # Check the error on the density
-                    if abs(self.state_pcsaft_QT.rhomolar() / self.state_pcsaft.rhomolar() - 1) < 1e-3 and abs(self.state_pcsaft_QT.p() / self.state_pcsaft.p() - 1) < 1e-3 and abs(self.state_pcsaft_QT.T() - self.state_pcsaft.T()) < 1e-3:
-                        data.append(dict(cls="GOOD", x=x, y=y))
-                        if 'REFPROP' not in self.backend:
-                            if self.state_pcsaft_QT.phase() != self.state_pcsaft.phase():
-                                myprint(1, 'bad phase (2phase)', self.pair, '{0:18.16g}, {1:18.16g}'.format(self.state_pcsaft_QT.keyed_output(key1), self.state_pcsaft_QT.keyed_output(key2)), self.state_pcsaft.phase(), 'instead of', self.state_pcsaft_QT.phase())
-
-                    else:
-                        myprint(1, 'Q', q)
-                        myprint(1, 'bad(2phase)', self.pair, '{0:18.16g}, {1:18.16g}'.format(self.state_pcsaft_QT.keyed_output(key1), self.state_pcsaft_QT.keyed_output(key2)), 'pnew:', self.state_pcsaft.p(), 'pold:', self.state_pcsaft_QT.p(), 'Tnew:', self.state_pcsaft.T(), 'T:', self.state_pcsaft_QT.T(), 'Drho:', abs(self.state_pcsaft_QT.rhomolar() / self.state_pcsaft.rhomolar() - 1), 'DP', abs(self.state_pcsaft_QT.p() / self.state_pcsaft.p() - 1), 'DT:', abs(self.state_pcsaft_QT.T() - self.state_pcsaft.T()))
-                        data.append(dict(cls="INCONSISTENT", type="update", in1=param1, val1=val1, in2=param2, val2=val2, x=x, y=y))
-
-        toc = time.time()
-        df = pandas.DataFrame(data)
-        bad = df[df.cls == 'INCONSISTENT']
-        good = df[df.cls == 'GOOD']
-        excep = df[df.cls == 'EXCEPTION']
-        badphase = df[df.cls == 'BAD_PHASE']
-
-        self.ax.plot(bad.x, bad.y, 'r+', ms=3)
-        self.ax.plot(good.x, good.y, 'k.', ms=1)
-        self.ax.plot(excep.x, excep.y, 'rx', ms=3)
-        self.ax.plot(badphase.x, badphase.y, 'o', ms=3, mfc='none')
-        print('2-phase took ' + str(toc - tic) + ' s for ' + self.pair)
-
-    def cross_out_axis(self):
-        xlims = self.ax.get_xlim()
-        ylims = self.ax.get_ylim()
-        self.ax.plot([xlims[0], xlims[1]], [ylims[0], ylims[1]], lw=3, c='r')
-        self.ax.plot([xlims[0], xlims[1]], [ylims[1], ylims[0]], lw=3, c='r')
-
-        xparam, yparam = split_pair_xy(self.pair)
-        x = 0.5 * xlims[0] + 0.5 * xlims[1]
-        y = 0.5 * ylims[0] + 0.5 * ylims[1]
-        if xparam in ['P', 'Dmolar']:
-            x = (xlims[0] * xlims[1])**0.5
-        if yparam in ['P', 'Dmolar']:
-            y = (ylims[0] * ylims[1])**0.5
-
-        self.ax.text(x, y, 'Not\nImplemented', ha='center', va='center', bbox=dict(fc='white'))
-
-
-if __name__ == '__main__':
-    PVT = PdfPages('Consistency.pdf')
-    CP.CoolProp.set_debug_level(0)
-    open('timelog.txt', 'w')
-    with open('timelog.txt', 'a+', buffering=1) as fp:
-        for fluid in ['METHANOL']:  # CP.__fluids__:
-            tic = timeit.default_timer()
-            skips = ['DmolarHmolar', 'DmolarSmolar', 'DmolarUmolar', 'HmolarSmolar']
-            skips = []
-            ff = ConsistencyFigure(fluid, backend='PCSAFT', additional_skips=skips)  # , NT_1phase = 10, Np_1phase = 10, NT_2phase = 100, NQ_2phase = 0)
-            ff.to_csv('Errors' + fluid, sep=';')
-            # ff.errors.to_excel('Errors' + fluid + '.xlsx') # !!! uncomment
-            toc = timeit.default_timer()
-            print('Time to build:', toc - tic, 'seconds')
-            ff.add_to_pdf(PVT)
-            ff.savefig(fluid + '.png')
-            ff.savefig(fluid + '.pdf')
-            plt.close()
-            fp.write('Time to build: {0} seconds for {1}\n'.format(toc - tic, fluid))
-            del ff
-    PVT.close()
+# -*- coding: utf-8 -*-
+from __future__ import print_function, division, absolute_import
+
+
+import matplotlib.pyplot as plt
+import numpy as np
+import time, timeit
+import six
+import pandas
+import CoolProp as CP
+from math import ceil
+
+CP.CoolProp.set_debug_level(00)
+from matplotlib.backends.backend_pdf import PdfPages
+
+# all_solvers = ['PT', 'DmolarT', 'HmolarP', 'PSmolar', 'SmolarT', 'DmolarP', 'DmolarHmolar', 'DmolarSmolar', 'HmolarSmolar', 'HmolarT']
+# not_implemented_solvers = ['HmolarP', 'PSmolar', 'SmolarT', 'DmolarP', 'DmolarHmolar', 'DmolarSmolar', 'HmolarSmolar', 'HmolarT']
+all_solvers = ['PT', 'DmolarT']
+not_implemented_solvers = []
+no_two_phase_solvers = ['PT']
+
+implemented_solvers = [pair for pair in all_solvers if pair not in not_implemented_solvers]
+
+param_labels = dict(Hmolar='Enthalpy [J/mol]/1000',
+                    Smolar='Entropy [J/mol/K]/1000',
+                    Umolar='Int. Ener. [J/mol]/1000',
+                    T='Temperature [K]',
+                    Dmolar='Density [mol/m3]/1000',
+                    P='Pressure [Pa]/1000')
+
+
+def split_pair(pair):
+    for key in ['Dmolar', 'Hmolar', 'Smolar', 'P', 'T', 'Umolar']:
+        if pair.startswith(key):
+            return key, pair.replace(key, '')
+
+
+def split_pair_xy(pair):
+    if pair == 'HmolarP':
+        return 'Hmolar', 'P'
+    elif pair == 'PSmolar':
+        return 'Smolar', 'P'
+    elif pair == 'PUmolar':
+        return 'Umolar', 'P'
+    elif pair == 'PT':
+        return 'T', 'P'
+    elif pair == 'DmolarT':
+        return 'Dmolar', 'T'
+    elif pair == 'SmolarT':
+        return 'Smolar', 'T'
+    elif pair == 'TUmolar':
+        return 'Umolar', 'T'
+    elif pair == 'HmolarT':
+        return 'Hmolar', 'T'
+    elif pair == 'DmolarP':
+        return 'Dmolar', 'P'
+    elif pair == 'DmolarHmolar':
+        return 'Dmolar', 'Hmolar'
+    elif pair == 'DmolarSmolar':
+        return 'Dmolar', 'Smolar'
+    elif pair == 'DmolarUmolar':
+        return 'Dmolar', 'Umolar'
+    elif pair == 'HmolarSmolar':
+        return 'Smolar', 'Hmolar'
+    elif pair == 'SmolarUmolar':
+        return 'Smolar', 'Umolar'
+    elif pair == 'HmolarUmolar':
+        return 'Hmolar', 'Umolar'
+    else:
+        raise ValueError(pair)
+
+
+DEBUG_LEVEL = 1
+
+
+def myprint(level, *args, **kwargs):
+    if level > DEBUG_LEVEL:
+        print(*args, **kwargs)
+
+
+class ConsistencyFigure(object):
+    def __init__(self, fluid, figsize=(15, 23), backend='PCSAFT', additional_skips=[], mole_fractions=None, p_limits_1phase=None, T_limits_1phase=None, NT_1phase=40, Np_1phase=40, NT_2phase=20, NQ_2phase=20):
+
+        self.fluid = fluid
+        self.backend = backend
+        self.additional_backend = 'HEOS' # the PCSAFT backend does not currently have all the constants and functions for calculating the boundaries of the phase diagram
+        print('***********************************************************************************')
+        print('*************** ' + backend + '::' + fluid + ' ************************')
+        print('***********************************************************************************')
+        self.fig, self.axes = plt.subplots(nrows=ceil(len(all_solvers)/2), ncols=2, figsize=figsize)
+        self.pairs = all_solvers
+        pairs_generator = iter(self.pairs)
+
+        states = [CP.AbstractState(self.additional_backend, fluid) for _ in range(3)]
+        states_pcsaft = [CP.AbstractState(backend, fluid) for _ in range(3)]
+        if mole_fractions is not None:
+            for state in states:
+                state.set_mole_fractions(mole_fractions)
+            for state in states_pcsaft:
+                state.set_mole_fractions(mole_fractions)
+        self.axes_list = []
+        if len(self.axes.shape) > 1:
+            for row in self.axes:
+                for ax in row:
+                    pair = six.next(pairs_generator)
+                    kwargs = dict(p_limits_1phase=p_limits_1phase, T_limits_1phase=T_limits_1phase, NT_1phase=NT_1phase, Np_1phase=Np_1phase,
+                                  NT_2phase=NT_2phase, NQ_2phase=NQ_2phase)
+                    self.axes_list.append(ConsistencyAxis(ax, self, pair, self.fluid, self.backend, self.additional_backend, *states, *states_pcsaft, **kwargs))
+                    ax.set_title(pair)
+        else:
+            for ax in self.axes:
+                pair = six.next(pairs_generator)
+                kwargs = dict(p_limits_1phase=p_limits_1phase, T_limits_1phase=T_limits_1phase, NT_1phase=NT_1phase, Np_1phase=Np_1phase,
+                              NT_2phase=NT_2phase, NQ_2phase=NQ_2phase)
+                self.axes_list.append(ConsistencyAxis(ax, self, pair, self.fluid, self.backend, self.additional_backend, *states, *states_pcsaft, **kwargs))
+                ax.set_title(pair)
+
+        self.calc_saturation_curves()
+        self.plot_saturation_curves()
+
+        # self.calc_Tmax_curve()
+        # self.plot_Tmax_curve()
+        #
+        # self.calc_melting_curve()
+        # self.plot_melting_curve()
+
+        self.tight_layout()
+
+        self.fig.subplots_adjust(top=0.95)
+        self.fig.suptitle('Consistency plots for ' + self.fluid, size=14)
+
+        errors = []
+        for i, (ax, pair) in enumerate(zip(self.axes_list, self.pairs)):
+            if pair not in not_implemented_solvers and pair not in additional_skips:
+                errors.append(ax.consistency_check_singlephase())
+                if pair not in no_two_phase_solvers:
+                    ax.consistency_check_twophase()
+            else:
+                ax.cross_out_axis()
+
+        self.errors = pandas.concat(errors, sort=True)
+
+    def calc_saturation_curves(self):
+        """
+        Calculate all the saturation curves in one shot using the state class to save computational time
+        """
+        HEOS = CP.AbstractState(self.additional_backend, self.fluid)
+        PCSAFT = CP.AbstractState(self.backend, self.fluid)
+        self.dictL, self.dictV = {}, {}
+        for Q, dic in zip([0, 1], [self.dictL, self.dictV]):
+            # rhomolar, smolar, hmolar, T, p, umolar = [], [], [], [], [], []
+            rhomolar, T, p = [], [], []
+            for _T in np.logspace(np.log10(HEOS.keyed_output(CP.iT_triple)), np.log10(HEOS.keyed_output(CP.iT_critical)), 500):
+                try:
+                    PCSAFT.update(CP.QT_INPUTS, Q, _T)
+                    # print('T', PCSAFT.T())
+                    # print('p', PCSAFT.p())
+                    # print('rhomolar', PCSAFT.rhomolar())
+                    if (PCSAFT.p() < 0): raise ValueError('P is negative:' + str(PCSAFT.p()))
+                    PCSAFT.T(), PCSAFT.p(), PCSAFT.rhomolar()
+                    # PCSAFT.hmolar(), PCSAFT.smolar(), PCSAFT.umolar()
+
+                    T.append(PCSAFT.T())
+                    p.append(PCSAFT.p())
+                    rhomolar.append(PCSAFT.rhomolar())
+                    # hmolar.append(PCSAFT.hmolar())
+                    # smolar.append(PCSAFT.smolar())
+                    # umolar.append(PCSAFT.umolar())
+                except ValueError as VE:
+                    myprint(1, 'satT error:', VE, '; T:', '{T:0.16g}'.format(T=_T), 'T/Tc:', _T / HEOS.keyed_output(CP.iT_critical))
+
+            dic.update(dict(T=np.array(T),
+                            P=np.array(p),
+                            Dmolar=np.array(rhomolar)))
+                            # Hmolar=np.array(hmolar),
+                            # Smolar=np.array(smolar)))
+                            # Umolar=np.array(umolar)))
+
+    def plot_saturation_curves(self):
+        for ax in self.axes_list:
+            ax.label_axes()
+            ax.plot_saturation_curves()
+
+    def calc_Tmax_curve(self):
+        HEOS = CP.AbstractState(self.additional_backend, self.fluid)
+        PCSAFT = CP.AbstractState(self.backend, self.fluid)
+        # rhomolar, smolar, hmolar, T, p, umolar = [], [], [], [], [], []
+        rhomolar, T, p = [], [], []
+
+        for _p in np.logspace(np.log10(HEOS.keyed_output(CP.iP_min) * 1.01), np.log10(HEOS.keyed_output(CP.iP_max)), 300):
+            try:
+                PCSAFT.update(CP.PT_INPUTS, _p, HEOS.keyed_output(CP.iT_max))
+            except ValueError as VE:
+                print(1, 'Tmax', _p, VE)
+                print('T', PCSAFT.T())
+                print('p', PCSAFT.p())
+                print('rhomolar', PCSAFT.rhomolar())
+                myprint(1, 'Tmax', _p, VE)
+                continue
+
+            try:
+                T.append(PCSAFT.T())
+                p.append(PCSAFT.p())
+                rhomolar.append(PCSAFT.rhomolar())
+                # hmolar.append(PCSAFT.hmolar())
+                # smolar.append(PCSAFT.smolar())
+                # umolar.append(PCSAFT.umolar())
+            except ValueError as VE:
+                myprint(1, 'Tmax access', VE)
+
+        self.Tmax = dict(T=np.array(T),
+                         P=np.array(p),
+                         Dmolar=np.array(rhomolar))
+                         # Hmolar=np.array(hmolar),
+                         # Smolar=np.array(smolar))
+                         # Umolar=np.array(umolar))
+
+    def plot_Tmax_curve(self):
+        for ax in self.axes_list:
+            ax.plot_Tmax_curve()
+
+    def calc_melting_curve(self):
+        state = CP.AbstractState('HEOS', self.fluid)
+        # rhomolar, smolar, hmolar, T, p, umolar = [], [], [], [], [], []
+        rhomolar, T, p = [], [], []
+
+        # Melting line if it has it
+        if state.has_melting_line():
+            pmelt_min = max(state.melting_line(CP.iP_min, -1, -1), state.keyed_output(CP.iP_triple)) * 1.01
+            pmelt_max = min(state.melting_line(CP.iP_max, -1, -1), state.keyed_output(CP.iP_max)) * 0.99
+
+            for _p in np.logspace(np.log10(pmelt_min), np.log10(pmelt_max), 100):
+                try:
+                    Tm = state.melting_line(CP.iT, CP.iP, _p)
+                    state.update(CP.PT_INPUTS, _p, Tm)
+                    T.append(state.T())
+                    p.append(state.p())
+                    rhomolar.append(state.rhomolar())
+                    # hmolar.append(state.hmolar())
+                    # smolar.append(state.smolar())
+                    # umolar.append(state.umolar())
+                except ValueError as VE:
+                    myprint(1, 'melting', VE)
+
+        self.melt = dict(T=np.array(T),
+                         P=np.array(p),
+                         Dmolar=np.array(rhomolar))
+                         # Hmolar=np.array(hmolar),
+                         # Smolar=np.array(smolar))
+                         # Umolar=np.array(umolar))
+
+    def plot_melting_curve(self):
+        for ax in self.axes_list:
+            ax.plot_melting_curve()
+
+    def tight_layout(self):
+        self.fig.tight_layout()
+
+    def add_to_pdf(self, pdf):
+        """ Add this figure to the pdf instance """
+        pdf.savefig(self.fig)
+
+    def savefig(self, fname, **kwargs):
+        self.fig.savefig(fname, **kwargs)
+
+
+class ConsistencyAxis(object):
+    def __init__(self, axis, fig, pair, fluid, backend, additional_backend, state1, state2, state3,
+                 state4, state5, state6, p_limits_1phase=None, T_limits_1phase=None, NT_1phase=40, Np_1phase=40,
+                 NT_2phase=20, NQ_2phase=20
+                 ):
+        self.ax = axis
+        self.fig = fig
+        self.pair = pair
+        self.fluid = fluid
+        self.backend = backend
+        self.additional_backend = additional_backend
+        self.state = state1
+        self.state_PT = state2
+        self.state_QT = state3
+        self.state_pcsaft = state4
+        self.state_pcsaft_PT = state5
+        self.state_pcsaft_QT = state6
+        self.p_limits_1phase = p_limits_1phase
+        self.T_limits_1phase = T_limits_1phase
+        self.NT_1phase = NT_1phase
+        self.Np_1phase = Np_1phase
+        self.NQ_2phase = NQ_2phase
+        self.NT_2phase = NT_2phase
+        # self.saturation_curves()
+
+    def label_axes(self):
+        """ Label the axes for the given pair """
+        xparam, yparam = split_pair_xy(self.pair)
+        self.ax.set_xlabel(param_labels[xparam])
+        self.ax.set_ylabel(param_labels[yparam])
+
+        if xparam in ['P', 'Dmolar']:
+            self.ax.set_xscale('log')
+        if yparam in ['P', 'Dmolar']:
+            self.ax.set_yscale('log')
+
+    def plot_saturation_curves(self):
+        xparam, yparam = split_pair_xy(self.pair)
+        xL = self.to_axis_units(xparam, self.fig.dictL[xparam])
+        yL = self.to_axis_units(yparam, self.fig.dictL[yparam])
+        xV = self.to_axis_units(xparam, self.fig.dictV[xparam])
+        yV = self.to_axis_units(yparam, self.fig.dictV[yparam])
+        self.ax.plot(xL, yL, 'k', lw=1)
+        self.ax.plot(xV, yV, 'k', lw=1)
+
+    def plot_Tmax_curve(self):
+        xparam, yparam = split_pair_xy(self.pair)
+        x = self.to_axis_units(xparam, self.fig.Tmax[xparam])
+        y = self.to_axis_units(yparam, self.fig.Tmax[yparam])
+        self.ax.plot(x, y, 'r', lw=1) # !!! start here: ValueError: x and y must have same first dimension, but have shapes (0,) and (65,)
+
+    def plot_melting_curve(self):
+        xparam, yparam = split_pair_xy(self.pair)
+        x = self.to_axis_units(xparam, self.fig.melt[xparam])
+        y = self.to_axis_units(yparam, self.fig.melt[yparam])
+        self.ax.plot(x, y, 'b', lw=1)
+
+    def to_axis_units(self, label, vals):
+        """ Convert to the units used in the plot """
+        if label in ['Hmolar', 'Smolar', 'Umolar', 'Dmolar', 'P']:
+            return vals / 1000
+        elif label in ['T']:
+            return vals
+        else:
+            raise ValueError(label)
+
+    def consistency_check_singlephase(self):
+
+        tic = time.time()
+
+        # Update the state given the desired set of inputs
+        param1, param2 = split_pair(self.pair)
+        key1 = getattr(CP, 'i' + param1)
+        key2 = getattr(CP, 'i' + param2)
+        pairkey = getattr(CP, self.pair + '_INPUTS')
+
+        # Get the keys and indices and values for the inputs needed
+        xparam, yparam = split_pair_xy(self.pair)
+        xkey = getattr(CP, 'i' + xparam)
+        ykey = getattr(CP, 'i' + yparam)
+
+        data = []
+
+        if self.p_limits_1phase is not None:
+            # User-specified limits were provided, use them
+            p_min, p_max = self.p_limits_1phase
+        else:
+            # No user-specified limits were provided, use the defaults
+            p_min = self.state.keyed_output(CP.iP_min) * 1.01
+            p_max = self.state.keyed_output(CP.iP_max)
+
+        for p in np.logspace(np.log10(p_min), np.log10(p_max), self.Np_1phase):
+            if self.T_limits_1phase is None:
+                # No user-specified limits were provided, using the defaults
+                Tmin = self.state.keyed_output(CP.iT_triple)
+                if self.state.has_melting_line():
+                    try:
+                        pmelt_min = self.state.melting_line(CP.iP_min, -1, -1)
+                        if p < pmelt_min:
+                            T0 = Tmin
+                        else:
+                            T0 = self.state.melting_line(CP.iT, CP.iP, p)
+                    except Exception as E:
+                        T0 = Tmin + 1.1
+                        data.append(dict(err=str(E), type="melting", input=p))
+                        myprint(1, 'MeltingLine:', E)
+                else:
+                    T0 = Tmin + 1.1
+                Tvec = np.linspace(T0, self.state.keyed_output(CP.iT_max), self.NT_1phase)
+            else:
+                # Use the provided limits for T
+                Tvec = np.linspace(self.T_limits_1phase[0], self.T_limits_1phase[1], self.NT_1phase)
+
+            for T in Tvec:
+                try:
+                    # Update the state using PT inputs in order to calculate all the remaining inputs
+                    self.state_pcsaft_PT.update(CP.PT_INPUTS, p, T)
+                except ValueError as VE:
+                    print(self.state_pcsaft_PT.get_mole_fractions())
+                    print(self.state_PT.get_mole_fractions())
+                    data.append(dict(err=str(VE), cls="EXCEPTION", type="update", in1="P", val1=p, in2="T", val2=T))
+                    myprint(1, 'consistency', VE)
+                    continue
+
+                _exception = False
+                tic2 = timeit.default_timer()
+                try:
+                    val1, val2 = self.state_pcsaft_PT.keyed_output(key1), self.state_pcsaft_PT.keyed_output(key2)
+                    self.state_pcsaft.update(pairkey, val1, val2)
+                    toc2 = timeit.default_timer()
+                except ValueError as VE:
+                    data.append(dict(err=str(VE), cls="EXCEPTION", type="update", in1=param1, val1=val1, in2=param2, val2=val2))
+                    myprint(1, 'update(1p)', self.pair, 'P', p, 'T', T, 'D', self.state_pcsaft_PT.keyed_output(CP.iDmolar), '{0:18.16g}, {1:18.16g}'.format(self.state_pcsaft_PT.keyed_output(key1), self.state_pcsaft_PT.keyed_output(key2)), VE)
+                    _exception = True
+
+                x = self.to_axis_units(xparam, self.state_pcsaft_PT.keyed_output(xkey))
+                y = self.to_axis_units(yparam, self.state_pcsaft_PT.keyed_output(ykey))
+
+                if not _exception:
+                    # Check the error on the density
+                    if abs(self.state_pcsaft_PT.rhomolar() / self.state_pcsaft.rhomolar() - 1) < 1e-3 and abs(self.state_pcsaft_PT.p() / self.state_pcsaft.p() - 1) < 1e-3 and abs(self.state_pcsaft_PT.T() - self.state_pcsaft.T()) < 1e-3:
+                        data.append(dict(cls="GOOD", x=x, y=y, elapsed=toc2 - tic2))
+                        if 'REFPROP' not in self.backend:
+                            if self.state_pcsaft_PT.phase() != self.state_pcsaft.phase():
+                                myprint(1, 'bad phase', self.pair, '{0:18.16g}, {1:18.16g}'.format(self.state_pcsaft_PT.keyed_output(key1), self.state_pcsaft_PT.keyed_output(key2)), self.state_pcsaft.phase(), 'instead of', self.state_pcsaft_PT.phase())
+                    else:
+                        data.append(dict(cls="INCONSISTENT", type="update", in1=param1, val1=val1, in2=param2, val2=val2, x=x, y=y))
+                        myprint(1, 'bad', self.pair, '{0:18.16g}, {1:18.16g}'.format(self.state_pcsaft_PT.keyed_output(key1), self.state_pcsaft_PT.keyed_output(key2)), 'T:', self.state_pcsaft_PT.T(), 'Drho:', abs(self.state_pcsaft_PT.rhomolar() / self.state_pcsaft.rhomolar() - 1), abs(self.state_pcsaft_PT.p() / self.state_pcsaft.p() - 1), 'DT:', abs(self.state_pcsaft_PT.T() - self.state_pcsaft.T()))
+
+        toc = time.time()
+        df = pandas.DataFrame(data)
+        bad = df[df.cls == 'INCONSISTENT']
+        good = df[df.cls == 'GOOD']
+        slowgood = good[good.elapsed > 0.01]
+        excep = df[df.cls == 'EXCEPTION']
+        badphase = df[df.cls == 'BAD_PHASE']
+
+        self.ax.plot(bad.x, bad.y, 'r+', ms=3)
+        self.ax.plot(good.x, good.y, 'k.', ms=1)
+        self.ax.plot(excep.x, excep.y, 'rx', ms=3)
+        self.ax.plot(slowgood.x, slowgood.y, 'b*', ms=6)
+        self.ax.plot(badphase.x, badphase.y, 'o', ms=3, mfc='none')
+
+        print('1-phase took ' + str(toc - tic) + ' s for ' + self.pair)
+
+        if self.pair == 'HmolarSmolar':
+            # plt.plot(good.elapsed)
+            # plt.title(self.pair)
+            # plt.show()
+
+            good.to_csv('times_water', sep=';')
+            # good.to_excel('times_water.xlsx') # !!! uncomment
+        return df[df.cls != 'GOOD']
+
+    def consistency_check_twophase(self):
+
+        tic = time.time()
+        state = self.state
+
+        try:
+            if state_pcsaft.fluid_param_string('pure') == 'false':
+                print("Not a pure-fluid, skipping two-phase evaluation")
+                return
+        except:
+            pass
+
+        # Update the state given the desired set of inputs
+        param1, param2 = split_pair(self.pair)
+        key1 = getattr(CP, 'i' + param1)
+        key2 = getattr(CP, 'i' + param2)
+        pairkey = getattr(CP, self.pair + '_INPUTS')
+
+        # Get the keys and indices and values for the inputs needed
+        xparam, yparam = split_pair_xy(self.pair)
+        xkey = getattr(CP, 'i' + xparam)
+        ykey = getattr(CP, 'i' + yparam)
+
+        data = []
+        for q in np.linspace(0, 1, self.NQ_2phase):
+
+            Tmin = state.keyed_output(CP.iT_triple) + 1
+
+            for T in np.linspace(Tmin, state.keyed_output(CP.iT_critical) - 1, self.NT_2phase):
+
+                try:
+                    # Update the state using QT inputs in order to calculate all the remaining inputs
+                    self.state_pcsaft_QT.update(CP.QT_INPUTS, q, T)
+                except ValueError as VE:
+                    data.append(dict(err=str(VE), cls="EXCEPTION", type="update", in1="Q", val1=q, in2="T", val2=T))
+                    myprint(1, 'consistency', VE)
+                    continue
+
+                _exception = False
+                try:
+                    val1, val2 = self.state_pcsaft_QT.keyed_output(key1), self.state_pcsaft_QT.keyed_output(key2)
+                    self.state_pcsaft.update(pairkey, val1, val2)
+                except ValueError as VE:
+                    data.append(dict(err=str(VE), cls="EXCEPTION", type="update", in1=param1, val1=val1, in2=param2, val2=val2))
+                    myprint(1, 'update_QT', T, q)
+                    myprint(1, 'update', param1, self.state_pcsaft_QT.keyed_output(key1), param2, self.state_pcsaft_QT.keyed_output(key2), VE)
+                    _exception = True
+
+                x = self.to_axis_units(xparam, self.state_pcsaft_QT.keyed_output(xkey))
+                y = self.to_axis_units(yparam, self.state_pcsaft_QT.keyed_output(ykey))
+
+                if not _exception:
+                    # Check the error on the density
+                    if abs(self.state_pcsaft_QT.rhomolar() / self.state_pcsaft.rhomolar() - 1) < 1e-3 and abs(self.state_pcsaft_QT.p() / self.state_pcsaft.p() - 1) < 1e-3 and abs(self.state_pcsaft_QT.T() - self.state_pcsaft.T()) < 1e-3:
+                        data.append(dict(cls="GOOD", x=x, y=y))
+                        if 'REFPROP' not in self.backend:
+                            if self.state_pcsaft_QT.phase() != self.state_pcsaft.phase():
+                                myprint(1, 'bad phase (2phase)', self.pair, '{0:18.16g}, {1:18.16g}'.format(self.state_pcsaft_QT.keyed_output(key1), self.state_pcsaft_QT.keyed_output(key2)), self.state_pcsaft.phase(), 'instead of', self.state_pcsaft_QT.phase())
+
+                    else:
+                        myprint(1, 'Q', q)
+                        myprint(1, 'bad(2phase)', self.pair, '{0:18.16g}, {1:18.16g}'.format(self.state_pcsaft_QT.keyed_output(key1), self.state_pcsaft_QT.keyed_output(key2)), 'pnew:', self.state_pcsaft.p(), 'pold:', self.state_pcsaft_QT.p(), 'Tnew:', self.state_pcsaft.T(), 'T:', self.state_pcsaft_QT.T(), 'Drho:', abs(self.state_pcsaft_QT.rhomolar() / self.state_pcsaft.rhomolar() - 1), 'DP', abs(self.state_pcsaft_QT.p() / self.state_pcsaft.p() - 1), 'DT:', abs(self.state_pcsaft_QT.T() - self.state_pcsaft.T()))
+                        data.append(dict(cls="INCONSISTENT", type="update", in1=param1, val1=val1, in2=param2, val2=val2, x=x, y=y))
+
+        toc = time.time()
+        df = pandas.DataFrame(data)
+        bad = df[df.cls == 'INCONSISTENT']
+        good = df[df.cls == 'GOOD']
+        excep = df[df.cls == 'EXCEPTION']
+        badphase = df[df.cls == 'BAD_PHASE']
+
+        self.ax.plot(bad.x, bad.y, 'r+', ms=3)
+        self.ax.plot(good.x, good.y, 'k.', ms=1)
+        self.ax.plot(excep.x, excep.y, 'rx', ms=3)
+        self.ax.plot(badphase.x, badphase.y, 'o', ms=3, mfc='none')
+        print('2-phase took ' + str(toc - tic) + ' s for ' + self.pair)
+
+    def cross_out_axis(self):
+        xlims = self.ax.get_xlim()
+        ylims = self.ax.get_ylim()
+        self.ax.plot([xlims[0], xlims[1]], [ylims[0], ylims[1]], lw=3, c='r')
+        self.ax.plot([xlims[0], xlims[1]], [ylims[1], ylims[0]], lw=3, c='r')
+
+        xparam, yparam = split_pair_xy(self.pair)
+        x = 0.5 * xlims[0] + 0.5 * xlims[1]
+        y = 0.5 * ylims[0] + 0.5 * ylims[1]
+        if xparam in ['P', 'Dmolar']:
+            x = (xlims[0] * xlims[1])**0.5
+        if yparam in ['P', 'Dmolar']:
+            y = (ylims[0] * ylims[1])**0.5
+
+        self.ax.text(x, y, 'Not\nImplemented', ha='center', va='center', bbox=dict(fc='white'))
+
+
+if __name__ == '__main__':
+    PVT = PdfPages('Consistency.pdf')
+    CP.CoolProp.set_debug_level(0)
+    open('timelog.txt', 'w')
+    with open('timelog.txt', 'a+', buffering=1) as fp:
+        for fluid in ['METHANOL']:  # CP.__fluids__:
+            tic = timeit.default_timer()
+            skips = ['DmolarHmolar', 'DmolarSmolar', 'DmolarUmolar', 'HmolarSmolar']
+            skips = []
+            ff = ConsistencyFigure(fluid, backend='PCSAFT', additional_skips=skips)  # , NT_1phase = 10, Np_1phase = 10, NT_2phase = 100, NQ_2phase = 0)
+            ff.to_csv('Errors' + fluid, sep=';')
+            # ff.errors.to_excel('Errors' + fluid + '.xlsx') # !!! uncomment
+            toc = timeit.default_timer()
+            print('Time to build:', toc - tic, 'seconds')
+            ff.add_to_pdf(PVT)
+            ff.savefig(fluid + '.png')
+            ff.savefig(fluid + '.pdf')
+            plt.close()
+            fp.write('Time to build: {0} seconds for {1}\n'.format(toc - tic, fluid))
+            del ff
+    PVT.close()
```

## CoolProp/Plots/Plots.py

 * *Ordering differences only*

```diff
@@ -1,361 +1,361 @@
-# -*- coding: utf-8 -*-
-from __future__ import print_function, division, absolute_import
-
-import numpy as np
-import warnings
-
-import CoolProp
-from CoolProp.Plots.Common import IsoLine, BasePlot, interpolate_values_1d
-from CoolProp.Plots.SimpleCycles import StateContainer
-
-
-class PropertyPlot(BasePlot):
-    def __init__(self, fluid_name, graph_type, **kwargs):
-        """
-        Create graph for the specified fluid properties
-
-        Parameters
-        ----------
-        fluid_name : string or AbstractState
-            The name of the fluid to be plotted or a state instance
-        graph_type : string
-            The graph type to be plotted, like \"PH\" or \"TS\"
-        axis : :func:`matplotlib.pyplot.gca()`, Optional
-            The current axis system to be plotted to.
-            Default: create a new axis system
-        fig : :func:`matplotlib.pyplot.figure()`, Optional
-            The current figure to be plotted to.
-            Default: create a new figure
-        unit_system : string, ['EUR','KSI','SI']
-            Select the units used for the plotting.  'EUR' is bar, kJ, C; 'KSI' is kPa, kJ, K; 'SI' is Pa, J, K
-        tp_limits : string, ['NONE','DEF','ACHP','ORC']
-            Select the limits in T and p.
-        reciprocal_density : bool
-            NOT IMPLEMENTED: If True, 1/rho will be plotted instead of rho
-
-        Examples
-        --------
-        >>> from CoolProp.Plots import PropertyPlot
-        >>> plot = PropertyPlot('HEOS::Water', 'TS')
-        >>> plot.calc_isolines()
-        >>> plot.show()
-
-        >>> import CoolProp
-        >>> from CoolProp.Plots import PropertyPlot
-        >>> plot = PropertyPlot('HEOS::R134a', 'PH', unit_system='EUR', tp_limits='ACHP')
-        >>> plot.calc_isolines(CoolProp.iQ, num=11)
-        >>> plot.calc_isolines(CoolProp.iT, num=25)
-        >>> plot.calc_isolines(CoolProp.iSmass, num=15)
-        >>> plot.show()
-
-        >>> import CoolProp
-        >>> from CoolProp.Plots import PropertyPlot
-        >>> plot = PropertyPlot('HEOS::R245fa', 'TS', unit_system='EUR', tp_limits='ORC')
-        >>> plot.calc_isolines(CoolProp.iQ, num=11)
-        >>> plot.calc_isolines(CoolProp.iP, iso_range=[1,50], num=10, rounding=True)
-        >>> plot.draw()
-        >>> plot.isolines.clear()
-        >>> plot.props[CoolProp.iP]['color'] = 'green'
-        >>> plot.props[CoolProp.iP]['lw'] = '0.5'
-        >>> plot.calc_isolines(CoolProp.iP, iso_range=[1,50], num=10, rounding=False)
-        >>> plot.show()
-
-        .. note::
-
-            See the online documentation for a list of the available fluids and
-            graph types
-        """
-        super(PropertyPlot, self).__init__(fluid_name, graph_type, **kwargs)
-        self._isolines = {}
-        #self._plines = {}
-        #self._ppoints = {}
-        self.get_axis_limits()
-        self._plot_default_annotations()
-
-    @property
-    def isolines(self): return self._isolines
-    # @property
-    #def plines(self): return self._plines
-    # @property
-    #def ppoints(self): return self._ppoints
-
-    def show(self):
-        self.draw()
-        super(PropertyPlot, self).show()
-
-    def savefig(self, *args, **kwargs):
-        self.draw()
-        super(PropertyPlot, self).savefig(*args, **kwargs)
-
-    def _plotRound(self, values):
-        """
-        A function round an array-like object while maintaining the
-        amount of entries. This is needed for the isolines since we
-        want the labels to look pretty (=rounding), but we do not
-        know the spacing of the lines. A fixed number of digits after
-        rounding might lead to reduced array size.
-        """
-        inVal = np.unique(np.sort(np.array(values)))
-        output = inVal[1:] * 0.0
-        digits = -1
-        limit = 10
-        lim = inVal * 0.0 + 10
-        # remove less from the numbers until same length,
-        # more than 10 significant digits does not really
-        # make sense, does it?
-        while len(inVal) > len(output) and digits < limit:
-            digits += 1
-            val = (np.around(np.log10(np.abs(inVal))) * -1) + digits + 1
-            val = np.where(val < lim, val, lim)
-            val = np.where(val > -lim, val, -lim)
-            output = np.zeros(inVal.shape)
-            for i in range(len(inVal)):
-                output[i] = np.around(inVal[i], decimals=int(val[i]))
-            output = np.unique(output)
-        return output
-
-    def calc_isolines(self, iso_type=None, iso_range=None, num=15, rounding=False, points=250):
-        """Calculate lines with constant values of type 'iso_type' in terms of x and y as
-        defined by the plot object. 'iso_range' either is a collection of values or
-        simply the minimum and maximum value between which 'num' lines get calculated.
-        The 'rounding' parameter can be used to generate prettier labels if needed.
-        """
-
-        if iso_type is None or iso_type == 'all':
-            for i_type in IsoLine.XY_SWITCH:
-                if IsoLine.XY_SWITCH[i_type].get(self.y_index * 10 + self.x_index, None) is not None:
-                    self.calc_isolines(i_type, None, num, rounding, points)
-            return
-
-        if iso_range is None:
-            if iso_type is CoolProp.iQ:
-                iso_range = [0.0, 1.0]
-            else:
-                limits = self.get_axis_limits(iso_type, CoolProp.iT)
-                iso_range = [limits[0], limits[1]]
-
-        if len(iso_range) <= 1 and num != 1:
-            raise ValueError('You have to provide two values for the iso_range, {0} is not valid.'.format(iso_range))
-
-        if len(iso_range) == 2 and (num is None or num < 2):
-            raise ValueError('Please specify the number of isoline you want e.g. num=10.')
-
-        iso_range = np.sort(np.unique(iso_range))
-        # Generate iso ranges
-        if len(iso_range) == 2:
-            iso_range = self.generate_ranges(iso_type, iso_range[0], iso_range[1], num)
-        if rounding:
-            iso_range = self._plotRound(iso_range)
-
-        # Limits are already in SI units
-        limits = self._get_axis_limits()
-
-        ixrange = self.generate_ranges(self._x_index, limits[0], limits[1], points)
-        iyrange = self.generate_ranges(self._y_index, limits[2], limits[3], points)
-
-        dim = self._system[iso_type]
-
-        lines = self.isolines.get(iso_type, [])
-        for i in range(num):
-            lines.append(IsoLine(iso_type, self._x_index, self._y_index, value=dim.to_SI(iso_range[i]), state=self._state))
-            lines[-1].calc_range(ixrange, iyrange)
-            lines[-1].sanitize_data()
-        self.isolines[iso_type] = lines
-        return
-
-    def draw_isolines(self):
-        dimx = self._system[self._x_index]
-        dimy = self._system[self._y_index]
-
-        sat_props = self.props[CoolProp.iQ].copy()
-        if 'lw' in sat_props: sat_props['lw'] *= 2.0
-        else: sat_props['lw'] = 1.0
-        if 'alpha' in sat_props: min([sat_props['alpha'] * 2.0, 1.0])
-        else: sat_props['alpha'] = 1.0
-
-        for i in self.isolines:
-            props = self.props[i]
-            dew = None; bub = None
-            xcrit = None; ycrit = None
-            if i == CoolProp.iQ:
-                for line in self.isolines[i]:
-                    if line.value == 0.0: bub = line
-                    elif line.value == 1.0: dew = line
-                if dew is not None and bub is not None:
-                    xmin, xmax, ymin, ymax = self.get_axis_limits()
-                    xmin = dimx.to_SI(xmin)
-                    xmax = dimx.to_SI(xmax)
-                    ymin = dimy.to_SI(ymin)
-                    ymax = dimy.to_SI(ymax)
-                    dx = xmax - xmin
-                    dy = ymax - ymin
-                    dew_filter = np.logical_and(np.isfinite(dew.x), np.isfinite(dew.y))
-                    #dew_filter = np.logical_and(dew_filter,dew.x>dew.x[-1])
-                    stp = min([dew_filter.size, 10])
-                    dew_filter[0:-stp] = False
-                    bub_filter = np.logical_and(np.isfinite(bub.x), np.isfinite(bub.y))
-
-                    if self._x_index == CoolProp.iP or self._x_index == CoolProp.iDmass:
-                        filter_x = lambda x: np.log10(x)
-                    else:
-                        filter_x = lambda x: x
-                    if self._y_index == CoolProp.iP or self._y_index == CoolProp.iDmass:
-                        filter_y = lambda y: np.log10(y)
-                    else:
-                        filter_y = lambda y: y
-
-                    if (  # (filter_x(dew.x[dew_filter][-1])-filter_x(bub.x[bub_filter][-1])) > 0.010*filter_x(dx) and
-                        (filter_x(dew.x[dew_filter][-1]) - filter_x(bub.x[bub_filter][-1])) < 0.050 * filter_x(dx) or
-                        (filter_y(dew.y[dew_filter][-1]) - filter_y(bub.y[bub_filter][-1])) < 0.010 * filter_y(dy)):
-                        x = np.linspace(bub.x[bub_filter][-1], dew.x[dew_filter][-1], 11)
-                        y = interpolate_values_1d(
-                          np.append(bub.x[bub_filter], dew.x[dew_filter][::-1]),
-                          np.append(bub.y[bub_filter], dew.y[dew_filter][::-1]),
-                          x_points=x,
-                          kind='cubic')
-                        self.axis.plot(dimx.from_SI(x), dimy.from_SI(y), **sat_props)
-                        warnings.warn("Detected an incomplete phase envelope, fixing it numerically.")
-                        xcrit = x[5]; ycrit = y[5]
-                        #Tcrit = self.state.trivial_keyed_output(CoolProp.iT_critical)
-                        #Dcrit = self.state.trivial_keyed_output(CoolProp.irhomass_critical)
-                        # try:
-                        #    self.state.update(CoolProp.DmassT_INPUTS, Dcrit, Tcrit)
-                        #    xcrit = self.state.keyed_output(self._x_index)
-                        #    ycrit = self.state.keyed_output(self._y_index)
-                        # except:
-                        #    xcrit = x[5]; ycrit = y[5]
-                        #    pass
-                        #self.axis.plot(dimx.from_SI(np.array([bub.x[bub_filter][-1], dew.x[dew_filter][-1]])),dimy.from_SI(np.array([bub.y[bub_filter][-1], dew.y[dew_filter][-1]])),'o')
-            for line in self.isolines[i]:
-                if line.i_index == CoolProp.iQ:
-                    if line.value == 0.0 or line.value == 1.0:
-                        self.axis.plot(dimx.from_SI(line.x), dimy.from_SI(line.y), **sat_props)
-                    else:
-                        if xcrit is not None and ycrit is not None:
-                            self.axis.plot(dimx.from_SI(np.append(line.x, xcrit)), dimy.from_SI(np.append(line.y, ycrit)), **props)
-                            # try:
-                            #    x = np.append(line.x,[xcrit])
-                            #    y = np.append(line.y,[ycrit])
-                            #    fltr = np.logical_and(np.isfinite(x),np.isfinite(y))
-                            #    f = interp1d(x[fltr][-3:],y[fltr][-3:],kind='linear') # could also be quadratic
-                            #    x = np.linspace(x[fltr][-2], x[fltr][-1], 5)
-                            #    y = f(x)
-                            #    #f = interp1d(y[fltr][-5:],x[fltr][-5:],kind='cubic')
-                            #    #y = np.linspace(y[fltr][-2], y[fltr][-1], 5)
-                            #    #x = f(y)
-                            #    self.axis.plot(dimx.from_SI(np.append(line.x,x)),dimy.from_SI(np.append(line.y,y)),**props)
-                            # except:
-                            #    self.axis.plot(dimx.from_SI(np.append(line.x,xcrit)),dimy.from_SI(np.append(line.y,ycrit)),**props)
-                            #    pass
-                else:
-                    self.axis.plot(dimx.from_SI(line.x), dimy.from_SI(line.y), **props)
-
-    def draw(self):
-        self.get_axis_limits()
-        self.draw_isolines()
-
-    # def label_isolines(self, dx=0.075, dy=0.100):
-    #    [xmin, xmax, ymin, ymax] = self.get_axis_limits()
-    #    for i in self.isolines:
-    #         for line in self.isolines[i]:
-    #             if self.get_x_y_dydx(xv, yv, x)
-
-    def draw_process(self, statecontainer, points=None, line_opts=None):
-        """ Draw process or cycle from x and y values in axis units
-
-        Parameters
-        ----------
-        statecontainer : CoolProp.Plots.SimpleCycles.StateContainer()
-            A state container object that contains all the information required to draw the process.
-            Note that points that appear several times get added to a special of highlighted points.
-        line_opts : dict
-            Line options (please see :func:`matplotlib.pyplot.plot`), optional
-            Use this parameter to pass a label for the legend.
-
-        Examples
-        --------
-        >>> import CoolProp
-        >>> from CoolProp.Plots import PropertyPlot
-        >>> pp = PropertyPlot('HEOS::Water', 'TS', unit_system='EUR')
-        >>> pp.calc_isolines(CoolProp.iP        )
-        >>> pp.calc_isolines(CoolProp.iHmass    )
-        >>> pp.calc_isolines(CoolProp.iQ, num=11)
-        >>> cycle = SimpleRankineCycle('HEOS::Water', 'TS', unit_system='EUR')
-        >>> T0 = 300
-        >>> pp.state.update(CoolProp.QT_INPUTS,0.0,T0+15)
-        >>> p0 = pp.state.keyed_output(CoolProp.iP)
-        >>> T2 = 700
-        >>> pp.state.update(CoolProp.QT_INPUTS,1.0,T2-150)
-        >>> p2 = pp.state.keyed_output(CoolProp.iP)
-        >>> cycle.simple_solve(T0, p0, T2, p2, 0.7, 0.8, SI=True)
-        >>> cycle.steps = 50
-        >>> sc = cycle.get_state_changes()
-        >>> pp.draw_process(sc)
-        >>> # The same calculation can be carried out in another unit system:
-        >>> cycle.simple_solve(T0-273.15-10, p0/1e5, T2-273.15+50, p2/1e5-5, 0.7, 0.8, SI=False)
-        >>> sc2 = cycle.get_state_changes()
-        >>> pp.draw_process(sc2, line_opts={'color':'blue', 'lw':1.5})
-        >>> pp.show()
-
-        """
-        warnings.warn("You called the function \"draw_process\", which is not tested.", UserWarning)
-
-        # Default values
-        line_opts = line_opts or {'color': 'r', 'lw': 1.5}
-
-        dimx = self.system[self.x_index]
-        dimy = self.system[self.y_index]
-
-        marker = line_opts.pop('marker', 'o')
-        style = line_opts.pop('linestyle', 'solid')
-        style = line_opts.pop('ls', style)
-
-        if points is None: points = StateContainer()
-
-        xdata = []
-        ydata = []
-        old = statecontainer[len(statecontainer) - 1]
-        for i in statecontainer:
-            point = statecontainer[i]
-            if point == old:
-                points.append(point)
-                old = point
-                continue
-            xdata.append(point[self.x_index])
-            ydata.append(point[self.y_index])
-            old = point
-        xdata = dimx.from_SI(np.asarray(xdata))
-        ydata = dimy.from_SI(np.asarray(ydata))
-        self.axis.plot(xdata, ydata, marker='None', linestyle=style, **line_opts)
-
-        xdata = np.empty(len(points))
-        ydata = np.empty(len(points))
-        for i in points:
-            point = points[i]
-            xdata[i] = point[self.x_index]
-            ydata[i] = point[self.y_index]
-        xdata = dimx.from_SI(np.asarray(xdata))
-        ydata = dimy.from_SI(np.asarray(ydata))
-        line_opts['label'] = ''
-        self.axis.plot(xdata, ydata, marker=marker, linestyle='None', **line_opts)
-
-
-def InlineLabel(xv, yv, x=None, y=None, axis=None, fig=None):
-    warnings.warn("You called the deprecated function \"InlineLabel\", use \"BasePlot.inline_label\".", DeprecationWarning)
-    plot = PropertyPlot("water", "TS", figure=fig, axis=axis)
-    return plot.inline_label(xv, yv, x, y)
-
-
-class PropsPlot(PropertyPlot):
-    def __init__(self, fluid_name, graph_type, units='KSI', reciprocal_density=False, **kwargs):
-        super(PropsPlot, self).__init__(fluid_name, graph_type, unit_system=units, reciprocal_density=reciprocal_density, **kwargs)
-        warnings.warn("You called the deprecated class \"PropsPlot\", use \"PropertyPlot\".", DeprecationWarning)
-
-
-if __name__ == "__main__":
-    plot = PropertyPlot('HEOS::n-Pentane', 'PD', unit_system='EUR')  # , reciprocal_density=True)
-    plot.calc_isolines(CoolProp.iT)
-    plot.calc_isolines(CoolProp.iQ, num=11)
-    # plot.calc_isolines(CoolProp.iSmass)
-    # plot.calc_isolines(CoolProp.iHmass)
-    plot.show()
+# -*- coding: utf-8 -*-
+from __future__ import print_function, division, absolute_import
+
+import numpy as np
+import warnings
+
+import CoolProp
+from CoolProp.Plots.Common import IsoLine, BasePlot, interpolate_values_1d
+from CoolProp.Plots.SimpleCycles import StateContainer
+
+
+class PropertyPlot(BasePlot):
+    def __init__(self, fluid_name, graph_type, **kwargs):
+        """
+        Create graph for the specified fluid properties
+
+        Parameters
+        ----------
+        fluid_name : string or AbstractState
+            The name of the fluid to be plotted or a state instance
+        graph_type : string
+            The graph type to be plotted, like \"PH\" or \"TS\"
+        axis : :func:`matplotlib.pyplot.gca()`, Optional
+            The current axis system to be plotted to.
+            Default: create a new axis system
+        fig : :func:`matplotlib.pyplot.figure()`, Optional
+            The current figure to be plotted to.
+            Default: create a new figure
+        unit_system : string, ['EUR','KSI','SI']
+            Select the units used for the plotting.  'EUR' is bar, kJ, C; 'KSI' is kPa, kJ, K; 'SI' is Pa, J, K
+        tp_limits : string, ['NONE','DEF','ACHP','ORC']
+            Select the limits in T and p.
+        reciprocal_density : bool
+            NOT IMPLEMENTED: If True, 1/rho will be plotted instead of rho
+
+        Examples
+        --------
+        >>> from CoolProp.Plots import PropertyPlot
+        >>> plot = PropertyPlot('HEOS::Water', 'TS')
+        >>> plot.calc_isolines()
+        >>> plot.show()
+
+        >>> import CoolProp
+        >>> from CoolProp.Plots import PropertyPlot
+        >>> plot = PropertyPlot('HEOS::R134a', 'PH', unit_system='EUR', tp_limits='ACHP')
+        >>> plot.calc_isolines(CoolProp.iQ, num=11)
+        >>> plot.calc_isolines(CoolProp.iT, num=25)
+        >>> plot.calc_isolines(CoolProp.iSmass, num=15)
+        >>> plot.show()
+
+        >>> import CoolProp
+        >>> from CoolProp.Plots import PropertyPlot
+        >>> plot = PropertyPlot('HEOS::R245fa', 'TS', unit_system='EUR', tp_limits='ORC')
+        >>> plot.calc_isolines(CoolProp.iQ, num=11)
+        >>> plot.calc_isolines(CoolProp.iP, iso_range=[1,50], num=10, rounding=True)
+        >>> plot.draw()
+        >>> plot.isolines.clear()
+        >>> plot.props[CoolProp.iP]['color'] = 'green'
+        >>> plot.props[CoolProp.iP]['lw'] = '0.5'
+        >>> plot.calc_isolines(CoolProp.iP, iso_range=[1,50], num=10, rounding=False)
+        >>> plot.show()
+
+        .. note::
+
+            See the online documentation for a list of the available fluids and
+            graph types
+        """
+        super(PropertyPlot, self).__init__(fluid_name, graph_type, **kwargs)
+        self._isolines = {}
+        #self._plines = {}
+        #self._ppoints = {}
+        self.get_axis_limits()
+        self._plot_default_annotations()
+
+    @property
+    def isolines(self): return self._isolines
+    # @property
+    #def plines(self): return self._plines
+    # @property
+    #def ppoints(self): return self._ppoints
+
+    def show(self):
+        self.draw()
+        super(PropertyPlot, self).show()
+
+    def savefig(self, *args, **kwargs):
+        self.draw()
+        super(PropertyPlot, self).savefig(*args, **kwargs)
+
+    def _plotRound(self, values):
+        """
+        A function round an array-like object while maintaining the
+        amount of entries. This is needed for the isolines since we
+        want the labels to look pretty (=rounding), but we do not
+        know the spacing of the lines. A fixed number of digits after
+        rounding might lead to reduced array size.
+        """
+        inVal = np.unique(np.sort(np.array(values)))
+        output = inVal[1:] * 0.0
+        digits = -1
+        limit = 10
+        lim = inVal * 0.0 + 10
+        # remove less from the numbers until same length,
+        # more than 10 significant digits does not really
+        # make sense, does it?
+        while len(inVal) > len(output) and digits < limit:
+            digits += 1
+            val = (np.around(np.log10(np.abs(inVal))) * -1) + digits + 1
+            val = np.where(val < lim, val, lim)
+            val = np.where(val > -lim, val, -lim)
+            output = np.zeros(inVal.shape)
+            for i in range(len(inVal)):
+                output[i] = np.around(inVal[i], decimals=int(val[i]))
+            output = np.unique(output)
+        return output
+
+    def calc_isolines(self, iso_type=None, iso_range=None, num=15, rounding=False, points=250):
+        """Calculate lines with constant values of type 'iso_type' in terms of x and y as
+        defined by the plot object. 'iso_range' either is a collection of values or
+        simply the minimum and maximum value between which 'num' lines get calculated.
+        The 'rounding' parameter can be used to generate prettier labels if needed.
+        """
+
+        if iso_type is None or iso_type == 'all':
+            for i_type in IsoLine.XY_SWITCH:
+                if IsoLine.XY_SWITCH[i_type].get(self.y_index * 10 + self.x_index, None) is not None:
+                    self.calc_isolines(i_type, None, num, rounding, points)
+            return
+
+        if iso_range is None:
+            if iso_type is CoolProp.iQ:
+                iso_range = [0.0, 1.0]
+            else:
+                limits = self.get_axis_limits(iso_type, CoolProp.iT)
+                iso_range = [limits[0], limits[1]]
+
+        if len(iso_range) <= 1 and num != 1:
+            raise ValueError('You have to provide two values for the iso_range, {0} is not valid.'.format(iso_range))
+
+        if len(iso_range) == 2 and (num is None or num < 2):
+            raise ValueError('Please specify the number of isoline you want e.g. num=10.')
+
+        iso_range = np.sort(np.unique(iso_range))
+        # Generate iso ranges
+        if len(iso_range) == 2:
+            iso_range = self.generate_ranges(iso_type, iso_range[0], iso_range[1], num)
+        if rounding:
+            iso_range = self._plotRound(iso_range)
+
+        # Limits are already in SI units
+        limits = self._get_axis_limits()
+
+        ixrange = self.generate_ranges(self._x_index, limits[0], limits[1], points)
+        iyrange = self.generate_ranges(self._y_index, limits[2], limits[3], points)
+
+        dim = self._system[iso_type]
+
+        lines = self.isolines.get(iso_type, [])
+        for i in range(num):
+            lines.append(IsoLine(iso_type, self._x_index, self._y_index, value=dim.to_SI(iso_range[i]), state=self._state))
+            lines[-1].calc_range(ixrange, iyrange)
+            lines[-1].sanitize_data()
+        self.isolines[iso_type] = lines
+        return
+
+    def draw_isolines(self):
+        dimx = self._system[self._x_index]
+        dimy = self._system[self._y_index]
+
+        sat_props = self.props[CoolProp.iQ].copy()
+        if 'lw' in sat_props: sat_props['lw'] *= 2.0
+        else: sat_props['lw'] = 1.0
+        if 'alpha' in sat_props: min([sat_props['alpha'] * 2.0, 1.0])
+        else: sat_props['alpha'] = 1.0
+
+        for i in self.isolines:
+            props = self.props[i]
+            dew = None; bub = None
+            xcrit = None; ycrit = None
+            if i == CoolProp.iQ:
+                for line in self.isolines[i]:
+                    if line.value == 0.0: bub = line
+                    elif line.value == 1.0: dew = line
+                if dew is not None and bub is not None:
+                    xmin, xmax, ymin, ymax = self.get_axis_limits()
+                    xmin = dimx.to_SI(xmin)
+                    xmax = dimx.to_SI(xmax)
+                    ymin = dimy.to_SI(ymin)
+                    ymax = dimy.to_SI(ymax)
+                    dx = xmax - xmin
+                    dy = ymax - ymin
+                    dew_filter = np.logical_and(np.isfinite(dew.x), np.isfinite(dew.y))
+                    #dew_filter = np.logical_and(dew_filter,dew.x>dew.x[-1])
+                    stp = min([dew_filter.size, 10])
+                    dew_filter[0:-stp] = False
+                    bub_filter = np.logical_and(np.isfinite(bub.x), np.isfinite(bub.y))
+
+                    if self._x_index == CoolProp.iP or self._x_index == CoolProp.iDmass:
+                        filter_x = lambda x: np.log10(x)
+                    else:
+                        filter_x = lambda x: x
+                    if self._y_index == CoolProp.iP or self._y_index == CoolProp.iDmass:
+                        filter_y = lambda y: np.log10(y)
+                    else:
+                        filter_y = lambda y: y
+
+                    if (  # (filter_x(dew.x[dew_filter][-1])-filter_x(bub.x[bub_filter][-1])) > 0.010*filter_x(dx) and
+                        (filter_x(dew.x[dew_filter][-1]) - filter_x(bub.x[bub_filter][-1])) < 0.050 * filter_x(dx) or
+                        (filter_y(dew.y[dew_filter][-1]) - filter_y(bub.y[bub_filter][-1])) < 0.010 * filter_y(dy)):
+                        x = np.linspace(bub.x[bub_filter][-1], dew.x[dew_filter][-1], 11)
+                        y = interpolate_values_1d(
+                          np.append(bub.x[bub_filter], dew.x[dew_filter][::-1]),
+                          np.append(bub.y[bub_filter], dew.y[dew_filter][::-1]),
+                          x_points=x,
+                          kind='cubic')
+                        self.axis.plot(dimx.from_SI(x), dimy.from_SI(y), **sat_props)
+                        warnings.warn("Detected an incomplete phase envelope, fixing it numerically.")
+                        xcrit = x[5]; ycrit = y[5]
+                        #Tcrit = self.state.trivial_keyed_output(CoolProp.iT_critical)
+                        #Dcrit = self.state.trivial_keyed_output(CoolProp.irhomass_critical)
+                        # try:
+                        #    self.state.update(CoolProp.DmassT_INPUTS, Dcrit, Tcrit)
+                        #    xcrit = self.state.keyed_output(self._x_index)
+                        #    ycrit = self.state.keyed_output(self._y_index)
+                        # except:
+                        #    xcrit = x[5]; ycrit = y[5]
+                        #    pass
+                        #self.axis.plot(dimx.from_SI(np.array([bub.x[bub_filter][-1], dew.x[dew_filter][-1]])),dimy.from_SI(np.array([bub.y[bub_filter][-1], dew.y[dew_filter][-1]])),'o')
+            for line in self.isolines[i]:
+                if line.i_index == CoolProp.iQ:
+                    if line.value == 0.0 or line.value == 1.0:
+                        self.axis.plot(dimx.from_SI(line.x), dimy.from_SI(line.y), **sat_props)
+                    else:
+                        if xcrit is not None and ycrit is not None:
+                            self.axis.plot(dimx.from_SI(np.append(line.x, xcrit)), dimy.from_SI(np.append(line.y, ycrit)), **props)
+                            # try:
+                            #    x = np.append(line.x,[xcrit])
+                            #    y = np.append(line.y,[ycrit])
+                            #    fltr = np.logical_and(np.isfinite(x),np.isfinite(y))
+                            #    f = interp1d(x[fltr][-3:],y[fltr][-3:],kind='linear') # could also be quadratic
+                            #    x = np.linspace(x[fltr][-2], x[fltr][-1], 5)
+                            #    y = f(x)
+                            #    #f = interp1d(y[fltr][-5:],x[fltr][-5:],kind='cubic')
+                            #    #y = np.linspace(y[fltr][-2], y[fltr][-1], 5)
+                            #    #x = f(y)
+                            #    self.axis.plot(dimx.from_SI(np.append(line.x,x)),dimy.from_SI(np.append(line.y,y)),**props)
+                            # except:
+                            #    self.axis.plot(dimx.from_SI(np.append(line.x,xcrit)),dimy.from_SI(np.append(line.y,ycrit)),**props)
+                            #    pass
+                else:
+                    self.axis.plot(dimx.from_SI(line.x), dimy.from_SI(line.y), **props)
+
+    def draw(self):
+        self.get_axis_limits()
+        self.draw_isolines()
+
+    # def label_isolines(self, dx=0.075, dy=0.100):
+    #    [xmin, xmax, ymin, ymax] = self.get_axis_limits()
+    #    for i in self.isolines:
+    #         for line in self.isolines[i]:
+    #             if self.get_x_y_dydx(xv, yv, x)
+
+    def draw_process(self, statecontainer, points=None, line_opts=None):
+        """ Draw process or cycle from x and y values in axis units
+
+        Parameters
+        ----------
+        statecontainer : CoolProp.Plots.SimpleCycles.StateContainer()
+            A state container object that contains all the information required to draw the process.
+            Note that points that appear several times get added to a special of highlighted points.
+        line_opts : dict
+            Line options (please see :func:`matplotlib.pyplot.plot`), optional
+            Use this parameter to pass a label for the legend.
+
+        Examples
+        --------
+        >>> import CoolProp
+        >>> from CoolProp.Plots import PropertyPlot
+        >>> pp = PropertyPlot('HEOS::Water', 'TS', unit_system='EUR')
+        >>> pp.calc_isolines(CoolProp.iP        )
+        >>> pp.calc_isolines(CoolProp.iHmass    )
+        >>> pp.calc_isolines(CoolProp.iQ, num=11)
+        >>> cycle = SimpleRankineCycle('HEOS::Water', 'TS', unit_system='EUR')
+        >>> T0 = 300
+        >>> pp.state.update(CoolProp.QT_INPUTS,0.0,T0+15)
+        >>> p0 = pp.state.keyed_output(CoolProp.iP)
+        >>> T2 = 700
+        >>> pp.state.update(CoolProp.QT_INPUTS,1.0,T2-150)
+        >>> p2 = pp.state.keyed_output(CoolProp.iP)
+        >>> cycle.simple_solve(T0, p0, T2, p2, 0.7, 0.8, SI=True)
+        >>> cycle.steps = 50
+        >>> sc = cycle.get_state_changes()
+        >>> pp.draw_process(sc)
+        >>> # The same calculation can be carried out in another unit system:
+        >>> cycle.simple_solve(T0-273.15-10, p0/1e5, T2-273.15+50, p2/1e5-5, 0.7, 0.8, SI=False)
+        >>> sc2 = cycle.get_state_changes()
+        >>> pp.draw_process(sc2, line_opts={'color':'blue', 'lw':1.5})
+        >>> pp.show()
+
+        """
+        warnings.warn("You called the function \"draw_process\", which is not tested.", UserWarning)
+
+        # Default values
+        line_opts = line_opts or {'color': 'r', 'lw': 1.5}
+
+        dimx = self.system[self.x_index]
+        dimy = self.system[self.y_index]
+
+        marker = line_opts.pop('marker', 'o')
+        style = line_opts.pop('linestyle', 'solid')
+        style = line_opts.pop('ls', style)
+
+        if points is None: points = StateContainer()
+
+        xdata = []
+        ydata = []
+        old = statecontainer[len(statecontainer) - 1]
+        for i in statecontainer:
+            point = statecontainer[i]
+            if point == old:
+                points.append(point)
+                old = point
+                continue
+            xdata.append(point[self.x_index])
+            ydata.append(point[self.y_index])
+            old = point
+        xdata = dimx.from_SI(np.asarray(xdata))
+        ydata = dimy.from_SI(np.asarray(ydata))
+        self.axis.plot(xdata, ydata, marker='None', linestyle=style, **line_opts)
+
+        xdata = np.empty(len(points))
+        ydata = np.empty(len(points))
+        for i in points:
+            point = points[i]
+            xdata[i] = point[self.x_index]
+            ydata[i] = point[self.y_index]
+        xdata = dimx.from_SI(np.asarray(xdata))
+        ydata = dimy.from_SI(np.asarray(ydata))
+        line_opts['label'] = ''
+        self.axis.plot(xdata, ydata, marker=marker, linestyle='None', **line_opts)
+
+
+def InlineLabel(xv, yv, x=None, y=None, axis=None, fig=None):
+    warnings.warn("You called the deprecated function \"InlineLabel\", use \"BasePlot.inline_label\".", DeprecationWarning)
+    plot = PropertyPlot("water", "TS", figure=fig, axis=axis)
+    return plot.inline_label(xv, yv, x, y)
+
+
+class PropsPlot(PropertyPlot):
+    def __init__(self, fluid_name, graph_type, units='KSI', reciprocal_density=False, **kwargs):
+        super(PropsPlot, self).__init__(fluid_name, graph_type, unit_system=units, reciprocal_density=reciprocal_density, **kwargs)
+        warnings.warn("You called the deprecated class \"PropsPlot\", use \"PropertyPlot\".", DeprecationWarning)
+
+
+if __name__ == "__main__":
+    plot = PropertyPlot('HEOS::n-Pentane', 'PD', unit_system='EUR')  # , reciprocal_density=True)
+    plot.calc_isolines(CoolProp.iT)
+    plot.calc_isolines(CoolProp.iQ, num=11)
+    # plot.calc_isolines(CoolProp.iSmass)
+    # plot.calc_isolines(CoolProp.iHmass)
+    plot.show()
```

## CoolProp/Plots/PsychChart.py

 * *Ordering differences only*

```diff
@@ -1,187 +1,187 @@
-# -*- coding: utf-8 -*-
-from __future__ import print_function, division, absolute_import
-
-"""
-This file implements a psychrometric chart for air at 1 atm
-"""
-
-from CoolProp.HumidAirProp import HAPropsSI
-from CoolProp.Plots.Plots import InlineLabel
-import matplotlib, numpy, textwrap
-
-import_template = (
-"""
-# This file was auto-generated by the PsychChart.py script in wrappers/Python/CoolProp/Plots
-
-if __name__=='__main__':
-    import numpy, matplotlib
-    from CoolProp.HumidAirProp import HAPropsSI
-    from CoolProp.Plots.Plots import InlineLabel
-
-    p = 101325
-    Tdb = numpy.linspace(-10,60,100)+273.15
-
-    # Make the figure and the axes
-    fig=matplotlib.pyplot.figure(figsize=(10,8))
-    ax=fig.add_axes((0.1,0.1,0.85,0.85))
-"""
-)
-
-closure_template = (
-"""
-    matplotlib.pyplot.show()
-"""
-)
-
-Tdb = numpy.linspace(-10, 60, 100) + 273.15
-p = 101325
-
-
-def indented_segment(s):
-    return '\n'.join(['    ' + line for line in textwrap.dedent(s).split('\n')])
-
-
-class PlotFormatting(object):
-
-    def plot(self, ax):
-        ax.set_xlim(Tdb[0] - 273.15, Tdb[-1] - 273.15)
-        ax.set_ylim(0, 0.03)
-        ax.set_xlabel(r"$T_{db}$ [$^{\circ}$C]")
-        ax.set_ylabel(r"$W$ ($m_{w}/m_{da}$) [-]")
-
-    def __str__(self):
-        return indented_segment("""
-            ax.set_xlim(Tdb[0]-273.15,Tdb[-1]-273.15)
-            ax.set_ylim(0,0.03)
-            ax.set_xlabel(r"$T_{db}$ [$^{\circ}$C]")
-            ax.set_ylabel(r"$W$ ($m_{w}/m_{da}$) [-]")
-            """)
-
-
-class SaturationLine(object):
-
-    def plot(self, ax):
-        w = [HAPropsSI('W', 'T', T, 'P', p, 'R', 1.0) for T in Tdb]
-        ax.plot(Tdb - 273.15, w, lw=2)
-
-    def __str__(self):
-        return indented_segment("""
-               # Saturation line
-               w = [HAPropsSI('W','T',T,'P',p,'R',1.0) for T in Tdb]
-               ax.plot(Tdb-273.15,w,lw=2)
-               """
-               )
-
-
-class HumidityLabels(object):
-    def __init__(self, RH_values, h):
-        self.RH_values = RH_values
-        self.h = h
-
-    def plot(self, ax):
-        xv = Tdb  # [K]
-        for RH in self.RH_values:
-            yv = [HAPropsSI('W', 'T', T, 'P', p, 'R', RH) for T in Tdb]
-            y = HAPropsSI('W', 'P', p, 'H', self.h, 'R', RH)
-            T_K, w, rot = InlineLabel(xv, yv, y=y, axis=ax)
-            string = r'$\phi$=' + '{s:0.0f}'.format(s=RH * 100) + '%'
-            # Make a temporary label to get its bounding box
-            bbox_opts = dict(boxstyle='square,pad=0.0', fc='white', ec='None', alpha=0.5)
-            ax.text(T_K - 273.15, w, string, rotation=rot, ha='center', va='center', bbox=bbox_opts)
-
-    def __str__(self):
-        return indented_segment("""
-                xv = Tdb #[K]
-                for RH in {RHValues:s}:
-                    yv = [HAPropsSI('W','T',T,'P',p,'R',RH) for T in Tdb]
-                    y = HAPropsSI('W','P',p,'H',{h:f},'R',RH)
-                    T_K,w,rot = InlineLabel(xv, yv, y=y, axis = ax)
-                    string = r'$\phi$='+{s:s}+'%'
-                    bbox_opts = dict(boxstyle='square,pad=0.0',fc='white',ec='None',alpha = 0.5)
-                    ax.text(T_K-273.15,w,string,rotation = rot,ha ='center',va='center',bbox=bbox_opts)
-                """.format(h=self.h, RHValues=str(self.RH_values), s="'{s:0.0f}'.format(s=RH*100)")
-                )
-
-
-class HumidityLines(object):
-
-    def __init__(self, RH_values):
-        self.RH_values = RH_values
-
-    def plot(self, ax):
-        for RH in self.RH_values:
-            w = [HAPropsSI('W', 'T', T, 'P', p, 'R', RH) for T in Tdb]
-            ax.plot(Tdb - 273.15, w, 'r', lw=1)
-
-    def __str__(self):
-        return indented_segment("""
-               # Humidity lines
-               RHValues = {RHValues:s}
-               for RH in RHValues:
-                   w = [HAPropsSI('W','T',T,'P',p,'R',RH) for T in Tdb]
-                   ax.plot(Tdb-273.15,w,'r',lw=1)
-               """.format(RHValues=str(self.RH_values))
-               )
-
-
-class EnthalpyLines(object):
-
-    def __init__(self, H_values):
-        self.H_values = H_values
-
-    def plot(self, ax):
-        for H in self.H_values:
-            # Line goes from saturation to zero humidity ratio for this enthalpy
-            T1 = HAPropsSI('T', 'H', H, 'P', p, 'R', 1.0) - 273.15
-            T0 = HAPropsSI('T', 'H', H, 'P', p, 'R', 0.0) - 273.15
-            w1 = HAPropsSI('W', 'H', H, 'P', p, 'R', 1.0)
-            w0 = HAPropsSI('W', 'H', H, 'P', p, 'R', 0.0)
-            ax.plot(numpy.r_[T1, T0], numpy.r_[w1, w0], 'r', lw=1)
-
-    def __str__(self):
-        return indented_segment("""
-               # Humidity lines
-               for H in {HValues:s}:
-                   #Line goes from saturation to zero humidity ratio for this enthalpy
-                   T1 = HAPropsSI('T','H',H,'P',p,'R',1.0)-273.15
-                   T0 = HAPropsSI('T','H',H,'P',p,'R',0.0)-273.15
-                   w1 = HAPropsSI('W','H',H,'P',p,'R',1.0)
-                   w0 = HAPropsSI('W','H',H,'P',p,'R',0.0)
-                   ax.plot(numpy.r_[T1,T0],numpy.r_[w1,w0],'r',lw=1)
-               """.format(HValues=str(self.H_values))
-               )
-
-
-if __name__ == '__main__':
-
-    and_plot = False
-    if and_plot:
-        fig = matplotlib.pyplot.figure(figsize=(10, 8))
-        ax = fig.add_axes((0.1, 0.1, 0.85, 0.85))
-        ax.set_xlim(Tdb[0] - 273.15, Tdb[-1] - 273.15)
-        ax.set_ylim(0, 0.03)
-        ax.set_xlabel(r"Dry bulb temperature [$^{\circ}$C]")
-        ax.set_ylabel(r"Humidity ratio ($m_{water}/m_{dry\ air}$) [-]")
-
-    SL = SaturationLine()
-    if and_plot: SL.plot(ax)
-
-    RHL = HumidityLines([0.05, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
-    if and_plot: RHL.plot(ax)
-
-    RHLabels = HumidityLabels([0.05, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9], h=65000)
-    if and_plot: RHLabels.plot(ax)
-
-    HL = EnthalpyLines(range(-20000, 100000, 10000))
-    if and_plot: HL.plot(ax)
-
-    PF = PlotFormatting()
-    if and_plot: PF.plot(ax)
-
-    if and_plot: matplotlib.pyplot.show()
-
-    with open('PsychScript.py', 'w') as fp:
-        for chunk in [import_template, SL, RHL, HL, PF, RHLabels, closure_template]:
-            fp.write(str(chunk).encode('ascii'))
-
-    execfile('PsychScript.py')
+# -*- coding: utf-8 -*-
+from __future__ import print_function, division, absolute_import
+
+"""
+This file implements a psychrometric chart for air at 1 atm
+"""
+
+from CoolProp.HumidAirProp import HAPropsSI
+from CoolProp.Plots.Plots import InlineLabel
+import matplotlib, numpy, textwrap
+
+import_template = (
+"""
+# This file was auto-generated by the PsychChart.py script in wrappers/Python/CoolProp/Plots
+
+if __name__=='__main__':
+    import numpy, matplotlib
+    from CoolProp.HumidAirProp import HAPropsSI
+    from CoolProp.Plots.Plots import InlineLabel
+
+    p = 101325
+    Tdb = numpy.linspace(-10,60,100)+273.15
+
+    # Make the figure and the axes
+    fig=matplotlib.pyplot.figure(figsize=(10,8))
+    ax=fig.add_axes((0.1,0.1,0.85,0.85))
+"""
+)
+
+closure_template = (
+"""
+    matplotlib.pyplot.show()
+"""
+)
+
+Tdb = numpy.linspace(-10, 60, 100) + 273.15
+p = 101325
+
+
+def indented_segment(s):
+    return '\n'.join(['    ' + line for line in textwrap.dedent(s).split('\n')])
+
+
+class PlotFormatting(object):
+
+    def plot(self, ax):
+        ax.set_xlim(Tdb[0] - 273.15, Tdb[-1] - 273.15)
+        ax.set_ylim(0, 0.03)
+        ax.set_xlabel(r"$T_{db}$ [$^{\circ}$C]")
+        ax.set_ylabel(r"$W$ ($m_{w}/m_{da}$) [-]")
+
+    def __str__(self):
+        return indented_segment("""
+            ax.set_xlim(Tdb[0]-273.15,Tdb[-1]-273.15)
+            ax.set_ylim(0,0.03)
+            ax.set_xlabel(r"$T_{db}$ [$^{\circ}$C]")
+            ax.set_ylabel(r"$W$ ($m_{w}/m_{da}$) [-]")
+            """)
+
+
+class SaturationLine(object):
+
+    def plot(self, ax):
+        w = [HAPropsSI('W', 'T', T, 'P', p, 'R', 1.0) for T in Tdb]
+        ax.plot(Tdb - 273.15, w, lw=2)
+
+    def __str__(self):
+        return indented_segment("""
+               # Saturation line
+               w = [HAPropsSI('W','T',T,'P',p,'R',1.0) for T in Tdb]
+               ax.plot(Tdb-273.15,w,lw=2)
+               """
+               )
+
+
+class HumidityLabels(object):
+    def __init__(self, RH_values, h):
+        self.RH_values = RH_values
+        self.h = h
+
+    def plot(self, ax):
+        xv = Tdb  # [K]
+        for RH in self.RH_values:
+            yv = [HAPropsSI('W', 'T', T, 'P', p, 'R', RH) for T in Tdb]
+            y = HAPropsSI('W', 'P', p, 'H', self.h, 'R', RH)
+            T_K, w, rot = InlineLabel(xv, yv, y=y, axis=ax)
+            string = r'$\phi$=' + '{s:0.0f}'.format(s=RH * 100) + '%'
+            # Make a temporary label to get its bounding box
+            bbox_opts = dict(boxstyle='square,pad=0.0', fc='white', ec='None', alpha=0.5)
+            ax.text(T_K - 273.15, w, string, rotation=rot, ha='center', va='center', bbox=bbox_opts)
+
+    def __str__(self):
+        return indented_segment("""
+                xv = Tdb #[K]
+                for RH in {RHValues:s}:
+                    yv = [HAPropsSI('W','T',T,'P',p,'R',RH) for T in Tdb]
+                    y = HAPropsSI('W','P',p,'H',{h:f},'R',RH)
+                    T_K,w,rot = InlineLabel(xv, yv, y=y, axis = ax)
+                    string = r'$\phi$='+{s:s}+'%'
+                    bbox_opts = dict(boxstyle='square,pad=0.0',fc='white',ec='None',alpha = 0.5)
+                    ax.text(T_K-273.15,w,string,rotation = rot,ha ='center',va='center',bbox=bbox_opts)
+                """.format(h=self.h, RHValues=str(self.RH_values), s="'{s:0.0f}'.format(s=RH*100)")
+                )
+
+
+class HumidityLines(object):
+
+    def __init__(self, RH_values):
+        self.RH_values = RH_values
+
+    def plot(self, ax):
+        for RH in self.RH_values:
+            w = [HAPropsSI('W', 'T', T, 'P', p, 'R', RH) for T in Tdb]
+            ax.plot(Tdb - 273.15, w, 'r', lw=1)
+
+    def __str__(self):
+        return indented_segment("""
+               # Humidity lines
+               RHValues = {RHValues:s}
+               for RH in RHValues:
+                   w = [HAPropsSI('W','T',T,'P',p,'R',RH) for T in Tdb]
+                   ax.plot(Tdb-273.15,w,'r',lw=1)
+               """.format(RHValues=str(self.RH_values))
+               )
+
+
+class EnthalpyLines(object):
+
+    def __init__(self, H_values):
+        self.H_values = H_values
+
+    def plot(self, ax):
+        for H in self.H_values:
+            # Line goes from saturation to zero humidity ratio for this enthalpy
+            T1 = HAPropsSI('T', 'H', H, 'P', p, 'R', 1.0) - 273.15
+            T0 = HAPropsSI('T', 'H', H, 'P', p, 'R', 0.0) - 273.15
+            w1 = HAPropsSI('W', 'H', H, 'P', p, 'R', 1.0)
+            w0 = HAPropsSI('W', 'H', H, 'P', p, 'R', 0.0)
+            ax.plot(numpy.r_[T1, T0], numpy.r_[w1, w0], 'r', lw=1)
+
+    def __str__(self):
+        return indented_segment("""
+               # Humidity lines
+               for H in {HValues:s}:
+                   #Line goes from saturation to zero humidity ratio for this enthalpy
+                   T1 = HAPropsSI('T','H',H,'P',p,'R',1.0)-273.15
+                   T0 = HAPropsSI('T','H',H,'P',p,'R',0.0)-273.15
+                   w1 = HAPropsSI('W','H',H,'P',p,'R',1.0)
+                   w0 = HAPropsSI('W','H',H,'P',p,'R',0.0)
+                   ax.plot(numpy.r_[T1,T0],numpy.r_[w1,w0],'r',lw=1)
+               """.format(HValues=str(self.H_values))
+               )
+
+
+if __name__ == '__main__':
+
+    and_plot = False
+    if and_plot:
+        fig = matplotlib.pyplot.figure(figsize=(10, 8))
+        ax = fig.add_axes((0.1, 0.1, 0.85, 0.85))
+        ax.set_xlim(Tdb[0] - 273.15, Tdb[-1] - 273.15)
+        ax.set_ylim(0, 0.03)
+        ax.set_xlabel(r"Dry bulb temperature [$^{\circ}$C]")
+        ax.set_ylabel(r"Humidity ratio ($m_{water}/m_{dry\ air}$) [-]")
+
+    SL = SaturationLine()
+    if and_plot: SL.plot(ax)
+
+    RHL = HumidityLines([0.05, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
+    if and_plot: RHL.plot(ax)
+
+    RHLabels = HumidityLabels([0.05, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9], h=65000)
+    if and_plot: RHLabels.plot(ax)
+
+    HL = EnthalpyLines(range(-20000, 100000, 10000))
+    if and_plot: HL.plot(ax)
+
+    PF = PlotFormatting()
+    if and_plot: PF.plot(ax)
+
+    if and_plot: matplotlib.pyplot.show()
+
+    with open('PsychScript.py', 'w') as fp:
+        for chunk in [import_template, SL, RHL, HL, PF, RHLabels, closure_template]:
+            fp.write(str(chunk).encode('ascii'))
+
+    execfile('PsychScript.py')
```

## CoolProp/Plots/PsychScript.py

 * *Ordering differences only*

```diff
@@ -1,49 +1,49 @@
-
-# This file was auto-generated by the PsychChart.py script in wrappers/Python/CoolProp/Plots
-
-if __name__ == '__main__':
-    import numpy, matplotlib
-    from CoolProp.HumidAirProp import HAPropsSI
-    from CoolProp.Plots.Plots import InlineLabel
-
-    p = 101325
-    Tdb = numpy.linspace(-10, 60, 100) + 273.15
-
-    # Make the figure and the axes
-    fig = matplotlib.pyplot.figure(figsize=(10, 8))
-    ax = fig.add_axes((0.1, 0.1, 0.85, 0.85))
-
-    # Saturation line
-    w = [HAPropsSI('W', 'T', T, 'P', p, 'R', 1.0) for T in Tdb]
-    ax.plot(Tdb - 273.15, w, lw=2)
-
-    # Humidity lines
-    RHValues = [0.05, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]
-    for RH in RHValues:
-        w = [HAPropsSI('W', 'T', T, 'P', p, 'R', RH) for T in Tdb]
-        ax.plot(Tdb - 273.15, w, 'r', lw=1)
-
-    # Humidity lines
-    for H in [-20000, -10000, 0, 10000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000]:
-        # Line goes from saturation to zero humidity ratio for this enthalpy
-        T1 = HAPropsSI('T', 'H', H, 'P', p, 'R', 1.0) - 273.15
-        T0 = HAPropsSI('T', 'H', H, 'P', p, 'R', 0.0) - 273.15
-        w1 = HAPropsSI('W', 'H', H, 'P', p, 'R', 1.0)
-        w0 = HAPropsSI('W', 'H', H, 'P', p, 'R', 0.0)
-        ax.plot(numpy.r_[T1, T0], numpy.r_[w1, w0], 'r', lw=1)
-
-    ax.set_xlim(Tdb[0] - 273.15, Tdb[-1] - 273.15)
-    ax.set_ylim(0, 0.03)
-    ax.set_xlabel(r"$T_{db}$ [$^{\circ}$C]")
-    ax.set_ylabel(r"$W$ ($m_{w}/m_{da}$) [-]")
-
-    xv = Tdb  # [K]
-    for RH in [0.05, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]:
-        yv = [HAPropsSI('W', 'T', T, 'P', p, 'R', RH) for T in Tdb]
-        y = HAPropsSI('W', 'P', p, 'H', 65000.000000, 'R', RH)
-        T_K, w, rot = InlineLabel(xv, yv, y=y, axis=ax)
-        string = r'$\phi$=' + '{s:0.0f}'.format(s=RH * 100) + '%'
-        bbox_opts = dict(boxstyle='square,pad=0.0', fc='white', ec='None', alpha=0.5)
-        ax.text(T_K - 273.15, w, string, rotation=rot, ha='center', va='center', bbox=bbox_opts)
-
-    matplotlib.pyplot.show()
+
+# This file was auto-generated by the PsychChart.py script in wrappers/Python/CoolProp/Plots
+
+if __name__ == '__main__':
+    import numpy, matplotlib
+    from CoolProp.HumidAirProp import HAPropsSI
+    from CoolProp.Plots.Plots import InlineLabel
+
+    p = 101325
+    Tdb = numpy.linspace(-10, 60, 100) + 273.15
+
+    # Make the figure and the axes
+    fig = matplotlib.pyplot.figure(figsize=(10, 8))
+    ax = fig.add_axes((0.1, 0.1, 0.85, 0.85))
+
+    # Saturation line
+    w = [HAPropsSI('W', 'T', T, 'P', p, 'R', 1.0) for T in Tdb]
+    ax.plot(Tdb - 273.15, w, lw=2)
+
+    # Humidity lines
+    RHValues = [0.05, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]
+    for RH in RHValues:
+        w = [HAPropsSI('W', 'T', T, 'P', p, 'R', RH) for T in Tdb]
+        ax.plot(Tdb - 273.15, w, 'r', lw=1)
+
+    # Humidity lines
+    for H in [-20000, -10000, 0, 10000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000]:
+        # Line goes from saturation to zero humidity ratio for this enthalpy
+        T1 = HAPropsSI('T', 'H', H, 'P', p, 'R', 1.0) - 273.15
+        T0 = HAPropsSI('T', 'H', H, 'P', p, 'R', 0.0) - 273.15
+        w1 = HAPropsSI('W', 'H', H, 'P', p, 'R', 1.0)
+        w0 = HAPropsSI('W', 'H', H, 'P', p, 'R', 0.0)
+        ax.plot(numpy.r_[T1, T0], numpy.r_[w1, w0], 'r', lw=1)
+
+    ax.set_xlim(Tdb[0] - 273.15, Tdb[-1] - 273.15)
+    ax.set_ylim(0, 0.03)
+    ax.set_xlabel(r"$T_{db}$ [$^{\circ}$C]")
+    ax.set_ylabel(r"$W$ ($m_{w}/m_{da}$) [-]")
+
+    xv = Tdb  # [K]
+    for RH in [0.05, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]:
+        yv = [HAPropsSI('W', 'T', T, 'P', p, 'R', RH) for T in Tdb]
+        y = HAPropsSI('W', 'P', p, 'H', 65000.000000, 'R', RH)
+        T_K, w, rot = InlineLabel(xv, yv, y=y, axis=ax)
+        string = r'$\phi$=' + '{s:0.0f}'.format(s=RH * 100) + '%'
+        bbox_opts = dict(boxstyle='square,pad=0.0', fc='white', ec='None', alpha=0.5)
+        ax.text(T_K - 273.15, w, string, rotation=rot, ha='center', va='center', bbox=bbox_opts)
+
+    matplotlib.pyplot.show()
```

## CoolProp/Plots/SimpleCycles.py

 * *Ordering differences only*

```diff
@@ -1,767 +1,767 @@
-# -*- coding: utf-8 -*-
-from __future__ import print_function, division, absolute_import
-
-
-import matplotlib, warnings
-import numpy as np
-
-
-import CoolProp
-from CoolProp.CoolProp import PropsSI
-from CoolProp.Plots.Common import BasePlot, PropertyDict, SIunits
-
-
-def SimpleCycle(Ref, Te, Tc, DTsh, DTsc, eta_a, Ts_Ph='Ph', **kwargs):
-    """
-    This function plots a simple four-component cycle, on the current axis, or that given by the optional parameter *axis*
-
-    Required parameters:
-
-    * Ref : A string for the refrigerant
-    * Te : Evap Temperature in K
-    * Tc : Condensing Temperature in K
-    * DTsh : Evaporator outlet superheat in K
-    * DTsc : Condenser outlet subcooling in K
-    * eta_a : Adiabatic efficiency of compressor (no units) in range [0,1]
-
-    Optional parameters:
-
-    * Ts_Ph : 'Ts' for a Temperature-Entropy plot, 'Ph' for a Pressure-Enthalpy
-    * axis : An axis to use instead of the active axis
-    * skipPlot : If True, won't actually plot anything, just print COP
-
-    """
-    warnings.warn("This function has been deprecated. Please consider converting it to an object inheriting from \"BaseCycle\".", DeprecationWarning)
-
-    for i in kwargs:
-        warnings.warn("This function has been deprecated, your input \"{0}: {1}\" will be ignored".format(i, kwargs[i]), DeprecationWarning)
-
-    from CoolProp.Plots import SimpleCompressionCycle
-    cycle = SimpleCompressionCycle(fluid_ref=Ref, graph_type=Ts_Ph)
-    cycle.simple_solve_dt(Te, Tc, DTsh, DTsc, eta_a, SI=True)
-    print(cycle.COP_cooling(), cycle.COP_heating())
-
-
-def TwoStage(Ref, Q, Te, Tc, DTsh, DTsc, eta_oi, f_p, Tsat_ic, DTsh_ic, Ts_Ph='Ph', prints=False, skipPlot=False, axis=None, **kwargs):
-    """
-    This function plots a two-stage cycle, on the current axis, or that given by the optional parameter *axis*
-
-    Required parameters:
-
-    * Ref : Refrigerant [string]
-    * Q : Cooling capacity [W]
-    * Te : Evap Temperature [K]
-    * Tc : Condensing Temperature [K]
-    * DTsh : Evaporator outlet superheat [K]
-    * DTsc : Condenser outlet subcooling [K]
-    * eta_oi : Adiabatic efficiency of compressor (no units) in range [0,1]
-    * f_p : fraction of compressor power lost as ambient heat transfer in range [0,1]
-    * Tsat_ic : Saturation temperature corresponding to intermediate pressure [K]
-    * DTsh_ic : Superheating at outlet of intermediate stage [K]
-
-    Optional parameters:
-
-    * Ts_Ph : 'Ts' for a Temperature-Entropy plot, 'Ph' for a Pressure-Enthalpy
-    * prints : True to print out some values
-    * axis : An axis to use instead of the active axis
-    * skipPlot : If True, won't actually plot anything, just print COP
-
-    """
-
-    warnings.warn("This function has been deprecated. PLease consider converting it to an object inheriting from \"BaseCycle\".", DeprecationWarning)
-
-    T = np.zeros((8))
-    h = np.zeros_like(T)
-    p = np.zeros_like(T)
-    s = np.zeros_like(T)
-    rho = np.zeros_like(T)
-    T[0] = np.NAN
-    s[0] = np.NAN
-    T[1] = Te + DTsh
-    pe = PropsSI('P', 'T', Te, 'Q', 1.0, Ref)
-    pc = PropsSI('P', 'T', Tc, 'Q', 1.0, Ref)
-    pic = PropsSI('P', 'T', Tsat_ic, 'Q', 1.0, Ref)
-    Tbubble_c = PropsSI('T', 'P', pc, 'Q', 0, Ref)
-    Tbubble_e = PropsSI('T', 'P', pe, 'Q', 0, Ref)
-
-    h[1] = PropsSI('H', 'T', T[1], 'P', pe, Ref)
-    s[1] = PropsSI('S', 'T', T[1], 'P', pe, Ref)
-    rho[1] = PropsSI('D', 'T', T[1], 'P', pe, Ref)
-    T[5] = Tbubble_c - DTsc
-    h[5] = PropsSI('H', 'T', T[5], 'P', pc, Ref)
-    s[5] = PropsSI('S', 'T', T[5], 'P', pc, Ref)
-    rho[5] = PropsSI('D', 'T', T[5], 'P', pc, Ref)
-    mdot = Q / (h[1] - h[5])
-
-    rho1 = PropsSI('D', 'T', T[1], 'P', pe, Ref)
-    h2s = PropsSI('H', 'S', s[1], 'P', pic, Ref)
-    Wdot1 = mdot * (h2s - h[1]) / eta_oi
-    h[2] = h[1] + (1 - f_p) * Wdot1 / mdot
-    T[2] = PropsSI('T', 'H', h[2], 'P', pic, Ref)
-    s[2] = PropsSI('S', 'T', T[2], 'P', pic, Ref)
-    rho[2] = PropsSI('D', 'T', T[2], 'P', pic, Ref)
-    T[3] = 288
-    p[3] = pic
-    h[3] = PropsSI('H', 'T', T[3], 'P', pic, Ref)
-    s[3] = PropsSI('S', 'T', T[3], 'P', pic, Ref)
-    rho[3] = PropsSI('D', 'T', T[3], 'P', pic, Ref)
-    rho3 = PropsSI('D', 'T', T[3], 'P', pic, Ref)
-    h4s = PropsSI('H', 'T', s[3], 'P', pc, Ref)
-    Wdot2 = mdot * (h4s - h[3]) / eta_oi
-    h[4] = h[3] + (1 - f_p) * Wdot2 / mdot
-    T[4] = PropsSI('T', 'H', h[4], 'P', pc, Ref)
-    s[4] = PropsSI('S', 'T', T[4], 'P', pc, Ref)
-    rho[4] = PropsSI('D', 'T', T[4], 'P', pc, Ref)
-
-    sbubble_e = PropsSI('S', 'T', Tbubble_e, 'Q', 0, Ref)
-    sbubble_c = PropsSI('S', 'T', Tbubble_c, 'Q', 0, Ref)
-    sdew_e = PropsSI('S', 'T', Te, 'Q', 1, Ref)
-    sdew_c = PropsSI('S', 'T', Tc, 'Q', 1, Ref)
-
-    hsatL = PropsSI('H', 'T', Tbubble_e, 'Q', 0, Ref)
-    hsatV = PropsSI('H', 'T', Te, 'Q', 1, Ref)
-    ssatL = PropsSI('S', 'T', Tbubble_e, 'Q', 0, Ref)
-    ssatV = PropsSI('S', 'T', Te, 'Q', 1, Ref)
-    vsatL = 1 / PropsSI('D', 'T', Tbubble_e, 'Q', 0, Ref)
-    vsatV = 1 / PropsSI('D', 'T', Te, 'Q', 1, Ref)
-    x = (h[5] - hsatL) / (hsatV - hsatL)
-    s[6] = x * ssatV + (1 - x) * ssatL
-    T[6] = x * Te + (1 - x) * Tbubble_e
-    rho[6] = 1.0 / (x * vsatV + (1 - x) * vsatL)
-
-    h[6] = h[5]
-    h[7] = h[1]
-    s[7] = s[1]
-    T[7] = T[1]
-    p = [np.nan, pe, pic, pic, pc, pc, pe, pe]
-    COP = Q / (Wdot1 + Wdot2)
-    RE = h[1] - h[6]
-
-    if prints == True:
-        print('x5:', x)
-        print('COP:', COP)
-        print('COPH', (Q + Wdot1 + Wdot2) / (Wdot1 + Wdot2))
-        print(T[2] - 273.15, T[4] - 273.15, p[2] / p[1], p[4] / p[3])
-        print(mdot, mdot * (h[4] - h[5]), pic)
-        print('Vdot1', mdot / rho1, 'Vdisp', mdot / rho1 / (3500 / 60.) * 1e6 / 0.7)
-        print('Vdot2', mdot / rho3, 'Vdisp', mdot / rho3 / (3500 / 60.) * 1e6 / 0.7)
-        print(mdot * (h[4] - h[5]), Tc - 273.15)
-        for i in range(1, len(T) - 1):
-            print('%d & %g & %g & %g & %g & %g \\\\' % (i, T[i] - 273.15, p[i], h[i], s[i], rho[i]))
-    else:
-        print(Tsat_ic, COP)
-
-    if skipPlot == False:
-        if axis == None:
-            ax = matplotlib.pyplot.gca()
-        else:
-            ax = axis
-        if Ts_Ph in ['ph', 'Ph']:
-            ax.plot(h, p)
-        elif Ts_Ph in ['Ts', 'ts']:
-            s_copy = s.copy()
-            T_copy = T.copy()
-            for i in range(1, len(s) - 1):
-                ax.plot(s[i], T[i], 'bo', mfc='b', mec='b')
-                dT = [0, -5, 5, -20, 5, 5, 5]
-                ds = [0, 0.05, 0, 0, 0, 0, 0]
-                ax.text(s[i] + ds[i], T[i] + dT[i], str(i))
-
-            s = list(s)
-            T = list(T)
-            s.insert(7, sdew_e)
-            T.insert(7, Te)
-            s.insert(5, sbubble_c)
-            T.insert(5, Tbubble_c)
-            s.insert(5, sdew_c)
-            T.insert(5, Tc)
-
-            ax.plot(s, T)
-            s = s_copy
-            T = T_copy
-        else:
-            raise TypeError('Type of Ts_Ph invalid')
-    return COP
-
-
-def EconomizedCycle(Ref, Qin, Te, Tc, DTsh, DTsc, eta_oi, f_p, Ti, Ts_Ph='Ts', skipPlot=False, axis=None, **kwargs):
-    """
-    This function plots an economized cycle, on the current axis, or that given by the optional parameter *axis*
-
-    Required parameters:
-
-    * Ref : Refrigerant [string]
-    * Qin : Cooling capacity [W]
-    * Te : Evap Temperature [K]
-    * Tc : Condensing Temperature [K]
-    * DTsh : Evaporator outlet superheat [K]
-    * DTsc : Condenser outlet subcooling [K]
-    * eta_oi : Adiabatic efficiency of compressor (no units) in range [0,1]
-    * f_p : fraction of compressor power lost as ambient heat transfer in range [0,1]
-    * Ti : Saturation temperature corresponding to intermediate pressure [K]
-
-    Optional parameters:
-
-    * Ts_Ph : 'Ts' for a Temperature-Entropy plot, 'Ph' for a Pressure-Enthalpy
-    * axis : An axis to use instead of the active axis
-    * skipPlot : If True, won't actually plot anything, just print COP
-
-    """
-
-    warnings.warn("This function has been deprecated. Please consider converting it to an object inheriting from \"BaseCycle\".", DeprecationWarning)
-    from scipy.optimize import newton
-
-    m = 1
-
-    T = np.zeros((11))
-    h = np.zeros_like(T)
-    p = np.zeros_like(T)
-    s = np.zeros_like(T)
-    rho = np.zeros_like(T)
-
-    T[0] = np.NAN
-    s[0] = np.NAN
-    T[1] = Te + DTsh
-    pe = PropsSI('P', 'T', Te, 'Q', 1.0, Ref)
-    pc = PropsSI('P', 'T', Tc, 'Q', 1.0, Ref)
-    pi = PropsSI('P', 'T', Ti, 'Q', 1.0, Ref)
-    p[1] = pe
-    h[1] = PropsSI('H', 'T', T[1], 'P', pe, Ref)
-    s[1] = PropsSI('S', 'T', T[1], 'P', pe, Ref)
-    rho[1] = PropsSI('D', 'T', T[1], 'P', pe, Ref)
-    h2s = PropsSI('H', 'S', s[1], 'P', pi, Ref)
-    wdot1 = (h2s - h[1]) / eta_oi
-    h[2] = h[1] + (1 - f_p[0]) * wdot1
-    p[2] = pi
-    # T[2]=T_hp(Ref,h[2],pi,T2s)
-    T[2] = PropsSI('T', 'H', h[2], 'P', pi, Ref)
-
-    s[2] = PropsSI('S', 'T', T[2], 'P', pi, Ref)
-    rho[2] = PropsSI('D', 'T', T[2], 'P', pi, Ref)
-
-    T[5] = Tc - DTsc
-    h[5] = PropsSI('H', 'T', T[5], 'P', pc, Ref)
-    s[5] = PropsSI('S', 'T', T[5], 'P', pc, Ref)
-    rho[5] = PropsSI('D', 'T', T[5], 'P', pc, Ref)
-
-    p[5] = pc
-    p[6] = pi
-    h[6] = h[5]
-
-    p[7] = pi
-    p[8] = pi
-    p[6] = pi
-    T[7] = Ti
-    h[7] = PropsSI('H', 'T', Ti, 'Q', 1, Ref)
-    s[7] = PropsSI('S', 'T', Ti, 'Q', 1, Ref)
-    rho[7] = PropsSI('D', 'T', Ti, 'Q', 1, Ref)
-    T[8] = Ti
-    h[8] = PropsSI('H', 'T', Ti, 'Q', 0, Ref)
-    s[8] = PropsSI('S', 'T', Ti, 'Q', 0, Ref)
-    rho[8] = PropsSI('D', 'T', Ti, 'Q', 0, Ref)
-    x6 = (h[6] - h[8]) / (h[7] - h[8])  # Vapor Quality
-    s[6] = s[7] * x6 + s[8] * (1 - x6)
-    rho[6] = 1.0 / (x6 / rho[7] + (1 - x6) / rho[8])
-    T[6] = Ti
-
-    # Injection mass flow rate
-    x = m * (h[6] - h[8]) / (h[7] - h[6])
-
-    p[3] = pi
-    h[3] = (m * h[2] + x * h[7]) / (m + x)
-    # T[3]=T_hp(Ref,h[3],pi,T[2])
-    T[3] = PropsSI('T', 'H', h[3], 'P', pi, Ref)
-    s[3] = PropsSI('S', 'T', T[3], 'P', pi, Ref)
-    rho[3] = PropsSI('D', 'T', T[3], 'P', pi, Ref)
-    T4s = newton(lambda T: PropsSI('S', 'T', T, 'P', pc, Ref) - s[3], T[2] + 30)
-    h4s = PropsSI('H', 'T', T4s, 'P', pc, Ref)
-    p[4] = pc
-    wdot2 = (h4s - h[3]) / eta_oi
-    h[4] = h[3] + (1 - f_p[1]) * wdot2
-    # T[4]=T_hp(Ref,h[4],pc,T4s)
-    T[4] = PropsSI('T', 'H', h[4], 'P', pc, Ref)
-    s[4] = PropsSI('S', 'T', T[4], 'P', pc, Ref)
-    rho[4] = PropsSI('D', 'T', T[4], 'P', pc, Ref)
-
-    p[9] = pe
-    h[9] = h[8]
-    T[9] = Te
-    hsatL_e = PropsSI('H', 'T', Te, 'Q', 0, Ref)
-    hsatV_e = PropsSI('H', 'T', Te, 'Q', 1, Ref)
-    ssatL_e = PropsSI('S', 'T', Te, 'Q', 0, Ref)
-    ssatV_e = PropsSI('S', 'T', Te, 'Q', 1, Ref)
-    vsatL_e = 1 / PropsSI('D', 'T', Te, 'Q', 0, Ref)
-    vsatV_e = 1 / PropsSI('D', 'T', Te, 'Q', 1, Ref)
-    x9 = (h[9] - hsatL_e) / (hsatV_e - hsatL_e)  # Vapor Quality
-    s[9] = ssatV_e * x9 + ssatL_e * (1 - x9)
-    rho[9] = 1.0 / (x9 * vsatV_e + (1 - x9) * vsatL_e)
-
-    s[10] = s[1]
-    T[10] = T[1]
-    h[10] = h[1]
-    p[10] = p[1]
-
-    Tbubble_e = Te
-    Tbubble_c = Tc
-    sbubble_e = PropsSI('S', 'T', Tbubble_e, 'Q', 0, Ref)
-    sbubble_c = PropsSI('S', 'T', Tbubble_c, 'Q', 0, Ref)
-    sdew_e = PropsSI('S', 'T', Te, 'Q', 1, Ref)
-    sdew_c = PropsSI('S', 'T', Tc, 'Q', 1, Ref)
-
-    Wdot1 = m * wdot1
-    Wdot2 = (m + x) * wdot2
-    if skipPlot == False:
-        if axis == None:
-            ax = matplotlib.pyplot.gca()
-        else:
-            ax = axis
-        if Ts_Ph in ['ph', 'Ph']:
-            ax.plot(h, p)
-            ax.set_yscale('log')
-        elif Ts_Ph in ['Ts', 'ts']:
-            ax.plot(np.r_[s[7], s[3]], np.r_[T[7], T[3]], 'b')
-            s_copy = s.copy()
-            T_copy = T.copy()
-            dT = [0, -5, 5, -12, 5, 12, -12, 0, 0, 0]
-            ds = [0, 0.05, 0.05, 0, 0.05, 0, 0.0, 0.05, -0.05, -0.05]
-            for i in range(1, len(s) - 1):
-                ax.plot(s[i], T[i], 'bo', mfc='b', mec='b')
-                ax.text(s[i] + ds[i], T[i] + dT[i], str(i), ha='center', va='center')
-
-            s = list(s)
-            T = list(T)
-            s.insert(10, sdew_e)
-            T.insert(10, Te)
-            s.insert(5, sbubble_c)
-            T.insert(5, Tbubble_c)
-            s.insert(5, sdew_c)
-            T.insert(5, Tc)
-            ax.plot(s, T, 'b')
-
-            s = s_copy
-            T = T_copy
-        else:
-            raise TypeError('Type of Ts_Ph invalid')
-
-    COP = m * (h[1] - h[9]) / (m * (h[2] - h[1]) + (m + x) * (h[4] - h[3]))
-    for i in range(1, len(T) - 1):
-        print('%d & %g & %g & %g & %g & %g \\\\' % (i, T[i] - 273.15, p[i], h[i], s[i], rho[i]))
-    print(x, m * (h[1] - h[9]), (m * (h[2] - h[1]) + (m + x) * (h[4] - h[3])), COP)
-    mdot = Qin / (h[1] - h[9])
-    mdot_inj = x * mdot
-    print('x9', x9,)
-    print('Qcond', (mdot + mdot_inj) * (h[4] - h[5]), 'T4', T[4] - 273.15)
-    print(mdot, mdot + mdot_inj)
-    f = 3500 / 60.
-    eta_v = 0.7
-    print('Vdisp1: ', mdot / (rho[1] * f * eta_v) * 1e6, 'cm^3')
-    print('Vdisp2: ', (mdot + mdot_inj) / (rho[1] * f * eta_v) * 1e6, 'cm^3')
-    return COP
-
-    # class SimpleCycle(object):
-    #    """A class that calculates a simple thermodynamic cycle"""
-    #    def __init__(self, *args, **kwargs):
-    #        object.__init__(self, *args, **kwargs)
-    # (states, steps, fluid):
-
-#             Parameters
-#         ----------
-#         x_type : int, str
-#             Either a letter or an integer that specifies the property type for the x-axis
-#         y_type : int, str
-#             Either a letter or an integer that specifies the property type for the y-axis
-#         states : list
-#             A collection of state points that follows a fixed scheme defined
-#             in the implementing subclass.
-#         fluid_ref : str, CoolProp.AbstractState
-#             The fluid property provider, either a subclass of CoolProp.AbstractState
-#             or a string that can be used to generate a CoolProp.AbstractState instance
-#             via :func:`Common.process_fluid_state`.
-#         steps : int
-#             The number of steps used for going from one state to another
-#
-#         for more properties, see :class:`CoolProp.Plots.Common.Base2DObject`.
-
-# # See http://stackoverflow.com/questions/1061283/lt-instead-of-cmp
-# class ComparableMixin:
-#     """A mixin class that implements all comparing mathods except for __lt__"""
-#     def __eq__(self, other):
-#         return not self<other and not other<self
-#     def __ne__(self, other):
-#         return self<other or other<self
-#     def __gt__(self, other):
-#         return other<self
-#     def __ge__(self, other):
-#         return not self<other
-#     def __le__(self, other):
-#         return not other<self
-
-
-class StatePoint(PropertyDict):
-    """A simple fixed dimension dict represented by an object with attributes"""
-
-    # Significant digits in SI units
-    ROUND_DECIMALS = {
-      CoolProp.iDmass: 5,
-      CoolProp.iHmass: 5,
-      CoolProp.iP: 2,
-      CoolProp.iSmass: 5,
-      CoolProp.iT: 5,
-      CoolProp.iUmass: 5,
-      CoolProp.iQ: 5
-    }
-
-    def __iter__(self):
-        """Make sure we always iterate in the same order"""
-        keys = [CoolProp.iDmass, CoolProp.iHmass, CoolProp.iP, CoolProp.iSmass, CoolProp.iT]
-        for key in sorted(keys):
-            yield key
-
-    def __str__(self):
-        return str(self.__dict__)
-
-    def __prop_compare(self, other, typ):
-        # TODO
-        if self[typ] is None and other[typ] is None: return 0
-        elif self[typ] is None and other[typ] is not None: return -1
-        elif self[typ] is not None and other[typ] is None: return 1
-        else:
-            A = np.round(self[typ], self.ROUND_DECIMALS[typ])
-            B = np.round(other[typ], self.ROUND_DECIMALS[typ])
-            if A > B: return 1
-            elif A < B: return -1
-            elif A == B: return 0
-            else: raise ValueError("Comparison failed.")
-
-    def __eq__(self, other):
-        for i in self:
-            if not self.__prop_compare(other, i) == 0:
-                return False
-        return True
-
-    def __hash__(self):
-        return hash(repr(self))
-
-
-class StateContainer(object):
-    """A collection of values for the main properties, built to mixin with :class:`CoolProp.Plots.Common.PropertyDict`
-
-    Examples
-    --------
-    This container has overloaded accessor methods. Just pick your own flavour
-    or mix the styles as you like:
-
-    >>> from __future__ import print_function
-    >>> import CoolProp
-    >>> from CoolProp.Plots.SimpleCycles import StateContainer
-    >>> T0 = 300.000; p0 = 200000.000; h0 = 112745.749; s0 = 393.035
-    >>> cycle_states = StateContainer()
-    >>> cycle_states[0,'H'] = h0
-    >>> cycle_states[0]['S'] = s0
-    >>> cycle_states[0][CoolProp.iP] = p0
-    >>> cycle_states[0,CoolProp.iT] = T0
-    >>> cycle_states[1,"T"] = 300.064
-    >>> print(cycle_states)
-    Stored State Points:
-    state        T (K)       p (Pa)    d (kg/m3)     h (J/kg)   s (J/kg/K)
-        0      300.000   200000.000            -   112745.749      393.035
-        1      300.064            -            -            -            -
-
-    """
-
-    def __init__(self, unit_system=SIunits()):
-        self._points = {}
-        self._units = unit_system
-
-    @property
-    def points(self): return self._points
-
-    @points.setter
-    def points(self, value): self._points = value
-
-    @property
-    def units(self): return self._units
-
-    @units.setter
-    def units(self, value): self._units = value
-
-    def get_point(self, index, SI=True):
-        if SI:
-            state = self[index]
-        else:
-            state = self[index]
-            for i in state:
-                state[i] = self.units[i].from_SI(state[i])
-        return state
-
-    def set_point(self, index, value, SI=True):
-        if SI:
-            self._points[index] = value
-        else:
-            for i in value:
-                self._points[index][i] = self.units[i].to_SI(value[i])
-
-    def _list_like(self, value):
-        """Try to detect a list-like structure excluding strings"""
-        return (not hasattr(value, "strip") and
-            (hasattr(value, "__getitem__") or
-            hasattr(value, "__iter__")))
-        # return is_sequence(value) # use from pandas.core.common import is_sequence
-
-    def __len__(self):
-        """Some cheating to get the correct behaviour"""
-        return len(self._points)
-
-    def __iter__(self):
-        """Make sure we iterate in the righ order"""
-        for key in sorted(self._points):
-            yield key
-
-    def __getitem__(self, index):
-        """Another tweak that changes the default access path"""
-        if self._list_like(index):
-            len_var = len(index)
-            if len_var == 0:
-                raise IndexError("Received empty index.")
-            elif len_var == 1:
-                return self._points[index[0]]
-            elif len_var == 2:
-                return self._points[index[0]][index[1]]
-            else:
-                raise IndexError("Received too long index.")
-        return self._points[index]
-
-    def __setitem__(self, index, value):
-        """Another tweak that changes the default access path"""
-        if self._list_like(index):
-            len_var = len(index)
-            if len_var == 0:
-                raise IndexError("Received empty index.")
-            elif len_var == 1:
-                self._points[index[0]] = value
-            elif len_var == 2:
-                # safeguard against empty entries
-                if index[0] not in self._points:
-                    self._points[index[0]] = StatePoint()
-                self._points[index[0]][index[1]] = value
-            else:
-                raise IndexError("Received too long index.")
-        else:
-            self._points[index] = value
-
-    def __str__(self):
-        out = "Stored State Points:\n"
-        keys = True
-        for i in self._points:
-            if keys:
-                row = [u"{0:>5s}".format("state")]
-                for j in self._points[i]:
-                    label = u"{0:s} ({1:s})".format(self.units[j].symbol, self.units[j].unit)
-                    row.append(u"{0:>11s}".format(label))
-                out = out + u"  ".join(row) + "\n"
-                keys = False
-            row = [u"{0:>5s}".format(str(i))]
-            for j in self._points[i]:
-                try:
-                    row.append(u"{0:11.3f}".format(self.units[j].from_SI(self._points[i][j])))
-                except:
-                    row.append(u"{0:>11s}".format("-"))
-            out = out + u"  ".join(row) + "\n"
-        return out
-
-    def append(self, new):
-        i = 0 + self.__len__()
-        for j in new:
-            self[i, j] = new[j]
-        return self
-
-    def extend(self, new):
-        i = 0 + self.__len__()
-        for j in new:
-            for k in new[j]:
-                self[i, k] = new[j][k]
-            i = i + 1
-        return self
-
-    @property
-    def D(self): return np.array([self._points[k].D for k in self])
-
-    @property
-    def H(self): return np.array([self._points[k].H for k in self])
-
-    @property
-    def P(self): return np.array([self._points[k].P for k in self])
-
-    @property
-    def S(self): return np.array([self._points[k].S for k in self])
-
-    @property
-    def T(self): return np.array([self._points[k].T for k in self])
-
-    @property
-    def U(self): return np.array([self._points[k].U for k in self])
-
-    @property
-    def Q(self): return np.array([self._points[k].Q for k in self])
-
-
-class BaseCycle(BasePlot):
-    """A simple thermodynamic cycle, should not be used on its own."""
-
-    # Define the iteration keys
-    PROPERTIES = {
-      CoolProp.iDmass: 'density',
-      CoolProp.iHmass: 'specific enthalpy',
-      CoolProp.iP: 'pressure',
-      CoolProp.iSmass: 'specific entropy',
-      CoolProp.iT: 'temperature'
-    }
-
-    STATECOUNT = 0
-    """A list of accepted numbers of states"""
-
-    STATECHANGE = None
-    """A list of lists of tuples that defines how the state transitions
-    behave for the corresponding entry in BaseCycle.STATECOUNT"""
-
-    def __init__(self, fluid_ref, graph_type, unit_system='EUR', **kwargs):
-        """Initialises a simple cycle calculator
-
-        Parameters
-        ----------
-        fluid_ref : str, CoolProp.AbstractState
-            The fluid property provider, either a subclass of CoolProp.AbstractState
-            or a string that can be used to generate a CoolProp.AbstractState instance
-            via :func:`Common.process_fluid_state`.
-        graph_type : string
-            The graph type to be plotted, like \"PH\" or \"TS\"
-        unit_system : string, ['EUR','KSI','SI']
-            Select the units used for the plotting.  'EUR' is bar, kJ, C; 'KSI' is kPa, kJ, K; 'SI' is Pa, J, K
-
-        for more properties, see :class:`CoolProp.Plots.Common.BasePlot`.
-        """
-        self._cycle_states = StateContainer()
-        self._steps = 2
-        BasePlot.__init__(self, fluid_ref, graph_type, unit_system, **kwargs)
-
-    @property
-    def cycle_states(self): return self._cycle_states
-
-    @cycle_states.setter
-    def cycle_states(self, value):
-        if len(value) != self.STATECOUNT:
-            raise ValueError("Your number of states ({0:d}) is not in the list of allowed state counts: {1:s}.".format(len(value), str(self.STATECOUNT)))
-        self._cycle_states = value
-
-    @property
-    def steps(self): return self._steps
-
-    @steps.setter
-    def steps(self, value): self._steps = int(max([value, 2]))
-
-    @BasePlot.system.setter
-    def system(self, value):
-        if value in self.UNIT_SYSTEMS:
-            self._system = self.UNIT_SYSTEMS[value]
-        elif isinstance(value, PropertyDict):
-            self._system = value
-        else:
-            raise ValueError("Invalid unit_system input \"{0:s}\", expected a string from {1:s}".format(str(value), str(self.UNIT_SYSTEMS.keys())))
-        self._cycle_states.units = self._system
-
-    def valid_states(self):
-        """Check the formats of BaseCycle.STATECOUNT and BaseCycle.STATECHANGE"""
-        if len(self.STATECHANGE) != self.STATECOUNT:
-            raise ValueError("Invalid number of states and or state change operations")
-        return True
-
-    def fill_states(self, objs=None):
-        """Try to populate all fields in the state objects"""
-
-        if objs is None:
-            objs = self._cycle_states
-            local = True
-        else:
-            local = False
-
-        for i in objs:
-            full = True
-            for j in objs[i]:
-                if objs[i][j] is None:
-                    full = False
-            if full: continue
-            if (objs[i][CoolProp.iDmass] is not None and
-              objs[i][CoolProp.iT] is not None):
-                self._state.update(CoolProp.DmassT_INPUTS, objs[i][CoolProp.iDmass], objs[i][CoolProp.iT])
-            elif (objs[i][CoolProp.iP] is not None and
-              objs[i][CoolProp.iHmass] is not None):
-                self._state.update(CoolProp.HmassP_INPUTS, objs[i][CoolProp.iHmass], objs[i][CoolProp.iP])
-            elif (objs[i][CoolProp.iP] is not None and
-              objs[i][CoolProp.iSmass] is not None):
-                self._state.update(CoolProp.PSmass_INPUTS, objs[i][CoolProp.iP], objs[i][CoolProp.iSmass])
-            else:
-                warnings.warn("Please fill the state[{0:s}] manually.".format(str(i)))
-                continue
-            for j in objs[i]:
-                if objs[i][j] is None:
-                    objs[i][j] = self._state.keyed_output(j)
-
-        if local: self._cycle_states = objs
-        return objs
-
-    def state_change(self, in1, in2, start, ty1='lin', ty2='lin'):
-        """Calculates a state change defined by the properties in1 and in2
-
-        Uses self.states[start] and self.states[start+1] (or self.states[0]) to define
-        the process and interpolates between the values.
-
-        Parameters
-        ----------
-        in1 : int
-            The index of the first defined property.
-        in2 : int
-            The index of the second defined property.
-        start : int
-            The index of the start state.
-        ty1 : str
-            The key that defines the type of state change for in1, lin or log.
-        ty2 : str
-            The key that defines the type of state change for in2, lin or log.
-
-        Returns
-        -------
-        scalar or array_like
-            a list of the length of self.steps+1 that describes the process. It includes start and end state.
-        """
-        self.fill_states()
-        end = start + 1
-        if end >= len(self.cycle_states): end -= len(self.cycle_states)
-        start = self.cycle_states[start]
-        end = self.cycle_states[end]
-        #
-        val = []
-        inv = [in1, in2]
-        typ = [ty1, ty2]
-        for i, v in enumerate(inv):
-            if typ[i] == 'lin':
-                val.append(np.linspace(start[v], end[v], self.steps))
-            elif typ[i] == 'log':
-                val.append(np.logspace(np.log10(start[v]), np.log10(end[v]), self.steps))
-            else:
-                raise ValueError("Unknown range generator {0:s}".format(str(typ[i])))
-
-        sc = StateContainer(self._system)
-        for i, _ in enumerate(val[0]):
-            sc[i, inv[0]] = val[0][i]
-            sc[i, inv[1]] = val[1][i]
-
-        return self.fill_states(sc)
-
-    def get_state_change(self, index):
-        return self.STATECHANGE[index](self)
-
-    def get_state_changes(self):
-        sc = self.get_state_change(0)
-        for i in range(1, self.STATECOUNT):
-            sc.extend(self.get_state_change(i))
-        return sc
+# -*- coding: utf-8 -*-
+from __future__ import print_function, division, absolute_import
+
+
+import matplotlib, warnings
+import numpy as np
+
+
+import CoolProp
+from CoolProp.CoolProp import PropsSI
+from CoolProp.Plots.Common import BasePlot, PropertyDict, SIunits
+
+
+def SimpleCycle(Ref, Te, Tc, DTsh, DTsc, eta_a, Ts_Ph='Ph', **kwargs):
+    """
+    This function plots a simple four-component cycle, on the current axis, or that given by the optional parameter *axis*
+
+    Required parameters:
+
+    * Ref : A string for the refrigerant
+    * Te : Evap Temperature in K
+    * Tc : Condensing Temperature in K
+    * DTsh : Evaporator outlet superheat in K
+    * DTsc : Condenser outlet subcooling in K
+    * eta_a : Adiabatic efficiency of compressor (no units) in range [0,1]
+
+    Optional parameters:
+
+    * Ts_Ph : 'Ts' for a Temperature-Entropy plot, 'Ph' for a Pressure-Enthalpy
+    * axis : An axis to use instead of the active axis
+    * skipPlot : If True, won't actually plot anything, just print COP
+
+    """
+    warnings.warn("This function has been deprecated. Please consider converting it to an object inheriting from \"BaseCycle\".", DeprecationWarning)
+
+    for i in kwargs:
+        warnings.warn("This function has been deprecated, your input \"{0}: {1}\" will be ignored".format(i, kwargs[i]), DeprecationWarning)
+
+    from CoolProp.Plots import SimpleCompressionCycle
+    cycle = SimpleCompressionCycle(fluid_ref=Ref, graph_type=Ts_Ph)
+    cycle.simple_solve_dt(Te, Tc, DTsh, DTsc, eta_a, SI=True)
+    print(cycle.COP_cooling(), cycle.COP_heating())
+
+
+def TwoStage(Ref, Q, Te, Tc, DTsh, DTsc, eta_oi, f_p, Tsat_ic, DTsh_ic, Ts_Ph='Ph', prints=False, skipPlot=False, axis=None, **kwargs):
+    """
+    This function plots a two-stage cycle, on the current axis, or that given by the optional parameter *axis*
+
+    Required parameters:
+
+    * Ref : Refrigerant [string]
+    * Q : Cooling capacity [W]
+    * Te : Evap Temperature [K]
+    * Tc : Condensing Temperature [K]
+    * DTsh : Evaporator outlet superheat [K]
+    * DTsc : Condenser outlet subcooling [K]
+    * eta_oi : Adiabatic efficiency of compressor (no units) in range [0,1]
+    * f_p : fraction of compressor power lost as ambient heat transfer in range [0,1]
+    * Tsat_ic : Saturation temperature corresponding to intermediate pressure [K]
+    * DTsh_ic : Superheating at outlet of intermediate stage [K]
+
+    Optional parameters:
+
+    * Ts_Ph : 'Ts' for a Temperature-Entropy plot, 'Ph' for a Pressure-Enthalpy
+    * prints : True to print out some values
+    * axis : An axis to use instead of the active axis
+    * skipPlot : If True, won't actually plot anything, just print COP
+
+    """
+
+    warnings.warn("This function has been deprecated. PLease consider converting it to an object inheriting from \"BaseCycle\".", DeprecationWarning)
+
+    T = np.zeros((8))
+    h = np.zeros_like(T)
+    p = np.zeros_like(T)
+    s = np.zeros_like(T)
+    rho = np.zeros_like(T)
+    T[0] = np.NAN
+    s[0] = np.NAN
+    T[1] = Te + DTsh
+    pe = PropsSI('P', 'T', Te, 'Q', 1.0, Ref)
+    pc = PropsSI('P', 'T', Tc, 'Q', 1.0, Ref)
+    pic = PropsSI('P', 'T', Tsat_ic, 'Q', 1.0, Ref)
+    Tbubble_c = PropsSI('T', 'P', pc, 'Q', 0, Ref)
+    Tbubble_e = PropsSI('T', 'P', pe, 'Q', 0, Ref)
+
+    h[1] = PropsSI('H', 'T', T[1], 'P', pe, Ref)
+    s[1] = PropsSI('S', 'T', T[1], 'P', pe, Ref)
+    rho[1] = PropsSI('D', 'T', T[1], 'P', pe, Ref)
+    T[5] = Tbubble_c - DTsc
+    h[5] = PropsSI('H', 'T', T[5], 'P', pc, Ref)
+    s[5] = PropsSI('S', 'T', T[5], 'P', pc, Ref)
+    rho[5] = PropsSI('D', 'T', T[5], 'P', pc, Ref)
+    mdot = Q / (h[1] - h[5])
+
+    rho1 = PropsSI('D', 'T', T[1], 'P', pe, Ref)
+    h2s = PropsSI('H', 'S', s[1], 'P', pic, Ref)
+    Wdot1 = mdot * (h2s - h[1]) / eta_oi
+    h[2] = h[1] + (1 - f_p) * Wdot1 / mdot
+    T[2] = PropsSI('T', 'H', h[2], 'P', pic, Ref)
+    s[2] = PropsSI('S', 'T', T[2], 'P', pic, Ref)
+    rho[2] = PropsSI('D', 'T', T[2], 'P', pic, Ref)
+    T[3] = 288
+    p[3] = pic
+    h[3] = PropsSI('H', 'T', T[3], 'P', pic, Ref)
+    s[3] = PropsSI('S', 'T', T[3], 'P', pic, Ref)
+    rho[3] = PropsSI('D', 'T', T[3], 'P', pic, Ref)
+    rho3 = PropsSI('D', 'T', T[3], 'P', pic, Ref)
+    h4s = PropsSI('H', 'T', s[3], 'P', pc, Ref)
+    Wdot2 = mdot * (h4s - h[3]) / eta_oi
+    h[4] = h[3] + (1 - f_p) * Wdot2 / mdot
+    T[4] = PropsSI('T', 'H', h[4], 'P', pc, Ref)
+    s[4] = PropsSI('S', 'T', T[4], 'P', pc, Ref)
+    rho[4] = PropsSI('D', 'T', T[4], 'P', pc, Ref)
+
+    sbubble_e = PropsSI('S', 'T', Tbubble_e, 'Q', 0, Ref)
+    sbubble_c = PropsSI('S', 'T', Tbubble_c, 'Q', 0, Ref)
+    sdew_e = PropsSI('S', 'T', Te, 'Q', 1, Ref)
+    sdew_c = PropsSI('S', 'T', Tc, 'Q', 1, Ref)
+
+    hsatL = PropsSI('H', 'T', Tbubble_e, 'Q', 0, Ref)
+    hsatV = PropsSI('H', 'T', Te, 'Q', 1, Ref)
+    ssatL = PropsSI('S', 'T', Tbubble_e, 'Q', 0, Ref)
+    ssatV = PropsSI('S', 'T', Te, 'Q', 1, Ref)
+    vsatL = 1 / PropsSI('D', 'T', Tbubble_e, 'Q', 0, Ref)
+    vsatV = 1 / PropsSI('D', 'T', Te, 'Q', 1, Ref)
+    x = (h[5] - hsatL) / (hsatV - hsatL)
+    s[6] = x * ssatV + (1 - x) * ssatL
+    T[6] = x * Te + (1 - x) * Tbubble_e
+    rho[6] = 1.0 / (x * vsatV + (1 - x) * vsatL)
+
+    h[6] = h[5]
+    h[7] = h[1]
+    s[7] = s[1]
+    T[7] = T[1]
+    p = [np.nan, pe, pic, pic, pc, pc, pe, pe]
+    COP = Q / (Wdot1 + Wdot2)
+    RE = h[1] - h[6]
+
+    if prints == True:
+        print('x5:', x)
+        print('COP:', COP)
+        print('COPH', (Q + Wdot1 + Wdot2) / (Wdot1 + Wdot2))
+        print(T[2] - 273.15, T[4] - 273.15, p[2] / p[1], p[4] / p[3])
+        print(mdot, mdot * (h[4] - h[5]), pic)
+        print('Vdot1', mdot / rho1, 'Vdisp', mdot / rho1 / (3500 / 60.) * 1e6 / 0.7)
+        print('Vdot2', mdot / rho3, 'Vdisp', mdot / rho3 / (3500 / 60.) * 1e6 / 0.7)
+        print(mdot * (h[4] - h[5]), Tc - 273.15)
+        for i in range(1, len(T) - 1):
+            print('%d & %g & %g & %g & %g & %g \\\\' % (i, T[i] - 273.15, p[i], h[i], s[i], rho[i]))
+    else:
+        print(Tsat_ic, COP)
+
+    if skipPlot == False:
+        if axis == None:
+            ax = matplotlib.pyplot.gca()
+        else:
+            ax = axis
+        if Ts_Ph in ['ph', 'Ph']:
+            ax.plot(h, p)
+        elif Ts_Ph in ['Ts', 'ts']:
+            s_copy = s.copy()
+            T_copy = T.copy()
+            for i in range(1, len(s) - 1):
+                ax.plot(s[i], T[i], 'bo', mfc='b', mec='b')
+                dT = [0, -5, 5, -20, 5, 5, 5]
+                ds = [0, 0.05, 0, 0, 0, 0, 0]
+                ax.text(s[i] + ds[i], T[i] + dT[i], str(i))
+
+            s = list(s)
+            T = list(T)
+            s.insert(7, sdew_e)
+            T.insert(7, Te)
+            s.insert(5, sbubble_c)
+            T.insert(5, Tbubble_c)
+            s.insert(5, sdew_c)
+            T.insert(5, Tc)
+
+            ax.plot(s, T)
+            s = s_copy
+            T = T_copy
+        else:
+            raise TypeError('Type of Ts_Ph invalid')
+    return COP
+
+
+def EconomizedCycle(Ref, Qin, Te, Tc, DTsh, DTsc, eta_oi, f_p, Ti, Ts_Ph='Ts', skipPlot=False, axis=None, **kwargs):
+    """
+    This function plots an economized cycle, on the current axis, or that given by the optional parameter *axis*
+
+    Required parameters:
+
+    * Ref : Refrigerant [string]
+    * Qin : Cooling capacity [W]
+    * Te : Evap Temperature [K]
+    * Tc : Condensing Temperature [K]
+    * DTsh : Evaporator outlet superheat [K]
+    * DTsc : Condenser outlet subcooling [K]
+    * eta_oi : Adiabatic efficiency of compressor (no units) in range [0,1]
+    * f_p : fraction of compressor power lost as ambient heat transfer in range [0,1]
+    * Ti : Saturation temperature corresponding to intermediate pressure [K]
+
+    Optional parameters:
+
+    * Ts_Ph : 'Ts' for a Temperature-Entropy plot, 'Ph' for a Pressure-Enthalpy
+    * axis : An axis to use instead of the active axis
+    * skipPlot : If True, won't actually plot anything, just print COP
+
+    """
+
+    warnings.warn("This function has been deprecated. Please consider converting it to an object inheriting from \"BaseCycle\".", DeprecationWarning)
+    from scipy.optimize import newton
+
+    m = 1
+
+    T = np.zeros((11))
+    h = np.zeros_like(T)
+    p = np.zeros_like(T)
+    s = np.zeros_like(T)
+    rho = np.zeros_like(T)
+
+    T[0] = np.NAN
+    s[0] = np.NAN
+    T[1] = Te + DTsh
+    pe = PropsSI('P', 'T', Te, 'Q', 1.0, Ref)
+    pc = PropsSI('P', 'T', Tc, 'Q', 1.0, Ref)
+    pi = PropsSI('P', 'T', Ti, 'Q', 1.0, Ref)
+    p[1] = pe
+    h[1] = PropsSI('H', 'T', T[1], 'P', pe, Ref)
+    s[1] = PropsSI('S', 'T', T[1], 'P', pe, Ref)
+    rho[1] = PropsSI('D', 'T', T[1], 'P', pe, Ref)
+    h2s = PropsSI('H', 'S', s[1], 'P', pi, Ref)
+    wdot1 = (h2s - h[1]) / eta_oi
+    h[2] = h[1] + (1 - f_p[0]) * wdot1
+    p[2] = pi
+    # T[2]=T_hp(Ref,h[2],pi,T2s)
+    T[2] = PropsSI('T', 'H', h[2], 'P', pi, Ref)
+
+    s[2] = PropsSI('S', 'T', T[2], 'P', pi, Ref)
+    rho[2] = PropsSI('D', 'T', T[2], 'P', pi, Ref)
+
+    T[5] = Tc - DTsc
+    h[5] = PropsSI('H', 'T', T[5], 'P', pc, Ref)
+    s[5] = PropsSI('S', 'T', T[5], 'P', pc, Ref)
+    rho[5] = PropsSI('D', 'T', T[5], 'P', pc, Ref)
+
+    p[5] = pc
+    p[6] = pi
+    h[6] = h[5]
+
+    p[7] = pi
+    p[8] = pi
+    p[6] = pi
+    T[7] = Ti
+    h[7] = PropsSI('H', 'T', Ti, 'Q', 1, Ref)
+    s[7] = PropsSI('S', 'T', Ti, 'Q', 1, Ref)
+    rho[7] = PropsSI('D', 'T', Ti, 'Q', 1, Ref)
+    T[8] = Ti
+    h[8] = PropsSI('H', 'T', Ti, 'Q', 0, Ref)
+    s[8] = PropsSI('S', 'T', Ti, 'Q', 0, Ref)
+    rho[8] = PropsSI('D', 'T', Ti, 'Q', 0, Ref)
+    x6 = (h[6] - h[8]) / (h[7] - h[8])  # Vapor Quality
+    s[6] = s[7] * x6 + s[8] * (1 - x6)
+    rho[6] = 1.0 / (x6 / rho[7] + (1 - x6) / rho[8])
+    T[6] = Ti
+
+    # Injection mass flow rate
+    x = m * (h[6] - h[8]) / (h[7] - h[6])
+
+    p[3] = pi
+    h[3] = (m * h[2] + x * h[7]) / (m + x)
+    # T[3]=T_hp(Ref,h[3],pi,T[2])
+    T[3] = PropsSI('T', 'H', h[3], 'P', pi, Ref)
+    s[3] = PropsSI('S', 'T', T[3], 'P', pi, Ref)
+    rho[3] = PropsSI('D', 'T', T[3], 'P', pi, Ref)
+    T4s = newton(lambda T: PropsSI('S', 'T', T, 'P', pc, Ref) - s[3], T[2] + 30)
+    h4s = PropsSI('H', 'T', T4s, 'P', pc, Ref)
+    p[4] = pc
+    wdot2 = (h4s - h[3]) / eta_oi
+    h[4] = h[3] + (1 - f_p[1]) * wdot2
+    # T[4]=T_hp(Ref,h[4],pc,T4s)
+    T[4] = PropsSI('T', 'H', h[4], 'P', pc, Ref)
+    s[4] = PropsSI('S', 'T', T[4], 'P', pc, Ref)
+    rho[4] = PropsSI('D', 'T', T[4], 'P', pc, Ref)
+
+    p[9] = pe
+    h[9] = h[8]
+    T[9] = Te
+    hsatL_e = PropsSI('H', 'T', Te, 'Q', 0, Ref)
+    hsatV_e = PropsSI('H', 'T', Te, 'Q', 1, Ref)
+    ssatL_e = PropsSI('S', 'T', Te, 'Q', 0, Ref)
+    ssatV_e = PropsSI('S', 'T', Te, 'Q', 1, Ref)
+    vsatL_e = 1 / PropsSI('D', 'T', Te, 'Q', 0, Ref)
+    vsatV_e = 1 / PropsSI('D', 'T', Te, 'Q', 1, Ref)
+    x9 = (h[9] - hsatL_e) / (hsatV_e - hsatL_e)  # Vapor Quality
+    s[9] = ssatV_e * x9 + ssatL_e * (1 - x9)
+    rho[9] = 1.0 / (x9 * vsatV_e + (1 - x9) * vsatL_e)
+
+    s[10] = s[1]
+    T[10] = T[1]
+    h[10] = h[1]
+    p[10] = p[1]
+
+    Tbubble_e = Te
+    Tbubble_c = Tc
+    sbubble_e = PropsSI('S', 'T', Tbubble_e, 'Q', 0, Ref)
+    sbubble_c = PropsSI('S', 'T', Tbubble_c, 'Q', 0, Ref)
+    sdew_e = PropsSI('S', 'T', Te, 'Q', 1, Ref)
+    sdew_c = PropsSI('S', 'T', Tc, 'Q', 1, Ref)
+
+    Wdot1 = m * wdot1
+    Wdot2 = (m + x) * wdot2
+    if skipPlot == False:
+        if axis == None:
+            ax = matplotlib.pyplot.gca()
+        else:
+            ax = axis
+        if Ts_Ph in ['ph', 'Ph']:
+            ax.plot(h, p)
+            ax.set_yscale('log')
+        elif Ts_Ph in ['Ts', 'ts']:
+            ax.plot(np.r_[s[7], s[3]], np.r_[T[7], T[3]], 'b')
+            s_copy = s.copy()
+            T_copy = T.copy()
+            dT = [0, -5, 5, -12, 5, 12, -12, 0, 0, 0]
+            ds = [0, 0.05, 0.05, 0, 0.05, 0, 0.0, 0.05, -0.05, -0.05]
+            for i in range(1, len(s) - 1):
+                ax.plot(s[i], T[i], 'bo', mfc='b', mec='b')
+                ax.text(s[i] + ds[i], T[i] + dT[i], str(i), ha='center', va='center')
+
+            s = list(s)
+            T = list(T)
+            s.insert(10, sdew_e)
+            T.insert(10, Te)
+            s.insert(5, sbubble_c)
+            T.insert(5, Tbubble_c)
+            s.insert(5, sdew_c)
+            T.insert(5, Tc)
+            ax.plot(s, T, 'b')
+
+            s = s_copy
+            T = T_copy
+        else:
+            raise TypeError('Type of Ts_Ph invalid')
+
+    COP = m * (h[1] - h[9]) / (m * (h[2] - h[1]) + (m + x) * (h[4] - h[3]))
+    for i in range(1, len(T) - 1):
+        print('%d & %g & %g & %g & %g & %g \\\\' % (i, T[i] - 273.15, p[i], h[i], s[i], rho[i]))
+    print(x, m * (h[1] - h[9]), (m * (h[2] - h[1]) + (m + x) * (h[4] - h[3])), COP)
+    mdot = Qin / (h[1] - h[9])
+    mdot_inj = x * mdot
+    print('x9', x9,)
+    print('Qcond', (mdot + mdot_inj) * (h[4] - h[5]), 'T4', T[4] - 273.15)
+    print(mdot, mdot + mdot_inj)
+    f = 3500 / 60.
+    eta_v = 0.7
+    print('Vdisp1: ', mdot / (rho[1] * f * eta_v) * 1e6, 'cm^3')
+    print('Vdisp2: ', (mdot + mdot_inj) / (rho[1] * f * eta_v) * 1e6, 'cm^3')
+    return COP
+
+    # class SimpleCycle(object):
+    #    """A class that calculates a simple thermodynamic cycle"""
+    #    def __init__(self, *args, **kwargs):
+    #        object.__init__(self, *args, **kwargs)
+    # (states, steps, fluid):
+
+#             Parameters
+#         ----------
+#         x_type : int, str
+#             Either a letter or an integer that specifies the property type for the x-axis
+#         y_type : int, str
+#             Either a letter or an integer that specifies the property type for the y-axis
+#         states : list
+#             A collection of state points that follows a fixed scheme defined
+#             in the implementing subclass.
+#         fluid_ref : str, CoolProp.AbstractState
+#             The fluid property provider, either a subclass of CoolProp.AbstractState
+#             or a string that can be used to generate a CoolProp.AbstractState instance
+#             via :func:`Common.process_fluid_state`.
+#         steps : int
+#             The number of steps used for going from one state to another
+#
+#         for more properties, see :class:`CoolProp.Plots.Common.Base2DObject`.
+
+# # See http://stackoverflow.com/questions/1061283/lt-instead-of-cmp
+# class ComparableMixin:
+#     """A mixin class that implements all comparing mathods except for __lt__"""
+#     def __eq__(self, other):
+#         return not self<other and not other<self
+#     def __ne__(self, other):
+#         return self<other or other<self
+#     def __gt__(self, other):
+#         return other<self
+#     def __ge__(self, other):
+#         return not self<other
+#     def __le__(self, other):
+#         return not other<self
+
+
+class StatePoint(PropertyDict):
+    """A simple fixed dimension dict represented by an object with attributes"""
+
+    # Significant digits in SI units
+    ROUND_DECIMALS = {
+      CoolProp.iDmass: 5,
+      CoolProp.iHmass: 5,
+      CoolProp.iP: 2,
+      CoolProp.iSmass: 5,
+      CoolProp.iT: 5,
+      CoolProp.iUmass: 5,
+      CoolProp.iQ: 5
+    }
+
+    def __iter__(self):
+        """Make sure we always iterate in the same order"""
+        keys = [CoolProp.iDmass, CoolProp.iHmass, CoolProp.iP, CoolProp.iSmass, CoolProp.iT]
+        for key in sorted(keys):
+            yield key
+
+    def __str__(self):
+        return str(self.__dict__)
+
+    def __prop_compare(self, other, typ):
+        # TODO
+        if self[typ] is None and other[typ] is None: return 0
+        elif self[typ] is None and other[typ] is not None: return -1
+        elif self[typ] is not None and other[typ] is None: return 1
+        else:
+            A = np.round(self[typ], self.ROUND_DECIMALS[typ])
+            B = np.round(other[typ], self.ROUND_DECIMALS[typ])
+            if A > B: return 1
+            elif A < B: return -1
+            elif A == B: return 0
+            else: raise ValueError("Comparison failed.")
+
+    def __eq__(self, other):
+        for i in self:
+            if not self.__prop_compare(other, i) == 0:
+                return False
+        return True
+
+    def __hash__(self):
+        return hash(repr(self))
+
+
+class StateContainer(object):
+    """A collection of values for the main properties, built to mixin with :class:`CoolProp.Plots.Common.PropertyDict`
+
+    Examples
+    --------
+    This container has overloaded accessor methods. Just pick your own flavour
+    or mix the styles as you like:
+
+    >>> from __future__ import print_function
+    >>> import CoolProp
+    >>> from CoolProp.Plots.SimpleCycles import StateContainer
+    >>> T0 = 300.000; p0 = 200000.000; h0 = 112745.749; s0 = 393.035
+    >>> cycle_states = StateContainer()
+    >>> cycle_states[0,'H'] = h0
+    >>> cycle_states[0]['S'] = s0
+    >>> cycle_states[0][CoolProp.iP] = p0
+    >>> cycle_states[0,CoolProp.iT] = T0
+    >>> cycle_states[1,"T"] = 300.064
+    >>> print(cycle_states)
+    Stored State Points:
+    state        T (K)       p (Pa)    d (kg/m3)     h (J/kg)   s (J/kg/K)
+        0      300.000   200000.000            -   112745.749      393.035
+        1      300.064            -            -            -            -
+
+    """
+
+    def __init__(self, unit_system=SIunits()):
+        self._points = {}
+        self._units = unit_system
+
+    @property
+    def points(self): return self._points
+
+    @points.setter
+    def points(self, value): self._points = value
+
+    @property
+    def units(self): return self._units
+
+    @units.setter
+    def units(self, value): self._units = value
+
+    def get_point(self, index, SI=True):
+        if SI:
+            state = self[index]
+        else:
+            state = self[index]
+            for i in state:
+                state[i] = self.units[i].from_SI(state[i])
+        return state
+
+    def set_point(self, index, value, SI=True):
+        if SI:
+            self._points[index] = value
+        else:
+            for i in value:
+                self._points[index][i] = self.units[i].to_SI(value[i])
+
+    def _list_like(self, value):
+        """Try to detect a list-like structure excluding strings"""
+        return (not hasattr(value, "strip") and
+            (hasattr(value, "__getitem__") or
+            hasattr(value, "__iter__")))
+        # return is_sequence(value) # use from pandas.core.common import is_sequence
+
+    def __len__(self):
+        """Some cheating to get the correct behaviour"""
+        return len(self._points)
+
+    def __iter__(self):
+        """Make sure we iterate in the righ order"""
+        for key in sorted(self._points):
+            yield key
+
+    def __getitem__(self, index):
+        """Another tweak that changes the default access path"""
+        if self._list_like(index):
+            len_var = len(index)
+            if len_var == 0:
+                raise IndexError("Received empty index.")
+            elif len_var == 1:
+                return self._points[index[0]]
+            elif len_var == 2:
+                return self._points[index[0]][index[1]]
+            else:
+                raise IndexError("Received too long index.")
+        return self._points[index]
+
+    def __setitem__(self, index, value):
+        """Another tweak that changes the default access path"""
+        if self._list_like(index):
+            len_var = len(index)
+            if len_var == 0:
+                raise IndexError("Received empty index.")
+            elif len_var == 1:
+                self._points[index[0]] = value
+            elif len_var == 2:
+                # safeguard against empty entries
+                if index[0] not in self._points:
+                    self._points[index[0]] = StatePoint()
+                self._points[index[0]][index[1]] = value
+            else:
+                raise IndexError("Received too long index.")
+        else:
+            self._points[index] = value
+
+    def __str__(self):
+        out = "Stored State Points:\n"
+        keys = True
+        for i in self._points:
+            if keys:
+                row = [u"{0:>5s}".format("state")]
+                for j in self._points[i]:
+                    label = u"{0:s} ({1:s})".format(self.units[j].symbol, self.units[j].unit)
+                    row.append(u"{0:>11s}".format(label))
+                out = out + u"  ".join(row) + "\n"
+                keys = False
+            row = [u"{0:>5s}".format(str(i))]
+            for j in self._points[i]:
+                try:
+                    row.append(u"{0:11.3f}".format(self.units[j].from_SI(self._points[i][j])))
+                except:
+                    row.append(u"{0:>11s}".format("-"))
+            out = out + u"  ".join(row) + "\n"
+        return out
+
+    def append(self, new):
+        i = 0 + self.__len__()
+        for j in new:
+            self[i, j] = new[j]
+        return self
+
+    def extend(self, new):
+        i = 0 + self.__len__()
+        for j in new:
+            for k in new[j]:
+                self[i, k] = new[j][k]
+            i = i + 1
+        return self
+
+    @property
+    def D(self): return np.array([self._points[k].D for k in self])
+
+    @property
+    def H(self): return np.array([self._points[k].H for k in self])
+
+    @property
+    def P(self): return np.array([self._points[k].P for k in self])
+
+    @property
+    def S(self): return np.array([self._points[k].S for k in self])
+
+    @property
+    def T(self): return np.array([self._points[k].T for k in self])
+
+    @property
+    def U(self): return np.array([self._points[k].U for k in self])
+
+    @property
+    def Q(self): return np.array([self._points[k].Q for k in self])
+
+
+class BaseCycle(BasePlot):
+    """A simple thermodynamic cycle, should not be used on its own."""
+
+    # Define the iteration keys
+    PROPERTIES = {
+      CoolProp.iDmass: 'density',
+      CoolProp.iHmass: 'specific enthalpy',
+      CoolProp.iP: 'pressure',
+      CoolProp.iSmass: 'specific entropy',
+      CoolProp.iT: 'temperature'
+    }
+
+    STATECOUNT = 0
+    """A list of accepted numbers of states"""
+
+    STATECHANGE = None
+    """A list of lists of tuples that defines how the state transitions
+    behave for the corresponding entry in BaseCycle.STATECOUNT"""
+
+    def __init__(self, fluid_ref, graph_type, unit_system='EUR', **kwargs):
+        """Initialises a simple cycle calculator
+
+        Parameters
+        ----------
+        fluid_ref : str, CoolProp.AbstractState
+            The fluid property provider, either a subclass of CoolProp.AbstractState
+            or a string that can be used to generate a CoolProp.AbstractState instance
+            via :func:`Common.process_fluid_state`.
+        graph_type : string
+            The graph type to be plotted, like \"PH\" or \"TS\"
+        unit_system : string, ['EUR','KSI','SI']
+            Select the units used for the plotting.  'EUR' is bar, kJ, C; 'KSI' is kPa, kJ, K; 'SI' is Pa, J, K
+
+        for more properties, see :class:`CoolProp.Plots.Common.BasePlot`.
+        """
+        self._cycle_states = StateContainer()
+        self._steps = 2
+        BasePlot.__init__(self, fluid_ref, graph_type, unit_system, **kwargs)
+
+    @property
+    def cycle_states(self): return self._cycle_states
+
+    @cycle_states.setter
+    def cycle_states(self, value):
+        if len(value) != self.STATECOUNT:
+            raise ValueError("Your number of states ({0:d}) is not in the list of allowed state counts: {1:s}.".format(len(value), str(self.STATECOUNT)))
+        self._cycle_states = value
+
+    @property
+    def steps(self): return self._steps
+
+    @steps.setter
+    def steps(self, value): self._steps = int(max([value, 2]))
+
+    @BasePlot.system.setter
+    def system(self, value):
+        if value in self.UNIT_SYSTEMS:
+            self._system = self.UNIT_SYSTEMS[value]
+        elif isinstance(value, PropertyDict):
+            self._system = value
+        else:
+            raise ValueError("Invalid unit_system input \"{0:s}\", expected a string from {1:s}".format(str(value), str(self.UNIT_SYSTEMS.keys())))
+        self._cycle_states.units = self._system
+
+    def valid_states(self):
+        """Check the formats of BaseCycle.STATECOUNT and BaseCycle.STATECHANGE"""
+        if len(self.STATECHANGE) != self.STATECOUNT:
+            raise ValueError("Invalid number of states and or state change operations")
+        return True
+
+    def fill_states(self, objs=None):
+        """Try to populate all fields in the state objects"""
+
+        if objs is None:
+            objs = self._cycle_states
+            local = True
+        else:
+            local = False
+
+        for i in objs:
+            full = True
+            for j in objs[i]:
+                if objs[i][j] is None:
+                    full = False
+            if full: continue
+            if (objs[i][CoolProp.iDmass] is not None and
+              objs[i][CoolProp.iT] is not None):
+                self._state.update(CoolProp.DmassT_INPUTS, objs[i][CoolProp.iDmass], objs[i][CoolProp.iT])
+            elif (objs[i][CoolProp.iP] is not None and
+              objs[i][CoolProp.iHmass] is not None):
+                self._state.update(CoolProp.HmassP_INPUTS, objs[i][CoolProp.iHmass], objs[i][CoolProp.iP])
+            elif (objs[i][CoolProp.iP] is not None and
+              objs[i][CoolProp.iSmass] is not None):
+                self._state.update(CoolProp.PSmass_INPUTS, objs[i][CoolProp.iP], objs[i][CoolProp.iSmass])
+            else:
+                warnings.warn("Please fill the state[{0:s}] manually.".format(str(i)))
+                continue
+            for j in objs[i]:
+                if objs[i][j] is None:
+                    objs[i][j] = self._state.keyed_output(j)
+
+        if local: self._cycle_states = objs
+        return objs
+
+    def state_change(self, in1, in2, start, ty1='lin', ty2='lin'):
+        """Calculates a state change defined by the properties in1 and in2
+
+        Uses self.states[start] and self.states[start+1] (or self.states[0]) to define
+        the process and interpolates between the values.
+
+        Parameters
+        ----------
+        in1 : int
+            The index of the first defined property.
+        in2 : int
+            The index of the second defined property.
+        start : int
+            The index of the start state.
+        ty1 : str
+            The key that defines the type of state change for in1, lin or log.
+        ty2 : str
+            The key that defines the type of state change for in2, lin or log.
+
+        Returns
+        -------
+        scalar or array_like
+            a list of the length of self.steps+1 that describes the process. It includes start and end state.
+        """
+        self.fill_states()
+        end = start + 1
+        if end >= len(self.cycle_states): end -= len(self.cycle_states)
+        start = self.cycle_states[start]
+        end = self.cycle_states[end]
+        #
+        val = []
+        inv = [in1, in2]
+        typ = [ty1, ty2]
+        for i, v in enumerate(inv):
+            if typ[i] == 'lin':
+                val.append(np.linspace(start[v], end[v], self.steps))
+            elif typ[i] == 'log':
+                val.append(np.logspace(np.log10(start[v]), np.log10(end[v]), self.steps))
+            else:
+                raise ValueError("Unknown range generator {0:s}".format(str(typ[i])))
+
+        sc = StateContainer(self._system)
+        for i, _ in enumerate(val[0]):
+            sc[i, inv[0]] = val[0][i]
+            sc[i, inv[1]] = val[1][i]
+
+        return self.fill_states(sc)
+
+    def get_state_change(self, index):
+        return self.STATECHANGE[index](self)
+
+    def get_state_changes(self):
+        sc = self.get_state_change(0)
+        for i in range(1, self.STATECOUNT):
+            sc.extend(self.get_state_change(i))
+        return sc
```

## CoolProp/Plots/SimpleCyclesCompression.py

 * *Ordering differences only*

```diff
@@ -1,239 +1,239 @@
-# -*- coding: utf-8 -*-
-from __future__ import print_function, division, absolute_import
-
-import numpy as np
-
-import CoolProp
-from .Common import process_fluid_state
-from .SimpleCycles import BaseCycle, StateContainer
-
-
-class BaseCompressionCycle(BaseCycle):
-    """A thermodynamic cycle for vapour compression processes.
-
-    Defines the basic properties and methods to unify access to
-    compression cycle-related quantities.
-    """
-
-    def __init__(self, fluid_ref='HEOS::Water', graph_type='PH', **kwargs):
-        """see :class:`CoolProp.Plots.SimpleCycles.BaseCycle` for details."""
-        BaseCycle.__init__(self, fluid_ref, graph_type, **kwargs)
-
-    def eta_carnot_heating(self):
-        """Carnot efficiency
-
-        Calculates the Carnot efficiency for a heating process, :math:`\eta_c = \frac{T_h}{T_h-T_c}`.
-
-        Returns
-        -------
-        float
-        """
-        Tvector = self._cycle_states.T
-        return np.max(Tvector) / (np.max(Tvector) - np.min(Tvector))
-
-    def eta_carnot_cooling(self):
-        """Carnot efficiency
-
-        Calculates the Carnot efficiency for a cooling process, :math:`\eta_c = \frac{T_c}{T_h-T_c}`.
-
-        Returns
-        -------
-        float
-        """
-        Tvector = self._cycle_states.T
-        return np.min(Tvector) / (np.max(Tvector) - np.min(Tvector))
-
-
-class SimpleCompressionCycle(BaseCompressionCycle):
-    """A simple vapour compression cycle"""
-    STATECOUNT = 4
-    STATECHANGE = [
-      lambda inp: BaseCycle.state_change(inp, 'S', 'P', 0, ty1='log', ty2='log'),  # Compression process
-      lambda inp: BaseCycle.state_change(inp, 'H', 'P', 1, ty1='lin', ty2='lin'),  # Heat removal
-      lambda inp: BaseCycle.state_change(inp, 'H', 'P', 2, ty1='log', ty2='log'),  # Expansion
-      lambda inp: BaseCycle.state_change(inp, 'H', 'P', 3, ty1='lin', ty2='lin')  # Heat addition
-      ]
-
-    def __init__(self, fluid_ref='HEOS::Water', graph_type='PH', **kwargs):
-        """see :class:`CoolProp.Plots.SimpleCyclesCompression.BaseCompressionCycle` for details."""
-        BaseCompressionCycle.__init__(self, fluid_ref, graph_type, **kwargs)
-
-    def simple_solve(self, T0, p0, T2, p2, eta_com, fluid=None, SI=True):
-        """"
-        A simple vapour compression cycle calculation
-
-        Parameters
-        ----------
-        T0 : float
-            The evaporated fluid, before the compressor
-        p0 : float
-            The evaporated fluid, before the compressor
-        T2 : float
-            The condensed fluid, before the expansion valve
-        p2 : float
-            The condensed fluid, before the expansion valve
-        eta_com : float
-            Isentropic compressor efficiency
-
-        Examples
-        --------
-        >>> import CoolProp
-        >>> from CoolProp.Plots import PropertyPlot
-        >>> from CoolProp.Plots import SimpleCompressionCycle
-        >>> pp = PropertyPlot('HEOS::R134a', 'PH', unit_system='EUR')
-        >>> pp.calc_isolines(CoolProp.iQ, num=11)
-        >>> cycle = SimpleCompressionCycle('HEOS::R134a', 'PH', unit_system='EUR')
-        >>> T0 = 280
-        >>> pp.state.update(CoolProp.QT_INPUTS,0.0,T0-15)
-        >>> p0 = pp.state.keyed_output(CoolProp.iP)
-        >>> T2 = 310
-        >>> pp.state.update(CoolProp.QT_INPUTS,1.0,T2+10)
-        >>> p2 = pp.state.keyed_output(CoolProp.iP)
-        >>> cycle.simple_solve(T0, p0, T2, p2, 0.7, SI=True)
-        >>> cycle.steps = 50
-        >>> sc = cycle.get_state_changes()
-        >>> import matplotlib.pyplot as plt
-        >>> plt.close(cycle.figure)
-        >>> pp.draw_process(sc)
-
-        """
-        if fluid is not None:
-            self.state = process_fluid_state(fluid)
-        if self._state is None:
-            raise ValueError("You have to specify a fluid before you can calculate.")
-
-        cycle_states = StateContainer(unit_system=self._system)
-
-        if not SI:
-            conv_t = self._system[CoolProp.iT].to_SI
-            conv_p = self._system[CoolProp.iP].to_SI
-            T0 = conv_t(T0)
-            p0 = conv_p(p0)
-            T2 = conv_t(T2)
-            p2 = conv_p(p2)
-
-        # Gas from evaporator
-        self.state.update(CoolProp.PT_INPUTS, p0, T0)
-        h0 = self.state.hmass()
-        s0 = self.state.smass()
-        # Just a showcase for the different accessor methods
-        cycle_states[0, 'H'] = h0
-        cycle_states[0]['S'] = s0
-        cycle_states[0][CoolProp.iP] = p0
-        cycle_states[0, CoolProp.iT] = T0
-
-        # Pressurised vapour
-        p1 = p2
-        self.state.update(CoolProp.PSmass_INPUTS, p1, s0)
-        h1 = h0 + (self.state.hmass() - h0) / eta_com
-        self.state.update(CoolProp.HmassP_INPUTS, h1, p1)
-        s1 = self.state.smass()
-        T1 = self.state.T()
-        cycle_states[1, 'H'] = h1
-        cycle_states[1, 'S'] = s1
-        cycle_states[1, 'P'] = p1
-        cycle_states[1, 'T'] = T1
-
-        # Condensed vapour
-        self.state.update(CoolProp.PT_INPUTS, p2, T2)
-        h2 = self.state.hmass()
-        s2 = self.state.smass()
-        cycle_states[2, 'H'] = h2
-        cycle_states[2, 'S'] = s2
-        cycle_states[2, 'P'] = p2
-        cycle_states[2, 'T'] = T2
-
-        # Expanded fluid, 2-phase
-        p3 = p0
-        h3 = h2
-        self.state.update(CoolProp.HmassP_INPUTS, h3, p3)
-        s3 = self.state.smass()
-        T3 = self.state.T()
-        cycle_states[3, 'H'] = h3
-        cycle_states[3, 'S'] = s3
-        cycle_states[3, 'P'] = p3
-        cycle_states[3, 'T'] = T3
-
-        w_net = h0 - h1
-        q_evap = h0 - h3
-
-        self.cycle_states = cycle_states
-        self.fill_states()
-
-    def simple_solve_dt(self, Te, Tc, dT_sh, dT_sc, eta_com, fluid=None, SI=True):
-        """"
-        A simple vapour compression cycle calculation based on
-        superheat, subcooling and temperatures.
-
-        Parameters
-        ----------
-        Te : float
-            The evaporation temperature
-        Tc : float
-            The condensation temperature
-        dT_sh : float
-            The superheat after the evaporator
-        dT_sc : float
-            The subcooling after the condenser
-        eta_com : float
-            Isentropic compressor efficiency
-
-        Examples
-        --------
-        >>> import CoolProp
-        >>> from CoolProp.Plots import PropertyPlot
-        >>> from CoolProp.Plots import SimpleCompressionCycle
-        >>> pp = PropertyPlot('HEOS::R134a', 'PH', unit_system='EUR')
-        >>> pp.calc_isolines(CoolProp.iQ, num=11)
-        >>> cycle = SimpleCompressionCycle('HEOS::R134a', 'PH', unit_system='EUR')
-        >>> Te = 265
-        >>> Tc = 300
-        >>> cycle.simple_solve_dt(Te, Tc, 10, 15, 0.7, SI=True)
-        >>> cycle.steps = 50
-        >>> sc = cycle.get_state_changes()
-        >>> import matplotlib.pyplot as plt
-        >>> plt.close(cycle.figure)
-        >>> pp.draw_process(sc)
-        """
-        if fluid is not None:
-            self.state = process_fluid_state(fluid)
-        if self._state is None:
-            raise ValueError("You have to specify a fluid before you can calculate.")
-
-        if not SI:
-            conv_t = self._system[CoolProp.iT].to_SI
-            Te = conv_p(Te)
-            Tc = conv_p(Tc)
-
-        # Get the saturation conditions
-        self.state.update(CoolProp.QT_INPUTS, 1.0, Te)
-        p0 = self.state.p()
-        self.state.update(CoolProp.QT_INPUTS, 0.0, Tc)
-        p2 = self.state.p()
-
-        T0 = Te + dT_sh
-        T2 = Tc - dT_sc
-
-        self.simple_solve(T0, p0, T2, p2, eta_com, fluid=None, SI=True)
-
-    def COP_heating(self):
-        """COP for a heating process
-
-        Calculates the coefficient of performance for a heating process, :math:`COP_h = \frac{q_{con}}{w_{comp}}`.
-
-        Returns
-        -------
-        float
-        """
-        return (self.cycle_states[1, 'H'] - self.cycle_states[2, 'H']) / (self.cycle_states[1, 'H'] - self.cycle_states[0, 'H'])
-
-    def COP_cooling(self):
-        """COP for a cooling process
-
-        Calculates the coefficient of performance for a cooling process, :math:`COP_c = \frac{q_{eva}}{w_{comp}}`.
-
-        Returns
-        -------
-        float
-        """
-        return (self.cycle_states[0, 'H'] - self.cycle_states[3, 'H']) / (self.cycle_states[1, 'H'] - self.cycle_states[0, 'H'])
+# -*- coding: utf-8 -*-
+from __future__ import print_function, division, absolute_import
+
+import numpy as np
+
+import CoolProp
+from .Common import process_fluid_state
+from .SimpleCycles import BaseCycle, StateContainer
+
+
+class BaseCompressionCycle(BaseCycle):
+    """A thermodynamic cycle for vapour compression processes.
+
+    Defines the basic properties and methods to unify access to
+    compression cycle-related quantities.
+    """
+
+    def __init__(self, fluid_ref='HEOS::Water', graph_type='PH', **kwargs):
+        """see :class:`CoolProp.Plots.SimpleCycles.BaseCycle` for details."""
+        BaseCycle.__init__(self, fluid_ref, graph_type, **kwargs)
+
+    def eta_carnot_heating(self):
+        """Carnot efficiency
+
+        Calculates the Carnot efficiency for a heating process, :math:`\eta_c = \frac{T_h}{T_h-T_c}`.
+
+        Returns
+        -------
+        float
+        """
+        Tvector = self._cycle_states.T
+        return np.max(Tvector) / (np.max(Tvector) - np.min(Tvector))
+
+    def eta_carnot_cooling(self):
+        """Carnot efficiency
+
+        Calculates the Carnot efficiency for a cooling process, :math:`\eta_c = \frac{T_c}{T_h-T_c}`.
+
+        Returns
+        -------
+        float
+        """
+        Tvector = self._cycle_states.T
+        return np.min(Tvector) / (np.max(Tvector) - np.min(Tvector))
+
+
+class SimpleCompressionCycle(BaseCompressionCycle):
+    """A simple vapour compression cycle"""
+    STATECOUNT = 4
+    STATECHANGE = [
+      lambda inp: BaseCycle.state_change(inp, 'S', 'P', 0, ty1='log', ty2='log'),  # Compression process
+      lambda inp: BaseCycle.state_change(inp, 'H', 'P', 1, ty1='lin', ty2='lin'),  # Heat removal
+      lambda inp: BaseCycle.state_change(inp, 'H', 'P', 2, ty1='log', ty2='log'),  # Expansion
+      lambda inp: BaseCycle.state_change(inp, 'H', 'P', 3, ty1='lin', ty2='lin')  # Heat addition
+      ]
+
+    def __init__(self, fluid_ref='HEOS::Water', graph_type='PH', **kwargs):
+        """see :class:`CoolProp.Plots.SimpleCyclesCompression.BaseCompressionCycle` for details."""
+        BaseCompressionCycle.__init__(self, fluid_ref, graph_type, **kwargs)
+
+    def simple_solve(self, T0, p0, T2, p2, eta_com, fluid=None, SI=True):
+        """"
+        A simple vapour compression cycle calculation
+
+        Parameters
+        ----------
+        T0 : float
+            The evaporated fluid, before the compressor
+        p0 : float
+            The evaporated fluid, before the compressor
+        T2 : float
+            The condensed fluid, before the expansion valve
+        p2 : float
+            The condensed fluid, before the expansion valve
+        eta_com : float
+            Isentropic compressor efficiency
+
+        Examples
+        --------
+        >>> import CoolProp
+        >>> from CoolProp.Plots import PropertyPlot
+        >>> from CoolProp.Plots import SimpleCompressionCycle
+        >>> pp = PropertyPlot('HEOS::R134a', 'PH', unit_system='EUR')
+        >>> pp.calc_isolines(CoolProp.iQ, num=11)
+        >>> cycle = SimpleCompressionCycle('HEOS::R134a', 'PH', unit_system='EUR')
+        >>> T0 = 280
+        >>> pp.state.update(CoolProp.QT_INPUTS,0.0,T0-15)
+        >>> p0 = pp.state.keyed_output(CoolProp.iP)
+        >>> T2 = 310
+        >>> pp.state.update(CoolProp.QT_INPUTS,1.0,T2+10)
+        >>> p2 = pp.state.keyed_output(CoolProp.iP)
+        >>> cycle.simple_solve(T0, p0, T2, p2, 0.7, SI=True)
+        >>> cycle.steps = 50
+        >>> sc = cycle.get_state_changes()
+        >>> import matplotlib.pyplot as plt
+        >>> plt.close(cycle.figure)
+        >>> pp.draw_process(sc)
+
+        """
+        if fluid is not None:
+            self.state = process_fluid_state(fluid)
+        if self._state is None:
+            raise ValueError("You have to specify a fluid before you can calculate.")
+
+        cycle_states = StateContainer(unit_system=self._system)
+
+        if not SI:
+            conv_t = self._system[CoolProp.iT].to_SI
+            conv_p = self._system[CoolProp.iP].to_SI
+            T0 = conv_t(T0)
+            p0 = conv_p(p0)
+            T2 = conv_t(T2)
+            p2 = conv_p(p2)
+
+        # Gas from evaporator
+        self.state.update(CoolProp.PT_INPUTS, p0, T0)
+        h0 = self.state.hmass()
+        s0 = self.state.smass()
+        # Just a showcase for the different accessor methods
+        cycle_states[0, 'H'] = h0
+        cycle_states[0]['S'] = s0
+        cycle_states[0][CoolProp.iP] = p0
+        cycle_states[0, CoolProp.iT] = T0
+
+        # Pressurised vapour
+        p1 = p2
+        self.state.update(CoolProp.PSmass_INPUTS, p1, s0)
+        h1 = h0 + (self.state.hmass() - h0) / eta_com
+        self.state.update(CoolProp.HmassP_INPUTS, h1, p1)
+        s1 = self.state.smass()
+        T1 = self.state.T()
+        cycle_states[1, 'H'] = h1
+        cycle_states[1, 'S'] = s1
+        cycle_states[1, 'P'] = p1
+        cycle_states[1, 'T'] = T1
+
+        # Condensed vapour
+        self.state.update(CoolProp.PT_INPUTS, p2, T2)
+        h2 = self.state.hmass()
+        s2 = self.state.smass()
+        cycle_states[2, 'H'] = h2
+        cycle_states[2, 'S'] = s2
+        cycle_states[2, 'P'] = p2
+        cycle_states[2, 'T'] = T2
+
+        # Expanded fluid, 2-phase
+        p3 = p0
+        h3 = h2
+        self.state.update(CoolProp.HmassP_INPUTS, h3, p3)
+        s3 = self.state.smass()
+        T3 = self.state.T()
+        cycle_states[3, 'H'] = h3
+        cycle_states[3, 'S'] = s3
+        cycle_states[3, 'P'] = p3
+        cycle_states[3, 'T'] = T3
+
+        w_net = h0 - h1
+        q_evap = h0 - h3
+
+        self.cycle_states = cycle_states
+        self.fill_states()
+
+    def simple_solve_dt(self, Te, Tc, dT_sh, dT_sc, eta_com, fluid=None, SI=True):
+        """"
+        A simple vapour compression cycle calculation based on
+        superheat, subcooling and temperatures.
+
+        Parameters
+        ----------
+        Te : float
+            The evaporation temperature
+        Tc : float
+            The condensation temperature
+        dT_sh : float
+            The superheat after the evaporator
+        dT_sc : float
+            The subcooling after the condenser
+        eta_com : float
+            Isentropic compressor efficiency
+
+        Examples
+        --------
+        >>> import CoolProp
+        >>> from CoolProp.Plots import PropertyPlot
+        >>> from CoolProp.Plots import SimpleCompressionCycle
+        >>> pp = PropertyPlot('HEOS::R134a', 'PH', unit_system='EUR')
+        >>> pp.calc_isolines(CoolProp.iQ, num=11)
+        >>> cycle = SimpleCompressionCycle('HEOS::R134a', 'PH', unit_system='EUR')
+        >>> Te = 265
+        >>> Tc = 300
+        >>> cycle.simple_solve_dt(Te, Tc, 10, 15, 0.7, SI=True)
+        >>> cycle.steps = 50
+        >>> sc = cycle.get_state_changes()
+        >>> import matplotlib.pyplot as plt
+        >>> plt.close(cycle.figure)
+        >>> pp.draw_process(sc)
+        """
+        if fluid is not None:
+            self.state = process_fluid_state(fluid)
+        if self._state is None:
+            raise ValueError("You have to specify a fluid before you can calculate.")
+
+        if not SI:
+            conv_t = self._system[CoolProp.iT].to_SI
+            Te = conv_p(Te)
+            Tc = conv_p(Tc)
+
+        # Get the saturation conditions
+        self.state.update(CoolProp.QT_INPUTS, 1.0, Te)
+        p0 = self.state.p()
+        self.state.update(CoolProp.QT_INPUTS, 0.0, Tc)
+        p2 = self.state.p()
+
+        T0 = Te + dT_sh
+        T2 = Tc - dT_sc
+
+        self.simple_solve(T0, p0, T2, p2, eta_com, fluid=None, SI=True)
+
+    def COP_heating(self):
+        """COP for a heating process
+
+        Calculates the coefficient of performance for a heating process, :math:`COP_h = \frac{q_{con}}{w_{comp}}`.
+
+        Returns
+        -------
+        float
+        """
+        return (self.cycle_states[1, 'H'] - self.cycle_states[2, 'H']) / (self.cycle_states[1, 'H'] - self.cycle_states[0, 'H'])
+
+    def COP_cooling(self):
+        """COP for a cooling process
+
+        Calculates the coefficient of performance for a cooling process, :math:`COP_c = \frac{q_{eva}}{w_{comp}}`.
+
+        Returns
+        -------
+        float
+        """
+        return (self.cycle_states[0, 'H'] - self.cycle_states[3, 'H']) / (self.cycle_states[1, 'H'] - self.cycle_states[0, 'H'])
```

## CoolProp/Plots/SimpleCyclesExpansion.py

 * *Ordering differences only*

```diff
@@ -1,176 +1,176 @@
-# -*- coding: utf-8 -*-
-from __future__ import print_function, division, absolute_import
-
-import numpy as np
-
-import CoolProp
-from .Common import process_fluid_state
-from .SimpleCycles import BaseCycle, StateContainer
-
-
-class BasePowerCycle(BaseCycle):
-    """A thermodynamic cycle for power producing processes.
-
-    Defines the basic properties and methods to unify access to
-    power cycle-related quantities.
-    """
-
-    def __init__(self, fluid_ref='HEOS::Water', graph_type='TS', **kwargs):
-        """see :class:`CoolProp.Plots.SimpleCycles.BaseCycle` for details."""
-        BaseCycle.__init__(self, fluid_ref, graph_type, **kwargs)
-
-    def eta_carnot(self):
-        """Carnot efficiency
-
-        Calculates the Carnot efficiency for the specified process, :math:`\eta_c = 1 - \frac{T_c}{T_h}`.
-
-        Returns
-        -------
-        float
-        """
-        Tvector = self._cycle_states.T
-        return 1. - np.min(Tvector) / np.max(Tvector)
-
-    def eta_thermal(self):
-        """Thermal efficiency
-
-        The thermal efficiency for the specified process(es), :math:`\eta_{th} = \frac{\dot{W}_{exp} - \dot{W}_{pum}}{\dot{Q}_{in}}`.
-
-        Returns
-        -------
-        float
-        """
-        raise NotImplementedError("Implement it in the subclass.")
-
-
-class SimpleRankineCycle(BasePowerCycle):
-    """A simple Rankine cycle *without* regeneration"""
-    STATECOUNT = 4
-    STATECHANGE = [
-      lambda inp: BaseCycle.state_change(inp, 'S', 'P', 0, ty1='log', ty2='log'),  # Pumping process
-      lambda inp: BaseCycle.state_change(inp, 'H', 'P', 1, ty1='lin', ty2='lin'),  # Heat addition
-      lambda inp: BaseCycle.state_change(inp, 'H', 'P', 2, ty1='log', ty2='log'),  # Expansion
-      lambda inp: BaseCycle.state_change(inp, 'H', 'P', 3, ty1='lin', ty2='lin')  # Heat removal
-      ]
-
-    def __init__(self, fluid_ref='HEOS::Water', graph_type='TS', **kwargs):
-        """see :class:`CoolProp.Plots.SimpleCycles.BasePowerCycle` for details."""
-        BasePowerCycle.__init__(self, fluid_ref, graph_type, **kwargs)
-
-    def simple_solve(self, T0, p0, T2, p2, eta_exp, eta_pum, fluid=None, SI=True):
-        """"
-        A simple Rankine cycle calculation
-
-        Parameters
-        ----------
-        T0 : float
-            The coldest point, before the pump
-        p0 : float
-            The lowest pressure, before the pump
-        T2 : float
-            The hottest point, before the expander
-        p2 : float
-            The highest pressure, before the expander
-        eta_exp : float
-            Isentropic expander efficiency
-        eta_pum : float
-            Isentropic pump efficiency
-
-        Examples
-        --------
-        >>> import CoolProp
-        >>> from CoolProp.Plots import PropertyPlot
-        >>> from CoolProp.Plots import SimpleRankineCycle
-        >>> pp = PropertyPlot('HEOS::Water', 'TS', unit_system='EUR')
-        >>> pp.calc_isolines(CoolProp.iQ, num=11)
-        >>> cycle = SimpleRankineCycle('HEOS::Water', 'TS', unit_system='EUR')
-        >>> T0 = 300
-        >>> pp.state.update(CoolProp.QT_INPUTS,0.0,T0+15)
-        >>> p0 = pp.state.keyed_output(CoolProp.iP)
-        >>> T2 = 700
-        >>> pp.state.update(CoolProp.QT_INPUTS,1.0,T2-150)
-        >>> p2 = pp.state.keyed_output(CoolProp.iP)
-        >>> cycle.simple_solve(T0, p0, T2, p2, 0.7, 0.8, SI=True)
-        >>> cycle.steps = 50
-        >>> sc = cycle.get_state_changes()
-        >>> import matplotlib.pyplot as plt
-        >>> plt.close(cycle.figure)
-        >>> pp.draw_process(sc)
-
-        """
-        if fluid is not None: self.state = process_fluid_state(fluid)
-        if self._state is None:
-            raise ValueError("You have to specify a fluid before you can calculate.")
-
-        cycle_states = StateContainer(unit_system=self._system)
-
-        if not SI:
-            Tc = self._system[CoolProp.iT].to_SI
-            pc = self._system[CoolProp.iP].to_SI
-            T0 = Tc(T0)
-            p0 = pc(p0)
-            T2 = Tc(T2)
-            p2 = pc(p2)
-
-        # Subcooled liquid
-        self.state.update(CoolProp.PT_INPUTS, p0, T0)
-        h0 = self.state.hmass()
-        s0 = self.state.smass()
-        # Just a showcase for the different accessor methods
-        cycle_states[0, 'H'] = h0
-        cycle_states[0]['S'] = s0
-        cycle_states[0][CoolProp.iP] = p0
-        cycle_states[0, CoolProp.iT] = T0
-
-        # Pressurised liquid
-        p1 = p2
-        self.state.update(CoolProp.PSmass_INPUTS, p1, s0)
-        h1 = h0 + (self.state.hmass() - h0) / eta_pum
-        self.state.update(CoolProp.HmassP_INPUTS, h1, p1)
-        s1 = self.state.smass()
-        T1 = self.state.T()
-        cycle_states[1, 'H'] = h1
-        cycle_states[1, 'S'] = s1
-        cycle_states[1, 'P'] = p1
-        cycle_states[1, 'T'] = T1
-
-        # Evaporated vapour
-        self.state.update(CoolProp.PT_INPUTS, p2, T2)
-        h2 = self.state.hmass()
-        s2 = self.state.smass()
-        cycle_states[2, 'H'] = h2
-        cycle_states[2, 'S'] = s2
-        cycle_states[2, 'P'] = p2
-        cycle_states[2, 'T'] = T2
-
-        # Expanded gas
-        p3 = p0
-        self.state.update(CoolProp.PSmass_INPUTS, p3, s2)
-        h3 = h2 - eta_exp * (h2 - self.state.hmass())
-        self.state.update(CoolProp.HmassP_INPUTS, h3, p3)
-        s3 = self.state.smass()
-        T3 = self.state.T()
-        cycle_states[3, 'H'] = h3
-        cycle_states[3, 'S'] = s3
-        cycle_states[3, 'P'] = p3
-        cycle_states[3, 'T'] = T3
-
-        w_net = h2 - h3
-        q_boiler = h2 - h1
-        eta_th = w_net / q_boiler
-
-        self.cycle_states = cycle_states
-        self.fill_states()
-
-    def eta_thermal(self):
-        """Thermal efficiency
-
-        The thermal efficiency for the specified process(es), :math:`\eta_{th} = \frac{\dot{W}_{exp} - \dot{W}_{pum}}{\dot{Q}_{in}}`.
-
-        Returns
-        -------
-        float
-        """
-        w_net = self.cycle_states[2].H - self.cycle_states[3].H - (self.cycle_states[1].H - self.cycle_states[0].H)
-        q_boiler = self.cycle_states[2].H - self.cycle_states[1].H
-        return w_net / q_boiler
+# -*- coding: utf-8 -*-
+from __future__ import print_function, division, absolute_import
+
+import numpy as np
+
+import CoolProp
+from .Common import process_fluid_state
+from .SimpleCycles import BaseCycle, StateContainer
+
+
+class BasePowerCycle(BaseCycle):
+    """A thermodynamic cycle for power producing processes.
+
+    Defines the basic properties and methods to unify access to
+    power cycle-related quantities.
+    """
+
+    def __init__(self, fluid_ref='HEOS::Water', graph_type='TS', **kwargs):
+        """see :class:`CoolProp.Plots.SimpleCycles.BaseCycle` for details."""
+        BaseCycle.__init__(self, fluid_ref, graph_type, **kwargs)
+
+    def eta_carnot(self):
+        """Carnot efficiency
+
+        Calculates the Carnot efficiency for the specified process, :math:`\eta_c = 1 - \frac{T_c}{T_h}`.
+
+        Returns
+        -------
+        float
+        """
+        Tvector = self._cycle_states.T
+        return 1. - np.min(Tvector) / np.max(Tvector)
+
+    def eta_thermal(self):
+        """Thermal efficiency
+
+        The thermal efficiency for the specified process(es), :math:`\eta_{th} = \frac{\dot{W}_{exp} - \dot{W}_{pum}}{\dot{Q}_{in}}`.
+
+        Returns
+        -------
+        float
+        """
+        raise NotImplementedError("Implement it in the subclass.")
+
+
+class SimpleRankineCycle(BasePowerCycle):
+    """A simple Rankine cycle *without* regeneration"""
+    STATECOUNT = 4
+    STATECHANGE = [
+      lambda inp: BaseCycle.state_change(inp, 'S', 'P', 0, ty1='log', ty2='log'),  # Pumping process
+      lambda inp: BaseCycle.state_change(inp, 'H', 'P', 1, ty1='lin', ty2='lin'),  # Heat addition
+      lambda inp: BaseCycle.state_change(inp, 'H', 'P', 2, ty1='log', ty2='log'),  # Expansion
+      lambda inp: BaseCycle.state_change(inp, 'H', 'P', 3, ty1='lin', ty2='lin')  # Heat removal
+      ]
+
+    def __init__(self, fluid_ref='HEOS::Water', graph_type='TS', **kwargs):
+        """see :class:`CoolProp.Plots.SimpleCycles.BasePowerCycle` for details."""
+        BasePowerCycle.__init__(self, fluid_ref, graph_type, **kwargs)
+
+    def simple_solve(self, T0, p0, T2, p2, eta_exp, eta_pum, fluid=None, SI=True):
+        """"
+        A simple Rankine cycle calculation
+
+        Parameters
+        ----------
+        T0 : float
+            The coldest point, before the pump
+        p0 : float
+            The lowest pressure, before the pump
+        T2 : float
+            The hottest point, before the expander
+        p2 : float
+            The highest pressure, before the expander
+        eta_exp : float
+            Isentropic expander efficiency
+        eta_pum : float
+            Isentropic pump efficiency
+
+        Examples
+        --------
+        >>> import CoolProp
+        >>> from CoolProp.Plots import PropertyPlot
+        >>> from CoolProp.Plots import SimpleRankineCycle
+        >>> pp = PropertyPlot('HEOS::Water', 'TS', unit_system='EUR')
+        >>> pp.calc_isolines(CoolProp.iQ, num=11)
+        >>> cycle = SimpleRankineCycle('HEOS::Water', 'TS', unit_system='EUR')
+        >>> T0 = 300
+        >>> pp.state.update(CoolProp.QT_INPUTS,0.0,T0+15)
+        >>> p0 = pp.state.keyed_output(CoolProp.iP)
+        >>> T2 = 700
+        >>> pp.state.update(CoolProp.QT_INPUTS,1.0,T2-150)
+        >>> p2 = pp.state.keyed_output(CoolProp.iP)
+        >>> cycle.simple_solve(T0, p0, T2, p2, 0.7, 0.8, SI=True)
+        >>> cycle.steps = 50
+        >>> sc = cycle.get_state_changes()
+        >>> import matplotlib.pyplot as plt
+        >>> plt.close(cycle.figure)
+        >>> pp.draw_process(sc)
+
+        """
+        if fluid is not None: self.state = process_fluid_state(fluid)
+        if self._state is None:
+            raise ValueError("You have to specify a fluid before you can calculate.")
+
+        cycle_states = StateContainer(unit_system=self._system)
+
+        if not SI:
+            Tc = self._system[CoolProp.iT].to_SI
+            pc = self._system[CoolProp.iP].to_SI
+            T0 = Tc(T0)
+            p0 = pc(p0)
+            T2 = Tc(T2)
+            p2 = pc(p2)
+
+        # Subcooled liquid
+        self.state.update(CoolProp.PT_INPUTS, p0, T0)
+        h0 = self.state.hmass()
+        s0 = self.state.smass()
+        # Just a showcase for the different accessor methods
+        cycle_states[0, 'H'] = h0
+        cycle_states[0]['S'] = s0
+        cycle_states[0][CoolProp.iP] = p0
+        cycle_states[0, CoolProp.iT] = T0
+
+        # Pressurised liquid
+        p1 = p2
+        self.state.update(CoolProp.PSmass_INPUTS, p1, s0)
+        h1 = h0 + (self.state.hmass() - h0) / eta_pum
+        self.state.update(CoolProp.HmassP_INPUTS, h1, p1)
+        s1 = self.state.smass()
+        T1 = self.state.T()
+        cycle_states[1, 'H'] = h1
+        cycle_states[1, 'S'] = s1
+        cycle_states[1, 'P'] = p1
+        cycle_states[1, 'T'] = T1
+
+        # Evaporated vapour
+        self.state.update(CoolProp.PT_INPUTS, p2, T2)
+        h2 = self.state.hmass()
+        s2 = self.state.smass()
+        cycle_states[2, 'H'] = h2
+        cycle_states[2, 'S'] = s2
+        cycle_states[2, 'P'] = p2
+        cycle_states[2, 'T'] = T2
+
+        # Expanded gas
+        p3 = p0
+        self.state.update(CoolProp.PSmass_INPUTS, p3, s2)
+        h3 = h2 - eta_exp * (h2 - self.state.hmass())
+        self.state.update(CoolProp.HmassP_INPUTS, h3, p3)
+        s3 = self.state.smass()
+        T3 = self.state.T()
+        cycle_states[3, 'H'] = h3
+        cycle_states[3, 'S'] = s3
+        cycle_states[3, 'P'] = p3
+        cycle_states[3, 'T'] = T3
+
+        w_net = h2 - h3
+        q_boiler = h2 - h1
+        eta_th = w_net / q_boiler
+
+        self.cycle_states = cycle_states
+        self.fill_states()
+
+    def eta_thermal(self):
+        """Thermal efficiency
+
+        The thermal efficiency for the specified process(es), :math:`\eta_{th} = \frac{\dot{W}_{exp} - \dot{W}_{pum}}{\dot{Q}_{in}}`.
+
+        Returns
+        -------
+        float
+        """
+        w_net = self.cycle_states[2].H - self.cycle_states[3].H - (self.cycle_states[1].H - self.cycle_states[0].H)
+        q_boiler = self.cycle_states[2].H - self.cycle_states[1].H
+        return w_net / q_boiler
```

## CoolProp/Plots/Tests.py

 * *Ordering differences only*

```diff
@@ -1,19 +1,19 @@
-# -*- coding: utf-8 -*-
-from __future__ import print_function, division, absolute_import
-
-from CoolProp.Plots import PropertyPlot  # TODO: Change to absolute import
-
-
-def main():
-    fluid_ref = 'n-Pentane'
-    for plot_type in ['Ts']:  # ['pt', 'ph', 'ps', 'ts', 'pt', 'prho', 'trho']:
-        plt = PropertyPlot(fluid_ref, plot_type)
-        plt.set_axis_limits([-0.5 * 1e3, 1.5 * 1e3, 300, 530])
-        plt.draw_isolines('Q', [0.1, 0.9])
-        plt.draw_isolines('P', [100 * 1e3, 2000 * 1e3])
-        plt.draw_isolines('D', [2, 600])
-        plt.show()
-
-
-if __name__ == "__main__":
-    main()
+# -*- coding: utf-8 -*-
+from __future__ import print_function, division, absolute_import
+
+from CoolProp.Plots import PropertyPlot  # TODO: Change to absolute import
+
+
+def main():
+    fluid_ref = 'n-Pentane'
+    for plot_type in ['Ts']:  # ['pt', 'ph', 'ps', 'ts', 'pt', 'prho', 'trho']:
+        plt = PropertyPlot(fluid_ref, plot_type)
+        plt.set_axis_limits([-0.5 * 1e3, 1.5 * 1e3, 300, 530])
+        plt.draw_isolines('Q', [0.1, 0.9])
+        plt.draw_isolines('P', [100 * 1e3, 2000 * 1e3])
+        plt.draw_isolines('D', [2, 600])
+        plt.show()
+
+
+if __name__ == "__main__":
+    main()
```

## CoolProp/Plots/__init__.py

 * *Ordering differences only*

```diff
@@ -1,18 +1,18 @@
-# -*- coding: utf-8 -*-
-from __future__ import print_function, division, absolute_import
-
-# Bring some functions into the Plots namespace for code concision,
-# but be careful not to clutter the namespace with too many
-# classes and functions.
-
-# Plotting objects and functions
-from .Plots import PropertyPlot
-from .Common import IsoLine
-
-# Cycle calculation and drawing
-from .SimpleCycles import StateContainer
-from .SimpleCyclesExpansion import SimpleRankineCycle
-from .SimpleCyclesCompression import SimpleCompressionCycle
-
-# Old and deprecated objects
-from .SimpleCycles import SimpleCycle, TwoStage, EconomizedCycle
+# -*- coding: utf-8 -*-
+from __future__ import print_function, division, absolute_import
+
+# Bring some functions into the Plots namespace for code concision,
+# but be careful not to clutter the namespace with too many
+# classes and functions.
+
+# Plotting objects and functions
+from .Plots import PropertyPlot
+from .Common import IsoLine
+
+# Cycle calculation and drawing
+from .SimpleCycles import StateContainer
+from .SimpleCyclesExpansion import SimpleRankineCycle
+from .SimpleCyclesCompression import SimpleCompressionCycle
+
+# Old and deprecated objects
+from .SimpleCycles import SimpleCycle, TwoStage, EconomizedCycle
```

## CoolProp/Plots/psy.py

 * *Ordering differences only*

```diff
@@ -1,508 +1,508 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-
-import os
-import cPickle
-from ConfigParser import ConfigParser
-
-import numpy as np
-
-from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg
-from pylab import Figure
-
-from CoolProp.HumidAirProp import HAProps, HAProps_Aux
-
-from PyQt4.QtGui import (QDialog, QGridLayout, QProgressBar, QLabel,
-                         QDialogButtonBox, QPushButton, QFileDialog, QApplication)
-
-Preferences = ConfigParser()
-config_path = os.path.join(os.path.dirname(__file__), "psyrc")
-Preferences.read(config_path)
-P = Preferences.getfloat("General", "P")
-
-
-def _Pbar(Z):
-    """
-    ASHRAE Fundamentals Handbook pag 1.1 eq. 3
-    input:
-        Z: altitude, m
-    return
-        standard atmosphere barometric pressure, Pa
-    """
-    return 101325. * (1 - 2.25577e-5 * Z)**5.256
-
-
-class PsychroPlot(FigureCanvasQTAgg):
-    """
-    Plot widget for psychrometric chart
-        Add custom margins
-        Define a pointer to text state properties, to remove and redraw
-    """
-
-    def __init__(self, parent=None, width=15, height=5, dpi=100):
-        self.fig = Figure(figsize=(width, height), dpi=dpi)
-        FigureCanvasQTAgg.__init__(self, self.fig)
-        self.setParent(parent)
-        self.axes2D = self.fig.add_subplot(111)
-        FigureCanvasQTAgg.updateGeometry(self)
-        self.axes2D.figure.subplots_adjust(left=0.01, right=0.92,
-                                           bottom=0.05, top=0.98)
-        self.notes = []
-
-    def plot(self, *args, **kwargs):
-        self.axes2D.plot(*args, **kwargs)
-
-    def config(self):
-        self.axes2D.set_autoscale_on(False)
-        self.axes2D.set_xlabel(u"Tdb, ºC")
-        self.axes2D.set_ylabel("Absolute humidity, kg/kg")
-        self.axes2D.yaxis.set_ticks_position("right")
-        self.axes2D.yaxis.set_label_position("right")
-
-        tmin = Preferences.getfloat("Psychr", "isotdbStart") - 273.15
-        tmax = Preferences.getfloat("Psychr", "isotdbEnd") - 273.15
-
-        self.axes2D.set_xlim(tmin, tmax)
-        self.axes2D.set_ylim(0, 0.04)
-
-    def showPointData(self, state):
-        self.clearPointData()
-
-        yi = 0.99
-        keys = "tdb", "tdp", "twb", "HR", "w", "h", "v", "rho"
-        units = u"ºC", u"ºC", u"ºC", "%", "kgw/kgda", "kJ/kg", u"m³/kg", u"kg/m³"
-        for key, txt in zip(keys, units):
-            self.notes.append(self.axes2D.annotate(
-                "%s: %0.4f %s" % (key, state.__getattribute__(key), txt), (0.01, yi),
-                xycoords='axes fraction', size="small", va="center"))
-            yi -= 0.025
-        self.draw()
-
-    def clearPointData(self):
-        while self.notes:
-            anotation = self.notes.pop()
-            anotation.remove()
-        self.draw()
-
-
-class PsyCoolprop(object):
-    """
-    Psychrometric state using coolprop library
-
-    kwargs definition parameters:
-        P: Pressure, Pa
-        z: altitude, m
-
-        tdp: dew-point temperature
-        tdb: dry-bulb temperature
-        twb: web-bulb temperature
-        w: Humidity Ratio [kg water/kg dry air]
-        HR: Relative humidity
-        h: Mixture enthalpy
-        v: Mixture specified volume
-
-    P: mandatory input for barometric pressure, z is an alternate pressure input
-    it needs other two input parameters:
-        0 - tdb, w
-        1 - tdb, HR
-        2 - tdb, twb
-        3 - tdb, tdp
-        4 - tdp, HR
-        5 - tdp, twb
-        6 - twb, w
-    """
-    kwargs = {"z": 0.0,
-              "P": 0.0,
-
-              "tdb": 0.0,
-              "tdb": 0.0,
-              "twb": 0.0,
-              "w": None,
-              "HR": None,
-              "h": None,
-              "v": 0.0}
-    status = 0
-    msg = "Unknown variables"
-
-    def __init__(self, **kwargs):
-        self.kwargs = self.__class__.kwargs.copy()
-        self.__call__(**kwargs)
-
-    def __call__(self, **kwargs):
-        self.kwargs.update(kwargs)
-
-        if self.calculable:
-            self.status = 1
-            self.calculo()
-            self.msg = "Solved"
-
-    @property
-    def calculable(self):
-        tdp = self.kwargs.get("tdp", 0)
-        tdb = self.kwargs.get("tdb", 0)
-        twb = self.kwargs.get("twb", 0)
-        w = self.kwargs.get("w", None)
-        HR = self.kwargs.get("HR", None)
-        h = self.kwargs.get("h", None)
-        v = self.kwargs.get("v", 0)
-
-        self._mode = 0
-        if tdb and w is not None:
-            self._mode = ("Tdb", "W")
-        elif tdb and HR is not None:
-            self._mode = ("Tdb", "RH")
-        elif tdb and twb:
-            self._mode = ("Tdb", "Twb")
-        elif tdb and tdp:
-            self._mode = ("Tdb", "Tdp")
-        elif tdp and HR is not None:
-            self._mode = ("Tdp", "RH")
-
-        return bool(self._mode)
-
-    def calculo(self):
-        tdp, tdb, twb, P, Pvs, Pv, ws, w, HR, v, h = self._lib()
-        self.tdp = tdp - 273.15
-        self.tdb = tdb - 273.15
-        self.twb = twb - 273.15
-        self.P = P
-        self.Pvs = Pvs
-        self.Pv = Pv
-        self.ws = ws
-        self.w = w
-        self.HR = HR
-        self.mu = w / ws * 100
-        self.v = v
-        self.rho = 1 / v
-        self.h = h
-        self.Xa = 1 / (1 + self.w / 0.62198)
-        self.Xw = 1 - self.Xa
-
-    def args(self):
-        # Correct coolprop custom namespace versus pychemqt namespace
-        if "Tdb" in self._mode:
-            self.kwargs["Tdb"] = self.kwargs["tdb"]
-        if "Twb" in self._mode:
-            self.kwargs["Twb"] = self.kwargs["twb"]
-        if "Tdp" in self._mode:
-            self.kwargs["Tdp"] = self.kwargs["tdp"]
-        if "RH" in self._mode:
-            self.kwargs["RH"] = self.kwargs["HR"]
-        if "W" in self._mode:
-            self.kwargs["W"] = self.kwargs["w"]
-
-        var1 = self.kwargs[self._mode[0]]
-        var2 = self.kwargs[self._mode[1]]
-
-        # units conversion to coolprop expected unit:
-        # HR in 0-1, H in kJ/kg, S in kJ/kgK
-        if "RH" in self._mode[0]:
-            var1 /= 100.
-        if "RH" in self._mode[1]:
-            var2 /= 100.
-
-        args = ("P", self._P_kPa, self._mode[0], var1, self._mode[1], var2)
-        return args
-
-    def _P(self):
-        """Barometric pressure calculation, Pa"""
-        if self.kwargs["P"]:
-            P = self.kwargs["P"]
-        elif self.kwargs["z"]:
-            P = _Pbar(self.kwargs["z"])
-        else:
-            P = 101325.
-        return P
-
-    @property
-    def _P_kPa(self):
-        """Property for ease access to pressure in kPa"""
-        P = self._P()
-        return P / 1000.
-
-    def _lib(self):
-        args = self.args()
-        P = self._P()
-
-        if "Tdb" in self._mode:
-            tdb = self.kwargs["Tdb"]
-        else:
-            tdb = HAProps("Tdb", *args)
-        tdp = HAProps("Tdp", *args)
-        twb = HAProps("Twb", *args)
-        w = HAProps("W", *args)
-        HR = HAProps("RH", *args) * 100
-        Pvs = HAProps_Aux("p_ws", tdb, self._P_kPa, w)[0] * 1000
-        Pv = Pvs * HR / 100
-        ws = HAProps("W", "P", self._P_kPa, "Tdb", tdb, "RH", 1)
-        v = HAProps("V", *args)
-        h = HAProps("H", *args)
-
-        return tdp, tdb, twb, P, Pvs, Pv, ws, w, HR, v, h
-
-    @classmethod
-    def calculatePlot(cls, parent):
-        """Function to calculate points in chart"""
-
-        data = {}
-        P = Preferences.getfloat("General", "P")
-        P_kPa = P / 1000
-        t = cls.LineList("isotdb", Preferences)
-
-        # Saturation line
-        Hs = []
-        for tdb in t:
-            Hs.append(HAProps("W", "P", P_kPa, "Tdb", tdb, "RH", 1))
-            parent.progressBar.setValue(5 * len(Hs) / len(t))
-        data["t"] = t
-        data["Hs"] = Hs
-
-        # left limit of isow lines
-        H = cls.LineList("isow", Preferences)
-        th = []
-        for w in H:
-            if w:
-                tdp = HAProps("Tdp", "P", 101.325, "W", w, "RH", 1)
-                th.append(tdp - 273.15)
-            else:
-                tmin = Preferences.getfloat("Psychr", "isotdbStart")
-                th.append(tmin - 273.15)
-        data["H"] = H
-        data["th"] = th
-
-        # Humidity ratio lines
-        hr = cls.LineList("isohr", Preferences)
-        Hr = {}
-        cont = 0
-        for i in hr:
-            Hr[i] = []
-            for tdb in t:
-                Hr[i].append(HAProps("W", "P", P_kPa, "Tdb", tdb, "RH", i / 100.))
-                cont += 1
-                parent.progressBar.setValue(5 + 10 * cont / len(hr) / len(Hs))
-        data["Hr"] = Hr
-
-        # Twb
-        lines = cls.LineList("isotwb", Preferences)
-        Twb = {}
-        cont = 0
-        for T in lines:
-            ws = HAProps("W", "P", P_kPa, "RH", 1, "Tdb", T)
-            H = [ws, 0]
-            Tw = [T - 273.15, HAProps("Tdb", "P", P_kPa, "Twb", T, "RH", 0) - 273.15]
-            cont += 1
-            parent.progressBar.setValue(15 + 75 * cont / len(lines))
-            Twb[T] = (H, Tw)
-        data["Twb"] = Twb
-
-        # v
-        lines = cls.LineList("isochor", Preferences)
-        V = {}
-        rh = np.arange(1, -0.05, -0.05)
-        for cont, v in enumerate(lines):
-            w = []
-            Td = []
-            for r in rh:
-                w.append(HAProps("W", "P", P_kPa, "RH", r, "V", v))
-                Td.append(HAProps("Tdb", "P", P_kPa, "RH", r, "V", v) - 273.15)
-            parent.progressBar.setValue(90 + 10 * cont / len(lines))
-            V[v] = (Td, w)
-        data["v"] = V
-
-        return data
-
-    @staticmethod
-    def LineList(name, Preferences):
-        """Return a list with the values of isoline name to plot"""
-        if Preferences.getboolean("Psychr", name + "Custom"):
-            t = []
-            for i in Preferences.get("Psychr", name + 'List').split(','):
-                if i:
-                    t.append(float(i))
-        else:
-            start = Preferences.getfloat("Psychr", name + "Start")
-            end = Preferences.getfloat("Psychr", name + "End")
-            step = Preferences.getfloat("Psychr", name + "Step")
-            t = np.arange(start, end, step)
-        return t
-
-
-class UI_Psychrometry(QDialog):
-    """Psychrometric charts tool"""
-
-    def __init__(self, parent=None):
-        super(UI_Psychrometry, self).__init__(parent)
-        self.showMaximized()
-        self.setWindowTitle("Psychrometric chart")
-
-        layout = QGridLayout(self)
-        self.diagrama2D = PsychroPlot(self, dpi=90)
-        self.diagrama2D.fig.canvas.mpl_connect('motion_notify_event', self.scroll)
-        layout.addWidget(self.diagrama2D, 1, 1, 1, 2)
-        self.progressBar = QProgressBar()
-        self.progressBar.setVisible(False)
-        layout.addWidget(self.progressBar, 2, 1)
-        self.status = QLabel()
-        layout.addWidget(self.status, 2, 1)
-
-        self.buttonBox = QDialogButtonBox(QDialogButtonBox.Close)
-        butonPNG = QPushButton("Save as PNG")
-        self.buttonBox.addButton(butonPNG, QDialogButtonBox.AcceptRole)
-        self.buttonBox.rejected.connect(self.reject)
-        self.buttonBox.accepted.connect(self.savePNG)
-        layout.addWidget(self.buttonBox, 2, 2)
-
-        self.plot()
-
-    def savePNG(self):
-        """Save chart image to png file"""
-        fname = unicode(QFileDialog.getSaveFileName(
-            self, "Save chart to file",
-            "./", "Portable Network Graphics (*.png)"))
-        self.diagrama2D.fig.savefig(fname, facecolor='#eeeeee')
-
-    def drawlabel(self, name, Preferences, t, W, label, unit):
-        """
-        Draw annotation for isolines
-            name: name of isoline
-            Preferences: Configparse instance of pychemqt preferences
-            t: x array of line
-            W: y array of line
-            label: text value to draw
-            unit: text units to draw
-        """
-        if Preferences.getboolean("Psychr", name + "label"):
-            tmin = Preferences.getfloat("Psychr", "isotdbStart") - 273.15
-            tmax = Preferences.getfloat("Psychr", "isotdbEnd") - 273.15
-            x = tmax - tmin
-            wmin = Preferences.getfloat("Psychr", "isowStart")
-            wmax = Preferences.getfloat("Psychr", "isowEnd")
-            y = wmax - wmin
-
-            i = 0
-            for ti, wi in zip(t, W):
-                if tmin <= ti <= tmax and wmin <= wi <= wmax:
-                    i += 1
-            label = str(label)
-            if Preferences.getboolean("Psychr", name + "units"):
-                label += unit
-            pos = Preferences.getfloat("Psychr", name + "position")
-            p = int(i * pos / 100 - 1)
-            rot = np.arctan((W[p] - W[p - 1]) / y / (t[p] - t[p - 1]) * x) * 360.0 / 2.0 / np.pi
-            self.diagrama2D.axes2D.annotate(label, (t[p], W[p]),
-                rotation=rot, size="small", ha="center", va="center")
-
-    def plot(self):
-        """Plot chart"""
-        Preferences = ConfigParser()
-        Preferences.read("psyrc")
-
-        self.diagrama2D.axes2D.clear()
-        self.diagrama2D.config()
-        filename = "%i.pkl" % P
-        if os.path.isfile(filename):
-            with open(filename, "r") as archivo:
-                data = cPickle.load(archivo)
-                self.status.setText("Loading cached data...")
-                QApplication.processEvents()
-        else:
-            self.progressBar.setVisible(True)
-            self.status.setText("Calculating data, be patient...")
-            QApplication.processEvents()
-            data = PsyCoolprop.calculatePlot(self)
-            cPickle.dump(data, open(filename, "w"))
-            self.progressBar.setVisible(False)
-        self.status.setText("Plotting...")
-        QApplication.processEvents()
-
-        tmax = Preferences.getfloat("Psychr", "isotdbEnd") - 273.15
-
-        t = [ti - 273.15 for ti in data["t"]]
-        Hs = data["Hs"]
-        format = {}
-        format["ls"] = Preferences.get("Psychr", "saturationlineStyle")
-        format["lw"] = Preferences.getfloat("Psychr", "saturationlineWidth")
-        format["color"] = Preferences.get("Psychr", "saturationColor")
-        format["marker"] = Preferences.get("Psychr", "saturationmarker")
-        format["markersize"] = 3
-        self.diagrama2D.plot(t, Hs, **format)
-
-        format = {}
-        format["ls"] = Preferences.get("Psychr", "isotdblineStyle")
-        format["lw"] = Preferences.getfloat("Psychr", "isotdblineWidth")
-        format["color"] = Preferences.get("Psychr", "isotdbColor")
-        format["marker"] = Preferences.get("Psychr", "isotdbmarker")
-        format["markersize"] = 3
-        for i, T in enumerate(t):
-            self.diagrama2D.plot([T, T], [0, Hs[i]], **format)
-
-        H = data["H"]
-        th = data["th"]
-        format = {}
-        format["ls"] = Preferences.get("Psychr", "isowlineStyle")
-        format["lw"] = Preferences.getfloat("Psychr", "isowlineWidth")
-        format["color"] = Preferences.get("Psychr", "isowColor")
-        format["marker"] = Preferences.get("Psychr", "isowmarker")
-        format["markersize"] = 3
-        for i, H in enumerate(H):
-            self.diagrama2D.plot([th[i], tmax], [H, H], **format)
-
-        format = {}
-        format["ls"] = Preferences.get("Psychr", "isohrlineStyle")
-        format["lw"] = Preferences.getfloat("Psychr", "isohrlineWidth")
-        format["color"] = Preferences.get("Psychr", "isohrColor")
-        format["marker"] = Preferences.get("Psychr", "isohrmarker")
-        format["markersize"] = 3
-        for Hr, H0 in data["Hr"].iteritems():
-            self.diagrama2D.plot(t, H0, **format)
-            self.drawlabel("isohr", Preferences, t, H0, Hr, "%")
-
-        format = {}
-        format["ls"] = Preferences.get("Psychr", "isotwblineStyle")
-        format["lw"] = Preferences.getfloat("Psychr", "isotwblineWidth")
-        format["color"] = Preferences.get("Psychr", "isotwbColor")
-        format["marker"] = Preferences.get("Psychr", "isotwbmarker")
-        format["markersize"] = 3
-        for T, (H, Tw) in data["Twb"].iteritems():
-            self.diagrama2D.plot(Tw, H, **format)
-            value = T - 273.15
-            txt = u"ºC"
-            self.drawlabel("isotwb", Preferences, Tw, H, value, txt)
-
-        format = {}
-        format["ls"] = Preferences.get("Psychr", "isochorlineStyle")
-        format["lw"] = Preferences.getfloat("Psychr", "isochorlineWidth")
-        format["color"] = Preferences.get("Psychr", "isochorColor")
-        format["marker"] = Preferences.get("Psychr", "isochormarker")
-        format["markersize"] = 3
-        for v, (Td, H) in data["v"].iteritems():
-            self.diagrama2D.plot(Td, H, **format)
-            value = v
-            txt = u"m³/kg"
-            self.drawlabel("isochor", Preferences, Td, H, value, txt)
-
-        self.diagrama2D.draw()
-        self.status.setText("P = %i Pa" % P)
-
-    def scroll(self, event):
-        """Update graph annotate when mouse scroll over chart"""
-        if event.xdata and event.ydata:
-            punto = self.createState(event.xdata, event.ydata)
-            if event.ydata < punto.ws:
-                self.diagrama2D.showPointData(punto)
-            else:
-                self.diagrama2D.clearPointData()
-
-    def createState(self, x, y):
-        """Create psychrometric state from click or mouse position"""
-        tdb = x + 273.15
-        punto = PsyCoolprop(P=P, tdb=tdb, w=y)
-        return punto
-
-
-if __name__ == "__main__":
-    import sys
-    app = QApplication(sys.argv)
-    aireHumedo = UI_Psychrometry()
-    aireHumedo.show()
-    sys.exit(app.exec_())
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+
+import os
+import cPickle
+from ConfigParser import ConfigParser
+
+import numpy as np
+
+from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg
+from pylab import Figure
+
+from CoolProp.HumidAirProp import HAProps, HAProps_Aux
+
+from PyQt4.QtGui import (QDialog, QGridLayout, QProgressBar, QLabel,
+                         QDialogButtonBox, QPushButton, QFileDialog, QApplication)
+
+Preferences = ConfigParser()
+config_path = os.path.join(os.path.dirname(__file__), "psyrc")
+Preferences.read(config_path)
+P = Preferences.getfloat("General", "P")
+
+
+def _Pbar(Z):
+    """
+    ASHRAE Fundamentals Handbook pag 1.1 eq. 3
+    input:
+        Z: altitude, m
+    return
+        standard atmosphere barometric pressure, Pa
+    """
+    return 101325. * (1 - 2.25577e-5 * Z)**5.256
+
+
+class PsychroPlot(FigureCanvasQTAgg):
+    """
+    Plot widget for psychrometric chart
+        Add custom margins
+        Define a pointer to text state properties, to remove and redraw
+    """
+
+    def __init__(self, parent=None, width=15, height=5, dpi=100):
+        self.fig = Figure(figsize=(width, height), dpi=dpi)
+        FigureCanvasQTAgg.__init__(self, self.fig)
+        self.setParent(parent)
+        self.axes2D = self.fig.add_subplot(111)
+        FigureCanvasQTAgg.updateGeometry(self)
+        self.axes2D.figure.subplots_adjust(left=0.01, right=0.92,
+                                           bottom=0.05, top=0.98)
+        self.notes = []
+
+    def plot(self, *args, **kwargs):
+        self.axes2D.plot(*args, **kwargs)
+
+    def config(self):
+        self.axes2D.set_autoscale_on(False)
+        self.axes2D.set_xlabel(u"Tdb, ºC")
+        self.axes2D.set_ylabel("Absolute humidity, kg/kg")
+        self.axes2D.yaxis.set_ticks_position("right")
+        self.axes2D.yaxis.set_label_position("right")
+
+        tmin = Preferences.getfloat("Psychr", "isotdbStart") - 273.15
+        tmax = Preferences.getfloat("Psychr", "isotdbEnd") - 273.15
+
+        self.axes2D.set_xlim(tmin, tmax)
+        self.axes2D.set_ylim(0, 0.04)
+
+    def showPointData(self, state):
+        self.clearPointData()
+
+        yi = 0.99
+        keys = "tdb", "tdp", "twb", "HR", "w", "h", "v", "rho"
+        units = u"ºC", u"ºC", u"ºC", "%", "kgw/kgda", "kJ/kg", u"m³/kg", u"kg/m³"
+        for key, txt in zip(keys, units):
+            self.notes.append(self.axes2D.annotate(
+                "%s: %0.4f %s" % (key, state.__getattribute__(key), txt), (0.01, yi),
+                xycoords='axes fraction', size="small", va="center"))
+            yi -= 0.025
+        self.draw()
+
+    def clearPointData(self):
+        while self.notes:
+            anotation = self.notes.pop()
+            anotation.remove()
+        self.draw()
+
+
+class PsyCoolprop(object):
+    """
+    Psychrometric state using coolprop library
+
+    kwargs definition parameters:
+        P: Pressure, Pa
+        z: altitude, m
+
+        tdp: dew-point temperature
+        tdb: dry-bulb temperature
+        twb: web-bulb temperature
+        w: Humidity Ratio [kg water/kg dry air]
+        HR: Relative humidity
+        h: Mixture enthalpy
+        v: Mixture specified volume
+
+    P: mandatory input for barometric pressure, z is an alternate pressure input
+    it needs other two input parameters:
+        0 - tdb, w
+        1 - tdb, HR
+        2 - tdb, twb
+        3 - tdb, tdp
+        4 - tdp, HR
+        5 - tdp, twb
+        6 - twb, w
+    """
+    kwargs = {"z": 0.0,
+              "P": 0.0,
+
+              "tdb": 0.0,
+              "tdb": 0.0,
+              "twb": 0.0,
+              "w": None,
+              "HR": None,
+              "h": None,
+              "v": 0.0}
+    status = 0
+    msg = "Unknown variables"
+
+    def __init__(self, **kwargs):
+        self.kwargs = self.__class__.kwargs.copy()
+        self.__call__(**kwargs)
+
+    def __call__(self, **kwargs):
+        self.kwargs.update(kwargs)
+
+        if self.calculable:
+            self.status = 1
+            self.calculo()
+            self.msg = "Solved"
+
+    @property
+    def calculable(self):
+        tdp = self.kwargs.get("tdp", 0)
+        tdb = self.kwargs.get("tdb", 0)
+        twb = self.kwargs.get("twb", 0)
+        w = self.kwargs.get("w", None)
+        HR = self.kwargs.get("HR", None)
+        h = self.kwargs.get("h", None)
+        v = self.kwargs.get("v", 0)
+
+        self._mode = 0
+        if tdb and w is not None:
+            self._mode = ("Tdb", "W")
+        elif tdb and HR is not None:
+            self._mode = ("Tdb", "RH")
+        elif tdb and twb:
+            self._mode = ("Tdb", "Twb")
+        elif tdb and tdp:
+            self._mode = ("Tdb", "Tdp")
+        elif tdp and HR is not None:
+            self._mode = ("Tdp", "RH")
+
+        return bool(self._mode)
+
+    def calculo(self):
+        tdp, tdb, twb, P, Pvs, Pv, ws, w, HR, v, h = self._lib()
+        self.tdp = tdp - 273.15
+        self.tdb = tdb - 273.15
+        self.twb = twb - 273.15
+        self.P = P
+        self.Pvs = Pvs
+        self.Pv = Pv
+        self.ws = ws
+        self.w = w
+        self.HR = HR
+        self.mu = w / ws * 100
+        self.v = v
+        self.rho = 1 / v
+        self.h = h
+        self.Xa = 1 / (1 + self.w / 0.62198)
+        self.Xw = 1 - self.Xa
+
+    def args(self):
+        # Correct coolprop custom namespace versus pychemqt namespace
+        if "Tdb" in self._mode:
+            self.kwargs["Tdb"] = self.kwargs["tdb"]
+        if "Twb" in self._mode:
+            self.kwargs["Twb"] = self.kwargs["twb"]
+        if "Tdp" in self._mode:
+            self.kwargs["Tdp"] = self.kwargs["tdp"]
+        if "RH" in self._mode:
+            self.kwargs["RH"] = self.kwargs["HR"]
+        if "W" in self._mode:
+            self.kwargs["W"] = self.kwargs["w"]
+
+        var1 = self.kwargs[self._mode[0]]
+        var2 = self.kwargs[self._mode[1]]
+
+        # units conversion to coolprop expected unit:
+        # HR in 0-1, H in kJ/kg, S in kJ/kgK
+        if "RH" in self._mode[0]:
+            var1 /= 100.
+        if "RH" in self._mode[1]:
+            var2 /= 100.
+
+        args = ("P", self._P_kPa, self._mode[0], var1, self._mode[1], var2)
+        return args
+
+    def _P(self):
+        """Barometric pressure calculation, Pa"""
+        if self.kwargs["P"]:
+            P = self.kwargs["P"]
+        elif self.kwargs["z"]:
+            P = _Pbar(self.kwargs["z"])
+        else:
+            P = 101325.
+        return P
+
+    @property
+    def _P_kPa(self):
+        """Property for ease access to pressure in kPa"""
+        P = self._P()
+        return P / 1000.
+
+    def _lib(self):
+        args = self.args()
+        P = self._P()
+
+        if "Tdb" in self._mode:
+            tdb = self.kwargs["Tdb"]
+        else:
+            tdb = HAProps("Tdb", *args)
+        tdp = HAProps("Tdp", *args)
+        twb = HAProps("Twb", *args)
+        w = HAProps("W", *args)
+        HR = HAProps("RH", *args) * 100
+        Pvs = HAProps_Aux("p_ws", tdb, self._P_kPa, w)[0] * 1000
+        Pv = Pvs * HR / 100
+        ws = HAProps("W", "P", self._P_kPa, "Tdb", tdb, "RH", 1)
+        v = HAProps("V", *args)
+        h = HAProps("H", *args)
+
+        return tdp, tdb, twb, P, Pvs, Pv, ws, w, HR, v, h
+
+    @classmethod
+    def calculatePlot(cls, parent):
+        """Function to calculate points in chart"""
+
+        data = {}
+        P = Preferences.getfloat("General", "P")
+        P_kPa = P / 1000
+        t = cls.LineList("isotdb", Preferences)
+
+        # Saturation line
+        Hs = []
+        for tdb in t:
+            Hs.append(HAProps("W", "P", P_kPa, "Tdb", tdb, "RH", 1))
+            parent.progressBar.setValue(5 * len(Hs) / len(t))
+        data["t"] = t
+        data["Hs"] = Hs
+
+        # left limit of isow lines
+        H = cls.LineList("isow", Preferences)
+        th = []
+        for w in H:
+            if w:
+                tdp = HAProps("Tdp", "P", 101.325, "W", w, "RH", 1)
+                th.append(tdp - 273.15)
+            else:
+                tmin = Preferences.getfloat("Psychr", "isotdbStart")
+                th.append(tmin - 273.15)
+        data["H"] = H
+        data["th"] = th
+
+        # Humidity ratio lines
+        hr = cls.LineList("isohr", Preferences)
+        Hr = {}
+        cont = 0
+        for i in hr:
+            Hr[i] = []
+            for tdb in t:
+                Hr[i].append(HAProps("W", "P", P_kPa, "Tdb", tdb, "RH", i / 100.))
+                cont += 1
+                parent.progressBar.setValue(5 + 10 * cont / len(hr) / len(Hs))
+        data["Hr"] = Hr
+
+        # Twb
+        lines = cls.LineList("isotwb", Preferences)
+        Twb = {}
+        cont = 0
+        for T in lines:
+            ws = HAProps("W", "P", P_kPa, "RH", 1, "Tdb", T)
+            H = [ws, 0]
+            Tw = [T - 273.15, HAProps("Tdb", "P", P_kPa, "Twb", T, "RH", 0) - 273.15]
+            cont += 1
+            parent.progressBar.setValue(15 + 75 * cont / len(lines))
+            Twb[T] = (H, Tw)
+        data["Twb"] = Twb
+
+        # v
+        lines = cls.LineList("isochor", Preferences)
+        V = {}
+        rh = np.arange(1, -0.05, -0.05)
+        for cont, v in enumerate(lines):
+            w = []
+            Td = []
+            for r in rh:
+                w.append(HAProps("W", "P", P_kPa, "RH", r, "V", v))
+                Td.append(HAProps("Tdb", "P", P_kPa, "RH", r, "V", v) - 273.15)
+            parent.progressBar.setValue(90 + 10 * cont / len(lines))
+            V[v] = (Td, w)
+        data["v"] = V
+
+        return data
+
+    @staticmethod
+    def LineList(name, Preferences):
+        """Return a list with the values of isoline name to plot"""
+        if Preferences.getboolean("Psychr", name + "Custom"):
+            t = []
+            for i in Preferences.get("Psychr", name + 'List').split(','):
+                if i:
+                    t.append(float(i))
+        else:
+            start = Preferences.getfloat("Psychr", name + "Start")
+            end = Preferences.getfloat("Psychr", name + "End")
+            step = Preferences.getfloat("Psychr", name + "Step")
+            t = np.arange(start, end, step)
+        return t
+
+
+class UI_Psychrometry(QDialog):
+    """Psychrometric charts tool"""
+
+    def __init__(self, parent=None):
+        super(UI_Psychrometry, self).__init__(parent)
+        self.showMaximized()
+        self.setWindowTitle("Psychrometric chart")
+
+        layout = QGridLayout(self)
+        self.diagrama2D = PsychroPlot(self, dpi=90)
+        self.diagrama2D.fig.canvas.mpl_connect('motion_notify_event', self.scroll)
+        layout.addWidget(self.diagrama2D, 1, 1, 1, 2)
+        self.progressBar = QProgressBar()
+        self.progressBar.setVisible(False)
+        layout.addWidget(self.progressBar, 2, 1)
+        self.status = QLabel()
+        layout.addWidget(self.status, 2, 1)
+
+        self.buttonBox = QDialogButtonBox(QDialogButtonBox.Close)
+        butonPNG = QPushButton("Save as PNG")
+        self.buttonBox.addButton(butonPNG, QDialogButtonBox.AcceptRole)
+        self.buttonBox.rejected.connect(self.reject)
+        self.buttonBox.accepted.connect(self.savePNG)
+        layout.addWidget(self.buttonBox, 2, 2)
+
+        self.plot()
+
+    def savePNG(self):
+        """Save chart image to png file"""
+        fname = unicode(QFileDialog.getSaveFileName(
+            self, "Save chart to file",
+            "./", "Portable Network Graphics (*.png)"))
+        self.diagrama2D.fig.savefig(fname, facecolor='#eeeeee')
+
+    def drawlabel(self, name, Preferences, t, W, label, unit):
+        """
+        Draw annotation for isolines
+            name: name of isoline
+            Preferences: Configparse instance of pychemqt preferences
+            t: x array of line
+            W: y array of line
+            label: text value to draw
+            unit: text units to draw
+        """
+        if Preferences.getboolean("Psychr", name + "label"):
+            tmin = Preferences.getfloat("Psychr", "isotdbStart") - 273.15
+            tmax = Preferences.getfloat("Psychr", "isotdbEnd") - 273.15
+            x = tmax - tmin
+            wmin = Preferences.getfloat("Psychr", "isowStart")
+            wmax = Preferences.getfloat("Psychr", "isowEnd")
+            y = wmax - wmin
+
+            i = 0
+            for ti, wi in zip(t, W):
+                if tmin <= ti <= tmax and wmin <= wi <= wmax:
+                    i += 1
+            label = str(label)
+            if Preferences.getboolean("Psychr", name + "units"):
+                label += unit
+            pos = Preferences.getfloat("Psychr", name + "position")
+            p = int(i * pos / 100 - 1)
+            rot = np.arctan((W[p] - W[p - 1]) / y / (t[p] - t[p - 1]) * x) * 360.0 / 2.0 / np.pi
+            self.diagrama2D.axes2D.annotate(label, (t[p], W[p]),
+                rotation=rot, size="small", ha="center", va="center")
+
+    def plot(self):
+        """Plot chart"""
+        Preferences = ConfigParser()
+        Preferences.read("psyrc")
+
+        self.diagrama2D.axes2D.clear()
+        self.diagrama2D.config()
+        filename = "%i.pkl" % P
+        if os.path.isfile(filename):
+            with open(filename, "r") as archivo:
+                data = cPickle.load(archivo)
+                self.status.setText("Loading cached data...")
+                QApplication.processEvents()
+        else:
+            self.progressBar.setVisible(True)
+            self.status.setText("Calculating data, be patient...")
+            QApplication.processEvents()
+            data = PsyCoolprop.calculatePlot(self)
+            cPickle.dump(data, open(filename, "w"))
+            self.progressBar.setVisible(False)
+        self.status.setText("Plotting...")
+        QApplication.processEvents()
+
+        tmax = Preferences.getfloat("Psychr", "isotdbEnd") - 273.15
+
+        t = [ti - 273.15 for ti in data["t"]]
+        Hs = data["Hs"]
+        format = {}
+        format["ls"] = Preferences.get("Psychr", "saturationlineStyle")
+        format["lw"] = Preferences.getfloat("Psychr", "saturationlineWidth")
+        format["color"] = Preferences.get("Psychr", "saturationColor")
+        format["marker"] = Preferences.get("Psychr", "saturationmarker")
+        format["markersize"] = 3
+        self.diagrama2D.plot(t, Hs, **format)
+
+        format = {}
+        format["ls"] = Preferences.get("Psychr", "isotdblineStyle")
+        format["lw"] = Preferences.getfloat("Psychr", "isotdblineWidth")
+        format["color"] = Preferences.get("Psychr", "isotdbColor")
+        format["marker"] = Preferences.get("Psychr", "isotdbmarker")
+        format["markersize"] = 3
+        for i, T in enumerate(t):
+            self.diagrama2D.plot([T, T], [0, Hs[i]], **format)
+
+        H = data["H"]
+        th = data["th"]
+        format = {}
+        format["ls"] = Preferences.get("Psychr", "isowlineStyle")
+        format["lw"] = Preferences.getfloat("Psychr", "isowlineWidth")
+        format["color"] = Preferences.get("Psychr", "isowColor")
+        format["marker"] = Preferences.get("Psychr", "isowmarker")
+        format["markersize"] = 3
+        for i, H in enumerate(H):
+            self.diagrama2D.plot([th[i], tmax], [H, H], **format)
+
+        format = {}
+        format["ls"] = Preferences.get("Psychr", "isohrlineStyle")
+        format["lw"] = Preferences.getfloat("Psychr", "isohrlineWidth")
+        format["color"] = Preferences.get("Psychr", "isohrColor")
+        format["marker"] = Preferences.get("Psychr", "isohrmarker")
+        format["markersize"] = 3
+        for Hr, H0 in data["Hr"].iteritems():
+            self.diagrama2D.plot(t, H0, **format)
+            self.drawlabel("isohr", Preferences, t, H0, Hr, "%")
+
+        format = {}
+        format["ls"] = Preferences.get("Psychr", "isotwblineStyle")
+        format["lw"] = Preferences.getfloat("Psychr", "isotwblineWidth")
+        format["color"] = Preferences.get("Psychr", "isotwbColor")
+        format["marker"] = Preferences.get("Psychr", "isotwbmarker")
+        format["markersize"] = 3
+        for T, (H, Tw) in data["Twb"].iteritems():
+            self.diagrama2D.plot(Tw, H, **format)
+            value = T - 273.15
+            txt = u"ºC"
+            self.drawlabel("isotwb", Preferences, Tw, H, value, txt)
+
+        format = {}
+        format["ls"] = Preferences.get("Psychr", "isochorlineStyle")
+        format["lw"] = Preferences.getfloat("Psychr", "isochorlineWidth")
+        format["color"] = Preferences.get("Psychr", "isochorColor")
+        format["marker"] = Preferences.get("Psychr", "isochormarker")
+        format["markersize"] = 3
+        for v, (Td, H) in data["v"].iteritems():
+            self.diagrama2D.plot(Td, H, **format)
+            value = v
+            txt = u"m³/kg"
+            self.drawlabel("isochor", Preferences, Td, H, value, txt)
+
+        self.diagrama2D.draw()
+        self.status.setText("P = %i Pa" % P)
+
+    def scroll(self, event):
+        """Update graph annotate when mouse scroll over chart"""
+        if event.xdata and event.ydata:
+            punto = self.createState(event.xdata, event.ydata)
+            if event.ydata < punto.ws:
+                self.diagrama2D.showPointData(punto)
+            else:
+                self.diagrama2D.clearPointData()
+
+    def createState(self, x, y):
+        """Create psychrometric state from click or mouse position"""
+        tdb = x + 273.15
+        punto = PsyCoolprop(P=P, tdb=tdb, w=y)
+        return punto
+
+
+if __name__ == "__main__":
+    import sys
+    app = QApplication(sys.argv)
+    aireHumedo = UI_Psychrometry()
+    aireHumedo.show()
+    sys.exit(app.exec_())
```

## CoolProp/Plots/psyrc

```diff
@@ -1,88 +1,84 @@
-00000000: 5b47 656e 6572 616c 5d0d 0a50 203d 2031  [General]..P = 1
-00000010: 3031 3332 350d 0a0d 0a5b 5073 7963 6872  01325....[Psychr
-00000020: 5d0d 0a76 6972 6961 6c20 3d20 5472 7565  ]..virial = True
-00000030: 0d0a 636f 6f6c 7072 6f70 203d 2054 7275  ..coolprop = Tru
-00000040: 650d 0a72 6566 7072 6f70 203d 2046 616c  e..refprop = Fal
-00000050: 7365 0d0a 7361 7475 7261 7469 6f6e 636f  se..saturationco
-00000060: 6c6f 7220 3d20 2330 3030 3030 300d 0a73  lor = #000000..s
-00000070: 6174 7572 6174 696f 6e6c 696e 6577 6964  aturationlinewid
-00000080: 7468 203d 2031 2e30 0d0a 7361 7475 7261  th = 1.0..satura
-00000090: 7469 6f6e 6c69 6e65 7374 796c 6520 3d20  tionlinestyle = 
-000000a0: 2d0d 0a73 6174 7572 6174 696f 6e6d 6172  -..saturationmar
-000000b0: 6b65 7220 3d20 4e6f 6e65 0d0a 6973 6f74  ker = None..isot
-000000c0: 6462 7374 6172 7420 3d20 3237 342e 300d  dbstart = 274.0.
-000000d0: 0a69 736f 7464 6265 6e64 203d 2033 3330  .isotdbend = 330
-000000e0: 2e30 0d0a 6973 6f74 6462 7374 6570 203d  .0..isotdbstep =
-000000f0: 2031 2e30 0d0a 6973 6f74 6462 6375 7374   1.0..isotdbcust
-00000100: 6f6d 203d 2046 616c 7365 0d0a 6973 6f74  om = False..isot
-00000110: 6462 6c69 7374 203d 200d 0a69 736f 7464  dblist = ..isotd
-00000120: 6263 6f6c 6f72 203d 2023 3030 3030 3030  bcolor = #000000
-00000130: 0d0a 6973 6f74 6462 6c69 6e65 7769 6474  ..isotdblinewidt
-00000140: 6820 3d20 302e 350d 0a69 736f 7464 626c  h = 0.5..isotdbl
-00000150: 696e 6573 7479 6c65 203d 203a 0d0a 6973  inestyle = :..is
-00000160: 6f74 6462 6d61 726b 6572 203d 204e 6f6e  otdbmarker = Non
-00000170: 650d 0a69 736f 7464 626c 6162 656c 203d  e..isotdblabel =
-00000180: 2046 616c 7365 0d0a 6973 6f74 6462 756e   False..isotdbun
-00000190: 6974 7320 3d20 4661 6c73 650d 0a69 736f  its = False..iso
-000001a0: 7464 6270 6f73 6974 696f 6e20 3d20 3530  tdbposition = 50
-000001b0: 0d0a 6973 6f77 7374 6172 7420 3d20 302e  ..isowstart = 0.
-000001c0: 300d 0a69 736f 7765 6e64 203d 2030 2e30  0..isowend = 0.0
-000001d0: 340d 0a69 736f 7773 7465 7020 3d20 302e  4..isowstep = 0.
-000001e0: 3030 310d 0a69 736f 7763 7573 746f 6d20  001..isowcustom 
-000001f0: 3d20 4661 6c73 650d 0a69 736f 776c 6973  = False..isowlis
-00000200: 7420 3d20 0d0a 6973 6f77 636f 6c6f 7220  t = ..isowcolor 
-00000210: 3d20 2330 3030 3030 300d 0a69 736f 776c  = #000000..isowl
-00000220: 696e 6577 6964 7468 203d 2030 2e35 0d0a  inewidth = 0.5..
-00000230: 6973 6f77 6c69 6e65 7374 796c 6520 3d20  isowlinestyle = 
-00000240: 3a0d 0a69 736f 776d 6172 6b65 7220 3d20  :..isowmarker = 
-00000250: 4e6f 6e65 0d0a 6973 6f77 6c61 6265 6c20  None..isowlabel 
-00000260: 3d20 4661 6c73 650d 0a69 736f 7775 6e69  = False..isowuni
-00000270: 7473 203d 2046 616c 7365 0d0a 6973 6f77  ts = False..isow
-00000280: 706f 7369 7469 6f6e 203d 2035 300d 0a69  position = 50..i
-00000290: 736f 6872 7374 6172 7420 3d20 3130 2e30  sohrstart = 10.0
-000002a0: 0d0a 6973 6f68 7265 6e64 203d 2031 3030  ..isohrend = 100
-000002b0: 2e30 0d0a 6973 6f68 7273 7465 7020 3d20  .0..isohrstep = 
-000002c0: 3130 2e30 0d0a 6973 6f68 7263 7573 746f  10.0..isohrcusto
-000002d0: 6d20 3d20 4661 6c73 650d 0a69 736f 6872  m = False..isohr
-000002e0: 6c69 7374 203d 200d 0a69 736f 6872 636f  list = ..isohrco
-000002f0: 6c6f 7220 3d20 2330 3030 3030 300d 0a69  lor = #000000..i
-00000300: 736f 6872 6c69 6e65 7769 6474 6820 3d20  sohrlinewidth = 
-00000310: 302e 350d 0a69 736f 6872 6c69 6e65 7374  0.5..isohrlinest
-00000320: 796c 6520 3d20 2d2d 0d0a 6973 6f68 726d  yle = --..isohrm
-00000330: 6172 6b65 7220 3d20 4e6f 6e65 0d0a 6973  arker = None..is
-00000340: 6f68 726c 6162 656c 203d 2054 7275 650d  ohrlabel = True.
-00000350: 0a69 736f 6872 756e 6974 7320 3d20 5472  .isohrunits = Tr
-00000360: 7565 0d0a 6973 6f68 7270 6f73 6974 696f  ue..isohrpositio
-00000370: 6e20 3d20 3835 0d0a 6973 6f74 7762 7374  n = 85..isotwbst
-00000380: 6172 7420 3d20 3235 302e 300d 0a69 736f  art = 250.0..iso
-00000390: 7477 6265 6e64 203d 2033 3230 2e30 0d0a  twbend = 320.0..
-000003a0: 6973 6f74 7762 7374 6570 203d 2031 2e30  isotwbstep = 1.0
-000003b0: 0d0a 6973 6f74 7762 6375 7374 6f6d 203d  ..isotwbcustom =
-000003c0: 2046 616c 7365 0d0a 6973 6f74 7762 6c69   False..isotwbli
-000003d0: 7374 203d 200d 0a69 736f 7477 6263 6f6c  st = ..isotwbcol
-000003e0: 6f72 203d 2023 6161 3030 3030 0d0a 6973  or = #aa0000..is
-000003f0: 6f74 7762 6c69 6e65 7769 6474 6820 3d20  otwblinewidth = 
-00000400: 302e 380d 0a69 736f 7477 626c 696e 6573  0.8..isotwblines
-00000410: 7479 6c65 203d 203a 0d0a 6973 6f74 7762  tyle = :..isotwb
-00000420: 6d61 726b 6572 203d 204e 6f6e 650d 0a69  marker = None..i
-00000430: 736f 7477 626c 6162 656c 203d 2046 616c  sotwblabel = Fal
-00000440: 7365 0d0a 6973 6f74 7762 756e 6974 7320  se..isotwbunits 
-00000450: 3d20 4661 6c73 650d 0a69 736f 7477 6270  = False..isotwbp
-00000460: 6f73 6974 696f 6e20 3d20 3939 0d0a 6973  osition = 99..is
-00000470: 6f63 686f 7273 7461 7274 203d 2030 2e38  ochorstart = 0.8
-00000480: 0d0a 6973 6f63 686f 7265 6e64 203d 2031  ..isochorend = 1
-00000490: 2e30 0d0a 6973 6f63 686f 7273 7465 7020  .0..isochorstep 
-000004a0: 3d20 302e 3031 0d0a 6973 6f63 686f 7263  = 0.01..isochorc
-000004b0: 7573 746f 6d20 3d20 4661 6c73 650d 0a69  ustom = False..i
-000004c0: 736f 6368 6f72 6c69 7374 203d 200d 0a69  sochorlist = ..i
-000004d0: 736f 6368 6f72 636f 6c6f 7220 3d20 2330  sochorcolor = #0
-000004e0: 3061 6130 300d 0a69 736f 6368 6f72 6c69  0aa00..isochorli
-000004f0: 6e65 7769 6474 6820 3d20 302e 380d 0a69  newidth = 0.8..i
-00000500: 736f 6368 6f72 6c69 6e65 7374 796c 6520  sochorlinestyle 
-00000510: 3d20 3a0d 0a69 736f 6368 6f72 6d61 726b  = :..isochormark
-00000520: 6572 203d 204e 6f6e 650d 0a69 736f 6368  er = None..isoch
-00000530: 6f72 6c61 6265 6c20 3d20 5472 7565 0d0a  orlabel = True..
-00000540: 6973 6f63 686f 7275 6e69 7473 203d 2046  isochorunits = F
-00000550: 616c 7365 0d0a 6973 6f63 686f 7270 6f73  alse..isochorpos
-00000560: 6974 696f 6e20 3d20 3930 0d0a 6368 6172  ition = 90..char
-00000570: 7420 3d20 5472 7565 0d0a 0d0a            t = True....
+00000000: 5b47 656e 6572 616c 5d0a 5020 3d20 3130  [General].P = 10
+00000010: 3133 3235 0a0a 5b50 7379 6368 725d 0a76  1325..[Psychr].v
+00000020: 6972 6961 6c20 3d20 5472 7565 0a63 6f6f  irial = True.coo
+00000030: 6c70 726f 7020 3d20 5472 7565 0a72 6566  lprop = True.ref
+00000040: 7072 6f70 203d 2046 616c 7365 0a73 6174  prop = False.sat
+00000050: 7572 6174 696f 6e63 6f6c 6f72 203d 2023  urationcolor = #
+00000060: 3030 3030 3030 0a73 6174 7572 6174 696f  000000.saturatio
+00000070: 6e6c 696e 6577 6964 7468 203d 2031 2e30  nlinewidth = 1.0
+00000080: 0a73 6174 7572 6174 696f 6e6c 696e 6573  .saturationlines
+00000090: 7479 6c65 203d 202d 0a73 6174 7572 6174  tyle = -.saturat
+000000a0: 696f 6e6d 6172 6b65 7220 3d20 4e6f 6e65  ionmarker = None
+000000b0: 0a69 736f 7464 6273 7461 7274 203d 2032  .isotdbstart = 2
+000000c0: 3734 2e30 0a69 736f 7464 6265 6e64 203d  74.0.isotdbend =
+000000d0: 2033 3330 2e30 0a69 736f 7464 6273 7465   330.0.isotdbste
+000000e0: 7020 3d20 312e 300a 6973 6f74 6462 6375  p = 1.0.isotdbcu
+000000f0: 7374 6f6d 203d 2046 616c 7365 0a69 736f  stom = False.iso
+00000100: 7464 626c 6973 7420 3d20 0a69 736f 7464  tdblist = .isotd
+00000110: 6263 6f6c 6f72 203d 2023 3030 3030 3030  bcolor = #000000
+00000120: 0a69 736f 7464 626c 696e 6577 6964 7468  .isotdblinewidth
+00000130: 203d 2030 2e35 0a69 736f 7464 626c 696e   = 0.5.isotdblin
+00000140: 6573 7479 6c65 203d 203a 0a69 736f 7464  estyle = :.isotd
+00000150: 626d 6172 6b65 7220 3d20 4e6f 6e65 0a69  bmarker = None.i
+00000160: 736f 7464 626c 6162 656c 203d 2046 616c  sotdblabel = Fal
+00000170: 7365 0a69 736f 7464 6275 6e69 7473 203d  se.isotdbunits =
+00000180: 2046 616c 7365 0a69 736f 7464 6270 6f73   False.isotdbpos
+00000190: 6974 696f 6e20 3d20 3530 0a69 736f 7773  ition = 50.isows
+000001a0: 7461 7274 203d 2030 2e30 0a69 736f 7765  tart = 0.0.isowe
+000001b0: 6e64 203d 2030 2e30 340a 6973 6f77 7374  nd = 0.04.isowst
+000001c0: 6570 203d 2030 2e30 3031 0a69 736f 7763  ep = 0.001.isowc
+000001d0: 7573 746f 6d20 3d20 4661 6c73 650a 6973  ustom = False.is
+000001e0: 6f77 6c69 7374 203d 200a 6973 6f77 636f  owlist = .isowco
+000001f0: 6c6f 7220 3d20 2330 3030 3030 300a 6973  lor = #000000.is
+00000200: 6f77 6c69 6e65 7769 6474 6820 3d20 302e  owlinewidth = 0.
+00000210: 350a 6973 6f77 6c69 6e65 7374 796c 6520  5.isowlinestyle 
+00000220: 3d20 3a0a 6973 6f77 6d61 726b 6572 203d  = :.isowmarker =
+00000230: 204e 6f6e 650a 6973 6f77 6c61 6265 6c20   None.isowlabel 
+00000240: 3d20 4661 6c73 650a 6973 6f77 756e 6974  = False.isowunit
+00000250: 7320 3d20 4661 6c73 650a 6973 6f77 706f  s = False.isowpo
+00000260: 7369 7469 6f6e 203d 2035 300a 6973 6f68  sition = 50.isoh
+00000270: 7273 7461 7274 203d 2031 302e 300a 6973  rstart = 10.0.is
+00000280: 6f68 7265 6e64 203d 2031 3030 2e30 0a69  ohrend = 100.0.i
+00000290: 736f 6872 7374 6570 203d 2031 302e 300a  sohrstep = 10.0.
+000002a0: 6973 6f68 7263 7573 746f 6d20 3d20 4661  isohrcustom = Fa
+000002b0: 6c73 650a 6973 6f68 726c 6973 7420 3d20  lse.isohrlist = 
+000002c0: 0a69 736f 6872 636f 6c6f 7220 3d20 2330  .isohrcolor = #0
+000002d0: 3030 3030 300a 6973 6f68 726c 696e 6577  00000.isohrlinew
+000002e0: 6964 7468 203d 2030 2e35 0a69 736f 6872  idth = 0.5.isohr
+000002f0: 6c69 6e65 7374 796c 6520 3d20 2d2d 0a69  linestyle = --.i
+00000300: 736f 6872 6d61 726b 6572 203d 204e 6f6e  sohrmarker = Non
+00000310: 650a 6973 6f68 726c 6162 656c 203d 2054  e.isohrlabel = T
+00000320: 7275 650a 6973 6f68 7275 6e69 7473 203d  rue.isohrunits =
+00000330: 2054 7275 650a 6973 6f68 7270 6f73 6974   True.isohrposit
+00000340: 696f 6e20 3d20 3835 0a69 736f 7477 6273  ion = 85.isotwbs
+00000350: 7461 7274 203d 2032 3530 2e30 0a69 736f  tart = 250.0.iso
+00000360: 7477 6265 6e64 203d 2033 3230 2e30 0a69  twbend = 320.0.i
+00000370: 736f 7477 6273 7465 7020 3d20 312e 300a  sotwbstep = 1.0.
+00000380: 6973 6f74 7762 6375 7374 6f6d 203d 2046  isotwbcustom = F
+00000390: 616c 7365 0a69 736f 7477 626c 6973 7420  alse.isotwblist 
+000003a0: 3d20 0a69 736f 7477 6263 6f6c 6f72 203d  = .isotwbcolor =
+000003b0: 2023 6161 3030 3030 0a69 736f 7477 626c   #aa0000.isotwbl
+000003c0: 696e 6577 6964 7468 203d 2030 2e38 0a69  inewidth = 0.8.i
+000003d0: 736f 7477 626c 696e 6573 7479 6c65 203d  sotwblinestyle =
+000003e0: 203a 0a69 736f 7477 626d 6172 6b65 7220   :.isotwbmarker 
+000003f0: 3d20 4e6f 6e65 0a69 736f 7477 626c 6162  = None.isotwblab
+00000400: 656c 203d 2046 616c 7365 0a69 736f 7477  el = False.isotw
+00000410: 6275 6e69 7473 203d 2046 616c 7365 0a69  bunits = False.i
+00000420: 736f 7477 6270 6f73 6974 696f 6e20 3d20  sotwbposition = 
+00000430: 3939 0a69 736f 6368 6f72 7374 6172 7420  99.isochorstart 
+00000440: 3d20 302e 380a 6973 6f63 686f 7265 6e64  = 0.8.isochorend
+00000450: 203d 2031 2e30 0a69 736f 6368 6f72 7374   = 1.0.isochorst
+00000460: 6570 203d 2030 2e30 310a 6973 6f63 686f  ep = 0.01.isocho
+00000470: 7263 7573 746f 6d20 3d20 4661 6c73 650a  rcustom = False.
+00000480: 6973 6f63 686f 726c 6973 7420 3d20 0a69  isochorlist = .i
+00000490: 736f 6368 6f72 636f 6c6f 7220 3d20 2330  sochorcolor = #0
+000004a0: 3061 6130 300a 6973 6f63 686f 726c 696e  0aa00.isochorlin
+000004b0: 6577 6964 7468 203d 2030 2e38 0a69 736f  ewidth = 0.8.iso
+000004c0: 6368 6f72 6c69 6e65 7374 796c 6520 3d20  chorlinestyle = 
+000004d0: 3a0a 6973 6f63 686f 726d 6172 6b65 7220  :.isochormarker 
+000004e0: 3d20 4e6f 6e65 0a69 736f 6368 6f72 6c61  = None.isochorla
+000004f0: 6265 6c20 3d20 5472 7565 0a69 736f 6368  bel = True.isoch
+00000500: 6f72 756e 6974 7320 3d20 4661 6c73 650a  orunits = False.
+00000510: 6973 6f63 686f 7270 6f73 6974 696f 6e20  isochorposition 
+00000520: 3d20 3930 0a63 6861 7274 203d 2054 7275  = 90.chart = Tru
+00000530: 650a 0a                                  e..
```

## CoolProp/include/.gitignore

 * *Ordering differences only*

```diff
@@ -1,4 +1,4 @@
-/predefined_mixtures_JSON.h
-/mixture_binary_pairs_JSON.h
-/mixture_departure_functions_JSON.h
-/all_cubics_JSON.h
+/predefined_mixtures_JSON.h
+/mixture_binary_pairs_JSON.h
+/mixture_departure_functions_JSON.h
+/all_cubics_JSON.h
```

## CoolProp/include/AbstractState.h

 * *Ordering differences only*

```diff
@@ -1,1611 +1,1611 @@
-/*
- * AbstractState.h
- *
- *  Created on: 21 Dec 2013
- *      Author: jowr
- */
-
-#ifndef ABSTRACTSTATE_H_
-#define ABSTRACTSTATE_H_
-
-#include "CachedElement.h"
-#include "Exceptions.h"
-#include "DataStructures.h"
-#include "PhaseEnvelope.h"
-#include "crossplatform_shared_ptr.h"
-
-#include <numeric>
-
-namespace CoolProp {
-
-/// This structure holds values obtained while tracing the spinodal curve
-/// (most often in the process of finding critical points, but not only)
-class SpinodalData
-{
-   public:
-    std::vector<double> tau,  ///< The reciprocal reduced temperature (\f$\tau=T_r/T\f$)
-      delta,                  ///< The reduced density (\f$\delta=\rho/\rho_r\f$)
-      M1;                     ///< The determinant of the scaled matrix for the second criticality condition
-};
-
-/// This simple class holds the values for guesses for use in some solvers
-/// that have the ability to use guess values intelligently
-class GuessesStructure
-{
-   public:
-    double T,               ///< temperature in K
-      p,                    ///< pressure in Pa
-      rhomolar,             ///< molar density in mol/m^3
-      hmolar,               ///< molar enthalpy in J/mol
-      smolar,               ///< molar entropy in J/mol/K
-      rhomolar_liq,         ///< molar density of the liquid phase in mol/m^3
-      rhomolar_vap;         ///< molar density of the vapor phase in mol/m^3
-    std::vector<double> x,  ///< molar composition of the liquid phase
-      y;                    ///< molar composition of the vapor phase
-    GuessesStructure() {
-        clear();
-    };
-    void clear() {
-        T = _HUGE;
-        p = _HUGE;
-        rhomolar = _HUGE;
-        hmolar = _HUGE;
-        smolar = _HUGE;
-        rhomolar_liq = _HUGE;
-        rhomolar_vap = _HUGE;
-        x.clear(), y.clear();
-    }
-};
-
-//! The mother of all state classes
-/*!
-This class provides the basic properties based on interrelations of the
-properties, their derivatives and the Helmholtz energy terms. It does not
-provide the mechanism to update the values. This has to be implemented in
-a subclass. Most functions are defined as virtual functions allowing us
-redefine them later, for example to implement the TTSE technique. The
-functions defined here are always used as a fall-back.
-
-This base class does not perform any checks on the two-phase conditions and
-alike. Most of the functions defined here only apply to compressible single
-state substances. Make sure you are aware of all the assumptions we made
-when using this class.
-
-Add build table function to Abstract State
-Interpolator inherit AS implemented by TTSE BICUBIC
-
-*/
-class AbstractState
-{
-   protected:
-    /// Some administrative variables
-    long _fluid_type;
-    phases _phase;               ///< The key for the phase from CoolProp::phases enum
-    phases imposed_phase_index;  ///< If the phase is imposed, the imposed phase index
-
-    bool isSupercriticalPhase(void) {
-        return (this->_phase == iphase_supercritical || this->_phase == iphase_supercritical_liquid || this->_phase == iphase_supercritical_gas);
-    }
-
-    bool isHomogeneousPhase(void) {
-        return (this->_phase == iphase_liquid || this->_phase == iphase_gas || isSupercriticalPhase() || this->_phase == iphase_critical_point);
-    }
-
-    bool isTwoPhase(void) {
-        return (this->_phase == iphase_twophase);
-    }
-
-    /// Two important points
-    SimpleState _critical, _reducing;
-
-    /// Molar mass [mol/kg]
-    CachedElement _molar_mass;
-
-    /// Universal gas constant [J/mol/K]
-    CachedElement _gas_constant;
-
-    /// Bulk values
-    double _rhomolar, _T, _p, _Q, _R;
-
-    CachedElement _tau, _delta;
-
-    /// Transport properties
-    CachedElement _viscosity, _conductivity, _surface_tension;
-
-    CachedElement _hmolar, _smolar, _umolar, _logp, _logrhomolar, _cpmolar, _cp0molar, _cvmolar, _speed_sound, _gibbsmolar, _helmholtzmolar;
-
-    /// Residual properties
-    CachedElement _hmolar_residual, _smolar_residual, _gibbsmolar_residual;
-
-    /// Excess properties
-    CachedElement _hmolar_excess, _smolar_excess, _gibbsmolar_excess, _umolar_excess, _volumemolar_excess, _helmholtzmolar_excess;
-
-    /// Ancillary values
-    CachedElement _rhoLanc, _rhoVanc, _pLanc, _pVanc, _TLanc, _TVanc;
-
-    CachedElement _fugacity_coefficient;
-
-    /// Smoothing values
-    CachedElement _rho_spline, _drho_spline_dh__constp, _drho_spline_dp__consth;
-
-    /// Cached low-level elements for in-place calculation of other properties
-    CachedElement _alpha0, _dalpha0_dTau, _dalpha0_dDelta, _d2alpha0_dTau2, _d2alpha0_dDelta_dTau, _d2alpha0_dDelta2, _d3alpha0_dTau3,
-      _d3alpha0_dDelta_dTau2, _d3alpha0_dDelta2_dTau, _d3alpha0_dDelta3, _alphar, _dalphar_dTau, _dalphar_dDelta, _d2alphar_dTau2,
-      _d2alphar_dDelta_dTau, _d2alphar_dDelta2, _d3alphar_dTau3, _d3alphar_dDelta_dTau2, _d3alphar_dDelta2_dTau, _d3alphar_dDelta3, _d4alphar_dTau4,
-      _d4alphar_dDelta_dTau3, _d4alphar_dDelta2_dTau2, _d4alphar_dDelta3_dTau, _d4alphar_dDelta4;
-
-    CachedElement _dalphar_dDelta_lim, _d2alphar_dDelta2_lim, _d2alphar_dDelta_dTau_lim, _d3alphar_dDelta2_dTau_lim;
-
-    /// Two-Phase variables
-    CachedElement _rhoLmolar, _rhoVmolar;
-
-    // ----------------------------------------
-    // Property accessors to be optionally implemented by the backend
-    // for properties that are not always calculated
-    // ----------------------------------------
-    /// Using this backend, calculate the molar enthalpy in J/mol
-    virtual CoolPropDbl calc_hmolar(void) {
-        throw NotImplementedError("calc_hmolar is not implemented for this backend");
-    };
-    /// Using this backend, calculate the residual molar enthalpy in J/mol
-    virtual CoolPropDbl calc_hmolar_residual(void) {
-        throw NotImplementedError("calc_hmolar_residual is not implemented for this backend");
-    };
-    /// Using this backend, calculate the molar entropy in J/mol/K
-    virtual CoolPropDbl calc_smolar(void) {
-        throw NotImplementedError("calc_smolar is not implemented for this backend");
-    };
-    /// Using this backend, calculate the residual molar entropy in J/mol/K
-    virtual CoolPropDbl calc_smolar_residual(void) {
-        throw NotImplementedError("calc_smolar_residual is not implemented for this backend");
-    };
-    /// Using this backend, calculate the molar internal energy in J/mol
-    virtual CoolPropDbl calc_umolar(void) {
-        throw NotImplementedError("calc_umolar is not implemented for this backend");
-    };
-    /// Using this backend, calculate the molar constant-pressure specific heat in J/mol/K
-    virtual CoolPropDbl calc_cpmolar(void) {
-        throw NotImplementedError("calc_cpmolar is not implemented for this backend");
-    };
-    /// Using this backend, calculate the ideal gas molar constant-pressure specific heat in J/mol/K
-    virtual CoolPropDbl calc_cpmolar_idealgas(void) {
-        throw NotImplementedError("calc_cpmolar_idealgas is not implemented for this backend");
-    };
-    /// Using this backend, calculate the molar constant-volume specific heat in J/mol/K
-    virtual CoolPropDbl calc_cvmolar(void) {
-        throw NotImplementedError("calc_cvmolar is not implemented for this backend");
-    };
-    /// Using this backend, calculate the molar Gibbs function in J/mol
-    virtual CoolPropDbl calc_gibbsmolar(void) {
-        throw NotImplementedError("calc_gibbsmolar is not implemented for this backend");
-    };
-    /// Using this backend, calculate the residual molar Gibbs function in J/mol
-    virtual CoolPropDbl calc_gibbsmolar_residual(void) {
-        throw NotImplementedError("calc_gibbsmolar_residual is not implemented for this backend");
-    };
-    /// Using this backend, calculate the molar Helmholtz energy in J/mol
-    virtual CoolPropDbl calc_helmholtzmolar(void) {
-        throw NotImplementedError("calc_helmholtzmolar is not implemented for this backend");
-    };
-    /// Using this backend, calculate the speed of sound in m/s
-    virtual CoolPropDbl calc_speed_sound(void) {
-        throw NotImplementedError("calc_speed_sound is not implemented for this backend");
-    };
-    /// Using this backend, calculate the isothermal compressibility \f$ \kappa = -\frac{1}{v}\left.\frac{\partial v}{\partial p}\right|_T=\frac{1}{\rho}\left.\frac{\partial \rho}{\partial p}\right|_T\f$  in 1/Pa
-    virtual CoolPropDbl calc_isothermal_compressibility(void) {
-        throw NotImplementedError("calc_isothermal_compressibility is not implemented for this backend");
-    };
-    /// Using this backend, calculate the isobaric expansion coefficient \f$ \beta = \frac{1}{v}\left.\frac{\partial v}{\partial T}\right|_p = -\frac{1}{\rho}\left.\frac{\partial \rho}{\partial T}\right|_p\f$  in 1/K
-    virtual CoolPropDbl calc_isobaric_expansion_coefficient(void) {
-        throw NotImplementedError("calc_isobaric_expansion_coefficient is not implemented for this backend");
-    };
-    /// Using this backend, calculate the isentropic expansion coefficient \f$ \kappa_s = -\frac{c_p}{c_v}\frac{v}{p}\left.\frac{\partial p}{\partial v}\right|_T = \frac{\rho}{p}\left.\frac{\partial p}{\partial \rho}\right|_s\f$
-    virtual CoolPropDbl calc_isentropic_expansion_coefficient(void) {
-        throw NotImplementedError("calc_isentropic_expansion_coefficient is not implemented for this backend");
-    };
-    /// Using this backend, calculate the viscosity in Pa-s
-    virtual CoolPropDbl calc_viscosity(void) {
-        throw NotImplementedError("calc_viscosity is not implemented for this backend");
-    };
-    /// Using this backend, calculate the thermal conductivity in W/m/K
-    virtual CoolPropDbl calc_conductivity(void) {
-        throw NotImplementedError("calc_conductivity is not implemented for this backend");
-    };
-    /// Using this backend, calculate the surface tension in N/m
-    virtual CoolPropDbl calc_surface_tension(void) {
-        throw NotImplementedError("calc_surface_tension is not implemented for this backend");
-    };
-    /// Using this backend, calculate the molar mass in kg/mol
-    virtual CoolPropDbl calc_molar_mass(void) {
-        throw NotImplementedError("calc_molar_mass is not implemented for this backend");
-    };
-    /// Using this backend, calculate the acentric factor
-    virtual CoolPropDbl calc_acentric_factor(void) {
-        throw NotImplementedError("calc_acentric_factor is not implemented for this backend");
-    };
-    /// Using this backend, calculate the pressure in Pa
-    virtual CoolPropDbl calc_pressure(void) {
-        throw NotImplementedError("calc_pressure is not implemented for this backend");
-    };
-    /// Using this backend, calculate the universal gas constant \f$R_u\f$ in J/mol/K
-    virtual CoolPropDbl calc_gas_constant(void) {
-        throw NotImplementedError("calc_gas_constant is not implemented for this backend");
-    };
-    /// Using this backend, calculate the fugacity coefficient (dimensionless)
-    virtual CoolPropDbl calc_fugacity_coefficient(std::size_t i) {
-        throw NotImplementedError("calc_fugacity_coefficient is not implemented for this backend");
-    };
-    /// Using this backend, calculate the fugacity in Pa
-    virtual std::vector<CoolPropDbl> calc_fugacity_coefficients() {
-        throw NotImplementedError("calc_fugacity_coefficients is not implemented for this backend");
-    };
-    /// Using this backend, calculate the fugacity in Pa
-    virtual CoolPropDbl calc_fugacity(std::size_t i) {
-        throw NotImplementedError("calc_fugacity is not implemented for this backend");
-    };
-    /// Using this backend, calculate the chemical potential in J/mol
-    virtual CoolPropDbl calc_chemical_potential(std::size_t i) {
-        throw NotImplementedError("calc_chemical_potential is not implemented for this backend");
-    };
-    /// Using this backend, calculate the phase identification parameter (PIP)
-    virtual CoolPropDbl calc_PIP(void) {
-        throw NotImplementedError("calc_PIP is not implemented for this backend");
-    };
-
-    // Excess properties
-    /// Using this backend, calculate and cache the excess properties
-    virtual void calc_excess_properties(void) {
-        throw NotImplementedError("calc_excess_properties is not implemented for this backend");
-    };
-
-    // Derivatives of residual helmholtz energy
-    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r\f$ (dimensionless)
-    virtual CoolPropDbl calc_alphar(void) {
-        throw NotImplementedError("calc_alphar is not implemented for this backend");
-    };
-    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\delta}\f$ (dimensionless)
-    virtual CoolPropDbl calc_dalphar_dDelta(void) {
-        throw NotImplementedError("calc_dalphar_dDelta is not implemented for this backend");
-    };
-    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\tau}\f$ (dimensionless)
-    virtual CoolPropDbl calc_dalphar_dTau(void) {
-        throw NotImplementedError("calc_dalphar_dTau is not implemented for this backend");
-    };
-    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\delta\delta}\f$ (dimensionless)
-    virtual CoolPropDbl calc_d2alphar_dDelta2(void) {
-        throw NotImplementedError("calc_d2alphar_dDelta2 is not implemented for this backend");
-    };
-    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\delta\tau}\f$ (dimensionless)
-    virtual CoolPropDbl calc_d2alphar_dDelta_dTau(void) {
-        throw NotImplementedError("calc_d2alphar_dDelta_dTau is not implemented for this backend");
-    };
-    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\tau\tau}\f$ (dimensionless)
-    virtual CoolPropDbl calc_d2alphar_dTau2(void) {
-        throw NotImplementedError("calc_d2alphar_dTau2 is not implemented for this backend");
-    };
-    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\delta\delta\delta}\f$ (dimensionless)
-    virtual CoolPropDbl calc_d3alphar_dDelta3(void) {
-        throw NotImplementedError("calc_d3alphar_dDelta3 is not implemented for this backend");
-    };
-    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\delta\delta\tau}\f$ (dimensionless)
-    virtual CoolPropDbl calc_d3alphar_dDelta2_dTau(void) {
-        throw NotImplementedError("calc_d3alphar_dDelta2_dTau is not implemented for this backend");
-    };
-    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\delta\tau\tau}\f$ (dimensionless)
-    virtual CoolPropDbl calc_d3alphar_dDelta_dTau2(void) {
-        throw NotImplementedError("calc_d3alphar_dDelta_dTau2 is not implemented for this backend");
-    };
-    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\tau\tau\tau}\f$ (dimensionless)
-    virtual CoolPropDbl calc_d3alphar_dTau3(void) {
-        throw NotImplementedError("calc_d3alphar_dTau3 is not implemented for this backend");
-    };
-
-    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\delta\delta\delta\delta}\f$ (dimensionless)
-    virtual CoolPropDbl calc_d4alphar_dDelta4(void) {
-        throw NotImplementedError("calc_d4alphar_dDelta4 is not implemented for this backend");
-    };
-    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\delta\delta\delta\tau}\f$ (dimensionless)
-    virtual CoolPropDbl calc_d4alphar_dDelta3_dTau(void) {
-        throw NotImplementedError("calc_d4alphar_dDelta3_dTau is not implemented for this backend");
-    };
-    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\delta\delta\tau\tau}\f$ (dimensionless)
-    virtual CoolPropDbl calc_d4alphar_dDelta2_dTau2(void) {
-        throw NotImplementedError("calc_d4alphar_dDelta2_dTau2 is not implemented for this backend");
-    };
-    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\delta\tau\tau\tau}\f$ (dimensionless)
-    virtual CoolPropDbl calc_d4alphar_dDelta_dTau3(void) {
-        throw NotImplementedError("calc_d4alphar_dDelta_dTau3 is not implemented for this backend");
-    };
-    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\tau\tau\tau\tau}\f$ (dimensionless)
-    virtual CoolPropDbl calc_d4alphar_dTau4(void) {
-        throw NotImplementedError("calc_d4alphar_dTau4 is not implemented for this backend");
-    };
-
-    // Derivatives of ideal-gas helmholtz energy
-    /// Using this backend, calculate the ideal-gas Helmholtz energy term \f$\alpha^0\f$ (dimensionless)
-    virtual CoolPropDbl calc_alpha0(void) {
-        throw NotImplementedError("calc_alpha0 is not implemented for this backend");
-    };
-    /// Using this backend, calculate the ideal-gas Helmholtz energy term \f$\alpha^0_{\delta}\f$ (dimensionless)
-    virtual CoolPropDbl calc_dalpha0_dDelta(void) {
-        throw NotImplementedError("calc_dalpha0_dDelta is not implemented for this backend");
-    };
-    /// Using this backend, calculate the ideal-gas Helmholtz energy term \f$\alpha^0_{\tau}\f$ (dimensionless)
-    virtual CoolPropDbl calc_dalpha0_dTau(void) {
-        throw NotImplementedError("calc_dalpha0_dTau is not implemented for this backend");
-    };
-    /// Using this backend, calculate the ideal-gas Helmholtz energy term \f$\alpha^0_{\delta\delta}\f$ (dimensionless)
-    virtual CoolPropDbl calc_d2alpha0_dDelta_dTau(void) {
-        throw NotImplementedError("calc_d2alpha0_dDelta_dTau is not implemented for this backend");
-    };
-    /// Using this backend, calculate the ideal-gas Helmholtz energy term \f$\alpha^0_{\delta\tau}\f$ (dimensionless)
-    virtual CoolPropDbl calc_d2alpha0_dDelta2(void) {
-        throw NotImplementedError("calc_d2alpha0_dDelta2 is not implemented for this backend");
-    };
-    /// Using this backend, calculate the ideal-gas Helmholtz energy term \f$\alpha^0_{\tau\tau}\f$ (dimensionless)
-    virtual CoolPropDbl calc_d2alpha0_dTau2(void) {
-        throw NotImplementedError("calc_d2alpha0_dTau2 is not implemented for this backend");
-    };
-    /// Using this backend, calculate the ideal-gas Helmholtz energy term \f$\alpha^0_{\delta\delta\delta}\f$ (dimensionless)
-    virtual CoolPropDbl calc_d3alpha0_dDelta3(void) {
-        throw NotImplementedError("calc_d3alpha0_dDelta3 is not implemented for this backend");
-    };
-    /// Using this backend, calculate the ideal-gas Helmholtz energy term \f$\alpha^0_{\delta\delta\tau}\f$ (dimensionless)
-    virtual CoolPropDbl calc_d3alpha0_dDelta2_dTau(void) {
-        throw NotImplementedError("calc_d3alpha0_dDelta2_dTau is not implemented for this backend");
-    };
-    /// Using this backend, calculate the ideal-gas Helmholtz energy term \f$\alpha^0_{\delta\tau\tau}\f$ (dimensionless)
-    virtual CoolPropDbl calc_d3alpha0_dDelta_dTau2(void) {
-        throw NotImplementedError("calc_d3alpha0_dDelta_dTau2 is not implemented for this backend");
-    };
-    /// Using this backend, calculate the ideal-gas Helmholtz energy term \f$\alpha^0_{\tau\tau\tau}\f$ (dimensionless)
-    virtual CoolPropDbl calc_d3alpha0_dTau3(void) {
-        throw NotImplementedError("calc_d3alpha0_dTau3 is not implemented for this backend");
-    };
-
-    virtual void calc_reducing_state(void) {
-        throw NotImplementedError("calc_reducing_state is not implemented for this backend");
-    };
-
-    /// Using this backend, calculate the maximum temperature in K
-    virtual CoolPropDbl calc_Tmax(void) {
-        throw NotImplementedError("calc_Tmax is not implemented for this backend");
-    };
-    /// Using this backend, calculate the minimum temperature in K
-    virtual CoolPropDbl calc_Tmin(void) {
-        throw NotImplementedError("calc_Tmin is not implemented for this backend");
-    };
-    /// Using this backend, calculate the maximum pressure in Pa
-    virtual CoolPropDbl calc_pmax(void) {
-        throw NotImplementedError("calc_pmax is not implemented for this backend");
-    };
-
-    /// Using this backend, calculate the 20-year global warming potential (GWP)
-    virtual CoolPropDbl calc_GWP20(void) {
-        throw NotImplementedError("calc_GWP20 is not implemented for this backend");
-    };
-    /// Using this backend, calculate the 100-year global warming potential (GWP)
-    virtual CoolPropDbl calc_GWP100(void) {
-        throw NotImplementedError("calc_GWP100 is not implemented for this backend");
-    };
-    /// Using this backend, calculate the 500-year global warming potential (GWP)
-    virtual CoolPropDbl calc_GWP500(void) {
-        throw NotImplementedError("calc_GWP500 is not implemented for this backend");
-    };
-    /// Using this backend, calculate the ozone depletion potential (ODP)
-    virtual CoolPropDbl calc_ODP(void) {
-        throw NotImplementedError("calc_ODP is not implemented for this backend");
-    };
-    /// Using this backend, calculate the flame hazard
-    virtual CoolPropDbl calc_flame_hazard(void) {
-        throw NotImplementedError("calc_flame_hazard is not implemented for this backend");
-    };
-    /// Using this backend, calculate the health hazard
-    virtual CoolPropDbl calc_health_hazard(void) {
-        throw NotImplementedError("calc_health_hazard is not implemented for this backend");
-    };
-    /// Using this backend, calculate the physical hazard
-    virtual CoolPropDbl calc_physical_hazard(void) {
-        throw NotImplementedError("calc_physical_hazard is not implemented for this backend");
-    };
-    /// Using this backend, calculate the dipole moment in C-m (1 D = 3.33564e-30 C-m)
-    virtual CoolPropDbl calc_dipole_moment(void) {
-        throw NotImplementedError("calc_dipole_moment is not implemented for this backend");
-    };
-
-    /// Calculate the first partial derivative for the desired derivative
-    virtual CoolPropDbl calc_first_partial_deriv(parameters Of, parameters Wrt, parameters Constant);
-    /// Calculate the second partial derivative using the given backend
-    virtual CoolPropDbl calc_second_partial_deriv(parameters Of1, parameters Wrt1, parameters Constant1, parameters Wrt2, parameters Constant2);
-
-    /// Using this backend, calculate the reduced density (rho/rhoc)
-    virtual CoolPropDbl calc_reduced_density(void) {
-        throw NotImplementedError("calc_reduced_density is not implemented for this backend");
-    };
-    /// Using this backend, calculate the reciprocal reduced temperature (Tc/T)
-    virtual CoolPropDbl calc_reciprocal_reduced_temperature(void) {
-        throw NotImplementedError("calc_reciprocal_reduced_temperature is not implemented for this backend");
-    };
-
-    /// Using this backend, calculate the second virial coefficient
-    virtual CoolPropDbl calc_Bvirial(void) {
-        throw NotImplementedError("calc_Bvirial is not implemented for this backend");
-    };
-    /// Using this backend, calculate the third virial coefficient
-    virtual CoolPropDbl calc_Cvirial(void) {
-        throw NotImplementedError("calc_Cvirial is not implemented for this backend");
-    };
-    /// Using this backend, calculate the derivative dB/dT
-    virtual CoolPropDbl calc_dBvirial_dT(void) {
-        throw NotImplementedError("calc_dBvirial_dT is not implemented for this backend");
-    };
-    /// Using this backend, calculate the derivative dC/dT
-    virtual CoolPropDbl calc_dCvirial_dT(void) {
-        throw NotImplementedError("calc_dCvirial_dT is not implemented for this backend");
-    };
-    /// Using this backend, calculate the compressibility factor Z \f$ Z = p/(\rho R T) \f$
-    virtual CoolPropDbl calc_compressibility_factor(void) {
-        throw NotImplementedError("calc_compressibility_factor is not implemented for this backend");
-    };
-
-    /// Using this backend, get the name of the fluid
-    virtual std::string calc_name(void) {
-        throw NotImplementedError("calc_name is not implemented for this backend");
-    };
-    /// Using this backend, get the description of the fluid
-    virtual std::string calc_description(void) {
-        throw NotImplementedError("calc_description is not implemented for this backend");
-    };
-
-    /// Using this backend, get the triple point temperature in K
-    virtual CoolPropDbl calc_Ttriple(void) {
-        throw NotImplementedError("calc_Ttriple is not implemented for this backend");
-    };
-    /// Using this backend, get the triple point pressure in Pa
-    virtual CoolPropDbl calc_p_triple(void) {
-        throw NotImplementedError("calc_p_triple is not implemented for this backend");
-    };
-
-    /// Using this backend, get the critical point temperature in K
-    virtual CoolPropDbl calc_T_critical(void) {
-        throw NotImplementedError("calc_T_critical is not implemented for this backend");
-    };
-    /// Using this backend, get the reducing point temperature in K
-    virtual CoolPropDbl calc_T_reducing(void) {
-        throw NotImplementedError("calc_T_reducing is not implemented for this backend");
-    };
-    /// Using this backend, get the critical point pressure in Pa
-    virtual CoolPropDbl calc_p_critical(void) {
-        throw NotImplementedError("calc_p_critical is not implemented for this backend");
-    };
-    /// Using this backend, get the reducing point pressure in Pa
-    virtual CoolPropDbl calc_p_reducing(void) {
-        throw NotImplementedError("calc_p_reducing is not implemented for this backend");
-    };
-    /// Using this backend, get the critical point molar density in mol/m^3
-    virtual CoolPropDbl calc_rhomolar_critical(void) {
-        throw NotImplementedError("calc_rhomolar_critical is not implemented for this backend");
-    };
-    /// Using this backend, get the critical point mass density in kg/m^3 - Added for IF97Backend which is mass based
-    virtual CoolPropDbl calc_rhomass_critical(void) {
-        throw NotImplementedError("calc_rhomass_critical is not implemented for this backend");
-    };
-    /// Using this backend, get the reducing point molar density in mol/m^3
-    virtual CoolPropDbl calc_rhomolar_reducing(void) {
-        throw NotImplementedError("calc_rhomolar_reducing is not implemented for this backend");
-    };
-    /// Using this backend, construct the phase envelope, the variable type describes the type of phase envelope to be built.
-    virtual void calc_phase_envelope(const std::string& type) {
-        throw NotImplementedError("calc_phase_envelope is not implemented for this backend");
-    };
-    ///
-    virtual CoolPropDbl calc_rhomass(void) {
-        return rhomolar() * molar_mass();
-    }
-    virtual CoolPropDbl calc_hmass(void) {
-        return hmolar() / molar_mass();
-    }
-    virtual CoolPropDbl calc_hmass_excess(void) {
-        return hmolar_excess() / molar_mass();
-    }
-    virtual CoolPropDbl calc_smass(void) {
-        return smolar() / molar_mass();
-    }
-    virtual CoolPropDbl calc_smass_excess(void) {
-        return smolar_excess() / molar_mass();
-    }
-    virtual CoolPropDbl calc_cpmass(void) {
-        return cpmolar() / molar_mass();
-    }
-    virtual CoolPropDbl calc_cp0mass(void) {
-        return cp0molar() / molar_mass();
-    }
-    virtual CoolPropDbl calc_cvmass(void) {
-        return cvmolar() / molar_mass();
-    }
-    virtual CoolPropDbl calc_umass(void) {
-        return umolar() / molar_mass();
-    }
-    virtual CoolPropDbl calc_umass_excess(void) {
-        return umolar_excess() / molar_mass();
-    }
-    virtual CoolPropDbl calc_gibbsmass(void) {
-        return gibbsmolar() / molar_mass();
-    }
-    virtual CoolPropDbl calc_gibbsmass_excess(void) {
-        return gibbsmolar_excess() / molar_mass();
-    }
-    virtual CoolPropDbl calc_helmholtzmass(void) {
-        return helmholtzmolar() / molar_mass();
-    }
-    virtual CoolPropDbl calc_helmholtzmass_excess(void) {
-        return helmholtzmolar_excess() / molar_mass();
-    }
-    virtual CoolPropDbl calc_volumemass_excess(void) {
-        return volumemolar_excess() / molar_mass();
-    }
-
-    /// Update the states after having changed the reference state for enthalpy and entropy
-    virtual void update_states(void) {
-        throw NotImplementedError("This backend does not implement update_states function");
-    };
-
-    virtual CoolPropDbl calc_melting_line(int param, int given, CoolPropDbl value) {
-        throw NotImplementedError("This backend does not implement calc_melting_line function");
-    };
-
-    /// @param param The key for the parameter to be returned
-    /// @param Q The quality for the parameter that is given (0 = saturated liquid, 1 = saturated vapor)
-    /// @param given The key for the parameter that is given
-    /// @param value The value for the parameter that is given
-    virtual CoolPropDbl calc_saturation_ancillary(parameters param, int Q, parameters given, double value) {
-        throw NotImplementedError("This backend does not implement calc_saturation_ancillary");
-    };
-
-    /// Using this backend, calculate the phase
-    virtual phases calc_phase(void) {
-        throw NotImplementedError("This backend does not implement calc_phase function");
-    };
-    /// Using this backend, specify the phase to be used for all further calculations
-    virtual void calc_specify_phase(phases phase) {
-        throw NotImplementedError("This backend does not implement calc_specify_phase function");
-    };
-    /// Using this backend, unspecify the phase
-    virtual void calc_unspecify_phase(void) {
-        throw NotImplementedError("This backend does not implement calc_unspecify_phase function");
-    };
-    /// Using this backend, get a vector of fluid names
-    virtual std::vector<std::string> calc_fluid_names(void) {
-        throw NotImplementedError("This backend does not implement calc_fluid_names function");
-    };
-    /// Using this backend, calculate a phase given by the state string
-    /// @param state A string that describes the state desired, one of "hs_anchor", "critical"/"crit", "reducing"
-    virtual const CoolProp::SimpleState& calc_state(const std::string& state) {
-        throw NotImplementedError("calc_state is not implemented for this backend");
-    };
-
-    virtual const CoolProp::PhaseEnvelopeData& calc_phase_envelope_data(void) {
-        throw NotImplementedError("calc_phase_envelope_data is not implemented for this backend");
-    };
-
-    virtual std::vector<CoolPropDbl> calc_mole_fractions_liquid(void) {
-        throw NotImplementedError("calc_mole_fractions_liquid is not implemented for this backend");
-    };
-    virtual std::vector<CoolPropDbl> calc_mole_fractions_vapor(void) {
-        throw NotImplementedError("calc_mole_fractions_vapor is not implemented for this backend");
-    };
-    virtual const std::vector<CoolPropDbl> calc_mass_fractions(void) {
-        throw NotImplementedError("calc_mass_fractions is not implemented for this backend");
-    };
-
-    /// Get the minimum fraction (mole, mass, volume) for incompressible fluid
-    virtual CoolPropDbl calc_fraction_min(void) {
-        throw NotImplementedError("calc_fraction_min is not implemented for this backend");
-    };
-    /// Get the maximum fraction (mole, mass, volume) for incompressible fluid
-    virtual CoolPropDbl calc_fraction_max(void) {
-        throw NotImplementedError("calc_fraction_max is not implemented for this backend");
-    };
-    virtual CoolPropDbl calc_T_freeze(void) {
-        throw NotImplementedError("calc_T_freeze is not implemented for this backend");
-    };
-
-    virtual CoolPropDbl calc_first_saturation_deriv(parameters Of1, parameters Wrt1) {
-        throw NotImplementedError("calc_first_saturation_deriv is not implemented for this backend");
-    };
-    virtual CoolPropDbl calc_second_saturation_deriv(parameters Of1, parameters Wrt1, parameters Wrt2) {
-        throw NotImplementedError("calc_second_saturation_deriv is not implemented for this backend");
-    };
-    virtual CoolPropDbl calc_first_two_phase_deriv(parameters Of, parameters Wrt, parameters Constant) {
-        throw NotImplementedError("calc_first_two_phase_deriv is not implemented for this backend");
-    };
-    virtual CoolPropDbl calc_second_two_phase_deriv(parameters Of, parameters Wrt, parameters Constant, parameters Wrt2, parameters Constant2) {
-        throw NotImplementedError("calc_second_two_phase_deriv is not implemented for this backend");
-    };
-    virtual CoolPropDbl calc_first_two_phase_deriv_splined(parameters Of, parameters Wrt, parameters Constant, CoolPropDbl x_end) {
-        throw NotImplementedError("calc_first_two_phase_deriv_splined is not implemented for this backend");
-    };
-
-    virtual CoolPropDbl calc_saturated_liquid_keyed_output(parameters key) {
-        throw NotImplementedError("calc_saturated_liquid_keyed_output is not implemented for this backend");
-    };
-    virtual CoolPropDbl calc_saturated_vapor_keyed_output(parameters key) {
-        throw NotImplementedError("calc_saturated_vapor_keyed_output is not implemented for this backend");
-    };
-    virtual void calc_ideal_curve(const std::string& type, std::vector<double>& T, std::vector<double>& p) {
-        throw NotImplementedError("calc_ideal_curve is not implemented for this backend");
-    };
-
-    /// Using this backend, get the temperature
-    virtual CoolPropDbl calc_T(void) {
-        return _T;
-    }
-    /// Using this backend, get the molar density in mol/m^3
-    virtual CoolPropDbl calc_rhomolar(void) {
-        return _rhomolar;
-    }
-
-    /// Using this backend, calculate the tangent plane distance for a given trial composition
-    virtual double calc_tangent_plane_distance(const double T, const double p, const std::vector<double>& w, const double rhomolar_guess) {
-        throw NotImplementedError("calc_tangent_plane_distance is not implemented for this backend");
-    };
-
-    /// Using this backend, return true critical point where dp/drho|T = 0 and d2p/drho^2|T = 0
-    virtual void calc_true_critical_point(double& T, double& rho) {
-        throw NotImplementedError("calc_true_critical_point is not implemented for this backend");
-    };
-
-    virtual void calc_conformal_state(const std::string& reference_fluid, CoolPropDbl& T, CoolPropDbl& rhomolar) {
-        throw NotImplementedError("calc_conformal_state is not implemented for this backend");
-    };
-
-    virtual void calc_viscosity_contributions(CoolPropDbl& dilute, CoolPropDbl& initial_density, CoolPropDbl& residual, CoolPropDbl& critical) {
-        throw NotImplementedError("calc_viscosity_contributions is not implemented for this backend");
-    };
-    virtual void calc_conductivity_contributions(CoolPropDbl& dilute, CoolPropDbl& initial_density, CoolPropDbl& residual, CoolPropDbl& critical) {
-        throw NotImplementedError("calc_conductivity_contributions is not implemented for this backend");
-    };
-    virtual std::vector<CriticalState> calc_all_critical_points(void) {
-        throw NotImplementedError("calc_all_critical_points is not implemented for this backend");
-    };
-    virtual void calc_build_spinodal() {
-        throw NotImplementedError("calc_build_spinodal is not implemented for this backend");
-    };
-    virtual SpinodalData calc_get_spinodal_data() {
-        throw NotImplementedError("calc_get_spinodal_data is not implemented for this backend");
-    };
-    virtual void calc_criticality_contour_values(double& L1star, double& M1star) {
-        throw NotImplementedError("calc_criticality_contour_values is not implemented for this backend");
-    };
-
-    /// Convert mass-based input pair to molar-based input pair;  If molar-based, do nothing
-    virtual void mass_to_molar_inputs(CoolProp::input_pairs& input_pair, CoolPropDbl& value1, CoolPropDbl& value2);
-
-    /// Change the equation of state for a given component to a specified EOS
-    virtual void calc_change_EOS(const std::size_t i, const std::string& EOS_name) {
-        throw NotImplementedError("calc_change_EOS is not implemented for this backend");
-    };
-
-   public:
-    AbstractState() : _fluid_type(FLUID_TYPE_UNDEFINED), _phase(iphase_unknown) {
-        clear();
-    }
-    virtual ~AbstractState(){};
-
-    /// A factory function to return a pointer to a new-allocated instance of one of the backends.
-    /**
-     * @brief This is a convenience function to allow for the use of '&' delimited fluid names.  Slightly less computationally efficient than the
-     * @param backend The backend in use, one of "HEOS", "REFPROP", etc.
-     * @param fluid_names Fluid names as a '&' delimited string
-     * @return
-     */
-    static AbstractState* factory(const std::string& backend, const std::string& fluid_names) {
-        return factory(backend, strsplit(fluid_names, '&'));
-    };
-
-    /**
-     * @brief A factory function to return a pointer to a new-allocated instance of one of the backends.
-     * @param backend The backend in use, "HEOS", "REFPROP", etc.
-     * @param fluid_names A vector of strings of the fluid names
-     * @return A pointer to the instance generated
-     *
-     * Several backends are possible:
-     *
-     * 1. "?" : The backend is unknown, we will parse the fluid string to determine the backend to be used.  Probably will use HEOS backend (see below)
-     * 2. "HEOS" : The Helmholtz Equation of State backend for use with pure and pseudo-pure fluids, and mixtures, all of which are based on multi-parameter Helmholtz Energy equations of state.  The fluid part of the string should then either be
-     *    1. A pure or pseudo-pure fluid name (eg. "PROPANE" or "R410A"), yielding a HelmholtzEOSBackend instance.
-     *    2. A string that encodes the components of the mixture with a "&" between them (e.g. "R32&R125"), yielding a HelmholtzEOSMixtureBackend instance.
-     *
-     * 3. "REFPROP" : The REFPROP backend will be used.  The fluid part of the string should then either be
-     *    1. A pure or pseudo-pure fluid name (eg. "PROPANE" or "R410A"), yielding a REFPROPBackend instance.
-     *    2. A string that encodes the components of the mixture with a "&" between them (e.g. "R32&R125"), yielding a REFPROPMixtureBackend instance.
-     *
-     * 4. "INCOMP": The incompressible backend will be used
-     * 5. "TTSE&XXXX": The TTSE backend will be used, and the tables will be generated using the XXXX backend where XXXX is one of the base backends("HEOS", "REFPROP", etc. )
-     * 6. "BICUBIC&XXXX": The Bicubic backend will be used, and the tables will be generated using the XXXX backend where XXXX is one of the base backends("HEOS", "REFPROP", etc. )
-     *
-     * Very Important!! : Use a smart pointer to manage the pointer returned.  In older versions of C++, you can use std::tr1::smart_ptr. In C++2011 you can use std::shared_ptr
-     */
-    static AbstractState* factory(const std::string& backend, const std::vector<std::string>& fluid_names);
-
-    /// Set the internal variable T without a flash call (expert use only!)
-    void set_T(CoolPropDbl T) {
-        _T = T;
-    }
-
-    /// Get a string representation of the backend - for instance "HelmholtzEOSMixtureBackend"
-    /// for the core mixture model in CoolProp
-    ///
-    /// Must be overloaded by the backend to provide the backend's name
-    virtual std::string backend_name(void) = 0;
-
-    // The derived classes must implement this function to define whether they use mole fractions (true) or mass fractions (false)
-    virtual bool using_mole_fractions(void) = 0;
-    virtual bool using_mass_fractions(void) = 0;
-    virtual bool using_volu_fractions(void) = 0;
-
-    virtual void set_mole_fractions(const std::vector<CoolPropDbl>& mole_fractions) = 0;
-    virtual void set_mass_fractions(const std::vector<CoolPropDbl>& mass_fractions) = 0;
-    virtual void set_volu_fractions(const std::vector<CoolPropDbl>& mass_fractions) {
-        throw NotImplementedError("Volume composition has not been implemented.");
-    }
-
-    /**
-    \brief Set the reference state based on a string representation
-
-    @param reference_state The reference state to use, one of
-
-    Reference State | Description
-    -------------   | -------------------
-    "IIR"           | h = 200 kJ/kg, s=1 kJ/kg/K at 0C saturated liquid
-    "ASHRAE"        | h = 0, s = 0 @ -40C saturated liquid
-    "NBP"           | h = 0, s = 0 @ 1.0 bar saturated liquid
-    "DEF"           | Reset to the default reference state for the fluid
-    "RESET"         | Remove the offset
-
-    The offset in the ideal gas Helmholtz energy can be obtained from
-    \f[
-    \displaystyle\frac{\Delta s}{R_u/M}+\frac{\Delta h}{(R_u/M)T}\tau
-    \f]
-    where \f$ \Delta s = s-s_{spec} \f$ and \f$ \Delta h = h-h_{spec} \f$
-    */
-    virtual void set_reference_stateS(const std::string& reference_state) {
-        throw NotImplementedError(
-          "Setting reference state has not been implemented for this backend. Try using CoolProp::set_reference_stateD instead.");
-    }
-
-    /// Set the reference state based on a thermodynamic state point specified by temperature and molar density
-    /// @param T Temperature at reference state [K]
-    /// @param rhomolar Molar density at reference state [mol/m^3]
-    /// @param hmolar0 Molar enthalpy at reference state [J/mol]
-    /// @param smolar0 Molar entropy at reference state [J/mol/K]
-    virtual void set_reference_stateD(double T, double rhomolar, double hmolar0, double smolar0) {
-        throw NotImplementedError(
-          "Setting reference state has not been implemented for this backend. Try using CoolProp::set_reference_stateD instead.");
-    }
-
-#ifndef COOLPROPDBL_MAPS_TO_DOUBLE
-    void set_mole_fractions(const std::vector<double>& mole_fractions) {
-        set_mole_fractions(std::vector<CoolPropDbl>(mole_fractions.begin(), mole_fractions.end()));
-    };
-    void set_mass_fractions(const std::vector<double>& mass_fractions) {
-        set_mass_fractions(std::vector<CoolPropDbl>(mass_fractions.begin(), mass_fractions.end()));
-    };
-    void set_volu_fractions(const std::vector<double>& volu_fractions) {
-        set_volu_fractions(std::vector<CoolPropDbl>(volu_fractions.begin(), volu_fractions.end()));
-    };
-#endif
-
-#ifdef EMSCRIPTEN
-    void set_mole_fractions_double(const std::vector<double>& mole_fractions) {
-        set_mole_fractions(std::vector<CoolPropDbl>(mole_fractions.begin(), mole_fractions.end()));
-    };
-#endif
-
-    /// Get the mole fractions of the equilibrium liquid phase
-    std::vector<CoolPropDbl> mole_fractions_liquid(void) {
-        return calc_mole_fractions_liquid();
-    };
-    /// Get the mole fractions of the equilibrium liquid phase (but as a double for use in SWIG wrapper)
-    std::vector<double> mole_fractions_liquid_double(void) {
-        std::vector<CoolPropDbl> x = calc_mole_fractions_liquid();
-        return std::vector<double>(x.begin(), x.end());
-    };
-
-    /// Get the mole fractions of the equilibrium vapor phase
-    std::vector<CoolPropDbl> mole_fractions_vapor(void) {
-        return calc_mole_fractions_vapor();
-    };
-    /// Get the mole fractions of the equilibrium vapor phase (but as a double for use in SWIG wrapper)
-    std::vector<double> mole_fractions_vapor_double(void) {
-        std::vector<CoolPropDbl> y = calc_mole_fractions_vapor();
-        return std::vector<double>(y.begin(), y.end());
-    };
-
-    /// Get the mole fractions of the fluid
-    virtual const std::vector<CoolPropDbl>& get_mole_fractions(void) = 0;
-    /// Get the mass fractions of the fluid
-    virtual const std::vector<CoolPropDbl> get_mass_fractions(void) {
-        return this->calc_mass_fractions();
-    };
-
-    /// Update the state using two state variables
-    virtual void update(CoolProp::input_pairs input_pair, double Value1, double Value2) = 0;
-
-    /// Update the state using two state variables and providing guess values
-    /// Some or all of the guesses will be used - this is backend dependent
-    virtual void update_with_guesses(CoolProp::input_pairs input_pair, double Value1, double Value2, const GuessesStructure& guesses) {
-        throw NotImplementedError("update_with_guesses is not implemented for this backend");
-    };
-
-    /// A function that says whether the backend instance can be instantiated in the high-level interface
-    /// In general this should be true, except for some other backends (especially the tabular backends)
-    /// To disable use in high-level interface, implement this function and return false
-    virtual bool available_in_high_level(void) {
-        return true;
-    }
-
-    /// Return a string from the backend for the mixture/fluid - backend dependent - could be CAS #, name, etc.
-    virtual std::string fluid_param_string(const std::string&) {
-        throw NotImplementedError("fluid_param_string has not been implemented for this backend");
-    }
-
-    /// Return a vector of strings of the fluid names that are in use
-    std::vector<std::string> fluid_names(void);
-
-    /** Get a constant for one of the fluids forming this mixture
-     *  @param i Index (0-based) of the fluid
-     *  @param param parameter you want to obtain (probably one that is a trivial parameter)
-     */
-    virtual const double get_fluid_constant(std::size_t i, parameters param) const {
-        throw NotImplementedError("get_fluid_constant is not implemented for this backend");
-    };
-    ;
-
-    /// Set binary mixture floating point parameter (EXPERT USE ONLY!!!)
-    virtual void set_binary_interaction_double(const std::string& CAS1, const std::string& CAS2, const std::string& parameter, const double value) {
-        throw NotImplementedError("set_binary_interaction_double is not implemented for this backend");
-    };
-    /// Set binary mixture floating point parameter (EXPERT USE ONLY!!!)
-    virtual void set_binary_interaction_double(const std::size_t i, const std::size_t j, const std::string& parameter, const double value) {
-        throw NotImplementedError("set_binary_interaction_double is not implemented for this backend");
-    };
-    /// Set binary mixture string parameter (EXPERT USE ONLY!!!)
-    virtual void set_binary_interaction_string(const std::string& CAS1, const std::string& CAS2, const std::string& parameter,
-                                               const std::string& value) {
-        throw NotImplementedError("set_binary_interaction_string is not implemented for this backend");
-    };
-    /// Set binary mixture string parameter (EXPERT USE ONLY!!!)
-    virtual void set_binary_interaction_string(const std::size_t i, const std::size_t j, const std::string& parameter, const std::string& value) {
-        throw NotImplementedError("set_binary_interaction_string is not implemented for this backend");
-    };
-    /// Get binary mixture double value (EXPERT USE ONLY!!!)
-    virtual double get_binary_interaction_double(const std::string& CAS1, const std::string& CAS2, const std::string& parameter) {
-        throw NotImplementedError("get_binary_interaction_double is not implemented for this backend");
-    };
-    /// Get binary mixture double value (EXPERT USE ONLY!!!)
-    virtual double get_binary_interaction_double(const std::size_t i, const std::size_t j, const std::string& parameter) {
-        throw NotImplementedError("get_binary_interaction_double is not implemented for this backend");
-    };
-    /// Get binary mixture string value (EXPERT USE ONLY!!!)
-    virtual std::string get_binary_interaction_string(const std::string& CAS1, const std::string& CAS2, const std::string& parameter) {
-        throw NotImplementedError("get_binary_interaction_string is not implemented for this backend");
-    };
-    /// Apply a simple mixing rule (EXPERT USE ONLY!!!)
-    virtual void apply_simple_mixing_rule(std::size_t i, std::size_t j, const std::string& model) {
-        throw NotImplementedError("apply_simple_mixing_rule is not implemented for this backend");
-    };
-    /// Set the cubic alpha function's constants:
-    virtual void set_cubic_alpha_C(const size_t i, const std::string& parameter, const double c1, const double c2, const double c3) {
-        throw ValueError("set_cubic_alpha_C only defined for cubic backends");
-    };
-    /// Set fluid parameter (currently the volume translation parameter for cubic)
-    virtual void set_fluid_parameter_double(const size_t i, const std::string& parameter, const double value) {
-        throw ValueError("set_fluid_parameter_double only defined for cubic backends");
-    };
-    /// Double fluid parameter (currently the volume translation parameter for cubic)
-    virtual double get_fluid_parameter_double(const size_t i, const std::string& parameter) {
-        throw ValueError("get_fluid_parameter_double only defined for cubic backends");
-    };
-
-    /// Clear all the cached values
-    virtual bool clear();
-    /// When the composition changes, clear all cached values that are only dependent on composition, but not the thermodynamic state
-    virtual bool clear_comp_change();
-
-    /// Get the state that is used in the equation of state or mixture model
-    /// to reduce the state.  For pure fluids this is usually, but not always,
-    /// the critical point.  For mixture models, it is usually composition dependent
-    virtual const CoolProp::SimpleState& get_reducing_state() {
-        return _reducing;
-    };
-
-    /// Get a desired state point - backend dependent
-    const CoolProp::SimpleState& get_state(const std::string& state) {
-        return calc_state(state);
-    };
-
-    /// Get the minimum temperature in K
-    double Tmin(void);
-    /// Get the maximum temperature in K
-    double Tmax(void);
-    /// Get the maximum pressure in Pa
-    double pmax(void);
-    /// Get the triple point temperature in K
-    double Ttriple(void);
-
-    /// Get the phase of the state
-    phases phase(void) {
-        return calc_phase();
-    };
-    /// Specify the phase for all further calculations with this state class
-    void specify_phase(phases phase) {
-        calc_specify_phase(phase);
-    };
-    /// Unspecify the phase and go back to calculating it based on the inputs
-    void unspecify_phase(void) {
-        calc_unspecify_phase();
-    };
-
-    /// Return the critical temperature in K
-    double T_critical(void);
-    /// Return the critical pressure in Pa
-    double p_critical(void);
-    /// Return the critical molar density in mol/m^3
-    double rhomolar_critical(void);
-    /// Return the critical mass density in kg/m^3
-    double rhomass_critical(void);
-
-    /// Return the vector of critical points, including points that are unstable or correspond to negative pressure
-    std::vector<CriticalState> all_critical_points(void) {
-        return calc_all_critical_points();
-    };
-
-    /// Construct the spinodal curve for the mixture (or pure fluid)
-    void build_spinodal() {
-        calc_build_spinodal();
-    };
-
-    /// Get the data from the spinodal curve constructed in the call to build_spinodal()
-    SpinodalData get_spinodal_data() {
-        return calc_get_spinodal_data();
-    };
-
-    /// Calculate the criticality contour values \f$\mathcal{L}_1^*\f$ and \f$\mathcal{M}_1^*\f$
-    void criticality_contour_values(double& L1star, double& M1star) {
-        return calc_criticality_contour_values(L1star, M1star);
-    }
-
-    /// Return the tangent plane distance for a given trial composition w
-    /// @param T Temperature (K)
-    /// @param p Pressure (Pa)
-    /// @param w The trial composition
-    /// @param rhomolar_guess (mol/m^3) The molar density guess value (if <0 (default), not used; if >0, guess value will be used in flash evaluation)
-    ///
-    /// \f[
-    /// tpd(w) = \sum_i w_i(\ln w_i + \ln \phi_i(w) - d_i)
-    /// \f]
-    /// with
-    /// \f[ d_i = \ln z_i + \ln \phi_i(z) \f]
-    /// Or you can express the \f$ tpd \f$ in terms of fugacity (See Table 7.3 from GERG 2004 monograph)
-    /// since \f$ \ln \phi_i = \ln f_i - \ln p -\ln z_i\f$
-    /// thus
-    /// \f[ d_i = \ln f_i(z) - \ln p\f]
-    /// and
-    /// \f[
-    /// tpd(w) = \sum_i w_i(\ln f_i(w) - \ln p - d_i)
-    /// \f]
-    /// and the \f$ \ln p \f$ cancel, leaving
-    /// \f[
-    /// tpd(w) = \sum_i w_i(\ln f_i(w) - \ln f_i(z))
-    /// \f]
-    double tangent_plane_distance(const double T, const double p, const std::vector<double>& w, const double rhomolar_guess = -1) {
-        return calc_tangent_plane_distance(T, p, w, rhomolar_guess);
-    };
-
-    /// Return the reducing point temperature in K
-    double T_reducing(void);
-    /// Return the molar density at the reducing point in mol/m^3
-    double rhomolar_reducing(void);
-    /// Return the mass density at the reducing point in kg/m^3
-    double rhomass_reducing(void);
-
-    /// Return the triple point pressure in Pa
-    double p_triple(void);
-
-    /// Return the name - backend dependent
-    std::string name() {
-        return calc_name();
-    };
-    /// Return the description - backend dependent
-    std::string description() {
-        return calc_description();
-    };
-
-    /// Return the dipole moment in C-m (1 D = 3.33564e-30 C-m)
-    double dipole_moment() {
-        return calc_dipole_moment();
-    }
-
-    // ----------------------------------------
-    // Bulk properties - temperature and density are directly calculated every time
-    // All other parameters are calculated on an as-needed basis
-    // ----------------------------------------
-    /// Retrieve a value by key
-    double keyed_output(parameters key);
-    /// A trivial keyed output like molar mass that does not depend on the state
-    double trivial_keyed_output(parameters key);
-    /// Get an output from the saturated liquid state by key
-    double saturated_liquid_keyed_output(parameters key) {
-        return calc_saturated_liquid_keyed_output(key);
-    };
-    /// Get an output from the saturated vapor state by key
-    double saturated_vapor_keyed_output(parameters key) {
-        return calc_saturated_vapor_keyed_output(key);
-    };
-
-    /// Return the temperature in K
-    double T(void) {
-        return calc_T();
-    };
-    /// Return the molar density in mol/m^3
-    double rhomolar(void) {
-        return calc_rhomolar();
-    };
-    /// Return the mass density in kg/m^3
-    double rhomass(void) {
-        return calc_rhomass();
-    };
-    /// Return the pressure in Pa
-    double p(void) {
-        return _p;
-    };
-    /// Return the vapor quality (mol/mol); Q = 0 for saturated liquid
-    double Q(void) {
-        return _Q;
-    };
-    /// Return the reciprocal of the reduced temperature (\f$\tau = T_c/T\f$)
-    double tau(void);
-    /// Return the reduced density (\f$\delta = \rho/\rho_c\f$)
-    double delta(void);
-    /// Return the molar mass in kg/mol
-    double molar_mass(void);
-    /// Return the acentric factor
-    double acentric_factor(void);
-    /// Return the mole-fraction weighted gas constant in J/mol/K
-    double gas_constant(void);
-    /// Return the B virial coefficient
-    double Bvirial(void);
-    /// Return the derivative of the B virial coefficient with respect to temperature
-    double dBvirial_dT(void);
-    /// Return the C virial coefficient
-    double Cvirial(void);
-    /// Return the derivative of the C virial coefficient with respect to temperature
-    double dCvirial_dT(void);
-    /// Return the compressibility factor \f$ Z = p/(rho R T) \f$
-    double compressibility_factor(void);
-    /// Return the molar enthalpy in J/mol
-    double hmolar(void);
-    /// Return the residual molar enthalpy in J/mol
-    double hmolar_residual(void);
-    /// Return the mass enthalpy in J/kg
-    double hmass(void) {
-        return calc_hmass();
-    };
-    /// Return the excess molar enthalpy in J/mol
-    double hmolar_excess(void);
-    /// Return the excess mass enthalpy in J/kg
-    double hmass_excess(void) {
-        return calc_hmass_excess();
-    };
-    /// Return the molar entropy in J/mol/K
-    double smolar(void);
-    /// Return the residual molar entropy (as a function of temperature and density) in J/mol/K
-    double smolar_residual(void);
-    /// Return the molar entropy in J/kg/K
-    double smass(void) {
-        return calc_smass();
-    };
-    /// Return the molar entropy in J/mol/K
-    double smolar_excess(void);
-    /// Return the molar entropy in J/kg/K
-    double smass_excess(void) {
-        return calc_smass_excess();
-    };
-    /// Return the molar internal energy in J/mol
-    double umolar(void);
-    /// Return the mass internal energy in J/kg
-    double umass(void) {
-        return calc_umass();
-    };
-    /// Return the excess internal energy in J/mol
-    double umolar_excess(void);
-    /// Return the excess internal energy in J/kg
-    double umass_excess(void) {
-        return calc_umass_excess();
-    };
-    /// Return the molar constant pressure specific heat in J/mol/K
-    double cpmolar(void);
-    /// Return the mass constant pressure specific heat in J/kg/K
-    double cpmass(void) {
-        return calc_cpmass();
-    };
-    /// Return the molar constant pressure specific heat for ideal gas part only in J/mol/K
-    double cp0molar(void);
-    /// Return the mass constant pressure specific heat for ideal gas part only in J/kg/K
-    double cp0mass(void) {
-        return calc_cp0mass();
-    };
-    /// Return the molar constant volume specific heat in J/mol/K
-    double cvmolar(void);
-    /// Return the mass constant volume specific heat in J/kg/K
-    double cvmass(void) {
-        return calc_cvmass();
-    };
-    /// Return the Gibbs energy in J/mol
-    double gibbsmolar(void);
-    /// Return the residual Gibbs energy in J/mol
-    double gibbsmolar_residual(void);
-    /// Return the Gibbs energy in J/kg
-    double gibbsmass(void) {
-        return calc_gibbsmass();
-    };
-    /// Return the excess Gibbs energy in J/mol
-    double gibbsmolar_excess(void);
-    /// Return the excess Gibbs energy in J/kg
-    double gibbsmass_excess(void) {
-        return calc_gibbsmass_excess();
-    };
-    /// Return the Helmholtz energy in J/mol
-    double helmholtzmolar(void);
-    /// Return the Helmholtz energy in J/kg
-    double helmholtzmass(void) {
-        return calc_helmholtzmass();
-    };
-    /// Return the excess Helmholtz energy in J/mol
-    double helmholtzmolar_excess(void);
-    /// Return the excess Helmholtz energy in J/kg
-    double helmholtzmass_excess(void) {
-        return calc_helmholtzmass_excess();
-    };
-    /// Return the excess volume in m^3/mol
-    double volumemolar_excess(void);
-    /// Return the excess volume in m^3/kg
-    double volumemass_excess(void) {
-        return calc_volumemass_excess();
-    };
-    /// Return the speed of sound in m/s
-    double speed_sound(void);
-    /// Return the isothermal compressibility \f$ \kappa = -\frac{1}{v}\left.\frac{\partial v}{\partial p}\right|_T=\frac{1}{\rho}\left.\frac{\partial \rho}{\partial p}\right|_T\f$  in 1/Pa
-    double isothermal_compressibility(void);
-    /// Return the isobaric expansion coefficient \f$ \beta = \frac{1}{v}\left.\frac{\partial v}{\partial T}\right|_p = -\frac{1}{\rho}\left.\frac{\partial \rho}{\partial T}\right|_p\f$  in 1/K
-    double isobaric_expansion_coefficient(void);
-    /// Return the isentropic expansion coefficient \f$ \kappa_s = -\frac{c_p}{c_v}\frac{v}{p}\left.\frac{\partial p}{\partial v}\right|_T = \frac{\rho}{p}\left.\frac{\partial p}{\partial \rho}\right|_s\f$
-    double isentropic_expansion_coefficient(void);
-    /// Return the fugacity coefficient of the i-th component of the mixture
-    double fugacity_coefficient(std::size_t i);
-    /// Return a vector of the fugacity coefficients for all components in the mixture
-    std::vector<double> fugacity_coefficients();
-    /// Return the fugacity of the i-th component of the mixture
-    double fugacity(std::size_t i);
-    /// Return the chemical potential of the i-th component of the mixture
-    double chemical_potential(std::size_t i);
-    /** \brief Return the fundamental derivative of gas dynamics \f$ \Gamma \f$
-     *
-     * see also Colonna et al, FPE, 2010
-     *
-     * \f[ \Gamma = 1+\frac{\rho}{c}\left(\frac{\partial c}{\partial \rho}\right)_{s} = 1+\frac{\rho}{2c^2}\left(\frac{\partial^2 p}{\partial \rho^2}\right)_{s} = \frac{v^3}{2c^2}\left(\frac{\partial^2 p}{\partial v^2}\right)_{s}\f]
-     *
-     * Note: densities are mass-based densities, not mole-based densities
-     */
-    double fundamental_derivative_of_gas_dynamics(void);
-    /// Return the phase identification parameter (PIP) of G. Venkatarathnam and L.R. Oellrich, "Identification of the phase of a fluid using partial derivatives of pressure, volume, and temperature without reference to saturation properties: Applications in phase equilibria calculations"
-    double PIP() {
-        return calc_PIP();
-    };
-
-    /// Calculate the "true" critical point for pure fluids where dpdrho|T and d2p/drho2|T are equal to zero
-    void true_critical_point(double& T, double& rho) {
-        calc_true_critical_point(T, rho);
-    }
-
-    /**
-     * \brief Calculate an ideal curve for a pure fluid
-     *
-     * @param type The type of ideal curve you would like to calculate - "Ideal", "Boyle", "Joule-Thomson", "Joule Inversion", etc.
-     * @param T The temperatures along the curve in K
-     * @param p The pressures along the curve in Pa
-    */
-    void ideal_curve(const std::string& type, std::vector<double>& T, std::vector<double>& p) {
-        calc_ideal_curve(type, T, p);
-    };
-
-    // ----------------------------------------
-    //    Partial derivatives
-    // ----------------------------------------
-
-    /** \brief The first partial derivative in homogeneous phases
-     *
-     * \f[ \left(\frac{\partial A}{\partial B}\right)_C = \frac{\left(\frac{\partial A}{\partial \tau}\right)_\delta\left(\frac{\partial C}{\partial \delta}\right)_\tau-\left(\frac{\partial A}{\partial \delta}\right)_\tau\left(\frac{\partial C}{\partial \tau}\right)_\delta}{\left(\frac{\partial B}{\partial \tau}\right)_\delta\left(\frac{\partial C}{\partial \delta}\right)_\tau-\left(\frac{\partial B}{\partial \delta}\right)_\tau\left(\frac{\partial C}{\partial \tau}\right)_\delta} = \frac{N}{D}\f]
-     */
-    CoolPropDbl first_partial_deriv(parameters Of, parameters Wrt, parameters Constant) {
-        return calc_first_partial_deriv(Of, Wrt, Constant);
-    };
-
-    /** \brief The second partial derivative in homogeneous phases
-     *
-     * The first partial derivative (\ref CoolProp::AbstractState::first_partial_deriv) can be expressed as
-     *
-     * \f[ \left(\frac{\partial A}{\partial B}\right)_C = \frac{\left(\frac{\partial A}{\partial T}\right)_\rho\left(\frac{\partial C}{\partial \rho}\right)_T-\left(\frac{\partial A}{\partial \rho}\right)_T\left(\frac{\partial C}{\partial T}\right)_\rho}{\left(\frac{\partial B}{\partial T}\right)_\rho\left(\frac{\partial C}{\partial \rho}\right)_T-\left(\frac{\partial B}{\partial \rho}\right)_T\left(\frac{\partial C}{\partial T}\right)_\rho} = \frac{N}{D}\f]
-     *
-     * and the second derivative can be expressed as
-     *
-     * \f[
-     * \frac{\partial}{\partial D}\left(\left(\frac{\partial A}{\partial B}\right)_C\right)_E = \frac{\frac{\partial}{\partial T}\left( \left(\frac{\partial A}{\partial B}\right)_C \right)_\rho\left(\frac{\partial E}{\partial \rho}\right)_T-\frac{\partial}{\partial \rho}\left(\left(\frac{\partial A}{\partial B}\right)_C\right)_T\left(\frac{\partial E}{\partial T}\right)_\rho}{\left(\frac{\partial D}{\partial T}\right)_\rho\left(\frac{\partial E}{\partial \rho}\right)_T-\left(\frac{\partial D}{\partial \rho}\right)_T\left(\frac{\partial E}{\partial T}\right)_\rho}
-     * \f]
-     *
-     * which can be expressed in parts as
-     *
-     * \f[\left(\frac{\partial N}{\partial \rho}\right)_{T} = \left(\frac{\partial A}{\partial T}\right)_\rho\left(\frac{\partial^2 C}{\partial \rho^2}\right)_{T}+\left(\frac{\partial^2 A}{\partial T\partial\rho}\right)\left(\frac{\partial C}{\partial \rho}\right)_{T}-\left(\frac{\partial A}{\partial \rho}\right)_T\left(\frac{\partial^2 C}{\partial T\partial\rho}\right)-\left(\frac{\partial^2 A}{\partial \rho^2}\right)_{T}\left(\frac{\partial C}{\partial T}\right)_\rho\f]
-     * \f[\left(\frac{\partial D}{\partial \rho}\right)_{T} = \left(\frac{\partial B}{\partial T}\right)_\rho\left(\frac{\partial^2 C}{\partial \rho^2}\right)_{T}+\left(\frac{\partial^2 B}{\partial T\partial\rho}\right)\left(\frac{\partial C}{\partial \rho}\right)_{T}-\left(\frac{\partial B}{\partial \rho}\right)_T\left(\frac{\partial^2 C}{\partial T\partial\rho}\right)-\left(\frac{\partial^2 B}{\partial \rho^2}\right)_{T}\left(\frac{\partial C}{\partial T}\right)_\rho\f]
-     * \f[\left(\frac{\partial N}{\partial T}\right)_{\rho} = \left(\frac{\partial A}{\partial T}\right)_\rho\left(\frac{\partial^2 C}{\partial \rho\partial T}\right)+\left(\frac{\partial^2 A}{\partial T^2}\right)_\rho\left(\frac{\partial C}{\partial \rho}\right)_{T}-\left(\frac{\partial A}{\partial \rho}\right)_T\left(\frac{\partial^2 C}{\partial T^2}\right)_\rho-\left(\frac{\partial^2 A}{\partial \rho\partial T}\right)\left(\frac{\partial C}{\partial T}\right)_\rho\f]
-     * \f[\left(\frac{\partial D}{\partial T}\right)_{\rho} = \left(\frac{\partial B}{\partial T}\right)_\rho\left(\frac{\partial^2 C}{\partial \rho\partial T}\right)+\left(\frac{\partial^2 B}{\partial T^2}\right)_\rho\left(\frac{\partial C}{\partial \rho}\right)_{T}-\left(\frac{\partial B}{\partial \rho}\right)_T\left(\frac{\partial^2 C}{\partial T^2}\right)_\rho-\left(\frac{\partial^2 B}{\partial \rho\partial T}\right)\left(\frac{\partial C}{\partial T}\right)_\rho\f]
-     * \f[\frac{\partial}{\partial \rho}\left( \left(\frac{\partial A}{\partial B}\right)_C \right)_T = \frac{D\left(\frac{\partial N}{\partial \rho}\right)_{T}-N\left(\frac{\partial D}{\partial \rho}\right)_{\tau}}{D^2}\f]
-     * \f[\frac{\partial}{\partial T}\left( \left(\frac{\partial A}{\partial B}\right)_C \right)_\rho = \frac{D\left(\frac{\partial N}{\partial T}\right)_{\rho}-N\left(\frac{\partial D}{\partial T}\right)_{\rho}}{D^2}\f]
-     *
-     * The terms \f$ N \f$ and \f$ D \f$ are the numerator and denominator from \ref CoolProp::AbstractState::first_partial_deriv respectively
-     */
-    CoolPropDbl second_partial_deriv(parameters Of1, parameters Wrt1, parameters Constant1, parameters Wrt2, parameters Constant2) {
-        return calc_second_partial_deriv(Of1, Wrt1, Constant1, Wrt2, Constant2);
-    };
-
-    /** \brief The first partial derivative along the saturation curve
-     *
-     * Implementing the algorithms and ideas of:
-     * Matthis Thorade, Ali Saadat, "Partial derivatives of thermodynamic state properties for dynamic simulation",
-     * Environmental Earth Sciences, December 2013, Volume 70, Issue 8, pp 3497-3503
-     *
-     * Basically the idea is that the p-T derivative is given by Clapeyron relations:
-     *
-     * \f[ \left(\frac{\partial T}{\partial p}\right)_{\sigma} = T\left(\frac{v'' - v'}{h'' - h'}\right)_{\sigma} \f]
-     *
-     * and then other derivatives can be obtained along the saturation curve from
-     *
-     * \f[ \left(\frac{\partial y}{\partial p}\right)_{\sigma} = \left(\frac{\partial y}{\partial p}\right)+\left(\frac{\partial y}{\partial T}\right)\left(\frac{\partial T}{\partial p}\right)_{\sigma} \f]
-     *
-     * \f[ \left(\frac{\partial y}{\partial T}\right)_{\sigma} = \left(\frac{\partial y}{\partial T}\right)+\left(\frac{\partial y}{\partial p}\right)\left(\frac{\partial p}{\partial T}\right)_{\sigma} \f]
-     *
-     * where derivatives without the \f$ \sigma \f$ are homogeneous (conventional) derivatives.
-     *
-     * @param Of1 The parameter that the derivative is taken of
-     * @param Wrt1 The parameter that the derivative is taken with respect to
-     */
-    CoolPropDbl first_saturation_deriv(parameters Of1, parameters Wrt1) {
-        return calc_first_saturation_deriv(Of1, Wrt1);
-    };
-
-    /** \brief The second partial derivative along the saturation curve
-     *
-     * Implementing the algorithms and ideas of:
-     * Matthis Thorade, Ali Saadat, "Partial derivatives of thermodynamic state properties for dynamic simulation",
-     * Environmental Earth Sciences, December 2013, Volume 70, Issue 8, pp 3497-3503
-     *
-     * Like with \ref first_saturation_deriv, we can express the derivative as
-     * \f[ \left(\frac{\partial y}{\partial T}\right)_{\sigma} = \left(\frac{\partial y}{\partial T}\right)+\left(\frac{\partial y}{\partial p}\right)\left(\frac{\partial p}{\partial T}\right)_{\sigma} \f]
-     *
-     * where \f$ y \f$ is already a saturation derivative. So you might end up with something like
-     *
-     * \f[ \left(\frac{\partial \left(\frac{\partial T}{\partial p}\right)_{\sigma}}{\partial T}\right)_{\sigma} = \left(\frac{\partial \left(\frac{\partial T}{\partial p}\right)_{\sigma}}{\partial T}\right)+\left(\frac{\partial \left(\frac{\partial T}{\partial p}\right)_{\sigma}}{\partial p}\right)\left(\frac{\partial p}{\partial T}\right)_{\sigma} \f]
-     *
-     * @param Of1 The parameter that the first derivative is taken of
-     * @param Wrt1 The parameter that the first derivative is taken with respect to
-     * @param Wrt2 The parameter that the second derivative is taken with respect to
-     * */
-    CoolPropDbl second_saturation_deriv(parameters Of1, parameters Wrt1, parameters Wrt2) {
-        return calc_second_saturation_deriv(Of1, Wrt1, Wrt2);
-    };
-
-    /**
-     * @brief Calculate the first "two-phase" derivative as described by Thorade and Sadaat, EAS, 2013
-     *
-     * Implementing the algorithms and ideas of:
-     * Matthis Thorade, Ali Saadat, "Partial derivatives of thermodynamic state properties for dynamic simulation",
-     * Environmental Earth Sciences, December 2013, Volume 70, Issue 8, pp 3497-3503
-     *
-     * Spline evaluation is as described in:
-     * S Quoilin, I Bell, A Desideri, P Dewallef, V Lemort,
-     * "Methods to increase the robustness of finite-volume flow models in thermodynamic systems",
-     * Energies 7 (3), 1621-1640
-     *
-     * \note Not all derivatives are supported!
-     *
-     * @param Of The parameter to be derived
-     * @param Wrt The parameter that the derivative is taken with respect to
-     * @param Constant The parameter that is held constant
-     * @return
-     */
-    double first_two_phase_deriv(parameters Of, parameters Wrt, parameters Constant) {
-        return calc_first_two_phase_deriv(Of, Wrt, Constant);
-    };
-
-    /**
-    * @brief Calculate the second "two-phase" derivative as described by Thorade and Sadaat, EAS, 2013
-    *
-    * Implementing the algorithms and ideas of:
-    * Matthis Thorade, Ali Saadat, "Partial derivatives of thermodynamic state properties for dynamic simulation",
-    * Environmental Earth Sciences, December 2013, Volume 70, Issue 8, pp 3497-3503
-    *
-    * \note Not all derivatives are supported!
-    *
-    * @param Of The parameter to be derived
-    * @param Wrt1 The parameter that the derivative is taken with respect to in the first derivative
-    * @param Constant1 The parameter that is held constant in the first derivative
-    * @param Wrt2 The parameter that the derivative is taken with respect to in the second derivative
-    * @param Constant2 The parameter that is held constant in the second derivative
-    * @return
-    */
-    double second_two_phase_deriv(parameters Of, parameters Wrt1, parameters Constant1, parameters Wrt2, parameters Constant2) {
-        return calc_second_two_phase_deriv(Of, Wrt1, Constant1, Wrt2, Constant2);
-    };
-
-    /**
-    * @brief Calculate the first "two-phase" derivative as described by Thorade and Sadaat, EAS, 2013
-    *
-    * Implementing the algorithms and ideas of:
-    * Matthis Thorade, Ali Saadat, "Partial derivatives of thermodynamic state properties for dynamic simulation",
-    * Environmental Earth Sciences, December 2013, Volume 70, Issue 8, pp 3497-3503
-    *
-    * Spline evaluation is as described in:
-    * S Quoilin, I Bell, A Desideri, P Dewallef, V Lemort,
-    * "Methods to increase the robustness of finite-volume flow models in thermodynamic systems",
-    * Energies 7 (3), 1621-1640
-    *
-    * \note Not all derivatives are supported! If you need all three currently supported values (drho_dh__p, drho_dp__h and rho_spline), you should calculate drho_dp__h first to avoid duplicate calculations.
-    *
-    * @param Of The parameter to be derived
-    * @param Wrt The parameter that the derivative is taken with respect to
-    * @param Constant The parameter that is held constant
-    * @param x_end The end vapor quality at which the spline is defined (spline is active in [0, x_end])
-    * @return
-    */
-    double first_two_phase_deriv_splined(parameters Of, parameters Wrt, parameters Constant, double x_end) {
-        return calc_first_two_phase_deriv_splined(Of, Wrt, Constant, x_end);
-    };
-
-    // ----------------------------------------
-    //    Phase envelope for mixtures
-    // ----------------------------------------
-
-    /**
-     * \brief Construct the phase envelope for a mixture
-     *
-     * @param type currently a dummy variable that is not used
-     */
-    void build_phase_envelope(const std::string& type = "");
-    /**
-     * \brief After having calculated the phase envelope, return the phase envelope data
-     */
-    const CoolProp::PhaseEnvelopeData& get_phase_envelope_data() {
-        return calc_phase_envelope_data();
-    };
-
-    // ----------------------------------------
-    //    Ancillary equations
-    // ----------------------------------------
-
-    /// Return true if the fluid has a melting line - default is false, but can be re-implemented by derived class
-    virtual bool has_melting_line(void) {
-        return false;
-    };
-    /// Return a value from the melting line
-    /// @param param The key for the parameter to be returned
-    /// @param given The key for the parameter that is given
-    /// @param value The value for the parameter that is given
-    double melting_line(int param, int given, double value);
-    /// Return the value from a saturation ancillary curve (if the backend implements it)
-    /// @param param The key for the parameter to be returned
-    /// @param Q The quality for the parameter that is given (0 = saturated liquid, 1 = saturated vapor)
-    /// @param given The key for the parameter that is given
-    /// @param value The value for the parameter that is given
-    double saturation_ancillary(parameters param, int Q, parameters given, double value);
-
-    // ----------------------------------------
-    // Transport properties
-    // ----------------------------------------
-    /// Return the viscosity in Pa-s
-    double viscosity(void);
-    /// Return the viscosity contributions, each in Pa-s
-    void viscosity_contributions(CoolPropDbl& dilute, CoolPropDbl& initial_density, CoolPropDbl& residual, CoolPropDbl& critical) {
-        calc_viscosity_contributions(dilute, initial_density, residual, critical);
-    };
-    /// Return the thermal conductivity in W/m/K
-    double conductivity(void);
-    /// Return the thermal conductivity contributions, each in W/m/K
-    void conductivity_contributions(CoolPropDbl& dilute, CoolPropDbl& initial_density, CoolPropDbl& residual, CoolPropDbl& critical) {
-        calc_conductivity_contributions(dilute, initial_density, residual, critical);
-    };
-    /// Return the surface tension in N/m
-    double surface_tension(void);
-    /// Return the Prandtl number (dimensionless)
-    double Prandtl(void) {
-        return cpmass() * viscosity() / conductivity();
-    };
-    /**
-     * @brief Find the conformal state needed for ECS
-     * @param reference_fluid The reference fluid for which the conformal state will be calculated
-     * @param T Temperature (initial guess must be provided, or < 0 to start with unity shape factors)
-     * @param rhomolar Molar density (initial guess must be provided, or < 0 to start with unity shape factors)
-     */
-    void conformal_state(const std::string& reference_fluid, CoolPropDbl& T, CoolPropDbl& rhomolar) {
-        return calc_conformal_state(reference_fluid, T, rhomolar);
-    };
-
-    /// \brief Change the equation of state for a given component to a specified EOS
-    /// @param i Index of the component to change (if a pure fluid, i=0)
-    /// @param EOS_name Name of the EOS to use (something like "SRK", "PR", "XiangDeiters", but backend-specific)
-    /// \note Calls the calc_change_EOS function of the implementation
-    void change_EOS(const std::size_t i, const std::string& EOS_name) {
-        calc_change_EOS(i, EOS_name);
-    }
-
-    // ----------------------------------------
-    // Helmholtz energy and derivatives
-    // ----------------------------------------
-    /// Return the term \f$ \alpha^0 \f$
-    CoolPropDbl alpha0(void) {
-        if (!_alpha0) _alpha0 = calc_alpha0();
-        return _alpha0;
-    };
-    /// Return the term \f$ \alpha^0_{\delta} \f$
-    CoolPropDbl dalpha0_dDelta(void) {
-        if (!_dalpha0_dDelta) _dalpha0_dDelta = calc_dalpha0_dDelta();
-        return _dalpha0_dDelta;
-    };
-    /// Return the term \f$ \alpha^0_{\tau} \f$
-    CoolPropDbl dalpha0_dTau(void) {
-        if (!_dalpha0_dTau) _dalpha0_dTau = calc_dalpha0_dTau();
-        return _dalpha0_dTau;
-    };
-    /// Return the term \f$ \alpha^0_{\delta\delta} \f$
-    CoolPropDbl d2alpha0_dDelta2(void) {
-        if (!_d2alpha0_dDelta2) _d2alpha0_dDelta2 = calc_d2alpha0_dDelta2();
-        return _d2alpha0_dDelta2;
-    };
-    /// Return the term \f$ \alpha^0_{\delta\tau} \f$
-    CoolPropDbl d2alpha0_dDelta_dTau(void) {
-        if (!_d2alpha0_dDelta_dTau) _d2alpha0_dDelta_dTau = calc_d2alpha0_dDelta_dTau();
-        return _d2alpha0_dDelta_dTau;
-    };
-    /// Return the term \f$ \alpha^0_{\tau\tau} \f$
-    CoolPropDbl d2alpha0_dTau2(void) {
-        if (!_d2alpha0_dTau2) _d2alpha0_dTau2 = calc_d2alpha0_dTau2();
-        return _d2alpha0_dTau2;
-    };
-    /// Return the term \f$ \alpha^0_{\tau\tau\tau} \f$
-    CoolPropDbl d3alpha0_dTau3(void) {
-        if (!_d3alpha0_dTau3) _d3alpha0_dTau3 = calc_d3alpha0_dTau3();
-        return _d3alpha0_dTau3;
-    };
-    /// Return the term \f$ \alpha^0_{\delta\tau\tau} \f$
-    CoolPropDbl d3alpha0_dDelta_dTau2(void) {
-        if (!_d3alpha0_dDelta_dTau2) _d3alpha0_dDelta_dTau2 = calc_d3alpha0_dDelta_dTau2();
-        return _d3alpha0_dDelta_dTau2;
-    };
-    /// Return the term \f$ \alpha^0_{\delta\delta\tau} \f$
-    CoolPropDbl d3alpha0_dDelta2_dTau(void) {
-        if (!_d3alpha0_dDelta2_dTau) _d3alpha0_dDelta2_dTau = calc_d3alpha0_dDelta2_dTau();
-        return _d3alpha0_dDelta2_dTau;
-    };
-    /// Return the term \f$ \alpha^0_{\delta\delta\delta} \f$
-    CoolPropDbl d3alpha0_dDelta3(void) {
-        if (!_d3alpha0_dDelta3) _d3alpha0_dDelta3 = calc_d3alpha0_dDelta3();
-        return _d3alpha0_dDelta3;
-    };
-
-    /// Return the term \f$ \alpha^r \f$
-    CoolPropDbl alphar(void) {
-        if (!_alphar) _alphar = calc_alphar();
-        return _alphar;
-    };
-    /// Return the term \f$ \alpha^r_{\delta} \f$
-    CoolPropDbl dalphar_dDelta(void) {
-        if (!_dalphar_dDelta) _dalphar_dDelta = calc_dalphar_dDelta();
-        return _dalphar_dDelta;
-    };
-    /// Return the term \f$ \alpha^r_{\tau} \f$
-    CoolPropDbl dalphar_dTau(void) {
-        if (!_dalphar_dTau) _dalphar_dTau = calc_dalphar_dTau();
-        return _dalphar_dTau;
-    };
-    /// Return the term \f$ \alpha^r_{\delta\delta} \f$
-    CoolPropDbl d2alphar_dDelta2(void) {
-        if (!_d2alphar_dDelta2) _d2alphar_dDelta2 = calc_d2alphar_dDelta2();
-        return _d2alphar_dDelta2;
-    };
-    /// Return the term \f$ \alpha^r_{\delta\tau} \f$
-    CoolPropDbl d2alphar_dDelta_dTau(void) {
-        if (!_d2alphar_dDelta_dTau) _d2alphar_dDelta_dTau = calc_d2alphar_dDelta_dTau();
-        return _d2alphar_dDelta_dTau;
-    };
-    /// Return the term \f$ \alpha^r_{\tau\tau} \f$
-    CoolPropDbl d2alphar_dTau2(void) {
-        if (!_d2alphar_dTau2) _d2alphar_dTau2 = calc_d2alphar_dTau2();
-        return _d2alphar_dTau2;
-    };
-    /// Return the term \f$ \alpha^r_{\delta\delta\delta} \f$
-    CoolPropDbl d3alphar_dDelta3(void) {
-        if (!_d3alphar_dDelta3) _d3alphar_dDelta3 = calc_d3alphar_dDelta3();
-        return _d3alphar_dDelta3;
-    };
-    /// Return the term \f$ \alpha^r_{\delta\delta\tau} \f$
-    CoolPropDbl d3alphar_dDelta2_dTau(void) {
-        if (!_d3alphar_dDelta2_dTau) _d3alphar_dDelta2_dTau = calc_d3alphar_dDelta2_dTau();
-        return _d3alphar_dDelta2_dTau;
-    };
-    /// Return the term \f$ \alpha^r_{\delta\tau\tau} \f$
-    CoolPropDbl d3alphar_dDelta_dTau2(void) {
-        if (!_d3alphar_dDelta_dTau2) _d3alphar_dDelta_dTau2 = calc_d3alphar_dDelta_dTau2();
-        return _d3alphar_dDelta_dTau2;
-    };
-    /// Return the term \f$ \alpha^r_{\tau\tau\tau} \f$
-    CoolPropDbl d3alphar_dTau3(void) {
-        if (!_d3alphar_dTau3) _d3alphar_dTau3 = calc_d3alphar_dTau3();
-        return _d3alphar_dTau3;
-    };
-    /// Return the term \f$ \alpha^r_{\delta\delta\delta\delta} \f$
-    CoolPropDbl d4alphar_dDelta4(void) {
-        if (!_d4alphar_dDelta4) _d4alphar_dDelta4 = calc_d4alphar_dDelta4();
-        return _d4alphar_dDelta4;
-    };
-    /// Return the term \f$ \alpha^r_{\delta\delta\delta\tau} \f$
-    CoolPropDbl d4alphar_dDelta3_dTau(void) {
-        if (!_d4alphar_dDelta3_dTau) _d4alphar_dDelta3_dTau = calc_d4alphar_dDelta3_dTau();
-        return _d4alphar_dDelta3_dTau;
-    };
-    /// Return the term \f$ \alpha^r_{\delta\delta\tau\tau} \f$
-    CoolPropDbl d4alphar_dDelta2_dTau2(void) {
-        if (!_d4alphar_dDelta2_dTau2) _d4alphar_dDelta2_dTau2 = calc_d4alphar_dDelta2_dTau2();
-        return _d4alphar_dDelta2_dTau2;
-    };
-    /// Return the term \f$ \alpha^r_{\delta\tau\tau\tau} \f$
-    CoolPropDbl d4alphar_dDelta_dTau3(void) {
-        if (!_d4alphar_dDelta_dTau3) _d4alphar_dDelta_dTau3 = calc_d4alphar_dDelta_dTau3();
-        return _d4alphar_dDelta_dTau3;
-    };
-    /// Return the term \f$ \alpha^r_{\tau\tau\tau\tau} \f$
-    CoolPropDbl d4alphar_dTau4(void) {
-        if (!_d4alphar_dTau4) _d4alphar_dTau4 = calc_d4alphar_dTau4();
-        return _d4alphar_dTau4;
-    };
-};
-
-/** An abstract AbstractState generator class
- *
- *  This class should be derived and statically initialized in a C++ file.  In the initializer,
- *  the register_backend function should be called.  This will register the backend family, and
- *  when this generator is looked up in the map, the get_AbstractState function will be used
- *  to return an initialized instance
- */
-class AbstractStateGenerator
-{
-   public:
-    virtual AbstractState* get_AbstractState(const std::vector<std::string>& fluid_names) = 0;
-    virtual ~AbstractStateGenerator(){};
-};
-
-/** Register a backend in the backend library (statically defined in AbstractState.cpp and not
- *  publicly accessible)
- */
-void register_backend(const backend_families& bf, shared_ptr<AbstractStateGenerator> gen);
-
-template <class T>
-class GeneratorInitializer
-{
-   public:
-    GeneratorInitializer(backend_families bf) {
-        register_backend(bf, shared_ptr<AbstractStateGenerator>(new T()));
-    };
-};
-
-} /* namespace CoolProp */
-#endif /* ABSTRACTSTATE_H_ */
+/*
+ * AbstractState.h
+ *
+ *  Created on: 21 Dec 2013
+ *      Author: jowr
+ */
+
+#ifndef ABSTRACTSTATE_H_
+#define ABSTRACTSTATE_H_
+
+#include "CachedElement.h"
+#include "Exceptions.h"
+#include "DataStructures.h"
+#include "PhaseEnvelope.h"
+#include "crossplatform_shared_ptr.h"
+
+#include <numeric>
+
+namespace CoolProp {
+
+/// This structure holds values obtained while tracing the spinodal curve
+/// (most often in the process of finding critical points, but not only)
+class SpinodalData
+{
+   public:
+    std::vector<double> tau,  ///< The reciprocal reduced temperature (\f$\tau=T_r/T\f$)
+      delta,                  ///< The reduced density (\f$\delta=\rho/\rho_r\f$)
+      M1;                     ///< The determinant of the scaled matrix for the second criticality condition
+};
+
+/// This simple class holds the values for guesses for use in some solvers
+/// that have the ability to use guess values intelligently
+class GuessesStructure
+{
+   public:
+    double T,               ///< temperature in K
+      p,                    ///< pressure in Pa
+      rhomolar,             ///< molar density in mol/m^3
+      hmolar,               ///< molar enthalpy in J/mol
+      smolar,               ///< molar entropy in J/mol/K
+      rhomolar_liq,         ///< molar density of the liquid phase in mol/m^3
+      rhomolar_vap;         ///< molar density of the vapor phase in mol/m^3
+    std::vector<double> x,  ///< molar composition of the liquid phase
+      y;                    ///< molar composition of the vapor phase
+    GuessesStructure() {
+        clear();
+    };
+    void clear() {
+        T = _HUGE;
+        p = _HUGE;
+        rhomolar = _HUGE;
+        hmolar = _HUGE;
+        smolar = _HUGE;
+        rhomolar_liq = _HUGE;
+        rhomolar_vap = _HUGE;
+        x.clear(), y.clear();
+    }
+};
+
+//! The mother of all state classes
+/*!
+This class provides the basic properties based on interrelations of the
+properties, their derivatives and the Helmholtz energy terms. It does not
+provide the mechanism to update the values. This has to be implemented in
+a subclass. Most functions are defined as virtual functions allowing us
+redefine them later, for example to implement the TTSE technique. The
+functions defined here are always used as a fall-back.
+
+This base class does not perform any checks on the two-phase conditions and
+alike. Most of the functions defined here only apply to compressible single
+state substances. Make sure you are aware of all the assumptions we made
+when using this class.
+
+Add build table function to Abstract State
+Interpolator inherit AS implemented by TTSE BICUBIC
+
+*/
+class AbstractState
+{
+   protected:
+    /// Some administrative variables
+    long _fluid_type;
+    phases _phase;               ///< The key for the phase from CoolProp::phases enum
+    phases imposed_phase_index;  ///< If the phase is imposed, the imposed phase index
+
+    bool isSupercriticalPhase(void) {
+        return (this->_phase == iphase_supercritical || this->_phase == iphase_supercritical_liquid || this->_phase == iphase_supercritical_gas);
+    }
+
+    bool isHomogeneousPhase(void) {
+        return (this->_phase == iphase_liquid || this->_phase == iphase_gas || isSupercriticalPhase() || this->_phase == iphase_critical_point);
+    }
+
+    bool isTwoPhase(void) {
+        return (this->_phase == iphase_twophase);
+    }
+
+    /// Two important points
+    SimpleState _critical, _reducing;
+
+    /// Molar mass [mol/kg]
+    CachedElement _molar_mass;
+
+    /// Universal gas constant [J/mol/K]
+    CachedElement _gas_constant;
+
+    /// Bulk values
+    double _rhomolar, _T, _p, _Q, _R;
+
+    CachedElement _tau, _delta;
+
+    /// Transport properties
+    CachedElement _viscosity, _conductivity, _surface_tension;
+
+    CachedElement _hmolar, _smolar, _umolar, _logp, _logrhomolar, _cpmolar, _cp0molar, _cvmolar, _speed_sound, _gibbsmolar, _helmholtzmolar;
+
+    /// Residual properties
+    CachedElement _hmolar_residual, _smolar_residual, _gibbsmolar_residual;
+
+    /// Excess properties
+    CachedElement _hmolar_excess, _smolar_excess, _gibbsmolar_excess, _umolar_excess, _volumemolar_excess, _helmholtzmolar_excess;
+
+    /// Ancillary values
+    CachedElement _rhoLanc, _rhoVanc, _pLanc, _pVanc, _TLanc, _TVanc;
+
+    CachedElement _fugacity_coefficient;
+
+    /// Smoothing values
+    CachedElement _rho_spline, _drho_spline_dh__constp, _drho_spline_dp__consth;
+
+    /// Cached low-level elements for in-place calculation of other properties
+    CachedElement _alpha0, _dalpha0_dTau, _dalpha0_dDelta, _d2alpha0_dTau2, _d2alpha0_dDelta_dTau, _d2alpha0_dDelta2, _d3alpha0_dTau3,
+      _d3alpha0_dDelta_dTau2, _d3alpha0_dDelta2_dTau, _d3alpha0_dDelta3, _alphar, _dalphar_dTau, _dalphar_dDelta, _d2alphar_dTau2,
+      _d2alphar_dDelta_dTau, _d2alphar_dDelta2, _d3alphar_dTau3, _d3alphar_dDelta_dTau2, _d3alphar_dDelta2_dTau, _d3alphar_dDelta3, _d4alphar_dTau4,
+      _d4alphar_dDelta_dTau3, _d4alphar_dDelta2_dTau2, _d4alphar_dDelta3_dTau, _d4alphar_dDelta4;
+
+    CachedElement _dalphar_dDelta_lim, _d2alphar_dDelta2_lim, _d2alphar_dDelta_dTau_lim, _d3alphar_dDelta2_dTau_lim;
+
+    /// Two-Phase variables
+    CachedElement _rhoLmolar, _rhoVmolar;
+
+    // ----------------------------------------
+    // Property accessors to be optionally implemented by the backend
+    // for properties that are not always calculated
+    // ----------------------------------------
+    /// Using this backend, calculate the molar enthalpy in J/mol
+    virtual CoolPropDbl calc_hmolar(void) {
+        throw NotImplementedError("calc_hmolar is not implemented for this backend");
+    };
+    /// Using this backend, calculate the residual molar enthalpy in J/mol
+    virtual CoolPropDbl calc_hmolar_residual(void) {
+        throw NotImplementedError("calc_hmolar_residual is not implemented for this backend");
+    };
+    /// Using this backend, calculate the molar entropy in J/mol/K
+    virtual CoolPropDbl calc_smolar(void) {
+        throw NotImplementedError("calc_smolar is not implemented for this backend");
+    };
+    /// Using this backend, calculate the residual molar entropy in J/mol/K
+    virtual CoolPropDbl calc_smolar_residual(void) {
+        throw NotImplementedError("calc_smolar_residual is not implemented for this backend");
+    };
+    /// Using this backend, calculate the molar internal energy in J/mol
+    virtual CoolPropDbl calc_umolar(void) {
+        throw NotImplementedError("calc_umolar is not implemented for this backend");
+    };
+    /// Using this backend, calculate the molar constant-pressure specific heat in J/mol/K
+    virtual CoolPropDbl calc_cpmolar(void) {
+        throw NotImplementedError("calc_cpmolar is not implemented for this backend");
+    };
+    /// Using this backend, calculate the ideal gas molar constant-pressure specific heat in J/mol/K
+    virtual CoolPropDbl calc_cpmolar_idealgas(void) {
+        throw NotImplementedError("calc_cpmolar_idealgas is not implemented for this backend");
+    };
+    /// Using this backend, calculate the molar constant-volume specific heat in J/mol/K
+    virtual CoolPropDbl calc_cvmolar(void) {
+        throw NotImplementedError("calc_cvmolar is not implemented for this backend");
+    };
+    /// Using this backend, calculate the molar Gibbs function in J/mol
+    virtual CoolPropDbl calc_gibbsmolar(void) {
+        throw NotImplementedError("calc_gibbsmolar is not implemented for this backend");
+    };
+    /// Using this backend, calculate the residual molar Gibbs function in J/mol
+    virtual CoolPropDbl calc_gibbsmolar_residual(void) {
+        throw NotImplementedError("calc_gibbsmolar_residual is not implemented for this backend");
+    };
+    /// Using this backend, calculate the molar Helmholtz energy in J/mol
+    virtual CoolPropDbl calc_helmholtzmolar(void) {
+        throw NotImplementedError("calc_helmholtzmolar is not implemented for this backend");
+    };
+    /// Using this backend, calculate the speed of sound in m/s
+    virtual CoolPropDbl calc_speed_sound(void) {
+        throw NotImplementedError("calc_speed_sound is not implemented for this backend");
+    };
+    /// Using this backend, calculate the isothermal compressibility \f$ \kappa = -\frac{1}{v}\left.\frac{\partial v}{\partial p}\right|_T=\frac{1}{\rho}\left.\frac{\partial \rho}{\partial p}\right|_T\f$  in 1/Pa
+    virtual CoolPropDbl calc_isothermal_compressibility(void) {
+        throw NotImplementedError("calc_isothermal_compressibility is not implemented for this backend");
+    };
+    /// Using this backend, calculate the isobaric expansion coefficient \f$ \beta = \frac{1}{v}\left.\frac{\partial v}{\partial T}\right|_p = -\frac{1}{\rho}\left.\frac{\partial \rho}{\partial T}\right|_p\f$  in 1/K
+    virtual CoolPropDbl calc_isobaric_expansion_coefficient(void) {
+        throw NotImplementedError("calc_isobaric_expansion_coefficient is not implemented for this backend");
+    };
+    /// Using this backend, calculate the isentropic expansion coefficient \f$ \kappa_s = -\frac{c_p}{c_v}\frac{v}{p}\left.\frac{\partial p}{\partial v}\right|_T = \frac{\rho}{p}\left.\frac{\partial p}{\partial \rho}\right|_s\f$
+    virtual CoolPropDbl calc_isentropic_expansion_coefficient(void) {
+        throw NotImplementedError("calc_isentropic_expansion_coefficient is not implemented for this backend");
+    };
+    /// Using this backend, calculate the viscosity in Pa-s
+    virtual CoolPropDbl calc_viscosity(void) {
+        throw NotImplementedError("calc_viscosity is not implemented for this backend");
+    };
+    /// Using this backend, calculate the thermal conductivity in W/m/K
+    virtual CoolPropDbl calc_conductivity(void) {
+        throw NotImplementedError("calc_conductivity is not implemented for this backend");
+    };
+    /// Using this backend, calculate the surface tension in N/m
+    virtual CoolPropDbl calc_surface_tension(void) {
+        throw NotImplementedError("calc_surface_tension is not implemented for this backend");
+    };
+    /// Using this backend, calculate the molar mass in kg/mol
+    virtual CoolPropDbl calc_molar_mass(void) {
+        throw NotImplementedError("calc_molar_mass is not implemented for this backend");
+    };
+    /// Using this backend, calculate the acentric factor
+    virtual CoolPropDbl calc_acentric_factor(void) {
+        throw NotImplementedError("calc_acentric_factor is not implemented for this backend");
+    };
+    /// Using this backend, calculate the pressure in Pa
+    virtual CoolPropDbl calc_pressure(void) {
+        throw NotImplementedError("calc_pressure is not implemented for this backend");
+    };
+    /// Using this backend, calculate the universal gas constant \f$R_u\f$ in J/mol/K
+    virtual CoolPropDbl calc_gas_constant(void) {
+        throw NotImplementedError("calc_gas_constant is not implemented for this backend");
+    };
+    /// Using this backend, calculate the fugacity coefficient (dimensionless)
+    virtual CoolPropDbl calc_fugacity_coefficient(std::size_t i) {
+        throw NotImplementedError("calc_fugacity_coefficient is not implemented for this backend");
+    };
+    /// Using this backend, calculate the fugacity in Pa
+    virtual std::vector<CoolPropDbl> calc_fugacity_coefficients() {
+        throw NotImplementedError("calc_fugacity_coefficients is not implemented for this backend");
+    };
+    /// Using this backend, calculate the fugacity in Pa
+    virtual CoolPropDbl calc_fugacity(std::size_t i) {
+        throw NotImplementedError("calc_fugacity is not implemented for this backend");
+    };
+    /// Using this backend, calculate the chemical potential in J/mol
+    virtual CoolPropDbl calc_chemical_potential(std::size_t i) {
+        throw NotImplementedError("calc_chemical_potential is not implemented for this backend");
+    };
+    /// Using this backend, calculate the phase identification parameter (PIP)
+    virtual CoolPropDbl calc_PIP(void) {
+        throw NotImplementedError("calc_PIP is not implemented for this backend");
+    };
+
+    // Excess properties
+    /// Using this backend, calculate and cache the excess properties
+    virtual void calc_excess_properties(void) {
+        throw NotImplementedError("calc_excess_properties is not implemented for this backend");
+    };
+
+    // Derivatives of residual helmholtz energy
+    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r\f$ (dimensionless)
+    virtual CoolPropDbl calc_alphar(void) {
+        throw NotImplementedError("calc_alphar is not implemented for this backend");
+    };
+    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\delta}\f$ (dimensionless)
+    virtual CoolPropDbl calc_dalphar_dDelta(void) {
+        throw NotImplementedError("calc_dalphar_dDelta is not implemented for this backend");
+    };
+    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\tau}\f$ (dimensionless)
+    virtual CoolPropDbl calc_dalphar_dTau(void) {
+        throw NotImplementedError("calc_dalphar_dTau is not implemented for this backend");
+    };
+    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\delta\delta}\f$ (dimensionless)
+    virtual CoolPropDbl calc_d2alphar_dDelta2(void) {
+        throw NotImplementedError("calc_d2alphar_dDelta2 is not implemented for this backend");
+    };
+    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\delta\tau}\f$ (dimensionless)
+    virtual CoolPropDbl calc_d2alphar_dDelta_dTau(void) {
+        throw NotImplementedError("calc_d2alphar_dDelta_dTau is not implemented for this backend");
+    };
+    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\tau\tau}\f$ (dimensionless)
+    virtual CoolPropDbl calc_d2alphar_dTau2(void) {
+        throw NotImplementedError("calc_d2alphar_dTau2 is not implemented for this backend");
+    };
+    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\delta\delta\delta}\f$ (dimensionless)
+    virtual CoolPropDbl calc_d3alphar_dDelta3(void) {
+        throw NotImplementedError("calc_d3alphar_dDelta3 is not implemented for this backend");
+    };
+    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\delta\delta\tau}\f$ (dimensionless)
+    virtual CoolPropDbl calc_d3alphar_dDelta2_dTau(void) {
+        throw NotImplementedError("calc_d3alphar_dDelta2_dTau is not implemented for this backend");
+    };
+    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\delta\tau\tau}\f$ (dimensionless)
+    virtual CoolPropDbl calc_d3alphar_dDelta_dTau2(void) {
+        throw NotImplementedError("calc_d3alphar_dDelta_dTau2 is not implemented for this backend");
+    };
+    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\tau\tau\tau}\f$ (dimensionless)
+    virtual CoolPropDbl calc_d3alphar_dTau3(void) {
+        throw NotImplementedError("calc_d3alphar_dTau3 is not implemented for this backend");
+    };
+
+    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\delta\delta\delta\delta}\f$ (dimensionless)
+    virtual CoolPropDbl calc_d4alphar_dDelta4(void) {
+        throw NotImplementedError("calc_d4alphar_dDelta4 is not implemented for this backend");
+    };
+    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\delta\delta\delta\tau}\f$ (dimensionless)
+    virtual CoolPropDbl calc_d4alphar_dDelta3_dTau(void) {
+        throw NotImplementedError("calc_d4alphar_dDelta3_dTau is not implemented for this backend");
+    };
+    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\delta\delta\tau\tau}\f$ (dimensionless)
+    virtual CoolPropDbl calc_d4alphar_dDelta2_dTau2(void) {
+        throw NotImplementedError("calc_d4alphar_dDelta2_dTau2 is not implemented for this backend");
+    };
+    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\delta\tau\tau\tau}\f$ (dimensionless)
+    virtual CoolPropDbl calc_d4alphar_dDelta_dTau3(void) {
+        throw NotImplementedError("calc_d4alphar_dDelta_dTau3 is not implemented for this backend");
+    };
+    /// Using this backend, calculate the residual Helmholtz energy term \f$\alpha^r_{\tau\tau\tau\tau}\f$ (dimensionless)
+    virtual CoolPropDbl calc_d4alphar_dTau4(void) {
+        throw NotImplementedError("calc_d4alphar_dTau4 is not implemented for this backend");
+    };
+
+    // Derivatives of ideal-gas helmholtz energy
+    /// Using this backend, calculate the ideal-gas Helmholtz energy term \f$\alpha^0\f$ (dimensionless)
+    virtual CoolPropDbl calc_alpha0(void) {
+        throw NotImplementedError("calc_alpha0 is not implemented for this backend");
+    };
+    /// Using this backend, calculate the ideal-gas Helmholtz energy term \f$\alpha^0_{\delta}\f$ (dimensionless)
+    virtual CoolPropDbl calc_dalpha0_dDelta(void) {
+        throw NotImplementedError("calc_dalpha0_dDelta is not implemented for this backend");
+    };
+    /// Using this backend, calculate the ideal-gas Helmholtz energy term \f$\alpha^0_{\tau}\f$ (dimensionless)
+    virtual CoolPropDbl calc_dalpha0_dTau(void) {
+        throw NotImplementedError("calc_dalpha0_dTau is not implemented for this backend");
+    };
+    /// Using this backend, calculate the ideal-gas Helmholtz energy term \f$\alpha^0_{\delta\delta}\f$ (dimensionless)
+    virtual CoolPropDbl calc_d2alpha0_dDelta_dTau(void) {
+        throw NotImplementedError("calc_d2alpha0_dDelta_dTau is not implemented for this backend");
+    };
+    /// Using this backend, calculate the ideal-gas Helmholtz energy term \f$\alpha^0_{\delta\tau}\f$ (dimensionless)
+    virtual CoolPropDbl calc_d2alpha0_dDelta2(void) {
+        throw NotImplementedError("calc_d2alpha0_dDelta2 is not implemented for this backend");
+    };
+    /// Using this backend, calculate the ideal-gas Helmholtz energy term \f$\alpha^0_{\tau\tau}\f$ (dimensionless)
+    virtual CoolPropDbl calc_d2alpha0_dTau2(void) {
+        throw NotImplementedError("calc_d2alpha0_dTau2 is not implemented for this backend");
+    };
+    /// Using this backend, calculate the ideal-gas Helmholtz energy term \f$\alpha^0_{\delta\delta\delta}\f$ (dimensionless)
+    virtual CoolPropDbl calc_d3alpha0_dDelta3(void) {
+        throw NotImplementedError("calc_d3alpha0_dDelta3 is not implemented for this backend");
+    };
+    /// Using this backend, calculate the ideal-gas Helmholtz energy term \f$\alpha^0_{\delta\delta\tau}\f$ (dimensionless)
+    virtual CoolPropDbl calc_d3alpha0_dDelta2_dTau(void) {
+        throw NotImplementedError("calc_d3alpha0_dDelta2_dTau is not implemented for this backend");
+    };
+    /// Using this backend, calculate the ideal-gas Helmholtz energy term \f$\alpha^0_{\delta\tau\tau}\f$ (dimensionless)
+    virtual CoolPropDbl calc_d3alpha0_dDelta_dTau2(void) {
+        throw NotImplementedError("calc_d3alpha0_dDelta_dTau2 is not implemented for this backend");
+    };
+    /// Using this backend, calculate the ideal-gas Helmholtz energy term \f$\alpha^0_{\tau\tau\tau}\f$ (dimensionless)
+    virtual CoolPropDbl calc_d3alpha0_dTau3(void) {
+        throw NotImplementedError("calc_d3alpha0_dTau3 is not implemented for this backend");
+    };
+
+    virtual void calc_reducing_state(void) {
+        throw NotImplementedError("calc_reducing_state is not implemented for this backend");
+    };
+
+    /// Using this backend, calculate the maximum temperature in K
+    virtual CoolPropDbl calc_Tmax(void) {
+        throw NotImplementedError("calc_Tmax is not implemented for this backend");
+    };
+    /// Using this backend, calculate the minimum temperature in K
+    virtual CoolPropDbl calc_Tmin(void) {
+        throw NotImplementedError("calc_Tmin is not implemented for this backend");
+    };
+    /// Using this backend, calculate the maximum pressure in Pa
+    virtual CoolPropDbl calc_pmax(void) {
+        throw NotImplementedError("calc_pmax is not implemented for this backend");
+    };
+
+    /// Using this backend, calculate the 20-year global warming potential (GWP)
+    virtual CoolPropDbl calc_GWP20(void) {
+        throw NotImplementedError("calc_GWP20 is not implemented for this backend");
+    };
+    /// Using this backend, calculate the 100-year global warming potential (GWP)
+    virtual CoolPropDbl calc_GWP100(void) {
+        throw NotImplementedError("calc_GWP100 is not implemented for this backend");
+    };
+    /// Using this backend, calculate the 500-year global warming potential (GWP)
+    virtual CoolPropDbl calc_GWP500(void) {
+        throw NotImplementedError("calc_GWP500 is not implemented for this backend");
+    };
+    /// Using this backend, calculate the ozone depletion potential (ODP)
+    virtual CoolPropDbl calc_ODP(void) {
+        throw NotImplementedError("calc_ODP is not implemented for this backend");
+    };
+    /// Using this backend, calculate the flame hazard
+    virtual CoolPropDbl calc_flame_hazard(void) {
+        throw NotImplementedError("calc_flame_hazard is not implemented for this backend");
+    };
+    /// Using this backend, calculate the health hazard
+    virtual CoolPropDbl calc_health_hazard(void) {
+        throw NotImplementedError("calc_health_hazard is not implemented for this backend");
+    };
+    /// Using this backend, calculate the physical hazard
+    virtual CoolPropDbl calc_physical_hazard(void) {
+        throw NotImplementedError("calc_physical_hazard is not implemented for this backend");
+    };
+    /// Using this backend, calculate the dipole moment in C-m (1 D = 3.33564e-30 C-m)
+    virtual CoolPropDbl calc_dipole_moment(void) {
+        throw NotImplementedError("calc_dipole_moment is not implemented for this backend");
+    };
+
+    /// Calculate the first partial derivative for the desired derivative
+    virtual CoolPropDbl calc_first_partial_deriv(parameters Of, parameters Wrt, parameters Constant);
+    /// Calculate the second partial derivative using the given backend
+    virtual CoolPropDbl calc_second_partial_deriv(parameters Of1, parameters Wrt1, parameters Constant1, parameters Wrt2, parameters Constant2);
+
+    /// Using this backend, calculate the reduced density (rho/rhoc)
+    virtual CoolPropDbl calc_reduced_density(void) {
+        throw NotImplementedError("calc_reduced_density is not implemented for this backend");
+    };
+    /// Using this backend, calculate the reciprocal reduced temperature (Tc/T)
+    virtual CoolPropDbl calc_reciprocal_reduced_temperature(void) {
+        throw NotImplementedError("calc_reciprocal_reduced_temperature is not implemented for this backend");
+    };
+
+    /// Using this backend, calculate the second virial coefficient
+    virtual CoolPropDbl calc_Bvirial(void) {
+        throw NotImplementedError("calc_Bvirial is not implemented for this backend");
+    };
+    /// Using this backend, calculate the third virial coefficient
+    virtual CoolPropDbl calc_Cvirial(void) {
+        throw NotImplementedError("calc_Cvirial is not implemented for this backend");
+    };
+    /// Using this backend, calculate the derivative dB/dT
+    virtual CoolPropDbl calc_dBvirial_dT(void) {
+        throw NotImplementedError("calc_dBvirial_dT is not implemented for this backend");
+    };
+    /// Using this backend, calculate the derivative dC/dT
+    virtual CoolPropDbl calc_dCvirial_dT(void) {
+        throw NotImplementedError("calc_dCvirial_dT is not implemented for this backend");
+    };
+    /// Using this backend, calculate the compressibility factor Z \f$ Z = p/(\rho R T) \f$
+    virtual CoolPropDbl calc_compressibility_factor(void) {
+        throw NotImplementedError("calc_compressibility_factor is not implemented for this backend");
+    };
+
+    /// Using this backend, get the name of the fluid
+    virtual std::string calc_name(void) {
+        throw NotImplementedError("calc_name is not implemented for this backend");
+    };
+    /// Using this backend, get the description of the fluid
+    virtual std::string calc_description(void) {
+        throw NotImplementedError("calc_description is not implemented for this backend");
+    };
+
+    /// Using this backend, get the triple point temperature in K
+    virtual CoolPropDbl calc_Ttriple(void) {
+        throw NotImplementedError("calc_Ttriple is not implemented for this backend");
+    };
+    /// Using this backend, get the triple point pressure in Pa
+    virtual CoolPropDbl calc_p_triple(void) {
+        throw NotImplementedError("calc_p_triple is not implemented for this backend");
+    };
+
+    /// Using this backend, get the critical point temperature in K
+    virtual CoolPropDbl calc_T_critical(void) {
+        throw NotImplementedError("calc_T_critical is not implemented for this backend");
+    };
+    /// Using this backend, get the reducing point temperature in K
+    virtual CoolPropDbl calc_T_reducing(void) {
+        throw NotImplementedError("calc_T_reducing is not implemented for this backend");
+    };
+    /// Using this backend, get the critical point pressure in Pa
+    virtual CoolPropDbl calc_p_critical(void) {
+        throw NotImplementedError("calc_p_critical is not implemented for this backend");
+    };
+    /// Using this backend, get the reducing point pressure in Pa
+    virtual CoolPropDbl calc_p_reducing(void) {
+        throw NotImplementedError("calc_p_reducing is not implemented for this backend");
+    };
+    /// Using this backend, get the critical point molar density in mol/m^3
+    virtual CoolPropDbl calc_rhomolar_critical(void) {
+        throw NotImplementedError("calc_rhomolar_critical is not implemented for this backend");
+    };
+    /// Using this backend, get the critical point mass density in kg/m^3 - Added for IF97Backend which is mass based
+    virtual CoolPropDbl calc_rhomass_critical(void) {
+        throw NotImplementedError("calc_rhomass_critical is not implemented for this backend");
+    };
+    /// Using this backend, get the reducing point molar density in mol/m^3
+    virtual CoolPropDbl calc_rhomolar_reducing(void) {
+        throw NotImplementedError("calc_rhomolar_reducing is not implemented for this backend");
+    };
+    /// Using this backend, construct the phase envelope, the variable type describes the type of phase envelope to be built.
+    virtual void calc_phase_envelope(const std::string& type) {
+        throw NotImplementedError("calc_phase_envelope is not implemented for this backend");
+    };
+    ///
+    virtual CoolPropDbl calc_rhomass(void) {
+        return rhomolar() * molar_mass();
+    }
+    virtual CoolPropDbl calc_hmass(void) {
+        return hmolar() / molar_mass();
+    }
+    virtual CoolPropDbl calc_hmass_excess(void) {
+        return hmolar_excess() / molar_mass();
+    }
+    virtual CoolPropDbl calc_smass(void) {
+        return smolar() / molar_mass();
+    }
+    virtual CoolPropDbl calc_smass_excess(void) {
+        return smolar_excess() / molar_mass();
+    }
+    virtual CoolPropDbl calc_cpmass(void) {
+        return cpmolar() / molar_mass();
+    }
+    virtual CoolPropDbl calc_cp0mass(void) {
+        return cp0molar() / molar_mass();
+    }
+    virtual CoolPropDbl calc_cvmass(void) {
+        return cvmolar() / molar_mass();
+    }
+    virtual CoolPropDbl calc_umass(void) {
+        return umolar() / molar_mass();
+    }
+    virtual CoolPropDbl calc_umass_excess(void) {
+        return umolar_excess() / molar_mass();
+    }
+    virtual CoolPropDbl calc_gibbsmass(void) {
+        return gibbsmolar() / molar_mass();
+    }
+    virtual CoolPropDbl calc_gibbsmass_excess(void) {
+        return gibbsmolar_excess() / molar_mass();
+    }
+    virtual CoolPropDbl calc_helmholtzmass(void) {
+        return helmholtzmolar() / molar_mass();
+    }
+    virtual CoolPropDbl calc_helmholtzmass_excess(void) {
+        return helmholtzmolar_excess() / molar_mass();
+    }
+    virtual CoolPropDbl calc_volumemass_excess(void) {
+        return volumemolar_excess() / molar_mass();
+    }
+
+    /// Update the states after having changed the reference state for enthalpy and entropy
+    virtual void update_states(void) {
+        throw NotImplementedError("This backend does not implement update_states function");
+    };
+
+    virtual CoolPropDbl calc_melting_line(int param, int given, CoolPropDbl value) {
+        throw NotImplementedError("This backend does not implement calc_melting_line function");
+    };
+
+    /// @param param The key for the parameter to be returned
+    /// @param Q The quality for the parameter that is given (0 = saturated liquid, 1 = saturated vapor)
+    /// @param given The key for the parameter that is given
+    /// @param value The value for the parameter that is given
+    virtual CoolPropDbl calc_saturation_ancillary(parameters param, int Q, parameters given, double value) {
+        throw NotImplementedError("This backend does not implement calc_saturation_ancillary");
+    };
+
+    /// Using this backend, calculate the phase
+    virtual phases calc_phase(void) {
+        throw NotImplementedError("This backend does not implement calc_phase function");
+    };
+    /// Using this backend, specify the phase to be used for all further calculations
+    virtual void calc_specify_phase(phases phase) {
+        throw NotImplementedError("This backend does not implement calc_specify_phase function");
+    };
+    /// Using this backend, unspecify the phase
+    virtual void calc_unspecify_phase(void) {
+        throw NotImplementedError("This backend does not implement calc_unspecify_phase function");
+    };
+    /// Using this backend, get a vector of fluid names
+    virtual std::vector<std::string> calc_fluid_names(void) {
+        throw NotImplementedError("This backend does not implement calc_fluid_names function");
+    };
+    /// Using this backend, calculate a phase given by the state string
+    /// @param state A string that describes the state desired, one of "hs_anchor", "critical"/"crit", "reducing"
+    virtual const CoolProp::SimpleState& calc_state(const std::string& state) {
+        throw NotImplementedError("calc_state is not implemented for this backend");
+    };
+
+    virtual const CoolProp::PhaseEnvelopeData& calc_phase_envelope_data(void) {
+        throw NotImplementedError("calc_phase_envelope_data is not implemented for this backend");
+    };
+
+    virtual std::vector<CoolPropDbl> calc_mole_fractions_liquid(void) {
+        throw NotImplementedError("calc_mole_fractions_liquid is not implemented for this backend");
+    };
+    virtual std::vector<CoolPropDbl> calc_mole_fractions_vapor(void) {
+        throw NotImplementedError("calc_mole_fractions_vapor is not implemented for this backend");
+    };
+    virtual const std::vector<CoolPropDbl> calc_mass_fractions(void) {
+        throw NotImplementedError("calc_mass_fractions is not implemented for this backend");
+    };
+
+    /// Get the minimum fraction (mole, mass, volume) for incompressible fluid
+    virtual CoolPropDbl calc_fraction_min(void) {
+        throw NotImplementedError("calc_fraction_min is not implemented for this backend");
+    };
+    /// Get the maximum fraction (mole, mass, volume) for incompressible fluid
+    virtual CoolPropDbl calc_fraction_max(void) {
+        throw NotImplementedError("calc_fraction_max is not implemented for this backend");
+    };
+    virtual CoolPropDbl calc_T_freeze(void) {
+        throw NotImplementedError("calc_T_freeze is not implemented for this backend");
+    };
+
+    virtual CoolPropDbl calc_first_saturation_deriv(parameters Of1, parameters Wrt1) {
+        throw NotImplementedError("calc_first_saturation_deriv is not implemented for this backend");
+    };
+    virtual CoolPropDbl calc_second_saturation_deriv(parameters Of1, parameters Wrt1, parameters Wrt2) {
+        throw NotImplementedError("calc_second_saturation_deriv is not implemented for this backend");
+    };
+    virtual CoolPropDbl calc_first_two_phase_deriv(parameters Of, parameters Wrt, parameters Constant) {
+        throw NotImplementedError("calc_first_two_phase_deriv is not implemented for this backend");
+    };
+    virtual CoolPropDbl calc_second_two_phase_deriv(parameters Of, parameters Wrt, parameters Constant, parameters Wrt2, parameters Constant2) {
+        throw NotImplementedError("calc_second_two_phase_deriv is not implemented for this backend");
+    };
+    virtual CoolPropDbl calc_first_two_phase_deriv_splined(parameters Of, parameters Wrt, parameters Constant, CoolPropDbl x_end) {
+        throw NotImplementedError("calc_first_two_phase_deriv_splined is not implemented for this backend");
+    };
+
+    virtual CoolPropDbl calc_saturated_liquid_keyed_output(parameters key) {
+        throw NotImplementedError("calc_saturated_liquid_keyed_output is not implemented for this backend");
+    };
+    virtual CoolPropDbl calc_saturated_vapor_keyed_output(parameters key) {
+        throw NotImplementedError("calc_saturated_vapor_keyed_output is not implemented for this backend");
+    };
+    virtual void calc_ideal_curve(const std::string& type, std::vector<double>& T, std::vector<double>& p) {
+        throw NotImplementedError("calc_ideal_curve is not implemented for this backend");
+    };
+
+    /// Using this backend, get the temperature
+    virtual CoolPropDbl calc_T(void) {
+        return _T;
+    }
+    /// Using this backend, get the molar density in mol/m^3
+    virtual CoolPropDbl calc_rhomolar(void) {
+        return _rhomolar;
+    }
+
+    /// Using this backend, calculate the tangent plane distance for a given trial composition
+    virtual double calc_tangent_plane_distance(const double T, const double p, const std::vector<double>& w, const double rhomolar_guess) {
+        throw NotImplementedError("calc_tangent_plane_distance is not implemented for this backend");
+    };
+
+    /// Using this backend, return true critical point where dp/drho|T = 0 and d2p/drho^2|T = 0
+    virtual void calc_true_critical_point(double& T, double& rho) {
+        throw NotImplementedError("calc_true_critical_point is not implemented for this backend");
+    };
+
+    virtual void calc_conformal_state(const std::string& reference_fluid, CoolPropDbl& T, CoolPropDbl& rhomolar) {
+        throw NotImplementedError("calc_conformal_state is not implemented for this backend");
+    };
+
+    virtual void calc_viscosity_contributions(CoolPropDbl& dilute, CoolPropDbl& initial_density, CoolPropDbl& residual, CoolPropDbl& critical) {
+        throw NotImplementedError("calc_viscosity_contributions is not implemented for this backend");
+    };
+    virtual void calc_conductivity_contributions(CoolPropDbl& dilute, CoolPropDbl& initial_density, CoolPropDbl& residual, CoolPropDbl& critical) {
+        throw NotImplementedError("calc_conductivity_contributions is not implemented for this backend");
+    };
+    virtual std::vector<CriticalState> calc_all_critical_points(void) {
+        throw NotImplementedError("calc_all_critical_points is not implemented for this backend");
+    };
+    virtual void calc_build_spinodal() {
+        throw NotImplementedError("calc_build_spinodal is not implemented for this backend");
+    };
+    virtual SpinodalData calc_get_spinodal_data() {
+        throw NotImplementedError("calc_get_spinodal_data is not implemented for this backend");
+    };
+    virtual void calc_criticality_contour_values(double& L1star, double& M1star) {
+        throw NotImplementedError("calc_criticality_contour_values is not implemented for this backend");
+    };
+
+    /// Convert mass-based input pair to molar-based input pair;  If molar-based, do nothing
+    virtual void mass_to_molar_inputs(CoolProp::input_pairs& input_pair, CoolPropDbl& value1, CoolPropDbl& value2);
+
+    /// Change the equation of state for a given component to a specified EOS
+    virtual void calc_change_EOS(const std::size_t i, const std::string& EOS_name) {
+        throw NotImplementedError("calc_change_EOS is not implemented for this backend");
+    };
+
+   public:
+    AbstractState() : _fluid_type(FLUID_TYPE_UNDEFINED), _phase(iphase_unknown) {
+        clear();
+    }
+    virtual ~AbstractState(){};
+
+    /// A factory function to return a pointer to a new-allocated instance of one of the backends.
+    /**
+     * @brief This is a convenience function to allow for the use of '&' delimited fluid names.  Slightly less computationally efficient than the
+     * @param backend The backend in use, one of "HEOS", "REFPROP", etc.
+     * @param fluid_names Fluid names as a '&' delimited string
+     * @return
+     */
+    static AbstractState* factory(const std::string& backend, const std::string& fluid_names) {
+        return factory(backend, strsplit(fluid_names, '&'));
+    };
+
+    /**
+     * @brief A factory function to return a pointer to a new-allocated instance of one of the backends.
+     * @param backend The backend in use, "HEOS", "REFPROP", etc.
+     * @param fluid_names A vector of strings of the fluid names
+     * @return A pointer to the instance generated
+     *
+     * Several backends are possible:
+     *
+     * 1. "?" : The backend is unknown, we will parse the fluid string to determine the backend to be used.  Probably will use HEOS backend (see below)
+     * 2. "HEOS" : The Helmholtz Equation of State backend for use with pure and pseudo-pure fluids, and mixtures, all of which are based on multi-parameter Helmholtz Energy equations of state.  The fluid part of the string should then either be
+     *    1. A pure or pseudo-pure fluid name (eg. "PROPANE" or "R410A"), yielding a HelmholtzEOSBackend instance.
+     *    2. A string that encodes the components of the mixture with a "&" between them (e.g. "R32&R125"), yielding a HelmholtzEOSMixtureBackend instance.
+     *
+     * 3. "REFPROP" : The REFPROP backend will be used.  The fluid part of the string should then either be
+     *    1. A pure or pseudo-pure fluid name (eg. "PROPANE" or "R410A"), yielding a REFPROPBackend instance.
+     *    2. A string that encodes the components of the mixture with a "&" between them (e.g. "R32&R125"), yielding a REFPROPMixtureBackend instance.
+     *
+     * 4. "INCOMP": The incompressible backend will be used
+     * 5. "TTSE&XXXX": The TTSE backend will be used, and the tables will be generated using the XXXX backend where XXXX is one of the base backends("HEOS", "REFPROP", etc. )
+     * 6. "BICUBIC&XXXX": The Bicubic backend will be used, and the tables will be generated using the XXXX backend where XXXX is one of the base backends("HEOS", "REFPROP", etc. )
+     *
+     * Very Important!! : Use a smart pointer to manage the pointer returned.  In older versions of C++, you can use std::tr1::smart_ptr. In C++2011 you can use std::shared_ptr
+     */
+    static AbstractState* factory(const std::string& backend, const std::vector<std::string>& fluid_names);
+
+    /// Set the internal variable T without a flash call (expert use only!)
+    void set_T(CoolPropDbl T) {
+        _T = T;
+    }
+
+    /// Get a string representation of the backend - for instance "HelmholtzEOSMixtureBackend"
+    /// for the core mixture model in CoolProp
+    ///
+    /// Must be overloaded by the backend to provide the backend's name
+    virtual std::string backend_name(void) = 0;
+
+    // The derived classes must implement this function to define whether they use mole fractions (true) or mass fractions (false)
+    virtual bool using_mole_fractions(void) = 0;
+    virtual bool using_mass_fractions(void) = 0;
+    virtual bool using_volu_fractions(void) = 0;
+
+    virtual void set_mole_fractions(const std::vector<CoolPropDbl>& mole_fractions) = 0;
+    virtual void set_mass_fractions(const std::vector<CoolPropDbl>& mass_fractions) = 0;
+    virtual void set_volu_fractions(const std::vector<CoolPropDbl>& mass_fractions) {
+        throw NotImplementedError("Volume composition has not been implemented.");
+    }
+
+    /**
+    \brief Set the reference state based on a string representation
+
+    @param reference_state The reference state to use, one of
+
+    Reference State | Description
+    -------------   | -------------------
+    "IIR"           | h = 200 kJ/kg, s=1 kJ/kg/K at 0C saturated liquid
+    "ASHRAE"        | h = 0, s = 0 @ -40C saturated liquid
+    "NBP"           | h = 0, s = 0 @ 1.0 bar saturated liquid
+    "DEF"           | Reset to the default reference state for the fluid
+    "RESET"         | Remove the offset
+
+    The offset in the ideal gas Helmholtz energy can be obtained from
+    \f[
+    \displaystyle\frac{\Delta s}{R_u/M}+\frac{\Delta h}{(R_u/M)T}\tau
+    \f]
+    where \f$ \Delta s = s-s_{spec} \f$ and \f$ \Delta h = h-h_{spec} \f$
+    */
+    virtual void set_reference_stateS(const std::string& reference_state) {
+        throw NotImplementedError(
+          "Setting reference state has not been implemented for this backend. Try using CoolProp::set_reference_stateD instead.");
+    }
+
+    /// Set the reference state based on a thermodynamic state point specified by temperature and molar density
+    /// @param T Temperature at reference state [K]
+    /// @param rhomolar Molar density at reference state [mol/m^3]
+    /// @param hmolar0 Molar enthalpy at reference state [J/mol]
+    /// @param smolar0 Molar entropy at reference state [J/mol/K]
+    virtual void set_reference_stateD(double T, double rhomolar, double hmolar0, double smolar0) {
+        throw NotImplementedError(
+          "Setting reference state has not been implemented for this backend. Try using CoolProp::set_reference_stateD instead.");
+    }
+
+#ifndef COOLPROPDBL_MAPS_TO_DOUBLE
+    void set_mole_fractions(const std::vector<double>& mole_fractions) {
+        set_mole_fractions(std::vector<CoolPropDbl>(mole_fractions.begin(), mole_fractions.end()));
+    };
+    void set_mass_fractions(const std::vector<double>& mass_fractions) {
+        set_mass_fractions(std::vector<CoolPropDbl>(mass_fractions.begin(), mass_fractions.end()));
+    };
+    void set_volu_fractions(const std::vector<double>& volu_fractions) {
+        set_volu_fractions(std::vector<CoolPropDbl>(volu_fractions.begin(), volu_fractions.end()));
+    };
+#endif
+
+#ifdef EMSCRIPTEN
+    void set_mole_fractions_double(const std::vector<double>& mole_fractions) {
+        set_mole_fractions(std::vector<CoolPropDbl>(mole_fractions.begin(), mole_fractions.end()));
+    };
+#endif
+
+    /// Get the mole fractions of the equilibrium liquid phase
+    std::vector<CoolPropDbl> mole_fractions_liquid(void) {
+        return calc_mole_fractions_liquid();
+    };
+    /// Get the mole fractions of the equilibrium liquid phase (but as a double for use in SWIG wrapper)
+    std::vector<double> mole_fractions_liquid_double(void) {
+        std::vector<CoolPropDbl> x = calc_mole_fractions_liquid();
+        return std::vector<double>(x.begin(), x.end());
+    };
+
+    /// Get the mole fractions of the equilibrium vapor phase
+    std::vector<CoolPropDbl> mole_fractions_vapor(void) {
+        return calc_mole_fractions_vapor();
+    };
+    /// Get the mole fractions of the equilibrium vapor phase (but as a double for use in SWIG wrapper)
+    std::vector<double> mole_fractions_vapor_double(void) {
+        std::vector<CoolPropDbl> y = calc_mole_fractions_vapor();
+        return std::vector<double>(y.begin(), y.end());
+    };
+
+    /// Get the mole fractions of the fluid
+    virtual const std::vector<CoolPropDbl>& get_mole_fractions(void) = 0;
+    /// Get the mass fractions of the fluid
+    virtual const std::vector<CoolPropDbl> get_mass_fractions(void) {
+        return this->calc_mass_fractions();
+    };
+
+    /// Update the state using two state variables
+    virtual void update(CoolProp::input_pairs input_pair, double Value1, double Value2) = 0;
+
+    /// Update the state using two state variables and providing guess values
+    /// Some or all of the guesses will be used - this is backend dependent
+    virtual void update_with_guesses(CoolProp::input_pairs input_pair, double Value1, double Value2, const GuessesStructure& guesses) {
+        throw NotImplementedError("update_with_guesses is not implemented for this backend");
+    };
+
+    /// A function that says whether the backend instance can be instantiated in the high-level interface
+    /// In general this should be true, except for some other backends (especially the tabular backends)
+    /// To disable use in high-level interface, implement this function and return false
+    virtual bool available_in_high_level(void) {
+        return true;
+    }
+
+    /// Return a string from the backend for the mixture/fluid - backend dependent - could be CAS #, name, etc.
+    virtual std::string fluid_param_string(const std::string&) {
+        throw NotImplementedError("fluid_param_string has not been implemented for this backend");
+    }
+
+    /// Return a vector of strings of the fluid names that are in use
+    std::vector<std::string> fluid_names(void);
+
+    /** Get a constant for one of the fluids forming this mixture
+     *  @param i Index (0-based) of the fluid
+     *  @param param parameter you want to obtain (probably one that is a trivial parameter)
+     */
+    virtual const double get_fluid_constant(std::size_t i, parameters param) const {
+        throw NotImplementedError("get_fluid_constant is not implemented for this backend");
+    };
+    ;
+
+    /// Set binary mixture floating point parameter (EXPERT USE ONLY!!!)
+    virtual void set_binary_interaction_double(const std::string& CAS1, const std::string& CAS2, const std::string& parameter, const double value) {
+        throw NotImplementedError("set_binary_interaction_double is not implemented for this backend");
+    };
+    /// Set binary mixture floating point parameter (EXPERT USE ONLY!!!)
+    virtual void set_binary_interaction_double(const std::size_t i, const std::size_t j, const std::string& parameter, const double value) {
+        throw NotImplementedError("set_binary_interaction_double is not implemented for this backend");
+    };
+    /// Set binary mixture string parameter (EXPERT USE ONLY!!!)
+    virtual void set_binary_interaction_string(const std::string& CAS1, const std::string& CAS2, const std::string& parameter,
+                                               const std::string& value) {
+        throw NotImplementedError("set_binary_interaction_string is not implemented for this backend");
+    };
+    /// Set binary mixture string parameter (EXPERT USE ONLY!!!)
+    virtual void set_binary_interaction_string(const std::size_t i, const std::size_t j, const std::string& parameter, const std::string& value) {
+        throw NotImplementedError("set_binary_interaction_string is not implemented for this backend");
+    };
+    /// Get binary mixture double value (EXPERT USE ONLY!!!)
+    virtual double get_binary_interaction_double(const std::string& CAS1, const std::string& CAS2, const std::string& parameter) {
+        throw NotImplementedError("get_binary_interaction_double is not implemented for this backend");
+    };
+    /// Get binary mixture double value (EXPERT USE ONLY!!!)
+    virtual double get_binary_interaction_double(const std::size_t i, const std::size_t j, const std::string& parameter) {
+        throw NotImplementedError("get_binary_interaction_double is not implemented for this backend");
+    };
+    /// Get binary mixture string value (EXPERT USE ONLY!!!)
+    virtual std::string get_binary_interaction_string(const std::string& CAS1, const std::string& CAS2, const std::string& parameter) {
+        throw NotImplementedError("get_binary_interaction_string is not implemented for this backend");
+    };
+    /// Apply a simple mixing rule (EXPERT USE ONLY!!!)
+    virtual void apply_simple_mixing_rule(std::size_t i, std::size_t j, const std::string& model) {
+        throw NotImplementedError("apply_simple_mixing_rule is not implemented for this backend");
+    };
+    /// Set the cubic alpha function's constants:
+    virtual void set_cubic_alpha_C(const size_t i, const std::string& parameter, const double c1, const double c2, const double c3) {
+        throw ValueError("set_cubic_alpha_C only defined for cubic backends");
+    };
+    /// Set fluid parameter (currently the volume translation parameter for cubic)
+    virtual void set_fluid_parameter_double(const size_t i, const std::string& parameter, const double value) {
+        throw ValueError("set_fluid_parameter_double only defined for cubic backends");
+    };
+    /// Double fluid parameter (currently the volume translation parameter for cubic)
+    virtual double get_fluid_parameter_double(const size_t i, const std::string& parameter) {
+        throw ValueError("get_fluid_parameter_double only defined for cubic backends");
+    };
+
+    /// Clear all the cached values
+    virtual bool clear();
+    /// When the composition changes, clear all cached values that are only dependent on composition, but not the thermodynamic state
+    virtual bool clear_comp_change();
+
+    /// Get the state that is used in the equation of state or mixture model
+    /// to reduce the state.  For pure fluids this is usually, but not always,
+    /// the critical point.  For mixture models, it is usually composition dependent
+    virtual const CoolProp::SimpleState& get_reducing_state() {
+        return _reducing;
+    };
+
+    /// Get a desired state point - backend dependent
+    const CoolProp::SimpleState& get_state(const std::string& state) {
+        return calc_state(state);
+    };
+
+    /// Get the minimum temperature in K
+    double Tmin(void);
+    /// Get the maximum temperature in K
+    double Tmax(void);
+    /// Get the maximum pressure in Pa
+    double pmax(void);
+    /// Get the triple point temperature in K
+    double Ttriple(void);
+
+    /// Get the phase of the state
+    phases phase(void) {
+        return calc_phase();
+    };
+    /// Specify the phase for all further calculations with this state class
+    void specify_phase(phases phase) {
+        calc_specify_phase(phase);
+    };
+    /// Unspecify the phase and go back to calculating it based on the inputs
+    void unspecify_phase(void) {
+        calc_unspecify_phase();
+    };
+
+    /// Return the critical temperature in K
+    double T_critical(void);
+    /// Return the critical pressure in Pa
+    double p_critical(void);
+    /// Return the critical molar density in mol/m^3
+    double rhomolar_critical(void);
+    /// Return the critical mass density in kg/m^3
+    double rhomass_critical(void);
+
+    /// Return the vector of critical points, including points that are unstable or correspond to negative pressure
+    std::vector<CriticalState> all_critical_points(void) {
+        return calc_all_critical_points();
+    };
+
+    /// Construct the spinodal curve for the mixture (or pure fluid)
+    void build_spinodal() {
+        calc_build_spinodal();
+    };
+
+    /// Get the data from the spinodal curve constructed in the call to build_spinodal()
+    SpinodalData get_spinodal_data() {
+        return calc_get_spinodal_data();
+    };
+
+    /// Calculate the criticality contour values \f$\mathcal{L}_1^*\f$ and \f$\mathcal{M}_1^*\f$
+    void criticality_contour_values(double& L1star, double& M1star) {
+        return calc_criticality_contour_values(L1star, M1star);
+    }
+
+    /// Return the tangent plane distance for a given trial composition w
+    /// @param T Temperature (K)
+    /// @param p Pressure (Pa)
+    /// @param w The trial composition
+    /// @param rhomolar_guess (mol/m^3) The molar density guess value (if <0 (default), not used; if >0, guess value will be used in flash evaluation)
+    ///
+    /// \f[
+    /// tpd(w) = \sum_i w_i(\ln w_i + \ln \phi_i(w) - d_i)
+    /// \f]
+    /// with
+    /// \f[ d_i = \ln z_i + \ln \phi_i(z) \f]
+    /// Or you can express the \f$ tpd \f$ in terms of fugacity (See Table 7.3 from GERG 2004 monograph)
+    /// since \f$ \ln \phi_i = \ln f_i - \ln p -\ln z_i\f$
+    /// thus
+    /// \f[ d_i = \ln f_i(z) - \ln p\f]
+    /// and
+    /// \f[
+    /// tpd(w) = \sum_i w_i(\ln f_i(w) - \ln p - d_i)
+    /// \f]
+    /// and the \f$ \ln p \f$ cancel, leaving
+    /// \f[
+    /// tpd(w) = \sum_i w_i(\ln f_i(w) - \ln f_i(z))
+    /// \f]
+    double tangent_plane_distance(const double T, const double p, const std::vector<double>& w, const double rhomolar_guess = -1) {
+        return calc_tangent_plane_distance(T, p, w, rhomolar_guess);
+    };
+
+    /// Return the reducing point temperature in K
+    double T_reducing(void);
+    /// Return the molar density at the reducing point in mol/m^3
+    double rhomolar_reducing(void);
+    /// Return the mass density at the reducing point in kg/m^3
+    double rhomass_reducing(void);
+
+    /// Return the triple point pressure in Pa
+    double p_triple(void);
+
+    /// Return the name - backend dependent
+    std::string name() {
+        return calc_name();
+    };
+    /// Return the description - backend dependent
+    std::string description() {
+        return calc_description();
+    };
+
+    /// Return the dipole moment in C-m (1 D = 3.33564e-30 C-m)
+    double dipole_moment() {
+        return calc_dipole_moment();
+    }
+
+    // ----------------------------------------
+    // Bulk properties - temperature and density are directly calculated every time
+    // All other parameters are calculated on an as-needed basis
+    // ----------------------------------------
+    /// Retrieve a value by key
+    double keyed_output(parameters key);
+    /// A trivial keyed output like molar mass that does not depend on the state
+    double trivial_keyed_output(parameters key);
+    /// Get an output from the saturated liquid state by key
+    double saturated_liquid_keyed_output(parameters key) {
+        return calc_saturated_liquid_keyed_output(key);
+    };
+    /// Get an output from the saturated vapor state by key
+    double saturated_vapor_keyed_output(parameters key) {
+        return calc_saturated_vapor_keyed_output(key);
+    };
+
+    /// Return the temperature in K
+    double T(void) {
+        return calc_T();
+    };
+    /// Return the molar density in mol/m^3
+    double rhomolar(void) {
+        return calc_rhomolar();
+    };
+    /// Return the mass density in kg/m^3
+    double rhomass(void) {
+        return calc_rhomass();
+    };
+    /// Return the pressure in Pa
+    double p(void) {
+        return _p;
+    };
+    /// Return the vapor quality (mol/mol); Q = 0 for saturated liquid
+    double Q(void) {
+        return _Q;
+    };
+    /// Return the reciprocal of the reduced temperature (\f$\tau = T_c/T\f$)
+    double tau(void);
+    /// Return the reduced density (\f$\delta = \rho/\rho_c\f$)
+    double delta(void);
+    /// Return the molar mass in kg/mol
+    double molar_mass(void);
+    /// Return the acentric factor
+    double acentric_factor(void);
+    /// Return the mole-fraction weighted gas constant in J/mol/K
+    double gas_constant(void);
+    /// Return the B virial coefficient
+    double Bvirial(void);
+    /// Return the derivative of the B virial coefficient with respect to temperature
+    double dBvirial_dT(void);
+    /// Return the C virial coefficient
+    double Cvirial(void);
+    /// Return the derivative of the C virial coefficient with respect to temperature
+    double dCvirial_dT(void);
+    /// Return the compressibility factor \f$ Z = p/(rho R T) \f$
+    double compressibility_factor(void);
+    /// Return the molar enthalpy in J/mol
+    double hmolar(void);
+    /// Return the residual molar enthalpy in J/mol
+    double hmolar_residual(void);
+    /// Return the mass enthalpy in J/kg
+    double hmass(void) {
+        return calc_hmass();
+    };
+    /// Return the excess molar enthalpy in J/mol
+    double hmolar_excess(void);
+    /// Return the excess mass enthalpy in J/kg
+    double hmass_excess(void) {
+        return calc_hmass_excess();
+    };
+    /// Return the molar entropy in J/mol/K
+    double smolar(void);
+    /// Return the residual molar entropy (as a function of temperature and density) in J/mol/K
+    double smolar_residual(void);
+    /// Return the molar entropy in J/kg/K
+    double smass(void) {
+        return calc_smass();
+    };
+    /// Return the molar entropy in J/mol/K
+    double smolar_excess(void);
+    /// Return the molar entropy in J/kg/K
+    double smass_excess(void) {
+        return calc_smass_excess();
+    };
+    /// Return the molar internal energy in J/mol
+    double umolar(void);
+    /// Return the mass internal energy in J/kg
+    double umass(void) {
+        return calc_umass();
+    };
+    /// Return the excess internal energy in J/mol
+    double umolar_excess(void);
+    /// Return the excess internal energy in J/kg
+    double umass_excess(void) {
+        return calc_umass_excess();
+    };
+    /// Return the molar constant pressure specific heat in J/mol/K
+    double cpmolar(void);
+    /// Return the mass constant pressure specific heat in J/kg/K
+    double cpmass(void) {
+        return calc_cpmass();
+    };
+    /// Return the molar constant pressure specific heat for ideal gas part only in J/mol/K
+    double cp0molar(void);
+    /// Return the mass constant pressure specific heat for ideal gas part only in J/kg/K
+    double cp0mass(void) {
+        return calc_cp0mass();
+    };
+    /// Return the molar constant volume specific heat in J/mol/K
+    double cvmolar(void);
+    /// Return the mass constant volume specific heat in J/kg/K
+    double cvmass(void) {
+        return calc_cvmass();
+    };
+    /// Return the Gibbs energy in J/mol
+    double gibbsmolar(void);
+    /// Return the residual Gibbs energy in J/mol
+    double gibbsmolar_residual(void);
+    /// Return the Gibbs energy in J/kg
+    double gibbsmass(void) {
+        return calc_gibbsmass();
+    };
+    /// Return the excess Gibbs energy in J/mol
+    double gibbsmolar_excess(void);
+    /// Return the excess Gibbs energy in J/kg
+    double gibbsmass_excess(void) {
+        return calc_gibbsmass_excess();
+    };
+    /// Return the Helmholtz energy in J/mol
+    double helmholtzmolar(void);
+    /// Return the Helmholtz energy in J/kg
+    double helmholtzmass(void) {
+        return calc_helmholtzmass();
+    };
+    /// Return the excess Helmholtz energy in J/mol
+    double helmholtzmolar_excess(void);
+    /// Return the excess Helmholtz energy in J/kg
+    double helmholtzmass_excess(void) {
+        return calc_helmholtzmass_excess();
+    };
+    /// Return the excess volume in m^3/mol
+    double volumemolar_excess(void);
+    /// Return the excess volume in m^3/kg
+    double volumemass_excess(void) {
+        return calc_volumemass_excess();
+    };
+    /// Return the speed of sound in m/s
+    double speed_sound(void);
+    /// Return the isothermal compressibility \f$ \kappa = -\frac{1}{v}\left.\frac{\partial v}{\partial p}\right|_T=\frac{1}{\rho}\left.\frac{\partial \rho}{\partial p}\right|_T\f$  in 1/Pa
+    double isothermal_compressibility(void);
+    /// Return the isobaric expansion coefficient \f$ \beta = \frac{1}{v}\left.\frac{\partial v}{\partial T}\right|_p = -\frac{1}{\rho}\left.\frac{\partial \rho}{\partial T}\right|_p\f$  in 1/K
+    double isobaric_expansion_coefficient(void);
+    /// Return the isentropic expansion coefficient \f$ \kappa_s = -\frac{c_p}{c_v}\frac{v}{p}\left.\frac{\partial p}{\partial v}\right|_T = \frac{\rho}{p}\left.\frac{\partial p}{\partial \rho}\right|_s\f$
+    double isentropic_expansion_coefficient(void);
+    /// Return the fugacity coefficient of the i-th component of the mixture
+    double fugacity_coefficient(std::size_t i);
+    /// Return a vector of the fugacity coefficients for all components in the mixture
+    std::vector<double> fugacity_coefficients();
+    /// Return the fugacity of the i-th component of the mixture
+    double fugacity(std::size_t i);
+    /// Return the chemical potential of the i-th component of the mixture
+    double chemical_potential(std::size_t i);
+    /** \brief Return the fundamental derivative of gas dynamics \f$ \Gamma \f$
+     *
+     * see also Colonna et al, FPE, 2010
+     *
+     * \f[ \Gamma = 1+\frac{\rho}{c}\left(\frac{\partial c}{\partial \rho}\right)_{s} = 1+\frac{\rho}{2c^2}\left(\frac{\partial^2 p}{\partial \rho^2}\right)_{s} = \frac{v^3}{2c^2}\left(\frac{\partial^2 p}{\partial v^2}\right)_{s}\f]
+     *
+     * Note: densities are mass-based densities, not mole-based densities
+     */
+    double fundamental_derivative_of_gas_dynamics(void);
+    /// Return the phase identification parameter (PIP) of G. Venkatarathnam and L.R. Oellrich, "Identification of the phase of a fluid using partial derivatives of pressure, volume, and temperature without reference to saturation properties: Applications in phase equilibria calculations"
+    double PIP() {
+        return calc_PIP();
+    };
+
+    /// Calculate the "true" critical point for pure fluids where dpdrho|T and d2p/drho2|T are equal to zero
+    void true_critical_point(double& T, double& rho) {
+        calc_true_critical_point(T, rho);
+    }
+
+    /**
+     * \brief Calculate an ideal curve for a pure fluid
+     *
+     * @param type The type of ideal curve you would like to calculate - "Ideal", "Boyle", "Joule-Thomson", "Joule Inversion", etc.
+     * @param T The temperatures along the curve in K
+     * @param p The pressures along the curve in Pa
+    */
+    void ideal_curve(const std::string& type, std::vector<double>& T, std::vector<double>& p) {
+        calc_ideal_curve(type, T, p);
+    };
+
+    // ----------------------------------------
+    //    Partial derivatives
+    // ----------------------------------------
+
+    /** \brief The first partial derivative in homogeneous phases
+     *
+     * \f[ \left(\frac{\partial A}{\partial B}\right)_C = \frac{\left(\frac{\partial A}{\partial \tau}\right)_\delta\left(\frac{\partial C}{\partial \delta}\right)_\tau-\left(\frac{\partial A}{\partial \delta}\right)_\tau\left(\frac{\partial C}{\partial \tau}\right)_\delta}{\left(\frac{\partial B}{\partial \tau}\right)_\delta\left(\frac{\partial C}{\partial \delta}\right)_\tau-\left(\frac{\partial B}{\partial \delta}\right)_\tau\left(\frac{\partial C}{\partial \tau}\right)_\delta} = \frac{N}{D}\f]
+     */
+    CoolPropDbl first_partial_deriv(parameters Of, parameters Wrt, parameters Constant) {
+        return calc_first_partial_deriv(Of, Wrt, Constant);
+    };
+
+    /** \brief The second partial derivative in homogeneous phases
+     *
+     * The first partial derivative (\ref CoolProp::AbstractState::first_partial_deriv) can be expressed as
+     *
+     * \f[ \left(\frac{\partial A}{\partial B}\right)_C = \frac{\left(\frac{\partial A}{\partial T}\right)_\rho\left(\frac{\partial C}{\partial \rho}\right)_T-\left(\frac{\partial A}{\partial \rho}\right)_T\left(\frac{\partial C}{\partial T}\right)_\rho}{\left(\frac{\partial B}{\partial T}\right)_\rho\left(\frac{\partial C}{\partial \rho}\right)_T-\left(\frac{\partial B}{\partial \rho}\right)_T\left(\frac{\partial C}{\partial T}\right)_\rho} = \frac{N}{D}\f]
+     *
+     * and the second derivative can be expressed as
+     *
+     * \f[
+     * \frac{\partial}{\partial D}\left(\left(\frac{\partial A}{\partial B}\right)_C\right)_E = \frac{\frac{\partial}{\partial T}\left( \left(\frac{\partial A}{\partial B}\right)_C \right)_\rho\left(\frac{\partial E}{\partial \rho}\right)_T-\frac{\partial}{\partial \rho}\left(\left(\frac{\partial A}{\partial B}\right)_C\right)_T\left(\frac{\partial E}{\partial T}\right)_\rho}{\left(\frac{\partial D}{\partial T}\right)_\rho\left(\frac{\partial E}{\partial \rho}\right)_T-\left(\frac{\partial D}{\partial \rho}\right)_T\left(\frac{\partial E}{\partial T}\right)_\rho}
+     * \f]
+     *
+     * which can be expressed in parts as
+     *
+     * \f[\left(\frac{\partial N}{\partial \rho}\right)_{T} = \left(\frac{\partial A}{\partial T}\right)_\rho\left(\frac{\partial^2 C}{\partial \rho^2}\right)_{T}+\left(\frac{\partial^2 A}{\partial T\partial\rho}\right)\left(\frac{\partial C}{\partial \rho}\right)_{T}-\left(\frac{\partial A}{\partial \rho}\right)_T\left(\frac{\partial^2 C}{\partial T\partial\rho}\right)-\left(\frac{\partial^2 A}{\partial \rho^2}\right)_{T}\left(\frac{\partial C}{\partial T}\right)_\rho\f]
+     * \f[\left(\frac{\partial D}{\partial \rho}\right)_{T} = \left(\frac{\partial B}{\partial T}\right)_\rho\left(\frac{\partial^2 C}{\partial \rho^2}\right)_{T}+\left(\frac{\partial^2 B}{\partial T\partial\rho}\right)\left(\frac{\partial C}{\partial \rho}\right)_{T}-\left(\frac{\partial B}{\partial \rho}\right)_T\left(\frac{\partial^2 C}{\partial T\partial\rho}\right)-\left(\frac{\partial^2 B}{\partial \rho^2}\right)_{T}\left(\frac{\partial C}{\partial T}\right)_\rho\f]
+     * \f[\left(\frac{\partial N}{\partial T}\right)_{\rho} = \left(\frac{\partial A}{\partial T}\right)_\rho\left(\frac{\partial^2 C}{\partial \rho\partial T}\right)+\left(\frac{\partial^2 A}{\partial T^2}\right)_\rho\left(\frac{\partial C}{\partial \rho}\right)_{T}-\left(\frac{\partial A}{\partial \rho}\right)_T\left(\frac{\partial^2 C}{\partial T^2}\right)_\rho-\left(\frac{\partial^2 A}{\partial \rho\partial T}\right)\left(\frac{\partial C}{\partial T}\right)_\rho\f]
+     * \f[\left(\frac{\partial D}{\partial T}\right)_{\rho} = \left(\frac{\partial B}{\partial T}\right)_\rho\left(\frac{\partial^2 C}{\partial \rho\partial T}\right)+\left(\frac{\partial^2 B}{\partial T^2}\right)_\rho\left(\frac{\partial C}{\partial \rho}\right)_{T}-\left(\frac{\partial B}{\partial \rho}\right)_T\left(\frac{\partial^2 C}{\partial T^2}\right)_\rho-\left(\frac{\partial^2 B}{\partial \rho\partial T}\right)\left(\frac{\partial C}{\partial T}\right)_\rho\f]
+     * \f[\frac{\partial}{\partial \rho}\left( \left(\frac{\partial A}{\partial B}\right)_C \right)_T = \frac{D\left(\frac{\partial N}{\partial \rho}\right)_{T}-N\left(\frac{\partial D}{\partial \rho}\right)_{\tau}}{D^2}\f]
+     * \f[\frac{\partial}{\partial T}\left( \left(\frac{\partial A}{\partial B}\right)_C \right)_\rho = \frac{D\left(\frac{\partial N}{\partial T}\right)_{\rho}-N\left(\frac{\partial D}{\partial T}\right)_{\rho}}{D^2}\f]
+     *
+     * The terms \f$ N \f$ and \f$ D \f$ are the numerator and denominator from \ref CoolProp::AbstractState::first_partial_deriv respectively
+     */
+    CoolPropDbl second_partial_deriv(parameters Of1, parameters Wrt1, parameters Constant1, parameters Wrt2, parameters Constant2) {
+        return calc_second_partial_deriv(Of1, Wrt1, Constant1, Wrt2, Constant2);
+    };
+
+    /** \brief The first partial derivative along the saturation curve
+     *
+     * Implementing the algorithms and ideas of:
+     * Matthis Thorade, Ali Saadat, "Partial derivatives of thermodynamic state properties for dynamic simulation",
+     * Environmental Earth Sciences, December 2013, Volume 70, Issue 8, pp 3497-3503
+     *
+     * Basically the idea is that the p-T derivative is given by Clapeyron relations:
+     *
+     * \f[ \left(\frac{\partial T}{\partial p}\right)_{\sigma} = T\left(\frac{v'' - v'}{h'' - h'}\right)_{\sigma} \f]
+     *
+     * and then other derivatives can be obtained along the saturation curve from
+     *
+     * \f[ \left(\frac{\partial y}{\partial p}\right)_{\sigma} = \left(\frac{\partial y}{\partial p}\right)+\left(\frac{\partial y}{\partial T}\right)\left(\frac{\partial T}{\partial p}\right)_{\sigma} \f]
+     *
+     * \f[ \left(\frac{\partial y}{\partial T}\right)_{\sigma} = \left(\frac{\partial y}{\partial T}\right)+\left(\frac{\partial y}{\partial p}\right)\left(\frac{\partial p}{\partial T}\right)_{\sigma} \f]
+     *
+     * where derivatives without the \f$ \sigma \f$ are homogeneous (conventional) derivatives.
+     *
+     * @param Of1 The parameter that the derivative is taken of
+     * @param Wrt1 The parameter that the derivative is taken with respect to
+     */
+    CoolPropDbl first_saturation_deriv(parameters Of1, parameters Wrt1) {
+        return calc_first_saturation_deriv(Of1, Wrt1);
+    };
+
+    /** \brief The second partial derivative along the saturation curve
+     *
+     * Implementing the algorithms and ideas of:
+     * Matthis Thorade, Ali Saadat, "Partial derivatives of thermodynamic state properties for dynamic simulation",
+     * Environmental Earth Sciences, December 2013, Volume 70, Issue 8, pp 3497-3503
+     *
+     * Like with \ref first_saturation_deriv, we can express the derivative as
+     * \f[ \left(\frac{\partial y}{\partial T}\right)_{\sigma} = \left(\frac{\partial y}{\partial T}\right)+\left(\frac{\partial y}{\partial p}\right)\left(\frac{\partial p}{\partial T}\right)_{\sigma} \f]
+     *
+     * where \f$ y \f$ is already a saturation derivative. So you might end up with something like
+     *
+     * \f[ \left(\frac{\partial \left(\frac{\partial T}{\partial p}\right)_{\sigma}}{\partial T}\right)_{\sigma} = \left(\frac{\partial \left(\frac{\partial T}{\partial p}\right)_{\sigma}}{\partial T}\right)+\left(\frac{\partial \left(\frac{\partial T}{\partial p}\right)_{\sigma}}{\partial p}\right)\left(\frac{\partial p}{\partial T}\right)_{\sigma} \f]
+     *
+     * @param Of1 The parameter that the first derivative is taken of
+     * @param Wrt1 The parameter that the first derivative is taken with respect to
+     * @param Wrt2 The parameter that the second derivative is taken with respect to
+     * */
+    CoolPropDbl second_saturation_deriv(parameters Of1, parameters Wrt1, parameters Wrt2) {
+        return calc_second_saturation_deriv(Of1, Wrt1, Wrt2);
+    };
+
+    /**
+     * @brief Calculate the first "two-phase" derivative as described by Thorade and Sadaat, EAS, 2013
+     *
+     * Implementing the algorithms and ideas of:
+     * Matthis Thorade, Ali Saadat, "Partial derivatives of thermodynamic state properties for dynamic simulation",
+     * Environmental Earth Sciences, December 2013, Volume 70, Issue 8, pp 3497-3503
+     *
+     * Spline evaluation is as described in:
+     * S Quoilin, I Bell, A Desideri, P Dewallef, V Lemort,
+     * "Methods to increase the robustness of finite-volume flow models in thermodynamic systems",
+     * Energies 7 (3), 1621-1640
+     *
+     * \note Not all derivatives are supported!
+     *
+     * @param Of The parameter to be derived
+     * @param Wrt The parameter that the derivative is taken with respect to
+     * @param Constant The parameter that is held constant
+     * @return
+     */
+    double first_two_phase_deriv(parameters Of, parameters Wrt, parameters Constant) {
+        return calc_first_two_phase_deriv(Of, Wrt, Constant);
+    };
+
+    /**
+    * @brief Calculate the second "two-phase" derivative as described by Thorade and Sadaat, EAS, 2013
+    *
+    * Implementing the algorithms and ideas of:
+    * Matthis Thorade, Ali Saadat, "Partial derivatives of thermodynamic state properties for dynamic simulation",
+    * Environmental Earth Sciences, December 2013, Volume 70, Issue 8, pp 3497-3503
+    *
+    * \note Not all derivatives are supported!
+    *
+    * @param Of The parameter to be derived
+    * @param Wrt1 The parameter that the derivative is taken with respect to in the first derivative
+    * @param Constant1 The parameter that is held constant in the first derivative
+    * @param Wrt2 The parameter that the derivative is taken with respect to in the second derivative
+    * @param Constant2 The parameter that is held constant in the second derivative
+    * @return
+    */
+    double second_two_phase_deriv(parameters Of, parameters Wrt1, parameters Constant1, parameters Wrt2, parameters Constant2) {
+        return calc_second_two_phase_deriv(Of, Wrt1, Constant1, Wrt2, Constant2);
+    };
+
+    /**
+    * @brief Calculate the first "two-phase" derivative as described by Thorade and Sadaat, EAS, 2013
+    *
+    * Implementing the algorithms and ideas of:
+    * Matthis Thorade, Ali Saadat, "Partial derivatives of thermodynamic state properties for dynamic simulation",
+    * Environmental Earth Sciences, December 2013, Volume 70, Issue 8, pp 3497-3503
+    *
+    * Spline evaluation is as described in:
+    * S Quoilin, I Bell, A Desideri, P Dewallef, V Lemort,
+    * "Methods to increase the robustness of finite-volume flow models in thermodynamic systems",
+    * Energies 7 (3), 1621-1640
+    *
+    * \note Not all derivatives are supported! If you need all three currently supported values (drho_dh__p, drho_dp__h and rho_spline), you should calculate drho_dp__h first to avoid duplicate calculations.
+    *
+    * @param Of The parameter to be derived
+    * @param Wrt The parameter that the derivative is taken with respect to
+    * @param Constant The parameter that is held constant
+    * @param x_end The end vapor quality at which the spline is defined (spline is active in [0, x_end])
+    * @return
+    */
+    double first_two_phase_deriv_splined(parameters Of, parameters Wrt, parameters Constant, double x_end) {
+        return calc_first_two_phase_deriv_splined(Of, Wrt, Constant, x_end);
+    };
+
+    // ----------------------------------------
+    //    Phase envelope for mixtures
+    // ----------------------------------------
+
+    /**
+     * \brief Construct the phase envelope for a mixture
+     *
+     * @param type currently a dummy variable that is not used
+     */
+    void build_phase_envelope(const std::string& type = "");
+    /**
+     * \brief After having calculated the phase envelope, return the phase envelope data
+     */
+    const CoolProp::PhaseEnvelopeData& get_phase_envelope_data() {
+        return calc_phase_envelope_data();
+    };
+
+    // ----------------------------------------
+    //    Ancillary equations
+    // ----------------------------------------
+
+    /// Return true if the fluid has a melting line - default is false, but can be re-implemented by derived class
+    virtual bool has_melting_line(void) {
+        return false;
+    };
+    /// Return a value from the melting line
+    /// @param param The key for the parameter to be returned
+    /// @param given The key for the parameter that is given
+    /// @param value The value for the parameter that is given
+    double melting_line(int param, int given, double value);
+    /// Return the value from a saturation ancillary curve (if the backend implements it)
+    /// @param param The key for the parameter to be returned
+    /// @param Q The quality for the parameter that is given (0 = saturated liquid, 1 = saturated vapor)
+    /// @param given The key for the parameter that is given
+    /// @param value The value for the parameter that is given
+    double saturation_ancillary(parameters param, int Q, parameters given, double value);
+
+    // ----------------------------------------
+    // Transport properties
+    // ----------------------------------------
+    /// Return the viscosity in Pa-s
+    double viscosity(void);
+    /// Return the viscosity contributions, each in Pa-s
+    void viscosity_contributions(CoolPropDbl& dilute, CoolPropDbl& initial_density, CoolPropDbl& residual, CoolPropDbl& critical) {
+        calc_viscosity_contributions(dilute, initial_density, residual, critical);
+    };
+    /// Return the thermal conductivity in W/m/K
+    double conductivity(void);
+    /// Return the thermal conductivity contributions, each in W/m/K
+    void conductivity_contributions(CoolPropDbl& dilute, CoolPropDbl& initial_density, CoolPropDbl& residual, CoolPropDbl& critical) {
+        calc_conductivity_contributions(dilute, initial_density, residual, critical);
+    };
+    /// Return the surface tension in N/m
+    double surface_tension(void);
+    /// Return the Prandtl number (dimensionless)
+    double Prandtl(void) {
+        return cpmass() * viscosity() / conductivity();
+    };
+    /**
+     * @brief Find the conformal state needed for ECS
+     * @param reference_fluid The reference fluid for which the conformal state will be calculated
+     * @param T Temperature (initial guess must be provided, or < 0 to start with unity shape factors)
+     * @param rhomolar Molar density (initial guess must be provided, or < 0 to start with unity shape factors)
+     */
+    void conformal_state(const std::string& reference_fluid, CoolPropDbl& T, CoolPropDbl& rhomolar) {
+        return calc_conformal_state(reference_fluid, T, rhomolar);
+    };
+
+    /// \brief Change the equation of state for a given component to a specified EOS
+    /// @param i Index of the component to change (if a pure fluid, i=0)
+    /// @param EOS_name Name of the EOS to use (something like "SRK", "PR", "XiangDeiters", but backend-specific)
+    /// \note Calls the calc_change_EOS function of the implementation
+    void change_EOS(const std::size_t i, const std::string& EOS_name) {
+        calc_change_EOS(i, EOS_name);
+    }
+
+    // ----------------------------------------
+    // Helmholtz energy and derivatives
+    // ----------------------------------------
+    /// Return the term \f$ \alpha^0 \f$
+    CoolPropDbl alpha0(void) {
+        if (!_alpha0) _alpha0 = calc_alpha0();
+        return _alpha0;
+    };
+    /// Return the term \f$ \alpha^0_{\delta} \f$
+    CoolPropDbl dalpha0_dDelta(void) {
+        if (!_dalpha0_dDelta) _dalpha0_dDelta = calc_dalpha0_dDelta();
+        return _dalpha0_dDelta;
+    };
+    /// Return the term \f$ \alpha^0_{\tau} \f$
+    CoolPropDbl dalpha0_dTau(void) {
+        if (!_dalpha0_dTau) _dalpha0_dTau = calc_dalpha0_dTau();
+        return _dalpha0_dTau;
+    };
+    /// Return the term \f$ \alpha^0_{\delta\delta} \f$
+    CoolPropDbl d2alpha0_dDelta2(void) {
+        if (!_d2alpha0_dDelta2) _d2alpha0_dDelta2 = calc_d2alpha0_dDelta2();
+        return _d2alpha0_dDelta2;
+    };
+    /// Return the term \f$ \alpha^0_{\delta\tau} \f$
+    CoolPropDbl d2alpha0_dDelta_dTau(void) {
+        if (!_d2alpha0_dDelta_dTau) _d2alpha0_dDelta_dTau = calc_d2alpha0_dDelta_dTau();
+        return _d2alpha0_dDelta_dTau;
+    };
+    /// Return the term \f$ \alpha^0_{\tau\tau} \f$
+    CoolPropDbl d2alpha0_dTau2(void) {
+        if (!_d2alpha0_dTau2) _d2alpha0_dTau2 = calc_d2alpha0_dTau2();
+        return _d2alpha0_dTau2;
+    };
+    /// Return the term \f$ \alpha^0_{\tau\tau\tau} \f$
+    CoolPropDbl d3alpha0_dTau3(void) {
+        if (!_d3alpha0_dTau3) _d3alpha0_dTau3 = calc_d3alpha0_dTau3();
+        return _d3alpha0_dTau3;
+    };
+    /// Return the term \f$ \alpha^0_{\delta\tau\tau} \f$
+    CoolPropDbl d3alpha0_dDelta_dTau2(void) {
+        if (!_d3alpha0_dDelta_dTau2) _d3alpha0_dDelta_dTau2 = calc_d3alpha0_dDelta_dTau2();
+        return _d3alpha0_dDelta_dTau2;
+    };
+    /// Return the term \f$ \alpha^0_{\delta\delta\tau} \f$
+    CoolPropDbl d3alpha0_dDelta2_dTau(void) {
+        if (!_d3alpha0_dDelta2_dTau) _d3alpha0_dDelta2_dTau = calc_d3alpha0_dDelta2_dTau();
+        return _d3alpha0_dDelta2_dTau;
+    };
+    /// Return the term \f$ \alpha^0_{\delta\delta\delta} \f$
+    CoolPropDbl d3alpha0_dDelta3(void) {
+        if (!_d3alpha0_dDelta3) _d3alpha0_dDelta3 = calc_d3alpha0_dDelta3();
+        return _d3alpha0_dDelta3;
+    };
+
+    /// Return the term \f$ \alpha^r \f$
+    CoolPropDbl alphar(void) {
+        if (!_alphar) _alphar = calc_alphar();
+        return _alphar;
+    };
+    /// Return the term \f$ \alpha^r_{\delta} \f$
+    CoolPropDbl dalphar_dDelta(void) {
+        if (!_dalphar_dDelta) _dalphar_dDelta = calc_dalphar_dDelta();
+        return _dalphar_dDelta;
+    };
+    /// Return the term \f$ \alpha^r_{\tau} \f$
+    CoolPropDbl dalphar_dTau(void) {
+        if (!_dalphar_dTau) _dalphar_dTau = calc_dalphar_dTau();
+        return _dalphar_dTau;
+    };
+    /// Return the term \f$ \alpha^r_{\delta\delta} \f$
+    CoolPropDbl d2alphar_dDelta2(void) {
+        if (!_d2alphar_dDelta2) _d2alphar_dDelta2 = calc_d2alphar_dDelta2();
+        return _d2alphar_dDelta2;
+    };
+    /// Return the term \f$ \alpha^r_{\delta\tau} \f$
+    CoolPropDbl d2alphar_dDelta_dTau(void) {
+        if (!_d2alphar_dDelta_dTau) _d2alphar_dDelta_dTau = calc_d2alphar_dDelta_dTau();
+        return _d2alphar_dDelta_dTau;
+    };
+    /// Return the term \f$ \alpha^r_{\tau\tau} \f$
+    CoolPropDbl d2alphar_dTau2(void) {
+        if (!_d2alphar_dTau2) _d2alphar_dTau2 = calc_d2alphar_dTau2();
+        return _d2alphar_dTau2;
+    };
+    /// Return the term \f$ \alpha^r_{\delta\delta\delta} \f$
+    CoolPropDbl d3alphar_dDelta3(void) {
+        if (!_d3alphar_dDelta3) _d3alphar_dDelta3 = calc_d3alphar_dDelta3();
+        return _d3alphar_dDelta3;
+    };
+    /// Return the term \f$ \alpha^r_{\delta\delta\tau} \f$
+    CoolPropDbl d3alphar_dDelta2_dTau(void) {
+        if (!_d3alphar_dDelta2_dTau) _d3alphar_dDelta2_dTau = calc_d3alphar_dDelta2_dTau();
+        return _d3alphar_dDelta2_dTau;
+    };
+    /// Return the term \f$ \alpha^r_{\delta\tau\tau} \f$
+    CoolPropDbl d3alphar_dDelta_dTau2(void) {
+        if (!_d3alphar_dDelta_dTau2) _d3alphar_dDelta_dTau2 = calc_d3alphar_dDelta_dTau2();
+        return _d3alphar_dDelta_dTau2;
+    };
+    /// Return the term \f$ \alpha^r_{\tau\tau\tau} \f$
+    CoolPropDbl d3alphar_dTau3(void) {
+        if (!_d3alphar_dTau3) _d3alphar_dTau3 = calc_d3alphar_dTau3();
+        return _d3alphar_dTau3;
+    };
+    /// Return the term \f$ \alpha^r_{\delta\delta\delta\delta} \f$
+    CoolPropDbl d4alphar_dDelta4(void) {
+        if (!_d4alphar_dDelta4) _d4alphar_dDelta4 = calc_d4alphar_dDelta4();
+        return _d4alphar_dDelta4;
+    };
+    /// Return the term \f$ \alpha^r_{\delta\delta\delta\tau} \f$
+    CoolPropDbl d4alphar_dDelta3_dTau(void) {
+        if (!_d4alphar_dDelta3_dTau) _d4alphar_dDelta3_dTau = calc_d4alphar_dDelta3_dTau();
+        return _d4alphar_dDelta3_dTau;
+    };
+    /// Return the term \f$ \alpha^r_{\delta\delta\tau\tau} \f$
+    CoolPropDbl d4alphar_dDelta2_dTau2(void) {
+        if (!_d4alphar_dDelta2_dTau2) _d4alphar_dDelta2_dTau2 = calc_d4alphar_dDelta2_dTau2();
+        return _d4alphar_dDelta2_dTau2;
+    };
+    /// Return the term \f$ \alpha^r_{\delta\tau\tau\tau} \f$
+    CoolPropDbl d4alphar_dDelta_dTau3(void) {
+        if (!_d4alphar_dDelta_dTau3) _d4alphar_dDelta_dTau3 = calc_d4alphar_dDelta_dTau3();
+        return _d4alphar_dDelta_dTau3;
+    };
+    /// Return the term \f$ \alpha^r_{\tau\tau\tau\tau} \f$
+    CoolPropDbl d4alphar_dTau4(void) {
+        if (!_d4alphar_dTau4) _d4alphar_dTau4 = calc_d4alphar_dTau4();
+        return _d4alphar_dTau4;
+    };
+};
+
+/** An abstract AbstractState generator class
+ *
+ *  This class should be derived and statically initialized in a C++ file.  In the initializer,
+ *  the register_backend function should be called.  This will register the backend family, and
+ *  when this generator is looked up in the map, the get_AbstractState function will be used
+ *  to return an initialized instance
+ */
+class AbstractStateGenerator
+{
+   public:
+    virtual AbstractState* get_AbstractState(const std::vector<std::string>& fluid_names) = 0;
+    virtual ~AbstractStateGenerator(){};
+};
+
+/** Register a backend in the backend library (statically defined in AbstractState.cpp and not
+ *  publicly accessible)
+ */
+void register_backend(const backend_families& bf, shared_ptr<AbstractStateGenerator> gen);
+
+template <class T>
+class GeneratorInitializer
+{
+   public:
+    GeneratorInitializer(backend_families bf) {
+        register_backend(bf, shared_ptr<AbstractStateGenerator>(new T()));
+    };
+};
+
+} /* namespace CoolProp */
+#endif /* ABSTRACTSTATE_H_ */
```

## CoolProp/include/Ancillaries.h

 * *Ordering differences only*

```diff
@@ -1,263 +1,263 @@
-#ifndef ANCILLARIES_H
-#define ANCILLARIES_H
-
-#include "Exceptions.h"
-#include <vector>
-#include "rapidjson_include.h"
-#include "Eigen/Core"
-#include "PolyMath.h"
-
-namespace CoolProp {
-
-/**
-The surface tension correlation class uses correlations for the surface tension that are all
-of the form
-
-\f[
-\sigma = \sum_i a_i\left(1-\frac{T}{\tilde T_c}\right)^{n_i}
-\f]
-
-where \f$ \tilde T_c \f$ is the critical temperature used for the correlation which is
-almost always equal to the critical temperature of the equation of state.  Result for
-surface tension is in N/m
-*/
-class SurfaceTensionCorrelation
-{
-   public:
-    std::vector<CoolPropDbl> a,  ///< the leading coefficients a_i
-      n,                         ///< the powers n_i
-      s;                         ///< a summation buffer
-    CoolPropDbl Tc;              ///< critical temperature in K
-    std::size_t N;               ///< number of a_i, n_i pairs
-    std::string BibTeX;          ///< The BiBTeX key for the surface tension curve in use
-
-    SurfaceTensionCorrelation() : Tc(_HUGE), N(0) {}
-    SurfaceTensionCorrelation(rapidjson::Value& json_code) {
-        a = cpjson::get_long_double_array(json_code["a"]);
-        n = cpjson::get_long_double_array(json_code["n"]);
-
-        Tc = cpjson::get_double(json_code, "Tc");
-        BibTeX = cpjson::get_string(json_code, "BibTeX");
-
-        this->N = n.size();
-        s = n;
-    };
-    /// Actually evaluate the surface tension equation
-    CoolPropDbl evaluate(CoolPropDbl T) {
-        if (a.empty()) {
-            throw NotImplementedError(format("surface tension curve not provided"));
-        }
-        if (T > Tc) {
-            throw ValueError(format("Must be saturated state : T <= Tc"));
-        }
-        CoolPropDbl THETA = 1 - T / Tc;
-        for (std::size_t i = 0; i < N; ++i) {
-            s[i] = a[i] * pow(THETA, n[i]);
-        }
-        return std::accumulate(s.begin(), s.end(), 0.0);
-    }
-};
-/**
- *
- * This is generalized class that can be used to manage an ancillary curve,
- * here they are ancillary curves for saturation pressure, density, enthalpy, entropy.
- *
- * The form of the ancillary equation can take one of a number of forms:
- *
- * a) So-called "exponential" form (type = TYPE_EXPONENTIAL) that has a form like
- *
- * \f[ y = y_c\exp\left(\frac{T_c}{T}\sum(n_i \theta^{t_i})\right) \f]
- * or
- * \f[ y = y_c\exp\left(\sum(n_i \theta^{t_i})\right) \f]
- *
- * b) A non-exponential form (type = TYPE_NOT_EXPONENTIAL) that has a form of
- *
- * \f[ y = y_c\left(1+\sum_i(n_i\theta^t_i)\right) \f]
- * with
- * \f[ \theta = \left(1-\frac{T}{T_c}\right) \f]
- * which is conveniently equal to zero at the critical point
- *
- * c) Rational polynomial form (type = TYPE_RATIONAL_POLYNOMIAL) that has a form of
- * \f[ y = \frac{\sum_iA_iT^i}{\sum_iB_iT^i}\f]
- * where i is an integer, and the coefficients are in increasing order in both numerator and denominator
-*/
-class SaturationAncillaryFunction
-{
-   private:
-    Eigen::MatrixXd num_coeffs,   ///< Coefficients for numerator in rational polynomial
-      den_coeffs;                 ///< Coefficients for denominator in rational polynomial
-    std::vector<double> n, t, s;  // For TYPE_NOT_EXPONENTIAL & TYPE_EXPONENTIAL
-    union
-    {
-        CoolPropDbl max_abs_error;  ///< For TYPE_RATIONAL_POLYNOMIAL
-        struct
-        {                                // For TYPE_NOT_EXPONENTIAL & TYPE_EXPONENTIAL
-            bool using_tau_r;            ///< Whether the term \f$ \frac{T_c}{T} \f$ is included in the
-            CoolPropDbl reducing_value,  ///< The value used to reduce the output variable
-              T_r;                       ///< The temperature in K used to reduce the temperature (usually the critical temperature)
-            std::size_t N;               ///< The number of values in the arrays
-        };
-    };
-    CoolPropDbl Tmax,  ///< The maximum temperature in K
-      Tmin;            ///< The minimum temperature in K
-    enum ancillaryfunctiontypes
-    {
-        TYPE_NOT_SET = 0,
-        TYPE_NOT_EXPONENTIAL,     ///< It is a non-exponential type of equation
-        TYPE_EXPONENTIAL,         ///< It is an exponential type equation, with or without the T_c/T term
-        TYPE_RATIONAL_POLYNOMIAL  ///< It is a rational polynomial equation
-    };
-    ancillaryfunctiontypes type;  ///< The type of ancillary curve being used
-   public:
-    SaturationAncillaryFunction() {
-        type = TYPE_NOT_SET;
-        Tmin = _HUGE;
-        Tmax = _HUGE;
-    };
-    SaturationAncillaryFunction(rapidjson::Value& json_code);
-
-    /// Return true if the ancillary is enabled (type is not TYPE_NOT_SET)
-    bool enabled(void) {
-        return type != TYPE_NOT_SET;
-    }
-
-    /// Get the maximum absolute error for this fit
-    /// @returns max_abs_error the maximum absolute error for ancillaries that are characterized by maximum absolute error
-    CoolPropDbl get_max_abs_error() {
-        return max_abs_error;
-    };
-
-    /// Evaluate this ancillary function, yielding for instance the saturated liquid density
-    /// @param T The temperature in K
-    /// @returns y the value of the ancillary function at temperature T
-    double evaluate(double T);
-
-    /// Invert this ancillary function, and calculate the temperature given the output the value of the function
-    /// @param value The value of the output
-    /// @param min_bound (optional) The minimum value for T; ignored if < 0
-    /// @param max_bound (optional) The maximum value for T; ignored if < 0
-    /// @returns T The temperature in K
-    double invert(double value, double min_bound = -1, double max_bound = -1);
-
-    /// Get the minimum temperature in K
-    double get_Tmin(void) {
-        return Tmin;
-    };
-
-    /// Get the maximum temperature in K
-    double get_Tmax(void) {
-        return Tmax;
-    };
-};
-
-// ****************************************************************************
-// ****************************************************************************
-//                                 MELTING LINE
-// ****************************************************************************
-// ****************************************************************************
-
-struct MeltingLinePiecewiseSimonSegment
-{
-    CoolPropDbl T_0, a, c, p_0, T_max, T_min, p_min, p_max;
-};
-struct MeltingLinePiecewiseSimonData
-{
-    std::vector<MeltingLinePiecewiseSimonSegment> parts;
-};
-
-/**
-\brief The evaluator class for a melting curve formed of segments in the form
-
-\f[
-a_i((\frac{T}{T_0})^{t_i}-1)
-\f]
-*/
-class MeltingLinePiecewisePolynomialInTrSegment
-{
-   public:
-    std::vector<CoolPropDbl> a, t;
-    CoolPropDbl T_0, p_0, T_max, T_min, p_min, p_max;
-    CoolPropDbl evaluate(CoolPropDbl T) {
-        CoolPropDbl summer = 0;
-        for (std::size_t i = 0; i < a.size(); ++i) {
-            summer += a[i] * (pow(T / T_0, t[i]) - 1);
-        }
-        return p_0 * (1 + summer);
-    }
-};
-struct MeltingLinePiecewisePolynomialInTrData
-{
-    std::vector<MeltingLinePiecewisePolynomialInTrSegment> parts;
-};
-
-/**
- \brief The evaluator class for a melting curve formed of segments in the form
-
- \f[
- a_i(\frac{T}{T_0}-1)^t_i
- \f]
-*/
-class MeltingLinePiecewisePolynomialInThetaSegment
-{
-   public:
-    std::vector<CoolPropDbl> a, t;
-    CoolPropDbl T_0, p_0, T_max, T_min, p_min, p_max;
-
-    CoolPropDbl evaluate(CoolPropDbl T) {
-        CoolPropDbl summer = 0;
-        for (std::size_t i = 0; i < a.size(); ++i) {
-            summer += a[i] * pow(T / T_0 - 1, t[i]);
-        }
-        return p_0 * (1 + summer);
-    }
-};
-struct MeltingLinePiecewisePolynomialInThetaData
-{
-    std::vector<MeltingLinePiecewisePolynomialInThetaSegment> parts;
-};
-
-class MeltingLineVariables
-{
-   public:
-    enum MeltingLineVariablesEnum
-    {
-        MELTING_LINE_NOT_SET = 0,
-        MELTING_LINE_SIMON_TYPE,                ///< A simon-type curve is in use
-        MELTING_LINE_POLYNOMIAL_IN_TR_TYPE,     ///< a polynomial in \f$ T/T_c \f$ is in use
-        MELTING_LINE_POLYNOMIAL_IN_THETA_TYPE,  ///< a polynomial in \f$ \theta \f$ is in use
-    };
-    CoolPropDbl Tmin,  ///< Minimum temperature in K
-      Tmax,            ///< Maximum temperature in K
-      pmin,            ///< Minimum pressure in Pa
-      pmax;            ///< Maximum pressure in Pa
-
-    std::string BibTeX;                   ///< BibTeX key for the melting curve in use
-    CoolPropDbl T_m;                      ///< Melting temperature at 1 atmosphere
-    MeltingLinePiecewiseSimonData simon;  /// The data used for a Simon-style curve
-    MeltingLinePiecewisePolynomialInTrData
-      polynomial_in_Tr;  /// The data needed for a melting curve formed of segments that are polynomials in \f$ T/T_c \f$
-    MeltingLinePiecewisePolynomialInThetaData
-      polynomial_in_Theta;  /// The data needed for a melting curve formed of segments that are polynomials in \f$ \theta \f$
-    int type;
-
-    MeltingLineVariables() : Tmin(_HUGE), Tmax(_HUGE), pmin(_HUGE), pmax(_HUGE), T_m(_HUGE), type(MELTING_LINE_NOT_SET){};
-
-    /**
-     * \brief Evaluate the melting line
-     * @param OF The output variable
-     * @param GIVEN The given variable
-     * @param value The value of the given variable
-     */
-    CoolPropDbl evaluate(int OF, int GIVEN, CoolPropDbl value);
-
-    /// Evaluate the melting line to calculate the limits of the curve (Tmin/Tmax and pmin/pmax)
-    void set_limits();
-
-    /// Return true if the ancillary is enabled (type is not the default value of MELTING_LINE_NOT_SET)
-    bool enabled() {
-        return type != MELTING_LINE_NOT_SET;
-    };
-};
-
-} /* namespace CoolProp */
+#ifndef ANCILLARIES_H
+#define ANCILLARIES_H
+
+#include "Exceptions.h"
+#include <vector>
+#include "rapidjson_include.h"
+#include "Eigen/Core"
+#include "PolyMath.h"
+
+namespace CoolProp {
+
+/**
+The surface tension correlation class uses correlations for the surface tension that are all
+of the form
+
+\f[
+\sigma = \sum_i a_i\left(1-\frac{T}{\tilde T_c}\right)^{n_i}
+\f]
+
+where \f$ \tilde T_c \f$ is the critical temperature used for the correlation which is
+almost always equal to the critical temperature of the equation of state.  Result for
+surface tension is in N/m
+*/
+class SurfaceTensionCorrelation
+{
+   public:
+    std::vector<CoolPropDbl> a,  ///< the leading coefficients a_i
+      n,                         ///< the powers n_i
+      s;                         ///< a summation buffer
+    CoolPropDbl Tc;              ///< critical temperature in K
+    std::size_t N;               ///< number of a_i, n_i pairs
+    std::string BibTeX;          ///< The BiBTeX key for the surface tension curve in use
+
+    SurfaceTensionCorrelation() : Tc(_HUGE), N(0) {}
+    SurfaceTensionCorrelation(rapidjson::Value& json_code) {
+        a = cpjson::get_long_double_array(json_code["a"]);
+        n = cpjson::get_long_double_array(json_code["n"]);
+
+        Tc = cpjson::get_double(json_code, "Tc");
+        BibTeX = cpjson::get_string(json_code, "BibTeX");
+
+        this->N = n.size();
+        s = n;
+    };
+    /// Actually evaluate the surface tension equation
+    CoolPropDbl evaluate(CoolPropDbl T) {
+        if (a.empty()) {
+            throw NotImplementedError(format("surface tension curve not provided"));
+        }
+        if (T > Tc) {
+            throw ValueError(format("Must be saturated state : T <= Tc"));
+        }
+        CoolPropDbl THETA = 1 - T / Tc;
+        for (std::size_t i = 0; i < N; ++i) {
+            s[i] = a[i] * pow(THETA, n[i]);
+        }
+        return std::accumulate(s.begin(), s.end(), 0.0);
+    }
+};
+/**
+ *
+ * This is generalized class that can be used to manage an ancillary curve,
+ * here they are ancillary curves for saturation pressure, density, enthalpy, entropy.
+ *
+ * The form of the ancillary equation can take one of a number of forms:
+ *
+ * a) So-called "exponential" form (type = TYPE_EXPONENTIAL) that has a form like
+ *
+ * \f[ y = y_c\exp\left(\frac{T_c}{T}\sum(n_i \theta^{t_i})\right) \f]
+ * or
+ * \f[ y = y_c\exp\left(\sum(n_i \theta^{t_i})\right) \f]
+ *
+ * b) A non-exponential form (type = TYPE_NOT_EXPONENTIAL) that has a form of
+ *
+ * \f[ y = y_c\left(1+\sum_i(n_i\theta^t_i)\right) \f]
+ * with
+ * \f[ \theta = \left(1-\frac{T}{T_c}\right) \f]
+ * which is conveniently equal to zero at the critical point
+ *
+ * c) Rational polynomial form (type = TYPE_RATIONAL_POLYNOMIAL) that has a form of
+ * \f[ y = \frac{\sum_iA_iT^i}{\sum_iB_iT^i}\f]
+ * where i is an integer, and the coefficients are in increasing order in both numerator and denominator
+*/
+class SaturationAncillaryFunction
+{
+   private:
+    Eigen::MatrixXd num_coeffs,   ///< Coefficients for numerator in rational polynomial
+      den_coeffs;                 ///< Coefficients for denominator in rational polynomial
+    std::vector<double> n, t, s;  // For TYPE_NOT_EXPONENTIAL & TYPE_EXPONENTIAL
+    union
+    {
+        CoolPropDbl max_abs_error;  ///< For TYPE_RATIONAL_POLYNOMIAL
+        struct
+        {                                // For TYPE_NOT_EXPONENTIAL & TYPE_EXPONENTIAL
+            bool using_tau_r;            ///< Whether the term \f$ \frac{T_c}{T} \f$ is included in the
+            CoolPropDbl reducing_value,  ///< The value used to reduce the output variable
+              T_r;                       ///< The temperature in K used to reduce the temperature (usually the critical temperature)
+            std::size_t N;               ///< The number of values in the arrays
+        };
+    };
+    CoolPropDbl Tmax,  ///< The maximum temperature in K
+      Tmin;            ///< The minimum temperature in K
+    enum ancillaryfunctiontypes
+    {
+        TYPE_NOT_SET = 0,
+        TYPE_NOT_EXPONENTIAL,     ///< It is a non-exponential type of equation
+        TYPE_EXPONENTIAL,         ///< It is an exponential type equation, with or without the T_c/T term
+        TYPE_RATIONAL_POLYNOMIAL  ///< It is a rational polynomial equation
+    };
+    ancillaryfunctiontypes type;  ///< The type of ancillary curve being used
+   public:
+    SaturationAncillaryFunction() {
+        type = TYPE_NOT_SET;
+        Tmin = _HUGE;
+        Tmax = _HUGE;
+    };
+    SaturationAncillaryFunction(rapidjson::Value& json_code);
+
+    /// Return true if the ancillary is enabled (type is not TYPE_NOT_SET)
+    bool enabled(void) {
+        return type != TYPE_NOT_SET;
+    }
+
+    /// Get the maximum absolute error for this fit
+    /// @returns max_abs_error the maximum absolute error for ancillaries that are characterized by maximum absolute error
+    CoolPropDbl get_max_abs_error() {
+        return max_abs_error;
+    };
+
+    /// Evaluate this ancillary function, yielding for instance the saturated liquid density
+    /// @param T The temperature in K
+    /// @returns y the value of the ancillary function at temperature T
+    double evaluate(double T);
+
+    /// Invert this ancillary function, and calculate the temperature given the output the value of the function
+    /// @param value The value of the output
+    /// @param min_bound (optional) The minimum value for T; ignored if < 0
+    /// @param max_bound (optional) The maximum value for T; ignored if < 0
+    /// @returns T The temperature in K
+    double invert(double value, double min_bound = -1, double max_bound = -1);
+
+    /// Get the minimum temperature in K
+    double get_Tmin(void) {
+        return Tmin;
+    };
+
+    /// Get the maximum temperature in K
+    double get_Tmax(void) {
+        return Tmax;
+    };
+};
+
+// ****************************************************************************
+// ****************************************************************************
+//                                 MELTING LINE
+// ****************************************************************************
+// ****************************************************************************
+
+struct MeltingLinePiecewiseSimonSegment
+{
+    CoolPropDbl T_0, a, c, p_0, T_max, T_min, p_min, p_max;
+};
+struct MeltingLinePiecewiseSimonData
+{
+    std::vector<MeltingLinePiecewiseSimonSegment> parts;
+};
+
+/**
+\brief The evaluator class for a melting curve formed of segments in the form
+
+\f[
+a_i((\frac{T}{T_0})^{t_i}-1)
+\f]
+*/
+class MeltingLinePiecewisePolynomialInTrSegment
+{
+   public:
+    std::vector<CoolPropDbl> a, t;
+    CoolPropDbl T_0, p_0, T_max, T_min, p_min, p_max;
+    CoolPropDbl evaluate(CoolPropDbl T) {
+        CoolPropDbl summer = 0;
+        for (std::size_t i = 0; i < a.size(); ++i) {
+            summer += a[i] * (pow(T / T_0, t[i]) - 1);
+        }
+        return p_0 * (1 + summer);
+    }
+};
+struct MeltingLinePiecewisePolynomialInTrData
+{
+    std::vector<MeltingLinePiecewisePolynomialInTrSegment> parts;
+};
+
+/**
+ \brief The evaluator class for a melting curve formed of segments in the form
+
+ \f[
+ a_i(\frac{T}{T_0}-1)^t_i
+ \f]
+*/
+class MeltingLinePiecewisePolynomialInThetaSegment
+{
+   public:
+    std::vector<CoolPropDbl> a, t;
+    CoolPropDbl T_0, p_0, T_max, T_min, p_min, p_max;
+
+    CoolPropDbl evaluate(CoolPropDbl T) {
+        CoolPropDbl summer = 0;
+        for (std::size_t i = 0; i < a.size(); ++i) {
+            summer += a[i] * pow(T / T_0 - 1, t[i]);
+        }
+        return p_0 * (1 + summer);
+    }
+};
+struct MeltingLinePiecewisePolynomialInThetaData
+{
+    std::vector<MeltingLinePiecewisePolynomialInThetaSegment> parts;
+};
+
+class MeltingLineVariables
+{
+   public:
+    enum MeltingLineVariablesEnum
+    {
+        MELTING_LINE_NOT_SET = 0,
+        MELTING_LINE_SIMON_TYPE,                ///< A simon-type curve is in use
+        MELTING_LINE_POLYNOMIAL_IN_TR_TYPE,     ///< a polynomial in \f$ T/T_c \f$ is in use
+        MELTING_LINE_POLYNOMIAL_IN_THETA_TYPE,  ///< a polynomial in \f$ \theta \f$ is in use
+    };
+    CoolPropDbl Tmin,  ///< Minimum temperature in K
+      Tmax,            ///< Maximum temperature in K
+      pmin,            ///< Minimum pressure in Pa
+      pmax;            ///< Maximum pressure in Pa
+
+    std::string BibTeX;                   ///< BibTeX key for the melting curve in use
+    CoolPropDbl T_m;                      ///< Melting temperature at 1 atmosphere
+    MeltingLinePiecewiseSimonData simon;  /// The data used for a Simon-style curve
+    MeltingLinePiecewisePolynomialInTrData
+      polynomial_in_Tr;  /// The data needed for a melting curve formed of segments that are polynomials in \f$ T/T_c \f$
+    MeltingLinePiecewisePolynomialInThetaData
+      polynomial_in_Theta;  /// The data needed for a melting curve formed of segments that are polynomials in \f$ \theta \f$
+    int type;
+
+    MeltingLineVariables() : Tmin(_HUGE), Tmax(_HUGE), pmin(_HUGE), pmax(_HUGE), T_m(_HUGE), type(MELTING_LINE_NOT_SET){};
+
+    /**
+     * \brief Evaluate the melting line
+     * @param OF The output variable
+     * @param GIVEN The given variable
+     * @param value The value of the given variable
+     */
+    CoolPropDbl evaluate(int OF, int GIVEN, CoolPropDbl value);
+
+    /// Evaluate the melting line to calculate the limits of the curve (Tmin/Tmax and pmin/pmax)
+    void set_limits();
+
+    /// Return true if the ancillary is enabled (type is not the default value of MELTING_LINE_NOT_SET)
+    bool enabled() {
+        return type != MELTING_LINE_NOT_SET;
+    };
+};
+
+} /* namespace CoolProp */
 #endif
```

## CoolProp/include/CPfilepaths.h

 * *Ordering differences only*

```diff
@@ -1,36 +1,36 @@
-#ifndef COOLPROP_FILE_PATH_H
-#define COOLPROP_FILE_PATH_H
-
-#include <string>
-#include <vector>
-
-/// Get directory separator
-std::string get_separator(void);
-
-/// Get the user's home directory;  It is believed that is is always a place that files can be written
-std::string get_home_dir(void);
-
-/// Return true if path exists
-bool path_exists(const std::string& path);
-
-/// Return merged path, append separator if string two is empty
-std::string join_path(const std::string& one, const std::string& two);
-
-/// Make directory and all required intermediate directories
-void make_dirs(std::string file_path);
-
-/// Get the size of a directory in bytes
-#if defined(__ISWINDOWS__)
-unsigned long long CalculateDirSize(const std::wstring& path, std::vector<std::wstring>* errVect = NULL);
-#else
-unsigned long long CalculateDirSize(const std::string& path);
-#endif
-
-// Get all the contents of a file and dump into a STL string
-// Thanks to http://stackoverflow.com/questions/2602013/read-whole-ascii-file-into-c-stdstring
-std::string get_file_contents(const char* filename);
-
-/// Get all the contents of a binary file
-std::vector<char> get_binary_file_contents(const char* filename);
-
+#ifndef COOLPROP_FILE_PATH_H
+#define COOLPROP_FILE_PATH_H
+
+#include <string>
+#include <vector>
+
+/// Get directory separator
+std::string get_separator(void);
+
+/// Get the user's home directory;  It is believed that is is always a place that files can be written
+std::string get_home_dir(void);
+
+/// Return true if path exists
+bool path_exists(const std::string& path);
+
+/// Return merged path, append separator if string two is empty
+std::string join_path(const std::string& one, const std::string& two);
+
+/// Make directory and all required intermediate directories
+void make_dirs(std::string file_path);
+
+/// Get the size of a directory in bytes
+#if defined(__ISWINDOWS__)
+unsigned long long CalculateDirSize(const std::wstring& path, std::vector<std::wstring>* errVect = NULL);
+#else
+unsigned long long CalculateDirSize(const std::string& path);
+#endif
+
+// Get all the contents of a file and dump into a STL string
+// Thanks to http://stackoverflow.com/questions/2602013/read-whole-ascii-file-into-c-stdstring
+std::string get_file_contents(const char* filename);
+
+/// Get all the contents of a binary file
+std::vector<char> get_binary_file_contents(const char* filename);
+
 #endif
```

## CoolProp/include/CPmsgpack.h

 * *Ordering differences only*

```diff
@@ -1,20 +1,20 @@
-// Workaround MSVC warnings
-#ifdef _MSC_VER
-#    pragma warning(push)
-#    pragma warning(disable : 4267)
-#endif
-
-// Workaround MSVC endiannes issues
-#if defined(_MSC_VER) && ( defined(_M_ARM) || defined(_M_ARM64) )
-#    define MSGPACK_ENDIAN_LITTLE_BYTE
-#endif
-
-#include "msgpack.hpp"
-
-#if defined(MSGPACK_ENDIAN_LITTLE_BYTE)
-#    undef MSGPACK_ENDIAN_LITTLE_BYTE
-#endif
-
-#ifdef _MSC_VER
-#    pragma warning(pop)
-#endif
+// Workaround MSVC warnings
+#ifdef _MSC_VER
+#    pragma warning(push)
+#    pragma warning(disable : 4267)
+#endif
+
+// Workaround MSVC endiannes issues
+#if defined(_MSC_VER) && ( defined(_M_ARM) || defined(_M_ARM64) )
+#    define MSGPACK_ENDIAN_LITTLE_BYTE
+#endif
+
+#include "msgpack.hpp"
+
+#if defined(MSGPACK_ENDIAN_LITTLE_BYTE)
+#    undef MSGPACK_ENDIAN_LITTLE_BYTE
+#endif
+
+#ifdef _MSC_VER
+#    pragma warning(pop)
+#endif
```

## CoolProp/include/CPnumerics.h

 * *Ordering differences only*

```diff
@@ -1,704 +1,704 @@
-#ifndef COOLPROP_NUMERICS_H
-#define COOLPROP_NUMERICS_H
-
-#include <vector>
-#include <set>
-#include <cfloat>
-#include <stdlib.h>   // For abs
-#include <algorithm>  // For max
-#include <numeric>
-#include <cmath>
-#include "PlatformDetermination.h"
-#include "CPstrings.h"
-#include "Exceptions.h"
-
-#if defined(HUGE_VAL) && !defined(_HUGE)
-#    define _HUGE HUGE_VAL
-#else
-// GCC Version of huge value macro
-#    if defined(HUGE) && !defined(_HUGE)
-#        define _HUGE HUGE
-#    endif
-#endif
-
-inline bool ValidNumber(double x) {
-    // Idea from http://www.johndcook.com/IEEE_exceptions_in_cpp.html
-    return (x <= DBL_MAX && x >= -DBL_MAX);
-};
-
-#ifndef M_PI
-#    define M_PI 3.14159265358979323846
-#endif
-
-#ifndef COOLPROP_OK
-#    define COOLPROP_OK 1
-#endif
-
-// Undefine these terrible macros defined in windows header
-#undef min
-#undef max
-
-/* "THE BEER-WARE LICENSE" (Revision 42): Devin Lane wrote this file. As long as you retain
- * this notice you can do whatever you want with this stuff. If we meet some day, and you
- * think this stuff is worth it, you can buy me a beer in return.
- *
- * From http://shiftedbits.org/2011/01/30/cubic-spline-interpolation/
- *
- * IHB(05/01/2016): Removed overload and renamed the interpolate function (cython cannot disambiguate the functions)
- *
- * Templated on type of X, Y. X and Y must have operator +, -, *, /. Y must have defined
- * a constructor that takes a scalar. */
-template <typename X, typename Y>
-class Spline
-{
-   public:
-    /** An empty, invalid spline */
-    Spline() {}
-
-    /** A spline with x and y values */
-    Spline(const std::vector<X>& x, const std::vector<Y>& y) {
-        if (x.size() != y.size()) {
-            std::cerr << "X and Y must be the same size " << std::endl;
-            return;
-        }
-
-        if (x.size() < 3) {
-            std::cerr << "Must have at least three points for interpolation" << std::endl;
-            return;
-        }
-
-        typedef typename std::vector<X>::difference_type size_type;
-
-        size_type n = y.size() - 1;
-
-        std::vector<Y> b(n), d(n), a(n), c(n + 1), l(n + 1), u(n + 1), z(n + 1);
-        std::vector<X> h(n + 1);
-
-        l[0] = Y(1);
-        u[0] = Y(0);
-        z[0] = Y(0);
-        h[0] = x[1] - x[0];
-
-        for (size_type i = 1; i < n; i++) {
-            h[i] = x[i + 1] - x[i];
-            l[i] = Y(2 * (x[i + 1] - x[i - 1])) - Y(h[i - 1]) * u[i - 1];
-            u[i] = Y(h[i]) / l[i];
-            a[i] = (Y(3) / Y(h[i])) * (y[i + 1] - y[i]) - (Y(3) / Y(h[i - 1])) * (y[i] - y[i - 1]);
-            z[i] = (a[i] - Y(h[i - 1]) * z[i - 1]) / l[i];
-        }
-
-        l[n] = Y(1);
-        z[n] = c[n] = Y(0);
-
-        for (size_type j = n - 1; j >= 0; j--) {
-            c[j] = z[j] - u[j] * c[j + 1];
-            b[j] = (y[j + 1] - y[j]) / Y(h[j]) - (Y(h[j]) * (c[j + 1] + Y(2) * c[j])) / Y(3);
-            d[j] = (c[j + 1] - c[j]) / Y(3 * h[j]);
-        }
-
-        for (size_type i = 0; i < n; i++) {
-            mElements.push_back(Element(x[i], y[i], b[i], c[i], d[i]));
-        }
-    }
-    virtual ~Spline() {}
-
-    Y operator[](const X& x) const {
-        return interpolate(x);
-    }
-
-    Y interpolate(const X& x) const {
-        if (mElements.size() == 0) return Y();
-
-        typename std::vector<element_type>::const_iterator it;
-        it = std::lower_bound(mElements.begin(), mElements.end(), element_type(x));
-        if (it != mElements.begin()) {
-            it--;
-        }
-
-        return it->eval(x);
-    }
-
-    /* Evaluate at multiple locations, assuming xx is sorted ascending */
-    std::vector<Y> interpolate_vec(const std::vector<X>& xx) const {
-        if (mElements.size() == 0) return std::vector<Y>(xx.size());
-
-        typename std::vector<X>::const_iterator it;
-        typename std::vector<element_type>::const_iterator it2;
-        it2 = mElements.begin();
-        std::vector<Y> ys;
-        for (it = xx.begin(); it != xx.end(); it++) {
-            it2 = std::lower_bound(it2, mElements.end(), element_type(*it));
-            if (it2 != mElements.begin()) {
-                it2--;
-            }
-
-            ys.push_back(it2->eval(*it));
-        }
-
-        return ys;
-    }
-
-   protected:
-    class Element
-    {
-       public:
-        Element(X _x) : x(_x) {}
-        Element(X _x, Y _a, Y _b, Y _c, Y _d) : x(_x), a(_a), b(_b), c(_c), d(_d) {}
-
-        Y eval(const X& xx) const {
-            X xix(xx - x);
-            return a + b * xix + c * (xix * xix) + d * (xix * xix * xix);
-        }
-
-        bool operator<(const Element& e) const {
-            return x < e.x;
-        }
-        bool operator<(const X& xx) const {
-            return x < xx;
-        }
-
-        X x;
-        Y a, b, c, d;
-    };
-
-    typedef Element element_type;
-    std::vector<element_type> mElements;
-};
-
-/// Return the maximum difference between elements in two vectors where comparing z1[i] and z2[i]
-template <typename T>
-T maxvectordiff(const std::vector<T>& z1, const std::vector<T>& z2) {
-    T maxvecdiff = 0;
-    for (std::size_t i = 0; i < z1.size(); ++i) {
-        T diff = std::abs(z1[i] - z2[i]);
-        if (std::abs(diff) > maxvecdiff) {
-            maxvecdiff = diff;
-        }
-    }
-    return maxvecdiff;
-}
-
-/// Make a linearly spaced vector of points
-template <typename T>
-std::vector<T> linspace(T xmin, T xmax, std::size_t n) {
-    std::vector<T> x(n, 0.0);
-
-    for (std::size_t i = 0; i < n; ++i) {
-        x[i] = (xmax - xmin) / (n - 1) * i + xmin;
-    }
-    return x;
-}
-/// Make a base-10 logarithmically spaced vector of points
-template <typename T>
-std::vector<T> log10space(T xmin, T xmax, std::size_t n) {
-    std::vector<T> x(n, 0.0);
-    T logxmin = log10(xmin), logxmax = log10(xmax);
-
-    for (std::size_t i = 0; i < n; ++i) {
-        x[i] = exp((logxmax - logxmin) / (n - 1) * i + logxmin);
-    }
-    return x;
-}
-/// Make a base-e logarithmically spaced vector of points
-template <typename T>
-std::vector<T> logspace(T xmin, T xmax, std::size_t n) {
-    std::vector<T> x(n, 0.0);
-    T logxmin = log(xmin), logxmax = log(xmax);
-
-    for (std::size_t i = 0; i < n; ++i) {
-        x[i] = exp((logxmax - logxmin) / (n - 1) * i + logxmin);
-    }
-    return x;
-}
-
-/**
- * @brief Use bisection to find the inputs that bisect the value you want, the trick
- * here is that this function is allowed to have "holes" where parts of the the array are
- * also filled with invalid numbers for which ValidNumber(x) is false
- * @param vec The vector to be bisected
- * @param val The value to be found
- * @param i The index to the left of the final point; i and i+1 bound the value
- */
-template <typename T>
-void bisect_vector(const std::vector<T>& vec, T val, std::size_t& i) {
-    T rL, rM, rR;
-    std::size_t N = vec.size(), L = 0, R = N - 1, M = (L + R) / 2;
-    // Move the right limits in until they are good
-    while (!ValidNumber(vec[R])) {
-        if (R == 1) {
-            throw CoolProp::ValueError("All the values in bisection vector are invalid");
-        }
-        R--;
-    }
-    // Move the left limits in until they are good
-    while (!ValidNumber(vec[L])) {
-        if (L == vec.size() - 1) {
-            throw CoolProp::ValueError("All the values in bisection vector are invalid");
-        }
-        L++;
-    }
-    rL = vec[L] - val;
-    rR = vec[R] - val;
-    while (R - L > 1) {
-        if (!ValidNumber(vec[M])) {
-            std::size_t MR = M, ML = M;
-            // Move middle-right to the right until it is ok
-            while (!ValidNumber(vec[MR])) {
-                if (MR == vec.size() - 1) {
-                    throw CoolProp::ValueError("All the values in bisection vector are invalid");
-                }
-                MR++;
-            }
-            // Move middle-left to the left until it is ok
-            while (!ValidNumber(vec[ML])) {
-                if (ML == 1) {
-                    throw CoolProp::ValueError("All the values in bisection vector are invalid");
-                }
-                ML--;
-            }
-            T rML = vec[ML] - val;
-            T rMR = vec[MR] - val;
-            // Figure out which chunk is the good part
-            if (rR * rML > 0 && rL * rML < 0) {
-                // solution is between L and ML
-                R = ML;
-                rR = vec[ML] - val;
-            } else if (rR * rMR < 0 && rL * rMR > 0) {
-                // solution is between R and MR
-                L = MR;
-                rL = vec[MR] - val;
-            } else {
-                throw CoolProp::ValueError(
-                  format("Unable to bisect segmented vector; neither chunk contains the solution val:%g left:(%g,%g) right:(%g,%g)", val, vec[L],
-                         vec[ML], vec[MR], vec[R]));
-            }
-            M = (L + R) / 2;
-        } else {
-            rM = vec[M] - val;
-            if (rR * rM > 0 && rL * rM < 0) {
-                // solution is between L and M
-                R = M;
-                rR = vec[R] - val;
-            } else {
-                // solution is between R and M
-                L = M;
-                rL = vec[L] - val;
-            }
-            M = (L + R) / 2;
-        }
-    }
-    i = L;
-}
-
-/**
- * @brief Use bisection to find the inputs that bisect the value you want, the trick
- * here is that this function is allowed to have "holes" where parts of the the array are
- * also filled with invalid numbers for which ValidNumber(x) is false
- * @param matrix The vector to be bisected
- * @param j The index of the matric in the off-grain dimension
- * @param val The value to be found
- * @param i The index to the left of the final point; i and i+1 bound the value
- */
-template <typename T>
-void bisect_segmented_vector_slice(const std::vector<std::vector<T>>& mat, std::size_t j, T val, std::size_t& i) {
-    T rL, rM, rR;
-    std::size_t N = mat[j].size(), L = 0, R = N - 1, M = (L + R) / 2;
-    // Move the right limits in until they are good
-    while (!ValidNumber(mat[R][j])) {
-        if (R == 1) {
-            throw CoolProp::ValueError("All the values in bisection vector are invalid");
-        }
-        R--;
-    }
-    rR = mat[R][j] - val;
-    // Move the left limits in until they are good
-    while (!ValidNumber(mat[L][j])) {
-        if (L == mat.size() - 1) {
-            throw CoolProp::ValueError("All the values in bisection vector are invalid");
-        }
-        L++;
-    }
-    rL = mat[L][j] - val;
-    while (R - L > 1) {
-        if (!ValidNumber(mat[M][j])) {
-            std::size_t MR = M, ML = M;
-            // Move middle-right to the right until it is ok
-            while (!ValidNumber(mat[MR][j])) {
-                if (MR == mat.size() - 1) {
-                    throw CoolProp::ValueError("All the values in bisection vector are invalid");
-                }
-                MR++;
-            }
-            // Move middle-left to the left until it is ok
-            while (!ValidNumber(mat[ML][j])) {
-                if (ML == 1) {
-                    throw CoolProp::ValueError("All the values in bisection vector are invalid");
-                }
-                ML--;
-            }
-            T rML = mat[ML][j] - val;
-            T rMR = mat[MR][j] - val;
-            // Figure out which chunk is the good part
-            if (rR * rMR > 0 && rL * rML < 0) {
-                // solution is between L and ML
-                R = ML;
-                rR = mat[ML][j] - val;
-            } else if (rR * rMR < 0 && rL * rML > 0) {
-                // solution is between R and MR
-                L = MR;
-                rL = mat[MR][j] - val;
-            } else {
-                throw CoolProp::ValueError(
-                  format("Unable to bisect segmented vector slice; neither chunk contains the solution %g lef:(%g,%g) right:(%g,%g)", val, mat[L][j],
-                         mat[ML][j], mat[MR][j], mat[R][j]));
-            }
-            M = (L + R) / 2;
-        } else {
-            rM = mat[M][j] - val;
-            if (rR * rM > 0 && rL * rM < 0) {
-                // solution is between L and M
-                R = M;
-                rR = mat[R][j] - val;
-            } else {
-                // solution is between R and M
-                L = M;
-                rL = mat[L][j] - val;
-            }
-            M = (L + R) / 2;
-        }
-    }
-    i = L;
-}
-
-// From http://rosettacode.org/wiki/Power_set#C.2B.2B
-inline std::size_t powerset_dereference(std::set<std::size_t>::const_iterator v) {
-    return *v;
-};
-
-// From http://rosettacode.org/wiki/Power_set#C.2B.2B
-inline std::set<std::set<std::size_t>> powerset(std::set<std::size_t> const& set) {
-    std::set<std::set<std::size_t>> result;
-    std::vector<std::set<std::size_t>::const_iterator> elements;
-    do {
-        std::set<std::size_t> tmp;
-        std::transform(elements.begin(), elements.end(), std::inserter(tmp, tmp.end()), powerset_dereference);
-        result.insert(tmp);
-        if (!elements.empty() && ++elements.back() == set.end()) {
-            elements.pop_back();
-        } else {
-            std::set<std::size_t>::const_iterator iter;
-            if (elements.empty()) {
-                iter = set.begin();
-            } else {
-                iter = elements.back();
-                ++iter;
-            }
-            for (; iter != set.end(); ++iter) {
-                elements.push_back(iter);
-            }
-        }
-    } while (!elements.empty());
-
-    return result;
-}
-
-/// Some functions related to testing and comparison of values
-bool inline check_abs(double A, double B, double D) {
-    double max = std::abs(A);
-    double min = std::abs(B);
-    if (min > max) {
-        max = min;
-        min = std::abs(A);
-    }
-    if (max > DBL_EPSILON * 1e3)
-        return ((1.0 - min / max * 1e0) < D);
-    else
-        throw CoolProp::ValueError(
-          format("Too small numbers: %f cannot be tested with an accepted error of %f for a machine precision of %f. ", max, D, DBL_EPSILON));
-};
-bool inline check_abs(double A, double B) {
-    return check_abs(A, B, 1e5 * DBL_EPSILON);
-};
-
-template <class T>
-void normalize_vector(std::vector<T>& x) {
-    // Sum up all the elements in the vector
-    T sumx = std::accumulate(x.begin(), x.end(), static_cast<T>(0));
-    // Normalize the components by dividing each by the sum
-    for (std::size_t i = 0; i < x.size(); ++i) {
-        x[i] /= sumx;
-    }
-};
-
-/// A spline is a curve given by the form y = ax^3 + bx^2 + c*x + d
-/// As there are 4 constants, 4 constraints are needed to create the spline.  These constraints could be the derivative or value at a point
-/// Often, the value and derivative of the value are known at two points.
-class SplineClass
-{
-   protected:
-    int Nconstraints;
-    std::vector<std::vector<double>> A;
-    std::vector<double> B;
-
-   public:
-    double a, b, c, d;
-    SplineClass() : Nconstraints(0), A(4, std::vector<double>(4, 0)), B(4, 0), a(_HUGE), b(_HUGE), c(_HUGE), d(_HUGE) {}
-    bool build(void);
-    bool add_value_constraint(double x, double y);
-    void add_4value_constraints(double x1, double x2, double x3, double x4, double y1, double y2, double y3, double y4);
-    bool add_derivative_constraint(double x, double dydx);
-    double evaluate(double x);
-};
-
-/// from http://stackoverflow.com/a/5721830/1360263
-template <class T>
-T factorial(T n) {
-    if (n == 0) return 1;
-    return n * factorial(n - 1);
-}
-/// see https://proofwiki.org/wiki/Nth_Derivative_of_Mth_Power
-/// and https://proofwiki.org/wiki/Definition:Falling_Factorial
-template <class T1, class T2>
-T1 nth_derivative_of_x_to_m(T1 x, T2 n, T2 m) {
-    if (n > m) {
-        return 0;
-    } else {
-        return factorial(m) / factorial(m - n) * pow(x, m - n);
-    }
-}
-
-void MatInv_2(double A[2][2], double B[2][2]);
-
-double root_sum_square(const std::vector<double>& x);
-double interp1d(const std::vector<double>* x, const std::vector<double>* y, double x0);
-double powInt(double x, int y);
-
-template <class T>
-T POW2(T x) {
-    return x * x;
-}
-template <class T>
-T POW3(T x) {
-    return POW2(x) * x;
-}
-template <class T>
-T POW4(T x) {
-    return POW2(x) * POW2(x);
-}
-#define POW5(x) ((x) * (x) * (x) * (x) * (x))
-#define POW6(x) ((x) * (x) * (x) * (x) * (x) * (x))
-#define POW7(x) ((x) * (x) * (x) * (x) * (x) * (x) * (x))
-
-template <class T>
-T LinearInterp(T x0, T x1, T y0, T y1, T x) {
-    return (y1 - y0) / (x1 - x0) * (x - x0) + y0;
-};
-template <class T1, class T2>
-T2 LinearInterp(const std::vector<T1>& x, const std::vector<T1>& y, std::size_t i0, std::size_t i1, T2 val) {
-    return LinearInterp(x[i0], x[i1], y[i0], y[i1], static_cast<T1>(val));
-};
-
-template <class T>
-T QuadInterp(T x0, T x1, T x2, T f0, T f1, T f2, T x) {
-    /* Quadratic interpolation.
-    Based on method from Kreyszig,
-    Advanced Engineering Mathematics, 9th Edition
-    */
-    T L0, L1, L2;
-    L0 = ((x - x1) * (x - x2)) / ((x0 - x1) * (x0 - x2));
-    L1 = ((x - x0) * (x - x2)) / ((x1 - x0) * (x1 - x2));
-    L2 = ((x - x0) * (x - x1)) / ((x2 - x0) * (x2 - x1));
-    return L0 * f0 + L1 * f1 + L2 * f2;
-};
-template <class T1, class T2>
-T2 QuadInterp(const std::vector<T1>& x, const std::vector<T1>& y, std::size_t i0, std::size_t i1, std::size_t i2, T2 val) {
-    return QuadInterp(x[i0], x[i1], x[i2], y[i0], y[i1], y[i2], static_cast<T1>(val));
-};
-
-template <class T>
-T CubicInterp(T x0, T x1, T x2, T x3, T f0, T f1, T f2, T f3, T x) {
-    /*
-    Lagrange cubic interpolation as from
-    http://nd.edu/~jjwteach/441/PdfNotes/lecture6.pdf
-    */
-    T L0, L1, L2, L3;
-    L0 = ((x - x1) * (x - x2) * (x - x3)) / ((x0 - x1) * (x0 - x2) * (x0 - x3));
-    L1 = ((x - x0) * (x - x2) * (x - x3)) / ((x1 - x0) * (x1 - x2) * (x1 - x3));
-    L2 = ((x - x0) * (x - x1) * (x - x3)) / ((x2 - x0) * (x2 - x1) * (x2 - x3));
-    L3 = ((x - x0) * (x - x1) * (x - x2)) / ((x3 - x0) * (x3 - x1) * (x3 - x2));
-    return L0 * f0 + L1 * f1 + L2 * f2 + L3 * f3;
-};
-/** /brief Calculate the first derivative of the function using a cubic interpolation form
-    */
-template <class T>
-T CubicInterpFirstDeriv(T x0, T x1, T x2, T x3, T f0, T f1, T f2, T f3, T x) {
-    // Based on http://math.stackexchange.com/a/809946/66405
-    T L0 = ((x - x1) * (x - x2) * (x - x3)) / ((x0 - x1) * (x0 - x2) * (x0 - x3));
-    T dL0_dx = (1 / (x - x1) + 1 / (x - x2) + 1 / (x - x3)) * L0;
-    T L1 = ((x - x0) * (x - x2) * (x - x3)) / ((x1 - x0) * (x1 - x2) * (x1 - x3));
-    T dL1_dx = (1 / (x - x0) + 1 / (x - x2) + 1 / (x - x3)) * L1;
-    T L2 = ((x - x0) * (x - x1) * (x - x3)) / ((x2 - x0) * (x2 - x1) * (x2 - x3));
-    T dL2_dx = (1 / (x - x0) + 1 / (x - x1) + 1 / (x - x3)) * L2;
-    T L3 = ((x - x0) * (x - x1) * (x - x2)) / ((x3 - x0) * (x3 - x1) * (x3 - x2));
-    T dL3_dx = (1 / (x - x0) + 1 / (x - x1) + 1 / (x - x2)) * L3;
-    return dL0_dx * f0 + dL1_dx * f1 + dL2_dx * f2 + dL3_dx * f3;
-};
-template <class T1, class T2>
-T2 CubicInterp(const std::vector<T1>& x, const std::vector<T1>& y, std::size_t i0, std::size_t i1, std::size_t i2, std::size_t i3, T2 val) {
-    return CubicInterp(x[i0], x[i1], x[i2], x[i3], y[i0], y[i1], y[i2], y[i3], static_cast<T1>(val));
-};
-
-template <class T>
-T is_in_closed_range(T x1, T x2, T x) {
-    return (x >= std::min(x1, x2) && x <= std::max(x1, x2));
-};
-
-/** \brief Solve a cubic with coefficients in decreasing order
-    *
-    * 0 = ax^3 + b*x^2 + c*x + d
-    *
-    * @param a The x^3 coefficient
-    * @param b The x^2 coefficient
-    * @param c The x^1 coefficient
-    * @param d The x^0 coefficient
-    * @param N The number of unique real solutions found
-    * @param x0 The first solution found
-    * @param x1 The second solution found
-    * @param x2 The third solution found
-    */
-void solve_cubic(double a, double b, double c, double d, int& N, double& x0, double& x1, double& x2);
-
-void solve_quartic(double a, double b, double c, double d, double e, int& N, double& x0, double& x1, double& x2, double& x3);
-
-template <class T>
-inline T min3(T x1, T x2, T x3) {
-    return std::min(std::min(x1, x2), x3);
-};
-template <class T>
-inline T max3(T x1, T x2, T x3) {
-    return std::max(std::max(x1, x2), x3);
-};
-template <class T>
-inline T min4(T x1, T x2, T x3, T x4) {
-    return std::min(std::min(std::min(x1, x2), x3), x4);
-};
-template <class T>
-inline T max4(T x1, T x2, T x3, T x4) {
-    return std::max(std::max(std::max(x1, x2), x3), x4);
-};
-
-inline bool double_equal(double a, double b) {
-    return std::abs(a - b) <= 1 * DBL_EPSILON * std::max(std::abs(a), std::abs(b));
-};
-
-template <class T>
-T max_abs_value(const std::vector<T>& x) {
-    T max = 0;
-    std::size_t N = x.size();
-    for (std::size_t i = 0; i < N; ++i) {
-        T axi = std::abs(x[i]);
-        if (axi > max) {
-            max = axi;
-        }
-    }
-    return max;
-}
-
-template <class T>
-T min_abs_value(const std::vector<T>& x) {
-    T min = 1e40;
-    std::size_t N = x.size();
-    for (std::size_t i = 0; i < N; ++i) {
-        T axi = std::abs(x[i]);
-        if (axi < min) {
-            min = axi;
-        }
-    }
-    return min;
-}
-
-inline int Kronecker_delta(std::size_t i, std::size_t j) {
-    if (i == j) {
-        return static_cast<int>(1);
-    } else {
-        return static_cast<int>(0);
-    }
-};
-inline int Kronecker_delta(int i, int j) {
-    if (i == j) {
-        return 1;
-    } else {
-        return 0;
-    }
-};
-
-/// Sort three values in place; see http://codereview.stackexchange.com/a/64763
-template <typename T>
-void sort3(T& a, T& b, T& c) {
-    if (a > b) {
-        std::swap(a, b);
-    }
-    if (a > c) {
-        std::swap(a, c);
-    }
-    if (b > c) {
-        std::swap(b, c);
-    }
-}
-
-/**
-* Due to the periodicity of angles, you need to handle the case where the
-* angles wrap around - suppose theta_d is 6.28 and you are at an angles of 0.1 rad,
-* the difference should be around 0.1, not -6.27
-*
-* This brilliant method is from http://blog.lexique-du-net.com/index.php?post/Calculate-the-real-difference-between-two-angles-keeping-the-sign
-* and the comment of user tk
-*
-* Originally implemented in PDSim
-*/
-template <class T>
-T angle_difference(T angle1, T angle2) {
-    return fmod(angle1 - angle2 + M_PI, 2 * M_PI) - M_PI;
-}
-
-/// A simple function for use in wrappers where macros cause problems
-inline double get_HUGE() {
-    return _HUGE;
-}
-
-#if defined(_MSC_VER)
-// Microsoft version of math.h doesn't include acosh or asinh, so we just define them here.
-// It was included from Visual Studio 2013
-#    if _MSC_VER < 1800
-double acosh(double x) {
-    return log(x + sqrt(x * x - 1.0));
-}
-double asinh(double value) {
-    if (value > 0) {
-        return log(value + sqrt(value * value + 1));
-    } else {
-        return -log(-value + sqrt(value * value + 1));
-    }
-}
-#    endif
-#endif
-
-#if defined(__ISPOWERPC__)
-// PPC version of math.h doesn't include acosh or asinh, so we just define them here
-double acosh(double x) {
-    return log(x + sqrt(x * x - 1.0));
-}
-double asinh(double value) {
-    if (value > 0) {
-        return log(value + sqrt(value * value + 1));
-    } else {
-        return -log(-value + sqrt(value * value + 1));
-    }
-}
-#endif
-
-#if defined(__ISPOWERPC__)
-#    undef EOS
-#endif
-
-#endif
+#ifndef COOLPROP_NUMERICS_H
+#define COOLPROP_NUMERICS_H
+
+#include <vector>
+#include <set>
+#include <cfloat>
+#include <stdlib.h>   // For abs
+#include <algorithm>  // For max
+#include <numeric>
+#include <cmath>
+#include "PlatformDetermination.h"
+#include "CPstrings.h"
+#include "Exceptions.h"
+
+#if defined(HUGE_VAL) && !defined(_HUGE)
+#    define _HUGE HUGE_VAL
+#else
+// GCC Version of huge value macro
+#    if defined(HUGE) && !defined(_HUGE)
+#        define _HUGE HUGE
+#    endif
+#endif
+
+inline bool ValidNumber(double x) {
+    // Idea from http://www.johndcook.com/IEEE_exceptions_in_cpp.html
+    return (x <= DBL_MAX && x >= -DBL_MAX);
+};
+
+#ifndef M_PI
+#    define M_PI 3.14159265358979323846
+#endif
+
+#ifndef COOLPROP_OK
+#    define COOLPROP_OK 1
+#endif
+
+// Undefine these terrible macros defined in windows header
+#undef min
+#undef max
+
+/* "THE BEER-WARE LICENSE" (Revision 42): Devin Lane wrote this file. As long as you retain
+ * this notice you can do whatever you want with this stuff. If we meet some day, and you
+ * think this stuff is worth it, you can buy me a beer in return.
+ *
+ * From http://shiftedbits.org/2011/01/30/cubic-spline-interpolation/
+ *
+ * IHB(05/01/2016): Removed overload and renamed the interpolate function (cython cannot disambiguate the functions)
+ *
+ * Templated on type of X, Y. X and Y must have operator +, -, *, /. Y must have defined
+ * a constructor that takes a scalar. */
+template <typename X, typename Y>
+class Spline
+{
+   public:
+    /** An empty, invalid spline */
+    Spline() {}
+
+    /** A spline with x and y values */
+    Spline(const std::vector<X>& x, const std::vector<Y>& y) {
+        if (x.size() != y.size()) {
+            std::cerr << "X and Y must be the same size " << std::endl;
+            return;
+        }
+
+        if (x.size() < 3) {
+            std::cerr << "Must have at least three points for interpolation" << std::endl;
+            return;
+        }
+
+        typedef typename std::vector<X>::difference_type size_type;
+
+        size_type n = y.size() - 1;
+
+        std::vector<Y> b(n), d(n), a(n), c(n + 1), l(n + 1), u(n + 1), z(n + 1);
+        std::vector<X> h(n + 1);
+
+        l[0] = Y(1);
+        u[0] = Y(0);
+        z[0] = Y(0);
+        h[0] = x[1] - x[0];
+
+        for (size_type i = 1; i < n; i++) {
+            h[i] = x[i + 1] - x[i];
+            l[i] = Y(2 * (x[i + 1] - x[i - 1])) - Y(h[i - 1]) * u[i - 1];
+            u[i] = Y(h[i]) / l[i];
+            a[i] = (Y(3) / Y(h[i])) * (y[i + 1] - y[i]) - (Y(3) / Y(h[i - 1])) * (y[i] - y[i - 1]);
+            z[i] = (a[i] - Y(h[i - 1]) * z[i - 1]) / l[i];
+        }
+
+        l[n] = Y(1);
+        z[n] = c[n] = Y(0);
+
+        for (size_type j = n - 1; j >= 0; j--) {
+            c[j] = z[j] - u[j] * c[j + 1];
+            b[j] = (y[j + 1] - y[j]) / Y(h[j]) - (Y(h[j]) * (c[j + 1] + Y(2) * c[j])) / Y(3);
+            d[j] = (c[j + 1] - c[j]) / Y(3 * h[j]);
+        }
+
+        for (size_type i = 0; i < n; i++) {
+            mElements.push_back(Element(x[i], y[i], b[i], c[i], d[i]));
+        }
+    }
+    virtual ~Spline() {}
+
+    Y operator[](const X& x) const {
+        return interpolate(x);
+    }
+
+    Y interpolate(const X& x) const {
+        if (mElements.size() == 0) return Y();
+
+        typename std::vector<element_type>::const_iterator it;
+        it = std::lower_bound(mElements.begin(), mElements.end(), element_type(x));
+        if (it != mElements.begin()) {
+            it--;
+        }
+
+        return it->eval(x);
+    }
+
+    /* Evaluate at multiple locations, assuming xx is sorted ascending */
+    std::vector<Y> interpolate_vec(const std::vector<X>& xx) const {
+        if (mElements.size() == 0) return std::vector<Y>(xx.size());
+
+        typename std::vector<X>::const_iterator it;
+        typename std::vector<element_type>::const_iterator it2;
+        it2 = mElements.begin();
+        std::vector<Y> ys;
+        for (it = xx.begin(); it != xx.end(); it++) {
+            it2 = std::lower_bound(it2, mElements.end(), element_type(*it));
+            if (it2 != mElements.begin()) {
+                it2--;
+            }
+
+            ys.push_back(it2->eval(*it));
+        }
+
+        return ys;
+    }
+
+   protected:
+    class Element
+    {
+       public:
+        Element(X _x) : x(_x) {}
+        Element(X _x, Y _a, Y _b, Y _c, Y _d) : x(_x), a(_a), b(_b), c(_c), d(_d) {}
+
+        Y eval(const X& xx) const {
+            X xix(xx - x);
+            return a + b * xix + c * (xix * xix) + d * (xix * xix * xix);
+        }
+
+        bool operator<(const Element& e) const {
+            return x < e.x;
+        }
+        bool operator<(const X& xx) const {
+            return x < xx;
+        }
+
+        X x;
+        Y a, b, c, d;
+    };
+
+    typedef Element element_type;
+    std::vector<element_type> mElements;
+};
+
+/// Return the maximum difference between elements in two vectors where comparing z1[i] and z2[i]
+template <typename T>
+T maxvectordiff(const std::vector<T>& z1, const std::vector<T>& z2) {
+    T maxvecdiff = 0;
+    for (std::size_t i = 0; i < z1.size(); ++i) {
+        T diff = std::abs(z1[i] - z2[i]);
+        if (std::abs(diff) > maxvecdiff) {
+            maxvecdiff = diff;
+        }
+    }
+    return maxvecdiff;
+}
+
+/// Make a linearly spaced vector of points
+template <typename T>
+std::vector<T> linspace(T xmin, T xmax, std::size_t n) {
+    std::vector<T> x(n, 0.0);
+
+    for (std::size_t i = 0; i < n; ++i) {
+        x[i] = (xmax - xmin) / (n - 1) * i + xmin;
+    }
+    return x;
+}
+/// Make a base-10 logarithmically spaced vector of points
+template <typename T>
+std::vector<T> log10space(T xmin, T xmax, std::size_t n) {
+    std::vector<T> x(n, 0.0);
+    T logxmin = log10(xmin), logxmax = log10(xmax);
+
+    for (std::size_t i = 0; i < n; ++i) {
+        x[i] = exp((logxmax - logxmin) / (n - 1) * i + logxmin);
+    }
+    return x;
+}
+/// Make a base-e logarithmically spaced vector of points
+template <typename T>
+std::vector<T> logspace(T xmin, T xmax, std::size_t n) {
+    std::vector<T> x(n, 0.0);
+    T logxmin = log(xmin), logxmax = log(xmax);
+
+    for (std::size_t i = 0; i < n; ++i) {
+        x[i] = exp((logxmax - logxmin) / (n - 1) * i + logxmin);
+    }
+    return x;
+}
+
+/**
+ * @brief Use bisection to find the inputs that bisect the value you want, the trick
+ * here is that this function is allowed to have "holes" where parts of the the array are
+ * also filled with invalid numbers for which ValidNumber(x) is false
+ * @param vec The vector to be bisected
+ * @param val The value to be found
+ * @param i The index to the left of the final point; i and i+1 bound the value
+ */
+template <typename T>
+void bisect_vector(const std::vector<T>& vec, T val, std::size_t& i) {
+    T rL, rM, rR;
+    std::size_t N = vec.size(), L = 0, R = N - 1, M = (L + R) / 2;
+    // Move the right limits in until they are good
+    while (!ValidNumber(vec[R])) {
+        if (R == 1) {
+            throw CoolProp::ValueError("All the values in bisection vector are invalid");
+        }
+        R--;
+    }
+    // Move the left limits in until they are good
+    while (!ValidNumber(vec[L])) {
+        if (L == vec.size() - 1) {
+            throw CoolProp::ValueError("All the values in bisection vector are invalid");
+        }
+        L++;
+    }
+    rL = vec[L] - val;
+    rR = vec[R] - val;
+    while (R - L > 1) {
+        if (!ValidNumber(vec[M])) {
+            std::size_t MR = M, ML = M;
+            // Move middle-right to the right until it is ok
+            while (!ValidNumber(vec[MR])) {
+                if (MR == vec.size() - 1) {
+                    throw CoolProp::ValueError("All the values in bisection vector are invalid");
+                }
+                MR++;
+            }
+            // Move middle-left to the left until it is ok
+            while (!ValidNumber(vec[ML])) {
+                if (ML == 1) {
+                    throw CoolProp::ValueError("All the values in bisection vector are invalid");
+                }
+                ML--;
+            }
+            T rML = vec[ML] - val;
+            T rMR = vec[MR] - val;
+            // Figure out which chunk is the good part
+            if (rR * rML > 0 && rL * rML < 0) {
+                // solution is between L and ML
+                R = ML;
+                rR = vec[ML] - val;
+            } else if (rR * rMR < 0 && rL * rMR > 0) {
+                // solution is between R and MR
+                L = MR;
+                rL = vec[MR] - val;
+            } else {
+                throw CoolProp::ValueError(
+                  format("Unable to bisect segmented vector; neither chunk contains the solution val:%g left:(%g,%g) right:(%g,%g)", val, vec[L],
+                         vec[ML], vec[MR], vec[R]));
+            }
+            M = (L + R) / 2;
+        } else {
+            rM = vec[M] - val;
+            if (rR * rM > 0 && rL * rM < 0) {
+                // solution is between L and M
+                R = M;
+                rR = vec[R] - val;
+            } else {
+                // solution is between R and M
+                L = M;
+                rL = vec[L] - val;
+            }
+            M = (L + R) / 2;
+        }
+    }
+    i = L;
+}
+
+/**
+ * @brief Use bisection to find the inputs that bisect the value you want, the trick
+ * here is that this function is allowed to have "holes" where parts of the the array are
+ * also filled with invalid numbers for which ValidNumber(x) is false
+ * @param matrix The vector to be bisected
+ * @param j The index of the matric in the off-grain dimension
+ * @param val The value to be found
+ * @param i The index to the left of the final point; i and i+1 bound the value
+ */
+template <typename T>
+void bisect_segmented_vector_slice(const std::vector<std::vector<T>>& mat, std::size_t j, T val, std::size_t& i) {
+    T rL, rM, rR;
+    std::size_t N = mat[j].size(), L = 0, R = N - 1, M = (L + R) / 2;
+    // Move the right limits in until they are good
+    while (!ValidNumber(mat[R][j])) {
+        if (R == 1) {
+            throw CoolProp::ValueError("All the values in bisection vector are invalid");
+        }
+        R--;
+    }
+    rR = mat[R][j] - val;
+    // Move the left limits in until they are good
+    while (!ValidNumber(mat[L][j])) {
+        if (L == mat.size() - 1) {
+            throw CoolProp::ValueError("All the values in bisection vector are invalid");
+        }
+        L++;
+    }
+    rL = mat[L][j] - val;
+    while (R - L > 1) {
+        if (!ValidNumber(mat[M][j])) {
+            std::size_t MR = M, ML = M;
+            // Move middle-right to the right until it is ok
+            while (!ValidNumber(mat[MR][j])) {
+                if (MR == mat.size() - 1) {
+                    throw CoolProp::ValueError("All the values in bisection vector are invalid");
+                }
+                MR++;
+            }
+            // Move middle-left to the left until it is ok
+            while (!ValidNumber(mat[ML][j])) {
+                if (ML == 1) {
+                    throw CoolProp::ValueError("All the values in bisection vector are invalid");
+                }
+                ML--;
+            }
+            T rML = mat[ML][j] - val;
+            T rMR = mat[MR][j] - val;
+            // Figure out which chunk is the good part
+            if (rR * rMR > 0 && rL * rML < 0) {
+                // solution is between L and ML
+                R = ML;
+                rR = mat[ML][j] - val;
+            } else if (rR * rMR < 0 && rL * rML > 0) {
+                // solution is between R and MR
+                L = MR;
+                rL = mat[MR][j] - val;
+            } else {
+                throw CoolProp::ValueError(
+                  format("Unable to bisect segmented vector slice; neither chunk contains the solution %g lef:(%g,%g) right:(%g,%g)", val, mat[L][j],
+                         mat[ML][j], mat[MR][j], mat[R][j]));
+            }
+            M = (L + R) / 2;
+        } else {
+            rM = mat[M][j] - val;
+            if (rR * rM > 0 && rL * rM < 0) {
+                // solution is between L and M
+                R = M;
+                rR = mat[R][j] - val;
+            } else {
+                // solution is between R and M
+                L = M;
+                rL = mat[L][j] - val;
+            }
+            M = (L + R) / 2;
+        }
+    }
+    i = L;
+}
+
+// From http://rosettacode.org/wiki/Power_set#C.2B.2B
+inline std::size_t powerset_dereference(std::set<std::size_t>::const_iterator v) {
+    return *v;
+};
+
+// From http://rosettacode.org/wiki/Power_set#C.2B.2B
+inline std::set<std::set<std::size_t>> powerset(std::set<std::size_t> const& set) {
+    std::set<std::set<std::size_t>> result;
+    std::vector<std::set<std::size_t>::const_iterator> elements;
+    do {
+        std::set<std::size_t> tmp;
+        std::transform(elements.begin(), elements.end(), std::inserter(tmp, tmp.end()), powerset_dereference);
+        result.insert(tmp);
+        if (!elements.empty() && ++elements.back() == set.end()) {
+            elements.pop_back();
+        } else {
+            std::set<std::size_t>::const_iterator iter;
+            if (elements.empty()) {
+                iter = set.begin();
+            } else {
+                iter = elements.back();
+                ++iter;
+            }
+            for (; iter != set.end(); ++iter) {
+                elements.push_back(iter);
+            }
+        }
+    } while (!elements.empty());
+
+    return result;
+}
+
+/// Some functions related to testing and comparison of values
+bool inline check_abs(double A, double B, double D) {
+    double max = std::abs(A);
+    double min = std::abs(B);
+    if (min > max) {
+        max = min;
+        min = std::abs(A);
+    }
+    if (max > DBL_EPSILON * 1e3)
+        return ((1.0 - min / max * 1e0) < D);
+    else
+        throw CoolProp::ValueError(
+          format("Too small numbers: %f cannot be tested with an accepted error of %f for a machine precision of %f. ", max, D, DBL_EPSILON));
+};
+bool inline check_abs(double A, double B) {
+    return check_abs(A, B, 1e5 * DBL_EPSILON);
+};
+
+template <class T>
+void normalize_vector(std::vector<T>& x) {
+    // Sum up all the elements in the vector
+    T sumx = std::accumulate(x.begin(), x.end(), static_cast<T>(0));
+    // Normalize the components by dividing each by the sum
+    for (std::size_t i = 0; i < x.size(); ++i) {
+        x[i] /= sumx;
+    }
+};
+
+/// A spline is a curve given by the form y = ax^3 + bx^2 + c*x + d
+/// As there are 4 constants, 4 constraints are needed to create the spline.  These constraints could be the derivative or value at a point
+/// Often, the value and derivative of the value are known at two points.
+class SplineClass
+{
+   protected:
+    int Nconstraints;
+    std::vector<std::vector<double>> A;
+    std::vector<double> B;
+
+   public:
+    double a, b, c, d;
+    SplineClass() : Nconstraints(0), A(4, std::vector<double>(4, 0)), B(4, 0), a(_HUGE), b(_HUGE), c(_HUGE), d(_HUGE) {}
+    bool build(void);
+    bool add_value_constraint(double x, double y);
+    void add_4value_constraints(double x1, double x2, double x3, double x4, double y1, double y2, double y3, double y4);
+    bool add_derivative_constraint(double x, double dydx);
+    double evaluate(double x);
+};
+
+/// from http://stackoverflow.com/a/5721830/1360263
+template <class T>
+T factorial(T n) {
+    if (n == 0) return 1;
+    return n * factorial(n - 1);
+}
+/// see https://proofwiki.org/wiki/Nth_Derivative_of_Mth_Power
+/// and https://proofwiki.org/wiki/Definition:Falling_Factorial
+template <class T1, class T2>
+T1 nth_derivative_of_x_to_m(T1 x, T2 n, T2 m) {
+    if (n > m) {
+        return 0;
+    } else {
+        return factorial(m) / factorial(m - n) * pow(x, m - n);
+    }
+}
+
+void MatInv_2(double A[2][2], double B[2][2]);
+
+double root_sum_square(const std::vector<double>& x);
+double interp1d(const std::vector<double>* x, const std::vector<double>* y, double x0);
+double powInt(double x, int y);
+
+template <class T>
+T POW2(T x) {
+    return x * x;
+}
+template <class T>
+T POW3(T x) {
+    return POW2(x) * x;
+}
+template <class T>
+T POW4(T x) {
+    return POW2(x) * POW2(x);
+}
+#define POW5(x) ((x) * (x) * (x) * (x) * (x))
+#define POW6(x) ((x) * (x) * (x) * (x) * (x) * (x))
+#define POW7(x) ((x) * (x) * (x) * (x) * (x) * (x) * (x))
+
+template <class T>
+T LinearInterp(T x0, T x1, T y0, T y1, T x) {
+    return (y1 - y0) / (x1 - x0) * (x - x0) + y0;
+};
+template <class T1, class T2>
+T2 LinearInterp(const std::vector<T1>& x, const std::vector<T1>& y, std::size_t i0, std::size_t i1, T2 val) {
+    return LinearInterp(x[i0], x[i1], y[i0], y[i1], static_cast<T1>(val));
+};
+
+template <class T>
+T QuadInterp(T x0, T x1, T x2, T f0, T f1, T f2, T x) {
+    /* Quadratic interpolation.
+    Based on method from Kreyszig,
+    Advanced Engineering Mathematics, 9th Edition
+    */
+    T L0, L1, L2;
+    L0 = ((x - x1) * (x - x2)) / ((x0 - x1) * (x0 - x2));
+    L1 = ((x - x0) * (x - x2)) / ((x1 - x0) * (x1 - x2));
+    L2 = ((x - x0) * (x - x1)) / ((x2 - x0) * (x2 - x1));
+    return L0 * f0 + L1 * f1 + L2 * f2;
+};
+template <class T1, class T2>
+T2 QuadInterp(const std::vector<T1>& x, const std::vector<T1>& y, std::size_t i0, std::size_t i1, std::size_t i2, T2 val) {
+    return QuadInterp(x[i0], x[i1], x[i2], y[i0], y[i1], y[i2], static_cast<T1>(val));
+};
+
+template <class T>
+T CubicInterp(T x0, T x1, T x2, T x3, T f0, T f1, T f2, T f3, T x) {
+    /*
+    Lagrange cubic interpolation as from
+    http://nd.edu/~jjwteach/441/PdfNotes/lecture6.pdf
+    */
+    T L0, L1, L2, L3;
+    L0 = ((x - x1) * (x - x2) * (x - x3)) / ((x0 - x1) * (x0 - x2) * (x0 - x3));
+    L1 = ((x - x0) * (x - x2) * (x - x3)) / ((x1 - x0) * (x1 - x2) * (x1 - x3));
+    L2 = ((x - x0) * (x - x1) * (x - x3)) / ((x2 - x0) * (x2 - x1) * (x2 - x3));
+    L3 = ((x - x0) * (x - x1) * (x - x2)) / ((x3 - x0) * (x3 - x1) * (x3 - x2));
+    return L0 * f0 + L1 * f1 + L2 * f2 + L3 * f3;
+};
+/** /brief Calculate the first derivative of the function using a cubic interpolation form
+    */
+template <class T>
+T CubicInterpFirstDeriv(T x0, T x1, T x2, T x3, T f0, T f1, T f2, T f3, T x) {
+    // Based on http://math.stackexchange.com/a/809946/66405
+    T L0 = ((x - x1) * (x - x2) * (x - x3)) / ((x0 - x1) * (x0 - x2) * (x0 - x3));
+    T dL0_dx = (1 / (x - x1) + 1 / (x - x2) + 1 / (x - x3)) * L0;
+    T L1 = ((x - x0) * (x - x2) * (x - x3)) / ((x1 - x0) * (x1 - x2) * (x1 - x3));
+    T dL1_dx = (1 / (x - x0) + 1 / (x - x2) + 1 / (x - x3)) * L1;
+    T L2 = ((x - x0) * (x - x1) * (x - x3)) / ((x2 - x0) * (x2 - x1) * (x2 - x3));
+    T dL2_dx = (1 / (x - x0) + 1 / (x - x1) + 1 / (x - x3)) * L2;
+    T L3 = ((x - x0) * (x - x1) * (x - x2)) / ((x3 - x0) * (x3 - x1) * (x3 - x2));
+    T dL3_dx = (1 / (x - x0) + 1 / (x - x1) + 1 / (x - x2)) * L3;
+    return dL0_dx * f0 + dL1_dx * f1 + dL2_dx * f2 + dL3_dx * f3;
+};
+template <class T1, class T2>
+T2 CubicInterp(const std::vector<T1>& x, const std::vector<T1>& y, std::size_t i0, std::size_t i1, std::size_t i2, std::size_t i3, T2 val) {
+    return CubicInterp(x[i0], x[i1], x[i2], x[i3], y[i0], y[i1], y[i2], y[i3], static_cast<T1>(val));
+};
+
+template <class T>
+T is_in_closed_range(T x1, T x2, T x) {
+    return (x >= std::min(x1, x2) && x <= std::max(x1, x2));
+};
+
+/** \brief Solve a cubic with coefficients in decreasing order
+    *
+    * 0 = ax^3 + b*x^2 + c*x + d
+    *
+    * @param a The x^3 coefficient
+    * @param b The x^2 coefficient
+    * @param c The x^1 coefficient
+    * @param d The x^0 coefficient
+    * @param N The number of unique real solutions found
+    * @param x0 The first solution found
+    * @param x1 The second solution found
+    * @param x2 The third solution found
+    */
+void solve_cubic(double a, double b, double c, double d, int& N, double& x0, double& x1, double& x2);
+
+void solve_quartic(double a, double b, double c, double d, double e, int& N, double& x0, double& x1, double& x2, double& x3);
+
+template <class T>
+inline T min3(T x1, T x2, T x3) {
+    return std::min(std::min(x1, x2), x3);
+};
+template <class T>
+inline T max3(T x1, T x2, T x3) {
+    return std::max(std::max(x1, x2), x3);
+};
+template <class T>
+inline T min4(T x1, T x2, T x3, T x4) {
+    return std::min(std::min(std::min(x1, x2), x3), x4);
+};
+template <class T>
+inline T max4(T x1, T x2, T x3, T x4) {
+    return std::max(std::max(std::max(x1, x2), x3), x4);
+};
+
+inline bool double_equal(double a, double b) {
+    return std::abs(a - b) <= 1 * DBL_EPSILON * std::max(std::abs(a), std::abs(b));
+};
+
+template <class T>
+T max_abs_value(const std::vector<T>& x) {
+    T max = 0;
+    std::size_t N = x.size();
+    for (std::size_t i = 0; i < N; ++i) {
+        T axi = std::abs(x[i]);
+        if (axi > max) {
+            max = axi;
+        }
+    }
+    return max;
+}
+
+template <class T>
+T min_abs_value(const std::vector<T>& x) {
+    T min = 1e40;
+    std::size_t N = x.size();
+    for (std::size_t i = 0; i < N; ++i) {
+        T axi = std::abs(x[i]);
+        if (axi < min) {
+            min = axi;
+        }
+    }
+    return min;
+}
+
+inline int Kronecker_delta(std::size_t i, std::size_t j) {
+    if (i == j) {
+        return static_cast<int>(1);
+    } else {
+        return static_cast<int>(0);
+    }
+};
+inline int Kronecker_delta(int i, int j) {
+    if (i == j) {
+        return 1;
+    } else {
+        return 0;
+    }
+};
+
+/// Sort three values in place; see http://codereview.stackexchange.com/a/64763
+template <typename T>
+void sort3(T& a, T& b, T& c) {
+    if (a > b) {
+        std::swap(a, b);
+    }
+    if (a > c) {
+        std::swap(a, c);
+    }
+    if (b > c) {
+        std::swap(b, c);
+    }
+}
+
+/**
+* Due to the periodicity of angles, you need to handle the case where the
+* angles wrap around - suppose theta_d is 6.28 and you are at an angles of 0.1 rad,
+* the difference should be around 0.1, not -6.27
+*
+* This brilliant method is from http://blog.lexique-du-net.com/index.php?post/Calculate-the-real-difference-between-two-angles-keeping-the-sign
+* and the comment of user tk
+*
+* Originally implemented in PDSim
+*/
+template <class T>
+T angle_difference(T angle1, T angle2) {
+    return fmod(angle1 - angle2 + M_PI, 2 * M_PI) - M_PI;
+}
+
+/// A simple function for use in wrappers where macros cause problems
+inline double get_HUGE() {
+    return _HUGE;
+}
+
+#if defined(_MSC_VER)
+// Microsoft version of math.h doesn't include acosh or asinh, so we just define them here.
+// It was included from Visual Studio 2013
+#    if _MSC_VER < 1800
+double acosh(double x) {
+    return log(x + sqrt(x * x - 1.0));
+}
+double asinh(double value) {
+    if (value > 0) {
+        return log(value + sqrt(value * value + 1));
+    } else {
+        return -log(-value + sqrt(value * value + 1));
+    }
+}
+#    endif
+#endif
+
+#if defined(__ISPOWERPC__)
+// PPC version of math.h doesn't include acosh or asinh, so we just define them here
+double acosh(double x) {
+    return log(x + sqrt(x * x - 1.0));
+}
+double asinh(double value) {
+    if (value > 0) {
+        return log(value + sqrt(value * value + 1));
+    } else {
+        return -log(-value + sqrt(value * value + 1));
+    }
+}
+#endif
+
+#if defined(__ISPOWERPC__)
+#    undef EOS
+#endif
+
+#endif
```

## CoolProp/include/CPstrings.h

```diff
@@ -1,140 +1,140 @@
-
-#ifndef COOLPROP_STRINGS_H
-#define COOLPROP_STRINGS_H
-
-#include <iterator>
-#include <algorithm>
-#include <functional>
-#include <cctype>
-
-#if !defined(NO_FMTLIB)
-#    ifndef FMT_HEADER_ONLY
-#        define FMT_HEADER_ONLY
-#    endif
-#    include "fmt/format.h"  // For addition of the string formatting functions and macros from fmtlib
-#    include "fmt/printf.h"  // For sprintf
-#    undef FMT_HEADER_ONLY
-#else
-#    include <vector>
-#    include <string>
-#endif
-
-#include "Exceptions.h"
-
-#if !defined(__powerpc__)
-/// Copy string to wstring
-/// Dangerous if the string has non-ASCII characters; from http://stackoverflow.com/a/8969776/1360263
-inline void StringToWString(const std::string& s, std::wstring& ws) {
-    ws = std::wstring(s.begin(), s.end());
-}
-#endif
-
-/// The following code for the trim functions was taken from http://stackoverflow.com/questions/216823/whats-the-best-way-to-trim-stdstring
-// trim from start
-#ifdef HAS_MOVE_SEMANTICS  //More robust c++11 detection https://stackoverflow.com/questions/10717502/is-there-a-preprocessor-directive-for-detecting-c11x-support
-// #ifdef __cplusplus >= 201103L || (defined(_MSC_VER) && _MSC_VER >= 1900)
-inline std::string& strlstrip(std::string& s) {
-    s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));
-    return s;
-}
-#else
-inline std::string& strlstrip(std::string& s) {
-    s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](unsigned char ch) { return !std::isspace(ch); }));
-    return s;
-}
-#endif
-// trim from end
-#ifdef HAS_MOVE_SEMANTICS  //More robust c++11 detection https://stackoverflow.com/questions/10717502/is-there-a-preprocessor-directive-for-detecting-c11x-support
-// #ifdef __cplusplus >= 201103L || (defined(_MSC_VER) && _MSC_VER >= 1900)
-inline std::string& strrstrip(std::string& s) {
-    s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
-    return s;
-}
-#else
-inline std::string& strrstrip(std::string& s) {
-    s.erase(std::find_if(s.rbegin(), s.rend(), [](unsigned char ch) { return !std::isspace(ch); }).base(), s.end());
-    return s;
-}
-#endif
-// trim from both ends
-inline std::string& strstrip(std::string& s) {
-    return strlstrip(strrstrip(s));
-}
-/// Simple string function to check for end of string being equal to given string
-inline bool endswith(const std::string& s1, const std::string& s2) {
-    // Impossible to match a string longer than the given string
-    if (s2.size() > s1.size()) {
-        return false;
-    }
-    long lhs = static_cast<long>(s1.rfind(s2));
-    long rhs = static_cast<long>(s1.size()) - static_cast<long>(s2.size());
-    return lhs == rhs;
-}
-
-#if defined(NO_FMTLIB)
-// Missing string formatting function, this old guy is needed for ancient gcc compilers on PowerPC for VxWorks
-inline std::string format(const char* fmt, ...);
-#else
-// Missing std::string formatting function - provided by the fmtlib library
-inline std::string format(const char* format, fmt::ArgList args) {
-    return fmt::sprintf(format, args);
-}
-FMT_VARIADIC(std::string, format, const char*)
-// For latest FMTLIB
-/*template <typename... Args>
-    inline std::string format(const char *format_str, const Args & ... args) {
-        return fmt::sprintf(format_str, args);
-    }*/
-#endif
-
-// Missing string split - like in Python
-std::vector<std::string> strsplit(const std::string& s, char del);
-
-inline std::string upper(std::string str) {
-    std::transform(str.begin(), str.end(), str.begin(), ::toupper);
-    return str;
-}
-
-inline std::string lower(std::string str) {
-    std::transform(str.begin(), str.end(), str.begin(), ::tolower);
-    return str;
-}
-
-std::string strjoin(const std::vector<std::string>& strings, const std::string& delim);
-
-/// A convenience function that return true if a string begins with the given other string
-inline bool strstartswith(const std::string& s, const std::string& other) {
-    return s.find(other) == 0;
-};
-
-/**
-     * @brief Convert a number encoded as a string to a double
-     * @param s The string to be converted
-     *
-     * @note
-     */
-inline double string2double(const std::string& s) {
-    std::string mys = s;  //copy
-    // replace D with e (FORTRAN style scientific definition)
-    if (mys.find("D") != std::string::npos) {
-        std::size_t pos = mys.find("D"), len = 1;
-        mys.replace(pos, len, "e");
-    }
-    // replace d with e (FORTRAN style scientific definition)
-    if (mys.find("d") != std::string::npos) {
-        std::size_t pos = mys.find("d"), len = 1;
-        mys.replace(pos, len, "e");
-    }
-
-    const char* cs = mys.c_str();
-    char* pEnd;
-    double val = strtod(cs, &pEnd);
-    if ((pEnd - &(cs[0])) != static_cast<int>(s.size())) {
-        // Found a character that is not able to be converted to number
-        throw CoolProp::ValueError(format("Unable to convert this string to a number:%s", cs));
-    } else {
-        return val;
-    }
-}
-
-#endif
+
+#ifndef COOLPROP_STRINGS_H
+#define COOLPROP_STRINGS_H
+
+#include <iterator>
+#include <algorithm>
+#include <functional>
+#include <cctype>
+#include <vector>
+
+#if !defined(NO_FMTLIB)
+#    ifndef FMT_HEADER_ONLY
+#        define FMT_HEADER_ONLY
+#    endif
+#    include "fmt/format.h"  // For addition of the string formatting functions and macros from fmtlib
+#    include "fmt/printf.h"  // For sprintf
+#    undef FMT_HEADER_ONLY
+#else
+#    include <vector>
+#    include <string>
+#endif
+
+#include "Exceptions.h"
+
+#if !defined(__powerpc__)
+/// Copy string to wstring
+/// Dangerous if the string has non-ASCII characters; from http://stackoverflow.com/a/8969776/1360263
+inline void StringToWString(const std::string& s, std::wstring& ws) {
+    ws = std::wstring(s.begin(), s.end());
+}
+#endif
+
+/// The following code for the trim functions was taken from http://stackoverflow.com/questions/216823/whats-the-best-way-to-trim-stdstring
+// trim from start
+#ifdef HAS_MOVE_SEMANTICS  //More robust c++11 detection https://stackoverflow.com/questions/10717502/is-there-a-preprocessor-directive-for-detecting-c11x-support
+// #ifdef __cplusplus >= 201103L || (defined(_MSC_VER) && _MSC_VER >= 1900)
+inline std::string& strlstrip(std::string& s) {
+    s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));
+    return s;
+}
+#else
+inline std::string& strlstrip(std::string& s) {
+    s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](unsigned char ch) { return !std::isspace(ch); }));
+    return s;
+}
+#endif
+// trim from end
+#ifdef HAS_MOVE_SEMANTICS  //More robust c++11 detection https://stackoverflow.com/questions/10717502/is-there-a-preprocessor-directive-for-detecting-c11x-support
+// #ifdef __cplusplus >= 201103L || (defined(_MSC_VER) && _MSC_VER >= 1900)
+inline std::string& strrstrip(std::string& s) {
+    s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
+    return s;
+}
+#else
+inline std::string& strrstrip(std::string& s) {
+    s.erase(std::find_if(s.rbegin(), s.rend(), [](unsigned char ch) { return !std::isspace(ch); }).base(), s.end());
+    return s;
+}
+#endif
+// trim from both ends
+inline std::string& strstrip(std::string& s) {
+    return strlstrip(strrstrip(s));
+}
+/// Simple string function to check for end of string being equal to given string
+inline bool endswith(const std::string& s1, const std::string& s2) {
+    // Impossible to match a string longer than the given string
+    if (s2.size() > s1.size()) {
+        return false;
+    }
+    long lhs = static_cast<long>(s1.rfind(s2));
+    long rhs = static_cast<long>(s1.size()) - static_cast<long>(s2.size());
+    return lhs == rhs;
+}
+
+#if defined(NO_FMTLIB)
+// Missing string formatting function, this old guy is needed for ancient gcc compilers on PowerPC for VxWorks
+inline std::string format(const char* fmt, ...);
+#elif FMT_VERSION >= 50000
+template <typename... Args>
+inline std::string format(const char* format_str, const Args&... args) {
+    return fmt::sprintf(format_str, args...);
+}
+#else
+inline std::string format(const char* format, fmt::ArgList args) {
+    return fmt::sprintf(format, args);
+}
+FMT_VARIADIC(std::string, format, const char*)
+#endif
+
+// Missing string split - like in Python
+std::vector<std::string> strsplit(const std::string& s, char del);
+
+inline std::string upper(std::string str) {
+    std::transform(str.begin(), str.end(), str.begin(), ::toupper);
+    return str;
+}
+
+inline std::string lower(std::string str) {
+    std::transform(str.begin(), str.end(), str.begin(), ::tolower);
+    return str;
+}
+
+std::string strjoin(const std::vector<std::string>& strings, const std::string& delim);
+
+/// A convenience function that return true if a string begins with the given other string
+inline bool strstartswith(const std::string& s, const std::string& other) {
+    return s.find(other) == 0;
+};
+
+/**
+     * @brief Convert a number encoded as a string to a double
+     * @param s The string to be converted
+     *
+     * @note
+     */
+inline double string2double(const std::string& s) {
+    std::string mys = s;  //copy
+    // replace D with e (FORTRAN style scientific definition)
+    if (mys.find("D") != std::string::npos) {
+        std::size_t pos = mys.find("D"), len = 1;
+        mys.replace(pos, len, "e");
+    }
+    // replace d with e (FORTRAN style scientific definition)
+    if (mys.find("d") != std::string::npos) {
+        std::size_t pos = mys.find("d"), len = 1;
+        mys.replace(pos, len, "e");
+    }
+
+    const char* cs = mys.c_str();
+    char* pEnd;
+    double val = strtod(cs, &pEnd);
+    if ((pEnd - &(cs[0])) != static_cast<int>(s.size())) {
+        // Found a character that is not able to be converted to number
+        throw CoolProp::ValueError(format("Unable to convert this string to a number:%s", cs));
+    } else {
+        return val;
+    }
+}
+
+#endif
```

## CoolProp/include/CachedElement.h

 * *Ordering differences only*

```diff
@@ -1,89 +1,89 @@
-/*
- * CachedElement.h
- *
- *  Created on: 21 Dec 2013
- *      Author: jowr
- */
-
-#ifndef CACHEDELEMENT_H_
-#define CACHEDELEMENT_H_
-
-#include "CoolPropTools.h"
-#include "DataStructures.h"
-
-namespace CoolProp {
-
-/*!
-A class that contains the magic to cache a value.
-
-Includes an "=" assignment operator and casting to boolean
-so you can do something like::
-
-double CoolPropStateClassSI::d3phir_dTau3(double tau, double delta){
-    if (cache.d3phir_dTau3)    {
-        return cache.d3phir_dTau3;
-    } else {
-        cache.d3phir_dTau3 = pFluid->d3phir_dTau3(tau,delta);
-        return cache.d3phir_dTau3;
-    }
-};
-*/
-
-class CachedElement
-{
-
-   private:
-    bool is_cached;
-    CoolPropDbl value;
-
-   public:
-    /// Default constructor
-    CachedElement() {
-        this->clear();
-    };
-
-    /// Function to carry out the caching
-    void _do_cache(double value) {
-        this->value = value;
-        this->is_cached = true;
-    }
-
-    /// Assignment operator - sets the value and sets the flag
-    void operator=(const double& value) {
-        _do_cache(value);
-    };
-
-    /// Cast to boolean, for checking if cached
-    operator bool() {
-        return is_cached;
-    };
-
-    /// Cast to double, for returning value
-    operator double() {
-        if (is_cached) {
-            return static_cast<double>(value);
-        } else {
-            throw std::exception();
-        }
-    }
-#ifndef COOLPROPDBL_MAPS_TO_DOUBLE
-    operator CoolPropDbl() {
-        if (is_cached) {
-            return value;
-        } else {
-            throw std::exception();
-        }
-    }
-#endif
-    /// Clear the flag and the value
-    void clear() {
-        is_cached = false;
-        this->value = _HUGE;
-    };
-    CoolPropDbl& pt() {
-        return this->value;
-    }
-};
-
-} /* namespace CoolProp */
-#endif /* CACHEDELEMENT_H_ */
+/*
+ * CachedElement.h
+ *
+ *  Created on: 21 Dec 2013
+ *      Author: jowr
+ */
+
+#ifndef CACHEDELEMENT_H_
+#define CACHEDELEMENT_H_
+
+#include "CoolPropTools.h"
+#include "DataStructures.h"
+
+namespace CoolProp {
+
+/*!
+A class that contains the magic to cache a value.
+
+Includes an "=" assignment operator and casting to boolean
+so you can do something like::
+
+double CoolPropStateClassSI::d3phir_dTau3(double tau, double delta){
+    if (cache.d3phir_dTau3)    {
+        return cache.d3phir_dTau3;
+    } else {
+        cache.d3phir_dTau3 = pFluid->d3phir_dTau3(tau,delta);
+        return cache.d3phir_dTau3;
+    }
+};
+*/
+
+class CachedElement
+{
+
+   private:
+    bool is_cached;
+    CoolPropDbl value;
+
+   public:
+    /// Default constructor
+    CachedElement() {
+        this->clear();
+    };
+
+    /// Function to carry out the caching
+    void _do_cache(double value) {
+        this->value = value;
+        this->is_cached = true;
+    }
+
+    /// Assignment operator - sets the value and sets the flag
+    void operator=(const double& value) {
+        _do_cache(value);
+    };
+
+    /// Cast to boolean, for checking if cached
+    operator bool() {
+        return is_cached;
+    };
+
+    /// Cast to double, for returning value
+    operator double() {
+        if (is_cached) {
+            return static_cast<double>(value);
+        } else {
+            throw std::exception();
+        }
+    }
+#ifndef COOLPROPDBL_MAPS_TO_DOUBLE
+    operator CoolPropDbl() {
+        if (is_cached) {
+            return value;
+        } else {
+            throw std::exception();
+        }
+    }
+#endif
+    /// Clear the flag and the value
+    void clear() {
+        is_cached = false;
+        this->value = _HUGE;
+    };
+    CoolPropDbl& pt() {
+        return this->value;
+    }
+};
+
+} /* namespace CoolProp */
+#endif /* CACHEDELEMENT_H_ */
```

## CoolProp/include/Configuration.h

 * *Ordering differences only*

```diff
@@ -1,356 +1,356 @@
-#ifndef COOLPROP_CONFIGURATION
-#define COOLPROP_CONFIGURATION
-
-#include "Exceptions.h"
-#include "CoolPropTools.h"
-
-#if !defined(SWIG)  // Hide this for swig - Swig gets confused
-#    include "rapidjson_include.h"
-#endif
-
-/* See http://stackoverflow.com/a/148610
- * See http://stackoverflow.com/questions/147267/easy-way-to-use-variables-of-enum-types-as-string-in-c#202511
- * This will be used to generate an enum like:
- * enum configuration_keys {NORMALIZE_GAS_CONSTANTS, CRITICAL_SPLINES_ENABLED};
- *
- * The values in this list are given by:
- * enum, string representation of enum, default value, description
- *
- * The type of the default value specifies the only type that will be accepted for this parameter
- */
-#define CONFIGURATION_KEYS_ENUM                                                                                                                      \
-    X(NORMALIZE_GAS_CONSTANTS, "NORMALIZE_GAS_CONSTANTS", true, "If true, for mixtures, the molar gas constant (R) will be set to the CODATA value") \
-    X(CRITICAL_WITHIN_1UK, "CRITICAL_WITHIN_1UK", true,                                                                                              \
-      "If true, any temperature within 1 uK of the critical temperature will be considered to be AT the critical point")                             \
-    X(CRITICAL_SPLINES_ENABLED, "CRITICAL_SPLINES_ENABLED", true,                                                                                    \
-      "If true, the critical splines will be used in the near-vicinity of the critical point")                                                       \
-    X(SAVE_RAW_TABLES, "SAVE_RAW_TABLES", false, "If true, the raw, uncompressed tables will also be written to file")                               \
-    X(ALTERNATIVE_TABLES_DIRECTORY, "ALTERNATIVE_TABLES_DIRECTORY", "",                                                                              \
-      "If provided, this path will be the root directory for the tabular data.  Otherwise, ${HOME}/.CoolProp/Tables is used")                        \
-    X(ALTERNATIVE_REFPROP_PATH, "ALTERNATIVE_REFPROP_PATH", "",                                                                                      \
-      "An alternative path to be provided to the directory that contains REFPROP's fluids and mixtures directories.  If provided, the SETPATH "      \
-      "function will be called with this directory prior to calling any REFPROP functions.")                                                         \
-    X(ALTERNATIVE_REFPROP_HMX_BNC_PATH, "ALTERNATIVE_REFPROP_HMX_BNC_PATH", "",                                                                      \
-      "An alternative path to the HMX.BNC file.  If provided, it will be passed into REFPROP's SETUP or SETMIX routines")                            \
-    X(ALTERNATIVE_REFPROP_LIBRARY_PATH, "ALTERNATIVE_REFPROP_LIBRARY_PATH", "",                                                                      \
-      "An alternative path to the shared library file.  If provided, it will be used to load REFPROP")                                               \
-    X(REFPROP_DONT_ESTIMATE_INTERACTION_PARAMETERS, "REFPROP_DONT_ESTIMATE_INTERACTION_PARAMETERS", false,                                           \
-      "If true, if the binary interaction parameters in REFPROP are estimated, throw an error rather than silently continuing")                      \
-    X(REFPROP_IGNORE_ERROR_ESTIMATED_INTERACTION_PARAMETERS, "REFPROP_IGNORE_ERROR_ESTIMATED_INTERACTION_PARAMETERS", false,                         \
-      "If true, if the binary interaction parameters in REFPROP are unable to be estimated, silently continue rather than failing")                  \
-    X(REFPROP_USE_GERG, "REFPROP_USE_GERG", false,                                                                                                   \
-      "If true, rather than using the highly-accurate pure fluid equations of state, use the pure-fluid EOS from GERG-2008")                         \
-    X(REFPROP_ERROR_THRESHOLD, "REFPROP_ERROR_THRESHOLD", static_cast<int>(0), "The highest acceptable error code without throwing an exception")    \
-    X(REFPROP_USE_PENGROBINSON, "REFPROP_USE_PENGROBINSON", false,                                                                                   \
-      "If true, rather than using the highly-accurate pure fluid equations of state, use the Peng-Robinson EOS")                                     \
-    X(MAXIMUM_TABLE_DIRECTORY_SIZE_IN_GB, "MAXIMUM_TABLE_DIRECTORY_SIZE_IN_GB", 1.0,                                                                 \
-      "The maximum allowed size of the directory that is used to store tabular data")                                                                \
-    X(DONT_CHECK_PROPERTY_LIMITS, "DONT_CHECK_PROPERTY_LIMITS", false,                                                                               \
-      "If true, when possible, CoolProp will skip checking whether values are inside the property limits")                                           \
-    X(HENRYS_LAW_TO_GENERATE_VLE_GUESSES, "HENRYS_LAW_TO_GENERATE_VLE_GUESSES", false,                                                               \
-      "If true, when doing water-based mixture dewpoint calculations, use Henry's Law to generate guesses for liquid-phase composition")             \
-    X(PHASE_ENVELOPE_STARTING_PRESSURE_PA, "PHASE_ENVELOPE_STARTING_PRESSURE_PA", 100.0, "Starting pressure [Pa] for phase envelope construction")   \
-    X(R_U_CODATA, "R_U_CODATA", 8.3144598,                                                                                                           \
-      "The value for the ideal gas constant in J/mol/K according to CODATA 2014.  This value is used to harmonize all the ideal gas constants. "     \
-      "This is especially important in the critical region.")                                                                                        \
-    X(VTPR_UNIFAC_PATH, "VTPR_UNIFAC_PATH", "", "The path to the directory containing the UNIFAC JSON files.  Should be slash terminated")           \
-    X(SPINODAL_MINIMUM_DELTA, "SPINODAL_MINIMUM_DELTA", 0.5,                                                                                         \
-      "The minimal delta to be used in tracing out the spinodal; make sure that the EOS has a spinodal at this value of delta=rho/rho_r")            \
-    X(OVERWRITE_FLUIDS, "OVERWRITE_FLUIDS", false,                                                                                                   \
-      "If true, and a fluid is added to the fluids library that is already there, rather than not adding the fluid (and probably throwing an "       \
-      "exception), overwrite it")                                                                                                                    \
-    X(OVERWRITE_DEPARTURE_FUNCTION, "OVERWRITE_DEPARTURE_FUNCTION", false,                                                                           \
-      "If true, and a departure function to be added is already there, rather than not adding the departure function (and probably throwing an "     \
-      "exception), overwrite it")                                                                                                                    \
-    X(OVERWRITE_BINARY_INTERACTION, "OVERWRITE_BINARY_INTERACTION", false,                                                                           \
-      "If true, and a pair of binary interaction pairs to be added is already there, rather than not adding the binary interaction pair (and "       \
-      "probably throwing an exception), overwrite it")                                                                                               \
-    X(USE_GUESSES_IN_PROPSSI, "USE_GUESSES_IN_PROPSSI", false,                                                                                       \
-      "If true, calls to the vectorized versions of PropsSI use the previous state as guess value while looping over the input vectors, only makes " \
-      "sense when working with a single fluid and with points that are not too far from each other.")                                                \
-    X(ASSUME_CRITICAL_POINT_STABLE, "ASSUME_CRITICAL_POINT_STABLE", false,                                                                           \
-      "If true, evaluation of the stability of critical point will be skipped and point will be assumed to be stable")                               \
-    X(VTPR_ALWAYS_RELOAD_LIBRARY, "VTPR_ALWAYS_RELOAD_LIBRARY", false,                                                                               \
-      "If true, the library will always be reloaded, no matter what is currently loaded")                                                            \
-    X(FLOAT_PUNCTUATION, "FLOAT_PUNCTUATION", ".", "The first character of this string will be used as the separator between the number fraction.")  \
-    X(LIST_STRING_DELIMITER, "LIST_STRING_DELIMITER", ",", "The delimiter to be used when converting a list of strings to a string")
-
-// Use preprocessor to create the Enum
-enum configuration_keys
-{
-#define X(Enum, String, Default, Desc) Enum,
-    CONFIGURATION_KEYS_ENUM
-#undef X
-};
-
-// Evidently SWIG+MATLAB cannot properly wrap enums within classes
-enum ConfigurationDataTypes
-{
-    CONFIGURATION_NOT_DEFINED_TYPE = 0,
-    CONFIGURATION_BOOL_TYPE,
-    CONFIGURATION_DOUBLE_TYPE,
-    CONFIGURATION_INTEGER_TYPE,
-    CONFIGURATION_STRING_TYPE,
-    CONFIGURATION_ENDOFLIST_TYPE
-};
-
-namespace CoolProp {
-
-/// Convert the configuration key to a string in a 1-1 representation.
-std::string config_key_to_string(configuration_keys keys);
-
-/// Convert a string description to a configuration key
-configuration_keys config_string_to_key(const std::string& s);
-
-/// Return a string description of the configuration key
-std::string config_key_description(configuration_keys keys);
-
-/// Return a string description of the configuration key (with the key passed as a string)
-std::string config_key_description(const std::string& key);
-
-/// A class that contains one entry in configuration
-/// Can be cast to yield the output value
-class ConfigurationItem
-{
-   public:
-    /// Cast to boolean
-    operator bool() const {
-        check_data_type(CONFIGURATION_BOOL_TYPE);
-        return v_bool;
-    };
-    /// Cast to double
-    operator double() const {
-        check_data_type(CONFIGURATION_DOUBLE_TYPE);
-        return v_double;
-    };
-    /// Cast to string
-    operator std::string() const {
-        check_data_type(CONFIGURATION_STRING_TYPE);
-        return v_string;
-    };
-    /// Cast to integer
-    operator int() const {
-        check_data_type(CONFIGURATION_INTEGER_TYPE);
-        return v_integer;
-    };
-    // Initializer for bool
-    ConfigurationItem(configuration_keys key, bool val) {
-        this->key = key;
-        type = CONFIGURATION_BOOL_TYPE;
-        v_bool = val;
-    };
-    // Initializer for integer
-    ConfigurationItem(configuration_keys key, int val) {
-        this->key = key;
-        type = CONFIGURATION_INTEGER_TYPE;
-        v_integer = val;
-    };
-    // Initializer for double
-    ConfigurationItem(configuration_keys key, double val) {
-        this->key = key;
-        type = CONFIGURATION_DOUBLE_TYPE;
-        v_double = val;
-    };
-    // Initializer for const char *
-    ConfigurationItem(configuration_keys key, const char* val) {
-        this->key = key;
-        type = CONFIGURATION_STRING_TYPE;
-        v_string = val;
-    };
-    // Initializer for string
-    ConfigurationItem(configuration_keys key, const std::string& val) {
-        this->key = key;
-        type = CONFIGURATION_STRING_TYPE;
-        v_string = val;
-    };
-    void set_bool(bool val) {
-        check_data_type(CONFIGURATION_BOOL_TYPE);
-        v_bool = val;
-    }
-    void set_integer(int val) {
-        check_data_type(CONFIGURATION_INTEGER_TYPE);
-        v_integer = val;
-    }
-    void set_double(double val) {
-        check_data_type(CONFIGURATION_DOUBLE_TYPE);
-        v_double = val;
-    }
-    void set_string(const std::string& val) {
-        check_data_type(CONFIGURATION_STRING_TYPE);
-        v_string = val;
-    }
-
-    configuration_keys get_key(void) const {
-        return this->key;
-    }
-#if !defined(SWIG)
-    /// Cast to rapidjson::Value
-    void add_to_json(rapidjson::Value& val, rapidjson::Document& d) const {
-        std::string name_string = config_key_to_string(key);
-        rapidjson::Value name(name_string.c_str(), d.GetAllocator());
-        switch (type) {
-            case CONFIGURATION_BOOL_TYPE: {
-                rapidjson::Value v(v_bool);
-                val.AddMember(name, v, d.GetAllocator());
-                break;
-            }
-            case CONFIGURATION_INTEGER_TYPE: {
-                rapidjson::Value v(v_integer);
-                val.AddMember(name, v, d.GetAllocator());
-                break;
-            }
-            case CONFIGURATION_DOUBLE_TYPE: {
-                rapidjson::Value v(v_double);  // Try to upcast
-                val.AddMember(name, v, d.GetAllocator());
-                break;
-            }
-            case CONFIGURATION_STRING_TYPE: {
-                rapidjson::Value v(v_string.c_str(), d.GetAllocator());
-                val.AddMember(name, v, d.GetAllocator());
-                break;
-            }
-            case CONFIGURATION_ENDOFLIST_TYPE:
-            case CONFIGURATION_NOT_DEFINED_TYPE:
-                throw ValueError();
-        }
-    }
-    void set_from_json(rapidjson::Value& val) {
-        switch (type) {
-            case CONFIGURATION_BOOL_TYPE:
-                if (!val.IsBool()) {
-                    throw ValueError(format("Input is not boolean"));
-                };
-                v_bool = val.GetBool();
-                break;
-            case CONFIGURATION_INTEGER_TYPE:
-                if (!val.IsInt()) {
-                    throw ValueError(format("Input is not integer"));
-                };
-                v_integer = val.GetInt();
-                break;
-            case CONFIGURATION_DOUBLE_TYPE: {
-                if (!val.IsDouble() && !val.IsInt()) {
-                    throw ValueError(format("Input [%s] is not double (or something that can be cast to double)", cpjson::to_string(val).c_str()));
-                };
-                if (val.IsDouble()) {
-                    v_double = val.GetDouble();
-                } else {
-                    v_double = static_cast<double>(val.GetInt());
-                }
-                break;
-            }
-            case CONFIGURATION_STRING_TYPE:
-                if (!val.IsString()) {
-                    throw ValueError(format("Input is not string"));
-                };
-                v_string = val.GetString();
-                break;
-            case CONFIGURATION_ENDOFLIST_TYPE:
-            case CONFIGURATION_NOT_DEFINED_TYPE:
-                throw ValueError();
-        }
-    }
-#endif  // !defined(SWIG)
-
-   private:
-    void check_data_type(ConfigurationDataTypes type) const {
-        if (type != this->type) {
-            throw ValueError(format("type does not match"));
-        }
-    };
-    ConfigurationDataTypes type;
-    union
-    {
-        double v_double;
-        bool v_bool;
-        int v_integer;
-    };
-    std::string v_string;
-    configuration_keys key;
-};
-
-class Configuration
-{
-   protected:
-    std::map<configuration_keys, ConfigurationItem> items;
-
-   public:
-    Configuration() {
-        set_defaults();
-    };
-    ~Configuration(){};
-
-    /// Get an item from the configuration
-    ConfigurationItem& get_item(configuration_keys key) {
-        // Try to find it
-        std::map<configuration_keys, ConfigurationItem>::iterator it = items.find(key);
-        // If equal to end, not found
-        if (it != items.end()) {
-            // Found, return it
-            return it->second;
-        } else {
-            throw ValueError(format("invalid item"));
-        }
-    }
-    /// Add an item to the configuration
-    void add_item(ConfigurationItem item) {
-        std::pair<configuration_keys, ConfigurationItem> pair(item.get_key(), item);
-        items.insert(pair);
-    };
-
-    /// Return a reference to all of the items
-    std::map<configuration_keys, ConfigurationItem>& get_items(void) {
-        return items;
-    };
-
-    /// Set the default values in the configuration
-    void set_defaults(void) {
-/* ***MAGIC WARNING**!!
-             * See http://stackoverflow.com/a/148610
-             * See http://stackoverflow.com/questions/147267/easy-way-to-use-variables-of-enum-types-as-string-in-c#202511
-             */
-#define X(Enum, String, Default, Desc) add_item(ConfigurationItem(Enum, Default));
-        CONFIGURATION_KEYS_ENUM
-#undef X
-    };
-};
-
-/// *********************************************************
-///                      GETTERS
-/// *********************************************************
-
-/// Return the value of a boolean key from the configuration
-bool get_config_bool(configuration_keys key);
-/// Return the value of an integer key from the configuration
-int get_config_int(configuration_keys key);
-/// Return the value of a double configuration key
-double get_config_double(configuration_keys key);
-/// Return the value of a string configuration key
-std::string get_config_string(configuration_keys key);
-#if !defined(SWIG)  // Hide this for swig - Swig gets confused
-void get_config_as_json(rapidjson::Document& doc);
-#endif
-/// Get all the values in the configuration as a json-formatted string
-std::string get_config_as_json_string();
-
-/// *********************************************************
-///                      SETTERS
-/// *********************************************************
-
-/// Set the value of a boolean configuration value
-void set_config_bool(configuration_keys key, bool val);
-/// Set the value of an integer configuration value
-void set_config_int(configuration_keys key, int val);
-/// Set the value of a double configuration value
-void set_config_double(configuration_keys key, double val);
-/// Set the value of a string configuration value
-void set_config_string(configuration_keys key, const std::string& val);
-/// Set values in the configuration based on a json file
-#if !defined(SWIG)  // Hide this for swig - Swig gets confused
-void set_config_json(rapidjson::Document& doc);
-#endif
-/// Set the entire configuration based on a json-formatted string
-void set_config_as_json_string(const std::string& s);
-}  // namespace CoolProp
-
-#endif  // COOLPROP_CONFIGURATION
+#ifndef COOLPROP_CONFIGURATION
+#define COOLPROP_CONFIGURATION
+
+#include "Exceptions.h"
+#include "CoolPropTools.h"
+
+#if !defined(SWIG)  // Hide this for swig - Swig gets confused
+#    include "rapidjson_include.h"
+#endif
+
+/* See http://stackoverflow.com/a/148610
+ * See http://stackoverflow.com/questions/147267/easy-way-to-use-variables-of-enum-types-as-string-in-c#202511
+ * This will be used to generate an enum like:
+ * enum configuration_keys {NORMALIZE_GAS_CONSTANTS, CRITICAL_SPLINES_ENABLED};
+ *
+ * The values in this list are given by:
+ * enum, string representation of enum, default value, description
+ *
+ * The type of the default value specifies the only type that will be accepted for this parameter
+ */
+#define CONFIGURATION_KEYS_ENUM                                                                                                                      \
+    X(NORMALIZE_GAS_CONSTANTS, "NORMALIZE_GAS_CONSTANTS", true, "If true, for mixtures, the molar gas constant (R) will be set to the CODATA value") \
+    X(CRITICAL_WITHIN_1UK, "CRITICAL_WITHIN_1UK", true,                                                                                              \
+      "If true, any temperature within 1 uK of the critical temperature will be considered to be AT the critical point")                             \
+    X(CRITICAL_SPLINES_ENABLED, "CRITICAL_SPLINES_ENABLED", true,                                                                                    \
+      "If true, the critical splines will be used in the near-vicinity of the critical point")                                                       \
+    X(SAVE_RAW_TABLES, "SAVE_RAW_TABLES", false, "If true, the raw, uncompressed tables will also be written to file")                               \
+    X(ALTERNATIVE_TABLES_DIRECTORY, "ALTERNATIVE_TABLES_DIRECTORY", "",                                                                              \
+      "If provided, this path will be the root directory for the tabular data.  Otherwise, ${HOME}/.CoolProp/Tables is used")                        \
+    X(ALTERNATIVE_REFPROP_PATH, "ALTERNATIVE_REFPROP_PATH", "",                                                                                      \
+      "An alternative path to be provided to the directory that contains REFPROP's fluids and mixtures directories.  If provided, the SETPATH "      \
+      "function will be called with this directory prior to calling any REFPROP functions.")                                                         \
+    X(ALTERNATIVE_REFPROP_HMX_BNC_PATH, "ALTERNATIVE_REFPROP_HMX_BNC_PATH", "",                                                                      \
+      "An alternative path to the HMX.BNC file.  If provided, it will be passed into REFPROP's SETUP or SETMIX routines")                            \
+    X(ALTERNATIVE_REFPROP_LIBRARY_PATH, "ALTERNATIVE_REFPROP_LIBRARY_PATH", "",                                                                      \
+      "An alternative path to the shared library file.  If provided, it will be used to load REFPROP")                                               \
+    X(REFPROP_DONT_ESTIMATE_INTERACTION_PARAMETERS, "REFPROP_DONT_ESTIMATE_INTERACTION_PARAMETERS", false,                                           \
+      "If true, if the binary interaction parameters in REFPROP are estimated, throw an error rather than silently continuing")                      \
+    X(REFPROP_IGNORE_ERROR_ESTIMATED_INTERACTION_PARAMETERS, "REFPROP_IGNORE_ERROR_ESTIMATED_INTERACTION_PARAMETERS", false,                         \
+      "If true, if the binary interaction parameters in REFPROP are unable to be estimated, silently continue rather than failing")                  \
+    X(REFPROP_USE_GERG, "REFPROP_USE_GERG", false,                                                                                                   \
+      "If true, rather than using the highly-accurate pure fluid equations of state, use the pure-fluid EOS from GERG-2008")                         \
+    X(REFPROP_ERROR_THRESHOLD, "REFPROP_ERROR_THRESHOLD", static_cast<int>(0), "The highest acceptable error code without throwing an exception")    \
+    X(REFPROP_USE_PENGROBINSON, "REFPROP_USE_PENGROBINSON", false,                                                                                   \
+      "If true, rather than using the highly-accurate pure fluid equations of state, use the Peng-Robinson EOS")                                     \
+    X(MAXIMUM_TABLE_DIRECTORY_SIZE_IN_GB, "MAXIMUM_TABLE_DIRECTORY_SIZE_IN_GB", 1.0,                                                                 \
+      "The maximum allowed size of the directory that is used to store tabular data")                                                                \
+    X(DONT_CHECK_PROPERTY_LIMITS, "DONT_CHECK_PROPERTY_LIMITS", false,                                                                               \
+      "If true, when possible, CoolProp will skip checking whether values are inside the property limits")                                           \
+    X(HENRYS_LAW_TO_GENERATE_VLE_GUESSES, "HENRYS_LAW_TO_GENERATE_VLE_GUESSES", false,                                                               \
+      "If true, when doing water-based mixture dewpoint calculations, use Henry's Law to generate guesses for liquid-phase composition")             \
+    X(PHASE_ENVELOPE_STARTING_PRESSURE_PA, "PHASE_ENVELOPE_STARTING_PRESSURE_PA", 100.0, "Starting pressure [Pa] for phase envelope construction")   \
+    X(R_U_CODATA, "R_U_CODATA", 8.3144598,                                                                                                           \
+      "The value for the ideal gas constant in J/mol/K according to CODATA 2014.  This value is used to harmonize all the ideal gas constants. "     \
+      "This is especially important in the critical region.")                                                                                        \
+    X(VTPR_UNIFAC_PATH, "VTPR_UNIFAC_PATH", "", "The path to the directory containing the UNIFAC JSON files.  Should be slash terminated")           \
+    X(SPINODAL_MINIMUM_DELTA, "SPINODAL_MINIMUM_DELTA", 0.5,                                                                                         \
+      "The minimal delta to be used in tracing out the spinodal; make sure that the EOS has a spinodal at this value of delta=rho/rho_r")            \
+    X(OVERWRITE_FLUIDS, "OVERWRITE_FLUIDS", false,                                                                                                   \
+      "If true, and a fluid is added to the fluids library that is already there, rather than not adding the fluid (and probably throwing an "       \
+      "exception), overwrite it")                                                                                                                    \
+    X(OVERWRITE_DEPARTURE_FUNCTION, "OVERWRITE_DEPARTURE_FUNCTION", false,                                                                           \
+      "If true, and a departure function to be added is already there, rather than not adding the departure function (and probably throwing an "     \
+      "exception), overwrite it")                                                                                                                    \
+    X(OVERWRITE_BINARY_INTERACTION, "OVERWRITE_BINARY_INTERACTION", false,                                                                           \
+      "If true, and a pair of binary interaction pairs to be added is already there, rather than not adding the binary interaction pair (and "       \
+      "probably throwing an exception), overwrite it")                                                                                               \
+    X(USE_GUESSES_IN_PROPSSI, "USE_GUESSES_IN_PROPSSI", false,                                                                                       \
+      "If true, calls to the vectorized versions of PropsSI use the previous state as guess value while looping over the input vectors, only makes " \
+      "sense when working with a single fluid and with points that are not too far from each other.")                                                \
+    X(ASSUME_CRITICAL_POINT_STABLE, "ASSUME_CRITICAL_POINT_STABLE", false,                                                                           \
+      "If true, evaluation of the stability of critical point will be skipped and point will be assumed to be stable")                               \
+    X(VTPR_ALWAYS_RELOAD_LIBRARY, "VTPR_ALWAYS_RELOAD_LIBRARY", false,                                                                               \
+      "If true, the library will always be reloaded, no matter what is currently loaded")                                                            \
+    X(FLOAT_PUNCTUATION, "FLOAT_PUNCTUATION", ".", "The first character of this string will be used as the separator between the number fraction.")  \
+    X(LIST_STRING_DELIMITER, "LIST_STRING_DELIMITER", ",", "The delimiter to be used when converting a list of strings to a string")
+
+// Use preprocessor to create the Enum
+enum configuration_keys
+{
+#define X(Enum, String, Default, Desc) Enum,
+    CONFIGURATION_KEYS_ENUM
+#undef X
+};
+
+// Evidently SWIG+MATLAB cannot properly wrap enums within classes
+enum ConfigurationDataTypes
+{
+    CONFIGURATION_NOT_DEFINED_TYPE = 0,
+    CONFIGURATION_BOOL_TYPE,
+    CONFIGURATION_DOUBLE_TYPE,
+    CONFIGURATION_INTEGER_TYPE,
+    CONFIGURATION_STRING_TYPE,
+    CONFIGURATION_ENDOFLIST_TYPE
+};
+
+namespace CoolProp {
+
+/// Convert the configuration key to a string in a 1-1 representation.
+std::string config_key_to_string(configuration_keys keys);
+
+/// Convert a string description to a configuration key
+configuration_keys config_string_to_key(const std::string& s);
+
+/// Return a string description of the configuration key
+std::string config_key_description(configuration_keys keys);
+
+/// Return a string description of the configuration key (with the key passed as a string)
+std::string config_key_description(const std::string& key);
+
+/// A class that contains one entry in configuration
+/// Can be cast to yield the output value
+class ConfigurationItem
+{
+   public:
+    /// Cast to boolean
+    operator bool() const {
+        check_data_type(CONFIGURATION_BOOL_TYPE);
+        return v_bool;
+    };
+    /// Cast to double
+    operator double() const {
+        check_data_type(CONFIGURATION_DOUBLE_TYPE);
+        return v_double;
+    };
+    /// Cast to string
+    operator std::string() const {
+        check_data_type(CONFIGURATION_STRING_TYPE);
+        return v_string;
+    };
+    /// Cast to integer
+    operator int() const {
+        check_data_type(CONFIGURATION_INTEGER_TYPE);
+        return v_integer;
+    };
+    // Initializer for bool
+    ConfigurationItem(configuration_keys key, bool val) {
+        this->key = key;
+        type = CONFIGURATION_BOOL_TYPE;
+        v_bool = val;
+    };
+    // Initializer for integer
+    ConfigurationItem(configuration_keys key, int val) {
+        this->key = key;
+        type = CONFIGURATION_INTEGER_TYPE;
+        v_integer = val;
+    };
+    // Initializer for double
+    ConfigurationItem(configuration_keys key, double val) {
+        this->key = key;
+        type = CONFIGURATION_DOUBLE_TYPE;
+        v_double = val;
+    };
+    // Initializer for const char *
+    ConfigurationItem(configuration_keys key, const char* val) {
+        this->key = key;
+        type = CONFIGURATION_STRING_TYPE;
+        v_string = val;
+    };
+    // Initializer for string
+    ConfigurationItem(configuration_keys key, const std::string& val) {
+        this->key = key;
+        type = CONFIGURATION_STRING_TYPE;
+        v_string = val;
+    };
+    void set_bool(bool val) {
+        check_data_type(CONFIGURATION_BOOL_TYPE);
+        v_bool = val;
+    }
+    void set_integer(int val) {
+        check_data_type(CONFIGURATION_INTEGER_TYPE);
+        v_integer = val;
+    }
+    void set_double(double val) {
+        check_data_type(CONFIGURATION_DOUBLE_TYPE);
+        v_double = val;
+    }
+    void set_string(const std::string& val) {
+        check_data_type(CONFIGURATION_STRING_TYPE);
+        v_string = val;
+    }
+
+    configuration_keys get_key(void) const {
+        return this->key;
+    }
+#if !defined(SWIG)
+    /// Cast to rapidjson::Value
+    void add_to_json(rapidjson::Value& val, rapidjson::Document& d) const {
+        std::string name_string = config_key_to_string(key);
+        rapidjson::Value name(name_string.c_str(), d.GetAllocator());
+        switch (type) {
+            case CONFIGURATION_BOOL_TYPE: {
+                rapidjson::Value v(v_bool);
+                val.AddMember(name, v, d.GetAllocator());
+                break;
+            }
+            case CONFIGURATION_INTEGER_TYPE: {
+                rapidjson::Value v(v_integer);
+                val.AddMember(name, v, d.GetAllocator());
+                break;
+            }
+            case CONFIGURATION_DOUBLE_TYPE: {
+                rapidjson::Value v(v_double);  // Try to upcast
+                val.AddMember(name, v, d.GetAllocator());
+                break;
+            }
+            case CONFIGURATION_STRING_TYPE: {
+                rapidjson::Value v(v_string.c_str(), d.GetAllocator());
+                val.AddMember(name, v, d.GetAllocator());
+                break;
+            }
+            case CONFIGURATION_ENDOFLIST_TYPE:
+            case CONFIGURATION_NOT_DEFINED_TYPE:
+                throw ValueError();
+        }
+    }
+    void set_from_json(rapidjson::Value& val) {
+        switch (type) {
+            case CONFIGURATION_BOOL_TYPE:
+                if (!val.IsBool()) {
+                    throw ValueError(format("Input is not boolean"));
+                };
+                v_bool = val.GetBool();
+                break;
+            case CONFIGURATION_INTEGER_TYPE:
+                if (!val.IsInt()) {
+                    throw ValueError(format("Input is not integer"));
+                };
+                v_integer = val.GetInt();
+                break;
+            case CONFIGURATION_DOUBLE_TYPE: {
+                if (!val.IsDouble() && !val.IsInt()) {
+                    throw ValueError(format("Input [%s] is not double (or something that can be cast to double)", cpjson::to_string(val).c_str()));
+                };
+                if (val.IsDouble()) {
+                    v_double = val.GetDouble();
+                } else {
+                    v_double = static_cast<double>(val.GetInt());
+                }
+                break;
+            }
+            case CONFIGURATION_STRING_TYPE:
+                if (!val.IsString()) {
+                    throw ValueError(format("Input is not string"));
+                };
+                v_string = val.GetString();
+                break;
+            case CONFIGURATION_ENDOFLIST_TYPE:
+            case CONFIGURATION_NOT_DEFINED_TYPE:
+                throw ValueError();
+        }
+    }
+#endif  // !defined(SWIG)
+
+   private:
+    void check_data_type(ConfigurationDataTypes type) const {
+        if (type != this->type) {
+            throw ValueError(format("type does not match"));
+        }
+    };
+    ConfigurationDataTypes type;
+    union
+    {
+        double v_double;
+        bool v_bool;
+        int v_integer;
+    };
+    std::string v_string;
+    configuration_keys key;
+};
+
+class Configuration
+{
+   protected:
+    std::map<configuration_keys, ConfigurationItem> items;
+
+   public:
+    Configuration() {
+        set_defaults();
+    };
+    ~Configuration(){};
+
+    /// Get an item from the configuration
+    ConfigurationItem& get_item(configuration_keys key) {
+        // Try to find it
+        std::map<configuration_keys, ConfigurationItem>::iterator it = items.find(key);
+        // If equal to end, not found
+        if (it != items.end()) {
+            // Found, return it
+            return it->second;
+        } else {
+            throw ValueError(format("invalid item"));
+        }
+    }
+    /// Add an item to the configuration
+    void add_item(ConfigurationItem item) {
+        std::pair<configuration_keys, ConfigurationItem> pair(item.get_key(), item);
+        items.insert(pair);
+    };
+
+    /// Return a reference to all of the items
+    std::map<configuration_keys, ConfigurationItem>& get_items(void) {
+        return items;
+    };
+
+    /// Set the default values in the configuration
+    void set_defaults(void) {
+/* ***MAGIC WARNING**!!
+             * See http://stackoverflow.com/a/148610
+             * See http://stackoverflow.com/questions/147267/easy-way-to-use-variables-of-enum-types-as-string-in-c#202511
+             */
+#define X(Enum, String, Default, Desc) add_item(ConfigurationItem(Enum, Default));
+        CONFIGURATION_KEYS_ENUM
+#undef X
+    };
+};
+
+/// *********************************************************
+///                      GETTERS
+/// *********************************************************
+
+/// Return the value of a boolean key from the configuration
+bool get_config_bool(configuration_keys key);
+/// Return the value of an integer key from the configuration
+int get_config_int(configuration_keys key);
+/// Return the value of a double configuration key
+double get_config_double(configuration_keys key);
+/// Return the value of a string configuration key
+std::string get_config_string(configuration_keys key);
+#if !defined(SWIG)  // Hide this for swig - Swig gets confused
+void get_config_as_json(rapidjson::Document& doc);
+#endif
+/// Get all the values in the configuration as a json-formatted string
+std::string get_config_as_json_string();
+
+/// *********************************************************
+///                      SETTERS
+/// *********************************************************
+
+/// Set the value of a boolean configuration value
+void set_config_bool(configuration_keys key, bool val);
+/// Set the value of an integer configuration value
+void set_config_int(configuration_keys key, int val);
+/// Set the value of a double configuration value
+void set_config_double(configuration_keys key, double val);
+/// Set the value of a string configuration value
+void set_config_string(configuration_keys key, const std::string& val);
+/// Set values in the configuration based on a json file
+#if !defined(SWIG)  // Hide this for swig - Swig gets confused
+void set_config_json(rapidjson::Document& doc);
+#endif
+/// Set the entire configuration based on a json-formatted string
+void set_config_as_json_string(const std::string& s);
+}  // namespace CoolProp
+
+#endif  // COOLPROP_CONFIGURATION
```

## CoolProp/include/CoolProp.h

 * *Ordering differences only*

```diff
@@ -1,194 +1,194 @@
-/*
-This header file includes the high level API that is meant to be accessed via C++.  Functions may accept C++ types like std::vector
-
-For the C-style wrapper, refer to CoolPropLib.h
-
-\sa CoolPropLib.h
-*/
-
-/*! \mainpage CoolProp Core Code Documentation
-
-Welcome to the home page for the C++ sources of CoolProp.  This information may be useful for developers or just the plain inquisitive
-
-You might want to start by looking at CoolProp.h
-*/
-
-#ifndef CoolProp_H
-#define CoolProp_H
-
-#include <string>
-#include <vector>
-#include "DataStructures.h"
-
-namespace CoolProp {
-
-/// Return a value that does not depend on the thermodynamic state - this is a convenience function that does the call PropsSI(Output, "", 0, "", 0, FluidName)
-/// @param FluidName The fluid name
-/// @param Output The output parameter, one of "Tcrit","D","H",etc.
-double Props1SI(std::string FluidName, std::string Output);
-/**
-     * @brief  Get a matrix of outputs that do not depend on the thermodynamic state - this is a convenience function that does the call PropsSImulti(Outputs, "", {0}, "", {0}, backend, fluids, fractions)
-     * @param Outputs A vector of strings for the output parameters
-     * @param backend The string representation of the backend (HEOS, REFPROP, INCOMP, etc.)
-     * @param fluids The fluid name(s)
-     * @param fractions The fractions (molar, mass, volume, etc.) of the components
-     */     
-std::vector<std::vector<double>> Props1SImulti(const std::vector<std::string>& Outputs, const std::string& backend, const std::vector<std::string>& fluids, const std::vector<double>& fractions);
-/// Return a value that depends on the thermodynamic state
-/// @param Output The output parameter, one of "T","D","H",etc.
-/// @param Name1 The first state variable name, one of "T","D","H",etc.
-/// @param Prop1 The first state variable value
-/// @param Name2 The second state variable name, one of "T","D","H",etc.
-/// @param Prop2 The second state variable value
-/// @param FluidName The fluid name
-double PropsSI(const std::string& Output, const std::string& Name1, double Prop1, const std::string& Name2, double Prop2,
-               const std::string& FluidName);
-
-/**
-     * @brief Get a matrix of outputs for a given input.  Can handle both vector inputs as well as a vector of output strings
-     * @param Outputs A vector of strings for the output parameters
-     * @param Name1 The name of the first input variable
-     * @param Prop1 A vector of the first input values
-     * @param Name2 The name of the second input variable
-     * @param Prop2 A vector of the second input values
-     * @param backend The string representation of the backend (HEOS, REFPROP, INCOMP, etc.)
-     * @param fluids The fluid name(s)
-     * @param fractions The fractions (molar, mass, volume, etc.) of the components
-     */
-std::vector<std::vector<double>> PropsSImulti(const std::vector<std::string>& Outputs, const std::string& Name1, const std::vector<double>& Prop1,
-                                              const std::string& Name2, const std::vector<double>& Prop2, const std::string& backend,
-                                              const std::vector<std::string>& fluids, const std::vector<double>& fractions);
-
-/// Get the debug level
-/// @returns level The level of the verbosity for the debugging output (0-10) 0: no debgging output
-int get_debug_level();
-/// Set the debug level
-/// @param level The level of the verbosity for the debugging output (0-10) 0: no debgging output
-void set_debug_level(int level);
-
-/// Set the global error string
-/// @param error The error string to use
-void set_error_string(const std::string& error);
-/// An internal function to set the global warning string
-/// @param warning The string to set as the warning string
-void set_warning_string(const std::string& warning);
-
-/* \brief Extract a value from the saturation ancillary
-     *
-     * @param fluid_name The name of the fluid to be used - HelmholtzEOS backend only
-     * @param output The desired output variable ("P" for instance for pressure)
-     * @param Q The quality, 0 or 1
-     * @param input The input variable ("T")
-     * @param value The input value
-     */
-double saturation_ancillary(const std::string& fluid_name, const std::string& output, int Q, const std::string& input, double value);
-
-/// Get a globally-defined string
-/// @param ParamName A string, one of "version", "errstring", "warnstring", "gitrevision", "FluidsList", "fluids_list", "parameter_list","predefined_mixtures"
-/// @returns str The string, or an error message if not valid input
-std::string get_global_param_string(const std::string& ParamName);
-
-/*/// Get a long that represents the fluid type
-    /// @param FluidName The fluid name as a string
-    /// @returns long element from global type enumeration
-    long getFluidType(std::string FluidName);*/
-
-/**
-    \brief Get a string for a value from a fluid (numerical values for the fluid can be obtained from Props1SI function)
-
-    @param FluidName The name of the fluid that is part of CoolProp, for instance "n-Propane"
-    @param ParamName A string, can be in one of the terms described in the following table
-
-    ParamName                    | Description
-    --------------------------   | ----------------------------------------
-    "aliases"                    | A comma separated list of aliases for the fluid
-    "CAS", "CAS_number"          | The CAS number
-    "ASHRAE34"                   | The ASHRAE standard 34 safety rating
-    "REFPROPName","REFPROP_name" | The name of the fluid used in REFPROP
-    "Bibtex-XXX"                 | A BibTeX key, where XXX is one of the bibtex keys used in get_BibTeXKey
-    "pure"                       | "true" if the fluid is pure, "false" otherwise
-    "formula"                    | The chemical formula of the fluid in LaTeX form if available, "" otherwise
-
-    @returns The string, or an error message if not valid input
-    */
-std::string get_fluid_param_string(const std::string& FluidName, const std::string& ParamName);
-
-/** \brief Check if the fluid name is valid
-     *
-     * @returns output Returns true if the fluid string is valid
-     *
-     * \note "gfreilgregre" -> false; "HEOS::Water" -> true; "Water" -> true
-     *
-     */
-bool is_valid_fluid_string(const std::string& fluidstring);
-
-/** \brief Add fluids as a JSON-formatted string
-     *
-     * @param backend The backend to which these should be added; e.g. "HEOS", "SRK", "PR"
-     * @returns output Returns true if the fluids were able to be added
-     *
-     */
-bool add_fluids_as_JSON(const std::string& backend, const std::string& fluidstring);
-
-/**
-    \brief Set the reference state based on a string representation
-
-    @param FluidName The name of the fluid (Backend can be provided like "REFPROP::Water", or if no backend is provided, "HEOS" is the assumed backend)
-    @param reference_state The reference state to use, one of
-
-    Reference State | Description
-    -------------   | -------------------
-    "IIR"           | h = 200 kJ/kg, s=1 kJ/kg/K at 0C saturated liquid
-    "ASHRAE"        | h = 0, s = 0 @ -40C saturated liquid
-    "NBP"           | h = 0, s = 0 @ 1.0 bar saturated liquid
-    "DEF"           | Reset to the default reference state for the fluid
-    "RESET"         | Remove the offset
-
-    The offset in the ideal gas Helmholtz energy can be obtained from
-    \f[
-    \displaystyle\frac{\Delta s}{R_u/M}+\frac{\Delta h}{(R_u/M)T}\tau
-    \f]
-    where \f$ \Delta s = s-s_{spec} \f$ and \f$ \Delta h = h-h_{spec} \f$
-    */
-void set_reference_stateS(const std::string& FluidName, const std::string& reference_state);
-
-/// Set the reference state based on a thermodynamic state point specified by temperature and molar density
-/// @param FluidName The name of the fluid
-/// @param T Temperature at reference state [K]
-/// @param rhomolar Molar density at reference state [mol/m^3]
-/// @param hmolar0 Molar enthalpy at reference state [J/mol]
-/// @param smolar0 Molar entropy at reference state [J/mol/K]
-void set_reference_stateD(const std::string& FluidName, double T, double rhomolar, double hmolar0, double smolar0);
-
-/// Return a string representation of the phase
-/// @param Name1 The first state variable name, one of "T","D","H",etc.
-/// @param Prop1 The first state variable value
-/// @param Name2 The second state variable name, one of "T","D","H",etc.
-/// @param Prop2 The second state variable value
-/// @param FluidName The fluid name
-/// \note Returns empty string if there was an error; use get_global_param_string("errstring") to retrieve the error
-std::string PhaseSI(const std::string& Name1, double Prop1, const std::string& Name2, double Prop2, const std::string& FluidName);
-
-/**
-     * @brief Extract the backend from a string - something like "HEOS::Water" would split to "HEOS" and "Water".  If no backend is specified, the backend will be set to "?"
-     * @param fluid_string The input string
-     * @param backend The output backend, if none found, "?"
-     * @param fluid The output fluid string (minus the backend string)
-     */
-void extract_backend(std::string fluid_string, std::string& backend, std::string& fluid);
-
-/**
-     * @brief Extract fractions (molar, mass, etc.) encoded in the string if any
-     * @param fluid_string The input string
-     * @param fractions The fractions
-     * @return The fluids, as a '&' delimited string
-     */
-std::string extract_fractions(const std::string& fluid_string, std::vector<double>& fractions);
-
-/// An internal function to extract the phase string, given the phase index;
-/// Handy for printing the actual phase string in debug, warning, and error messages.
-/// @param Phase The enumerated phase index to be looked up
-std::string phase_lookup_string(phases Phase);
-
-} /* namespace CoolProp */
-#endif
+/*
+This header file includes the high level API that is meant to be accessed via C++.  Functions may accept C++ types like std::vector
+
+For the C-style wrapper, refer to CoolPropLib.h
+
+\sa CoolPropLib.h
+*/
+
+/*! \mainpage CoolProp Core Code Documentation
+
+Welcome to the home page for the C++ sources of CoolProp.  This information may be useful for developers or just the plain inquisitive
+
+You might want to start by looking at CoolProp.h
+*/
+
+#ifndef CoolProp_H
+#define CoolProp_H
+
+#include <string>
+#include <vector>
+#include "DataStructures.h"
+
+namespace CoolProp {
+
+/// Return a value that does not depend on the thermodynamic state - this is a convenience function that does the call PropsSI(Output, "", 0, "", 0, FluidName)
+/// @param FluidName The fluid name
+/// @param Output The output parameter, one of "Tcrit","D","H",etc.
+double Props1SI(std::string FluidName, std::string Output);
+/**
+     * @brief  Get a matrix of outputs that do not depend on the thermodynamic state - this is a convenience function that does the call PropsSImulti(Outputs, "", {0}, "", {0}, backend, fluids, fractions)
+     * @param Outputs A vector of strings for the output parameters
+     * @param backend The string representation of the backend (HEOS, REFPROP, INCOMP, etc.)
+     * @param fluids The fluid name(s)
+     * @param fractions The fractions (molar, mass, volume, etc.) of the components
+     */     
+std::vector<std::vector<double>> Props1SImulti(const std::vector<std::string>& Outputs, const std::string& backend, const std::vector<std::string>& fluids, const std::vector<double>& fractions);
+/// Return a value that depends on the thermodynamic state
+/// @param Output The output parameter, one of "T","D","H",etc.
+/// @param Name1 The first state variable name, one of "T","D","H",etc.
+/// @param Prop1 The first state variable value
+/// @param Name2 The second state variable name, one of "T","D","H",etc.
+/// @param Prop2 The second state variable value
+/// @param FluidName The fluid name
+double PropsSI(const std::string& Output, const std::string& Name1, double Prop1, const std::string& Name2, double Prop2,
+               const std::string& FluidName);
+
+/**
+     * @brief Get a matrix of outputs for a given input.  Can handle both vector inputs as well as a vector of output strings
+     * @param Outputs A vector of strings for the output parameters
+     * @param Name1 The name of the first input variable
+     * @param Prop1 A vector of the first input values
+     * @param Name2 The name of the second input variable
+     * @param Prop2 A vector of the second input values
+     * @param backend The string representation of the backend (HEOS, REFPROP, INCOMP, etc.)
+     * @param fluids The fluid name(s)
+     * @param fractions The fractions (molar, mass, volume, etc.) of the components
+     */
+std::vector<std::vector<double>> PropsSImulti(const std::vector<std::string>& Outputs, const std::string& Name1, const std::vector<double>& Prop1,
+                                              const std::string& Name2, const std::vector<double>& Prop2, const std::string& backend,
+                                              const std::vector<std::string>& fluids, const std::vector<double>& fractions);
+
+/// Get the debug level
+/// @returns level The level of the verbosity for the debugging output (0-10) 0: no debgging output
+int get_debug_level();
+/// Set the debug level
+/// @param level The level of the verbosity for the debugging output (0-10) 0: no debgging output
+void set_debug_level(int level);
+
+/// Set the global error string
+/// @param error The error string to use
+void set_error_string(const std::string& error);
+/// An internal function to set the global warning string
+/// @param warning The string to set as the warning string
+void set_warning_string(const std::string& warning);
+
+/* \brief Extract a value from the saturation ancillary
+     *
+     * @param fluid_name The name of the fluid to be used - HelmholtzEOS backend only
+     * @param output The desired output variable ("P" for instance for pressure)
+     * @param Q The quality, 0 or 1
+     * @param input The input variable ("T")
+     * @param value The input value
+     */
+double saturation_ancillary(const std::string& fluid_name, const std::string& output, int Q, const std::string& input, double value);
+
+/// Get a globally-defined string
+/// @param ParamName A string, one of "version", "errstring", "warnstring", "gitrevision", "FluidsList", "fluids_list", "parameter_list","predefined_mixtures"
+/// @returns str The string, or an error message if not valid input
+std::string get_global_param_string(const std::string& ParamName);
+
+/*/// Get a long that represents the fluid type
+    /// @param FluidName The fluid name as a string
+    /// @returns long element from global type enumeration
+    long getFluidType(std::string FluidName);*/
+
+/**
+    \brief Get a string for a value from a fluid (numerical values for the fluid can be obtained from Props1SI function)
+
+    @param FluidName The name of the fluid that is part of CoolProp, for instance "n-Propane"
+    @param ParamName A string, can be in one of the terms described in the following table
+
+    ParamName                    | Description
+    --------------------------   | ----------------------------------------
+    "aliases"                    | A comma separated list of aliases for the fluid
+    "CAS", "CAS_number"          | The CAS number
+    "ASHRAE34"                   | The ASHRAE standard 34 safety rating
+    "REFPROPName","REFPROP_name" | The name of the fluid used in REFPROP
+    "Bibtex-XXX"                 | A BibTeX key, where XXX is one of the bibtex keys used in get_BibTeXKey
+    "pure"                       | "true" if the fluid is pure, "false" otherwise
+    "formula"                    | The chemical formula of the fluid in LaTeX form if available, "" otherwise
+
+    @returns The string, or an error message if not valid input
+    */
+std::string get_fluid_param_string(const std::string& FluidName, const std::string& ParamName);
+
+/** \brief Check if the fluid name is valid
+     *
+     * @returns output Returns true if the fluid string is valid
+     *
+     * \note "gfreilgregre" -> false; "HEOS::Water" -> true; "Water" -> true
+     *
+     */
+bool is_valid_fluid_string(const std::string& fluidstring);
+
+/** \brief Add fluids as a JSON-formatted string
+     *
+     * @param backend The backend to which these should be added; e.g. "HEOS", "SRK", "PR"
+     * @returns output Returns true if the fluids were able to be added
+     *
+     */
+bool add_fluids_as_JSON(const std::string& backend, const std::string& fluidstring);
+
+/**
+    \brief Set the reference state based on a string representation
+
+    @param FluidName The name of the fluid (Backend can be provided like "REFPROP::Water", or if no backend is provided, "HEOS" is the assumed backend)
+    @param reference_state The reference state to use, one of
+
+    Reference State | Description
+    -------------   | -------------------
+    "IIR"           | h = 200 kJ/kg, s=1 kJ/kg/K at 0C saturated liquid
+    "ASHRAE"        | h = 0, s = 0 @ -40C saturated liquid
+    "NBP"           | h = 0, s = 0 @ 1.0 bar saturated liquid
+    "DEF"           | Reset to the default reference state for the fluid
+    "RESET"         | Remove the offset
+
+    The offset in the ideal gas Helmholtz energy can be obtained from
+    \f[
+    \displaystyle\frac{\Delta s}{R_u/M}+\frac{\Delta h}{(R_u/M)T}\tau
+    \f]
+    where \f$ \Delta s = s-s_{spec} \f$ and \f$ \Delta h = h-h_{spec} \f$
+    */
+void set_reference_stateS(const std::string& FluidName, const std::string& reference_state);
+
+/// Set the reference state based on a thermodynamic state point specified by temperature and molar density
+/// @param FluidName The name of the fluid
+/// @param T Temperature at reference state [K]
+/// @param rhomolar Molar density at reference state [mol/m^3]
+/// @param hmolar0 Molar enthalpy at reference state [J/mol]
+/// @param smolar0 Molar entropy at reference state [J/mol/K]
+void set_reference_stateD(const std::string& FluidName, double T, double rhomolar, double hmolar0, double smolar0);
+
+/// Return a string representation of the phase
+/// @param Name1 The first state variable name, one of "T","D","H",etc.
+/// @param Prop1 The first state variable value
+/// @param Name2 The second state variable name, one of "T","D","H",etc.
+/// @param Prop2 The second state variable value
+/// @param FluidName The fluid name
+/// \note Returns empty string if there was an error; use get_global_param_string("errstring") to retrieve the error
+std::string PhaseSI(const std::string& Name1, double Prop1, const std::string& Name2, double Prop2, const std::string& FluidName);
+
+/**
+     * @brief Extract the backend from a string - something like "HEOS::Water" would split to "HEOS" and "Water".  If no backend is specified, the backend will be set to "?"
+     * @param fluid_string The input string
+     * @param backend The output backend, if none found, "?"
+     * @param fluid The output fluid string (minus the backend string)
+     */
+void extract_backend(std::string fluid_string, std::string& backend, std::string& fluid);
+
+/**
+     * @brief Extract fractions (molar, mass, etc.) encoded in the string if any
+     * @param fluid_string The input string
+     * @param fractions The fractions
+     * @return The fluids, as a '&' delimited string
+     */
+std::string extract_fractions(const std::string& fluid_string, std::vector<double>& fractions);
+
+/// An internal function to extract the phase string, given the phase index;
+/// Handy for printing the actual phase string in debug, warning, and error messages.
+/// @param Phase The enumerated phase index to be looked up
+std::string phase_lookup_string(phases Phase);
+
+} /* namespace CoolProp */
+#endif
```

## CoolProp/include/CoolPropFluid.h

```diff
@@ -1,566 +1,583 @@
-/*
- * CoolPropFluid.h
- *
- *  Created on: 20 Dec 2013
- *      Author: jowr
- */
-
-#ifndef COOLPROPFLUID_H_
-#define COOLPROPFLUID_H_
-
-#include "DataStructures.h"
-#include "Helmholtz.h"
-#include "Solvers.h"
-
-#include <numeric>
-#include <string>
-#include <vector>
-#include <map>
-#include <cassert>
-#include <iterator>
-#include "Eigen/Core"
-#include "PolyMath.h"
-#include "Ancillaries.h"
-
-namespace CoolProp {
-
-struct BibTeXKeysStruct
-{
-    std::string EOS, CP0, VISCOSITY, CONDUCTIVITY, ECS_LENNARD_JONES, ECS_FITS, SURFACE_TENSION;
-};
-
-struct EnvironmentalFactorsStruct
-{
-    double GWP20, GWP100, GWP500, ODP, HH, PH, FH;
-    std::string ASHRAE34;
-};
-struct CriticalRegionSplines
-{
-    double T_min, T_max, rhomolar_min, rhomolar_max;
-    std::vector<double> cL, cV;
-    bool enabled;
-    CriticalRegionSplines() : T_min(_HUGE), T_max(_HUGE), rhomolar_min(_HUGE), rhomolar_max(_HUGE), enabled(false){};
-
-    const void get_densities(double T, double rho_min, double rho_crit, double rho_max, double& rhoL, double& rhoV) const {
-        int Nsoln = -1, Ngood = 0;
-        double rho1 = 0, rho2 = 0, rho3 = 0;
-
-        // -----------
-        // Liquid part
-        // -----------
-        Ngood = 0;
-        solve_cubic(cL[0], cL[1], cL[2], cL[3] - T, Nsoln, rho1, rho2, rho3);
-        if (Nsoln == 1 && rho1 < rho_max && rho1 > rho_crit) {
-            rhoL = rho1;
-        } else {
-            if (rho1 < rho_max && rho1 > rho_crit) {
-                Ngood++;
-                rhoL = rho1;
-            }
-            if (rho2 < rho_max && rho2 > rho_crit) {
-                Ngood++;
-                rhoL = rho2;
-            }
-            if (Nsoln > 2 && rho3 < rho_max && rho3 > rho_crit) {
-                Ngood++;
-                rhoL = rho3;
-            }
-            if (Ngood > 1) {
-                throw ValueError(format("More than one liquid solution found for critical spline for T=%0.12g", T));
-            };
-            if (Ngood < 1) {
-                throw ValueError(format("No liquid solution found for critical spline for T=%0.12g", T));
-            };
-        }
-
-        // ----------
-        // Vapor part
-        // ----------
-        Ngood = 0;
-        Nsoln = 0;
-        solve_cubic(cV[0], cV[1], cV[2], cV[3] - T, Nsoln, rho1, rho2, rho3);
-        if (Nsoln == 1 && rho1 > rho_min && rho1 < rho_crit) {
-            rhoV = rho1;
-        } else {
-            if (rho1 > rho_min && rho1 < rho_crit) {
-                Ngood++;
-                rhoV = rho1;
-            }
-            if (rho2 > rho_min && rho2 < rho_crit) {
-                Ngood++;
-                rhoV = rho2;
-            }
-            if (Nsoln > 2 && rho3 > rho_min && rho3 < rho_crit) {
-                Ngood++;
-                rhoV = rho3;
-            }
-            if (Ngood > 1) {
-                throw ValueError(format("More than one vapor solution found for critical spline for T=%0.12g", T));
-            };
-            if (Ngood < 1) {
-                throw ValueError(format("No vapor solution found for critical spline for T=%0.12g", T));
-            };
-        }
-    };
-};
-
-/// A set of limits for the eos parameters
-struct EOSLimits
-{
-    double Tmin, Tmax, rhomax, pmax;
-};
-
-struct ConductivityECSVariables
-{
-    std::string reference_fluid;
-    CoolPropDbl psi_rhomolar_reducing, f_int_T_reducing;
-    std::vector<CoolPropDbl> psi_a, psi_t, f_int_a, f_int_t;
-};
-
-struct ConductivityDiluteEta0AndPolyData
-{
-    std::vector<CoolPropDbl> A, t;
-};
-
-struct ConductivityDiluteRatioPolynomialsData
-{
-    CoolPropDbl T_reducing, p_reducing;
-    std::vector<CoolPropDbl> A, B, n, m;
-};
-struct ConductivityDiluteVariables
-{
-    enum ConductivityDiluteEnum
-    {
-        CONDUCTIVITY_DILUTE_RATIO_POLYNOMIALS,
-        CONDUCTIVITY_DILUTE_ETA0_AND_POLY,
-        CONDUCTIVITY_DILUTE_CO2,
-        CONDUCTIVITY_DILUTE_ETHANE,
-        CONDUCTIVITY_DILUTE_NONE,
-        CONDUCTIVITY_DILUTE_NOT_SET
-    };
-    int type;
-    ConductivityDiluteRatioPolynomialsData ratio_polynomials;
-    ConductivityDiluteEta0AndPolyData eta0_and_poly;
-
-    ConductivityDiluteVariables() {
-        type = CONDUCTIVITY_DILUTE_NOT_SET;
-    }
-};
-
-struct ConductivityResidualPolynomialAndExponentialData
-{
-    CoolPropDbl T_reducing, rhomass_reducing;
-    std::vector<CoolPropDbl> A, t, d, gamma, l;
-};
-
-struct ConductivityResidualPolynomialData
-{
-    CoolPropDbl T_reducing, rhomass_reducing;
-    std::vector<CoolPropDbl> B, t, d;
-};
-struct ConductivityResidualVariables
-{
-    enum ConductivityResidualEnum
-    {
-        CONDUCTIVITY_RESIDUAL_POLYNOMIAL,
-        CONDUCTIVITY_RESIDUAL_POLYNOMIAL_AND_EXPONENTIAL,
-        CONDUCTIVITY_RESIDUAL_R123,
-        CONDUCTIVITY_RESIDUAL_CO2,
-        CONDUCTIVITY_RESIDUAL_NOT_SET
-    };
-    int type;
-    ConductivityResidualPolynomialData polynomials;
-    ConductivityResidualPolynomialAndExponentialData polynomial_and_exponential;
-
-    ConductivityResidualVariables() {
-        type = CONDUCTIVITY_RESIDUAL_NOT_SET;
-    }
-};
-
-struct ConductivityCriticalSimplifiedOlchowySengersData
-{
-    CoolPropDbl k, R0, gamma, nu, GAMMA, zeta0, qD, T_reducing, p_reducing, T_ref;
-    ConductivityCriticalSimplifiedOlchowySengersData()
-      :                    // Universal constants - can still be adjusted if need be
-        k(1.3806488e-23),  //[J/K]
-        R0(1.03),          //[-]
-        gamma(1.239),      //[-]
-        nu(0.63),          //[-]
-        // Suggested default values - can be over-written
-        GAMMA(0.0496),    //[-]
-        zeta0(1.94e-10),  //[m]
-        qD(2e9),          //[m]
-        // Set to invalid number, can be provided in the JSON file
-        // T_ref default is 1.5*Tc
-        T_reducing(_HUGE),
-        p_reducing(_HUGE),
-        T_ref(_HUGE) {}
-};
-struct ConductivityCriticalVariables
-{
-    enum ConductivityResidualEnum
-    {
-        CONDUCTIVITY_CRITICAL_SIMPLIFIED_OLCHOWY_SENGERS,
-        CONDUCTIVITY_CRITICAL_R123,
-        CONDUCTIVITY_CRITICAL_AMMONIA,
-        CONDUCTIVITY_CRITICAL_NONE,
-        CONDUCTIVITY_CRITICAL_CARBONDIOXIDE_SCALABRIN_JPCRD_2006,
-        CONDUCTIVITY_CRITICAL_NOT_SET
-    };
-    int type;
-    ConductivityCriticalSimplifiedOlchowySengersData Olchowy_Sengers;
-
-    ConductivityCriticalVariables() {
-        type = CONDUCTIVITY_CRITICAL_NOT_SET;
-    }
-};
-
-/// Variables for the dilute gas part
-struct ViscosityDiluteGasCollisionIntegralData
-{
-    CoolPropDbl molar_mass, C;
-    std::vector<CoolPropDbl> a, t;
-};
-struct ViscosityDiluteCollisionIntegralPowersOfTstarData
-{
-    CoolPropDbl T_reducing,  ///< Reducing temperature [K[
-      C;                     ///< Leading constant
-    std::vector<CoolPropDbl> a, t;
-};
-struct ViscosityDiluteGasPowersOfT
-{
-    std::vector<CoolPropDbl> a, t;
-};
-struct ViscosityDiluteGasPowersOfTr
-{
-    std::vector<CoolPropDbl> a, t;
-    CoolPropDbl T_reducing;
-};
-struct ViscosityDiluteVariables
-{
-    enum ViscosityDiluteType
-    {
-        VISCOSITY_DILUTE_COLLISION_INTEGRAL,                  ///< Use \ref TransportRoutines::viscosity_dilute_collision_integral
-        VISCOSITY_DILUTE_COLLISION_INTEGRAL_POWERS_OF_TSTAR,  ///< Use \ref TransportRoutines::viscosity_dilute_collision_integral_powers_of_T
-        VISCOSITY_DILUTE_KINETIC_THEORY,                      ///< Use \ref TransportRoutines::viscosity_dilute_kinetic_theory
-        VISCOSITY_DILUTE_ETHANE,                              ///< Use \ref TransportRoutines::viscosity_dilute_ethane
-        VISCOSITY_DILUTE_CYCLOHEXANE,                         ///< Use \ref TransportRoutines::viscosity_dilute_cyclohexane
-        VISCOSITY_DILUTE_POWERS_OF_T,                         ///< Use \ref TransportRoutines::viscosity_dilute_powers_of_T
-        VISCOSITY_DILUTE_POWERS_OF_TR,                        ///< Use \ref TransportRoutines::viscosity_dilute_powers_of_Tr
-        VISCOSITY_DILUTE_NOT_SET
-    };
-    ViscosityDiluteType type;
-    ViscosityDiluteGasCollisionIntegralData collision_integral;  ///< Data for \ref TransportRoutines::viscosity_dilute_collision_integral
-    ViscosityDiluteCollisionIntegralPowersOfTstarData
-      collision_integral_powers_of_Tstar;       ///< Data for \ref TransportRoutines::viscosity_dilute_collision_integral_powers_of_T
-    ViscosityDiluteGasPowersOfT powers_of_T;    ///< Data for \ref TransportRoutines::viscosity_dilute_powers_of_T
-    ViscosityDiluteGasPowersOfTr powers_of_Tr;  ///< Data for \ref TransportRoutines::viscosity_dilute_powers_of_Tr
-    ViscosityDiluteVariables() {
-        type = VISCOSITY_DILUTE_NOT_SET;
-    }
-};
-
-struct ViscosityRainWaterFriendData
-{
-    std::vector<CoolPropDbl> b, t;
-};
-struct ViscosityInitialDensityEmpiricalData
-{
-    std::vector<CoolPropDbl> n, d, t;
-    CoolPropDbl T_reducing, rhomolar_reducing;
-};
-
-struct ViscosityInitialDensityVariables
-{
-    enum ViscosityInitialDensityEnum
-    {
-        VISCOSITY_INITIAL_DENSITY_RAINWATER_FRIEND,  ///< Use \ref TransportRoutines::viscosity_initial_density_dependence_Rainwater_Friend
-        VISCOSITY_INITIAL_DENSITY_EMPIRICAL,         ///< Use \ref TransportRoutines::viscosity_initial_density_dependence_empirical
-        VISCOSITY_INITIAL_DENSITY_NOT_SET
-    };
-    ViscosityInitialDensityEnum type;
-    ViscosityRainWaterFriendData rainwater_friend;   ///< Data for \ref TransportRoutines::viscosity_initial_density_dependence_Rainwater_Friend
-    ViscosityInitialDensityEmpiricalData empirical;  ///< Data for \ref TransportRoutines::viscosity_initial_density_dependence_empirical
-    ViscosityInitialDensityVariables() {
-        type = VISCOSITY_INITIAL_DENSITY_NOT_SET;
-    }
-};
-
-struct ViscosityModifiedBatschinskiHildebrandData
-{
-    std::vector<CoolPropDbl> a, d1, d2, t1, t2, f, g, h, p, q, gamma, l;
-    CoolPropDbl T_reduce, rhomolar_reduce;
-};
-struct ViscosityFrictionTheoryData
-{
-    std::vector<CoolPropDbl> Aa, Aaa, Aaaa, Ar, Arr, Adrdr, Arrr, Ai, Aii, AdrAdr;
-    int Na, Naa, Naaa, Nr, Nrr, Nrrr, Nii;
-    CoolPropDbl c1, c2, T_reduce, rhomolar_reduce;
-};
-struct ViscosityHigherOrderVariables
-{
-    enum ViscosityHigherOrderEnum
-    {
-        VISCOSITY_HIGHER_ORDER_BATSCHINKI_HILDEBRAND,  ///< Use \ref TransportRoutines::viscosity_higher_order_modified_Batschinski_Hildebrand
-        VISCOSITY_HIGHER_ORDER_HYDROGEN,               ///< Use \ref TransportRoutines::viscosity_hydrogen_higher_order_hardcoded
-        VISCOSITY_HIGHER_ORDER_HEXANE,                 ///< Use \ref TransportRoutines::viscosity_hexane_higher_order_hardcoded
-        VISCOSITY_HIGHER_ORDER_HEPTANE,                ///< Use \ref TransportRoutines::viscosity_heptane_higher_order_hardcoded
-        VISCOSITY_HIGHER_ORDER_ETHANE,                 ///< Use \ref TransportRoutines::viscosity_ethane_higher_order_hardcoded
-        VISCOSITY_HIGHER_ORDER_BENZENE,                ///< Use \ref TransportRoutines::viscosity_benzene_higher_order_hardcoded
-        VISCOSITY_HIGHER_ORDER_TOLUENE,                ///< Use \ref TransportRoutines::viscosity_toluene_higher_order_hardcoded
-        VISCOSITY_HIGHER_ORDER_FRICTION_THEORY,        ///< Use \ref TransportRoutines::viscosity_higher_order_friction_theory
-        VISCOSITY_HIGHER_ORDER_NOT_SET
-    };
-    ViscosityHigherOrderEnum type;
-    ViscosityModifiedBatschinskiHildebrandData
-      modified_Batschinski_Hildebrand;            ///< Data for \ref TransportRoutines::viscosity_higher_order_modified_Batschinski_Hildebrand
-    ViscosityFrictionTheoryData friction_theory;  ///< Data for \ref TransportRoutines::viscosity_higher_order_friction_theory
-    ViscosityHigherOrderVariables() {
-        type = VISCOSITY_HIGHER_ORDER_NOT_SET;
-    };
-};
-
-struct ViscosityRhoSrVariables
-{
-    std::vector<double> c_liq, c_vap;
-    double C, x_crossover, rhosr_critical;
-};
-struct ViscosityECSVariables
-{
-    std::string reference_fluid;
-    CoolPropDbl psi_rhomolar_reducing;
-    std::vector<CoolPropDbl> psi_a, psi_t;
-};
-struct ViscosityChungData
-{
-    CoolPropDbl rhomolar_critical, acentric, T_critical, molar_mass, dipole_moment_D;
-};
-
-class TransportPropertyData
-{
-   public:
-    enum ViscosityHardcodedEnum
-    {
-        VISCOSITY_HARDCODED_WATER,       ///< Use \ref TransportRoutines::viscosity_water_hardcoded
-        VISCOSITY_HARDCODED_HEAVYWATER,  ///< Use \ref TransportRoutines::viscosity_heavywater_hardcoded
-        VISCOSITY_HARDCODED_HELIUM,      ///< Use \ref TransportRoutines::viscosity_helium_hardcoded
-        VISCOSITY_HARDCODED_R23,         ///< Use \ref TransportRoutines::viscosity_R23_hardcoded
-        VISCOSITY_HARDCODED_METHANOL,    ///< Use \ref TransportRoutines::viscosity_methanol_hardcoded
-        VISCOSITY_HARDCODED_M_XYLENE,    ///< Use \ref TransportRoutines::viscosity_m_xylene_hardcoded
-        VISCOSITY_HARDCODED_O_XYLENE,    ///< Use \ref TransportRoutines::viscosity_o_xylene_hardcoded
-        VISCOSITY_HARDCODED_P_XYLENE,    ///< Use \ref TransportRoutines::viscosity_p_xylene_hardcoded
-        VISCOSITY_NOT_HARDCODED
-    };
-    enum ConductivityHardcodedEnum
-    {
-        CONDUCTIVITY_HARDCODED_WATER,       ///< Use \ref TransportRoutines::conductivity_hardcoded_water
-        CONDUCTIVITY_HARDCODED_HEAVYWATER,  ///< Use \ref TransportRoutines::conductivity_hardcoded_heavywater
-        CONDUCTIVITY_HARDCODED_R23,         ///< Use \ref TransportRoutines::conductivity_hardcoded_R23
-        CONDUCTIVITY_HARDCODED_HELIUM,      ///< Use \ref TransportRoutines::conductivity_hardcoded_helium
-        CONDUCTIVITY_HARDCODED_METHANE,     ///< Use \ref TransportRoutines::conductivity_hardcoded_methane
-        CONDUCTIVITY_NOT_HARDCODED
-    };
-    ViscosityDiluteVariables viscosity_dilute;
-    ViscosityInitialDensityVariables viscosity_initial;
-    ViscosityHigherOrderVariables viscosity_higher_order;
-    ViscosityECSVariables viscosity_ecs;
-    ViscosityRhoSrVariables viscosity_rhosr;
-    ViscosityChungData viscosity_Chung;
-
-    ConductivityDiluteVariables conductivity_dilute;
-    ConductivityResidualVariables conductivity_residual;
-    ConductivityCriticalVariables conductivity_critical;
-    ConductivityECSVariables conductivity_ecs;
-
-    std::string BibTeX_viscosity,                      ///< The BibTeX key for the viscosity model
-      BibTeX_conductivity;                             ///< The BibTeX key for the conductivity model
-    bool viscosity_using_ECS;                          ///< A flag for whether to use extended corresponding states for viscosity.  False for no
-    bool conductivity_using_ECS;                       ///< A flag for whether to use extended corresponding states for conductivity.  False for no
-    bool viscosity_using_Chung;                        ///< A flag for whether to use Chung model. False for no
-    bool viscosity_using_rhosr;                        ///< A flag for whether to use rho*sr CS model of Bell. False for no
-    bool viscosity_model_provided;                     ///< A flag for whether viscosity model is provided.  False for no
-    bool conductivity_model_provided;                  ///< A flag for whether thermal conductivity model is provided.  False for no
-    CoolPropDbl sigma_eta,                             ///< The Lennard-Jones 12-6 \f$ \sigma \f$ parameter
-      epsilon_over_k;                                  ///< The Lennard-Jones 12-6 \f$ \varepsilon/k \f$ parameter
-    ViscosityHardcodedEnum hardcoded_viscosity;        ///< Hardcoded flags for the viscosity
-    ConductivityHardcodedEnum hardcoded_conductivity;  ///< Hardcoded flags for the conductivity
-    TransportPropertyData()
-      : viscosity_using_ECS(false),
-        conductivity_using_ECS(false),
-        viscosity_using_Chung(false),
-        viscosity_using_rhosr(false),
-        viscosity_model_provided(false),
-        conductivity_model_provided(false),
-        sigma_eta(_HUGE),
-        epsilon_over_k(_HUGE),
-        hardcoded_viscosity(VISCOSITY_NOT_HARDCODED),
-        hardcoded_conductivity(CONDUCTIVITY_NOT_HARDCODED) {}
-};
-
-struct Ancillaries
-{
-    SaturationAncillaryFunction pL, pV, rhoL, rhoV, hL, hLV, sL, sLV;
-    MeltingLineVariables melting_line;
-    SurfaceTensionCorrelation surface_tension;
-};
-
-/// The core class for an equation of state
-/**
- This class holds the absolute minimum information to evaluate the equation
- of state.  This includes the reducing state, limits on the equation of state,
- the coefficients for the Helmholtz derivative terms.
-
- It does NOT include derived parameters like specific heat, enthalpy, etc.
-*/
-class EquationOfState
-{
-   public:
-    EquationOfState(){};
-    ~EquationOfState(){};
-    SimpleState reduce,  ///< Reducing state used for the EOS (usually, but not always, the critical point)
-      sat_min_liquid,    ///< The saturated liquid state at the minimum saturation temperature
-      sat_min_vapor,     ///< The saturated vapor state at the minimum saturation temperature
-      hs_anchor,         ///< A fixed anchor state at Tc*1.1 and rhoc*0.9 used as a reference state for enthalpy and entropy ancillary curves
-      max_sat_T,         ///< The state at the maximum saturation temperature for pseudo-pure
-      max_sat_p;         ///< The state at the maximum saturation pressure for pseudo-pure
-    EOSLimits limits;    ///< Limits on the EOS
-    double R_u,          ///< The universal gas constant used for this EOS (usually, but not always, 8.314472 J/mol/K)
-      molar_mass,        ///< The molar mass in kg/mol (note NOT kg/kmol)
-      acentric,          ///< The acentric factor \f$ \omega = -log_{10}\left(\frac{p_s(T/T_c=0.7)}{p_c}\right)-1\f$
-      Ttriple,           ///< Triple point temperature (K)
-      ptriple;           ///< Triple point pressure (Pa)
-    bool pseudo_pure;    ///< Is a pseudo-pure fluid (true) or pure fluid (false)
-    ResidualHelmholtzContainer alphar;  ///< The residual Helmholtz energy
-    IdealHelmholtzContainer alpha0;     ///< The ideal Helmholtz energy
-    std::string BibTeX_EOS,             ///< The bibtex key for the equation of state
-      BibTeX_CP0;                       ///< The bibtex key for the ideal gas specific heat correlation
-    CriticalRegionSplines
-      critical_region_splines;  ///< A cubic spline in the form T = f(rho) for saturated liquid and saturated vapor curves in the near-critical region
-
-    /// Validate the EOS that was just constructed
-    void validate() {
-        assert(R_u < 9 && R_u > 8);
-        assert(molar_mass > 0.001 && molar_mass < 1);
-    };
-    CoolPropDbl baser(const CoolPropDbl& tau, const CoolPropDbl& delta) {
-        return alphar.base(tau, delta);
-    };
-    // First partials
-    CoolPropDbl dalphar_dDelta(const CoolPropDbl& tau, const CoolPropDbl& delta) {
-        return alphar.dDelta(tau, delta);
-    };
-    CoolPropDbl dalphar_dTau(const CoolPropDbl& tau, const CoolPropDbl& delta) {
-        return alphar.dTau(tau, delta);
-    };
-    // Second partials
-    CoolPropDbl d2alphar_dDelta2(const CoolPropDbl& tau, const CoolPropDbl& delta) {
-        return alphar.dDelta2(tau, delta);
-    };
-    CoolPropDbl d2alphar_dDelta_dTau(const CoolPropDbl& tau, const CoolPropDbl& delta) {
-        return alphar.dDelta_dTau(tau, delta);
-    };
-    CoolPropDbl d2alphar_dTau2(const CoolPropDbl& tau, const CoolPropDbl& delta) {
-        return alphar.dTau2(tau, delta);
-    };
-    // Third partials
-    CoolPropDbl d3alphar_dDelta3(const CoolPropDbl& tau, const CoolPropDbl& delta) {
-        return alphar.dDelta3(tau, delta);
-    };
-    CoolPropDbl d3alphar_dDelta2_dTau(const CoolPropDbl& tau, const CoolPropDbl& delta) {
-        return alphar.dDelta2_dTau(tau, delta);
-    };
-    CoolPropDbl d3alphar_dDelta_dTau2(const CoolPropDbl& tau, const CoolPropDbl& delta) {
-        return alphar.dDelta_dTau2(tau, delta);
-    };
-    CoolPropDbl d3alphar_dTau3(const CoolPropDbl& tau, const CoolPropDbl& delta) {
-        return alphar.dTau3(tau, delta);
-    };
-
-    CoolPropDbl base0(const CoolPropDbl& tau, const CoolPropDbl& delta) {
-        return alpha0.base(tau, delta);
-    };
-    // First partials
-    CoolPropDbl dalpha0_dDelta(const CoolPropDbl& tau, const CoolPropDbl& delta) {
-        return alpha0.dDelta(tau, delta);
-    };
-    CoolPropDbl dalpha0_dTau(const CoolPropDbl& tau, const CoolPropDbl& delta) {
-        return alpha0.dTau(tau, delta);
-    };
-    // Second partials
-    CoolPropDbl d2alpha0_dDelta2(const CoolPropDbl& tau, const CoolPropDbl& delta) {
-        return alpha0.dDelta2(tau, delta);
-    };
-    CoolPropDbl d2alpha0_dDelta_dTau(const CoolPropDbl& tau, const CoolPropDbl& delta) {
-        return alpha0.dDelta_dTau(tau, delta);
-    };
-    CoolPropDbl d2alpha0_dTau2(const CoolPropDbl& tau, const CoolPropDbl& delta) {
-        return alpha0.dTau2(tau, delta);
-    };
-    // Third partials
-    CoolPropDbl d3alpha0_dDelta3(const CoolPropDbl& tau, const CoolPropDbl& delta) {
-        return alpha0.dDelta3(tau, delta);
-    };
-    CoolPropDbl d3alpha0_dDelta2_dTau(const CoolPropDbl& tau, const CoolPropDbl& delta) {
-        return alpha0.dDelta2_dTau(tau, delta);
-    };
-    CoolPropDbl d3alpha0_dDelta_dTau2(const CoolPropDbl& tau, const CoolPropDbl& delta) {
-        return alpha0.dDelta_dTau2(tau, delta);
-    };
-    CoolPropDbl d3alpha0_dTau3(const CoolPropDbl& tau, const CoolPropDbl& delta) {
-        return alpha0.dTau3(tau, delta);
-    };
-};
-
-/// A thermophysical property provider for critical and reducing values as well as derivatives of Helmholtz energy
-/**
-This fluid instance is populated using an entry from a JSON file
-*/
-class CoolPropFluid
-{
-   protected:
-    // Transport property data
-    std::string ECSReferenceFluid;  ///< A string that gives the name of the fluids that should be used for the ECS method for transport properties
-    double ECS_qd;                  ///< The critical qd parameter for the Olchowy-Sengers cross-over term
-   public:
-    CoolPropFluid() : ECS_qd(-_HUGE) {
-        this->ChemSpider_id = -1;
-    };
-    ~CoolPropFluid(){};
-    const EquationOfState& EOS() const {
-        return EOSVector[0];
-    }  ///< Get a reference to the equation of state
-    EquationOfState& EOS() {
-        return EOSVector[0];
-    }                                        ///< Get a reference to the equation of state
-    std::vector<EquationOfState> EOSVector;  ///< The equations of state that could be used for this fluid
-
-    std::string name;  ///< The name of the fluid
-    std::string
-      REFPROPname;  ///< The REFPROP-compliant name if REFPROP-"name" is not a compatible fluid name.  If not included, "name" is assumed to be a valid name for REFPROP
-    std::string CAS;                   ///< The CAS number of the fluid
-    std::string formula;               ///< The chemical formula, in LaTeX form
-    std::vector<std::string> aliases;  ///< A vector of aliases of names for the fluid
-    std::string InChI;                 ///< The InChI string for the fluid
-    std::string InChIKey;              ///< The InChI key for the fluid
-    std::string smiles;                ///< The SMILES identifier for the fluid
-    int ChemSpider_id;                 ///< The ChemSpider identifier for the fluid
-    std::string TwoDPNG_URL;           ///< The URL to a 2D representation of the molecule (from ChemSpider)
-
-    BibTeXKeysStruct BibTeXKeys;             ///< The BibTeX keys associated
-    EnvironmentalFactorsStruct environment;  ///< The environmental variables for global warming potential, ODP, etc.
-    Ancillaries ancillaries;                 ///< The set of ancillary equations for dewpoint, bubblepoint, surface tension, etc.
-    TransportPropertyData transport;
-    SimpleState crit,  ///< The state at the critical point
-      triple_liquid,   ///< The saturated liquid state at the triple point temperature
-      triple_vapor;    ///< The saturated vapor state at the triple point temperature
-
-    double gas_constant() {
-        return EOS().R_u;
-    };
-    double molar_mass() {
-        return EOS().molar_mass;
-    };
-};
-
-} /* namespace CoolProp */
-#endif /* COOLPROPFLUID_H_ */
+/*
+ * CoolPropFluid.h
+ *
+ *  Created on: 20 Dec 2013
+ *      Author: jowr
+ */
+
+#ifndef COOLPROPFLUID_H_
+#define COOLPROPFLUID_H_
+
+#include "DataStructures.h"
+#include "Helmholtz.h"
+#include "Solvers.h"
+
+#include <numeric>
+#include <string>
+#include <vector>
+#include <map>
+#include <cassert>
+#include <iterator>
+#include "Eigen/Core"
+#include "PolyMath.h"
+#include "Ancillaries.h"
+
+namespace CoolProp {
+
+struct BibTeXKeysStruct
+{
+    std::string EOS, CP0, VISCOSITY, CONDUCTIVITY, ECS_LENNARD_JONES, ECS_FITS, SURFACE_TENSION;
+};
+
+struct EnvironmentalFactorsStruct
+{
+    double GWP20, GWP100, GWP500, ODP, HH, PH, FH;
+    std::string ASHRAE34;
+};
+struct CriticalRegionSplines
+{
+    double T_min, T_max, rhomolar_min, rhomolar_max;
+    std::vector<double> cL, cV;
+    bool enabled;
+    CriticalRegionSplines() : T_min(_HUGE), T_max(_HUGE), rhomolar_min(_HUGE), rhomolar_max(_HUGE), enabled(false){};
+
+    const void get_densities(double T, double rho_min, double rho_crit, double rho_max, double& rhoL, double& rhoV) const {
+        int Nsoln = -1, Ngood = 0;
+        double rho1 = 0, rho2 = 0, rho3 = 0;
+
+        // -----------
+        // Liquid part
+        // -----------
+        Ngood = 0;
+        solve_cubic(cL[0], cL[1], cL[2], cL[3] - T, Nsoln, rho1, rho2, rho3);
+        if (Nsoln == 1 && rho1 < rho_max && rho1 > rho_crit) {
+            rhoL = rho1;
+        } else {
+            if (rho1 < rho_max && rho1 > rho_crit) {
+                Ngood++;
+                rhoL = rho1;
+            }
+            if (rho2 < rho_max && rho2 > rho_crit) {
+                Ngood++;
+                rhoL = rho2;
+            }
+            if (Nsoln > 2 && rho3 < rho_max && rho3 > rho_crit) {
+                Ngood++;
+                rhoL = rho3;
+            }
+            if (Ngood > 1) {
+                throw ValueError(format("More than one liquid solution found for critical spline for T=%0.12g", T));
+            };
+            if (Ngood < 1) {
+                throw ValueError(format("No liquid solution found for critical spline for T=%0.12g", T));
+            };
+        }
+
+        // ----------
+        // Vapor part
+        // ----------
+        Ngood = 0;
+        Nsoln = 0;
+        solve_cubic(cV[0], cV[1], cV[2], cV[3] - T, Nsoln, rho1, rho2, rho3);
+        if (Nsoln == 1 && rho1 > rho_min && rho1 < rho_crit) {
+            rhoV = rho1;
+        } else {
+            if (rho1 > rho_min && rho1 < rho_crit) {
+                Ngood++;
+                rhoV = rho1;
+            }
+            if (rho2 > rho_min && rho2 < rho_crit) {
+                Ngood++;
+                rhoV = rho2;
+            }
+            if (Nsoln > 2 && rho3 > rho_min && rho3 < rho_crit) {
+                Ngood++;
+                rhoV = rho3;
+            }
+            if (Ngood > 1) {
+                throw ValueError(format("More than one vapor solution found for critical spline for T=%0.12g", T));
+            };
+            if (Ngood < 1) {
+                throw ValueError(format("No vapor solution found for critical spline for T=%0.12g", T));
+            };
+        }
+    };
+};
+
+/// A set of limits for the eos parameters
+struct EOSLimits
+{
+    double Tmin, Tmax, rhomax, pmax;
+};
+
+struct ConductivityECSVariables
+{
+    std::string reference_fluid;
+    CoolPropDbl psi_rhomolar_reducing, f_int_T_reducing;
+    std::vector<CoolPropDbl> psi_a, psi_t, f_int_a, f_int_t;
+};
+
+struct ConductivityDiluteEta0AndPolyData
+{
+    std::vector<CoolPropDbl> A, t;
+};
+
+struct ConductivityDiluteRatioPolynomialsData
+{
+    CoolPropDbl T_reducing, p_reducing;
+    std::vector<CoolPropDbl> A, B, n, m;
+};
+struct ConductivityDiluteVariables
+{
+    enum ConductivityDiluteEnum
+    {
+        CONDUCTIVITY_DILUTE_RATIO_POLYNOMIALS,
+        CONDUCTIVITY_DILUTE_ETA0_AND_POLY,
+        CONDUCTIVITY_DILUTE_CO2,
+        CONDUCTIVITY_DILUTE_CO2_HUBER_JPCRD_2016,
+        CONDUCTIVITY_DILUTE_ETHANE,
+        CONDUCTIVITY_DILUTE_NONE,
+        CONDUCTIVITY_DILUTE_NOT_SET
+    };
+    int type;
+    ConductivityDiluteRatioPolynomialsData ratio_polynomials;
+    ConductivityDiluteEta0AndPolyData eta0_and_poly;
+
+    ConductivityDiluteVariables() {
+        type = CONDUCTIVITY_DILUTE_NOT_SET;
+    }
+};
+
+struct ConductivityResidualPolynomialAndExponentialData
+{
+    CoolPropDbl T_reducing, rhomass_reducing;
+    std::vector<CoolPropDbl> A, t, d, gamma, l;
+};
+
+struct ConductivityResidualPolynomialData
+{
+    CoolPropDbl T_reducing, rhomass_reducing;
+    std::vector<CoolPropDbl> B, t, d;
+};
+struct ConductivityResidualVariables
+{
+    enum ConductivityResidualEnum
+    {
+        CONDUCTIVITY_RESIDUAL_POLYNOMIAL,
+        CONDUCTIVITY_RESIDUAL_POLYNOMIAL_AND_EXPONENTIAL,
+        CONDUCTIVITY_RESIDUAL_R123,
+        CONDUCTIVITY_RESIDUAL_CO2,
+        CONDUCTIVITY_RESIDUAL_NOT_SET
+    };
+    int type;
+    ConductivityResidualPolynomialData polynomials;
+    ConductivityResidualPolynomialAndExponentialData polynomial_and_exponential;
+
+    ConductivityResidualVariables() {
+        type = CONDUCTIVITY_RESIDUAL_NOT_SET;
+    }
+};
+
+struct ConductivityCriticalSimplifiedOlchowySengersData
+{
+    CoolPropDbl k, R0, gamma, nu, GAMMA, zeta0, qD, T_reducing, p_reducing, T_ref;
+    ConductivityCriticalSimplifiedOlchowySengersData()
+      :                    // Universal constants - can still be adjusted if need be
+        k(1.3806488e-23),  //[J/K]
+        R0(1.03),          //[-]
+        gamma(1.239),      //[-]
+        nu(0.63),          //[-]
+        // Suggested default values - can be over-written
+        GAMMA(0.0496),    //[-]
+        zeta0(1.94e-10),  //[m]
+        qD(2e9),          //[m]
+        // Set to invalid number, can be provided in the JSON file
+        // T_ref default is 1.5*Tc
+        T_reducing(_HUGE),
+        p_reducing(_HUGE),
+        T_ref(_HUGE) {}
+};
+struct ConductivityCriticalVariables
+{
+    enum ConductivityResidualEnum
+    {
+        CONDUCTIVITY_CRITICAL_SIMPLIFIED_OLCHOWY_SENGERS,
+        CONDUCTIVITY_CRITICAL_R123,
+        CONDUCTIVITY_CRITICAL_AMMONIA,
+        CONDUCTIVITY_CRITICAL_NONE,
+        CONDUCTIVITY_CRITICAL_CARBONDIOXIDE_SCALABRIN_JPCRD_2006,
+        CONDUCTIVITY_CRITICAL_NOT_SET
+    };
+    int type;
+    ConductivityCriticalSimplifiedOlchowySengersData Olchowy_Sengers;
+
+    ConductivityCriticalVariables() {
+        type = CONDUCTIVITY_CRITICAL_NOT_SET;
+    }
+};
+
+/// Variables for the dilute gas part
+struct ViscosityDiluteGasCollisionIntegralData
+{
+    CoolPropDbl molar_mass, C;
+    std::vector<CoolPropDbl> a, t;
+};
+struct ViscosityDiluteCollisionIntegralPowersOfTstarData
+{
+    CoolPropDbl T_reducing,  ///< Reducing temperature [K[
+      C;                     ///< Leading constant
+    std::vector<CoolPropDbl> a, t;
+};
+struct ViscosityDiluteGasPowersOfT
+{
+    std::vector<CoolPropDbl> a, t;
+};
+struct ViscosityDiluteGasPowersOfTr
+{
+    std::vector<CoolPropDbl> a, t;
+    CoolPropDbl T_reducing;
+};
+struct ViscosityDiluteVariables
+{
+    enum ViscosityDiluteType
+    {
+        VISCOSITY_DILUTE_COLLISION_INTEGRAL,                  ///< Use \ref TransportRoutines::viscosity_dilute_collision_integral
+        VISCOSITY_DILUTE_COLLISION_INTEGRAL_POWERS_OF_TSTAR,  ///< Use \ref TransportRoutines::viscosity_dilute_collision_integral_powers_of_T
+        VISCOSITY_DILUTE_KINETIC_THEORY,                      ///< Use \ref TransportRoutines::viscosity_dilute_kinetic_theory
+        VISCOSITY_DILUTE_ETHANE,                              ///< Use \ref TransportRoutines::viscosity_dilute_ethane
+        VISCOSITY_DILUTE_CYCLOHEXANE,                         ///< Use \ref TransportRoutines::viscosity_dilute_cyclohexane
+        VISCOSITY_DILUTE_CO2_LAESECKE_JPCRD_2017,             ///< Use \ref TransportRoutines::viscosity_dilute_CO2_LaeseckeJPCRD2017
+        VISCOSITY_DILUTE_POWERS_OF_T,                         ///< Use \ref TransportRoutines::viscosity_dilute_powers_of_T
+        VISCOSITY_DILUTE_POWERS_OF_TR,                        ///< Use \ref TransportRoutines::viscosity_dilute_powers_of_Tr
+        VISCOSITY_DILUTE_NOT_SET
+    };
+    ViscosityDiluteType type;
+    ViscosityDiluteGasCollisionIntegralData collision_integral;  ///< Data for \ref TransportRoutines::viscosity_dilute_collision_integral
+    ViscosityDiluteCollisionIntegralPowersOfTstarData
+      collision_integral_powers_of_Tstar;       ///< Data for \ref TransportRoutines::viscosity_dilute_collision_integral_powers_of_T
+    ViscosityDiluteGasPowersOfT powers_of_T;    ///< Data for \ref TransportRoutines::viscosity_dilute_powers_of_T
+    ViscosityDiluteGasPowersOfTr powers_of_Tr;  ///< Data for \ref TransportRoutines::viscosity_dilute_powers_of_Tr
+    ViscosityDiluteVariables() {
+        type = VISCOSITY_DILUTE_NOT_SET;
+    }
+};
+
+struct ViscosityRainWaterFriendData
+{
+    std::vector<CoolPropDbl> b, t;
+};
+struct ViscosityInitialDensityEmpiricalData
+{
+    std::vector<CoolPropDbl> n, d, t;
+    CoolPropDbl T_reducing, rhomolar_reducing;
+};
+
+struct ViscosityInitialDensityVariables
+{
+    enum ViscosityInitialDensityEnum
+    {
+        VISCOSITY_INITIAL_DENSITY_RAINWATER_FRIEND,  ///< Use \ref TransportRoutines::viscosity_initial_density_dependence_Rainwater_Friend
+        VISCOSITY_INITIAL_DENSITY_EMPIRICAL,         ///< Use \ref TransportRoutines::viscosity_initial_density_dependence_empirical
+        VISCOSITY_INITIAL_DENSITY_NOT_SET
+    };
+    ViscosityInitialDensityEnum type;
+    ViscosityRainWaterFriendData rainwater_friend;   ///< Data for \ref TransportRoutines::viscosity_initial_density_dependence_Rainwater_Friend
+    ViscosityInitialDensityEmpiricalData empirical;  ///< Data for \ref TransportRoutines::viscosity_initial_density_dependence_empirical
+    ViscosityInitialDensityVariables() {
+        type = VISCOSITY_INITIAL_DENSITY_NOT_SET;
+    }
+};
+
+struct ViscosityModifiedBatschinskiHildebrandData
+{
+    std::vector<CoolPropDbl> a, d1, d2, t1, t2, f, g, h, p, q, gamma, l;
+    CoolPropDbl T_reduce, rhomolar_reduce;
+};
+struct ViscosityFrictionTheoryData
+{
+    std::vector<CoolPropDbl> Aa, Aaa, Aaaa, Ar, Arr, Adrdr, Arrr, Ai, Aii, AdrAdr;
+    int Na, Naa, Naaa, Nr, Nrr, Nrrr, Nii;
+    CoolPropDbl c1, c2, T_reduce, rhomolar_reduce;
+};
+struct ViscosityHigherOrderVariables
+{
+    enum ViscosityHigherOrderEnum
+    {
+        VISCOSITY_HIGHER_ORDER_BATSCHINKI_HILDEBRAND,  ///< Use \ref TransportRoutines::viscosity_higher_order_modified_Batschinski_Hildebrand
+        VISCOSITY_HIGHER_ORDER_HYDROGEN,               ///< Use \ref TransportRoutines::viscosity_hydrogen_higher_order_hardcoded
+        VISCOSITY_HIGHER_ORDER_HEXANE,                 ///< Use \ref TransportRoutines::viscosity_hexane_higher_order_hardcoded
+        VISCOSITY_HIGHER_ORDER_HEPTANE,                ///< Use \ref TransportRoutines::viscosity_heptane_higher_order_hardcoded
+        VISCOSITY_HIGHER_ORDER_ETHANE,                 ///< Use \ref TransportRoutines::viscosity_ethane_higher_order_hardcoded
+        VISCOSITY_HIGHER_ORDER_BENZENE,                ///< Use \ref TransportRoutines::viscosity_benzene_higher_order_hardcoded
+        VISCOSITY_HIGHER_ORDER_TOLUENE,                ///< Use \ref TransportRoutines::viscosity_toluene_higher_order_hardcoded
+        VISCOSITY_HIGHER_ORDER_CO2_LAESECKE_JPCRD_2017,///< Use \ref TransportRoutines::viscosity_CO2_higher_order_hardcoded_LaeseckeJPCRD2017
+        VISCOSITY_HIGHER_ORDER_FRICTION_THEORY,        ///< Use \ref TransportRoutines::viscosity_higher_order_friction_theory
+        VISCOSITY_HIGHER_ORDER_NOT_SET
+    };
+    ViscosityHigherOrderEnum type;
+    ViscosityModifiedBatschinskiHildebrandData
+      modified_Batschinski_Hildebrand;            ///< Data for \ref TransportRoutines::viscosity_higher_order_modified_Batschinski_Hildebrand
+    ViscosityFrictionTheoryData friction_theory;  ///< Data for \ref TransportRoutines::viscosity_higher_order_friction_theory
+    ViscosityHigherOrderVariables() {
+        type = VISCOSITY_HIGHER_ORDER_NOT_SET;
+    };
+};
+
+struct ViscosityRhoSrVariables
+{
+    std::vector<double> c_liq, c_vap;
+    double C, x_crossover, rhosr_critical;
+};
+struct ViscosityECSVariables
+{
+    std::string reference_fluid;
+    CoolPropDbl psi_rhomolar_reducing;
+    std::vector<CoolPropDbl> psi_a, psi_t;
+};
+struct ViscosityChungData
+{
+    CoolPropDbl rhomolar_critical, acentric, T_critical, molar_mass, dipole_moment_D;
+};
+
+class TransportPropertyData
+{
+   public:
+    enum ViscosityHardcodedEnum
+    {
+        VISCOSITY_HARDCODED_WATER,       ///< Use \ref TransportRoutines::viscosity_water_hardcoded
+        VISCOSITY_HARDCODED_HEAVYWATER,  ///< Use \ref TransportRoutines::viscosity_heavywater_hardcoded
+        VISCOSITY_HARDCODED_HELIUM,      ///< Use \ref TransportRoutines::viscosity_helium_hardcoded
+        VISCOSITY_HARDCODED_R23,         ///< Use \ref TransportRoutines::viscosity_R23_hardcoded
+        VISCOSITY_HARDCODED_METHANOL,    ///< Use \ref TransportRoutines::viscosity_methanol_hardcoded
+        VISCOSITY_HARDCODED_M_XYLENE,    ///< Use \ref TransportRoutines::viscosity_m_xylene_hardcoded
+        VISCOSITY_HARDCODED_O_XYLENE,    ///< Use \ref TransportRoutines::viscosity_o_xylene_hardcoded
+        VISCOSITY_HARDCODED_P_XYLENE,    ///< Use \ref TransportRoutines::viscosity_p_xylene_hardcoded
+        VISCOSITY_NOT_HARDCODED
+    };
+    enum ConductivityHardcodedEnum
+    {
+        CONDUCTIVITY_HARDCODED_WATER,       ///< Use \ref TransportRoutines::conductivity_hardcoded_water
+        CONDUCTIVITY_HARDCODED_HEAVYWATER,  ///< Use \ref TransportRoutines::conductivity_hardcoded_heavywater
+        CONDUCTIVITY_HARDCODED_R23,         ///< Use \ref TransportRoutines::conductivity_hardcoded_R23
+        CONDUCTIVITY_HARDCODED_HELIUM,      ///< Use \ref TransportRoutines::conductivity_hardcoded_helium
+        CONDUCTIVITY_HARDCODED_METHANE,     ///< Use \ref TransportRoutines::conductivity_hardcoded_methane
+        CONDUCTIVITY_NOT_HARDCODED
+    };
+    ViscosityDiluteVariables viscosity_dilute;
+    ViscosityInitialDensityVariables viscosity_initial;
+    ViscosityHigherOrderVariables viscosity_higher_order;
+    ViscosityECSVariables viscosity_ecs;
+    ViscosityRhoSrVariables viscosity_rhosr;
+    ViscosityChungData viscosity_Chung;
+
+    ConductivityDiluteVariables conductivity_dilute;
+    ConductivityResidualVariables conductivity_residual;
+    ConductivityCriticalVariables conductivity_critical;
+    ConductivityECSVariables conductivity_ecs;
+
+    std::string BibTeX_viscosity,                      ///< The BibTeX key for the viscosity model
+      BibTeX_conductivity;                             ///< The BibTeX key for the conductivity model
+    bool viscosity_using_ECS;                          ///< A flag for whether to use extended corresponding states for viscosity.  False for no
+    bool conductivity_using_ECS;                       ///< A flag for whether to use extended corresponding states for conductivity.  False for no
+    bool viscosity_using_Chung;                        ///< A flag for whether to use Chung model. False for no
+    bool viscosity_using_rhosr;                        ///< A flag for whether to use rho*sr CS model of Bell. False for no
+    bool viscosity_model_provided;                     ///< A flag for whether viscosity model is provided.  False for no
+    bool conductivity_model_provided;                  ///< A flag for whether thermal conductivity model is provided.  False for no
+    CoolPropDbl sigma_eta,                             ///< The Lennard-Jones 12-6 \f$ \sigma \f$ parameter
+      epsilon_over_k;                                  ///< The Lennard-Jones 12-6 \f$ \varepsilon/k \f$ parameter
+    ViscosityHardcodedEnum hardcoded_viscosity;        ///< Hardcoded flags for the viscosity
+    ConductivityHardcodedEnum hardcoded_conductivity;  ///< Hardcoded flags for the conductivity
+    TransportPropertyData()
+      : viscosity_using_ECS(false),
+        conductivity_using_ECS(false),
+        viscosity_using_Chung(false),
+        viscosity_using_rhosr(false),
+        viscosity_model_provided(false),
+        conductivity_model_provided(false),
+        sigma_eta(_HUGE),
+        epsilon_over_k(_HUGE),
+        hardcoded_viscosity(VISCOSITY_NOT_HARDCODED),
+        hardcoded_conductivity(CONDUCTIVITY_NOT_HARDCODED) {}
+};
+
+struct Ancillaries
+{
+    SaturationAncillaryFunction pL, pV, rhoL, rhoV, hL, hLV, sL, sLV;
+    MeltingLineVariables melting_line;
+    SurfaceTensionCorrelation surface_tension;
+};
+
+/// The core class for an equation of state
+/**
+ This class holds the absolute minimum information to evaluate the equation
+ of state.  This includes the reducing state, limits on the equation of state,
+ the coefficients for the Helmholtz derivative terms.
+
+ It does NOT include derived parameters like specific heat, enthalpy, etc.
+*/
+class EquationOfState
+{
+   public:
+    EquationOfState(){};
+    ~EquationOfState(){};
+    SimpleState reduce,  ///< Reducing state used for the EOS (usually, but not always, the critical point)
+      sat_min_liquid,    ///< The saturated liquid state at the minimum saturation temperature
+      sat_min_vapor,     ///< The saturated vapor state at the minimum saturation temperature
+      hs_anchor,         ///< A fixed anchor state at Tc*1.1 and rhoc*0.9 used as a reference state for enthalpy and entropy ancillary curves
+      max_sat_T,         ///< The state at the maximum saturation temperature for pseudo-pure
+      max_sat_p;         ///< The state at the maximum saturation pressure for pseudo-pure
+    EOSLimits limits;    ///< Limits on the EOS
+    double R_u,          ///< The universal gas constant used for this EOS (usually, but not always, 8.314472 J/mol/K)
+      molar_mass,        ///< The molar mass in kg/mol (note NOT kg/kmol)
+      acentric,          ///< The acentric factor \f$ \omega = -log_{10}\left(\frac{p_s(T/T_c=0.7)}{p_c}\right)-1\f$
+      Ttriple,           ///< Triple point temperature (K)
+      ptriple;           ///< Triple point pressure (Pa)
+    bool pseudo_pure;    ///< Is a pseudo-pure fluid (true) or pure fluid (false)
+    ResidualHelmholtzContainer alphar;  ///< The residual Helmholtz energy
+    IdealHelmholtzContainer alpha0;     ///< The ideal Helmholtz energy
+    std::string BibTeX_EOS,             ///< The bibtex key for the equation of state
+      BibTeX_CP0;                       ///< The bibtex key for the ideal gas specific heat correlation
+    CriticalRegionSplines
+      critical_region_splines;  ///< A cubic spline in the form T = f(rho) for saturated liquid and saturated vapor curves in the near-critical region
+
+    /// Validate the EOS that was just constructed
+    void validate() {
+        assert(R_u < 9 && R_u > 8);
+        assert(molar_mass > 0.001 && molar_mass < 1);
+    };
+    CoolPropDbl baser(const CoolPropDbl& tau, const CoolPropDbl& delta) {
+        return alphar.base(tau, delta);
+    };
+    // First partials
+    CoolPropDbl dalphar_dDelta(const CoolPropDbl& tau, const CoolPropDbl& delta) {
+        return alphar.dDelta(tau, delta);
+    };
+    CoolPropDbl dalphar_dTau(const CoolPropDbl& tau, const CoolPropDbl& delta) {
+        return alphar.dTau(tau, delta);
+    };
+    // Second partials
+    CoolPropDbl d2alphar_dDelta2(const CoolPropDbl& tau, const CoolPropDbl& delta) {
+        return alphar.dDelta2(tau, delta);
+    };
+    CoolPropDbl d2alphar_dDelta_dTau(const CoolPropDbl& tau, const CoolPropDbl& delta) {
+        return alphar.dDelta_dTau(tau, delta);
+    };
+    CoolPropDbl d2alphar_dTau2(const CoolPropDbl& tau, const CoolPropDbl& delta) {
+        return alphar.dTau2(tau, delta);
+    };
+    // Third partials
+    CoolPropDbl d3alphar_dDelta3(const CoolPropDbl& tau, const CoolPropDbl& delta) {
+        return alphar.dDelta3(tau, delta);
+    };
+    CoolPropDbl d3alphar_dDelta2_dTau(const CoolPropDbl& tau, const CoolPropDbl& delta) {
+        return alphar.dDelta2_dTau(tau, delta);
+    };
+    CoolPropDbl d3alphar_dDelta_dTau2(const CoolPropDbl& tau, const CoolPropDbl& delta) {
+        return alphar.dDelta_dTau2(tau, delta);
+    };
+    CoolPropDbl d3alphar_dTau3(const CoolPropDbl& tau, const CoolPropDbl& delta) {
+        return alphar.dTau3(tau, delta);
+    };
+
+    CoolPropDbl base0(const CoolPropDbl& tau, const CoolPropDbl& delta) {
+        return alpha0.base(tau, delta);
+    };
+    // First partials
+    CoolPropDbl dalpha0_dDelta(const CoolPropDbl& tau, const CoolPropDbl& delta) {
+        return alpha0.dDelta(tau, delta);
+    };
+    CoolPropDbl dalpha0_dTau(const CoolPropDbl& tau, const CoolPropDbl& delta) {
+        return alpha0.dTau(tau, delta);
+    };
+    // Second partials
+    CoolPropDbl d2alpha0_dDelta2(const CoolPropDbl& tau, const CoolPropDbl& delta) {
+        return alpha0.dDelta2(tau, delta);
+    };
+    CoolPropDbl d2alpha0_dDelta_dTau(const CoolPropDbl& tau, const CoolPropDbl& delta) {
+        return alpha0.dDelta_dTau(tau, delta);
+    };
+    CoolPropDbl d2alpha0_dTau2(const CoolPropDbl& tau, const CoolPropDbl& delta) {
+        return alpha0.dTau2(tau, delta);
+    };
+    // Third partials
+    CoolPropDbl d3alpha0_dDelta3(const CoolPropDbl& tau, const CoolPropDbl& delta) {
+        return alpha0.dDelta3(tau, delta);
+    };
+    CoolPropDbl d3alpha0_dDelta2_dTau(const CoolPropDbl& tau, const CoolPropDbl& delta) {
+        return alpha0.dDelta2_dTau(tau, delta);
+    };
+    CoolPropDbl d3alpha0_dDelta_dTau2(const CoolPropDbl& tau, const CoolPropDbl& delta) {
+        return alpha0.dDelta_dTau2(tau, delta);
+    };
+    CoolPropDbl d3alpha0_dTau3(const CoolPropDbl& tau, const CoolPropDbl& delta) {
+        return alpha0.dTau3(tau, delta);
+    };
+};
+
+/// A thermophysical property provider for critical and reducing values as well as derivatives of Helmholtz energy
+/**
+This fluid instance is populated using an entry from a JSON file
+*/
+class CoolPropFluid
+{
+   protected:
+    // Transport property data
+    std::string ECSReferenceFluid;  ///< A string that gives the name of the fluids that should be used for the ECS method for transport properties
+    double ECS_qd;                  ///< The critical qd parameter for the Olchowy-Sengers cross-over term
+   public:
+    CoolPropFluid() : ECS_qd(-_HUGE) {
+        this->ChemSpider_id = -1;
+    };
+    ~CoolPropFluid(){};
+    const EquationOfState& EOS() const {
+        return EOSVector[0];
+    }  ///< Get a reference to the equation of state
+    EquationOfState& EOS() {
+        return EOSVector[0];
+    }                                        ///< Get a reference to the equation of state
+    std::vector<EquationOfState> EOSVector;  ///< The equations of state that could be used for this fluid
+
+    std::string name;  ///< The name of the fluid
+    std::string
+      REFPROPname;  ///< The REFPROP-compliant name if REFPROP-"name" is not a compatible fluid name.  If not included, "name" is assumed to be a valid name for REFPROP
+    std::string CAS;                   ///< The CAS number of the fluid
+    std::string formula;               ///< The chemical formula, in LaTeX form
+    std::vector<std::string> aliases;  ///< A vector of aliases of names for the fluid
+    std::string InChI;                 ///< The InChI string for the fluid
+    std::string InChIKey;              ///< The InChI key for the fluid
+    std::string smiles;                ///< The SMILES identifier for the fluid
+    int ChemSpider_id;                 ///< The ChemSpider identifier for the fluid
+    std::string TwoDPNG_URL;           ///< The URL to a 2D representation of the molecule (from ChemSpider)
+
+    BibTeXKeysStruct BibTeXKeys;             ///< The BibTeX keys associated
+    EnvironmentalFactorsStruct environment;  ///< The environmental variables for global warming potential, ODP, etc.
+    Ancillaries ancillaries;                 ///< The set of ancillary equations for dewpoint, bubblepoint, surface tension, etc.
+    TransportPropertyData transport;
+    SimpleState crit,  ///< The state at the critical point
+      triple_liquid,   ///< The saturated liquid state at the triple point temperature
+      triple_vapor;    ///< The saturated vapor state at the triple point temperature
+
+    double gas_constant() {
+        return EOS().R_u;
+    };
+    double molar_mass() {
+        return EOS().molar_mass;
+    };
+};
+
+#if !defined(NO_FMTLIB) && FMT_VERSION >= 90000
+static int format_as(ViscosityDiluteVariables::ViscosityDiluteType type) {
+    return fmt::underlying(type);
+}
+
+static int format_as(TransportPropertyData::ViscosityHardcodedEnum viscosity) {
+    return fmt::underlying(viscosity);
+}
+
+static int format_as(TransportPropertyData::ConductivityHardcodedEnum conductivity) {
+    return fmt::underlying(conductivity);
+}
+#endif
+
+} /* namespace CoolProp */
+#endif /* COOLPROPFLUID_H_ */
```

## CoolProp/include/CoolPropLib.h

 * *Ordering differences only*

```diff
@@ -1,716 +1,716 @@
-/** \brief This file defines an interface for shared library (DLL) wrapping
- *
- * In general the functions defined here take strings which are 0-terminated (C-style),
- * vectors of doubles are passed as double* and length
- * These functions pass directly to equivalently named functions in CoolProp.h in the CoolProp namespace
- * that take std::string, vector<double> etc.
- *
- * Functions with the call type like
- * EXPORT_CODE void CONVENTION AFunction(double, double);
- * will be exported to the DLL
- *
- * The exact symbol that will be exported depends on the values of the preprocessor macros COOLPROP_LIB, EXPORT_CODE, CONVENTION, etc.
- *
- * In order to have 100% control over the export macros, you can specify EXPORT_CODE and CONVENTION directly. Check out
- * CMakeLists.txt in the repo root to see some examples.
- *
- */
-
-#ifndef COOLPROPDLL_H
-#define COOLPROPDLL_H
-
-// See also http://stackoverflow.com/questions/5919996/how-to-detect-reliably-mac-os-x-ios-linux-windows-in-c-preprocessor
-// Copied verbatim from PlatformDetermination.h in order to have a single-include header
-#if _WIN64
-#    define __ISWINDOWS__
-#elif _WIN32
-#    define __ISWINDOWS__
-#elif __APPLE__
-#    define __ISAPPLE__
-#elif __linux || __unix || __posix
-#    define __ISLINUX__
-#elif __powerpc__
-#    define __ISPOWERPC__
-#else
-#    pragma error
-#endif
-
-#if defined(COOLPROP_LIB)
-#    ifndef EXPORT_CODE
-#        if defined(__ISWINDOWS__)
-#            define EXPORT_CODE extern "C" __declspec(dllexport)
-#        else
-#            define EXPORT_CODE extern "C"
-#        endif
-#    endif
-#    ifndef CONVENTION
-#        if defined(__ISWINDOWS__)
-#            define CONVENTION __stdcall
-#        else
-#            define CONVENTION
-#        endif
-#    endif
-#else
-#    ifndef EXPORT_CODE
-#        define EXPORT_CODE
-#    endif
-#    ifndef CONVENTION
-#        define CONVENTION
-#    endif
-#endif
-
-// Hack for PowerPC compilation to only use extern "C"
-#if defined(__powerpc__) || defined(EXTERNC)
-#    undef EXPORT_CODE
-#    define EXPORT_CODE extern "C"
-#endif
-
-#if defined(__powerpc__)
-// From https://rowley.zendesk.com/entries/46176--Undefined-reference-to-assert-error-message
-// The __assert function is an error handler function that is invoked when an assertion fails.
-// If you are writing a program that uses the assert macro then you must supply you own __assert error handler function. For example
-inline void __assert(const char* error) {
-    while (1)
-        ;
-}
-#endif
-
-/**
-     * \overload
-     * \sa \ref CoolProp::Props1SI(std::string, std::string)
-     *
-     * \note If there is an error, a huge value will be returned, you can get the error message by doing something like get_global_param_string("errstring",output)
-     */
-EXPORT_CODE double CONVENTION Props1SI(const char* FluidName, const char* Output);
-
-/**
-     *\overload
-     *\sa \ref CoolProp::Props1SImulti(const std::vector<std::string>& Outputs, const std::string& backend, const std::vector<std::string>& fluids, const std::vector<double>& fractions)
-     *
-     * \note If there is an error, a huge value will be returned, you can get the error message by doing something like get_global_param_string("errstring",output)
-     */
-EXPORT_CODE void CONVENTION Props1SImulti(const char* Outputs, char* backend, const char* FluidNames, const double* fractions,
-                                          const long length_fractions, double* result, long* resdim1);
-/**
-     *\overload
-     *\sa \ref CoolProp::PropsSI(const std::string &, const std::string &, double, const std::string &, double, const std::string&)
-     *
-     * \note If there is an error, a huge value will be returned, you can get the error message by doing something like get_global_param_string("errstring",output)
-     */
-EXPORT_CODE double CONVENTION PropsSI(const char* Output, const char* Name1, double Prop1, const char* Name2, double Prop2, const char* Ref);
-/**
-     *\overload
-     *\sa \ref CoolProp::PropsSImulti(const std::vector<std::string>& Outputs, const std::string& Name1, const std::vector<double>& Prop1,
-                                              const std::string& Name2, const std::vector<double>& Prop2, const std::string& backend,
-                                              const std::vector<std::string>& fluids, const std::vector<double>& fractions)
-     *
-     * @param Outputs Delimited string separated by LIST_STRING_DELIMITER for the output parameters
-     * @param Name1 The name of the first input variable
-     * @param Prop1 A vector of the first input values 
-     * @param size_Prop1 Size of Prop1 double*
-     * @param Name2 The name of the second input variable
-     * @param Prop2 A vector of the second input values 
-     * @param size_Prop2 Size of Prop2 double*
-     * @param backend 	The string representation of the backend (HEOS, REFPROP, INCOMP, etc.) 
-     * @param FluidNames  Delimited string separated by LIST_STRING_DELIMITER for the fluid name(s)
-     * @param fractions The fractions (molar, mass, volume, etc.) of the components
-     * @param length_fractions Size of fractions double*
-     * @param result Allocated memory for result vector
-     * @param resdim1 result vector dimension 1 pointer, to check allocated space and return actual result size
-     * @param resdim2 result vector dimension 2 pointer, to check allocated space and return actual result size
-     * \note If there is an error, an empty vector will be returned, you can get the error message by doing something like get_global_param_string("errstring",output)
-     */
-EXPORT_CODE void CONVENTION PropsSImulti(const char* Outputs, const char* Name1, double* Prop1, const long size_Prop1, const char* Name2,
-                                         double* Prop2, const long size_Prop2, char* backend, const char* FluidNames, const double* fractions,
-                                         const long length_fractions, double* result, long* resdim1, long* resdim2);
-/**
-     *\overload
-     *\sa \ref CoolProp::PhaseSI(const std::string &, double, const std::string &, double, const std::string&)
-     *
-     * \note This function returns the phase string in pre-allocated phase variable.  If buffer is not large enough, no copy is made
-     */
-EXPORT_CODE long CONVENTION PhaseSI(const char* Name1, double Prop1, const char* Name2, double Prop2, const char* Ref, char* phase, int n);
-
-/**
-     *\overload
-     *\sa \ref CoolProp::get_global_param_string
-     *
-     * @returns error_code 1 = Ok 0 = error
-     *
-     * \note This function returns the output string in pre-allocated char buffer.  If buffer is not large enough, no copy is made
-     */
-EXPORT_CODE long CONVENTION get_global_param_string(const char* param, char* Output, int n);
-/**
-     * \overload
-     * \sa \ref CoolProp::get_parameter_information_string
-     * \note This function returns the output string in pre-allocated char buffer.  If buffer is not large enough, no copy is made
-     *
-     * @returns error_code 1 = Ok 0 = error
-     */
-EXPORT_CODE long CONVENTION get_parameter_information_string(const char* key, char* Output, int n);
-/**
-     * \overload
-     * \sa \ref CoolProp::get_fluid_param_string
-     *
-     * @returns error_code 1 = Ok 0 = error
-     */
-EXPORT_CODE long CONVENTION get_fluid_param_string(const char* fluid, const char* param, char* Output, int n);
-/** \brief Set configuration string
-    * @param key The key to configure
-    * @param val The value to set to the key
-    * \note you can get the error message by doing something like get_global_param_string("errstring",output)
-    */
-EXPORT_CODE void CONVENTION set_config_string(const char* key, const char* val);
-/** \brief Set configuration numerical value as double
-    * @param key The key to configure
-    * @param val The value to set to the key
-    * \note you can get the error message by doing something like get_global_param_string("errstring",output)
-    */
-EXPORT_CODE void CONVENTION set_config_double(const char* key, const double val);
-/** \brief Set configuration value as a boolean
-     * @param key The key to configure
-     * @param val The value to set to the key
-     * \note you can get the error message by doing something like get_global_param_string("errstring",output)
-     */
-EXPORT_CODE void CONVENTION set_config_bool(const char* key, const bool val);
-/**
-     * @brief Set the departure functions in the departure function library from a string format
-     * @param string_data The departure functions to be set, either provided as a JSON-formatted string
-     *                    or as a string of the contents of a HMX.BNC file from REFPROP
-     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-     * @param message_buffer A buffer for the error code
-     * @param buffer_length The length of the buffer for the error code
-     *
-     * @note By default, if a departure function already exists in the library, this is an error,
-     *       unless the configuration variable OVERWRITE_DEPARTURE_FUNCTIONS is set to true
-     */
-EXPORT_CODE void CONVENTION set_departure_functions(const char* string_data, long* errcode, char* message_buffer, const long buffer_length);
-/**
-     * \overload
-     * \sa \ref CoolProp::set_reference_stateS
-     * @returns error_code 1 = Ok 0 = error
-     */
-EXPORT_CODE int CONVENTION set_reference_stateS(const char* Ref, const char* reference_state);
-/**
-     * \overload
-     * \sa \ref CoolProp::set_reference_stateD
-     * @returns error_code 1 = Ok 0 = error
-     */
-EXPORT_CODE int CONVENTION set_reference_stateD(const char* Ref, double T, double rhomolar, double hmolar0, double smolar0);
-/** \brief FORTRAN 77 style wrapper of the PropsSI function
-     * \overload
-     * \sa \ref CoolProp::PropsSI(const std::string &, const std::string &, double, const std::string &, double, const std::string&)
-     *
-     * \note If there is an error, a huge value will be returned, you can get the error message by doing something like get_global_param_string("errstring",output)
-     */
-EXPORT_CODE void CONVENTION propssi_(const char* Output, const char* Name1, const double* Prop1, const char* Name2, const double* Prop2,
-                                     const char* Ref, double* output);
-
-/// Convert from degrees Fahrenheit to Kelvin (useful primarily for testing)
-EXPORT_CODE double CONVENTION F2K(double T_F);
-/// Convert from Kelvin to degrees Fahrenheit (useful primarily for testing)
-EXPORT_CODE double CONVENTION K2F(double T_K);
-/** \brief Get the index for a parameter "T", "P", etc.
-     *
-     * @returns index The index as a long.  If input is invalid, returns -1
-     */
-EXPORT_CODE long CONVENTION get_param_index(const char* param);
-/** \brief Get the index for an input pair for AbstractState.update function
-     *
-     * @returns index The index as a long.  If input is invalid, returns -1
-     */
-EXPORT_CODE long CONVENTION get_input_pair_index(const char* param);
-/** \brief Redirect all output that would go to console (stdout) to a file
-     */
-EXPORT_CODE long CONVENTION redirect_stdout(const char* file);
-
-// ---------------------------------
-// Getter and setter for debug level
-// ---------------------------------
-
-/// Get the debug level
-/// @returns level The level of the verbosity for the debugging output (0-10) 0: no debgging output
-EXPORT_CODE int CONVENTION get_debug_level();
-/// Set the debug level
-/// @param level The level of the verbosity for the debugging output (0-10) 0: no debgging output
-EXPORT_CODE void CONVENTION set_debug_level(int level);
-
-/* \brief Extract a value from the saturation ancillary
-     *
-     * @param fluid_name The name of the fluid to be used - HelmholtzEOS backend only
-     * @param output The desired output variable ("P" for instance for pressure)
-     * @param Q The quality, 0 or 1
-     * @param input The input variable ("T")
-     * @param value The input value
-     */
-EXPORT_CODE double CONVENTION saturation_ancillary(const char* fluid_name, const char* output, int Q, const char* input, double value);
-
-// ---------------------------------
-//        Humid Air Properties
-// ---------------------------------
-
-/** \brief DLL wrapper of the HAPropsSI function
-     * \sa \ref HumidAir::HAPropsSI(const char *OutputName, const char *Input1Name, double Input1, const char *Input2Name, double Input2, const char *Input3Name, double Input3);
-     *
-     * \note If there is an error, a huge value will be returned, you can get the error message by doing something like get_global_param_string("errstring",output)
-     */
-EXPORT_CODE double CONVENTION HAPropsSI(const char* Output, const char* Name1, double Prop1, const char* Name2, double Prop2, const char* Name3,
-                                        double Prop3);
-
-/** \brief Humid air saturation specific heat at 1 atmosphere, based on a correlation from EES.
-     * \sa \ref HumidAir::cair_sat(double);
-     *
-     * @param T [K] good from 250K to 300K, no error bound checking is carried out.
-     *
-     * \note Equals partial derivative of enthalpy with respect to temperature at constant relative humidity of 100 percent and pressure of 1 atmosphere.
-     */
-EXPORT_CODE double CONVENTION cair_sat(double T);
-
-/** \brief FORTRAN 77 style wrapper of the HAPropsSI function
-     * \sa \ref HumidAir::HAPropsSI(const char *OutputName, const char *Input1Name, double Input1, const char *Input2Name, double Input2, const char *Input3Name, double Input3);
-     *
-     * \note If there is an error, a huge value will be returned, you can get the error message by doing something like get_global_param_string("errstring",output)
-     */
-EXPORT_CODE void CONVENTION hapropssi_(const char* Output, const char* Name1, const double* Prop1, const char* Name2, const double* Prop2,
-                                       const char* Name3, const double* Prop3, double* output);
-
-/** \brief DLL wrapper of the HAProps function
-     *
-     * \warning DEPRECATED!!
-     * \sa \ref HumidAir::HAProps(const char *OutputName, const char *Input1Name, double Input1, const char *Input2Name, double Input2, const char *Input3Name, double Input3);
-     *
-     * \note If there is an error, a huge value will be returned, you can get the error message by doing something like get_global_param_string("errstring",output)
-     */
-EXPORT_CODE double CONVENTION HAProps(const char* Output, const char* Name1, double Prop1, const char* Name2, double Prop2, const char* Name3,
-                                      double Prop3);
-
-/** \brief FORTRAN 77 style wrapper of the HAProps function
-     *
-     * \warning DEPRECATED!!
-     * \sa \ref HumidAir::HAProps(const char *OutputName, const char *Input1Name, double Input1, const char *Input2Name, double Input2, const char *Input3Name, double Input3);
-     *
-     * \note If there is an error, a huge value will be returned, you can get the error message by doing something like get_global_param_string("errstring",output)
-     */
-EXPORT_CODE void CONVENTION haprops_(const char* Output, const char* Name1, const double* Prop1, const char* Name2, const double* Prop2,
-                                     const char* Name3, const double* Prop3, double* output);
-
-// ---------------------------------
-//        Low-level access
-// ---------------------------------
-
-/**
-     * @brief Generate an AbstractState instance, return an integer handle to the state class generated to be used in the other low-level accessor functions
-     * @param backend The backend you will use, "HEOS", "REFPROP", etc.
-     * @param fluids '&' delimited list of fluids
-     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-     * @param message_buffer A buffer for the error code
-     * @param buffer_length The length of the buffer for the error code
-     * @return A handle to the state class generated
-     */
-EXPORT_CODE long CONVENTION AbstractState_factory(const char* backend, const char* fluids, long* errcode, char* message_buffer,
-                                                  const long buffer_length);
-/**
-     * @brief Get the fluid names for the AbstractState
-     * @param handle The integer handle for the state class stored in memory
-     * @param fluids LIST_STRING_DELIMETER (',') delimited list of fluids
-     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-     * @param message_buffer A buffer for the error code
-     * @param buffer_length The length of the buffer for the error code
-     * @return
-     */
-EXPORT_CODE void CONVENTION AbstractState_fluid_names(const long handle, char* fluids, long* errcode, char* message_buffer, const long buffer_length);
-/**
-     * @brief Release a state class generated by the low-level interface wrapper
-     * @param handle The integer handle for the state class stored in memory
-     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-     * @param message_buffer A buffer for the error code
-     * @param buffer_length The length of the buffer for the error code
-     * @return
-     */
-EXPORT_CODE void CONVENTION AbstractState_free(const long handle, long* errcode, char* message_buffer, const long buffer_length);
-/**
-     * @brief Set the fractions (mole, mass, volume) for the AbstractState
-     * @param handle The integer handle for the state class stored in memory
-     * @param fractions The array of fractions
-     * @param N The length of the fractions array
-     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-     * @param message_buffer A buffer for the error code
-     * @param buffer_length The length of the buffer for the error code
-     * @return
-     */
-EXPORT_CODE void CONVENTION AbstractState_set_fractions(const long handle, const double* fractions, const long N, long* errcode, char* message_buffer,
-                                                        const long buffer_length);
-/**
-     * @brief Get the molar fractions for the AbstractState
-     * @param handle The integer handle for the state class stored in memory
-     * @param fractions The array of fractions
-     * @param maxN The length of the buffer for the fractions
-     * @param N number of fluids
-     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-     * @param message_buffer A buffer for the error code
-     * @param buffer_length The length of the buffer for the error code
-     * @return
-     */
-EXPORT_CODE void CONVENTION AbstractState_get_mole_fractions(const long handle, double* fractions, const long maxN, long* N, long* errcode,
-                                                             char* message_buffer, const long buffer_length);
-/**
-     * @brief Get the molar fractions for the AbstractState and the desired saturated State
-     * @param handle The integer handle for the state class stored in memory
-     * @param saturated_state The string specifying the state (liquid or gas)
-     * @param fractions The array of fractions
-     * @param maxN The length of the buffer for the fractions
-     * @param N number of fluids
-     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-     * @param message_buffer A buffer for the error code
-     * @param buffer_length The length of the buffer for the error code
-     * @return 
-     */
-EXPORT_CODE void CONVENTION AbstractState_get_mole_fractions_satState(const long handle, const char* saturated_state, double* fractions,
-                                                                      const long maxN, long* N, long* errcode, char* message_buffer,
-                                                                      const long buffer_length);
-/**
-     * @brief Update the state of the AbstractState
-     * @param handle The integer handle for the state class stored in memory
-     * @param input_pair The integer value for the input pair obtained from XXXXXXXXXXXXXXXX
-     * @param value1 The first input value
-     * @param value2 The second input value
-     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-     * @param message_buffer A buffer for the error code
-     * @param buffer_length The length of the buffer for the error code
-     * @return
-     */
-EXPORT_CODE void CONVENTION AbstractState_update(const long handle, const long input_pair, const double value1, const double value2, long* errcode,
-                                                 char* message_buffer, const long buffer_length);
-/**
-    * @brief Specify the phase to be used for all further calculations
-    * @param handle The integer handle for the state class stored in memory
-    * @param phase The string with the phase to use
-    * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-    * @param message_buffer A buffer for the error code
-    * @param buffer_length The length of the buffer for the error code
-    * @return
-    */
-EXPORT_CODE void CONVENTION AbstractState_specify_phase(const long handle, const char* phase, long* errcode, char* message_buffer,
-                                                        const long buffer_length);
-/**
-    * @brief Unspecify the phase to be used for all further calculations
-    * @param handle The integer handle for the state class stored in memory
-    * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-    * @param message_buffer A buffer for the error code
-    * @param buffer_length The length of the buffer for the error code
-    * @return
-    */
-EXPORT_CODE void CONVENTION AbstractState_unspecify_phase(const long handle, long* errcode, char* message_buffer, const long buffer_length);
-/**
-     * @brief Get an output value from the AbstractState using an integer value for the desired output value
-     * @param handle The integer handle for the state class stored in memory
-     * @param param The integer value for the parameter you want
-     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-     * @param message_buffer A buffer for the error code
-     * @param buffer_length The length of the buffer for the error code
-     * @return
-     */
-EXPORT_CODE double CONVENTION AbstractState_keyed_output(const long handle, const long param, long* errcode, char* message_buffer,
-                                                         const long buffer_length);
-
-/**
-    * @brief Calculate a saturation derivative from the AbstractState using integer values for the desired parameters
-    * @param handle The integer handle for the state class stored in memory
-    * @param Of The parameter of which the derivative is being taken
-    * @param Wrt The derivative with with respect to this parameter
-    * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-    * @param message_buffer A buffer for the error code
-    * @param buffer_length The length of the buffer for the error code
-    * @return
-    */
-EXPORT_CODE double CONVENTION AbstractState_first_saturation_deriv(const long handle, const long Of, const long Wrt, long* errcode,
-                                                                   char* message_buffer, const long buffer_length);
-
-/**
-    * @brief Calculate the first partial derivative in homogeneous phases from the AbstractState using integer values for the desired parameters
-    * @param handle The integer handle for the state class stored in memory
-    * @param Of The parameter of which the derivative is being taken
-    * @param Wrt The derivative with with respect to this parameter
-    * @param Constant The parameter that is not affected by the derivative
-    * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-    * @param message_buffer A buffer for the error code
-    * @param buffer_length The length of the buffer for the error code
-    * @return
-    */
-EXPORT_CODE double CONVENTION AbstractState_first_partial_deriv(const long handle, const long Of, const long Wrt, const long Constant, long* errcode,
-                                                                char* message_buffer, const long buffer_length);
-
-/**
-    * @brief Update the state of the AbstractState and get an output value five common outputs (temperature, pressure, molar density, molar enthalpy and molar entropy)
-    * @brief from the AbstractState using pointers as inputs and output to allow array computation.
-    * @param handle The integer handle for the state class stored in memory
-    * @param input_pair The integer value for the input pair obtained from get_input_pair_index
-    * @param value1 The pointer to the array of the first input parameters
-    * @param value2 The pointer to the array of the second input parameters
-    * @param length The number of elements stored in the arrays (both inputs and outputs MUST be the same length)
-    * @param T The pointer to the array of temperature
-    * @param p The pointer to the array of pressure
-    * @param rhomolar The pointer to the array of molar density
-    * @param hmolar The pointer to the array of molar enthalpy
-    * @param smolar The pointer to the array of molar entropy
-    * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-    * @param message_buffer A buffer for the error code
-    * @param buffer_length The length of the buffer for the error code
-    * @return
-    *
-    * @note If there is an error in an update call for one of the inputs, no change in the output array will be made
-    */
-EXPORT_CODE void CONVENTION AbstractState_update_and_common_out(const long handle, const long input_pair, const double* value1, const double* value2,
-                                                                const long length, double* T, double* p, double* rhomolar, double* hmolar,
-                                                                double* smolar, long* errcode, char* message_buffer, const long buffer_length);
-
-/**
-    * @brief Update the state of the AbstractState and get one output value (temperature, pressure, molar density, molar enthalpy and molar entropy)
-    * @brief from the AbstractState using pointers as inputs and output to allow array computation.
-    * @param handle The integer handle for the state class stored in memory
-    * @param input_pair The integer value for the input pair obtained from get_input_pair_index
-    * @param value1 The pointer to the array of the first input parameters
-    * @param value2 The pointer to the array of the second input parameters
-    * @param length The number of elements stored in the arrays (both inputs and outputs MUST be the same length)
-    * @param output The indice for the output desired
-    * @param out The pointer to the array for output
-    * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-    * @param message_buffer A buffer for the error code
-    * @param buffer_length The length of the buffer for the error code
-    * @return
-    *
-    * @note If there is an error in an update call for one of the inputs, no change in the output array will be made
-    */
-EXPORT_CODE void CONVENTION AbstractState_update_and_1_out(const long handle, const long input_pair, const double* value1, const double* value2,
-                                                           const long length, const long output, double* out, long* errcode, char* message_buffer,
-                                                           const long buffer_length);
-
-/**
-    * @brief Update the state of the AbstractState and get an output value five common outputs (temperature, pressure, molar density, molar enthalpy and molar entropy)
-    * @brief from the AbstractState using pointers as inputs and output to allow array computation.
-    * @param handle The integer handle for the state class stored in memory
-    * @param input_pair The integer value for the input pair obtained from get_input_pair_index
-    * @param value1 The pointer to the array of the first input parameters
-    * @param value2 The pointer to the array of the second input parameters
-    * @param length The number of elements stored in the arrays (both inputs and outputs MUST be the same length)
-    * @param outputs The 5-element vector of indices for the outputs desired
-    * @param out1 The pointer to the array for the first output
-    * @param out2 The pointer to the array for the second output
-    * @param out3 The pointer to the array for the third output
-    * @param out4 The pointer to the array for the fourth output
-    * @param out5 The pointer to the array for the fifth output
-    * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-    * @param message_buffer A buffer for the error code
-    * @param buffer_length The length of the buffer for the error code
-    * @return
-    *
-    * @note If there is an error in an update call for one of the inputs, no change in the output array will be made
-    */
-EXPORT_CODE void CONVENTION AbstractState_update_and_5_out(const long handle, const long input_pair, const double* value1, const double* value2,
-                                                           const long length, long* outputs, double* out1, double* out2, double* out3, double* out4,
-                                                           double* out5, long* errcode, char* message_buffer, const long buffer_length);
-
-/**
-    * @brief Set binary interraction parrameter for mixtures
-    * @param handle The integer handle for the state class stored in memory
-    * @param i indice of the first fluid of the binary pair
-    * @param j indice of the second fluid of the binary pair
-    * @param parameter string wit the name of the parameter
-    * @param value the value of the binary interaction parameter
-    * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-    * @param message_buffer A buffer for the error code
-    * @param buffer_length The length of the buffer for the error code
-    * @return
-    */
-EXPORT_CODE void CONVENTION AbstractState_set_binary_interaction_double(const long handle, const long i, const long j, const char* parameter,
-                                                                        const double value, long* errcode, char* message_buffer,
-                                                                        const long buffer_length);
-
-/**
-    * @brief Set cubic's alpha function parameters
-    * @param handle The integer handle for the state class stored in memory
-    * @param i indice of the fluid the parramter should be applied too (for mixtures)
-	* @param parameter the string specifying the alpha function to use, ex "TWU" for the TWU alpha function
-    * @param c1 the first parameter for the alpha function
-    * @param c2 the second parameter for the alpha function
-    * @param c3 the third parameter for the alpha function
-    * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-    * @param message_buffer A buffer for the error code
-    * @param buffer_length The length of the buffer for the error code
-    * @return
-    */
-EXPORT_CODE void CONVENTION AbstractState_set_cubic_alpha_C(const long handle, const long i, const char* parameter, const double c1, const double c2,
-                                                            const double c3, long* errcode, char* message_buffer, const long buffer_length);
-
-/**
-    * @brief Set some fluid parameter (ie volume translation for cubic)
-    * @param handle The integer handle for the state class stored in memory
-	* @param i indice of the fluid the parramter should be applied too (for mixtures)
-	* @param parameter the string specifying the parameter to use, ex "cm" for volume translation
-    * @param value the value of the parameter
-    * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-    * @param message_buffer A buffer for the error code
-    * @param buffer_length The length of the buffer for the error code
-    * @return
-    */
-EXPORT_CODE void CONVENTION AbstractState_set_fluid_parameter_double(const long handle, const long i, const char* parameter, const double value,
-                                                                     long* errcode, char* message_buffer, const long buffer_length);
-
-/**
-     * @brief Build the phase envelope
-     * @param handle The integer handle for the state class stored in memory
-     * @param level How much refining of the phase envelope ("none" to skip refining (recommended))
-     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-     * @param message_buffer A buffer for the error code
-     * @param buffer_length The length of the buffer for the error code
-     * @return
-     *
-     * @note If there is an error in an update call for one of the inputs, no change in the output array will be made
-     */
-EXPORT_CODE void CONVENTION AbstractState_build_phase_envelope(const long handle, const char* level, long* errcode, char* message_buffer,
-                                                               const long buffer_length);
-
-/**
-     * @brief Get data from the phase envelope for the given mixture composition
-     * @param handle The integer handle for the state class stored in memory
-     * @param length The number of elements stored in the arrays (both inputs and outputs MUST be the same length)
-     * @param T The pointer to the array of temperature (K)
-     * @param p The pointer to the array of pressure (Pa)
-     * @param rhomolar_vap The pointer to the array of molar density for vapor phase (m^3/mol)
-     * @param rhomolar_liq The pointer to the array of molar density for liquid phase (m^3/mol)
-     * @param x The compositions of the "liquid" phase (WARNING: buffer should be Ncomp*Npoints in length, at a minimum, but there is no way to check buffer length at runtime)
-     * @param y The compositions of the "vapor" phase (WARNING: buffer should be Ncomp*Npoints in length, at a minimum, but there is no way to check buffer length at runtime)
-     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-     * @param message_buffer A buffer for the error code
-     * @param buffer_length The length of the buffer for the error code
-     * @return
-     *
-     * @note If there is an error in an update call for one of the inputs, no change in the output array will be made
-     */
-EXPORT_CODE void CONVENTION AbstractState_get_phase_envelope_data(const long handle, const long length, double* T, double* p, double* rhomolar_vap,
-                                                                  double* rhomolar_liq, double* x, double* y, long* errcode, char* message_buffer,
-                                                                  const long buffer_length);
-
-/**
-     * @brief Get data from the phase envelope for the given mixture composition
-     * @param handle The integer handle for the state class stored in memory
-     * @param length The number of elements stored in the arrays (both inputs and outputs MUST be the same length)
-     * @param maxComponents The number of fluid components for which memory is allocated
-     * @param T The pointer to the array of temperature (K)
-     * @param p The pointer to the array of pressure (Pa)
-     * @param rhomolar_vap The pointer to the array of molar density for vapor phase (m^3/mol)
-     * @param rhomolar_liq The pointer to the array of molar density for liquid phase (m^3/mol)
-     * @param x The compositions of the "liquid" phase (WARNING: buffer should be Ncomp*Npoints in length, at a minimum, but there is no way to check buffer length at runtime)
-     * @param y The compositions of the "vapor" phase (WARNING: buffer should be Ncomp*Npoints in length, at a minimum, but there is no way to check buffer length at runtime)
-     * @param actual_length The number of elements actually stored in the arrays
-     * @param actual_components The number of fluid components actually stored in the arrays
-     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-     * @param message_buffer A buffer for the error code
-     * @param buffer_length The length of the buffer for the error code
-     * @return
-     *
-     * @note If there is an error in an update call for one of the inputs, no change in the output array will be made
-     */
-EXPORT_CODE void CONVENTION AbstractState_get_phase_envelope_data_checkedMemory(const long handle, const long length, const long maxComponents, double* T,
-                                                                  double* p, double* rhomolar_vap, double* rhomolar_liq, double* x, double* y,
-                                                                  long* actual_length, long* actual_components, long* errcode, char* message_buffer,
-                                                                  const long buffer_length);
-
-/**
-     * @brief Build the spinodal
-     * @param handle The integer handle for the state class stored in memory
-     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-     * @param message_buffer A buffer for the error code
-     * @param buffer_length The length of the buffer for the error code
-     * @return
-     */
-EXPORT_CODE void CONVENTION AbstractState_build_spinodal(const long handle, long* errcode, char* message_buffer, const long buffer_length);
-
-/**
-     * @brief Get data for the spinodal curve
-     * @param handle The integer handle for the state class stored in memory
-     * @param length The number of elements stored in the arrays (all outputs MUST be the same length)
-     * @param tau The pointer to the array of reciprocal reduced temperature
-     * @param delta The pointer to the array of reduced density
-     * @param M1 The pointer to the array of M1 values (when L1=M1=0, critical point)
-     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-     * @param message_buffer A buffer for the error code
-     * @param buffer_length The length of the buffer for the error code
-     * @return
-     *
-     * @note If there is an error, no change in the output arrays will be made
-     */
-EXPORT_CODE void CONVENTION AbstractState_get_spinodal_data(const long handle, const long length, double* tau, double* delta, double* M1,
-                                                            long* errcode, char* message_buffer, const long buffer_length);
-
-/**
-     * @brief Calculate all the critical points for a given composition
-     * @param handle The integer handle for the state class stored in memory
-     * @param length The length of the buffers passed to this function
-     * @param T The pointer to the array of temperature (K)
-     * @param p The pointer to the array of pressure (Pa)
-     * @param rhomolar The pointer to the array of molar density (m^3/mol)
-     * @param stable The pointer to the array of boolean flags for whether the critical point is stable (1) or unstable (0)
-     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-     * @param message_buffer A buffer for the error code
-     * @param buffer_length The length of the buffer for the error code
-     * @return
-     *
-     * @note If there is an error in an update call for one of the inputs, no change in the output array will be made
-     */
-EXPORT_CODE void CONVENTION AbstractState_all_critical_points(const long handle, const long length, double* T, double* p, double* rhomolar,
-                                                              long* stable, long* errcode, char* message_buffer, const long buffer_length);
-/**
-     * @brief Get an output value from the AbstractState using an integer value for the desired output value and desired saturated State
-     * @param handle The integer handle for the state class stored in memory
-     * @param saturated_state The string specifying the state (liquid or gas)
-     * @param param The integer value for the parameter you want
-     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-     * @param message_buffer A buffer for the error code
-     * @param buffer_length The length of the buffer for the error code
-     * @return
-     */
-EXPORT_CODE double CONVENTION AbstractState_keyed_output_satState(const long handle, const char* saturated_state, const long param, long* errcode,
-                                                                  char* message_buffer, const long buffer_length);
-/**
-     * @brief Return the name of the backend used in the AbstractState
-     * @param handle The integer handle for the state class stored in memory
-     * @param backend The char pointer the name is written to
-     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
-     * @param message_buffer A buffer for the error code
-     * @param buffer_length The length of the buffer for the error code
-     * @return
-     */
-EXPORT_CODE void CONVENTION AbstractState_backend_name(const long handle, char* backend, long* errcode, char* message_buffer,
-                                                       const long buffer_length);
-/** 
-     * \brief Add fluids as a JSON-formatted string
-     * @param backend The backend to which these should be added; e.g. "HEOS", "SRK", "PR"
-     * @param fluidstring The JSON-formatted string
-     * @return
-     *
-     */
-EXPORT_CODE void CONVENTION add_fluids_as_JSON(const char* backend, const char* fluidstring, long* errcode, char* message_buffer,
-                                               const long buffer_length);
-
-// *************************************************************************************
-// *************************************************************************************
-// *****************************  DEPRECATED *******************************************
-// *************************************************************************************
-// *************************************************************************************
-
-/**
-    \overload
-    \sa \ref Props(const char *Output, const char Name1, double Prop1, const char Name2, double Prop2, const char *Ref)
-    */
-EXPORT_CODE double CONVENTION PropsS(const char* Output, const char* Name1, double Prop1, const char* Name2, double Prop2, const char* Ref);
-/**
-    Works just like \ref CoolProp::PropsSI, but units are in KSI system.  This function is deprecated, no longer supported, and users should transition to using the PropsSI function
-    */
-EXPORT_CODE double CONVENTION Props(const char* Output, const char Name1, double Prop1, const char Name2, double Prop2, const char* Ref);
-/**
-    Works just like \ref CoolProp::Props1SI, but units are in KSI system.  This function is deprecated, no longer supported, and users should transition to using the Props1SI function
-    */
-EXPORT_CODE double CONVENTION Props1(const char* FluidName, const char* Output);
-
-#endif
+/** \brief This file defines an interface for shared library (DLL) wrapping
+ *
+ * In general the functions defined here take strings which are 0-terminated (C-style),
+ * vectors of doubles are passed as double* and length
+ * These functions pass directly to equivalently named functions in CoolProp.h in the CoolProp namespace
+ * that take std::string, vector<double> etc.
+ *
+ * Functions with the call type like
+ * EXPORT_CODE void CONVENTION AFunction(double, double);
+ * will be exported to the DLL
+ *
+ * The exact symbol that will be exported depends on the values of the preprocessor macros COOLPROP_LIB, EXPORT_CODE, CONVENTION, etc.
+ *
+ * In order to have 100% control over the export macros, you can specify EXPORT_CODE and CONVENTION directly. Check out
+ * CMakeLists.txt in the repo root to see some examples.
+ *
+ */
+
+#ifndef COOLPROPDLL_H
+#define COOLPROPDLL_H
+
+// See also http://stackoverflow.com/questions/5919996/how-to-detect-reliably-mac-os-x-ios-linux-windows-in-c-preprocessor
+// Copied verbatim from PlatformDetermination.h in order to have a single-include header
+#if _WIN64
+#    define __ISWINDOWS__
+#elif _WIN32
+#    define __ISWINDOWS__
+#elif __APPLE__
+#    define __ISAPPLE__
+#elif __linux || __unix || __posix
+#    define __ISLINUX__
+#elif __powerpc__
+#    define __ISPOWERPC__
+#else
+#    pragma error
+#endif
+
+#if defined(COOLPROP_LIB)
+#    ifndef EXPORT_CODE
+#        if defined(__ISWINDOWS__)
+#            define EXPORT_CODE extern "C" __declspec(dllexport)
+#        else
+#            define EXPORT_CODE extern "C"
+#        endif
+#    endif
+#    ifndef CONVENTION
+#        if defined(__ISWINDOWS__)
+#            define CONVENTION __stdcall
+#        else
+#            define CONVENTION
+#        endif
+#    endif
+#else
+#    ifndef EXPORT_CODE
+#        define EXPORT_CODE
+#    endif
+#    ifndef CONVENTION
+#        define CONVENTION
+#    endif
+#endif
+
+// Hack for PowerPC compilation to only use extern "C"
+#if defined(__powerpc__) || defined(EXTERNC)
+#    undef EXPORT_CODE
+#    define EXPORT_CODE extern "C"
+#endif
+
+#if defined(__powerpc__)
+// From https://rowley.zendesk.com/entries/46176--Undefined-reference-to-assert-error-message
+// The __assert function is an error handler function that is invoked when an assertion fails.
+// If you are writing a program that uses the assert macro then you must supply you own __assert error handler function. For example
+inline void __assert(const char* error) {
+    while (1)
+        ;
+}
+#endif
+
+/**
+     * \overload
+     * \sa \ref CoolProp::Props1SI(std::string, std::string)
+     *
+     * \note If there is an error, a huge value will be returned, you can get the error message by doing something like get_global_param_string("errstring",output)
+     */
+EXPORT_CODE double CONVENTION Props1SI(const char* FluidName, const char* Output);
+
+/**
+     *\overload
+     *\sa \ref CoolProp::Props1SImulti(const std::vector<std::string>& Outputs, const std::string& backend, const std::vector<std::string>& fluids, const std::vector<double>& fractions)
+     *
+     * \note If there is an error, a huge value will be returned, you can get the error message by doing something like get_global_param_string("errstring",output)
+     */
+EXPORT_CODE void CONVENTION Props1SImulti(const char* Outputs, char* backend, const char* FluidNames, const double* fractions,
+                                          const long length_fractions, double* result, long* resdim1);
+/**
+     *\overload
+     *\sa \ref CoolProp::PropsSI(const std::string &, const std::string &, double, const std::string &, double, const std::string&)
+     *
+     * \note If there is an error, a huge value will be returned, you can get the error message by doing something like get_global_param_string("errstring",output)
+     */
+EXPORT_CODE double CONVENTION PropsSI(const char* Output, const char* Name1, double Prop1, const char* Name2, double Prop2, const char* Ref);
+/**
+     *\overload
+     *\sa \ref CoolProp::PropsSImulti(const std::vector<std::string>& Outputs, const std::string& Name1, const std::vector<double>& Prop1,
+                                              const std::string& Name2, const std::vector<double>& Prop2, const std::string& backend,
+                                              const std::vector<std::string>& fluids, const std::vector<double>& fractions)
+     *
+     * @param Outputs Delimited string separated by LIST_STRING_DELIMITER for the output parameters
+     * @param Name1 The name of the first input variable
+     * @param Prop1 A vector of the first input values 
+     * @param size_Prop1 Size of Prop1 double*
+     * @param Name2 The name of the second input variable
+     * @param Prop2 A vector of the second input values 
+     * @param size_Prop2 Size of Prop2 double*
+     * @param backend 	The string representation of the backend (HEOS, REFPROP, INCOMP, etc.) 
+     * @param FluidNames  Delimited string separated by LIST_STRING_DELIMITER for the fluid name(s)
+     * @param fractions The fractions (molar, mass, volume, etc.) of the components
+     * @param length_fractions Size of fractions double*
+     * @param result Allocated memory for result vector
+     * @param resdim1 result vector dimension 1 pointer, to check allocated space and return actual result size
+     * @param resdim2 result vector dimension 2 pointer, to check allocated space and return actual result size
+     * \note If there is an error, an empty vector will be returned, you can get the error message by doing something like get_global_param_string("errstring",output)
+     */
+EXPORT_CODE void CONVENTION PropsSImulti(const char* Outputs, const char* Name1, double* Prop1, const long size_Prop1, const char* Name2,
+                                         double* Prop2, const long size_Prop2, char* backend, const char* FluidNames, const double* fractions,
+                                         const long length_fractions, double* result, long* resdim1, long* resdim2);
+/**
+     *\overload
+     *\sa \ref CoolProp::PhaseSI(const std::string &, double, const std::string &, double, const std::string&)
+     *
+     * \note This function returns the phase string in pre-allocated phase variable.  If buffer is not large enough, no copy is made
+     */
+EXPORT_CODE long CONVENTION PhaseSI(const char* Name1, double Prop1, const char* Name2, double Prop2, const char* Ref, char* phase, int n);
+
+/**
+     *\overload
+     *\sa \ref CoolProp::get_global_param_string
+     *
+     * @returns error_code 1 = Ok 0 = error
+     *
+     * \note This function returns the output string in pre-allocated char buffer.  If buffer is not large enough, no copy is made
+     */
+EXPORT_CODE long CONVENTION get_global_param_string(const char* param, char* Output, int n);
+/**
+     * \overload
+     * \sa \ref CoolProp::get_parameter_information_string
+     * \note This function returns the output string in pre-allocated char buffer.  If buffer is not large enough, no copy is made
+     *
+     * @returns error_code 1 = Ok 0 = error
+     */
+EXPORT_CODE long CONVENTION get_parameter_information_string(const char* key, char* Output, int n);
+/**
+     * \overload
+     * \sa \ref CoolProp::get_fluid_param_string
+     *
+     * @returns error_code 1 = Ok 0 = error
+     */
+EXPORT_CODE long CONVENTION get_fluid_param_string(const char* fluid, const char* param, char* Output, int n);
+/** \brief Set configuration string
+    * @param key The key to configure
+    * @param val The value to set to the key
+    * \note you can get the error message by doing something like get_global_param_string("errstring",output)
+    */
+EXPORT_CODE void CONVENTION set_config_string(const char* key, const char* val);
+/** \brief Set configuration numerical value as double
+    * @param key The key to configure
+    * @param val The value to set to the key
+    * \note you can get the error message by doing something like get_global_param_string("errstring",output)
+    */
+EXPORT_CODE void CONVENTION set_config_double(const char* key, const double val);
+/** \brief Set configuration value as a boolean
+     * @param key The key to configure
+     * @param val The value to set to the key
+     * \note you can get the error message by doing something like get_global_param_string("errstring",output)
+     */
+EXPORT_CODE void CONVENTION set_config_bool(const char* key, const bool val);
+/**
+     * @brief Set the departure functions in the departure function library from a string format
+     * @param string_data The departure functions to be set, either provided as a JSON-formatted string
+     *                    or as a string of the contents of a HMX.BNC file from REFPROP
+     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+     * @param message_buffer A buffer for the error code
+     * @param buffer_length The length of the buffer for the error code
+     *
+     * @note By default, if a departure function already exists in the library, this is an error,
+     *       unless the configuration variable OVERWRITE_DEPARTURE_FUNCTIONS is set to true
+     */
+EXPORT_CODE void CONVENTION set_departure_functions(const char* string_data, long* errcode, char* message_buffer, const long buffer_length);
+/**
+     * \overload
+     * \sa \ref CoolProp::set_reference_stateS
+     * @returns error_code 1 = Ok 0 = error
+     */
+EXPORT_CODE int CONVENTION set_reference_stateS(const char* Ref, const char* reference_state);
+/**
+     * \overload
+     * \sa \ref CoolProp::set_reference_stateD
+     * @returns error_code 1 = Ok 0 = error
+     */
+EXPORT_CODE int CONVENTION set_reference_stateD(const char* Ref, double T, double rhomolar, double hmolar0, double smolar0);
+/** \brief FORTRAN 77 style wrapper of the PropsSI function
+     * \overload
+     * \sa \ref CoolProp::PropsSI(const std::string &, const std::string &, double, const std::string &, double, const std::string&)
+     *
+     * \note If there is an error, a huge value will be returned, you can get the error message by doing something like get_global_param_string("errstring",output)
+     */
+EXPORT_CODE void CONVENTION propssi_(const char* Output, const char* Name1, const double* Prop1, const char* Name2, const double* Prop2,
+                                     const char* Ref, double* output);
+
+/// Convert from degrees Fahrenheit to Kelvin (useful primarily for testing)
+EXPORT_CODE double CONVENTION F2K(double T_F);
+/// Convert from Kelvin to degrees Fahrenheit (useful primarily for testing)
+EXPORT_CODE double CONVENTION K2F(double T_K);
+/** \brief Get the index for a parameter "T", "P", etc.
+     *
+     * @returns index The index as a long.  If input is invalid, returns -1
+     */
+EXPORT_CODE long CONVENTION get_param_index(const char* param);
+/** \brief Get the index for an input pair for AbstractState.update function
+     *
+     * @returns index The index as a long.  If input is invalid, returns -1
+     */
+EXPORT_CODE long CONVENTION get_input_pair_index(const char* param);
+/** \brief Redirect all output that would go to console (stdout) to a file
+     */
+EXPORT_CODE long CONVENTION redirect_stdout(const char* file);
+
+// ---------------------------------
+// Getter and setter for debug level
+// ---------------------------------
+
+/// Get the debug level
+/// @returns level The level of the verbosity for the debugging output (0-10) 0: no debgging output
+EXPORT_CODE int CONVENTION get_debug_level();
+/// Set the debug level
+/// @param level The level of the verbosity for the debugging output (0-10) 0: no debgging output
+EXPORT_CODE void CONVENTION set_debug_level(int level);
+
+/* \brief Extract a value from the saturation ancillary
+     *
+     * @param fluid_name The name of the fluid to be used - HelmholtzEOS backend only
+     * @param output The desired output variable ("P" for instance for pressure)
+     * @param Q The quality, 0 or 1
+     * @param input The input variable ("T")
+     * @param value The input value
+     */
+EXPORT_CODE double CONVENTION saturation_ancillary(const char* fluid_name, const char* output, int Q, const char* input, double value);
+
+// ---------------------------------
+//        Humid Air Properties
+// ---------------------------------
+
+/** \brief DLL wrapper of the HAPropsSI function
+     * \sa \ref HumidAir::HAPropsSI(const char *OutputName, const char *Input1Name, double Input1, const char *Input2Name, double Input2, const char *Input3Name, double Input3);
+     *
+     * \note If there is an error, a huge value will be returned, you can get the error message by doing something like get_global_param_string("errstring",output)
+     */
+EXPORT_CODE double CONVENTION HAPropsSI(const char* Output, const char* Name1, double Prop1, const char* Name2, double Prop2, const char* Name3,
+                                        double Prop3);
+
+/** \brief Humid air saturation specific heat at 1 atmosphere, based on a correlation from EES.
+     * \sa \ref HumidAir::cair_sat(double);
+     *
+     * @param T [K] good from 250K to 300K, no error bound checking is carried out.
+     *
+     * \note Equals partial derivative of enthalpy with respect to temperature at constant relative humidity of 100 percent and pressure of 1 atmosphere.
+     */
+EXPORT_CODE double CONVENTION cair_sat(double T);
+
+/** \brief FORTRAN 77 style wrapper of the HAPropsSI function
+     * \sa \ref HumidAir::HAPropsSI(const char *OutputName, const char *Input1Name, double Input1, const char *Input2Name, double Input2, const char *Input3Name, double Input3);
+     *
+     * \note If there is an error, a huge value will be returned, you can get the error message by doing something like get_global_param_string("errstring",output)
+     */
+EXPORT_CODE void CONVENTION hapropssi_(const char* Output, const char* Name1, const double* Prop1, const char* Name2, const double* Prop2,
+                                       const char* Name3, const double* Prop3, double* output);
+
+/** \brief DLL wrapper of the HAProps function
+     *
+     * \warning DEPRECATED!!
+     * \sa \ref HumidAir::HAProps(const char *OutputName, const char *Input1Name, double Input1, const char *Input2Name, double Input2, const char *Input3Name, double Input3);
+     *
+     * \note If there is an error, a huge value will be returned, you can get the error message by doing something like get_global_param_string("errstring",output)
+     */
+EXPORT_CODE double CONVENTION HAProps(const char* Output, const char* Name1, double Prop1, const char* Name2, double Prop2, const char* Name3,
+                                      double Prop3);
+
+/** \brief FORTRAN 77 style wrapper of the HAProps function
+     *
+     * \warning DEPRECATED!!
+     * \sa \ref HumidAir::HAProps(const char *OutputName, const char *Input1Name, double Input1, const char *Input2Name, double Input2, const char *Input3Name, double Input3);
+     *
+     * \note If there is an error, a huge value will be returned, you can get the error message by doing something like get_global_param_string("errstring",output)
+     */
+EXPORT_CODE void CONVENTION haprops_(const char* Output, const char* Name1, const double* Prop1, const char* Name2, const double* Prop2,
+                                     const char* Name3, const double* Prop3, double* output);
+
+// ---------------------------------
+//        Low-level access
+// ---------------------------------
+
+/**
+     * @brief Generate an AbstractState instance, return an integer handle to the state class generated to be used in the other low-level accessor functions
+     * @param backend The backend you will use, "HEOS", "REFPROP", etc.
+     * @param fluids '&' delimited list of fluids
+     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+     * @param message_buffer A buffer for the error code
+     * @param buffer_length The length of the buffer for the error code
+     * @return A handle to the state class generated
+     */
+EXPORT_CODE long CONVENTION AbstractState_factory(const char* backend, const char* fluids, long* errcode, char* message_buffer,
+                                                  const long buffer_length);
+/**
+     * @brief Get the fluid names for the AbstractState
+     * @param handle The integer handle for the state class stored in memory
+     * @param fluids LIST_STRING_DELIMETER (',') delimited list of fluids
+     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+     * @param message_buffer A buffer for the error code
+     * @param buffer_length The length of the buffer for the error code
+     * @return
+     */
+EXPORT_CODE void CONVENTION AbstractState_fluid_names(const long handle, char* fluids, long* errcode, char* message_buffer, const long buffer_length);
+/**
+     * @brief Release a state class generated by the low-level interface wrapper
+     * @param handle The integer handle for the state class stored in memory
+     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+     * @param message_buffer A buffer for the error code
+     * @param buffer_length The length of the buffer for the error code
+     * @return
+     */
+EXPORT_CODE void CONVENTION AbstractState_free(const long handle, long* errcode, char* message_buffer, const long buffer_length);
+/**
+     * @brief Set the fractions (mole, mass, volume) for the AbstractState
+     * @param handle The integer handle for the state class stored in memory
+     * @param fractions The array of fractions
+     * @param N The length of the fractions array
+     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+     * @param message_buffer A buffer for the error code
+     * @param buffer_length The length of the buffer for the error code
+     * @return
+     */
+EXPORT_CODE void CONVENTION AbstractState_set_fractions(const long handle, const double* fractions, const long N, long* errcode, char* message_buffer,
+                                                        const long buffer_length);
+/**
+     * @brief Get the molar fractions for the AbstractState
+     * @param handle The integer handle for the state class stored in memory
+     * @param fractions The array of fractions
+     * @param maxN The length of the buffer for the fractions
+     * @param N number of fluids
+     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+     * @param message_buffer A buffer for the error code
+     * @param buffer_length The length of the buffer for the error code
+     * @return
+     */
+EXPORT_CODE void CONVENTION AbstractState_get_mole_fractions(const long handle, double* fractions, const long maxN, long* N, long* errcode,
+                                                             char* message_buffer, const long buffer_length);
+/**
+     * @brief Get the molar fractions for the AbstractState and the desired saturated State
+     * @param handle The integer handle for the state class stored in memory
+     * @param saturated_state The string specifying the state (liquid or gas)
+     * @param fractions The array of fractions
+     * @param maxN The length of the buffer for the fractions
+     * @param N number of fluids
+     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+     * @param message_buffer A buffer for the error code
+     * @param buffer_length The length of the buffer for the error code
+     * @return 
+     */
+EXPORT_CODE void CONVENTION AbstractState_get_mole_fractions_satState(const long handle, const char* saturated_state, double* fractions,
+                                                                      const long maxN, long* N, long* errcode, char* message_buffer,
+                                                                      const long buffer_length);
+/**
+     * @brief Update the state of the AbstractState
+     * @param handle The integer handle for the state class stored in memory
+     * @param input_pair The integer value for the input pair obtained from XXXXXXXXXXXXXXXX
+     * @param value1 The first input value
+     * @param value2 The second input value
+     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+     * @param message_buffer A buffer for the error code
+     * @param buffer_length The length of the buffer for the error code
+     * @return
+     */
+EXPORT_CODE void CONVENTION AbstractState_update(const long handle, const long input_pair, const double value1, const double value2, long* errcode,
+                                                 char* message_buffer, const long buffer_length);
+/**
+    * @brief Specify the phase to be used for all further calculations
+    * @param handle The integer handle for the state class stored in memory
+    * @param phase The string with the phase to use
+    * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+    * @param message_buffer A buffer for the error code
+    * @param buffer_length The length of the buffer for the error code
+    * @return
+    */
+EXPORT_CODE void CONVENTION AbstractState_specify_phase(const long handle, const char* phase, long* errcode, char* message_buffer,
+                                                        const long buffer_length);
+/**
+    * @brief Unspecify the phase to be used for all further calculations
+    * @param handle The integer handle for the state class stored in memory
+    * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+    * @param message_buffer A buffer for the error code
+    * @param buffer_length The length of the buffer for the error code
+    * @return
+    */
+EXPORT_CODE void CONVENTION AbstractState_unspecify_phase(const long handle, long* errcode, char* message_buffer, const long buffer_length);
+/**
+     * @brief Get an output value from the AbstractState using an integer value for the desired output value
+     * @param handle The integer handle for the state class stored in memory
+     * @param param The integer value for the parameter you want
+     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+     * @param message_buffer A buffer for the error code
+     * @param buffer_length The length of the buffer for the error code
+     * @return
+     */
+EXPORT_CODE double CONVENTION AbstractState_keyed_output(const long handle, const long param, long* errcode, char* message_buffer,
+                                                         const long buffer_length);
+
+/**
+    * @brief Calculate a saturation derivative from the AbstractState using integer values for the desired parameters
+    * @param handle The integer handle for the state class stored in memory
+    * @param Of The parameter of which the derivative is being taken
+    * @param Wrt The derivative with with respect to this parameter
+    * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+    * @param message_buffer A buffer for the error code
+    * @param buffer_length The length of the buffer for the error code
+    * @return
+    */
+EXPORT_CODE double CONVENTION AbstractState_first_saturation_deriv(const long handle, const long Of, const long Wrt, long* errcode,
+                                                                   char* message_buffer, const long buffer_length);
+
+/**
+    * @brief Calculate the first partial derivative in homogeneous phases from the AbstractState using integer values for the desired parameters
+    * @param handle The integer handle for the state class stored in memory
+    * @param Of The parameter of which the derivative is being taken
+    * @param Wrt The derivative with with respect to this parameter
+    * @param Constant The parameter that is not affected by the derivative
+    * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+    * @param message_buffer A buffer for the error code
+    * @param buffer_length The length of the buffer for the error code
+    * @return
+    */
+EXPORT_CODE double CONVENTION AbstractState_first_partial_deriv(const long handle, const long Of, const long Wrt, const long Constant, long* errcode,
+                                                                char* message_buffer, const long buffer_length);
+
+/**
+    * @brief Update the state of the AbstractState and get an output value five common outputs (temperature, pressure, molar density, molar enthalpy and molar entropy)
+    * @brief from the AbstractState using pointers as inputs and output to allow array computation.
+    * @param handle The integer handle for the state class stored in memory
+    * @param input_pair The integer value for the input pair obtained from get_input_pair_index
+    * @param value1 The pointer to the array of the first input parameters
+    * @param value2 The pointer to the array of the second input parameters
+    * @param length The number of elements stored in the arrays (both inputs and outputs MUST be the same length)
+    * @param T The pointer to the array of temperature
+    * @param p The pointer to the array of pressure
+    * @param rhomolar The pointer to the array of molar density
+    * @param hmolar The pointer to the array of molar enthalpy
+    * @param smolar The pointer to the array of molar entropy
+    * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+    * @param message_buffer A buffer for the error code
+    * @param buffer_length The length of the buffer for the error code
+    * @return
+    *
+    * @note If there is an error in an update call for one of the inputs, no change in the output array will be made
+    */
+EXPORT_CODE void CONVENTION AbstractState_update_and_common_out(const long handle, const long input_pair, const double* value1, const double* value2,
+                                                                const long length, double* T, double* p, double* rhomolar, double* hmolar,
+                                                                double* smolar, long* errcode, char* message_buffer, const long buffer_length);
+
+/**
+    * @brief Update the state of the AbstractState and get one output value (temperature, pressure, molar density, molar enthalpy and molar entropy)
+    * @brief from the AbstractState using pointers as inputs and output to allow array computation.
+    * @param handle The integer handle for the state class stored in memory
+    * @param input_pair The integer value for the input pair obtained from get_input_pair_index
+    * @param value1 The pointer to the array of the first input parameters
+    * @param value2 The pointer to the array of the second input parameters
+    * @param length The number of elements stored in the arrays (both inputs and outputs MUST be the same length)
+    * @param output The indice for the output desired
+    * @param out The pointer to the array for output
+    * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+    * @param message_buffer A buffer for the error code
+    * @param buffer_length The length of the buffer for the error code
+    * @return
+    *
+    * @note If there is an error in an update call for one of the inputs, no change in the output array will be made
+    */
+EXPORT_CODE void CONVENTION AbstractState_update_and_1_out(const long handle, const long input_pair, const double* value1, const double* value2,
+                                                           const long length, const long output, double* out, long* errcode, char* message_buffer,
+                                                           const long buffer_length);
+
+/**
+    * @brief Update the state of the AbstractState and get an output value five common outputs (temperature, pressure, molar density, molar enthalpy and molar entropy)
+    * @brief from the AbstractState using pointers as inputs and output to allow array computation.
+    * @param handle The integer handle for the state class stored in memory
+    * @param input_pair The integer value for the input pair obtained from get_input_pair_index
+    * @param value1 The pointer to the array of the first input parameters
+    * @param value2 The pointer to the array of the second input parameters
+    * @param length The number of elements stored in the arrays (both inputs and outputs MUST be the same length)
+    * @param outputs The 5-element vector of indices for the outputs desired
+    * @param out1 The pointer to the array for the first output
+    * @param out2 The pointer to the array for the second output
+    * @param out3 The pointer to the array for the third output
+    * @param out4 The pointer to the array for the fourth output
+    * @param out5 The pointer to the array for the fifth output
+    * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+    * @param message_buffer A buffer for the error code
+    * @param buffer_length The length of the buffer for the error code
+    * @return
+    *
+    * @note If there is an error in an update call for one of the inputs, no change in the output array will be made
+    */
+EXPORT_CODE void CONVENTION AbstractState_update_and_5_out(const long handle, const long input_pair, const double* value1, const double* value2,
+                                                           const long length, long* outputs, double* out1, double* out2, double* out3, double* out4,
+                                                           double* out5, long* errcode, char* message_buffer, const long buffer_length);
+
+/**
+    * @brief Set binary interraction parrameter for mixtures
+    * @param handle The integer handle for the state class stored in memory
+    * @param i indice of the first fluid of the binary pair
+    * @param j indice of the second fluid of the binary pair
+    * @param parameter string wit the name of the parameter
+    * @param value the value of the binary interaction parameter
+    * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+    * @param message_buffer A buffer for the error code
+    * @param buffer_length The length of the buffer for the error code
+    * @return
+    */
+EXPORT_CODE void CONVENTION AbstractState_set_binary_interaction_double(const long handle, const long i, const long j, const char* parameter,
+                                                                        const double value, long* errcode, char* message_buffer,
+                                                                        const long buffer_length);
+
+/**
+    * @brief Set cubic's alpha function parameters
+    * @param handle The integer handle for the state class stored in memory
+    * @param i indice of the fluid the parramter should be applied too (for mixtures)
+	* @param parameter the string specifying the alpha function to use, ex "TWU" for the TWU alpha function
+    * @param c1 the first parameter for the alpha function
+    * @param c2 the second parameter for the alpha function
+    * @param c3 the third parameter for the alpha function
+    * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+    * @param message_buffer A buffer for the error code
+    * @param buffer_length The length of the buffer for the error code
+    * @return
+    */
+EXPORT_CODE void CONVENTION AbstractState_set_cubic_alpha_C(const long handle, const long i, const char* parameter, const double c1, const double c2,
+                                                            const double c3, long* errcode, char* message_buffer, const long buffer_length);
+
+/**
+    * @brief Set some fluid parameter (ie volume translation for cubic)
+    * @param handle The integer handle for the state class stored in memory
+	* @param i indice of the fluid the parramter should be applied too (for mixtures)
+	* @param parameter the string specifying the parameter to use, ex "cm" for volume translation
+    * @param value the value of the parameter
+    * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+    * @param message_buffer A buffer for the error code
+    * @param buffer_length The length of the buffer for the error code
+    * @return
+    */
+EXPORT_CODE void CONVENTION AbstractState_set_fluid_parameter_double(const long handle, const long i, const char* parameter, const double value,
+                                                                     long* errcode, char* message_buffer, const long buffer_length);
+
+/**
+     * @brief Build the phase envelope
+     * @param handle The integer handle for the state class stored in memory
+     * @param level How much refining of the phase envelope ("none" to skip refining (recommended))
+     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+     * @param message_buffer A buffer for the error code
+     * @param buffer_length The length of the buffer for the error code
+     * @return
+     *
+     * @note If there is an error in an update call for one of the inputs, no change in the output array will be made
+     */
+EXPORT_CODE void CONVENTION AbstractState_build_phase_envelope(const long handle, const char* level, long* errcode, char* message_buffer,
+                                                               const long buffer_length);
+
+/**
+     * @brief Get data from the phase envelope for the given mixture composition
+     * @param handle The integer handle for the state class stored in memory
+     * @param length The number of elements stored in the arrays (both inputs and outputs MUST be the same length)
+     * @param T The pointer to the array of temperature (K)
+     * @param p The pointer to the array of pressure (Pa)
+     * @param rhomolar_vap The pointer to the array of molar density for vapor phase (m^3/mol)
+     * @param rhomolar_liq The pointer to the array of molar density for liquid phase (m^3/mol)
+     * @param x The compositions of the "liquid" phase (WARNING: buffer should be Ncomp*Npoints in length, at a minimum, but there is no way to check buffer length at runtime)
+     * @param y The compositions of the "vapor" phase (WARNING: buffer should be Ncomp*Npoints in length, at a minimum, but there is no way to check buffer length at runtime)
+     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+     * @param message_buffer A buffer for the error code
+     * @param buffer_length The length of the buffer for the error code
+     * @return
+     *
+     * @note If there is an error in an update call for one of the inputs, no change in the output array will be made
+     */
+EXPORT_CODE void CONVENTION AbstractState_get_phase_envelope_data(const long handle, const long length, double* T, double* p, double* rhomolar_vap,
+                                                                  double* rhomolar_liq, double* x, double* y, long* errcode, char* message_buffer,
+                                                                  const long buffer_length);
+
+/**
+     * @brief Get data from the phase envelope for the given mixture composition
+     * @param handle The integer handle for the state class stored in memory
+     * @param length The number of elements stored in the arrays (both inputs and outputs MUST be the same length)
+     * @param maxComponents The number of fluid components for which memory is allocated
+     * @param T The pointer to the array of temperature (K)
+     * @param p The pointer to the array of pressure (Pa)
+     * @param rhomolar_vap The pointer to the array of molar density for vapor phase (m^3/mol)
+     * @param rhomolar_liq The pointer to the array of molar density for liquid phase (m^3/mol)
+     * @param x The compositions of the "liquid" phase (WARNING: buffer should be Ncomp*Npoints in length, at a minimum, but there is no way to check buffer length at runtime)
+     * @param y The compositions of the "vapor" phase (WARNING: buffer should be Ncomp*Npoints in length, at a minimum, but there is no way to check buffer length at runtime)
+     * @param actual_length The number of elements actually stored in the arrays
+     * @param actual_components The number of fluid components actually stored in the arrays
+     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+     * @param message_buffer A buffer for the error code
+     * @param buffer_length The length of the buffer for the error code
+     * @return
+     *
+     * @note If there is an error in an update call for one of the inputs, no change in the output array will be made
+     */
+EXPORT_CODE void CONVENTION AbstractState_get_phase_envelope_data_checkedMemory(const long handle, const long length, const long maxComponents, double* T,
+                                                                  double* p, double* rhomolar_vap, double* rhomolar_liq, double* x, double* y,
+                                                                  long* actual_length, long* actual_components, long* errcode, char* message_buffer,
+                                                                  const long buffer_length);
+
+/**
+     * @brief Build the spinodal
+     * @param handle The integer handle for the state class stored in memory
+     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+     * @param message_buffer A buffer for the error code
+     * @param buffer_length The length of the buffer for the error code
+     * @return
+     */
+EXPORT_CODE void CONVENTION AbstractState_build_spinodal(const long handle, long* errcode, char* message_buffer, const long buffer_length);
+
+/**
+     * @brief Get data for the spinodal curve
+     * @param handle The integer handle for the state class stored in memory
+     * @param length The number of elements stored in the arrays (all outputs MUST be the same length)
+     * @param tau The pointer to the array of reciprocal reduced temperature
+     * @param delta The pointer to the array of reduced density
+     * @param M1 The pointer to the array of M1 values (when L1=M1=0, critical point)
+     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+     * @param message_buffer A buffer for the error code
+     * @param buffer_length The length of the buffer for the error code
+     * @return
+     *
+     * @note If there is an error, no change in the output arrays will be made
+     */
+EXPORT_CODE void CONVENTION AbstractState_get_spinodal_data(const long handle, const long length, double* tau, double* delta, double* M1,
+                                                            long* errcode, char* message_buffer, const long buffer_length);
+
+/**
+     * @brief Calculate all the critical points for a given composition
+     * @param handle The integer handle for the state class stored in memory
+     * @param length The length of the buffers passed to this function
+     * @param T The pointer to the array of temperature (K)
+     * @param p The pointer to the array of pressure (Pa)
+     * @param rhomolar The pointer to the array of molar density (m^3/mol)
+     * @param stable The pointer to the array of boolean flags for whether the critical point is stable (1) or unstable (0)
+     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+     * @param message_buffer A buffer for the error code
+     * @param buffer_length The length of the buffer for the error code
+     * @return
+     *
+     * @note If there is an error in an update call for one of the inputs, no change in the output array will be made
+     */
+EXPORT_CODE void CONVENTION AbstractState_all_critical_points(const long handle, const long length, double* T, double* p, double* rhomolar,
+                                                              long* stable, long* errcode, char* message_buffer, const long buffer_length);
+/**
+     * @brief Get an output value from the AbstractState using an integer value for the desired output value and desired saturated State
+     * @param handle The integer handle for the state class stored in memory
+     * @param saturated_state The string specifying the state (liquid or gas)
+     * @param param The integer value for the parameter you want
+     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+     * @param message_buffer A buffer for the error code
+     * @param buffer_length The length of the buffer for the error code
+     * @return
+     */
+EXPORT_CODE double CONVENTION AbstractState_keyed_output_satState(const long handle, const char* saturated_state, const long param, long* errcode,
+                                                                  char* message_buffer, const long buffer_length);
+/**
+     * @brief Return the name of the backend used in the AbstractState
+     * @param handle The integer handle for the state class stored in memory
+     * @param backend The char pointer the name is written to
+     * @param errcode The errorcode that is returned (0 = no error, !0 = error)
+     * @param message_buffer A buffer for the error code
+     * @param buffer_length The length of the buffer for the error code
+     * @return
+     */
+EXPORT_CODE void CONVENTION AbstractState_backend_name(const long handle, char* backend, long* errcode, char* message_buffer,
+                                                       const long buffer_length);
+/** 
+     * \brief Add fluids as a JSON-formatted string
+     * @param backend The backend to which these should be added; e.g. "HEOS", "SRK", "PR"
+     * @param fluidstring The JSON-formatted string
+     * @return
+     *
+     */
+EXPORT_CODE void CONVENTION add_fluids_as_JSON(const char* backend, const char* fluidstring, long* errcode, char* message_buffer,
+                                               const long buffer_length);
+
+// *************************************************************************************
+// *************************************************************************************
+// *****************************  DEPRECATED *******************************************
+// *************************************************************************************
+// *************************************************************************************
+
+/**
+    \overload
+    \sa \ref Props(const char *Output, const char Name1, double Prop1, const char Name2, double Prop2, const char *Ref)
+    */
+EXPORT_CODE double CONVENTION PropsS(const char* Output, const char* Name1, double Prop1, const char* Name2, double Prop2, const char* Ref);
+/**
+    Works just like \ref CoolProp::PropsSI, but units are in KSI system.  This function is deprecated, no longer supported, and users should transition to using the PropsSI function
+    */
+EXPORT_CODE double CONVENTION Props(const char* Output, const char Name1, double Prop1, const char Name2, double Prop2, const char* Ref);
+/**
+    Works just like \ref CoolProp::Props1SI, but units are in KSI system.  This function is deprecated, no longer supported, and users should transition to using the Props1SI function
+    */
+EXPORT_CODE double CONVENTION Props1(const char* FluidName, const char* Output);
+
+#endif
```

## CoolProp/include/CoolPropTools.h

 * *Ordering differences only*

```diff
@@ -1,164 +1,164 @@
-#ifndef COOLPROPTOOLS_H
-#define COOLPROPTOOLS_H
-
-#ifndef _CRT_SECURE_NO_WARNINGS
-#    define _CRT_SECURE_NO_WARNINGS
-#endif
-
-#include "PlatformDetermination.h"
-#include "Exceptions.h"
-#include <string>
-#include <vector>
-#include <cctype>
-#include <map>
-
-#include "CPstrings.h"
-#include "CPnumerics.h"
-#include "CPfilepaths.h"
-
-#ifndef __has_feature           // Optional of course.
-#    define __has_feature(x) 0  // Compatibility with non-clang compilers.
-#endif
-
-#ifdef __EMSCRIPTEN__
-#    define thread_local
-#endif
-
-// see http://stackoverflow.com/questions/18298280/how-to-declare-a-variable-as-thread-local-portably
-#ifndef thread_local
-#    if __STDC_VERSION__ >= 201112 && !defined __STDC_NO_THREADS__
-#        define thread_local _Thread_local
-#    elif defined _WIN32 && (defined _MSC_VER || defined __ICL || defined __DMC__ || defined __BORLANDC__)
-#        define thread_local __declspec(thread)
-#    elif defined(__ISAPPLE__) && (defined(__llvm__) || defined(__clang__)) && !__has_feature(cxx_thread_local)
-#        define thread_local
-/* note that ICC (linux) and Clang are covered by __GNUC__ */
-#    elif defined __GNUC__ || defined __SUNPRO_C || defined __xlC__
-#        define thread_local __thread
-#    else
-#        error "Cannot define thread_local"
-//          #define thread_local
-#    endif
-#endif
-
-#define COOLPROPDBL_MAPS_TO_DOUBLE
-#ifdef COOLPROPDBL_MAPS_TO_DOUBLE
-typedef double CoolPropDbl;
-#else
-typedef long double CoolPropDbl;
-#endif
-
-/// Define the deprecated macro to give compile-time warnings
-#ifdef __GNUC__
-#    define DEPRECATED(func) func __attribute__((deprecated))
-#elif defined(_MSC_VER)
-#    define DEPRECATED(func) __declspec(deprecated) func
-#else
-#    pragma message("WARNING: You need to implement DEPRECATED for this compiler")
-#    define DEPRECATED(func) func
-#endif
-
-class Dictionary
-{
-   private:
-    typedef std::map<std::string, double> numbers_map;
-    numbers_map numbers;
-    typedef std::map<std::string, std::string> strings_map;
-    strings_map strings;
-    typedef std::map<std::string, std::vector<double>> double_vectors_map;
-    double_vectors_map double_vectors;
-    typedef std::map<std::string, std::vector<std::string>> string_vectors_map;
-    string_vectors_map string_vectors;
-
-   public:
-    Dictionary(){};
-    bool is_empty(void) const {
-        return numbers.empty() && strings.empty() && double_vectors.empty() && string_vectors.empty();
-    }
-    void add_string(const std::string& s1, const std::string& s2) {
-        strings.insert(std::pair<std::string, std::string>(s1, s2));
-    }
-    void add_number(const std::string& s1, double d) {
-        numbers.erase(s1);
-        numbers.insert(std::pair<std::string, double>(s1, d));
-    }
-    bool has_number(const std::string& s1) {
-        return numbers.find(s1) != numbers.end();
-    }
-    void add_double_vector(const std::string& s1, const std::vector<double>& d) {
-        double_vectors.insert(std::pair<std::string, std::vector<double>>(s1, d));
-    }
-    void add_string_vector(const std::string& s1, const std::vector<std::string>& d) {
-        string_vectors.insert(std::pair<std::string, std::vector<std::string>>(s1, d));
-    }
-    std::string get_string(const std::string& s) const {
-        strings_map::const_iterator i = strings.find(s);
-        if (i != strings.end()) {
-            return i->second;
-        } else {
-            throw CoolProp::ValueError(format("%s could not be matched in get_string", s.c_str()));
-        }
-    };
-    double get_double(const std::string& s) const {
-        numbers_map::const_iterator i = numbers.find(s);
-        if (i != numbers.end()) {
-            return i->second;
-        } else {
-            throw CoolProp::ValueError(format("%s could not be matched in get_number", s.c_str()));
-        }
-    };
-    /// Get a double, or return the default value if not found
-    double get_double(const std::string& s, const double default_value) const {
-        numbers_map::const_iterator i = numbers.find(s);
-        if (i != numbers.end()) {
-            return i->second;
-        } else {
-            return default_value;
-        }
-    };
-    double get_number(const std::string& s) const {
-        return get_double(s);
-    };
-    const std::vector<double>& get_double_vector(const std::string& s) const {
-        double_vectors_map::const_iterator i = double_vectors.find(s);
-        if (i != double_vectors.end()) {
-            return i->second;
-        } else {
-            throw CoolProp::ValueError(format("%s could not be matched in get_double_vector", s.c_str()));
-        }
-    };
-    const std::vector<std::string>& get_string_vector(const std::string& s) const {
-        string_vectors_map::const_iterator i = string_vectors.find(s);
-        if (i != string_vectors.end()) {
-            return i->second;
-        } else {
-            throw CoolProp::ValueError(format("%s could not be matched in get_string_vector", s.c_str()));
-        }
-    };
-};
-/// Utility function to clear a std::map of pointers
-//http://stackoverflow.com/questions/569110/why-is-memory-still-accessible-after-stdmapclear-is-called
-template <typename M>
-void freeClear(M& amap) {
-    for (typename M::iterator it = amap.begin(); it != amap.end(); ++it) {
-        delete it->second;
-    }
-    amap.clear();
-}
-
-#define CATCH_ALL_ERRORS_RETURN_HUGE(x) \
-    try {                               \
-        x                               \
-    } catch (const std::exception& e) { \
-        return _HUGE;                   \
-    } catch (...) {                     \
-        return _HUGE;                   \
-    }
-
-enum miniz_mode
-{
-    MINIZ_COMPRESS,
-    MINIZ_DECOMPRESS
-};
-void miniz(const std::string& inFile, const std::string& outFile, miniz_mode mode);
-#endif
+#ifndef COOLPROPTOOLS_H
+#define COOLPROPTOOLS_H
+
+#ifndef _CRT_SECURE_NO_WARNINGS
+#    define _CRT_SECURE_NO_WARNINGS
+#endif
+
+#include "PlatformDetermination.h"
+#include "Exceptions.h"
+#include <string>
+#include <vector>
+#include <cctype>
+#include <map>
+
+#include "CPstrings.h"
+#include "CPnumerics.h"
+#include "CPfilepaths.h"
+
+#ifndef __has_feature           // Optional of course.
+#    define __has_feature(x) 0  // Compatibility with non-clang compilers.
+#endif
+
+#ifdef __EMSCRIPTEN__
+#    define thread_local
+#endif
+
+// see http://stackoverflow.com/questions/18298280/how-to-declare-a-variable-as-thread-local-portably
+#ifndef thread_local
+#    if __STDC_VERSION__ >= 201112 && !defined __STDC_NO_THREADS__
+#        define thread_local _Thread_local
+#    elif defined _WIN32 && (defined _MSC_VER || defined __ICL || defined __DMC__ || defined __BORLANDC__)
+#        define thread_local __declspec(thread)
+#    elif defined(__ISAPPLE__) && (defined(__llvm__) || defined(__clang__)) && !__has_feature(cxx_thread_local)
+#        define thread_local
+/* note that ICC (linux) and Clang are covered by __GNUC__ */
+#    elif defined __GNUC__ || defined __SUNPRO_C || defined __xlC__
+#        define thread_local __thread
+#    else
+#        error "Cannot define thread_local"
+//          #define thread_local
+#    endif
+#endif
+
+#define COOLPROPDBL_MAPS_TO_DOUBLE
+#ifdef COOLPROPDBL_MAPS_TO_DOUBLE
+typedef double CoolPropDbl;
+#else
+typedef long double CoolPropDbl;
+#endif
+
+/// Define the deprecated macro to give compile-time warnings
+#ifdef __GNUC__
+#    define DEPRECATED(func) func __attribute__((deprecated))
+#elif defined(_MSC_VER)
+#    define DEPRECATED(func) __declspec(deprecated) func
+#else
+#    pragma message("WARNING: You need to implement DEPRECATED for this compiler")
+#    define DEPRECATED(func) func
+#endif
+
+class Dictionary
+{
+   private:
+    typedef std::map<std::string, double> numbers_map;
+    numbers_map numbers;
+    typedef std::map<std::string, std::string> strings_map;
+    strings_map strings;
+    typedef std::map<std::string, std::vector<double>> double_vectors_map;
+    double_vectors_map double_vectors;
+    typedef std::map<std::string, std::vector<std::string>> string_vectors_map;
+    string_vectors_map string_vectors;
+
+   public:
+    Dictionary(){};
+    bool is_empty(void) const {
+        return numbers.empty() && strings.empty() && double_vectors.empty() && string_vectors.empty();
+    }
+    void add_string(const std::string& s1, const std::string& s2) {
+        strings.insert(std::pair<std::string, std::string>(s1, s2));
+    }
+    void add_number(const std::string& s1, double d) {
+        numbers.erase(s1);
+        numbers.insert(std::pair<std::string, double>(s1, d));
+    }
+    bool has_number(const std::string& s1) {
+        return numbers.find(s1) != numbers.end();
+    }
+    void add_double_vector(const std::string& s1, const std::vector<double>& d) {
+        double_vectors.insert(std::pair<std::string, std::vector<double>>(s1, d));
+    }
+    void add_string_vector(const std::string& s1, const std::vector<std::string>& d) {
+        string_vectors.insert(std::pair<std::string, std::vector<std::string>>(s1, d));
+    }
+    std::string get_string(const std::string& s) const {
+        strings_map::const_iterator i = strings.find(s);
+        if (i != strings.end()) {
+            return i->second;
+        } else {
+            throw CoolProp::ValueError(format("%s could not be matched in get_string", s.c_str()));
+        }
+    };
+    double get_double(const std::string& s) const {
+        numbers_map::const_iterator i = numbers.find(s);
+        if (i != numbers.end()) {
+            return i->second;
+        } else {
+            throw CoolProp::ValueError(format("%s could not be matched in get_number", s.c_str()));
+        }
+    };
+    /// Get a double, or return the default value if not found
+    double get_double(const std::string& s, const double default_value) const {
+        numbers_map::const_iterator i = numbers.find(s);
+        if (i != numbers.end()) {
+            return i->second;
+        } else {
+            return default_value;
+        }
+    };
+    double get_number(const std::string& s) const {
+        return get_double(s);
+    };
+    const std::vector<double>& get_double_vector(const std::string& s) const {
+        double_vectors_map::const_iterator i = double_vectors.find(s);
+        if (i != double_vectors.end()) {
+            return i->second;
+        } else {
+            throw CoolProp::ValueError(format("%s could not be matched in get_double_vector", s.c_str()));
+        }
+    };
+    const std::vector<std::string>& get_string_vector(const std::string& s) const {
+        string_vectors_map::const_iterator i = string_vectors.find(s);
+        if (i != string_vectors.end()) {
+            return i->second;
+        } else {
+            throw CoolProp::ValueError(format("%s could not be matched in get_string_vector", s.c_str()));
+        }
+    };
+};
+/// Utility function to clear a std::map of pointers
+//http://stackoverflow.com/questions/569110/why-is-memory-still-accessible-after-stdmapclear-is-called
+template <typename M>
+void freeClear(M& amap) {
+    for (typename M::iterator it = amap.begin(); it != amap.end(); ++it) {
+        delete it->second;
+    }
+    amap.clear();
+}
+
+#define CATCH_ALL_ERRORS_RETURN_HUGE(x) \
+    try {                               \
+        x                               \
+    } catch (const std::exception& e) { \
+        return _HUGE;                   \
+    } catch (...) {                     \
+        return _HUGE;                   \
+    }
+
+enum miniz_mode
+{
+    MINIZ_COMPRESS,
+    MINIZ_DECOMPRESS
+};
+void miniz(const std::string& inFile, const std::string& outFile, miniz_mode mode);
+#endif
```

## CoolProp/include/DataStructures.h

```diff
@@ -1,477 +1,512 @@
-/*
- * DataStructures.h
- *
- *  Created on: 21 Dec 2013
- *      Author: jowr
- */
-
-#ifndef DATASTRUCTURES_H_
-#define DATASTRUCTURES_H_
-
-#include "CPnumerics.h"
-#include "Exceptions.h"
-#include <map>
-namespace CoolProp {
-
-struct SimpleState
-{
-    double rhomolar, T, p, hmolar, smolar, umolar, Q;
-    SimpleState() {
-        fill(_HUGE);
-    }
-    void fill(double v) {
-        rhomolar = v;
-        T = v;
-        p = v;
-        hmolar = v;
-        smolar = v;
-        umolar = v;
-        Q = v;
-    }
-    bool is_valid() {
-        return ValidNumber(rhomolar) && ValidNumber(T) && ValidNumber(hmolar) && ValidNumber(p);
-    }
-};
-
-struct CriticalState : SimpleState
-{
-    bool stable;
-    CriticalState() : stable(false) {
-        fill(_HUGE);
-    }
-};
-
-/// A modified class for the state point at the maximum saturation entropy on the vapor curve
-struct SsatSimpleState : public SimpleState
-{
-    enum SsatSimpleStateEnum
-    {
-        SSAT_MAX_NOT_SET = 0,
-        SSAT_MAX_DOESNT_EXIST,
-        SSAT_MAX_DOES_EXIST
-    };
-    SsatSimpleStateEnum exists;
-    SsatSimpleState() : exists(SSAT_MAX_NOT_SET) {}
-};
-
-/// --------------------------------------------------
-/// Define some constants that will be used throughout
-/// --------------------------------------------------
-/// These are constants for the input and output parameters
-/// The structure is taken directly from the AbstractState class.
-//
-// !! If you add a parameter, update the map in the corresponding CPP file !!
-enum parameters
-{
-    INVALID_PARAMETER = 0,
-
-    // General parameters
-    igas_constant,       ///< Ideal-gas constant
-    imolar_mass,         ///< Molar mass
-    iacentric_factor,    ///< Acentric factor
-    irhomolar_reducing,  ///< Molar density used for the reducing state
-    irhomolar_critical,  ///< Molar density used for the critical point
-    iT_reducing,         ///< Temperature at the reducing state
-    iT_critical,         ///< Temperature at the critical point
-    irhomass_reducing,   ///< Mass density at the reducing state
-    irhomass_critical,   ///< Mass density at the critical point
-    iP_critical,         ///< Pressure at the critical point
-    iP_reducing,         ///< Pressure at the reducing point
-    iT_triple,           ///< Triple point temperature
-    iP_triple,           ///< Triple point pressure
-    iT_min,              ///< Minimum temperature
-    iT_max,              ///< Maximum temperature
-    iP_max,              ///< Maximum pressure
-    iP_min,              ///< Minimum pressure
-    idipole_moment,      ///< Dipole moment
-
-    // Bulk properties
-    iT,      ///< Temperature
-    iP,      ///< Pressure
-    iQ,      ///< Vapor quality
-    iTau,    ///< Reciprocal reduced temperature
-    iDelta,  ///< Reduced density
-
-    // Molar specific thermodynamic properties
-    iDmolar,           ///< Mole-based density
-    iHmolar,           ///< Mole-based enthalpy
-    iSmolar,           ///< Mole-based entropy
-    iCpmolar,          ///< Mole-based constant-pressure specific heat
-    iCp0molar,         ///< Mole-based ideal-gas constant-pressure specific heat
-    iCvmolar,          ///< Mole-based constant-volume specific heat
-    iUmolar,           ///< Mole-based internal energy
-    iGmolar,           ///< Mole-based Gibbs energy
-    iHelmholtzmolar,   ///< Mole-based Helmholtz energy
-    iHmolar_residual,  ///< The residual molar enthalpy
-    iSmolar_residual,  ///< The residual molar entropy (as a function of temperature and density)
-    iGmolar_residual,  ///< The residual molar Gibbs energy
-
-    // Mass specific thermodynamic properties
-    iDmass,          ///< Mass-based density
-    iHmass,          ///< Mass-based enthalpy
-    iSmass,          ///< Mass-based entropy
-    iCpmass,         ///< Mass-based constant-pressure specific heat
-    iCp0mass,        ///< Mass-based ideal-gas specific heat
-    iCvmass,         ///< Mass-based constant-volume specific heat
-    iUmass,          ///< Mass-based internal energy
-    iGmass,          ///< Mass-based Gibbs energy
-    iHelmholtzmass,  ///< Mass-based Helmholtz energy
-
-    // Transport properties
-    iviscosity,        ///< Viscosity
-    iconductivity,     ///< Thermal conductivity
-    isurface_tension,  ///< Surface tension
-    iPrandtl,          ///< The Prandtl number
-
-    // Derivative-based terms
-    ispeed_sound,                       ///< Speed of sound
-    iisothermal_compressibility,        ///< Isothermal compressibility
-    iisobaric_expansion_coefficient,    ///< Isobaric expansion coefficient
-    iisentropic_expansion_coefficient,  ///< Isentropic expansion coefficient
-
-    // Fundamental derivative of gas dynamics
-    ifundamental_derivative_of_gas_dynamics,  ///< The fundamental derivative of gas dynamics
-
-    // Derivatives of the residual non-dimensionalized Helmholtz energy with respect to the EOS variables
-    ialphar,
-    idalphar_dtau_constdelta,
-    idalphar_ddelta_consttau,
-
-    // Derivatives of the ideal-gas non-dimensionalized Helmholtz energy with respect to the EOS variables
-    ialpha0,
-    idalpha0_dtau_constdelta,
-    idalpha0_ddelta_consttau,
-    id2alpha0_ddelta2_consttau,
-    id3alpha0_ddelta3_consttau,
-
-    // Other functions and derivatives
-    iBvirial,      ///< Second virial coefficient
-    iCvirial,      ///< Third virial coefficient
-    idBvirial_dT,  ///< Derivative of second virial coefficient with temperature
-    idCvirial_dT,  ///< Derivative of third virial coefficient with temperature
-    iZ,            ///< The compressibility factor Z = p*v/(R*T)
-    iPIP,          ///< The phase identification parameter of Venkatarathnam and Oellrich
-
-    // Accessors for incompressibles
-    ifraction_min,  ///< The minimum fraction (mole, mass, volume) for incompressibles
-    ifraction_max,  ///< The maximum fraction (mole,mass,volume) for incompressibles
-    iT_freeze,      ///< The freezing temperature for incompressibles
-
-    // Environmental parameters
-    iGWP20,               ///< The 20-year global warming potential
-    iGWP100,              ///< The 100-year global warming potential
-    iGWP500,              ///< The 500-year global warming potential
-    iFH,                  ///< Fire hazard index
-    iHH,                  ///< Health hazard index
-    iPH,                  ///< Physical hazard index
-    iODP,                 ///< Ozone depletion potential (R-11 = 1.0)
-    iPhase,               ///< The phase index of the given state
-    iundefined_parameter  ///< The last parameter, so we can check that all parameters are described in DataStructures.cpp
-
-};
-// !! If you add a parameter, update the map in the corresponding CPP file !!
-// !! Also update phase_lookup_string() in CoolProp.cpp                    !!
-
-/// These are constants for the phases of the fluid
-enum phases
-{
-    iphase_liquid,                ///< Subcritical liquid
-    iphase_supercritical,         ///< Supercritical (p > pc, T > Tc)
-    iphase_supercritical_gas,     ///< Supercritical gas (p < pc, T > Tc)
-    iphase_supercritical_liquid,  ///< Supercritical liquid (p > pc, T < Tc)
-    iphase_critical_point,        ///< At the critical point
-    iphase_gas,                   ///< Subcritical gas
-    iphase_twophase,              ///< Twophase
-    iphase_unknown,               ///< Unknown phase
-    iphase_not_imposed
-};  ///< Phase is not imposed
-
-/// Constants for the different PC-SAFT association schemes (see Huang and Radosz 1990)
-enum schemes
-{
-    i1,
-    i2a,
-    i2b,
-    i3a,
-    i3b,
-    i4a,
-    i4b,
-    i4c
-};
-
-/// Return information about the parameter
-/// @param key The key, one of iT, iP, etc.
-/// @param info The thing you want, one of "IO" ("IO" if input/output, "O" if output only), "short" (very short description), "long" (a longer description), "units"
-std::string get_parameter_information(int key, const std::string& info);
-
-/// Return the enum key corresponding to the parameter name ("Dmolar" for instance)
-parameters get_parameter_index(const std::string& param_name);
-
-/// Return true if passed phase name is valid, otherwise false
-/// @param phase_name The phase name string to be checked ("phase_liquid" for instance)
-/// @param iOutput Gets updated with the phases enum value if phase_name is found
-bool is_valid_phase(const std::string& phase_name, phases& iOutput);
-
-/// Return the enum key corresponding to the phase name ("phase_liquid" for instance)
-phases get_phase_index(const std::string& param_name);
-
-/// Return true if passed PC-SAFT association scheme name is valid, otherwise false
-/// @param scheme_name The association scheme string to be checked ("2B" for instance)
-/// @param iOutput Gets updated with the schemes enum value if scheme_name is found
-bool is_valid_scheme(const std::string &scheme_name, schemes &iOutput);
-
-/// Return the enum key corresponding to the association scheme name ("2B" for instance)
-schemes get_scheme_index(const std::string &scheme_name);
-
-/// Returns true if the input is trivial (constants, critical parameters, etc.)
-bool is_trivial_parameter(int key);
-
-/// Returns true if a valid parameter, and sets value in the variable iOutput
-bool is_valid_parameter(const std::string& name, parameters& iOutput);
-
-/// Returns true if the string corresponds to a valid first derivative
-///
-/// If it is a value derivative, the variables are set to the parts of the derivative
-bool is_valid_first_derivative(const std::string& name, parameters& iOf, parameters& iWrt, parameters& iConstant);
-
-/// Returns true if the string corresponds to a valid first saturation derivative - e.g. "d(P)/d(T)|sigma" for instance
-///
-/// If it is a valid derivative, the variables are set to the parts of the derivative
-bool is_valid_first_saturation_derivative(const std::string& name, parameters& iOf, parameters& iWrt);
-
-/// Returns true if the string corresponds to a valid second derivative
-///
-/// If it is a value derivative, the variables are set to the parts of the derivative
-bool is_valid_second_derivative(const std::string& name, parameters& iOf1, parameters& iWrt1, parameters& iConstant1, parameters& iWrt2,
-                                parameters& iConstant2);
-
-/// Get a comma separated list of parameters
-std::string get_csv_parameter_list();
-
-/// These are constants for the compositions
-enum composition_types
-{
-    IFRAC_MASS,
-    IFRAC_MOLE,
-    IFRAC_VOLUME,
-    IFRAC_UNDEFINED,
-    IFRAC_PURE
-};
-
-/// These are unit types for the fluid
-enum fluid_types
-{
-    FLUID_TYPE_PURE,
-    FLUID_TYPE_PSEUDOPURE,
-    FLUID_TYPE_REFPROP,
-    FLUID_TYPE_INCOMPRESSIBLE_LIQUID,
-    FLUID_TYPE_INCOMPRESSIBLE_SOLUTION,
-    FLUID_TYPE_UNDEFINED
-};
-
-// !! If you add a parameter, update the map in the corresponding CPP file !!
-/// These are input pairs that can be used for the update function (in each pair, input keys are sorted alphabetically)
-enum input_pairs
-{
-    INPUT_PAIR_INVALID = 0,  // Default (invalid) value
-    QT_INPUTS,               ///< Molar quality, Temperature in K
-    PQ_INPUTS,               ///< Pressure in Pa, Molar quality
-    QSmolar_INPUTS,          ///< Molar quality, Entropy in J/mol/K
-    QSmass_INPUTS,           ///< Molar quality, Entropy in J/kg/K
-    HmolarQ_INPUTS,          ///< Enthalpy in J/mol, Molar quality
-    HmassQ_INPUTS,           ///< Enthalpy in J/kg, Molar quality
-    DmolarQ_INPUTS,          ///< Density in mol/m^3, Molar quality
-    DmassQ_INPUTS,           ///< Density in kg/m^3, Molar quality
-
-    PT_INPUTS,  ///< Pressure in Pa, Temperature in K
-
-    DmassT_INPUTS,   ///< Mass density in kg/m^3, Temperature in K
-    DmolarT_INPUTS,  ///< Molar density in mol/m^3, Temperature in K
-    HmolarT_INPUTS,  ///< Enthalpy in J/mol, Temperature in K
-    HmassT_INPUTS,   ///< Enthalpy in J/kg, Temperature in K
-    SmolarT_INPUTS,  ///< Entropy in J/mol/K, Temperature in K
-    SmassT_INPUTS,   ///< Entropy in J/kg/K, Temperature in K
-    TUmolar_INPUTS,  ///< Temperature in K, Internal energy in J/mol
-    TUmass_INPUTS,   ///< Temperature in K, Internal energy in J/kg
-
-    DmassP_INPUTS,   ///< Mass density in kg/m^3, Pressure in Pa
-    DmolarP_INPUTS,  ///< Molar density in mol/m^3, Pressure in Pa
-    HmassP_INPUTS,   ///< Enthalpy in J/kg, Pressure in Pa
-    HmolarP_INPUTS,  ///< Enthalpy in J/mol, Pressure in Pa
-    PSmass_INPUTS,   ///< Pressure in Pa, Entropy in J/kg/K
-    PSmolar_INPUTS,  ///< Pressure in Pa, Entropy in J/mol/K
-    PUmass_INPUTS,   ///< Pressure in Pa, Internal energy in J/kg
-    PUmolar_INPUTS,  ///< Pressure in Pa, Internal energy in J/mol
-
-    HmassSmass_INPUTS,    ///< Enthalpy in J/kg, Entropy in J/kg/K
-    HmolarSmolar_INPUTS,  ///< Enthalpy in J/mol, Entropy in J/mol/K
-    SmassUmass_INPUTS,    ///< Entropy in J/kg/K, Internal energy in J/kg
-    SmolarUmolar_INPUTS,  ///< Entropy in J/mol/K, Internal energy in J/mol
-
-    DmassHmass_INPUTS,    ///< Mass density in kg/m^3, Enthalpy in J/kg
-    DmolarHmolar_INPUTS,  ///< Molar density in mol/m^3, Enthalpy in J/mol
-    DmassSmass_INPUTS,    ///< Mass density in kg/m^3, Entropy in J/kg/K
-    DmolarSmolar_INPUTS,  ///< Molar density in mol/m^3, Entropy in J/mol/K
-    DmassUmass_INPUTS,    ///< Mass density in kg/m^3, Internal energy in J/kg
-    DmolarUmolar_INPUTS,  ///< Molar density in mol/m^3, Internal energy in J/mol
-};
-// !! If you add or remove a parameter, update the map in the corresponding CPP file !!
-
-inline bool match_pair(parameters key1, parameters key2, parameters x1, parameters x2, bool& swap) {
-    swap = !(key1 == x1);
-    return ((key1 == x1 && key2 == x2) || (key2 == x1 && key1 == x2));
-};
-/**
- * @brief Generate an update pair from key, value pairs
- *
- * If the input pair is valid, v1 and v2 will correspond to the returned output pair
- *
- * @param key1 The first input key
- * @param value1 The first input value
- * @param key2 The second input key
- * @param value2 The second input value
- * @param out1 The first output value
- * @param out2 The second output value
- * @return pair, or INPUT_PAIR_INVALID if not valid
- */
-template <class T>
-CoolProp::input_pairs generate_update_pair(parameters key1, T value1, parameters key2, T value2, T& out1, T& out2) throw() {
-    CoolProp::input_pairs pair;
-    bool swap;
-
-    if (match_pair(key1, key2, iQ, iT, swap)) {
-        pair = QT_INPUTS;  ///< Molar quality, Temperature in K
-    } else if (match_pair(key1, key2, iP, iQ, swap)) {
-        pair = PQ_INPUTS;  ///< Pressure in Pa, Molar quality
-    } else if (match_pair(key1, key2, iP, iT, swap)) {
-        pair = PT_INPUTS;  ///< Pressure in Pa, Temperature in K
-    } else if (match_pair(key1, key2, iDmolar, iT, swap)) {
-        pair = DmolarT_INPUTS;  // Molar density in mol/m^3, Temperature in K
-    } else if (match_pair(key1, key2, iDmass, iT, swap)) {
-        pair = DmassT_INPUTS;  // Mass density in kg/m^3, Temperature in K
-    } else if (match_pair(key1, key2, iHmolar, iT, swap)) {
-        pair = HmolarT_INPUTS;  // Enthalpy in J/mol, Temperature in K
-    } else if (match_pair(key1, key2, iHmass, iT, swap)) {
-        pair = HmassT_INPUTS;  // Enthalpy in J/kg, Temperature in K
-    } else if (match_pair(key1, key2, iSmolar, iT, swap)) {
-        pair = SmolarT_INPUTS;  // Entropy in J/mol/K, Temperature in K
-    } else if (match_pair(key1, key2, iSmass, iT, swap)) {
-        pair = SmassT_INPUTS;  // Entropy in J/kg/K, Temperature in K
-    } else if (match_pair(key1, key2, iT, iUmolar, swap)) {
-        pair = TUmolar_INPUTS;  // Temperature in K, Internal energy in J/mol
-    } else if (match_pair(key1, key2, iT, iUmass, swap)) {
-        pair = TUmass_INPUTS;  // Temperature in K, Internal energy in J/kg
-    } else if (match_pair(key1, key2, iDmass, iHmass, swap)) {
-        pair = DmassHmass_INPUTS;  // Mass density in kg/m^3, Enthalpy in J/kg
-    } else if (match_pair(key1, key2, iDmolar, iHmolar, swap)) {
-        pair = DmolarHmolar_INPUTS;  // Molar density in mol/m^3, Enthalpy in J/mol
-    } else if (match_pair(key1, key2, iDmass, iSmass, swap)) {
-        pair = DmassSmass_INPUTS;  // Mass density in kg/m^3, Entropy in J/kg/K
-    } else if (match_pair(key1, key2, iDmolar, iSmolar, swap)) {
-        pair = DmolarSmolar_INPUTS;  // Molar density in mol/m^3, Entropy in J/mol/K
-    } else if (match_pair(key1, key2, iDmass, iUmass, swap)) {
-        pair = DmassUmass_INPUTS;  // Mass density in kg/m^3, Internal energy in J/kg
-    } else if (match_pair(key1, key2, iDmolar, iUmolar, swap)) {
-        pair = DmolarUmolar_INPUTS;  // Molar density in mol/m^3, Internal energy in J/mol
-    } else if (match_pair(key1, key2, iDmass, iP, swap)) {
-        pair = DmassP_INPUTS;  // Mass density in kg/m^3, Pressure in Pa
-    } else if (match_pair(key1, key2, iDmolar, iP, swap)) {
-        pair = DmolarP_INPUTS;  // Molar density in mol/m^3, Pressure in Pa
-    } else if (match_pair(key1, key2, iDmass, iQ, swap)) {
-        pair = DmassQ_INPUTS;  // Mass density in kg/m^3, molar vapor quality
-    } else if (match_pair(key1, key2, iDmolar, iQ, swap)) {
-        pair = DmolarQ_INPUTS;  // Molar density in mol/m^3, molar vapor quality
-    } else if (match_pair(key1, key2, iHmass, iP, swap)) {
-        pair = HmassP_INPUTS;  // Enthalpy in J/kg, Pressure in Pa
-    } else if (match_pair(key1, key2, iHmolar, iP, swap)) {
-        pair = HmolarP_INPUTS;  // Enthalpy in J/mol, Pressure in Pa
-    } else if (match_pair(key1, key2, iP, iSmass, swap)) {
-        pair = PSmass_INPUTS;  // Pressure in Pa, Entropy in J/kg/K
-    } else if (match_pair(key1, key2, iP, iSmolar, swap)) {
-        pair = PSmolar_INPUTS;  // Pressure in Pa, Entropy in J/mol/K
-    } else if (match_pair(key1, key2, iP, iUmass, swap)) {
-        pair = PUmass_INPUTS;  // Pressure in Pa, Internal energy in J/kg
-    } else if (match_pair(key1, key2, iP, iUmolar, swap)) {
-        pair = PUmolar_INPUTS;  // Pressure in Pa, Internal energy in J/mol
-    } else if (match_pair(key1, key2, iHmass, iSmass, swap)) {
-        pair = HmassSmass_INPUTS;  // Enthalpy in J/kg, Entropy in J/kg/K
-    } else if (match_pair(key1, key2, iHmolar, iSmolar, swap)) {
-        pair = HmolarSmolar_INPUTS;  // Enthalpy in J/mol, Entropy in J/mol/K
-    } else if (match_pair(key1, key2, iSmass, iUmass, swap)) {
-        pair = SmassUmass_INPUTS;  ///< Entropy in J/kg/K, Internal energy in J/kg
-    } else if (match_pair(key1, key2, iSmolar, iUmolar, swap)) {
-        pair = SmolarUmolar_INPUTS;  ///< Entropy in J/mol/K, Internal energy in J/mol
-    } else {
-        pair = INPUT_PAIR_INVALID;
-        return pair;
-    }
-
-    if (!swap) {
-        out1 = value1;
-        out2 = value2;
-    } else {
-        out1 = value2;
-        out2 = value1;
-    }
-    return pair;
-};
-
-/// Get the input pair index associated with its string representation
-input_pairs get_input_pair_index(const std::string& input_pair_name);
-
-/// Return the short description of an input pair key ("DmolarT_INPUTS" for instance)
-const std::string& get_input_pair_short_desc(input_pairs pair);
-
-/// Return the long description of an input pair key ("Molar density in mol/m^3, Temperature in K" for instance)
-const std::string& get_input_pair_long_desc(input_pairs pair);
-
-/// Split an input pair into parameters for the two parts that form the pair
-void split_input_pair(input_pairs pair, parameters& p1, parameters& p2);
-
-extern std::string get_mixture_binary_pair_data(const std::string& CAS1, const std::string& CAS2, const std::string& param);
-extern void set_mixture_binary_pair_data(const std::string& CAS1, const std::string& CAS2, const std::string& param, const double val);
-extern std::string get_mixture_binary_pair_pcsaft(const std::string& CAS1, const std::string& CAS2, const std::string& param);
-extern void set_mixture_binary_pair_pcsaft(const std::string& CAS1, const std::string& CAS2, const std::string& param, const double val);
-
-/// The structure is taken directly from the AbstractState class.
-// !! If you add a parameter, update the map in the corresponding CPP file !!
-enum backend_families
-{
-    INVALID_BACKEND_FAMILY = 0,
-    HEOS_BACKEND_FAMILY,
-    REFPROP_BACKEND_FAMILY,
-    INCOMP_BACKEND_FAMILY,
-    IF97_BACKEND_FAMILY,
-    TREND_BACKEND_FAMILY,
-    TTSE_BACKEND_FAMILY,
-    BICUBIC_BACKEND_FAMILY,
-    SRK_BACKEND_FAMILY,
-    PR_BACKEND_FAMILY,
-    VTPR_BACKEND_FAMILY,
-    PCSAFT_BACKEND_FAMILY
-};
-enum backends
-{
-    INVALID_BACKEND = 0,
-    HEOS_BACKEND_PURE,
-    HEOS_BACKEND_MIX,
-    REFPROP_BACKEND_PURE,
-    REFPROP_BACKEND_MIX,
-    INCOMP_BACKEND,
-    IF97_BACKEND,
-    TREND_BACKEND,
-    TTSE_BACKEND,
-    BICUBIC_BACKEND,
-    SRK_BACKEND,
-    PR_BACKEND,
-    VTPR_BACKEND,
-    PCSAFT_BACKEND
-};
-
-/// Convert a string into the enum values
-void extract_backend_families(std::string backend_string, backend_families& f1, backend_families& f2);
-void extract_backend_families_string(std::string backend_string, backend_families& f1, std::string& f2);
-std::string get_backend_string(backends backend);
-
-} /* namespace CoolProp */
-#endif /* DATASTRUCTURES_H_ */
+/*
+ * DataStructures.h
+ *
+ *  Created on: 21 Dec 2013
+ *      Author: jowr
+ */
+
+#ifndef DATASTRUCTURES_H_
+#define DATASTRUCTURES_H_
+
+#include "CPnumerics.h"
+#include "Exceptions.h"
+#include <map>
+namespace CoolProp {
+
+struct SimpleState
+{
+    double rhomolar, T, p, hmolar, smolar, umolar, Q;
+    SimpleState() {
+        fill(_HUGE);
+    }
+    void fill(double v) {
+        rhomolar = v;
+        T = v;
+        p = v;
+        hmolar = v;
+        smolar = v;
+        umolar = v;
+        Q = v;
+    }
+    bool is_valid() {
+        return ValidNumber(rhomolar) && ValidNumber(T) && ValidNumber(hmolar) && ValidNumber(p);
+    }
+};
+
+struct CriticalState : SimpleState
+{
+    bool stable;
+    CriticalState() : stable(false) {
+        fill(_HUGE);
+    }
+};
+
+/// A modified class for the state point at the maximum saturation entropy on the vapor curve
+struct SsatSimpleState : public SimpleState
+{
+    enum SsatSimpleStateEnum
+    {
+        SSAT_MAX_NOT_SET = 0,
+        SSAT_MAX_DOESNT_EXIST,
+        SSAT_MAX_DOES_EXIST
+    };
+    SsatSimpleStateEnum exists;
+    SsatSimpleState() : exists(SSAT_MAX_NOT_SET) {}
+};
+
+/// --------------------------------------------------
+/// Define some constants that will be used throughout
+/// --------------------------------------------------
+/// These are constants for the input and output parameters
+/// The structure is taken directly from the AbstractState class.
+//
+// !! If you add a parameter, update the map in the corresponding CPP file !!
+enum parameters
+{
+    INVALID_PARAMETER = 0,
+
+    // General parameters
+    igas_constant,       ///< Ideal-gas constant
+    imolar_mass,         ///< Molar mass
+    iacentric_factor,    ///< Acentric factor
+    irhomolar_reducing,  ///< Molar density used for the reducing state
+    irhomolar_critical,  ///< Molar density used for the critical point
+    iT_reducing,         ///< Temperature at the reducing state
+    iT_critical,         ///< Temperature at the critical point
+    irhomass_reducing,   ///< Mass density at the reducing state
+    irhomass_critical,   ///< Mass density at the critical point
+    iP_critical,         ///< Pressure at the critical point
+    iP_reducing,         ///< Pressure at the reducing point
+    iT_triple,           ///< Triple point temperature
+    iP_triple,           ///< Triple point pressure
+    iT_min,              ///< Minimum temperature
+    iT_max,              ///< Maximum temperature
+    iP_max,              ///< Maximum pressure
+    iP_min,              ///< Minimum pressure
+    idipole_moment,      ///< Dipole moment
+
+    // Bulk properties
+    iT,      ///< Temperature
+    iP,      ///< Pressure
+    iQ,      ///< Vapor quality
+    iTau,    ///< Reciprocal reduced temperature
+    iDelta,  ///< Reduced density
+
+    // Molar specific thermodynamic properties
+    iDmolar,           ///< Mole-based density
+    iHmolar,           ///< Mole-based enthalpy
+    iSmolar,           ///< Mole-based entropy
+    iCpmolar,          ///< Mole-based constant-pressure specific heat
+    iCp0molar,         ///< Mole-based ideal-gas constant-pressure specific heat
+    iCvmolar,          ///< Mole-based constant-volume specific heat
+    iUmolar,           ///< Mole-based internal energy
+    iGmolar,           ///< Mole-based Gibbs energy
+    iHelmholtzmolar,   ///< Mole-based Helmholtz energy
+    iHmolar_residual,  ///< The residual molar enthalpy
+    iSmolar_residual,  ///< The residual molar entropy (as a function of temperature and density)
+    iGmolar_residual,  ///< The residual molar Gibbs energy
+
+    // Mass specific thermodynamic properties
+    iDmass,          ///< Mass-based density
+    iHmass,          ///< Mass-based enthalpy
+    iSmass,          ///< Mass-based entropy
+    iCpmass,         ///< Mass-based constant-pressure specific heat
+    iCp0mass,        ///< Mass-based ideal-gas specific heat
+    iCvmass,         ///< Mass-based constant-volume specific heat
+    iUmass,          ///< Mass-based internal energy
+    iGmass,          ///< Mass-based Gibbs energy
+    iHelmholtzmass,  ///< Mass-based Helmholtz energy
+
+    // Transport properties
+    iviscosity,        ///< Viscosity
+    iconductivity,     ///< Thermal conductivity
+    isurface_tension,  ///< Surface tension
+    iPrandtl,          ///< The Prandtl number
+
+    // Derivative-based terms
+    ispeed_sound,                       ///< Speed of sound
+    iisothermal_compressibility,        ///< Isothermal compressibility
+    iisobaric_expansion_coefficient,    ///< Isobaric expansion coefficient
+    iisentropic_expansion_coefficient,  ///< Isentropic expansion coefficient
+
+    // Fundamental derivative of gas dynamics
+    ifundamental_derivative_of_gas_dynamics,  ///< The fundamental derivative of gas dynamics
+
+    // Derivatives of the residual non-dimensionalized Helmholtz energy with respect to the EOS variables
+    ialphar,
+    idalphar_dtau_constdelta,
+    idalphar_ddelta_consttau,
+
+    // Derivatives of the ideal-gas non-dimensionalized Helmholtz energy with respect to the EOS variables
+    ialpha0,
+    idalpha0_dtau_constdelta,
+    idalpha0_ddelta_consttau,
+    id2alpha0_ddelta2_consttau,
+    id3alpha0_ddelta3_consttau,
+
+    // Other functions and derivatives
+    iBvirial,      ///< Second virial coefficient
+    iCvirial,      ///< Third virial coefficient
+    idBvirial_dT,  ///< Derivative of second virial coefficient with temperature
+    idCvirial_dT,  ///< Derivative of third virial coefficient with temperature
+    iZ,            ///< The compressibility factor Z = p*v/(R*T)
+    iPIP,          ///< The phase identification parameter of Venkatarathnam and Oellrich
+
+    // Accessors for incompressibles
+    ifraction_min,  ///< The minimum fraction (mole, mass, volume) for incompressibles
+    ifraction_max,  ///< The maximum fraction (mole,mass,volume) for incompressibles
+    iT_freeze,      ///< The freezing temperature for incompressibles
+
+    // Environmental parameters
+    iGWP20,               ///< The 20-year global warming potential
+    iGWP100,              ///< The 100-year global warming potential
+    iGWP500,              ///< The 500-year global warming potential
+    iFH,                  ///< Fire hazard index
+    iHH,                  ///< Health hazard index
+    iPH,                  ///< Physical hazard index
+    iODP,                 ///< Ozone depletion potential (R-11 = 1.0)
+    iPhase,               ///< The phase index of the given state
+    iundefined_parameter  ///< The last parameter, so we can check that all parameters are described in DataStructures.cpp
+
+};
+// !! If you add a parameter, update the map in the corresponding CPP file !!
+// !! Also update phase_lookup_string() in CoolProp.cpp                    !!
+
+/// These are constants for the phases of the fluid
+enum phases
+{
+    iphase_liquid,                ///< Subcritical liquid
+    iphase_supercritical,         ///< Supercritical (p > pc, T > Tc)
+    iphase_supercritical_gas,     ///< Supercritical gas (p < pc, T > Tc)
+    iphase_supercritical_liquid,  ///< Supercritical liquid (p > pc, T < Tc)
+    iphase_critical_point,        ///< At the critical point
+    iphase_gas,                   ///< Subcritical gas
+    iphase_twophase,              ///< Twophase
+    iphase_unknown,               ///< Unknown phase
+    iphase_not_imposed
+};  ///< Phase is not imposed
+
+/// Constants for the different PC-SAFT association schemes (see Huang and Radosz 1990)
+enum schemes
+{
+    i1,
+    i2a,
+    i2b,
+    i3a,
+    i3b,
+    i4a,
+    i4b,
+    i4c
+};
+
+/// Return information about the parameter
+/// @param key The key, one of iT, iP, etc.
+/// @param info The thing you want, one of "IO" ("IO" if input/output, "O" if output only), "short" (very short description), "long" (a longer description), "units"
+std::string get_parameter_information(int key, const std::string& info);
+
+/// Return the enum key corresponding to the parameter name ("Dmolar" for instance)
+parameters get_parameter_index(const std::string& param_name);
+
+/// Return true if passed phase name is valid, otherwise false
+/// @param phase_name The phase name string to be checked ("phase_liquid" for instance)
+/// @param iOutput Gets updated with the phases enum value if phase_name is found
+bool is_valid_phase(const std::string& phase_name, phases& iOutput);
+
+/// Return the enum key corresponding to the phase name ("phase_liquid" for instance)
+phases get_phase_index(const std::string& param_name);
+
+/// Return true if passed PC-SAFT association scheme name is valid, otherwise false
+/// @param scheme_name The association scheme string to be checked ("2B" for instance)
+/// @param iOutput Gets updated with the schemes enum value if scheme_name is found
+bool is_valid_scheme(const std::string &scheme_name, schemes &iOutput);
+
+/// Return the enum key corresponding to the association scheme name ("2B" for instance)
+schemes get_scheme_index(const std::string &scheme_name);
+
+/// Returns true if the input is trivial (constants, critical parameters, etc.)
+bool is_trivial_parameter(int key);
+
+/// Returns true if a valid parameter, and sets value in the variable iOutput
+bool is_valid_parameter(const std::string& name, parameters& iOutput);
+
+/// Returns true if the string corresponds to a valid first derivative
+///
+/// If it is a value derivative, the variables are set to the parts of the derivative
+bool is_valid_first_derivative(const std::string& name, parameters& iOf, parameters& iWrt, parameters& iConstant);
+
+/// Returns true if the string corresponds to a valid first saturation derivative - e.g. "d(P)/d(T)|sigma" for instance
+///
+/// If it is a valid derivative, the variables are set to the parts of the derivative
+bool is_valid_first_saturation_derivative(const std::string& name, parameters& iOf, parameters& iWrt);
+
+/// Returns true if the string corresponds to a valid second derivative
+///
+/// If it is a value derivative, the variables are set to the parts of the derivative
+bool is_valid_second_derivative(const std::string& name, parameters& iOf1, parameters& iWrt1, parameters& iConstant1, parameters& iWrt2,
+                                parameters& iConstant2);
+
+/// Get a comma separated list of parameters
+std::string get_csv_parameter_list();
+
+/// These are constants for the compositions
+enum composition_types
+{
+    IFRAC_MASS,
+    IFRAC_MOLE,
+    IFRAC_VOLUME,
+    IFRAC_UNDEFINED,
+    IFRAC_PURE
+};
+
+/// These are unit types for the fluid
+enum fluid_types
+{
+    FLUID_TYPE_PURE,
+    FLUID_TYPE_PSEUDOPURE,
+    FLUID_TYPE_REFPROP,
+    FLUID_TYPE_INCOMPRESSIBLE_LIQUID,
+    FLUID_TYPE_INCOMPRESSIBLE_SOLUTION,
+    FLUID_TYPE_UNDEFINED
+};
+
+// !! If you add a parameter, update the map in the corresponding CPP file !!
+/// These are input pairs that can be used for the update function (in each pair, input keys are sorted alphabetically)
+enum input_pairs
+{
+    INPUT_PAIR_INVALID = 0,  // Default (invalid) value
+    QT_INPUTS,               ///< Molar quality, Temperature in K
+    PQ_INPUTS,               ///< Pressure in Pa, Molar quality
+    QSmolar_INPUTS,          ///< Molar quality, Entropy in J/mol/K
+    QSmass_INPUTS,           ///< Molar quality, Entropy in J/kg/K
+    HmolarQ_INPUTS,          ///< Enthalpy in J/mol, Molar quality
+    HmassQ_INPUTS,           ///< Enthalpy in J/kg, Molar quality
+    DmolarQ_INPUTS,          ///< Density in mol/m^3, Molar quality
+    DmassQ_INPUTS,           ///< Density in kg/m^3, Molar quality
+
+    PT_INPUTS,  ///< Pressure in Pa, Temperature in K
+
+    DmassT_INPUTS,   ///< Mass density in kg/m^3, Temperature in K
+    DmolarT_INPUTS,  ///< Molar density in mol/m^3, Temperature in K
+    HmolarT_INPUTS,  ///< Enthalpy in J/mol, Temperature in K
+    HmassT_INPUTS,   ///< Enthalpy in J/kg, Temperature in K
+    SmolarT_INPUTS,  ///< Entropy in J/mol/K, Temperature in K
+    SmassT_INPUTS,   ///< Entropy in J/kg/K, Temperature in K
+    TUmolar_INPUTS,  ///< Temperature in K, Internal energy in J/mol
+    TUmass_INPUTS,   ///< Temperature in K, Internal energy in J/kg
+
+    DmassP_INPUTS,   ///< Mass density in kg/m^3, Pressure in Pa
+    DmolarP_INPUTS,  ///< Molar density in mol/m^3, Pressure in Pa
+    HmassP_INPUTS,   ///< Enthalpy in J/kg, Pressure in Pa
+    HmolarP_INPUTS,  ///< Enthalpy in J/mol, Pressure in Pa
+    PSmass_INPUTS,   ///< Pressure in Pa, Entropy in J/kg/K
+    PSmolar_INPUTS,  ///< Pressure in Pa, Entropy in J/mol/K
+    PUmass_INPUTS,   ///< Pressure in Pa, Internal energy in J/kg
+    PUmolar_INPUTS,  ///< Pressure in Pa, Internal energy in J/mol
+
+    HmassSmass_INPUTS,    ///< Enthalpy in J/kg, Entropy in J/kg/K
+    HmolarSmolar_INPUTS,  ///< Enthalpy in J/mol, Entropy in J/mol/K
+    SmassUmass_INPUTS,    ///< Entropy in J/kg/K, Internal energy in J/kg
+    SmolarUmolar_INPUTS,  ///< Entropy in J/mol/K, Internal energy in J/mol
+
+    DmassHmass_INPUTS,    ///< Mass density in kg/m^3, Enthalpy in J/kg
+    DmolarHmolar_INPUTS,  ///< Molar density in mol/m^3, Enthalpy in J/mol
+    DmassSmass_INPUTS,    ///< Mass density in kg/m^3, Entropy in J/kg/K
+    DmolarSmolar_INPUTS,  ///< Molar density in mol/m^3, Entropy in J/mol/K
+    DmassUmass_INPUTS,    ///< Mass density in kg/m^3, Internal energy in J/kg
+    DmolarUmolar_INPUTS,  ///< Molar density in mol/m^3, Internal energy in J/mol
+};
+// !! If you add or remove a parameter, update the map in the corresponding CPP file !!
+
+inline bool match_pair(parameters key1, parameters key2, parameters x1, parameters x2, bool& swap) {
+    swap = !(key1 == x1);
+    return ((key1 == x1 && key2 == x2) || (key2 == x1 && key1 == x2));
+};
+/**
+ * @brief Generate an update pair from key, value pairs
+ *
+ * If the input pair is valid, v1 and v2 will correspond to the returned output pair
+ *
+ * @param key1 The first input key
+ * @param value1 The first input value
+ * @param key2 The second input key
+ * @param value2 The second input value
+ * @param out1 The first output value
+ * @param out2 The second output value
+ * @return pair, or INPUT_PAIR_INVALID if not valid
+ */
+template <class T>
+CoolProp::input_pairs generate_update_pair(parameters key1, T value1, parameters key2, T value2, T& out1, T& out2) throw() {
+    CoolProp::input_pairs pair;
+    bool swap;
+
+    if (match_pair(key1, key2, iQ, iT, swap)) {
+        pair = QT_INPUTS;  ///< Molar quality, Temperature in K
+    } else if (match_pair(key1, key2, iP, iQ, swap)) {
+        pair = PQ_INPUTS;  ///< Pressure in Pa, Molar quality
+    } else if (match_pair(key1, key2, iP, iT, swap)) {
+        pair = PT_INPUTS;  ///< Pressure in Pa, Temperature in K
+    } else if (match_pair(key1, key2, iDmolar, iT, swap)) {
+        pair = DmolarT_INPUTS;  // Molar density in mol/m^3, Temperature in K
+    } else if (match_pair(key1, key2, iDmass, iT, swap)) {
+        pair = DmassT_INPUTS;  // Mass density in kg/m^3, Temperature in K
+    } else if (match_pair(key1, key2, iHmolar, iT, swap)) {
+        pair = HmolarT_INPUTS;  // Enthalpy in J/mol, Temperature in K
+    } else if (match_pair(key1, key2, iHmass, iT, swap)) {
+        pair = HmassT_INPUTS;  // Enthalpy in J/kg, Temperature in K
+    } else if (match_pair(key1, key2, iSmolar, iT, swap)) {
+        pair = SmolarT_INPUTS;  // Entropy in J/mol/K, Temperature in K
+    } else if (match_pair(key1, key2, iSmass, iT, swap)) {
+        pair = SmassT_INPUTS;  // Entropy in J/kg/K, Temperature in K
+    } else if (match_pair(key1, key2, iT, iUmolar, swap)) {
+        pair = TUmolar_INPUTS;  // Temperature in K, Internal energy in J/mol
+    } else if (match_pair(key1, key2, iT, iUmass, swap)) {
+        pair = TUmass_INPUTS;  // Temperature in K, Internal energy in J/kg
+    } else if (match_pair(key1, key2, iDmass, iHmass, swap)) {
+        pair = DmassHmass_INPUTS;  // Mass density in kg/m^3, Enthalpy in J/kg
+    } else if (match_pair(key1, key2, iDmolar, iHmolar, swap)) {
+        pair = DmolarHmolar_INPUTS;  // Molar density in mol/m^3, Enthalpy in J/mol
+    } else if (match_pair(key1, key2, iDmass, iSmass, swap)) {
+        pair = DmassSmass_INPUTS;  // Mass density in kg/m^3, Entropy in J/kg/K
+    } else if (match_pair(key1, key2, iDmolar, iSmolar, swap)) {
+        pair = DmolarSmolar_INPUTS;  // Molar density in mol/m^3, Entropy in J/mol/K
+    } else if (match_pair(key1, key2, iDmass, iUmass, swap)) {
+        pair = DmassUmass_INPUTS;  // Mass density in kg/m^3, Internal energy in J/kg
+    } else if (match_pair(key1, key2, iDmolar, iUmolar, swap)) {
+        pair = DmolarUmolar_INPUTS;  // Molar density in mol/m^3, Internal energy in J/mol
+    } else if (match_pair(key1, key2, iDmass, iP, swap)) {
+        pair = DmassP_INPUTS;  // Mass density in kg/m^3, Pressure in Pa
+    } else if (match_pair(key1, key2, iDmolar, iP, swap)) {
+        pair = DmolarP_INPUTS;  // Molar density in mol/m^3, Pressure in Pa
+    } else if (match_pair(key1, key2, iDmass, iQ, swap)) {
+        pair = DmassQ_INPUTS;  // Mass density in kg/m^3, molar vapor quality
+    } else if (match_pair(key1, key2, iDmolar, iQ, swap)) {
+        pair = DmolarQ_INPUTS;  // Molar density in mol/m^3, molar vapor quality
+    } else if (match_pair(key1, key2, iHmass, iP, swap)) {
+        pair = HmassP_INPUTS;  // Enthalpy in J/kg, Pressure in Pa
+    } else if (match_pair(key1, key2, iHmolar, iP, swap)) {
+        pair = HmolarP_INPUTS;  // Enthalpy in J/mol, Pressure in Pa
+    } else if (match_pair(key1, key2, iP, iSmass, swap)) {
+        pair = PSmass_INPUTS;  // Pressure in Pa, Entropy in J/kg/K
+    } else if (match_pair(key1, key2, iP, iSmolar, swap)) {
+        pair = PSmolar_INPUTS;  // Pressure in Pa, Entropy in J/mol/K
+    } else if (match_pair(key1, key2, iP, iUmass, swap)) {
+        pair = PUmass_INPUTS;  // Pressure in Pa, Internal energy in J/kg
+    } else if (match_pair(key1, key2, iP, iUmolar, swap)) {
+        pair = PUmolar_INPUTS;  // Pressure in Pa, Internal energy in J/mol
+    } else if (match_pair(key1, key2, iHmass, iSmass, swap)) {
+        pair = HmassSmass_INPUTS;  // Enthalpy in J/kg, Entropy in J/kg/K
+    } else if (match_pair(key1, key2, iHmolar, iSmolar, swap)) {
+        pair = HmolarSmolar_INPUTS;  // Enthalpy in J/mol, Entropy in J/mol/K
+    } else if (match_pair(key1, key2, iSmass, iUmass, swap)) {
+        pair = SmassUmass_INPUTS;  ///< Entropy in J/kg/K, Internal energy in J/kg
+    } else if (match_pair(key1, key2, iSmolar, iUmolar, swap)) {
+        pair = SmolarUmolar_INPUTS;  ///< Entropy in J/mol/K, Internal energy in J/mol
+    } else {
+        pair = INPUT_PAIR_INVALID;
+        return pair;
+    }
+
+    if (!swap) {
+        out1 = value1;
+        out2 = value2;
+    } else {
+        out1 = value2;
+        out2 = value1;
+    }
+    return pair;
+};
+
+/// Get the input pair index associated with its string representation
+input_pairs get_input_pair_index(const std::string& input_pair_name);
+
+/// Return the short description of an input pair key ("DmolarT_INPUTS" for instance)
+const std::string& get_input_pair_short_desc(input_pairs pair);
+
+/// Return the long description of an input pair key ("Molar density in mol/m^3, Temperature in K" for instance)
+const std::string& get_input_pair_long_desc(input_pairs pair);
+
+/// Split an input pair into parameters for the two parts that form the pair
+void split_input_pair(input_pairs pair, parameters& p1, parameters& p2);
+
+extern std::string get_mixture_binary_pair_data(const std::string& CAS1, const std::string& CAS2, const std::string& param);
+extern void set_mixture_binary_pair_data(const std::string& CAS1, const std::string& CAS2, const std::string& param, const double val);
+extern std::string get_mixture_binary_pair_pcsaft(const std::string& CAS1, const std::string& CAS2, const std::string& param);
+extern void set_mixture_binary_pair_pcsaft(const std::string& CAS1, const std::string& CAS2, const std::string& param, const double val);
+
+/// The structure is taken directly from the AbstractState class.
+// !! If you add a parameter, update the map in the corresponding CPP file !!
+enum backend_families
+{
+    INVALID_BACKEND_FAMILY = 0,
+    HEOS_BACKEND_FAMILY,
+    REFPROP_BACKEND_FAMILY,
+    INCOMP_BACKEND_FAMILY,
+    IF97_BACKEND_FAMILY,
+    TREND_BACKEND_FAMILY,
+    TTSE_BACKEND_FAMILY,
+    BICUBIC_BACKEND_FAMILY,
+    SRK_BACKEND_FAMILY,
+    PR_BACKEND_FAMILY,
+    VTPR_BACKEND_FAMILY,
+    PCSAFT_BACKEND_FAMILY
+};
+enum backends
+{
+    INVALID_BACKEND = 0,
+    HEOS_BACKEND_PURE,
+    HEOS_BACKEND_MIX,
+    REFPROP_BACKEND_PURE,
+    REFPROP_BACKEND_MIX,
+    INCOMP_BACKEND,
+    IF97_BACKEND,
+    TREND_BACKEND,
+    TTSE_BACKEND,
+    BICUBIC_BACKEND,
+    SRK_BACKEND,
+    PR_BACKEND,
+    VTPR_BACKEND,
+    PCSAFT_BACKEND
+};
+
+/// Convert a string into the enum values
+void extract_backend_families(std::string backend_string, backend_families& f1, backend_families& f2);
+void extract_backend_families_string(std::string backend_string, backend_families& f1, std::string& f2);
+std::string get_backend_string(backends backend);
+
+#if !defined(NO_FMTLIB) && FMT_VERSION >= 90000
+/// Allows enums to be formatted
+static int format_as(parameters parameter) {
+    return fmt::underlying(parameter);
+}
+
+static int format_as(phases phase) {
+    return fmt::underlying(phase);
+}
+
+static int format_as(schemes scheme) {
+    return fmt::underlying(scheme);
+}
+
+static int format_as(composition_types type) {
+    return fmt::underlying(type);
+}
+
+static int format_as(fluid_types type) {
+    return fmt::underlying(type);
+}
+
+static int format_as(input_pairs pair) {
+    return fmt::underlying(pair);
+}
+
+static int format_as(backend_families family) {
+    return fmt::underlying(family);
+}
+
+static int format_as(backends backend) {
+    return fmt::underlying(backend);
+}
+#endif
+
+} /* namespace CoolProp */
+#endif /* DATASTRUCTURES_H_ */
```

## CoolProp/include/Exceptions.h

 * *Ordering differences only*

```diff
@@ -1,75 +1,75 @@
-
-
-#ifndef CPEXCEPTIONS_H
-#define CPEXCEPTIONS_H
-
-#include <exception>
-#include <iostream>
-
-namespace CoolProp {
-
-class CoolPropBaseError : public std::exception
-{
-   public:
-    enum ErrCode
-    {
-        eNotImplemented,
-        eSolution,
-        eAttribute,
-        eOutOfRange,
-        eValue,
-        eWrongFluid,
-        eComposition,
-        eInput,
-        eNotAvailable,
-        eHandle,
-        eKey,
-        eUnableToLoad,
-        eDirectorySize
-    };
-    CoolPropBaseError(const std::string& err, ErrCode code) throw() : m_code(code), m_err(err) {}
-    ~CoolPropBaseError() throw(){};
-    virtual const char* what() const throw() {
-        return m_err.c_str();
-    }
-    ErrCode code() {
-        return m_code;
-    }
-
-   private:
-    ErrCode m_code;
-    std::string m_err;
-};
-
-template <CoolPropBaseError::ErrCode errcode>
-class CoolPropError : public CoolPropBaseError
-{
-   public:
-    CoolPropError(const std::string& err = "", ErrCode ecode = errcode) throw() : CoolPropBaseError(err, ecode) {}
-};
-
-typedef CoolPropError<CoolPropBaseError::eNotImplemented> NotImplementedError;
-typedef CoolPropError<CoolPropBaseError::eSolution> SolutionError;
-typedef CoolPropError<CoolPropBaseError::eAttribute> AttributeError;
-typedef CoolPropError<CoolPropBaseError::eOutOfRange> OutOfRangeError;
-typedef CoolPropError<CoolPropBaseError::eValue> ValueError;
-typedef CoolPropError<CoolPropBaseError::eKey> KeyError;
-typedef CoolPropError<CoolPropBaseError::eHandle> HandleError;
-typedef CoolPropError<CoolPropBaseError::eUnableToLoad> UnableToLoadError;
-typedef CoolPropError<CoolPropBaseError::eDirectorySize> DirectorySizeError;
-
-// ValueError specializations
-template <CoolPropBaseError::ErrCode errcode>
-class ValueErrorSpec : public ValueError
-{
-   public:
-    ValueErrorSpec(const std::string& err = "", ErrCode ecode = errcode) throw() : ValueError(err, ecode) {}
-};
-
-typedef ValueErrorSpec<CoolPropBaseError::eWrongFluid> WrongFluidError;
-typedef ValueErrorSpec<CoolPropBaseError::eComposition> CompositionError;
-typedef ValueErrorSpec<CoolPropBaseError::eInput> InputError;
-typedef ValueErrorSpec<CoolPropBaseError::eNotAvailable> NotAvailableError;
-
-}; /* namespace CoolProp */
-#endif
+
+
+#ifndef CPEXCEPTIONS_H
+#define CPEXCEPTIONS_H
+
+#include <exception>
+#include <iostream>
+
+namespace CoolProp {
+
+class CoolPropBaseError : public std::exception
+{
+   public:
+    enum ErrCode
+    {
+        eNotImplemented,
+        eSolution,
+        eAttribute,
+        eOutOfRange,
+        eValue,
+        eWrongFluid,
+        eComposition,
+        eInput,
+        eNotAvailable,
+        eHandle,
+        eKey,
+        eUnableToLoad,
+        eDirectorySize
+    };
+    CoolPropBaseError(const std::string& err, ErrCode code) throw() : m_code(code), m_err(err) {}
+    ~CoolPropBaseError() throw(){};
+    virtual const char* what() const throw() {
+        return m_err.c_str();
+    }
+    ErrCode code() {
+        return m_code;
+    }
+
+   private:
+    ErrCode m_code;
+    std::string m_err;
+};
+
+template <CoolPropBaseError::ErrCode errcode>
+class CoolPropError : public CoolPropBaseError
+{
+   public:
+    CoolPropError(const std::string& err = "", ErrCode ecode = errcode) throw() : CoolPropBaseError(err, ecode) {}
+};
+
+typedef CoolPropError<CoolPropBaseError::eNotImplemented> NotImplementedError;
+typedef CoolPropError<CoolPropBaseError::eSolution> SolutionError;
+typedef CoolPropError<CoolPropBaseError::eAttribute> AttributeError;
+typedef CoolPropError<CoolPropBaseError::eOutOfRange> OutOfRangeError;
+typedef CoolPropError<CoolPropBaseError::eValue> ValueError;
+typedef CoolPropError<CoolPropBaseError::eKey> KeyError;
+typedef CoolPropError<CoolPropBaseError::eHandle> HandleError;
+typedef CoolPropError<CoolPropBaseError::eUnableToLoad> UnableToLoadError;
+typedef CoolPropError<CoolPropBaseError::eDirectorySize> DirectorySizeError;
+
+// ValueError specializations
+template <CoolPropBaseError::ErrCode errcode>
+class ValueErrorSpec : public ValueError
+{
+   public:
+    ValueErrorSpec(const std::string& err = "", ErrCode ecode = errcode) throw() : ValueError(err, ecode) {}
+};
+
+typedef ValueErrorSpec<CoolPropBaseError::eWrongFluid> WrongFluidError;
+typedef ValueErrorSpec<CoolPropBaseError::eComposition> CompositionError;
+typedef ValueErrorSpec<CoolPropBaseError::eInput> InputError;
+typedef ValueErrorSpec<CoolPropBaseError::eNotAvailable> NotAvailableError;
+
+}; /* namespace CoolProp */
+#endif
```

## CoolProp/include/Helmholtz.h

 * *Ordering differences only*

```diff
@@ -1,1410 +1,1410 @@
-
-#ifndef HELMHOLTZ_H
-#define HELMHOLTZ_H
-
-#include <vector>
-#include "rapidjson_include.h"
-//#include "Eigen/Core"
-#include "time.h"
-#include "CachedElement.h"
-#include "Backends/Cubics/GeneralizedCubic.h"
-#include "crossplatform_shared_ptr.h"
-
-namespace CoolProp {
-
-// #############################################################################
-// #############################################################################
-// #############################################################################
-//                                RESIDUAL TERMS
-// #############################################################################
-// #############################################################################
-// #############################################################################
-
-#define LIST_OF_DERIVATIVE_VARIABLES   \
-    X(alphar)                          \
-    X(dalphar_ddelta)                  \
-    X(dalphar_dtau)                    \
-    X(d2alphar_ddelta2)                \
-    X(d2alphar_dtau2)                  \
-    X(d2alphar_ddelta_dtau)            \
-    X(d3alphar_ddelta3)                \
-    X(d3alphar_ddelta_dtau2)           \
-    X(d3alphar_ddelta2_dtau)           \
-    X(d3alphar_dtau3)                  \
-    X(d4alphar_ddelta4)                \
-    X(d4alphar_ddelta3_dtau)           \
-    X(d4alphar_ddelta2_dtau2)          \
-    X(d4alphar_ddelta_dtau3)           \
-    X(d4alphar_dtau4)                  \
-    X(delta_x_dalphar_ddelta)          \
-    X(tau_x_dalphar_dtau)              \
-    X(delta2_x_d2alphar_ddelta2)       \
-    X(deltatau_x_d2alphar_ddelta_dtau) \
-    X(tau2_x_d2alphar_dtau2)
-
-struct HelmholtzDerivatives
-{
-#define X(name) CoolPropDbl name;
-    LIST_OF_DERIVATIVE_VARIABLES
-#undef X
-    CoolPropDbl tau, delta, T_red, rhomolar_red;
-
-    void reset(CoolPropDbl v) {
-#define X(name) name = v;
-        LIST_OF_DERIVATIVE_VARIABLES
-#undef X
-    }
-    HelmholtzDerivatives operator+(const HelmholtzDerivatives& other) const {
-        HelmholtzDerivatives _new;
-#define X(name) _new.name = name + other.name;
-        LIST_OF_DERIVATIVE_VARIABLES
-#undef X
-        return _new;
-    }
-    HelmholtzDerivatives operator*(const CoolPropDbl& other) const {
-        HelmholtzDerivatives _new;
-#define X(name) _new.name = name * other;
-        LIST_OF_DERIVATIVE_VARIABLES
-#undef X
-        return _new;
-    }
-    HelmholtzDerivatives() {
-        reset(0.0);
-        T_red = _HUGE;
-        rhomolar_red = _HUGE;
-    };
-    /// Retrieve a single value based on the number of derivatives with respect to tau and delta
-    double get(std::size_t itau, std::size_t idelta) {
-        if (itau == 0) {
-            if (idelta == 0) {
-                return alphar;
-            } else if (idelta == 1) {
-                return dalphar_ddelta;
-            } else if (idelta == 2) {
-                return d2alphar_ddelta2;
-            } else if (idelta == 3) {
-                return d3alphar_ddelta3;
-            } else if (idelta == 4) {
-                return d4alphar_ddelta4;
-            } else {
-                throw ValueError();
-            }
-        } else if (itau == 1) {
-            if (idelta == 0) {
-                return dalphar_dtau;
-            } else if (idelta == 1) {
-                return d2alphar_ddelta_dtau;
-            } else if (idelta == 2) {
-                return d3alphar_ddelta2_dtau;
-            } else if (idelta == 3) {
-                return d4alphar_ddelta3_dtau;
-            } else {
-                throw ValueError();
-            }
-        } else if (itau == 2) {
-            if (idelta == 0) {
-                return d2alphar_dtau2;
-            } else if (idelta == 1) {
-                return d3alphar_ddelta_dtau2;
-            } else if (idelta == 2) {
-                return d4alphar_ddelta2_dtau2;
-            } else {
-                throw ValueError();
-            }
-        } else if (itau == 3) {
-            if (idelta == 0) {
-                return d3alphar_dtau3;
-            } else if (idelta == 1) {
-                return d4alphar_ddelta_dtau3;
-            } else {
-                throw ValueError();
-            }
-        } else if (itau == 4) {
-            if (idelta == 0) {
-                return d4alphar_dtau4;
-            } else {
-                throw ValueError();
-            }
-        } else {
-            throw ValueError();
-        }
-    }
-};
-#undef LIST_OF_DERIVATIVE_VARIABLES
-
-/// The base class class for the Helmholtz energy terms
-/**
-
- Residual Helmholtz Energy Terms:
-
- Term                               | Helmholtz Energy Contribution
- ----------                         | ------------------------------
- ResidualHelmholtzPower             | \f$ \alpha^r=\left\lbrace\begin{array}{cc}\displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} & l_i=0\\ \displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} \exp(-\delta^{l_i}) & l_i\neq 0\end{array}\right.\f$
- ResidualHelmholtzExponential       | \f$ \alpha^r=\displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} \exp(-\gamma_i\delta^{l_i}) \f$
- ResidualHelmholtzLemmon2005        | \f$ \alpha^r=\displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} \exp(-\delta^{l_i}-\tau^{m_i})\f$
- ResidualHelmholtzGaussian          | \f$ \alpha^r=\displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} \exp(-\eta_i(\delta-\epsilon_i)^2-\beta_i(\tau-\gamma_i)^2)\f$
- ResidualHelmholtzGERG2008Gaussian  | \f$ \alpha^r=\displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} \exp(-\eta_i(\delta-\epsilon_i)^2-\beta_i(\delta-\gamma_i))\f$
- ResidualHelmholtzNonAnalytic       | \f$ \begin{array}{c}\alpha^r&=&\displaystyle\sum_i n_i \Delta^{b_i}\delta\psi \\ \Delta & = & \theta^2+B_i[(\delta-1)^2]^{a_i}\\ \theta & = & (1-\tau)+A_i[(\delta-1)^2]^{1/(2\beta_i)}\\ \psi & = & \exp(-C_i(\delta-1)^2-D_i(\tau-1)^2) \end{array}\f$
- ResidualHelmholtzSAFTAssociating   | \f$ \alpha^r = am\left(\ln X-\frac{X}{2}+\frac{1}{2}\right); \f$
-
-
- Ideal-Gas Helmholtz Energy Terms:
-
- Term                                        | Helmholtz Energy Contribution
- ----------                                  | ------------------------------
- IdealHelmholtzLead                          | \f$ \alpha^0 = n_1 + n_2\tau + \ln\delta \f$
- IdealHelmholtzEnthalpyEntropyOffset         | \f$ \alpha^0 = \displaystyle\frac{\Delta s}{R_u/M}+\frac{\Delta h}{(R_u/M)T}\tau \f$
- IdealHelmholtzLogTau                        | \f$ \alpha^0 = n_1\log\tau \f$
- IdealHelmholtzPower                         | \f$ \alpha^0 = \displaystyle\sum_i n_i\tau^{t_i} \f$
- IdealHelmholtzPlanckEinsteinGeneralized     | \f$ \alpha^0 = \displaystyle\sum_i n_i\log[c_i+d_i\exp(\theta_i\tau)] \f$
- */
-class BaseHelmholtzTerm
-{
-   public:
-    BaseHelmholtzTerm(){};
-    virtual ~BaseHelmholtzTerm(){};
-
-    /// Returns the base, non-dimensional, Helmholtz energy term (no derivatives) [-]
-    /** @param tau Reciprocal reduced temperature where \f$\tau=T_c / T\f$
-     *  @param delta Reduced density where \f$\delta = \rho / \rho_c \f$
-     */
-    virtual CoolPropDbl base(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
-        HelmholtzDerivatives deriv;
-        all(tau, delta, deriv);
-        return deriv.alphar;
-    };
-    /// Returns the first partial derivative of Helmholtz energy term with respect to tau [-]
-    /** @param tau Reciprocal reduced temperature where \f$\tau=T_c / T\f$
-     *  @param delta Reduced density where \f$\delta = \rho / \rho_c \f$
-     */
-    virtual CoolPropDbl dTau(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
-        HelmholtzDerivatives deriv;
-        all(tau, delta, deriv);
-        return deriv.dalphar_dtau;
-    };
-    /// Returns the second partial derivative of Helmholtz energy term with respect to tau [-]
-    /** @param tau Reciprocal reduced temperature where \f$\tau=T_c / T\f$
-     *  @param delta Reduced density where \f$\delta = \rho / \rho_c \f$
-     */
-    virtual CoolPropDbl dTau2(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
-        HelmholtzDerivatives deriv;
-        all(tau, delta, deriv);
-        return deriv.d2alphar_dtau2;
-    };
-    /// Returns the second mixed partial derivative (delta1,dtau1) of Helmholtz energy term with respect to delta and tau [-]
-    /** @param tau Reciprocal reduced temperature where \f$\tau=T_c / T\f$
-     *  @param delta Reduced density where \f$\delta = \rho / \rho_c \f$
-     */
-    virtual CoolPropDbl dDelta_dTau(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
-        HelmholtzDerivatives deriv;
-        all(tau, delta, deriv);
-        return deriv.d2alphar_ddelta_dtau;
-    };
-    /// Returns the first partial derivative of Helmholtz energy term with respect to delta [-]
-    /** @param tau Reciprocal reduced temperature where \f$\tau=T_c / T\f$
-     *  @param delta Reduced density where \f$\delta = \rho / \rho_c \f$
-     */
-    virtual CoolPropDbl dDelta(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
-        HelmholtzDerivatives deriv;
-        all(tau, delta, deriv);
-        return deriv.dalphar_ddelta;
-    };
-    /// Returns the second partial derivative of Helmholtz energy term with respect to delta [-]
-    /** @param tau Reciprocal reduced temperature where \f$\tau=T_c / T\f$
-     *  @param delta Reduced density where \f$\delta = \rho / \rho_c \f$
-     */
-    virtual CoolPropDbl dDelta2(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
-        HelmholtzDerivatives deriv;
-        all(tau, delta, deriv);
-        return deriv.d2alphar_ddelta2;
-    };
-    /// Returns the third mixed partial derivative (delta2,dtau1) of Helmholtz energy term with respect to delta and tau [-]
-    /** @param tau Reciprocal reduced temperature where \f$\tau=T_c / T\f$
-     *  @param delta Reduced density where \f$\delta = \rho / \rho_c \f$
-     */
-    virtual CoolPropDbl dDelta2_dTau(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
-        HelmholtzDerivatives deriv;
-        all(tau, delta, deriv);
-        return deriv.d3alphar_ddelta2_dtau;
-    };
-    /// Returns the third mixed partial derivative (delta1,dtau2) of Helmholtz energy term with respect to delta and tau [-]
-    /** @param tau Reciprocal reduced temperature where \f$\tau=T_c / T\f$
-     *  @param delta Reduced density where \f$\delta = \rho / \rho_c \f$
-     */
-    virtual CoolPropDbl dDelta_dTau2(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
-        HelmholtzDerivatives deriv;
-        all(tau, delta, deriv);
-        return deriv.d3alphar_ddelta_dtau2;
-    };
-    /// Returns the third partial derivative of Helmholtz energy term with respect to tau [-]
-    /** @param tau Reciprocal reduced temperature where \f$\tau=T_c / T\f$
-     *  @param delta Reduced density where \f$\delta = \rho / \rho_c \f$
-     */
-    virtual CoolPropDbl dTau3(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
-        HelmholtzDerivatives deriv;
-        all(tau, delta, deriv);
-        return deriv.d3alphar_dtau3;
-    };
-    /// Returns the third partial derivative of Helmholtz energy term with respect to delta [-]
-    /** @param tau Reciprocal reduced temperature where \f$\tau=T_c / T\f$
-     *  @param delta Reduced density where \f$\delta = \rho / \rho_c \f$
-     */
-    virtual CoolPropDbl dDelta3(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
-        HelmholtzDerivatives deriv;
-        all(tau, delta, deriv);
-        return deriv.d3alphar_ddelta3;
-    };
-    /// Returns the fourth partial derivative of Helmholtz energy term with respect to tau [-]
-    /** @param tau Reciprocal reduced temperature where \f$\tau=T_c / T\f$
-     *  @param delta Reduced density where \f$\delta = \rho / \rho_c \f$
-     */
-    virtual CoolPropDbl dTau4(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
-        HelmholtzDerivatives deriv;
-        all(tau, delta, deriv);
-        return deriv.d4alphar_dtau4;
-    };
-    virtual CoolPropDbl dDelta_dTau3(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
-        HelmholtzDerivatives deriv;
-        all(tau, delta, deriv);
-        return deriv.d4alphar_ddelta_dtau3;
-    };
-    virtual CoolPropDbl dDelta2_dTau2(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
-        HelmholtzDerivatives deriv;
-        all(tau, delta, deriv);
-        return deriv.d4alphar_ddelta2_dtau2;
-    };
-    virtual CoolPropDbl dDelta3_dTau(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
-        HelmholtzDerivatives deriv;
-        all(tau, delta, deriv);
-        return deriv.d4alphar_ddelta3_dtau;
-    };
-    virtual CoolPropDbl dDelta4(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
-        HelmholtzDerivatives deriv;
-        all(tau, delta, deriv);
-        return deriv.d4alphar_ddelta4;
-    };
-
-    virtual void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw() = 0;
-};
-
-struct ResidualHelmholtzGeneralizedExponentialElement
-{
-    /// These variables are for the n*delta^d_i*tau^t_i part
-    CoolPropDbl n, d, t;
-    /// These variables are for the exp(u) part
-    /// u is given by -c*delta^l_i-omega*tau^m_i-eta1*(delta-epsilon1)-eta2*(delta-epsilon2)^2-beta1*(tau-gamma1)-beta2*(tau-gamma2)^2
-    CoolPropDbl c, l_double, omega, m_double, eta1, epsilon1, eta2, epsilon2, beta1, gamma1, beta2, gamma2;
-    /// If l_i or m_i are integers, we will store them as integers in order to call pow(double, int) rather than pow(double, double)
-    int l_int, m_int;
-    /// If l is an integer, store a boolean flag so we can evaluate the correct pow() function
-    bool l_is_int, m_is_int;
-
-    ResidualHelmholtzGeneralizedExponentialElement() {
-        n = 0;
-        d = 0;
-        t = 0;
-        c = 0;
-        l_double = 0;
-        omega = 0;
-        m_double = 0;
-        eta1 = 0;
-        epsilon1 = 0;
-        eta2 = 0;
-        epsilon2 = 0;
-        beta1 = 0;
-        gamma1 = 0;
-        beta2 = 0;
-        gamma2 = 0;
-        l_int = 0;
-        m_int = 0;
-        l_is_int = false;
-        m_is_int = true;
-    };
-};
-/** \brief A generalized residual helmholtz energy container that can deal with a wide range of terms which can be converted to this general form
- *
- * \f$ \alpha^r=\sum_i n_i \delta^{d_i} \tau^{t_i}\exp(u_i) \f$
- *
- * where \f$ u_i \f$ is given by
- *
- * \f$ u_i = -c_i\delta^{l_i}-\omega_i\tau^{m_i}-\eta_{1,i}(\delta-\epsilon_{1,i})-\eta_{2,i}(\delta-\epsilon_{2,i})^2-\beta_{1,i}(\tau-\gamma_{1,i})-\beta_{2,i}(\tau-\gamma_{2,i})^2 \f$
- */
-class ResidualHelmholtzGeneralizedExponential : public BaseHelmholtzTerm
-{
-
-   public:
-    bool delta_li_in_u, tau_mi_in_u, eta1_in_u, eta2_in_u, beta1_in_u, beta2_in_u, finished;
-    std::vector<CoolPropDbl> s;
-    std::size_t N;
-
-    // These variables are for the exp(u) part
-    // u is given by -c*delta^l_i-omega*tau^m_i-eta1*(delta-epsilon1)-eta2*(delta-epsilon2)^2-beta1*(tau-gamma1)-beta2*(tau-gamma2)^2
-    std::vector<double> n, d, t, c, l_double, omega, m_double, eta1, epsilon1, eta2, epsilon2, beta1, gamma1, beta2, gamma2;
-    // If l_i or m_i are integers, we will store them as integers in order to call pow(double, int) rather than pow(double, double)
-    std::vector<int> l_int, m_int;
-
-    //Eigen::ArrayXd uE, du_ddeltaE, du_dtauE, d2u_ddelta2E, d2u_dtau2E, d3u_ddelta3E, d3u_dtau3E;
-
-    std::vector<ResidualHelmholtzGeneralizedExponentialElement> elements;
-    // Default Constructor
-    ResidualHelmholtzGeneralizedExponential()
-      : delta_li_in_u(false), tau_mi_in_u(false), eta1_in_u(false), eta2_in_u(false), beta1_in_u(false), beta2_in_u(false), finished(false), N(0){};
-    /** \brief Add and convert an old-style power (polynomial) term to generalized form
-	 *
-	 * Term of the format
-	 * \f$ \alpha^r=\left\lbrace\begin{array}{cc}\displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} & l_i=0\\ \displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} \exp(-\delta^{l_i}) & l_i\neq 0\end{array}\right.\f$
-	 */
-    void add_Power(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& d, const std::vector<CoolPropDbl>& t,
-                   const std::vector<CoolPropDbl>& l) {
-        for (std::size_t i = 0; i < n.size(); ++i) {
-            ResidualHelmholtzGeneralizedExponentialElement el;
-            el.n = n[i];
-            el.d = d[i];
-            el.t = t[i];
-            el.l_double = l[i];
-            el.l_int = (int)el.l_double;
-            if (el.l_double > 0)
-                el.c = 1.0;
-            else
-                el.c = 0.0;
-            elements.push_back(el);
-        }
-        delta_li_in_u = true;
-    };
-    /** \brief Add and convert an old-style exponential term to generalized form
-	 *
-	 * Term of the format
-	 * \f$ \alpha^r=\displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} \exp(-g_i\delta^{l_i}) \f$
-	 */
-    void add_Exponential(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& d, const std::vector<CoolPropDbl>& t,
-                         const std::vector<CoolPropDbl>& g, const std::vector<CoolPropDbl>& l) {
-        for (std::size_t i = 0; i < n.size(); ++i) {
-            ResidualHelmholtzGeneralizedExponentialElement el;
-            el.n = n[i];
-            el.d = d[i];
-            el.t = t[i];
-            el.c = g[i];
-            el.l_double = l[i];
-            el.l_int = (int)el.l_double;
-            elements.push_back(el);
-        }
-        delta_li_in_u = true;
-    }
-    /** \brief Add and convert an old-style Gaussian term to generalized form
-	 *
-	 * Term of the format
-	 * \f$ \alpha^r=\displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} \exp(-\eta_i(\delta-\epsilon_i)^2-\beta_i(\tau-\gamma_i)^2)\f$
-	 */
-    void add_Gaussian(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& d, const std::vector<CoolPropDbl>& t,
-                      const std::vector<CoolPropDbl>& eta, const std::vector<CoolPropDbl>& epsilon, const std::vector<CoolPropDbl>& beta,
-                      const std::vector<CoolPropDbl>& gamma) {
-        for (std::size_t i = 0; i < n.size(); ++i) {
-            ResidualHelmholtzGeneralizedExponentialElement el;
-            el.n = n[i];
-            el.d = d[i];
-            el.t = t[i];
-            el.eta2 = eta[i];
-            el.epsilon2 = epsilon[i];
-            el.beta2 = beta[i];
-            el.gamma2 = gamma[i];
-            elements.push_back(el);
-        }
-        eta2_in_u = true;
-        beta2_in_u = true;
-    };
-    /** \brief Add and convert an old-style Gaussian term from GERG 2008 natural gas model to generalized form
-	 *
-	 * Term of the format
-	 * \f$ \alpha^r=\displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} \exp(-\eta_i(\delta-\epsilon_i)^2-\beta_i(\delta-\gamma_i))\f$
-	 */
-    void add_GERG2008Gaussian(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& d, const std::vector<CoolPropDbl>& t,
-                              const std::vector<CoolPropDbl>& eta, const std::vector<CoolPropDbl>& epsilon, const std::vector<CoolPropDbl>& beta,
-                              const std::vector<CoolPropDbl>& gamma) {
-        for (std::size_t i = 0; i < n.size(); ++i) {
-            ResidualHelmholtzGeneralizedExponentialElement el;
-            el.n = n[i];
-            el.d = d[i];
-            el.t = t[i];
-            el.eta2 = eta[i];
-            el.epsilon2 = epsilon[i];
-            el.eta1 = beta[i];
-            el.epsilon1 = gamma[i];
-            elements.push_back(el);
-        }
-        eta2_in_u = true;
-        eta1_in_u = true;
-    };
-    /** \brief Add and convert a term from Lemmon and Jacobsen (2005) used for R125
-	 *
-	 * Term of the format
-	 * \f$ \alpha^r=\displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} \exp(-\delta^{l_i}-\tau^{m_i})\f$
-	 */
-    void add_Lemmon2005(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& d, const std::vector<CoolPropDbl>& t,
-                        const std::vector<CoolPropDbl>& l, const std::vector<CoolPropDbl>& m) {
-        for (std::size_t i = 0; i < n.size(); ++i) {
-            ResidualHelmholtzGeneralizedExponentialElement el;
-            el.n = n[i];
-            el.d = d[i];
-            el.t = t[i];
-            el.c = 1.0;
-            el.omega = 1.0;
-            el.l_double = l[i];
-            el.m_double = m[i];
-            el.l_int = (int)el.l_double;
-            el.m_int = (int)el.m_double;
-            elements.push_back(el);
-        }
-        delta_li_in_u = true;
-        tau_mi_in_u = true;
-    };
-
-    void finish() {
-        n.resize(elements.size());
-        d.resize(elements.size());
-        t.resize(elements.size());
-        c.resize(elements.size());
-        omega.resize(elements.size());
-        l_double.resize(elements.size());
-        l_int.resize(elements.size());
-        m_double.resize(elements.size());
-        m_int.resize(elements.size());
-        epsilon2.resize(elements.size());
-        eta2.resize(elements.size());
-        gamma2.resize(elements.size());
-        beta2.resize(elements.size());
-
-        for (std::size_t i = 0; i < elements.size(); ++i) {
-            n[i] = elements[i].n;
-            d[i] = elements[i].d;
-            t[i] = elements[i].t;
-            c[i] = elements[i].c;
-            omega[i] = elements[i].omega;
-            l_double[i] = elements[i].l_double;
-            l_int[i] = elements[i].l_int;
-            m_double[i] = elements[i].m_double;
-            m_int[i] = elements[i].m_int;
-            epsilon2[i] = elements[i].epsilon2;
-            eta2[i] = elements[i].eta2;
-            gamma2[i] = elements[i].gamma2;
-            beta2[i] = elements[i].beta2;
-
-            // See if l is an integer, and store a flag if it is
-            elements[i].l_is_int = (std::abs(static_cast<long>(elements[i].l_double) - elements[i].l_double) < 1e-14);
-        }
-        //        uE.resize(elements.size());
-        //        du_ddeltaE.resize(elements.size());
-        //        du_dtauE.resize(elements.size());
-        //        d2u_ddelta2E.resize(elements.size());
-        //        d2u_dtau2E.resize(elements.size());
-        //        d3u_ddelta3E.resize(elements.size());
-        //        d3u_dtau3E.resize(elements.size());
-
-        finished = true;
-    };
-
-    void to_json(rapidjson::Value& el, rapidjson::Document& doc);
-
-    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
-    //void allEigen(const CoolPropDbl &tau, const CoolPropDbl &delta, HelmholtzDerivatives &derivs) throw();
-};
-
-struct ResidualHelmholtzNonAnalyticElement
-{
-    CoolPropDbl n, a, b, beta, A, B, C, D;
-};
-class ResidualHelmholtzNonAnalytic : public BaseHelmholtzTerm
-{
-
-   public:
-    std::size_t N;
-    std::vector<CoolPropDbl> s;
-    std::vector<ResidualHelmholtzNonAnalyticElement> elements;
-    /// Default Constructor
-    ResidualHelmholtzNonAnalytic() {
-        N = 0;
-    };
-    /// Destructor. No implementation
-    ~ResidualHelmholtzNonAnalytic(){};
-    /// Constructor
-    ResidualHelmholtzNonAnalytic(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& a, const std::vector<CoolPropDbl>& b,
-                                 const std::vector<CoolPropDbl>& beta, const std::vector<CoolPropDbl>& A, const std::vector<CoolPropDbl>& B,
-                                 const std::vector<CoolPropDbl>& C, const std::vector<CoolPropDbl>& D) {
-        N = n.size();
-        s.resize(N);
-        for (std::size_t i = 0; i < n.size(); ++i) {
-            ResidualHelmholtzNonAnalyticElement el;
-            el.n = n[i];
-            el.a = a[i];
-            el.b = b[i];
-            el.beta = beta[i];
-            el.A = A[i];
-            el.B = B[i];
-            el.C = C[i];
-            el.D = D[i];
-            elements.push_back(el);
-        }
-    };
-    void to_json(rapidjson::Value& el, rapidjson::Document& doc);
-    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
-};
-
-class ResidualHelmholtzGeneralizedCubic : public BaseHelmholtzTerm
-{
-   protected:
-    shared_ptr<AbstractCubic> m_abstractcubic;
-    std::vector<double> z;  /// Vector of mole fractions, will be initialized to [1.0] since this is a pure fluid
-   public:
-    bool enabled;
-
-    /// Default Constructor
-    ResidualHelmholtzGeneralizedCubic() {
-        enabled = false;
-    };
-    /// Constructor given an abstract cubic instance
-    ResidualHelmholtzGeneralizedCubic(shared_ptr<AbstractCubic>& ac) : m_abstractcubic(ac) {
-        enabled = true;
-        z = std::vector<double>(1, 1);  // Init the vector to [1.0]
-    };
-
-    void to_json(rapidjson::Value& el, rapidjson::Document& doc);
-    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
-};
-
-class ResidualHelmholtzGaoB : public BaseHelmholtzTerm
-{
-   protected:
-    std::vector<double> n, t, d, eta, beta, gamma, epsilon, b;
-
-   public:
-    bool enabled;
-
-    /// Default Constructor
-    ResidualHelmholtzGaoB() {
-        enabled = false;
-    };
-
-    /// Constructor given coefficients
-    ResidualHelmholtzGaoB(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& t, const std::vector<CoolPropDbl>& d,
-                          const std::vector<CoolPropDbl>& eta, const std::vector<CoolPropDbl>& beta, const std::vector<CoolPropDbl>& gamma,
-                          const std::vector<CoolPropDbl>& epsilon, const std::vector<CoolPropDbl>& b)
-      : n(n), t(t), d(d), eta(eta), beta(beta), gamma(gamma), epsilon(epsilon), b(b) {
-        enabled = true;
-    };
-
-    void to_json(rapidjson::Value& el, rapidjson::Document& doc);
-    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
-};
-
-/// The generalized Lee-Kesler formulation of Xiang & Deiters: doi:10.1016/j.ces.2007.11.029
-class ResidualHelmholtzXiangDeiters : public BaseHelmholtzTerm
-{
-
-   public:
-    bool enabled;
-    ResidualHelmholtzGeneralizedExponential phi0, phi1, phi2;
-    CoolPropDbl Tc, pc, rhomolarc, acentric, R, theta;
-    /// Default Constructor
-    ResidualHelmholtzXiangDeiters() : Tc(_HUGE), pc(_HUGE), rhomolarc(_HUGE), acentric(_HUGE), R(_HUGE), theta(_HUGE) {
-        enabled = false;
-    };
-    /// Constructor
-    ResidualHelmholtzXiangDeiters(const CoolPropDbl Tc, const CoolPropDbl pc, const CoolPropDbl rhomolarc, const CoolPropDbl acentric,
-                                  const CoolPropDbl R);
-    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
-};
-
-class ResidualHelmholtzSAFTAssociating : public BaseHelmholtzTerm
-{
-
-   protected:
-    double a, m, epsilonbar, vbarn, kappabar;
-
-    CoolPropDbl Deltabar(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
-    CoolPropDbl dDeltabar_ddelta__consttau(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
-    CoolPropDbl d2Deltabar_ddelta2__consttau(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
-    CoolPropDbl dDeltabar_dtau__constdelta(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
-    CoolPropDbl d2Deltabar_dtau2__constdelta(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
-    CoolPropDbl d2Deltabar_ddelta_dtau(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
-    CoolPropDbl d3Deltabar_dtau3__constdelta(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
-    CoolPropDbl d3Deltabar_ddelta_dtau2(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
-    CoolPropDbl d3Deltabar_ddelta3__consttau(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
-    CoolPropDbl d3Deltabar_ddelta2_dtau(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
-
-    CoolPropDbl X(const CoolPropDbl& delta, const CoolPropDbl& Deltabar) const;
-    CoolPropDbl dX_dDeltabar__constdelta(const CoolPropDbl& delta, const CoolPropDbl& Deltabar) const;
-    CoolPropDbl dX_ddelta__constDeltabar(const CoolPropDbl& delta, const CoolPropDbl& Deltabar) const;
-    CoolPropDbl dX_dtau(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
-    CoolPropDbl dX_ddelta(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
-    CoolPropDbl d2X_dtau2(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
-    CoolPropDbl d2X_ddeltadtau(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
-    CoolPropDbl d2X_ddelta2(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
-
-    CoolPropDbl d3X_dtau3(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
-    CoolPropDbl d3X_ddelta3(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
-    CoolPropDbl d3X_ddeltadtau2(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
-    CoolPropDbl d3X_ddelta2dtau(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
-
-    CoolPropDbl g(const CoolPropDbl& eta) const;
-    CoolPropDbl dg_deta(const CoolPropDbl& eta) const;
-    CoolPropDbl d2g_deta2(const CoolPropDbl& eta) const;
-    CoolPropDbl d3g_deta3(const CoolPropDbl& eta) const;
-    CoolPropDbl eta(const CoolPropDbl& delta) const;
-
-   public:
-    /// Default constructor
-    ResidualHelmholtzSAFTAssociating() : a(_HUGE), m(_HUGE), epsilonbar(_HUGE), vbarn(_HUGE), kappabar(_HUGE) {
-        disabled = true;
-    };
-
-    // Constructor
-    ResidualHelmholtzSAFTAssociating(double a, double m, double epsilonbar, double vbarn, double kappabar)
-      : a(a), m(m), epsilonbar(epsilonbar), vbarn(vbarn), kappabar(kappabar) {
-        disabled = false;
-    };
-
-    bool disabled;
-
-    //Destructor. No Implementation
-    ~ResidualHelmholtzSAFTAssociating(){};
-
-    void to_json(rapidjson::Value& el, rapidjson::Document& doc);
-
-    CoolPropDbl dTau4(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
-        return 1e99;
-    };
-    CoolPropDbl dDelta_dTau3(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
-        return 1e99;
-    };
-    CoolPropDbl dDelta2_dTau2(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
-        return 1e99;
-    };
-    CoolPropDbl dDelta3_dTau(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
-        return 1e99;
-    };
-    CoolPropDbl dDelta4(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
-        return 1e99;
-    };
-
-    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& deriv) throw();
-};
-
-class BaseHelmholtzContainer
-{
-   protected:
-    CachedElement _base, _dDelta, _dTau, _dDelta2, _dTau2, _dDelta_dTau, _dDelta3, _dDelta2_dTau, _dDelta_dTau2, _dTau3;
-    CachedElement _dDelta4, _dDelta3_dTau, _dDelta2_dTau2, _dDelta_dTau3, _dTau4;
-
-   public:
-    void clear() {
-        _base.clear();
-        _dDelta.clear();
-        _dTau.clear();
-        _dDelta2.clear();
-        _dTau2.clear();
-        _dDelta_dTau.clear();
-        _dDelta3.clear();
-        _dTau3.clear();
-        _dDelta2_dTau.clear();
-        _dDelta_dTau2.clear();
-        _dDelta4.clear();
-        _dDelta3_dTau.clear();
-        _dDelta2_dTau2.clear();
-        _dDelta_dTau3.clear();
-        _dTau4.clear();
-    };
-
-    virtual void empty_the_EOS() = 0;
-    virtual HelmholtzDerivatives all(const CoolPropDbl tau, const CoolPropDbl delta, bool cache_values) = 0;
-
-    CoolPropDbl base(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
-        if (!_base || dont_use_cache)
-            return all(tau, delta, false).alphar;
-        else
-            return _base;
-    };
-    CoolPropDbl dDelta(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
-        if (!_dDelta || dont_use_cache)
-            return all(tau, delta, false).dalphar_ddelta;
-        else
-            return _dDelta;
-    };
-    CoolPropDbl dTau(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
-        if (!_dTau || dont_use_cache)
-            return all(tau, delta, false).dalphar_dtau;
-        else
-            return _dTau;
-    };
-    CoolPropDbl dDelta2(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
-        if (!_dDelta2 || dont_use_cache)
-            return all(tau, delta, false).d2alphar_ddelta2;
-        else
-            return _dDelta2;
-    };
-    CoolPropDbl dDelta_dTau(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
-        if (!_dDelta_dTau || dont_use_cache)
-            return all(tau, delta, false).d2alphar_ddelta_dtau;
-        else
-            return _dDelta_dTau;
-    };
-    CoolPropDbl dTau2(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
-        if (!_dTau2 || dont_use_cache)
-            return all(tau, delta, false).d2alphar_dtau2;
-        else
-            return _dTau2;
-    };
-    CoolPropDbl dDelta3(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
-        if (!_dDelta3 || dont_use_cache)
-            return all(tau, delta, false).d3alphar_ddelta3;
-        else
-            return _dDelta3;
-    };
-    CoolPropDbl dDelta2_dTau(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
-        if (!_dDelta2_dTau || dont_use_cache)
-            return all(tau, delta, false).d3alphar_ddelta2_dtau;
-        else
-            return _dDelta2_dTau;
-    };
-    CoolPropDbl dDelta_dTau2(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
-        if (!_dDelta_dTau2 || dont_use_cache)
-            return all(tau, delta, false).d3alphar_ddelta_dtau2;
-        else
-            return _dDelta_dTau2;
-    };
-    CoolPropDbl dTau3(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
-        if (!_dTau3 || dont_use_cache)
-            return all(tau, delta, false).d3alphar_dtau3;
-        else
-            return _dTau3;
-    };
-    CoolPropDbl dDelta4(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
-        return all(tau, delta, false).d4alphar_ddelta4;
-    };
-    CoolPropDbl dDelta3_dTau(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
-        return all(tau, delta, false).d4alphar_ddelta3_dtau;
-    };
-    CoolPropDbl dDelta2_dTau2(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
-        return all(tau, delta, false).d4alphar_ddelta2_dtau2;
-    };
-    CoolPropDbl dDelta_dTau3(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
-        return all(tau, delta, false).d4alphar_ddelta_dtau3;
-    };
-    CoolPropDbl dTau4(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
-        return all(tau, delta, false).d4alphar_dtau4;
-    };
-};
-
-class ResidualHelmholtzContainer : public BaseHelmholtzContainer
-{
-   public:
-    ResidualHelmholtzNonAnalytic NonAnalytic;
-    ResidualHelmholtzSAFTAssociating SAFT;
-    ResidualHelmholtzGeneralizedExponential GenExp;
-    ResidualHelmholtzGeneralizedCubic cubic;
-    ResidualHelmholtzXiangDeiters XiangDeiters;
-    ResidualHelmholtzGaoB GaoB;
-
-    void empty_the_EOS() {
-        NonAnalytic = ResidualHelmholtzNonAnalytic();
-        SAFT = ResidualHelmholtzSAFTAssociating();
-        GenExp = ResidualHelmholtzGeneralizedExponential();
-        cubic = ResidualHelmholtzGeneralizedCubic();
-        XiangDeiters = ResidualHelmholtzXiangDeiters();
-        GaoB = ResidualHelmholtzGaoB();
-    };
-
-    HelmholtzDerivatives all(const CoolPropDbl tau, const CoolPropDbl delta, bool cache_values = false) {
-        HelmholtzDerivatives derivs;  // zeros out the elements
-        GenExp.all(tau, delta, derivs);
-        NonAnalytic.all(tau, delta, derivs);
-        SAFT.all(tau, delta, derivs);
-        cubic.all(tau, delta, derivs);
-        XiangDeiters.all(tau, delta, derivs);
-        GaoB.all(tau, delta, derivs);
-        if (cache_values) {
-            _base = derivs.alphar;
-            _dDelta = derivs.dalphar_ddelta;
-            _dTau = derivs.dalphar_dtau;
-            _dDelta2 = derivs.d2alphar_ddelta2;
-            _dTau2 = derivs.d2alphar_dtau2;
-            _dDelta_dTau = derivs.d2alphar_ddelta_dtau;
-            _dDelta3 = derivs.d3alphar_ddelta3;
-            _dTau3 = derivs.d3alphar_dtau3;
-            _dDelta2_dTau = derivs.d3alphar_ddelta2_dtau;
-            _dDelta_dTau2 = derivs.d3alphar_ddelta_dtau2;
-        }
-        return derivs;
-    };
-};
-
-// #############################################################################
-// #############################################################################
-// #############################################################################
-//                                 IDEAL GAS TERMS
-// #############################################################################
-// #############################################################################
-// #############################################################################
-
-/// The leading term in the EOS used to set the desired reference state
-/**
-\f[
-\alpha^0 = \log(\delta)+a_1+a_2\tau
-\f]
-*/
-class IdealHelmholtzLead : public BaseHelmholtzTerm
-{
-
-   private:
-    CoolPropDbl a1, a2;
-    bool enabled;
-
-   public:
-    // Default constructor
-    IdealHelmholtzLead() : a1(_HUGE), a2(_HUGE), enabled(false) {}
-
-    // Constructor
-    IdealHelmholtzLead(CoolPropDbl a1, CoolPropDbl a2) : a1(a1), a2(a2), enabled(true) {}
-
-    bool is_enabled() const {
-        return enabled;
-    }
-
-    void to_json(rapidjson::Value& el, rapidjson::Document& doc) {
-        el.AddMember("type", "IdealHelmholtzLead", doc.GetAllocator());
-        el.AddMember("a1", static_cast<double>(a1), doc.GetAllocator());
-        el.AddMember("a2", static_cast<double>(a2), doc.GetAllocator());
-    };
-
-    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
-};
-
-/// The term in the EOS used to shift the reference state of the fluid
-/**
-\f[
-\alpha^0 = a_1+a_2\tau
-\f]
-*/
-class IdealHelmholtzEnthalpyEntropyOffset : public BaseHelmholtzTerm
-{
-   private:
-    CoolPropDbl a1, a2;  // Use these variables internally
-    std::string reference;
-    bool enabled;
-
-   public:
-    IdealHelmholtzEnthalpyEntropyOffset() : a1(_HUGE), a2(_HUGE), enabled(false) {}
-
-    // Constructor
-    IdealHelmholtzEnthalpyEntropyOffset(CoolPropDbl a1, CoolPropDbl a2, const std::string& ref) : a1(a1), a2(a2), reference(ref), enabled(true) {}
-
-    // Set the values in the class
-    void set(CoolPropDbl a1, CoolPropDbl a2, const std::string& ref) {
-        // If it doesn't already exist, just set the values
-        if (enabled == false) {
-            this->a1 = a1;
-            this->a2 = a2;
-            enabled = true;
-        } else if (ref == "DEF") {
-            this->a1 = 0.0;
-            this->a2 = 0.0;
-            enabled = false;
-        } else {
-            // Otherwise, increment the values
-            this->a1 += a1;
-            this->a2 += a2;
-            enabled = true;
-        }
-        this->reference = ref;
-    }
-
-    bool is_enabled() const {
-        return enabled;
-    };
-
-    void to_json(rapidjson::Value& el, rapidjson::Document& doc) {
-        el.AddMember("type", "IdealHelmholtzEnthalpyEntropyOffset", doc.GetAllocator());
-        el.AddMember("a1", static_cast<double>(a1), doc.GetAllocator());
-        el.AddMember("a2", static_cast<double>(a2), doc.GetAllocator());
-    };
-    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
-};
-
-/**
-\f[
-\alpha^0 = a_1\ln\tau
-\f]
-*/
-class IdealHelmholtzLogTau : public BaseHelmholtzTerm
-{
-   private:
-    CoolPropDbl a1;
-    bool enabled;
-
-   public:
-    /// Default constructor
-    IdealHelmholtzLogTau() : a1(_HUGE), enabled(false) {}
-
-    // Constructor
-    IdealHelmholtzLogTau(CoolPropDbl a1) : a1(a1), enabled(true) {}
-
-    bool is_enabled() const {
-        return enabled;
-    };
-
-    void to_json(rapidjson::Value& el, rapidjson::Document& doc) {
-        el.AddMember("type", "IdealHelmholtzLogTau", doc.GetAllocator());
-        el.AddMember("a1", static_cast<double>(a1), doc.GetAllocator());
-    };
-    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
-};
-
-/**
-\f[
-\alpha^0 = \displaystyle\sum_i n_i\tau^{t_i}
-\f]
-*/
-class IdealHelmholtzPower : public BaseHelmholtzTerm
-{
-
-   private:
-    std::vector<CoolPropDbl> n, t;  // Use these variables internally
-    std::size_t N;
-    bool enabled;
-
-   public:
-    IdealHelmholtzPower() : N(0), enabled(false){};
-    // Constructor
-    IdealHelmholtzPower(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& t) : n(n), t(t), N(n.size()), enabled(true){};
-
-    bool is_enabled() const {
-        return enabled;
-    };
-
-    void to_json(rapidjson::Value& el, rapidjson::Document& doc) {
-        el.AddMember("type", "IdealHelmholtzPower", doc.GetAllocator());
-        cpjson::set_long_double_array("n", n, el, doc);
-        cpjson::set_long_double_array("t", t, el, doc);
-    };
-    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
-};
-
-/**
-\f[
-\alpha^0 = \displaystyle\sum_i n_i\log[c_i+d_i\exp(\theta_i\tau)]
-\f]
-
-To convert conventional Plank-Einstein forms, given by
-\f$
-\frac{c_p^0}{R} = a_k\displaystyle\frac{\left( b_k/T \right)^2\exp \left( b_k/T \right)}{\left(\exp \left(b_k/T\right) - 1 \right)^2}
-\f$
-and
-\f$
-\alpha^0 = a_k\ln \left[1 - \exp \left( \frac{-b_k\tau}{T_c} \right) \right]
-\f$
-use \f$c = 1\f$, \f$d = -1\f$, \f$n = a\f$, \f$\theta = -\displaystyle\frac{b_k}{T_c}\f$
-
-To convert the second form of Plank-Einstein terms, given by
-\f$
-\frac{c_p^0}{R} = a_k\displaystyle\frac{\left( -b_k/T \right)^2\exp \left( b_k/T \right)}{c\left(\exp \left(-b_k/T\right) + 1 \right)^2}
-\f$
-and
-\f$
-\alpha^0 = a_k\ln \left[c + \exp \left( \frac{b_k\tau}{T_c} \right) \right]
-\f$
-use \f$c = 1\f$, \f$d = 1\f$, \f$n = -a\f$, \f$\theta = \displaystyle\frac{b_k}{T_c}\f$
-
-Converting Aly-Lee tems is a bit more complex
-
-Aly-Lee starts as
-\f[\frac{c_p^0}{R_u} = A + B\left(\frac{C/T}{\sinh(C/T)}\right)^2 + D\left(\frac{E/T}{\cosh(E/T)}\right)^2\f]
-
-Constant is separated out, and handled separately.  sinh part can be expanded as
-\f[B\left(\frac{C/T}{\sinh(C/T)}\right)^2 = \frac{B(-2C/T)^2\exp(-2C/T)}{(1-\exp(-2C/T))^2}\f]
-where
-\f[n_k = B\f]
-\f[\theta_k = -\frac{2C}{T_c}\f]
-\f[c_k = 1\f]
-\f[d_k = -1\f]
-
-cosh part can be expanded as
-\f[D\left(\frac{E/T}{\cosh(E/T)}\right)^2 = \frac{D(-2E/T)^2\exp(-2E/T)}{(1+\exp(-2E/T))^2}\f]
-where
-\f[n_k = -D\f]
-\f[\theta_k = -\frac{2E}{T_c}\f]
-\f[c_k = 1\f]
-\f[d_k = 1\f]
-*/
-class IdealHelmholtzPlanckEinsteinGeneralized : public BaseHelmholtzTerm
-{
-
-   private:
-    std::vector<CoolPropDbl> n, theta, c, d;  // Use these variables internally
-    std::size_t N;
-    bool enabled;
-
-   public:
-    IdealHelmholtzPlanckEinsteinGeneralized() : N(0), enabled(false) {}
-    // Constructor with std::vector instances
-    IdealHelmholtzPlanckEinsteinGeneralized(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& theta,
-                                            const std::vector<CoolPropDbl>& c, const std::vector<CoolPropDbl>& d)
-      : n(n), theta(theta), c(c), d(d), N(n.size()), enabled(true) {}
-
-    // Extend the vectors to allow for multiple instances feeding values to this function
-    void extend(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& theta, const std::vector<CoolPropDbl>& c,
-                const std::vector<CoolPropDbl>& d) {
-        this->n.insert(this->n.end(), n.begin(), n.end());
-        this->theta.insert(this->theta.end(), theta.begin(), theta.end());
-        this->c.insert(this->c.end(), c.begin(), c.end());
-        this->d.insert(this->d.end(), d.begin(), d.end());
-        N += n.size();
-    }
-
-    bool is_enabled() const {
-        return enabled;
-    };
-
-    void to_json(rapidjson::Value& el, rapidjson::Document& doc) {
-        el.AddMember("type", "IdealHelmholtzPlanckEinsteinGeneralized", doc.GetAllocator());
-        cpjson::set_long_double_array("n", n, el, doc);
-        cpjson::set_long_double_array("theta", theta, el, doc);
-    };
-    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
-};
-
-class IdealHelmholtzCP0Constant : public BaseHelmholtzTerm
-{
-
-   private:
-    double cp_over_R, Tc, T0, tau0;  // Use these variables internally
-    bool enabled;
-
-   public:
-    /// Default constructor
-    IdealHelmholtzCP0Constant() : cp_over_R(_HUGE), Tc(_HUGE), T0(_HUGE), tau0(_HUGE) {
-        enabled = false;
-    };
-
-    /// Constructor with just a single double value
-    IdealHelmholtzCP0Constant(CoolPropDbl cp_over_R, CoolPropDbl Tc, CoolPropDbl T0) : cp_over_R(cp_over_R), Tc(Tc), T0(T0) {
-        enabled = true;
-        tau0 = Tc / T0;
-    };
-
-    /// Destructor
-    ~IdealHelmholtzCP0Constant(){};
-
-    bool is_enabled() const {
-        return enabled;
-    };
-
-    void to_json(rapidjson::Value& el, rapidjson::Document& doc) {
-        el.AddMember("type", "IdealGasHelmholtzCP0Constant", doc.GetAllocator());
-        el.AddMember("cp_over_R", cp_over_R, doc.GetAllocator());
-        el.AddMember("Tc", Tc, doc.GetAllocator());
-        el.AddMember("T0", T0, doc.GetAllocator());
-    };
-
-    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
-};
-
-class IdealHelmholtzCP0PolyT : public BaseHelmholtzTerm
-{
-   private:
-    std::vector<CoolPropDbl> c, t;
-    CoolPropDbl Tc, T0, tau0;  // Use these variables internally
-    std::size_t N;
-    bool enabled;
-
-   public:
-    IdealHelmholtzCP0PolyT() : Tc(_HUGE), T0(_HUGE), tau0(_HUGE), N(0), enabled(false) {}
-
-    /// Constructor with std::vectors
-    IdealHelmholtzCP0PolyT(const std::vector<CoolPropDbl>& c, const std::vector<CoolPropDbl>& t, double Tc, double T0)
-      : c(c), t(t), Tc(Tc), T0(T0), tau0(Tc / T0), N(c.size()), enabled(true) {
-        assert(c.size() == t.size());
-    }
-
-    void extend(const std::vector<CoolPropDbl>& c, const std::vector<CoolPropDbl>& t) {
-        this->c.insert(this->c.end(), c.begin(), c.end());
-        this->t.insert(this->t.end(), t.begin(), t.end());
-        N += c.size();
-    }
-
-    bool is_enabled() const {
-        return enabled;
-    };
-
-    void to_json(rapidjson::Value& el, rapidjson::Document& doc);
-    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
-};
-/**
-
-*/
-class IdealHelmholtzGERG2004Sinh : public BaseHelmholtzTerm
-{
-   private:
-    std::vector<CoolPropDbl> n, theta;
-    CoolPropDbl Tc, _Tr;
-    std::size_t N;
-    bool enabled;
-
-   public:
-    IdealHelmholtzGERG2004Sinh() : Tc(_HUGE), _Tr(_HUGE), N(0), enabled(false) {}
-
-    /// Constructor with std::vectors
-    IdealHelmholtzGERG2004Sinh(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& theta, double Tc)
-      : n(n), theta(theta), Tc(Tc), N(n.size()), _Tr(_HUGE), enabled(true) {
-        assert(n.size() == theta.size());
-    }
-
-    void extend(const std::vector<CoolPropDbl>& c, const std::vector<CoolPropDbl>& t) {
-        this->n.insert(this->n.end(), n.begin(), n.end());
-        this->theta.insert(this->theta.end(), theta.begin(), theta.end());
-        N += c.size();
-    }
-    void set_Tred(CoolPropDbl Tr) {
-        this->_Tr = Tr;
-    }
-
-    bool is_enabled() const {
-        return enabled;
-    };
-    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
-};
-
-class IdealHelmholtzGERG2004Cosh : public BaseHelmholtzTerm
-{
-   private:
-    std::vector<CoolPropDbl> n, theta;
-    CoolPropDbl Tc, _Tr;
-    std::size_t N;
-    bool enabled;
-
-   public:
-    IdealHelmholtzGERG2004Cosh() : Tc(_HUGE), _Tr(_HUGE), N(0), enabled(false) {}
-
-    /// Constructor with std::vectors
-    IdealHelmholtzGERG2004Cosh(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& theta, double Tc)
-      : n(n), theta(theta), Tc(Tc), N(n.size()), _Tr(_HUGE), enabled(true) {
-        assert(n.size() == theta.size());
-    }
-
-    void extend(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& theta) {
-        this->n.insert(this->n.end(), n.begin(), n.end());
-        this->theta.insert(this->theta.end(), theta.begin(), theta.end());
-        N += n.size();
-    }
-    void set_Tred(CoolPropDbl Tr) {
-        this->_Tr = Tr;
-    }
-
-    bool is_enabled() const {
-        return enabled;
-    };
-    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
-};
-
-///// Term in the ideal-gas specific heat equation that is based on Aly-Lee formulation
-///** Specific heat is of the form:
-//\f[
-//\frac{c_p^0}{R_u} = A + B\left(\frac{C/T}{\sinh(C/T)}\right)^2 + D\left(\frac{E/T}{\cosh(E/T)}\right)^2
-//\f]
-//Second partial of ideal-gas Helmholtz energy given directly by specific heat (\f$\displaystyle\alpha_{\tau\tau}^0=-\frac{1}{\tau^2}\frac{c_p^0}{R_u} \f$) - this is obtained by real gas \f$c_p\f$ relationship, and killing off residual Helmholtz terms
-//\f[
-//\alpha^0_{\tau\tau} = -\frac{A}{\tau^2} - \frac{B}{\tau^2}\left(\frac{C/T}{\sinh(C/T)}\right)^2 - \frac{D}{\tau^2}\left(\frac{E/T}{\cosh(E/T)}\right)^2
-//\f]
-//or in terms of \f$ \tau \f$:
-//\f[
-//\alpha^0_{\tau\tau} = -\frac{A}{\tau^2} - \frac{BC^2}{T_c^2}\left(\frac{1}{\sinh(C\tau/T_c)}\right)^2 - \frac{DE^2}{T_c^2}\left(\frac{1}{\cosh(E\tau/T_c)}\right)^2
-//\f]
-//Third partial:
-//\f[
-//\alpha^0_{\tau\tau\tau} = 2\frac{A}{\tau^3} + 2\frac{BC^3}{T_c^3}\frac{\cosh(C\tau/T_c)}{\sinh^3(C\tau/T_c)} +2 \frac{DE^3}{T_c^3}\frac{\sinh(E\tau/T_c)}{\cosh^3(E\tau/T_c)}
-//\f]
-//Now coming back to the ideal gas Helmholtz energy definition:
-//\f[
-//\alpha^0 = -\tau\displaystyle\int_{\tau_0}^{\tau} \frac{1}{\tau^2}\frac{c_p^0}{R_u}d\tau+\displaystyle\int_{\tau_0}^{\tau} \frac{1}{\tau}\frac{c_p^0}{R_u}d\tau
-//\f]
-//Applying derivative
-//\f[
-//\alpha^0_{\tau} = -\displaystyle\int_{\tau_0}^{\tau} \frac{1}{\tau^2}\frac{c_p^0}{R_u}d\tau-\tau\frac{\partial}{\partial \tau}\left[\displaystyle\int_{\tau_0}^{\tau} \frac{1}{\tau^2}\frac{c_p^0}{R_u}d\tau \right]+\frac{\partial}{\partial \tau}\left[\displaystyle\int_{\tau_0}^{\tau} \frac{1}{\tau}\frac{c_p^0}{R_u}d\tau \right]
-//\f]
-//Fundamental theorem of calculus
-//\f[
-//\alpha^0_{\tau} = -\int_{\tau_0}^{\tau} \frac{1}{\tau^2}\frac{c_p^0}{R_u}d\tau-\tau \frac{1}{\tau^2}\frac{c_p^0}{R_u}d\tau+\frac{1}{\tau}\frac{c_p^0}{R_u}
-//\f]
-//Last two terms cancel, leaving
-//\f[
-//\alpha^0_{\tau} = -\int_{\tau_0}^{\tau} \frac{1}{\tau^2}\frac{c_p^0}{R_u}d\tau
-//\f]
-//Another derivative yields (from fundamental theorem of calculus)
-//\f[
-//\alpha^0_{\tau\tau} = - \frac{1}{\tau^2}\frac{c_p^0}{R_u}
-//\f]
-//
-//see also Jaeschke and Schley, 1995, (http://link.springer.com/article/10.1007%2FBF02083547#page-1)
-//*/
-///*
-//class IdealHelmholtzCP0AlyLee : public BaseHelmholtzTerm{
-//private:
-//    std::vector<CoolPropDbl> c;
-//    CoolPropDbl Tc, tau0, T0; // Use these variables internally
-//    bool enabled;
-//public:
-//    IdealHelmholtzCP0AlyLee(){enabled = false;};
-//
-//    /// Constructor with std::vectors
-//    IdealHelmholtzCP0AlyLee(const std::vector<CoolPropDbl> &c, double Tc, double T0)
-//    :c(c), Tc(Tc), T0(T0)
-//    {
-//        tau0=Tc/T0;
-//        enabled = true;
-//    };
-//
-//    /// Destructor
-//    ~IdealHelmholtzCP0AlyLee(){};
-//
-//    bool is_enabled() const {return enabled;};
-//
-//    void to_json(rapidjson::Value &el, rapidjson::Document &doc);
-//
-//
-//    /// The antiderivative given by \f$ \displaystyle\int \frac{1}{\tau^2}\frac{c_p^0}{R_u}d\tau \f$
-//    /**
-//    sympy code for this derivative:
-//
-//        from sympy import *
-//        a1,a2,a3,a4,a5,Tc,tau = symbols('a1,a2,a3,a4,a5,Tc,tau', real = True)
-//        integrand = a1 + a2*(a3/Tc/sinh(a3*tau/Tc))**2 + a4*(a5/Tc/cosh(a5*tau/Tc))**2
-//        integrand = integrand.rewrite(exp)
-//        antideriv = trigsimp(integrate(integrand,tau))
-//        display(antideriv)
-//        print latex(antideriv)
-//        print ccode(antideriv)
-//
-//    \f[
-//    \displaystyle\int \frac{1}{\tau^2}\frac{c_p^0}{R_u}d\tau = -\frac{a_0}{\tau}+\frac{2a_1a_2}{T_c\left[\exp\left(-\frac{2a_2\tau}{T_c}\right)-1\right]}+\frac{2a_3a_4}{T_c\left[\exp\left(-\frac{2a_4\tau}{T_c}\right)+1\right]}
-//    \f]
-//    */
-//    CoolPropDbl anti_deriv_cp0_tau2(const CoolPropDbl &tau);
-//
-//    /// The antiderivative given by \f$ \displaystyle\int \frac{1}{\tau}\frac{c_p^0}{R_u}d\tau \f$
-//    /**
-//    sympy code for this derivative:
-//
-//        a_0,a_1,a_2,a_3,a_4,Tc,tau = symbols('a_0,a_1,a_2,a_3,a_4,Tc,tau', real = True)
-//        integrand = a_0/tau + a_1/tau*(a_2*tau/Tc/sinh(a_2*tau/Tc))**2 + a_3/tau*(a_4*tau/Tc/cosh(a_4*tau/Tc))**2
-//
-//        term2 = a_1/tau*(a_2*tau/Tc/sinh(a_2*tau/Tc))**2
-//        term2 = term2.rewrite(exp)  # Unpack the sinh to exp functions
-//        antideriv2 = trigsimp(integrate(term2,tau))
-//        display(antideriv2)
-//        print latex(antideriv2)
-//        print ccode(antideriv2)
-//
-//        term3 = a_3/tau*(a_4*tau/Tc/cosh(a_4*tau/Tc))**2
-//        term3 = term3.rewrite(exp)  # Unpack the cosh to exp functions
-//        antideriv3 = factor(trigsimp(integrate(term3,tau).rewrite(exp)))
-//        display(antideriv3)
-//        print latex(antideriv3)
-//        print ccode(antideriv3)
-//
-//    Can be broken into three parts (trick is to express \f$sinh\f$ and \f$cosh\f$ in terms of \f$exp\f$ function)
-//
-//    Term 2:
-//    \f[
-//    \displaystyle\int \frac{a_1a_2^2}{T_c^2}\frac{\tau}{\sinh\left(\displaystyle\frac{a_2\tau}{T_c}\right)^2} d\tau = \frac{2 a_{1} a_{2} \tau}{- Tc + Tc e^{- \frac{2 a_{2}}{Tc} \tau}} + a_{1} \log{\left (-1 + e^{- \frac{2 a_{2}}{Tc} \tau} \right )} + \frac{2 a_{1}}{Tc} a_{2} \tau
-//    \f]
-//
-//    Term 3:
-//    \f[
-//    \displaystyle\int \frac{a_1a_2^2}{T_c^2}\frac{\tau}{\cosh\left(\displaystyle\frac{a_2\tau}{T_c}\right)^2} d\tau = - \frac{a_{3}}{Tc \left(e^{\frac{2 a_{4}}{Tc} \tau} + 1\right)} \left(Tc e^{\frac{2 a_{4}}{Tc} \tau} \log{\left (e^{\frac{2 a_{4}}{Tc} \tau} + 1 \right )} + Tc \log{\left (e^{\frac{2 a_{4}}{Tc} \tau} + 1 \right )} - 2 a_{4} \tau e^{\frac{2 a_{4}}{Tc} \tau}\right)
-//    \f]
-//    */
-//    CoolPropDbl anti_deriv_cp0_tau(const CoolPropDbl &tau);
-//
-//    CoolPropDbl base(const CoolPropDbl &tau, const CoolPropDbl &delta) throw();
-//    CoolPropDbl dDelta(const CoolPropDbl &tau, const CoolPropDbl &delta) throw(){return 0.0;};
-//    CoolPropDbl dTau(const CoolPropDbl &tau, const CoolPropDbl &delta) throw();
-//    CoolPropDbl dDelta2(const CoolPropDbl &tau, const CoolPropDbl &delta) throw(){return 0.0;};
-//    CoolPropDbl dDelta_dTau(const CoolPropDbl &tau, const CoolPropDbl &delta) throw(){return 0.0;};
-//    CoolPropDbl dTau2(const CoolPropDbl &tau, const CoolPropDbl &delta) throw();
-//    CoolPropDbl dDelta3(const CoolPropDbl &tau, const CoolPropDbl &delta) throw(){return 0.0;};
-//    CoolPropDbl dDelta2_dTau(const CoolPropDbl &tau, const CoolPropDbl &delta) throw(){return 0.0;};
-//    CoolPropDbl dDelta_dTau2(const CoolPropDbl &tau, const CoolPropDbl &delta) throw(){return 0.0;};
-//    CoolPropDbl dTau3(const CoolPropDbl &tau, const CoolPropDbl &delta) throw();
-//    CoolPropDbl dTau4(const CoolPropDbl &tau, const CoolPropDbl &delta) throw();
-//
-//};
-
-class IdealHelmholtzContainer : public BaseHelmholtzContainer
-{
-   private:
-    double _prefactor;
-
-   public:
-    IdealHelmholtzLead Lead;
-    IdealHelmholtzEnthalpyEntropyOffset EnthalpyEntropyOffsetCore, EnthalpyEntropyOffset;
-    IdealHelmholtzLogTau LogTau;
-    IdealHelmholtzPower Power;
-    IdealHelmholtzPlanckEinsteinGeneralized PlanckEinstein;
-
-    IdealHelmholtzCP0Constant CP0Constant;
-    IdealHelmholtzCP0PolyT CP0PolyT;
-    IdealHelmholtzGERG2004Cosh GERG2004Cosh;
-    IdealHelmholtzGERG2004Sinh GERG2004Sinh;
-
-    IdealHelmholtzContainer() : _prefactor(1.0){};
-
-    void set_prefactor(double prefactor) {
-        _prefactor = prefactor;
-    }
-
-    void set_Tred(double T_red) {
-        GERG2004Cosh.set_Tred(T_red);
-        GERG2004Sinh.set_Tred(T_red);
-    }
-
-    void empty_the_EOS() {
-        Lead = IdealHelmholtzLead();
-        EnthalpyEntropyOffsetCore = IdealHelmholtzEnthalpyEntropyOffset();
-        EnthalpyEntropyOffset = IdealHelmholtzEnthalpyEntropyOffset();
-        LogTau = IdealHelmholtzLogTau();
-        Power = IdealHelmholtzPower();
-        PlanckEinstein = IdealHelmholtzPlanckEinsteinGeneralized();
-        CP0Constant = IdealHelmholtzCP0Constant();
-        CP0PolyT = IdealHelmholtzCP0PolyT();
-        GERG2004Cosh = IdealHelmholtzGERG2004Cosh();
-        GERG2004Sinh = IdealHelmholtzGERG2004Sinh();
-    };
-
-    HelmholtzDerivatives all(const CoolPropDbl tau, const CoolPropDbl delta, bool cache_values = false) {
-        HelmholtzDerivatives derivs;  // zeros out the elements
-        Lead.all(tau, delta, derivs);
-        EnthalpyEntropyOffsetCore.all(tau, delta, derivs);
-        EnthalpyEntropyOffset.all(tau, delta, derivs);
-        LogTau.all(tau, delta, derivs);
-        Power.all(tau, delta, derivs);
-        PlanckEinstein.all(tau, delta, derivs);
-        CP0Constant.all(tau, delta, derivs);
-        CP0PolyT.all(tau, delta, derivs);
-        GERG2004Cosh.all(tau, delta, derivs);
-        GERG2004Sinh.all(tau, delta, derivs);
-
-        if (cache_values) {
-            _base = derivs.alphar * _prefactor;
-            _dDelta = derivs.dalphar_ddelta * _prefactor;
-            _dTau = derivs.dalphar_dtau * _prefactor;
-            _dDelta2 = derivs.d2alphar_ddelta2 * _prefactor;
-            _dTau2 = derivs.d2alphar_dtau2 * _prefactor;
-            _dDelta_dTau = derivs.d2alphar_ddelta_dtau * _prefactor;
-            _dDelta3 = derivs.d3alphar_ddelta3 * _prefactor;
-            _dTau3 = derivs.d3alphar_dtau3 * _prefactor;
-            _dDelta2_dTau = derivs.d3alphar_ddelta2_dtau * _prefactor;
-            _dDelta_dTau2 = derivs.d3alphar_ddelta_dtau2 * _prefactor;
-        }
-        return derivs * _prefactor;
-    };
-};
-}; /* namespace CoolProp */
-
-#endif
+
+#ifndef HELMHOLTZ_H
+#define HELMHOLTZ_H
+
+#include <vector>
+#include "rapidjson_include.h"
+//#include "Eigen/Core"
+#include "time.h"
+#include "CachedElement.h"
+#include "Backends/Cubics/GeneralizedCubic.h"
+#include "crossplatform_shared_ptr.h"
+
+namespace CoolProp {
+
+// #############################################################################
+// #############################################################################
+// #############################################################################
+//                                RESIDUAL TERMS
+// #############################################################################
+// #############################################################################
+// #############################################################################
+
+#define LIST_OF_DERIVATIVE_VARIABLES   \
+    X(alphar)                          \
+    X(dalphar_ddelta)                  \
+    X(dalphar_dtau)                    \
+    X(d2alphar_ddelta2)                \
+    X(d2alphar_dtau2)                  \
+    X(d2alphar_ddelta_dtau)            \
+    X(d3alphar_ddelta3)                \
+    X(d3alphar_ddelta_dtau2)           \
+    X(d3alphar_ddelta2_dtau)           \
+    X(d3alphar_dtau3)                  \
+    X(d4alphar_ddelta4)                \
+    X(d4alphar_ddelta3_dtau)           \
+    X(d4alphar_ddelta2_dtau2)          \
+    X(d4alphar_ddelta_dtau3)           \
+    X(d4alphar_dtau4)                  \
+    X(delta_x_dalphar_ddelta)          \
+    X(tau_x_dalphar_dtau)              \
+    X(delta2_x_d2alphar_ddelta2)       \
+    X(deltatau_x_d2alphar_ddelta_dtau) \
+    X(tau2_x_d2alphar_dtau2)
+
+struct HelmholtzDerivatives
+{
+#define X(name) CoolPropDbl name;
+    LIST_OF_DERIVATIVE_VARIABLES
+#undef X
+    CoolPropDbl tau, delta, T_red, rhomolar_red;
+
+    void reset(CoolPropDbl v) {
+#define X(name) name = v;
+        LIST_OF_DERIVATIVE_VARIABLES
+#undef X
+    }
+    HelmholtzDerivatives operator+(const HelmholtzDerivatives& other) const {
+        HelmholtzDerivatives _new;
+#define X(name) _new.name = name + other.name;
+        LIST_OF_DERIVATIVE_VARIABLES
+#undef X
+        return _new;
+    }
+    HelmholtzDerivatives operator*(const CoolPropDbl& other) const {
+        HelmholtzDerivatives _new;
+#define X(name) _new.name = name * other;
+        LIST_OF_DERIVATIVE_VARIABLES
+#undef X
+        return _new;
+    }
+    HelmholtzDerivatives() {
+        reset(0.0);
+        T_red = _HUGE;
+        rhomolar_red = _HUGE;
+    };
+    /// Retrieve a single value based on the number of derivatives with respect to tau and delta
+    double get(std::size_t itau, std::size_t idelta) {
+        if (itau == 0) {
+            if (idelta == 0) {
+                return alphar;
+            } else if (idelta == 1) {
+                return dalphar_ddelta;
+            } else if (idelta == 2) {
+                return d2alphar_ddelta2;
+            } else if (idelta == 3) {
+                return d3alphar_ddelta3;
+            } else if (idelta == 4) {
+                return d4alphar_ddelta4;
+            } else {
+                throw ValueError();
+            }
+        } else if (itau == 1) {
+            if (idelta == 0) {
+                return dalphar_dtau;
+            } else if (idelta == 1) {
+                return d2alphar_ddelta_dtau;
+            } else if (idelta == 2) {
+                return d3alphar_ddelta2_dtau;
+            } else if (idelta == 3) {
+                return d4alphar_ddelta3_dtau;
+            } else {
+                throw ValueError();
+            }
+        } else if (itau == 2) {
+            if (idelta == 0) {
+                return d2alphar_dtau2;
+            } else if (idelta == 1) {
+                return d3alphar_ddelta_dtau2;
+            } else if (idelta == 2) {
+                return d4alphar_ddelta2_dtau2;
+            } else {
+                throw ValueError();
+            }
+        } else if (itau == 3) {
+            if (idelta == 0) {
+                return d3alphar_dtau3;
+            } else if (idelta == 1) {
+                return d4alphar_ddelta_dtau3;
+            } else {
+                throw ValueError();
+            }
+        } else if (itau == 4) {
+            if (idelta == 0) {
+                return d4alphar_dtau4;
+            } else {
+                throw ValueError();
+            }
+        } else {
+            throw ValueError();
+        }
+    }
+};
+#undef LIST_OF_DERIVATIVE_VARIABLES
+
+/// The base class class for the Helmholtz energy terms
+/**
+
+ Residual Helmholtz Energy Terms:
+
+ Term                               | Helmholtz Energy Contribution
+ ----------                         | ------------------------------
+ ResidualHelmholtzPower             | \f$ \alpha^r=\left\lbrace\begin{array}{cc}\displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} & l_i=0\\ \displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} \exp(-\delta^{l_i}) & l_i\neq 0\end{array}\right.\f$
+ ResidualHelmholtzExponential       | \f$ \alpha^r=\displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} \exp(-\gamma_i\delta^{l_i}) \f$
+ ResidualHelmholtzLemmon2005        | \f$ \alpha^r=\displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} \exp(-\delta^{l_i}-\tau^{m_i})\f$
+ ResidualHelmholtzGaussian          | \f$ \alpha^r=\displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} \exp(-\eta_i(\delta-\epsilon_i)^2-\beta_i(\tau-\gamma_i)^2)\f$
+ ResidualHelmholtzGERG2008Gaussian  | \f$ \alpha^r=\displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} \exp(-\eta_i(\delta-\epsilon_i)^2-\beta_i(\delta-\gamma_i))\f$
+ ResidualHelmholtzNonAnalytic       | \f$ \begin{array}{c}\alpha^r&=&\displaystyle\sum_i n_i \Delta^{b_i}\delta\psi \\ \Delta & = & \theta^2+B_i[(\delta-1)^2]^{a_i}\\ \theta & = & (1-\tau)+A_i[(\delta-1)^2]^{1/(2\beta_i)}\\ \psi & = & \exp(-C_i(\delta-1)^2-D_i(\tau-1)^2) \end{array}\f$
+ ResidualHelmholtzSAFTAssociating   | \f$ \alpha^r = am\left(\ln X-\frac{X}{2}+\frac{1}{2}\right); \f$
+
+
+ Ideal-Gas Helmholtz Energy Terms:
+
+ Term                                        | Helmholtz Energy Contribution
+ ----------                                  | ------------------------------
+ IdealHelmholtzLead                          | \f$ \alpha^0 = n_1 + n_2\tau + \ln\delta \f$
+ IdealHelmholtzEnthalpyEntropyOffset         | \f$ \alpha^0 = \displaystyle\frac{\Delta s}{R_u/M}+\frac{\Delta h}{(R_u/M)T}\tau \f$
+ IdealHelmholtzLogTau                        | \f$ \alpha^0 = n_1\log\tau \f$
+ IdealHelmholtzPower                         | \f$ \alpha^0 = \displaystyle\sum_i n_i\tau^{t_i} \f$
+ IdealHelmholtzPlanckEinsteinGeneralized     | \f$ \alpha^0 = \displaystyle\sum_i n_i\log[c_i+d_i\exp(\theta_i\tau)] \f$
+ */
+class BaseHelmholtzTerm
+{
+   public:
+    BaseHelmholtzTerm(){};
+    virtual ~BaseHelmholtzTerm(){};
+
+    /// Returns the base, non-dimensional, Helmholtz energy term (no derivatives) [-]
+    /** @param tau Reciprocal reduced temperature where \f$\tau=T_c / T\f$
+     *  @param delta Reduced density where \f$\delta = \rho / \rho_c \f$
+     */
+    virtual CoolPropDbl base(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
+        HelmholtzDerivatives deriv;
+        all(tau, delta, deriv);
+        return deriv.alphar;
+    };
+    /// Returns the first partial derivative of Helmholtz energy term with respect to tau [-]
+    /** @param tau Reciprocal reduced temperature where \f$\tau=T_c / T\f$
+     *  @param delta Reduced density where \f$\delta = \rho / \rho_c \f$
+     */
+    virtual CoolPropDbl dTau(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
+        HelmholtzDerivatives deriv;
+        all(tau, delta, deriv);
+        return deriv.dalphar_dtau;
+    };
+    /// Returns the second partial derivative of Helmholtz energy term with respect to tau [-]
+    /** @param tau Reciprocal reduced temperature where \f$\tau=T_c / T\f$
+     *  @param delta Reduced density where \f$\delta = \rho / \rho_c \f$
+     */
+    virtual CoolPropDbl dTau2(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
+        HelmholtzDerivatives deriv;
+        all(tau, delta, deriv);
+        return deriv.d2alphar_dtau2;
+    };
+    /// Returns the second mixed partial derivative (delta1,dtau1) of Helmholtz energy term with respect to delta and tau [-]
+    /** @param tau Reciprocal reduced temperature where \f$\tau=T_c / T\f$
+     *  @param delta Reduced density where \f$\delta = \rho / \rho_c \f$
+     */
+    virtual CoolPropDbl dDelta_dTau(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
+        HelmholtzDerivatives deriv;
+        all(tau, delta, deriv);
+        return deriv.d2alphar_ddelta_dtau;
+    };
+    /// Returns the first partial derivative of Helmholtz energy term with respect to delta [-]
+    /** @param tau Reciprocal reduced temperature where \f$\tau=T_c / T\f$
+     *  @param delta Reduced density where \f$\delta = \rho / \rho_c \f$
+     */
+    virtual CoolPropDbl dDelta(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
+        HelmholtzDerivatives deriv;
+        all(tau, delta, deriv);
+        return deriv.dalphar_ddelta;
+    };
+    /// Returns the second partial derivative of Helmholtz energy term with respect to delta [-]
+    /** @param tau Reciprocal reduced temperature where \f$\tau=T_c / T\f$
+     *  @param delta Reduced density where \f$\delta = \rho / \rho_c \f$
+     */
+    virtual CoolPropDbl dDelta2(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
+        HelmholtzDerivatives deriv;
+        all(tau, delta, deriv);
+        return deriv.d2alphar_ddelta2;
+    };
+    /// Returns the third mixed partial derivative (delta2,dtau1) of Helmholtz energy term with respect to delta and tau [-]
+    /** @param tau Reciprocal reduced temperature where \f$\tau=T_c / T\f$
+     *  @param delta Reduced density where \f$\delta = \rho / \rho_c \f$
+     */
+    virtual CoolPropDbl dDelta2_dTau(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
+        HelmholtzDerivatives deriv;
+        all(tau, delta, deriv);
+        return deriv.d3alphar_ddelta2_dtau;
+    };
+    /// Returns the third mixed partial derivative (delta1,dtau2) of Helmholtz energy term with respect to delta and tau [-]
+    /** @param tau Reciprocal reduced temperature where \f$\tau=T_c / T\f$
+     *  @param delta Reduced density where \f$\delta = \rho / \rho_c \f$
+     */
+    virtual CoolPropDbl dDelta_dTau2(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
+        HelmholtzDerivatives deriv;
+        all(tau, delta, deriv);
+        return deriv.d3alphar_ddelta_dtau2;
+    };
+    /// Returns the third partial derivative of Helmholtz energy term with respect to tau [-]
+    /** @param tau Reciprocal reduced temperature where \f$\tau=T_c / T\f$
+     *  @param delta Reduced density where \f$\delta = \rho / \rho_c \f$
+     */
+    virtual CoolPropDbl dTau3(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
+        HelmholtzDerivatives deriv;
+        all(tau, delta, deriv);
+        return deriv.d3alphar_dtau3;
+    };
+    /// Returns the third partial derivative of Helmholtz energy term with respect to delta [-]
+    /** @param tau Reciprocal reduced temperature where \f$\tau=T_c / T\f$
+     *  @param delta Reduced density where \f$\delta = \rho / \rho_c \f$
+     */
+    virtual CoolPropDbl dDelta3(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
+        HelmholtzDerivatives deriv;
+        all(tau, delta, deriv);
+        return deriv.d3alphar_ddelta3;
+    };
+    /// Returns the fourth partial derivative of Helmholtz energy term with respect to tau [-]
+    /** @param tau Reciprocal reduced temperature where \f$\tau=T_c / T\f$
+     *  @param delta Reduced density where \f$\delta = \rho / \rho_c \f$
+     */
+    virtual CoolPropDbl dTau4(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
+        HelmholtzDerivatives deriv;
+        all(tau, delta, deriv);
+        return deriv.d4alphar_dtau4;
+    };
+    virtual CoolPropDbl dDelta_dTau3(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
+        HelmholtzDerivatives deriv;
+        all(tau, delta, deriv);
+        return deriv.d4alphar_ddelta_dtau3;
+    };
+    virtual CoolPropDbl dDelta2_dTau2(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
+        HelmholtzDerivatives deriv;
+        all(tau, delta, deriv);
+        return deriv.d4alphar_ddelta2_dtau2;
+    };
+    virtual CoolPropDbl dDelta3_dTau(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
+        HelmholtzDerivatives deriv;
+        all(tau, delta, deriv);
+        return deriv.d4alphar_ddelta3_dtau;
+    };
+    virtual CoolPropDbl dDelta4(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
+        HelmholtzDerivatives deriv;
+        all(tau, delta, deriv);
+        return deriv.d4alphar_ddelta4;
+    };
+
+    virtual void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw() = 0;
+};
+
+struct ResidualHelmholtzGeneralizedExponentialElement
+{
+    /// These variables are for the n*delta^d_i*tau^t_i part
+    CoolPropDbl n, d, t;
+    /// These variables are for the exp(u) part
+    /// u is given by -c*delta^l_i-omega*tau^m_i-eta1*(delta-epsilon1)-eta2*(delta-epsilon2)^2-beta1*(tau-gamma1)-beta2*(tau-gamma2)^2
+    CoolPropDbl c, l_double, omega, m_double, eta1, epsilon1, eta2, epsilon2, beta1, gamma1, beta2, gamma2;
+    /// If l_i or m_i are integers, we will store them as integers in order to call pow(double, int) rather than pow(double, double)
+    int l_int, m_int;
+    /// If l is an integer, store a boolean flag so we can evaluate the correct pow() function
+    bool l_is_int, m_is_int;
+
+    ResidualHelmholtzGeneralizedExponentialElement() {
+        n = 0;
+        d = 0;
+        t = 0;
+        c = 0;
+        l_double = 0;
+        omega = 0;
+        m_double = 0;
+        eta1 = 0;
+        epsilon1 = 0;
+        eta2 = 0;
+        epsilon2 = 0;
+        beta1 = 0;
+        gamma1 = 0;
+        beta2 = 0;
+        gamma2 = 0;
+        l_int = 0;
+        m_int = 0;
+        l_is_int = false;
+        m_is_int = true;
+    };
+};
+/** \brief A generalized residual helmholtz energy container that can deal with a wide range of terms which can be converted to this general form
+ *
+ * \f$ \alpha^r=\sum_i n_i \delta^{d_i} \tau^{t_i}\exp(u_i) \f$
+ *
+ * where \f$ u_i \f$ is given by
+ *
+ * \f$ u_i = -c_i\delta^{l_i}-\omega_i\tau^{m_i}-\eta_{1,i}(\delta-\epsilon_{1,i})-\eta_{2,i}(\delta-\epsilon_{2,i})^2-\beta_{1,i}(\tau-\gamma_{1,i})-\beta_{2,i}(\tau-\gamma_{2,i})^2 \f$
+ */
+class ResidualHelmholtzGeneralizedExponential : public BaseHelmholtzTerm
+{
+
+   public:
+    bool delta_li_in_u, tau_mi_in_u, eta1_in_u, eta2_in_u, beta1_in_u, beta2_in_u, finished;
+    std::vector<CoolPropDbl> s;
+    std::size_t N;
+
+    // These variables are for the exp(u) part
+    // u is given by -c*delta^l_i-omega*tau^m_i-eta1*(delta-epsilon1)-eta2*(delta-epsilon2)^2-beta1*(tau-gamma1)-beta2*(tau-gamma2)^2
+    std::vector<double> n, d, t, c, l_double, omega, m_double, eta1, epsilon1, eta2, epsilon2, beta1, gamma1, beta2, gamma2;
+    // If l_i or m_i are integers, we will store them as integers in order to call pow(double, int) rather than pow(double, double)
+    std::vector<int> l_int, m_int;
+
+    //Eigen::ArrayXd uE, du_ddeltaE, du_dtauE, d2u_ddelta2E, d2u_dtau2E, d3u_ddelta3E, d3u_dtau3E;
+
+    std::vector<ResidualHelmholtzGeneralizedExponentialElement> elements;
+    // Default Constructor
+    ResidualHelmholtzGeneralizedExponential()
+      : delta_li_in_u(false), tau_mi_in_u(false), eta1_in_u(false), eta2_in_u(false), beta1_in_u(false), beta2_in_u(false), finished(false), N(0){};
+    /** \brief Add and convert an old-style power (polynomial) term to generalized form
+	 *
+	 * Term of the format
+	 * \f$ \alpha^r=\left\lbrace\begin{array}{cc}\displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} & l_i=0\\ \displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} \exp(-\delta^{l_i}) & l_i\neq 0\end{array}\right.\f$
+	 */
+    void add_Power(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& d, const std::vector<CoolPropDbl>& t,
+                   const std::vector<CoolPropDbl>& l) {
+        for (std::size_t i = 0; i < n.size(); ++i) {
+            ResidualHelmholtzGeneralizedExponentialElement el;
+            el.n = n[i];
+            el.d = d[i];
+            el.t = t[i];
+            el.l_double = l[i];
+            el.l_int = (int)el.l_double;
+            if (el.l_double > 0)
+                el.c = 1.0;
+            else
+                el.c = 0.0;
+            elements.push_back(el);
+        }
+        delta_li_in_u = true;
+    };
+    /** \brief Add and convert an old-style exponential term to generalized form
+	 *
+	 * Term of the format
+	 * \f$ \alpha^r=\displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} \exp(-g_i\delta^{l_i}) \f$
+	 */
+    void add_Exponential(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& d, const std::vector<CoolPropDbl>& t,
+                         const std::vector<CoolPropDbl>& g, const std::vector<CoolPropDbl>& l) {
+        for (std::size_t i = 0; i < n.size(); ++i) {
+            ResidualHelmholtzGeneralizedExponentialElement el;
+            el.n = n[i];
+            el.d = d[i];
+            el.t = t[i];
+            el.c = g[i];
+            el.l_double = l[i];
+            el.l_int = (int)el.l_double;
+            elements.push_back(el);
+        }
+        delta_li_in_u = true;
+    }
+    /** \brief Add and convert an old-style Gaussian term to generalized form
+	 *
+	 * Term of the format
+	 * \f$ \alpha^r=\displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} \exp(-\eta_i(\delta-\epsilon_i)^2-\beta_i(\tau-\gamma_i)^2)\f$
+	 */
+    void add_Gaussian(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& d, const std::vector<CoolPropDbl>& t,
+                      const std::vector<CoolPropDbl>& eta, const std::vector<CoolPropDbl>& epsilon, const std::vector<CoolPropDbl>& beta,
+                      const std::vector<CoolPropDbl>& gamma) {
+        for (std::size_t i = 0; i < n.size(); ++i) {
+            ResidualHelmholtzGeneralizedExponentialElement el;
+            el.n = n[i];
+            el.d = d[i];
+            el.t = t[i];
+            el.eta2 = eta[i];
+            el.epsilon2 = epsilon[i];
+            el.beta2 = beta[i];
+            el.gamma2 = gamma[i];
+            elements.push_back(el);
+        }
+        eta2_in_u = true;
+        beta2_in_u = true;
+    };
+    /** \brief Add and convert an old-style Gaussian term from GERG 2008 natural gas model to generalized form
+	 *
+	 * Term of the format
+	 * \f$ \alpha^r=\displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} \exp(-\eta_i(\delta-\epsilon_i)^2-\beta_i(\delta-\gamma_i))\f$
+	 */
+    void add_GERG2008Gaussian(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& d, const std::vector<CoolPropDbl>& t,
+                              const std::vector<CoolPropDbl>& eta, const std::vector<CoolPropDbl>& epsilon, const std::vector<CoolPropDbl>& beta,
+                              const std::vector<CoolPropDbl>& gamma) {
+        for (std::size_t i = 0; i < n.size(); ++i) {
+            ResidualHelmholtzGeneralizedExponentialElement el;
+            el.n = n[i];
+            el.d = d[i];
+            el.t = t[i];
+            el.eta2 = eta[i];
+            el.epsilon2 = epsilon[i];
+            el.eta1 = beta[i];
+            el.epsilon1 = gamma[i];
+            elements.push_back(el);
+        }
+        eta2_in_u = true;
+        eta1_in_u = true;
+    };
+    /** \brief Add and convert a term from Lemmon and Jacobsen (2005) used for R125
+	 *
+	 * Term of the format
+	 * \f$ \alpha^r=\displaystyle\sum_i n_i \delta^{d_i} \tau^{t_i} \exp(-\delta^{l_i}-\tau^{m_i})\f$
+	 */
+    void add_Lemmon2005(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& d, const std::vector<CoolPropDbl>& t,
+                        const std::vector<CoolPropDbl>& l, const std::vector<CoolPropDbl>& m) {
+        for (std::size_t i = 0; i < n.size(); ++i) {
+            ResidualHelmholtzGeneralizedExponentialElement el;
+            el.n = n[i];
+            el.d = d[i];
+            el.t = t[i];
+            el.c = 1.0;
+            el.omega = 1.0;
+            el.l_double = l[i];
+            el.m_double = m[i];
+            el.l_int = (int)el.l_double;
+            el.m_int = (int)el.m_double;
+            elements.push_back(el);
+        }
+        delta_li_in_u = true;
+        tau_mi_in_u = true;
+    };
+
+    void finish() {
+        n.resize(elements.size());
+        d.resize(elements.size());
+        t.resize(elements.size());
+        c.resize(elements.size());
+        omega.resize(elements.size());
+        l_double.resize(elements.size());
+        l_int.resize(elements.size());
+        m_double.resize(elements.size());
+        m_int.resize(elements.size());
+        epsilon2.resize(elements.size());
+        eta2.resize(elements.size());
+        gamma2.resize(elements.size());
+        beta2.resize(elements.size());
+
+        for (std::size_t i = 0; i < elements.size(); ++i) {
+            n[i] = elements[i].n;
+            d[i] = elements[i].d;
+            t[i] = elements[i].t;
+            c[i] = elements[i].c;
+            omega[i] = elements[i].omega;
+            l_double[i] = elements[i].l_double;
+            l_int[i] = elements[i].l_int;
+            m_double[i] = elements[i].m_double;
+            m_int[i] = elements[i].m_int;
+            epsilon2[i] = elements[i].epsilon2;
+            eta2[i] = elements[i].eta2;
+            gamma2[i] = elements[i].gamma2;
+            beta2[i] = elements[i].beta2;
+
+            // See if l is an integer, and store a flag if it is
+            elements[i].l_is_int = (std::abs(static_cast<long>(elements[i].l_double) - elements[i].l_double) < 1e-14);
+        }
+        //        uE.resize(elements.size());
+        //        du_ddeltaE.resize(elements.size());
+        //        du_dtauE.resize(elements.size());
+        //        d2u_ddelta2E.resize(elements.size());
+        //        d2u_dtau2E.resize(elements.size());
+        //        d3u_ddelta3E.resize(elements.size());
+        //        d3u_dtau3E.resize(elements.size());
+
+        finished = true;
+    };
+
+    void to_json(rapidjson::Value& el, rapidjson::Document& doc);
+
+    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
+    //void allEigen(const CoolPropDbl &tau, const CoolPropDbl &delta, HelmholtzDerivatives &derivs) throw();
+};
+
+struct ResidualHelmholtzNonAnalyticElement
+{
+    CoolPropDbl n, a, b, beta, A, B, C, D;
+};
+class ResidualHelmholtzNonAnalytic : public BaseHelmholtzTerm
+{
+
+   public:
+    std::size_t N;
+    std::vector<CoolPropDbl> s;
+    std::vector<ResidualHelmholtzNonAnalyticElement> elements;
+    /// Default Constructor
+    ResidualHelmholtzNonAnalytic() {
+        N = 0;
+    };
+    /// Destructor. No implementation
+    ~ResidualHelmholtzNonAnalytic(){};
+    /// Constructor
+    ResidualHelmholtzNonAnalytic(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& a, const std::vector<CoolPropDbl>& b,
+                                 const std::vector<CoolPropDbl>& beta, const std::vector<CoolPropDbl>& A, const std::vector<CoolPropDbl>& B,
+                                 const std::vector<CoolPropDbl>& C, const std::vector<CoolPropDbl>& D) {
+        N = n.size();
+        s.resize(N);
+        for (std::size_t i = 0; i < n.size(); ++i) {
+            ResidualHelmholtzNonAnalyticElement el;
+            el.n = n[i];
+            el.a = a[i];
+            el.b = b[i];
+            el.beta = beta[i];
+            el.A = A[i];
+            el.B = B[i];
+            el.C = C[i];
+            el.D = D[i];
+            elements.push_back(el);
+        }
+    };
+    void to_json(rapidjson::Value& el, rapidjson::Document& doc);
+    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
+};
+
+class ResidualHelmholtzGeneralizedCubic : public BaseHelmholtzTerm
+{
+   protected:
+    shared_ptr<AbstractCubic> m_abstractcubic;
+    std::vector<double> z;  /// Vector of mole fractions, will be initialized to [1.0] since this is a pure fluid
+   public:
+    bool enabled;
+
+    /// Default Constructor
+    ResidualHelmholtzGeneralizedCubic() {
+        enabled = false;
+    };
+    /// Constructor given an abstract cubic instance
+    ResidualHelmholtzGeneralizedCubic(shared_ptr<AbstractCubic>& ac) : m_abstractcubic(ac) {
+        enabled = true;
+        z = std::vector<double>(1, 1);  // Init the vector to [1.0]
+    };
+
+    void to_json(rapidjson::Value& el, rapidjson::Document& doc);
+    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
+};
+
+class ResidualHelmholtzGaoB : public BaseHelmholtzTerm
+{
+   protected:
+    std::vector<double> n, t, d, eta, beta, gamma, epsilon, b;
+
+   public:
+    bool enabled;
+
+    /// Default Constructor
+    ResidualHelmholtzGaoB() {
+        enabled = false;
+    };
+
+    /// Constructor given coefficients
+    ResidualHelmholtzGaoB(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& t, const std::vector<CoolPropDbl>& d,
+                          const std::vector<CoolPropDbl>& eta, const std::vector<CoolPropDbl>& beta, const std::vector<CoolPropDbl>& gamma,
+                          const std::vector<CoolPropDbl>& epsilon, const std::vector<CoolPropDbl>& b)
+      : n(n), t(t), d(d), eta(eta), beta(beta), gamma(gamma), epsilon(epsilon), b(b) {
+        enabled = true;
+    };
+
+    void to_json(rapidjson::Value& el, rapidjson::Document& doc);
+    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
+};
+
+/// The generalized Lee-Kesler formulation of Xiang & Deiters: doi:10.1016/j.ces.2007.11.029
+class ResidualHelmholtzXiangDeiters : public BaseHelmholtzTerm
+{
+
+   public:
+    bool enabled;
+    ResidualHelmholtzGeneralizedExponential phi0, phi1, phi2;
+    CoolPropDbl Tc, pc, rhomolarc, acentric, R, theta;
+    /// Default Constructor
+    ResidualHelmholtzXiangDeiters() : Tc(_HUGE), pc(_HUGE), rhomolarc(_HUGE), acentric(_HUGE), R(_HUGE), theta(_HUGE) {
+        enabled = false;
+    };
+    /// Constructor
+    ResidualHelmholtzXiangDeiters(const CoolPropDbl Tc, const CoolPropDbl pc, const CoolPropDbl rhomolarc, const CoolPropDbl acentric,
+                                  const CoolPropDbl R);
+    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
+};
+
+class ResidualHelmholtzSAFTAssociating : public BaseHelmholtzTerm
+{
+
+   protected:
+    double a, m, epsilonbar, vbarn, kappabar;
+
+    CoolPropDbl Deltabar(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
+    CoolPropDbl dDeltabar_ddelta__consttau(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
+    CoolPropDbl d2Deltabar_ddelta2__consttau(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
+    CoolPropDbl dDeltabar_dtau__constdelta(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
+    CoolPropDbl d2Deltabar_dtau2__constdelta(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
+    CoolPropDbl d2Deltabar_ddelta_dtau(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
+    CoolPropDbl d3Deltabar_dtau3__constdelta(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
+    CoolPropDbl d3Deltabar_ddelta_dtau2(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
+    CoolPropDbl d3Deltabar_ddelta3__consttau(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
+    CoolPropDbl d3Deltabar_ddelta2_dtau(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
+
+    CoolPropDbl X(const CoolPropDbl& delta, const CoolPropDbl& Deltabar) const;
+    CoolPropDbl dX_dDeltabar__constdelta(const CoolPropDbl& delta, const CoolPropDbl& Deltabar) const;
+    CoolPropDbl dX_ddelta__constDeltabar(const CoolPropDbl& delta, const CoolPropDbl& Deltabar) const;
+    CoolPropDbl dX_dtau(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
+    CoolPropDbl dX_ddelta(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
+    CoolPropDbl d2X_dtau2(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
+    CoolPropDbl d2X_ddeltadtau(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
+    CoolPropDbl d2X_ddelta2(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
+
+    CoolPropDbl d3X_dtau3(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
+    CoolPropDbl d3X_ddelta3(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
+    CoolPropDbl d3X_ddeltadtau2(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
+    CoolPropDbl d3X_ddelta2dtau(const CoolPropDbl& tau, const CoolPropDbl& delta) const;
+
+    CoolPropDbl g(const CoolPropDbl& eta) const;
+    CoolPropDbl dg_deta(const CoolPropDbl& eta) const;
+    CoolPropDbl d2g_deta2(const CoolPropDbl& eta) const;
+    CoolPropDbl d3g_deta3(const CoolPropDbl& eta) const;
+    CoolPropDbl eta(const CoolPropDbl& delta) const;
+
+   public:
+    /// Default constructor
+    ResidualHelmholtzSAFTAssociating() : a(_HUGE), m(_HUGE), epsilonbar(_HUGE), vbarn(_HUGE), kappabar(_HUGE) {
+        disabled = true;
+    };
+
+    // Constructor
+    ResidualHelmholtzSAFTAssociating(double a, double m, double epsilonbar, double vbarn, double kappabar)
+      : a(a), m(m), epsilonbar(epsilonbar), vbarn(vbarn), kappabar(kappabar) {
+        disabled = false;
+    };
+
+    bool disabled;
+
+    //Destructor. No Implementation
+    ~ResidualHelmholtzSAFTAssociating(){};
+
+    void to_json(rapidjson::Value& el, rapidjson::Document& doc);
+
+    CoolPropDbl dTau4(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
+        return 1e99;
+    };
+    CoolPropDbl dDelta_dTau3(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
+        return 1e99;
+    };
+    CoolPropDbl dDelta2_dTau2(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
+        return 1e99;
+    };
+    CoolPropDbl dDelta3_dTau(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
+        return 1e99;
+    };
+    CoolPropDbl dDelta4(const CoolPropDbl& tau, const CoolPropDbl& delta) throw() {
+        return 1e99;
+    };
+
+    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& deriv) throw();
+};
+
+class BaseHelmholtzContainer
+{
+   protected:
+    CachedElement _base, _dDelta, _dTau, _dDelta2, _dTau2, _dDelta_dTau, _dDelta3, _dDelta2_dTau, _dDelta_dTau2, _dTau3;
+    CachedElement _dDelta4, _dDelta3_dTau, _dDelta2_dTau2, _dDelta_dTau3, _dTau4;
+
+   public:
+    void clear() {
+        _base.clear();
+        _dDelta.clear();
+        _dTau.clear();
+        _dDelta2.clear();
+        _dTau2.clear();
+        _dDelta_dTau.clear();
+        _dDelta3.clear();
+        _dTau3.clear();
+        _dDelta2_dTau.clear();
+        _dDelta_dTau2.clear();
+        _dDelta4.clear();
+        _dDelta3_dTau.clear();
+        _dDelta2_dTau2.clear();
+        _dDelta_dTau3.clear();
+        _dTau4.clear();
+    };
+
+    virtual void empty_the_EOS() = 0;
+    virtual HelmholtzDerivatives all(const CoolPropDbl tau, const CoolPropDbl delta, bool cache_values) = 0;
+
+    CoolPropDbl base(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
+        if (!_base || dont_use_cache)
+            return all(tau, delta, false).alphar;
+        else
+            return _base;
+    };
+    CoolPropDbl dDelta(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
+        if (!_dDelta || dont_use_cache)
+            return all(tau, delta, false).dalphar_ddelta;
+        else
+            return _dDelta;
+    };
+    CoolPropDbl dTau(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
+        if (!_dTau || dont_use_cache)
+            return all(tau, delta, false).dalphar_dtau;
+        else
+            return _dTau;
+    };
+    CoolPropDbl dDelta2(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
+        if (!_dDelta2 || dont_use_cache)
+            return all(tau, delta, false).d2alphar_ddelta2;
+        else
+            return _dDelta2;
+    };
+    CoolPropDbl dDelta_dTau(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
+        if (!_dDelta_dTau || dont_use_cache)
+            return all(tau, delta, false).d2alphar_ddelta_dtau;
+        else
+            return _dDelta_dTau;
+    };
+    CoolPropDbl dTau2(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
+        if (!_dTau2 || dont_use_cache)
+            return all(tau, delta, false).d2alphar_dtau2;
+        else
+            return _dTau2;
+    };
+    CoolPropDbl dDelta3(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
+        if (!_dDelta3 || dont_use_cache)
+            return all(tau, delta, false).d3alphar_ddelta3;
+        else
+            return _dDelta3;
+    };
+    CoolPropDbl dDelta2_dTau(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
+        if (!_dDelta2_dTau || dont_use_cache)
+            return all(tau, delta, false).d3alphar_ddelta2_dtau;
+        else
+            return _dDelta2_dTau;
+    };
+    CoolPropDbl dDelta_dTau2(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
+        if (!_dDelta_dTau2 || dont_use_cache)
+            return all(tau, delta, false).d3alphar_ddelta_dtau2;
+        else
+            return _dDelta_dTau2;
+    };
+    CoolPropDbl dTau3(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
+        if (!_dTau3 || dont_use_cache)
+            return all(tau, delta, false).d3alphar_dtau3;
+        else
+            return _dTau3;
+    };
+    CoolPropDbl dDelta4(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
+        return all(tau, delta, false).d4alphar_ddelta4;
+    };
+    CoolPropDbl dDelta3_dTau(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
+        return all(tau, delta, false).d4alphar_ddelta3_dtau;
+    };
+    CoolPropDbl dDelta2_dTau2(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
+        return all(tau, delta, false).d4alphar_ddelta2_dtau2;
+    };
+    CoolPropDbl dDelta_dTau3(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
+        return all(tau, delta, false).d4alphar_ddelta_dtau3;
+    };
+    CoolPropDbl dTau4(CoolPropDbl tau, CoolPropDbl delta, const bool dont_use_cache = false) {
+        return all(tau, delta, false).d4alphar_dtau4;
+    };
+};
+
+class ResidualHelmholtzContainer : public BaseHelmholtzContainer
+{
+   public:
+    ResidualHelmholtzNonAnalytic NonAnalytic;
+    ResidualHelmholtzSAFTAssociating SAFT;
+    ResidualHelmholtzGeneralizedExponential GenExp;
+    ResidualHelmholtzGeneralizedCubic cubic;
+    ResidualHelmholtzXiangDeiters XiangDeiters;
+    ResidualHelmholtzGaoB GaoB;
+
+    void empty_the_EOS() {
+        NonAnalytic = ResidualHelmholtzNonAnalytic();
+        SAFT = ResidualHelmholtzSAFTAssociating();
+        GenExp = ResidualHelmholtzGeneralizedExponential();
+        cubic = ResidualHelmholtzGeneralizedCubic();
+        XiangDeiters = ResidualHelmholtzXiangDeiters();
+        GaoB = ResidualHelmholtzGaoB();
+    };
+
+    HelmholtzDerivatives all(const CoolPropDbl tau, const CoolPropDbl delta, bool cache_values = false) {
+        HelmholtzDerivatives derivs;  // zeros out the elements
+        GenExp.all(tau, delta, derivs);
+        NonAnalytic.all(tau, delta, derivs);
+        SAFT.all(tau, delta, derivs);
+        cubic.all(tau, delta, derivs);
+        XiangDeiters.all(tau, delta, derivs);
+        GaoB.all(tau, delta, derivs);
+        if (cache_values) {
+            _base = derivs.alphar;
+            _dDelta = derivs.dalphar_ddelta;
+            _dTau = derivs.dalphar_dtau;
+            _dDelta2 = derivs.d2alphar_ddelta2;
+            _dTau2 = derivs.d2alphar_dtau2;
+            _dDelta_dTau = derivs.d2alphar_ddelta_dtau;
+            _dDelta3 = derivs.d3alphar_ddelta3;
+            _dTau3 = derivs.d3alphar_dtau3;
+            _dDelta2_dTau = derivs.d3alphar_ddelta2_dtau;
+            _dDelta_dTau2 = derivs.d3alphar_ddelta_dtau2;
+        }
+        return derivs;
+    };
+};
+
+// #############################################################################
+// #############################################################################
+// #############################################################################
+//                                 IDEAL GAS TERMS
+// #############################################################################
+// #############################################################################
+// #############################################################################
+
+/// The leading term in the EOS used to set the desired reference state
+/**
+\f[
+\alpha^0 = \log(\delta)+a_1+a_2\tau
+\f]
+*/
+class IdealHelmholtzLead : public BaseHelmholtzTerm
+{
+
+   private:
+    CoolPropDbl a1, a2;
+    bool enabled;
+
+   public:
+    // Default constructor
+    IdealHelmholtzLead() : a1(_HUGE), a2(_HUGE), enabled(false) {}
+
+    // Constructor
+    IdealHelmholtzLead(CoolPropDbl a1, CoolPropDbl a2) : a1(a1), a2(a2), enabled(true) {}
+
+    bool is_enabled() const {
+        return enabled;
+    }
+
+    void to_json(rapidjson::Value& el, rapidjson::Document& doc) {
+        el.AddMember("type", "IdealHelmholtzLead", doc.GetAllocator());
+        el.AddMember("a1", static_cast<double>(a1), doc.GetAllocator());
+        el.AddMember("a2", static_cast<double>(a2), doc.GetAllocator());
+    };
+
+    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
+};
+
+/// The term in the EOS used to shift the reference state of the fluid
+/**
+\f[
+\alpha^0 = a_1+a_2\tau
+\f]
+*/
+class IdealHelmholtzEnthalpyEntropyOffset : public BaseHelmholtzTerm
+{
+   private:
+    CoolPropDbl a1, a2;  // Use these variables internally
+    std::string reference;
+    bool enabled;
+
+   public:
+    IdealHelmholtzEnthalpyEntropyOffset() : a1(_HUGE), a2(_HUGE), enabled(false) {}
+
+    // Constructor
+    IdealHelmholtzEnthalpyEntropyOffset(CoolPropDbl a1, CoolPropDbl a2, const std::string& ref) : a1(a1), a2(a2), reference(ref), enabled(true) {}
+
+    // Set the values in the class
+    void set(CoolPropDbl a1, CoolPropDbl a2, const std::string& ref) {
+        // If it doesn't already exist, just set the values
+        if (enabled == false) {
+            this->a1 = a1;
+            this->a2 = a2;
+            enabled = true;
+        } else if (ref == "DEF") {
+            this->a1 = 0.0;
+            this->a2 = 0.0;
+            enabled = false;
+        } else {
+            // Otherwise, increment the values
+            this->a1 += a1;
+            this->a2 += a2;
+            enabled = true;
+        }
+        this->reference = ref;
+    }
+
+    bool is_enabled() const {
+        return enabled;
+    };
+
+    void to_json(rapidjson::Value& el, rapidjson::Document& doc) {
+        el.AddMember("type", "IdealHelmholtzEnthalpyEntropyOffset", doc.GetAllocator());
+        el.AddMember("a1", static_cast<double>(a1), doc.GetAllocator());
+        el.AddMember("a2", static_cast<double>(a2), doc.GetAllocator());
+    };
+    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
+};
+
+/**
+\f[
+\alpha^0 = a_1\ln\tau
+\f]
+*/
+class IdealHelmholtzLogTau : public BaseHelmholtzTerm
+{
+   private:
+    CoolPropDbl a1;
+    bool enabled;
+
+   public:
+    /// Default constructor
+    IdealHelmholtzLogTau() : a1(_HUGE), enabled(false) {}
+
+    // Constructor
+    IdealHelmholtzLogTau(CoolPropDbl a1) : a1(a1), enabled(true) {}
+
+    bool is_enabled() const {
+        return enabled;
+    };
+
+    void to_json(rapidjson::Value& el, rapidjson::Document& doc) {
+        el.AddMember("type", "IdealHelmholtzLogTau", doc.GetAllocator());
+        el.AddMember("a1", static_cast<double>(a1), doc.GetAllocator());
+    };
+    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
+};
+
+/**
+\f[
+\alpha^0 = \displaystyle\sum_i n_i\tau^{t_i}
+\f]
+*/
+class IdealHelmholtzPower : public BaseHelmholtzTerm
+{
+
+   private:
+    std::vector<CoolPropDbl> n, t;  // Use these variables internally
+    std::size_t N;
+    bool enabled;
+
+   public:
+    IdealHelmholtzPower() : N(0), enabled(false){};
+    // Constructor
+    IdealHelmholtzPower(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& t) : n(n), t(t), N(n.size()), enabled(true){};
+
+    bool is_enabled() const {
+        return enabled;
+    };
+
+    void to_json(rapidjson::Value& el, rapidjson::Document& doc) {
+        el.AddMember("type", "IdealHelmholtzPower", doc.GetAllocator());
+        cpjson::set_long_double_array("n", n, el, doc);
+        cpjson::set_long_double_array("t", t, el, doc);
+    };
+    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
+};
+
+/**
+\f[
+\alpha^0 = \displaystyle\sum_i n_i\log[c_i+d_i\exp(\theta_i\tau)]
+\f]
+
+To convert conventional Plank-Einstein forms, given by
+\f$
+\frac{c_p^0}{R} = a_k\displaystyle\frac{\left( b_k/T \right)^2\exp \left( b_k/T \right)}{\left(\exp \left(b_k/T\right) - 1 \right)^2}
+\f$
+and
+\f$
+\alpha^0 = a_k\ln \left[1 - \exp \left( \frac{-b_k\tau}{T_c} \right) \right]
+\f$
+use \f$c = 1\f$, \f$d = -1\f$, \f$n = a\f$, \f$\theta = -\displaystyle\frac{b_k}{T_c}\f$
+
+To convert the second form of Plank-Einstein terms, given by
+\f$
+\frac{c_p^0}{R} = a_k\displaystyle\frac{\left( -b_k/T \right)^2\exp \left( b_k/T \right)}{c\left(\exp \left(-b_k/T\right) + 1 \right)^2}
+\f$
+and
+\f$
+\alpha^0 = a_k\ln \left[c + \exp \left( \frac{b_k\tau}{T_c} \right) \right]
+\f$
+use \f$c = 1\f$, \f$d = 1\f$, \f$n = -a\f$, \f$\theta = \displaystyle\frac{b_k}{T_c}\f$
+
+Converting Aly-Lee tems is a bit more complex
+
+Aly-Lee starts as
+\f[\frac{c_p^0}{R_u} = A + B\left(\frac{C/T}{\sinh(C/T)}\right)^2 + D\left(\frac{E/T}{\cosh(E/T)}\right)^2\f]
+
+Constant is separated out, and handled separately.  sinh part can be expanded as
+\f[B\left(\frac{C/T}{\sinh(C/T)}\right)^2 = \frac{B(-2C/T)^2\exp(-2C/T)}{(1-\exp(-2C/T))^2}\f]
+where
+\f[n_k = B\f]
+\f[\theta_k = -\frac{2C}{T_c}\f]
+\f[c_k = 1\f]
+\f[d_k = -1\f]
+
+cosh part can be expanded as
+\f[D\left(\frac{E/T}{\cosh(E/T)}\right)^2 = \frac{D(-2E/T)^2\exp(-2E/T)}{(1+\exp(-2E/T))^2}\f]
+where
+\f[n_k = -D\f]
+\f[\theta_k = -\frac{2E}{T_c}\f]
+\f[c_k = 1\f]
+\f[d_k = 1\f]
+*/
+class IdealHelmholtzPlanckEinsteinGeneralized : public BaseHelmholtzTerm
+{
+
+   private:
+    std::vector<CoolPropDbl> n, theta, c, d;  // Use these variables internally
+    std::size_t N;
+    bool enabled;
+
+   public:
+    IdealHelmholtzPlanckEinsteinGeneralized() : N(0), enabled(false) {}
+    // Constructor with std::vector instances
+    IdealHelmholtzPlanckEinsteinGeneralized(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& theta,
+                                            const std::vector<CoolPropDbl>& c, const std::vector<CoolPropDbl>& d)
+      : n(n), theta(theta), c(c), d(d), N(n.size()), enabled(true) {}
+
+    // Extend the vectors to allow for multiple instances feeding values to this function
+    void extend(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& theta, const std::vector<CoolPropDbl>& c,
+                const std::vector<CoolPropDbl>& d) {
+        this->n.insert(this->n.end(), n.begin(), n.end());
+        this->theta.insert(this->theta.end(), theta.begin(), theta.end());
+        this->c.insert(this->c.end(), c.begin(), c.end());
+        this->d.insert(this->d.end(), d.begin(), d.end());
+        N += n.size();
+    }
+
+    bool is_enabled() const {
+        return enabled;
+    };
+
+    void to_json(rapidjson::Value& el, rapidjson::Document& doc) {
+        el.AddMember("type", "IdealHelmholtzPlanckEinsteinGeneralized", doc.GetAllocator());
+        cpjson::set_long_double_array("n", n, el, doc);
+        cpjson::set_long_double_array("theta", theta, el, doc);
+    };
+    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
+};
+
+class IdealHelmholtzCP0Constant : public BaseHelmholtzTerm
+{
+
+   private:
+    double cp_over_R, Tc, T0, tau0;  // Use these variables internally
+    bool enabled;
+
+   public:
+    /// Default constructor
+    IdealHelmholtzCP0Constant() : cp_over_R(_HUGE), Tc(_HUGE), T0(_HUGE), tau0(_HUGE) {
+        enabled = false;
+    };
+
+    /// Constructor with just a single double value
+    IdealHelmholtzCP0Constant(CoolPropDbl cp_over_R, CoolPropDbl Tc, CoolPropDbl T0) : cp_over_R(cp_over_R), Tc(Tc), T0(T0) {
+        enabled = true;
+        tau0 = Tc / T0;
+    };
+
+    /// Destructor
+    ~IdealHelmholtzCP0Constant(){};
+
+    bool is_enabled() const {
+        return enabled;
+    };
+
+    void to_json(rapidjson::Value& el, rapidjson::Document& doc) {
+        el.AddMember("type", "IdealGasHelmholtzCP0Constant", doc.GetAllocator());
+        el.AddMember("cp_over_R", cp_over_R, doc.GetAllocator());
+        el.AddMember("Tc", Tc, doc.GetAllocator());
+        el.AddMember("T0", T0, doc.GetAllocator());
+    };
+
+    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
+};
+
+class IdealHelmholtzCP0PolyT : public BaseHelmholtzTerm
+{
+   private:
+    std::vector<CoolPropDbl> c, t;
+    CoolPropDbl Tc, T0, tau0;  // Use these variables internally
+    std::size_t N;
+    bool enabled;
+
+   public:
+    IdealHelmholtzCP0PolyT() : Tc(_HUGE), T0(_HUGE), tau0(_HUGE), N(0), enabled(false) {}
+
+    /// Constructor with std::vectors
+    IdealHelmholtzCP0PolyT(const std::vector<CoolPropDbl>& c, const std::vector<CoolPropDbl>& t, double Tc, double T0)
+      : c(c), t(t), Tc(Tc), T0(T0), tau0(Tc / T0), N(c.size()), enabled(true) {
+        assert(c.size() == t.size());
+    }
+
+    void extend(const std::vector<CoolPropDbl>& c, const std::vector<CoolPropDbl>& t) {
+        this->c.insert(this->c.end(), c.begin(), c.end());
+        this->t.insert(this->t.end(), t.begin(), t.end());
+        N += c.size();
+    }
+
+    bool is_enabled() const {
+        return enabled;
+    };
+
+    void to_json(rapidjson::Value& el, rapidjson::Document& doc);
+    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
+};
+/**
+
+*/
+class IdealHelmholtzGERG2004Sinh : public BaseHelmholtzTerm
+{
+   private:
+    std::vector<CoolPropDbl> n, theta;
+    CoolPropDbl Tc, _Tr;
+    std::size_t N;
+    bool enabled;
+
+   public:
+    IdealHelmholtzGERG2004Sinh() : Tc(_HUGE), _Tr(_HUGE), N(0), enabled(false) {}
+
+    /// Constructor with std::vectors
+    IdealHelmholtzGERG2004Sinh(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& theta, double Tc)
+      : n(n), theta(theta), Tc(Tc), N(n.size()), _Tr(_HUGE), enabled(true) {
+        assert(n.size() == theta.size());
+    }
+
+    void extend(const std::vector<CoolPropDbl>& c, const std::vector<CoolPropDbl>& t) {
+        this->n.insert(this->n.end(), n.begin(), n.end());
+        this->theta.insert(this->theta.end(), theta.begin(), theta.end());
+        N += c.size();
+    }
+    void set_Tred(CoolPropDbl Tr) {
+        this->_Tr = Tr;
+    }
+
+    bool is_enabled() const {
+        return enabled;
+    };
+    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
+};
+
+class IdealHelmholtzGERG2004Cosh : public BaseHelmholtzTerm
+{
+   private:
+    std::vector<CoolPropDbl> n, theta;
+    CoolPropDbl Tc, _Tr;
+    std::size_t N;
+    bool enabled;
+
+   public:
+    IdealHelmholtzGERG2004Cosh() : Tc(_HUGE), _Tr(_HUGE), N(0), enabled(false) {}
+
+    /// Constructor with std::vectors
+    IdealHelmholtzGERG2004Cosh(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& theta, double Tc)
+      : n(n), theta(theta), Tc(Tc), N(n.size()), _Tr(_HUGE), enabled(true) {
+        assert(n.size() == theta.size());
+    }
+
+    void extend(const std::vector<CoolPropDbl>& n, const std::vector<CoolPropDbl>& theta) {
+        this->n.insert(this->n.end(), n.begin(), n.end());
+        this->theta.insert(this->theta.end(), theta.begin(), theta.end());
+        N += n.size();
+    }
+    void set_Tred(CoolPropDbl Tr) {
+        this->_Tr = Tr;
+    }
+
+    bool is_enabled() const {
+        return enabled;
+    };
+    void all(const CoolPropDbl& tau, const CoolPropDbl& delta, HelmholtzDerivatives& derivs) throw();
+};
+
+///// Term in the ideal-gas specific heat equation that is based on Aly-Lee formulation
+///** Specific heat is of the form:
+//\f[
+//\frac{c_p^0}{R_u} = A + B\left(\frac{C/T}{\sinh(C/T)}\right)^2 + D\left(\frac{E/T}{\cosh(E/T)}\right)^2
+//\f]
+//Second partial of ideal-gas Helmholtz energy given directly by specific heat (\f$\displaystyle\alpha_{\tau\tau}^0=-\frac{1}{\tau^2}\frac{c_p^0}{R_u} \f$) - this is obtained by real gas \f$c_p\f$ relationship, and killing off residual Helmholtz terms
+//\f[
+//\alpha^0_{\tau\tau} = -\frac{A}{\tau^2} - \frac{B}{\tau^2}\left(\frac{C/T}{\sinh(C/T)}\right)^2 - \frac{D}{\tau^2}\left(\frac{E/T}{\cosh(E/T)}\right)^2
+//\f]
+//or in terms of \f$ \tau \f$:
+//\f[
+//\alpha^0_{\tau\tau} = -\frac{A}{\tau^2} - \frac{BC^2}{T_c^2}\left(\frac{1}{\sinh(C\tau/T_c)}\right)^2 - \frac{DE^2}{T_c^2}\left(\frac{1}{\cosh(E\tau/T_c)}\right)^2
+//\f]
+//Third partial:
+//\f[
+//\alpha^0_{\tau\tau\tau} = 2\frac{A}{\tau^3} + 2\frac{BC^3}{T_c^3}\frac{\cosh(C\tau/T_c)}{\sinh^3(C\tau/T_c)} +2 \frac{DE^3}{T_c^3}\frac{\sinh(E\tau/T_c)}{\cosh^3(E\tau/T_c)}
+//\f]
+//Now coming back to the ideal gas Helmholtz energy definition:
+//\f[
+//\alpha^0 = -\tau\displaystyle\int_{\tau_0}^{\tau} \frac{1}{\tau^2}\frac{c_p^0}{R_u}d\tau+\displaystyle\int_{\tau_0}^{\tau} \frac{1}{\tau}\frac{c_p^0}{R_u}d\tau
+//\f]
+//Applying derivative
+//\f[
+//\alpha^0_{\tau} = -\displaystyle\int_{\tau_0}^{\tau} \frac{1}{\tau^2}\frac{c_p^0}{R_u}d\tau-\tau\frac{\partial}{\partial \tau}\left[\displaystyle\int_{\tau_0}^{\tau} \frac{1}{\tau^2}\frac{c_p^0}{R_u}d\tau \right]+\frac{\partial}{\partial \tau}\left[\displaystyle\int_{\tau_0}^{\tau} \frac{1}{\tau}\frac{c_p^0}{R_u}d\tau \right]
+//\f]
+//Fundamental theorem of calculus
+//\f[
+//\alpha^0_{\tau} = -\int_{\tau_0}^{\tau} \frac{1}{\tau^2}\frac{c_p^0}{R_u}d\tau-\tau \frac{1}{\tau^2}\frac{c_p^0}{R_u}d\tau+\frac{1}{\tau}\frac{c_p^0}{R_u}
+//\f]
+//Last two terms cancel, leaving
+//\f[
+//\alpha^0_{\tau} = -\int_{\tau_0}^{\tau} \frac{1}{\tau^2}\frac{c_p^0}{R_u}d\tau
+//\f]
+//Another derivative yields (from fundamental theorem of calculus)
+//\f[
+//\alpha^0_{\tau\tau} = - \frac{1}{\tau^2}\frac{c_p^0}{R_u}
+//\f]
+//
+//see also Jaeschke and Schley, 1995, (http://link.springer.com/article/10.1007%2FBF02083547#page-1)
+//*/
+///*
+//class IdealHelmholtzCP0AlyLee : public BaseHelmholtzTerm{
+//private:
+//    std::vector<CoolPropDbl> c;
+//    CoolPropDbl Tc, tau0, T0; // Use these variables internally
+//    bool enabled;
+//public:
+//    IdealHelmholtzCP0AlyLee(){enabled = false;};
+//
+//    /// Constructor with std::vectors
+//    IdealHelmholtzCP0AlyLee(const std::vector<CoolPropDbl> &c, double Tc, double T0)
+//    :c(c), Tc(Tc), T0(T0)
+//    {
+//        tau0=Tc/T0;
+//        enabled = true;
+//    };
+//
+//    /// Destructor
+//    ~IdealHelmholtzCP0AlyLee(){};
+//
+//    bool is_enabled() const {return enabled;};
+//
+//    void to_json(rapidjson::Value &el, rapidjson::Document &doc);
+//
+//
+//    /// The antiderivative given by \f$ \displaystyle\int \frac{1}{\tau^2}\frac{c_p^0}{R_u}d\tau \f$
+//    /**
+//    sympy code for this derivative:
+//
+//        from sympy import *
+//        a1,a2,a3,a4,a5,Tc,tau = symbols('a1,a2,a3,a4,a5,Tc,tau', real = True)
+//        integrand = a1 + a2*(a3/Tc/sinh(a3*tau/Tc))**2 + a4*(a5/Tc/cosh(a5*tau/Tc))**2
+//        integrand = integrand.rewrite(exp)
+//        antideriv = trigsimp(integrate(integrand,tau))
+//        display(antideriv)
+//        print latex(antideriv)
+//        print ccode(antideriv)
+//
+//    \f[
+//    \displaystyle\int \frac{1}{\tau^2}\frac{c_p^0}{R_u}d\tau = -\frac{a_0}{\tau}+\frac{2a_1a_2}{T_c\left[\exp\left(-\frac{2a_2\tau}{T_c}\right)-1\right]}+\frac{2a_3a_4}{T_c\left[\exp\left(-\frac{2a_4\tau}{T_c}\right)+1\right]}
+//    \f]
+//    */
+//    CoolPropDbl anti_deriv_cp0_tau2(const CoolPropDbl &tau);
+//
+//    /// The antiderivative given by \f$ \displaystyle\int \frac{1}{\tau}\frac{c_p^0}{R_u}d\tau \f$
+//    /**
+//    sympy code for this derivative:
+//
+//        a_0,a_1,a_2,a_3,a_4,Tc,tau = symbols('a_0,a_1,a_2,a_3,a_4,Tc,tau', real = True)
+//        integrand = a_0/tau + a_1/tau*(a_2*tau/Tc/sinh(a_2*tau/Tc))**2 + a_3/tau*(a_4*tau/Tc/cosh(a_4*tau/Tc))**2
+//
+//        term2 = a_1/tau*(a_2*tau/Tc/sinh(a_2*tau/Tc))**2
+//        term2 = term2.rewrite(exp)  # Unpack the sinh to exp functions
+//        antideriv2 = trigsimp(integrate(term2,tau))
+//        display(antideriv2)
+//        print latex(antideriv2)
+//        print ccode(antideriv2)
+//
+//        term3 = a_3/tau*(a_4*tau/Tc/cosh(a_4*tau/Tc))**2
+//        term3 = term3.rewrite(exp)  # Unpack the cosh to exp functions
+//        antideriv3 = factor(trigsimp(integrate(term3,tau).rewrite(exp)))
+//        display(antideriv3)
+//        print latex(antideriv3)
+//        print ccode(antideriv3)
+//
+//    Can be broken into three parts (trick is to express \f$sinh\f$ and \f$cosh\f$ in terms of \f$exp\f$ function)
+//
+//    Term 2:
+//    \f[
+//    \displaystyle\int \frac{a_1a_2^2}{T_c^2}\frac{\tau}{\sinh\left(\displaystyle\frac{a_2\tau}{T_c}\right)^2} d\tau = \frac{2 a_{1} a_{2} \tau}{- Tc + Tc e^{- \frac{2 a_{2}}{Tc} \tau}} + a_{1} \log{\left (-1 + e^{- \frac{2 a_{2}}{Tc} \tau} \right )} + \frac{2 a_{1}}{Tc} a_{2} \tau
+//    \f]
+//
+//    Term 3:
+//    \f[
+//    \displaystyle\int \frac{a_1a_2^2}{T_c^2}\frac{\tau}{\cosh\left(\displaystyle\frac{a_2\tau}{T_c}\right)^2} d\tau = - \frac{a_{3}}{Tc \left(e^{\frac{2 a_{4}}{Tc} \tau} + 1\right)} \left(Tc e^{\frac{2 a_{4}}{Tc} \tau} \log{\left (e^{\frac{2 a_{4}}{Tc} \tau} + 1 \right )} + Tc \log{\left (e^{\frac{2 a_{4}}{Tc} \tau} + 1 \right )} - 2 a_{4} \tau e^{\frac{2 a_{4}}{Tc} \tau}\right)
+//    \f]
+//    */
+//    CoolPropDbl anti_deriv_cp0_tau(const CoolPropDbl &tau);
+//
+//    CoolPropDbl base(const CoolPropDbl &tau, const CoolPropDbl &delta) throw();
+//    CoolPropDbl dDelta(const CoolPropDbl &tau, const CoolPropDbl &delta) throw(){return 0.0;};
+//    CoolPropDbl dTau(const CoolPropDbl &tau, const CoolPropDbl &delta) throw();
+//    CoolPropDbl dDelta2(const CoolPropDbl &tau, const CoolPropDbl &delta) throw(){return 0.0;};
+//    CoolPropDbl dDelta_dTau(const CoolPropDbl &tau, const CoolPropDbl &delta) throw(){return 0.0;};
+//    CoolPropDbl dTau2(const CoolPropDbl &tau, const CoolPropDbl &delta) throw();
+//    CoolPropDbl dDelta3(const CoolPropDbl &tau, const CoolPropDbl &delta) throw(){return 0.0;};
+//    CoolPropDbl dDelta2_dTau(const CoolPropDbl &tau, const CoolPropDbl &delta) throw(){return 0.0;};
+//    CoolPropDbl dDelta_dTau2(const CoolPropDbl &tau, const CoolPropDbl &delta) throw(){return 0.0;};
+//    CoolPropDbl dTau3(const CoolPropDbl &tau, const CoolPropDbl &delta) throw();
+//    CoolPropDbl dTau4(const CoolPropDbl &tau, const CoolPropDbl &delta) throw();
+//
+//};
+
+class IdealHelmholtzContainer : public BaseHelmholtzContainer
+{
+   private:
+    double _prefactor;
+
+   public:
+    IdealHelmholtzLead Lead;
+    IdealHelmholtzEnthalpyEntropyOffset EnthalpyEntropyOffsetCore, EnthalpyEntropyOffset;
+    IdealHelmholtzLogTau LogTau;
+    IdealHelmholtzPower Power;
+    IdealHelmholtzPlanckEinsteinGeneralized PlanckEinstein;
+
+    IdealHelmholtzCP0Constant CP0Constant;
+    IdealHelmholtzCP0PolyT CP0PolyT;
+    IdealHelmholtzGERG2004Cosh GERG2004Cosh;
+    IdealHelmholtzGERG2004Sinh GERG2004Sinh;
+
+    IdealHelmholtzContainer() : _prefactor(1.0){};
+
+    void set_prefactor(double prefactor) {
+        _prefactor = prefactor;
+    }
+
+    void set_Tred(double T_red) {
+        GERG2004Cosh.set_Tred(T_red);
+        GERG2004Sinh.set_Tred(T_red);
+    }
+
+    void empty_the_EOS() {
+        Lead = IdealHelmholtzLead();
+        EnthalpyEntropyOffsetCore = IdealHelmholtzEnthalpyEntropyOffset();
+        EnthalpyEntropyOffset = IdealHelmholtzEnthalpyEntropyOffset();
+        LogTau = IdealHelmholtzLogTau();
+        Power = IdealHelmholtzPower();
+        PlanckEinstein = IdealHelmholtzPlanckEinsteinGeneralized();
+        CP0Constant = IdealHelmholtzCP0Constant();
+        CP0PolyT = IdealHelmholtzCP0PolyT();
+        GERG2004Cosh = IdealHelmholtzGERG2004Cosh();
+        GERG2004Sinh = IdealHelmholtzGERG2004Sinh();
+    };
+
+    HelmholtzDerivatives all(const CoolPropDbl tau, const CoolPropDbl delta, bool cache_values = false) {
+        HelmholtzDerivatives derivs;  // zeros out the elements
+        Lead.all(tau, delta, derivs);
+        EnthalpyEntropyOffsetCore.all(tau, delta, derivs);
+        EnthalpyEntropyOffset.all(tau, delta, derivs);
+        LogTau.all(tau, delta, derivs);
+        Power.all(tau, delta, derivs);
+        PlanckEinstein.all(tau, delta, derivs);
+        CP0Constant.all(tau, delta, derivs);
+        CP0PolyT.all(tau, delta, derivs);
+        GERG2004Cosh.all(tau, delta, derivs);
+        GERG2004Sinh.all(tau, delta, derivs);
+
+        if (cache_values) {
+            _base = derivs.alphar * _prefactor;
+            _dDelta = derivs.dalphar_ddelta * _prefactor;
+            _dTau = derivs.dalphar_dtau * _prefactor;
+            _dDelta2 = derivs.d2alphar_ddelta2 * _prefactor;
+            _dTau2 = derivs.d2alphar_dtau2 * _prefactor;
+            _dDelta_dTau = derivs.d2alphar_ddelta_dtau * _prefactor;
+            _dDelta3 = derivs.d3alphar_ddelta3 * _prefactor;
+            _dTau3 = derivs.d3alphar_dtau3 * _prefactor;
+            _dDelta2_dTau = derivs.d3alphar_ddelta2_dtau * _prefactor;
+            _dDelta_dTau2 = derivs.d3alphar_ddelta_dtau2 * _prefactor;
+        }
+        return derivs * _prefactor;
+    };
+};
+}; /* namespace CoolProp */
+
+#endif
```

## CoolProp/include/HumidAirProp.h

 * *Ordering differences only*

```diff
@@ -1,47 +1,47 @@
-
-
-#ifndef HUMAIR_H
-#define HUMAIR_H
-
-#include "CoolPropTools.h"
-
-namespace HumidAir {
-/* \brief Standard I/O function using base SI units exclusively
- *
- */
-double HAPropsSI(const std::string& OutputName, const std::string& Input1Name, double Input1, const std::string& Input2Name, double Input2,
-                 const std::string& Input3Name, double Input3);
-
-/* \brief Standard I/O function using mixed kSI units
- *
- * \warning DEPRECATED!! Use \ref HAPropsSI
- */
-double HAProps(const std::string& OutputName, const std::string& Input1Name, double Input1, const std::string& Input2Name, double Input2,
-               const std::string& Input3Name, double Input3);
-
-// -----------------------
-// Extra I/O function
-// -----------------------
-double HAProps_Aux(const char* OutputName, double T, double p, double W, char* units);
-
-// Properties for Ice Ih at temperatures below 273.16 K
-double IceProps(const char* Name, double T, double p);
-
-//Turn on the use of virial correlations for air and water
-void UseVirialCorrelations(int flag);
-void UseIsothermCompressCorrelation(int flag);
-void UseIdealGasEnthalpyCorrelations(int flag);
-
-// --------------
-// Help functions
-// --------------
-void HAHelp(void);
-int returnHumAirCode(const char* Code);
-
-// ----------------------
-// Other simple functions
-// ----------------------
-double cair_sat(double T);
-
-} /* namespace HumidAir */
-#endif
+
+
+#ifndef HUMAIR_H
+#define HUMAIR_H
+
+#include "CoolPropTools.h"
+
+namespace HumidAir {
+/* \brief Standard I/O function using base SI units exclusively
+ *
+ */
+double HAPropsSI(const std::string& OutputName, const std::string& Input1Name, double Input1, const std::string& Input2Name, double Input2,
+                 const std::string& Input3Name, double Input3);
+
+/* \brief Standard I/O function using mixed kSI units
+ *
+ * \warning DEPRECATED!! Use \ref HAPropsSI
+ */
+double HAProps(const std::string& OutputName, const std::string& Input1Name, double Input1, const std::string& Input2Name, double Input2,
+               const std::string& Input3Name, double Input3);
+
+// -----------------------
+// Extra I/O function
+// -----------------------
+double HAProps_Aux(const char* OutputName, double T, double p, double W, char* units);
+
+// Properties for Ice Ih at temperatures below 273.16 K
+double IceProps(const char* Name, double T, double p);
+
+//Turn on the use of virial correlations for air and water
+void UseVirialCorrelations(int flag);
+void UseIsothermCompressCorrelation(int flag);
+void UseIdealGasEnthalpyCorrelations(int flag);
+
+// --------------
+// Help functions
+// --------------
+void HAHelp(void);
+int returnHumAirCode(const char* Code);
+
+// ----------------------
+// Other simple functions
+// ----------------------
+double cair_sat(double T);
+
+} /* namespace HumidAir */
+#endif
```

## CoolProp/include/Ice.h

 * *Ordering differences only*

```diff
@@ -1,14 +1,14 @@
-#ifndef ICE_H
-#define ICE_H
-
-double psub_Ice(double T);
-double g_Ice(double T, double p);
-double dg_dp_Ice(double T, double p);
-double dg2_dp2_Ice(double T, double p);
-double IsothermCompress_Ice(double T, double p);
-double dg_dT_Ice(double T, double p);
-double h_Ice(double T, double p);
-double s_Ice(double T, double p);
-double rho_Ice(double T, double p);
-
+#ifndef ICE_H
+#define ICE_H
+
+double psub_Ice(double T);
+double g_Ice(double T, double p);
+double dg_dp_Ice(double T, double p);
+double dg2_dp2_Ice(double T, double p);
+double IsothermCompress_Ice(double T, double p);
+double dg_dT_Ice(double T, double p);
+double h_Ice(double T, double p);
+double s_Ice(double T, double p);
+double rho_Ice(double T, double p);
+
 #endif
```

## CoolProp/include/IdealCurves.h

 * *Ordering differences only*

```diff
@@ -1,140 +1,140 @@
-#include "AbstractState.h"
-#include "crossplatform_shared_ptr.h"
-#include "Solvers.h"
-#include "CoolPropTools.h"
-#include <string>
-
-namespace CoolProp {
-
-class CurveTracer : public FuncWrapper1D
-{
-   public:
-    AbstractState* AS;
-    double p0, T0, lnT, lnp, rho_guess;
-    std::vector<double> T, p;
-    enum OBJECTIVE_TYPE
-    {
-        OBJECTIVE_INVALID = 0,
-        OBJECTIVE_CIRCLE,
-        OBJECTIVE_T
-    };
-    OBJECTIVE_TYPE obj;
-    CurveTracer(AbstractState* AS, double p0, double T0) : AS(AS), p0(p0), T0(T0), lnT(_HUGE), lnp(_HUGE), rho_guess(_HUGE), obj(OBJECTIVE_INVALID) {
-        this->p.push_back(p0);
-    };
-    void init() {
-        // Solve for Temperature for first point
-        this->obj = OBJECTIVE_T;
-        this->rho_guess = -1;
-        this->T.push_back(Secant(this, T0, 0.001 * T0, 1e-10, 100));
-    }
-
-    virtual double objective(void) = 0;
-
-    virtual double starting_direction() {
-        return M_PI / 2.0;
-    }
-
-    double call(double t) {
-        if (this->obj == OBJECTIVE_CIRCLE) {
-            double T2, P2;
-            this->TPcoords(t, lnT, lnp, T2, P2);
-            this->AS->update(PT_INPUTS, P2, T2);
-        } else {
-            if (this->rho_guess < 0)
-                this->AS->update(PT_INPUTS, this->p[this->p.size() - 1], t);
-            else {
-                GuessesStructure guesses;
-                guesses.rhomolar = this->rho_guess;
-                this->AS->update_with_guesses(PT_INPUTS, this->p[this->p.size() - 1], t, guesses);
-            }
-        }
-        double r = this->objective();
-        return r;
-    }
-
-    void TPcoords(double t, double lnT, double lnp, double& T, double& p) {
-        double rlnT = 0.1, rlnp = 0.1;
-        T = exp(lnT + rlnT * cos(t));
-        p = exp(lnp + rlnp * sin(t));
-    }
-
-    void trace(std::vector<double>& T, std::vector<double>& p) {
-        double t = this->starting_direction();
-        for (int i = 0; i < 1000; ++i) {
-            try {
-                this->lnT = log(this->T[this->T.size() - 1]);
-                this->lnp = log(this->p[this->p.size() - 1]);
-                this->obj = OBJECTIVE_CIRCLE;
-                t = Brent(this, t - M_PI / 2.0, t + M_PI / 2.0, DBL_EPSILON, 1e-10, 100);
-                double T2, P2;
-                this->TPcoords(t, this->lnT, this->lnp, T2, P2);
-                this->T.push_back(T2);
-                this->p.push_back(P2);
-                if (this->T[this->T.size() - 1] < this->AS->keyed_output(iT_triple)
-                    || this->p[this->p.size() - 1] > 1000 * this->AS->keyed_output(iP_critical)) {
-                    break;
-                }
-            } catch (std::exception&) {
-                break;
-            }
-        }
-        T = this->T;
-        p = this->p;
-    }
-};
-
-class IdealCurveTracer : public CurveTracer
-{
-   public:
-    IdealCurveTracer(AbstractState* AS, double p0, double T0) : CurveTracer(AS, p0, T0) {
-        init();
-    };
-    /// Z = 1
-    double objective(void) {
-        return this->AS->keyed_output(iZ) - 1;
-    };
-};
-
-class BoyleCurveTracer : public CurveTracer
-{
-   public:
-    BoyleCurveTracer(AbstractState* AS, double p0, double T0) : CurveTracer(AS, p0, T0) {
-        init();
-    };
-    /// dZ/dv|T = 0
-    double objective(void) {
-        double r =
-          (this->AS->p() - this->AS->rhomolar() * this->AS->first_partial_deriv(iP, iDmolar, iT)) / (this->AS->gas_constant() * this->AS->T());
-        return r;
-    };
-};
-class JouleInversionCurveTracer : public CurveTracer
-{
-   public:
-    JouleInversionCurveTracer(AbstractState* AS, double p0, double T0) : CurveTracer(AS, p0, T0) {
-        init();
-    };
-    /// dZ/dT|v = 0
-    double objective(void) {
-        double r = (this->AS->gas_constant() * this->AS->T() * 1 / this->AS->rhomolar() * this->AS->first_partial_deriv(iP, iT, iDmolar)
-                    - this->AS->p() * this->AS->gas_constant() / this->AS->rhomolar())
-                   / POW2(this->AS->gas_constant() * this->AS->T());
-        return r;
-    };
-};
-class JouleThomsonCurveTracer : public CurveTracer
-{
-   public:
-    JouleThomsonCurveTracer(AbstractState* AS, double p0, double T0) : CurveTracer(AS, p0, T0) {
-        init();
-    };
-    /// dZ/dT|p = 0
-    double objective(void) {
-        double dvdT__constp = -this->AS->first_partial_deriv(iDmolar, iT, iP) / POW2(this->AS->rhomolar());
-        double r = this->AS->p() / (this->AS->gas_constant() * POW2(this->AS->T())) * (this->AS->T() * dvdT__constp - 1 / this->AS->rhomolar());
-        return r;
-    };
-};
-
+#include "AbstractState.h"
+#include "crossplatform_shared_ptr.h"
+#include "Solvers.h"
+#include "CoolPropTools.h"
+#include <string>
+
+namespace CoolProp {
+
+class CurveTracer : public FuncWrapper1D
+{
+   public:
+    AbstractState* AS;
+    double p0, T0, lnT, lnp, rho_guess;
+    std::vector<double> T, p;
+    enum OBJECTIVE_TYPE
+    {
+        OBJECTIVE_INVALID = 0,
+        OBJECTIVE_CIRCLE,
+        OBJECTIVE_T
+    };
+    OBJECTIVE_TYPE obj;
+    CurveTracer(AbstractState* AS, double p0, double T0) : AS(AS), p0(p0), T0(T0), lnT(_HUGE), lnp(_HUGE), rho_guess(_HUGE), obj(OBJECTIVE_INVALID) {
+        this->p.push_back(p0);
+    };
+    void init() {
+        // Solve for Temperature for first point
+        this->obj = OBJECTIVE_T;
+        this->rho_guess = -1;
+        this->T.push_back(Secant(this, T0, 0.001 * T0, 1e-10, 100));
+    }
+
+    virtual double objective(void) = 0;
+
+    virtual double starting_direction() {
+        return M_PI / 2.0;
+    }
+
+    double call(double t) {
+        if (this->obj == OBJECTIVE_CIRCLE) {
+            double T2, P2;
+            this->TPcoords(t, lnT, lnp, T2, P2);
+            this->AS->update(PT_INPUTS, P2, T2);
+        } else {
+            if (this->rho_guess < 0)
+                this->AS->update(PT_INPUTS, this->p[this->p.size() - 1], t);
+            else {
+                GuessesStructure guesses;
+                guesses.rhomolar = this->rho_guess;
+                this->AS->update_with_guesses(PT_INPUTS, this->p[this->p.size() - 1], t, guesses);
+            }
+        }
+        double r = this->objective();
+        return r;
+    }
+
+    void TPcoords(double t, double lnT, double lnp, double& T, double& p) {
+        double rlnT = 0.1, rlnp = 0.1;
+        T = exp(lnT + rlnT * cos(t));
+        p = exp(lnp + rlnp * sin(t));
+    }
+
+    void trace(std::vector<double>& T, std::vector<double>& p) {
+        double t = this->starting_direction();
+        for (int i = 0; i < 1000; ++i) {
+            try {
+                this->lnT = log(this->T[this->T.size() - 1]);
+                this->lnp = log(this->p[this->p.size() - 1]);
+                this->obj = OBJECTIVE_CIRCLE;
+                t = Brent(this, t - M_PI / 2.0, t + M_PI / 2.0, DBL_EPSILON, 1e-10, 100);
+                double T2, P2;
+                this->TPcoords(t, this->lnT, this->lnp, T2, P2);
+                this->T.push_back(T2);
+                this->p.push_back(P2);
+                if (this->T[this->T.size() - 1] < this->AS->keyed_output(iT_triple)
+                    || this->p[this->p.size() - 1] > 1000 * this->AS->keyed_output(iP_critical)) {
+                    break;
+                }
+            } catch (std::exception&) {
+                break;
+            }
+        }
+        T = this->T;
+        p = this->p;
+    }
+};
+
+class IdealCurveTracer : public CurveTracer
+{
+   public:
+    IdealCurveTracer(AbstractState* AS, double p0, double T0) : CurveTracer(AS, p0, T0) {
+        init();
+    };
+    /// Z = 1
+    double objective(void) {
+        return this->AS->keyed_output(iZ) - 1;
+    };
+};
+
+class BoyleCurveTracer : public CurveTracer
+{
+   public:
+    BoyleCurveTracer(AbstractState* AS, double p0, double T0) : CurveTracer(AS, p0, T0) {
+        init();
+    };
+    /// dZ/dv|T = 0
+    double objective(void) {
+        double r =
+          (this->AS->p() - this->AS->rhomolar() * this->AS->first_partial_deriv(iP, iDmolar, iT)) / (this->AS->gas_constant() * this->AS->T());
+        return r;
+    };
+};
+class JouleInversionCurveTracer : public CurveTracer
+{
+   public:
+    JouleInversionCurveTracer(AbstractState* AS, double p0, double T0) : CurveTracer(AS, p0, T0) {
+        init();
+    };
+    /// dZ/dT|v = 0
+    double objective(void) {
+        double r = (this->AS->gas_constant() * this->AS->T() * 1 / this->AS->rhomolar() * this->AS->first_partial_deriv(iP, iT, iDmolar)
+                    - this->AS->p() * this->AS->gas_constant() / this->AS->rhomolar())
+                   / POW2(this->AS->gas_constant() * this->AS->T());
+        return r;
+    };
+};
+class JouleThomsonCurveTracer : public CurveTracer
+{
+   public:
+    JouleThomsonCurveTracer(AbstractState* AS, double p0, double T0) : CurveTracer(AS, p0, T0) {
+        init();
+    };
+    /// dZ/dT|p = 0
+    double objective(void) {
+        double dvdT__constp = -this->AS->first_partial_deriv(iDmolar, iT, iP) / POW2(this->AS->rhomolar());
+        double r = this->AS->p() / (this->AS->gas_constant() * POW2(this->AS->T())) * (this->AS->T() * dvdT__constp - 1 / this->AS->rhomolar());
+        return r;
+    };
+};
+
 } /* namespace CoolProp */
```

## CoolProp/include/IncompressibleFluid.h

```diff
@@ -1,423 +1,429 @@
-/*
- * CoolPropFluid.h
- *
- *  Created on: 20 Dec 2013
- *      Author: jowr
- */
-
-#ifndef INCOMPRESSIBLEFLUID_H_
-#define INCOMPRESSIBLEFLUID_H_
-
-#include "DataStructures.h"
-#include "Helmholtz.h"
-#include "Solvers.h"
-
-#include <numeric>
-#include <string>
-#include <vector>
-#include <map>
-#include <cassert>
-#include <iterator>
-
-#include <Eigen/Core>
-#include "PolyMath.h"
-#include "MatrixMath.h"
-
-namespace CoolProp {
-
-struct IncompressibleData
-{
-    enum IncompressibleTypeEnum
-    {
-        INCOMPRESSIBLE_NOT_SET,
-        INCOMPRESSIBLE_POLYNOMIAL,
-        INCOMPRESSIBLE_EXPPOLYNOMIAL,
-        INCOMPRESSIBLE_EXPONENTIAL,
-        INCOMPRESSIBLE_LOGEXPONENTIAL,
-        INCOMPRESSIBLE_POLYOFFSET
-    };
-    IncompressibleTypeEnum type;
-    Eigen::MatrixXd coeffs;  //TODO: Can we store the Eigen::Matrix objects more efficiently?
-    //std::vector<std::vector<double> > coeffs;
-    IncompressibleData() {
-        type = INCOMPRESSIBLE_NOT_SET;
-    };
-};
-
-/// A property provider for incompressible solutions and pure fluids
-/**
-This fluid instance is populated using an entry from a JSON file
-*/
-class IncompressibleFluid
-{
-
-   protected:
-    bool strict;
-
-    std::string name;
-    std::string description;
-    std::string reference;
-
-    double Tmin, Tmax;
-    double xmin, xmax;
-    composition_types xid;
-
-    double TminPsat;
-    double xbase, Tbase;
-
-    /// These are the objects that hold the coefficients
-    /** Note that all polynomials require a 2-dimensional array
-     *  of coefficients. This array may have only one row or
-     *  column, but the structure should be 2D. This behaviour is
-     *  hard-coded in the JSON file reader that resides inside
-     *  the IncompressibleLibrary.cpp
-     *  All other functions, also polyoffset, can only handle 1D
-     *  input and throw an error if you feed them other coefficients.
-     */
-
-    /// Density coefficients
-    /** If 2D, the rows are temperature and the columns are concentration.
-     *  If 1D, should be a column vector of temperature coefficients
-     */
-    IncompressibleData density;
-    /// Specific heat coefficients
-    /** If 2D, the rows are temperature and the columns are concentration.
-     *  If 1D, should be a column vector of temperature coefficients
-     *  Fails for all other forms than polynomial due to the automatic
-     *  integration for internal energy and entropy.
-     */
-    IncompressibleData specific_heat;
-    /// Viscosity coefficients
-    /** If 2D, the rows are temperature and the columns are concentration.
-     *  If 1D, should be a column vector of temperature coefficients
-     */
-    IncompressibleData viscosity;
-    /// Conductivity coefficients
-    /** If 2D, the rows are temperature and the columns are concentration.
-     *  If 1D, should be a column vector of temperature coefficients
-     */
-    IncompressibleData conductivity;
-    /// Saturation pressure coefficients
-    /** If 2D, the rows are temperature and the columns are concentration.
-     *  If 1D, should be a column vector of temperature coefficients
-     */
-    IncompressibleData p_sat;
-    /// Freezing temperature coefficients
-    /** If 2D, the rows are concentration and the columns are pressure.
-     *  If 1D, should be a column vector of concentration coefficients
-     */
-    IncompressibleData T_freeze;
-
-    /// Mass fraction conversion coefficients
-    /** If the fluid type is mass-based, it does not do anything. Otherwise,
-     *  it converts the mass fraction to the required input.
-     */
-    IncompressibleData mass2input;
-    /// Volume fraction conversion coefficients
-    /** If the fluid type is volume-based, it does not do anything. Otherwise,
-     *  it converts the volume fraction to the required input.
-     */
-    IncompressibleData volume2input;
-    /// Mole fraction conversion coefficients
-    /** If the fluid type is mole-based, it does not do anything. Otherwise,
-     *  it converts the mole fraction to the required input.
-     */
-    IncompressibleData mole2input;
-
-    Polynomial2DFrac poly;
-
-    // Forward declaration of the some internal functions
-    //double h_u(double T, double p, double x);
-    //double u_h(double T, double p, double x);
-
-   public:
-    IncompressibleFluid() : Tmin(_HUGE), Tmax(_HUGE), xmin(_HUGE), xmax(_HUGE), TminPsat(_HUGE), xbase(_HUGE), Tbase(_HUGE) {
-        strict = true;
-        xid = IFRAC_UNDEFINED;
-    };
-    virtual ~IncompressibleFluid(){};
-
-    std::string getName() const {
-        return name;
-    }
-    std::string get_name() const {
-        return getName();
-    }  // For backwards-compatibility.
-    std::string getDescription() const {
-        return description;
-    }
-    std::string getReference() const {
-        return reference;
-    }
-
-    double getTmax() const {
-        return Tmax;
-    }
-    double getTmin() const {
-        return Tmin;
-    }
-    double getxmax() const {
-        return xmax;
-    }
-    double getxmin() const {
-        return xmin;
-    }
-    composition_types getxid() const {
-        return xid;
-    }
-    double getTminPsat() const {
-        return TminPsat;
-    }
-    double getTbase() const {
-        return Tbase;
-    }
-    double getxbase() const {
-        return xbase;
-    }
-
-    void setName(const std::string& name) {
-        this->name = name;
-    }
-    void setDescription(const std::string& description) {
-        this->description = description;
-    }
-    void setReference(const std::string& reference) {
-        this->reference = reference;
-    }
-    void setTmax(double Tmax) {
-        this->Tmax = Tmax;
-    }
-    void setTmin(double Tmin) {
-        this->Tmin = Tmin;
-    }
-    void setxmax(double xmax) {
-        this->xmax = xmax;
-    }
-    void setxmin(double xmin) {
-        this->xmin = xmin;
-    }
-    void setxid(composition_types xid) {
-        this->xid = xid;
-    }
-    void setTminPsat(double TminPsat) {
-        this->TminPsat = TminPsat;
-    }
-    void setTbase(double Tbase) {
-        this->Tbase = Tbase;
-    }
-    void setxbase(double xbase) {
-        this->xbase = xbase;
-    }
-
-    /// Setters for the coefficients
-    void setDensity(IncompressibleData density) {
-        this->density = density;
-    }
-    void setSpecificHeat(IncompressibleData specific_heat) {
-        this->specific_heat = specific_heat;
-    }
-    void setViscosity(IncompressibleData viscosity) {
-        this->viscosity = viscosity;
-    }
-    void setConductivity(IncompressibleData conductivity) {
-        this->conductivity = conductivity;
-    }
-    void setPsat(IncompressibleData p_sat) {
-        this->p_sat = p_sat;
-    }
-    void setTfreeze(IncompressibleData T_freeze) {
-        this->T_freeze = T_freeze;
-    }
-
-    /// Setters for the concentration conversion coefficients
-    void setMass2input(IncompressibleData mass2input) {
-        this->mass2input = mass2input;
-    }
-    void setVolume2input(IncompressibleData volume2input) {
-        this->volume2input = volume2input;
-    }
-    void setMole2input(IncompressibleData mole2input) {
-        this->mole2input = mole2input;
-    }
-
-    /// A function to check coefficients and equation types.
-    void validate();
-    /// A function to test the density coefficients for 1D or 2D
-    bool is_pure();
-
-   protected:
-    /// Base functions that handle the custom function types
-    double baseExponential(IncompressibleData data, double y, double ybase);
-    double baseLogexponential(IncompressibleData data, double y, double ybase);
-    double baseExponentialOffset(IncompressibleData data, double y);
-    double basePolyOffset(IncompressibleData data, double y, double z = 0.0);
-
-   public:
-    /* All functions need T and p as input. Might not
-     * be necessary, but gives a clearer structure.
-     */
-    /// Density as a function of temperature, pressure and composition.
-    double rho(double T, double p, double x);
-    /// Heat capacities as a function of temperature, pressure and composition.
-    double c(double T, double p, double x);
-    double cp(double T, double p, double x) {
-        throw ValueError(format("%s (%d): Please use the c-function instead.", __FILE__, __LINE__));
-    }
-    double cv(double T, double p, double x) {
-        throw ValueError(format("%s (%d): Please use the c-function instead.", __FILE__, __LINE__));
-    }
-    /// Entropy as a function of temperature, pressure and composition.
-    double s(double T, double p, double x) {
-        throw ValueError(format("%s (%d): The internal calculations have changed, use the backend to calculate entropy from the partial derivatives.",
-                                __FILE__, __LINE__));
-    }
-    /// Internal energy as a function of temperature, pressure and composition.
-    double u(double T, double p, double x) {
-        throw ValueError(
-          format("%s (%d): The internal calculations have changed, use the backend to calculate internal energy from enthalpy.", __FILE__, __LINE__));
-    }
-    /// Enthalpy as a function of temperature, pressure and composition.
-    double h(double T, double p, double x) {
-        throw ValueError(
-          format("%s (%d): The internal calculations have changed, use the backend to calculate enthalpy from the partial derivatives.", __FILE__,
-                 __LINE__));
-    }
-    /// Viscosity as a function of temperature, pressure and composition.
-    double visc(double T, double p, double x);
-    /// Thermal conductivity as a function of temperature, pressure and composition.
-    double cond(double T, double p, double x);
-    /// Saturation pressure as a function of temperature and composition.
-    double psat(double T, double x);
-    /// Freezing temperature as a function of pressure and composition.
-    double Tfreeze(double p, double x);
-
-    /* Below are direct calculations of the derivatives. Nothing
-     * special is going on, we simply use the polynomial class to
-     * derive the different functions with respect to temperature.
-     */
-    /// Partial derivative of density
-    //  with respect to temperature at constant pressure and composition
-    double drhodTatPx(double T, double p, double x);
-    ///// Partial derivative of entropy
-    ////  with respect to temperature at constant pressure and composition
-    //double dsdTatPx  (double T, double p, double x){return c(T,p,x)/T;};
-    ///// Partial derivative of enthalpy
-    ////  with respect to temperature at constant pressure and composition
-    //double dhdTatPx  (double T, double p, double x){return c(T,p,x);};
-    /// Partial derivative of entropy
-    //  with respect to temperature at constant pressure and composition
-    //  integrated in temperature
-    double dsdTatPxdT(double T, double p, double x);
-    /// Partial derivative of enthalpy
-    //  with respect to temperature at constant pressure and composition
-    //  integrated in temperature
-    double dhdTatPxdT(double T, double p, double x);
-
-    /// Mass fraction conversion function
-    /** If the fluid type is mass-based, it does not do anything. Otherwise,
-     *  it converts the mass fraction to the required input. */
-    double inputFromMass(double T, double x);
-    /// Volume fraction conversion function
-    /** If the fluid type is volume-based, it does not do anything. Otherwise,
-     *  it converts the volume fraction to the required input. */
-    double inputFromVolume(double T, double x);
-    /// Mole fraction conversion function
-    /** If the fluid type is mole-based, it does not do anything. Otherwise,
-     *  it converts the mole fraction to the required input. */
-    double inputFromMole(double T, double x);
-
-    /* Some functions can be inverted directly, those are listed
-     * here. It is also possible to solve for other quantities, but
-     * that involves some more sophisticated processing and is not
-     * done here, but in the backend, T(h,p) for example.
-     */
-    /// Temperature as a function of density, pressure and composition.
-    double T_rho(double Dmass, double p, double x);
-    /// Temperature as a function of heat capacities as a function of temperature, pressure and composition.
-    double T_c(double Cmass, double p, double x);
-    /// Temperature as a function of entropy as a function of temperature, pressure and composition.
-    double T_s(double Smass, double p, double x) {
-        throw NotImplementedError(format("%s (%d): T from entropy is not implemented in the fluid, use the backend.", __FILE__, __LINE__));
-    }
-    /// Temperature as a function of internal energy as a function of temperature, pressure and composition.
-    double T_u(double Umass, double p, double x) {
-        throw NotImplementedError(format("%s (%d): T from internal energy is not implemented in the fluid, use the backend.", __FILE__, __LINE__));
-    }
-    /// Temperature as a function of enthalpy, pressure and composition.
-    double T_h(double Hmass, double p, double x) {
-        throw NotImplementedError(format("%s (%d): T from enthalpy is not implemented in the fluid, use the backend.", __FILE__, __LINE__));
-    }
-    /// Viscosity as a function of temperature, pressure and composition.
-    double T_visc(double visc, double p, double x) {
-        throw NotImplementedError(format("%s (%d): T from viscosity is not implemented.", __FILE__, __LINE__));
-    }
-    /// Thermal conductivity as a function of temperature, pressure and composition.
-    double T_cond(double cond, double p, double x) {
-        throw NotImplementedError(format("%s (%d): T from conductivity is not implemented.", __FILE__, __LINE__));
-    }
-    /// Saturation pressure as a function of temperature and composition.
-    double T_psat(double psat, double x) {
-        throw NotImplementedError(format("%s (%d): T from psat is not implemented.", __FILE__, __LINE__));
-    }
-    /// Composition as a function of freezing temperature and pressure.
-    double x_Tfreeze(double Tfreeze, double p) {
-        throw NotImplementedError(format("%s (%d): x from T_freeze is not implemented.", __FILE__, __LINE__));
-    }
-
-   protected:
-    /* Define internal energy and enthalpy as functions of the
-     * other properties to provide data in case there are no
-     * coefficients.
-     */
-    /// Enthalpy from u, p and rho.
-    /** Calculate enthalpy as a function of temperature and
-     *  pressure employing functions for internal energy and
-     *  density. Provides consistent formulations. */
-    double h_u(double T, double p, double x) {
-        return u(T, p, x) + p / rho(T, p, x);
-    };
-
-    /// Internal energy from h, p and rho.
-    /** Calculate internal energy as a function of temperature
-     *  and pressure employing functions for enthalpy and
-     *  density. Provides consistent formulations. */
-    double u_h(double T, double p, double x) {
-        return h(T, p, x) - p / rho(T, p, x);
-    };
-
-    /*
-     * Some more functions to provide a single implementation
-     * of important routines.
-     * We start with the check functions that can validate input
-     * in terms of pressure p, temperature T and composition x.
-     */
-    /// Check validity of temperature input.
-    /** Compares the given temperature T to the result of a
-     *  freezing point calculation. This is not necessarily
-     *  defined for all fluids, default values do not cause errors. */
-    bool checkT(double T, double p, double x);
-
-    /// Check validity of pressure input.
-    /** Compares the given pressure p to the saturation pressure at
-     *  temperature T and throws and exception if p is lower than
-     *  the saturation conditions.
-     *  The default value for psat is -1 yielding true if psat
-     *  is not redefined in the subclass.
-     *  */
-    bool checkP(double T, double p, double x);
-
-   public:
-    /// Check validity of composition input.
-    /** Compares the given composition x to a stored minimum and
-     *  maximum value. Enforces the redefinition of xmin and
-     *  xmax since the default values cause an error. */
-    bool checkX(double x);
-
-    /// Check validity of temperature, pressure and composition input.
-    bool checkTPX(double T, double p, double x) {
-        return (checkT(T, p, x) && checkP(T, p, x) && checkX(x));
-    };
-};
-
-} /* namespace CoolProp */
-#endif /* INCOMPRESSIBLEFLUID_H_ */
+/*
+ * CoolPropFluid.h
+ *
+ *  Created on: 20 Dec 2013
+ *      Author: jowr
+ */
+
+#ifndef INCOMPRESSIBLEFLUID_H_
+#define INCOMPRESSIBLEFLUID_H_
+
+#include "DataStructures.h"
+#include "Helmholtz.h"
+#include "Solvers.h"
+
+#include <numeric>
+#include <string>
+#include <vector>
+#include <map>
+#include <cassert>
+#include <iterator>
+
+#include <Eigen/Core>
+#include "PolyMath.h"
+#include "MatrixMath.h"
+
+namespace CoolProp {
+
+struct IncompressibleData
+{
+    enum IncompressibleTypeEnum
+    {
+        INCOMPRESSIBLE_NOT_SET,
+        INCOMPRESSIBLE_POLYNOMIAL,
+        INCOMPRESSIBLE_EXPPOLYNOMIAL,
+        INCOMPRESSIBLE_EXPONENTIAL,
+        INCOMPRESSIBLE_LOGEXPONENTIAL,
+        INCOMPRESSIBLE_POLYOFFSET
+    };
+    IncompressibleTypeEnum type;
+    Eigen::MatrixXd coeffs;  //TODO: Can we store the Eigen::Matrix objects more efficiently?
+    //std::vector<std::vector<double> > coeffs;
+    IncompressibleData() {
+        type = INCOMPRESSIBLE_NOT_SET;
+    };
+};
+
+#if !defined(NO_FMTLIB) && FMT_VERSION >= 90000
+static int format_as(IncompressibleData::IncompressibleTypeEnum type) {
+    return fmt::underlying(type);
+}
+#endif
+
+/// A property provider for incompressible solutions and pure fluids
+/**
+This fluid instance is populated using an entry from a JSON file
+*/
+class IncompressibleFluid
+{
+
+   protected:
+    bool strict;
+
+    std::string name;
+    std::string description;
+    std::string reference;
+
+    double Tmin, Tmax;
+    double xmin, xmax;
+    composition_types xid;
+
+    double TminPsat;
+    double xbase, Tbase;
+
+    /// These are the objects that hold the coefficients
+    /** Note that all polynomials require a 2-dimensional array
+     *  of coefficients. This array may have only one row or
+     *  column, but the structure should be 2D. This behaviour is
+     *  hard-coded in the JSON file reader that resides inside
+     *  the IncompressibleLibrary.cpp
+     *  All other functions, also polyoffset, can only handle 1D
+     *  input and throw an error if you feed them other coefficients.
+     */
+
+    /// Density coefficients
+    /** If 2D, the rows are temperature and the columns are concentration.
+     *  If 1D, should be a column vector of temperature coefficients
+     */
+    IncompressibleData density;
+    /// Specific heat coefficients
+    /** If 2D, the rows are temperature and the columns are concentration.
+     *  If 1D, should be a column vector of temperature coefficients
+     *  Fails for all other forms than polynomial due to the automatic
+     *  integration for internal energy and entropy.
+     */
+    IncompressibleData specific_heat;
+    /// Viscosity coefficients
+    /** If 2D, the rows are temperature and the columns are concentration.
+     *  If 1D, should be a column vector of temperature coefficients
+     */
+    IncompressibleData viscosity;
+    /// Conductivity coefficients
+    /** If 2D, the rows are temperature and the columns are concentration.
+     *  If 1D, should be a column vector of temperature coefficients
+     */
+    IncompressibleData conductivity;
+    /// Saturation pressure coefficients
+    /** If 2D, the rows are temperature and the columns are concentration.
+     *  If 1D, should be a column vector of temperature coefficients
+     */
+    IncompressibleData p_sat;
+    /// Freezing temperature coefficients
+    /** If 2D, the rows are concentration and the columns are pressure.
+     *  If 1D, should be a column vector of concentration coefficients
+     */
+    IncompressibleData T_freeze;
+
+    /// Mass fraction conversion coefficients
+    /** If the fluid type is mass-based, it does not do anything. Otherwise,
+     *  it converts the mass fraction to the required input.
+     */
+    IncompressibleData mass2input;
+    /// Volume fraction conversion coefficients
+    /** If the fluid type is volume-based, it does not do anything. Otherwise,
+     *  it converts the volume fraction to the required input.
+     */
+    IncompressibleData volume2input;
+    /// Mole fraction conversion coefficients
+    /** If the fluid type is mole-based, it does not do anything. Otherwise,
+     *  it converts the mole fraction to the required input.
+     */
+    IncompressibleData mole2input;
+
+    Polynomial2DFrac poly;
+
+    // Forward declaration of the some internal functions
+    //double h_u(double T, double p, double x);
+    //double u_h(double T, double p, double x);
+
+   public:
+    IncompressibleFluid() : Tmin(_HUGE), Tmax(_HUGE), xmin(_HUGE), xmax(_HUGE), TminPsat(_HUGE), xbase(_HUGE), Tbase(_HUGE) {
+        strict = true;
+        xid = IFRAC_UNDEFINED;
+    };
+    virtual ~IncompressibleFluid(){};
+
+    std::string getName() const {
+        return name;
+    }
+    std::string get_name() const {
+        return getName();
+    }  // For backwards-compatibility.
+    std::string getDescription() const {
+        return description;
+    }
+    std::string getReference() const {
+        return reference;
+    }
+
+    double getTmax() const {
+        return Tmax;
+    }
+    double getTmin() const {
+        return Tmin;
+    }
+    double getxmax() const {
+        return xmax;
+    }
+    double getxmin() const {
+        return xmin;
+    }
+    composition_types getxid() const {
+        return xid;
+    }
+    double getTminPsat() const {
+        return TminPsat;
+    }
+    double getTbase() const {
+        return Tbase;
+    }
+    double getxbase() const {
+        return xbase;
+    }
+
+    void setName(const std::string& name) {
+        this->name = name;
+    }
+    void setDescription(const std::string& description) {
+        this->description = description;
+    }
+    void setReference(const std::string& reference) {
+        this->reference = reference;
+    }
+    void setTmax(double Tmax) {
+        this->Tmax = Tmax;
+    }
+    void setTmin(double Tmin) {
+        this->Tmin = Tmin;
+    }
+    void setxmax(double xmax) {
+        this->xmax = xmax;
+    }
+    void setxmin(double xmin) {
+        this->xmin = xmin;
+    }
+    void setxid(composition_types xid) {
+        this->xid = xid;
+    }
+    void setTminPsat(double TminPsat) {
+        this->TminPsat = TminPsat;
+    }
+    void setTbase(double Tbase) {
+        this->Tbase = Tbase;
+    }
+    void setxbase(double xbase) {
+        this->xbase = xbase;
+    }
+
+    /// Setters for the coefficients
+    void setDensity(IncompressibleData density) {
+        this->density = density;
+    }
+    void setSpecificHeat(IncompressibleData specific_heat) {
+        this->specific_heat = specific_heat;
+    }
+    void setViscosity(IncompressibleData viscosity) {
+        this->viscosity = viscosity;
+    }
+    void setConductivity(IncompressibleData conductivity) {
+        this->conductivity = conductivity;
+    }
+    void setPsat(IncompressibleData p_sat) {
+        this->p_sat = p_sat;
+    }
+    void setTfreeze(IncompressibleData T_freeze) {
+        this->T_freeze = T_freeze;
+    }
+
+    /// Setters for the concentration conversion coefficients
+    void setMass2input(IncompressibleData mass2input) {
+        this->mass2input = mass2input;
+    }
+    void setVolume2input(IncompressibleData volume2input) {
+        this->volume2input = volume2input;
+    }
+    void setMole2input(IncompressibleData mole2input) {
+        this->mole2input = mole2input;
+    }
+
+    /// A function to check coefficients and equation types.
+    void validate();
+    /// A function to test the density coefficients for 1D or 2D
+    bool is_pure();
+
+   protected:
+    /// Base functions that handle the custom function types
+    double baseExponential(IncompressibleData data, double y, double ybase);
+    double baseLogexponential(IncompressibleData data, double y, double ybase);
+    double baseExponentialOffset(IncompressibleData data, double y);
+    double basePolyOffset(IncompressibleData data, double y, double z = 0.0);
+
+   public:
+    /* All functions need T and p as input. Might not
+     * be necessary, but gives a clearer structure.
+     */
+    /// Density as a function of temperature, pressure and composition.
+    double rho(double T, double p, double x);
+    /// Heat capacities as a function of temperature, pressure and composition.
+    double c(double T, double p, double x);
+    double cp(double T, double p, double x) {
+        throw ValueError(format("%s (%d): Please use the c-function instead.", __FILE__, __LINE__));
+    }
+    double cv(double T, double p, double x) {
+        throw ValueError(format("%s (%d): Please use the c-function instead.", __FILE__, __LINE__));
+    }
+    /// Entropy as a function of temperature, pressure and composition.
+    double s(double T, double p, double x) {
+        throw ValueError(format("%s (%d): The internal calculations have changed, use the backend to calculate entropy from the partial derivatives.",
+                                __FILE__, __LINE__));
+    }
+    /// Internal energy as a function of temperature, pressure and composition.
+    double u(double T, double p, double x) {
+        throw ValueError(
+          format("%s (%d): The internal calculations have changed, use the backend to calculate internal energy from enthalpy.", __FILE__, __LINE__));
+    }
+    /// Enthalpy as a function of temperature, pressure and composition.
+    double h(double T, double p, double x) {
+        throw ValueError(
+          format("%s (%d): The internal calculations have changed, use the backend to calculate enthalpy from the partial derivatives.", __FILE__,
+                 __LINE__));
+    }
+    /// Viscosity as a function of temperature, pressure and composition.
+    double visc(double T, double p, double x);
+    /// Thermal conductivity as a function of temperature, pressure and composition.
+    double cond(double T, double p, double x);
+    /// Saturation pressure as a function of temperature and composition.
+    double psat(double T, double x);
+    /// Freezing temperature as a function of pressure and composition.
+    double Tfreeze(double p, double x);
+
+    /* Below are direct calculations of the derivatives. Nothing
+     * special is going on, we simply use the polynomial class to
+     * derive the different functions with respect to temperature.
+     */
+    /// Partial derivative of density
+    //  with respect to temperature at constant pressure and composition
+    double drhodTatPx(double T, double p, double x);
+    ///// Partial derivative of entropy
+    ////  with respect to temperature at constant pressure and composition
+    //double dsdTatPx  (double T, double p, double x){return c(T,p,x)/T;};
+    ///// Partial derivative of enthalpy
+    ////  with respect to temperature at constant pressure and composition
+    //double dhdTatPx  (double T, double p, double x){return c(T,p,x);};
+    /// Partial derivative of entropy
+    //  with respect to temperature at constant pressure and composition
+    //  integrated in temperature
+    double dsdTatPxdT(double T, double p, double x);
+    /// Partial derivative of enthalpy
+    //  with respect to temperature at constant pressure and composition
+    //  integrated in temperature
+    double dhdTatPxdT(double T, double p, double x);
+
+    /// Mass fraction conversion function
+    /** If the fluid type is mass-based, it does not do anything. Otherwise,
+     *  it converts the mass fraction to the required input. */
+    double inputFromMass(double T, double x);
+    /// Volume fraction conversion function
+    /** If the fluid type is volume-based, it does not do anything. Otherwise,
+     *  it converts the volume fraction to the required input. */
+    double inputFromVolume(double T, double x);
+    /// Mole fraction conversion function
+    /** If the fluid type is mole-based, it does not do anything. Otherwise,
+     *  it converts the mole fraction to the required input. */
+    double inputFromMole(double T, double x);
+
+    /* Some functions can be inverted directly, those are listed
+     * here. It is also possible to solve for other quantities, but
+     * that involves some more sophisticated processing and is not
+     * done here, but in the backend, T(h,p) for example.
+     */
+    /// Temperature as a function of density, pressure and composition.
+    double T_rho(double Dmass, double p, double x);
+    /// Temperature as a function of heat capacities as a function of temperature, pressure and composition.
+    double T_c(double Cmass, double p, double x);
+    /// Temperature as a function of entropy as a function of temperature, pressure and composition.
+    double T_s(double Smass, double p, double x) {
+        throw NotImplementedError(format("%s (%d): T from entropy is not implemented in the fluid, use the backend.", __FILE__, __LINE__));
+    }
+    /// Temperature as a function of internal energy as a function of temperature, pressure and composition.
+    double T_u(double Umass, double p, double x) {
+        throw NotImplementedError(format("%s (%d): T from internal energy is not implemented in the fluid, use the backend.", __FILE__, __LINE__));
+    }
+    /// Temperature as a function of enthalpy, pressure and composition.
+    double T_h(double Hmass, double p, double x) {
+        throw NotImplementedError(format("%s (%d): T from enthalpy is not implemented in the fluid, use the backend.", __FILE__, __LINE__));
+    }
+    /// Viscosity as a function of temperature, pressure and composition.
+    double T_visc(double visc, double p, double x) {
+        throw NotImplementedError(format("%s (%d): T from viscosity is not implemented.", __FILE__, __LINE__));
+    }
+    /// Thermal conductivity as a function of temperature, pressure and composition.
+    double T_cond(double cond, double p, double x) {
+        throw NotImplementedError(format("%s (%d): T from conductivity is not implemented.", __FILE__, __LINE__));
+    }
+    /// Saturation pressure as a function of temperature and composition.
+    double T_psat(double psat, double x) {
+        throw NotImplementedError(format("%s (%d): T from psat is not implemented.", __FILE__, __LINE__));
+    }
+    /// Composition as a function of freezing temperature and pressure.
+    double x_Tfreeze(double Tfreeze, double p) {
+        throw NotImplementedError(format("%s (%d): x from T_freeze is not implemented.", __FILE__, __LINE__));
+    }
+
+   protected:
+    /* Define internal energy and enthalpy as functions of the
+     * other properties to provide data in case there are no
+     * coefficients.
+     */
+    /// Enthalpy from u, p and rho.
+    /** Calculate enthalpy as a function of temperature and
+     *  pressure employing functions for internal energy and
+     *  density. Provides consistent formulations. */
+    double h_u(double T, double p, double x) {
+        return u(T, p, x) + p / rho(T, p, x);
+    };
+
+    /// Internal energy from h, p and rho.
+    /** Calculate internal energy as a function of temperature
+     *  and pressure employing functions for enthalpy and
+     *  density. Provides consistent formulations. */
+    double u_h(double T, double p, double x) {
+        return h(T, p, x) - p / rho(T, p, x);
+    };
+
+    /*
+     * Some more functions to provide a single implementation
+     * of important routines.
+     * We start with the check functions that can validate input
+     * in terms of pressure p, temperature T and composition x.
+     */
+    /// Check validity of temperature input.
+    /** Compares the given temperature T to the result of a
+     *  freezing point calculation. This is not necessarily
+     *  defined for all fluids, default values do not cause errors. */
+    bool checkT(double T, double p, double x);
+
+    /// Check validity of pressure input.
+    /** Compares the given pressure p to the saturation pressure at
+     *  temperature T and throws and exception if p is lower than
+     *  the saturation conditions.
+     *  The default value for psat is -1 yielding true if psat
+     *  is not redefined in the subclass.
+     *  */
+    bool checkP(double T, double p, double x);
+
+   public:
+    /// Check validity of composition input.
+    /** Compares the given composition x to a stored minimum and
+     *  maximum value. Enforces the redefinition of xmin and
+     *  xmax since the default values cause an error. */
+    bool checkX(double x);
+
+    /// Check validity of temperature, pressure and composition input.
+    bool checkTPX(double T, double p, double x) {
+        return (checkT(T, p, x) && checkP(T, p, x) && checkX(x));
+    };
+};
+
+} /* namespace CoolProp */
+#endif /* INCOMPRESSIBLEFLUID_H_ */
```

## CoolProp/include/MatrixMath.h

 * *Ordering differences only*

```diff
@@ -1,941 +1,941 @@
-#ifndef MATRIXMATH_H
-#define MATRIXMATH_H
-
-#include "CoolPropTools.h"
-#include "Exceptions.h"
-
-#include <vector>
-#include <string>
-#include <numeric>  // inner_product
-#include <sstream>
-#include "float.h"
-
-#include "Eigen/Core"
-
-/// A wrapper around std::vector
-/** This wrapper makes the standard vector multi-dimensional.
- *  A useful thing even though we might not need it that
- *  much. However, it makes the code look better and the
- *  polynomial class really is a mess...
- *  Source: http://stackoverflow.com/questions/13105514/n-dimensional-vector
- */
-template <size_t dimcount, typename T>
-struct VectorNd
-{
-    typedef std::vector<typename VectorNd<dimcount - 1, T>::type> type;
-};
-template <typename T>
-struct VectorNd<0, T>
-{
-    typedef T type;
-};
-
-namespace CoolProp {
-
-/// Some shortcuts and regularly needed operations
-template <class T>
-std::size_t num_rows(std::vector<T> const& in) {
-    return in.size();
-}
-template <class T>
-std::size_t num_rows(std::vector<std::vector<T>> const& in) {
-    return in.size();
-}
-
-template <class T>
-std::size_t max_cols(std::vector<std::vector<T>> const& in) {
-    std::size_t cols = 0;
-    std::size_t col = 0;
-    for (std::size_t i = 0; i < in.size(); i++) {
-        col = in[i].size();
-        if (cols < col) {
-            cols = col;
-        }
-    }
-    return cols;
-};
-template <class T>
-bool is_squared(std::vector<std::vector<T>> const& in) {
-    std::size_t cols = max_cols(in);
-    if (cols != num_rows(in)) {
-        return false;
-    } else {
-        for (std::size_t i = 0; i < in.size(); i++) {
-            if (cols != in[i].size()) {
-                return false;
-            }
-        }
-    }
-    return true;
-};
-
-template <class T>
-std::size_t num_cols(std::vector<T> const& in) {
-    return 1;
-}
-template <class T>
-std::size_t num_cols(std::vector<std::vector<T>> const& in) {
-    if (num_rows(in) > 0) {
-        if (is_squared(in)) {
-            return in[0].size();
-        } else {
-            return max_cols(in);
-        }
-    } else {
-        return 0;
-    }
-};
-
-/// Convert vectors and matrices
-/** Conversion functions for the different kinds of object-like
- *  parameters. This might be obsolete at a later stage, but now
- *  it is still needed.
- *  @param coefficients matrix containing the ordered coefficients
- *  @param axis axis along which to extract
- */
-template <typename T>
-std::vector<T> eigen_to_vec1D(const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& coefficients, int axis = 0) {
-    std::vector<T> result;
-    size_t r = coefficients.rows(), c = coefficients.cols();
-    if (axis == 0) {
-        if (c != 1) throw ValueError(format("Your matrix has the wrong dimensions: %d,%d", r, c));
-        result.resize(r);
-        for (size_t i = 0; i < r; ++i) {
-            result[i] = coefficients(i, 0);
-        }
-    } else if (axis == 1) {
-        if (r != 1) throw ValueError(format("Your matrix has the wrong dimensions: %d,%d", r, c));
-        result.resize(c);
-        for (size_t i = 0; i < c; ++i) {
-            result[i] = coefficients(0, i);
-        }
-    } else {
-        throw ValueError(format("You have to provide axis information: %d is not valid. ", axis));
-    }
-    return result;
-}
-/// @param coefficients matrix containing the ordered coefficients
-template <class T>
-std::vector<std::vector<T>> eigen_to_vec(const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& coefficients) {
-    // Eigen uses columns as major axis, this might be faster than the row iteration.
-    // However, the 2D vector stores things differently, no idea what is faster...
-    std::vector<std::vector<T>> result;
-    size_t r = coefficients.rows(), c = coefficients.cols();
-    result.resize(r, std::vector<T>(c, 0));  // extends vector if necessary
-    for (size_t i = 0; i < r; ++i) {
-        result[i].resize(c, 0);
-        for (size_t j = 0; j < c; ++j) {
-            result[i][j] = coefficients(i, j);
-        }
-    }
-    return result;
-}
-
-/// @param coefficients matrix containing the ordered coefficients
-template <class T>
-Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> vec_to_eigen(const std::vector<std::vector<T>>& coefficients) {
-    size_t nRows = num_rows(coefficients), nCols = num_cols(coefficients);
-    Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> result(nRows, nCols);
-    for (size_t i = 0; i < nCols; ++i) {
-        for (size_t j = 0; j < nRows; ++j) {
-            result(j, i) = coefficients[j][i];
-        }
-    }
-    return result;
-}
-/**
- * @param coefficients matrix containing the ordered coefficients
- * @param axis axis along which to extract data
- */
-template <class T>
-Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> vec_to_eigen(const std::vector<T>& coefficients, int axis = 0) {
-    size_t nRows = num_rows(coefficients);
-    Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> result;
-    if (axis == 0)
-        result.resize(nRows, 1);
-    else if (axis == 1)
-        result.resize(1, nRows);
-    else
-        throw ValueError(format("You have to provide axis information: %d is not valid. ", axis));
-    for (size_t i = 0; i < nRows; ++i) {
-        if (axis == 0) result(i, 0) = coefficients[i];
-        if (axis == 1) result(0, i) = coefficients[i];
-    }
-    return result;
-}
-/// @param coefficient
-template <class T>
-Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> vec_to_eigen(const T& coefficient) {
-    Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> result = Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>(1, 1);
-    result(0, 0) = coefficient;
-    return result;
-}
-
-/// Convert 1D matrix to vector
-/** Returns either a row- or a column-based
- *  vector. By default, Eigen prefers column
- *  major ordering, just like Fortran.
- */
-
-template <class T>
-Eigen::Matrix<T, Eigen::Dynamic, 1> makeColVector(const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& matrix) {
-    std::size_t r = matrix.rows();
-    std::size_t c = matrix.cols();
-    Eigen::Matrix<T, Eigen::Dynamic, 1> vector;
-    if (r == 1 && c >= 1) {  // Check passed, matrix can be transformed
-        vector = matrix.transpose().block(0, 0, c, r);
-    } else if (r >= 1 && c == 1) {  // Check passed, matrix can be transformed
-        vector = matrix.block(0, 0, r, c);
-    } else {  // Check failed, throw error
-        throw ValueError(format("Your matrix (%d,%d) cannot be converted into a vector (x,1).", r, c));
-    }
-    return vector;
-}
-template <class T>
-Eigen::Matrix<T, Eigen::Dynamic, 1> makeVector(const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& matrix) {
-    return makeColVector(matrix);
-}
-template <class T>
-Eigen::Matrix<T, 1, Eigen::Dynamic> makeRowVector(const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& matrix) {
-    std::size_t r = matrix.rows();
-    std::size_t c = matrix.cols();
-    Eigen::Matrix<T, 1, Eigen::Dynamic> vector;
-    if (r == 1 && c >= 1) {  // Check passed, matrix can be transformed
-        vector = matrix.block(0, 0, r, c);
-    } else if (r >= 1 && c == 1) {  // Check passed, matrix can be transformed
-        vector = matrix.transpose().block(0, 0, c, r);
-    } else {  // Check failed, throw error
-        throw ValueError(format("Your matrix (%d,%d) cannot be converted into a vector (1,x).", r, c));
-    }
-    return vector;
-}
-
-/// Remove rows and columns from matrices
-/** A set of convenience functions inspired by http://stackoverflow.com/questions/13290395/how-to-remove-a-certain-row-or-column-while-using-eigen-library-c
- *  but altered to respect templates.
- */
-template <class T>
-void removeRow(Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& matrix, std::size_t rowToRemove) {
-    //template<class T> void removeRow(Eigen::MatrixXd& matrix, std::size_t rowToRemove){
-    //void removeRow(Eigen::MatrixXd& matrix, unsigned int rowToRemove){
-    //template <typename Derived> void removeRow(Eigen::MatrixBase<Derived> &matrix, std::size_t rowToRemove){
-    std::size_t numRows = matrix.rows() - 1;
-    std::size_t numCols = matrix.cols();
-    if (rowToRemove < numRows) {
-        matrix.block(rowToRemove, 0, numRows - rowToRemove, numCols) = matrix.block(rowToRemove + 1, 0, numRows - rowToRemove, numCols);
-    } else {
-        if (rowToRemove > numRows) {
-            throw ValueError(format("Your matrix does not have enough rows, %d is not greater or equal to %d.", numRows, rowToRemove));
-        }
-        // Do nothing, resize removes the last row
-    }
-    matrix.conservativeResize(numRows, numCols);
-}
-
-template <class T>
-void removeColumn(Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& matrix, std::size_t colToRemove) {
-    //template<class T> void removeColumn(Eigen::MatrixXd& matrix, std::size_t colToRemove){
-    //void removeColumn(Eigen::MatrixXd& matrix, unsigned int colToRemove){
-    //template <typename Derived> void removeColumn(Eigen::MatrixBase<Derived> &matrix, std::size_t colToRemove){
-    std::size_t numRows = matrix.rows();
-    std::size_t numCols = matrix.cols() - 1;
-    if (colToRemove < numCols) {
-        matrix.block(0, colToRemove, numRows, numCols - colToRemove) = matrix.block(0, colToRemove + 1, numRows, numCols - colToRemove);
-    } else {
-        if (colToRemove > numCols) {
-            throw ValueError(format("Your matrix does not have enough columns, %d is not greater or equal to %d.", numCols, colToRemove));
-        }
-        // Do nothing, resize removes the last column
-    }
-    matrix.conservativeResize(numRows, numCols);
-}
-
-///// @param coefficients matrix containing the ordered coefficients
-//template <class T> Eigen::Matrix<T, Eigen::Dynamic,Eigen::Dynamic> convert(const std::vector<std::vector<T> > &coefficients){
-//    size_t nRows = num_rows(coefficients), nCols = num_cols(coefficients);
-//    Eigen::MatrixBase<T> result(nRows,nCols);
-//    for (size_t i = 0; i < nCols; ++i) {
-//        for (size_t j = 0; j < nRows; ++j) {
-//            result(j,i) = coefficients[j][i];
-//        }
-//    }
-//    return result;
-//}
-//
-///// @param coefficients matrix containing the ordered coefficients
-//template <class T, int R, int C> void convert(const std::vector<std::vector<T> > &coefficients, Eigen::Matrix<T,R,C> &result){
-//    size_t nRows = num_rows(coefficients), nCols = num_cols(coefficients);
-//    //Eigen::MatrixBase<T> result(nRows,nCols);
-//    for (size_t i = 0; i < nCols; ++i) {
-//        for (size_t j = 0; j < nRows; ++j) {
-//            result(j,i) = coefficients[j][i];
-//        }
-//    }
-//    //return result;
-//}
-
-//
-//template <class T> void convert(const std::vector<std::vector<T> > &coefficients, Eigen::MatrixBase<T> &result){
-//    size_t nRows = num_rows(coefficients), nCols = num_cols(coefficients);
-//    //Eigen::MatrixBase<T> result;
-//    //if ((R!=nRows) || (C!=nCols))
-//    result.resize(nRows,nCols);
-//    for (size_t i = 0; i < nCols; ++i) {
-//        for (size_t j = 0; j < nRows; ++j) {
-//            result(j,i) = coefficients[j][i];
-//        }
-//    }
-//    //return result;
-//}
-
-//template <class Derived>
-//inline void func1(MatrixBase<Derived> &out_mat ){
-//  // Do something then return a matrix
-//  out_mat = ...
-//}
-
-//template <class Derived>
-//Eigen::Matrix<class Derived::Scalar, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime>
-//Multiply(const Eigen::MatrixBase<DerivedA>& p1,
-//    const Eigen::MatrixBase<DerivedB>& p2)
-//{
-//    return (p1 * p2);
-//}
-//
-//
-//template <typename DerivedA, typename DerivedB>
-//Eigen::Matrix<typename DerivedA::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime>
-//Multiply(const Eigen::MatrixBase<DerivedA>& p1,
-//    const Eigen::MatrixBase<DerivedB>& p2)
-//{
-//    return (p1 * p2);
-//}
-
-/// Templates for printing numbers, vectors and matrices
-static const char* stdFmt = "%8.3f";
-
-///Templates for turning vectors (1D-matrices) into strings
-template <class T>
-std::string vec_to_string(const std::vector<T>& a, const char* fmt) {
-    if (a.size() < 1) return std::string("");
-    std::stringstream out;
-    out << "[ " << format(fmt, a[0]);
-    for (size_t j = 1; j < a.size(); j++) {
-        out << ", " << format(fmt, a[j]);
-    }
-    out << " ]";
-    return out.str();
-};
-template <class T>
-std::string vec_to_string(const std::vector<T>& a) {
-    return vec_to_string(std::vector<double>(a.begin(), a.end()), stdFmt);
-};
-///Templates for turning vectors (1D-matrices) into strings
-inline std::string stringvec_to_string(const std::vector<std::string>& a) {
-    if (a.size() < 1) return std::string("");
-    std::stringstream out;
-    out << "[ " << format("%s", a[0].c_str());
-    for (size_t j = 1; j < a.size(); j++) {
-        out << ", " << format("%s", a[j].c_str());
-    }
-    out << " ]";
-    return out.str();
-};
-
-/// Templates for turning numbers (0D-matrices) into strings
-template <class T>
-std::string vec_to_string(const T& a, const char* fmt) {
-    std::vector<T> vec;
-    vec.push_back(a);
-    return vec_to_string(vec, fmt);
-};
-template <class T>
-std::string vec_to_string(const T& a) {
-    return vec_to_string((double)a, stdFmt);
-};
-
-///Templates for turning 2D-matrices into strings
-template <class T>
-std::string vec_to_string(const std::vector<std::vector<T>>& A, const char* fmt) {
-    if (A.size() < 1) return std::string("");
-    std::stringstream out;
-    out << "[ " << vec_to_string(A[0], fmt);
-    for (size_t j = 1; j < A.size(); j++) {
-        out << ", " << std::endl << "  " << vec_to_string(A[j], fmt);
-    }
-    out << " ]";
-    return out.str();
-};
-template <class T>
-std::string vec_to_string(const std::vector<std::vector<T>>& A) {
-    return vec_to_string(A, stdFmt);
-};
-
-///Templates for turning Eigen matrices into strings
-template <class T>
-std::string mat_to_string(const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& A, const char* fmt) {
-    //std::string mat_to_string(const Eigen::MatrixXd &A, const char *fmt) {
-    std::size_t r = A.rows();
-    std::size_t c = A.cols();
-    if ((r < 1) || (c < 1)) return std::string("");
-    std::stringstream out;
-    out << "[ ";
-    if (r == 1) {
-        out << format(fmt, A(0, 0));
-        for (size_t j = 1; j < c; j++) {
-            out << ", " << format(fmt, A(0, j));
-        }
-    } else {
-        out << mat_to_string(Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>(A.row(0)), fmt);
-        for (size_t i = 1; i < r; i++) {
-            out << ", " << std::endl << "  " << mat_to_string(Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>(A.row(i)), fmt);
-        }
-    }
-    out << " ]";
-    return out.str();
-};
-template <class T>
-std::string mat_to_string(const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& A) {
-    //std::string vec_to_string(const Eigen::MatrixXd &A) {
-    return mat_to_string(A, stdFmt);
-};
-
-///// Templates for printing numbers, vectors and matrices
-//static const char* stdFmt = "%8.3f";
-//
-/////Templates for turning vectors (1D-matrices) into strings
-//template<class T> std::string vec_to_string(const             std::vector<T>   &a, const char *fmt) {
-//    if (a.size()<1) return std::string("");
-//    std::stringstream out;
-//    out << "[ " << format(fmt,a[0]);
-//    for (size_t j = 1; j < a.size(); j++) {
-//        out << ", " << format(fmt, a[j]);
-//    }
-//    out << " ]";
-//    return out.str();
-//};
-//template<class T> std::string vec_to_string(const             std::vector<T>   &a) {
-//    return vec_to_string(a, stdFmt);
-//};
-//
-///// Templates for turning numbers (0D-matrices) into strings
-//template<class T> std::string vec_to_string(const                         T    &a, const char *fmt) {
-//    std::vector<T> vec;
-//    vec.push_back(a);
-//    return vec_to_string(vec, fmt);
-//};
-//template<class T> std::string vec_to_string(const                         T    &a) {
-//    return vec_to_string(a, stdFmt);
-//};
-//
-/////Templates for turning 2D-matrices into strings
-//template<class T> std::string vec_to_string(const std::vector<std::vector<T> > &A, const char *fmt) {
-//    if (A.size()<1) return std::string("");
-//    std::stringstream out;
-//    out << "[ " << vec_to_string(A[0], fmt);
-//    for (size_t j = 1; j < A.size(); j++) {
-//        out << ", " << std::endl << "  " << vec_to_string(A[j], fmt);
-//    }
-//    out << " ]";
-//    return out.str();
-//};
-//template<class T> std::string vec_to_string(const std::vector<std::vector<T> > &A) {
-//    return vec_to_string(A, stdFmt);
-//};
-//
-/////Templates for turning Eigen matrices into strings
-//template <class T>  std::string mat_to_string(const Eigen::Matrix<T,Eigen::Dynamic,Eigen::Dynamic> &A, const char *fmt) {
-////std::string mat_to_string(const Eigen::MatrixXd &A, const char *fmt) {
-//    std::size_t r = A.rows();
-//    std::size_t c = A.cols();
-//    if ((r<1)||(c<1)) return std::string("");
-//    std::stringstream out;
-//    out << "[ ";
-//    if (r==1) {
-//        out << format(fmt, A(0,0));
-//        for (size_t j = 1; j < c; j++) {
-//            out << ", " << format(fmt, A(0,j));
-//        }
-//    } else {
-//        out << mat_to_string(Eigen::Matrix<T,Eigen::Dynamic,Eigen::Dynamic>(A.row(0)), fmt);
-//        for (size_t i = 1; i < r; i++) {
-//            out << ", " << std::endl << "  " << mat_to_string(Eigen::Matrix<T,Eigen::Dynamic,Eigen::Dynamic>(A.row(i)), fmt);
-//        }
-//    }
-//    out << " ]";
-//    return out.str();
-//};
-//template <class T> std::string mat_to_string(const Eigen::Matrix<T,Eigen::Dynamic,Eigen::Dynamic> &A) {
-////std::string vec_to_string(const Eigen::MatrixXd &A) {
-//    return mat_to_string(A, stdFmt);
-//};
-
-/// Template class for turning numbers (0D-matrices) into strings
-//template<class T> std::string vec_to_string(const             T  &a){
-//    return vec_to_string(a, stdFmt);
-//    std::stringstream out;
-//    out << format("[ %7.3f ]",a);
-//    return out.str();
-//};
-//template<class T> std::string vec_to_string(const VectorNd<0, T> &a){
-//    return vec_to_string(a, stdFmt);
-//};
-//template<class T> std::string vec_to_string(const VectorNd<0, T> &a, const char *fmt) {
-//    VectorNd<1, T> vec;
-//    vec.push_back(a);
-//    return vec_to_string(vec, fmt);
-//};
-//
-/////Template classes for turning vectors (1D-matrices) into strings
-//template<class T> std::string vec_to_string(const VectorNd<1, T> &a) {
-//    return vec_to_string(a, stdFmt);
-//};
-//template<class T> std::string vec_to_string(const VectorNd<1, T> &a, const char *fmt) {
-//    if (a.size()<1) {
-//        return std::string("");
-//    } else {
-//        std::stringstream out;
-//        out << "[ ";
-//        out << format(fmt,a[0]);
-//        for (size_t j = 1; j < a.size(); j++) {
-//            out << ", ";
-//            out << format(fmt,a[j]);
-//        }
-//        out << " ]";
-//        return out.str();
-//    }
-//};
-//
-/////Template classes for turning 2D-matrices into strings
-//template<class T> std::string vec_to_string(const VectorNd<2, T> &A) {
-//    return vec_to_string(A, stdFmt);
-//}
-//template<class T> std::string vec_to_string(const VectorNd<2, T> &A, const char *fmt) {
-//    if (A.size()<1) return std::string("");
-//    std::stringstream out;
-//    out << "[ " << format(fmt,A[0]);
-//    for (size_t j = 1; j < A.size(); j++) {
-//        out << ", " << std::endl << "  " << vec_to_string(A[j], fmt);
-//    }
-//    out << " ]";
-//    return out.str();
-//}
-
-///// Publish the linear algebra solver
-//template<class T> std::vector<T>   linsolve(std::vector<std::vector<T> > const& A,             std::vector<T>   const& b);
-//template<class T> std::vector<std::vector<T> > linsolve(std::vector<std::vector<T> > const& A, std::vector<std::vector<T> > const& B);
-//
-///// Some shortcuts and regularly needed operations
-//template<class T> std::size_t         num_rows  (std::vector<std::vector<T> > const& in);
-//template<class T> std::size_t         num_cols  (std::vector<std::vector<T> > const& in);
-//template<class T> std::size_t         max_cols  (std::vector<std::vector<T> > const& in);
-//template<class T> std::vector<T> get_row   (std::vector<std::vector<T> > const& in, size_t row);
-//template<class T> std::vector<T> get_col   (std::vector<std::vector<T> > const& in, size_t col);
-//template<class T> bool                is_squared(std::vector<std::vector<T> > const& in);
-//template<class T> std::vector<std::vector<T> > make_squared(std::vector<std::vector<T> > const& in);
-//
-///// Define some basic math operations for vectors
-//template<class T> T    multiply(            std::vector<T>   const& A,             std::vector<T>   const& B);
-//template<class T>             std::vector<T>   multiply(std::vector<std::vector<T> > const& A,             std::vector<T>   const& B);
-//template<class T> std::vector<std::vector<T> > multiply(std::vector<std::vector<T> > const& A, std::vector<std::vector<T> > const& B);
-//
-//template<class T> T              dot_product(std::vector<T> const& a, std::vector<T> const& b);
-//template<class T> std::vector<T> cross_product(std::vector<T> const& a, std::vector<T> const& b);
-//
-//template<class T> std::vector<std::vector<T> > transpose(std::vector<std::vector<T> > const& in);
-//template<class T> std::vector<std::vector<T> >    invert(std::vector<std::vector<T> > const& in);
-//
-//template<class T> std::string vec_to_string(                        T    const& a);
-//template<class T> std::string vec_to_string(            std::vector<T>   const& a);
-//template<class T> std::string vec_to_string(std::vector<std::vector<T> > const& A);
-//
-//template<class T> std::string vec_to_string(            std::vector<T>   const& a, const char *fmt);
-//template<class T> std::string vec_to_string(std::vector<std::vector<T> > const& A, const char *fmt);
-
-/*
-Owe a debt of gratitude to http://sole.ooz.ie/en - very clear treatment of GJ
-*/
-template <typename T>
-void swap_rows(std::vector<std::vector<T>>* A, size_t row1, size_t row2) {
-    for (size_t col = 0; col < (*A)[0].size(); col++) {
-        std::swap((*A)[row1][col], (*A)[row2][col]);
-    }
-};
-template <typename T>
-void subtract_row_multiple(std::vector<std::vector<T>>* A, size_t row, T multiple, size_t pivot_row) {
-    for (size_t col = 0; col < (*A)[0].size(); col++) {
-        (*A)[row][col] -= multiple * (*A)[pivot_row][col];
-    }
-};
-template <typename T>
-void divide_row_by(std::vector<std::vector<T>>* A, size_t row, T value) {
-    for (size_t col = 0; col < (*A)[0].size(); col++) {
-        (*A)[row][col] /= value;
-    }
-};
-
-template <typename T>
-size_t get_pivot_row(std::vector<std::vector<T>>* A, size_t col) {
-    std::size_t index = col;
-    T max = 0, val;
-
-    for (size_t row = col; row < (*A).size(); row++) {
-        val = (*A)[row][col];
-        if (std::abs(val) > max) {
-            max = std::abs(val);
-            index = row;
-        }
-    }
-    return index;
-};
-
-template <typename T>
-std::vector<std::vector<T>> linsolve_Gauss_Jordan(std::vector<std::vector<T>> const& A, std::vector<std::vector<T>> const& B) {
-    std::vector<std::vector<T>> AB;
-    std::vector<std::vector<T>> X;
-    size_t pivot_row;
-    T pivot_element;
-
-    size_t NrowA = num_rows(A);
-    size_t NrowB = num_rows(B);
-    size_t NcolA = num_cols(A);
-    size_t NcolB = num_cols(B);
-
-    if (NrowA != NrowB) throw ValueError(format("You have to provide matrices with the same number of rows: %d is not %d. ", NrowA, NrowB));
-
-    AB.resize(NrowA, std::vector<T>(NcolA + NcolB, 0));
-    X.resize(NrowA, std::vector<T>(NcolB, 0));
-
-    // Build the augmented matrix
-    for (size_t row = 0; row < NrowA; row++) {
-        for (size_t col = 0; col < NcolA; col++) {
-            AB[row][col] = A[row][col];
-        }
-        for (size_t col = NcolA; col < NcolA + NcolB; col++) {
-            AB[row][col] = B[row][col - NcolA];
-        }
-    }
-
-    for (size_t col = 0; col < NcolA; col++) {
-        // Find the pivot value
-        pivot_row = get_pivot_row(&AB, col);
-
-        if (std::abs(AB[pivot_row][col]) < 10 * DBL_EPSILON) {
-            throw ValueError(format("Zero occurred in row %d, the matrix is singular. ", pivot_row));
-        }
-
-        if (pivot_row >= col) {
-            // Swap pivot row and current row
-            swap_rows(&AB, col, pivot_row);
-        }
-        // Get the pivot element
-        pivot_element = AB[col][col];
-        // Divide the pivot row by the pivot element
-        divide_row_by(&AB, col, pivot_element);
-
-        if (col < NrowA - 1) {
-            // All the rest of the rows, subtract the value of the [r][c] combination
-            for (size_t row = col + 1; row < NrowA; row++) {
-                subtract_row_multiple(&AB, row, AB[row][col], col);
-            }
-        }
-    }
-    for (std::size_t col = NcolA - 1; col > 0; col--) {
-        for (int row = static_cast<int>(col) - 1; row >= 0; row--) {
-            subtract_row_multiple(&AB, row, AB[row][col], col);
-        }
-    }
-    // Set the output value
-    for (size_t row = 0; row < NrowA; row++) {
-        for (size_t col = 0; col < NcolB; col++) {
-            X[row][col] = AB[row][NcolA + col];
-        }
-    }
-    return X;
-};
-
-//std::vector<std::vector<double> > linsolve_Gauss_Jordan_reimpl(std::vector<std::vector<double> > const& A, std::vector<std::vector<double> > const& B) {
-//    std::vector<std::vector<double> > AB;
-//    std::vector<std::vector<double> > X;
-//    size_t pivot_row;
-//    double pivot_element;
-//    double tmp_element;
-//
-//    size_t NrowA = num_rows(A);
-//    size_t NrowB = num_rows(B);
-//    size_t NcolA = num_cols(A);
-//    size_t NcolB = num_cols(B);
-//
-//    if (NrowA!=NrowB) throw ValueError(format("You have to provide matrices with the same number of rows: %d is not %d. ",NrowA,NrowB));
-//
-//    AB.resize(NrowA, std::vector<double>(NcolA+NcolB, 0));
-//     X.resize(NrowA, std::vector<double>(NcolB, 0));
-//
-//    // Build the augmented matrix
-//    for (size_t row = 0; row < NrowA; row++){
-//        for (size_t col  = 0; col < NcolA; col++){
-//            AB[row][col] = A[row][col];
-//        }
-//        for (size_t col  = NcolA; col < NcolA+NcolB; col++){
-//            AB[row][col] = B[row][col-NcolA];
-//        }
-//    }
-//
-//    for (size_t col = 0; col < NcolA; col++){
-//        // Find the pivot row
-//        pivot_row     = 0;
-//        pivot_element = 0.0;
-//        for (size_t row = col; row < NrowA; row++){
-//            tmp_element = std::abs(AB[row][col]);
-//            if (tmp_element>pivot_element) {
-//                pivot_element = tmp_element;
-//                pivot_row = row;
-//            }
-//        }
-//        // Check for errors
-//        if (AB[pivot_row][col]<1./_HUGE) throw ValueError(format("Zero occurred in row %d, the matrix is singular. ",pivot_row));
-//        // Swap the rows
-//        if (pivot_row>col) {
-//            for (size_t colInt = 0; colInt < NcolA; colInt++){
-//                std::swap(AB[pivot_row][colInt],AB[pivot_row][colInt]);
-//            }
-//        }
-//        // Process the entries below current element
-//        for (size_t row = col; row < NrowA; row++){
-//            // Entries to the right of current element (until end of A)
-//            for (size_t colInt = col+1; colInt < NcolA; colInt++){
-//                // All entries in augmented matrix
-//                for (size_t colFull = col; colFull < NcolA+NcolB; colFull++){
-//                    AB[colInt][colFull] -= AB[col][colFull] * AB[colInt][col] / AB[col][col];
-//                }
-//                AB[colInt][col] = 0.0;
-//            }
-//        }
-//    }
-//    return AB;
-//}
-
-template <class T>
-std::vector<std::vector<T>> linsolve(std::vector<std::vector<T>> const& A, std::vector<std::vector<T>> const& B) {
-    return linsolve_Gauss_Jordan(A, B);
-};
-
-template <class T>
-std::vector<T> linsolve(std::vector<std::vector<T>> const& A, std::vector<T> const& b) {
-    std::vector<std::vector<T>> B;
-    for (size_t i = 0; i < b.size(); i++) {
-        B.push_back(std::vector<T>(1, b[i]));
-    }
-    B = linsolve(A, B);
-    B[0].resize(B.size(), 0.0);
-    for (size_t i = 1; i < B.size(); i++) {
-        B[0][i] = B[i][0];
-    }
-    return B[0];
-};
-
-template <class T>
-std::vector<T> get_row(std::vector<std::vector<T>> const& in, size_t row) {
-    return in[row];
-};
-template <class T>
-std::vector<T> get_col(std::vector<std::vector<T>> const& in, size_t col) {
-    std::size_t sizeX = in.size();
-    if (sizeX < 1) throw ValueError(format("You have to provide values, a vector length of %d is not valid. ", sizeX));
-    size_t sizeY = in[0].size();
-    if (sizeY < 1) throw ValueError(format("You have to provide values, a vector length of %d is not valid. ", sizeY));
-    std::vector<T> out;
-    for (std::size_t i = 0; i < sizeX; i++) {
-        sizeY = in[i].size();
-        if (sizeY - 1 < col)
-            throw ValueError(format("Your matrix does not have enough entries in row %d, last index %d is less than %d. ", i, sizeY - 1, col));
-        out.push_back(in[i][col]);
-    }
-    return out;
-};
-
-template <class T>
-std::vector<std::vector<T>> make_squared(std::vector<std::vector<T>> const& in) {
-    std::size_t cols = max_cols(in);
-    std::size_t rows = num_rows(in);
-    std::size_t maxVal = 0;
-    std::vector<std::vector<T>> out;
-    std::vector<T> tmp;
-
-    if (cols > rows) {
-        maxVal = cols;
-    } else {
-        maxVal = rows;
-    }
-    out.clear();
-    for (std::size_t i = 0; i < in.size(); i++) {
-        tmp.clear();
-        for (std::size_t j = 0; j < in[i].size(); j++) {
-            tmp.push_back(in[i][j]);
-        }
-        while (maxVal > tmp.size()) {
-            tmp.push_back(0.0);
-        }
-        out.push_back(tmp);
-    }
-    // Check rows
-    tmp.clear();
-    tmp.resize(maxVal, 0.0);
-    while (maxVal > out.size()) {
-        out.push_back(tmp);
-    }
-    return out;
-};
-
-template <class T>
-T multiply(std::vector<T> const& a, std::vector<T> const& b) {
-    return dot_product(a, b);
-};
-template <class T>
-std::vector<T> multiply(std::vector<std::vector<T>> const& A, std::vector<T> const& b) {
-    std::vector<std::vector<T>> B;
-    for (size_t i = 0; i < b.size(); i++) {
-        B.push_back(std::vector<T>(1, b[i]));
-    }
-    B = multiply(A, B);
-    B[0].resize(B.size(), 0.0);
-    for (size_t i = 1; i < B.size(); i++) {
-        B[0][i] = B[i][0];
-    }
-    return B[0];
-}
-
-template <class T>
-std::vector<std::vector<T>> multiply(std::vector<std::vector<T>> const& A, std::vector<std::vector<T>> const& B) {
-    if (num_cols(A) != num_rows(B)) {
-        throw ValueError(format("You have to provide matrices with the same columns and rows: %d is not equal to %d. ", num_cols(A), num_rows(B)));
-    }
-    size_t rows = num_rows(A);
-    size_t cols = num_cols(B);
-    T tmp;
-    std::vector<std::vector<T>> outVec;
-    std::vector<T> tmpVec;
-    outVec.clear();
-    for (size_t i = 0; i < rows; i++) {
-        tmpVec.clear();
-        for (size_t j = 0; j < cols; j++) {
-            tmp = 0.0;
-            for (size_t k = 0; k < num_cols(A); k++) {
-                tmp += A[i][k] * B[k][j];
-            }
-            tmpVec.push_back(tmp);
-        }
-        outVec.push_back(tmpVec);
-    }
-    return outVec;
-};
-
-template <class T>
-T dot_product(std::vector<T> const& a, std::vector<T> const& b) {
-    if (a.size() == b.size()) {
-        return std::inner_product(a.begin(), a.end(), b.begin(), 0.0);
-    }
-    throw ValueError(format("You have to provide vectors with the same length: %d is not equal to %d. ", a.size(), b.size()));
-};
-
-template <class T>
-std::vector<T> cross_product(std::vector<T> const& a, std::vector<T> const& b) {
-    throw NotImplementedError("The cross product function has not been implemented, yet");
-};
-
-template <class T>
-std::vector<std::vector<T>> transpose(std::vector<std::vector<T>> const& in) {
-    size_t sizeX = in.size();
-    if (sizeX < 1) throw ValueError(format("You have to provide values, a vector length of %d is not a valid. ", sizeX));
-    size_t sizeY = in[0].size();
-    size_t sizeYOld = sizeY;
-    if (sizeY < 1) throw ValueError(format("You have to provide values, a vector length of %d is not a valid. ", sizeY));
-    std::vector<std::vector<T>> out(sizeY, std::vector<T>(sizeX));
-    for (size_t i = 0; i < sizeX; ++i) {
-        sizeY = in[i].size();
-        if (sizeY != sizeYOld) throw ValueError(format("You have to provide a rectangular matrix: %d is not equal to %d. ", sizeY, sizeYOld));
-        for (size_t j = 0; j < sizeY; ++j) {
-            out[j][i] = in[i][j];
-        }
-    }
-    return out;
-};
-
-template <class T>
-std::vector<std::vector<T>> invert(std::vector<std::vector<T>> const& in) {
-    if (!is_squared(in)) throw ValueError(format("Only square matrices can be inverted: %d is not equal to %d. ", num_rows(in), num_cols(in)));
-    std::vector<std::vector<T>> identity;
-    // Build the identity matrix
-    size_t dim = num_rows(in);
-    identity.resize(dim, std::vector<T>(dim, 0));
-    for (size_t row = 0; row < dim; row++) {
-        identity[row][row] = 1.0;
-    }
-    return linsolve(in, identity);
-};
-
-inline void removeRow(Eigen::MatrixXd& matrix, unsigned int rowToRemove) {
-    unsigned int numRows = static_cast<unsigned int>(matrix.rows()) - 1;
-    unsigned int numCols = static_cast<unsigned int>(matrix.cols());
-
-    if (rowToRemove <= numRows)
-        matrix.block(rowToRemove, 0, numRows - rowToRemove, numCols) = matrix.block(rowToRemove + 1, 0, numRows - rowToRemove, numCols);
-    else {
-        throw ValueError(format("Trying to remove row index [%d] greater than max index [%d] ", rowToRemove, numRows));
-    }
-    matrix.conservativeResize(numRows, numCols);
-};
-
-inline void removeColumn(Eigen::MatrixXd& matrix, unsigned int colToRemove) {
-    unsigned int numRows = static_cast<unsigned int>(matrix.rows());
-    unsigned int numCols = static_cast<unsigned int>(matrix.cols()) - 1;
-
-    if (colToRemove <= numCols)
-        matrix.block(0, colToRemove, numRows, numCols - colToRemove) = matrix.block(0, colToRemove + 1, numRows, numCols - colToRemove);
-    else {
-        throw ValueError(format("Trying to remove column index [%d] greater than max index [%d] ", colToRemove, numCols));
-    }
-    matrix.conservativeResize(numRows, numCols);
-};
-template <typename Derived>
-inline Eigen::MatrixXd minor_matrix(const Eigen::MatrixBase<Derived>& A, std::size_t i, std::size_t j) {
-    Eigen::MatrixXd Am = A;
-    removeRow(Am, static_cast<unsigned int>(i));
-    removeColumn(Am, static_cast<unsigned int>(j));
-    return Am;
-};
-
-template <typename Derived>
-static Eigen::MatrixXd adjugate(const Eigen::MatrixBase<Derived>& A) {
-    std::size_t N = A.rows();
-    if (N == 1) {
-        Eigen::MatrixXd Aadj(1, 1);
-        Aadj << 1;
-        return Aadj;
-    }
-    Eigen::MatrixXd Aadj(N, N);
-    for (std::size_t i = 0; i < N; ++i) {
-        for (std::size_t j = 0; j < N; ++j) {
-            int negative_1_to_the_i_plus_j = ((i + j) % 2 == 0) ? 1 : -1;
-            Aadj(i, j) = negative_1_to_the_i_plus_j * minor_matrix(A, j, i).determinant();
-        }
-    }
-    return Aadj;
-}
-
-template <typename Derived>
-static Eigen::MatrixXd adjugate_derivative(const Eigen::MatrixBase<Derived>& A, const Eigen::MatrixBase<Derived>& dAdt) {
-    std::size_t N = A.rows();
-    Eigen::MatrixXd Aadj(N, N);
-    for (std::size_t i = 0; i < N; ++i) {
-        for (std::size_t j = 0; j < N; ++j) {
-            int negative_1_to_the_i_plus_j = ((i + j) % 2 == 0) ? 1 : -1;
-            Eigen::MatrixXd mm = minor_matrix(A, j, i);
-            Aadj(i, j) = negative_1_to_the_i_plus_j * (adjugate(minor_matrix(A, j, i)) * minor_matrix(dAdt, j, i)).trace();
-        }
-    }
-    return Aadj;
-}
-
-}; /* namespace CoolProp */
-#endif
+#ifndef MATRIXMATH_H
+#define MATRIXMATH_H
+
+#include "CoolPropTools.h"
+#include "Exceptions.h"
+
+#include <vector>
+#include <string>
+#include <numeric>  // inner_product
+#include <sstream>
+#include "float.h"
+
+#include "Eigen/Core"
+
+/// A wrapper around std::vector
+/** This wrapper makes the standard vector multi-dimensional.
+ *  A useful thing even though we might not need it that
+ *  much. However, it makes the code look better and the
+ *  polynomial class really is a mess...
+ *  Source: http://stackoverflow.com/questions/13105514/n-dimensional-vector
+ */
+template <size_t dimcount, typename T>
+struct VectorNd
+{
+    typedef std::vector<typename VectorNd<dimcount - 1, T>::type> type;
+};
+template <typename T>
+struct VectorNd<0, T>
+{
+    typedef T type;
+};
+
+namespace CoolProp {
+
+/// Some shortcuts and regularly needed operations
+template <class T>
+std::size_t num_rows(std::vector<T> const& in) {
+    return in.size();
+}
+template <class T>
+std::size_t num_rows(std::vector<std::vector<T>> const& in) {
+    return in.size();
+}
+
+template <class T>
+std::size_t max_cols(std::vector<std::vector<T>> const& in) {
+    std::size_t cols = 0;
+    std::size_t col = 0;
+    for (std::size_t i = 0; i < in.size(); i++) {
+        col = in[i].size();
+        if (cols < col) {
+            cols = col;
+        }
+    }
+    return cols;
+};
+template <class T>
+bool is_squared(std::vector<std::vector<T>> const& in) {
+    std::size_t cols = max_cols(in);
+    if (cols != num_rows(in)) {
+        return false;
+    } else {
+        for (std::size_t i = 0; i < in.size(); i++) {
+            if (cols != in[i].size()) {
+                return false;
+            }
+        }
+    }
+    return true;
+};
+
+template <class T>
+std::size_t num_cols(std::vector<T> const& in) {
+    return 1;
+}
+template <class T>
+std::size_t num_cols(std::vector<std::vector<T>> const& in) {
+    if (num_rows(in) > 0) {
+        if (is_squared(in)) {
+            return in[0].size();
+        } else {
+            return max_cols(in);
+        }
+    } else {
+        return 0;
+    }
+};
+
+/// Convert vectors and matrices
+/** Conversion functions for the different kinds of object-like
+ *  parameters. This might be obsolete at a later stage, but now
+ *  it is still needed.
+ *  @param coefficients matrix containing the ordered coefficients
+ *  @param axis axis along which to extract
+ */
+template <typename T>
+std::vector<T> eigen_to_vec1D(const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& coefficients, int axis = 0) {
+    std::vector<T> result;
+    size_t r = coefficients.rows(), c = coefficients.cols();
+    if (axis == 0) {
+        if (c != 1) throw ValueError(format("Your matrix has the wrong dimensions: %d,%d", r, c));
+        result.resize(r);
+        for (size_t i = 0; i < r; ++i) {
+            result[i] = coefficients(i, 0);
+        }
+    } else if (axis == 1) {
+        if (r != 1) throw ValueError(format("Your matrix has the wrong dimensions: %d,%d", r, c));
+        result.resize(c);
+        for (size_t i = 0; i < c; ++i) {
+            result[i] = coefficients(0, i);
+        }
+    } else {
+        throw ValueError(format("You have to provide axis information: %d is not valid. ", axis));
+    }
+    return result;
+}
+/// @param coefficients matrix containing the ordered coefficients
+template <class T>
+std::vector<std::vector<T>> eigen_to_vec(const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& coefficients) {
+    // Eigen uses columns as major axis, this might be faster than the row iteration.
+    // However, the 2D vector stores things differently, no idea what is faster...
+    std::vector<std::vector<T>> result;
+    size_t r = coefficients.rows(), c = coefficients.cols();
+    result.resize(r, std::vector<T>(c, 0));  // extends vector if necessary
+    for (size_t i = 0; i < r; ++i) {
+        result[i].resize(c, 0);
+        for (size_t j = 0; j < c; ++j) {
+            result[i][j] = coefficients(i, j);
+        }
+    }
+    return result;
+}
+
+/// @param coefficients matrix containing the ordered coefficients
+template <class T>
+Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> vec_to_eigen(const std::vector<std::vector<T>>& coefficients) {
+    size_t nRows = num_rows(coefficients), nCols = num_cols(coefficients);
+    Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> result(nRows, nCols);
+    for (size_t i = 0; i < nCols; ++i) {
+        for (size_t j = 0; j < nRows; ++j) {
+            result(j, i) = coefficients[j][i];
+        }
+    }
+    return result;
+}
+/**
+ * @param coefficients matrix containing the ordered coefficients
+ * @param axis axis along which to extract data
+ */
+template <class T>
+Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> vec_to_eigen(const std::vector<T>& coefficients, int axis = 0) {
+    size_t nRows = num_rows(coefficients);
+    Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> result;
+    if (axis == 0)
+        result.resize(nRows, 1);
+    else if (axis == 1)
+        result.resize(1, nRows);
+    else
+        throw ValueError(format("You have to provide axis information: %d is not valid. ", axis));
+    for (size_t i = 0; i < nRows; ++i) {
+        if (axis == 0) result(i, 0) = coefficients[i];
+        if (axis == 1) result(0, i) = coefficients[i];
+    }
+    return result;
+}
+/// @param coefficient
+template <class T>
+Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> vec_to_eigen(const T& coefficient) {
+    Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> result = Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>(1, 1);
+    result(0, 0) = coefficient;
+    return result;
+}
+
+/// Convert 1D matrix to vector
+/** Returns either a row- or a column-based
+ *  vector. By default, Eigen prefers column
+ *  major ordering, just like Fortran.
+ */
+
+template <class T>
+Eigen::Matrix<T, Eigen::Dynamic, 1> makeColVector(const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& matrix) {
+    std::size_t r = matrix.rows();
+    std::size_t c = matrix.cols();
+    Eigen::Matrix<T, Eigen::Dynamic, 1> vector;
+    if (r == 1 && c >= 1) {  // Check passed, matrix can be transformed
+        vector = matrix.transpose().block(0, 0, c, r);
+    } else if (r >= 1 && c == 1) {  // Check passed, matrix can be transformed
+        vector = matrix.block(0, 0, r, c);
+    } else {  // Check failed, throw error
+        throw ValueError(format("Your matrix (%d,%d) cannot be converted into a vector (x,1).", r, c));
+    }
+    return vector;
+}
+template <class T>
+Eigen::Matrix<T, Eigen::Dynamic, 1> makeVector(const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& matrix) {
+    return makeColVector(matrix);
+}
+template <class T>
+Eigen::Matrix<T, 1, Eigen::Dynamic> makeRowVector(const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& matrix) {
+    std::size_t r = matrix.rows();
+    std::size_t c = matrix.cols();
+    Eigen::Matrix<T, 1, Eigen::Dynamic> vector;
+    if (r == 1 && c >= 1) {  // Check passed, matrix can be transformed
+        vector = matrix.block(0, 0, r, c);
+    } else if (r >= 1 && c == 1) {  // Check passed, matrix can be transformed
+        vector = matrix.transpose().block(0, 0, c, r);
+    } else {  // Check failed, throw error
+        throw ValueError(format("Your matrix (%d,%d) cannot be converted into a vector (1,x).", r, c));
+    }
+    return vector;
+}
+
+/// Remove rows and columns from matrices
+/** A set of convenience functions inspired by http://stackoverflow.com/questions/13290395/how-to-remove-a-certain-row-or-column-while-using-eigen-library-c
+ *  but altered to respect templates.
+ */
+template <class T>
+void removeRow(Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& matrix, std::size_t rowToRemove) {
+    //template<class T> void removeRow(Eigen::MatrixXd& matrix, std::size_t rowToRemove){
+    //void removeRow(Eigen::MatrixXd& matrix, unsigned int rowToRemove){
+    //template <typename Derived> void removeRow(Eigen::MatrixBase<Derived> &matrix, std::size_t rowToRemove){
+    std::size_t numRows = matrix.rows() - 1;
+    std::size_t numCols = matrix.cols();
+    if (rowToRemove < numRows) {
+        matrix.block(rowToRemove, 0, numRows - rowToRemove, numCols) = matrix.block(rowToRemove + 1, 0, numRows - rowToRemove, numCols);
+    } else {
+        if (rowToRemove > numRows) {
+            throw ValueError(format("Your matrix does not have enough rows, %d is not greater or equal to %d.", numRows, rowToRemove));
+        }
+        // Do nothing, resize removes the last row
+    }
+    matrix.conservativeResize(numRows, numCols);
+}
+
+template <class T>
+void removeColumn(Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& matrix, std::size_t colToRemove) {
+    //template<class T> void removeColumn(Eigen::MatrixXd& matrix, std::size_t colToRemove){
+    //void removeColumn(Eigen::MatrixXd& matrix, unsigned int colToRemove){
+    //template <typename Derived> void removeColumn(Eigen::MatrixBase<Derived> &matrix, std::size_t colToRemove){
+    std::size_t numRows = matrix.rows();
+    std::size_t numCols = matrix.cols() - 1;
+    if (colToRemove < numCols) {
+        matrix.block(0, colToRemove, numRows, numCols - colToRemove) = matrix.block(0, colToRemove + 1, numRows, numCols - colToRemove);
+    } else {
+        if (colToRemove > numCols) {
+            throw ValueError(format("Your matrix does not have enough columns, %d is not greater or equal to %d.", numCols, colToRemove));
+        }
+        // Do nothing, resize removes the last column
+    }
+    matrix.conservativeResize(numRows, numCols);
+}
+
+///// @param coefficients matrix containing the ordered coefficients
+//template <class T> Eigen::Matrix<T, Eigen::Dynamic,Eigen::Dynamic> convert(const std::vector<std::vector<T> > &coefficients){
+//    size_t nRows = num_rows(coefficients), nCols = num_cols(coefficients);
+//    Eigen::MatrixBase<T> result(nRows,nCols);
+//    for (size_t i = 0; i < nCols; ++i) {
+//        for (size_t j = 0; j < nRows; ++j) {
+//            result(j,i) = coefficients[j][i];
+//        }
+//    }
+//    return result;
+//}
+//
+///// @param coefficients matrix containing the ordered coefficients
+//template <class T, int R, int C> void convert(const std::vector<std::vector<T> > &coefficients, Eigen::Matrix<T,R,C> &result){
+//    size_t nRows = num_rows(coefficients), nCols = num_cols(coefficients);
+//    //Eigen::MatrixBase<T> result(nRows,nCols);
+//    for (size_t i = 0; i < nCols; ++i) {
+//        for (size_t j = 0; j < nRows; ++j) {
+//            result(j,i) = coefficients[j][i];
+//        }
+//    }
+//    //return result;
+//}
+
+//
+//template <class T> void convert(const std::vector<std::vector<T> > &coefficients, Eigen::MatrixBase<T> &result){
+//    size_t nRows = num_rows(coefficients), nCols = num_cols(coefficients);
+//    //Eigen::MatrixBase<T> result;
+//    //if ((R!=nRows) || (C!=nCols))
+//    result.resize(nRows,nCols);
+//    for (size_t i = 0; i < nCols; ++i) {
+//        for (size_t j = 0; j < nRows; ++j) {
+//            result(j,i) = coefficients[j][i];
+//        }
+//    }
+//    //return result;
+//}
+
+//template <class Derived>
+//inline void func1(MatrixBase<Derived> &out_mat ){
+//  // Do something then return a matrix
+//  out_mat = ...
+//}
+
+//template <class Derived>
+//Eigen::Matrix<class Derived::Scalar, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime>
+//Multiply(const Eigen::MatrixBase<DerivedA>& p1,
+//    const Eigen::MatrixBase<DerivedB>& p2)
+//{
+//    return (p1 * p2);
+//}
+//
+//
+//template <typename DerivedA, typename DerivedB>
+//Eigen::Matrix<typename DerivedA::Scalar, DerivedA::RowsAtCompileTime, DerivedB::ColsAtCompileTime>
+//Multiply(const Eigen::MatrixBase<DerivedA>& p1,
+//    const Eigen::MatrixBase<DerivedB>& p2)
+//{
+//    return (p1 * p2);
+//}
+
+/// Templates for printing numbers, vectors and matrices
+static const char* stdFmt = "%8.3f";
+
+///Templates for turning vectors (1D-matrices) into strings
+template <class T>
+std::string vec_to_string(const std::vector<T>& a, const char* fmt) {
+    if (a.size() < 1) return std::string("");
+    std::stringstream out;
+    out << "[ " << format(fmt, a[0]);
+    for (size_t j = 1; j < a.size(); j++) {
+        out << ", " << format(fmt, a[j]);
+    }
+    out << " ]";
+    return out.str();
+};
+template <class T>
+std::string vec_to_string(const std::vector<T>& a) {
+    return vec_to_string(std::vector<double>(a.begin(), a.end()), stdFmt);
+};
+///Templates for turning vectors (1D-matrices) into strings
+inline std::string stringvec_to_string(const std::vector<std::string>& a) {
+    if (a.size() < 1) return std::string("");
+    std::stringstream out;
+    out << "[ " << format("%s", a[0].c_str());
+    for (size_t j = 1; j < a.size(); j++) {
+        out << ", " << format("%s", a[j].c_str());
+    }
+    out << " ]";
+    return out.str();
+};
+
+/// Templates for turning numbers (0D-matrices) into strings
+template <class T>
+std::string vec_to_string(const T& a, const char* fmt) {
+    std::vector<T> vec;
+    vec.push_back(a);
+    return vec_to_string(vec, fmt);
+};
+template <class T>
+std::string vec_to_string(const T& a) {
+    return vec_to_string((double)a, stdFmt);
+};
+
+///Templates for turning 2D-matrices into strings
+template <class T>
+std::string vec_to_string(const std::vector<std::vector<T>>& A, const char* fmt) {
+    if (A.size() < 1) return std::string("");
+    std::stringstream out;
+    out << "[ " << vec_to_string(A[0], fmt);
+    for (size_t j = 1; j < A.size(); j++) {
+        out << ", " << std::endl << "  " << vec_to_string(A[j], fmt);
+    }
+    out << " ]";
+    return out.str();
+};
+template <class T>
+std::string vec_to_string(const std::vector<std::vector<T>>& A) {
+    return vec_to_string(A, stdFmt);
+};
+
+///Templates for turning Eigen matrices into strings
+template <class T>
+std::string mat_to_string(const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& A, const char* fmt) {
+    //std::string mat_to_string(const Eigen::MatrixXd &A, const char *fmt) {
+    std::size_t r = A.rows();
+    std::size_t c = A.cols();
+    if ((r < 1) || (c < 1)) return std::string("");
+    std::stringstream out;
+    out << "[ ";
+    if (r == 1) {
+        out << format(fmt, A(0, 0));
+        for (size_t j = 1; j < c; j++) {
+            out << ", " << format(fmt, A(0, j));
+        }
+    } else {
+        out << mat_to_string(Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>(A.row(0)), fmt);
+        for (size_t i = 1; i < r; i++) {
+            out << ", " << std::endl << "  " << mat_to_string(Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>(A.row(i)), fmt);
+        }
+    }
+    out << " ]";
+    return out.str();
+};
+template <class T>
+std::string mat_to_string(const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>& A) {
+    //std::string vec_to_string(const Eigen::MatrixXd &A) {
+    return mat_to_string(A, stdFmt);
+};
+
+///// Templates for printing numbers, vectors and matrices
+//static const char* stdFmt = "%8.3f";
+//
+/////Templates for turning vectors (1D-matrices) into strings
+//template<class T> std::string vec_to_string(const             std::vector<T>   &a, const char *fmt) {
+//    if (a.size()<1) return std::string("");
+//    std::stringstream out;
+//    out << "[ " << format(fmt,a[0]);
+//    for (size_t j = 1; j < a.size(); j++) {
+//        out << ", " << format(fmt, a[j]);
+//    }
+//    out << " ]";
+//    return out.str();
+//};
+//template<class T> std::string vec_to_string(const             std::vector<T>   &a) {
+//    return vec_to_string(a, stdFmt);
+//};
+//
+///// Templates for turning numbers (0D-matrices) into strings
+//template<class T> std::string vec_to_string(const                         T    &a, const char *fmt) {
+//    std::vector<T> vec;
+//    vec.push_back(a);
+//    return vec_to_string(vec, fmt);
+//};
+//template<class T> std::string vec_to_string(const                         T    &a) {
+//    return vec_to_string(a, stdFmt);
+//};
+//
+/////Templates for turning 2D-matrices into strings
+//template<class T> std::string vec_to_string(const std::vector<std::vector<T> > &A, const char *fmt) {
+//    if (A.size()<1) return std::string("");
+//    std::stringstream out;
+//    out << "[ " << vec_to_string(A[0], fmt);
+//    for (size_t j = 1; j < A.size(); j++) {
+//        out << ", " << std::endl << "  " << vec_to_string(A[j], fmt);
+//    }
+//    out << " ]";
+//    return out.str();
+//};
+//template<class T> std::string vec_to_string(const std::vector<std::vector<T> > &A) {
+//    return vec_to_string(A, stdFmt);
+//};
+//
+/////Templates for turning Eigen matrices into strings
+//template <class T>  std::string mat_to_string(const Eigen::Matrix<T,Eigen::Dynamic,Eigen::Dynamic> &A, const char *fmt) {
+////std::string mat_to_string(const Eigen::MatrixXd &A, const char *fmt) {
+//    std::size_t r = A.rows();
+//    std::size_t c = A.cols();
+//    if ((r<1)||(c<1)) return std::string("");
+//    std::stringstream out;
+//    out << "[ ";
+//    if (r==1) {
+//        out << format(fmt, A(0,0));
+//        for (size_t j = 1; j < c; j++) {
+//            out << ", " << format(fmt, A(0,j));
+//        }
+//    } else {
+//        out << mat_to_string(Eigen::Matrix<T,Eigen::Dynamic,Eigen::Dynamic>(A.row(0)), fmt);
+//        for (size_t i = 1; i < r; i++) {
+//            out << ", " << std::endl << "  " << mat_to_string(Eigen::Matrix<T,Eigen::Dynamic,Eigen::Dynamic>(A.row(i)), fmt);
+//        }
+//    }
+//    out << " ]";
+//    return out.str();
+//};
+//template <class T> std::string mat_to_string(const Eigen::Matrix<T,Eigen::Dynamic,Eigen::Dynamic> &A) {
+////std::string vec_to_string(const Eigen::MatrixXd &A) {
+//    return mat_to_string(A, stdFmt);
+//};
+
+/// Template class for turning numbers (0D-matrices) into strings
+//template<class T> std::string vec_to_string(const             T  &a){
+//    return vec_to_string(a, stdFmt);
+//    std::stringstream out;
+//    out << format("[ %7.3f ]",a);
+//    return out.str();
+//};
+//template<class T> std::string vec_to_string(const VectorNd<0, T> &a){
+//    return vec_to_string(a, stdFmt);
+//};
+//template<class T> std::string vec_to_string(const VectorNd<0, T> &a, const char *fmt) {
+//    VectorNd<1, T> vec;
+//    vec.push_back(a);
+//    return vec_to_string(vec, fmt);
+//};
+//
+/////Template classes for turning vectors (1D-matrices) into strings
+//template<class T> std::string vec_to_string(const VectorNd<1, T> &a) {
+//    return vec_to_string(a, stdFmt);
+//};
+//template<class T> std::string vec_to_string(const VectorNd<1, T> &a, const char *fmt) {
+//    if (a.size()<1) {
+//        return std::string("");
+//    } else {
+//        std::stringstream out;
+//        out << "[ ";
+//        out << format(fmt,a[0]);
+//        for (size_t j = 1; j < a.size(); j++) {
+//            out << ", ";
+//            out << format(fmt,a[j]);
+//        }
+//        out << " ]";
+//        return out.str();
+//    }
+//};
+//
+/////Template classes for turning 2D-matrices into strings
+//template<class T> std::string vec_to_string(const VectorNd<2, T> &A) {
+//    return vec_to_string(A, stdFmt);
+//}
+//template<class T> std::string vec_to_string(const VectorNd<2, T> &A, const char *fmt) {
+//    if (A.size()<1) return std::string("");
+//    std::stringstream out;
+//    out << "[ " << format(fmt,A[0]);
+//    for (size_t j = 1; j < A.size(); j++) {
+//        out << ", " << std::endl << "  " << vec_to_string(A[j], fmt);
+//    }
+//    out << " ]";
+//    return out.str();
+//}
+
+///// Publish the linear algebra solver
+//template<class T> std::vector<T>   linsolve(std::vector<std::vector<T> > const& A,             std::vector<T>   const& b);
+//template<class T> std::vector<std::vector<T> > linsolve(std::vector<std::vector<T> > const& A, std::vector<std::vector<T> > const& B);
+//
+///// Some shortcuts and regularly needed operations
+//template<class T> std::size_t         num_rows  (std::vector<std::vector<T> > const& in);
+//template<class T> std::size_t         num_cols  (std::vector<std::vector<T> > const& in);
+//template<class T> std::size_t         max_cols  (std::vector<std::vector<T> > const& in);
+//template<class T> std::vector<T> get_row   (std::vector<std::vector<T> > const& in, size_t row);
+//template<class T> std::vector<T> get_col   (std::vector<std::vector<T> > const& in, size_t col);
+//template<class T> bool                is_squared(std::vector<std::vector<T> > const& in);
+//template<class T> std::vector<std::vector<T> > make_squared(std::vector<std::vector<T> > const& in);
+//
+///// Define some basic math operations for vectors
+//template<class T> T    multiply(            std::vector<T>   const& A,             std::vector<T>   const& B);
+//template<class T>             std::vector<T>   multiply(std::vector<std::vector<T> > const& A,             std::vector<T>   const& B);
+//template<class T> std::vector<std::vector<T> > multiply(std::vector<std::vector<T> > const& A, std::vector<std::vector<T> > const& B);
+//
+//template<class T> T              dot_product(std::vector<T> const& a, std::vector<T> const& b);
+//template<class T> std::vector<T> cross_product(std::vector<T> const& a, std::vector<T> const& b);
+//
+//template<class T> std::vector<std::vector<T> > transpose(std::vector<std::vector<T> > const& in);
+//template<class T> std::vector<std::vector<T> >    invert(std::vector<std::vector<T> > const& in);
+//
+//template<class T> std::string vec_to_string(                        T    const& a);
+//template<class T> std::string vec_to_string(            std::vector<T>   const& a);
+//template<class T> std::string vec_to_string(std::vector<std::vector<T> > const& A);
+//
+//template<class T> std::string vec_to_string(            std::vector<T>   const& a, const char *fmt);
+//template<class T> std::string vec_to_string(std::vector<std::vector<T> > const& A, const char *fmt);
+
+/*
+Owe a debt of gratitude to http://sole.ooz.ie/en - very clear treatment of GJ
+*/
+template <typename T>
+void swap_rows(std::vector<std::vector<T>>* A, size_t row1, size_t row2) {
+    for (size_t col = 0; col < (*A)[0].size(); col++) {
+        std::swap((*A)[row1][col], (*A)[row2][col]);
+    }
+};
+template <typename T>
+void subtract_row_multiple(std::vector<std::vector<T>>* A, size_t row, T multiple, size_t pivot_row) {
+    for (size_t col = 0; col < (*A)[0].size(); col++) {
+        (*A)[row][col] -= multiple * (*A)[pivot_row][col];
+    }
+};
+template <typename T>
+void divide_row_by(std::vector<std::vector<T>>* A, size_t row, T value) {
+    for (size_t col = 0; col < (*A)[0].size(); col++) {
+        (*A)[row][col] /= value;
+    }
+};
+
+template <typename T>
+size_t get_pivot_row(std::vector<std::vector<T>>* A, size_t col) {
+    std::size_t index = col;
+    T max = 0, val;
+
+    for (size_t row = col; row < (*A).size(); row++) {
+        val = (*A)[row][col];
+        if (std::abs(val) > max) {
+            max = std::abs(val);
+            index = row;
+        }
+    }
+    return index;
+};
+
+template <typename T>
+std::vector<std::vector<T>> linsolve_Gauss_Jordan(std::vector<std::vector<T>> const& A, std::vector<std::vector<T>> const& B) {
+    std::vector<std::vector<T>> AB;
+    std::vector<std::vector<T>> X;
+    size_t pivot_row;
+    T pivot_element;
+
+    size_t NrowA = num_rows(A);
+    size_t NrowB = num_rows(B);
+    size_t NcolA = num_cols(A);
+    size_t NcolB = num_cols(B);
+
+    if (NrowA != NrowB) throw ValueError(format("You have to provide matrices with the same number of rows: %d is not %d. ", NrowA, NrowB));
+
+    AB.resize(NrowA, std::vector<T>(NcolA + NcolB, 0));
+    X.resize(NrowA, std::vector<T>(NcolB, 0));
+
+    // Build the augmented matrix
+    for (size_t row = 0; row < NrowA; row++) {
+        for (size_t col = 0; col < NcolA; col++) {
+            AB[row][col] = A[row][col];
+        }
+        for (size_t col = NcolA; col < NcolA + NcolB; col++) {
+            AB[row][col] = B[row][col - NcolA];
+        }
+    }
+
+    for (size_t col = 0; col < NcolA; col++) {
+        // Find the pivot value
+        pivot_row = get_pivot_row(&AB, col);
+
+        if (std::abs(AB[pivot_row][col]) < 10 * DBL_EPSILON) {
+            throw ValueError(format("Zero occurred in row %d, the matrix is singular. ", pivot_row));
+        }
+
+        if (pivot_row >= col) {
+            // Swap pivot row and current row
+            swap_rows(&AB, col, pivot_row);
+        }
+        // Get the pivot element
+        pivot_element = AB[col][col];
+        // Divide the pivot row by the pivot element
+        divide_row_by(&AB, col, pivot_element);
+
+        if (col < NrowA - 1) {
+            // All the rest of the rows, subtract the value of the [r][c] combination
+            for (size_t row = col + 1; row < NrowA; row++) {
+                subtract_row_multiple(&AB, row, AB[row][col], col);
+            }
+        }
+    }
+    for (std::size_t col = NcolA - 1; col > 0; col--) {
+        for (int row = static_cast<int>(col) - 1; row >= 0; row--) {
+            subtract_row_multiple(&AB, row, AB[row][col], col);
+        }
+    }
+    // Set the output value
+    for (size_t row = 0; row < NrowA; row++) {
+        for (size_t col = 0; col < NcolB; col++) {
+            X[row][col] = AB[row][NcolA + col];
+        }
+    }
+    return X;
+};
+
+//std::vector<std::vector<double> > linsolve_Gauss_Jordan_reimpl(std::vector<std::vector<double> > const& A, std::vector<std::vector<double> > const& B) {
+//    std::vector<std::vector<double> > AB;
+//    std::vector<std::vector<double> > X;
+//    size_t pivot_row;
+//    double pivot_element;
+//    double tmp_element;
+//
+//    size_t NrowA = num_rows(A);
+//    size_t NrowB = num_rows(B);
+//    size_t NcolA = num_cols(A);
+//    size_t NcolB = num_cols(B);
+//
+//    if (NrowA!=NrowB) throw ValueError(format("You have to provide matrices with the same number of rows: %d is not %d. ",NrowA,NrowB));
+//
+//    AB.resize(NrowA, std::vector<double>(NcolA+NcolB, 0));
+//     X.resize(NrowA, std::vector<double>(NcolB, 0));
+//
+//    // Build the augmented matrix
+//    for (size_t row = 0; row < NrowA; row++){
+//        for (size_t col  = 0; col < NcolA; col++){
+//            AB[row][col] = A[row][col];
+//        }
+//        for (size_t col  = NcolA; col < NcolA+NcolB; col++){
+//            AB[row][col] = B[row][col-NcolA];
+//        }
+//    }
+//
+//    for (size_t col = 0; col < NcolA; col++){
+//        // Find the pivot row
+//        pivot_row     = 0;
+//        pivot_element = 0.0;
+//        for (size_t row = col; row < NrowA; row++){
+//            tmp_element = std::abs(AB[row][col]);
+//            if (tmp_element>pivot_element) {
+//                pivot_element = tmp_element;
+//                pivot_row = row;
+//            }
+//        }
+//        // Check for errors
+//        if (AB[pivot_row][col]<1./_HUGE) throw ValueError(format("Zero occurred in row %d, the matrix is singular. ",pivot_row));
+//        // Swap the rows
+//        if (pivot_row>col) {
+//            for (size_t colInt = 0; colInt < NcolA; colInt++){
+//                std::swap(AB[pivot_row][colInt],AB[pivot_row][colInt]);
+//            }
+//        }
+//        // Process the entries below current element
+//        for (size_t row = col; row < NrowA; row++){
+//            // Entries to the right of current element (until end of A)
+//            for (size_t colInt = col+1; colInt < NcolA; colInt++){
+//                // All entries in augmented matrix
+//                for (size_t colFull = col; colFull < NcolA+NcolB; colFull++){
+//                    AB[colInt][colFull] -= AB[col][colFull] * AB[colInt][col] / AB[col][col];
+//                }
+//                AB[colInt][col] = 0.0;
+//            }
+//        }
+//    }
+//    return AB;
+//}
+
+template <class T>
+std::vector<std::vector<T>> linsolve(std::vector<std::vector<T>> const& A, std::vector<std::vector<T>> const& B) {
+    return linsolve_Gauss_Jordan(A, B);
+};
+
+template <class T>
+std::vector<T> linsolve(std::vector<std::vector<T>> const& A, std::vector<T> const& b) {
+    std::vector<std::vector<T>> B;
+    for (size_t i = 0; i < b.size(); i++) {
+        B.push_back(std::vector<T>(1, b[i]));
+    }
+    B = linsolve(A, B);
+    B[0].resize(B.size(), 0.0);
+    for (size_t i = 1; i < B.size(); i++) {
+        B[0][i] = B[i][0];
+    }
+    return B[0];
+};
+
+template <class T>
+std::vector<T> get_row(std::vector<std::vector<T>> const& in, size_t row) {
+    return in[row];
+};
+template <class T>
+std::vector<T> get_col(std::vector<std::vector<T>> const& in, size_t col) {
+    std::size_t sizeX = in.size();
+    if (sizeX < 1) throw ValueError(format("You have to provide values, a vector length of %d is not valid. ", sizeX));
+    size_t sizeY = in[0].size();
+    if (sizeY < 1) throw ValueError(format("You have to provide values, a vector length of %d is not valid. ", sizeY));
+    std::vector<T> out;
+    for (std::size_t i = 0; i < sizeX; i++) {
+        sizeY = in[i].size();
+        if (sizeY - 1 < col)
+            throw ValueError(format("Your matrix does not have enough entries in row %d, last index %d is less than %d. ", i, sizeY - 1, col));
+        out.push_back(in[i][col]);
+    }
+    return out;
+};
+
+template <class T>
+std::vector<std::vector<T>> make_squared(std::vector<std::vector<T>> const& in) {
+    std::size_t cols = max_cols(in);
+    std::size_t rows = num_rows(in);
+    std::size_t maxVal = 0;
+    std::vector<std::vector<T>> out;
+    std::vector<T> tmp;
+
+    if (cols > rows) {
+        maxVal = cols;
+    } else {
+        maxVal = rows;
+    }
+    out.clear();
+    for (std::size_t i = 0; i < in.size(); i++) {
+        tmp.clear();
+        for (std::size_t j = 0; j < in[i].size(); j++) {
+            tmp.push_back(in[i][j]);
+        }
+        while (maxVal > tmp.size()) {
+            tmp.push_back(0.0);
+        }
+        out.push_back(tmp);
+    }
+    // Check rows
+    tmp.clear();
+    tmp.resize(maxVal, 0.0);
+    while (maxVal > out.size()) {
+        out.push_back(tmp);
+    }
+    return out;
+};
+
+template <class T>
+T multiply(std::vector<T> const& a, std::vector<T> const& b) {
+    return dot_product(a, b);
+};
+template <class T>
+std::vector<T> multiply(std::vector<std::vector<T>> const& A, std::vector<T> const& b) {
+    std::vector<std::vector<T>> B;
+    for (size_t i = 0; i < b.size(); i++) {
+        B.push_back(std::vector<T>(1, b[i]));
+    }
+    B = multiply(A, B);
+    B[0].resize(B.size(), 0.0);
+    for (size_t i = 1; i < B.size(); i++) {
+        B[0][i] = B[i][0];
+    }
+    return B[0];
+}
+
+template <class T>
+std::vector<std::vector<T>> multiply(std::vector<std::vector<T>> const& A, std::vector<std::vector<T>> const& B) {
+    if (num_cols(A) != num_rows(B)) {
+        throw ValueError(format("You have to provide matrices with the same columns and rows: %d is not equal to %d. ", num_cols(A), num_rows(B)));
+    }
+    size_t rows = num_rows(A);
+    size_t cols = num_cols(B);
+    T tmp;
+    std::vector<std::vector<T>> outVec;
+    std::vector<T> tmpVec;
+    outVec.clear();
+    for (size_t i = 0; i < rows; i++) {
+        tmpVec.clear();
+        for (size_t j = 0; j < cols; j++) {
+            tmp = 0.0;
+            for (size_t k = 0; k < num_cols(A); k++) {
+                tmp += A[i][k] * B[k][j];
+            }
+            tmpVec.push_back(tmp);
+        }
+        outVec.push_back(tmpVec);
+    }
+    return outVec;
+};
+
+template <class T>
+T dot_product(std::vector<T> const& a, std::vector<T> const& b) {
+    if (a.size() == b.size()) {
+        return std::inner_product(a.begin(), a.end(), b.begin(), 0.0);
+    }
+    throw ValueError(format("You have to provide vectors with the same length: %d is not equal to %d. ", a.size(), b.size()));
+};
+
+template <class T>
+std::vector<T> cross_product(std::vector<T> const& a, std::vector<T> const& b) {
+    throw NotImplementedError("The cross product function has not been implemented, yet");
+};
+
+template <class T>
+std::vector<std::vector<T>> transpose(std::vector<std::vector<T>> const& in) {
+    size_t sizeX = in.size();
+    if (sizeX < 1) throw ValueError(format("You have to provide values, a vector length of %d is not a valid. ", sizeX));
+    size_t sizeY = in[0].size();
+    size_t sizeYOld = sizeY;
+    if (sizeY < 1) throw ValueError(format("You have to provide values, a vector length of %d is not a valid. ", sizeY));
+    std::vector<std::vector<T>> out(sizeY, std::vector<T>(sizeX));
+    for (size_t i = 0; i < sizeX; ++i) {
+        sizeY = in[i].size();
+        if (sizeY != sizeYOld) throw ValueError(format("You have to provide a rectangular matrix: %d is not equal to %d. ", sizeY, sizeYOld));
+        for (size_t j = 0; j < sizeY; ++j) {
+            out[j][i] = in[i][j];
+        }
+    }
+    return out;
+};
+
+template <class T>
+std::vector<std::vector<T>> invert(std::vector<std::vector<T>> const& in) {
+    if (!is_squared(in)) throw ValueError(format("Only square matrices can be inverted: %d is not equal to %d. ", num_rows(in), num_cols(in)));
+    std::vector<std::vector<T>> identity;
+    // Build the identity matrix
+    size_t dim = num_rows(in);
+    identity.resize(dim, std::vector<T>(dim, 0));
+    for (size_t row = 0; row < dim; row++) {
+        identity[row][row] = 1.0;
+    }
+    return linsolve(in, identity);
+};
+
+inline void removeRow(Eigen::MatrixXd& matrix, unsigned int rowToRemove) {
+    unsigned int numRows = static_cast<unsigned int>(matrix.rows()) - 1;
+    unsigned int numCols = static_cast<unsigned int>(matrix.cols());
+
+    if (rowToRemove <= numRows)
+        matrix.block(rowToRemove, 0, numRows - rowToRemove, numCols) = matrix.block(rowToRemove + 1, 0, numRows - rowToRemove, numCols);
+    else {
+        throw ValueError(format("Trying to remove row index [%d] greater than max index [%d] ", rowToRemove, numRows));
+    }
+    matrix.conservativeResize(numRows, numCols);
+};
+
+inline void removeColumn(Eigen::MatrixXd& matrix, unsigned int colToRemove) {
+    unsigned int numRows = static_cast<unsigned int>(matrix.rows());
+    unsigned int numCols = static_cast<unsigned int>(matrix.cols()) - 1;
+
+    if (colToRemove <= numCols)
+        matrix.block(0, colToRemove, numRows, numCols - colToRemove) = matrix.block(0, colToRemove + 1, numRows, numCols - colToRemove);
+    else {
+        throw ValueError(format("Trying to remove column index [%d] greater than max index [%d] ", colToRemove, numCols));
+    }
+    matrix.conservativeResize(numRows, numCols);
+};
+template <typename Derived>
+inline Eigen::MatrixXd minor_matrix(const Eigen::MatrixBase<Derived>& A, std::size_t i, std::size_t j) {
+    Eigen::MatrixXd Am = A;
+    removeRow(Am, static_cast<unsigned int>(i));
+    removeColumn(Am, static_cast<unsigned int>(j));
+    return Am;
+};
+
+template <typename Derived>
+static Eigen::MatrixXd adjugate(const Eigen::MatrixBase<Derived>& A) {
+    std::size_t N = A.rows();
+    if (N == 1) {
+        Eigen::MatrixXd Aadj(1, 1);
+        Aadj << 1;
+        return Aadj;
+    }
+    Eigen::MatrixXd Aadj(N, N);
+    for (std::size_t i = 0; i < N; ++i) {
+        for (std::size_t j = 0; j < N; ++j) {
+            int negative_1_to_the_i_plus_j = ((i + j) % 2 == 0) ? 1 : -1;
+            Aadj(i, j) = negative_1_to_the_i_plus_j * minor_matrix(A, j, i).determinant();
+        }
+    }
+    return Aadj;
+}
+
+template <typename Derived>
+static Eigen::MatrixXd adjugate_derivative(const Eigen::MatrixBase<Derived>& A, const Eigen::MatrixBase<Derived>& dAdt) {
+    std::size_t N = A.rows();
+    Eigen::MatrixXd Aadj(N, N);
+    for (std::size_t i = 0; i < N; ++i) {
+        for (std::size_t j = 0; j < N; ++j) {
+            int negative_1_to_the_i_plus_j = ((i + j) % 2 == 0) ? 1 : -1;
+            Eigen::MatrixXd mm = minor_matrix(A, j, i);
+            Aadj(i, j) = negative_1_to_the_i_plus_j * (adjugate(minor_matrix(A, j, i)) * minor_matrix(dAdt, j, i)).trace();
+        }
+    }
+    return Aadj;
+}
+
+}; /* namespace CoolProp */
+#endif
```

## CoolProp/include/ODEIntegrators.h

 * *Ordering differences only*

```diff
@@ -1,40 +1,40 @@
-#ifndef ODEINTEGRATORS_H
-#define ODEINTEGRATORS_H
-
-#include <vector>
-
-namespace ODEIntegrators {
-
-/// The abstract class defining the interface for the integrator routines
-class AbstractODEIntegrator
-{
-   public:
-    virtual std::vector<double> get_initial_array() const = 0;
-
-    virtual void pre_step_callback() = 0;
-
-    virtual void post_deriv_callback() = 0;
-
-    virtual void post_step_callback(double t, double h, std::vector<double>& x) = 0;
-
-    virtual bool premature_termination() = 0;
-
-    virtual void derivs(double t, std::vector<double>& x, std::vector<double>& f) = 0;
-};
-
-/**
-     @brief Use the adaptive Runge-Kutta integrator to integrate a system of differential equations
-
-     @param tmin Starting value of the independent variable.  ``t`` is in the closed range [``tmin``, ``tmax``]
-     @param tmax Ending value for the independent variable.  ``t`` is in the closed range [``tmin``, ``tmax``]
-     @param hmin Minimum step size, something like 1e-5 usually is good.  Don't make this too big or you may not be able to get a stable solution
-     @param hmax Maximum step size
-     @param eps_allowed Maximum absolute error of any CV per step allowed.  Don't make this parameter too big or you may not be able to get a stable solution.  Also don't make it too small because then you are going to run into truncation error.
-     @param step_relax The relaxation factor that is used in the step resizing algorithm.  Should be less than 1.0; you can play with this parameter to improve the adaptive resizing, but should not be necessary.
-
-     */
-bool AdaptiveRK54(AbstractODEIntegrator& ode, double tmin, double tmax, double hmin, double hmax, double eps_allowed, double step_relax);
-
-}  // namespace ODEIntegrators
-
+#ifndef ODEINTEGRATORS_H
+#define ODEINTEGRATORS_H
+
+#include <vector>
+
+namespace ODEIntegrators {
+
+/// The abstract class defining the interface for the integrator routines
+class AbstractODEIntegrator
+{
+   public:
+    virtual std::vector<double> get_initial_array() const = 0;
+
+    virtual void pre_step_callback() = 0;
+
+    virtual void post_deriv_callback() = 0;
+
+    virtual void post_step_callback(double t, double h, std::vector<double>& x) = 0;
+
+    virtual bool premature_termination() = 0;
+
+    virtual void derivs(double t, std::vector<double>& x, std::vector<double>& f) = 0;
+};
+
+/**
+     @brief Use the adaptive Runge-Kutta integrator to integrate a system of differential equations
+
+     @param tmin Starting value of the independent variable.  ``t`` is in the closed range [``tmin``, ``tmax``]
+     @param tmax Ending value for the independent variable.  ``t`` is in the closed range [``tmin``, ``tmax``]
+     @param hmin Minimum step size, something like 1e-5 usually is good.  Don't make this too big or you may not be able to get a stable solution
+     @param hmax Maximum step size
+     @param eps_allowed Maximum absolute error of any CV per step allowed.  Don't make this parameter too big or you may not be able to get a stable solution.  Also don't make it too small because then you are going to run into truncation error.
+     @param step_relax The relaxation factor that is used in the step resizing algorithm.  Should be less than 1.0; you can play with this parameter to improve the adaptive resizing, but should not be necessary.
+
+     */
+bool AdaptiveRK54(AbstractODEIntegrator& ode, double tmin, double tmax, double hmin, double hmax, double eps_allowed, double step_relax);
+
+}  // namespace ODEIntegrators
+
 #endif
```

## CoolProp/include/PCSAFTFluid.h

 * *Ordering differences only*

```diff
@@ -1,83 +1,83 @@
-#ifndef PCSAFTFLUID_H
-#define PCSAFTFLUID_H
-
-#include <string>
-#include <vector>
-#include <map>
-
-#include "rapidjson_include.h"
-
-namespace CoolProp {
-
-struct PCSAFTValues
-{
-    CoolPropDbl m;       ///< Number of segments
-    CoolPropDbl sigma;   ///< Segment diameter (1/Angstrom)
-    CoolPropDbl u;       ///< Dispersion energy divided by Boltzmann constant (K)
-    CoolPropDbl uAB;     ///< Association energy (K)
-    CoolPropDbl volA;    ///< Association volume
-    std::vector<std::string> assocScheme; ///< The type of association for each associating functional group (see Huang and Radosz 1990)
-    CoolPropDbl dipm;    ///< Dipole moment (Debye)
-    CoolPropDbl dipnum;  ///< Number of dipole moments per molecule
-    CoolPropDbl z;       ///< Charge of the compound
-};
-
-class PCSAFTFluid
-{
-   protected:
-    std::string name;      // name of fluid
-    std::string CAS;       // CAS number
-    CoolPropDbl molemass;  ///< Molar mass (kg/mol)
-    std::vector<std::string> aliases;
-    PCSAFTValues params;
-
-   public:
-    PCSAFTFluid(){};
-    PCSAFTFluid(rapidjson::Value::ValueIterator itr);
-    ~PCSAFTFluid(){};
-
-    std::string getName() const {
-        return name;
-    }
-    std::string getCAS() const {
-        return CAS;
-    }
-    CoolPropDbl molar_mass() const {
-        return molemass;
-    }
-    std::vector<std::string> getAliases() const {
-        return aliases;
-    }
-    CoolPropDbl getM() const {
-        return params.m;
-    }
-    CoolPropDbl getSigma() const {
-        return params.sigma;
-    }
-    CoolPropDbl getU() const {
-        return params.u;
-    }
-    CoolPropDbl getUAB() const {
-        return params.uAB;
-    }
-    CoolPropDbl getVolA() const {
-        return params.volA;
-    }
-    std::vector<std::string> getAssocScheme() const {
-        return params.assocScheme;
-    }
-    CoolPropDbl getDipm() const {
-        return params.dipm;
-    }
-    CoolPropDbl getDipnum() const {
-        return params.dipnum;
-    }
-    CoolPropDbl getZ() const {
-        return params.z;
-    }
-
-    void calc_water_sigma(double t);
-};
-
-} /* namespace CoolProp */
-#endif /* PCSAFTFLUID_H_ */
+#ifndef PCSAFTFLUID_H
+#define PCSAFTFLUID_H
+
+#include <string>
+#include <vector>
+#include <map>
+
+#include "rapidjson_include.h"
+
+namespace CoolProp {
+
+struct PCSAFTValues
+{
+    CoolPropDbl m;       ///< Number of segments
+    CoolPropDbl sigma;   ///< Segment diameter (1/Angstrom)
+    CoolPropDbl u;       ///< Dispersion energy divided by Boltzmann constant (K)
+    CoolPropDbl uAB;     ///< Association energy (K)
+    CoolPropDbl volA;    ///< Association volume
+    std::vector<std::string> assocScheme; ///< The type of association for each associating functional group (see Huang and Radosz 1990)
+    CoolPropDbl dipm;    ///< Dipole moment (Debye)
+    CoolPropDbl dipnum;  ///< Number of dipole moments per molecule
+    CoolPropDbl z;       ///< Charge of the compound
+};
+
+class PCSAFTFluid
+{
+   protected:
+    std::string name;      // name of fluid
+    std::string CAS;       // CAS number
+    CoolPropDbl molemass;  ///< Molar mass (kg/mol)
+    std::vector<std::string> aliases;
+    PCSAFTValues params;
+
+   public:
+    PCSAFTFluid(){};
+    PCSAFTFluid(rapidjson::Value::ValueIterator itr);
+    ~PCSAFTFluid(){};
+
+    std::string getName() const {
+        return name;
+    }
+    std::string getCAS() const {
+        return CAS;
+    }
+    CoolPropDbl molar_mass() const {
+        return molemass;
+    }
+    std::vector<std::string> getAliases() const {
+        return aliases;
+    }
+    CoolPropDbl getM() const {
+        return params.m;
+    }
+    CoolPropDbl getSigma() const {
+        return params.sigma;
+    }
+    CoolPropDbl getU() const {
+        return params.u;
+    }
+    CoolPropDbl getUAB() const {
+        return params.uAB;
+    }
+    CoolPropDbl getVolA() const {
+        return params.volA;
+    }
+    std::vector<std::string> getAssocScheme() const {
+        return params.assocScheme;
+    }
+    CoolPropDbl getDipm() const {
+        return params.dipm;
+    }
+    CoolPropDbl getDipnum() const {
+        return params.dipnum;
+    }
+    CoolPropDbl getZ() const {
+        return params.z;
+    }
+
+    void calc_water_sigma(double t);
+};
+
+} /* namespace CoolProp */
+#endif /* PCSAFTFLUID_H_ */
```

## CoolProp/include/PhaseEnvelope.h

 * *Ordering differences only*

```diff
@@ -1,140 +1,140 @@
-#ifndef PHASE_ENVELOPE_H
-#define PHASE_ENVELOPE_H
-
-#include "Exceptions.h"
-
-#define PHASE_ENVELOPE_MATRICES X(K) X(lnK) X(x) X(y)
-#define PHASE_ENVELOPE_VECTORS \
-    X(T)                       \
-    X(p)                       \
-    X(lnT)                     \
-    X(lnp)                     \
-    X(rhomolar_liq)            \
-    X(rhomolar_vap)            \
-    X(lnrhomolar_liq)          \
-    X(lnrhomolar_vap)          \
-    X(hmolar_liq)              \
-    X(hmolar_vap)              \
-    X(smolar_liq)              \
-    X(smolar_vap)              \
-    X(Q)                       \
-    X(cpmolar_liq)             \
-    X(cpmolar_vap)             \
-    X(cvmolar_liq)             \
-    X(cvmolar_vap)             \
-    X(viscosity_liq)           \
-    X(viscosity_vap)           \
-    X(conductivity_liq)        \
-    X(conductivity_vap)        \
-    X(speed_sound_vap)
-
-namespace CoolProp {
-
-/** \brief A data structure to hold the data for a phase envelope
- *
- */
-class PhaseEnvelopeData
-{
-   public:
-    bool TypeI;             ///< True if it is a Type-I mixture that has a phase envelope that looks like a pure fluid more or less
-    bool built;             ///< True if the phase envelope has been constructed
-    std::size_t iTsat_max,  ///< The index of the point corresponding to the maximum temperature for Type-I mixtures
-      ipsat_max,            ///< The index of the point corresponding to the maximum pressure for Type-I mixtures
-      icrit;                ///< The index of the point corresponding to the critical point
-
-// Use X macros to auto-generate the variables;
-// each will look something like: std::vector<double> T;
-#define X(name) std::vector<double> name;
-    PHASE_ENVELOPE_VECTORS
-#undef X
-
-// Use X macros to auto-generate the variables;
-// each will look something like: std::vector<std::vector<double> > K;
-#define X(name) std::vector<std::vector<double>> name;
-    PHASE_ENVELOPE_MATRICES
-#undef X
-
-    PhaseEnvelopeData() : TypeI(false), built(false), iTsat_max(-1), ipsat_max(-1), icrit(-1) {}
-
-    void resize(std::size_t N) {
-        K.resize(N);
-        lnK.resize(N);
-        x.resize(N);
-        y.resize(N);
-    }
-    void clear() {
-/* Use X macros to auto-generate the clearing code; each will look something like: T.clear(); */
-#define X(name) name.clear();
-        PHASE_ENVELOPE_VECTORS
-#undef X
-#define X(name) name.clear();
-        PHASE_ENVELOPE_MATRICES
-#undef X
-    }
-    void insert_variables(const CoolPropDbl T, const CoolPropDbl p, const CoolPropDbl rhomolar_liq, const CoolPropDbl rhomolar_vap,
-                          const CoolPropDbl hmolar_liq, const CoolPropDbl hmolar_vap, const CoolPropDbl smolar_liq, const CoolPropDbl smolar_vap,
-                          const std::vector<CoolPropDbl>& x, const std::vector<CoolPropDbl>& y, std::size_t i) {
-        std::size_t N = K.size();
-        if (N == 0) {
-            throw CoolProp::ValueError("Cannot insert variables in phase envelope since resize() function has not been called");
-        }
-        this->p.insert(this->p.begin() + i, p);
-        this->T.insert(this->T.begin() + i, T);
-        this->lnT.insert(this->lnT.begin() + i, log(T));
-        this->lnp.insert(this->lnp.begin() + i, log(p));
-        this->rhomolar_liq.insert(this->rhomolar_liq.begin() + i, rhomolar_liq);
-        this->rhomolar_vap.insert(this->rhomolar_vap.begin() + i, rhomolar_vap);
-        this->hmolar_liq.insert(this->hmolar_liq.begin() + i, hmolar_liq);
-        this->hmolar_vap.insert(this->hmolar_vap.begin() + i, hmolar_vap);
-        this->smolar_liq.insert(this->smolar_liq.begin() + i, smolar_liq);
-        this->smolar_vap.insert(this->smolar_vap.begin() + i, smolar_vap);
-        this->lnrhomolar_liq.insert(this->lnrhomolar_liq.begin() + i, log(rhomolar_liq));
-        this->lnrhomolar_vap.insert(this->lnrhomolar_vap.begin() + i, log(rhomolar_vap));
-        for (unsigned int j = 0; j < N; j++) {
-            this->K[j].insert(this->K[j].begin() + i, y[j] / x[j]);
-            this->lnK[j].insert(this->lnK[j].begin() + i, log(y[j] / x[j]));
-            this->x[j].insert(this->x[j].begin() + i, x[j]);
-            this->y[j].insert(this->y[j].begin() + i, y[j]);
-        }
-        if (rhomolar_liq > rhomolar_vap) {
-            this->Q.insert(this->Q.begin() + i, 1);
-        } else {
-            this->Q.insert(this->Q.begin() + i, 0);
-        }
-    };
-    void store_variables(const CoolPropDbl T, const CoolPropDbl p, const CoolPropDbl rhomolar_liq, const CoolPropDbl rhomolar_vap,
-                         const CoolPropDbl hmolar_liq, const CoolPropDbl hmolar_vap, const CoolPropDbl smolar_liq, const CoolPropDbl smolar_vap,
-                         const std::vector<CoolPropDbl>& x, const std::vector<CoolPropDbl>& y) {
-        std::size_t N = K.size();
-        if (N == 0) {
-            throw CoolProp::ValueError("Cannot store variables in phase envelope since resize() function has not been called");
-        }
-        this->p.push_back(p);
-        this->T.push_back(T);
-        this->lnT.push_back(log(T));
-        this->lnp.push_back(log(p));
-        this->rhomolar_liq.push_back(rhomolar_liq);
-        this->rhomolar_vap.push_back(rhomolar_vap);
-        this->hmolar_liq.push_back(hmolar_liq);
-        this->hmolar_vap.push_back(hmolar_vap);
-        this->smolar_liq.push_back(smolar_liq);
-        this->smolar_vap.push_back(smolar_vap);
-        this->lnrhomolar_liq.push_back(log(rhomolar_liq));
-        this->lnrhomolar_vap.push_back(log(rhomolar_vap));
-        for (unsigned int i = 0; i < N; i++) {
-            this->K[i].push_back(y[i] / x[i]);
-            this->lnK[i].push_back(log(y[i] / x[i]));
-            this->x[i].push_back(x[i]);
-            this->y[i].push_back(y[i]);
-        }
-        if (rhomolar_liq > rhomolar_vap) {
-            this->Q.push_back(1);
-        } else {
-            this->Q.push_back(0);
-        }
-    };
-};
-
-} /* namespace CoolProp */
-
-#endif
+#ifndef PHASE_ENVELOPE_H
+#define PHASE_ENVELOPE_H
+
+#include "Exceptions.h"
+
+#define PHASE_ENVELOPE_MATRICES X(K) X(lnK) X(x) X(y)
+#define PHASE_ENVELOPE_VECTORS \
+    X(T)                       \
+    X(p)                       \
+    X(lnT)                     \
+    X(lnp)                     \
+    X(rhomolar_liq)            \
+    X(rhomolar_vap)            \
+    X(lnrhomolar_liq)          \
+    X(lnrhomolar_vap)          \
+    X(hmolar_liq)              \
+    X(hmolar_vap)              \
+    X(smolar_liq)              \
+    X(smolar_vap)              \
+    X(Q)                       \
+    X(cpmolar_liq)             \
+    X(cpmolar_vap)             \
+    X(cvmolar_liq)             \
+    X(cvmolar_vap)             \
+    X(viscosity_liq)           \
+    X(viscosity_vap)           \
+    X(conductivity_liq)        \
+    X(conductivity_vap)        \
+    X(speed_sound_vap)
+
+namespace CoolProp {
+
+/** \brief A data structure to hold the data for a phase envelope
+ *
+ */
+class PhaseEnvelopeData
+{
+   public:
+    bool TypeI;             ///< True if it is a Type-I mixture that has a phase envelope that looks like a pure fluid more or less
+    bool built;             ///< True if the phase envelope has been constructed
+    std::size_t iTsat_max,  ///< The index of the point corresponding to the maximum temperature for Type-I mixtures
+      ipsat_max,            ///< The index of the point corresponding to the maximum pressure for Type-I mixtures
+      icrit;                ///< The index of the point corresponding to the critical point
+
+// Use X macros to auto-generate the variables;
+// each will look something like: std::vector<double> T;
+#define X(name) std::vector<double> name;
+    PHASE_ENVELOPE_VECTORS
+#undef X
+
+// Use X macros to auto-generate the variables;
+// each will look something like: std::vector<std::vector<double> > K;
+#define X(name) std::vector<std::vector<double>> name;
+    PHASE_ENVELOPE_MATRICES
+#undef X
+
+    PhaseEnvelopeData() : TypeI(false), built(false), iTsat_max(-1), ipsat_max(-1), icrit(-1) {}
+
+    void resize(std::size_t N) {
+        K.resize(N);
+        lnK.resize(N);
+        x.resize(N);
+        y.resize(N);
+    }
+    void clear() {
+/* Use X macros to auto-generate the clearing code; each will look something like: T.clear(); */
+#define X(name) name.clear();
+        PHASE_ENVELOPE_VECTORS
+#undef X
+#define X(name) name.clear();
+        PHASE_ENVELOPE_MATRICES
+#undef X
+    }
+    void insert_variables(const CoolPropDbl T, const CoolPropDbl p, const CoolPropDbl rhomolar_liq, const CoolPropDbl rhomolar_vap,
+                          const CoolPropDbl hmolar_liq, const CoolPropDbl hmolar_vap, const CoolPropDbl smolar_liq, const CoolPropDbl smolar_vap,
+                          const std::vector<CoolPropDbl>& x, const std::vector<CoolPropDbl>& y, std::size_t i) {
+        std::size_t N = K.size();
+        if (N == 0) {
+            throw CoolProp::ValueError("Cannot insert variables in phase envelope since resize() function has not been called");
+        }
+        this->p.insert(this->p.begin() + i, p);
+        this->T.insert(this->T.begin() + i, T);
+        this->lnT.insert(this->lnT.begin() + i, log(T));
+        this->lnp.insert(this->lnp.begin() + i, log(p));
+        this->rhomolar_liq.insert(this->rhomolar_liq.begin() + i, rhomolar_liq);
+        this->rhomolar_vap.insert(this->rhomolar_vap.begin() + i, rhomolar_vap);
+        this->hmolar_liq.insert(this->hmolar_liq.begin() + i, hmolar_liq);
+        this->hmolar_vap.insert(this->hmolar_vap.begin() + i, hmolar_vap);
+        this->smolar_liq.insert(this->smolar_liq.begin() + i, smolar_liq);
+        this->smolar_vap.insert(this->smolar_vap.begin() + i, smolar_vap);
+        this->lnrhomolar_liq.insert(this->lnrhomolar_liq.begin() + i, log(rhomolar_liq));
+        this->lnrhomolar_vap.insert(this->lnrhomolar_vap.begin() + i, log(rhomolar_vap));
+        for (unsigned int j = 0; j < N; j++) {
+            this->K[j].insert(this->K[j].begin() + i, y[j] / x[j]);
+            this->lnK[j].insert(this->lnK[j].begin() + i, log(y[j] / x[j]));
+            this->x[j].insert(this->x[j].begin() + i, x[j]);
+            this->y[j].insert(this->y[j].begin() + i, y[j]);
+        }
+        if (rhomolar_liq > rhomolar_vap) {
+            this->Q.insert(this->Q.begin() + i, 1);
+        } else {
+            this->Q.insert(this->Q.begin() + i, 0);
+        }
+    };
+    void store_variables(const CoolPropDbl T, const CoolPropDbl p, const CoolPropDbl rhomolar_liq, const CoolPropDbl rhomolar_vap,
+                         const CoolPropDbl hmolar_liq, const CoolPropDbl hmolar_vap, const CoolPropDbl smolar_liq, const CoolPropDbl smolar_vap,
+                         const std::vector<CoolPropDbl>& x, const std::vector<CoolPropDbl>& y) {
+        std::size_t N = K.size();
+        if (N == 0) {
+            throw CoolProp::ValueError("Cannot store variables in phase envelope since resize() function has not been called");
+        }
+        this->p.push_back(p);
+        this->T.push_back(T);
+        this->lnT.push_back(log(T));
+        this->lnp.push_back(log(p));
+        this->rhomolar_liq.push_back(rhomolar_liq);
+        this->rhomolar_vap.push_back(rhomolar_vap);
+        this->hmolar_liq.push_back(hmolar_liq);
+        this->hmolar_vap.push_back(hmolar_vap);
+        this->smolar_liq.push_back(smolar_liq);
+        this->smolar_vap.push_back(smolar_vap);
+        this->lnrhomolar_liq.push_back(log(rhomolar_liq));
+        this->lnrhomolar_vap.push_back(log(rhomolar_vap));
+        for (unsigned int i = 0; i < N; i++) {
+            this->K[i].push_back(y[i] / x[i]);
+            this->lnK[i].push_back(log(y[i] / x[i]));
+            this->x[i].push_back(x[i]);
+            this->y[i].push_back(y[i]);
+        }
+        if (rhomolar_liq > rhomolar_vap) {
+            this->Q.push_back(1);
+        } else {
+            this->Q.push_back(0);
+        }
+    };
+};
+
+} /* namespace CoolProp */
+
+#endif
```

## CoolProp/include/PlatformDetermination.h

 * *Ordering differences only*

```diff
@@ -1,19 +1,19 @@
-#ifndef PLATFORMDETERMINATION_H
-#define PLATFORMDETERMINATION_H
-
-// See also http://stackoverflow.com/questions/5919996/how-to-detect-reliably-mac-os-x-ios-linux-windows-in-c-preprocessor
-#if _WIN64
-#    define __ISWINDOWS__
-#elif _WIN32
-#    define __ISWINDOWS__
-#elif __APPLE__
-#    define __ISAPPLE__
-#elif __linux || __unix || __posix
-#    define __ISLINUX__
-#elif __powerpc__
-#    define __ISPOWERPC__
-#else
-#    pragma error
-#endif
-
-#endif
+#ifndef PLATFORMDETERMINATION_H
+#define PLATFORMDETERMINATION_H
+
+// See also http://stackoverflow.com/questions/5919996/how-to-detect-reliably-mac-os-x-ios-linux-windows-in-c-preprocessor
+#if _WIN64
+#    define __ISWINDOWS__
+#elif _WIN32
+#    define __ISWINDOWS__
+#elif __APPLE__
+#    define __ISAPPLE__
+#elif __linux || __unix || __posix
+#    define __ISLINUX__
+#elif __powerpc__
+#    define __ISPOWERPC__
+#else
+#    pragma error
+#endif
+
+#endif
```

## CoolProp/include/PolyMath.h

 * *Ordering differences only*

```diff
@@ -1,988 +1,988 @@
-#ifndef POLYMATH_H
-#define POLYMATH_H
-
-#include "CoolProp.h"
-#include "CoolPropTools.h"
-#include "Exceptions.h"
-
-#include <vector>
-#include <string>
-#include "Solvers.h"
-#include "MatrixMath.h"
-#include "unsupported/Eigen/Polynomials"
-
-namespace CoolProp {
-
-// Just a forward declaration
-class Poly2DResidual;
-class Poly2DFracResidual;
-
-/// The base class for all Polynomials
-/** A clear and straight forward implementation of polynomial operations. Still
- *  very basic, but serves its purpose.
- */
-class Polynomial2D
-{
-
-   public:
-    /// Constructors
-    Polynomial2D(){};
-
-    /// Destructor.  No implementation
-    virtual ~Polynomial2D(){};
-
-   public:
-    /// Convert the coefficient vector.
-    /// @param coefficients vector containing the ordered coefficients
-    Eigen::MatrixXd convertCoefficients(const std::vector<double>& coefficients) {
-        return vec_to_eigen(coefficients);
-    }
-    /// Convert the coefficient matrix.
-    /// @param coefficients matrix containing the ordered coefficients
-    Eigen::MatrixXd convertCoefficients(const std::vector<std::vector<double>>& coefficients) {
-        return vec_to_eigen(coefficients);
-    }
-
-    /// Basic checks for coefficient vectors.
-    /** Starts with only the first coefficient dimension
-     *  and checks the matrix size against the parameters rows and columns. */
-    /// @param coefficients matrix containing the ordered coefficients
-    /// @param rows unsigned integer value that represents the desired degree of the polynomial in the 1st dimension
-    /// @param columns unsigned integer value that represents the desired degree of the polynomial in the 2nd dimension
-    bool checkCoefficients(const Eigen::MatrixXd& coefficients, const unsigned int rows, const unsigned int columns);
-
-   public:
-    /// Integration functions
-    /** Integrating coefficients for polynomials is done by dividing the
-     *  original coefficients by (i+1) and elevating the order by 1
-     *  through adding a zero as first coefficient.
-     *  Some reslicing needs to be applied to integrate along the x-axis.
-     *  In the brine/solution equations, reordering of the parameters
-     *  avoids this expensive operation. However, it is included for the
-     *  sake of completeness.
-     */
-    /// @param coefficients matrix containing the ordered coefficients
-    /// @param axis unsigned integer value that represents the desired direction of integration
-    /// @param times integer value that represents the desired order of integration
-    Eigen::MatrixXd integrateCoeffs(const Eigen::MatrixXd& coefficients, const int& axis, const int& times);
-
-    /// Derivative coefficients calculation
-    /** Deriving coefficients for polynomials is done by multiplying the
-     *  original coefficients with i and lowering the order by 1.
-     */
-    /// @param coefficients matrix containing the ordered coefficients
-    /// @param axis unsigned integer value that represents the desired direction of derivation
-    /// @param times integer value that represents the desired order of derivation
-    Eigen::MatrixXd deriveCoeffs(const Eigen::MatrixXd& coefficients, const int& axis = -1, const int& times = 1);
-
-   public:
-    /// The core functions to evaluate the polynomial
-    /** It is here we implement the different special
-     *  functions that allow us to specify certain
-     *  types of polynomials.
-     *
-     *  Try to avoid many calls to the derivative and integral functions.
-     *  Both of them have to calculate the new coefficients internally,
-     *  which slows things down. Instead, you should use the deriveCoeffs
-     *  and integrateCoeffs functions and store the coefficient matrix
-     *  you need for future calls to evaluate derivative and integral.
-     */
-    /// @param coefficients vector containing the ordered coefficients
-    /// @param x_in double value that represents the current input in the 1st dimension
-    double evaluate(const Eigen::MatrixXd& coefficients, const double& x_in);
-
-    /// @param coefficients vector containing the ordered coefficients
-    /// @param x_in double value that represents the current input in the 1st dimension
-    /// @param y_in double value that represents the current input in the 2nd dimension
-    double evaluate(const Eigen::MatrixXd& coefficients, const double& x_in, const double& y_in);
-
-    /// @param coefficients vector containing the ordered coefficients
-    /// @param x_in double value that represents the current input in the 1st dimension
-    /// @param y_in double value that represents the current input in the 2nd dimension
-    /// @param axis unsigned integer value that represents the axis to derive for (0=x, 1=y)
-    double derivative(const Eigen::MatrixXd& coefficients, const double& x_in, const double& y_in, const int& axis);
-
-    /// @param coefficients vector containing the ordered coefficients
-    /// @param x_in double value that represents the current input in the 1st dimension
-    /// @param y_in double value that represents the current input in the 2nd dimension
-    /// @param axis unsigned integer value that represents the axis to integrate for (0=x, 1=y)
-    double integral(const Eigen::MatrixXd& coefficients, const double& x_in, const double& y_in, const int& axis);
-
-   protected:
-    // TODO: Why doe these base definitions not work with derived classes?
-    /// Uses the Brent solver to find the roots of p(x_in,y_in)-z_in
-    /// @param res Poly2DResidual object to calculate residuals and derivatives
-    /// @param min double value that represents the minimum value
-    /// @param max double value that represents the maximum value
-    double solve_limits(Poly2DResidual* res, const double& min, const double& max);
-
-    // TODO: Why doe these base definitions not work with derived classes?
-    /// Uses the Newton solver to find the roots of p(x_in,y_in)-z_in
-    /// @param res Poly2DResidual object to calculate residuals and derivatives
-    /// @param guess double value that represents the start value
-    double solve_guess(Poly2DResidual* res, const double& guess);
-
-   public:
-    /// Returns a vector with ALL the real roots of p(x_in,y_in)-z_in
-    /// @param coefficients vector containing the ordered coefficients
-    /// @param in double value that represents the current input in x (1st dimension) or y (2nd dimension)
-    /// @param z_in double value that represents the current output in the 3rd dimension
-    /// @param axis unsigned integer value that represents the axis to solve for (0=x, 1=y)
-    Eigen::VectorXd solve(const Eigen::MatrixXd& coefficients, const double& in, const double& z_in, const int& axis);
-
-    /// Uses the Brent solver to find the roots of p(x_in,y_in)-z_in
-    /// @param coefficients vector containing the ordered coefficients
-    /// @param in double value that represents the current input in x (1st dimension) or y (2nd dimension)
-    /// @param z_in double value that represents the current output in the 3rd dimension
-    /// @param min double value that represents the minimum value
-    /// @param max double value that represents the maximum value
-    /// @param axis unsigned integer value that represents the axis to solve for (0=x, 1=y)
-    double solve_limits(const Eigen::MatrixXd& coefficients, const double& in, const double& z_in, const double& min, const double& max,
-                        const int& axis);
-
-    /// Uses the Newton solver to find the roots of p(x_in,y_in)-z_in
-    /// @param coefficients vector containing the ordered coefficients
-    /// @param in double value that represents the current input in x (1st dimension) or y (2nd dimension)
-    /// @param z_in double value that represents the current output in the 3rd dimension
-    /// @param guess double value that represents the start value
-    /// @param axis unsigned integer value that represents the axis to solve for (0=x, 1=y)
-    double solve_guess(const Eigen::MatrixXd& coefficients, const double& in, const double& z_in, const double& guess, const int& axis);
-
-   protected:
-    /// Simple polynomial function generator. <- Deprecated due to poor performance, use Horner-scheme instead
-    /** Base function to produce n-th order polynomials
-     *  based on the length of the coefficient vector.
-     *  Starts with only the first coefficient at x^0. */
-    double simplePolynomial(const std::vector<double>& coefficients, double x);
-    DEPRECATED(double simplePolynomial(const std::vector<std::vector<double>>& coefficients, double x, double y));
-    /// Horner function generator implementations
-    /** Represent polynomials according to Horner's scheme.
-     *  This avoids unnecessary multiplication and thus
-     *  speeds up calculation.
-     *  Deprecated since we moved everything to the Eigen framework.
-     */
-    double baseHorner(const std::vector<double>& coefficients, double x);
-    DEPRECATED(double baseHorner(const std::vector<std::vector<double>>& coefficients, double x, double y));
-
-    bool do_debug(void) {
-        return get_debug_level() >= 500;
-    }
-};
-
-class Poly2DResidual : public FuncWrapper1DWithDeriv
-{
-   protected:
-    enum dims
-    {
-        iX,
-        iY
-    };
-    Eigen::MatrixXd coefficients;
-    bool derIsSet;
-    Eigen::MatrixXd coefficientsDer;
-    int axis;
-    /// the fixed input != targetDim
-    double in;
-    /// Object that evaluates the equation
-    Polynomial2D poly;
-    /// Current output value
-    double z_in;
-
-   protected:
-    Poly2DResidual();
-
-   public:
-    /// Residual of a polynomial
-    /// @param poly polynomial object used to evaluate the calls
-    /// @param coefficients
-    /// @param in double value that represents the current input in x (1st dimension) or y (2nd dimension)
-    /// @param z_in double value that represents the current output in the 3rd dimension
-    /// @param axis unsigned integer value that represents the axis to solve for (0=x, 1=y)
-    Poly2DResidual(Polynomial2D& poly, const Eigen::MatrixXd& coefficients, const double& in, const double& z_in, const int& axis);
-    virtual ~Poly2DResidual(){};
-
-    double call(double target);
-    double deriv(double target);
-};
-
-/// A class for polynomials starting at an arbitrary degree.
-/** It is implemented for the incompressibles and is a little messy, but seems to
- *  work fine for now. Besides handling arbitrary starting exponents for the
- *  polynomials, it can also calculate polynomials with a base value. This means
- *  that the independent variable no longer is x, but (x-x_base). For fitted
- *  functions, we often see such a design to enhance the fit quality/stability.
- */
-class Polynomial2DFrac : public Polynomial2D
-{
-
-   public:
-    /// Constructors
-    Polynomial2DFrac(){};
-
-    /// Destructor.  No implementation
-    virtual ~Polynomial2DFrac(){};
-
-   public:
-    //    /// Integration functions
-    //    /** Integrating coefficients for polynomials is done by dividing the
-    //     *  original coefficients by (i+1) and elevating the order by 1
-    //     *  through adding a zero as first coefficient.
-    //     *  Some reslicing needs to be applied to integrate along the x-axis.
-    //     *  In the brine/solution equations, reordering of the parameters
-    //     *  avoids this expensive operation. However, it is included for the
-    //     *  sake of completeness.
-    //     */
-    //    /// @param coefficients matrix containing the ordered coefficients
-    //    /// @param axis unsigned integer value that represents the desired direction of integration
-    //    /// @param times integer value that represents the desired order of integration
-    //    /// @param firstExponent integer value that represents the first exponent of the polynomial in axis direction
-    //    Eigen::MatrixXd integrateCoeffs(const Eigen::MatrixXd &coefficients, const int &axis, const int &times, const int &firstExponent);
-    //
-    /// Derivative coefficients calculation
-    /** Deriving coefficients for polynomials is done by multiplying the
-     *  original coefficients with i and lowering the order by 1.
-     *
-     *  Remember that the first exponent might need to be adjusted after derivation.
-     *  It has to be lowered by times:
-     *  derCoeffs = deriveCoeffs(coefficients, axis, times, firstExponent);
-     *  firstExponent -= times;
-     */
-    /// @param coefficients matrix containing the ordered coefficients
-    /// @param axis unsigned integer value that represents the desired direction of derivation
-    /// @param times integer value that represents the desired order of derivation
-    /// @param firstExponent integer value that represents the lowest exponent of the polynomial in axis direction
-    Eigen::MatrixXd deriveCoeffs(const Eigen::MatrixXd& coefficients, const int& axis, const int& times, const int& firstExponent);
-
-   public:
-    /// The core functions to evaluate the polynomial
-    /** It is here we implement the different special
-     *  functions that allow us to specify certain
-     *  types of polynomials.
-     *
-     *  Try to avoid many calls to the derivative and integral functions.
-     *  Both of them have to calculate the new coefficients internally,
-     *  which slows things down. Instead, you should use the deriveCoeffs
-     *  and integrateCoeffs functions and store the coefficient matrix
-     *  you need for future calls to evaluate derivative and integral.
-     */
-    /// @param coefficients vector containing the ordered coefficients
-    /// @param x_in double value that represents the current input in the 1st dimension
-    /// @param firstExponent integer value that represents the lowest exponent of the polynomial
-    /// @param x_base double value that represents the base value for a centered fit in the 1st dimension
-    double evaluate(const Eigen::MatrixXd& coefficients, const double& x_in, const int& firstExponent = 0, const double& x_base = 0.0);
-
-    /// @param coefficients matrix containing the ordered coefficients
-    /// @param x_in double value that represents the current input in the 1st dimension
-    /// @param y_in double value that represents the current input in the 2nd dimension
-    /// @param x_exp integer value that represents the lowest exponent of the polynomial in the 1st dimension
-    /// @param y_exp integer value that represents the lowest exponent of the polynomial in the 2nd dimension
-    /// @param x_base double value that represents the base value for a centered fit in the 1st dimension
-    /// @param y_base double value that represents the base value for a centered fit in the 2nd dimension
-    double evaluate(const Eigen::MatrixXd& coefficients, const double& x_in, const double& y_in, const int& x_exp, const int& y_exp,
-                    const double& x_base = 0.0, const double& y_base = 0.0);
-
-    /// @param coefficients vector containing the ordered coefficients
-    /// @param x_in double value that represents the current input in the 1st dimension
-    /// @param y_in double value that represents the current input in the 2nd dimension
-    /// @param axis unsigned integer value that represents the axis to derive for (0=x, 1=y)
-    /// @param x_exp integer value that represents the lowest exponent of the polynomial in the 1st dimension
-    /// @param y_exp integer value that represents the lowest exponent of the polynomial in the 2nd dimension
-    /// @param x_base double value that represents the base value for a centred fit in the 1st dimension
-    /// @param y_base double value that represents the base value for a centred fit in the 2nd dimension
-    double derivative(const Eigen::MatrixXd& coefficients, const double& x_in, const double& y_in, const int& axis, const int& x_exp,
-                      const int& y_exp, const double& x_base = 0.0, const double& y_base = 0.0);
-
-    /// @param coefficients vector containing the ordered coefficients
-    /// @param x_in double value that represents the current input in the 1st dimension
-    /// @param y_in double value that represents the current input in the 2nd dimension
-    /// @param axis unsigned integer value that represents the axis to integrate for (0=x, 1=y)
-    /// @param x_exp integer value that represents the lowest exponent of the polynomial in the 1st dimension
-    /// @param y_exp integer value that represents the lowest exponent of the polynomial in the 2nd dimension
-    /// @param x_base double value that represents the base value for a centred fit in the 1st dimension
-    /// @param y_base double value that represents the base value for a centred fit in the 2nd dimension
-    /// @param ax_val double value that represents the base value for the definite integral on the chosen axis.
-    double integral(const Eigen::MatrixXd& coefficients, const double& x_in, const double& y_in, const int& axis, const int& x_exp, const int& y_exp,
-                    const double& x_base = 0.0, const double& y_base = 0.0, const double& ax_val = 0.0);
-
-   public:
-    /// Returns a vector with ALL the real roots of p(x_in,y_in)-z_in
-    /// @param coefficients vector containing the ordered coefficients
-    /// @param in double value that represents the current input in x (1st dimension) or y (2nd dimension)
-    /// @param z_in double value that represents the current output in the 3rd dimension
-    /// @param axis unsigned integer value that represents the axis to solve for (0=x, 1=y)
-    /// @param x_exp integer value that represents the lowest exponent of the polynomial in the 1st dimension
-    /// @param y_exp integer value that represents the lowest exponent of the polynomial in the 2nd dimension
-    /// @param x_base double value that represents the base value for a centred fit in the 1st dimension
-    /// @param y_base double value that represents the base value for a centred fit in the 2nd dimension
-    Eigen::VectorXd solve(const Eigen::MatrixXd& coefficients, const double& in, const double& z_in, const int& axis, const int& x_exp,
-                          const int& y_exp, const double& x_base = 0.0, const double& y_base = 0.0);
-
-    /// Uses the Brent solver to find the roots of p(x_in,y_in)-z_in
-    /// @param coefficients vector containing the ordered coefficients
-    /// @param in double value that represents the current input in x (1st dimension) or y (2nd dimension)
-    /// @param z_in double value that represents the current output in the 3rd dimension
-    /// @param min double value that represents the minimum value
-    /// @param max double value that represents the maximum value
-    /// @param axis unsigned integer value that represents the axis to solve for (0=x, 1=y)
-    /// @param x_exp integer value that represents the lowest exponent of the polynomial in the 1st dimension
-    /// @param y_exp integer value that represents the lowest exponent of the polynomial in the 2nd dimension
-    /// @param x_base double value that represents the base value for a centred fit in the 1st dimension
-    /// @param y_base double value that represents the base value for a centred fit in the 2nd dimension
-    double solve_limits(const Eigen::MatrixXd& coefficients, const double& in, const double& z_in, const double& min, const double& max,
-                        const int& axis, const int& x_exp, const int& y_exp, const double& x_base = 0.0, const double& y_base = 0.0);
-
-    /// Uses the Newton solver to find the roots of p(x_in,y_in)-z_in
-    /// @param coefficients vector containing the ordered coefficients
-    /// @param in double value that represents the current input in x (1st dimension) or y (2nd dimension)
-    /// @param z_in double value that represents the current output in the 3rd dimension
-    /// @param guess double value that represents the start value
-    /// @param axis unsigned integer value that represents the axis to solve for (0=x, 1=y)
-    /// @param x_exp integer value that represents the lowest exponent of the polynomial in the 1st dimension
-    /// @param y_exp integer value that represents the lowest exponent of the polynomial in the 2nd dimension
-    /// @param x_base double value that represents the base value for a centred fit in the 1st dimension
-    /// @param y_base double value that represents the base value for a centred fit in the 2nd dimension
-    double solve_guess(const Eigen::MatrixXd& coefficients, const double& in, const double& z_in, const double& guess, const int& axis,
-                       const int& x_exp, const int& y_exp, const double& x_base = 0.0, const double& y_base = 0.0);
-
-    /// Uses the Brent solver to find the roots of Int(p(x_in,y_in))-z_in
-    /// @param coefficients vector containing the ordered coefficients
-    /// @param in double value that represents the current input in x (1st dimension) or y (2nd dimension)
-    /// @param z_in double value that represents the current output in the 3rd dimension
-    /// @param min double value that represents the minimum value
-    /// @param max double value that represents the maximum value
-    /// @param axis unsigned integer value that represents the axis to solve for (0=x, 1=y)
-    /// @param x_exp integer value that represents the lowest exponent of the polynomial in the 1st dimension
-    /// @param y_exp integer value that represents the lowest exponent of the polynomial in the 2nd dimension
-    /// @param x_base double value that represents the base value for a centred fit in the 1st dimension
-    /// @param y_base double value that represents the base value for a centred fit in the 2nd dimension
-    /// @param int_axis axis for the integration (0=x, 1=y)
-    double solve_limitsInt(const Eigen::MatrixXd& coefficients, const double& in, const double& z_in, const double& min, const double& max,
-                           const int& axis, const int& x_exp, const int& y_exp, const double& x_base = 0.0, const double& y_base = 0.0,
-                           const int& int_axis = 0);
-
-    /// Uses the Newton solver to find the roots of Int(p(x_in,y_in))-z_in
-    /// @param coefficients vector containing the ordered coefficients
-    /// @param in double value that represents the current input in x (1st dimension) or y (2nd dimension)
-    /// @param z_in double value that represents the current output in the 3rd dimension
-    /// @param guess double value that represents the start value
-    /// @param axis unsigned integer value that represents the axis to solve for (0=x, 1=y)
-    /// @param x_exp integer value that represents the lowest exponent of the polynomial in the 1st dimension
-    /// @param y_exp integer value that represents the lowest exponent of the polynomial in the 2nd dimension
-    /// @param x_base double value that represents the base value for a centred fit in the 1st dimension
-    /// @param y_base double value that represents the base value for a centred fit in the 2nd dimension
-    /// @param int_axis axis for the integration (0=x, 1=y)
-    double solve_guessInt(const Eigen::MatrixXd& coefficients, const double& in, const double& z_in, const double& guess, const int& axis,
-                          const int& x_exp, const int& y_exp, const double& x_base = 0.0, const double& y_base = 0.0, const int& int_axis = 0);
-
-   protected:
-    /// @param nValue integer value that represents the order of the factorial
-    double factorial(const int& nValue);
-
-    /// @param nValue integer value that represents the upper part of the factorial
-    /// @param nValue2 integer value that represents the lower part of the factorial
-    double binom(const int& nValue, const int& nValue2);
-
-    ///Helper function to calculate the D vector:
-    /// @param m integer value that represents order
-    /// @param x_in double value that represents the current input
-    /// @param x_base double value that represents the basis for the fit
-    Eigen::MatrixXd fracIntCentralDvector(const int& m, const double& x_in, const double& x_base);
-
-    ///Indefinite integral of a centred polynomial divided by its independent variable
-    /// @param coefficients vector containing the ordered coefficients
-    /// @param x_in double value that represents the current input
-    /// @param x_base double value that represents the basis for the fit
-    double fracIntCentral(const Eigen::MatrixXd& coefficients, const double& x_in, const double& x_base);
-};
-
-class Poly2DFracResidual : public Poly2DResidual
-{
-   protected:
-    int x_exp, y_exp;
-    double x_base, y_base;
-    /// Object that evaluates the equation
-    Polynomial2DFrac poly;
-
-   protected:
-    Poly2DFracResidual();
-
-   public:
-    /// Residual of a polynomial divided by the independent variable
-    /// @param poly polynomial object used to evaluate the calls
-    /// @param coefficients
-    /// @param in double value that represents the current input in x (1st dimension) or y (2nd dimension)
-    /// @param z_in double value that represents the current output in the 3rd dimension
-    /// @param axis unsigned integer value that represents the axis to solve for (0=x, 1=y)
-    /// @param x_exp first exponent in x-direction
-    /// @param y_exp first exponent in y-direction
-    /// @param x_base base value for x (x = x_in - x_base)
-    /// @param y_base base value for y (y = y_in - y_base)
-    Poly2DFracResidual(Polynomial2DFrac& poly, const Eigen::MatrixXd& coefficients, const double& in, const double& z_in, const int& axis,
-                       const int& x_exp, const int& y_exp, const double& x_base, const double& y_base);
-    virtual ~Poly2DFracResidual(){};
-    double call(double target);
-    double deriv(double target);
-};
-
-class Poly2DFracIntResidual : public Poly2DFracResidual
-{
-
-   protected:
-    int int_axis;
-    Poly2DFracIntResidual();
-
-   public:
-    /// Residual of an integrated polynomial divided by the independent variable
-    /// @param poly polynomial object used to evaluate the calls
-    /// @param coefficients vector of coefficients
-    /// @param in double value that represents the current input in x (1st dimension) or y (2nd dimension)
-    /// @param z_in double value that represents the current output in the 3rd dimension
-    /// @param axis unsigned integer value that represents the axis to solve for (0=x, 1=y)
-    /// @param x_exp first exponent in x-direction
-    /// @param y_exp first exponent in y-direction
-    /// @param x_base base value for x (x = x_in - x_base)
-    /// @param y_base base value for y (y = y_in - y_base)
-    /// @param int_axis axis for the integration (0=x, 1=y)
-    Poly2DFracIntResidual(Polynomial2DFrac& poly, const Eigen::MatrixXd& coefficients, const double& in, const double& z_in, const int& axis,
-                          const int& x_exp, const int& y_exp, const double& x_base, const double& y_base, const int& int_axis);
-    virtual ~Poly2DFracIntResidual(){};
-    double call(double target);
-    double deriv(double target);
-};
-
-//
-//
-//
-//
-//
-//
-//
-//
-//
-///// The base class for Polynomials
-//class BasePolynomial{
-//
-//public:
-//    // Constructor
-//    BasePolynomial();
-//    // Destructor.  No implementation
-//    virtual ~BasePolynomial(){};
-//
-//public:
-//    /// Basic checks for coefficient vectors.
-//    /** Starts with only the first coefficient dimension
-//     *  and checks the vector length against parameter n. */
-//    bool checkCoefficients(const Eigen::VectorXd &coefficients, const unsigned int n);
-//    bool checkCoefficients(const Eigen::MatrixXd &coefficients, const unsigned int rows, const unsigned int columns);
-//    bool checkCoefficients(const std::vector<double> &coefficients, const unsigned int n);
-//    bool checkCoefficients(const std::vector< std::vector<double> > &coefficients, const unsigned int rows, const unsigned int columns);
-//
-//    /** Integrating coefficients for polynomials is done by dividing the
-//     *  original coefficients by (i+1) and elevating the order by 1
-//     *  through adding a zero as first coefficient.
-//     *  Some reslicing needs to be applied to integrate along the x-axis.
-//     *  In the brine/solution equations, reordering of the parameters
-//     *  avoids this expensive operation. However, it is included for the
-//     *  sake of completeness.
-//     */
-//    std::vector<double> integrateCoeffs(const std::vector<double> &coefficients);
-//    std::vector< std::vector<double> > integrateCoeffs(const std::vector< std::vector<double> > &coefficients, bool axis);
-//
-//    /** Deriving coefficients for polynomials is done by multiplying the
-//     *  original coefficients with i and lowering the order by 1.
-//     *
-//     *  It is not really deprecated, but untested and therefore a warning
-//     *  is issued. Please check this method before you use it.
-//     */
-//    std::vector<double> deriveCoeffs(const std::vector<double> &coefficients);
-//    std::vector< std::vector<double> > deriveCoeffs(const std::vector< std::vector<double> > &coefficients, unsigned int axis);
-//
-//private:
-//    /** The core of the polynomial wrappers are the different
-//     *  implementations that follow below. In case there are
-//     *  new calculation schemes available, please do not delete
-//     *  the implementations, but mark them as deprecated.
-//     *  The old functions are good for debugging since the
-//     *  structure is easier to read than the backward Horner-scheme
-//     *  or the recursive Horner-scheme.
-//     */
-//
-//    /// Simple polynomial function generator. <- Deprecated due to poor performance, use Horner-scheme instead
-//    /** Base function to produce n-th order polynomials
-//     *  based on the length of the coefficient vector.
-//     *  Starts with only the first coefficient at x^0. */
-//    DEPRECATED(double simplePolynomial(const std::vector<double> &coefficients, double x));
-//    DEPRECATED(double simplePolynomial(const std::vector<std::vector<double> > &coefficients, double x, double y));
-//
-//    /// Simple integrated polynomial function generator.
-//    /** Base function to produce integrals of n-th order polynomials based on
-//     *  the length of the coefficient vector.
-//     *  Starts with only the first coefficient at x^0 */
-//    ///Indefinite integral in x-direction
-//    double simplePolynomialInt(const std::vector<double> &coefficients, double x);
-//    ///Indefinite integral in y-direction only
-//    double simplePolynomialInt(const std::vector<std::vector<double> > &coefficients, double x, double y);
-//
-//    /// Simple integrated polynomial function generator divided by independent variable.
-//    /** Base function to produce integrals of n-th order
-//     *  polynomials based on the length of the coefficient
-//     *  vector. Starts with only the first coefficient at x^0 */
-//    ///Indefinite integral of a polynomial divided by its independent variable
-//    double simpleFracInt(const std::vector<double> &coefficients, double x);
-//    ///Indefinite integral of a polynomial divided by its 2nd independent variable
-//    double simpleFracInt(const std::vector<std::vector<double> > &coefficients, double x, double y);
-//
-//    /** Simple integrated centred(!) polynomial function generator divided by independent variable.
-//     *  We need to rewrite some of the functions in order to
-//     *  use central fit. Having a central temperature xbase
-//     *  allows for a better fit, but requires a different
-//     *  formulation of the fracInt function group. Other
-//     *  functions are not affected.
-//     *  Starts with only the first coefficient at x^0 */
-//    ///Helper function to calculate the D vector:
-//    double factorial(double nValue);
-//    double binom(double nValue, double nValue2);
-//    std::vector<double> fracIntCentralDvector(int m, double x, double xbase);
-//    ///Indefinite integral of a centred polynomial divided by its independent variable
-//    double fracIntCentral(const std::vector<double> &coefficients, double x, double xbase);
-//
-//    /// Horner function generator implementations
-//    /** Represent polynomials according to Horner's scheme.
-//     *  This avoids unnecessary multiplication and thus
-//     *  speeds up calculation.
-//     */
-//    double baseHorner(const std::vector<double> &coefficients, double x);
-//    double baseHorner(const std::vector< std::vector<double> > &coefficients, double x, double y);
-//    ///Indefinite integral in x-direction
-//    double baseHornerInt(const std::vector<double> &coefficients, double x);
-//    ///Indefinite integral in y-direction only
-//    double baseHornerInt(const std::vector<std::vector<double> > &coefficients, double x, double y);
-//    ///Indefinite integral of a polynomial divided by its independent variable
-//    double baseHornerFracInt(const std::vector<double> &coefficients, double x);
-//    ///Indefinite integral of a polynomial divided by its 2nd independent variable
-//    double baseHornerFracInt(const std::vector<std::vector<double> > &coefficients, double x, double y);
-//
-//    /** Alternatives
-//     *  Simple functions that heavily rely on other parts of this file.
-//     *  We still need to check which combinations yield the best
-//     *  performance.
-//     */
-//    ///Derivative in x-direction
-//    double deriveIn2Steps(const std::vector<double> &coefficients, double x); // TODO: Check results!
-//    ///Derivative in terms of x(axis=true) or y(axis=false).
-//    double deriveIn2Steps(const std::vector< std::vector<double> > &coefficients, double x, double y, bool axis); // TODO: Check results!
-//    ///Indefinite integral in x-direction
-//    double integrateIn2Steps(const std::vector<double> &coefficients, double x);
-//    ///Indefinite integral in terms of x(axis=true) or y(axis=false).
-//    double integrateIn2Steps(const std::vector< std::vector<double> > &coefficients, double x, double y, bool axis);
-//    ///Indefinite integral in x-direction of a polynomial divided by its independent variable
-//    double fracIntIn2Steps(const std::vector<double> &coefficients, double x);
-//    ///Indefinite integral in y-direction of a polynomial divided by its 2nd independent variable
-//    double fracIntIn2Steps(const std::vector<std::vector<double> > &coefficients, double x, double y);
-//    ///Indefinite integral of a centred polynomial divided by its 2nd independent variable
-//    double fracIntCentral2Steps(const std::vector<std::vector<double> > &coefficients, double x, double y, double ybase);
-//
-//public:
-//    /** Here we define the functions that should be used by the
-//     *  respective implementations. Please do no use any other
-//     *  method since this would break the purpose of this interface.
-//     *  Note that the functions below are supposed to be aliases
-//     *  to implementations declared elsewhere in this file.
-//     */
-//
-//    /** Everything related to the normal polynomials goes in this
-//     *  section, holds all the functions for evaluating polynomials.
-//     */
-//    /// Evaluates a one-dimensional polynomial for the given coefficients
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current input
-//    virtual inline double polyval(const std::vector<double> &coefficients, double x){
-//        return baseHorner(coefficients,x);
-//    }
-//
-//    /// Evaluates a two-dimensional polynomial for the given coefficients
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current input in the 1st dimension
-//    /// @param y double value that represents the current input in the 2nd dimension
-//    virtual inline double polyval(const std::vector< std::vector<double> > &coefficients, double x, double y){
-//        return baseHorner(coefficients,x,y);
-//    }
-//
-//
-//    /** Everything related to the integrated polynomials goes in this
-//     *  section, holds all the functions for evaluating polynomials.
-//     */
-//    /// Evaluates the indefinite integral of a one-dimensional polynomial
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current input
-//    virtual inline double polyint(const std::vector<double> &coefficients, double x){
-//        return baseHornerInt(coefficients,x);
-//    }
-//
-//    /// Evaluates the indefinite integral of a two-dimensional polynomial along the 2nd axis (y)
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current input in the 1st dimension
-//    /// @param y double value that represents the current input in the 2nd dimension
-//    virtual inline double polyint(const std::vector< std::vector<double> > &coefficients, double x, double y){
-//        return baseHornerInt(coefficients,x,y);
-//    }
-//
-//
-//    /** Everything related to the derived polynomials goes in this
-//     *  section, holds all the functions for evaluating polynomials.
-//     */
-//    /// Evaluates the derivative of a one-dimensional polynomial
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current input
-//    virtual inline double polyder(const std::vector<double> &coefficients, double x){
-//        return deriveIn2Steps(coefficients,x);
-//    }
-//
-//    /// Evaluates the derivative of a two-dimensional polynomial along the 2nd axis (y)
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current input in the 1st dimension
-//    /// @param y double value that represents the current input in the 2nd dimension
-//    virtual inline double polyder(const std::vector< std::vector<double> > &coefficients, double x, double y){
-//        return deriveIn2Steps(coefficients,x,y,false);
-//    }
-//
-//
-//    /** Everything related to the polynomials divided by one variable goes in this
-//     *  section, holds all the functions for evaluating polynomials.
-//     */
-//    /// Evaluates the indefinite integral of a one-dimensional polynomial divided by its independent variable
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current position
-//    virtual inline double polyfracval(const std::vector<double> &coefficients, double x){
-//        return baseHorner(coefficients,x)/x;
-//    }
-//
-//    /// Evaluates the indefinite integral of a two-dimensional polynomial divided by its 2nd independent variable
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current input in the 1st dimension
-//    /// @param y double value that represents the current input in the 2nd dimension
-//    virtual inline double polyfracval(const std::vector< std::vector<double> > &coefficients, double x, double y){
-//        return baseHorner(coefficients,x,y)/y;
-//    }
-//
-//
-//    /** Everything related to the integrated polynomials divided by one variable goes in this
-//     *  section, holds all the functions for solving polynomials.
-//     */
-//    /// Evaluates the indefinite integral of a one-dimensional polynomial divided by its independent variable
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current position
-//    virtual inline double polyfracint(const std::vector<double> &coefficients, double x){
-//        return baseHornerFracInt(coefficients,x);
-//    }
-//
-//    /// Evaluates the indefinite integral of a two-dimensional polynomial divided by its 2nd independent variable
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current input in the 1st dimension
-//    /// @param y double value that represents the current input in the 2nd dimension
-//    virtual inline double polyfracint(const std::vector< std::vector<double> > &coefficients, double x, double y){
-//        return baseHornerFracInt(coefficients,x,y);
-//    }
-//
-//    /// Evaluates the indefinite integral of a centred one-dimensional polynomial divided by its independent variable
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current position
-//    /// @param xbase central temperature for fitted function
-//    virtual inline double polyfracintcentral(const std::vector<double> &coefficients, double x, double xbase){
-//        return fracIntCentral(coefficients,x,xbase);
-//    }
-//
-//    /// Evaluates the indefinite integral of a centred two-dimensional polynomial divided by its 2nd independent variable
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current input in the 1st dimension
-//    /// @param y double value that represents the current input in the 2nd dimension
-//    /// @param ybase central temperature for fitted function
-//    virtual inline double polyfracintcentral(const std::vector< std::vector<double> > &coefficients, double x, double y, double ybase){
-//        return fracIntCentral2Steps(coefficients,x,y,ybase);
-//    }
-//
-//
-//    /** Everything related to the derived polynomials divided by one variable goes in this
-//     *  section, holds all the functions for solving polynomials.
-//     */
-//    /// Evaluates the derivative of a one-dimensional polynomial divided by its independent variable
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current position
-//    virtual inline double polyfracder(const std::vector<double> &coefficients, double x){
-//        throw CoolProp::NotImplementedError("Derivatives of polynomials divided by their independent variable have not been implemented."); // TODO: Implement polyfracder1D
-//    }
-//
-//    /// Evaluates the derivative of a two-dimensional polynomial divided by its 2nd independent variable
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current input in the 1st dimension
-//    /// @param y double value that represents the current input in the 2nd dimension
-//    virtual inline double polyfracder(const std::vector< std::vector<double> > &coefficients, double x, double y){
-//        throw CoolProp::NotImplementedError("Derivatives of polynomials divided by their independent variable have not been implemented."); // TODO: Implement polyfracder2D
-//    }
-//
-//    /// Evaluates the derivative of a centred one-dimensional polynomial divided by its independent variable
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current position
-//    /// @param xbase central temperature for fitted function
-//    virtual inline double polyfracdercentral(const std::vector<double> &coefficients, double x, double xbase){
-//        throw CoolProp::NotImplementedError("Derivatives of polynomials divided by their independent variable have not been implemented."); // TODO: Implement polyfracdercentral1D
-//    }
-//
-//    /// Evaluates the derivative of a centred two-dimensional polynomial divided by its 2nd independent variable
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current input in the 1st dimension
-//    /// @param y double value that represents the current input in the 2nd dimension
-//    /// @param ybase central temperature for fitted function
-//    virtual inline double polyfracdercentral(const std::vector< std::vector<double> > &coefficients, double x, double y, double ybase){
-//        throw CoolProp::NotImplementedError("Derivatives of polynomials divided by their independent variable have not been implemented."); // TODO: Implement polyfracdercentral2D
-//    }
-//};
-//
-//
-//
-//
-///** Implements the function wrapper interface and can be
-// *  used by the solvers.
-// *  TODO: Make multidimensional
-// */
-//class PolyResidual : public FuncWrapper1D {
-//protected:
-//    enum dims {i1D, i2D};
-//    /// Object that evaluates the equation
-//    BasePolynomial poly;
-//    /// Current output value
-//    double output, firstDim;
-//    int dim;
-//    std::vector< std::vector<double> > coefficients;
-//private:
-//    PolyResidual();
-//public:
-//    PolyResidual(const std::vector<double> &coefficients, double y);
-//    PolyResidual(const std::vector< std::vector<double> > &coefficients, double x, double z);
-//    virtual ~PolyResidual(){};
-//    bool is2D(){return (this->dim==i2D);};
-//    virtual double call(double x);
-//    virtual double deriv(double x);
-//};
-//class PolyIntResidual : public PolyResidual {
-//public:
-//    PolyIntResidual(const std::vector<double> &coefficients, double y):PolyResidual(coefficients, y){};
-//    PolyIntResidual(const std::vector< std::vector<double> > &coefficients, double x, double z):PolyResidual(coefficients, x, z){};
-//    virtual double call(double x);
-//    virtual double deriv(double x);
-//};
-//class PolyFracIntResidual : public PolyResidual {
-//public:
-//    PolyFracIntResidual(const std::vector<double> &coefficients, double y):PolyResidual(coefficients, y){};
-//    PolyFracIntResidual(const std::vector< std::vector<double> > &coefficients, double x, double z):PolyResidual(coefficients, x, z){};
-//    virtual double call(double x);
-//    virtual double deriv(double x);
-//};
-//class PolyFracIntCentralResidual : public PolyResidual {
-//protected:
-//    double baseVal;
-//public:
-//    PolyFracIntCentralResidual(const std::vector<double> &coefficients, double y, double xBase):PolyResidual(coefficients, y){this->baseVal = xBase;};
-//    PolyFracIntCentralResidual(const std::vector< std::vector<double> > &coefficients, double x, double z, double yBase): PolyResidual(coefficients, x, z){this->baseVal = yBase;};
-//    virtual double call(double x);
-//    virtual double deriv(double x);
-//};
-//class PolyDerResidual : public PolyResidual {
-//public:
-//    PolyDerResidual(const std::vector<double> &coefficients, double y):PolyResidual(coefficients, y){};
-//    PolyDerResidual(const std::vector< std::vector<double> > &coefficients, double x, double z):PolyResidual(coefficients, x, z){};
-//    virtual double call(double x);
-//    virtual double deriv(double x);
-//};
-//
-//
-//
-//
-///** Implements the same public functions as the
-// *  but solves the polynomial for the given value
-// *  instead of evaluating it.
-// *  TODO: This class does not check for bijective
-// *        polynomials and is therefore a little
-// *        fragile.
-// */
-//class PolynomialSolver : public BasePolynomial{
-//private:
-//    enum solvers {iNewton, iBrent};
-//    int uses;
-//    double guess, min, max;
-//    double macheps, tol;
-//    int maxiter;
-//
-//public:
-//    // Constructor
-//    PolynomialSolver();
-//    // Destructor.  No implementation
-//    virtual ~PolynomialSolver(){};
-//
-//public:
-//    /** Here we redefine the functions that solve the polynomials.
-//     *  These implementations all use the base class to evaluate
-//     *  the polynomial during the solution process.
-//     */
-//
-//    /** Everything related to the normal polynomials goes in this
-//     *  section, holds all the functions for solving polynomials.
-//     */
-//    /// Solves a one-dimensional polynomial for the given coefficients
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param y double value that represents the current input
-//    virtual double polyval(const std::vector<double> &coefficients, double y);
-//
-//    /// Solves a two-dimensional polynomial for the given coefficients
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current input in the 1st dimension
-//    /// @param z double value that represents the current output
-//    virtual double polyval(const std::vector< std::vector<double> > &coefficients, double x, double z);
-//
-//
-//    /** Everything related to the integrated polynomials goes in this
-//     *  section, holds all the functions for solving polynomials.
-//     */
-//    /// Solves the indefinite integral of a one-dimensional polynomial
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param y double value that represents the current output
-//    virtual double polyint(const std::vector<double> &coefficients, double y);
-//
-//    /// Solves the indefinite integral of a two-dimensional polynomial along the 2nd axis (y)
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current input in the 1st dimension
-//    /// @param z double value that represents the current output
-//    virtual double polyint(const std::vector< std::vector<double> > &coefficients, double x, double z);
-//
-//
-//    /** Everything related to the derived polynomials goes in this
-//     *  section, holds all the functions for solving polynomials.
-//     */
-//    /// Solves the derivative of a one-dimensional polynomial
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param y double value that represents the current output
-//    virtual double polyder(const std::vector<double> &coefficients, double y);
-//
-//    /// Solves the derivative of a two-dimensional polynomial along the 2nd axis (y)
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current input in the 1st dimension
-//    /// @param z double value that represents the current output
-//    virtual double polyder(const std::vector< std::vector<double> > &coefficients, double x, double z);
-//
-//
-//    /** Everything related to the polynomials divided by one variable goes in this
-//     *  section, holds all the functions for solving polynomials.
-//     */
-//    /// Solves the indefinite integral of a one-dimensional polynomial divided by its independent variable
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param y double value that represents the current output
-//    virtual double polyfracval(const std::vector<double> &coefficients, double y);
-//
-//    /// Solves the indefinite integral of a two-dimensional polynomial divided by its 2nd independent variable
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current input in the 1st dimension
-//    /// @param z double value that represents the current output
-//    virtual double polyfracval(const std::vector< std::vector<double> > &coefficients, double x, double z);
-//
-//
-//    /** Everything related to the integrated polynomials divided by one variable goes in this
-//     *  section, holds all the functions for solving polynomials.
-//     */
-//    /// Solves the indefinite integral of a one-dimensional polynomial divided by its independent variable
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param y double value that represents the current output
-//    virtual double polyfracint(const std::vector<double> &coefficients, double y);
-//
-//    /// Solves the indefinite integral of a two-dimensional polynomial divided by its 2nd independent variable
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current input in the 1st dimension
-//    /// @param z double value that represents the current output
-//    virtual double polyfracint(const std::vector< std::vector<double> > &coefficients, double x, double z);
-//
-//    /// Solves the indefinite integral of a centred one-dimensional polynomial divided by its independent variable
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param y double value that represents the current output
-//    /// @param xbase central x-value for fitted function
-//    virtual double polyfracintcentral(const std::vector<double> &coefficients, double y, double xbase);
-//
-//    /// Solves the indefinite integral of a centred two-dimensional polynomial divided by its 2nd independent variable
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current input in the 1st dimension
-//    /// @param z double value that represents the current output
-//    /// @param ybase central y-value for fitted function
-//    virtual double polyfracintcentral(const std::vector< std::vector<double> > &coefficients, double x, double z, double ybase);
-//
-//
-//    /** Everything related to the derived polynomials divided by one variable goes in this
-//     *  section, holds all the functions for solving polynomials.
-//     */
-//    /// Solves the derivative of a one-dimensional polynomial divided by its independent variable
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param y double value that represents the current output
-//    virtual double polyfracder(const std::vector<double> &coefficients, double y);
-//
-//    /// Solves the derivative of a two-dimensional polynomial divided by its 2nd independent variable
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current input in the 1st dimension
-//    /// @param z double value that represents the current output
-//    virtual double polyfracder(const std::vector< std::vector<double> > &coefficients, double x, double z);
-//
-//    /// Solves the derivative of a centred one-dimensional polynomial divided by its independent variable
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param y double value that represents the current output
-//    /// @param xbase central x-value for fitted function
-//    virtual double polyfracdercentral(const std::vector<double> &coefficients, double y, double xbase);
-//
-//    /// Solves the derivative of a centred two-dimensional polynomial divided by its 2nd independent variable
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current input in the 1st dimension
-//    /// @param z double value that represents the current output
-//    /// @param ybase central y-value for fitted function
-//    virtual double polyfracdercentral(const std::vector< std::vector<double> > &coefficients, double x, double z, double ybase);
-//
-//
-//    /** Set the solvers and updates either the guess values or the
-//     *  boundaries for the variable to solve for.
-//     */
-//    /// Sets the guess value for the Newton solver and enables it.
-//    /// @param guess double value that represents the guess value
-//    virtual void setGuess(double guess);
-//    /// Sets the limits for the Brent solver and enables it.
-//    /// @param min double value that represents the lower boundary
-//    /// @param max double value that represents the upper boundary
-//    virtual void setLimits(double min, double max);
-//    /// Solves the equations based on previously defined parameters.
-//    /// @param min double value that represents the lower boundary
-//    /// @param max double value that represents the upper boundary
-//    virtual double solve(PolyResidual &res);
-//};
-//
-//
-///// The base class for exponential functions
-//class BaseExponential{
-//
-//protected:
-//    BasePolynomial poly;
-//    bool POLYMATH_DEBUG;
-//
-//public:
-//    BaseExponential();
-//    virtual ~BaseExponential(){};
-//
-//public:
-//    /// Evaluates an exponential function for the given coefficients
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current input
-//    /// @param n int value that determines the kind of exponential function
-//    double expval(const std::vector<double> &coefficients, double x, int n);
-//
-//    /// Evaluates an exponential function for the given coefficients
-//    /// @param coefficients vector containing the ordered coefficients
-//    /// @param x double value that represents the current input in the 1st dimension
-//    /// @param y double value that represents the current input in the 2nd dimension
-//    /// @param n int value that determines the kind of exponential function
-//    double expval(const std::vector< std::vector<double> > &coefficients, double x, double y, int n);
-//};
-
-}; /* namespace CoolProp */
-#endif
+#ifndef POLYMATH_H
+#define POLYMATH_H
+
+#include "CoolProp.h"
+#include "CoolPropTools.h"
+#include "Exceptions.h"
+
+#include <vector>
+#include <string>
+#include "Solvers.h"
+#include "MatrixMath.h"
+#include "unsupported/Eigen/Polynomials"
+
+namespace CoolProp {
+
+// Just a forward declaration
+class Poly2DResidual;
+class Poly2DFracResidual;
+
+/// The base class for all Polynomials
+/** A clear and straight forward implementation of polynomial operations. Still
+ *  very basic, but serves its purpose.
+ */
+class Polynomial2D
+{
+
+   public:
+    /// Constructors
+    Polynomial2D(){};
+
+    /// Destructor.  No implementation
+    virtual ~Polynomial2D(){};
+
+   public:
+    /// Convert the coefficient vector.
+    /// @param coefficients vector containing the ordered coefficients
+    Eigen::MatrixXd convertCoefficients(const std::vector<double>& coefficients) {
+        return vec_to_eigen(coefficients);
+    }
+    /// Convert the coefficient matrix.
+    /// @param coefficients matrix containing the ordered coefficients
+    Eigen::MatrixXd convertCoefficients(const std::vector<std::vector<double>>& coefficients) {
+        return vec_to_eigen(coefficients);
+    }
+
+    /// Basic checks for coefficient vectors.
+    /** Starts with only the first coefficient dimension
+     *  and checks the matrix size against the parameters rows and columns. */
+    /// @param coefficients matrix containing the ordered coefficients
+    /// @param rows unsigned integer value that represents the desired degree of the polynomial in the 1st dimension
+    /// @param columns unsigned integer value that represents the desired degree of the polynomial in the 2nd dimension
+    bool checkCoefficients(const Eigen::MatrixXd& coefficients, const unsigned int rows, const unsigned int columns);
+
+   public:
+    /// Integration functions
+    /** Integrating coefficients for polynomials is done by dividing the
+     *  original coefficients by (i+1) and elevating the order by 1
+     *  through adding a zero as first coefficient.
+     *  Some reslicing needs to be applied to integrate along the x-axis.
+     *  In the brine/solution equations, reordering of the parameters
+     *  avoids this expensive operation. However, it is included for the
+     *  sake of completeness.
+     */
+    /// @param coefficients matrix containing the ordered coefficients
+    /// @param axis unsigned integer value that represents the desired direction of integration
+    /// @param times integer value that represents the desired order of integration
+    Eigen::MatrixXd integrateCoeffs(const Eigen::MatrixXd& coefficients, const int& axis, const int& times);
+
+    /// Derivative coefficients calculation
+    /** Deriving coefficients for polynomials is done by multiplying the
+     *  original coefficients with i and lowering the order by 1.
+     */
+    /// @param coefficients matrix containing the ordered coefficients
+    /// @param axis unsigned integer value that represents the desired direction of derivation
+    /// @param times integer value that represents the desired order of derivation
+    Eigen::MatrixXd deriveCoeffs(const Eigen::MatrixXd& coefficients, const int& axis = -1, const int& times = 1);
+
+   public:
+    /// The core functions to evaluate the polynomial
+    /** It is here we implement the different special
+     *  functions that allow us to specify certain
+     *  types of polynomials.
+     *
+     *  Try to avoid many calls to the derivative and integral functions.
+     *  Both of them have to calculate the new coefficients internally,
+     *  which slows things down. Instead, you should use the deriveCoeffs
+     *  and integrateCoeffs functions and store the coefficient matrix
+     *  you need for future calls to evaluate derivative and integral.
+     */
+    /// @param coefficients vector containing the ordered coefficients
+    /// @param x_in double value that represents the current input in the 1st dimension
+    double evaluate(const Eigen::MatrixXd& coefficients, const double& x_in);
+
+    /// @param coefficients vector containing the ordered coefficients
+    /// @param x_in double value that represents the current input in the 1st dimension
+    /// @param y_in double value that represents the current input in the 2nd dimension
+    double evaluate(const Eigen::MatrixXd& coefficients, const double& x_in, const double& y_in);
+
+    /// @param coefficients vector containing the ordered coefficients
+    /// @param x_in double value that represents the current input in the 1st dimension
+    /// @param y_in double value that represents the current input in the 2nd dimension
+    /// @param axis unsigned integer value that represents the axis to derive for (0=x, 1=y)
+    double derivative(const Eigen::MatrixXd& coefficients, const double& x_in, const double& y_in, const int& axis);
+
+    /// @param coefficients vector containing the ordered coefficients
+    /// @param x_in double value that represents the current input in the 1st dimension
+    /// @param y_in double value that represents the current input in the 2nd dimension
+    /// @param axis unsigned integer value that represents the axis to integrate for (0=x, 1=y)
+    double integral(const Eigen::MatrixXd& coefficients, const double& x_in, const double& y_in, const int& axis);
+
+   protected:
+    // TODO: Why doe these base definitions not work with derived classes?
+    /// Uses the Brent solver to find the roots of p(x_in,y_in)-z_in
+    /// @param res Poly2DResidual object to calculate residuals and derivatives
+    /// @param min double value that represents the minimum value
+    /// @param max double value that represents the maximum value
+    double solve_limits(Poly2DResidual* res, const double& min, const double& max);
+
+    // TODO: Why doe these base definitions not work with derived classes?
+    /// Uses the Newton solver to find the roots of p(x_in,y_in)-z_in
+    /// @param res Poly2DResidual object to calculate residuals and derivatives
+    /// @param guess double value that represents the start value
+    double solve_guess(Poly2DResidual* res, const double& guess);
+
+   public:
+    /// Returns a vector with ALL the real roots of p(x_in,y_in)-z_in
+    /// @param coefficients vector containing the ordered coefficients
+    /// @param in double value that represents the current input in x (1st dimension) or y (2nd dimension)
+    /// @param z_in double value that represents the current output in the 3rd dimension
+    /// @param axis unsigned integer value that represents the axis to solve for (0=x, 1=y)
+    Eigen::VectorXd solve(const Eigen::MatrixXd& coefficients, const double& in, const double& z_in, const int& axis);
+
+    /// Uses the Brent solver to find the roots of p(x_in,y_in)-z_in
+    /// @param coefficients vector containing the ordered coefficients
+    /// @param in double value that represents the current input in x (1st dimension) or y (2nd dimension)
+    /// @param z_in double value that represents the current output in the 3rd dimension
+    /// @param min double value that represents the minimum value
+    /// @param max double value that represents the maximum value
+    /// @param axis unsigned integer value that represents the axis to solve for (0=x, 1=y)
+    double solve_limits(const Eigen::MatrixXd& coefficients, const double& in, const double& z_in, const double& min, const double& max,
+                        const int& axis);
+
+    /// Uses the Newton solver to find the roots of p(x_in,y_in)-z_in
+    /// @param coefficients vector containing the ordered coefficients
+    /// @param in double value that represents the current input in x (1st dimension) or y (2nd dimension)
+    /// @param z_in double value that represents the current output in the 3rd dimension
+    /// @param guess double value that represents the start value
+    /// @param axis unsigned integer value that represents the axis to solve for (0=x, 1=y)
+    double solve_guess(const Eigen::MatrixXd& coefficients, const double& in, const double& z_in, const double& guess, const int& axis);
+
+   protected:
+    /// Simple polynomial function generator. <- Deprecated due to poor performance, use Horner-scheme instead
+    /** Base function to produce n-th order polynomials
+     *  based on the length of the coefficient vector.
+     *  Starts with only the first coefficient at x^0. */
+    double simplePolynomial(const std::vector<double>& coefficients, double x);
+    DEPRECATED(double simplePolynomial(const std::vector<std::vector<double>>& coefficients, double x, double y));
+    /// Horner function generator implementations
+    /** Represent polynomials according to Horner's scheme.
+     *  This avoids unnecessary multiplication and thus
+     *  speeds up calculation.
+     *  Deprecated since we moved everything to the Eigen framework.
+     */
+    double baseHorner(const std::vector<double>& coefficients, double x);
+    DEPRECATED(double baseHorner(const std::vector<std::vector<double>>& coefficients, double x, double y));
+
+    bool do_debug(void) {
+        return get_debug_level() >= 500;
+    }
+};
+
+class Poly2DResidual : public FuncWrapper1DWithDeriv
+{
+   protected:
+    enum dims
+    {
+        iX,
+        iY
+    };
+    Eigen::MatrixXd coefficients;
+    bool derIsSet;
+    Eigen::MatrixXd coefficientsDer;
+    int axis;
+    /// the fixed input != targetDim
+    double in;
+    /// Object that evaluates the equation
+    Polynomial2D poly;
+    /// Current output value
+    double z_in;
+
+   protected:
+    Poly2DResidual();
+
+   public:
+    /// Residual of a polynomial
+    /// @param poly polynomial object used to evaluate the calls
+    /// @param coefficients
+    /// @param in double value that represents the current input in x (1st dimension) or y (2nd dimension)
+    /// @param z_in double value that represents the current output in the 3rd dimension
+    /// @param axis unsigned integer value that represents the axis to solve for (0=x, 1=y)
+    Poly2DResidual(Polynomial2D& poly, const Eigen::MatrixXd& coefficients, const double& in, const double& z_in, const int& axis);
+    virtual ~Poly2DResidual(){};
+
+    double call(double target);
+    double deriv(double target);
+};
+
+/// A class for polynomials starting at an arbitrary degree.
+/** It is implemented for the incompressibles and is a little messy, but seems to
+ *  work fine for now. Besides handling arbitrary starting exponents for the
+ *  polynomials, it can also calculate polynomials with a base value. This means
+ *  that the independent variable no longer is x, but (x-x_base). For fitted
+ *  functions, we often see such a design to enhance the fit quality/stability.
+ */
+class Polynomial2DFrac : public Polynomial2D
+{
+
+   public:
+    /// Constructors
+    Polynomial2DFrac(){};
+
+    /// Destructor.  No implementation
+    virtual ~Polynomial2DFrac(){};
+
+   public:
+    //    /// Integration functions
+    //    /** Integrating coefficients for polynomials is done by dividing the
+    //     *  original coefficients by (i+1) and elevating the order by 1
+    //     *  through adding a zero as first coefficient.
+    //     *  Some reslicing needs to be applied to integrate along the x-axis.
+    //     *  In the brine/solution equations, reordering of the parameters
+    //     *  avoids this expensive operation. However, it is included for the
+    //     *  sake of completeness.
+    //     */
+    //    /// @param coefficients matrix containing the ordered coefficients
+    //    /// @param axis unsigned integer value that represents the desired direction of integration
+    //    /// @param times integer value that represents the desired order of integration
+    //    /// @param firstExponent integer value that represents the first exponent of the polynomial in axis direction
+    //    Eigen::MatrixXd integrateCoeffs(const Eigen::MatrixXd &coefficients, const int &axis, const int &times, const int &firstExponent);
+    //
+    /// Derivative coefficients calculation
+    /** Deriving coefficients for polynomials is done by multiplying the
+     *  original coefficients with i and lowering the order by 1.
+     *
+     *  Remember that the first exponent might need to be adjusted after derivation.
+     *  It has to be lowered by times:
+     *  derCoeffs = deriveCoeffs(coefficients, axis, times, firstExponent);
+     *  firstExponent -= times;
+     */
+    /// @param coefficients matrix containing the ordered coefficients
+    /// @param axis unsigned integer value that represents the desired direction of derivation
+    /// @param times integer value that represents the desired order of derivation
+    /// @param firstExponent integer value that represents the lowest exponent of the polynomial in axis direction
+    Eigen::MatrixXd deriveCoeffs(const Eigen::MatrixXd& coefficients, const int& axis, const int& times, const int& firstExponent);
+
+   public:
+    /// The core functions to evaluate the polynomial
+    /** It is here we implement the different special
+     *  functions that allow us to specify certain
+     *  types of polynomials.
+     *
+     *  Try to avoid many calls to the derivative and integral functions.
+     *  Both of them have to calculate the new coefficients internally,
+     *  which slows things down. Instead, you should use the deriveCoeffs
+     *  and integrateCoeffs functions and store the coefficient matrix
+     *  you need for future calls to evaluate derivative and integral.
+     */
+    /// @param coefficients vector containing the ordered coefficients
+    /// @param x_in double value that represents the current input in the 1st dimension
+    /// @param firstExponent integer value that represents the lowest exponent of the polynomial
+    /// @param x_base double value that represents the base value for a centered fit in the 1st dimension
+    double evaluate(const Eigen::MatrixXd& coefficients, const double& x_in, const int& firstExponent = 0, const double& x_base = 0.0);
+
+    /// @param coefficients matrix containing the ordered coefficients
+    /// @param x_in double value that represents the current input in the 1st dimension
+    /// @param y_in double value that represents the current input in the 2nd dimension
+    /// @param x_exp integer value that represents the lowest exponent of the polynomial in the 1st dimension
+    /// @param y_exp integer value that represents the lowest exponent of the polynomial in the 2nd dimension
+    /// @param x_base double value that represents the base value for a centered fit in the 1st dimension
+    /// @param y_base double value that represents the base value for a centered fit in the 2nd dimension
+    double evaluate(const Eigen::MatrixXd& coefficients, const double& x_in, const double& y_in, const int& x_exp, const int& y_exp,
+                    const double& x_base = 0.0, const double& y_base = 0.0);
+
+    /// @param coefficients vector containing the ordered coefficients
+    /// @param x_in double value that represents the current input in the 1st dimension
+    /// @param y_in double value that represents the current input in the 2nd dimension
+    /// @param axis unsigned integer value that represents the axis to derive for (0=x, 1=y)
+    /// @param x_exp integer value that represents the lowest exponent of the polynomial in the 1st dimension
+    /// @param y_exp integer value that represents the lowest exponent of the polynomial in the 2nd dimension
+    /// @param x_base double value that represents the base value for a centred fit in the 1st dimension
+    /// @param y_base double value that represents the base value for a centred fit in the 2nd dimension
+    double derivative(const Eigen::MatrixXd& coefficients, const double& x_in, const double& y_in, const int& axis, const int& x_exp,
+                      const int& y_exp, const double& x_base = 0.0, const double& y_base = 0.0);
+
+    /// @param coefficients vector containing the ordered coefficients
+    /// @param x_in double value that represents the current input in the 1st dimension
+    /// @param y_in double value that represents the current input in the 2nd dimension
+    /// @param axis unsigned integer value that represents the axis to integrate for (0=x, 1=y)
+    /// @param x_exp integer value that represents the lowest exponent of the polynomial in the 1st dimension
+    /// @param y_exp integer value that represents the lowest exponent of the polynomial in the 2nd dimension
+    /// @param x_base double value that represents the base value for a centred fit in the 1st dimension
+    /// @param y_base double value that represents the base value for a centred fit in the 2nd dimension
+    /// @param ax_val double value that represents the base value for the definite integral on the chosen axis.
+    double integral(const Eigen::MatrixXd& coefficients, const double& x_in, const double& y_in, const int& axis, const int& x_exp, const int& y_exp,
+                    const double& x_base = 0.0, const double& y_base = 0.0, const double& ax_val = 0.0);
+
+   public:
+    /// Returns a vector with ALL the real roots of p(x_in,y_in)-z_in
+    /// @param coefficients vector containing the ordered coefficients
+    /// @param in double value that represents the current input in x (1st dimension) or y (2nd dimension)
+    /// @param z_in double value that represents the current output in the 3rd dimension
+    /// @param axis unsigned integer value that represents the axis to solve for (0=x, 1=y)
+    /// @param x_exp integer value that represents the lowest exponent of the polynomial in the 1st dimension
+    /// @param y_exp integer value that represents the lowest exponent of the polynomial in the 2nd dimension
+    /// @param x_base double value that represents the base value for a centred fit in the 1st dimension
+    /// @param y_base double value that represents the base value for a centred fit in the 2nd dimension
+    Eigen::VectorXd solve(const Eigen::MatrixXd& coefficients, const double& in, const double& z_in, const int& axis, const int& x_exp,
+                          const int& y_exp, const double& x_base = 0.0, const double& y_base = 0.0);
+
+    /// Uses the Brent solver to find the roots of p(x_in,y_in)-z_in
+    /// @param coefficients vector containing the ordered coefficients
+    /// @param in double value that represents the current input in x (1st dimension) or y (2nd dimension)
+    /// @param z_in double value that represents the current output in the 3rd dimension
+    /// @param min double value that represents the minimum value
+    /// @param max double value that represents the maximum value
+    /// @param axis unsigned integer value that represents the axis to solve for (0=x, 1=y)
+    /// @param x_exp integer value that represents the lowest exponent of the polynomial in the 1st dimension
+    /// @param y_exp integer value that represents the lowest exponent of the polynomial in the 2nd dimension
+    /// @param x_base double value that represents the base value for a centred fit in the 1st dimension
+    /// @param y_base double value that represents the base value for a centred fit in the 2nd dimension
+    double solve_limits(const Eigen::MatrixXd& coefficients, const double& in, const double& z_in, const double& min, const double& max,
+                        const int& axis, const int& x_exp, const int& y_exp, const double& x_base = 0.0, const double& y_base = 0.0);
+
+    /// Uses the Newton solver to find the roots of p(x_in,y_in)-z_in
+    /// @param coefficients vector containing the ordered coefficients
+    /// @param in double value that represents the current input in x (1st dimension) or y (2nd dimension)
+    /// @param z_in double value that represents the current output in the 3rd dimension
+    /// @param guess double value that represents the start value
+    /// @param axis unsigned integer value that represents the axis to solve for (0=x, 1=y)
+    /// @param x_exp integer value that represents the lowest exponent of the polynomial in the 1st dimension
+    /// @param y_exp integer value that represents the lowest exponent of the polynomial in the 2nd dimension
+    /// @param x_base double value that represents the base value for a centred fit in the 1st dimension
+    /// @param y_base double value that represents the base value for a centred fit in the 2nd dimension
+    double solve_guess(const Eigen::MatrixXd& coefficients, const double& in, const double& z_in, const double& guess, const int& axis,
+                       const int& x_exp, const int& y_exp, const double& x_base = 0.0, const double& y_base = 0.0);
+
+    /// Uses the Brent solver to find the roots of Int(p(x_in,y_in))-z_in
+    /// @param coefficients vector containing the ordered coefficients
+    /// @param in double value that represents the current input in x (1st dimension) or y (2nd dimension)
+    /// @param z_in double value that represents the current output in the 3rd dimension
+    /// @param min double value that represents the minimum value
+    /// @param max double value that represents the maximum value
+    /// @param axis unsigned integer value that represents the axis to solve for (0=x, 1=y)
+    /// @param x_exp integer value that represents the lowest exponent of the polynomial in the 1st dimension
+    /// @param y_exp integer value that represents the lowest exponent of the polynomial in the 2nd dimension
+    /// @param x_base double value that represents the base value for a centred fit in the 1st dimension
+    /// @param y_base double value that represents the base value for a centred fit in the 2nd dimension
+    /// @param int_axis axis for the integration (0=x, 1=y)
+    double solve_limitsInt(const Eigen::MatrixXd& coefficients, const double& in, const double& z_in, const double& min, const double& max,
+                           const int& axis, const int& x_exp, const int& y_exp, const double& x_base = 0.0, const double& y_base = 0.0,
+                           const int& int_axis = 0);
+
+    /// Uses the Newton solver to find the roots of Int(p(x_in,y_in))-z_in
+    /// @param coefficients vector containing the ordered coefficients
+    /// @param in double value that represents the current input in x (1st dimension) or y (2nd dimension)
+    /// @param z_in double value that represents the current output in the 3rd dimension
+    /// @param guess double value that represents the start value
+    /// @param axis unsigned integer value that represents the axis to solve for (0=x, 1=y)
+    /// @param x_exp integer value that represents the lowest exponent of the polynomial in the 1st dimension
+    /// @param y_exp integer value that represents the lowest exponent of the polynomial in the 2nd dimension
+    /// @param x_base double value that represents the base value for a centred fit in the 1st dimension
+    /// @param y_base double value that represents the base value for a centred fit in the 2nd dimension
+    /// @param int_axis axis for the integration (0=x, 1=y)
+    double solve_guessInt(const Eigen::MatrixXd& coefficients, const double& in, const double& z_in, const double& guess, const int& axis,
+                          const int& x_exp, const int& y_exp, const double& x_base = 0.0, const double& y_base = 0.0, const int& int_axis = 0);
+
+   protected:
+    /// @param nValue integer value that represents the order of the factorial
+    double factorial(const int& nValue);
+
+    /// @param nValue integer value that represents the upper part of the factorial
+    /// @param nValue2 integer value that represents the lower part of the factorial
+    double binom(const int& nValue, const int& nValue2);
+
+    ///Helper function to calculate the D vector:
+    /// @param m integer value that represents order
+    /// @param x_in double value that represents the current input
+    /// @param x_base double value that represents the basis for the fit
+    Eigen::MatrixXd fracIntCentralDvector(const int& m, const double& x_in, const double& x_base);
+
+    ///Indefinite integral of a centred polynomial divided by its independent variable
+    /// @param coefficients vector containing the ordered coefficients
+    /// @param x_in double value that represents the current input
+    /// @param x_base double value that represents the basis for the fit
+    double fracIntCentral(const Eigen::MatrixXd& coefficients, const double& x_in, const double& x_base);
+};
+
+class Poly2DFracResidual : public Poly2DResidual
+{
+   protected:
+    int x_exp, y_exp;
+    double x_base, y_base;
+    /// Object that evaluates the equation
+    Polynomial2DFrac poly;
+
+   protected:
+    Poly2DFracResidual();
+
+   public:
+    /// Residual of a polynomial divided by the independent variable
+    /// @param poly polynomial object used to evaluate the calls
+    /// @param coefficients
+    /// @param in double value that represents the current input in x (1st dimension) or y (2nd dimension)
+    /// @param z_in double value that represents the current output in the 3rd dimension
+    /// @param axis unsigned integer value that represents the axis to solve for (0=x, 1=y)
+    /// @param x_exp first exponent in x-direction
+    /// @param y_exp first exponent in y-direction
+    /// @param x_base base value for x (x = x_in - x_base)
+    /// @param y_base base value for y (y = y_in - y_base)
+    Poly2DFracResidual(Polynomial2DFrac& poly, const Eigen::MatrixXd& coefficients, const double& in, const double& z_in, const int& axis,
+                       const int& x_exp, const int& y_exp, const double& x_base, const double& y_base);
+    virtual ~Poly2DFracResidual(){};
+    double call(double target);
+    double deriv(double target);
+};
+
+class Poly2DFracIntResidual : public Poly2DFracResidual
+{
+
+   protected:
+    int int_axis;
+    Poly2DFracIntResidual();
+
+   public:
+    /// Residual of an integrated polynomial divided by the independent variable
+    /// @param poly polynomial object used to evaluate the calls
+    /// @param coefficients vector of coefficients
+    /// @param in double value that represents the current input in x (1st dimension) or y (2nd dimension)
+    /// @param z_in double value that represents the current output in the 3rd dimension
+    /// @param axis unsigned integer value that represents the axis to solve for (0=x, 1=y)
+    /// @param x_exp first exponent in x-direction
+    /// @param y_exp first exponent in y-direction
+    /// @param x_base base value for x (x = x_in - x_base)
+    /// @param y_base base value for y (y = y_in - y_base)
+    /// @param int_axis axis for the integration (0=x, 1=y)
+    Poly2DFracIntResidual(Polynomial2DFrac& poly, const Eigen::MatrixXd& coefficients, const double& in, const double& z_in, const int& axis,
+                          const int& x_exp, const int& y_exp, const double& x_base, const double& y_base, const int& int_axis);
+    virtual ~Poly2DFracIntResidual(){};
+    double call(double target);
+    double deriv(double target);
+};
+
+//
+//
+//
+//
+//
+//
+//
+//
+//
+///// The base class for Polynomials
+//class BasePolynomial{
+//
+//public:
+//    // Constructor
+//    BasePolynomial();
+//    // Destructor.  No implementation
+//    virtual ~BasePolynomial(){};
+//
+//public:
+//    /// Basic checks for coefficient vectors.
+//    /** Starts with only the first coefficient dimension
+//     *  and checks the vector length against parameter n. */
+//    bool checkCoefficients(const Eigen::VectorXd &coefficients, const unsigned int n);
+//    bool checkCoefficients(const Eigen::MatrixXd &coefficients, const unsigned int rows, const unsigned int columns);
+//    bool checkCoefficients(const std::vector<double> &coefficients, const unsigned int n);
+//    bool checkCoefficients(const std::vector< std::vector<double> > &coefficients, const unsigned int rows, const unsigned int columns);
+//
+//    /** Integrating coefficients for polynomials is done by dividing the
+//     *  original coefficients by (i+1) and elevating the order by 1
+//     *  through adding a zero as first coefficient.
+//     *  Some reslicing needs to be applied to integrate along the x-axis.
+//     *  In the brine/solution equations, reordering of the parameters
+//     *  avoids this expensive operation. However, it is included for the
+//     *  sake of completeness.
+//     */
+//    std::vector<double> integrateCoeffs(const std::vector<double> &coefficients);
+//    std::vector< std::vector<double> > integrateCoeffs(const std::vector< std::vector<double> > &coefficients, bool axis);
+//
+//    /** Deriving coefficients for polynomials is done by multiplying the
+//     *  original coefficients with i and lowering the order by 1.
+//     *
+//     *  It is not really deprecated, but untested and therefore a warning
+//     *  is issued. Please check this method before you use it.
+//     */
+//    std::vector<double> deriveCoeffs(const std::vector<double> &coefficients);
+//    std::vector< std::vector<double> > deriveCoeffs(const std::vector< std::vector<double> > &coefficients, unsigned int axis);
+//
+//private:
+//    /** The core of the polynomial wrappers are the different
+//     *  implementations that follow below. In case there are
+//     *  new calculation schemes available, please do not delete
+//     *  the implementations, but mark them as deprecated.
+//     *  The old functions are good for debugging since the
+//     *  structure is easier to read than the backward Horner-scheme
+//     *  or the recursive Horner-scheme.
+//     */
+//
+//    /// Simple polynomial function generator. <- Deprecated due to poor performance, use Horner-scheme instead
+//    /** Base function to produce n-th order polynomials
+//     *  based on the length of the coefficient vector.
+//     *  Starts with only the first coefficient at x^0. */
+//    DEPRECATED(double simplePolynomial(const std::vector<double> &coefficients, double x));
+//    DEPRECATED(double simplePolynomial(const std::vector<std::vector<double> > &coefficients, double x, double y));
+//
+//    /// Simple integrated polynomial function generator.
+//    /** Base function to produce integrals of n-th order polynomials based on
+//     *  the length of the coefficient vector.
+//     *  Starts with only the first coefficient at x^0 */
+//    ///Indefinite integral in x-direction
+//    double simplePolynomialInt(const std::vector<double> &coefficients, double x);
+//    ///Indefinite integral in y-direction only
+//    double simplePolynomialInt(const std::vector<std::vector<double> > &coefficients, double x, double y);
+//
+//    /// Simple integrated polynomial function generator divided by independent variable.
+//    /** Base function to produce integrals of n-th order
+//     *  polynomials based on the length of the coefficient
+//     *  vector. Starts with only the first coefficient at x^0 */
+//    ///Indefinite integral of a polynomial divided by its independent variable
+//    double simpleFracInt(const std::vector<double> &coefficients, double x);
+//    ///Indefinite integral of a polynomial divided by its 2nd independent variable
+//    double simpleFracInt(const std::vector<std::vector<double> > &coefficients, double x, double y);
+//
+//    /** Simple integrated centred(!) polynomial function generator divided by independent variable.
+//     *  We need to rewrite some of the functions in order to
+//     *  use central fit. Having a central temperature xbase
+//     *  allows for a better fit, but requires a different
+//     *  formulation of the fracInt function group. Other
+//     *  functions are not affected.
+//     *  Starts with only the first coefficient at x^0 */
+//    ///Helper function to calculate the D vector:
+//    double factorial(double nValue);
+//    double binom(double nValue, double nValue2);
+//    std::vector<double> fracIntCentralDvector(int m, double x, double xbase);
+//    ///Indefinite integral of a centred polynomial divided by its independent variable
+//    double fracIntCentral(const std::vector<double> &coefficients, double x, double xbase);
+//
+//    /// Horner function generator implementations
+//    /** Represent polynomials according to Horner's scheme.
+//     *  This avoids unnecessary multiplication and thus
+//     *  speeds up calculation.
+//     */
+//    double baseHorner(const std::vector<double> &coefficients, double x);
+//    double baseHorner(const std::vector< std::vector<double> > &coefficients, double x, double y);
+//    ///Indefinite integral in x-direction
+//    double baseHornerInt(const std::vector<double> &coefficients, double x);
+//    ///Indefinite integral in y-direction only
+//    double baseHornerInt(const std::vector<std::vector<double> > &coefficients, double x, double y);
+//    ///Indefinite integral of a polynomial divided by its independent variable
+//    double baseHornerFracInt(const std::vector<double> &coefficients, double x);
+//    ///Indefinite integral of a polynomial divided by its 2nd independent variable
+//    double baseHornerFracInt(const std::vector<std::vector<double> > &coefficients, double x, double y);
+//
+//    /** Alternatives
+//     *  Simple functions that heavily rely on other parts of this file.
+//     *  We still need to check which combinations yield the best
+//     *  performance.
+//     */
+//    ///Derivative in x-direction
+//    double deriveIn2Steps(const std::vector<double> &coefficients, double x); // TODO: Check results!
+//    ///Derivative in terms of x(axis=true) or y(axis=false).
+//    double deriveIn2Steps(const std::vector< std::vector<double> > &coefficients, double x, double y, bool axis); // TODO: Check results!
+//    ///Indefinite integral in x-direction
+//    double integrateIn2Steps(const std::vector<double> &coefficients, double x);
+//    ///Indefinite integral in terms of x(axis=true) or y(axis=false).
+//    double integrateIn2Steps(const std::vector< std::vector<double> > &coefficients, double x, double y, bool axis);
+//    ///Indefinite integral in x-direction of a polynomial divided by its independent variable
+//    double fracIntIn2Steps(const std::vector<double> &coefficients, double x);
+//    ///Indefinite integral in y-direction of a polynomial divided by its 2nd independent variable
+//    double fracIntIn2Steps(const std::vector<std::vector<double> > &coefficients, double x, double y);
+//    ///Indefinite integral of a centred polynomial divided by its 2nd independent variable
+//    double fracIntCentral2Steps(const std::vector<std::vector<double> > &coefficients, double x, double y, double ybase);
+//
+//public:
+//    /** Here we define the functions that should be used by the
+//     *  respective implementations. Please do no use any other
+//     *  method since this would break the purpose of this interface.
+//     *  Note that the functions below are supposed to be aliases
+//     *  to implementations declared elsewhere in this file.
+//     */
+//
+//    /** Everything related to the normal polynomials goes in this
+//     *  section, holds all the functions for evaluating polynomials.
+//     */
+//    /// Evaluates a one-dimensional polynomial for the given coefficients
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current input
+//    virtual inline double polyval(const std::vector<double> &coefficients, double x){
+//        return baseHorner(coefficients,x);
+//    }
+//
+//    /// Evaluates a two-dimensional polynomial for the given coefficients
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current input in the 1st dimension
+//    /// @param y double value that represents the current input in the 2nd dimension
+//    virtual inline double polyval(const std::vector< std::vector<double> > &coefficients, double x, double y){
+//        return baseHorner(coefficients,x,y);
+//    }
+//
+//
+//    /** Everything related to the integrated polynomials goes in this
+//     *  section, holds all the functions for evaluating polynomials.
+//     */
+//    /// Evaluates the indefinite integral of a one-dimensional polynomial
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current input
+//    virtual inline double polyint(const std::vector<double> &coefficients, double x){
+//        return baseHornerInt(coefficients,x);
+//    }
+//
+//    /// Evaluates the indefinite integral of a two-dimensional polynomial along the 2nd axis (y)
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current input in the 1st dimension
+//    /// @param y double value that represents the current input in the 2nd dimension
+//    virtual inline double polyint(const std::vector< std::vector<double> > &coefficients, double x, double y){
+//        return baseHornerInt(coefficients,x,y);
+//    }
+//
+//
+//    /** Everything related to the derived polynomials goes in this
+//     *  section, holds all the functions for evaluating polynomials.
+//     */
+//    /// Evaluates the derivative of a one-dimensional polynomial
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current input
+//    virtual inline double polyder(const std::vector<double> &coefficients, double x){
+//        return deriveIn2Steps(coefficients,x);
+//    }
+//
+//    /// Evaluates the derivative of a two-dimensional polynomial along the 2nd axis (y)
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current input in the 1st dimension
+//    /// @param y double value that represents the current input in the 2nd dimension
+//    virtual inline double polyder(const std::vector< std::vector<double> > &coefficients, double x, double y){
+//        return deriveIn2Steps(coefficients,x,y,false);
+//    }
+//
+//
+//    /** Everything related to the polynomials divided by one variable goes in this
+//     *  section, holds all the functions for evaluating polynomials.
+//     */
+//    /// Evaluates the indefinite integral of a one-dimensional polynomial divided by its independent variable
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current position
+//    virtual inline double polyfracval(const std::vector<double> &coefficients, double x){
+//        return baseHorner(coefficients,x)/x;
+//    }
+//
+//    /// Evaluates the indefinite integral of a two-dimensional polynomial divided by its 2nd independent variable
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current input in the 1st dimension
+//    /// @param y double value that represents the current input in the 2nd dimension
+//    virtual inline double polyfracval(const std::vector< std::vector<double> > &coefficients, double x, double y){
+//        return baseHorner(coefficients,x,y)/y;
+//    }
+//
+//
+//    /** Everything related to the integrated polynomials divided by one variable goes in this
+//     *  section, holds all the functions for solving polynomials.
+//     */
+//    /// Evaluates the indefinite integral of a one-dimensional polynomial divided by its independent variable
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current position
+//    virtual inline double polyfracint(const std::vector<double> &coefficients, double x){
+//        return baseHornerFracInt(coefficients,x);
+//    }
+//
+//    /// Evaluates the indefinite integral of a two-dimensional polynomial divided by its 2nd independent variable
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current input in the 1st dimension
+//    /// @param y double value that represents the current input in the 2nd dimension
+//    virtual inline double polyfracint(const std::vector< std::vector<double> > &coefficients, double x, double y){
+//        return baseHornerFracInt(coefficients,x,y);
+//    }
+//
+//    /// Evaluates the indefinite integral of a centred one-dimensional polynomial divided by its independent variable
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current position
+//    /// @param xbase central temperature for fitted function
+//    virtual inline double polyfracintcentral(const std::vector<double> &coefficients, double x, double xbase){
+//        return fracIntCentral(coefficients,x,xbase);
+//    }
+//
+//    /// Evaluates the indefinite integral of a centred two-dimensional polynomial divided by its 2nd independent variable
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current input in the 1st dimension
+//    /// @param y double value that represents the current input in the 2nd dimension
+//    /// @param ybase central temperature for fitted function
+//    virtual inline double polyfracintcentral(const std::vector< std::vector<double> > &coefficients, double x, double y, double ybase){
+//        return fracIntCentral2Steps(coefficients,x,y,ybase);
+//    }
+//
+//
+//    /** Everything related to the derived polynomials divided by one variable goes in this
+//     *  section, holds all the functions for solving polynomials.
+//     */
+//    /// Evaluates the derivative of a one-dimensional polynomial divided by its independent variable
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current position
+//    virtual inline double polyfracder(const std::vector<double> &coefficients, double x){
+//        throw CoolProp::NotImplementedError("Derivatives of polynomials divided by their independent variable have not been implemented."); // TODO: Implement polyfracder1D
+//    }
+//
+//    /// Evaluates the derivative of a two-dimensional polynomial divided by its 2nd independent variable
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current input in the 1st dimension
+//    /// @param y double value that represents the current input in the 2nd dimension
+//    virtual inline double polyfracder(const std::vector< std::vector<double> > &coefficients, double x, double y){
+//        throw CoolProp::NotImplementedError("Derivatives of polynomials divided by their independent variable have not been implemented."); // TODO: Implement polyfracder2D
+//    }
+//
+//    /// Evaluates the derivative of a centred one-dimensional polynomial divided by its independent variable
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current position
+//    /// @param xbase central temperature for fitted function
+//    virtual inline double polyfracdercentral(const std::vector<double> &coefficients, double x, double xbase){
+//        throw CoolProp::NotImplementedError("Derivatives of polynomials divided by their independent variable have not been implemented."); // TODO: Implement polyfracdercentral1D
+//    }
+//
+//    /// Evaluates the derivative of a centred two-dimensional polynomial divided by its 2nd independent variable
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current input in the 1st dimension
+//    /// @param y double value that represents the current input in the 2nd dimension
+//    /// @param ybase central temperature for fitted function
+//    virtual inline double polyfracdercentral(const std::vector< std::vector<double> > &coefficients, double x, double y, double ybase){
+//        throw CoolProp::NotImplementedError("Derivatives of polynomials divided by their independent variable have not been implemented."); // TODO: Implement polyfracdercentral2D
+//    }
+//};
+//
+//
+//
+//
+///** Implements the function wrapper interface and can be
+// *  used by the solvers.
+// *  TODO: Make multidimensional
+// */
+//class PolyResidual : public FuncWrapper1D {
+//protected:
+//    enum dims {i1D, i2D};
+//    /// Object that evaluates the equation
+//    BasePolynomial poly;
+//    /// Current output value
+//    double output, firstDim;
+//    int dim;
+//    std::vector< std::vector<double> > coefficients;
+//private:
+//    PolyResidual();
+//public:
+//    PolyResidual(const std::vector<double> &coefficients, double y);
+//    PolyResidual(const std::vector< std::vector<double> > &coefficients, double x, double z);
+//    virtual ~PolyResidual(){};
+//    bool is2D(){return (this->dim==i2D);};
+//    virtual double call(double x);
+//    virtual double deriv(double x);
+//};
+//class PolyIntResidual : public PolyResidual {
+//public:
+//    PolyIntResidual(const std::vector<double> &coefficients, double y):PolyResidual(coefficients, y){};
+//    PolyIntResidual(const std::vector< std::vector<double> > &coefficients, double x, double z):PolyResidual(coefficients, x, z){};
+//    virtual double call(double x);
+//    virtual double deriv(double x);
+//};
+//class PolyFracIntResidual : public PolyResidual {
+//public:
+//    PolyFracIntResidual(const std::vector<double> &coefficients, double y):PolyResidual(coefficients, y){};
+//    PolyFracIntResidual(const std::vector< std::vector<double> > &coefficients, double x, double z):PolyResidual(coefficients, x, z){};
+//    virtual double call(double x);
+//    virtual double deriv(double x);
+//};
+//class PolyFracIntCentralResidual : public PolyResidual {
+//protected:
+//    double baseVal;
+//public:
+//    PolyFracIntCentralResidual(const std::vector<double> &coefficients, double y, double xBase):PolyResidual(coefficients, y){this->baseVal = xBase;};
+//    PolyFracIntCentralResidual(const std::vector< std::vector<double> > &coefficients, double x, double z, double yBase): PolyResidual(coefficients, x, z){this->baseVal = yBase;};
+//    virtual double call(double x);
+//    virtual double deriv(double x);
+//};
+//class PolyDerResidual : public PolyResidual {
+//public:
+//    PolyDerResidual(const std::vector<double> &coefficients, double y):PolyResidual(coefficients, y){};
+//    PolyDerResidual(const std::vector< std::vector<double> > &coefficients, double x, double z):PolyResidual(coefficients, x, z){};
+//    virtual double call(double x);
+//    virtual double deriv(double x);
+//};
+//
+//
+//
+//
+///** Implements the same public functions as the
+// *  but solves the polynomial for the given value
+// *  instead of evaluating it.
+// *  TODO: This class does not check for bijective
+// *        polynomials and is therefore a little
+// *        fragile.
+// */
+//class PolynomialSolver : public BasePolynomial{
+//private:
+//    enum solvers {iNewton, iBrent};
+//    int uses;
+//    double guess, min, max;
+//    double macheps, tol;
+//    int maxiter;
+//
+//public:
+//    // Constructor
+//    PolynomialSolver();
+//    // Destructor.  No implementation
+//    virtual ~PolynomialSolver(){};
+//
+//public:
+//    /** Here we redefine the functions that solve the polynomials.
+//     *  These implementations all use the base class to evaluate
+//     *  the polynomial during the solution process.
+//     */
+//
+//    /** Everything related to the normal polynomials goes in this
+//     *  section, holds all the functions for solving polynomials.
+//     */
+//    /// Solves a one-dimensional polynomial for the given coefficients
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param y double value that represents the current input
+//    virtual double polyval(const std::vector<double> &coefficients, double y);
+//
+//    /// Solves a two-dimensional polynomial for the given coefficients
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current input in the 1st dimension
+//    /// @param z double value that represents the current output
+//    virtual double polyval(const std::vector< std::vector<double> > &coefficients, double x, double z);
+//
+//
+//    /** Everything related to the integrated polynomials goes in this
+//     *  section, holds all the functions for solving polynomials.
+//     */
+//    /// Solves the indefinite integral of a one-dimensional polynomial
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param y double value that represents the current output
+//    virtual double polyint(const std::vector<double> &coefficients, double y);
+//
+//    /// Solves the indefinite integral of a two-dimensional polynomial along the 2nd axis (y)
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current input in the 1st dimension
+//    /// @param z double value that represents the current output
+//    virtual double polyint(const std::vector< std::vector<double> > &coefficients, double x, double z);
+//
+//
+//    /** Everything related to the derived polynomials goes in this
+//     *  section, holds all the functions for solving polynomials.
+//     */
+//    /// Solves the derivative of a one-dimensional polynomial
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param y double value that represents the current output
+//    virtual double polyder(const std::vector<double> &coefficients, double y);
+//
+//    /// Solves the derivative of a two-dimensional polynomial along the 2nd axis (y)
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current input in the 1st dimension
+//    /// @param z double value that represents the current output
+//    virtual double polyder(const std::vector< std::vector<double> > &coefficients, double x, double z);
+//
+//
+//    /** Everything related to the polynomials divided by one variable goes in this
+//     *  section, holds all the functions for solving polynomials.
+//     */
+//    /// Solves the indefinite integral of a one-dimensional polynomial divided by its independent variable
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param y double value that represents the current output
+//    virtual double polyfracval(const std::vector<double> &coefficients, double y);
+//
+//    /// Solves the indefinite integral of a two-dimensional polynomial divided by its 2nd independent variable
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current input in the 1st dimension
+//    /// @param z double value that represents the current output
+//    virtual double polyfracval(const std::vector< std::vector<double> > &coefficients, double x, double z);
+//
+//
+//    /** Everything related to the integrated polynomials divided by one variable goes in this
+//     *  section, holds all the functions for solving polynomials.
+//     */
+//    /// Solves the indefinite integral of a one-dimensional polynomial divided by its independent variable
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param y double value that represents the current output
+//    virtual double polyfracint(const std::vector<double> &coefficients, double y);
+//
+//    /// Solves the indefinite integral of a two-dimensional polynomial divided by its 2nd independent variable
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current input in the 1st dimension
+//    /// @param z double value that represents the current output
+//    virtual double polyfracint(const std::vector< std::vector<double> > &coefficients, double x, double z);
+//
+//    /// Solves the indefinite integral of a centred one-dimensional polynomial divided by its independent variable
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param y double value that represents the current output
+//    /// @param xbase central x-value for fitted function
+//    virtual double polyfracintcentral(const std::vector<double> &coefficients, double y, double xbase);
+//
+//    /// Solves the indefinite integral of a centred two-dimensional polynomial divided by its 2nd independent variable
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current input in the 1st dimension
+//    /// @param z double value that represents the current output
+//    /// @param ybase central y-value for fitted function
+//    virtual double polyfracintcentral(const std::vector< std::vector<double> > &coefficients, double x, double z, double ybase);
+//
+//
+//    /** Everything related to the derived polynomials divided by one variable goes in this
+//     *  section, holds all the functions for solving polynomials.
+//     */
+//    /// Solves the derivative of a one-dimensional polynomial divided by its independent variable
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param y double value that represents the current output
+//    virtual double polyfracder(const std::vector<double> &coefficients, double y);
+//
+//    /// Solves the derivative of a two-dimensional polynomial divided by its 2nd independent variable
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current input in the 1st dimension
+//    /// @param z double value that represents the current output
+//    virtual double polyfracder(const std::vector< std::vector<double> > &coefficients, double x, double z);
+//
+//    /// Solves the derivative of a centred one-dimensional polynomial divided by its independent variable
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param y double value that represents the current output
+//    /// @param xbase central x-value for fitted function
+//    virtual double polyfracdercentral(const std::vector<double> &coefficients, double y, double xbase);
+//
+//    /// Solves the derivative of a centred two-dimensional polynomial divided by its 2nd independent variable
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current input in the 1st dimension
+//    /// @param z double value that represents the current output
+//    /// @param ybase central y-value for fitted function
+//    virtual double polyfracdercentral(const std::vector< std::vector<double> > &coefficients, double x, double z, double ybase);
+//
+//
+//    /** Set the solvers and updates either the guess values or the
+//     *  boundaries for the variable to solve for.
+//     */
+//    /// Sets the guess value for the Newton solver and enables it.
+//    /// @param guess double value that represents the guess value
+//    virtual void setGuess(double guess);
+//    /// Sets the limits for the Brent solver and enables it.
+//    /// @param min double value that represents the lower boundary
+//    /// @param max double value that represents the upper boundary
+//    virtual void setLimits(double min, double max);
+//    /// Solves the equations based on previously defined parameters.
+//    /// @param min double value that represents the lower boundary
+//    /// @param max double value that represents the upper boundary
+//    virtual double solve(PolyResidual &res);
+//};
+//
+//
+///// The base class for exponential functions
+//class BaseExponential{
+//
+//protected:
+//    BasePolynomial poly;
+//    bool POLYMATH_DEBUG;
+//
+//public:
+//    BaseExponential();
+//    virtual ~BaseExponential(){};
+//
+//public:
+//    /// Evaluates an exponential function for the given coefficients
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current input
+//    /// @param n int value that determines the kind of exponential function
+//    double expval(const std::vector<double> &coefficients, double x, int n);
+//
+//    /// Evaluates an exponential function for the given coefficients
+//    /// @param coefficients vector containing the ordered coefficients
+//    /// @param x double value that represents the current input in the 1st dimension
+//    /// @param y double value that represents the current input in the 2nd dimension
+//    /// @param n int value that determines the kind of exponential function
+//    double expval(const std::vector< std::vector<double> > &coefficients, double x, double y, int n);
+//};
+
+}; /* namespace CoolProp */
+#endif
```

## CoolProp/include/Solvers.h

 * *Ordering differences only*

```diff
@@ -1,109 +1,109 @@
-#ifndef SOLVERS_H
-#define SOLVERS_H
-
-#include <vector>
-#include <string>
-#include "Exceptions.h"
-#include "CoolPropTools.h"
-
-namespace CoolProp {
-
-// *****************************************************************************
-// *****************************************************************************
-//                              SOLVER WRAPPER CLASSES
-// *****************************************************************************
-// *****************************************************************************
-
-class FuncWrapper1D
-{
-   public:
-    int errcode;
-    std::string errstring;
-    Dictionary options;
-    int iter;
-    FuncWrapper1D() : errcode(0), errstring(""){};
-    virtual ~FuncWrapper1D(){};
-    virtual double call(double) = 0;
-    /**
-     * /brief A function for checking whether the input is in range;
-     *
-     * Meant to be implemented by derived classes; return true if input is out of range
-     */
-    virtual bool input_not_in_range(double x) {
-        return false;
-    };
-};
-
-class FuncWrapper1DWithDeriv : public FuncWrapper1D
-{
-   public:
-    virtual double deriv(double) = 0;
-};
-
-class FuncWrapper1DWithTwoDerivs : public FuncWrapper1DWithDeriv
-{
-   public:
-    virtual double second_deriv(double) = 0;
-};
-
-class FuncWrapper1DWithThreeDerivs : public FuncWrapper1DWithTwoDerivs
-{
-   public:
-    virtual double third_deriv(double) = 0;
-};
-
-class FuncWrapperND
-{
-   public:
-    int errcode;
-    std::string errstring;
-    FuncWrapperND() : errcode(0), errstring(""){};
-    virtual ~FuncWrapperND(){};
-    virtual std::vector<double> call(const std::vector<double>&) = 0;  // must be provided
-    virtual std::vector<std::vector<double>> Jacobian(const std::vector<double>&);
-};
-
-// *****************************************************************************
-// *****************************************************************************
-//                              SOLVER ROUTINES
-// *****************************************************************************
-// *****************************************************************************
-
-// Single-Dimensional solvers, pointer versions
-double Brent(FuncWrapper1D* f, double a, double b, double macheps, double t, int maxiter);
-double Secant(FuncWrapper1D* f, double x0, double dx, double ftol, int maxiter);
-double BoundedSecant(FuncWrapper1D* f, double x0, double xmin, double xmax, double dx, double ftol, int maxiter);
-double ExtrapolatingSecant(FuncWrapper1D* f, double x0, double dx, double ftol, int maxiter);
-double Newton(FuncWrapper1DWithDeriv* f, double x0, double ftol, int maxiter);
-double Halley(FuncWrapper1DWithTwoDerivs* f, double x0, double ftol, int maxiter, double xtol_rel = 1e-12);
-double Householder4(FuncWrapper1DWithThreeDerivs* f, double x0, double ftol, int maxiter, double xtol_rel = 1e-12);
-
-// Single-Dimensional solvers, refere
-inline double Brent(FuncWrapper1D& f, double a, double b, double macheps, double t, int maxiter) {
-    return Brent(&f, a, b, macheps, t, maxiter);
-}
-inline double Secant(FuncWrapper1D& f, double x0, double dx, double ftol, int maxiter) {
-    return Secant(&f, x0, dx, ftol, maxiter);
-}
-
-inline double ExtrapolatingSecant(FuncWrapper1D& f, double x0, double dx, double ftol, int maxiter){
-    return ExtrapolatingSecant(&f, x0, dx, ftol, maxiter);
-}
-inline double BoundedSecant(FuncWrapper1D& f, double x0, double xmin, double xmax, double dx, double ftol, int maxiter){
-    return BoundedSecant(&f, x0, xmin, xmax, dx, ftol, maxiter);
-}
-inline double Newton(FuncWrapper1DWithDeriv& f, double x0, double ftol, int maxiter) {
-    return Newton(&f, x0, ftol, maxiter);
-}
-inline double Halley(FuncWrapper1DWithTwoDerivs& f, double x0, double ftol, int maxiter, double xtol_rel = 1e-12) {
-    return Halley(&f, x0, ftol, maxiter, xtol_rel);
-}
-inline double Householder4(FuncWrapper1DWithThreeDerivs& f, double x0, double ftol, int maxiter, double xtol_rel = 1e-12) {
-    return Householder4(&f, x0, ftol, maxiter, xtol_rel);
-}
-
-// Multi-Dimensional solvers
-std::vector<double> NDNewtonRaphson_Jacobian(FuncWrapperND* f, const std::vector<double>& x0, double tol, int maxiter, double w = 1.0);
-
-}; /*namespace CoolProp*/
-#endif
+#ifndef SOLVERS_H
+#define SOLVERS_H
+
+#include <vector>
+#include <string>
+#include "Exceptions.h"
+#include "CoolPropTools.h"
+
+namespace CoolProp {
+
+// *****************************************************************************
+// *****************************************************************************
+//                              SOLVER WRAPPER CLASSES
+// *****************************************************************************
+// *****************************************************************************
+
+class FuncWrapper1D
+{
+   public:
+    int errcode;
+    std::string errstring;
+    Dictionary options;
+    int iter;
+    FuncWrapper1D() : errcode(0), errstring(""){};
+    virtual ~FuncWrapper1D(){};
+    virtual double call(double) = 0;
+    /**
+     * /brief A function for checking whether the input is in range;
+     *
+     * Meant to be implemented by derived classes; return true if input is out of range
+     */
+    virtual bool input_not_in_range(double x) {
+        return false;
+    };
+};
+
+class FuncWrapper1DWithDeriv : public FuncWrapper1D
+{
+   public:
+    virtual double deriv(double) = 0;
+};
+
+class FuncWrapper1DWithTwoDerivs : public FuncWrapper1DWithDeriv
+{
+   public:
+    virtual double second_deriv(double) = 0;
+};
+
+class FuncWrapper1DWithThreeDerivs : public FuncWrapper1DWithTwoDerivs
+{
+   public:
+    virtual double third_deriv(double) = 0;
+};
+
+class FuncWrapperND
+{
+   public:
+    int errcode;
+    std::string errstring;
+    FuncWrapperND() : errcode(0), errstring(""){};
+    virtual ~FuncWrapperND(){};
+    virtual std::vector<double> call(const std::vector<double>&) = 0;  // must be provided
+    virtual std::vector<std::vector<double>> Jacobian(const std::vector<double>&);
+};
+
+// *****************************************************************************
+// *****************************************************************************
+//                              SOLVER ROUTINES
+// *****************************************************************************
+// *****************************************************************************
+
+// Single-Dimensional solvers, pointer versions
+double Brent(FuncWrapper1D* f, double a, double b, double macheps, double t, int maxiter);
+double Secant(FuncWrapper1D* f, double x0, double dx, double ftol, int maxiter);
+double BoundedSecant(FuncWrapper1D* f, double x0, double xmin, double xmax, double dx, double ftol, int maxiter);
+double ExtrapolatingSecant(FuncWrapper1D* f, double x0, double dx, double ftol, int maxiter);
+double Newton(FuncWrapper1DWithDeriv* f, double x0, double ftol, int maxiter);
+double Halley(FuncWrapper1DWithTwoDerivs* f, double x0, double ftol, int maxiter, double xtol_rel = 1e-12);
+double Householder4(FuncWrapper1DWithThreeDerivs* f, double x0, double ftol, int maxiter, double xtol_rel = 1e-12);
+
+// Single-Dimensional solvers, refere
+inline double Brent(FuncWrapper1D& f, double a, double b, double macheps, double t, int maxiter) {
+    return Brent(&f, a, b, macheps, t, maxiter);
+}
+inline double Secant(FuncWrapper1D& f, double x0, double dx, double ftol, int maxiter) {
+    return Secant(&f, x0, dx, ftol, maxiter);
+}
+
+inline double ExtrapolatingSecant(FuncWrapper1D& f, double x0, double dx, double ftol, int maxiter){
+    return ExtrapolatingSecant(&f, x0, dx, ftol, maxiter);
+}
+inline double BoundedSecant(FuncWrapper1D& f, double x0, double xmin, double xmax, double dx, double ftol, int maxiter){
+    return BoundedSecant(&f, x0, xmin, xmax, dx, ftol, maxiter);
+}
+inline double Newton(FuncWrapper1DWithDeriv& f, double x0, double ftol, int maxiter) {
+    return Newton(&f, x0, ftol, maxiter);
+}
+inline double Halley(FuncWrapper1DWithTwoDerivs& f, double x0, double ftol, int maxiter, double xtol_rel = 1e-12) {
+    return Halley(&f, x0, ftol, maxiter, xtol_rel);
+}
+inline double Householder4(FuncWrapper1DWithThreeDerivs& f, double x0, double ftol, int maxiter, double xtol_rel = 1e-12) {
+    return Householder4(&f, x0, ftol, maxiter, xtol_rel);
+}
+
+// Multi-Dimensional solvers
+std::vector<double> NDNewtonRaphson_Jacobian(FuncWrapperND* f, const std::vector<double>& x0, double tol, int maxiter, double w = 1.0);
+
+}; /*namespace CoolProp*/
+#endif
```

## CoolProp/include/SpeedTest.h

 * *Ordering differences only*

```diff
@@ -1,12 +1,12 @@
-#ifndef SPEEDTEST_H
-#define SPEEDTEST_H
-
-#include <string>
-
-namespace CoolProp {
-
-void compare_REFPROP_and_CoolProp(const std::string& fluid, int inputs, double val1, double val2, std::size_t N, double d1 = 0, double d2 = 0);
-
-} /* namespace CoolProp */
-
+#ifndef SPEEDTEST_H
+#define SPEEDTEST_H
+
+#include <string>
+
+namespace CoolProp {
+
+void compare_REFPROP_and_CoolProp(const std::string& fluid, int inputs, double val1, double val2, std::size_t N, double d1 = 0, double d2 = 0);
+
+} /* namespace CoolProp */
+
 #endif
```

## CoolProp/include/TestObjects.h

 * *Ordering differences only*

```diff
@@ -1,20 +1,20 @@
-/**
- *  This file contains some basic methods to generate
- *  objects that can be used in the test routines.
- *  This makes the tests themselves much more readable
- *  and assures that the objects used for testing are the
- *  same in all places.
- */
-#include "IncompressibleFluid.h"
-#include "Eigen/Core"
-#include "MatrixMath.h"
-
-#if defined ENABLE_CATCH
-namespace CoolPropTesting {
-
-Eigen::MatrixXd makeMatrix(const std::vector<double>& coefficients);
-//CoolProp::IncompressibleFluid incompressibleFluidObject();
-//IncompressibleBackend incompressibleBackendObject();
-
-}  // namespace CoolPropTesting
-#endif  // ENABLE_CATCH
+/**
+ *  This file contains some basic methods to generate
+ *  objects that can be used in the test routines.
+ *  This makes the tests themselves much more readable
+ *  and assures that the objects used for testing are the
+ *  same in all places.
+ */
+#include "IncompressibleFluid.h"
+#include "Eigen/Core"
+#include "MatrixMath.h"
+
+#if defined ENABLE_CATCH
+namespace CoolPropTesting {
+
+Eigen::MatrixXd makeMatrix(const std::vector<double>& coefficients);
+//CoolProp::IncompressibleFluid incompressibleFluidObject();
+//IncompressibleBackend incompressibleBackendObject();
+
+}  // namespace CoolPropTesting
+#endif  // ENABLE_CATCH
```

## CoolProp/include/Tests.h

 * *Ordering differences only*

```diff
@@ -1,12 +1,12 @@
-#ifndef TESTS_H
-#define TESTS_H
-
-#include <vector>
-#include <string>
-
-void run_tests();
-int run_fast_tests();
-int run_not_slow_tests();
-int run_user_defined_tests(const std::vector<std::string>& tests_or_tags);
-
+#ifndef TESTS_H
+#define TESTS_H
+
+#include <vector>
+#include <string>
+
+void run_tests();
+int run_fast_tests();
+int run_not_slow_tests();
+int run_user_defined_tests(const std::vector<std::string>& tests_or_tags);
+
 #endif
```

## CoolProp/include/cpversion.h

```diff
@@ -1,3 +1,3 @@
-//Generated by the generate_headers.py script on 2022-12-16 13:22:40.925374
-
-static char version [] ="6.4.3";
+//Generated by the generate_headers.py script on 2023-08-06 20:37:23.656377
+
+static char version [] ="6.5.0";
```

## CoolProp/include/crossplatform_shared_ptr.h

 * *Ordering differences only*

```diff
@@ -1,21 +1,21 @@
-#ifndef CROSSPLATFORM_SHARED_PTR
-#define CROSSPLATFORM_SHARED_PTR
-
-// By default, we use shared_ptr from the std namespace, and include the memory header,
-// but some compilers need different treatment. Cmake provides the tools to
-// ensure that the correct header is identified as a compile-time check, and we use
-// that capability to change the include and/or the namespace
-
-#if defined(SHARED_PTR_TR1_MEMORY_HEADER)
-#    include <tr1/memory>
-#else
-#    include <memory>
-#endif
-
-#if defined(SHARED_PTR_TR1_NAMESPACE)
-using std::tr1::shared_ptr;
-#else
-using std::shared_ptr;
-#endif
-
+#ifndef CROSSPLATFORM_SHARED_PTR
+#define CROSSPLATFORM_SHARED_PTR
+
+// By default, we use shared_ptr from the std namespace, and include the memory header,
+// but some compilers need different treatment. Cmake provides the tools to
+// ensure that the correct header is identified as a compile-time check, and we use
+// that capability to change the include and/or the namespace
+
+#if defined(SHARED_PTR_TR1_MEMORY_HEADER)
+#    include <tr1/memory>
+#else
+#    include <memory>
+#endif
+
+#if defined(SHARED_PTR_TR1_NAMESPACE)
+using std::tr1::shared_ptr;
+#else
+using std::shared_ptr;
+#endif
+
 #endif
```

## CoolProp/include/gitrevision.h

```diff
@@ -1,3 +1,3 @@
-//Generated by the generate_headers.py script on 2022-12-16 13:22:41.003502
-
-std::string gitrevision = "84897ce7a110a70ba2229e7a1f5d17ea03efd068";
+//Generated by the generate_headers.py script on 2023-08-06 20:37:23.939476
+
+std::string gitrevision = "d3e15b10e153a960107e7749bf319046ad97aea4";
```

## CoolProp/include/miniz.h

 * *Ordering differences only*

```diff
@@ -1,5294 +1,5294 @@
-/* miniz.c v1.15 - public domain deflate/inflate, zlib-subset, ZIP reading/writing/appending, PNG writing
-   See "unlicense" statement at the end of this file.
-   Rich Geldreich <richgel99@gmail.com>, last updated Oct. 13, 2013
-   Implements RFC 1950: http://www.ietf.org/rfc/rfc1950.txt and RFC 1951: http://www.ietf.org/rfc/rfc1951.txt
-
-   Most API's defined in miniz.c are optional. For example, to disable the archive related functions just define
-   MINIZ_NO_ARCHIVE_APIS, or to get rid of all stdio usage define MINIZ_NO_STDIO (see the list below for more macros).
-
-   * Change History
-     10/13/13 v1.15 r4 - Interim bugfix release while I work on the next major release with Zip64 support (almost there!):
-       - Critical fix for the MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY bug (thanks kahmyong.moon@hp.com) which could cause locate files to not find files. This bug
-        would only have occurred in earlier versions if you explicitly used this flag, OR if you used mz_zip_extract_archive_file_to_heap() or mz_zip_add_mem_to_archive_file_in_place()
-        (which used this flag). If you can't switch to v1.15 but want to fix this bug, just remove the uses of this flag from both helper funcs (and of course don't use the flag).
-       - Bugfix in mz_zip_reader_extract_to_mem_no_alloc() from kymoon when pUser_read_buf is not NULL and compressed size is > uncompressed size
-       - Fixing mz_zip_reader_extract_*() funcs so they don't try to extract compressed data from directory entries, to account for weird zipfiles which contain zero-size compressed data on dir entries.
-         Hopefully this fix won't cause any issues on weird zip archives, because it assumes the low 16-bits of zip external attributes are DOS attributes (which I believe they always are in practice).
-       - Fixing mz_zip_reader_is_file_a_directory() so it doesn't check the internal attributes, just the filename and external attributes
-       - mz_zip_reader_init_file() - missing MZ_FCLOSE() call if the seek failed
-       - Added cmake support for Linux builds which builds all the examples, tested with clang v3.3 and gcc v4.6.
-       - Clang fix for tdefl_write_image_to_png_file_in_memory() from toffaletti
-       - Merged MZ_FORCEINLINE fix from hdeanclark
-       - Fix <time.h> include before config #ifdef, thanks emil.brink
-       - Added tdefl_write_image_to_png_file_in_memory_ex(): supports Y flipping (super useful for OpenGL apps), and explicit control over the compression level (so you can
-        set it to 1 for real-time compression).
-       - Merged in some compiler fixes from paulharris's github repro.
-       - Retested this build under Windows (VS 2010, including static analysis), tcc  0.9.26, gcc v4.6 and clang v3.3.
-       - Added example6.c, which dumps an image of the mandelbrot set to a PNG file.
-       - Modified example2 to help test the MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY flag more.
-       - In r3: Bugfix to mz_zip_writer_add_file() found during merge: Fix possible src file fclose() leak if alignment bytes+local header file write faiiled
-       - In r4: Minor bugfix to mz_zip_writer_add_from_zip_reader(): Was pushing the wrong central dir header offset, appears harmless in this release, but it became a problem in the zip64 branch
-     5/20/12 v1.14 - MinGW32/64 GCC 4.6.1 compiler fixes: added MZ_FORCEINLINE, #include <time.h> (thanks fermtect).
-     5/19/12 v1.13 - From jason@cornsyrup.org and kelwert@mtu.edu - Fix mz_crc32() so it doesn't compute the wrong CRC-32's when mz_ulong is 64-bit.
-       - Temporarily/locally slammed in "typedef unsigned long mz_ulong" and re-ran a randomized regression test on ~500k files.
-       - Eliminated a bunch of warnings when compiling with GCC 32-bit/64.
-       - Ran all examples, miniz.c, and tinfl.c through MSVC 2008's /analyze (static analysis) option and fixed all warnings (except for the silly
-        "Use of the comma-operator in a tested expression.." analysis warning, which I purposely use to work around a MSVC compiler warning).
-       - Created 32-bit and 64-bit Codeblocks projects/workspace. Built and tested Linux executables. The codeblocks workspace is compatible with Linux+Win32/x64.
-       - Added miniz_tester solution/project, which is a useful little app derived from LZHAM's tester app that I use as part of the regression test.
-       - Ran miniz.c and tinfl.c through another series of regression testing on ~500,000 files and archives.
-       - Modified example5.c so it purposely disables a bunch of high-level functionality (MINIZ_NO_STDIO, etc.). (Thanks to corysama for the MINIZ_NO_STDIO bug report.)
-       - Fix ftell() usage in examples so they exit with an error on files which are too large (a limitation of the examples, not miniz itself).
-     4/12/12 v1.12 - More comments, added low-level example5.c, fixed a couple minor level_and_flags issues in the archive API's.
-      level_and_flags can now be set to MZ_DEFAULT_COMPRESSION. Thanks to Bruce Dawson <bruced@valvesoftware.com> for the feedback/bug report.
-     5/28/11 v1.11 - Added statement from unlicense.org
-     5/27/11 v1.10 - Substantial compressor optimizations:
-      - Level 1 is now ~4x faster than before. The L1 compressor's throughput now varies between 70-110MB/sec. on a
-      - Core i7 (actual throughput varies depending on the type of data, and x64 vs. x86).
-      - Improved baseline L2-L9 compression perf. Also, greatly improved compression perf. issues on some file types.
-      - Refactored the compression code for better readability and maintainability.
-      - Added level 10 compression level (L10 has slightly better ratio than level 9, but could have a potentially large
-       drop in throughput on some files).
-     5/15/11 v1.09 - Initial stable release.
-
-   * Low-level Deflate/Inflate implementation notes:
-
-     Compression: Use the "tdefl" API's. The compressor supports raw, static, and dynamic blocks, lazy or
-     greedy parsing, match length filtering, RLE-only, and Huffman-only streams. It performs and compresses
-     approximately as well as zlib.
-
-     Decompression: Use the "tinfl" API's. The entire decompressor is implemented as a single function
-     coroutine: see tinfl_decompress(). It supports decompression into a 32KB (or larger power of 2) wrapping buffer, or into a memory
-     block large enough to hold the entire file.
-
-     The low-level tdefl/tinfl API's do not make any use of dynamic memory allocation.
-
-   * zlib-style API notes:
-
-     miniz.c implements a fairly large subset of zlib. There's enough functionality present for it to be a drop-in
-     zlib replacement in many apps:
-        The z_stream struct, optional memory allocation callbacks
-        deflateInit/deflateInit2/deflate/deflateReset/deflateEnd/deflateBound
-        inflateInit/inflateInit2/inflate/inflateEnd
-        compress, compress2, compressBound, uncompress
-        CRC-32, Adler-32 - Using modern, minimal code size, CPU cache friendly routines.
-        Supports raw deflate streams or standard zlib streams with adler-32 checking.
-
-     Limitations:
-      The callback API's are not implemented yet. No support for gzip headers or zlib static dictionaries.
-      I've tried to closely emulate zlib's various flavors of stream flushing and return status codes, but
-      there are no guarantees that miniz.c pulls this off perfectly.
-
-   * PNG writing: See the tdefl_write_image_to_png_file_in_memory() function, originally written by
-     Alex Evans. Supports 1-4 bytes/pixel images.
-
-   * ZIP archive API notes:
-
-     The ZIP archive API's where designed with simplicity and efficiency in mind, with just enough abstraction to
-     get the job done with minimal fuss. There are simple API's to retrieve file information, read files from
-     existing archives, create new archives, append new files to existing archives, or clone archive data from
-     one archive to another. It supports archives located in memory or the heap, on disk (using stdio.h),
-     or you can specify custom file read/write callbacks.
-
-     - Archive reading: Just call this function to read a single file from a disk archive:
-
-      void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name,
-        size_t *pSize, mz_uint zip_flags);
-
-     For more complex cases, use the "mz_zip_reader" functions. Upon opening an archive, the entire central
-     directory is located and read as-is into memory, and subsequent file access only occurs when reading individual files.
-
-     - Archives file scanning: The simple way is to use this function to scan a loaded archive for a specific file:
-
-     int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);
-
-     The locate operation can optionally check file comments too, which (as one example) can be used to identify
-     multiple versions of the same file in an archive. This function uses a simple linear search through the central
-     directory, so it's not very fast.
-
-     Alternately, you can iterate through all the files in an archive (using mz_zip_reader_get_num_files()) and
-     retrieve detailed info on each file by calling mz_zip_reader_file_stat().
-
-     - Archive creation: Use the "mz_zip_writer" functions. The ZIP writer immediately writes compressed file data
-     to disk and builds an exact image of the central directory in memory. The central directory image is written
-     all at once at the end of the archive file when the archive is finalized.
-
-     The archive writer can optionally align each file's local header and file data to any power of 2 alignment,
-     which can be useful when the archive will be read from optical media. Also, the writer supports placing
-     arbitrary data blobs at the very beginning of ZIP archives. Archives written using either feature are still
-     readable by any ZIP tool.
-
-     - Archive appending: The simple way to add a single file to an archive is to call this function:
-
-      mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name,
-        const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);
-
-     The archive will be created if it doesn't already exist, otherwise it'll be appended to.
-     Note the appending is done in-place and is not an atomic operation, so if something goes wrong
-     during the operation it's possible the archive could be left without a central directory (although the local
-     file headers and file data will be fine, so the archive will be recoverable).
-
-     For more complex archive modification scenarios:
-     1. The safest way is to use a mz_zip_reader to read the existing archive, cloning only those bits you want to
-     preserve into a new archive using using the mz_zip_writer_add_from_zip_reader() function (which compiles the
-     compressed file data as-is). When you're done, delete the old archive and rename the newly written archive, and
-     you're done. This is safe but requires a bunch of temporary disk space or heap memory.
-
-     2. Or, you can convert an mz_zip_reader in-place to an mz_zip_writer using mz_zip_writer_init_from_reader(),
-     append new files as needed, then finalize the archive which will write an updated central directory to the
-     original archive. (This is basically what mz_zip_add_mem_to_archive_file_in_place() does.) There's a
-     possibility that the archive's central directory could be lost with this method if anything goes wrong, though.
-
-     - ZIP archive support limitations:
-     No zip64 or spanning support. Extraction functions can only handle unencrypted, stored or deflated files.
-     Requires streams capable of seeking.
-
-   * This is a header file library, like stb_image.c. To get only a header file, either cut and paste the
-     below header, or create miniz.h, #define MINIZ_HEADER_FILE_ONLY, and then include miniz.c from it.
-
-   * Important: For best perf. be sure to customize the below macros for your target platform:
-     #define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1
-     #define MINIZ_LITTLE_ENDIAN 1
-     #define MINIZ_HAS_64BIT_REGISTERS 1
-
-   * On platforms using glibc, Be sure to "#define _LARGEFILE64_SOURCE 1" before including miniz.c to ensure miniz
-     uses the 64-bit variants: fopen64(), stat64(), etc. Otherwise you won't be able to process large files
-     (i.e. 32-bit stat() fails for me on files > 0x7FFFFFFF bytes).
-*/
-
-#ifndef MINIZ_HEADER_INCLUDED
-#    define MINIZ_HEADER_INCLUDED
-
-#    include <stdlib.h>
-
-// Defines to completely disable specific portions of miniz.c:
-// If all macros here are defined the only functionality remaining will be CRC-32, adler-32, tinfl, and tdefl.
-
-// Define MINIZ_NO_STDIO to disable all usage and any functions which rely on stdio for file I/O.
-//#define MINIZ_NO_STDIO
-
-// If MINIZ_NO_TIME is specified then the ZIP archive functions will not be able to get the current time, or
-// get/set file times, and the C run-time funcs that get/set times won't be called.
-// The current downside is the times written to your archives will be from 1979.
-//#define MINIZ_NO_TIME
-
-// Define MINIZ_NO_ARCHIVE_APIS to disable all ZIP archive API's.
-//#define MINIZ_NO_ARCHIVE_APIS
-
-// Define MINIZ_NO_ARCHIVE_APIS to disable all writing related ZIP archive API's.
-//#define MINIZ_NO_ARCHIVE_WRITING_APIS
-
-// Define MINIZ_NO_ZLIB_APIS to remove all ZLIB-style compression/decompression API's.
-//#define MINIZ_NO_ZLIB_APIS
-
-// Define MINIZ_NO_ZLIB_COMPATIBLE_NAME to disable zlib names, to prevent conflicts against stock zlib.
-//#define MINIZ_NO_ZLIB_COMPATIBLE_NAMES
-
-// Define MINIZ_NO_MALLOC to disable all calls to malloc, free, and realloc.
-// Note if MINIZ_NO_MALLOC is defined then the user must always provide custom user alloc/free/realloc
-// callbacks to the zlib and archive API's, and a few stand-alone helper API's which don't provide custom user
-// functions (such as tdefl_compress_mem_to_heap() and tinfl_decompress_mem_to_heap()) won't work.
-//#define MINIZ_NO_MALLOC
-
-#    if defined(__TINYC__) && (defined(__linux) || defined(__linux__))
-// TODO: Work around "error: include file 'sys\utime.h' when compiling with tcc on Linux
-#        define MINIZ_NO_TIME
-#    endif
-
-#    if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_ARCHIVE_APIS)
-#        include <time.h>
-#    endif
-
-#    if defined(_M_IX86) || defined(_M_X64) || defined(__i386__) || defined(__i386) || defined(__i486__) || defined(__i486) || defined(i386) \
-      || defined(__ia64__) || defined(__x86_64__)
-// MINIZ_X86_OR_X64_CPU is only used to help set the below macros.
-#        define MINIZ_X86_OR_X64_CPU 1
-#    endif
-
-#    if (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || MINIZ_X86_OR_X64_CPU
-// Set MINIZ_LITTLE_ENDIAN to 1 if the processor is little endian.
-#        define MINIZ_LITTLE_ENDIAN 1
-#    endif
-
-#    if MINIZ_X86_OR_X64_CPU
-// Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES to 1 on CPU's that permit efficient integer loads and stores from unaligned addresses.
-#        define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1
-#    endif
-
-#    if defined(_M_X64) || defined(_WIN64) || defined(__MINGW64__) || defined(_LP64) || defined(__LP64__) || defined(__ia64__) || defined(__x86_64__)
-// Set MINIZ_HAS_64BIT_REGISTERS to 1 if operations on 64-bit integers are reasonably fast (and don't involve compiler generated calls to helper functions).
-#        define MINIZ_HAS_64BIT_REGISTERS 1
-#    endif
-
-#    ifdef __cplusplus
-extern "C"
-{
-#    endif
-
-    // ------------------- zlib-style API Definitions.
-
-    // For more compatibility with zlib, miniz.c uses unsigned long for some parameters/struct members. Beware: mz_ulong can be either 32 or 64-bits!
-    typedef unsigned long mz_ulong;
-
-    // mz_free() internally uses the MZ_FREE() macro (which by default calls free() unless you've modified the MZ_MALLOC macro) to release a block allocated from the heap.
-    void mz_free(void* p);
-
-#    define MZ_ADLER32_INIT (1)
-    // mz_adler32() returns the initial adler-32 value to use when called with ptr==NULL.
-    mz_ulong mz_adler32(mz_ulong adler, const unsigned char* ptr, size_t buf_len);
-
-#    define MZ_CRC32_INIT (0)
-    // mz_crc32() returns the initial CRC-32 value to use when called with ptr==NULL.
-    mz_ulong mz_crc32(mz_ulong crc, const unsigned char* ptr, size_t buf_len);
-
-    // Compression strategies.
-    enum
-    {
-        MZ_DEFAULT_STRATEGY = 0,
-        MZ_FILTERED = 1,
-        MZ_HUFFMAN_ONLY = 2,
-        MZ_RLE = 3,
-        MZ_FIXED = 4
-    };
-
-// Method
-#    define MZ_DEFLATED 8
-
-#    ifndef MINIZ_NO_ZLIB_APIS
-
-    // Heap allocation callbacks.
-    // Note that mz_alloc_func parameter types purpsosely differ from zlib's: items/size is size_t, not unsigned long.
-    typedef void* (*mz_alloc_func)(void* opaque, size_t items, size_t size);
-    typedef void (*mz_free_func)(void* opaque, void* address);
-    typedef void* (*mz_realloc_func)(void* opaque, void* address, size_t items, size_t size);
-
-#        define MZ_VERSION "9.1.15"
-#        define MZ_VERNUM 0x91F0
-#        define MZ_VER_MAJOR 9
-#        define MZ_VER_MINOR 1
-#        define MZ_VER_REVISION 15
-#        define MZ_VER_SUBREVISION 0
-
-    // Flush values. For typical usage you only need MZ_NO_FLUSH and MZ_FINISH. The other values are for advanced use (refer to the zlib docs).
-    enum
-    {
-        MZ_NO_FLUSH = 0,
-        MZ_PARTIAL_FLUSH = 1,
-        MZ_SYNC_FLUSH = 2,
-        MZ_FULL_FLUSH = 3,
-        MZ_FINISH = 4,
-        MZ_BLOCK = 5
-    };
-
-    // Return status codes. MZ_PARAM_ERROR is non-standard.
-    enum
-    {
-        MZ_OK = 0,
-        MZ_STREAM_END = 1,
-        MZ_NEED_DICT = 2,
-        MZ_ERRNO = -1,
-        MZ_STREAM_ERROR = -2,
-        MZ_DATA_ERROR = -3,
-        MZ_MEM_ERROR = -4,
-        MZ_BUF_ERROR = -5,
-        MZ_VERSION_ERROR = -6,
-        MZ_PARAM_ERROR = -10000
-    };
-
-    // Compression levels: 0-9 are the standard zlib-style levels, 10 is best possible compression (not zlib compatible, and may be very slow), MZ_DEFAULT_COMPRESSION=MZ_DEFAULT_LEVEL.
-    enum
-    {
-        MZ_NO_COMPRESSION = 0,
-        MZ_BEST_SPEED = 1,
-        MZ_BEST_COMPRESSION = 9,
-        MZ_UBER_COMPRESSION = 10,
-        MZ_DEFAULT_LEVEL = 6,
-        MZ_DEFAULT_COMPRESSION = -1
-    };
-
-// Window bits
-#        define MZ_DEFAULT_WINDOW_BITS 15
-
-    struct mz_internal_state;
-
-    // Compression/decompression stream struct.
-    typedef struct mz_stream_s
-    {
-        const unsigned char* next_in;  // pointer to next byte to read
-        unsigned int avail_in;         // number of bytes available at next_in
-        mz_ulong total_in;             // total number of bytes consumed so far
-
-        unsigned char* next_out;  // pointer to next byte to write
-        unsigned int avail_out;   // number of bytes that can be written to next_out
-        mz_ulong total_out;       // total number of bytes produced so far
-
-        char* msg;                        // error msg (unused)
-        struct mz_internal_state* state;  // internal state, allocated by zalloc/zfree
-
-        mz_alloc_func zalloc;  // optional heap allocation function (defaults to malloc)
-        mz_free_func zfree;    // optional heap free function (defaults to free)
-        void* opaque;          // heap alloc function user pointer
-
-        int data_type;      // data_type (unused)
-        mz_ulong adler;     // adler32 of the source or uncompressed data
-        mz_ulong reserved;  // not used
-    } mz_stream;
-
-    typedef mz_stream* mz_streamp;
-
-    // Returns the version string of miniz.c.
-    const char* mz_version(void);
-
-    // mz_deflateInit() initializes a compressor with default options:
-    // Parameters:
-    //  pStream must point to an initialized mz_stream struct.
-    //  level must be between [MZ_NO_COMPRESSION, MZ_BEST_COMPRESSION].
-    //  level 1 enables a specially optimized compression function that's been optimized purely for performance, not ratio.
-    //  (This special func. is currently only enabled when MINIZ_USE_UNALIGNED_LOADS_AND_STORES and MINIZ_LITTLE_ENDIAN are defined.)
-    // Return values:
-    //  MZ_OK on success.
-    //  MZ_STREAM_ERROR if the stream is bogus.
-    //  MZ_PARAM_ERROR if the input parameters are bogus.
-    //  MZ_MEM_ERROR on out of memory.
-    int mz_deflateInit(mz_streamp pStream, int level);
-
-    // mz_deflateInit2() is like mz_deflate(), except with more control:
-    // Additional parameters:
-    //   method must be MZ_DEFLATED
-    //   window_bits must be MZ_DEFAULT_WINDOW_BITS (to wrap the deflate stream with zlib header/adler-32 footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate/no header or footer)
-    //   mem_level must be between [1, 9] (it's checked but ignored by miniz.c)
-    int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy);
-
-    // Quickly resets a compressor without having to reallocate anything. Same as calling mz_deflateEnd() followed by mz_deflateInit()/mz_deflateInit2().
-    int mz_deflateReset(mz_streamp pStream);
-
-    // mz_deflate() compresses the input to output, consuming as much of the input and producing as much output as possible.
-    // Parameters:
-    //   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members.
-    //   flush may be MZ_NO_FLUSH, MZ_PARTIAL_FLUSH/MZ_SYNC_FLUSH, MZ_FULL_FLUSH, or MZ_FINISH.
-    // Return values:
-    //   MZ_OK on success (when flushing, or if more input is needed but not available, and/or there's more output to be written but the output buffer is full).
-    //   MZ_STREAM_END if all input has been consumed and all output bytes have been written. Don't call mz_deflate() on the stream anymore.
-    //   MZ_STREAM_ERROR if the stream is bogus.
-    //   MZ_PARAM_ERROR if one of the parameters is invalid.
-    //   MZ_BUF_ERROR if no forward progress is possible because the input and/or output buffers are empty. (Fill up the input buffer or free up some output space and try again.)
-    int mz_deflate(mz_streamp pStream, int flush);
-
-    // mz_deflateEnd() deinitializes a compressor:
-    // Return values:
-    //  MZ_OK on success.
-    //  MZ_STREAM_ERROR if the stream is bogus.
-    int mz_deflateEnd(mz_streamp pStream);
-
-    // mz_deflateBound() returns a (very) conservative upper bound on the amount of data that could be generated by deflate(), assuming flush is set to only MZ_NO_FLUSH or MZ_FINISH.
-    mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len);
-
-    // Single-call compression functions mz_compress() and mz_compress2():
-    // Returns MZ_OK on success, or one of the error codes from mz_deflate() on failure.
-    int mz_compress(unsigned char* pDest, mz_ulong* pDest_len, const unsigned char* pSource, mz_ulong source_len);
-    int mz_compress2(unsigned char* pDest, mz_ulong* pDest_len, const unsigned char* pSource, mz_ulong source_len, int level);
-
-    // mz_compressBound() returns a (very) conservative upper bound on the amount of data that could be generated by calling mz_compress().
-    mz_ulong mz_compressBound(mz_ulong source_len);
-
-    // Initializes a decompressor.
-    int mz_inflateInit(mz_streamp pStream);
-
-    // mz_inflateInit2() is like mz_inflateInit() with an additional option that controls the window size and whether or not the stream has been wrapped with a zlib header/footer:
-    // window_bits must be MZ_DEFAULT_WINDOW_BITS (to parse zlib header/footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate).
-    int mz_inflateInit2(mz_streamp pStream, int window_bits);
-
-    // Decompresses the input stream to the output, consuming only as much of the input as needed, and writing as much to the output as possible.
-    // Parameters:
-    //   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members.
-    //   flush may be MZ_NO_FLUSH, MZ_SYNC_FLUSH, or MZ_FINISH.
-    //   On the first call, if flush is MZ_FINISH it's assumed the input and output buffers are both sized large enough to decompress the entire stream in a single call (this is slightly faster).
-    //   MZ_FINISH implies that there are no more source bytes available beside what's already in the input buffer, and that the output buffer is large enough to hold the rest of the decompressed data.
-    // Return values:
-    //   MZ_OK on success. Either more input is needed but not available, and/or there's more output to be written but the output buffer is full.
-    //   MZ_STREAM_END if all needed input has been consumed and all output bytes have been written. For zlib streams, the adler-32 of the decompressed data has also been verified.
-    //   MZ_STREAM_ERROR if the stream is bogus.
-    //   MZ_DATA_ERROR if the deflate stream is invalid.
-    //   MZ_PARAM_ERROR if one of the parameters is invalid.
-    //   MZ_BUF_ERROR if no forward progress is possible because the input buffer is empty but the inflater needs more input to continue, or if the output buffer is not large enough. Call mz_inflate() again
-    //   with more input data, or with more room in the output buffer (except when using single call decompression, described above).
-    int mz_inflate(mz_streamp pStream, int flush);
-
-    // Deinitializes a decompressor.
-    int mz_inflateEnd(mz_streamp pStream);
-
-    // Single-call decompression.
-    // Returns MZ_OK on success, or one of the error codes from mz_inflate() on failure.
-    int mz_uncompress(unsigned char* pDest, mz_ulong* pDest_len, const unsigned char* pSource, mz_ulong source_len);
-
-    // Returns a string description of the specified error code, or NULL if the error code is invalid.
-    const char* mz_error(int err);
-
-// Redefine zlib-compatible names to miniz equivalents, so miniz.c can be used as a drop-in replacement for the subset of zlib that miniz.c supports.
-// Define MINIZ_NO_ZLIB_COMPATIBLE_NAMES to disable zlib-compatibility if you use zlib in the same project.
-#        ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES
-    typedef unsigned char Byte;
-    typedef unsigned int uInt;
-    typedef mz_ulong uLong;
-    typedef Byte Bytef;
-    typedef uInt uIntf;
-    typedef char charf;
-    typedef int intf;
-    typedef void* voidpf;
-    typedef uLong uLongf;
-    typedef void* voidp;
-    typedef void* const voidpc;
-#            define Z_NULL 0
-#            define Z_NO_FLUSH MZ_NO_FLUSH
-#            define Z_PARTIAL_FLUSH MZ_PARTIAL_FLUSH
-#            define Z_SYNC_FLUSH MZ_SYNC_FLUSH
-#            define Z_FULL_FLUSH MZ_FULL_FLUSH
-#            define Z_FINISH MZ_FINISH
-#            define Z_BLOCK MZ_BLOCK
-#            define Z_OK MZ_OK
-#            define Z_STREAM_END MZ_STREAM_END
-#            define Z_NEED_DICT MZ_NEED_DICT
-#            define Z_ERRNO MZ_ERRNO
-#            define Z_STREAM_ERROR MZ_STREAM_ERROR
-#            define Z_DATA_ERROR MZ_DATA_ERROR
-#            define Z_MEM_ERROR MZ_MEM_ERROR
-#            define Z_BUF_ERROR MZ_BUF_ERROR
-#            define Z_VERSION_ERROR MZ_VERSION_ERROR
-#            define Z_PARAM_ERROR MZ_PARAM_ERROR
-#            define Z_NO_COMPRESSION MZ_NO_COMPRESSION
-#            define Z_BEST_SPEED MZ_BEST_SPEED
-#            define Z_BEST_COMPRESSION MZ_BEST_COMPRESSION
-#            define Z_DEFAULT_COMPRESSION MZ_DEFAULT_COMPRESSION
-#            define Z_DEFAULT_STRATEGY MZ_DEFAULT_STRATEGY
-#            define Z_FILTERED MZ_FILTERED
-#            define Z_HUFFMAN_ONLY MZ_HUFFMAN_ONLY
-#            define Z_RLE MZ_RLE
-#            define Z_FIXED MZ_FIXED
-#            define Z_DEFLATED MZ_DEFLATED
-#            define Z_DEFAULT_WINDOW_BITS MZ_DEFAULT_WINDOW_BITS
-#            define alloc_func mz_alloc_func
-#            define free_func mz_free_func
-#            define internal_state mz_internal_state
-#            define z_stream mz_stream
-#            define deflateInit mz_deflateInit
-#            define deflateInit2 mz_deflateInit2
-#            define deflateReset mz_deflateReset
-#            define deflate mz_deflate
-#            define deflateEnd mz_deflateEnd
-#            define deflateBound mz_deflateBound
-#            define compress mz_compress
-#            define compress2 mz_compress2
-#            define compressBound mz_compressBound
-#            define inflateInit mz_inflateInit
-#            define inflateInit2 mz_inflateInit2
-#            define inflate mz_inflate
-#            define inflateEnd mz_inflateEnd
-#            define uncompress mz_uncompress
-#            define crc32 mz_crc32
-#            define adler32 mz_adler32
-#            define MAX_WBITS 15
-#            define MAX_MEM_LEVEL 9
-#            define zError mz_error
-#            define ZLIB_VERSION MZ_VERSION
-#            define ZLIB_VERNUM MZ_VERNUM
-#            define ZLIB_VER_MAJOR MZ_VER_MAJOR
-#            define ZLIB_VER_MINOR MZ_VER_MINOR
-#            define ZLIB_VER_REVISION MZ_VER_REVISION
-#            define ZLIB_VER_SUBREVISION MZ_VER_SUBREVISION
-#            define zlibVersion mz_version
-#            define zlib_version mz_version()
-#        endif  // #ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES
-
-#    endif  // MINIZ_NO_ZLIB_APIS
-
-    // ------------------- Types and macros
-
-    typedef unsigned char mz_uint8;
-    typedef signed short mz_int16;
-    typedef unsigned short mz_uint16;
-    typedef unsigned int mz_uint32;
-    typedef unsigned int mz_uint;
-    typedef long long mz_int64;
-    typedef unsigned long long mz_uint64;
-    typedef int mz_bool;
-
-#    define MZ_FALSE (0)
-#    define MZ_TRUE (1)
-
-// An attempt to work around MSVC's spammy "warning C4127: conditional expression is constant" message.
-#    ifdef _MSC_VER
-#        define MZ_MACRO_END while (0, 0)
-#    else
-#        define MZ_MACRO_END while (0)
-#    endif
-
-    // ------------------- ZIP archive reading/writing
-
-#    ifndef MINIZ_NO_ARCHIVE_APIS
-
-    enum
-    {
-        MZ_ZIP_MAX_IO_BUF_SIZE = 64 * 1024,
-        MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE = 260,
-        MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE = 256
-    };
-
-    typedef struct
-    {
-        mz_uint32 m_file_index;
-        mz_uint32 m_central_dir_ofs;
-        mz_uint16 m_version_made_by;
-        mz_uint16 m_version_needed;
-        mz_uint16 m_bit_flag;
-        mz_uint16 m_method;
-#        ifndef MINIZ_NO_TIME
-        time_t m_time;
-#        endif
-        mz_uint32 m_crc32;
-        mz_uint64 m_comp_size;
-        mz_uint64 m_uncomp_size;
-        mz_uint16 m_internal_attr;
-        mz_uint32 m_external_attr;
-        mz_uint64 m_local_header_ofs;
-        mz_uint32 m_comment_size;
-        char m_filename[MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE];
-        char m_comment[MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE];
-    } mz_zip_archive_file_stat;
-
-    typedef size_t (*mz_file_read_func)(void* pOpaque, mz_uint64 file_ofs, void* pBuf, size_t n);
-    typedef size_t (*mz_file_write_func)(void* pOpaque, mz_uint64 file_ofs, const void* pBuf, size_t n);
-
-    struct mz_zip_internal_state_tag;
-    typedef struct mz_zip_internal_state_tag mz_zip_internal_state;
-
-    typedef enum
-    {
-        MZ_ZIP_MODE_INVALID = 0,
-        MZ_ZIP_MODE_READING = 1,
-        MZ_ZIP_MODE_WRITING = 2,
-        MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED = 3
-    } mz_zip_mode;
-
-    typedef struct mz_zip_archive_tag
-    {
-        mz_uint64 m_archive_size;
-        mz_uint64 m_central_directory_file_ofs;
-        mz_uint m_total_files;
-        mz_zip_mode m_zip_mode;
-
-        mz_uint m_file_offset_alignment;
-
-        mz_alloc_func m_pAlloc;
-        mz_free_func m_pFree;
-        mz_realloc_func m_pRealloc;
-        void* m_pAlloc_opaque;
-
-        mz_file_read_func m_pRead;
-        mz_file_write_func m_pWrite;
-        void* m_pIO_opaque;
-
-        mz_zip_internal_state* m_pState;
-
-    } mz_zip_archive;
-
-    typedef enum
-    {
-        MZ_ZIP_FLAG_CASE_SENSITIVE = 0x0100,
-        MZ_ZIP_FLAG_IGNORE_PATH = 0x0200,
-        MZ_ZIP_FLAG_COMPRESSED_DATA = 0x0400,
-        MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY = 0x0800
-    } mz_zip_flags;
-
-    // ZIP archive reading
-
-    // Inits a ZIP archive reader.
-    // These functions read and validate the archive's central directory.
-    mz_bool mz_zip_reader_init(mz_zip_archive* pZip, mz_uint64 size, mz_uint32 flags);
-    mz_bool mz_zip_reader_init_mem(mz_zip_archive* pZip, const void* pMem, size_t size, mz_uint32 flags);
-
-#        ifndef MINIZ_NO_STDIO
-    mz_bool mz_zip_reader_init_file(mz_zip_archive* pZip, const char* pFilename, mz_uint32 flags);
-#        endif
-
-    // Returns the total number of files in the archive.
-    mz_uint mz_zip_reader_get_num_files(mz_zip_archive* pZip);
-
-    // Returns detailed information about an archive file entry.
-    mz_bool mz_zip_reader_file_stat(mz_zip_archive* pZip, mz_uint file_index, mz_zip_archive_file_stat* pStat);
-
-    // Determines if an archive file entry is a directory entry.
-    mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive* pZip, mz_uint file_index);
-    mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive* pZip, mz_uint file_index);
-
-    // Retrieves the filename of an archive file entry.
-    // Returns the number of bytes written to pFilename, or if filename_buf_size is 0 this function returns the number of bytes needed to fully store the filename.
-    mz_uint mz_zip_reader_get_filename(mz_zip_archive* pZip, mz_uint file_index, char* pFilename, mz_uint filename_buf_size);
-
-    // Attempts to locates a file in the archive's central directory.
-    // Valid flags: MZ_ZIP_FLAG_CASE_SENSITIVE, MZ_ZIP_FLAG_IGNORE_PATH
-    // Returns -1 if the file cannot be found.
-    int mz_zip_reader_locate_file(mz_zip_archive* pZip, const char* pName, const char* pComment, mz_uint flags);
-
-    // Extracts a archive file to a memory buffer using no memory allocation.
-    mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive* pZip, mz_uint file_index, void* pBuf, size_t buf_size, mz_uint flags,
-                                                  void* pUser_read_buf, size_t user_read_buf_size);
-    mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive* pZip, const char* pFilename, void* pBuf, size_t buf_size, mz_uint flags,
-                                                       void* pUser_read_buf, size_t user_read_buf_size);
-
-    // Extracts a archive file to a memory buffer.
-    mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive* pZip, mz_uint file_index, void* pBuf, size_t buf_size, mz_uint flags);
-    mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive* pZip, const char* pFilename, void* pBuf, size_t buf_size, mz_uint flags);
-
-    // Extracts a archive file to a dynamically allocated heap buffer.
-    void* mz_zip_reader_extract_to_heap(mz_zip_archive* pZip, mz_uint file_index, size_t* pSize, mz_uint flags);
-    void* mz_zip_reader_extract_file_to_heap(mz_zip_archive* pZip, const char* pFilename, size_t* pSize, mz_uint flags);
-
-    // Extracts a archive file using a callback function to output the file's data.
-    mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive* pZip, mz_uint file_index, mz_file_write_func pCallback, void* pOpaque, mz_uint flags);
-    mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive* pZip, const char* pFilename, mz_file_write_func pCallback, void* pOpaque,
-                                                   mz_uint flags);
-
-#        ifndef MINIZ_NO_STDIO
-    // Extracts a archive file to a disk file and sets its last accessed and modified times.
-    // This function only extracts files, not archive directory records.
-    mz_bool mz_zip_reader_extract_to_file(mz_zip_archive* pZip, mz_uint file_index, const char* pDst_filename, mz_uint flags);
-    mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive* pZip, const char* pArchive_filename, const char* pDst_filename, mz_uint flags);
-#        endif
-
-    // Ends archive reading, freeing all allocations, and closing the input archive file if mz_zip_reader_init_file() was used.
-    mz_bool mz_zip_reader_end(mz_zip_archive* pZip);
-
-    // ZIP archive writing
-
-#        ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
-
-    // Inits a ZIP archive writer.
-    mz_bool mz_zip_writer_init(mz_zip_archive* pZip, mz_uint64 existing_size);
-    mz_bool mz_zip_writer_init_heap(mz_zip_archive* pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size);
-
-#            ifndef MINIZ_NO_STDIO
-    mz_bool mz_zip_writer_init_file(mz_zip_archive* pZip, const char* pFilename, mz_uint64 size_to_reserve_at_beginning);
-#            endif
-
-    // Converts a ZIP archive reader object into a writer object, to allow efficient in-place file appends to occur on an existing archive.
-    // For archives opened using mz_zip_reader_init_file, pFilename must be the archive's filename so it can be reopened for writing. If the file can't be reopened, mz_zip_reader_end() will be called.
-    // For archives opened using mz_zip_reader_init_mem, the memory block must be growable using the realloc callback (which defaults to realloc unless you've overridden it).
-    // Finally, for archives opened using mz_zip_reader_init, the mz_zip_archive's user provided m_pWrite function cannot be NULL.
-    // Note: In-place archive modification is not recommended unless you know what you're doing, because if execution stops or something goes wrong before
-    // the archive is finalized the file's central directory will be hosed.
-    mz_bool mz_zip_writer_init_from_reader(mz_zip_archive* pZip, const char* pFilename);
-
-    // Adds the contents of a memory buffer to an archive. These functions record the current local time into the archive.
-    // To add a directory entry, call this method with an archive name ending in a forwardslash with empty buffer.
-    // level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION.
-    mz_bool mz_zip_writer_add_mem(mz_zip_archive* pZip, const char* pArchive_name, const void* pBuf, size_t buf_size, mz_uint level_and_flags);
-    mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive* pZip, const char* pArchive_name, const void* pBuf, size_t buf_size, const void* pComment,
-                                     mz_uint16 comment_size, mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32);
-
-#            ifndef MINIZ_NO_STDIO
-    // Adds the contents of a disk file to an archive. This function also records the disk file's modified time into the archive.
-    // level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION.
-    mz_bool mz_zip_writer_add_file(mz_zip_archive* pZip, const char* pArchive_name, const char* pSrc_filename, const void* pComment,
-                                   mz_uint16 comment_size, mz_uint level_and_flags);
-#            endif
-
-    // Adds a file to an archive by fully cloning the data from another archive.
-    // This function fully clones the source file's compressed data (no recompression), along with its full filename, extra data, and comment fields.
-    mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive* pZip, mz_zip_archive* pSource_zip, mz_uint file_index);
-
-    // Finalizes the archive by writing the central directory records followed by the end of central directory record.
-    // After an archive is finalized, the only valid call on the mz_zip_archive struct is mz_zip_writer_end().
-    // An archive must be manually finalized by calling this function for it to be valid.
-    mz_bool mz_zip_writer_finalize_archive(mz_zip_archive* pZip);
-    mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive* pZip, void** pBuf, size_t* pSize);
-
-    // Ends archive writing, freeing all allocations, and closing the output file if mz_zip_writer_init_file() was used.
-    // Note for the archive to be valid, it must have been finalized before ending.
-    mz_bool mz_zip_writer_end(mz_zip_archive* pZip);
-
-    // Misc. high-level helper functions:
-
-    // mz_zip_add_mem_to_archive_file_in_place() efficiently (but not atomically) appends a memory blob to a ZIP archive.
-    // level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION.
-    mz_bool mz_zip_add_mem_to_archive_file_in_place(const char* pZip_filename, const char* pArchive_name, const void* pBuf, size_t buf_size,
-                                                    const void* pComment, mz_uint16 comment_size, mz_uint level_and_flags);
-
-    // Reads a single file from an archive into a heap block.
-    // Returns NULL on failure.
-    void* mz_zip_extract_archive_file_to_heap(const char* pZip_filename, const char* pArchive_name, size_t* pSize, mz_uint zip_flags);
-
-#        endif  // #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
-
-#    endif  // #ifndef MINIZ_NO_ARCHIVE_APIS
-
-    // ------------------- Low-level Decompression API Definitions
-
-    // Decompression flags used by tinfl_decompress().
-    // TINFL_FLAG_PARSE_ZLIB_HEADER: If set, the input has a valid zlib header and ends with an adler32 checksum (it's a valid zlib stream). Otherwise, the input is a raw deflate stream.
-    // TINFL_FLAG_HAS_MORE_INPUT: If set, there are more input bytes available beyond the end of the supplied input buffer. If clear, the input buffer contains all remaining input.
-    // TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF: If set, the output buffer is large enough to hold the entire decompressed stream. If clear, the output buffer is at least the size of the dictionary (typically 32KB).
-    // TINFL_FLAG_COMPUTE_ADLER32: Force adler-32 checksum computation of the decompressed bytes.
-    enum
-    {
-        TINFL_FLAG_PARSE_ZLIB_HEADER = 1,
-        TINFL_FLAG_HAS_MORE_INPUT = 2,
-        TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,
-        TINFL_FLAG_COMPUTE_ADLER32 = 8
-    };
-
-    // High level decompression functions:
-    // tinfl_decompress_mem_to_heap() decompresses a block in memory to a heap block allocated via malloc().
-    // On entry:
-    //  pSrc_buf, src_buf_len: Pointer and size of the Deflate or zlib source data to decompress.
-    // On return:
-    //  Function returns a pointer to the decompressed data, or NULL on failure.
-    //  *pOut_len will be set to the decompressed data's size, which could be larger than src_buf_len on uncompressible data.
-    //  The caller must call mz_free() on the returned block when it's no longer needed.
-    void* tinfl_decompress_mem_to_heap(const void* pSrc_buf, size_t src_buf_len, size_t* pOut_len, int flags);
-
-// tinfl_decompress_mem_to_mem() decompresses a block in memory to another block in memory.
-// Returns TINFL_DECOMPRESS_MEM_TO_MEM_FAILED on failure, or the number of bytes written on success.
-#    define TINFL_DECOMPRESS_MEM_TO_MEM_FAILED ((size_t)(-1))
-    size_t tinfl_decompress_mem_to_mem(void* pOut_buf, size_t out_buf_len, const void* pSrc_buf, size_t src_buf_len, int flags);
-
-    // tinfl_decompress_mem_to_callback() decompresses a block in memory to an internal 32KB buffer, and a user provided callback function will be called to flush the buffer.
-    // Returns 1 on success or 0 on failure.
-    typedef int (*tinfl_put_buf_func_ptr)(const void* pBuf, int len, void* pUser);
-    int tinfl_decompress_mem_to_callback(const void* pIn_buf, size_t* pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void* pPut_buf_user,
-                                         int flags);
-
-    struct tinfl_decompressor_tag;
-    typedef struct tinfl_decompressor_tag tinfl_decompressor;
-
-// Max size of LZ dictionary.
-#    define TINFL_LZ_DICT_SIZE 32768
-
-    // Return status.
-    typedef enum
-    {
-        TINFL_STATUS_BAD_PARAM = -3,
-        TINFL_STATUS_ADLER32_MISMATCH = -2,
-        TINFL_STATUS_FAILED = -1,
-        TINFL_STATUS_DONE = 0,
-        TINFL_STATUS_NEEDS_MORE_INPUT = 1,
-        TINFL_STATUS_HAS_MORE_OUTPUT = 2
-    } tinfl_status;
-
-// Initializes the decompressor to its initial state.
-#    define tinfl_init(r)     \
-        do {                  \
-            (r)->m_state = 0; \
-        }                     \
-        MZ_MACRO_END
-#    define tinfl_get_adler32(r) (r)->m_check_adler32
-
-    // Main low-level decompressor coroutine function. This is the only function actually needed for decompression. All the other functions are just high-level helpers for improved usability.
-    // This is a universal API, i.e. it can be used as a building block to build any desired higher level decompression API. In the limit case, it can be called once per every byte input or output.
-    tinfl_status tinfl_decompress(tinfl_decompressor* r, const mz_uint8* pIn_buf_next, size_t* pIn_buf_size, mz_uint8* pOut_buf_start,
-                                  mz_uint8* pOut_buf_next, size_t* pOut_buf_size, const mz_uint32 decomp_flags);
-
-    // Internal/private bits follow.
-    enum
-    {
-        TINFL_MAX_HUFF_TABLES = 3,
-        TINFL_MAX_HUFF_SYMBOLS_0 = 288,
-        TINFL_MAX_HUFF_SYMBOLS_1 = 32,
-        TINFL_MAX_HUFF_SYMBOLS_2 = 19,
-        TINFL_FAST_LOOKUP_BITS = 10,
-        TINFL_FAST_LOOKUP_SIZE = 1 << TINFL_FAST_LOOKUP_BITS
-    };
-
-    typedef struct
-    {
-        mz_uint8 m_code_size[TINFL_MAX_HUFF_SYMBOLS_0];
-        mz_int16 m_look_up[TINFL_FAST_LOOKUP_SIZE], m_tree[TINFL_MAX_HUFF_SYMBOLS_0 * 2];
-    } tinfl_huff_table;
-
-#    if MINIZ_HAS_64BIT_REGISTERS
-#        define TINFL_USE_64BIT_BITBUF 1
-#    endif
-
-#    if TINFL_USE_64BIT_BITBUF
-    typedef mz_uint64 tinfl_bit_buf_t;
-#        define TINFL_BITBUF_SIZE (64)
-#    else
-typedef mz_uint32 tinfl_bit_buf_t;
-#        define TINFL_BITBUF_SIZE (32)
-#    endif
-
-    struct tinfl_decompressor_tag
-    {
-        mz_uint32 m_state, m_num_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra,
-          m_table_sizes[TINFL_MAX_HUFF_TABLES];
-        tinfl_bit_buf_t m_bit_buf;
-        size_t m_dist_from_out_buf_start;
-        tinfl_huff_table m_tables[TINFL_MAX_HUFF_TABLES];
-        mz_uint8 m_raw_header[4], m_len_codes[TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1 + 137];
-    };
-
-// ------------------- Low-level Compression API Definitions
-
-// Set TDEFL_LESS_MEMORY to 1 to use less memory (compression will be slightly slower, and raw/dynamic blocks will be output more frequently).
-#    define TDEFL_LESS_MEMORY 0
-
-    // tdefl_init() compression flags logically OR'd together (low 12 bits contain the max. number of probes per dictionary search):
-    // TDEFL_DEFAULT_MAX_PROBES: The compressor defaults to 128 dictionary probes per dictionary search. 0=Huffman only, 1=Huffman+LZ (fastest/crap compression), 4095=Huffman+LZ (slowest/best compression).
-    enum
-    {
-        TDEFL_HUFFMAN_ONLY = 0,
-        TDEFL_DEFAULT_MAX_PROBES = 128,
-        TDEFL_MAX_PROBES_MASK = 0xFFF
-    };
-
-    // TDEFL_WRITE_ZLIB_HEADER: If set, the compressor outputs a zlib header before the deflate data, and the Adler-32 of the source data at the end. Otherwise, you'll get raw deflate data.
-    // TDEFL_COMPUTE_ADLER32: Always compute the adler-32 of the input data (even when not writing zlib headers).
-    // TDEFL_GREEDY_PARSING_FLAG: Set to use faster greedy parsing, instead of more efficient lazy parsing.
-    // TDEFL_NONDETERMINISTIC_PARSING_FLAG: Enable to decrease the compressor's initialization time to the minimum, but the output may vary from run to run given the same input (depending on the contents of memory).
-    // TDEFL_RLE_MATCHES: Only look for RLE matches (matches with a distance of 1)
-    // TDEFL_FILTER_MATCHES: Discards matches <= 5 chars if enabled.
-    // TDEFL_FORCE_ALL_STATIC_BLOCKS: Disable usage of optimized Huffman tables.
-    // TDEFL_FORCE_ALL_RAW_BLOCKS: Only use raw (uncompressed) deflate blocks.
-    // The low 12 bits are reserved to control the max # of hash probes per dictionary lookup (see TDEFL_MAX_PROBES_MASK).
-    enum
-    {
-        TDEFL_WRITE_ZLIB_HEADER = 0x01000,
-        TDEFL_COMPUTE_ADLER32 = 0x02000,
-        TDEFL_GREEDY_PARSING_FLAG = 0x04000,
-        TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0x08000,
-        TDEFL_RLE_MATCHES = 0x10000,
-        TDEFL_FILTER_MATCHES = 0x20000,
-        TDEFL_FORCE_ALL_STATIC_BLOCKS = 0x40000,
-        TDEFL_FORCE_ALL_RAW_BLOCKS = 0x80000
-    };
-
-    // High level compression functions:
-    // tdefl_compress_mem_to_heap() compresses a block in memory to a heap block allocated via malloc().
-    // On entry:
-    //  pSrc_buf, src_buf_len: Pointer and size of source block to compress.
-    //  flags: The max match finder probes (default is 128) logically OR'd against the above flags. Higher probes are slower but improve compression.
-    // On return:
-    //  Function returns a pointer to the compressed data, or NULL on failure.
-    //  *pOut_len will be set to the compressed data's size, which could be larger than src_buf_len on uncompressible data.
-    //  The caller must free() the returned block when it's no longer needed.
-    void* tdefl_compress_mem_to_heap(const void* pSrc_buf, size_t src_buf_len, size_t* pOut_len, int flags);
-
-    // tdefl_compress_mem_to_mem() compresses a block in memory to another block in memory.
-    // Returns 0 on failure.
-    size_t tdefl_compress_mem_to_mem(void* pOut_buf, size_t out_buf_len, const void* pSrc_buf, size_t src_buf_len, int flags);
-
-    // Compresses an image to a compressed PNG file in memory.
-    // On entry:
-    //  pImage, w, h, and num_chans describe the image to compress. num_chans may be 1, 2, 3, or 4.
-    //  The image pitch in bytes per scanline will be w*num_chans. The leftmost pixel on the top scanline is stored first in memory.
-    //  level may range from [0,10], use MZ_NO_COMPRESSION, MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc. or a decent default is MZ_DEFAULT_LEVEL
-    //  If flip is true, the image will be flipped on the Y axis (useful for OpenGL apps).
-    // On return:
-    //  Function returns a pointer to the compressed data, or NULL on failure.
-    //  *pLen_out will be set to the size of the PNG image file.
-    //  The caller must mz_free() the returned heap block (which will typically be larger than *pLen_out) when it's no longer needed.
-    void* tdefl_write_image_to_png_file_in_memory_ex(const void* pImage, int w, int h, int num_chans, size_t* pLen_out, mz_uint level, mz_bool flip);
-    void* tdefl_write_image_to_png_file_in_memory(const void* pImage, int w, int h, int num_chans, size_t* pLen_out);
-
-    // Output stream interface. The compressor uses this interface to write compressed data. It'll typically be called TDEFL_OUT_BUF_SIZE at a time.
-    typedef mz_bool (*tdefl_put_buf_func_ptr)(const void* pBuf, int len, void* pUser);
-
-    // tdefl_compress_mem_to_output() compresses a block to an output stream. The above helpers use this function internally.
-    mz_bool tdefl_compress_mem_to_output(const void* pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void* pPut_buf_user, int flags);
-
-    enum
-    {
-        TDEFL_MAX_HUFF_TABLES = 3,
-        TDEFL_MAX_HUFF_SYMBOLS_0 = 288,
-        TDEFL_MAX_HUFF_SYMBOLS_1 = 32,
-        TDEFL_MAX_HUFF_SYMBOLS_2 = 19,
-        TDEFL_LZ_DICT_SIZE = 32768,
-        TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1,
-        TDEFL_MIN_MATCH_LEN = 3,
-        TDEFL_MAX_MATCH_LEN = 258
-    };
-
-// TDEFL_OUT_BUF_SIZE MUST be large enough to hold a single entire compressed output block (using static/fixed Huffman codes).
-#    if TDEFL_LESS_MEMORY
-    enum
-    {
-        TDEFL_LZ_CODE_BUF_SIZE = 24 * 1024,
-        TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,
-        TDEFL_MAX_HUFF_SYMBOLS = 288,
-        TDEFL_LZ_HASH_BITS = 12,
-        TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,
-        TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,
-        TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS
-    };
-#    else
-enum
-{
-    TDEFL_LZ_CODE_BUF_SIZE = 64 * 1024,
-    TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,
-    TDEFL_MAX_HUFF_SYMBOLS = 288,
-    TDEFL_LZ_HASH_BITS = 15,
-    TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,
-    TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,
-    TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS
-};
-#    endif
-
-    // The low-level tdefl functions below may be used directly if the above helper functions aren't flexible enough. The low-level functions don't make any heap allocations, unlike the above helper functions.
-    typedef enum
-    {
-        TDEFL_STATUS_BAD_PARAM = -2,
-        TDEFL_STATUS_PUT_BUF_FAILED = -1,
-        TDEFL_STATUS_OKAY = 0,
-        TDEFL_STATUS_DONE = 1,
-    } tdefl_status;
-
-    // Must map to MZ_NO_FLUSH, MZ_SYNC_FLUSH, etc. enums
-    typedef enum
-    {
-        TDEFL_NO_FLUSH = 0,
-        TDEFL_SYNC_FLUSH = 2,
-        TDEFL_FULL_FLUSH = 3,
-        TDEFL_FINISH = 4
-    } tdefl_flush;
-
-    // tdefl's compression state structure.
-    typedef struct
-    {
-        tdefl_put_buf_func_ptr m_pPut_buf_func;
-        void* m_pPut_buf_user;
-        mz_uint m_flags, m_max_probes[2];
-        int m_greedy_parsing;
-        mz_uint m_adler32, m_lookahead_pos, m_lookahead_size, m_dict_size;
-        mz_uint8 *m_pLZ_code_buf, *m_pLZ_flags, *m_pOutput_buf, *m_pOutput_buf_end;
-        mz_uint m_num_flags_left, m_total_lz_bytes, m_lz_code_buf_dict_pos, m_bits_in, m_bit_buffer;
-        mz_uint m_saved_match_dist, m_saved_match_len, m_saved_lit, m_output_flush_ofs, m_output_flush_remaining, m_finished, m_block_index,
-          m_wants_to_finish;
-        tdefl_status m_prev_return_status;
-        const void* m_pIn_buf;
-        void* m_pOut_buf;
-        size_t *m_pIn_buf_size, *m_pOut_buf_size;
-        tdefl_flush m_flush;
-        const mz_uint8* m_pSrc;
-        size_t m_src_buf_left, m_out_buf_ofs;
-        mz_uint8 m_dict[TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN - 1];
-        mz_uint16 m_huff_count[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
-        mz_uint16 m_huff_codes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
-        mz_uint8 m_huff_code_sizes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
-        mz_uint8 m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE];
-        mz_uint16 m_next[TDEFL_LZ_DICT_SIZE];
-        mz_uint16 m_hash[TDEFL_LZ_HASH_SIZE];
-        mz_uint8 m_output_buf[TDEFL_OUT_BUF_SIZE];
-    } tdefl_compressor;
-
-    // Initializes the compressor.
-    // There is no corresponding deinit() function because the tdefl API's do not dynamically allocate memory.
-    // pBut_buf_func: If NULL, output data will be supplied to the specified callback. In this case, the user should call the tdefl_compress_buffer() API for compression.
-    // If pBut_buf_func is NULL the user should always call the tdefl_compress() API.
-    // flags: See the above enums (TDEFL_HUFFMAN_ONLY, TDEFL_WRITE_ZLIB_HEADER, etc.)
-    tdefl_status tdefl_init(tdefl_compressor* d, tdefl_put_buf_func_ptr pPut_buf_func, void* pPut_buf_user, int flags);
-
-    // Compresses a block of data, consuming as much of the specified input buffer as possible, and writing as much compressed data to the specified output buffer as possible.
-    tdefl_status tdefl_compress(tdefl_compressor* d, const void* pIn_buf, size_t* pIn_buf_size, void* pOut_buf, size_t* pOut_buf_size,
-                                tdefl_flush flush);
-
-    // tdefl_compress_buffer() is only usable when the tdefl_init() is called with a non-NULL tdefl_put_buf_func_ptr.
-    // tdefl_compress_buffer() always consumes the entire input buffer.
-    tdefl_status tdefl_compress_buffer(tdefl_compressor* d, const void* pIn_buf, size_t in_buf_size, tdefl_flush flush);
-
-    tdefl_status tdefl_get_prev_return_status(tdefl_compressor* d);
-    mz_uint32 tdefl_get_adler32(tdefl_compressor* d);
-
-// Can't use tdefl_create_comp_flags_from_zip_params if MINIZ_NO_ZLIB_APIS isn't defined, because it uses some of its macros.
-#    ifndef MINIZ_NO_ZLIB_APIS
-    // Create tdefl_compress() flags given zlib-style compression parameters.
-    // level may range from [0,10] (where 10 is absolute max compression, but may be much slower on some files)
-    // window_bits may be -15 (raw deflate) or 15 (zlib)
-    // strategy may be either MZ_DEFAULT_STRATEGY, MZ_FILTERED, MZ_HUFFMAN_ONLY, MZ_RLE, or MZ_FIXED
-    mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy);
-#    endif  // #ifndef MINIZ_NO_ZLIB_APIS
-
-#    ifdef __cplusplus
-}
-#    endif
-
-#endif  // MINIZ_HEADER_INCLUDED
-
-// ------------------- End of Header: Implementation follows. (If you only want the header, define MINIZ_HEADER_FILE_ONLY.)
-
-#ifndef MINIZ_HEADER_FILE_ONLY
-
-typedef unsigned char mz_validate_uint16[sizeof(mz_uint16) == 2 ? 1 : -1];
-typedef unsigned char mz_validate_uint32[sizeof(mz_uint32) == 4 ? 1 : -1];
-typedef unsigned char mz_validate_uint64[sizeof(mz_uint64) == 8 ? 1 : -1];
-
-#    include <string.h>
-#    include <assert.h>
-
-#    define MZ_ASSERT(x) assert(x)
-
-#    ifdef MINIZ_NO_MALLOC
-#        define MZ_MALLOC(x) NULL
-#        define MZ_FREE(x) (void)x, ((void)0)
-#        define MZ_REALLOC(p, x) NULL
-#    else
-#        define MZ_MALLOC(x) malloc(x)
-#        define MZ_FREE(x) free(x)
-#        define MZ_REALLOC(p, x) realloc(p, x)
-#    endif
-
-#    define MZ_MAX(a, b) (((a) > (b)) ? (a) : (b))
-#    define MZ_MIN(a, b) (((a) < (b)) ? (a) : (b))
-#    define MZ_CLEAR_OBJ(obj) memset(&(obj), 0, sizeof(obj))
-
-#    if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
-#        define MZ_READ_LE16(p) *((const mz_uint16*)(p))
-#        define MZ_READ_LE32(p) *((const mz_uint32*)(p))
-#    else
-#        define MZ_READ_LE16(p) ((mz_uint32)(((const mz_uint8*)(p))[0]) | ((mz_uint32)(((const mz_uint8*)(p))[1]) << 8U))
-#        define MZ_READ_LE32(p)                                                                      \
-            ((mz_uint32)(((const mz_uint8*)(p))[0]) | ((mz_uint32)(((const mz_uint8*)(p))[1]) << 8U) \
-             | ((mz_uint32)(((const mz_uint8*)(p))[2]) << 16U) | ((mz_uint32)(((const mz_uint8*)(p))[3]) << 24U))
-#    endif
-
-#    ifdef _MSC_VER
-#        define MZ_FORCEINLINE __forceinline
-#    elif defined(__GNUC__)
-#        define MZ_FORCEINLINE inline __attribute__((__always_inline__))
-#    else
-#        define MZ_FORCEINLINE inline
-#    endif
-
-#    ifdef __cplusplus
-extern "C"
-{
-#    endif
-
-    // ------------------- zlib-style API's
-
-    mz_ulong mz_adler32(mz_ulong adler, const unsigned char* ptr, size_t buf_len) {
-        mz_uint32 i, s1 = (mz_uint32)(adler & 0xffff), s2 = (mz_uint32)(adler >> 16);
-        size_t block_len = buf_len % 5552;
-        if (!ptr) return MZ_ADLER32_INIT;
-        while (buf_len) {
-            for (i = 0; i + 7 < block_len; i += 8, ptr += 8) {
-                s1 += ptr[0], s2 += s1;
-                s1 += ptr[1], s2 += s1;
-                s1 += ptr[2], s2 += s1;
-                s1 += ptr[3], s2 += s1;
-                s1 += ptr[4], s2 += s1;
-                s1 += ptr[5], s2 += s1;
-                s1 += ptr[6], s2 += s1;
-                s1 += ptr[7], s2 += s1;
-            }
-            for (; i < block_len; ++i)
-                s1 += *ptr++, s2 += s1;
-            s1 %= 65521U, s2 %= 65521U;
-            buf_len -= block_len;
-            block_len = 5552;
-        }
-        return (s2 << 16) + s1;
-    }
-
-    // Karl Malbrain's compact CRC-32. See "A compact CCITT crc16 and crc32 C implementation that balances processor cache usage against speed": http://www.geocities.com/malbrain/
-    mz_ulong mz_crc32(mz_ulong crc, const mz_uint8* ptr, size_t buf_len) {
-        static const mz_uint32 s_crc32[16] = {0,          0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
-                                              0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c};
-        mz_uint32 crcu32 = (mz_uint32)crc;
-        if (!ptr) return MZ_CRC32_INIT;
-        crcu32 = ~crcu32;
-        while (buf_len--) {
-            mz_uint8 b = *ptr++;
-            crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b & 0xF)];
-            crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b >> 4)];
-        }
-        return ~crcu32;
-    }
-
-    void mz_free(void* p) {
-        MZ_FREE(p);
-    }
-
-#    ifndef MINIZ_NO_ZLIB_APIS
-
-    static void* def_alloc_func(void* opaque, size_t items, size_t size) {
-        (void)opaque, (void)items, (void)size;
-        return MZ_MALLOC(items * size);
-    }
-    static void def_free_func(void* opaque, void* address) {
-        (void)opaque, (void)address;
-        MZ_FREE(address);
-    }
-    static void* def_realloc_func(void* opaque, void* address, size_t items, size_t size) {
-        (void)opaque, (void)address, (void)items, (void)size;
-        return MZ_REALLOC(address, items * size);
-    }
-
-    const char* mz_version(void) {
-        return MZ_VERSION;
-    }
-
-    int mz_deflateInit(mz_streamp pStream, int level) {
-        return mz_deflateInit2(pStream, level, MZ_DEFLATED, MZ_DEFAULT_WINDOW_BITS, 9, MZ_DEFAULT_STRATEGY);
-    }
-
-    int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy) {
-        tdefl_compressor* pComp;
-        mz_uint comp_flags = TDEFL_COMPUTE_ADLER32 | tdefl_create_comp_flags_from_zip_params(level, window_bits, strategy);
-
-        if (!pStream) return MZ_STREAM_ERROR;
-        if ((method != MZ_DEFLATED) || ((mem_level < 1) || (mem_level > 9))
-            || ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS)))
-            return MZ_PARAM_ERROR;
-
-        pStream->data_type = 0;
-        pStream->adler = MZ_ADLER32_INIT;
-        pStream->msg = NULL;
-        pStream->reserved = 0;
-        pStream->total_in = 0;
-        pStream->total_out = 0;
-        if (!pStream->zalloc) pStream->zalloc = def_alloc_func;
-        if (!pStream->zfree) pStream->zfree = def_free_func;
-
-        pComp = (tdefl_compressor*)pStream->zalloc(pStream->opaque, 1, sizeof(tdefl_compressor));
-        if (!pComp) return MZ_MEM_ERROR;
-
-        pStream->state = (struct mz_internal_state*)pComp;
-
-        if (tdefl_init(pComp, NULL, NULL, comp_flags) != TDEFL_STATUS_OKAY) {
-            mz_deflateEnd(pStream);
-            return MZ_PARAM_ERROR;
-        }
-
-        return MZ_OK;
-    }
-
-    int mz_deflateReset(mz_streamp pStream) {
-        if ((!pStream) || (!pStream->state) || (!pStream->zalloc) || (!pStream->zfree)) return MZ_STREAM_ERROR;
-        pStream->total_in = pStream->total_out = 0;
-        tdefl_init((tdefl_compressor*)pStream->state, NULL, NULL, ((tdefl_compressor*)pStream->state)->m_flags);
-        return MZ_OK;
-    }
-
-    int mz_deflate(mz_streamp pStream, int flush) {
-        size_t in_bytes, out_bytes;
-        mz_ulong orig_total_in, orig_total_out;
-        int mz_status = MZ_OK;
-
-        if ((!pStream) || (!pStream->state) || (flush < 0) || (flush > MZ_FINISH) || (!pStream->next_out)) return MZ_STREAM_ERROR;
-        if (!pStream->avail_out) return MZ_BUF_ERROR;
-
-        if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;
-
-        if (((tdefl_compressor*)pStream->state)->m_prev_return_status == TDEFL_STATUS_DONE)
-            return (flush == MZ_FINISH) ? MZ_STREAM_END : MZ_BUF_ERROR;
-
-        orig_total_in = pStream->total_in;
-        orig_total_out = pStream->total_out;
-        for (;;) {
-            tdefl_status defl_status;
-            in_bytes = pStream->avail_in;
-            out_bytes = pStream->avail_out;
-
-            defl_status =
-              tdefl_compress((tdefl_compressor*)pStream->state, pStream->next_in, &in_bytes, pStream->next_out, &out_bytes, (tdefl_flush)flush);
-            pStream->next_in += (mz_uint)in_bytes;
-            pStream->avail_in -= (mz_uint)in_bytes;
-            pStream->total_in += (mz_uint)in_bytes;
-            pStream->adler = tdefl_get_adler32((tdefl_compressor*)pStream->state);
-
-            pStream->next_out += (mz_uint)out_bytes;
-            pStream->avail_out -= (mz_uint)out_bytes;
-            pStream->total_out += (mz_uint)out_bytes;
-
-            if (defl_status < 0) {
-                mz_status = MZ_STREAM_ERROR;
-                break;
-            } else if (defl_status == TDEFL_STATUS_DONE) {
-                mz_status = MZ_STREAM_END;
-                break;
-            } else if (!pStream->avail_out)
-                break;
-            else if ((!pStream->avail_in) && (flush != MZ_FINISH)) {
-                if ((flush) || (pStream->total_in != orig_total_in) || (pStream->total_out != orig_total_out)) break;
-                return MZ_BUF_ERROR;  // Can't make forward progress without some input.
-            }
-        }
-        return mz_status;
-    }
-
-    int mz_deflateEnd(mz_streamp pStream) {
-        if (!pStream) return MZ_STREAM_ERROR;
-        if (pStream->state) {
-            pStream->zfree(pStream->opaque, pStream->state);
-            pStream->state = NULL;
-        }
-        return MZ_OK;
-    }
-
-    mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len) {
-        (void)pStream;
-        // This is really over conservative. (And lame, but it's actually pretty tricky to compute a true upper bound given the way tdefl's blocking works.)
-        return MZ_MAX(128 + (source_len * 110) / 100, 128 + source_len + ((source_len / (31 * 1024)) + 1) * 5);
-    }
-
-    int mz_compress2(unsigned char* pDest, mz_ulong* pDest_len, const unsigned char* pSource, mz_ulong source_len, int level) {
-        int status;
-        mz_stream stream;
-        memset(&stream, 0, sizeof(stream));
-
-        // In case mz_ulong is 64-bits (argh I hate longs).
-        if ((source_len | *pDest_len) > 0xFFFFFFFFU) return MZ_PARAM_ERROR;
-
-        stream.next_in = pSource;
-        stream.avail_in = (mz_uint32)source_len;
-        stream.next_out = pDest;
-        stream.avail_out = (mz_uint32)*pDest_len;
-
-        status = mz_deflateInit(&stream, level);
-        if (status != MZ_OK) return status;
-
-        status = mz_deflate(&stream, MZ_FINISH);
-        if (status != MZ_STREAM_END) {
-            mz_deflateEnd(&stream);
-            return (status == MZ_OK) ? MZ_BUF_ERROR : status;
-        }
-
-        *pDest_len = stream.total_out;
-        return mz_deflateEnd(&stream);
-    }
-
-    int mz_compress(unsigned char* pDest, mz_ulong* pDest_len, const unsigned char* pSource, mz_ulong source_len) {
-        return mz_compress2(pDest, pDest_len, pSource, source_len, MZ_DEFAULT_COMPRESSION);
-    }
-
-    mz_ulong mz_compressBound(mz_ulong source_len) {
-        return mz_deflateBound(NULL, source_len);
-    }
-
-    typedef struct
-    {
-        tinfl_decompressor m_decomp;
-        mz_uint m_dict_ofs, m_dict_avail, m_first_call, m_has_flushed;
-        int m_window_bits;
-        mz_uint8 m_dict[TINFL_LZ_DICT_SIZE];
-        tinfl_status m_last_status;
-    } inflate_state;
-
-    int mz_inflateInit2(mz_streamp pStream, int window_bits) {
-        inflate_state* pDecomp;
-        if (!pStream) return MZ_STREAM_ERROR;
-        if ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS)) return MZ_PARAM_ERROR;
-
-        pStream->data_type = 0;
-        pStream->adler = 0;
-        pStream->msg = NULL;
-        pStream->total_in = 0;
-        pStream->total_out = 0;
-        pStream->reserved = 0;
-        if (!pStream->zalloc) pStream->zalloc = def_alloc_func;
-        if (!pStream->zfree) pStream->zfree = def_free_func;
-
-        pDecomp = (inflate_state*)pStream->zalloc(pStream->opaque, 1, sizeof(inflate_state));
-        if (!pDecomp) return MZ_MEM_ERROR;
-
-        pStream->state = (struct mz_internal_state*)pDecomp;
-
-        tinfl_init(&pDecomp->m_decomp);
-        pDecomp->m_dict_ofs = 0;
-        pDecomp->m_dict_avail = 0;
-        pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
-        pDecomp->m_first_call = 1;
-        pDecomp->m_has_flushed = 0;
-        pDecomp->m_window_bits = window_bits;
-
-        return MZ_OK;
-    }
-
-    int mz_inflateInit(mz_streamp pStream) {
-        return mz_inflateInit2(pStream, MZ_DEFAULT_WINDOW_BITS);
-    }
-
-    int mz_inflate(mz_streamp pStream, int flush) {
-        inflate_state* pState;
-        mz_uint n, first_call, decomp_flags = TINFL_FLAG_COMPUTE_ADLER32;
-        size_t in_bytes, out_bytes, orig_avail_in;
-        tinfl_status status;
-
-        if ((!pStream) || (!pStream->state)) return MZ_STREAM_ERROR;
-        if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;
-        if ((flush) && (flush != MZ_SYNC_FLUSH) && (flush != MZ_FINISH)) return MZ_STREAM_ERROR;
-
-        pState = (inflate_state*)pStream->state;
-        if (pState->m_window_bits > 0) decomp_flags |= TINFL_FLAG_PARSE_ZLIB_HEADER;
-        orig_avail_in = pStream->avail_in;
-
-        first_call = pState->m_first_call;
-        pState->m_first_call = 0;
-        if (pState->m_last_status < 0) return MZ_DATA_ERROR;
-
-        if (pState->m_has_flushed && (flush != MZ_FINISH)) return MZ_STREAM_ERROR;
-        pState->m_has_flushed |= (flush == MZ_FINISH);
-
-        if ((flush == MZ_FINISH) && (first_call)) {
-            // MZ_FINISH on the first call implies that the input and output buffers are large enough to hold the entire compressed/decompressed file.
-            decomp_flags |= TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
-            in_bytes = pStream->avail_in;
-            out_bytes = pStream->avail_out;
-            status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pStream->next_out, pStream->next_out, &out_bytes, decomp_flags);
-            pState->m_last_status = status;
-            pStream->next_in += (mz_uint)in_bytes;
-            pStream->avail_in -= (mz_uint)in_bytes;
-            pStream->total_in += (mz_uint)in_bytes;
-            pStream->adler = tinfl_get_adler32(&pState->m_decomp);
-            pStream->next_out += (mz_uint)out_bytes;
-            pStream->avail_out -= (mz_uint)out_bytes;
-            pStream->total_out += (mz_uint)out_bytes;
-
-            if (status < 0)
-                return MZ_DATA_ERROR;
-            else if (status != TINFL_STATUS_DONE) {
-                pState->m_last_status = TINFL_STATUS_FAILED;
-                return MZ_BUF_ERROR;
-            }
-            return MZ_STREAM_END;
-        }
-        // flush != MZ_FINISH then we must assume there's more input.
-        if (flush != MZ_FINISH) decomp_flags |= TINFL_FLAG_HAS_MORE_INPUT;
-
-        if (pState->m_dict_avail) {
-            n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
-            memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
-            pStream->next_out += n;
-            pStream->avail_out -= n;
-            pStream->total_out += n;
-            pState->m_dict_avail -= n;
-            pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);
-            return ((pState->m_last_status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;
-        }
-
-        for (;;) {
-            in_bytes = pStream->avail_in;
-            out_bytes = TINFL_LZ_DICT_SIZE - pState->m_dict_ofs;
-
-            status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pState->m_dict, pState->m_dict + pState->m_dict_ofs, &out_bytes,
-                                      decomp_flags);
-            pState->m_last_status = status;
-
-            pStream->next_in += (mz_uint)in_bytes;
-            pStream->avail_in -= (mz_uint)in_bytes;
-            pStream->total_in += (mz_uint)in_bytes;
-            pStream->adler = tinfl_get_adler32(&pState->m_decomp);
-
-            pState->m_dict_avail = (mz_uint)out_bytes;
-
-            n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
-            memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
-            pStream->next_out += n;
-            pStream->avail_out -= n;
-            pStream->total_out += n;
-            pState->m_dict_avail -= n;
-            pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);
-
-            if (status < 0)
-                return MZ_DATA_ERROR;  // Stream is corrupted (there could be some uncompressed data left in the output dictionary - oh well).
-            else if ((status == TINFL_STATUS_NEEDS_MORE_INPUT) && (!orig_avail_in))
-                return MZ_BUF_ERROR;  // Signal caller that we can't make forward progress without supplying more input or by setting flush to MZ_FINISH.
-            else if (flush == MZ_FINISH) {
-                // The output buffer MUST be large to hold the remaining uncompressed data when flush==MZ_FINISH.
-                if (status == TINFL_STATUS_DONE) return pState->m_dict_avail ? MZ_BUF_ERROR : MZ_STREAM_END;
-                // status here must be TINFL_STATUS_HAS_MORE_OUTPUT, which means there's at least 1 more byte on the way. If there's no more room left in the output buffer then something is wrong.
-                else if (!pStream->avail_out)
-                    return MZ_BUF_ERROR;
-            } else if ((status == TINFL_STATUS_DONE) || (!pStream->avail_in) || (!pStream->avail_out) || (pState->m_dict_avail))
-                break;
-        }
-
-        return ((status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;
-    }
-
-    int mz_inflateEnd(mz_streamp pStream) {
-        if (!pStream) return MZ_STREAM_ERROR;
-        if (pStream->state) {
-            pStream->zfree(pStream->opaque, pStream->state);
-            pStream->state = NULL;
-        }
-        return MZ_OK;
-    }
-
-    int mz_uncompress(unsigned char* pDest, mz_ulong* pDest_len, const unsigned char* pSource, mz_ulong source_len) {
-        mz_stream stream;
-        int status;
-        memset(&stream, 0, sizeof(stream));
-
-        // In case mz_ulong is 64-bits (argh I hate longs).
-        if ((source_len | *pDest_len) > 0xFFFFFFFFU) return MZ_PARAM_ERROR;
-
-        stream.next_in = pSource;
-        stream.avail_in = (mz_uint32)source_len;
-        stream.next_out = pDest;
-        stream.avail_out = (mz_uint32)*pDest_len;
-
-        status = mz_inflateInit(&stream);
-        if (status != MZ_OK) return status;
-
-        status = mz_inflate(&stream, MZ_FINISH);
-        if (status != MZ_STREAM_END) {
-            mz_inflateEnd(&stream);
-            return ((status == MZ_BUF_ERROR) && (!stream.avail_in)) ? MZ_DATA_ERROR : status;
-        }
-        *pDest_len = stream.total_out;
-
-        return mz_inflateEnd(&stream);
-    }
-
-    const char* mz_error(int err) {
-        static struct
-        {
-            int m_err;
-            const char* m_pDesc;
-        } s_error_descs[] = {{MZ_OK, ""},
-                             {MZ_STREAM_END, "stream end"},
-                             {MZ_NEED_DICT, "need dictionary"},
-                             {MZ_ERRNO, "file error"},
-                             {MZ_STREAM_ERROR, "stream error"},
-                             {MZ_DATA_ERROR, "data error"},
-                             {MZ_MEM_ERROR, "out of memory"},
-                             {MZ_BUF_ERROR, "buf error"},
-                             {MZ_VERSION_ERROR, "version error"},
-                             {MZ_PARAM_ERROR, "parameter error"}};
-        mz_uint i;
-        for (i = 0; i < sizeof(s_error_descs) / sizeof(s_error_descs[0]); ++i)
-            if (s_error_descs[i].m_err == err) return s_error_descs[i].m_pDesc;
-        return NULL;
-    }
-
-#    endif  //MINIZ_NO_ZLIB_APIS
-
-    // ------------------- Low-level Decompression (completely independent from all compression API's)
-
-#    define TINFL_MEMCPY(d, s, l) memcpy(d, s, l)
-#    define TINFL_MEMSET(p, c, l) memset(p, c, l)
-
-#    define TINFL_CR_BEGIN    \
-        switch (r->m_state) { \
-            case 0:
-#    define TINFL_CR_RETURN(state_index, result) \
-        do {                                     \
-            status = result;                     \
-            r->m_state = state_index;            \
-            goto common_exit;                    \
-            case state_index:;                   \
-        }                                        \
-        MZ_MACRO_END
-#    define TINFL_CR_RETURN_FOREVER(state_index, result) \
-        do {                                             \
-            for (;;) {                                   \
-                TINFL_CR_RETURN(state_index, result);    \
-            }                                            \
-        }                                                \
-        MZ_MACRO_END
-#    define TINFL_CR_FINISH }
-
-// TODO: If the caller has indicated that there's no more input, and we attempt to read beyond the input buf, then something is wrong with the input because the inflator never
-// reads ahead more than it needs to. Currently TINFL_GET_BYTE() pads the end of the stream with 0's in this scenario.
-#    define TINFL_GET_BYTE(state_index, c)                                           \
-        do {                                                                         \
-            if (pIn_buf_cur >= pIn_buf_end) {                                        \
-                for (;;) {                                                           \
-                    if (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) {                  \
-                        TINFL_CR_RETURN(state_index, TINFL_STATUS_NEEDS_MORE_INPUT); \
-                        if (pIn_buf_cur < pIn_buf_end) {                             \
-                            c = *pIn_buf_cur++;                                      \
-                            break;                                                   \
-                        }                                                            \
-                    } else {                                                         \
-                        c = 0;                                                       \
-                        break;                                                       \
-                    }                                                                \
-                }                                                                    \
-            } else                                                                   \
-                c = *pIn_buf_cur++;                                                  \
-        }                                                                            \
-        MZ_MACRO_END
-
-#    define TINFL_NEED_BITS(state_index, n)                \
-        do {                                               \
-            mz_uint c;                                     \
-            TINFL_GET_BYTE(state_index, c);                \
-            bit_buf |= (((tinfl_bit_buf_t)c) << num_bits); \
-            num_bits += 8;                                 \
-        } while (num_bits < (mz_uint)(n))
-#    define TINFL_SKIP_BITS(state_index, n)      \
-        do {                                     \
-            if (num_bits < (mz_uint)(n)) {       \
-                TINFL_NEED_BITS(state_index, n); \
-            }                                    \
-            bit_buf >>= (n);                     \
-            num_bits -= (n);                     \
-        }                                        \
-        MZ_MACRO_END
-#    define TINFL_GET_BITS(state_index, b, n)    \
-        do {                                     \
-            if (num_bits < (mz_uint)(n)) {       \
-                TINFL_NEED_BITS(state_index, n); \
-            }                                    \
-            b = bit_buf & ((1 << (n)) - 1);      \
-            bit_buf >>= (n);                     \
-            num_bits -= (n);                     \
-        }                                        \
-        MZ_MACRO_END
-
-// TINFL_HUFF_BITBUF_FILL() is only used rarely, when the number of bytes remaining in the input buffer falls below 2.
-// It reads just enough bytes from the input stream that are needed to decode the next Huffman code (and absolutely no more). It works by trying to fully decode a
-// Huffman code by using whatever bits are currently present in the bit buffer. If this fails, it reads another byte, and tries again until it succeeds or until the
-// bit buffer contains >=15 bits (deflate's max. Huffman code size).
-#    define TINFL_HUFF_BITBUF_FILL(state_index, pHuff)                             \
-        do {                                                                       \
-            temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)];     \
-            if (temp >= 0) {                                                       \
-                code_len = temp >> 9;                                              \
-                if ((code_len) && (num_bits >= code_len)) break;                   \
-            } else if (num_bits > TINFL_FAST_LOOKUP_BITS) {                        \
-                code_len = TINFL_FAST_LOOKUP_BITS;                                 \
-                do {                                                               \
-                    temp = (pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)]; \
-                } while ((temp < 0) && (num_bits >= (code_len + 1)));              \
-                if (temp >= 0) break;                                              \
-            }                                                                      \
-            TINFL_GET_BYTE(state_index, c);                                        \
-            bit_buf |= (((tinfl_bit_buf_t)c) << num_bits);                         \
-            num_bits += 8;                                                         \
-        } while (num_bits < 15);
-
-// TINFL_HUFF_DECODE() decodes the next Huffman coded symbol. It's more complex than you would initially expect because the zlib API expects the decompressor to never read
-// beyond the final byte of the deflate stream. (In other words, when this macro wants to read another byte from the input, it REALLY needs another byte in order to fully
-// decode the next Huffman code.) Handling this properly is particularly important on raw deflate (non-zlib) streams, which aren't followed by a byte aligned adler-32.
-// The slow path is only executed at the very end of the input buffer.
-#    define TINFL_HUFF_DECODE(state_index, sym, pHuff)                                                                                  \
-        do {                                                                                                                            \
-            int temp;                                                                                                                   \
-            mz_uint code_len, c;                                                                                                        \
-            if (num_bits < 15) {                                                                                                        \
-                if ((pIn_buf_end - pIn_buf_cur) < 2) {                                                                                  \
-                    TINFL_HUFF_BITBUF_FILL(state_index, pHuff);                                                                         \
-                } else {                                                                                                                \
-                    bit_buf |= (((tinfl_bit_buf_t)pIn_buf_cur[0]) << num_bits) | (((tinfl_bit_buf_t)pIn_buf_cur[1]) << (num_bits + 8)); \
-                    pIn_buf_cur += 2;                                                                                                   \
-                    num_bits += 16;                                                                                                     \
-                }                                                                                                                       \
-            }                                                                                                                           \
-            if ((temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)                                               \
-                code_len = temp >> 9, temp &= 511;                                                                                      \
-            else {                                                                                                                      \
-                code_len = TINFL_FAST_LOOKUP_BITS;                                                                                      \
-                do {                                                                                                                    \
-                    temp = (pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)];                                                      \
-                } while (temp < 0);                                                                                                     \
-            }                                                                                                                           \
-            sym = temp;                                                                                                                 \
-            bit_buf >>= code_len;                                                                                                       \
-            num_bits -= code_len;                                                                                                       \
-        }                                                                                                                               \
-        MZ_MACRO_END
-
-    tinfl_status tinfl_decompress(tinfl_decompressor* r, const mz_uint8* pIn_buf_next, size_t* pIn_buf_size, mz_uint8* pOut_buf_start,
-                                  mz_uint8* pOut_buf_next, size_t* pOut_buf_size, const mz_uint32 decomp_flags) {
-        static const int s_length_base[31] = {3,  4,  5,  6,  7,  8,  9,  10,  11,  13,  15,  17,  19,  23, 27, 31,
-                                              35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0,  0};
-        static const int s_length_extra[31] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0};
-        static const int s_dist_base[32] = {1,   2,   3,   4,   5,    7,    9,    13,   17,   25,   33,   49,    65,    97,    129, 193,
-                                            257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0,   0};
-        static const int s_dist_extra[32] = {0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13};
-        static const mz_uint8 s_length_dezigzag[19] = {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
-        static const int s_min_table_sizes[3] = {257, 1, 4};
-
-        tinfl_status status = TINFL_STATUS_FAILED;
-        mz_uint32 num_bits, dist, counter, num_extra;
-        tinfl_bit_buf_t bit_buf;
-        const mz_uint8 *pIn_buf_cur = pIn_buf_next, *const pIn_buf_end = pIn_buf_next + *pIn_buf_size;
-        mz_uint8 *pOut_buf_cur = pOut_buf_next, *const pOut_buf_end = pOut_buf_next + *pOut_buf_size;
-        size_t out_buf_size_mask =
-                 (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF) ? (size_t)-1 : ((pOut_buf_next - pOut_buf_start) + *pOut_buf_size) - 1,
-               dist_from_out_buf_start;
-
-        // Ensure the output buffer's size is a power of 2, unless the output buffer is large enough to hold the entire output file (in which case it doesn't matter).
-        if (((out_buf_size_mask + 1) & out_buf_size_mask) || (pOut_buf_next < pOut_buf_start)) {
-            *pIn_buf_size = *pOut_buf_size = 0;
-            return TINFL_STATUS_BAD_PARAM;
-        }
-
-        num_bits = r->m_num_bits;
-        bit_buf = r->m_bit_buf;
-        dist = r->m_dist;
-        counter = r->m_counter;
-        num_extra = r->m_num_extra;
-        dist_from_out_buf_start = r->m_dist_from_out_buf_start;
-        TINFL_CR_BEGIN
-
-        bit_buf = num_bits = dist = counter = num_extra = r->m_zhdr0 = r->m_zhdr1 = 0;
-        r->m_z_adler32 = r->m_check_adler32 = 1;
-        if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) {
-            TINFL_GET_BYTE(1, r->m_zhdr0);
-            TINFL_GET_BYTE(2, r->m_zhdr1);
-            counter = (((r->m_zhdr0 * 256 + r->m_zhdr1) % 31 != 0) || (r->m_zhdr1 & 32) || ((r->m_zhdr0 & 15) != 8));
-            if (!(decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF))
-                counter |= (((1U << (8U + (r->m_zhdr0 >> 4))) > 32768U) || ((out_buf_size_mask + 1) < (size_t)(1U << (8U + (r->m_zhdr0 >> 4)))));
-            if (counter) {
-                TINFL_CR_RETURN_FOREVER(36, TINFL_STATUS_FAILED);
-            }
-        }
-
-        do {
-            TINFL_GET_BITS(3, r->m_final, 3);
-            r->m_type = r->m_final >> 1;
-            if (r->m_type == 0) {
-                TINFL_SKIP_BITS(5, num_bits & 7);
-                for (counter = 0; counter < 4; ++counter) {
-                    if (num_bits)
-                        TINFL_GET_BITS(6, r->m_raw_header[counter], 8);
-                    else
-                        TINFL_GET_BYTE(7, r->m_raw_header[counter]);
-                }
-                if ((counter = (r->m_raw_header[0] | (r->m_raw_header[1] << 8)))
-                    != (mz_uint)(0xFFFF ^ (r->m_raw_header[2] | (r->m_raw_header[3] << 8)))) {
-                    TINFL_CR_RETURN_FOREVER(39, TINFL_STATUS_FAILED);
-                }
-                while ((counter) && (num_bits)) {
-                    TINFL_GET_BITS(51, dist, 8);
-                    while (pOut_buf_cur >= pOut_buf_end) {
-                        TINFL_CR_RETURN(52, TINFL_STATUS_HAS_MORE_OUTPUT);
-                    }
-                    *pOut_buf_cur++ = (mz_uint8)dist;
-                    counter--;
-                }
-                while (counter) {
-                    size_t n;
-                    while (pOut_buf_cur >= pOut_buf_end) {
-                        TINFL_CR_RETURN(9, TINFL_STATUS_HAS_MORE_OUTPUT);
-                    }
-                    while (pIn_buf_cur >= pIn_buf_end) {
-                        if (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) {
-                            TINFL_CR_RETURN(38, TINFL_STATUS_NEEDS_MORE_INPUT);
-                        } else {
-                            TINFL_CR_RETURN_FOREVER(40, TINFL_STATUS_FAILED);
-                        }
-                    }
-                    n = MZ_MIN(MZ_MIN((size_t)(pOut_buf_end - pOut_buf_cur), (size_t)(pIn_buf_end - pIn_buf_cur)), counter);
-                    TINFL_MEMCPY(pOut_buf_cur, pIn_buf_cur, n);
-                    pIn_buf_cur += n;
-                    pOut_buf_cur += n;
-                    counter -= (mz_uint)n;
-                }
-            } else if (r->m_type == 3) {
-                TINFL_CR_RETURN_FOREVER(10, TINFL_STATUS_FAILED);
-            } else {
-                if (r->m_type == 1) {
-                    mz_uint8* p = r->m_tables[0].m_code_size;
-                    mz_uint i;
-                    r->m_table_sizes[0] = 288;
-                    r->m_table_sizes[1] = 32;
-                    TINFL_MEMSET(r->m_tables[1].m_code_size, 5, 32);
-                    for (i = 0; i <= 143; ++i)
-                        *p++ = 8;
-                    for (; i <= 255; ++i)
-                        *p++ = 9;
-                    for (; i <= 279; ++i)
-                        *p++ = 7;
-                    for (; i <= 287; ++i)
-                        *p++ = 8;
-                } else {
-                    for (counter = 0; counter < 3; counter++) {
-                        TINFL_GET_BITS(11, r->m_table_sizes[counter], "\05\05\04"[counter]);
-                        r->m_table_sizes[counter] += s_min_table_sizes[counter];
-                    }
-                    MZ_CLEAR_OBJ(r->m_tables[2].m_code_size);
-                    for (counter = 0; counter < r->m_table_sizes[2]; counter++) {
-                        mz_uint s;
-                        TINFL_GET_BITS(14, s, 3);
-                        r->m_tables[2].m_code_size[s_length_dezigzag[counter]] = (mz_uint8)s;
-                    }
-                    r->m_table_sizes[2] = 19;
-                }
-                for (; (int)r->m_type >= 0; r->m_type--) {
-                    int tree_next, tree_cur;
-                    tinfl_huff_table* pTable;
-                    mz_uint i, j, used_syms, total, sym_index, next_code[17], total_syms[16];
-                    pTable = &r->m_tables[r->m_type];
-                    MZ_CLEAR_OBJ(total_syms);
-                    MZ_CLEAR_OBJ(pTable->m_look_up);
-                    MZ_CLEAR_OBJ(pTable->m_tree);
-                    for (i = 0; i < r->m_table_sizes[r->m_type]; ++i)
-                        total_syms[pTable->m_code_size[i]]++;
-                    used_syms = 0, total = 0;
-                    next_code[0] = next_code[1] = 0;
-                    for (i = 1; i <= 15; ++i) {
-                        used_syms += total_syms[i];
-                        next_code[i + 1] = (total = ((total + total_syms[i]) << 1));
-                    }
-                    if ((65536 != total) && (used_syms > 1)) {
-                        TINFL_CR_RETURN_FOREVER(35, TINFL_STATUS_FAILED);
-                    }
-                    for (tree_next = -1, sym_index = 0; sym_index < r->m_table_sizes[r->m_type]; ++sym_index) {
-                        mz_uint rev_code = 0, l, cur_code, code_size = pTable->m_code_size[sym_index];
-                        if (!code_size) continue;
-                        cur_code = next_code[code_size]++;
-                        for (l = code_size; l > 0; l--, cur_code >>= 1)
-                            rev_code = (rev_code << 1) | (cur_code & 1);
-                        if (code_size <= TINFL_FAST_LOOKUP_BITS) {
-                            mz_int16 k = (mz_int16)((code_size << 9) | sym_index);
-                            while (rev_code < TINFL_FAST_LOOKUP_SIZE) {
-                                pTable->m_look_up[rev_code] = k;
-                                rev_code += (1 << code_size);
-                            }
-                            continue;
-                        }
-                        if (0 == (tree_cur = pTable->m_look_up[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)])) {
-                            pTable->m_look_up[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)] = (mz_int16)tree_next;
-                            tree_cur = tree_next;
-                            tree_next -= 2;
-                        }
-                        rev_code >>= (TINFL_FAST_LOOKUP_BITS - 1);
-                        for (j = code_size; j > (TINFL_FAST_LOOKUP_BITS + 1); j--) {
-                            tree_cur -= ((rev_code >>= 1) & 1);
-                            if (!pTable->m_tree[-tree_cur - 1]) {
-                                pTable->m_tree[-tree_cur - 1] = (mz_int16)tree_next;
-                                tree_cur = tree_next;
-                                tree_next -= 2;
-                            } else
-                                tree_cur = pTable->m_tree[-tree_cur - 1];
-                        }
-                        tree_cur -= ((rev_code >>= 1) & 1);
-                        pTable->m_tree[-tree_cur - 1] = (mz_int16)sym_index;
-                    }
-                    if (r->m_type == 2) {
-                        for (counter = 0; counter < (r->m_table_sizes[0] + r->m_table_sizes[1]);) {
-                            mz_uint s;
-                            TINFL_HUFF_DECODE(16, dist, &r->m_tables[2]);
-                            if (dist < 16) {
-                                r->m_len_codes[counter++] = (mz_uint8)dist;
-                                continue;
-                            }
-                            if ((dist == 16) && (!counter)) {
-                                TINFL_CR_RETURN_FOREVER(17, TINFL_STATUS_FAILED);
-                            }
-                            num_extra = "\02\03\07"[dist - 16];
-                            TINFL_GET_BITS(18, s, num_extra);
-                            s += "\03\03\013"[dist - 16];
-                            TINFL_MEMSET(r->m_len_codes + counter, (dist == 16) ? r->m_len_codes[counter - 1] : 0, s);
-                            counter += s;
-                        }
-                        if ((r->m_table_sizes[0] + r->m_table_sizes[1]) != counter) {
-                            TINFL_CR_RETURN_FOREVER(21, TINFL_STATUS_FAILED);
-                        }
-                        TINFL_MEMCPY(r->m_tables[0].m_code_size, r->m_len_codes, r->m_table_sizes[0]);
-                        TINFL_MEMCPY(r->m_tables[1].m_code_size, r->m_len_codes + r->m_table_sizes[0], r->m_table_sizes[1]);
-                    }
-                }
-                for (;;) {
-                    mz_uint8* pSrc;
-                    for (;;) {
-                        if (((pIn_buf_end - pIn_buf_cur) < 4) || ((pOut_buf_end - pOut_buf_cur) < 2)) {
-                            TINFL_HUFF_DECODE(23, counter, &r->m_tables[0]);
-                            if (counter >= 256) break;
-                            while (pOut_buf_cur >= pOut_buf_end) {
-                                TINFL_CR_RETURN(24, TINFL_STATUS_HAS_MORE_OUTPUT);
-                            }
-                            *pOut_buf_cur++ = (mz_uint8)counter;
-                        } else {
-                            int sym2;
-                            mz_uint code_len;
-#    if TINFL_USE_64BIT_BITBUF
-                            if (num_bits < 30) {
-                                bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE32(pIn_buf_cur)) << num_bits);
-                                pIn_buf_cur += 4;
-                                num_bits += 32;
-                            }
-#    else
-                        if (num_bits < 15) {
-                            bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits);
-                            pIn_buf_cur += 2;
-                            num_bits += 16;
-                        }
-#    endif
-                            if ((sym2 = r->m_tables[0].m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)
-                                code_len = sym2 >> 9;
-                            else {
-                                code_len = TINFL_FAST_LOOKUP_BITS;
-                                do {
-                                    sym2 = r->m_tables[0].m_tree[~sym2 + ((bit_buf >> code_len++) & 1)];
-                                } while (sym2 < 0);
-                            }
-                            counter = sym2;
-                            bit_buf >>= code_len;
-                            num_bits -= code_len;
-                            if (counter & 256) break;
-
-#    if !TINFL_USE_64BIT_BITBUF
-                            if (num_bits < 15) {
-                                bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits);
-                                pIn_buf_cur += 2;
-                                num_bits += 16;
-                            }
-#    endif
-                            if ((sym2 = r->m_tables[0].m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)
-                                code_len = sym2 >> 9;
-                            else {
-                                code_len = TINFL_FAST_LOOKUP_BITS;
-                                do {
-                                    sym2 = r->m_tables[0].m_tree[~sym2 + ((bit_buf >> code_len++) & 1)];
-                                } while (sym2 < 0);
-                            }
-                            bit_buf >>= code_len;
-                            num_bits -= code_len;
-
-                            pOut_buf_cur[0] = (mz_uint8)counter;
-                            if (sym2 & 256) {
-                                pOut_buf_cur++;
-                                counter = sym2;
-                                break;
-                            }
-                            pOut_buf_cur[1] = (mz_uint8)sym2;
-                            pOut_buf_cur += 2;
-                        }
-                    }
-                    if ((counter &= 511) == 256) break;
-
-                    num_extra = s_length_extra[counter - 257];
-                    counter = s_length_base[counter - 257];
-                    if (num_extra) {
-                        mz_uint extra_bits;
-                        TINFL_GET_BITS(25, extra_bits, num_extra);
-                        counter += extra_bits;
-                    }
-
-                    TINFL_HUFF_DECODE(26, dist, &r->m_tables[1]);
-                    num_extra = s_dist_extra[dist];
-                    dist = s_dist_base[dist];
-                    if (num_extra) {
-                        mz_uint extra_bits;
-                        TINFL_GET_BITS(27, extra_bits, num_extra);
-                        dist += extra_bits;
-                    }
-
-                    dist_from_out_buf_start = pOut_buf_cur - pOut_buf_start;
-                    if ((dist > dist_from_out_buf_start) && (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)) {
-                        TINFL_CR_RETURN_FOREVER(37, TINFL_STATUS_FAILED);
-                    }
-
-                    pSrc = pOut_buf_start + ((dist_from_out_buf_start - dist) & out_buf_size_mask);
-
-                    if ((MZ_MAX(pOut_buf_cur, pSrc) + counter) > pOut_buf_end) {
-                        while (counter--) {
-                            while (pOut_buf_cur >= pOut_buf_end) {
-                                TINFL_CR_RETURN(53, TINFL_STATUS_HAS_MORE_OUTPUT);
-                            }
-                            *pOut_buf_cur++ = pOut_buf_start[(dist_from_out_buf_start++ - dist) & out_buf_size_mask];
-                        }
-                        continue;
-                    }
-#    if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
-                    else if ((counter >= 9) && (counter <= dist)) {
-                        const mz_uint8* pSrc_end = pSrc + (counter & ~7);
-                        do {
-                            ((mz_uint32*)pOut_buf_cur)[0] = ((const mz_uint32*)pSrc)[0];
-                            ((mz_uint32*)pOut_buf_cur)[1] = ((const mz_uint32*)pSrc)[1];
-                            pOut_buf_cur += 8;
-                        } while ((pSrc += 8) < pSrc_end);
-                        if ((counter &= 7) < 3) {
-                            if (counter) {
-                                pOut_buf_cur[0] = pSrc[0];
-                                if (counter > 1) pOut_buf_cur[1] = pSrc[1];
-                                pOut_buf_cur += counter;
-                            }
-                            continue;
-                        }
-                    }
-#    endif
-                    do {
-                        pOut_buf_cur[0] = pSrc[0];
-                        pOut_buf_cur[1] = pSrc[1];
-                        pOut_buf_cur[2] = pSrc[2];
-                        pOut_buf_cur += 3;
-                        pSrc += 3;
-                    } while ((int)(counter -= 3) > 2);
-                    if ((int)counter > 0) {
-                        pOut_buf_cur[0] = pSrc[0];
-                        if ((int)counter > 1) pOut_buf_cur[1] = pSrc[1];
-                        pOut_buf_cur += counter;
-                    }
-                }
-            }
-        } while (!(r->m_final & 1));
-        if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) {
-            TINFL_SKIP_BITS(32, num_bits & 7);
-            for (counter = 0; counter < 4; ++counter) {
-                mz_uint s;
-                if (num_bits)
-                    TINFL_GET_BITS(41, s, 8);
-                else
-                    TINFL_GET_BYTE(42, s);
-                r->m_z_adler32 = (r->m_z_adler32 << 8) | s;
-            }
-        }
-        TINFL_CR_RETURN_FOREVER(34, TINFL_STATUS_DONE);
-        TINFL_CR_FINISH
-
-    common_exit:
-        r->m_num_bits = num_bits;
-        r->m_bit_buf = bit_buf;
-        r->m_dist = dist;
-        r->m_counter = counter;
-        r->m_num_extra = num_extra;
-        r->m_dist_from_out_buf_start = dist_from_out_buf_start;
-        *pIn_buf_size = pIn_buf_cur - pIn_buf_next;
-        *pOut_buf_size = pOut_buf_cur - pOut_buf_next;
-        if ((decomp_flags & (TINFL_FLAG_PARSE_ZLIB_HEADER | TINFL_FLAG_COMPUTE_ADLER32)) && (status >= 0)) {
-            const mz_uint8* ptr = pOut_buf_next;
-            size_t buf_len = *pOut_buf_size;
-            mz_uint32 i, s1 = r->m_check_adler32 & 0xffff, s2 = r->m_check_adler32 >> 16;
-            size_t block_len = buf_len % 5552;
-            while (buf_len) {
-                for (i = 0; i + 7 < block_len; i += 8, ptr += 8) {
-                    s1 += ptr[0], s2 += s1;
-                    s1 += ptr[1], s2 += s1;
-                    s1 += ptr[2], s2 += s1;
-                    s1 += ptr[3], s2 += s1;
-                    s1 += ptr[4], s2 += s1;
-                    s1 += ptr[5], s2 += s1;
-                    s1 += ptr[6], s2 += s1;
-                    s1 += ptr[7], s2 += s1;
-                }
-                for (; i < block_len; ++i)
-                    s1 += *ptr++, s2 += s1;
-                s1 %= 65521U, s2 %= 65521U;
-                buf_len -= block_len;
-                block_len = 5552;
-            }
-            r->m_check_adler32 = (s2 << 16) + s1;
-            if ((status == TINFL_STATUS_DONE) && (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) && (r->m_check_adler32 != r->m_z_adler32))
-                status = TINFL_STATUS_ADLER32_MISMATCH;
-        }
-        return status;
-    }
-
-    // Higher level helper functions.
-    void* tinfl_decompress_mem_to_heap(const void* pSrc_buf, size_t src_buf_len, size_t* pOut_len, int flags) {
-        tinfl_decompressor decomp;
-        void *pBuf = NULL, *pNew_buf;
-        size_t src_buf_ofs = 0, out_buf_capacity = 0;
-        *pOut_len = 0;
-        tinfl_init(&decomp);
-        for (;;) {
-            size_t src_buf_size = src_buf_len - src_buf_ofs, dst_buf_size = out_buf_capacity - *pOut_len, new_out_buf_capacity;
-            tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8*)pSrc_buf + src_buf_ofs, &src_buf_size, (mz_uint8*)pBuf,
-                                                   pBuf ? (mz_uint8*)pBuf + *pOut_len : NULL, &dst_buf_size,
-                                                   (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
-            if ((status < 0) || (status == TINFL_STATUS_NEEDS_MORE_INPUT)) {
-                MZ_FREE(pBuf);
-                *pOut_len = 0;
-                return NULL;
-            }
-            src_buf_ofs += src_buf_size;
-            *pOut_len += dst_buf_size;
-            if (status == TINFL_STATUS_DONE) break;
-            new_out_buf_capacity = out_buf_capacity * 2;
-            if (new_out_buf_capacity < 128) new_out_buf_capacity = 128;
-            pNew_buf = MZ_REALLOC(pBuf, new_out_buf_capacity);
-            if (!pNew_buf) {
-                MZ_FREE(pBuf);
-                *pOut_len = 0;
-                return NULL;
-            }
-            pBuf = pNew_buf;
-            out_buf_capacity = new_out_buf_capacity;
-        }
-        return pBuf;
-    }
-
-    size_t tinfl_decompress_mem_to_mem(void* pOut_buf, size_t out_buf_len, const void* pSrc_buf, size_t src_buf_len, int flags) {
-        tinfl_decompressor decomp;
-        tinfl_status status;
-        tinfl_init(&decomp);
-        status = tinfl_decompress(&decomp, (const mz_uint8*)pSrc_buf, &src_buf_len, (mz_uint8*)pOut_buf, (mz_uint8*)pOut_buf, &out_buf_len,
-                                  (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
-        return (status != TINFL_STATUS_DONE) ? TINFL_DECOMPRESS_MEM_TO_MEM_FAILED : out_buf_len;
-    }
-
-    int tinfl_decompress_mem_to_callback(const void* pIn_buf, size_t* pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void* pPut_buf_user,
-                                         int flags) {
-        int result = 0;
-        tinfl_decompressor decomp;
-        mz_uint8* pDict = (mz_uint8*)MZ_MALLOC(TINFL_LZ_DICT_SIZE);
-        size_t in_buf_ofs = 0, dict_ofs = 0;
-        if (!pDict) return TINFL_STATUS_FAILED;
-        tinfl_init(&decomp);
-        for (;;) {
-            size_t in_buf_size = *pIn_buf_size - in_buf_ofs, dst_buf_size = TINFL_LZ_DICT_SIZE - dict_ofs;
-            tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8*)pIn_buf + in_buf_ofs, &in_buf_size, pDict, pDict + dict_ofs,
-                                                   &dst_buf_size, (flags & ~(TINFL_FLAG_HAS_MORE_INPUT | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)));
-            in_buf_ofs += in_buf_size;
-            if ((dst_buf_size) && (!(*pPut_buf_func)(pDict + dict_ofs, (int)dst_buf_size, pPut_buf_user))) break;
-            if (status != TINFL_STATUS_HAS_MORE_OUTPUT) {
-                result = (status == TINFL_STATUS_DONE);
-                break;
-            }
-            dict_ofs = (dict_ofs + dst_buf_size) & (TINFL_LZ_DICT_SIZE - 1);
-        }
-        MZ_FREE(pDict);
-        *pIn_buf_size = in_buf_ofs;
-        return result;
-    }
-
-    // ------------------- Low-level Compression (independent from all decompression API's)
-
-    // Purposely making these tables static for faster init and thread safety.
-    static const mz_uint16 s_tdefl_len_sym[256] = {
-      257, 258, 259, 260, 261, 262, 263, 264, 265, 265, 266, 266, 267, 267, 268, 268, 269, 269, 269, 269, 270, 270, 270, 270, 271, 271, 271, 271, 272,
-      272, 272, 272, 273, 273, 273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 274, 274, 274, 274, 275, 275, 275, 275, 275, 275, 275, 275, 276, 276,
-      276, 276, 276, 276, 276, 276, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 278, 278, 278, 278, 278, 278, 278,
-      278, 278, 278, 278, 278, 278, 278, 278, 278, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 280, 280, 280, 280,
-      280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,
-      281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
-      282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,
-      283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 284, 284, 284, 284, 284, 284, 284, 284,
-      284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 285};
-
-    static const mz_uint8 s_tdefl_len_extra[256] = {
-      0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-      3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
-      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5,
-      5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
-      5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
-      5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0};
-
-    static const mz_uint8 s_tdefl_small_dist_sym[512] = {
-      0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9,  10, 10, 10,
-      10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12,
-      12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13,
-      13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
-      15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
-      15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
-      16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
-      16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
-      16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17,
-      17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
-      17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
-      17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
-      17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17};
-
-    static const mz_uint8 s_tdefl_small_dist_extra[512] = {
-      0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
-      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
-      5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
-      6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
-      6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
-      6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
-      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
-      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
-      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
-      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
-      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7};
-
-    static const mz_uint8 s_tdefl_large_dist_sym[128] = {
-      0,  0,  18, 19, 20, 20, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25,
-      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-      28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-      29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29};
-
-    static const mz_uint8 s_tdefl_large_dist_extra[128] = {
-      0,  0,  8,  8,  9,  9,  9,  9,  10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
-      12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
-      13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
-      13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13};
-
-    // Radix sorts tdefl_sym_freq[] array by 16-bit key m_key. Returns ptr to sorted values.
-    typedef struct
-    {
-        mz_uint16 m_key, m_sym_index;
-    } tdefl_sym_freq;
-    static tdefl_sym_freq* tdefl_radix_sort_syms(mz_uint num_syms, tdefl_sym_freq* pSyms0, tdefl_sym_freq* pSyms1) {
-        mz_uint32 total_passes = 2, pass_shift, pass, i, hist[256 * 2];
-        tdefl_sym_freq *pCur_syms = pSyms0, *pNew_syms = pSyms1;
-        MZ_CLEAR_OBJ(hist);
-        for (i = 0; i < num_syms; i++) {
-            mz_uint freq = pSyms0[i].m_key;
-            hist[freq & 0xFF]++;
-            hist[256 + ((freq >> 8) & 0xFF)]++;
-        }
-        while ((total_passes > 1) && (num_syms == hist[(total_passes - 1) * 256]))
-            total_passes--;
-        for (pass_shift = 0, pass = 0; pass < total_passes; pass++, pass_shift += 8) {
-            const mz_uint32* pHist = &hist[pass << 8];
-            mz_uint offsets[256], cur_ofs = 0;
-            for (i = 0; i < 256; i++) {
-                offsets[i] = cur_ofs;
-                cur_ofs += pHist[i];
-            }
-            for (i = 0; i < num_syms; i++)
-                pNew_syms[offsets[(pCur_syms[i].m_key >> pass_shift) & 0xFF]++] = pCur_syms[i];
-            {
-                tdefl_sym_freq* t = pCur_syms;
-                pCur_syms = pNew_syms;
-                pNew_syms = t;
-            }
-        }
-        return pCur_syms;
-    }
-
-    // tdefl_calculate_minimum_redundancy() originally written by: Alistair Moffat, alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996.
-    static void tdefl_calculate_minimum_redundancy(tdefl_sym_freq* A, int n) {
-        int root, leaf, next, avbl, used, dpth;
-        if (n == 0)
-            return;
-        else if (n == 1) {
-            A[0].m_key = 1;
-            return;
-        }
-        A[0].m_key += A[1].m_key;
-        root = 0;
-        leaf = 2;
-        for (next = 1; next < n - 1; next++) {
-            if (leaf >= n || A[root].m_key < A[leaf].m_key) {
-                A[next].m_key = A[root].m_key;
-                A[root++].m_key = (mz_uint16)next;
-            } else
-                A[next].m_key = A[leaf++].m_key;
-            if (leaf >= n || (root < next && A[root].m_key < A[leaf].m_key)) {
-                A[next].m_key = (mz_uint16)(A[next].m_key + A[root].m_key);
-                A[root++].m_key = (mz_uint16)next;
-            } else
-                A[next].m_key = (mz_uint16)(A[next].m_key + A[leaf++].m_key);
-        }
-        A[n - 2].m_key = 0;
-        for (next = n - 3; next >= 0; next--)
-            A[next].m_key = A[A[next].m_key].m_key + 1;
-        avbl = 1;
-        used = dpth = 0;
-        root = n - 2;
-        next = n - 1;
-        while (avbl > 0) {
-            while (root >= 0 && (int)A[root].m_key == dpth) {
-                used++;
-                root--;
-            }
-            while (avbl > used) {
-                A[next--].m_key = (mz_uint16)(dpth);
-                avbl--;
-            }
-            avbl = 2 * used;
-            dpth++;
-            used = 0;
-        }
-    }
-
-    // Limits canonical Huffman code table's max code size.
-    enum
-    {
-        TDEFL_MAX_SUPPORTED_HUFF_CODESIZE = 32
-    };
-    static void tdefl_huffman_enforce_max_code_size(int* pNum_codes, int code_list_len, int max_code_size) {
-        int i;
-        mz_uint32 total = 0;
-        if (code_list_len <= 1) return;
-        for (i = max_code_size + 1; i <= TDEFL_MAX_SUPPORTED_HUFF_CODESIZE; i++)
-            pNum_codes[max_code_size] += pNum_codes[i];
-        for (i = max_code_size; i > 0; i--)
-            total += (((mz_uint32)pNum_codes[i]) << (max_code_size - i));
-        while (total != (1UL << max_code_size)) {
-            pNum_codes[max_code_size]--;
-            for (i = max_code_size - 1; i > 0; i--)
-                if (pNum_codes[i]) {
-                    pNum_codes[i]--;
-                    pNum_codes[i + 1] += 2;
-                    break;
-                }
-            total--;
-        }
-    }
-
-    static void tdefl_optimize_huffman_table(tdefl_compressor* d, int table_num, int table_len, int code_size_limit, int static_table) {
-        int i, j, l, num_codes[1 + TDEFL_MAX_SUPPORTED_HUFF_CODESIZE];
-        mz_uint next_code[TDEFL_MAX_SUPPORTED_HUFF_CODESIZE + 1];
-        MZ_CLEAR_OBJ(num_codes);
-        if (static_table) {
-            for (i = 0; i < table_len; i++)
-                num_codes[d->m_huff_code_sizes[table_num][i]]++;
-        } else {
-            tdefl_sym_freq syms0[TDEFL_MAX_HUFF_SYMBOLS], syms1[TDEFL_MAX_HUFF_SYMBOLS], *pSyms;
-            int num_used_syms = 0;
-            const mz_uint16* pSym_count = &d->m_huff_count[table_num][0];
-            for (i = 0; i < table_len; i++)
-                if (pSym_count[i]) {
-                    syms0[num_used_syms].m_key = (mz_uint16)pSym_count[i];
-                    syms0[num_used_syms++].m_sym_index = (mz_uint16)i;
-                }
-
-            pSyms = tdefl_radix_sort_syms(num_used_syms, syms0, syms1);
-            tdefl_calculate_minimum_redundancy(pSyms, num_used_syms);
-
-            for (i = 0; i < num_used_syms; i++)
-                num_codes[pSyms[i].m_key]++;
-
-            tdefl_huffman_enforce_max_code_size(num_codes, num_used_syms, code_size_limit);
-
-            MZ_CLEAR_OBJ(d->m_huff_code_sizes[table_num]);
-            MZ_CLEAR_OBJ(d->m_huff_codes[table_num]);
-            for (i = 1, j = num_used_syms; i <= code_size_limit; i++)
-                for (l = num_codes[i]; l > 0; l--)
-                    d->m_huff_code_sizes[table_num][pSyms[--j].m_sym_index] = (mz_uint8)(i);
-        }
-
-        next_code[1] = 0;
-        for (j = 0, i = 2; i <= code_size_limit; i++)
-            next_code[i] = j = ((j + num_codes[i - 1]) << 1);
-
-        for (i = 0; i < table_len; i++) {
-            mz_uint rev_code = 0, code, code_size;
-            if ((code_size = d->m_huff_code_sizes[table_num][i]) == 0) continue;
-            code = next_code[code_size]++;
-            for (l = code_size; l > 0; l--, code >>= 1)
-                rev_code = (rev_code << 1) | (code & 1);
-            d->m_huff_codes[table_num][i] = (mz_uint16)rev_code;
-        }
-    }
-
-#    define TDEFL_PUT_BITS(b, l)                                                                                \
-        do {                                                                                                    \
-            mz_uint bits = b;                                                                                   \
-            mz_uint len = l;                                                                                    \
-            MZ_ASSERT(bits <= ((1U << len) - 1U));                                                              \
-            d->m_bit_buffer |= (bits << d->m_bits_in);                                                          \
-            d->m_bits_in += len;                                                                                \
-            while (d->m_bits_in >= 8) {                                                                         \
-                if (d->m_pOutput_buf < d->m_pOutput_buf_end) *d->m_pOutput_buf++ = (mz_uint8)(d->m_bit_buffer); \
-                d->m_bit_buffer >>= 8;                                                                          \
-                d->m_bits_in -= 8;                                                                              \
-            }                                                                                                   \
-        }                                                                                                       \
-        MZ_MACRO_END
-
-#    define TDEFL_RLE_PREV_CODE_SIZE()                                                                                       \
-        {                                                                                                                    \
-            if (rle_repeat_count) {                                                                                          \
-                if (rle_repeat_count < 3) {                                                                                  \
-                    d->m_huff_count[2][prev_code_size] = (mz_uint16)(d->m_huff_count[2][prev_code_size] + rle_repeat_count); \
-                    while (rle_repeat_count--)                                                                               \
-                        packed_code_sizes[num_packed_code_sizes++] = prev_code_size;                                         \
-                } else {                                                                                                     \
-                    d->m_huff_count[2][16] = (mz_uint16)(d->m_huff_count[2][16] + 1);                                        \
-                    packed_code_sizes[num_packed_code_sizes++] = 16;                                                         \
-                    packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_repeat_count - 3);                           \
-                }                                                                                                            \
-                rle_repeat_count = 0;                                                                                        \
-            }                                                                                                                \
-        }
-
-#    define TDEFL_RLE_ZERO_CODE_SIZE()                                                         \
-        {                                                                                      \
-            if (rle_z_count) {                                                                 \
-                if (rle_z_count < 3) {                                                         \
-                    d->m_huff_count[2][0] = (mz_uint16)(d->m_huff_count[2][0] + rle_z_count);  \
-                    while (rle_z_count--)                                                      \
-                        packed_code_sizes[num_packed_code_sizes++] = 0;                        \
-                } else if (rle_z_count <= 10) {                                                \
-                    d->m_huff_count[2][17] = (mz_uint16)(d->m_huff_count[2][17] + 1);          \
-                    packed_code_sizes[num_packed_code_sizes++] = 17;                           \
-                    packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 3);  \
-                } else {                                                                       \
-                    d->m_huff_count[2][18] = (mz_uint16)(d->m_huff_count[2][18] + 1);          \
-                    packed_code_sizes[num_packed_code_sizes++] = 18;                           \
-                    packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 11); \
-                }                                                                              \
-                rle_z_count = 0;                                                               \
-            }                                                                                  \
-        }
-
-    static mz_uint8 s_tdefl_packed_code_size_syms_swizzle[] = {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
-
-    static void tdefl_start_dynamic_block(tdefl_compressor* d) {
-        int num_lit_codes, num_dist_codes, num_bit_lengths;
-        mz_uint i, total_code_sizes_to_pack, num_packed_code_sizes, rle_z_count, rle_repeat_count, packed_code_sizes_index;
-        mz_uint8 code_sizes_to_pack[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1],
-          packed_code_sizes[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1], prev_code_size = 0xFF;
-
-        d->m_huff_count[0][256] = 1;
-
-        tdefl_optimize_huffman_table(d, 0, TDEFL_MAX_HUFF_SYMBOLS_0, 15, MZ_FALSE);
-        tdefl_optimize_huffman_table(d, 1, TDEFL_MAX_HUFF_SYMBOLS_1, 15, MZ_FALSE);
-
-        for (num_lit_codes = 286; num_lit_codes > 257; num_lit_codes--)
-            if (d->m_huff_code_sizes[0][num_lit_codes - 1]) break;
-        for (num_dist_codes = 30; num_dist_codes > 1; num_dist_codes--)
-            if (d->m_huff_code_sizes[1][num_dist_codes - 1]) break;
-
-        memcpy(code_sizes_to_pack, &d->m_huff_code_sizes[0][0], num_lit_codes);
-        memcpy(code_sizes_to_pack + num_lit_codes, &d->m_huff_code_sizes[1][0], num_dist_codes);
-        total_code_sizes_to_pack = num_lit_codes + num_dist_codes;
-        num_packed_code_sizes = 0;
-        rle_z_count = 0;
-        rle_repeat_count = 0;
-
-        memset(&d->m_huff_count[2][0], 0, sizeof(d->m_huff_count[2][0]) * TDEFL_MAX_HUFF_SYMBOLS_2);
-        for (i = 0; i < total_code_sizes_to_pack; i++) {
-            mz_uint8 code_size = code_sizes_to_pack[i];
-            if (!code_size) {
-                TDEFL_RLE_PREV_CODE_SIZE();
-                if (++rle_z_count == 138) {
-                    TDEFL_RLE_ZERO_CODE_SIZE();
-                }
-            } else {
-                TDEFL_RLE_ZERO_CODE_SIZE();
-                if (code_size != prev_code_size) {
-                    TDEFL_RLE_PREV_CODE_SIZE();
-                    d->m_huff_count[2][code_size] = (mz_uint16)(d->m_huff_count[2][code_size] + 1);
-                    packed_code_sizes[num_packed_code_sizes++] = code_size;
-                } else if (++rle_repeat_count == 6) {
-                    TDEFL_RLE_PREV_CODE_SIZE();
-                }
-            }
-            prev_code_size = code_size;
-        }
-        if (rle_repeat_count) {
-            TDEFL_RLE_PREV_CODE_SIZE();
-        } else {
-            TDEFL_RLE_ZERO_CODE_SIZE();
-        }
-
-        tdefl_optimize_huffman_table(d, 2, TDEFL_MAX_HUFF_SYMBOLS_2, 7, MZ_FALSE);
-
-        TDEFL_PUT_BITS(2, 2);
-
-        TDEFL_PUT_BITS(num_lit_codes - 257, 5);
-        TDEFL_PUT_BITS(num_dist_codes - 1, 5);
-
-        for (num_bit_lengths = 18; num_bit_lengths >= 0; num_bit_lengths--)
-            if (d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[num_bit_lengths]]) break;
-        num_bit_lengths = MZ_MAX(4, (num_bit_lengths + 1));
-        TDEFL_PUT_BITS(num_bit_lengths - 4, 4);
-        for (i = 0; (int)i < num_bit_lengths; i++)
-            TDEFL_PUT_BITS(d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[i]], 3);
-
-        for (packed_code_sizes_index = 0; packed_code_sizes_index < num_packed_code_sizes;) {
-            mz_uint code = packed_code_sizes[packed_code_sizes_index++];
-            MZ_ASSERT(code < TDEFL_MAX_HUFF_SYMBOLS_2);
-            TDEFL_PUT_BITS(d->m_huff_codes[2][code], d->m_huff_code_sizes[2][code]);
-            if (code >= 16) TDEFL_PUT_BITS(packed_code_sizes[packed_code_sizes_index++], "\02\03\07"[code - 16]);
-        }
-    }
-
-    static void tdefl_start_static_block(tdefl_compressor* d) {
-        mz_uint i;
-        mz_uint8* p = &d->m_huff_code_sizes[0][0];
-
-        for (i = 0; i <= 143; ++i)
-            *p++ = 8;
-        for (; i <= 255; ++i)
-            *p++ = 9;
-        for (; i <= 279; ++i)
-            *p++ = 7;
-        for (; i <= 287; ++i)
-            *p++ = 8;
-
-        memset(d->m_huff_code_sizes[1], 5, 32);
-
-        tdefl_optimize_huffman_table(d, 0, 288, 15, MZ_TRUE);
-        tdefl_optimize_huffman_table(d, 1, 32, 15, MZ_TRUE);
-
-        TDEFL_PUT_BITS(1, 2);
-    }
-
-    static const mz_uint mz_bitmasks[17] = {0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF,
-                                            0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF};
-
-#    if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS
-    static mz_bool tdefl_compress_lz_codes(tdefl_compressor* d) {
-        mz_uint flags;
-        mz_uint8* pLZ_codes;
-        mz_uint8* pOutput_buf = d->m_pOutput_buf;
-        mz_uint8* pLZ_code_buf_end = d->m_pLZ_code_buf;
-        mz_uint64 bit_buffer = d->m_bit_buffer;
-        mz_uint bits_in = d->m_bits_in;
-
-#        define TDEFL_PUT_BITS_FAST(b, l)                    \
-            {                                                \
-                bit_buffer |= (((mz_uint64)(b)) << bits_in); \
-                bits_in += (l);                              \
-            }
-
-        flags = 1;
-        for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < pLZ_code_buf_end; flags >>= 1) {
-            if (flags == 1) flags = *pLZ_codes++ | 0x100;
-
-            if (flags & 1) {
-                mz_uint s0, s1, n0, n1, sym, num_extra_bits;
-                mz_uint match_len = pLZ_codes[0], match_dist = *(const mz_uint16*)(pLZ_codes + 1);
-                pLZ_codes += 3;
-
-                MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
-                TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
-                TDEFL_PUT_BITS_FAST(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);
-
-                // This sequence coaxes MSVC into using cmov's vs. jmp's.
-                s0 = s_tdefl_small_dist_sym[match_dist & 511];
-                n0 = s_tdefl_small_dist_extra[match_dist & 511];
-                s1 = s_tdefl_large_dist_sym[match_dist >> 8];
-                n1 = s_tdefl_large_dist_extra[match_dist >> 8];
-                sym = (match_dist < 512) ? s0 : s1;
-                num_extra_bits = (match_dist < 512) ? n0 : n1;
-
-                MZ_ASSERT(d->m_huff_code_sizes[1][sym]);
-                TDEFL_PUT_BITS_FAST(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);
-                TDEFL_PUT_BITS_FAST(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);
-            } else {
-                mz_uint lit = *pLZ_codes++;
-                MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
-                TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
-
-                if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end)) {
-                    flags >>= 1;
-                    lit = *pLZ_codes++;
-                    MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
-                    TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
-
-                    if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end)) {
-                        flags >>= 1;
-                        lit = *pLZ_codes++;
-                        MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
-                        TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
-                    }
-                }
-            }
-
-            if (pOutput_buf >= d->m_pOutput_buf_end) return MZ_FALSE;
-
-            *(mz_uint64*)pOutput_buf = bit_buffer;
-            pOutput_buf += (bits_in >> 3);
-            bit_buffer >>= (bits_in & ~7);
-            bits_in &= 7;
-        }
-
-#        undef TDEFL_PUT_BITS_FAST
-
-        d->m_pOutput_buf = pOutput_buf;
-        d->m_bits_in = 0;
-        d->m_bit_buffer = 0;
-
-        while (bits_in) {
-            mz_uint32 n = MZ_MIN(bits_in, 16);
-            TDEFL_PUT_BITS((mz_uint)bit_buffer & mz_bitmasks[n], n);
-            bit_buffer >>= n;
-            bits_in -= n;
-        }
-
-        TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);
-
-        return (d->m_pOutput_buf < d->m_pOutput_buf_end);
-    }
-#    else
-static mz_bool tdefl_compress_lz_codes(tdefl_compressor* d) {
-    mz_uint flags;
-    mz_uint8* pLZ_codes;
-
-    flags = 1;
-    for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < d->m_pLZ_code_buf; flags >>= 1) {
-        if (flags == 1) flags = *pLZ_codes++ | 0x100;
-        if (flags & 1) {
-            mz_uint sym, num_extra_bits;
-            mz_uint match_len = pLZ_codes[0], match_dist = (pLZ_codes[1] | (pLZ_codes[2] << 8));
-            pLZ_codes += 3;
-
-            MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
-            TDEFL_PUT_BITS(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
-            TDEFL_PUT_BITS(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);
-
-            if (match_dist < 512) {
-                sym = s_tdefl_small_dist_sym[match_dist];
-                num_extra_bits = s_tdefl_small_dist_extra[match_dist];
-            } else {
-                sym = s_tdefl_large_dist_sym[match_dist >> 8];
-                num_extra_bits = s_tdefl_large_dist_extra[match_dist >> 8];
-            }
-            MZ_ASSERT(d->m_huff_code_sizes[1][sym]);
-            TDEFL_PUT_BITS(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);
-            TDEFL_PUT_BITS(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);
-        } else {
-            mz_uint lit = *pLZ_codes++;
-            MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
-            TDEFL_PUT_BITS(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
-        }
-    }
-
-    TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);
-
-    return (d->m_pOutput_buf < d->m_pOutput_buf_end);
-}
-#    endif  // MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS
-
-    static mz_bool tdefl_compress_block(tdefl_compressor* d, mz_bool static_block) {
-        if (static_block)
-            tdefl_start_static_block(d);
-        else
-            tdefl_start_dynamic_block(d);
-        return tdefl_compress_lz_codes(d);
-    }
-
-    static int tdefl_flush_block(tdefl_compressor* d, int flush) {
-        mz_uint saved_bit_buf, saved_bits_in;
-        mz_uint8* pSaved_output_buf;
-        mz_bool comp_block_succeeded = MZ_FALSE;
-        int n, use_raw_block = ((d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS) != 0) && (d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size;
-        mz_uint8* pOutput_buf_start = ((d->m_pPut_buf_func == NULL) && ((*d->m_pOut_buf_size - d->m_out_buf_ofs) >= TDEFL_OUT_BUF_SIZE))
-                                        ? ((mz_uint8*)d->m_pOut_buf + d->m_out_buf_ofs)
-                                        : d->m_output_buf;
-
-        d->m_pOutput_buf = pOutput_buf_start;
-        d->m_pOutput_buf_end = d->m_pOutput_buf + TDEFL_OUT_BUF_SIZE - 16;
-
-        MZ_ASSERT(!d->m_output_flush_remaining);
-        d->m_output_flush_ofs = 0;
-        d->m_output_flush_remaining = 0;
-
-        *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> d->m_num_flags_left);
-        d->m_pLZ_code_buf -= (d->m_num_flags_left == 8);
-
-        if ((d->m_flags & TDEFL_WRITE_ZLIB_HEADER) && (!d->m_block_index)) {
-            TDEFL_PUT_BITS(0x78, 8);
-            TDEFL_PUT_BITS(0x01, 8);
-        }
-
-        TDEFL_PUT_BITS(flush == TDEFL_FINISH, 1);
-
-        pSaved_output_buf = d->m_pOutput_buf;
-        saved_bit_buf = d->m_bit_buffer;
-        saved_bits_in = d->m_bits_in;
-
-        if (!use_raw_block)
-            comp_block_succeeded = tdefl_compress_block(d, (d->m_flags & TDEFL_FORCE_ALL_STATIC_BLOCKS) || (d->m_total_lz_bytes < 48));
-
-        // If the block gets expanded, forget the current contents of the output buffer and send a raw block instead.
-        if (((use_raw_block) || ((d->m_total_lz_bytes) && ((d->m_pOutput_buf - pSaved_output_buf + 1U) >= d->m_total_lz_bytes)))
-            && ((d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size)) {
-            mz_uint i;
-            d->m_pOutput_buf = pSaved_output_buf;
-            d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;
-            TDEFL_PUT_BITS(0, 2);
-            if (d->m_bits_in) {
-                TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
-            }
-            for (i = 2; i; --i, d->m_total_lz_bytes ^= 0xFFFF) {
-                TDEFL_PUT_BITS(d->m_total_lz_bytes & 0xFFFF, 16);
-            }
-            for (i = 0; i < d->m_total_lz_bytes; ++i) {
-                TDEFL_PUT_BITS(d->m_dict[(d->m_lz_code_buf_dict_pos + i) & TDEFL_LZ_DICT_SIZE_MASK], 8);
-            }
-        }
-        // Check for the extremely unlikely (if not impossible) case of the compressed block not fitting into the output buffer when using dynamic codes.
-        else if (!comp_block_succeeded) {
-            d->m_pOutput_buf = pSaved_output_buf;
-            d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;
-            tdefl_compress_block(d, MZ_TRUE);
-        }
-
-        if (flush) {
-            if (flush == TDEFL_FINISH) {
-                if (d->m_bits_in) {
-                    TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
-                }
-                if (d->m_flags & TDEFL_WRITE_ZLIB_HEADER) {
-                    mz_uint i, a = d->m_adler32;
-                    for (i = 0; i < 4; i++) {
-                        TDEFL_PUT_BITS((a >> 24) & 0xFF, 8);
-                        a <<= 8;
-                    }
-                }
-            } else {
-                mz_uint i, z = 0;
-                TDEFL_PUT_BITS(0, 3);
-                if (d->m_bits_in) {
-                    TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
-                }
-                for (i = 2; i; --i, z ^= 0xFFFF) {
-                    TDEFL_PUT_BITS(z & 0xFFFF, 16);
-                }
-            }
-        }
-
-        MZ_ASSERT(d->m_pOutput_buf < d->m_pOutput_buf_end);
-
-        memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
-        memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);
-
-        d->m_pLZ_code_buf = d->m_lz_code_buf + 1;
-        d->m_pLZ_flags = d->m_lz_code_buf;
-        d->m_num_flags_left = 8;
-        d->m_lz_code_buf_dict_pos += d->m_total_lz_bytes;
-        d->m_total_lz_bytes = 0;
-        d->m_block_index++;
-
-        if ((n = (int)(d->m_pOutput_buf - pOutput_buf_start)) != 0) {
-            if (d->m_pPut_buf_func) {
-                *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8*)d->m_pIn_buf;
-                if (!(*d->m_pPut_buf_func)(d->m_output_buf, n, d->m_pPut_buf_user)) return (d->m_prev_return_status = TDEFL_STATUS_PUT_BUF_FAILED);
-            } else if (pOutput_buf_start == d->m_output_buf) {
-                int bytes_to_copy = (int)MZ_MIN((size_t)n, (size_t)(*d->m_pOut_buf_size - d->m_out_buf_ofs));
-                memcpy((mz_uint8*)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf, bytes_to_copy);
-                d->m_out_buf_ofs += bytes_to_copy;
-                if ((n -= bytes_to_copy) != 0) {
-                    d->m_output_flush_ofs = bytes_to_copy;
-                    d->m_output_flush_remaining = n;
-                }
-            } else {
-                d->m_out_buf_ofs += n;
-            }
-        }
-
-        return d->m_output_flush_remaining;
-    }
-
-#    if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
-#        define TDEFL_READ_UNALIGNED_WORD(p) *(const mz_uint16*)(p)
-    static MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor* d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len,
-                                                mz_uint* pMatch_dist, mz_uint* pMatch_len) {
-        mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;
-        mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
-        const mz_uint16 *s = (const mz_uint16*)(d->m_dict + pos), *p, *q;
-        mz_uint16 c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]), s01 = TDEFL_READ_UNALIGNED_WORD(s);
-        MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN);
-        if (max_match_len <= match_len) return;
-        for (;;) {
-            for (;;) {
-                if (--num_probes_left == 0) return;
-#        define TDEFL_PROBE                                                                                     \
-            next_probe_pos = d->m_next[probe_pos];                                                              \
-            if ((!next_probe_pos) || ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist)) return; \
-            probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK;                                               \
-            if (TDEFL_READ_UNALIGNED_WORD(&d->m_dict[probe_pos + match_len - 1]) == c01) break;
-                TDEFL_PROBE;
-                TDEFL_PROBE;
-                TDEFL_PROBE;
-            }
-            if (!dist) break;
-            q = (const mz_uint16*)(d->m_dict + probe_pos);
-            if (TDEFL_READ_UNALIGNED_WORD(q) != s01) continue;
-            p = s;
-            probe_len = 32;
-            do {
-            } while ((TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q))
-                     && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q))
-                     && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q))
-                     && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (--probe_len > 0));
-            if (!probe_len) {
-                *pMatch_dist = dist;
-                *pMatch_len = MZ_MIN(max_match_len, TDEFL_MAX_MATCH_LEN);
-                break;
-            } else if ((probe_len = ((mz_uint)(p - s) * 2) + (mz_uint)(*(const mz_uint8*)p == *(const mz_uint8*)q)) > match_len) {
-                *pMatch_dist = dist;
-                if ((*pMatch_len = match_len = MZ_MIN(max_match_len, probe_len)) == max_match_len) break;
-                c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]);
-            }
-        }
-    }
-#    else
-static MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor* d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint* pMatch_dist,
-                                            mz_uint* pMatch_len) {
-    mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;
-    mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
-    const mz_uint8 *s = d->m_dict + pos, *p, *q;
-    mz_uint8 c0 = d->m_dict[pos + match_len], c1 = d->m_dict[pos + match_len - 1];
-    MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN);
-    if (max_match_len <= match_len) return;
-    for (;;) {
-        for (;;) {
-            if (--num_probes_left == 0) return;
-#        define TDEFL_PROBE                                                                                     \
-            next_probe_pos = d->m_next[probe_pos];                                                              \
-            if ((!next_probe_pos) || ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist)) return; \
-            probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK;                                               \
-            if ((d->m_dict[probe_pos + match_len] == c0) && (d->m_dict[probe_pos + match_len - 1] == c1)) break;
-            TDEFL_PROBE;
-            TDEFL_PROBE;
-            TDEFL_PROBE;
-        }
-        if (!dist) break;
-        p = s;
-        q = d->m_dict + probe_pos;
-        for (probe_len = 0; probe_len < max_match_len; probe_len++)
-            if (*p++ != *q++) break;
-        if (probe_len > match_len) {
-            *pMatch_dist = dist;
-            if ((*pMatch_len = match_len = probe_len) == max_match_len) return;
-            c0 = d->m_dict[pos + match_len];
-            c1 = d->m_dict[pos + match_len - 1];
-        }
-    }
-}
-#    endif  // #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
-
-#    if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
-    static mz_bool tdefl_compress_fast(tdefl_compressor* d) {
-        // Faster, minimally featured LZRW1-style match+parse loop with better register utilization. Intended for applications where raw throughput is valued more highly than ratio.
-        mz_uint lookahead_pos = d->m_lookahead_pos, lookahead_size = d->m_lookahead_size, dict_size = d->m_dict_size,
-                total_lz_bytes = d->m_total_lz_bytes, num_flags_left = d->m_num_flags_left;
-        mz_uint8 *pLZ_code_buf = d->m_pLZ_code_buf, *pLZ_flags = d->m_pLZ_flags;
-        mz_uint cur_pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;
-
-        while ((d->m_src_buf_left) || ((d->m_flush) && (lookahead_size))) {
-            const mz_uint TDEFL_COMP_FAST_LOOKAHEAD_SIZE = 4096;
-            mz_uint dst_pos = (lookahead_pos + lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;
-            mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(d->m_src_buf_left, TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size);
-            d->m_src_buf_left -= num_bytes_to_process;
-            lookahead_size += num_bytes_to_process;
-
-            while (num_bytes_to_process) {
-                mz_uint32 n = MZ_MIN(TDEFL_LZ_DICT_SIZE - dst_pos, num_bytes_to_process);
-                memcpy(d->m_dict + dst_pos, d->m_pSrc, n);
-                if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
-                    memcpy(d->m_dict + TDEFL_LZ_DICT_SIZE + dst_pos, d->m_pSrc, MZ_MIN(n, (TDEFL_MAX_MATCH_LEN - 1) - dst_pos));
-                d->m_pSrc += n;
-                dst_pos = (dst_pos + n) & TDEFL_LZ_DICT_SIZE_MASK;
-                num_bytes_to_process -= n;
-            }
-
-            dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - lookahead_size, dict_size);
-            if ((!d->m_flush) && (lookahead_size < TDEFL_COMP_FAST_LOOKAHEAD_SIZE)) break;
-
-            while (lookahead_size >= 4) {
-                mz_uint cur_match_dist, cur_match_len = 1;
-                mz_uint8* pCur_dict = d->m_dict + cur_pos;
-                mz_uint first_trigram = (*(const mz_uint32*)pCur_dict) & 0xFFFFFF;
-                mz_uint hash = (first_trigram ^ (first_trigram >> (24 - (TDEFL_LZ_HASH_BITS - 8)))) & TDEFL_LEVEL1_HASH_SIZE_MASK;
-                mz_uint probe_pos = d->m_hash[hash];
-                d->m_hash[hash] = (mz_uint16)lookahead_pos;
-
-                if (((cur_match_dist = (mz_uint16)(lookahead_pos - probe_pos)) <= dict_size)
-                    && ((*(const mz_uint32*)(d->m_dict + (probe_pos &= TDEFL_LZ_DICT_SIZE_MASK)) & 0xFFFFFF) == first_trigram)) {
-                    const mz_uint16* p = (const mz_uint16*)pCur_dict;
-                    const mz_uint16* q = (const mz_uint16*)(d->m_dict + probe_pos);
-                    mz_uint32 probe_len = 32;
-                    do {
-                    } while ((TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q))
-                             && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q))
-                             && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q))
-                             && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (--probe_len > 0));
-                    cur_match_len = ((mz_uint)(p - (const mz_uint16*)pCur_dict) * 2) + (mz_uint)(*(const mz_uint8*)p == *(const mz_uint8*)q);
-                    if (!probe_len) cur_match_len = cur_match_dist ? TDEFL_MAX_MATCH_LEN : 0;
-
-                    if ((cur_match_len < TDEFL_MIN_MATCH_LEN) || ((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U * 1024U))) {
-                        cur_match_len = 1;
-                        *pLZ_code_buf++ = (mz_uint8)first_trigram;
-                        *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
-                        d->m_huff_count[0][(mz_uint8)first_trigram]++;
-                    } else {
-                        mz_uint32 s0, s1;
-                        cur_match_len = MZ_MIN(cur_match_len, lookahead_size);
-
-                        MZ_ASSERT((cur_match_len >= TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 1) && (cur_match_dist <= TDEFL_LZ_DICT_SIZE));
-
-                        cur_match_dist--;
-
-                        pLZ_code_buf[0] = (mz_uint8)(cur_match_len - TDEFL_MIN_MATCH_LEN);
-                        *(mz_uint16*)(&pLZ_code_buf[1]) = (mz_uint16)cur_match_dist;
-                        pLZ_code_buf += 3;
-                        *pLZ_flags = (mz_uint8)((*pLZ_flags >> 1) | 0x80);
-
-                        s0 = s_tdefl_small_dist_sym[cur_match_dist & 511];
-                        s1 = s_tdefl_large_dist_sym[cur_match_dist >> 8];
-                        d->m_huff_count[1][(cur_match_dist < 512) ? s0 : s1]++;
-
-                        d->m_huff_count[0][s_tdefl_len_sym[cur_match_len - TDEFL_MIN_MATCH_LEN]]++;
-                    }
-                } else {
-                    *pLZ_code_buf++ = (mz_uint8)first_trigram;
-                    *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
-                    d->m_huff_count[0][(mz_uint8)first_trigram]++;
-                }
-
-                if (--num_flags_left == 0) {
-                    num_flags_left = 8;
-                    pLZ_flags = pLZ_code_buf++;
-                }
-
-                total_lz_bytes += cur_match_len;
-                lookahead_pos += cur_match_len;
-                dict_size = MZ_MIN(dict_size + cur_match_len, TDEFL_LZ_DICT_SIZE);
-                cur_pos = (cur_pos + cur_match_len) & TDEFL_LZ_DICT_SIZE_MASK;
-                MZ_ASSERT(lookahead_size >= cur_match_len);
-                lookahead_size -= cur_match_len;
-
-                if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) {
-                    int n;
-                    d->m_lookahead_pos = lookahead_pos;
-                    d->m_lookahead_size = lookahead_size;
-                    d->m_dict_size = dict_size;
-                    d->m_total_lz_bytes = total_lz_bytes;
-                    d->m_pLZ_code_buf = pLZ_code_buf;
-                    d->m_pLZ_flags = pLZ_flags;
-                    d->m_num_flags_left = num_flags_left;
-                    if ((n = tdefl_flush_block(d, 0)) != 0) return (n < 0) ? MZ_FALSE : MZ_TRUE;
-                    total_lz_bytes = d->m_total_lz_bytes;
-                    pLZ_code_buf = d->m_pLZ_code_buf;
-                    pLZ_flags = d->m_pLZ_flags;
-                    num_flags_left = d->m_num_flags_left;
-                }
-            }
-
-            while (lookahead_size) {
-                mz_uint8 lit = d->m_dict[cur_pos];
-
-                total_lz_bytes++;
-                *pLZ_code_buf++ = lit;
-                *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
-                if (--num_flags_left == 0) {
-                    num_flags_left = 8;
-                    pLZ_flags = pLZ_code_buf++;
-                }
-
-                d->m_huff_count[0][lit]++;
-
-                lookahead_pos++;
-                dict_size = MZ_MIN(dict_size + 1, TDEFL_LZ_DICT_SIZE);
-                cur_pos = (cur_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;
-                lookahead_size--;
-
-                if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) {
-                    int n;
-                    d->m_lookahead_pos = lookahead_pos;
-                    d->m_lookahead_size = lookahead_size;
-                    d->m_dict_size = dict_size;
-                    d->m_total_lz_bytes = total_lz_bytes;
-                    d->m_pLZ_code_buf = pLZ_code_buf;
-                    d->m_pLZ_flags = pLZ_flags;
-                    d->m_num_flags_left = num_flags_left;
-                    if ((n = tdefl_flush_block(d, 0)) != 0) return (n < 0) ? MZ_FALSE : MZ_TRUE;
-                    total_lz_bytes = d->m_total_lz_bytes;
-                    pLZ_code_buf = d->m_pLZ_code_buf;
-                    pLZ_flags = d->m_pLZ_flags;
-                    num_flags_left = d->m_num_flags_left;
-                }
-            }
-        }
-
-        d->m_lookahead_pos = lookahead_pos;
-        d->m_lookahead_size = lookahead_size;
-        d->m_dict_size = dict_size;
-        d->m_total_lz_bytes = total_lz_bytes;
-        d->m_pLZ_code_buf = pLZ_code_buf;
-        d->m_pLZ_flags = pLZ_flags;
-        d->m_num_flags_left = num_flags_left;
-        return MZ_TRUE;
-    }
-#    endif  // MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
-
-    static MZ_FORCEINLINE void tdefl_record_literal(tdefl_compressor* d, mz_uint8 lit) {
-        d->m_total_lz_bytes++;
-        *d->m_pLZ_code_buf++ = lit;
-        *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> 1);
-        if (--d->m_num_flags_left == 0) {
-            d->m_num_flags_left = 8;
-            d->m_pLZ_flags = d->m_pLZ_code_buf++;
-        }
-        d->m_huff_count[0][lit]++;
-    }
-
-    static MZ_FORCEINLINE void tdefl_record_match(tdefl_compressor* d, mz_uint match_len, mz_uint match_dist) {
-        mz_uint32 s0, s1;
-
-        MZ_ASSERT((match_len >= TDEFL_MIN_MATCH_LEN) && (match_dist >= 1) && (match_dist <= TDEFL_LZ_DICT_SIZE));
-
-        d->m_total_lz_bytes += match_len;
-
-        d->m_pLZ_code_buf[0] = (mz_uint8)(match_len - TDEFL_MIN_MATCH_LEN);
-
-        match_dist -= 1;
-        d->m_pLZ_code_buf[1] = (mz_uint8)(match_dist & 0xFF);
-        d->m_pLZ_code_buf[2] = (mz_uint8)(match_dist >> 8);
-        d->m_pLZ_code_buf += 3;
-
-        *d->m_pLZ_flags = (mz_uint8)((*d->m_pLZ_flags >> 1) | 0x80);
-        if (--d->m_num_flags_left == 0) {
-            d->m_num_flags_left = 8;
-            d->m_pLZ_flags = d->m_pLZ_code_buf++;
-        }
-
-        s0 = s_tdefl_small_dist_sym[match_dist & 511];
-        s1 = s_tdefl_large_dist_sym[(match_dist >> 8) & 127];
-        d->m_huff_count[1][(match_dist < 512) ? s0 : s1]++;
-
-        if (match_len >= TDEFL_MIN_MATCH_LEN) d->m_huff_count[0][s_tdefl_len_sym[match_len - TDEFL_MIN_MATCH_LEN]]++;
-    }
-
-    static mz_bool tdefl_compress_normal(tdefl_compressor* d) {
-        const mz_uint8* pSrc = d->m_pSrc;
-        size_t src_buf_left = d->m_src_buf_left;
-        tdefl_flush flush = d->m_flush;
-
-        while ((src_buf_left) || ((flush) && (d->m_lookahead_size))) {
-            mz_uint len_to_move, cur_match_dist, cur_match_len, cur_pos;
-            // Update dictionary and hash chains. Keeps the lookahead size equal to TDEFL_MAX_MATCH_LEN.
-            if ((d->m_lookahead_size + d->m_dict_size) >= (TDEFL_MIN_MATCH_LEN - 1)) {
-                mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK,
-                        ins_pos = d->m_lookahead_pos + d->m_lookahead_size - 2;
-                mz_uint hash =
-                  (d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK];
-                mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(src_buf_left, TDEFL_MAX_MATCH_LEN - d->m_lookahead_size);
-                const mz_uint8* pSrc_end = pSrc + num_bytes_to_process;
-                src_buf_left -= num_bytes_to_process;
-                d->m_lookahead_size += num_bytes_to_process;
-                while (pSrc != pSrc_end) {
-                    mz_uint8 c = *pSrc++;
-                    d->m_dict[dst_pos] = c;
-                    if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1)) d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;
-                    hash = ((hash << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);
-                    d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];
-                    d->m_hash[hash] = (mz_uint16)(ins_pos);
-                    dst_pos = (dst_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;
-                    ins_pos++;
-                }
-            } else {
-                while ((src_buf_left) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN)) {
-                    mz_uint8 c = *pSrc++;
-                    mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;
-                    src_buf_left--;
-                    d->m_dict[dst_pos] = c;
-                    if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1)) d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;
-                    if ((++d->m_lookahead_size + d->m_dict_size) >= TDEFL_MIN_MATCH_LEN) {
-                        mz_uint ins_pos = d->m_lookahead_pos + (d->m_lookahead_size - 1) - 2;
-                        mz_uint hash = ((d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << (TDEFL_LZ_HASH_SHIFT * 2))
-                                        ^ (d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ c)
-                                       & (TDEFL_LZ_HASH_SIZE - 1);
-                        d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];
-                        d->m_hash[hash] = (mz_uint16)(ins_pos);
-                    }
-                }
-            }
-            d->m_dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - d->m_lookahead_size, d->m_dict_size);
-            if ((!flush) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN)) break;
-
-            // Simple lazy/greedy parsing state machine.
-            len_to_move = 1;
-            cur_match_dist = 0;
-            cur_match_len = d->m_saved_match_len ? d->m_saved_match_len : (TDEFL_MIN_MATCH_LEN - 1);
-            cur_pos = d->m_lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;
-            if (d->m_flags & (TDEFL_RLE_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS)) {
-                if ((d->m_dict_size) && (!(d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS))) {
-                    mz_uint8 c = d->m_dict[(cur_pos - 1) & TDEFL_LZ_DICT_SIZE_MASK];
-                    cur_match_len = 0;
-                    while (cur_match_len < d->m_lookahead_size) {
-                        if (d->m_dict[cur_pos + cur_match_len] != c) break;
-                        cur_match_len++;
-                    }
-                    if (cur_match_len < TDEFL_MIN_MATCH_LEN)
-                        cur_match_len = 0;
-                    else
-                        cur_match_dist = 1;
-                }
-            } else {
-                tdefl_find_match(d, d->m_lookahead_pos, d->m_dict_size, d->m_lookahead_size, &cur_match_dist, &cur_match_len);
-            }
-            if (((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U * 1024U)) || (cur_pos == cur_match_dist)
-                || ((d->m_flags & TDEFL_FILTER_MATCHES) && (cur_match_len <= 5))) {
-                cur_match_dist = cur_match_len = 0;
-            }
-            if (d->m_saved_match_len) {
-                if (cur_match_len > d->m_saved_match_len) {
-                    tdefl_record_literal(d, (mz_uint8)d->m_saved_lit);
-                    if (cur_match_len >= 128) {
-                        tdefl_record_match(d, cur_match_len, cur_match_dist);
-                        d->m_saved_match_len = 0;
-                        len_to_move = cur_match_len;
-                    } else {
-                        d->m_saved_lit = d->m_dict[cur_pos];
-                        d->m_saved_match_dist = cur_match_dist;
-                        d->m_saved_match_len = cur_match_len;
-                    }
-                } else {
-                    tdefl_record_match(d, d->m_saved_match_len, d->m_saved_match_dist);
-                    len_to_move = d->m_saved_match_len - 1;
-                    d->m_saved_match_len = 0;
-                }
-            } else if (!cur_match_dist)
-                tdefl_record_literal(d, d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)]);
-            else if ((d->m_greedy_parsing) || (d->m_flags & TDEFL_RLE_MATCHES) || (cur_match_len >= 128)) {
-                tdefl_record_match(d, cur_match_len, cur_match_dist);
-                len_to_move = cur_match_len;
-            } else {
-                d->m_saved_lit = d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)];
-                d->m_saved_match_dist = cur_match_dist;
-                d->m_saved_match_len = cur_match_len;
-            }
-            // Move the lookahead forward by len_to_move bytes.
-            d->m_lookahead_pos += len_to_move;
-            MZ_ASSERT(d->m_lookahead_size >= len_to_move);
-            d->m_lookahead_size -= len_to_move;
-            d->m_dict_size = MZ_MIN(d->m_dict_size + len_to_move, TDEFL_LZ_DICT_SIZE);
-            // Check if it's time to flush the current LZ codes to the internal output buffer.
-            if ((d->m_pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])
-                || ((d->m_total_lz_bytes > 31 * 1024)
-                    && (((((mz_uint)(d->m_pLZ_code_buf - d->m_lz_code_buf) * 115) >> 7) >= d->m_total_lz_bytes)
-                        || (d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS)))) {
-                int n;
-                d->m_pSrc = pSrc;
-                d->m_src_buf_left = src_buf_left;
-                if ((n = tdefl_flush_block(d, 0)) != 0) return (n < 0) ? MZ_FALSE : MZ_TRUE;
-            }
-        }
-
-        d->m_pSrc = pSrc;
-        d->m_src_buf_left = src_buf_left;
-        return MZ_TRUE;
-    }
-
-    static tdefl_status tdefl_flush_output_buffer(tdefl_compressor* d) {
-        if (d->m_pIn_buf_size) {
-            *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8*)d->m_pIn_buf;
-        }
-
-        if (d->m_pOut_buf_size) {
-            size_t n = MZ_MIN(*d->m_pOut_buf_size - d->m_out_buf_ofs, d->m_output_flush_remaining);
-            memcpy((mz_uint8*)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf + d->m_output_flush_ofs, n);
-            d->m_output_flush_ofs += (mz_uint)n;
-            d->m_output_flush_remaining -= (mz_uint)n;
-            d->m_out_buf_ofs += n;
-
-            *d->m_pOut_buf_size = d->m_out_buf_ofs;
-        }
-
-        return (d->m_finished && !d->m_output_flush_remaining) ? TDEFL_STATUS_DONE : TDEFL_STATUS_OKAY;
-    }
-
-    tdefl_status tdefl_compress(tdefl_compressor* d, const void* pIn_buf, size_t* pIn_buf_size, void* pOut_buf, size_t* pOut_buf_size,
-                                tdefl_flush flush) {
-        if (!d) {
-            if (pIn_buf_size) *pIn_buf_size = 0;
-            if (pOut_buf_size) *pOut_buf_size = 0;
-            return TDEFL_STATUS_BAD_PARAM;
-        }
-
-        d->m_pIn_buf = pIn_buf;
-        d->m_pIn_buf_size = pIn_buf_size;
-        d->m_pOut_buf = pOut_buf;
-        d->m_pOut_buf_size = pOut_buf_size;
-        d->m_pSrc = (const mz_uint8*)(pIn_buf);
-        d->m_src_buf_left = pIn_buf_size ? *pIn_buf_size : 0;
-        d->m_out_buf_ofs = 0;
-        d->m_flush = flush;
-
-        if (((d->m_pPut_buf_func != NULL) == ((pOut_buf != NULL) || (pOut_buf_size != NULL))) || (d->m_prev_return_status != TDEFL_STATUS_OKAY)
-            || (d->m_wants_to_finish && (flush != TDEFL_FINISH)) || (pIn_buf_size && *pIn_buf_size && !pIn_buf)
-            || (pOut_buf_size && *pOut_buf_size && !pOut_buf)) {
-            if (pIn_buf_size) *pIn_buf_size = 0;
-            if (pOut_buf_size) *pOut_buf_size = 0;
-            return (d->m_prev_return_status = TDEFL_STATUS_BAD_PARAM);
-        }
-        d->m_wants_to_finish |= (flush == TDEFL_FINISH);
-
-        if ((d->m_output_flush_remaining) || (d->m_finished)) return (d->m_prev_return_status = tdefl_flush_output_buffer(d));
-
-#    if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
-        if (((d->m_flags & TDEFL_MAX_PROBES_MASK) == 1) && ((d->m_flags & TDEFL_GREEDY_PARSING_FLAG) != 0)
-            && ((d->m_flags & (TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS | TDEFL_RLE_MATCHES)) == 0)) {
-            if (!tdefl_compress_fast(d)) return d->m_prev_return_status;
-        } else
-#    endif  // #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
-        {
-            if (!tdefl_compress_normal(d)) return d->m_prev_return_status;
-        }
-
-        if ((d->m_flags & (TDEFL_WRITE_ZLIB_HEADER | TDEFL_COMPUTE_ADLER32)) && (pIn_buf))
-            d->m_adler32 = (mz_uint32)mz_adler32(d->m_adler32, (const mz_uint8*)pIn_buf, d->m_pSrc - (const mz_uint8*)pIn_buf);
-
-        if ((flush) && (!d->m_lookahead_size) && (!d->m_src_buf_left) && (!d->m_output_flush_remaining)) {
-            if (tdefl_flush_block(d, flush) < 0) return d->m_prev_return_status;
-            d->m_finished = (flush == TDEFL_FINISH);
-            if (flush == TDEFL_FULL_FLUSH) {
-                MZ_CLEAR_OBJ(d->m_hash);
-                MZ_CLEAR_OBJ(d->m_next);
-                d->m_dict_size = 0;
-            }
-        }
-
-        return (d->m_prev_return_status = tdefl_flush_output_buffer(d));
-    }
-
-    tdefl_status tdefl_compress_buffer(tdefl_compressor* d, const void* pIn_buf, size_t in_buf_size, tdefl_flush flush) {
-        MZ_ASSERT(d->m_pPut_buf_func);
-        return tdefl_compress(d, pIn_buf, &in_buf_size, NULL, NULL, flush);
-    }
-
-    tdefl_status tdefl_init(tdefl_compressor* d, tdefl_put_buf_func_ptr pPut_buf_func, void* pPut_buf_user, int flags) {
-        d->m_pPut_buf_func = pPut_buf_func;
-        d->m_pPut_buf_user = pPut_buf_user;
-        d->m_flags = (mz_uint)(flags);
-        d->m_max_probes[0] = 1 + ((flags & 0xFFF) + 2) / 3;
-        d->m_greedy_parsing = (flags & TDEFL_GREEDY_PARSING_FLAG) != 0;
-        d->m_max_probes[1] = 1 + (((flags & 0xFFF) >> 2) + 2) / 3;
-        if (!(flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG)) MZ_CLEAR_OBJ(d->m_hash);
-        d->m_lookahead_pos = d->m_lookahead_size = d->m_dict_size = d->m_total_lz_bytes = d->m_lz_code_buf_dict_pos = d->m_bits_in = 0;
-        d->m_output_flush_ofs = d->m_output_flush_remaining = d->m_finished = d->m_block_index = d->m_bit_buffer = d->m_wants_to_finish = 0;
-        d->m_pLZ_code_buf = d->m_lz_code_buf + 1;
-        d->m_pLZ_flags = d->m_lz_code_buf;
-        d->m_num_flags_left = 8;
-        d->m_pOutput_buf = d->m_output_buf;
-        d->m_pOutput_buf_end = d->m_output_buf;
-        d->m_prev_return_status = TDEFL_STATUS_OKAY;
-        d->m_saved_match_dist = d->m_saved_match_len = d->m_saved_lit = 0;
-        d->m_adler32 = 1;
-        d->m_pIn_buf = NULL;
-        d->m_pOut_buf = NULL;
-        d->m_pIn_buf_size = NULL;
-        d->m_pOut_buf_size = NULL;
-        d->m_flush = TDEFL_NO_FLUSH;
-        d->m_pSrc = NULL;
-        d->m_src_buf_left = 0;
-        d->m_out_buf_ofs = 0;
-        memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
-        memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);
-        return TDEFL_STATUS_OKAY;
-    }
-
-    tdefl_status tdefl_get_prev_return_status(tdefl_compressor* d) {
-        return d->m_prev_return_status;
-    }
-
-    mz_uint32 tdefl_get_adler32(tdefl_compressor* d) {
-        return d->m_adler32;
-    }
-
-    mz_bool tdefl_compress_mem_to_output(const void* pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void* pPut_buf_user, int flags) {
-        tdefl_compressor* pComp;
-        mz_bool succeeded;
-        if (((buf_len) && (!pBuf)) || (!pPut_buf_func)) return MZ_FALSE;
-        pComp = (tdefl_compressor*)MZ_MALLOC(sizeof(tdefl_compressor));
-        if (!pComp) return MZ_FALSE;
-        succeeded = (tdefl_init(pComp, pPut_buf_func, pPut_buf_user, flags) == TDEFL_STATUS_OKAY);
-        succeeded = succeeded && (tdefl_compress_buffer(pComp, pBuf, buf_len, TDEFL_FINISH) == TDEFL_STATUS_DONE);
-        MZ_FREE(pComp);
-        return succeeded;
-    }
-
-    typedef struct
-    {
-        size_t m_size, m_capacity;
-        mz_uint8* m_pBuf;
-        mz_bool m_expandable;
-    } tdefl_output_buffer;
-
-    static mz_bool tdefl_output_buffer_putter(const void* pBuf, int len, void* pUser) {
-        tdefl_output_buffer* p = (tdefl_output_buffer*)pUser;
-        size_t new_size = p->m_size + len;
-        if (new_size > p->m_capacity) {
-            size_t new_capacity = p->m_capacity;
-            mz_uint8* pNew_buf;
-            if (!p->m_expandable) return MZ_FALSE;
-            do {
-                new_capacity = MZ_MAX(128U, new_capacity << 1U);
-            } while (new_size > new_capacity);
-            pNew_buf = (mz_uint8*)MZ_REALLOC(p->m_pBuf, new_capacity);
-            if (!pNew_buf) return MZ_FALSE;
-            p->m_pBuf = pNew_buf;
-            p->m_capacity = new_capacity;
-        }
-        memcpy((mz_uint8*)p->m_pBuf + p->m_size, pBuf, len);
-        p->m_size = new_size;
-        return MZ_TRUE;
-    }
-
-    void* tdefl_compress_mem_to_heap(const void* pSrc_buf, size_t src_buf_len, size_t* pOut_len, int flags) {
-        tdefl_output_buffer out_buf;
-        MZ_CLEAR_OBJ(out_buf);
-        if (!pOut_len)
-            return MZ_FALSE;
-        else
-            *pOut_len = 0;
-        out_buf.m_expandable = MZ_TRUE;
-        if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags)) return NULL;
-        *pOut_len = out_buf.m_size;
-        return out_buf.m_pBuf;
-    }
-
-    size_t tdefl_compress_mem_to_mem(void* pOut_buf, size_t out_buf_len, const void* pSrc_buf, size_t src_buf_len, int flags) {
-        tdefl_output_buffer out_buf;
-        MZ_CLEAR_OBJ(out_buf);
-        if (!pOut_buf) return 0;
-        out_buf.m_pBuf = (mz_uint8*)pOut_buf;
-        out_buf.m_capacity = out_buf_len;
-        if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags)) return 0;
-        return out_buf.m_size;
-    }
-
-#    ifndef MINIZ_NO_ZLIB_APIS
-    static const mz_uint s_tdefl_num_probes[11] = {0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500};
-
-    // level may actually range from [0,10] (10 is a "hidden" max level, where we want a bit more compression and it's fine if throughput to fall off a cliff on some files).
-    mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy) {
-        mz_uint comp_flags = s_tdefl_num_probes[(level >= 0) ? MZ_MIN(10, level) : MZ_DEFAULT_LEVEL] | ((level <= 3) ? TDEFL_GREEDY_PARSING_FLAG : 0);
-        if (window_bits > 0) comp_flags |= TDEFL_WRITE_ZLIB_HEADER;
-
-        if (!level)
-            comp_flags |= TDEFL_FORCE_ALL_RAW_BLOCKS;
-        else if (strategy == MZ_FILTERED)
-            comp_flags |= TDEFL_FILTER_MATCHES;
-        else if (strategy == MZ_HUFFMAN_ONLY)
-            comp_flags &= ~TDEFL_MAX_PROBES_MASK;
-        else if (strategy == MZ_FIXED)
-            comp_flags |= TDEFL_FORCE_ALL_STATIC_BLOCKS;
-        else if (strategy == MZ_RLE)
-            comp_flags |= TDEFL_RLE_MATCHES;
-
-        return comp_flags;
-    }
-#    endif  //MINIZ_NO_ZLIB_APIS
-
-#    ifdef _MSC_VER
-#        pragma warning(push)
-#        pragma warning( \
-          disable : 4204)  // nonstandard extension used : non-constant aggregate initializer (also supported by GNU C and C99, so no big deal)
-#    endif
-
-    // Simple PNG writer function by Alex Evans, 2011. Released into the public domain: https://gist.github.com/908299, more context at
-    // http://altdevblogaday.org/2011/04/06/a-smaller-jpg-encoder/.
-    // This is actually a modification of Alex's original code so PNG files generated by this function pass pngcheck.
-    void* tdefl_write_image_to_png_file_in_memory_ex(const void* pImage, int w, int h, int num_chans, size_t* pLen_out, mz_uint level, mz_bool flip) {
-        // Using a local copy of this array here in case MINIZ_NO_ZLIB_APIS was defined.
-        static const mz_uint s_tdefl_png_num_probes[11] = {0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500};
-        tdefl_compressor* pComp = (tdefl_compressor*)MZ_MALLOC(sizeof(tdefl_compressor));
-        tdefl_output_buffer out_buf;
-        int i, bpl = w * num_chans, y, z;
-        mz_uint32 c;
-        *pLen_out = 0;
-        if (!pComp) return NULL;
-        MZ_CLEAR_OBJ(out_buf);
-        out_buf.m_expandable = MZ_TRUE;
-        out_buf.m_capacity = 57 + MZ_MAX(64, (1 + bpl) * h);
-        if (NULL == (out_buf.m_pBuf = (mz_uint8*)MZ_MALLOC(out_buf.m_capacity))) {
-            MZ_FREE(pComp);
-            return NULL;
-        }
-        // write dummy header
-        for (z = 41; z; --z)
-            tdefl_output_buffer_putter(&z, 1, &out_buf);
-        // compress image data
-        tdefl_init(pComp, tdefl_output_buffer_putter, &out_buf, s_tdefl_png_num_probes[MZ_MIN(10, level)] | TDEFL_WRITE_ZLIB_HEADER);
-        for (y = 0; y < h; ++y) {
-            tdefl_compress_buffer(pComp, &z, 1, TDEFL_NO_FLUSH);
-            tdefl_compress_buffer(pComp, (mz_uint8*)pImage + (flip ? (h - 1 - y) : y) * bpl, bpl, TDEFL_NO_FLUSH);
-        }
-        if (tdefl_compress_buffer(pComp, NULL, 0, TDEFL_FINISH) != TDEFL_STATUS_DONE) {
-            MZ_FREE(pComp);
-            MZ_FREE(out_buf.m_pBuf);
-            return NULL;
-        }
-        // write real header
-        *pLen_out = out_buf.m_size - 41;
-        {
-            static const mz_uint8 chans[] = {0x00, 0x00, 0x04, 0x02, 0x06};
-            mz_uint8 pnghdr[41] = {0x89,
-                                   0x50,
-                                   0x4e,
-                                   0x47,
-                                   0x0d,
-                                   0x0a,
-                                   0x1a,
-                                   0x0a,
-                                   0x00,
-                                   0x00,
-                                   0x00,
-                                   0x0d,
-                                   0x49,
-                                   0x48,
-                                   0x44,
-                                   0x52,
-                                   0,
-                                   0,
-                                   (mz_uint8)(w >> 8),
-                                   (mz_uint8)w,
-                                   0,
-                                   0,
-                                   (mz_uint8)(h >> 8),
-                                   (mz_uint8)h,
-                                   8,
-                                   chans[num_chans],
-                                   0,
-                                   0,
-                                   0,
-                                   0,
-                                   0,
-                                   0,
-                                   0,
-                                   (mz_uint8)(*pLen_out >> 24),
-                                   (mz_uint8)(*pLen_out >> 16),
-                                   (mz_uint8)(*pLen_out >> 8),
-                                   (mz_uint8)*pLen_out,
-                                   0x49,
-                                   0x44,
-                                   0x41,
-                                   0x54};
-            c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, pnghdr + 12, 17);
-            for (i = 0; i < 4; ++i, c <<= 8)
-                ((mz_uint8*)(pnghdr + 29))[i] = (mz_uint8)(c >> 24);
-            memcpy(out_buf.m_pBuf, pnghdr, 41);
-        }
-        // write footer (IDAT CRC-32, followed by IEND chunk)
-        if (!tdefl_output_buffer_putter("\0\0\0\0\0\0\0\0\x49\x45\x4e\x44\xae\x42\x60\x82", 16, &out_buf)) {
-            *pLen_out = 0;
-            MZ_FREE(pComp);
-            MZ_FREE(out_buf.m_pBuf);
-            return NULL;
-        }
-        c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, out_buf.m_pBuf + 41 - 4, *pLen_out + 4);
-        for (i = 0; i < 4; ++i, c <<= 8)
-            (out_buf.m_pBuf + out_buf.m_size - 16)[i] = (mz_uint8)(c >> 24);
-        // compute final size of file, grab compressed data buffer and return
-        *pLen_out += 57;
-        MZ_FREE(pComp);
-        return out_buf.m_pBuf;
-    }
-    void* tdefl_write_image_to_png_file_in_memory(const void* pImage, int w, int h, int num_chans, size_t* pLen_out) {
-        // Level 6 corresponds to TDEFL_DEFAULT_MAX_PROBES or MZ_DEFAULT_LEVEL (but we can't depend on MZ_DEFAULT_LEVEL being available in case the zlib API's where #defined out)
-        return tdefl_write_image_to_png_file_in_memory_ex(pImage, w, h, num_chans, pLen_out, 6, MZ_FALSE);
-    }
-
-#    ifdef _MSC_VER
-#        pragma warning(pop)
-#    endif
-
-    // ------------------- .ZIP archive reading
-
-#    ifndef MINIZ_NO_ARCHIVE_APIS
-
-#        ifdef MINIZ_NO_STDIO
-#            define MZ_FILE void*
-#        else
-#            include <stdio.h>
-#            include <sys/stat.h>
-
-#            if defined(_MSC_VER)
-    static FILE* mz_fopen(const char* pFilename, const char* pMode) {
-        FILE* pFile = NULL;
-        fopen_s(&pFile, pFilename, pMode);
-        return pFile;
-    }
-    static FILE* mz_freopen(const char* pPath, const char* pMode, FILE* pStream) {
-        FILE* pFile = NULL;
-        if (freopen_s(&pFile, pPath, pMode, pStream)) return NULL;
-        return pFile;
-    }
-#                ifndef MINIZ_NO_TIME
-#                    include <sys/utime.h>
-#                endif
-#                define MZ_FILE FILE
-#                define MZ_FOPEN mz_fopen
-#                define MZ_FCLOSE fclose
-#                define MZ_FREAD fread
-#                define MZ_FWRITE fwrite
-#                define MZ_FTELL64 _ftelli64
-#                define MZ_FSEEK64 _fseeki64
-#                define MZ_FILE_STAT_STRUCT _stat
-#                define MZ_FILE_STAT _stat
-#                define MZ_FFLUSH fflush
-#                define MZ_FREOPEN mz_freopen
-#                define MZ_DELETE_FILE remove
-#            elif defined(__MINGW32__)
-#                ifndef MINIZ_NO_TIME
-#                    include <sys/utime.h>
-#                endif
-#                define MZ_FILE FILE
-#                define MZ_FOPEN(f, m) fopen(f, m)
-#                define MZ_FCLOSE fclose
-#                define MZ_FREAD fread
-#                define MZ_FWRITE fwrite
-#                define MZ_FTELL64 ftello64
-#                define MZ_FSEEK64 fseeko64
-#                define MZ_FILE_STAT_STRUCT _stat
-#                define MZ_FILE_STAT _stat
-#                define MZ_FFLUSH fflush
-#                define MZ_FREOPEN(f, m, s) freopen(f, m, s)
-#                define MZ_DELETE_FILE remove
-#            elif defined(__TINYC__)
-#                ifndef MINIZ_NO_TIME
-#                    include <sys/utime.h>
-#                endif
-#                define MZ_FILE FILE
-#                define MZ_FOPEN(f, m) fopen(f, m)
-#                define MZ_FCLOSE fclose
-#                define MZ_FREAD fread
-#                define MZ_FWRITE fwrite
-#                define MZ_FTELL64 ftell
-#                define MZ_FSEEK64 fseek
-#                define MZ_FILE_STAT_STRUCT stat
-#                define MZ_FILE_STAT stat
-#                define MZ_FFLUSH fflush
-#                define MZ_FREOPEN(f, m, s) freopen(f, m, s)
-#                define MZ_DELETE_FILE remove
-#            elif defined(__GNUC__) && _LARGEFILE64_SOURCE
-#                ifndef MINIZ_NO_TIME
-#                    include <utime.h>
-#                endif
-#                define MZ_FILE FILE
-#                define MZ_FOPEN(f, m) fopen64(f, m)
-#                define MZ_FCLOSE fclose
-#                define MZ_FREAD fread
-#                define MZ_FWRITE fwrite
-#                define MZ_FTELL64 ftello64
-#                define MZ_FSEEK64 fseeko64
-#                define MZ_FILE_STAT_STRUCT stat64
-#                define MZ_FILE_STAT stat64
-#                define MZ_FFLUSH fflush
-#                define MZ_FREOPEN(p, m, s) freopen64(p, m, s)
-#                define MZ_DELETE_FILE remove
-#            else
-#                ifndef MINIZ_NO_TIME
-#                    include <utime.h>
-#                endif
-#                define MZ_FILE FILE
-#                define MZ_FOPEN(f, m) fopen(f, m)
-#                define MZ_FCLOSE fclose
-#                define MZ_FREAD fread
-#                define MZ_FWRITE fwrite
-#                define MZ_FTELL64 ftello
-#                define MZ_FSEEK64 fseeko
-#                define MZ_FILE_STAT_STRUCT stat
-#                define MZ_FILE_STAT stat
-#                define MZ_FFLUSH fflush
-#                define MZ_FREOPEN(f, m, s) freopen(f, m, s)
-#                define MZ_DELETE_FILE remove
-#            endif  // #ifdef _MSC_VER
-#        endif      // #ifdef MINIZ_NO_STDIO
-
-#        define MZ_TOLOWER(c) ((((c) >= 'A') && ((c) <= 'Z')) ? ((c) - 'A' + 'a') : (c))
-
-    // Various ZIP archive enums. To completely avoid cross platform compiler alignment and platform endian issues, miniz.c doesn't use structs for any of this stuff.
-    enum
-    {
-        // ZIP archive identifiers and record sizes
-        MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06054b50,
-        MZ_ZIP_CENTRAL_DIR_HEADER_SIG = 0x02014b50,
-        MZ_ZIP_LOCAL_DIR_HEADER_SIG = 0x04034b50,
-        MZ_ZIP_LOCAL_DIR_HEADER_SIZE = 30,
-        MZ_ZIP_CENTRAL_DIR_HEADER_SIZE = 46,
-        MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE = 22,
-        // Central directory header record offsets
-        MZ_ZIP_CDH_SIG_OFS = 0,
-        MZ_ZIP_CDH_VERSION_MADE_BY_OFS = 4,
-        MZ_ZIP_CDH_VERSION_NEEDED_OFS = 6,
-        MZ_ZIP_CDH_BIT_FLAG_OFS = 8,
-        MZ_ZIP_CDH_METHOD_OFS = 10,
-        MZ_ZIP_CDH_FILE_TIME_OFS = 12,
-        MZ_ZIP_CDH_FILE_DATE_OFS = 14,
-        MZ_ZIP_CDH_CRC32_OFS = 16,
-        MZ_ZIP_CDH_COMPRESSED_SIZE_OFS = 20,
-        MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS = 24,
-        MZ_ZIP_CDH_FILENAME_LEN_OFS = 28,
-        MZ_ZIP_CDH_EXTRA_LEN_OFS = 30,
-        MZ_ZIP_CDH_COMMENT_LEN_OFS = 32,
-        MZ_ZIP_CDH_DISK_START_OFS = 34,
-        MZ_ZIP_CDH_INTERNAL_ATTR_OFS = 36,
-        MZ_ZIP_CDH_EXTERNAL_ATTR_OFS = 38,
-        MZ_ZIP_CDH_LOCAL_HEADER_OFS = 42,
-        // Local directory header offsets
-        MZ_ZIP_LDH_SIG_OFS = 0,
-        MZ_ZIP_LDH_VERSION_NEEDED_OFS = 4,
-        MZ_ZIP_LDH_BIT_FLAG_OFS = 6,
-        MZ_ZIP_LDH_METHOD_OFS = 8,
-        MZ_ZIP_LDH_FILE_TIME_OFS = 10,
-        MZ_ZIP_LDH_FILE_DATE_OFS = 12,
-        MZ_ZIP_LDH_CRC32_OFS = 14,
-        MZ_ZIP_LDH_COMPRESSED_SIZE_OFS = 18,
-        MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS = 22,
-        MZ_ZIP_LDH_FILENAME_LEN_OFS = 26,
-        MZ_ZIP_LDH_EXTRA_LEN_OFS = 28,
-        // End of central directory offsets
-        MZ_ZIP_ECDH_SIG_OFS = 0,
-        MZ_ZIP_ECDH_NUM_THIS_DISK_OFS = 4,
-        MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS = 6,
-        MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 8,
-        MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS = 10,
-        MZ_ZIP_ECDH_CDIR_SIZE_OFS = 12,
-        MZ_ZIP_ECDH_CDIR_OFS_OFS = 16,
-        MZ_ZIP_ECDH_COMMENT_SIZE_OFS = 20,
-    };
-
-    typedef struct
-    {
-        void* m_p;
-        size_t m_size, m_capacity;
-        mz_uint m_element_size;
-    } mz_zip_array;
-
-    struct mz_zip_internal_state_tag
-    {
-        mz_zip_array m_central_dir;
-        mz_zip_array m_central_dir_offsets;
-        mz_zip_array m_sorted_central_dir_offsets;
-        MZ_FILE* m_pFile;
-        void* m_pMem;
-        size_t m_mem_size;
-        size_t m_mem_capacity;
-    };
-
-#        define MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(array_ptr, element_size) (array_ptr)->m_element_size = element_size
-#        define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index) ((element_type*)((array_ptr)->m_p))[index]
-
-    static MZ_FORCEINLINE void mz_zip_array_clear(mz_zip_archive* pZip, mz_zip_array* pArray) {
-        pZip->m_pFree(pZip->m_pAlloc_opaque, pArray->m_p);
-        memset(pArray, 0, sizeof(mz_zip_array));
-    }
-
-    static mz_bool mz_zip_array_ensure_capacity(mz_zip_archive* pZip, mz_zip_array* pArray, size_t min_new_capacity, mz_uint growing) {
-        void* pNew_p;
-        size_t new_capacity = min_new_capacity;
-        MZ_ASSERT(pArray->m_element_size);
-        if (pArray->m_capacity >= min_new_capacity) return MZ_TRUE;
-        if (growing) {
-            new_capacity = MZ_MAX(1, pArray->m_capacity);
-            while (new_capacity < min_new_capacity)
-                new_capacity *= 2;
-        }
-        if (NULL == (pNew_p = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pArray->m_p, pArray->m_element_size, new_capacity))) return MZ_FALSE;
-        pArray->m_p = pNew_p;
-        pArray->m_capacity = new_capacity;
-        return MZ_TRUE;
-    }
-
-    static MZ_FORCEINLINE mz_bool mz_zip_array_reserve(mz_zip_archive* pZip, mz_zip_array* pArray, size_t new_capacity, mz_uint growing) {
-        if (new_capacity > pArray->m_capacity) {
-            if (!mz_zip_array_ensure_capacity(pZip, pArray, new_capacity, growing)) return MZ_FALSE;
-        }
-        return MZ_TRUE;
-    }
-
-    static MZ_FORCEINLINE mz_bool mz_zip_array_resize(mz_zip_archive* pZip, mz_zip_array* pArray, size_t new_size, mz_uint growing) {
-        if (new_size > pArray->m_capacity) {
-            if (!mz_zip_array_ensure_capacity(pZip, pArray, new_size, growing)) return MZ_FALSE;
-        }
-        pArray->m_size = new_size;
-        return MZ_TRUE;
-    }
-
-    static MZ_FORCEINLINE mz_bool mz_zip_array_ensure_room(mz_zip_archive* pZip, mz_zip_array* pArray, size_t n) {
-        return mz_zip_array_reserve(pZip, pArray, pArray->m_size + n, MZ_TRUE);
-    }
-
-    static MZ_FORCEINLINE mz_bool mz_zip_array_push_back(mz_zip_archive* pZip, mz_zip_array* pArray, const void* pElements, size_t n) {
-        size_t orig_size = pArray->m_size;
-        if (!mz_zip_array_resize(pZip, pArray, orig_size + n, MZ_TRUE)) return MZ_FALSE;
-        memcpy((mz_uint8*)pArray->m_p + orig_size * pArray->m_element_size, pElements, n * pArray->m_element_size);
-        return MZ_TRUE;
-    }
-
-#        ifndef MINIZ_NO_TIME
-    static time_t mz_zip_dos_to_time_t(int dos_time, int dos_date) {
-        struct tm tm;
-        memset(&tm, 0, sizeof(tm));
-        tm.tm_isdst = -1;
-        tm.tm_year = ((dos_date >> 9) & 127) + 1980 - 1900;
-        tm.tm_mon = ((dos_date >> 5) & 15) - 1;
-        tm.tm_mday = dos_date & 31;
-        tm.tm_hour = (dos_time >> 11) & 31;
-        tm.tm_min = (dos_time >> 5) & 63;
-        tm.tm_sec = (dos_time << 1) & 62;
-        return mktime(&tm);
-    }
-
-    static void mz_zip_time_to_dos_time(time_t time, mz_uint16* pDOS_time, mz_uint16* pDOS_date) {
-#            ifdef _MSC_VER
-        struct tm tm_struct;
-        struct tm* tm = &tm_struct;
-        errno_t err = localtime_s(tm, &time);
-        if (err) {
-            *pDOS_date = 0;
-            *pDOS_time = 0;
-            return;
-        }
-#            else
-        struct tm* tm = localtime(&time);
-#            endif
-        *pDOS_time = (mz_uint16)(((tm->tm_hour) << 11) + ((tm->tm_min) << 5) + ((tm->tm_sec) >> 1));
-        *pDOS_date = (mz_uint16)(((tm->tm_year + 1900 - 1980) << 9) + ((tm->tm_mon + 1) << 5) + tm->tm_mday);
-    }
-#        endif
-
-#        ifndef MINIZ_NO_STDIO
-    static mz_bool mz_zip_get_file_modified_time(const char* pFilename, mz_uint16* pDOS_time, mz_uint16* pDOS_date) {
-#            ifdef MINIZ_NO_TIME
-        (void)pFilename;
-        *pDOS_date = *pDOS_time = 0;
-#            else
-        struct MZ_FILE_STAT_STRUCT file_stat;
-        // On Linux with x86 glibc, this call will fail on large files (>= 0x80000000 bytes) unless you compiled with _LARGEFILE64_SOURCE. Argh.
-        if (MZ_FILE_STAT(pFilename, &file_stat) != 0) return MZ_FALSE;
-        mz_zip_time_to_dos_time(file_stat.st_mtime, pDOS_time, pDOS_date);
-#            endif  // #ifdef MINIZ_NO_TIME
-        return MZ_TRUE;
-    }
-
-#            ifndef MINIZ_NO_TIME
-    static mz_bool mz_zip_set_file_times(const char* pFilename, time_t access_time, time_t modified_time) {
-        struct utimbuf t;
-        t.actime = access_time;
-        t.modtime = modified_time;
-        return !utime(pFilename, &t);
-    }
-#            endif  // #ifndef MINIZ_NO_TIME
-#        endif      // #ifndef MINIZ_NO_STDIO
-
-    static mz_bool mz_zip_reader_init_internal(mz_zip_archive* pZip, mz_uint32 flags) {
-        (void)flags;
-        if ((!pZip) || (pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID)) return MZ_FALSE;
-
-        if (!pZip->m_pAlloc) pZip->m_pAlloc = def_alloc_func;
-        if (!pZip->m_pFree) pZip->m_pFree = def_free_func;
-        if (!pZip->m_pRealloc) pZip->m_pRealloc = def_realloc_func;
-
-        pZip->m_zip_mode = MZ_ZIP_MODE_READING;
-        pZip->m_archive_size = 0;
-        pZip->m_central_directory_file_ofs = 0;
-        pZip->m_total_files = 0;
-
-        if (NULL == (pZip->m_pState = (mz_zip_internal_state*)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
-            return MZ_FALSE;
-        memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));
-        MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));
-        MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));
-        MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));
-        return MZ_TRUE;
-    }
-
-    static MZ_FORCEINLINE mz_bool mz_zip_reader_filename_less(const mz_zip_array* pCentral_dir_array, const mz_zip_array* pCentral_dir_offsets,
-                                                              mz_uint l_index, mz_uint r_index) {
-        const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;
-        const mz_uint8* pR = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, r_index));
-        mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS), r_len = MZ_READ_LE16(pR + MZ_ZIP_CDH_FILENAME_LEN_OFS);
-        mz_uint8 l = 0, r = 0;
-        pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
-        pR += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
-        pE = pL + MZ_MIN(l_len, r_len);
-        while (pL < pE) {
-            if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR))) break;
-            pL++;
-            pR++;
-        }
-        return (pL == pE) ? (l_len < r_len) : (l < r);
-    }
-
-#        define MZ_SWAP_UINT32(a, b) \
-            do {                     \
-                mz_uint32 t = a;     \
-                a = b;               \
-                b = t;               \
-            }                        \
-            MZ_MACRO_END
-
-    // Heap sort of lowercase filenames, used to help accelerate plain central directory searches by mz_zip_reader_locate_file(). (Could also use qsort(), but it could allocate memory.)
-    static void mz_zip_reader_sort_central_dir_offsets_by_filename(mz_zip_archive* pZip) {
-        mz_zip_internal_state* pState = pZip->m_pState;
-        const mz_zip_array* pCentral_dir_offsets = &pState->m_central_dir_offsets;
-        const mz_zip_array* pCentral_dir = &pState->m_central_dir;
-        mz_uint32* pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);
-        const int size = pZip->m_total_files;
-        int start = (size - 2) >> 1, end;
-        while (start >= 0) {
-            int child, root = start;
-            for (;;) {
-                if ((child = (root << 1) + 1) >= size) break;
-                child +=
-                  (((child + 1) < size) && (mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1])));
-                if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child])) break;
-                MZ_SWAP_UINT32(pIndices[root], pIndices[child]);
-                root = child;
-            }
-            start--;
-        }
-
-        end = size - 1;
-        while (end > 0) {
-            int child, root = 0;
-            MZ_SWAP_UINT32(pIndices[end], pIndices[0]);
-            for (;;) {
-                if ((child = (root << 1) + 1) >= end) break;
-                child +=
-                  (((child + 1) < end) && mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1]));
-                if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child])) break;
-                MZ_SWAP_UINT32(pIndices[root], pIndices[child]);
-                root = child;
-            }
-            end--;
-        }
-    }
-
-    static mz_bool mz_zip_reader_read_central_dir(mz_zip_archive* pZip, mz_uint32 flags) {
-        mz_uint cdir_size, num_this_disk, cdir_disk_index;
-        mz_uint64 cdir_ofs;
-        mz_int64 cur_file_ofs;
-        const mz_uint8* p;
-        mz_uint32 buf_u32[4096 / sizeof(mz_uint32)];
-        mz_uint8* pBuf = (mz_uint8*)buf_u32;
-        mz_bool sort_central_dir = ((flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0);
-        // Basic sanity checks - reject files which are too small, and check the first 4 bytes of the file to make sure a local header is there.
-        if (pZip->m_archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) return MZ_FALSE;
-        // Find the end of central directory record by scanning the file from the end towards the beginning.
-        cur_file_ofs = MZ_MAX((mz_int64)pZip->m_archive_size - (mz_int64)sizeof(buf_u32), 0);
-        for (;;) {
-            int i, n = (int)MZ_MIN(sizeof(buf_u32), pZip->m_archive_size - cur_file_ofs);
-            if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, n) != (mz_uint)n) return MZ_FALSE;
-            for (i = n - 4; i >= 0; --i)
-                if (MZ_READ_LE32(pBuf + i) == MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG) break;
-            if (i >= 0) {
-                cur_file_ofs += i;
-                break;
-            }
-            if ((!cur_file_ofs) || ((pZip->m_archive_size - cur_file_ofs) >= (0xFFFF + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE))) return MZ_FALSE;
-            cur_file_ofs = MZ_MAX(cur_file_ofs - (sizeof(buf_u32) - 3), 0);
-        }
-        // Read and verify the end of central directory record.
-        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
-            return MZ_FALSE;
-        if ((MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_SIG_OFS) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG)
-            || ((pZip->m_total_files = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS))
-                != MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS)))
-            return MZ_FALSE;
-
-        num_this_disk = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_THIS_DISK_OFS);
-        cdir_disk_index = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS);
-        if (((num_this_disk | cdir_disk_index) != 0) && ((num_this_disk != 1) || (cdir_disk_index != 1))) return MZ_FALSE;
-
-        if ((cdir_size = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_SIZE_OFS)) < pZip->m_total_files * MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) return MZ_FALSE;
-
-        cdir_ofs = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_OFS_OFS);
-        if ((cdir_ofs + (mz_uint64)cdir_size) > pZip->m_archive_size) return MZ_FALSE;
-
-        pZip->m_central_directory_file_ofs = cdir_ofs;
-
-        if (pZip->m_total_files) {
-            mz_uint i, n;
-
-            // Read the entire central directory into a heap block, and allocate another heap block to hold the unsorted central dir file record offsets, and another to hold the sorted indices.
-            if ((!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir, cdir_size, MZ_FALSE))
-                || (!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir_offsets, pZip->m_total_files, MZ_FALSE)))
-                return MZ_FALSE;
-
-            if (sort_central_dir) {
-                if (!mz_zip_array_resize(pZip, &pZip->m_pState->m_sorted_central_dir_offsets, pZip->m_total_files, MZ_FALSE)) return MZ_FALSE;
-            }
-
-            if (pZip->m_pRead(pZip->m_pIO_opaque, cdir_ofs, pZip->m_pState->m_central_dir.m_p, cdir_size) != cdir_size) return MZ_FALSE;
-
-            // Now create an index into the central directory file records, do some basic sanity checking on each record, and check for zip64 entries (which are not yet supported).
-            p = (const mz_uint8*)pZip->m_pState->m_central_dir.m_p;
-            for (n = cdir_size, i = 0; i < pZip->m_total_files; ++i) {
-                mz_uint total_header_size, comp_size, decomp_size, disk_index;
-                if ((n < MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) || (MZ_READ_LE32(p) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG)) return MZ_FALSE;
-                MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, i) =
-                  (mz_uint32)(p - (const mz_uint8*)pZip->m_pState->m_central_dir.m_p);
-                if (sort_central_dir) MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_sorted_central_dir_offsets, mz_uint32, i) = i;
-                comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
-                decomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
-                if (((!MZ_READ_LE32(p + MZ_ZIP_CDH_METHOD_OFS)) && (decomp_size != comp_size)) || (decomp_size && !comp_size)
-                    || (decomp_size == 0xFFFFFFFF) || (comp_size == 0xFFFFFFFF))
-                    return MZ_FALSE;
-                disk_index = MZ_READ_LE16(p + MZ_ZIP_CDH_DISK_START_OFS);
-                if ((disk_index != num_this_disk) && (disk_index != 1)) return MZ_FALSE;
-                if (((mz_uint64)MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS) + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + comp_size) > pZip->m_archive_size)
-                    return MZ_FALSE;
-                if ((total_header_size = MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS)
-                                         + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS))
-                    > n)
-                    return MZ_FALSE;
-                n -= total_header_size;
-                p += total_header_size;
-            }
-        }
-
-        if (sort_central_dir) mz_zip_reader_sort_central_dir_offsets_by_filename(pZip);
-
-        return MZ_TRUE;
-    }
-
-    mz_bool mz_zip_reader_init(mz_zip_archive* pZip, mz_uint64 size, mz_uint32 flags) {
-        if ((!pZip) || (!pZip->m_pRead)) return MZ_FALSE;
-        if (!mz_zip_reader_init_internal(pZip, flags)) return MZ_FALSE;
-        pZip->m_archive_size = size;
-        if (!mz_zip_reader_read_central_dir(pZip, flags)) {
-            mz_zip_reader_end(pZip);
-            return MZ_FALSE;
-        }
-        return MZ_TRUE;
-    }
-
-    static size_t mz_zip_mem_read_func(void* pOpaque, mz_uint64 file_ofs, void* pBuf, size_t n) {
-        mz_zip_archive* pZip = (mz_zip_archive*)pOpaque;
-        size_t s = (file_ofs >= pZip->m_archive_size) ? 0 : (size_t)MZ_MIN(pZip->m_archive_size - file_ofs, n);
-        memcpy(pBuf, (const mz_uint8*)pZip->m_pState->m_pMem + file_ofs, s);
-        return s;
-    }
-
-    mz_bool mz_zip_reader_init_mem(mz_zip_archive* pZip, const void* pMem, size_t size, mz_uint32 flags) {
-        if (!mz_zip_reader_init_internal(pZip, flags)) return MZ_FALSE;
-        pZip->m_archive_size = size;
-        pZip->m_pRead = mz_zip_mem_read_func;
-        pZip->m_pIO_opaque = pZip;
-#        ifdef __cplusplus
-        pZip->m_pState->m_pMem = const_cast<void*>(pMem);
-#        else
-        pZip->m_pState->m_pMem = (void*)pMem;
-#        endif
-        pZip->m_pState->m_mem_size = size;
-        if (!mz_zip_reader_read_central_dir(pZip, flags)) {
-            mz_zip_reader_end(pZip);
-            return MZ_FALSE;
-        }
-        return MZ_TRUE;
-    }
-
-#        ifndef MINIZ_NO_STDIO
-    static size_t mz_zip_file_read_func(void* pOpaque, mz_uint64 file_ofs, void* pBuf, size_t n) {
-        mz_zip_archive* pZip = (mz_zip_archive*)pOpaque;
-        mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
-        if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
-            return 0;
-        return MZ_FREAD(pBuf, 1, n, pZip->m_pState->m_pFile);
-    }
-
-    mz_bool mz_zip_reader_init_file(mz_zip_archive* pZip, const char* pFilename, mz_uint32 flags) {
-        mz_uint64 file_size;
-        MZ_FILE* pFile = MZ_FOPEN(pFilename, "rb");
-        if (!pFile) return MZ_FALSE;
-        if (MZ_FSEEK64(pFile, 0, SEEK_END)) {
-            MZ_FCLOSE(pFile);
-            return MZ_FALSE;
-        }
-        file_size = MZ_FTELL64(pFile);
-        if (!mz_zip_reader_init_internal(pZip, flags)) {
-            MZ_FCLOSE(pFile);
-            return MZ_FALSE;
-        }
-        pZip->m_pRead = mz_zip_file_read_func;
-        pZip->m_pIO_opaque = pZip;
-        pZip->m_pState->m_pFile = pFile;
-        pZip->m_archive_size = file_size;
-        if (!mz_zip_reader_read_central_dir(pZip, flags)) {
-            mz_zip_reader_end(pZip);
-            return MZ_FALSE;
-        }
-        return MZ_TRUE;
-    }
-#        endif  // #ifndef MINIZ_NO_STDIO
-
-    mz_uint mz_zip_reader_get_num_files(mz_zip_archive* pZip) {
-        return pZip ? pZip->m_total_files : 0;
-    }
-
-    static MZ_FORCEINLINE const mz_uint8* mz_zip_reader_get_cdh(mz_zip_archive* pZip, mz_uint file_index) {
-        if ((!pZip) || (!pZip->m_pState) || (file_index >= pZip->m_total_files) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING)) return NULL;
-        return &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8,
-                                     MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));
-    }
-
-    mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive* pZip, mz_uint file_index) {
-        mz_uint m_bit_flag;
-        const mz_uint8* p = mz_zip_reader_get_cdh(pZip, file_index);
-        if (!p) return MZ_FALSE;
-        m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
-        return (m_bit_flag & 1);
-    }
-
-    mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive* pZip, mz_uint file_index) {
-        mz_uint filename_len, external_attr;
-        const mz_uint8* p = mz_zip_reader_get_cdh(pZip, file_index);
-        if (!p) return MZ_FALSE;
-
-        // First see if the filename ends with a '/' character.
-        filename_len = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
-        if (filename_len) {
-            if (*(p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_len - 1) == '/') return MZ_TRUE;
-        }
-
-        // Bugfix: This code was also checking if the internal attribute was non-zero, which wasn't correct.
-        // Most/all zip writers (hopefully) set DOS file/directory attributes in the low 16-bits, so check for the DOS directory flag and ignore the source OS ID in the created by field.
-        // FIXME: Remove this check? Is it necessary - we already check the filename.
-        external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
-        if ((external_attr & 0x10) != 0) return MZ_TRUE;
-
-        return MZ_FALSE;
-    }
-
-    mz_bool mz_zip_reader_file_stat(mz_zip_archive* pZip, mz_uint file_index, mz_zip_archive_file_stat* pStat) {
-        mz_uint n;
-        const mz_uint8* p = mz_zip_reader_get_cdh(pZip, file_index);
-        if ((!p) || (!pStat)) return MZ_FALSE;
-
-        // Unpack the central directory record.
-        pStat->m_file_index = file_index;
-        pStat->m_central_dir_ofs = MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index);
-        pStat->m_version_made_by = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS);
-        pStat->m_version_needed = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_NEEDED_OFS);
-        pStat->m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
-        pStat->m_method = MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS);
-#        ifndef MINIZ_NO_TIME
-        pStat->m_time = mz_zip_dos_to_time_t(MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_TIME_OFS), MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_DATE_OFS));
-#        endif
-        pStat->m_crc32 = MZ_READ_LE32(p + MZ_ZIP_CDH_CRC32_OFS);
-        pStat->m_comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
-        pStat->m_uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
-        pStat->m_internal_attr = MZ_READ_LE16(p + MZ_ZIP_CDH_INTERNAL_ATTR_OFS);
-        pStat->m_external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
-        pStat->m_local_header_ofs = MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS);
-
-        // Copy as much of the filename and comment as possible.
-        n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
-        n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE - 1);
-        memcpy(pStat->m_filename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
-        pStat->m_filename[n] = '\0';
-
-        n = MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS);
-        n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE - 1);
-        pStat->m_comment_size = n;
-        memcpy(pStat->m_comment,
-               p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS), n);
-        pStat->m_comment[n] = '\0';
-
-        return MZ_TRUE;
-    }
-
-    mz_uint mz_zip_reader_get_filename(mz_zip_archive* pZip, mz_uint file_index, char* pFilename, mz_uint filename_buf_size) {
-        mz_uint n;
-        const mz_uint8* p = mz_zip_reader_get_cdh(pZip, file_index);
-        if (!p) {
-            if (filename_buf_size) pFilename[0] = '\0';
-            return 0;
-        }
-        n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
-        if (filename_buf_size) {
-            n = MZ_MIN(n, filename_buf_size - 1);
-            memcpy(pFilename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
-            pFilename[n] = '\0';
-        }
-        return n + 1;
-    }
-
-    static MZ_FORCEINLINE mz_bool mz_zip_reader_string_equal(const char* pA, const char* pB, mz_uint len, mz_uint flags) {
-        mz_uint i;
-        if (flags & MZ_ZIP_FLAG_CASE_SENSITIVE) return 0 == memcmp(pA, pB, len);
-        for (i = 0; i < len; ++i)
-            if (MZ_TOLOWER(pA[i]) != MZ_TOLOWER(pB[i])) return MZ_FALSE;
-        return MZ_TRUE;
-    }
-
-    static MZ_FORCEINLINE int mz_zip_reader_filename_compare(const mz_zip_array* pCentral_dir_array, const mz_zip_array* pCentral_dir_offsets,
-                                                             mz_uint l_index, const char* pR, mz_uint r_len) {
-        const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;
-        mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS);
-        mz_uint8 l = 0, r = 0;
-        pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
-        pE = pL + MZ_MIN(l_len, r_len);
-        while (pL < pE) {
-            if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR))) break;
-            pL++;
-            pR++;
-        }
-        return (pL == pE) ? (int)(l_len - r_len) : (l - r);
-    }
-
-    static int mz_zip_reader_locate_file_binary_search(mz_zip_archive* pZip, const char* pFilename) {
-        mz_zip_internal_state* pState = pZip->m_pState;
-        const mz_zip_array* pCentral_dir_offsets = &pState->m_central_dir_offsets;
-        const mz_zip_array* pCentral_dir = &pState->m_central_dir;
-        mz_uint32* pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);
-        const int size = pZip->m_total_files;
-        const mz_uint filename_len = (mz_uint)strlen(pFilename);
-        int l = 0, h = size - 1;
-        while (l <= h) {
-            int m = (l + h) >> 1, file_index = pIndices[m],
-                comp = mz_zip_reader_filename_compare(pCentral_dir, pCentral_dir_offsets, file_index, pFilename, filename_len);
-            if (!comp)
-                return file_index;
-            else if (comp < 0)
-                l = m + 1;
-            else
-                h = m - 1;
-        }
-        return -1;
-    }
-
-    int mz_zip_reader_locate_file(mz_zip_archive* pZip, const char* pName, const char* pComment, mz_uint flags) {
-        mz_uint file_index;
-        size_t name_len, comment_len;
-        if ((!pZip) || (!pZip->m_pState) || (!pName) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING)) return -1;
-        if (((flags & (MZ_ZIP_FLAG_IGNORE_PATH | MZ_ZIP_FLAG_CASE_SENSITIVE)) == 0) && (!pComment)
-            && (pZip->m_pState->m_sorted_central_dir_offsets.m_size))
-            return mz_zip_reader_locate_file_binary_search(pZip, pName);
-        name_len = strlen(pName);
-        if (name_len > 0xFFFF) return -1;
-        comment_len = pComment ? strlen(pComment) : 0;
-        if (comment_len > 0xFFFF) return -1;
-        for (file_index = 0; file_index < pZip->m_total_files; file_index++) {
-            const mz_uint8* pHeader = &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8,
-                                                            MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));
-            mz_uint filename_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_FILENAME_LEN_OFS);
-            const char* pFilename = (const char*)pHeader + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
-            if (filename_len < name_len) continue;
-            if (comment_len) {
-                mz_uint file_extra_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_EXTRA_LEN_OFS),
-                        file_comment_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_COMMENT_LEN_OFS);
-                const char* pFile_comment = pFilename + filename_len + file_extra_len;
-                if ((file_comment_len != comment_len) || (!mz_zip_reader_string_equal(pComment, pFile_comment, file_comment_len, flags))) continue;
-            }
-            if ((flags & MZ_ZIP_FLAG_IGNORE_PATH) && (filename_len)) {
-                int ofs = filename_len - 1;
-                do {
-                    if ((pFilename[ofs] == '/') || (pFilename[ofs] == '\\') || (pFilename[ofs] == ':')) break;
-                } while (--ofs >= 0);
-                ofs++;
-                pFilename += ofs;
-                filename_len -= ofs;
-            }
-            if ((filename_len == name_len) && (mz_zip_reader_string_equal(pName, pFilename, filename_len, flags))) return file_index;
-        }
-        return -1;
-    }
-
-    mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive* pZip, mz_uint file_index, void* pBuf, size_t buf_size, mz_uint flags,
-                                                  void* pUser_read_buf, size_t user_read_buf_size) {
-        int status = TINFL_STATUS_DONE;
-        mz_uint64 needed_size, cur_file_ofs, comp_remaining, out_buf_ofs = 0, read_buf_size, read_buf_ofs = 0, read_buf_avail;
-        mz_zip_archive_file_stat file_stat;
-        void* pRead_buf;
-        mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
-        mz_uint8* pLocal_header = (mz_uint8*)local_header_u32;
-        tinfl_decompressor inflator;
-
-        if ((buf_size) && (!pBuf)) return MZ_FALSE;
-
-        if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat)) return MZ_FALSE;
-
-        // Empty file, or a directory (but not always a directory - I've seen odd zips with directories that have compressed data which inflates to 0 bytes)
-        if (!file_stat.m_comp_size) return MZ_TRUE;
-
-        // Entry is a subdirectory (I've seen old zips with dir entries which have compressed deflate data which inflates to 0 bytes, but these entries claim to uncompress to 512 bytes in the headers).
-        // I'm torn how to handle this case - should it fail instead?
-        if (mz_zip_reader_is_file_a_directory(pZip, file_index)) return MZ_TRUE;
-
-        // Encryption and patch files are not supported.
-        if (file_stat.m_bit_flag & (1 | 32)) return MZ_FALSE;
-
-        // This function only supports stored and deflate.
-        if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED)) return MZ_FALSE;
-
-        // Ensure supplied output buffer is large enough.
-        needed_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? file_stat.m_comp_size : file_stat.m_uncomp_size;
-        if (buf_size < needed_size) return MZ_FALSE;
-
-        // Read and parse the local directory entry.
-        cur_file_ofs = file_stat.m_local_header_ofs;
-        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
-            return MZ_FALSE;
-        if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG) return MZ_FALSE;
-
-        cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS)
-                        + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
-        if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size) return MZ_FALSE;
-
-        if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method)) {
-            // The file is stored or the caller has requested the compressed data.
-            if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, (size_t)needed_size) != needed_size) return MZ_FALSE;
-            return ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) != 0)
-                   || (mz_crc32(MZ_CRC32_INIT, (const mz_uint8*)pBuf, (size_t)file_stat.m_uncomp_size) == file_stat.m_crc32);
-        }
-
-        // Decompress the file either directly from memory or from a file input buffer.
-        tinfl_init(&inflator);
-
-        if (pZip->m_pState->m_pMem) {
-            // Read directly from the archive in memory.
-            pRead_buf = (mz_uint8*)pZip->m_pState->m_pMem + cur_file_ofs;
-            read_buf_size = read_buf_avail = file_stat.m_comp_size;
-            comp_remaining = 0;
-        } else if (pUser_read_buf) {
-            // Use a user provided read buffer.
-            if (!user_read_buf_size) return MZ_FALSE;
-            pRead_buf = (mz_uint8*)pUser_read_buf;
-            read_buf_size = user_read_buf_size;
-            read_buf_avail = 0;
-            comp_remaining = file_stat.m_comp_size;
-        } else {
-            // Temporarily allocate a read buffer.
-            read_buf_size = MZ_MIN(file_stat.m_comp_size, MZ_ZIP_MAX_IO_BUF_SIZE);
-#        ifdef _MSC_VER
-            if (((0, sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))
-#        else
-            if (((sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))
-#        endif
-                return MZ_FALSE;
-            if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size))) return MZ_FALSE;
-            read_buf_avail = 0;
-            comp_remaining = file_stat.m_comp_size;
-        }
-
-        do {
-            size_t in_buf_size, out_buf_size = (size_t)(file_stat.m_uncomp_size - out_buf_ofs);
-            if ((!read_buf_avail) && (!pZip->m_pState->m_pMem)) {
-                read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
-                if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail) {
-                    status = TINFL_STATUS_FAILED;
-                    break;
-                }
-                cur_file_ofs += read_buf_avail;
-                comp_remaining -= read_buf_avail;
-                read_buf_ofs = 0;
-            }
-            in_buf_size = (size_t)read_buf_avail;
-            status = tinfl_decompress(&inflator, (mz_uint8*)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8*)pBuf, (mz_uint8*)pBuf + out_buf_ofs,
-                                      &out_buf_size, TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF | (comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0));
-            read_buf_avail -= in_buf_size;
-            read_buf_ofs += in_buf_size;
-            out_buf_ofs += out_buf_size;
-        } while (status == TINFL_STATUS_NEEDS_MORE_INPUT);
-
-        if (status == TINFL_STATUS_DONE) {
-            // Make sure the entire file was decompressed, and check its CRC.
-            if ((out_buf_ofs != file_stat.m_uncomp_size)
-                || (mz_crc32(MZ_CRC32_INIT, (const mz_uint8*)pBuf, (size_t)file_stat.m_uncomp_size) != file_stat.m_crc32))
-                status = TINFL_STATUS_FAILED;
-        }
-
-        if ((!pZip->m_pState->m_pMem) && (!pUser_read_buf)) pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
-
-        return status == TINFL_STATUS_DONE;
-    }
-
-    mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive* pZip, const char* pFilename, void* pBuf, size_t buf_size, mz_uint flags,
-                                                       void* pUser_read_buf, size_t user_read_buf_size) {
-        int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);
-        if (file_index < 0) return MZ_FALSE;
-        return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size, flags, pUser_read_buf, user_read_buf_size);
-    }
-
-    mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive* pZip, mz_uint file_index, void* pBuf, size_t buf_size, mz_uint flags) {
-        return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size, flags, NULL, 0);
-    }
-
-    mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive* pZip, const char* pFilename, void* pBuf, size_t buf_size, mz_uint flags) {
-        return mz_zip_reader_extract_file_to_mem_no_alloc(pZip, pFilename, pBuf, buf_size, flags, NULL, 0);
-    }
-
-    void* mz_zip_reader_extract_to_heap(mz_zip_archive* pZip, mz_uint file_index, size_t* pSize, mz_uint flags) {
-        mz_uint64 comp_size, uncomp_size, alloc_size;
-        const mz_uint8* p = mz_zip_reader_get_cdh(pZip, file_index);
-        void* pBuf;
-
-        if (pSize) *pSize = 0;
-        if (!p) return NULL;
-
-        comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
-        uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
-
-        alloc_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? comp_size : uncomp_size;
-#        ifdef _MSC_VER
-        if (((0, sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))
-#        else
-        if (((sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))
-#        endif
-            return NULL;
-        if (NULL == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)alloc_size))) return NULL;
-
-        if (!mz_zip_reader_extract_to_mem(pZip, file_index, pBuf, (size_t)alloc_size, flags)) {
-            pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
-            return NULL;
-        }
-
-        if (pSize) *pSize = (size_t)alloc_size;
-        return pBuf;
-    }
-
-    void* mz_zip_reader_extract_file_to_heap(mz_zip_archive* pZip, const char* pFilename, size_t* pSize, mz_uint flags) {
-        int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);
-        if (file_index < 0) {
-            if (pSize) *pSize = 0;
-            return MZ_FALSE;
-        }
-        return mz_zip_reader_extract_to_heap(pZip, file_index, pSize, flags);
-    }
-
-    mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive* pZip, mz_uint file_index, mz_file_write_func pCallback, void* pOpaque, mz_uint flags) {
-        int status = TINFL_STATUS_DONE;
-        mz_uint file_crc32 = MZ_CRC32_INIT;
-        mz_uint64 read_buf_size, read_buf_ofs = 0, read_buf_avail, comp_remaining, out_buf_ofs = 0, cur_file_ofs;
-        mz_zip_archive_file_stat file_stat;
-        void* pRead_buf = NULL;
-        void* pWrite_buf = NULL;
-        mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
-        mz_uint8* pLocal_header = (mz_uint8*)local_header_u32;
-
-        if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat)) return MZ_FALSE;
-
-        // Empty file, or a directory (but not always a directory - I've seen odd zips with directories that have compressed data which inflates to 0 bytes)
-        if (!file_stat.m_comp_size) return MZ_TRUE;
-
-        // Entry is a subdirectory (I've seen old zips with dir entries which have compressed deflate data which inflates to 0 bytes, but these entries claim to uncompress to 512 bytes in the headers).
-        // I'm torn how to handle this case - should it fail instead?
-        if (mz_zip_reader_is_file_a_directory(pZip, file_index)) return MZ_TRUE;
-
-        // Encryption and patch files are not supported.
-        if (file_stat.m_bit_flag & (1 | 32)) return MZ_FALSE;
-
-        // This function only supports stored and deflate.
-        if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED)) return MZ_FALSE;
-
-        // Read and parse the local directory entry.
-        cur_file_ofs = file_stat.m_local_header_ofs;
-        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
-            return MZ_FALSE;
-        if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG) return MZ_FALSE;
-
-        cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS)
-                        + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
-        if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size) return MZ_FALSE;
-
-        // Decompress the file either directly from memory or from a file input buffer.
-        if (pZip->m_pState->m_pMem) {
-            pRead_buf = (mz_uint8*)pZip->m_pState->m_pMem + cur_file_ofs;
-            read_buf_size = read_buf_avail = file_stat.m_comp_size;
-            comp_remaining = 0;
-        } else {
-            read_buf_size = MZ_MIN(file_stat.m_comp_size, MZ_ZIP_MAX_IO_BUF_SIZE);
-            if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size))) return MZ_FALSE;
-            read_buf_avail = 0;
-            comp_remaining = file_stat.m_comp_size;
-        }
-
-        if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method)) {
-            // The file is stored or the caller has requested the compressed data.
-            if (pZip->m_pState->m_pMem) {
-#        ifdef _MSC_VER
-                if (((0, sizeof(size_t) == sizeof(mz_uint32))) && (file_stat.m_comp_size > 0xFFFFFFFF))
-#        else
-                if (((sizeof(size_t) == sizeof(mz_uint32))) && (file_stat.m_comp_size > 0xFFFFFFFF))
-#        endif
-                    return MZ_FALSE;
-                if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)file_stat.m_comp_size) != file_stat.m_comp_size)
-                    status = TINFL_STATUS_FAILED;
-                else if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
-                    file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8*)pRead_buf, (size_t)file_stat.m_comp_size);
-                cur_file_ofs += file_stat.m_comp_size;
-                out_buf_ofs += file_stat.m_comp_size;
-                comp_remaining = 0;
-            } else {
-                while (comp_remaining) {
-                    read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
-                    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail) {
-                        status = TINFL_STATUS_FAILED;
-                        break;
-                    }
-
-                    if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
-                        file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8*)pRead_buf, (size_t)read_buf_avail);
-
-                    if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail) {
-                        status = TINFL_STATUS_FAILED;
-                        break;
-                    }
-                    cur_file_ofs += read_buf_avail;
-                    out_buf_ofs += read_buf_avail;
-                    comp_remaining -= read_buf_avail;
-                }
-            }
-        } else {
-            tinfl_decompressor inflator;
-            tinfl_init(&inflator);
-
-            if (NULL == (pWrite_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, TINFL_LZ_DICT_SIZE)))
-                status = TINFL_STATUS_FAILED;
-            else {
-                do {
-                    mz_uint8* pWrite_buf_cur = (mz_uint8*)pWrite_buf + (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
-                    size_t in_buf_size, out_buf_size = TINFL_LZ_DICT_SIZE - (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
-                    if ((!read_buf_avail) && (!pZip->m_pState->m_pMem)) {
-                        read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
-                        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail) {
-                            status = TINFL_STATUS_FAILED;
-                            break;
-                        }
-                        cur_file_ofs += read_buf_avail;
-                        comp_remaining -= read_buf_avail;
-                        read_buf_ofs = 0;
-                    }
-
-                    in_buf_size = (size_t)read_buf_avail;
-                    status = tinfl_decompress(&inflator, (const mz_uint8*)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8*)pWrite_buf,
-                                              pWrite_buf_cur, &out_buf_size, comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0);
-                    read_buf_avail -= in_buf_size;
-                    read_buf_ofs += in_buf_size;
-
-                    if (out_buf_size) {
-                        if (pCallback(pOpaque, out_buf_ofs, pWrite_buf_cur, out_buf_size) != out_buf_size) {
-                            status = TINFL_STATUS_FAILED;
-                            break;
-                        }
-                        file_crc32 = (mz_uint32)mz_crc32(file_crc32, pWrite_buf_cur, out_buf_size);
-                        if ((out_buf_ofs += out_buf_size) > file_stat.m_uncomp_size) {
-                            status = TINFL_STATUS_FAILED;
-                            break;
-                        }
-                    }
-                } while ((status == TINFL_STATUS_NEEDS_MORE_INPUT) || (status == TINFL_STATUS_HAS_MORE_OUTPUT));
-            }
-        }
-
-        if ((status == TINFL_STATUS_DONE) && (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))) {
-            // Make sure the entire file was decompressed, and check its CRC.
-            if ((out_buf_ofs != file_stat.m_uncomp_size) || (file_crc32 != file_stat.m_crc32)) status = TINFL_STATUS_FAILED;
-        }
-
-        if (!pZip->m_pState->m_pMem) pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
-        if (pWrite_buf) pZip->m_pFree(pZip->m_pAlloc_opaque, pWrite_buf);
-
-        return status == TINFL_STATUS_DONE;
-    }
-
-    mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive* pZip, const char* pFilename, mz_file_write_func pCallback, void* pOpaque,
-                                                   mz_uint flags) {
-        int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);
-        if (file_index < 0) return MZ_FALSE;
-        return mz_zip_reader_extract_to_callback(pZip, file_index, pCallback, pOpaque, flags);
-    }
-
-#        ifndef MINIZ_NO_STDIO
-    static size_t mz_zip_file_write_callback(void* pOpaque, mz_uint64 ofs, const void* pBuf, size_t n) {
-        (void)ofs;
-        return MZ_FWRITE(pBuf, 1, n, (MZ_FILE*)pOpaque);
-    }
-
-    mz_bool mz_zip_reader_extract_to_file(mz_zip_archive* pZip, mz_uint file_index, const char* pDst_filename, mz_uint flags) {
-        mz_bool status;
-        mz_zip_archive_file_stat file_stat;
-        MZ_FILE* pFile;
-        if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat)) return MZ_FALSE;
-        pFile = MZ_FOPEN(pDst_filename, "wb");
-        if (!pFile) return MZ_FALSE;
-        status = mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_file_write_callback, pFile, flags);
-        if (MZ_FCLOSE(pFile) == EOF) return MZ_FALSE;
-#            ifndef MINIZ_NO_TIME
-        if (status) mz_zip_set_file_times(pDst_filename, file_stat.m_time, file_stat.m_time);
-#            endif
-        return status;
-    }
-#        endif  // #ifndef MINIZ_NO_STDIO
-
-    mz_bool mz_zip_reader_end(mz_zip_archive* pZip) {
-        if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING)) return MZ_FALSE;
-
-        if (pZip->m_pState) {
-            mz_zip_internal_state* pState = pZip->m_pState;
-            pZip->m_pState = NULL;
-            mz_zip_array_clear(pZip, &pState->m_central_dir);
-            mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
-            mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);
-
-#        ifndef MINIZ_NO_STDIO
-            if (pState->m_pFile) {
-                MZ_FCLOSE(pState->m_pFile);
-                pState->m_pFile = NULL;
-            }
-#        endif  // #ifndef MINIZ_NO_STDIO
-
-            pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
-        }
-        pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;
-
-        return MZ_TRUE;
-    }
-
-#        ifndef MINIZ_NO_STDIO
-    mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive* pZip, const char* pArchive_filename, const char* pDst_filename, mz_uint flags) {
-        int file_index = mz_zip_reader_locate_file(pZip, pArchive_filename, NULL, flags);
-        if (file_index < 0) return MZ_FALSE;
-        return mz_zip_reader_extract_to_file(pZip, file_index, pDst_filename, flags);
-    }
-#        endif
-
-    // ------------------- .ZIP archive writing
-
-#        ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
-
-    static void mz_write_le16(mz_uint8* p, mz_uint16 v) {
-        p[0] = (mz_uint8)v;
-        p[1] = (mz_uint8)(v >> 8);
-    }
-    static void mz_write_le32(mz_uint8* p, mz_uint32 v) {
-        p[0] = (mz_uint8)v;
-        p[1] = (mz_uint8)(v >> 8);
-        p[2] = (mz_uint8)(v >> 16);
-        p[3] = (mz_uint8)(v >> 24);
-    }
-#            define MZ_WRITE_LE16(p, v) mz_write_le16((mz_uint8*)(p), (mz_uint16)(v))
-#            define MZ_WRITE_LE32(p, v) mz_write_le32((mz_uint8*)(p), (mz_uint32)(v))
-
-    mz_bool mz_zip_writer_init(mz_zip_archive* pZip, mz_uint64 existing_size) {
-        if ((!pZip) || (pZip->m_pState) || (!pZip->m_pWrite) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID)) return MZ_FALSE;
-
-        if (pZip->m_file_offset_alignment) {
-            // Ensure user specified file offset alignment is a power of 2.
-            if (pZip->m_file_offset_alignment & (pZip->m_file_offset_alignment - 1)) return MZ_FALSE;
-        }
-
-        if (!pZip->m_pAlloc) pZip->m_pAlloc = def_alloc_func;
-        if (!pZip->m_pFree) pZip->m_pFree = def_free_func;
-        if (!pZip->m_pRealloc) pZip->m_pRealloc = def_realloc_func;
-
-        pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;
-        pZip->m_archive_size = existing_size;
-        pZip->m_central_directory_file_ofs = 0;
-        pZip->m_total_files = 0;
-
-        if (NULL == (pZip->m_pState = (mz_zip_internal_state*)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
-            return MZ_FALSE;
-        memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));
-        MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));
-        MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));
-        MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));
-        return MZ_TRUE;
-    }
-
-    static size_t mz_zip_heap_write_func(void* pOpaque, mz_uint64 file_ofs, const void* pBuf, size_t n) {
-        mz_zip_archive* pZip = (mz_zip_archive*)pOpaque;
-        mz_zip_internal_state* pState = pZip->m_pState;
-        mz_uint64 new_size = MZ_MAX(file_ofs + n, pState->m_mem_size);
-#            ifdef _MSC_VER
-        if ((!n) || ((0, sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF)))
-#            else
-        if ((!n) || ((sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF)))
-#            endif
-            return 0;
-        if (new_size > pState->m_mem_capacity) {
-            void* pNew_block;
-            size_t new_capacity = MZ_MAX(64, pState->m_mem_capacity);
-            while (new_capacity < new_size)
-                new_capacity *= 2;
-            if (NULL == (pNew_block = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pState->m_pMem, 1, new_capacity))) return 0;
-            pState->m_pMem = pNew_block;
-            pState->m_mem_capacity = new_capacity;
-        }
-        memcpy((mz_uint8*)pState->m_pMem + file_ofs, pBuf, n);
-        pState->m_mem_size = (size_t)new_size;
-        return n;
-    }
-
-    mz_bool mz_zip_writer_init_heap(mz_zip_archive* pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size) {
-        pZip->m_pWrite = mz_zip_heap_write_func;
-        pZip->m_pIO_opaque = pZip;
-        if (!mz_zip_writer_init(pZip, size_to_reserve_at_beginning)) return MZ_FALSE;
-        if (0 != (initial_allocation_size = MZ_MAX(initial_allocation_size, size_to_reserve_at_beginning))) {
-            if (NULL == (pZip->m_pState->m_pMem = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, initial_allocation_size))) {
-                mz_zip_writer_end(pZip);
-                return MZ_FALSE;
-            }
-            pZip->m_pState->m_mem_capacity = initial_allocation_size;
-        }
-        return MZ_TRUE;
-    }
-
-#            ifndef MINIZ_NO_STDIO
-    static size_t mz_zip_file_write_func(void* pOpaque, mz_uint64 file_ofs, const void* pBuf, size_t n) {
-        mz_zip_archive* pZip = (mz_zip_archive*)pOpaque;
-        mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
-        if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
-            return 0;
-        return MZ_FWRITE(pBuf, 1, n, pZip->m_pState->m_pFile);
-    }
-
-    mz_bool mz_zip_writer_init_file(mz_zip_archive* pZip, const char* pFilename, mz_uint64 size_to_reserve_at_beginning) {
-        MZ_FILE* pFile;
-        pZip->m_pWrite = mz_zip_file_write_func;
-        pZip->m_pIO_opaque = pZip;
-        if (!mz_zip_writer_init(pZip, size_to_reserve_at_beginning)) return MZ_FALSE;
-        if (NULL == (pFile = MZ_FOPEN(pFilename, "wb"))) {
-            mz_zip_writer_end(pZip);
-            return MZ_FALSE;
-        }
-        pZip->m_pState->m_pFile = pFile;
-        if (size_to_reserve_at_beginning) {
-            mz_uint64 cur_ofs = 0;
-            char buf[4096];
-            MZ_CLEAR_OBJ(buf);
-            do {
-                size_t n = (size_t)MZ_MIN(sizeof(buf), size_to_reserve_at_beginning);
-                if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_ofs, buf, n) != n) {
-                    mz_zip_writer_end(pZip);
-                    return MZ_FALSE;
-                }
-                cur_ofs += n;
-                size_to_reserve_at_beginning -= n;
-            } while (size_to_reserve_at_beginning);
-        }
-        return MZ_TRUE;
-    }
-#            endif  // #ifndef MINIZ_NO_STDIO
-
-    mz_bool mz_zip_writer_init_from_reader(mz_zip_archive* pZip, const char* pFilename) {
-        mz_zip_internal_state* pState;
-        if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING)) return MZ_FALSE;
-        // No sense in trying to write to an archive that's already at the support max size
-        if ((pZip->m_total_files == 0xFFFF) || ((pZip->m_archive_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_ZIP_LOCAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))
-            return MZ_FALSE;
-
-        pState = pZip->m_pState;
-
-        if (pState->m_pFile) {
-#            ifdef MINIZ_NO_STDIO
-            pFilename;
-            return MZ_FALSE;
-#            else
-            // Archive is being read from stdio - try to reopen as writable.
-            if (pZip->m_pIO_opaque != pZip) return MZ_FALSE;
-            if (!pFilename) return MZ_FALSE;
-            pZip->m_pWrite = mz_zip_file_write_func;
-            if (NULL == (pState->m_pFile = MZ_FREOPEN(pFilename, "r+b", pState->m_pFile))) {
-                // The mz_zip_archive is now in a bogus state because pState->m_pFile is NULL, so just close it.
-                mz_zip_reader_end(pZip);
-                return MZ_FALSE;
-            }
-#            endif  // #ifdef MINIZ_NO_STDIO
-        } else if (pState->m_pMem) {
-            // Archive lives in a memory block. Assume it's from the heap that we can resize using the realloc callback.
-            if (pZip->m_pIO_opaque != pZip) return MZ_FALSE;
-            pState->m_mem_capacity = pState->m_mem_size;
-            pZip->m_pWrite = mz_zip_heap_write_func;
-        }
-        // Archive is being read via a user provided read function - make sure the user has specified a write function too.
-        else if (!pZip->m_pWrite)
-            return MZ_FALSE;
-
-        // Start writing new files at the archive's current central directory location.
-        pZip->m_archive_size = pZip->m_central_directory_file_ofs;
-        pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;
-        pZip->m_central_directory_file_ofs = 0;
-
-        return MZ_TRUE;
-    }
-
-    mz_bool mz_zip_writer_add_mem(mz_zip_archive* pZip, const char* pArchive_name, const void* pBuf, size_t buf_size, mz_uint level_and_flags) {
-        return mz_zip_writer_add_mem_ex(pZip, pArchive_name, pBuf, buf_size, NULL, 0, level_and_flags, 0, 0);
-    }
-
-    typedef struct
-    {
-        mz_zip_archive* m_pZip;
-        mz_uint64 m_cur_archive_file_ofs;
-        mz_uint64 m_comp_size;
-    } mz_zip_writer_add_state;
-
-    static mz_bool mz_zip_writer_add_put_buf_callback(const void* pBuf, int len, void* pUser) {
-        mz_zip_writer_add_state* pState = (mz_zip_writer_add_state*)pUser;
-        if ((int)pState->m_pZip->m_pWrite(pState->m_pZip->m_pIO_opaque, pState->m_cur_archive_file_ofs, pBuf, len) != len) return MZ_FALSE;
-        pState->m_cur_archive_file_ofs += len;
-        pState->m_comp_size += len;
-        return MZ_TRUE;
-    }
-
-    static mz_bool mz_zip_writer_create_local_dir_header(mz_zip_archive* pZip, mz_uint8* pDst, mz_uint16 filename_size, mz_uint16 extra_size,
-                                                         mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method,
-                                                         mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date) {
-        (void)pZip;
-        memset(pDst, 0, MZ_ZIP_LOCAL_DIR_HEADER_SIZE);
-        MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_SIG_OFS, MZ_ZIP_LOCAL_DIR_HEADER_SIG);
-        MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_VERSION_NEEDED_OFS, method ? 20 : 0);
-        MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_BIT_FLAG_OFS, bit_flags);
-        MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_METHOD_OFS, method);
-        MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_TIME_OFS, dos_time);
-        MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_DATE_OFS, dos_date);
-        MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_CRC32_OFS, uncomp_crc32);
-        MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS, comp_size);
-        MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS, uncomp_size);
-        MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILENAME_LEN_OFS, filename_size);
-        MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_EXTRA_LEN_OFS, extra_size);
-        return MZ_TRUE;
-    }
-
-    static mz_bool mz_zip_writer_create_central_dir_header(mz_zip_archive* pZip, mz_uint8* pDst, mz_uint16 filename_size, mz_uint16 extra_size,
-                                                           mz_uint16 comment_size, mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32,
-                                                           mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date,
-                                                           mz_uint64 local_header_ofs, mz_uint32 ext_attributes) {
-        (void)pZip;
-        memset(pDst, 0, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
-        MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_SIG_OFS, MZ_ZIP_CENTRAL_DIR_HEADER_SIG);
-        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_VERSION_NEEDED_OFS, method ? 20 : 0);
-        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_BIT_FLAG_OFS, bit_flags);
-        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_METHOD_OFS, method);
-        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_TIME_OFS, dos_time);
-        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_DATE_OFS, dos_date);
-        MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_CRC32_OFS, uncomp_crc32);
-        MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, comp_size);
-        MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, uncomp_size);
-        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILENAME_LEN_OFS, filename_size);
-        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_EXTRA_LEN_OFS, extra_size);
-        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_COMMENT_LEN_OFS, comment_size);
-        MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS, ext_attributes);
-        MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_header_ofs);
-        return MZ_TRUE;
-    }
-
-    static mz_bool mz_zip_writer_add_to_central_dir(mz_zip_archive* pZip, const char* pFilename, mz_uint16 filename_size, const void* pExtra,
-                                                    mz_uint16 extra_size, const void* pComment, mz_uint16 comment_size, mz_uint64 uncomp_size,
-                                                    mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags,
-                                                    mz_uint16 dos_time, mz_uint16 dos_date, mz_uint64 local_header_ofs, mz_uint32 ext_attributes) {
-        mz_zip_internal_state* pState = pZip->m_pState;
-        mz_uint32 central_dir_ofs = (mz_uint32)pState->m_central_dir.m_size;
-        size_t orig_central_dir_size = pState->m_central_dir.m_size;
-        mz_uint8 central_dir_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];
-
-        // No zip64 support yet
-        if ((local_header_ofs > 0xFFFFFFFF)
-            || (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size + extra_size + comment_size) > 0xFFFFFFFF))
-            return MZ_FALSE;
-
-        if (!mz_zip_writer_create_central_dir_header(pZip, central_dir_header, filename_size, extra_size, comment_size, uncomp_size, comp_size,
-                                                     uncomp_crc32, method, bit_flags, dos_time, dos_date, local_header_ofs, ext_attributes))
-            return MZ_FALSE;
-
-        if ((!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_dir_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE))
-            || (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pFilename, filename_size))
-            || (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pExtra, extra_size))
-            || (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pComment, comment_size))
-            || (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &central_dir_ofs, 1))) {
-            // Try to push the central directory array back into its original state.
-            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
-            return MZ_FALSE;
-        }
-
-        return MZ_TRUE;
-    }
-
-    static mz_bool mz_zip_writer_validate_archive_name(const char* pArchive_name) {
-        // Basic ZIP archive filename validity checks: Valid filenames cannot start with a forward slash, cannot contain a drive letter, and cannot use DOS-style backward slashes.
-        if (*pArchive_name == '/') return MZ_FALSE;
-        while (*pArchive_name) {
-            if ((*pArchive_name == '\\') || (*pArchive_name == ':')) return MZ_FALSE;
-            pArchive_name++;
-        }
-        return MZ_TRUE;
-    }
-
-    static mz_uint mz_zip_writer_compute_padding_needed_for_file_alignment(mz_zip_archive* pZip) {
-        mz_uint32 n;
-        if (!pZip->m_file_offset_alignment) return 0;
-        n = (mz_uint32)(pZip->m_archive_size & (pZip->m_file_offset_alignment - 1));
-        return (pZip->m_file_offset_alignment - n) & (pZip->m_file_offset_alignment - 1);
-    }
-
-    static mz_bool mz_zip_writer_write_zeros(mz_zip_archive* pZip, mz_uint64 cur_file_ofs, mz_uint32 n) {
-        char buf[4096];
-        memset(buf, 0, MZ_MIN(sizeof(buf), n));
-        while (n) {
-            mz_uint32 s = MZ_MIN(sizeof(buf), n);
-            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_file_ofs, buf, s) != s) return MZ_FALSE;
-            cur_file_ofs += s;
-            n -= s;
-        }
-        return MZ_TRUE;
-    }
-
-    mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive* pZip, const char* pArchive_name, const void* pBuf, size_t buf_size, const void* pComment,
-                                     mz_uint16 comment_size, mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32) {
-        mz_uint16 method = 0, dos_time = 0, dos_date = 0;
-        mz_uint level, ext_attributes = 0, num_alignment_padding_bytes;
-        mz_uint64 local_dir_header_ofs = pZip->m_archive_size, cur_archive_file_ofs = pZip->m_archive_size, comp_size = 0;
-        size_t archive_name_size;
-        mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
-        tdefl_compressor* pComp = NULL;
-        mz_bool store_data_uncompressed;
-        mz_zip_internal_state* pState;
-
-        if ((int)level_and_flags < 0) level_and_flags = MZ_DEFAULT_LEVEL;
-        level = level_and_flags & 0xF;
-        store_data_uncompressed = ((!level) || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA));
-
-        if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || ((buf_size) && (!pBuf)) || (!pArchive_name)
-            || ((comment_size) && (!pComment)) || (pZip->m_total_files == 0xFFFF) || (level > MZ_UBER_COMPRESSION))
-            return MZ_FALSE;
-
-        pState = pZip->m_pState;
-
-        if ((!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (uncomp_size)) return MZ_FALSE;
-        // No zip64 support yet
-        if ((buf_size > 0xFFFFFFFF) || (uncomp_size > 0xFFFFFFFF)) return MZ_FALSE;
-        if (!mz_zip_writer_validate_archive_name(pArchive_name)) return MZ_FALSE;
-
-#            ifndef MINIZ_NO_TIME
-        {
-            time_t cur_time;
-            time(&cur_time);
-            mz_zip_time_to_dos_time(cur_time, &dos_time, &dos_date);
-        }
-#            endif  // #ifndef MINIZ_NO_TIME
-
-        archive_name_size = strlen(pArchive_name);
-        if (archive_name_size > 0xFFFF) return MZ_FALSE;
-
-        num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);
-
-        // no zip64 support yet
-        if ((pZip->m_total_files == 0xFFFF)
-            || ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + comment_size
-                 + archive_name_size)
-                > 0xFFFFFFFF))
-            return MZ_FALSE;
-
-        if ((archive_name_size) && (pArchive_name[archive_name_size - 1] == '/')) {
-            // Set DOS Subdirectory attribute bit.
-            ext_attributes |= 0x10;
-            // Subdirectories cannot contain data.
-            if ((buf_size) || (uncomp_size)) return MZ_FALSE;
-        }
-
-        // Try to do any allocations before writing to the archive, so if an allocation fails the file remains unmodified. (A good idea if we're doing an in-place modification.)
-        if ((!mz_zip_array_ensure_room(pZip, &pState->m_central_dir, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + comment_size))
-            || (!mz_zip_array_ensure_room(pZip, &pState->m_central_dir_offsets, 1)))
-            return MZ_FALSE;
-
-        if ((!store_data_uncompressed) && (buf_size)) {
-            if (NULL == (pComp = (tdefl_compressor*)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor)))) return MZ_FALSE;
-        }
-
-        if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes + sizeof(local_dir_header))) {
-            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
-            return MZ_FALSE;
-        }
-        local_dir_header_ofs += num_alignment_padding_bytes;
-        if (pZip->m_file_offset_alignment) {
-            MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0);
-        }
-        cur_archive_file_ofs += num_alignment_padding_bytes + sizeof(local_dir_header);
-
-        MZ_CLEAR_OBJ(local_dir_header);
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size) {
-            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
-            return MZ_FALSE;
-        }
-        cur_archive_file_ofs += archive_name_size;
-
-        if (!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) {
-            uncomp_crc32 = (mz_uint32)mz_crc32(MZ_CRC32_INIT, (const mz_uint8*)pBuf, buf_size);
-            uncomp_size = buf_size;
-            if (uncomp_size <= 3) {
-                level = 0;
-                store_data_uncompressed = MZ_TRUE;
-            }
-        }
-
-        if (store_data_uncompressed) {
-            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pBuf, buf_size) != buf_size) {
-                pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
-                return MZ_FALSE;
-            }
-
-            cur_archive_file_ofs += buf_size;
-            comp_size = buf_size;
-
-            if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA) method = MZ_DEFLATED;
-        } else if (buf_size) {
-            mz_zip_writer_add_state state;
-
-            state.m_pZip = pZip;
-            state.m_cur_archive_file_ofs = cur_archive_file_ofs;
-            state.m_comp_size = 0;
-
-            if ((tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state,
-                            tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY))
-                 != TDEFL_STATUS_OKAY)
-                || (tdefl_compress_buffer(pComp, pBuf, buf_size, TDEFL_FINISH) != TDEFL_STATUS_DONE)) {
-                pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
-                return MZ_FALSE;
-            }
-
-            comp_size = state.m_comp_size;
-            cur_archive_file_ofs = state.m_cur_archive_file_ofs;
-
-            method = MZ_DEFLATED;
-        }
-
-        pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
-        pComp = NULL;
-
-        // no zip64 support yet
-        if ((comp_size > 0xFFFFFFFF) || (cur_archive_file_ofs > 0xFFFFFFFF)) return MZ_FALSE;
-
-        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, 0, uncomp_size, comp_size, uncomp_crc32,
-                                                   method, 0, dos_time, dos_date))
-            return MZ_FALSE;
-
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
-            return MZ_FALSE;
-
-        if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, NULL, 0, pComment, comment_size, uncomp_size,
-                                              comp_size, uncomp_crc32, method, 0, dos_time, dos_date, local_dir_header_ofs, ext_attributes))
-            return MZ_FALSE;
-
-        pZip->m_total_files++;
-        pZip->m_archive_size = cur_archive_file_ofs;
-
-        return MZ_TRUE;
-    }
-
-#            ifndef MINIZ_NO_STDIO
-    mz_bool mz_zip_writer_add_file(mz_zip_archive* pZip, const char* pArchive_name, const char* pSrc_filename, const void* pComment,
-                                   mz_uint16 comment_size, mz_uint level_and_flags) {
-        mz_uint uncomp_crc32 = MZ_CRC32_INIT, level, num_alignment_padding_bytes;
-        mz_uint16 method = 0, dos_time = 0, dos_date = 0, ext_attributes = 0;
-        mz_uint64 local_dir_header_ofs = pZip->m_archive_size, cur_archive_file_ofs = pZip->m_archive_size, uncomp_size = 0, comp_size = 0;
-        size_t archive_name_size;
-        mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
-        MZ_FILE* pSrc_file = NULL;
-
-        if ((int)level_and_flags < 0) level_and_flags = MZ_DEFAULT_LEVEL;
-        level = level_and_flags & 0xF;
-
-        if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pArchive_name) || ((comment_size) && (!pComment))
-            || (level > MZ_UBER_COMPRESSION))
-            return MZ_FALSE;
-        if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA) return MZ_FALSE;
-        if (!mz_zip_writer_validate_archive_name(pArchive_name)) return MZ_FALSE;
-
-        archive_name_size = strlen(pArchive_name);
-        if (archive_name_size > 0xFFFF) return MZ_FALSE;
-
-        num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);
-
-        // no zip64 support yet
-        if ((pZip->m_total_files == 0xFFFF)
-            || ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + comment_size
-                 + archive_name_size)
-                > 0xFFFFFFFF))
-            return MZ_FALSE;
-
-        if (!mz_zip_get_file_modified_time(pSrc_filename, &dos_time, &dos_date)) return MZ_FALSE;
-
-        pSrc_file = MZ_FOPEN(pSrc_filename, "rb");
-        if (!pSrc_file) return MZ_FALSE;
-        MZ_FSEEK64(pSrc_file, 0, SEEK_END);
-        uncomp_size = MZ_FTELL64(pSrc_file);
-        MZ_FSEEK64(pSrc_file, 0, SEEK_SET);
-
-        if (uncomp_size > 0xFFFFFFFF) {
-            // No zip64 support yet
-            MZ_FCLOSE(pSrc_file);
-            return MZ_FALSE;
-        }
-        if (uncomp_size <= 3) level = 0;
-
-        if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes + sizeof(local_dir_header))) {
-            MZ_FCLOSE(pSrc_file);
-            return MZ_FALSE;
-        }
-        local_dir_header_ofs += num_alignment_padding_bytes;
-        if (pZip->m_file_offset_alignment) {
-            MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0);
-        }
-        cur_archive_file_ofs += num_alignment_padding_bytes + sizeof(local_dir_header);
-
-        MZ_CLEAR_OBJ(local_dir_header);
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size) {
-            MZ_FCLOSE(pSrc_file);
-            return MZ_FALSE;
-        }
-        cur_archive_file_ofs += archive_name_size;
-
-        if (uncomp_size) {
-            mz_uint64 uncomp_remaining = uncomp_size;
-            void* pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, MZ_ZIP_MAX_IO_BUF_SIZE);
-            if (!pRead_buf) {
-                MZ_FCLOSE(pSrc_file);
-                return MZ_FALSE;
-            }
-
-            if (!level) {
-                while (uncomp_remaining) {
-                    mz_uint n = (mz_uint)MZ_MIN(MZ_ZIP_MAX_IO_BUF_SIZE, uncomp_remaining);
-                    if ((MZ_FREAD(pRead_buf, 1, n, pSrc_file) != n)
-                        || (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pRead_buf, n) != n)) {
-                        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
-                        MZ_FCLOSE(pSrc_file);
-                        return MZ_FALSE;
-                    }
-                    uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8*)pRead_buf, n);
-                    uncomp_remaining -= n;
-                    cur_archive_file_ofs += n;
-                }
-                comp_size = uncomp_size;
-            } else {
-                mz_bool result = MZ_FALSE;
-                mz_zip_writer_add_state state;
-                tdefl_compressor* pComp = (tdefl_compressor*)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor));
-                if (!pComp) {
-                    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
-                    MZ_FCLOSE(pSrc_file);
-                    return MZ_FALSE;
-                }
-
-                state.m_pZip = pZip;
-                state.m_cur_archive_file_ofs = cur_archive_file_ofs;
-                state.m_comp_size = 0;
-
-                if (tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state,
-                               tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY))
-                    != TDEFL_STATUS_OKAY) {
-                    pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
-                    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
-                    MZ_FCLOSE(pSrc_file);
-                    return MZ_FALSE;
-                }
-
-                for (;;) {
-                    size_t in_buf_size = (mz_uint32)MZ_MIN(uncomp_remaining, MZ_ZIP_MAX_IO_BUF_SIZE);
-                    tdefl_status status;
-
-                    if (MZ_FREAD(pRead_buf, 1, in_buf_size, pSrc_file) != in_buf_size) break;
-
-                    uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8*)pRead_buf, in_buf_size);
-                    uncomp_remaining -= in_buf_size;
-
-                    status = tdefl_compress_buffer(pComp, pRead_buf, in_buf_size, uncomp_remaining ? TDEFL_NO_FLUSH : TDEFL_FINISH);
-                    if (status == TDEFL_STATUS_DONE) {
-                        result = MZ_TRUE;
-                        break;
-                    } else if (status != TDEFL_STATUS_OKAY)
-                        break;
-                }
-
-                pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
-
-                if (!result) {
-                    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
-                    MZ_FCLOSE(pSrc_file);
-                    return MZ_FALSE;
-                }
-
-                comp_size = state.m_comp_size;
-                cur_archive_file_ofs = state.m_cur_archive_file_ofs;
-
-                method = MZ_DEFLATED;
-            }
-
-            pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
-        }
-
-        MZ_FCLOSE(pSrc_file);
-        pSrc_file = NULL;
-
-        // no zip64 support yet
-        if ((comp_size > 0xFFFFFFFF) || (cur_archive_file_ofs > 0xFFFFFFFF)) return MZ_FALSE;
-
-        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, 0, uncomp_size, comp_size, uncomp_crc32,
-                                                   method, 0, dos_time, dos_date))
-            return MZ_FALSE;
-
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
-            return MZ_FALSE;
-
-        if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, NULL, 0, pComment, comment_size, uncomp_size,
-                                              comp_size, uncomp_crc32, method, 0, dos_time, dos_date, local_dir_header_ofs, ext_attributes))
-            return MZ_FALSE;
-
-        pZip->m_total_files++;
-        pZip->m_archive_size = cur_archive_file_ofs;
-
-        return MZ_TRUE;
-    }
-#            endif  // #ifndef MINIZ_NO_STDIO
-
-    mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive* pZip, mz_zip_archive* pSource_zip, mz_uint file_index) {
-        mz_uint n, bit_flags, num_alignment_padding_bytes;
-        mz_uint64 comp_bytes_remaining, local_dir_header_ofs;
-        mz_uint64 cur_src_file_ofs, cur_dst_file_ofs;
-        mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
-        mz_uint8* pLocal_header = (mz_uint8*)local_header_u32;
-        mz_uint8 central_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];
-        size_t orig_central_dir_size;
-        mz_zip_internal_state* pState;
-        void* pBuf;
-        const mz_uint8* pSrc_central_header;
-
-        if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING)) return MZ_FALSE;
-        if (NULL == (pSrc_central_header = mz_zip_reader_get_cdh(pSource_zip, file_index))) return MZ_FALSE;
-        pState = pZip->m_pState;
-
-        num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);
-
-        // no zip64 support yet
-        if ((pZip->m_total_files == 0xFFFF)
-            || ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))
-            return MZ_FALSE;
-
-        cur_src_file_ofs = MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS);
-        cur_dst_file_ofs = pZip->m_archive_size;
-
-        if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
-            != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
-            return MZ_FALSE;
-        if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG) return MZ_FALSE;
-        cur_src_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;
-
-        if (!mz_zip_writer_write_zeros(pZip, cur_dst_file_ofs, num_alignment_padding_bytes)) return MZ_FALSE;
-        cur_dst_file_ofs += num_alignment_padding_bytes;
-        local_dir_header_ofs = cur_dst_file_ofs;
-        if (pZip->m_file_offset_alignment) {
-            MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0);
-        }
-
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
-            return MZ_FALSE;
-        cur_dst_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;
-
-        n = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
-        comp_bytes_remaining = n + MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
-
-        if (NULL
-            == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1,
-                                      (size_t)MZ_MAX(sizeof(mz_uint32) * 4, MZ_MIN(MZ_ZIP_MAX_IO_BUF_SIZE, comp_bytes_remaining)))))
-            return MZ_FALSE;
-
-        while (comp_bytes_remaining) {
-            n = (mz_uint)MZ_MIN(MZ_ZIP_MAX_IO_BUF_SIZE, comp_bytes_remaining);
-            if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, n) != n) {
-                pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
-                return MZ_FALSE;
-            }
-            cur_src_file_ofs += n;
-
-            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n) {
-                pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
-                return MZ_FALSE;
-            }
-            cur_dst_file_ofs += n;
-
-            comp_bytes_remaining -= n;
-        }
-
-        bit_flags = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_BIT_FLAG_OFS);
-        if (bit_flags & 8) {
-            // Copy data descriptor
-            if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, sizeof(mz_uint32) * 4) != sizeof(mz_uint32) * 4) {
-                pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
-                return MZ_FALSE;
-            }
-
-            n = sizeof(mz_uint32) * ((MZ_READ_LE32(pBuf) == 0x08074b50) ? 4 : 3);
-            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n) {
-                pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
-                return MZ_FALSE;
-            }
-
-            cur_src_file_ofs += n;
-            cur_dst_file_ofs += n;
-        }
-        pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
-
-        // no zip64 support yet
-        if (cur_dst_file_ofs > 0xFFFFFFFF) return MZ_FALSE;
-
-        orig_central_dir_size = pState->m_central_dir.m_size;
-
-        memcpy(central_header, pSrc_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
-        MZ_WRITE_LE32(central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_dir_header_ofs);
-        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)) return MZ_FALSE;
-
-        n = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS)
-            + MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_COMMENT_LEN_OFS);
-        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n)) {
-            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
-            return MZ_FALSE;
-        }
-
-        if (pState->m_central_dir.m_size > 0xFFFFFFFF) return MZ_FALSE;
-        n = (mz_uint32)orig_central_dir_size;
-        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &n, 1)) {
-            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
-            return MZ_FALSE;
-        }
-
-        pZip->m_total_files++;
-        pZip->m_archive_size = cur_dst_file_ofs;
-
-        return MZ_TRUE;
-    }
-
-    mz_bool mz_zip_writer_finalize_archive(mz_zip_archive* pZip) {
-        mz_zip_internal_state* pState;
-        mz_uint64 central_dir_ofs, central_dir_size;
-        mz_uint8 hdr[MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE];
-
-        if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING)) return MZ_FALSE;
-
-        pState = pZip->m_pState;
-
-        // no zip64 support yet
-        if ((pZip->m_total_files > 0xFFFF)
-            || ((pZip->m_archive_size + pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))
-            return MZ_FALSE;
-
-        central_dir_ofs = 0;
-        central_dir_size = 0;
-        if (pZip->m_total_files) {
-            // Write central directory
-            central_dir_ofs = pZip->m_archive_size;
-            central_dir_size = pState->m_central_dir.m_size;
-            pZip->m_central_directory_file_ofs = central_dir_ofs;
-            if (pZip->m_pWrite(pZip->m_pIO_opaque, central_dir_ofs, pState->m_central_dir.m_p, (size_t)central_dir_size) != central_dir_size)
-                return MZ_FALSE;
-            pZip->m_archive_size += central_dir_size;
-        }
-
-        // Write end of central directory record
-        MZ_CLEAR_OBJ(hdr);
-        MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_SIG_OFS, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG);
-        MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS, pZip->m_total_files);
-        MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS, pZip->m_total_files);
-        MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_SIZE_OFS, central_dir_size);
-        MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_OFS_OFS, central_dir_ofs);
-
-        if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, sizeof(hdr)) != sizeof(hdr)) return MZ_FALSE;
-#            ifndef MINIZ_NO_STDIO
-        if ((pState->m_pFile) && (MZ_FFLUSH(pState->m_pFile) == EOF)) return MZ_FALSE;
-#            endif  // #ifndef MINIZ_NO_STDIO
-
-        pZip->m_archive_size += sizeof(hdr);
-
-        pZip->m_zip_mode = MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED;
-        return MZ_TRUE;
-    }
-
-    mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive* pZip, void** pBuf, size_t* pSize) {
-        if ((!pZip) || (!pZip->m_pState) || (!pBuf) || (!pSize)) return MZ_FALSE;
-        if (pZip->m_pWrite != mz_zip_heap_write_func) return MZ_FALSE;
-        if (!mz_zip_writer_finalize_archive(pZip)) return MZ_FALSE;
-
-        *pBuf = pZip->m_pState->m_pMem;
-        *pSize = pZip->m_pState->m_mem_size;
-        pZip->m_pState->m_pMem = NULL;
-        pZip->m_pState->m_mem_size = pZip->m_pState->m_mem_capacity = 0;
-        return MZ_TRUE;
-    }
-
-    mz_bool mz_zip_writer_end(mz_zip_archive* pZip) {
-        mz_zip_internal_state* pState;
-        mz_bool status = MZ_TRUE;
-        if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree)
-            || ((pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) && (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED)))
-            return MZ_FALSE;
-
-        pState = pZip->m_pState;
-        pZip->m_pState = NULL;
-        mz_zip_array_clear(pZip, &pState->m_central_dir);
-        mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
-        mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);
-
-#            ifndef MINIZ_NO_STDIO
-        if (pState->m_pFile) {
-            MZ_FCLOSE(pState->m_pFile);
-            pState->m_pFile = NULL;
-        }
-#            endif  // #ifndef MINIZ_NO_STDIO
-
-        if ((pZip->m_pWrite == mz_zip_heap_write_func) && (pState->m_pMem)) {
-            pZip->m_pFree(pZip->m_pAlloc_opaque, pState->m_pMem);
-            pState->m_pMem = NULL;
-        }
-
-        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
-        pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;
-        return status;
-    }
-
-#            ifndef MINIZ_NO_STDIO
-    mz_bool mz_zip_add_mem_to_archive_file_in_place(const char* pZip_filename, const char* pArchive_name, const void* pBuf, size_t buf_size,
-                                                    const void* pComment, mz_uint16 comment_size, mz_uint level_and_flags) {
-        mz_bool status, created_new_archive = MZ_FALSE;
-        mz_zip_archive zip_archive;
-        struct MZ_FILE_STAT_STRUCT file_stat;
-        MZ_CLEAR_OBJ(zip_archive);
-        if ((int)level_and_flags < 0) level_and_flags = MZ_DEFAULT_LEVEL;
-        if ((!pZip_filename) || (!pArchive_name) || ((buf_size) && (!pBuf)) || ((comment_size) && (!pComment))
-            || ((level_and_flags & 0xF) > MZ_UBER_COMPRESSION))
-            return MZ_FALSE;
-        if (!mz_zip_writer_validate_archive_name(pArchive_name)) return MZ_FALSE;
-        if (MZ_FILE_STAT(pZip_filename, &file_stat) != 0) {
-            // Create a new archive.
-            if (!mz_zip_writer_init_file(&zip_archive, pZip_filename, 0)) return MZ_FALSE;
-            created_new_archive = MZ_TRUE;
-        } else {
-            // Append to an existing archive.
-            if (!mz_zip_reader_init_file(&zip_archive, pZip_filename, level_and_flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY)) return MZ_FALSE;
-            if (!mz_zip_writer_init_from_reader(&zip_archive, pZip_filename)) {
-                mz_zip_reader_end(&zip_archive);
-                return MZ_FALSE;
-            }
-        }
-        status = mz_zip_writer_add_mem_ex(&zip_archive, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, 0, 0);
-        // Always finalize, even if adding failed for some reason, so we have a valid central directory. (This may not always succeed, but we can try.)
-        if (!mz_zip_writer_finalize_archive(&zip_archive)) status = MZ_FALSE;
-        if (!mz_zip_writer_end(&zip_archive)) status = MZ_FALSE;
-        if ((!status) && (created_new_archive)) {
-            // It's a new archive and something went wrong, so just delete it.
-            int ignoredStatus = MZ_DELETE_FILE(pZip_filename);
-            (void)ignoredStatus;
-        }
-        return status;
-    }
-
-    void* mz_zip_extract_archive_file_to_heap(const char* pZip_filename, const char* pArchive_name, size_t* pSize, mz_uint flags) {
-        int file_index;
-        mz_zip_archive zip_archive;
-        void* p = NULL;
-
-        if (pSize) *pSize = 0;
-
-        if ((!pZip_filename) || (!pArchive_name)) return NULL;
-
-        MZ_CLEAR_OBJ(zip_archive);
-        if (!mz_zip_reader_init_file(&zip_archive, pZip_filename, flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY)) return NULL;
-
-        if ((file_index = mz_zip_reader_locate_file(&zip_archive, pArchive_name, NULL, flags)) >= 0)
-            p = mz_zip_reader_extract_to_heap(&zip_archive, file_index, pSize, flags);
-
-        mz_zip_reader_end(&zip_archive);
-        return p;
-    }
-
-#            endif  // #ifndef MINIZ_NO_STDIO
-
-#        endif  // #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
-
-#    endif  // #ifndef MINIZ_NO_ARCHIVE_APIS
-
-#    ifdef __cplusplus
-}
-#    endif
-
-#endif  // MINIZ_HEADER_FILE_ONLY
-
-/*
-  This is free and unencumbered software released into the public domain.
-
-  Anyone is free to copy, modify, publish, use, compile, sell, or
-  distribute this software, either in source code form or as a compiled
-  binary, for any purpose, commercial or non-commercial, and by any
-  means.
-
-  In jurisdictions that recognize copyright laws, the author or authors
-  of this software dedicate any and all copyright interest in the
-  software to the public domain. We make this dedication for the benefit
-  of the public at large and to the detriment of our heirs and
-  successors. We intend this dedication to be an overt act of
-  relinquishment in perpetuity of all present and future rights to this
-  software under copyright law.
-
-  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
-  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
-  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-  OTHER DEALINGS IN THE SOFTWARE.
-
-  For more information, please refer to <http://unlicense.org/>
-*/
+/* miniz.c v1.15 - public domain deflate/inflate, zlib-subset, ZIP reading/writing/appending, PNG writing
+   See "unlicense" statement at the end of this file.
+   Rich Geldreich <richgel99@gmail.com>, last updated Oct. 13, 2013
+   Implements RFC 1950: http://www.ietf.org/rfc/rfc1950.txt and RFC 1951: http://www.ietf.org/rfc/rfc1951.txt
+
+   Most API's defined in miniz.c are optional. For example, to disable the archive related functions just define
+   MINIZ_NO_ARCHIVE_APIS, or to get rid of all stdio usage define MINIZ_NO_STDIO (see the list below for more macros).
+
+   * Change History
+     10/13/13 v1.15 r4 - Interim bugfix release while I work on the next major release with Zip64 support (almost there!):
+       - Critical fix for the MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY bug (thanks kahmyong.moon@hp.com) which could cause locate files to not find files. This bug
+        would only have occurred in earlier versions if you explicitly used this flag, OR if you used mz_zip_extract_archive_file_to_heap() or mz_zip_add_mem_to_archive_file_in_place()
+        (which used this flag). If you can't switch to v1.15 but want to fix this bug, just remove the uses of this flag from both helper funcs (and of course don't use the flag).
+       - Bugfix in mz_zip_reader_extract_to_mem_no_alloc() from kymoon when pUser_read_buf is not NULL and compressed size is > uncompressed size
+       - Fixing mz_zip_reader_extract_*() funcs so they don't try to extract compressed data from directory entries, to account for weird zipfiles which contain zero-size compressed data on dir entries.
+         Hopefully this fix won't cause any issues on weird zip archives, because it assumes the low 16-bits of zip external attributes are DOS attributes (which I believe they always are in practice).
+       - Fixing mz_zip_reader_is_file_a_directory() so it doesn't check the internal attributes, just the filename and external attributes
+       - mz_zip_reader_init_file() - missing MZ_FCLOSE() call if the seek failed
+       - Added cmake support for Linux builds which builds all the examples, tested with clang v3.3 and gcc v4.6.
+       - Clang fix for tdefl_write_image_to_png_file_in_memory() from toffaletti
+       - Merged MZ_FORCEINLINE fix from hdeanclark
+       - Fix <time.h> include before config #ifdef, thanks emil.brink
+       - Added tdefl_write_image_to_png_file_in_memory_ex(): supports Y flipping (super useful for OpenGL apps), and explicit control over the compression level (so you can
+        set it to 1 for real-time compression).
+       - Merged in some compiler fixes from paulharris's github repro.
+       - Retested this build under Windows (VS 2010, including static analysis), tcc  0.9.26, gcc v4.6 and clang v3.3.
+       - Added example6.c, which dumps an image of the mandelbrot set to a PNG file.
+       - Modified example2 to help test the MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY flag more.
+       - In r3: Bugfix to mz_zip_writer_add_file() found during merge: Fix possible src file fclose() leak if alignment bytes+local header file write faiiled
+       - In r4: Minor bugfix to mz_zip_writer_add_from_zip_reader(): Was pushing the wrong central dir header offset, appears harmless in this release, but it became a problem in the zip64 branch
+     5/20/12 v1.14 - MinGW32/64 GCC 4.6.1 compiler fixes: added MZ_FORCEINLINE, #include <time.h> (thanks fermtect).
+     5/19/12 v1.13 - From jason@cornsyrup.org and kelwert@mtu.edu - Fix mz_crc32() so it doesn't compute the wrong CRC-32's when mz_ulong is 64-bit.
+       - Temporarily/locally slammed in "typedef unsigned long mz_ulong" and re-ran a randomized regression test on ~500k files.
+       - Eliminated a bunch of warnings when compiling with GCC 32-bit/64.
+       - Ran all examples, miniz.c, and tinfl.c through MSVC 2008's /analyze (static analysis) option and fixed all warnings (except for the silly
+        "Use of the comma-operator in a tested expression.." analysis warning, which I purposely use to work around a MSVC compiler warning).
+       - Created 32-bit and 64-bit Codeblocks projects/workspace. Built and tested Linux executables. The codeblocks workspace is compatible with Linux+Win32/x64.
+       - Added miniz_tester solution/project, which is a useful little app derived from LZHAM's tester app that I use as part of the regression test.
+       - Ran miniz.c and tinfl.c through another series of regression testing on ~500,000 files and archives.
+       - Modified example5.c so it purposely disables a bunch of high-level functionality (MINIZ_NO_STDIO, etc.). (Thanks to corysama for the MINIZ_NO_STDIO bug report.)
+       - Fix ftell() usage in examples so they exit with an error on files which are too large (a limitation of the examples, not miniz itself).
+     4/12/12 v1.12 - More comments, added low-level example5.c, fixed a couple minor level_and_flags issues in the archive API's.
+      level_and_flags can now be set to MZ_DEFAULT_COMPRESSION. Thanks to Bruce Dawson <bruced@valvesoftware.com> for the feedback/bug report.
+     5/28/11 v1.11 - Added statement from unlicense.org
+     5/27/11 v1.10 - Substantial compressor optimizations:
+      - Level 1 is now ~4x faster than before. The L1 compressor's throughput now varies between 70-110MB/sec. on a
+      - Core i7 (actual throughput varies depending on the type of data, and x64 vs. x86).
+      - Improved baseline L2-L9 compression perf. Also, greatly improved compression perf. issues on some file types.
+      - Refactored the compression code for better readability and maintainability.
+      - Added level 10 compression level (L10 has slightly better ratio than level 9, but could have a potentially large
+       drop in throughput on some files).
+     5/15/11 v1.09 - Initial stable release.
+
+   * Low-level Deflate/Inflate implementation notes:
+
+     Compression: Use the "tdefl" API's. The compressor supports raw, static, and dynamic blocks, lazy or
+     greedy parsing, match length filtering, RLE-only, and Huffman-only streams. It performs and compresses
+     approximately as well as zlib.
+
+     Decompression: Use the "tinfl" API's. The entire decompressor is implemented as a single function
+     coroutine: see tinfl_decompress(). It supports decompression into a 32KB (or larger power of 2) wrapping buffer, or into a memory
+     block large enough to hold the entire file.
+
+     The low-level tdefl/tinfl API's do not make any use of dynamic memory allocation.
+
+   * zlib-style API notes:
+
+     miniz.c implements a fairly large subset of zlib. There's enough functionality present for it to be a drop-in
+     zlib replacement in many apps:
+        The z_stream struct, optional memory allocation callbacks
+        deflateInit/deflateInit2/deflate/deflateReset/deflateEnd/deflateBound
+        inflateInit/inflateInit2/inflate/inflateEnd
+        compress, compress2, compressBound, uncompress
+        CRC-32, Adler-32 - Using modern, minimal code size, CPU cache friendly routines.
+        Supports raw deflate streams or standard zlib streams with adler-32 checking.
+
+     Limitations:
+      The callback API's are not implemented yet. No support for gzip headers or zlib static dictionaries.
+      I've tried to closely emulate zlib's various flavors of stream flushing and return status codes, but
+      there are no guarantees that miniz.c pulls this off perfectly.
+
+   * PNG writing: See the tdefl_write_image_to_png_file_in_memory() function, originally written by
+     Alex Evans. Supports 1-4 bytes/pixel images.
+
+   * ZIP archive API notes:
+
+     The ZIP archive API's where designed with simplicity and efficiency in mind, with just enough abstraction to
+     get the job done with minimal fuss. There are simple API's to retrieve file information, read files from
+     existing archives, create new archives, append new files to existing archives, or clone archive data from
+     one archive to another. It supports archives located in memory or the heap, on disk (using stdio.h),
+     or you can specify custom file read/write callbacks.
+
+     - Archive reading: Just call this function to read a single file from a disk archive:
+
+      void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name,
+        size_t *pSize, mz_uint zip_flags);
+
+     For more complex cases, use the "mz_zip_reader" functions. Upon opening an archive, the entire central
+     directory is located and read as-is into memory, and subsequent file access only occurs when reading individual files.
+
+     - Archives file scanning: The simple way is to use this function to scan a loaded archive for a specific file:
+
+     int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);
+
+     The locate operation can optionally check file comments too, which (as one example) can be used to identify
+     multiple versions of the same file in an archive. This function uses a simple linear search through the central
+     directory, so it's not very fast.
+
+     Alternately, you can iterate through all the files in an archive (using mz_zip_reader_get_num_files()) and
+     retrieve detailed info on each file by calling mz_zip_reader_file_stat().
+
+     - Archive creation: Use the "mz_zip_writer" functions. The ZIP writer immediately writes compressed file data
+     to disk and builds an exact image of the central directory in memory. The central directory image is written
+     all at once at the end of the archive file when the archive is finalized.
+
+     The archive writer can optionally align each file's local header and file data to any power of 2 alignment,
+     which can be useful when the archive will be read from optical media. Also, the writer supports placing
+     arbitrary data blobs at the very beginning of ZIP archives. Archives written using either feature are still
+     readable by any ZIP tool.
+
+     - Archive appending: The simple way to add a single file to an archive is to call this function:
+
+      mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name,
+        const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);
+
+     The archive will be created if it doesn't already exist, otherwise it'll be appended to.
+     Note the appending is done in-place and is not an atomic operation, so if something goes wrong
+     during the operation it's possible the archive could be left without a central directory (although the local
+     file headers and file data will be fine, so the archive will be recoverable).
+
+     For more complex archive modification scenarios:
+     1. The safest way is to use a mz_zip_reader to read the existing archive, cloning only those bits you want to
+     preserve into a new archive using using the mz_zip_writer_add_from_zip_reader() function (which compiles the
+     compressed file data as-is). When you're done, delete the old archive and rename the newly written archive, and
+     you're done. This is safe but requires a bunch of temporary disk space or heap memory.
+
+     2. Or, you can convert an mz_zip_reader in-place to an mz_zip_writer using mz_zip_writer_init_from_reader(),
+     append new files as needed, then finalize the archive which will write an updated central directory to the
+     original archive. (This is basically what mz_zip_add_mem_to_archive_file_in_place() does.) There's a
+     possibility that the archive's central directory could be lost with this method if anything goes wrong, though.
+
+     - ZIP archive support limitations:
+     No zip64 or spanning support. Extraction functions can only handle unencrypted, stored or deflated files.
+     Requires streams capable of seeking.
+
+   * This is a header file library, like stb_image.c. To get only a header file, either cut and paste the
+     below header, or create miniz.h, #define MINIZ_HEADER_FILE_ONLY, and then include miniz.c from it.
+
+   * Important: For best perf. be sure to customize the below macros for your target platform:
+     #define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1
+     #define MINIZ_LITTLE_ENDIAN 1
+     #define MINIZ_HAS_64BIT_REGISTERS 1
+
+   * On platforms using glibc, Be sure to "#define _LARGEFILE64_SOURCE 1" before including miniz.c to ensure miniz
+     uses the 64-bit variants: fopen64(), stat64(), etc. Otherwise you won't be able to process large files
+     (i.e. 32-bit stat() fails for me on files > 0x7FFFFFFF bytes).
+*/
+
+#ifndef MINIZ_HEADER_INCLUDED
+#    define MINIZ_HEADER_INCLUDED
+
+#    include <stdlib.h>
+
+// Defines to completely disable specific portions of miniz.c:
+// If all macros here are defined the only functionality remaining will be CRC-32, adler-32, tinfl, and tdefl.
+
+// Define MINIZ_NO_STDIO to disable all usage and any functions which rely on stdio for file I/O.
+//#define MINIZ_NO_STDIO
+
+// If MINIZ_NO_TIME is specified then the ZIP archive functions will not be able to get the current time, or
+// get/set file times, and the C run-time funcs that get/set times won't be called.
+// The current downside is the times written to your archives will be from 1979.
+//#define MINIZ_NO_TIME
+
+// Define MINIZ_NO_ARCHIVE_APIS to disable all ZIP archive API's.
+//#define MINIZ_NO_ARCHIVE_APIS
+
+// Define MINIZ_NO_ARCHIVE_APIS to disable all writing related ZIP archive API's.
+//#define MINIZ_NO_ARCHIVE_WRITING_APIS
+
+// Define MINIZ_NO_ZLIB_APIS to remove all ZLIB-style compression/decompression API's.
+//#define MINIZ_NO_ZLIB_APIS
+
+// Define MINIZ_NO_ZLIB_COMPATIBLE_NAME to disable zlib names, to prevent conflicts against stock zlib.
+//#define MINIZ_NO_ZLIB_COMPATIBLE_NAMES
+
+// Define MINIZ_NO_MALLOC to disable all calls to malloc, free, and realloc.
+// Note if MINIZ_NO_MALLOC is defined then the user must always provide custom user alloc/free/realloc
+// callbacks to the zlib and archive API's, and a few stand-alone helper API's which don't provide custom user
+// functions (such as tdefl_compress_mem_to_heap() and tinfl_decompress_mem_to_heap()) won't work.
+//#define MINIZ_NO_MALLOC
+
+#    if defined(__TINYC__) && (defined(__linux) || defined(__linux__))
+// TODO: Work around "error: include file 'sys\utime.h' when compiling with tcc on Linux
+#        define MINIZ_NO_TIME
+#    endif
+
+#    if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_ARCHIVE_APIS)
+#        include <time.h>
+#    endif
+
+#    if defined(_M_IX86) || defined(_M_X64) || defined(__i386__) || defined(__i386) || defined(__i486__) || defined(__i486) || defined(i386) \
+      || defined(__ia64__) || defined(__x86_64__)
+// MINIZ_X86_OR_X64_CPU is only used to help set the below macros.
+#        define MINIZ_X86_OR_X64_CPU 1
+#    endif
+
+#    if (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || MINIZ_X86_OR_X64_CPU
+// Set MINIZ_LITTLE_ENDIAN to 1 if the processor is little endian.
+#        define MINIZ_LITTLE_ENDIAN 1
+#    endif
+
+#    if MINIZ_X86_OR_X64_CPU
+// Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES to 1 on CPU's that permit efficient integer loads and stores from unaligned addresses.
+#        define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1
+#    endif
+
+#    if defined(_M_X64) || defined(_WIN64) || defined(__MINGW64__) || defined(_LP64) || defined(__LP64__) || defined(__ia64__) || defined(__x86_64__)
+// Set MINIZ_HAS_64BIT_REGISTERS to 1 if operations on 64-bit integers are reasonably fast (and don't involve compiler generated calls to helper functions).
+#        define MINIZ_HAS_64BIT_REGISTERS 1
+#    endif
+
+#    ifdef __cplusplus
+extern "C"
+{
+#    endif
+
+    // ------------------- zlib-style API Definitions.
+
+    // For more compatibility with zlib, miniz.c uses unsigned long for some parameters/struct members. Beware: mz_ulong can be either 32 or 64-bits!
+    typedef unsigned long mz_ulong;
+
+    // mz_free() internally uses the MZ_FREE() macro (which by default calls free() unless you've modified the MZ_MALLOC macro) to release a block allocated from the heap.
+    void mz_free(void* p);
+
+#    define MZ_ADLER32_INIT (1)
+    // mz_adler32() returns the initial adler-32 value to use when called with ptr==NULL.
+    mz_ulong mz_adler32(mz_ulong adler, const unsigned char* ptr, size_t buf_len);
+
+#    define MZ_CRC32_INIT (0)
+    // mz_crc32() returns the initial CRC-32 value to use when called with ptr==NULL.
+    mz_ulong mz_crc32(mz_ulong crc, const unsigned char* ptr, size_t buf_len);
+
+    // Compression strategies.
+    enum
+    {
+        MZ_DEFAULT_STRATEGY = 0,
+        MZ_FILTERED = 1,
+        MZ_HUFFMAN_ONLY = 2,
+        MZ_RLE = 3,
+        MZ_FIXED = 4
+    };
+
+// Method
+#    define MZ_DEFLATED 8
+
+#    ifndef MINIZ_NO_ZLIB_APIS
+
+    // Heap allocation callbacks.
+    // Note that mz_alloc_func parameter types purpsosely differ from zlib's: items/size is size_t, not unsigned long.
+    typedef void* (*mz_alloc_func)(void* opaque, size_t items, size_t size);
+    typedef void (*mz_free_func)(void* opaque, void* address);
+    typedef void* (*mz_realloc_func)(void* opaque, void* address, size_t items, size_t size);
+
+#        define MZ_VERSION "9.1.15"
+#        define MZ_VERNUM 0x91F0
+#        define MZ_VER_MAJOR 9
+#        define MZ_VER_MINOR 1
+#        define MZ_VER_REVISION 15
+#        define MZ_VER_SUBREVISION 0
+
+    // Flush values. For typical usage you only need MZ_NO_FLUSH and MZ_FINISH. The other values are for advanced use (refer to the zlib docs).
+    enum
+    {
+        MZ_NO_FLUSH = 0,
+        MZ_PARTIAL_FLUSH = 1,
+        MZ_SYNC_FLUSH = 2,
+        MZ_FULL_FLUSH = 3,
+        MZ_FINISH = 4,
+        MZ_BLOCK = 5
+    };
+
+    // Return status codes. MZ_PARAM_ERROR is non-standard.
+    enum
+    {
+        MZ_OK = 0,
+        MZ_STREAM_END = 1,
+        MZ_NEED_DICT = 2,
+        MZ_ERRNO = -1,
+        MZ_STREAM_ERROR = -2,
+        MZ_DATA_ERROR = -3,
+        MZ_MEM_ERROR = -4,
+        MZ_BUF_ERROR = -5,
+        MZ_VERSION_ERROR = -6,
+        MZ_PARAM_ERROR = -10000
+    };
+
+    // Compression levels: 0-9 are the standard zlib-style levels, 10 is best possible compression (not zlib compatible, and may be very slow), MZ_DEFAULT_COMPRESSION=MZ_DEFAULT_LEVEL.
+    enum
+    {
+        MZ_NO_COMPRESSION = 0,
+        MZ_BEST_SPEED = 1,
+        MZ_BEST_COMPRESSION = 9,
+        MZ_UBER_COMPRESSION = 10,
+        MZ_DEFAULT_LEVEL = 6,
+        MZ_DEFAULT_COMPRESSION = -1
+    };
+
+// Window bits
+#        define MZ_DEFAULT_WINDOW_BITS 15
+
+    struct mz_internal_state;
+
+    // Compression/decompression stream struct.
+    typedef struct mz_stream_s
+    {
+        const unsigned char* next_in;  // pointer to next byte to read
+        unsigned int avail_in;         // number of bytes available at next_in
+        mz_ulong total_in;             // total number of bytes consumed so far
+
+        unsigned char* next_out;  // pointer to next byte to write
+        unsigned int avail_out;   // number of bytes that can be written to next_out
+        mz_ulong total_out;       // total number of bytes produced so far
+
+        char* msg;                        // error msg (unused)
+        struct mz_internal_state* state;  // internal state, allocated by zalloc/zfree
+
+        mz_alloc_func zalloc;  // optional heap allocation function (defaults to malloc)
+        mz_free_func zfree;    // optional heap free function (defaults to free)
+        void* opaque;          // heap alloc function user pointer
+
+        int data_type;      // data_type (unused)
+        mz_ulong adler;     // adler32 of the source or uncompressed data
+        mz_ulong reserved;  // not used
+    } mz_stream;
+
+    typedef mz_stream* mz_streamp;
+
+    // Returns the version string of miniz.c.
+    const char* mz_version(void);
+
+    // mz_deflateInit() initializes a compressor with default options:
+    // Parameters:
+    //  pStream must point to an initialized mz_stream struct.
+    //  level must be between [MZ_NO_COMPRESSION, MZ_BEST_COMPRESSION].
+    //  level 1 enables a specially optimized compression function that's been optimized purely for performance, not ratio.
+    //  (This special func. is currently only enabled when MINIZ_USE_UNALIGNED_LOADS_AND_STORES and MINIZ_LITTLE_ENDIAN are defined.)
+    // Return values:
+    //  MZ_OK on success.
+    //  MZ_STREAM_ERROR if the stream is bogus.
+    //  MZ_PARAM_ERROR if the input parameters are bogus.
+    //  MZ_MEM_ERROR on out of memory.
+    int mz_deflateInit(mz_streamp pStream, int level);
+
+    // mz_deflateInit2() is like mz_deflate(), except with more control:
+    // Additional parameters:
+    //   method must be MZ_DEFLATED
+    //   window_bits must be MZ_DEFAULT_WINDOW_BITS (to wrap the deflate stream with zlib header/adler-32 footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate/no header or footer)
+    //   mem_level must be between [1, 9] (it's checked but ignored by miniz.c)
+    int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy);
+
+    // Quickly resets a compressor without having to reallocate anything. Same as calling mz_deflateEnd() followed by mz_deflateInit()/mz_deflateInit2().
+    int mz_deflateReset(mz_streamp pStream);
+
+    // mz_deflate() compresses the input to output, consuming as much of the input and producing as much output as possible.
+    // Parameters:
+    //   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members.
+    //   flush may be MZ_NO_FLUSH, MZ_PARTIAL_FLUSH/MZ_SYNC_FLUSH, MZ_FULL_FLUSH, or MZ_FINISH.
+    // Return values:
+    //   MZ_OK on success (when flushing, or if more input is needed but not available, and/or there's more output to be written but the output buffer is full).
+    //   MZ_STREAM_END if all input has been consumed and all output bytes have been written. Don't call mz_deflate() on the stream anymore.
+    //   MZ_STREAM_ERROR if the stream is bogus.
+    //   MZ_PARAM_ERROR if one of the parameters is invalid.
+    //   MZ_BUF_ERROR if no forward progress is possible because the input and/or output buffers are empty. (Fill up the input buffer or free up some output space and try again.)
+    int mz_deflate(mz_streamp pStream, int flush);
+
+    // mz_deflateEnd() deinitializes a compressor:
+    // Return values:
+    //  MZ_OK on success.
+    //  MZ_STREAM_ERROR if the stream is bogus.
+    int mz_deflateEnd(mz_streamp pStream);
+
+    // mz_deflateBound() returns a (very) conservative upper bound on the amount of data that could be generated by deflate(), assuming flush is set to only MZ_NO_FLUSH or MZ_FINISH.
+    mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len);
+
+    // Single-call compression functions mz_compress() and mz_compress2():
+    // Returns MZ_OK on success, or one of the error codes from mz_deflate() on failure.
+    int mz_compress(unsigned char* pDest, mz_ulong* pDest_len, const unsigned char* pSource, mz_ulong source_len);
+    int mz_compress2(unsigned char* pDest, mz_ulong* pDest_len, const unsigned char* pSource, mz_ulong source_len, int level);
+
+    // mz_compressBound() returns a (very) conservative upper bound on the amount of data that could be generated by calling mz_compress().
+    mz_ulong mz_compressBound(mz_ulong source_len);
+
+    // Initializes a decompressor.
+    int mz_inflateInit(mz_streamp pStream);
+
+    // mz_inflateInit2() is like mz_inflateInit() with an additional option that controls the window size and whether or not the stream has been wrapped with a zlib header/footer:
+    // window_bits must be MZ_DEFAULT_WINDOW_BITS (to parse zlib header/footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate).
+    int mz_inflateInit2(mz_streamp pStream, int window_bits);
+
+    // Decompresses the input stream to the output, consuming only as much of the input as needed, and writing as much to the output as possible.
+    // Parameters:
+    //   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members.
+    //   flush may be MZ_NO_FLUSH, MZ_SYNC_FLUSH, or MZ_FINISH.
+    //   On the first call, if flush is MZ_FINISH it's assumed the input and output buffers are both sized large enough to decompress the entire stream in a single call (this is slightly faster).
+    //   MZ_FINISH implies that there are no more source bytes available beside what's already in the input buffer, and that the output buffer is large enough to hold the rest of the decompressed data.
+    // Return values:
+    //   MZ_OK on success. Either more input is needed but not available, and/or there's more output to be written but the output buffer is full.
+    //   MZ_STREAM_END if all needed input has been consumed and all output bytes have been written. For zlib streams, the adler-32 of the decompressed data has also been verified.
+    //   MZ_STREAM_ERROR if the stream is bogus.
+    //   MZ_DATA_ERROR if the deflate stream is invalid.
+    //   MZ_PARAM_ERROR if one of the parameters is invalid.
+    //   MZ_BUF_ERROR if no forward progress is possible because the input buffer is empty but the inflater needs more input to continue, or if the output buffer is not large enough. Call mz_inflate() again
+    //   with more input data, or with more room in the output buffer (except when using single call decompression, described above).
+    int mz_inflate(mz_streamp pStream, int flush);
+
+    // Deinitializes a decompressor.
+    int mz_inflateEnd(mz_streamp pStream);
+
+    // Single-call decompression.
+    // Returns MZ_OK on success, or one of the error codes from mz_inflate() on failure.
+    int mz_uncompress(unsigned char* pDest, mz_ulong* pDest_len, const unsigned char* pSource, mz_ulong source_len);
+
+    // Returns a string description of the specified error code, or NULL if the error code is invalid.
+    const char* mz_error(int err);
+
+// Redefine zlib-compatible names to miniz equivalents, so miniz.c can be used as a drop-in replacement for the subset of zlib that miniz.c supports.
+// Define MINIZ_NO_ZLIB_COMPATIBLE_NAMES to disable zlib-compatibility if you use zlib in the same project.
+#        ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES
+    typedef unsigned char Byte;
+    typedef unsigned int uInt;
+    typedef mz_ulong uLong;
+    typedef Byte Bytef;
+    typedef uInt uIntf;
+    typedef char charf;
+    typedef int intf;
+    typedef void* voidpf;
+    typedef uLong uLongf;
+    typedef void* voidp;
+    typedef void* const voidpc;
+#            define Z_NULL 0
+#            define Z_NO_FLUSH MZ_NO_FLUSH
+#            define Z_PARTIAL_FLUSH MZ_PARTIAL_FLUSH
+#            define Z_SYNC_FLUSH MZ_SYNC_FLUSH
+#            define Z_FULL_FLUSH MZ_FULL_FLUSH
+#            define Z_FINISH MZ_FINISH
+#            define Z_BLOCK MZ_BLOCK
+#            define Z_OK MZ_OK
+#            define Z_STREAM_END MZ_STREAM_END
+#            define Z_NEED_DICT MZ_NEED_DICT
+#            define Z_ERRNO MZ_ERRNO
+#            define Z_STREAM_ERROR MZ_STREAM_ERROR
+#            define Z_DATA_ERROR MZ_DATA_ERROR
+#            define Z_MEM_ERROR MZ_MEM_ERROR
+#            define Z_BUF_ERROR MZ_BUF_ERROR
+#            define Z_VERSION_ERROR MZ_VERSION_ERROR
+#            define Z_PARAM_ERROR MZ_PARAM_ERROR
+#            define Z_NO_COMPRESSION MZ_NO_COMPRESSION
+#            define Z_BEST_SPEED MZ_BEST_SPEED
+#            define Z_BEST_COMPRESSION MZ_BEST_COMPRESSION
+#            define Z_DEFAULT_COMPRESSION MZ_DEFAULT_COMPRESSION
+#            define Z_DEFAULT_STRATEGY MZ_DEFAULT_STRATEGY
+#            define Z_FILTERED MZ_FILTERED
+#            define Z_HUFFMAN_ONLY MZ_HUFFMAN_ONLY
+#            define Z_RLE MZ_RLE
+#            define Z_FIXED MZ_FIXED
+#            define Z_DEFLATED MZ_DEFLATED
+#            define Z_DEFAULT_WINDOW_BITS MZ_DEFAULT_WINDOW_BITS
+#            define alloc_func mz_alloc_func
+#            define free_func mz_free_func
+#            define internal_state mz_internal_state
+#            define z_stream mz_stream
+#            define deflateInit mz_deflateInit
+#            define deflateInit2 mz_deflateInit2
+#            define deflateReset mz_deflateReset
+#            define deflate mz_deflate
+#            define deflateEnd mz_deflateEnd
+#            define deflateBound mz_deflateBound
+#            define compress mz_compress
+#            define compress2 mz_compress2
+#            define compressBound mz_compressBound
+#            define inflateInit mz_inflateInit
+#            define inflateInit2 mz_inflateInit2
+#            define inflate mz_inflate
+#            define inflateEnd mz_inflateEnd
+#            define uncompress mz_uncompress
+#            define crc32 mz_crc32
+#            define adler32 mz_adler32
+#            define MAX_WBITS 15
+#            define MAX_MEM_LEVEL 9
+#            define zError mz_error
+#            define ZLIB_VERSION MZ_VERSION
+#            define ZLIB_VERNUM MZ_VERNUM
+#            define ZLIB_VER_MAJOR MZ_VER_MAJOR
+#            define ZLIB_VER_MINOR MZ_VER_MINOR
+#            define ZLIB_VER_REVISION MZ_VER_REVISION
+#            define ZLIB_VER_SUBREVISION MZ_VER_SUBREVISION
+#            define zlibVersion mz_version
+#            define zlib_version mz_version()
+#        endif  // #ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES
+
+#    endif  // MINIZ_NO_ZLIB_APIS
+
+    // ------------------- Types and macros
+
+    typedef unsigned char mz_uint8;
+    typedef signed short mz_int16;
+    typedef unsigned short mz_uint16;
+    typedef unsigned int mz_uint32;
+    typedef unsigned int mz_uint;
+    typedef long long mz_int64;
+    typedef unsigned long long mz_uint64;
+    typedef int mz_bool;
+
+#    define MZ_FALSE (0)
+#    define MZ_TRUE (1)
+
+// An attempt to work around MSVC's spammy "warning C4127: conditional expression is constant" message.
+#    ifdef _MSC_VER
+#        define MZ_MACRO_END while (0, 0)
+#    else
+#        define MZ_MACRO_END while (0)
+#    endif
+
+    // ------------------- ZIP archive reading/writing
+
+#    ifndef MINIZ_NO_ARCHIVE_APIS
+
+    enum
+    {
+        MZ_ZIP_MAX_IO_BUF_SIZE = 64 * 1024,
+        MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE = 260,
+        MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE = 256
+    };
+
+    typedef struct
+    {
+        mz_uint32 m_file_index;
+        mz_uint32 m_central_dir_ofs;
+        mz_uint16 m_version_made_by;
+        mz_uint16 m_version_needed;
+        mz_uint16 m_bit_flag;
+        mz_uint16 m_method;
+#        ifndef MINIZ_NO_TIME
+        time_t m_time;
+#        endif
+        mz_uint32 m_crc32;
+        mz_uint64 m_comp_size;
+        mz_uint64 m_uncomp_size;
+        mz_uint16 m_internal_attr;
+        mz_uint32 m_external_attr;
+        mz_uint64 m_local_header_ofs;
+        mz_uint32 m_comment_size;
+        char m_filename[MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE];
+        char m_comment[MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE];
+    } mz_zip_archive_file_stat;
+
+    typedef size_t (*mz_file_read_func)(void* pOpaque, mz_uint64 file_ofs, void* pBuf, size_t n);
+    typedef size_t (*mz_file_write_func)(void* pOpaque, mz_uint64 file_ofs, const void* pBuf, size_t n);
+
+    struct mz_zip_internal_state_tag;
+    typedef struct mz_zip_internal_state_tag mz_zip_internal_state;
+
+    typedef enum
+    {
+        MZ_ZIP_MODE_INVALID = 0,
+        MZ_ZIP_MODE_READING = 1,
+        MZ_ZIP_MODE_WRITING = 2,
+        MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED = 3
+    } mz_zip_mode;
+
+    typedef struct mz_zip_archive_tag
+    {
+        mz_uint64 m_archive_size;
+        mz_uint64 m_central_directory_file_ofs;
+        mz_uint m_total_files;
+        mz_zip_mode m_zip_mode;
+
+        mz_uint m_file_offset_alignment;
+
+        mz_alloc_func m_pAlloc;
+        mz_free_func m_pFree;
+        mz_realloc_func m_pRealloc;
+        void* m_pAlloc_opaque;
+
+        mz_file_read_func m_pRead;
+        mz_file_write_func m_pWrite;
+        void* m_pIO_opaque;
+
+        mz_zip_internal_state* m_pState;
+
+    } mz_zip_archive;
+
+    typedef enum
+    {
+        MZ_ZIP_FLAG_CASE_SENSITIVE = 0x0100,
+        MZ_ZIP_FLAG_IGNORE_PATH = 0x0200,
+        MZ_ZIP_FLAG_COMPRESSED_DATA = 0x0400,
+        MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY = 0x0800
+    } mz_zip_flags;
+
+    // ZIP archive reading
+
+    // Inits a ZIP archive reader.
+    // These functions read and validate the archive's central directory.
+    mz_bool mz_zip_reader_init(mz_zip_archive* pZip, mz_uint64 size, mz_uint32 flags);
+    mz_bool mz_zip_reader_init_mem(mz_zip_archive* pZip, const void* pMem, size_t size, mz_uint32 flags);
+
+#        ifndef MINIZ_NO_STDIO
+    mz_bool mz_zip_reader_init_file(mz_zip_archive* pZip, const char* pFilename, mz_uint32 flags);
+#        endif
+
+    // Returns the total number of files in the archive.
+    mz_uint mz_zip_reader_get_num_files(mz_zip_archive* pZip);
+
+    // Returns detailed information about an archive file entry.
+    mz_bool mz_zip_reader_file_stat(mz_zip_archive* pZip, mz_uint file_index, mz_zip_archive_file_stat* pStat);
+
+    // Determines if an archive file entry is a directory entry.
+    mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive* pZip, mz_uint file_index);
+    mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive* pZip, mz_uint file_index);
+
+    // Retrieves the filename of an archive file entry.
+    // Returns the number of bytes written to pFilename, or if filename_buf_size is 0 this function returns the number of bytes needed to fully store the filename.
+    mz_uint mz_zip_reader_get_filename(mz_zip_archive* pZip, mz_uint file_index, char* pFilename, mz_uint filename_buf_size);
+
+    // Attempts to locates a file in the archive's central directory.
+    // Valid flags: MZ_ZIP_FLAG_CASE_SENSITIVE, MZ_ZIP_FLAG_IGNORE_PATH
+    // Returns -1 if the file cannot be found.
+    int mz_zip_reader_locate_file(mz_zip_archive* pZip, const char* pName, const char* pComment, mz_uint flags);
+
+    // Extracts a archive file to a memory buffer using no memory allocation.
+    mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive* pZip, mz_uint file_index, void* pBuf, size_t buf_size, mz_uint flags,
+                                                  void* pUser_read_buf, size_t user_read_buf_size);
+    mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive* pZip, const char* pFilename, void* pBuf, size_t buf_size, mz_uint flags,
+                                                       void* pUser_read_buf, size_t user_read_buf_size);
+
+    // Extracts a archive file to a memory buffer.
+    mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive* pZip, mz_uint file_index, void* pBuf, size_t buf_size, mz_uint flags);
+    mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive* pZip, const char* pFilename, void* pBuf, size_t buf_size, mz_uint flags);
+
+    // Extracts a archive file to a dynamically allocated heap buffer.
+    void* mz_zip_reader_extract_to_heap(mz_zip_archive* pZip, mz_uint file_index, size_t* pSize, mz_uint flags);
+    void* mz_zip_reader_extract_file_to_heap(mz_zip_archive* pZip, const char* pFilename, size_t* pSize, mz_uint flags);
+
+    // Extracts a archive file using a callback function to output the file's data.
+    mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive* pZip, mz_uint file_index, mz_file_write_func pCallback, void* pOpaque, mz_uint flags);
+    mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive* pZip, const char* pFilename, mz_file_write_func pCallback, void* pOpaque,
+                                                   mz_uint flags);
+
+#        ifndef MINIZ_NO_STDIO
+    // Extracts a archive file to a disk file and sets its last accessed and modified times.
+    // This function only extracts files, not archive directory records.
+    mz_bool mz_zip_reader_extract_to_file(mz_zip_archive* pZip, mz_uint file_index, const char* pDst_filename, mz_uint flags);
+    mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive* pZip, const char* pArchive_filename, const char* pDst_filename, mz_uint flags);
+#        endif
+
+    // Ends archive reading, freeing all allocations, and closing the input archive file if mz_zip_reader_init_file() was used.
+    mz_bool mz_zip_reader_end(mz_zip_archive* pZip);
+
+    // ZIP archive writing
+
+#        ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
+
+    // Inits a ZIP archive writer.
+    mz_bool mz_zip_writer_init(mz_zip_archive* pZip, mz_uint64 existing_size);
+    mz_bool mz_zip_writer_init_heap(mz_zip_archive* pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size);
+
+#            ifndef MINIZ_NO_STDIO
+    mz_bool mz_zip_writer_init_file(mz_zip_archive* pZip, const char* pFilename, mz_uint64 size_to_reserve_at_beginning);
+#            endif
+
+    // Converts a ZIP archive reader object into a writer object, to allow efficient in-place file appends to occur on an existing archive.
+    // For archives opened using mz_zip_reader_init_file, pFilename must be the archive's filename so it can be reopened for writing. If the file can't be reopened, mz_zip_reader_end() will be called.
+    // For archives opened using mz_zip_reader_init_mem, the memory block must be growable using the realloc callback (which defaults to realloc unless you've overridden it).
+    // Finally, for archives opened using mz_zip_reader_init, the mz_zip_archive's user provided m_pWrite function cannot be NULL.
+    // Note: In-place archive modification is not recommended unless you know what you're doing, because if execution stops or something goes wrong before
+    // the archive is finalized the file's central directory will be hosed.
+    mz_bool mz_zip_writer_init_from_reader(mz_zip_archive* pZip, const char* pFilename);
+
+    // Adds the contents of a memory buffer to an archive. These functions record the current local time into the archive.
+    // To add a directory entry, call this method with an archive name ending in a forwardslash with empty buffer.
+    // level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION.
+    mz_bool mz_zip_writer_add_mem(mz_zip_archive* pZip, const char* pArchive_name, const void* pBuf, size_t buf_size, mz_uint level_and_flags);
+    mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive* pZip, const char* pArchive_name, const void* pBuf, size_t buf_size, const void* pComment,
+                                     mz_uint16 comment_size, mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32);
+
+#            ifndef MINIZ_NO_STDIO
+    // Adds the contents of a disk file to an archive. This function also records the disk file's modified time into the archive.
+    // level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION.
+    mz_bool mz_zip_writer_add_file(mz_zip_archive* pZip, const char* pArchive_name, const char* pSrc_filename, const void* pComment,
+                                   mz_uint16 comment_size, mz_uint level_and_flags);
+#            endif
+
+    // Adds a file to an archive by fully cloning the data from another archive.
+    // This function fully clones the source file's compressed data (no recompression), along with its full filename, extra data, and comment fields.
+    mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive* pZip, mz_zip_archive* pSource_zip, mz_uint file_index);
+
+    // Finalizes the archive by writing the central directory records followed by the end of central directory record.
+    // After an archive is finalized, the only valid call on the mz_zip_archive struct is mz_zip_writer_end().
+    // An archive must be manually finalized by calling this function for it to be valid.
+    mz_bool mz_zip_writer_finalize_archive(mz_zip_archive* pZip);
+    mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive* pZip, void** pBuf, size_t* pSize);
+
+    // Ends archive writing, freeing all allocations, and closing the output file if mz_zip_writer_init_file() was used.
+    // Note for the archive to be valid, it must have been finalized before ending.
+    mz_bool mz_zip_writer_end(mz_zip_archive* pZip);
+
+    // Misc. high-level helper functions:
+
+    // mz_zip_add_mem_to_archive_file_in_place() efficiently (but not atomically) appends a memory blob to a ZIP archive.
+    // level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION.
+    mz_bool mz_zip_add_mem_to_archive_file_in_place(const char* pZip_filename, const char* pArchive_name, const void* pBuf, size_t buf_size,
+                                                    const void* pComment, mz_uint16 comment_size, mz_uint level_and_flags);
+
+    // Reads a single file from an archive into a heap block.
+    // Returns NULL on failure.
+    void* mz_zip_extract_archive_file_to_heap(const char* pZip_filename, const char* pArchive_name, size_t* pSize, mz_uint zip_flags);
+
+#        endif  // #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
+
+#    endif  // #ifndef MINIZ_NO_ARCHIVE_APIS
+
+    // ------------------- Low-level Decompression API Definitions
+
+    // Decompression flags used by tinfl_decompress().
+    // TINFL_FLAG_PARSE_ZLIB_HEADER: If set, the input has a valid zlib header and ends with an adler32 checksum (it's a valid zlib stream). Otherwise, the input is a raw deflate stream.
+    // TINFL_FLAG_HAS_MORE_INPUT: If set, there are more input bytes available beyond the end of the supplied input buffer. If clear, the input buffer contains all remaining input.
+    // TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF: If set, the output buffer is large enough to hold the entire decompressed stream. If clear, the output buffer is at least the size of the dictionary (typically 32KB).
+    // TINFL_FLAG_COMPUTE_ADLER32: Force adler-32 checksum computation of the decompressed bytes.
+    enum
+    {
+        TINFL_FLAG_PARSE_ZLIB_HEADER = 1,
+        TINFL_FLAG_HAS_MORE_INPUT = 2,
+        TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,
+        TINFL_FLAG_COMPUTE_ADLER32 = 8
+    };
+
+    // High level decompression functions:
+    // tinfl_decompress_mem_to_heap() decompresses a block in memory to a heap block allocated via malloc().
+    // On entry:
+    //  pSrc_buf, src_buf_len: Pointer and size of the Deflate or zlib source data to decompress.
+    // On return:
+    //  Function returns a pointer to the decompressed data, or NULL on failure.
+    //  *pOut_len will be set to the decompressed data's size, which could be larger than src_buf_len on uncompressible data.
+    //  The caller must call mz_free() on the returned block when it's no longer needed.
+    void* tinfl_decompress_mem_to_heap(const void* pSrc_buf, size_t src_buf_len, size_t* pOut_len, int flags);
+
+// tinfl_decompress_mem_to_mem() decompresses a block in memory to another block in memory.
+// Returns TINFL_DECOMPRESS_MEM_TO_MEM_FAILED on failure, or the number of bytes written on success.
+#    define TINFL_DECOMPRESS_MEM_TO_MEM_FAILED ((size_t)(-1))
+    size_t tinfl_decompress_mem_to_mem(void* pOut_buf, size_t out_buf_len, const void* pSrc_buf, size_t src_buf_len, int flags);
+
+    // tinfl_decompress_mem_to_callback() decompresses a block in memory to an internal 32KB buffer, and a user provided callback function will be called to flush the buffer.
+    // Returns 1 on success or 0 on failure.
+    typedef int (*tinfl_put_buf_func_ptr)(const void* pBuf, int len, void* pUser);
+    int tinfl_decompress_mem_to_callback(const void* pIn_buf, size_t* pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void* pPut_buf_user,
+                                         int flags);
+
+    struct tinfl_decompressor_tag;
+    typedef struct tinfl_decompressor_tag tinfl_decompressor;
+
+// Max size of LZ dictionary.
+#    define TINFL_LZ_DICT_SIZE 32768
+
+    // Return status.
+    typedef enum
+    {
+        TINFL_STATUS_BAD_PARAM = -3,
+        TINFL_STATUS_ADLER32_MISMATCH = -2,
+        TINFL_STATUS_FAILED = -1,
+        TINFL_STATUS_DONE = 0,
+        TINFL_STATUS_NEEDS_MORE_INPUT = 1,
+        TINFL_STATUS_HAS_MORE_OUTPUT = 2
+    } tinfl_status;
+
+// Initializes the decompressor to its initial state.
+#    define tinfl_init(r)     \
+        do {                  \
+            (r)->m_state = 0; \
+        }                     \
+        MZ_MACRO_END
+#    define tinfl_get_adler32(r) (r)->m_check_adler32
+
+    // Main low-level decompressor coroutine function. This is the only function actually needed for decompression. All the other functions are just high-level helpers for improved usability.
+    // This is a universal API, i.e. it can be used as a building block to build any desired higher level decompression API. In the limit case, it can be called once per every byte input or output.
+    tinfl_status tinfl_decompress(tinfl_decompressor* r, const mz_uint8* pIn_buf_next, size_t* pIn_buf_size, mz_uint8* pOut_buf_start,
+                                  mz_uint8* pOut_buf_next, size_t* pOut_buf_size, const mz_uint32 decomp_flags);
+
+    // Internal/private bits follow.
+    enum
+    {
+        TINFL_MAX_HUFF_TABLES = 3,
+        TINFL_MAX_HUFF_SYMBOLS_0 = 288,
+        TINFL_MAX_HUFF_SYMBOLS_1 = 32,
+        TINFL_MAX_HUFF_SYMBOLS_2 = 19,
+        TINFL_FAST_LOOKUP_BITS = 10,
+        TINFL_FAST_LOOKUP_SIZE = 1 << TINFL_FAST_LOOKUP_BITS
+    };
+
+    typedef struct
+    {
+        mz_uint8 m_code_size[TINFL_MAX_HUFF_SYMBOLS_0];
+        mz_int16 m_look_up[TINFL_FAST_LOOKUP_SIZE], m_tree[TINFL_MAX_HUFF_SYMBOLS_0 * 2];
+    } tinfl_huff_table;
+
+#    if MINIZ_HAS_64BIT_REGISTERS
+#        define TINFL_USE_64BIT_BITBUF 1
+#    endif
+
+#    if TINFL_USE_64BIT_BITBUF
+    typedef mz_uint64 tinfl_bit_buf_t;
+#        define TINFL_BITBUF_SIZE (64)
+#    else
+typedef mz_uint32 tinfl_bit_buf_t;
+#        define TINFL_BITBUF_SIZE (32)
+#    endif
+
+    struct tinfl_decompressor_tag
+    {
+        mz_uint32 m_state, m_num_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra,
+          m_table_sizes[TINFL_MAX_HUFF_TABLES];
+        tinfl_bit_buf_t m_bit_buf;
+        size_t m_dist_from_out_buf_start;
+        tinfl_huff_table m_tables[TINFL_MAX_HUFF_TABLES];
+        mz_uint8 m_raw_header[4], m_len_codes[TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1 + 137];
+    };
+
+// ------------------- Low-level Compression API Definitions
+
+// Set TDEFL_LESS_MEMORY to 1 to use less memory (compression will be slightly slower, and raw/dynamic blocks will be output more frequently).
+#    define TDEFL_LESS_MEMORY 0
+
+    // tdefl_init() compression flags logically OR'd together (low 12 bits contain the max. number of probes per dictionary search):
+    // TDEFL_DEFAULT_MAX_PROBES: The compressor defaults to 128 dictionary probes per dictionary search. 0=Huffman only, 1=Huffman+LZ (fastest/crap compression), 4095=Huffman+LZ (slowest/best compression).
+    enum
+    {
+        TDEFL_HUFFMAN_ONLY = 0,
+        TDEFL_DEFAULT_MAX_PROBES = 128,
+        TDEFL_MAX_PROBES_MASK = 0xFFF
+    };
+
+    // TDEFL_WRITE_ZLIB_HEADER: If set, the compressor outputs a zlib header before the deflate data, and the Adler-32 of the source data at the end. Otherwise, you'll get raw deflate data.
+    // TDEFL_COMPUTE_ADLER32: Always compute the adler-32 of the input data (even when not writing zlib headers).
+    // TDEFL_GREEDY_PARSING_FLAG: Set to use faster greedy parsing, instead of more efficient lazy parsing.
+    // TDEFL_NONDETERMINISTIC_PARSING_FLAG: Enable to decrease the compressor's initialization time to the minimum, but the output may vary from run to run given the same input (depending on the contents of memory).
+    // TDEFL_RLE_MATCHES: Only look for RLE matches (matches with a distance of 1)
+    // TDEFL_FILTER_MATCHES: Discards matches <= 5 chars if enabled.
+    // TDEFL_FORCE_ALL_STATIC_BLOCKS: Disable usage of optimized Huffman tables.
+    // TDEFL_FORCE_ALL_RAW_BLOCKS: Only use raw (uncompressed) deflate blocks.
+    // The low 12 bits are reserved to control the max # of hash probes per dictionary lookup (see TDEFL_MAX_PROBES_MASK).
+    enum
+    {
+        TDEFL_WRITE_ZLIB_HEADER = 0x01000,
+        TDEFL_COMPUTE_ADLER32 = 0x02000,
+        TDEFL_GREEDY_PARSING_FLAG = 0x04000,
+        TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0x08000,
+        TDEFL_RLE_MATCHES = 0x10000,
+        TDEFL_FILTER_MATCHES = 0x20000,
+        TDEFL_FORCE_ALL_STATIC_BLOCKS = 0x40000,
+        TDEFL_FORCE_ALL_RAW_BLOCKS = 0x80000
+    };
+
+    // High level compression functions:
+    // tdefl_compress_mem_to_heap() compresses a block in memory to a heap block allocated via malloc().
+    // On entry:
+    //  pSrc_buf, src_buf_len: Pointer and size of source block to compress.
+    //  flags: The max match finder probes (default is 128) logically OR'd against the above flags. Higher probes are slower but improve compression.
+    // On return:
+    //  Function returns a pointer to the compressed data, or NULL on failure.
+    //  *pOut_len will be set to the compressed data's size, which could be larger than src_buf_len on uncompressible data.
+    //  The caller must free() the returned block when it's no longer needed.
+    void* tdefl_compress_mem_to_heap(const void* pSrc_buf, size_t src_buf_len, size_t* pOut_len, int flags);
+
+    // tdefl_compress_mem_to_mem() compresses a block in memory to another block in memory.
+    // Returns 0 on failure.
+    size_t tdefl_compress_mem_to_mem(void* pOut_buf, size_t out_buf_len, const void* pSrc_buf, size_t src_buf_len, int flags);
+
+    // Compresses an image to a compressed PNG file in memory.
+    // On entry:
+    //  pImage, w, h, and num_chans describe the image to compress. num_chans may be 1, 2, 3, or 4.
+    //  The image pitch in bytes per scanline will be w*num_chans. The leftmost pixel on the top scanline is stored first in memory.
+    //  level may range from [0,10], use MZ_NO_COMPRESSION, MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc. or a decent default is MZ_DEFAULT_LEVEL
+    //  If flip is true, the image will be flipped on the Y axis (useful for OpenGL apps).
+    // On return:
+    //  Function returns a pointer to the compressed data, or NULL on failure.
+    //  *pLen_out will be set to the size of the PNG image file.
+    //  The caller must mz_free() the returned heap block (which will typically be larger than *pLen_out) when it's no longer needed.
+    void* tdefl_write_image_to_png_file_in_memory_ex(const void* pImage, int w, int h, int num_chans, size_t* pLen_out, mz_uint level, mz_bool flip);
+    void* tdefl_write_image_to_png_file_in_memory(const void* pImage, int w, int h, int num_chans, size_t* pLen_out);
+
+    // Output stream interface. The compressor uses this interface to write compressed data. It'll typically be called TDEFL_OUT_BUF_SIZE at a time.
+    typedef mz_bool (*tdefl_put_buf_func_ptr)(const void* pBuf, int len, void* pUser);
+
+    // tdefl_compress_mem_to_output() compresses a block to an output stream. The above helpers use this function internally.
+    mz_bool tdefl_compress_mem_to_output(const void* pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void* pPut_buf_user, int flags);
+
+    enum
+    {
+        TDEFL_MAX_HUFF_TABLES = 3,
+        TDEFL_MAX_HUFF_SYMBOLS_0 = 288,
+        TDEFL_MAX_HUFF_SYMBOLS_1 = 32,
+        TDEFL_MAX_HUFF_SYMBOLS_2 = 19,
+        TDEFL_LZ_DICT_SIZE = 32768,
+        TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1,
+        TDEFL_MIN_MATCH_LEN = 3,
+        TDEFL_MAX_MATCH_LEN = 258
+    };
+
+// TDEFL_OUT_BUF_SIZE MUST be large enough to hold a single entire compressed output block (using static/fixed Huffman codes).
+#    if TDEFL_LESS_MEMORY
+    enum
+    {
+        TDEFL_LZ_CODE_BUF_SIZE = 24 * 1024,
+        TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,
+        TDEFL_MAX_HUFF_SYMBOLS = 288,
+        TDEFL_LZ_HASH_BITS = 12,
+        TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,
+        TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,
+        TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS
+    };
+#    else
+enum
+{
+    TDEFL_LZ_CODE_BUF_SIZE = 64 * 1024,
+    TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,
+    TDEFL_MAX_HUFF_SYMBOLS = 288,
+    TDEFL_LZ_HASH_BITS = 15,
+    TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,
+    TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,
+    TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS
+};
+#    endif
+
+    // The low-level tdefl functions below may be used directly if the above helper functions aren't flexible enough. The low-level functions don't make any heap allocations, unlike the above helper functions.
+    typedef enum
+    {
+        TDEFL_STATUS_BAD_PARAM = -2,
+        TDEFL_STATUS_PUT_BUF_FAILED = -1,
+        TDEFL_STATUS_OKAY = 0,
+        TDEFL_STATUS_DONE = 1,
+    } tdefl_status;
+
+    // Must map to MZ_NO_FLUSH, MZ_SYNC_FLUSH, etc. enums
+    typedef enum
+    {
+        TDEFL_NO_FLUSH = 0,
+        TDEFL_SYNC_FLUSH = 2,
+        TDEFL_FULL_FLUSH = 3,
+        TDEFL_FINISH = 4
+    } tdefl_flush;
+
+    // tdefl's compression state structure.
+    typedef struct
+    {
+        tdefl_put_buf_func_ptr m_pPut_buf_func;
+        void* m_pPut_buf_user;
+        mz_uint m_flags, m_max_probes[2];
+        int m_greedy_parsing;
+        mz_uint m_adler32, m_lookahead_pos, m_lookahead_size, m_dict_size;
+        mz_uint8 *m_pLZ_code_buf, *m_pLZ_flags, *m_pOutput_buf, *m_pOutput_buf_end;
+        mz_uint m_num_flags_left, m_total_lz_bytes, m_lz_code_buf_dict_pos, m_bits_in, m_bit_buffer;
+        mz_uint m_saved_match_dist, m_saved_match_len, m_saved_lit, m_output_flush_ofs, m_output_flush_remaining, m_finished, m_block_index,
+          m_wants_to_finish;
+        tdefl_status m_prev_return_status;
+        const void* m_pIn_buf;
+        void* m_pOut_buf;
+        size_t *m_pIn_buf_size, *m_pOut_buf_size;
+        tdefl_flush m_flush;
+        const mz_uint8* m_pSrc;
+        size_t m_src_buf_left, m_out_buf_ofs;
+        mz_uint8 m_dict[TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN - 1];
+        mz_uint16 m_huff_count[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
+        mz_uint16 m_huff_codes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
+        mz_uint8 m_huff_code_sizes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
+        mz_uint8 m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE];
+        mz_uint16 m_next[TDEFL_LZ_DICT_SIZE];
+        mz_uint16 m_hash[TDEFL_LZ_HASH_SIZE];
+        mz_uint8 m_output_buf[TDEFL_OUT_BUF_SIZE];
+    } tdefl_compressor;
+
+    // Initializes the compressor.
+    // There is no corresponding deinit() function because the tdefl API's do not dynamically allocate memory.
+    // pBut_buf_func: If NULL, output data will be supplied to the specified callback. In this case, the user should call the tdefl_compress_buffer() API for compression.
+    // If pBut_buf_func is NULL the user should always call the tdefl_compress() API.
+    // flags: See the above enums (TDEFL_HUFFMAN_ONLY, TDEFL_WRITE_ZLIB_HEADER, etc.)
+    tdefl_status tdefl_init(tdefl_compressor* d, tdefl_put_buf_func_ptr pPut_buf_func, void* pPut_buf_user, int flags);
+
+    // Compresses a block of data, consuming as much of the specified input buffer as possible, and writing as much compressed data to the specified output buffer as possible.
+    tdefl_status tdefl_compress(tdefl_compressor* d, const void* pIn_buf, size_t* pIn_buf_size, void* pOut_buf, size_t* pOut_buf_size,
+                                tdefl_flush flush);
+
+    // tdefl_compress_buffer() is only usable when the tdefl_init() is called with a non-NULL tdefl_put_buf_func_ptr.
+    // tdefl_compress_buffer() always consumes the entire input buffer.
+    tdefl_status tdefl_compress_buffer(tdefl_compressor* d, const void* pIn_buf, size_t in_buf_size, tdefl_flush flush);
+
+    tdefl_status tdefl_get_prev_return_status(tdefl_compressor* d);
+    mz_uint32 tdefl_get_adler32(tdefl_compressor* d);
+
+// Can't use tdefl_create_comp_flags_from_zip_params if MINIZ_NO_ZLIB_APIS isn't defined, because it uses some of its macros.
+#    ifndef MINIZ_NO_ZLIB_APIS
+    // Create tdefl_compress() flags given zlib-style compression parameters.
+    // level may range from [0,10] (where 10 is absolute max compression, but may be much slower on some files)
+    // window_bits may be -15 (raw deflate) or 15 (zlib)
+    // strategy may be either MZ_DEFAULT_STRATEGY, MZ_FILTERED, MZ_HUFFMAN_ONLY, MZ_RLE, or MZ_FIXED
+    mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy);
+#    endif  // #ifndef MINIZ_NO_ZLIB_APIS
+
+#    ifdef __cplusplus
+}
+#    endif
+
+#endif  // MINIZ_HEADER_INCLUDED
+
+// ------------------- End of Header: Implementation follows. (If you only want the header, define MINIZ_HEADER_FILE_ONLY.)
+
+#ifndef MINIZ_HEADER_FILE_ONLY
+
+typedef unsigned char mz_validate_uint16[sizeof(mz_uint16) == 2 ? 1 : -1];
+typedef unsigned char mz_validate_uint32[sizeof(mz_uint32) == 4 ? 1 : -1];
+typedef unsigned char mz_validate_uint64[sizeof(mz_uint64) == 8 ? 1 : -1];
+
+#    include <string.h>
+#    include <assert.h>
+
+#    define MZ_ASSERT(x) assert(x)
+
+#    ifdef MINIZ_NO_MALLOC
+#        define MZ_MALLOC(x) NULL
+#        define MZ_FREE(x) (void)x, ((void)0)
+#        define MZ_REALLOC(p, x) NULL
+#    else
+#        define MZ_MALLOC(x) malloc(x)
+#        define MZ_FREE(x) free(x)
+#        define MZ_REALLOC(p, x) realloc(p, x)
+#    endif
+
+#    define MZ_MAX(a, b) (((a) > (b)) ? (a) : (b))
+#    define MZ_MIN(a, b) (((a) < (b)) ? (a) : (b))
+#    define MZ_CLEAR_OBJ(obj) memset(&(obj), 0, sizeof(obj))
+
+#    if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
+#        define MZ_READ_LE16(p) *((const mz_uint16*)(p))
+#        define MZ_READ_LE32(p) *((const mz_uint32*)(p))
+#    else
+#        define MZ_READ_LE16(p) ((mz_uint32)(((const mz_uint8*)(p))[0]) | ((mz_uint32)(((const mz_uint8*)(p))[1]) << 8U))
+#        define MZ_READ_LE32(p)                                                                      \
+            ((mz_uint32)(((const mz_uint8*)(p))[0]) | ((mz_uint32)(((const mz_uint8*)(p))[1]) << 8U) \
+             | ((mz_uint32)(((const mz_uint8*)(p))[2]) << 16U) | ((mz_uint32)(((const mz_uint8*)(p))[3]) << 24U))
+#    endif
+
+#    ifdef _MSC_VER
+#        define MZ_FORCEINLINE __forceinline
+#    elif defined(__GNUC__)
+#        define MZ_FORCEINLINE inline __attribute__((__always_inline__))
+#    else
+#        define MZ_FORCEINLINE inline
+#    endif
+
+#    ifdef __cplusplus
+extern "C"
+{
+#    endif
+
+    // ------------------- zlib-style API's
+
+    mz_ulong mz_adler32(mz_ulong adler, const unsigned char* ptr, size_t buf_len) {
+        mz_uint32 i, s1 = (mz_uint32)(adler & 0xffff), s2 = (mz_uint32)(adler >> 16);
+        size_t block_len = buf_len % 5552;
+        if (!ptr) return MZ_ADLER32_INIT;
+        while (buf_len) {
+            for (i = 0; i + 7 < block_len; i += 8, ptr += 8) {
+                s1 += ptr[0], s2 += s1;
+                s1 += ptr[1], s2 += s1;
+                s1 += ptr[2], s2 += s1;
+                s1 += ptr[3], s2 += s1;
+                s1 += ptr[4], s2 += s1;
+                s1 += ptr[5], s2 += s1;
+                s1 += ptr[6], s2 += s1;
+                s1 += ptr[7], s2 += s1;
+            }
+            for (; i < block_len; ++i)
+                s1 += *ptr++, s2 += s1;
+            s1 %= 65521U, s2 %= 65521U;
+            buf_len -= block_len;
+            block_len = 5552;
+        }
+        return (s2 << 16) + s1;
+    }
+
+    // Karl Malbrain's compact CRC-32. See "A compact CCITT crc16 and crc32 C implementation that balances processor cache usage against speed": http://www.geocities.com/malbrain/
+    mz_ulong mz_crc32(mz_ulong crc, const mz_uint8* ptr, size_t buf_len) {
+        static const mz_uint32 s_crc32[16] = {0,          0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
+                                              0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c};
+        mz_uint32 crcu32 = (mz_uint32)crc;
+        if (!ptr) return MZ_CRC32_INIT;
+        crcu32 = ~crcu32;
+        while (buf_len--) {
+            mz_uint8 b = *ptr++;
+            crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b & 0xF)];
+            crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b >> 4)];
+        }
+        return ~crcu32;
+    }
+
+    void mz_free(void* p) {
+        MZ_FREE(p);
+    }
+
+#    ifndef MINIZ_NO_ZLIB_APIS
+
+    static void* def_alloc_func(void* opaque, size_t items, size_t size) {
+        (void)opaque, (void)items, (void)size;
+        return MZ_MALLOC(items * size);
+    }
+    static void def_free_func(void* opaque, void* address) {
+        (void)opaque, (void)address;
+        MZ_FREE(address);
+    }
+    static void* def_realloc_func(void* opaque, void* address, size_t items, size_t size) {
+        (void)opaque, (void)address, (void)items, (void)size;
+        return MZ_REALLOC(address, items * size);
+    }
+
+    const char* mz_version(void) {
+        return MZ_VERSION;
+    }
+
+    int mz_deflateInit(mz_streamp pStream, int level) {
+        return mz_deflateInit2(pStream, level, MZ_DEFLATED, MZ_DEFAULT_WINDOW_BITS, 9, MZ_DEFAULT_STRATEGY);
+    }
+
+    int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy) {
+        tdefl_compressor* pComp;
+        mz_uint comp_flags = TDEFL_COMPUTE_ADLER32 | tdefl_create_comp_flags_from_zip_params(level, window_bits, strategy);
+
+        if (!pStream) return MZ_STREAM_ERROR;
+        if ((method != MZ_DEFLATED) || ((mem_level < 1) || (mem_level > 9))
+            || ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS)))
+            return MZ_PARAM_ERROR;
+
+        pStream->data_type = 0;
+        pStream->adler = MZ_ADLER32_INIT;
+        pStream->msg = NULL;
+        pStream->reserved = 0;
+        pStream->total_in = 0;
+        pStream->total_out = 0;
+        if (!pStream->zalloc) pStream->zalloc = def_alloc_func;
+        if (!pStream->zfree) pStream->zfree = def_free_func;
+
+        pComp = (tdefl_compressor*)pStream->zalloc(pStream->opaque, 1, sizeof(tdefl_compressor));
+        if (!pComp) return MZ_MEM_ERROR;
+
+        pStream->state = (struct mz_internal_state*)pComp;
+
+        if (tdefl_init(pComp, NULL, NULL, comp_flags) != TDEFL_STATUS_OKAY) {
+            mz_deflateEnd(pStream);
+            return MZ_PARAM_ERROR;
+        }
+
+        return MZ_OK;
+    }
+
+    int mz_deflateReset(mz_streamp pStream) {
+        if ((!pStream) || (!pStream->state) || (!pStream->zalloc) || (!pStream->zfree)) return MZ_STREAM_ERROR;
+        pStream->total_in = pStream->total_out = 0;
+        tdefl_init((tdefl_compressor*)pStream->state, NULL, NULL, ((tdefl_compressor*)pStream->state)->m_flags);
+        return MZ_OK;
+    }
+
+    int mz_deflate(mz_streamp pStream, int flush) {
+        size_t in_bytes, out_bytes;
+        mz_ulong orig_total_in, orig_total_out;
+        int mz_status = MZ_OK;
+
+        if ((!pStream) || (!pStream->state) || (flush < 0) || (flush > MZ_FINISH) || (!pStream->next_out)) return MZ_STREAM_ERROR;
+        if (!pStream->avail_out) return MZ_BUF_ERROR;
+
+        if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;
+
+        if (((tdefl_compressor*)pStream->state)->m_prev_return_status == TDEFL_STATUS_DONE)
+            return (flush == MZ_FINISH) ? MZ_STREAM_END : MZ_BUF_ERROR;
+
+        orig_total_in = pStream->total_in;
+        orig_total_out = pStream->total_out;
+        for (;;) {
+            tdefl_status defl_status;
+            in_bytes = pStream->avail_in;
+            out_bytes = pStream->avail_out;
+
+            defl_status =
+              tdefl_compress((tdefl_compressor*)pStream->state, pStream->next_in, &in_bytes, pStream->next_out, &out_bytes, (tdefl_flush)flush);
+            pStream->next_in += (mz_uint)in_bytes;
+            pStream->avail_in -= (mz_uint)in_bytes;
+            pStream->total_in += (mz_uint)in_bytes;
+            pStream->adler = tdefl_get_adler32((tdefl_compressor*)pStream->state);
+
+            pStream->next_out += (mz_uint)out_bytes;
+            pStream->avail_out -= (mz_uint)out_bytes;
+            pStream->total_out += (mz_uint)out_bytes;
+
+            if (defl_status < 0) {
+                mz_status = MZ_STREAM_ERROR;
+                break;
+            } else if (defl_status == TDEFL_STATUS_DONE) {
+                mz_status = MZ_STREAM_END;
+                break;
+            } else if (!pStream->avail_out)
+                break;
+            else if ((!pStream->avail_in) && (flush != MZ_FINISH)) {
+                if ((flush) || (pStream->total_in != orig_total_in) || (pStream->total_out != orig_total_out)) break;
+                return MZ_BUF_ERROR;  // Can't make forward progress without some input.
+            }
+        }
+        return mz_status;
+    }
+
+    int mz_deflateEnd(mz_streamp pStream) {
+        if (!pStream) return MZ_STREAM_ERROR;
+        if (pStream->state) {
+            pStream->zfree(pStream->opaque, pStream->state);
+            pStream->state = NULL;
+        }
+        return MZ_OK;
+    }
+
+    mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len) {
+        (void)pStream;
+        // This is really over conservative. (And lame, but it's actually pretty tricky to compute a true upper bound given the way tdefl's blocking works.)
+        return MZ_MAX(128 + (source_len * 110) / 100, 128 + source_len + ((source_len / (31 * 1024)) + 1) * 5);
+    }
+
+    int mz_compress2(unsigned char* pDest, mz_ulong* pDest_len, const unsigned char* pSource, mz_ulong source_len, int level) {
+        int status;
+        mz_stream stream;
+        memset(&stream, 0, sizeof(stream));
+
+        // In case mz_ulong is 64-bits (argh I hate longs).
+        if ((source_len | *pDest_len) > 0xFFFFFFFFU) return MZ_PARAM_ERROR;
+
+        stream.next_in = pSource;
+        stream.avail_in = (mz_uint32)source_len;
+        stream.next_out = pDest;
+        stream.avail_out = (mz_uint32)*pDest_len;
+
+        status = mz_deflateInit(&stream, level);
+        if (status != MZ_OK) return status;
+
+        status = mz_deflate(&stream, MZ_FINISH);
+        if (status != MZ_STREAM_END) {
+            mz_deflateEnd(&stream);
+            return (status == MZ_OK) ? MZ_BUF_ERROR : status;
+        }
+
+        *pDest_len = stream.total_out;
+        return mz_deflateEnd(&stream);
+    }
+
+    int mz_compress(unsigned char* pDest, mz_ulong* pDest_len, const unsigned char* pSource, mz_ulong source_len) {
+        return mz_compress2(pDest, pDest_len, pSource, source_len, MZ_DEFAULT_COMPRESSION);
+    }
+
+    mz_ulong mz_compressBound(mz_ulong source_len) {
+        return mz_deflateBound(NULL, source_len);
+    }
+
+    typedef struct
+    {
+        tinfl_decompressor m_decomp;
+        mz_uint m_dict_ofs, m_dict_avail, m_first_call, m_has_flushed;
+        int m_window_bits;
+        mz_uint8 m_dict[TINFL_LZ_DICT_SIZE];
+        tinfl_status m_last_status;
+    } inflate_state;
+
+    int mz_inflateInit2(mz_streamp pStream, int window_bits) {
+        inflate_state* pDecomp;
+        if (!pStream) return MZ_STREAM_ERROR;
+        if ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS)) return MZ_PARAM_ERROR;
+
+        pStream->data_type = 0;
+        pStream->adler = 0;
+        pStream->msg = NULL;
+        pStream->total_in = 0;
+        pStream->total_out = 0;
+        pStream->reserved = 0;
+        if (!pStream->zalloc) pStream->zalloc = def_alloc_func;
+        if (!pStream->zfree) pStream->zfree = def_free_func;
+
+        pDecomp = (inflate_state*)pStream->zalloc(pStream->opaque, 1, sizeof(inflate_state));
+        if (!pDecomp) return MZ_MEM_ERROR;
+
+        pStream->state = (struct mz_internal_state*)pDecomp;
+
+        tinfl_init(&pDecomp->m_decomp);
+        pDecomp->m_dict_ofs = 0;
+        pDecomp->m_dict_avail = 0;
+        pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
+        pDecomp->m_first_call = 1;
+        pDecomp->m_has_flushed = 0;
+        pDecomp->m_window_bits = window_bits;
+
+        return MZ_OK;
+    }
+
+    int mz_inflateInit(mz_streamp pStream) {
+        return mz_inflateInit2(pStream, MZ_DEFAULT_WINDOW_BITS);
+    }
+
+    int mz_inflate(mz_streamp pStream, int flush) {
+        inflate_state* pState;
+        mz_uint n, first_call, decomp_flags = TINFL_FLAG_COMPUTE_ADLER32;
+        size_t in_bytes, out_bytes, orig_avail_in;
+        tinfl_status status;
+
+        if ((!pStream) || (!pStream->state)) return MZ_STREAM_ERROR;
+        if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;
+        if ((flush) && (flush != MZ_SYNC_FLUSH) && (flush != MZ_FINISH)) return MZ_STREAM_ERROR;
+
+        pState = (inflate_state*)pStream->state;
+        if (pState->m_window_bits > 0) decomp_flags |= TINFL_FLAG_PARSE_ZLIB_HEADER;
+        orig_avail_in = pStream->avail_in;
+
+        first_call = pState->m_first_call;
+        pState->m_first_call = 0;
+        if (pState->m_last_status < 0) return MZ_DATA_ERROR;
+
+        if (pState->m_has_flushed && (flush != MZ_FINISH)) return MZ_STREAM_ERROR;
+        pState->m_has_flushed |= (flush == MZ_FINISH);
+
+        if ((flush == MZ_FINISH) && (first_call)) {
+            // MZ_FINISH on the first call implies that the input and output buffers are large enough to hold the entire compressed/decompressed file.
+            decomp_flags |= TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
+            in_bytes = pStream->avail_in;
+            out_bytes = pStream->avail_out;
+            status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pStream->next_out, pStream->next_out, &out_bytes, decomp_flags);
+            pState->m_last_status = status;
+            pStream->next_in += (mz_uint)in_bytes;
+            pStream->avail_in -= (mz_uint)in_bytes;
+            pStream->total_in += (mz_uint)in_bytes;
+            pStream->adler = tinfl_get_adler32(&pState->m_decomp);
+            pStream->next_out += (mz_uint)out_bytes;
+            pStream->avail_out -= (mz_uint)out_bytes;
+            pStream->total_out += (mz_uint)out_bytes;
+
+            if (status < 0)
+                return MZ_DATA_ERROR;
+            else if (status != TINFL_STATUS_DONE) {
+                pState->m_last_status = TINFL_STATUS_FAILED;
+                return MZ_BUF_ERROR;
+            }
+            return MZ_STREAM_END;
+        }
+        // flush != MZ_FINISH then we must assume there's more input.
+        if (flush != MZ_FINISH) decomp_flags |= TINFL_FLAG_HAS_MORE_INPUT;
+
+        if (pState->m_dict_avail) {
+            n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
+            memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
+            pStream->next_out += n;
+            pStream->avail_out -= n;
+            pStream->total_out += n;
+            pState->m_dict_avail -= n;
+            pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);
+            return ((pState->m_last_status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;
+        }
+
+        for (;;) {
+            in_bytes = pStream->avail_in;
+            out_bytes = TINFL_LZ_DICT_SIZE - pState->m_dict_ofs;
+
+            status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pState->m_dict, pState->m_dict + pState->m_dict_ofs, &out_bytes,
+                                      decomp_flags);
+            pState->m_last_status = status;
+
+            pStream->next_in += (mz_uint)in_bytes;
+            pStream->avail_in -= (mz_uint)in_bytes;
+            pStream->total_in += (mz_uint)in_bytes;
+            pStream->adler = tinfl_get_adler32(&pState->m_decomp);
+
+            pState->m_dict_avail = (mz_uint)out_bytes;
+
+            n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
+            memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
+            pStream->next_out += n;
+            pStream->avail_out -= n;
+            pStream->total_out += n;
+            pState->m_dict_avail -= n;
+            pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);
+
+            if (status < 0)
+                return MZ_DATA_ERROR;  // Stream is corrupted (there could be some uncompressed data left in the output dictionary - oh well).
+            else if ((status == TINFL_STATUS_NEEDS_MORE_INPUT) && (!orig_avail_in))
+                return MZ_BUF_ERROR;  // Signal caller that we can't make forward progress without supplying more input or by setting flush to MZ_FINISH.
+            else if (flush == MZ_FINISH) {
+                // The output buffer MUST be large to hold the remaining uncompressed data when flush==MZ_FINISH.
+                if (status == TINFL_STATUS_DONE) return pState->m_dict_avail ? MZ_BUF_ERROR : MZ_STREAM_END;
+                // status here must be TINFL_STATUS_HAS_MORE_OUTPUT, which means there's at least 1 more byte on the way. If there's no more room left in the output buffer then something is wrong.
+                else if (!pStream->avail_out)
+                    return MZ_BUF_ERROR;
+            } else if ((status == TINFL_STATUS_DONE) || (!pStream->avail_in) || (!pStream->avail_out) || (pState->m_dict_avail))
+                break;
+        }
+
+        return ((status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;
+    }
+
+    int mz_inflateEnd(mz_streamp pStream) {
+        if (!pStream) return MZ_STREAM_ERROR;
+        if (pStream->state) {
+            pStream->zfree(pStream->opaque, pStream->state);
+            pStream->state = NULL;
+        }
+        return MZ_OK;
+    }
+
+    int mz_uncompress(unsigned char* pDest, mz_ulong* pDest_len, const unsigned char* pSource, mz_ulong source_len) {
+        mz_stream stream;
+        int status;
+        memset(&stream, 0, sizeof(stream));
+
+        // In case mz_ulong is 64-bits (argh I hate longs).
+        if ((source_len | *pDest_len) > 0xFFFFFFFFU) return MZ_PARAM_ERROR;
+
+        stream.next_in = pSource;
+        stream.avail_in = (mz_uint32)source_len;
+        stream.next_out = pDest;
+        stream.avail_out = (mz_uint32)*pDest_len;
+
+        status = mz_inflateInit(&stream);
+        if (status != MZ_OK) return status;
+
+        status = mz_inflate(&stream, MZ_FINISH);
+        if (status != MZ_STREAM_END) {
+            mz_inflateEnd(&stream);
+            return ((status == MZ_BUF_ERROR) && (!stream.avail_in)) ? MZ_DATA_ERROR : status;
+        }
+        *pDest_len = stream.total_out;
+
+        return mz_inflateEnd(&stream);
+    }
+
+    const char* mz_error(int err) {
+        static struct
+        {
+            int m_err;
+            const char* m_pDesc;
+        } s_error_descs[] = {{MZ_OK, ""},
+                             {MZ_STREAM_END, "stream end"},
+                             {MZ_NEED_DICT, "need dictionary"},
+                             {MZ_ERRNO, "file error"},
+                             {MZ_STREAM_ERROR, "stream error"},
+                             {MZ_DATA_ERROR, "data error"},
+                             {MZ_MEM_ERROR, "out of memory"},
+                             {MZ_BUF_ERROR, "buf error"},
+                             {MZ_VERSION_ERROR, "version error"},
+                             {MZ_PARAM_ERROR, "parameter error"}};
+        mz_uint i;
+        for (i = 0; i < sizeof(s_error_descs) / sizeof(s_error_descs[0]); ++i)
+            if (s_error_descs[i].m_err == err) return s_error_descs[i].m_pDesc;
+        return NULL;
+    }
+
+#    endif  //MINIZ_NO_ZLIB_APIS
+
+    // ------------------- Low-level Decompression (completely independent from all compression API's)
+
+#    define TINFL_MEMCPY(d, s, l) memcpy(d, s, l)
+#    define TINFL_MEMSET(p, c, l) memset(p, c, l)
+
+#    define TINFL_CR_BEGIN    \
+        switch (r->m_state) { \
+            case 0:
+#    define TINFL_CR_RETURN(state_index, result) \
+        do {                                     \
+            status = result;                     \
+            r->m_state = state_index;            \
+            goto common_exit;                    \
+            case state_index:;                   \
+        }                                        \
+        MZ_MACRO_END
+#    define TINFL_CR_RETURN_FOREVER(state_index, result) \
+        do {                                             \
+            for (;;) {                                   \
+                TINFL_CR_RETURN(state_index, result);    \
+            }                                            \
+        }                                                \
+        MZ_MACRO_END
+#    define TINFL_CR_FINISH }
+
+// TODO: If the caller has indicated that there's no more input, and we attempt to read beyond the input buf, then something is wrong with the input because the inflator never
+// reads ahead more than it needs to. Currently TINFL_GET_BYTE() pads the end of the stream with 0's in this scenario.
+#    define TINFL_GET_BYTE(state_index, c)                                           \
+        do {                                                                         \
+            if (pIn_buf_cur >= pIn_buf_end) {                                        \
+                for (;;) {                                                           \
+                    if (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) {                  \
+                        TINFL_CR_RETURN(state_index, TINFL_STATUS_NEEDS_MORE_INPUT); \
+                        if (pIn_buf_cur < pIn_buf_end) {                             \
+                            c = *pIn_buf_cur++;                                      \
+                            break;                                                   \
+                        }                                                            \
+                    } else {                                                         \
+                        c = 0;                                                       \
+                        break;                                                       \
+                    }                                                                \
+                }                                                                    \
+            } else                                                                   \
+                c = *pIn_buf_cur++;                                                  \
+        }                                                                            \
+        MZ_MACRO_END
+
+#    define TINFL_NEED_BITS(state_index, n)                \
+        do {                                               \
+            mz_uint c;                                     \
+            TINFL_GET_BYTE(state_index, c);                \
+            bit_buf |= (((tinfl_bit_buf_t)c) << num_bits); \
+            num_bits += 8;                                 \
+        } while (num_bits < (mz_uint)(n))
+#    define TINFL_SKIP_BITS(state_index, n)      \
+        do {                                     \
+            if (num_bits < (mz_uint)(n)) {       \
+                TINFL_NEED_BITS(state_index, n); \
+            }                                    \
+            bit_buf >>= (n);                     \
+            num_bits -= (n);                     \
+        }                                        \
+        MZ_MACRO_END
+#    define TINFL_GET_BITS(state_index, b, n)    \
+        do {                                     \
+            if (num_bits < (mz_uint)(n)) {       \
+                TINFL_NEED_BITS(state_index, n); \
+            }                                    \
+            b = bit_buf & ((1 << (n)) - 1);      \
+            bit_buf >>= (n);                     \
+            num_bits -= (n);                     \
+        }                                        \
+        MZ_MACRO_END
+
+// TINFL_HUFF_BITBUF_FILL() is only used rarely, when the number of bytes remaining in the input buffer falls below 2.
+// It reads just enough bytes from the input stream that are needed to decode the next Huffman code (and absolutely no more). It works by trying to fully decode a
+// Huffman code by using whatever bits are currently present in the bit buffer. If this fails, it reads another byte, and tries again until it succeeds or until the
+// bit buffer contains >=15 bits (deflate's max. Huffman code size).
+#    define TINFL_HUFF_BITBUF_FILL(state_index, pHuff)                             \
+        do {                                                                       \
+            temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)];     \
+            if (temp >= 0) {                                                       \
+                code_len = temp >> 9;                                              \
+                if ((code_len) && (num_bits >= code_len)) break;                   \
+            } else if (num_bits > TINFL_FAST_LOOKUP_BITS) {                        \
+                code_len = TINFL_FAST_LOOKUP_BITS;                                 \
+                do {                                                               \
+                    temp = (pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)]; \
+                } while ((temp < 0) && (num_bits >= (code_len + 1)));              \
+                if (temp >= 0) break;                                              \
+            }                                                                      \
+            TINFL_GET_BYTE(state_index, c);                                        \
+            bit_buf |= (((tinfl_bit_buf_t)c) << num_bits);                         \
+            num_bits += 8;                                                         \
+        } while (num_bits < 15);
+
+// TINFL_HUFF_DECODE() decodes the next Huffman coded symbol. It's more complex than you would initially expect because the zlib API expects the decompressor to never read
+// beyond the final byte of the deflate stream. (In other words, when this macro wants to read another byte from the input, it REALLY needs another byte in order to fully
+// decode the next Huffman code.) Handling this properly is particularly important on raw deflate (non-zlib) streams, which aren't followed by a byte aligned adler-32.
+// The slow path is only executed at the very end of the input buffer.
+#    define TINFL_HUFF_DECODE(state_index, sym, pHuff)                                                                                  \
+        do {                                                                                                                            \
+            int temp;                                                                                                                   \
+            mz_uint code_len, c;                                                                                                        \
+            if (num_bits < 15) {                                                                                                        \
+                if ((pIn_buf_end - pIn_buf_cur) < 2) {                                                                                  \
+                    TINFL_HUFF_BITBUF_FILL(state_index, pHuff);                                                                         \
+                } else {                                                                                                                \
+                    bit_buf |= (((tinfl_bit_buf_t)pIn_buf_cur[0]) << num_bits) | (((tinfl_bit_buf_t)pIn_buf_cur[1]) << (num_bits + 8)); \
+                    pIn_buf_cur += 2;                                                                                                   \
+                    num_bits += 16;                                                                                                     \
+                }                                                                                                                       \
+            }                                                                                                                           \
+            if ((temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)                                               \
+                code_len = temp >> 9, temp &= 511;                                                                                      \
+            else {                                                                                                                      \
+                code_len = TINFL_FAST_LOOKUP_BITS;                                                                                      \
+                do {                                                                                                                    \
+                    temp = (pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)];                                                      \
+                } while (temp < 0);                                                                                                     \
+            }                                                                                                                           \
+            sym = temp;                                                                                                                 \
+            bit_buf >>= code_len;                                                                                                       \
+            num_bits -= code_len;                                                                                                       \
+        }                                                                                                                               \
+        MZ_MACRO_END
+
+    tinfl_status tinfl_decompress(tinfl_decompressor* r, const mz_uint8* pIn_buf_next, size_t* pIn_buf_size, mz_uint8* pOut_buf_start,
+                                  mz_uint8* pOut_buf_next, size_t* pOut_buf_size, const mz_uint32 decomp_flags) {
+        static const int s_length_base[31] = {3,  4,  5,  6,  7,  8,  9,  10,  11,  13,  15,  17,  19,  23, 27, 31,
+                                              35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0,  0};
+        static const int s_length_extra[31] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0};
+        static const int s_dist_base[32] = {1,   2,   3,   4,   5,    7,    9,    13,   17,   25,   33,   49,    65,    97,    129, 193,
+                                            257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0,   0};
+        static const int s_dist_extra[32] = {0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13};
+        static const mz_uint8 s_length_dezigzag[19] = {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
+        static const int s_min_table_sizes[3] = {257, 1, 4};
+
+        tinfl_status status = TINFL_STATUS_FAILED;
+        mz_uint32 num_bits, dist, counter, num_extra;
+        tinfl_bit_buf_t bit_buf;
+        const mz_uint8 *pIn_buf_cur = pIn_buf_next, *const pIn_buf_end = pIn_buf_next + *pIn_buf_size;
+        mz_uint8 *pOut_buf_cur = pOut_buf_next, *const pOut_buf_end = pOut_buf_next + *pOut_buf_size;
+        size_t out_buf_size_mask =
+                 (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF) ? (size_t)-1 : ((pOut_buf_next - pOut_buf_start) + *pOut_buf_size) - 1,
+               dist_from_out_buf_start;
+
+        // Ensure the output buffer's size is a power of 2, unless the output buffer is large enough to hold the entire output file (in which case it doesn't matter).
+        if (((out_buf_size_mask + 1) & out_buf_size_mask) || (pOut_buf_next < pOut_buf_start)) {
+            *pIn_buf_size = *pOut_buf_size = 0;
+            return TINFL_STATUS_BAD_PARAM;
+        }
+
+        num_bits = r->m_num_bits;
+        bit_buf = r->m_bit_buf;
+        dist = r->m_dist;
+        counter = r->m_counter;
+        num_extra = r->m_num_extra;
+        dist_from_out_buf_start = r->m_dist_from_out_buf_start;
+        TINFL_CR_BEGIN
+
+        bit_buf = num_bits = dist = counter = num_extra = r->m_zhdr0 = r->m_zhdr1 = 0;
+        r->m_z_adler32 = r->m_check_adler32 = 1;
+        if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) {
+            TINFL_GET_BYTE(1, r->m_zhdr0);
+            TINFL_GET_BYTE(2, r->m_zhdr1);
+            counter = (((r->m_zhdr0 * 256 + r->m_zhdr1) % 31 != 0) || (r->m_zhdr1 & 32) || ((r->m_zhdr0 & 15) != 8));
+            if (!(decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF))
+                counter |= (((1U << (8U + (r->m_zhdr0 >> 4))) > 32768U) || ((out_buf_size_mask + 1) < (size_t)(1U << (8U + (r->m_zhdr0 >> 4)))));
+            if (counter) {
+                TINFL_CR_RETURN_FOREVER(36, TINFL_STATUS_FAILED);
+            }
+        }
+
+        do {
+            TINFL_GET_BITS(3, r->m_final, 3);
+            r->m_type = r->m_final >> 1;
+            if (r->m_type == 0) {
+                TINFL_SKIP_BITS(5, num_bits & 7);
+                for (counter = 0; counter < 4; ++counter) {
+                    if (num_bits)
+                        TINFL_GET_BITS(6, r->m_raw_header[counter], 8);
+                    else
+                        TINFL_GET_BYTE(7, r->m_raw_header[counter]);
+                }
+                if ((counter = (r->m_raw_header[0] | (r->m_raw_header[1] << 8)))
+                    != (mz_uint)(0xFFFF ^ (r->m_raw_header[2] | (r->m_raw_header[3] << 8)))) {
+                    TINFL_CR_RETURN_FOREVER(39, TINFL_STATUS_FAILED);
+                }
+                while ((counter) && (num_bits)) {
+                    TINFL_GET_BITS(51, dist, 8);
+                    while (pOut_buf_cur >= pOut_buf_end) {
+                        TINFL_CR_RETURN(52, TINFL_STATUS_HAS_MORE_OUTPUT);
+                    }
+                    *pOut_buf_cur++ = (mz_uint8)dist;
+                    counter--;
+                }
+                while (counter) {
+                    size_t n;
+                    while (pOut_buf_cur >= pOut_buf_end) {
+                        TINFL_CR_RETURN(9, TINFL_STATUS_HAS_MORE_OUTPUT);
+                    }
+                    while (pIn_buf_cur >= pIn_buf_end) {
+                        if (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) {
+                            TINFL_CR_RETURN(38, TINFL_STATUS_NEEDS_MORE_INPUT);
+                        } else {
+                            TINFL_CR_RETURN_FOREVER(40, TINFL_STATUS_FAILED);
+                        }
+                    }
+                    n = MZ_MIN(MZ_MIN((size_t)(pOut_buf_end - pOut_buf_cur), (size_t)(pIn_buf_end - pIn_buf_cur)), counter);
+                    TINFL_MEMCPY(pOut_buf_cur, pIn_buf_cur, n);
+                    pIn_buf_cur += n;
+                    pOut_buf_cur += n;
+                    counter -= (mz_uint)n;
+                }
+            } else if (r->m_type == 3) {
+                TINFL_CR_RETURN_FOREVER(10, TINFL_STATUS_FAILED);
+            } else {
+                if (r->m_type == 1) {
+                    mz_uint8* p = r->m_tables[0].m_code_size;
+                    mz_uint i;
+                    r->m_table_sizes[0] = 288;
+                    r->m_table_sizes[1] = 32;
+                    TINFL_MEMSET(r->m_tables[1].m_code_size, 5, 32);
+                    for (i = 0; i <= 143; ++i)
+                        *p++ = 8;
+                    for (; i <= 255; ++i)
+                        *p++ = 9;
+                    for (; i <= 279; ++i)
+                        *p++ = 7;
+                    for (; i <= 287; ++i)
+                        *p++ = 8;
+                } else {
+                    for (counter = 0; counter < 3; counter++) {
+                        TINFL_GET_BITS(11, r->m_table_sizes[counter], "\05\05\04"[counter]);
+                        r->m_table_sizes[counter] += s_min_table_sizes[counter];
+                    }
+                    MZ_CLEAR_OBJ(r->m_tables[2].m_code_size);
+                    for (counter = 0; counter < r->m_table_sizes[2]; counter++) {
+                        mz_uint s;
+                        TINFL_GET_BITS(14, s, 3);
+                        r->m_tables[2].m_code_size[s_length_dezigzag[counter]] = (mz_uint8)s;
+                    }
+                    r->m_table_sizes[2] = 19;
+                }
+                for (; (int)r->m_type >= 0; r->m_type--) {
+                    int tree_next, tree_cur;
+                    tinfl_huff_table* pTable;
+                    mz_uint i, j, used_syms, total, sym_index, next_code[17], total_syms[16];
+                    pTable = &r->m_tables[r->m_type];
+                    MZ_CLEAR_OBJ(total_syms);
+                    MZ_CLEAR_OBJ(pTable->m_look_up);
+                    MZ_CLEAR_OBJ(pTable->m_tree);
+                    for (i = 0; i < r->m_table_sizes[r->m_type]; ++i)
+                        total_syms[pTable->m_code_size[i]]++;
+                    used_syms = 0, total = 0;
+                    next_code[0] = next_code[1] = 0;
+                    for (i = 1; i <= 15; ++i) {
+                        used_syms += total_syms[i];
+                        next_code[i + 1] = (total = ((total + total_syms[i]) << 1));
+                    }
+                    if ((65536 != total) && (used_syms > 1)) {
+                        TINFL_CR_RETURN_FOREVER(35, TINFL_STATUS_FAILED);
+                    }
+                    for (tree_next = -1, sym_index = 0; sym_index < r->m_table_sizes[r->m_type]; ++sym_index) {
+                        mz_uint rev_code = 0, l, cur_code, code_size = pTable->m_code_size[sym_index];
+                        if (!code_size) continue;
+                        cur_code = next_code[code_size]++;
+                        for (l = code_size; l > 0; l--, cur_code >>= 1)
+                            rev_code = (rev_code << 1) | (cur_code & 1);
+                        if (code_size <= TINFL_FAST_LOOKUP_BITS) {
+                            mz_int16 k = (mz_int16)((code_size << 9) | sym_index);
+                            while (rev_code < TINFL_FAST_LOOKUP_SIZE) {
+                                pTable->m_look_up[rev_code] = k;
+                                rev_code += (1 << code_size);
+                            }
+                            continue;
+                        }
+                        if (0 == (tree_cur = pTable->m_look_up[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)])) {
+                            pTable->m_look_up[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)] = (mz_int16)tree_next;
+                            tree_cur = tree_next;
+                            tree_next -= 2;
+                        }
+                        rev_code >>= (TINFL_FAST_LOOKUP_BITS - 1);
+                        for (j = code_size; j > (TINFL_FAST_LOOKUP_BITS + 1); j--) {
+                            tree_cur -= ((rev_code >>= 1) & 1);
+                            if (!pTable->m_tree[-tree_cur - 1]) {
+                                pTable->m_tree[-tree_cur - 1] = (mz_int16)tree_next;
+                                tree_cur = tree_next;
+                                tree_next -= 2;
+                            } else
+                                tree_cur = pTable->m_tree[-tree_cur - 1];
+                        }
+                        tree_cur -= ((rev_code >>= 1) & 1);
+                        pTable->m_tree[-tree_cur - 1] = (mz_int16)sym_index;
+                    }
+                    if (r->m_type == 2) {
+                        for (counter = 0; counter < (r->m_table_sizes[0] + r->m_table_sizes[1]);) {
+                            mz_uint s;
+                            TINFL_HUFF_DECODE(16, dist, &r->m_tables[2]);
+                            if (dist < 16) {
+                                r->m_len_codes[counter++] = (mz_uint8)dist;
+                                continue;
+                            }
+                            if ((dist == 16) && (!counter)) {
+                                TINFL_CR_RETURN_FOREVER(17, TINFL_STATUS_FAILED);
+                            }
+                            num_extra = "\02\03\07"[dist - 16];
+                            TINFL_GET_BITS(18, s, num_extra);
+                            s += "\03\03\013"[dist - 16];
+                            TINFL_MEMSET(r->m_len_codes + counter, (dist == 16) ? r->m_len_codes[counter - 1] : 0, s);
+                            counter += s;
+                        }
+                        if ((r->m_table_sizes[0] + r->m_table_sizes[1]) != counter) {
+                            TINFL_CR_RETURN_FOREVER(21, TINFL_STATUS_FAILED);
+                        }
+                        TINFL_MEMCPY(r->m_tables[0].m_code_size, r->m_len_codes, r->m_table_sizes[0]);
+                        TINFL_MEMCPY(r->m_tables[1].m_code_size, r->m_len_codes + r->m_table_sizes[0], r->m_table_sizes[1]);
+                    }
+                }
+                for (;;) {
+                    mz_uint8* pSrc;
+                    for (;;) {
+                        if (((pIn_buf_end - pIn_buf_cur) < 4) || ((pOut_buf_end - pOut_buf_cur) < 2)) {
+                            TINFL_HUFF_DECODE(23, counter, &r->m_tables[0]);
+                            if (counter >= 256) break;
+                            while (pOut_buf_cur >= pOut_buf_end) {
+                                TINFL_CR_RETURN(24, TINFL_STATUS_HAS_MORE_OUTPUT);
+                            }
+                            *pOut_buf_cur++ = (mz_uint8)counter;
+                        } else {
+                            int sym2;
+                            mz_uint code_len;
+#    if TINFL_USE_64BIT_BITBUF
+                            if (num_bits < 30) {
+                                bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE32(pIn_buf_cur)) << num_bits);
+                                pIn_buf_cur += 4;
+                                num_bits += 32;
+                            }
+#    else
+                        if (num_bits < 15) {
+                            bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits);
+                            pIn_buf_cur += 2;
+                            num_bits += 16;
+                        }
+#    endif
+                            if ((sym2 = r->m_tables[0].m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)
+                                code_len = sym2 >> 9;
+                            else {
+                                code_len = TINFL_FAST_LOOKUP_BITS;
+                                do {
+                                    sym2 = r->m_tables[0].m_tree[~sym2 + ((bit_buf >> code_len++) & 1)];
+                                } while (sym2 < 0);
+                            }
+                            counter = sym2;
+                            bit_buf >>= code_len;
+                            num_bits -= code_len;
+                            if (counter & 256) break;
+
+#    if !TINFL_USE_64BIT_BITBUF
+                            if (num_bits < 15) {
+                                bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits);
+                                pIn_buf_cur += 2;
+                                num_bits += 16;
+                            }
+#    endif
+                            if ((sym2 = r->m_tables[0].m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)
+                                code_len = sym2 >> 9;
+                            else {
+                                code_len = TINFL_FAST_LOOKUP_BITS;
+                                do {
+                                    sym2 = r->m_tables[0].m_tree[~sym2 + ((bit_buf >> code_len++) & 1)];
+                                } while (sym2 < 0);
+                            }
+                            bit_buf >>= code_len;
+                            num_bits -= code_len;
+
+                            pOut_buf_cur[0] = (mz_uint8)counter;
+                            if (sym2 & 256) {
+                                pOut_buf_cur++;
+                                counter = sym2;
+                                break;
+                            }
+                            pOut_buf_cur[1] = (mz_uint8)sym2;
+                            pOut_buf_cur += 2;
+                        }
+                    }
+                    if ((counter &= 511) == 256) break;
+
+                    num_extra = s_length_extra[counter - 257];
+                    counter = s_length_base[counter - 257];
+                    if (num_extra) {
+                        mz_uint extra_bits;
+                        TINFL_GET_BITS(25, extra_bits, num_extra);
+                        counter += extra_bits;
+                    }
+
+                    TINFL_HUFF_DECODE(26, dist, &r->m_tables[1]);
+                    num_extra = s_dist_extra[dist];
+                    dist = s_dist_base[dist];
+                    if (num_extra) {
+                        mz_uint extra_bits;
+                        TINFL_GET_BITS(27, extra_bits, num_extra);
+                        dist += extra_bits;
+                    }
+
+                    dist_from_out_buf_start = pOut_buf_cur - pOut_buf_start;
+                    if ((dist > dist_from_out_buf_start) && (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)) {
+                        TINFL_CR_RETURN_FOREVER(37, TINFL_STATUS_FAILED);
+                    }
+
+                    pSrc = pOut_buf_start + ((dist_from_out_buf_start - dist) & out_buf_size_mask);
+
+                    if ((MZ_MAX(pOut_buf_cur, pSrc) + counter) > pOut_buf_end) {
+                        while (counter--) {
+                            while (pOut_buf_cur >= pOut_buf_end) {
+                                TINFL_CR_RETURN(53, TINFL_STATUS_HAS_MORE_OUTPUT);
+                            }
+                            *pOut_buf_cur++ = pOut_buf_start[(dist_from_out_buf_start++ - dist) & out_buf_size_mask];
+                        }
+                        continue;
+                    }
+#    if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
+                    else if ((counter >= 9) && (counter <= dist)) {
+                        const mz_uint8* pSrc_end = pSrc + (counter & ~7);
+                        do {
+                            ((mz_uint32*)pOut_buf_cur)[0] = ((const mz_uint32*)pSrc)[0];
+                            ((mz_uint32*)pOut_buf_cur)[1] = ((const mz_uint32*)pSrc)[1];
+                            pOut_buf_cur += 8;
+                        } while ((pSrc += 8) < pSrc_end);
+                        if ((counter &= 7) < 3) {
+                            if (counter) {
+                                pOut_buf_cur[0] = pSrc[0];
+                                if (counter > 1) pOut_buf_cur[1] = pSrc[1];
+                                pOut_buf_cur += counter;
+                            }
+                            continue;
+                        }
+                    }
+#    endif
+                    do {
+                        pOut_buf_cur[0] = pSrc[0];
+                        pOut_buf_cur[1] = pSrc[1];
+                        pOut_buf_cur[2] = pSrc[2];
+                        pOut_buf_cur += 3;
+                        pSrc += 3;
+                    } while ((int)(counter -= 3) > 2);
+                    if ((int)counter > 0) {
+                        pOut_buf_cur[0] = pSrc[0];
+                        if ((int)counter > 1) pOut_buf_cur[1] = pSrc[1];
+                        pOut_buf_cur += counter;
+                    }
+                }
+            }
+        } while (!(r->m_final & 1));
+        if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) {
+            TINFL_SKIP_BITS(32, num_bits & 7);
+            for (counter = 0; counter < 4; ++counter) {
+                mz_uint s;
+                if (num_bits)
+                    TINFL_GET_BITS(41, s, 8);
+                else
+                    TINFL_GET_BYTE(42, s);
+                r->m_z_adler32 = (r->m_z_adler32 << 8) | s;
+            }
+        }
+        TINFL_CR_RETURN_FOREVER(34, TINFL_STATUS_DONE);
+        TINFL_CR_FINISH
+
+    common_exit:
+        r->m_num_bits = num_bits;
+        r->m_bit_buf = bit_buf;
+        r->m_dist = dist;
+        r->m_counter = counter;
+        r->m_num_extra = num_extra;
+        r->m_dist_from_out_buf_start = dist_from_out_buf_start;
+        *pIn_buf_size = pIn_buf_cur - pIn_buf_next;
+        *pOut_buf_size = pOut_buf_cur - pOut_buf_next;
+        if ((decomp_flags & (TINFL_FLAG_PARSE_ZLIB_HEADER | TINFL_FLAG_COMPUTE_ADLER32)) && (status >= 0)) {
+            const mz_uint8* ptr = pOut_buf_next;
+            size_t buf_len = *pOut_buf_size;
+            mz_uint32 i, s1 = r->m_check_adler32 & 0xffff, s2 = r->m_check_adler32 >> 16;
+            size_t block_len = buf_len % 5552;
+            while (buf_len) {
+                for (i = 0; i + 7 < block_len; i += 8, ptr += 8) {
+                    s1 += ptr[0], s2 += s1;
+                    s1 += ptr[1], s2 += s1;
+                    s1 += ptr[2], s2 += s1;
+                    s1 += ptr[3], s2 += s1;
+                    s1 += ptr[4], s2 += s1;
+                    s1 += ptr[5], s2 += s1;
+                    s1 += ptr[6], s2 += s1;
+                    s1 += ptr[7], s2 += s1;
+                }
+                for (; i < block_len; ++i)
+                    s1 += *ptr++, s2 += s1;
+                s1 %= 65521U, s2 %= 65521U;
+                buf_len -= block_len;
+                block_len = 5552;
+            }
+            r->m_check_adler32 = (s2 << 16) + s1;
+            if ((status == TINFL_STATUS_DONE) && (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) && (r->m_check_adler32 != r->m_z_adler32))
+                status = TINFL_STATUS_ADLER32_MISMATCH;
+        }
+        return status;
+    }
+
+    // Higher level helper functions.
+    void* tinfl_decompress_mem_to_heap(const void* pSrc_buf, size_t src_buf_len, size_t* pOut_len, int flags) {
+        tinfl_decompressor decomp;
+        void *pBuf = NULL, *pNew_buf;
+        size_t src_buf_ofs = 0, out_buf_capacity = 0;
+        *pOut_len = 0;
+        tinfl_init(&decomp);
+        for (;;) {
+            size_t src_buf_size = src_buf_len - src_buf_ofs, dst_buf_size = out_buf_capacity - *pOut_len, new_out_buf_capacity;
+            tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8*)pSrc_buf + src_buf_ofs, &src_buf_size, (mz_uint8*)pBuf,
+                                                   pBuf ? (mz_uint8*)pBuf + *pOut_len : NULL, &dst_buf_size,
+                                                   (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
+            if ((status < 0) || (status == TINFL_STATUS_NEEDS_MORE_INPUT)) {
+                MZ_FREE(pBuf);
+                *pOut_len = 0;
+                return NULL;
+            }
+            src_buf_ofs += src_buf_size;
+            *pOut_len += dst_buf_size;
+            if (status == TINFL_STATUS_DONE) break;
+            new_out_buf_capacity = out_buf_capacity * 2;
+            if (new_out_buf_capacity < 128) new_out_buf_capacity = 128;
+            pNew_buf = MZ_REALLOC(pBuf, new_out_buf_capacity);
+            if (!pNew_buf) {
+                MZ_FREE(pBuf);
+                *pOut_len = 0;
+                return NULL;
+            }
+            pBuf = pNew_buf;
+            out_buf_capacity = new_out_buf_capacity;
+        }
+        return pBuf;
+    }
+
+    size_t tinfl_decompress_mem_to_mem(void* pOut_buf, size_t out_buf_len, const void* pSrc_buf, size_t src_buf_len, int flags) {
+        tinfl_decompressor decomp;
+        tinfl_status status;
+        tinfl_init(&decomp);
+        status = tinfl_decompress(&decomp, (const mz_uint8*)pSrc_buf, &src_buf_len, (mz_uint8*)pOut_buf, (mz_uint8*)pOut_buf, &out_buf_len,
+                                  (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
+        return (status != TINFL_STATUS_DONE) ? TINFL_DECOMPRESS_MEM_TO_MEM_FAILED : out_buf_len;
+    }
+
+    int tinfl_decompress_mem_to_callback(const void* pIn_buf, size_t* pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void* pPut_buf_user,
+                                         int flags) {
+        int result = 0;
+        tinfl_decompressor decomp;
+        mz_uint8* pDict = (mz_uint8*)MZ_MALLOC(TINFL_LZ_DICT_SIZE);
+        size_t in_buf_ofs = 0, dict_ofs = 0;
+        if (!pDict) return TINFL_STATUS_FAILED;
+        tinfl_init(&decomp);
+        for (;;) {
+            size_t in_buf_size = *pIn_buf_size - in_buf_ofs, dst_buf_size = TINFL_LZ_DICT_SIZE - dict_ofs;
+            tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8*)pIn_buf + in_buf_ofs, &in_buf_size, pDict, pDict + dict_ofs,
+                                                   &dst_buf_size, (flags & ~(TINFL_FLAG_HAS_MORE_INPUT | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)));
+            in_buf_ofs += in_buf_size;
+            if ((dst_buf_size) && (!(*pPut_buf_func)(pDict + dict_ofs, (int)dst_buf_size, pPut_buf_user))) break;
+            if (status != TINFL_STATUS_HAS_MORE_OUTPUT) {
+                result = (status == TINFL_STATUS_DONE);
+                break;
+            }
+            dict_ofs = (dict_ofs + dst_buf_size) & (TINFL_LZ_DICT_SIZE - 1);
+        }
+        MZ_FREE(pDict);
+        *pIn_buf_size = in_buf_ofs;
+        return result;
+    }
+
+    // ------------------- Low-level Compression (independent from all decompression API's)
+
+    // Purposely making these tables static for faster init and thread safety.
+    static const mz_uint16 s_tdefl_len_sym[256] = {
+      257, 258, 259, 260, 261, 262, 263, 264, 265, 265, 266, 266, 267, 267, 268, 268, 269, 269, 269, 269, 270, 270, 270, 270, 271, 271, 271, 271, 272,
+      272, 272, 272, 273, 273, 273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 274, 274, 274, 274, 275, 275, 275, 275, 275, 275, 275, 275, 276, 276,
+      276, 276, 276, 276, 276, 276, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 278, 278, 278, 278, 278, 278, 278,
+      278, 278, 278, 278, 278, 278, 278, 278, 278, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 280, 280, 280, 280,
+      280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,
+      281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
+      282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,
+      283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 284, 284, 284, 284, 284, 284, 284, 284,
+      284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 285};
+
+    static const mz_uint8 s_tdefl_len_extra[256] = {
+      0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+      3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
+      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5,
+      5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
+      5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
+      5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0};
+
+    static const mz_uint8 s_tdefl_small_dist_sym[512] = {
+      0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9,  10, 10, 10,
+      10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12,
+      12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13,
+      13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
+      15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
+      15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+      16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+      16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
+      16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17,
+      17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
+      17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
+      17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
+      17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17};
+
+    static const mz_uint8 s_tdefl_small_dist_extra[512] = {
+      0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
+      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
+      5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+      6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+      6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+      6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7};
+
+    static const mz_uint8 s_tdefl_large_dist_sym[128] = {
+      0,  0,  18, 19, 20, 20, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25,
+      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
+      28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
+      29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29};
+
+    static const mz_uint8 s_tdefl_large_dist_extra[128] = {
+      0,  0,  8,  8,  9,  9,  9,  9,  10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
+      12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
+      13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
+      13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13};
+
+    // Radix sorts tdefl_sym_freq[] array by 16-bit key m_key. Returns ptr to sorted values.
+    typedef struct
+    {
+        mz_uint16 m_key, m_sym_index;
+    } tdefl_sym_freq;
+    static tdefl_sym_freq* tdefl_radix_sort_syms(mz_uint num_syms, tdefl_sym_freq* pSyms0, tdefl_sym_freq* pSyms1) {
+        mz_uint32 total_passes = 2, pass_shift, pass, i, hist[256 * 2];
+        tdefl_sym_freq *pCur_syms = pSyms0, *pNew_syms = pSyms1;
+        MZ_CLEAR_OBJ(hist);
+        for (i = 0; i < num_syms; i++) {
+            mz_uint freq = pSyms0[i].m_key;
+            hist[freq & 0xFF]++;
+            hist[256 + ((freq >> 8) & 0xFF)]++;
+        }
+        while ((total_passes > 1) && (num_syms == hist[(total_passes - 1) * 256]))
+            total_passes--;
+        for (pass_shift = 0, pass = 0; pass < total_passes; pass++, pass_shift += 8) {
+            const mz_uint32* pHist = &hist[pass << 8];
+            mz_uint offsets[256], cur_ofs = 0;
+            for (i = 0; i < 256; i++) {
+                offsets[i] = cur_ofs;
+                cur_ofs += pHist[i];
+            }
+            for (i = 0; i < num_syms; i++)
+                pNew_syms[offsets[(pCur_syms[i].m_key >> pass_shift) & 0xFF]++] = pCur_syms[i];
+            {
+                tdefl_sym_freq* t = pCur_syms;
+                pCur_syms = pNew_syms;
+                pNew_syms = t;
+            }
+        }
+        return pCur_syms;
+    }
+
+    // tdefl_calculate_minimum_redundancy() originally written by: Alistair Moffat, alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996.
+    static void tdefl_calculate_minimum_redundancy(tdefl_sym_freq* A, int n) {
+        int root, leaf, next, avbl, used, dpth;
+        if (n == 0)
+            return;
+        else if (n == 1) {
+            A[0].m_key = 1;
+            return;
+        }
+        A[0].m_key += A[1].m_key;
+        root = 0;
+        leaf = 2;
+        for (next = 1; next < n - 1; next++) {
+            if (leaf >= n || A[root].m_key < A[leaf].m_key) {
+                A[next].m_key = A[root].m_key;
+                A[root++].m_key = (mz_uint16)next;
+            } else
+                A[next].m_key = A[leaf++].m_key;
+            if (leaf >= n || (root < next && A[root].m_key < A[leaf].m_key)) {
+                A[next].m_key = (mz_uint16)(A[next].m_key + A[root].m_key);
+                A[root++].m_key = (mz_uint16)next;
+            } else
+                A[next].m_key = (mz_uint16)(A[next].m_key + A[leaf++].m_key);
+        }
+        A[n - 2].m_key = 0;
+        for (next = n - 3; next >= 0; next--)
+            A[next].m_key = A[A[next].m_key].m_key + 1;
+        avbl = 1;
+        used = dpth = 0;
+        root = n - 2;
+        next = n - 1;
+        while (avbl > 0) {
+            while (root >= 0 && (int)A[root].m_key == dpth) {
+                used++;
+                root--;
+            }
+            while (avbl > used) {
+                A[next--].m_key = (mz_uint16)(dpth);
+                avbl--;
+            }
+            avbl = 2 * used;
+            dpth++;
+            used = 0;
+        }
+    }
+
+    // Limits canonical Huffman code table's max code size.
+    enum
+    {
+        TDEFL_MAX_SUPPORTED_HUFF_CODESIZE = 32
+    };
+    static void tdefl_huffman_enforce_max_code_size(int* pNum_codes, int code_list_len, int max_code_size) {
+        int i;
+        mz_uint32 total = 0;
+        if (code_list_len <= 1) return;
+        for (i = max_code_size + 1; i <= TDEFL_MAX_SUPPORTED_HUFF_CODESIZE; i++)
+            pNum_codes[max_code_size] += pNum_codes[i];
+        for (i = max_code_size; i > 0; i--)
+            total += (((mz_uint32)pNum_codes[i]) << (max_code_size - i));
+        while (total != (1UL << max_code_size)) {
+            pNum_codes[max_code_size]--;
+            for (i = max_code_size - 1; i > 0; i--)
+                if (pNum_codes[i]) {
+                    pNum_codes[i]--;
+                    pNum_codes[i + 1] += 2;
+                    break;
+                }
+            total--;
+        }
+    }
+
+    static void tdefl_optimize_huffman_table(tdefl_compressor* d, int table_num, int table_len, int code_size_limit, int static_table) {
+        int i, j, l, num_codes[1 + TDEFL_MAX_SUPPORTED_HUFF_CODESIZE];
+        mz_uint next_code[TDEFL_MAX_SUPPORTED_HUFF_CODESIZE + 1];
+        MZ_CLEAR_OBJ(num_codes);
+        if (static_table) {
+            for (i = 0; i < table_len; i++)
+                num_codes[d->m_huff_code_sizes[table_num][i]]++;
+        } else {
+            tdefl_sym_freq syms0[TDEFL_MAX_HUFF_SYMBOLS], syms1[TDEFL_MAX_HUFF_SYMBOLS], *pSyms;
+            int num_used_syms = 0;
+            const mz_uint16* pSym_count = &d->m_huff_count[table_num][0];
+            for (i = 0; i < table_len; i++)
+                if (pSym_count[i]) {
+                    syms0[num_used_syms].m_key = (mz_uint16)pSym_count[i];
+                    syms0[num_used_syms++].m_sym_index = (mz_uint16)i;
+                }
+
+            pSyms = tdefl_radix_sort_syms(num_used_syms, syms0, syms1);
+            tdefl_calculate_minimum_redundancy(pSyms, num_used_syms);
+
+            for (i = 0; i < num_used_syms; i++)
+                num_codes[pSyms[i].m_key]++;
+
+            tdefl_huffman_enforce_max_code_size(num_codes, num_used_syms, code_size_limit);
+
+            MZ_CLEAR_OBJ(d->m_huff_code_sizes[table_num]);
+            MZ_CLEAR_OBJ(d->m_huff_codes[table_num]);
+            for (i = 1, j = num_used_syms; i <= code_size_limit; i++)
+                for (l = num_codes[i]; l > 0; l--)
+                    d->m_huff_code_sizes[table_num][pSyms[--j].m_sym_index] = (mz_uint8)(i);
+        }
+
+        next_code[1] = 0;
+        for (j = 0, i = 2; i <= code_size_limit; i++)
+            next_code[i] = j = ((j + num_codes[i - 1]) << 1);
+
+        for (i = 0; i < table_len; i++) {
+            mz_uint rev_code = 0, code, code_size;
+            if ((code_size = d->m_huff_code_sizes[table_num][i]) == 0) continue;
+            code = next_code[code_size]++;
+            for (l = code_size; l > 0; l--, code >>= 1)
+                rev_code = (rev_code << 1) | (code & 1);
+            d->m_huff_codes[table_num][i] = (mz_uint16)rev_code;
+        }
+    }
+
+#    define TDEFL_PUT_BITS(b, l)                                                                                \
+        do {                                                                                                    \
+            mz_uint bits = b;                                                                                   \
+            mz_uint len = l;                                                                                    \
+            MZ_ASSERT(bits <= ((1U << len) - 1U));                                                              \
+            d->m_bit_buffer |= (bits << d->m_bits_in);                                                          \
+            d->m_bits_in += len;                                                                                \
+            while (d->m_bits_in >= 8) {                                                                         \
+                if (d->m_pOutput_buf < d->m_pOutput_buf_end) *d->m_pOutput_buf++ = (mz_uint8)(d->m_bit_buffer); \
+                d->m_bit_buffer >>= 8;                                                                          \
+                d->m_bits_in -= 8;                                                                              \
+            }                                                                                                   \
+        }                                                                                                       \
+        MZ_MACRO_END
+
+#    define TDEFL_RLE_PREV_CODE_SIZE()                                                                                       \
+        {                                                                                                                    \
+            if (rle_repeat_count) {                                                                                          \
+                if (rle_repeat_count < 3) {                                                                                  \
+                    d->m_huff_count[2][prev_code_size] = (mz_uint16)(d->m_huff_count[2][prev_code_size] + rle_repeat_count); \
+                    while (rle_repeat_count--)                                                                               \
+                        packed_code_sizes[num_packed_code_sizes++] = prev_code_size;                                         \
+                } else {                                                                                                     \
+                    d->m_huff_count[2][16] = (mz_uint16)(d->m_huff_count[2][16] + 1);                                        \
+                    packed_code_sizes[num_packed_code_sizes++] = 16;                                                         \
+                    packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_repeat_count - 3);                           \
+                }                                                                                                            \
+                rle_repeat_count = 0;                                                                                        \
+            }                                                                                                                \
+        }
+
+#    define TDEFL_RLE_ZERO_CODE_SIZE()                                                         \
+        {                                                                                      \
+            if (rle_z_count) {                                                                 \
+                if (rle_z_count < 3) {                                                         \
+                    d->m_huff_count[2][0] = (mz_uint16)(d->m_huff_count[2][0] + rle_z_count);  \
+                    while (rle_z_count--)                                                      \
+                        packed_code_sizes[num_packed_code_sizes++] = 0;                        \
+                } else if (rle_z_count <= 10) {                                                \
+                    d->m_huff_count[2][17] = (mz_uint16)(d->m_huff_count[2][17] + 1);          \
+                    packed_code_sizes[num_packed_code_sizes++] = 17;                           \
+                    packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 3);  \
+                } else {                                                                       \
+                    d->m_huff_count[2][18] = (mz_uint16)(d->m_huff_count[2][18] + 1);          \
+                    packed_code_sizes[num_packed_code_sizes++] = 18;                           \
+                    packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 11); \
+                }                                                                              \
+                rle_z_count = 0;                                                               \
+            }                                                                                  \
+        }
+
+    static mz_uint8 s_tdefl_packed_code_size_syms_swizzle[] = {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
+
+    static void tdefl_start_dynamic_block(tdefl_compressor* d) {
+        int num_lit_codes, num_dist_codes, num_bit_lengths;
+        mz_uint i, total_code_sizes_to_pack, num_packed_code_sizes, rle_z_count, rle_repeat_count, packed_code_sizes_index;
+        mz_uint8 code_sizes_to_pack[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1],
+          packed_code_sizes[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1], prev_code_size = 0xFF;
+
+        d->m_huff_count[0][256] = 1;
+
+        tdefl_optimize_huffman_table(d, 0, TDEFL_MAX_HUFF_SYMBOLS_0, 15, MZ_FALSE);
+        tdefl_optimize_huffman_table(d, 1, TDEFL_MAX_HUFF_SYMBOLS_1, 15, MZ_FALSE);
+
+        for (num_lit_codes = 286; num_lit_codes > 257; num_lit_codes--)
+            if (d->m_huff_code_sizes[0][num_lit_codes - 1]) break;
+        for (num_dist_codes = 30; num_dist_codes > 1; num_dist_codes--)
+            if (d->m_huff_code_sizes[1][num_dist_codes - 1]) break;
+
+        memcpy(code_sizes_to_pack, &d->m_huff_code_sizes[0][0], num_lit_codes);
+        memcpy(code_sizes_to_pack + num_lit_codes, &d->m_huff_code_sizes[1][0], num_dist_codes);
+        total_code_sizes_to_pack = num_lit_codes + num_dist_codes;
+        num_packed_code_sizes = 0;
+        rle_z_count = 0;
+        rle_repeat_count = 0;
+
+        memset(&d->m_huff_count[2][0], 0, sizeof(d->m_huff_count[2][0]) * TDEFL_MAX_HUFF_SYMBOLS_2);
+        for (i = 0; i < total_code_sizes_to_pack; i++) {
+            mz_uint8 code_size = code_sizes_to_pack[i];
+            if (!code_size) {
+                TDEFL_RLE_PREV_CODE_SIZE();
+                if (++rle_z_count == 138) {
+                    TDEFL_RLE_ZERO_CODE_SIZE();
+                }
+            } else {
+                TDEFL_RLE_ZERO_CODE_SIZE();
+                if (code_size != prev_code_size) {
+                    TDEFL_RLE_PREV_CODE_SIZE();
+                    d->m_huff_count[2][code_size] = (mz_uint16)(d->m_huff_count[2][code_size] + 1);
+                    packed_code_sizes[num_packed_code_sizes++] = code_size;
+                } else if (++rle_repeat_count == 6) {
+                    TDEFL_RLE_PREV_CODE_SIZE();
+                }
+            }
+            prev_code_size = code_size;
+        }
+        if (rle_repeat_count) {
+            TDEFL_RLE_PREV_CODE_SIZE();
+        } else {
+            TDEFL_RLE_ZERO_CODE_SIZE();
+        }
+
+        tdefl_optimize_huffman_table(d, 2, TDEFL_MAX_HUFF_SYMBOLS_2, 7, MZ_FALSE);
+
+        TDEFL_PUT_BITS(2, 2);
+
+        TDEFL_PUT_BITS(num_lit_codes - 257, 5);
+        TDEFL_PUT_BITS(num_dist_codes - 1, 5);
+
+        for (num_bit_lengths = 18; num_bit_lengths >= 0; num_bit_lengths--)
+            if (d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[num_bit_lengths]]) break;
+        num_bit_lengths = MZ_MAX(4, (num_bit_lengths + 1));
+        TDEFL_PUT_BITS(num_bit_lengths - 4, 4);
+        for (i = 0; (int)i < num_bit_lengths; i++)
+            TDEFL_PUT_BITS(d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[i]], 3);
+
+        for (packed_code_sizes_index = 0; packed_code_sizes_index < num_packed_code_sizes;) {
+            mz_uint code = packed_code_sizes[packed_code_sizes_index++];
+            MZ_ASSERT(code < TDEFL_MAX_HUFF_SYMBOLS_2);
+            TDEFL_PUT_BITS(d->m_huff_codes[2][code], d->m_huff_code_sizes[2][code]);
+            if (code >= 16) TDEFL_PUT_BITS(packed_code_sizes[packed_code_sizes_index++], "\02\03\07"[code - 16]);
+        }
+    }
+
+    static void tdefl_start_static_block(tdefl_compressor* d) {
+        mz_uint i;
+        mz_uint8* p = &d->m_huff_code_sizes[0][0];
+
+        for (i = 0; i <= 143; ++i)
+            *p++ = 8;
+        for (; i <= 255; ++i)
+            *p++ = 9;
+        for (; i <= 279; ++i)
+            *p++ = 7;
+        for (; i <= 287; ++i)
+            *p++ = 8;
+
+        memset(d->m_huff_code_sizes[1], 5, 32);
+
+        tdefl_optimize_huffman_table(d, 0, 288, 15, MZ_TRUE);
+        tdefl_optimize_huffman_table(d, 1, 32, 15, MZ_TRUE);
+
+        TDEFL_PUT_BITS(1, 2);
+    }
+
+    static const mz_uint mz_bitmasks[17] = {0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF,
+                                            0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF};
+
+#    if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS
+    static mz_bool tdefl_compress_lz_codes(tdefl_compressor* d) {
+        mz_uint flags;
+        mz_uint8* pLZ_codes;
+        mz_uint8* pOutput_buf = d->m_pOutput_buf;
+        mz_uint8* pLZ_code_buf_end = d->m_pLZ_code_buf;
+        mz_uint64 bit_buffer = d->m_bit_buffer;
+        mz_uint bits_in = d->m_bits_in;
+
+#        define TDEFL_PUT_BITS_FAST(b, l)                    \
+            {                                                \
+                bit_buffer |= (((mz_uint64)(b)) << bits_in); \
+                bits_in += (l);                              \
+            }
+
+        flags = 1;
+        for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < pLZ_code_buf_end; flags >>= 1) {
+            if (flags == 1) flags = *pLZ_codes++ | 0x100;
+
+            if (flags & 1) {
+                mz_uint s0, s1, n0, n1, sym, num_extra_bits;
+                mz_uint match_len = pLZ_codes[0], match_dist = *(const mz_uint16*)(pLZ_codes + 1);
+                pLZ_codes += 3;
+
+                MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
+                TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
+                TDEFL_PUT_BITS_FAST(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);
+
+                // This sequence coaxes MSVC into using cmov's vs. jmp's.
+                s0 = s_tdefl_small_dist_sym[match_dist & 511];
+                n0 = s_tdefl_small_dist_extra[match_dist & 511];
+                s1 = s_tdefl_large_dist_sym[match_dist >> 8];
+                n1 = s_tdefl_large_dist_extra[match_dist >> 8];
+                sym = (match_dist < 512) ? s0 : s1;
+                num_extra_bits = (match_dist < 512) ? n0 : n1;
+
+                MZ_ASSERT(d->m_huff_code_sizes[1][sym]);
+                TDEFL_PUT_BITS_FAST(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);
+                TDEFL_PUT_BITS_FAST(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);
+            } else {
+                mz_uint lit = *pLZ_codes++;
+                MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
+                TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
+
+                if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end)) {
+                    flags >>= 1;
+                    lit = *pLZ_codes++;
+                    MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
+                    TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
+
+                    if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end)) {
+                        flags >>= 1;
+                        lit = *pLZ_codes++;
+                        MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
+                        TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
+                    }
+                }
+            }
+
+            if (pOutput_buf >= d->m_pOutput_buf_end) return MZ_FALSE;
+
+            *(mz_uint64*)pOutput_buf = bit_buffer;
+            pOutput_buf += (bits_in >> 3);
+            bit_buffer >>= (bits_in & ~7);
+            bits_in &= 7;
+        }
+
+#        undef TDEFL_PUT_BITS_FAST
+
+        d->m_pOutput_buf = pOutput_buf;
+        d->m_bits_in = 0;
+        d->m_bit_buffer = 0;
+
+        while (bits_in) {
+            mz_uint32 n = MZ_MIN(bits_in, 16);
+            TDEFL_PUT_BITS((mz_uint)bit_buffer & mz_bitmasks[n], n);
+            bit_buffer >>= n;
+            bits_in -= n;
+        }
+
+        TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);
+
+        return (d->m_pOutput_buf < d->m_pOutput_buf_end);
+    }
+#    else
+static mz_bool tdefl_compress_lz_codes(tdefl_compressor* d) {
+    mz_uint flags;
+    mz_uint8* pLZ_codes;
+
+    flags = 1;
+    for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < d->m_pLZ_code_buf; flags >>= 1) {
+        if (flags == 1) flags = *pLZ_codes++ | 0x100;
+        if (flags & 1) {
+            mz_uint sym, num_extra_bits;
+            mz_uint match_len = pLZ_codes[0], match_dist = (pLZ_codes[1] | (pLZ_codes[2] << 8));
+            pLZ_codes += 3;
+
+            MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
+            TDEFL_PUT_BITS(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
+            TDEFL_PUT_BITS(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);
+
+            if (match_dist < 512) {
+                sym = s_tdefl_small_dist_sym[match_dist];
+                num_extra_bits = s_tdefl_small_dist_extra[match_dist];
+            } else {
+                sym = s_tdefl_large_dist_sym[match_dist >> 8];
+                num_extra_bits = s_tdefl_large_dist_extra[match_dist >> 8];
+            }
+            MZ_ASSERT(d->m_huff_code_sizes[1][sym]);
+            TDEFL_PUT_BITS(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);
+            TDEFL_PUT_BITS(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);
+        } else {
+            mz_uint lit = *pLZ_codes++;
+            MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
+            TDEFL_PUT_BITS(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
+        }
+    }
+
+    TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);
+
+    return (d->m_pOutput_buf < d->m_pOutput_buf_end);
+}
+#    endif  // MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS
+
+    static mz_bool tdefl_compress_block(tdefl_compressor* d, mz_bool static_block) {
+        if (static_block)
+            tdefl_start_static_block(d);
+        else
+            tdefl_start_dynamic_block(d);
+        return tdefl_compress_lz_codes(d);
+    }
+
+    static int tdefl_flush_block(tdefl_compressor* d, int flush) {
+        mz_uint saved_bit_buf, saved_bits_in;
+        mz_uint8* pSaved_output_buf;
+        mz_bool comp_block_succeeded = MZ_FALSE;
+        int n, use_raw_block = ((d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS) != 0) && (d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size;
+        mz_uint8* pOutput_buf_start = ((d->m_pPut_buf_func == NULL) && ((*d->m_pOut_buf_size - d->m_out_buf_ofs) >= TDEFL_OUT_BUF_SIZE))
+                                        ? ((mz_uint8*)d->m_pOut_buf + d->m_out_buf_ofs)
+                                        : d->m_output_buf;
+
+        d->m_pOutput_buf = pOutput_buf_start;
+        d->m_pOutput_buf_end = d->m_pOutput_buf + TDEFL_OUT_BUF_SIZE - 16;
+
+        MZ_ASSERT(!d->m_output_flush_remaining);
+        d->m_output_flush_ofs = 0;
+        d->m_output_flush_remaining = 0;
+
+        *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> d->m_num_flags_left);
+        d->m_pLZ_code_buf -= (d->m_num_flags_left == 8);
+
+        if ((d->m_flags & TDEFL_WRITE_ZLIB_HEADER) && (!d->m_block_index)) {
+            TDEFL_PUT_BITS(0x78, 8);
+            TDEFL_PUT_BITS(0x01, 8);
+        }
+
+        TDEFL_PUT_BITS(flush == TDEFL_FINISH, 1);
+
+        pSaved_output_buf = d->m_pOutput_buf;
+        saved_bit_buf = d->m_bit_buffer;
+        saved_bits_in = d->m_bits_in;
+
+        if (!use_raw_block)
+            comp_block_succeeded = tdefl_compress_block(d, (d->m_flags & TDEFL_FORCE_ALL_STATIC_BLOCKS) || (d->m_total_lz_bytes < 48));
+
+        // If the block gets expanded, forget the current contents of the output buffer and send a raw block instead.
+        if (((use_raw_block) || ((d->m_total_lz_bytes) && ((d->m_pOutput_buf - pSaved_output_buf + 1U) >= d->m_total_lz_bytes)))
+            && ((d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size)) {
+            mz_uint i;
+            d->m_pOutput_buf = pSaved_output_buf;
+            d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;
+            TDEFL_PUT_BITS(0, 2);
+            if (d->m_bits_in) {
+                TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
+            }
+            for (i = 2; i; --i, d->m_total_lz_bytes ^= 0xFFFF) {
+                TDEFL_PUT_BITS(d->m_total_lz_bytes & 0xFFFF, 16);
+            }
+            for (i = 0; i < d->m_total_lz_bytes; ++i) {
+                TDEFL_PUT_BITS(d->m_dict[(d->m_lz_code_buf_dict_pos + i) & TDEFL_LZ_DICT_SIZE_MASK], 8);
+            }
+        }
+        // Check for the extremely unlikely (if not impossible) case of the compressed block not fitting into the output buffer when using dynamic codes.
+        else if (!comp_block_succeeded) {
+            d->m_pOutput_buf = pSaved_output_buf;
+            d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;
+            tdefl_compress_block(d, MZ_TRUE);
+        }
+
+        if (flush) {
+            if (flush == TDEFL_FINISH) {
+                if (d->m_bits_in) {
+                    TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
+                }
+                if (d->m_flags & TDEFL_WRITE_ZLIB_HEADER) {
+                    mz_uint i, a = d->m_adler32;
+                    for (i = 0; i < 4; i++) {
+                        TDEFL_PUT_BITS((a >> 24) & 0xFF, 8);
+                        a <<= 8;
+                    }
+                }
+            } else {
+                mz_uint i, z = 0;
+                TDEFL_PUT_BITS(0, 3);
+                if (d->m_bits_in) {
+                    TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
+                }
+                for (i = 2; i; --i, z ^= 0xFFFF) {
+                    TDEFL_PUT_BITS(z & 0xFFFF, 16);
+                }
+            }
+        }
+
+        MZ_ASSERT(d->m_pOutput_buf < d->m_pOutput_buf_end);
+
+        memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
+        memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);
+
+        d->m_pLZ_code_buf = d->m_lz_code_buf + 1;
+        d->m_pLZ_flags = d->m_lz_code_buf;
+        d->m_num_flags_left = 8;
+        d->m_lz_code_buf_dict_pos += d->m_total_lz_bytes;
+        d->m_total_lz_bytes = 0;
+        d->m_block_index++;
+
+        if ((n = (int)(d->m_pOutput_buf - pOutput_buf_start)) != 0) {
+            if (d->m_pPut_buf_func) {
+                *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8*)d->m_pIn_buf;
+                if (!(*d->m_pPut_buf_func)(d->m_output_buf, n, d->m_pPut_buf_user)) return (d->m_prev_return_status = TDEFL_STATUS_PUT_BUF_FAILED);
+            } else if (pOutput_buf_start == d->m_output_buf) {
+                int bytes_to_copy = (int)MZ_MIN((size_t)n, (size_t)(*d->m_pOut_buf_size - d->m_out_buf_ofs));
+                memcpy((mz_uint8*)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf, bytes_to_copy);
+                d->m_out_buf_ofs += bytes_to_copy;
+                if ((n -= bytes_to_copy) != 0) {
+                    d->m_output_flush_ofs = bytes_to_copy;
+                    d->m_output_flush_remaining = n;
+                }
+            } else {
+                d->m_out_buf_ofs += n;
+            }
+        }
+
+        return d->m_output_flush_remaining;
+    }
+
+#    if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
+#        define TDEFL_READ_UNALIGNED_WORD(p) *(const mz_uint16*)(p)
+    static MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor* d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len,
+                                                mz_uint* pMatch_dist, mz_uint* pMatch_len) {
+        mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;
+        mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
+        const mz_uint16 *s = (const mz_uint16*)(d->m_dict + pos), *p, *q;
+        mz_uint16 c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]), s01 = TDEFL_READ_UNALIGNED_WORD(s);
+        MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN);
+        if (max_match_len <= match_len) return;
+        for (;;) {
+            for (;;) {
+                if (--num_probes_left == 0) return;
+#        define TDEFL_PROBE                                                                                     \
+            next_probe_pos = d->m_next[probe_pos];                                                              \
+            if ((!next_probe_pos) || ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist)) return; \
+            probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK;                                               \
+            if (TDEFL_READ_UNALIGNED_WORD(&d->m_dict[probe_pos + match_len - 1]) == c01) break;
+                TDEFL_PROBE;
+                TDEFL_PROBE;
+                TDEFL_PROBE;
+            }
+            if (!dist) break;
+            q = (const mz_uint16*)(d->m_dict + probe_pos);
+            if (TDEFL_READ_UNALIGNED_WORD(q) != s01) continue;
+            p = s;
+            probe_len = 32;
+            do {
+            } while ((TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q))
+                     && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q))
+                     && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q))
+                     && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (--probe_len > 0));
+            if (!probe_len) {
+                *pMatch_dist = dist;
+                *pMatch_len = MZ_MIN(max_match_len, TDEFL_MAX_MATCH_LEN);
+                break;
+            } else if ((probe_len = ((mz_uint)(p - s) * 2) + (mz_uint)(*(const mz_uint8*)p == *(const mz_uint8*)q)) > match_len) {
+                *pMatch_dist = dist;
+                if ((*pMatch_len = match_len = MZ_MIN(max_match_len, probe_len)) == max_match_len) break;
+                c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]);
+            }
+        }
+    }
+#    else
+static MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor* d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint* pMatch_dist,
+                                            mz_uint* pMatch_len) {
+    mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;
+    mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
+    const mz_uint8 *s = d->m_dict + pos, *p, *q;
+    mz_uint8 c0 = d->m_dict[pos + match_len], c1 = d->m_dict[pos + match_len - 1];
+    MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN);
+    if (max_match_len <= match_len) return;
+    for (;;) {
+        for (;;) {
+            if (--num_probes_left == 0) return;
+#        define TDEFL_PROBE                                                                                     \
+            next_probe_pos = d->m_next[probe_pos];                                                              \
+            if ((!next_probe_pos) || ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist)) return; \
+            probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK;                                               \
+            if ((d->m_dict[probe_pos + match_len] == c0) && (d->m_dict[probe_pos + match_len - 1] == c1)) break;
+            TDEFL_PROBE;
+            TDEFL_PROBE;
+            TDEFL_PROBE;
+        }
+        if (!dist) break;
+        p = s;
+        q = d->m_dict + probe_pos;
+        for (probe_len = 0; probe_len < max_match_len; probe_len++)
+            if (*p++ != *q++) break;
+        if (probe_len > match_len) {
+            *pMatch_dist = dist;
+            if ((*pMatch_len = match_len = probe_len) == max_match_len) return;
+            c0 = d->m_dict[pos + match_len];
+            c1 = d->m_dict[pos + match_len - 1];
+        }
+    }
+}
+#    endif  // #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
+
+#    if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
+    static mz_bool tdefl_compress_fast(tdefl_compressor* d) {
+        // Faster, minimally featured LZRW1-style match+parse loop with better register utilization. Intended for applications where raw throughput is valued more highly than ratio.
+        mz_uint lookahead_pos = d->m_lookahead_pos, lookahead_size = d->m_lookahead_size, dict_size = d->m_dict_size,
+                total_lz_bytes = d->m_total_lz_bytes, num_flags_left = d->m_num_flags_left;
+        mz_uint8 *pLZ_code_buf = d->m_pLZ_code_buf, *pLZ_flags = d->m_pLZ_flags;
+        mz_uint cur_pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;
+
+        while ((d->m_src_buf_left) || ((d->m_flush) && (lookahead_size))) {
+            const mz_uint TDEFL_COMP_FAST_LOOKAHEAD_SIZE = 4096;
+            mz_uint dst_pos = (lookahead_pos + lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;
+            mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(d->m_src_buf_left, TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size);
+            d->m_src_buf_left -= num_bytes_to_process;
+            lookahead_size += num_bytes_to_process;
+
+            while (num_bytes_to_process) {
+                mz_uint32 n = MZ_MIN(TDEFL_LZ_DICT_SIZE - dst_pos, num_bytes_to_process);
+                memcpy(d->m_dict + dst_pos, d->m_pSrc, n);
+                if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
+                    memcpy(d->m_dict + TDEFL_LZ_DICT_SIZE + dst_pos, d->m_pSrc, MZ_MIN(n, (TDEFL_MAX_MATCH_LEN - 1) - dst_pos));
+                d->m_pSrc += n;
+                dst_pos = (dst_pos + n) & TDEFL_LZ_DICT_SIZE_MASK;
+                num_bytes_to_process -= n;
+            }
+
+            dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - lookahead_size, dict_size);
+            if ((!d->m_flush) && (lookahead_size < TDEFL_COMP_FAST_LOOKAHEAD_SIZE)) break;
+
+            while (lookahead_size >= 4) {
+                mz_uint cur_match_dist, cur_match_len = 1;
+                mz_uint8* pCur_dict = d->m_dict + cur_pos;
+                mz_uint first_trigram = (*(const mz_uint32*)pCur_dict) & 0xFFFFFF;
+                mz_uint hash = (first_trigram ^ (first_trigram >> (24 - (TDEFL_LZ_HASH_BITS - 8)))) & TDEFL_LEVEL1_HASH_SIZE_MASK;
+                mz_uint probe_pos = d->m_hash[hash];
+                d->m_hash[hash] = (mz_uint16)lookahead_pos;
+
+                if (((cur_match_dist = (mz_uint16)(lookahead_pos - probe_pos)) <= dict_size)
+                    && ((*(const mz_uint32*)(d->m_dict + (probe_pos &= TDEFL_LZ_DICT_SIZE_MASK)) & 0xFFFFFF) == first_trigram)) {
+                    const mz_uint16* p = (const mz_uint16*)pCur_dict;
+                    const mz_uint16* q = (const mz_uint16*)(d->m_dict + probe_pos);
+                    mz_uint32 probe_len = 32;
+                    do {
+                    } while ((TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q))
+                             && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q))
+                             && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q))
+                             && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (--probe_len > 0));
+                    cur_match_len = ((mz_uint)(p - (const mz_uint16*)pCur_dict) * 2) + (mz_uint)(*(const mz_uint8*)p == *(const mz_uint8*)q);
+                    if (!probe_len) cur_match_len = cur_match_dist ? TDEFL_MAX_MATCH_LEN : 0;
+
+                    if ((cur_match_len < TDEFL_MIN_MATCH_LEN) || ((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U * 1024U))) {
+                        cur_match_len = 1;
+                        *pLZ_code_buf++ = (mz_uint8)first_trigram;
+                        *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
+                        d->m_huff_count[0][(mz_uint8)first_trigram]++;
+                    } else {
+                        mz_uint32 s0, s1;
+                        cur_match_len = MZ_MIN(cur_match_len, lookahead_size);
+
+                        MZ_ASSERT((cur_match_len >= TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 1) && (cur_match_dist <= TDEFL_LZ_DICT_SIZE));
+
+                        cur_match_dist--;
+
+                        pLZ_code_buf[0] = (mz_uint8)(cur_match_len - TDEFL_MIN_MATCH_LEN);
+                        *(mz_uint16*)(&pLZ_code_buf[1]) = (mz_uint16)cur_match_dist;
+                        pLZ_code_buf += 3;
+                        *pLZ_flags = (mz_uint8)((*pLZ_flags >> 1) | 0x80);
+
+                        s0 = s_tdefl_small_dist_sym[cur_match_dist & 511];
+                        s1 = s_tdefl_large_dist_sym[cur_match_dist >> 8];
+                        d->m_huff_count[1][(cur_match_dist < 512) ? s0 : s1]++;
+
+                        d->m_huff_count[0][s_tdefl_len_sym[cur_match_len - TDEFL_MIN_MATCH_LEN]]++;
+                    }
+                } else {
+                    *pLZ_code_buf++ = (mz_uint8)first_trigram;
+                    *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
+                    d->m_huff_count[0][(mz_uint8)first_trigram]++;
+                }
+
+                if (--num_flags_left == 0) {
+                    num_flags_left = 8;
+                    pLZ_flags = pLZ_code_buf++;
+                }
+
+                total_lz_bytes += cur_match_len;
+                lookahead_pos += cur_match_len;
+                dict_size = MZ_MIN(dict_size + cur_match_len, TDEFL_LZ_DICT_SIZE);
+                cur_pos = (cur_pos + cur_match_len) & TDEFL_LZ_DICT_SIZE_MASK;
+                MZ_ASSERT(lookahead_size >= cur_match_len);
+                lookahead_size -= cur_match_len;
+
+                if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) {
+                    int n;
+                    d->m_lookahead_pos = lookahead_pos;
+                    d->m_lookahead_size = lookahead_size;
+                    d->m_dict_size = dict_size;
+                    d->m_total_lz_bytes = total_lz_bytes;
+                    d->m_pLZ_code_buf = pLZ_code_buf;
+                    d->m_pLZ_flags = pLZ_flags;
+                    d->m_num_flags_left = num_flags_left;
+                    if ((n = tdefl_flush_block(d, 0)) != 0) return (n < 0) ? MZ_FALSE : MZ_TRUE;
+                    total_lz_bytes = d->m_total_lz_bytes;
+                    pLZ_code_buf = d->m_pLZ_code_buf;
+                    pLZ_flags = d->m_pLZ_flags;
+                    num_flags_left = d->m_num_flags_left;
+                }
+            }
+
+            while (lookahead_size) {
+                mz_uint8 lit = d->m_dict[cur_pos];
+
+                total_lz_bytes++;
+                *pLZ_code_buf++ = lit;
+                *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
+                if (--num_flags_left == 0) {
+                    num_flags_left = 8;
+                    pLZ_flags = pLZ_code_buf++;
+                }
+
+                d->m_huff_count[0][lit]++;
+
+                lookahead_pos++;
+                dict_size = MZ_MIN(dict_size + 1, TDEFL_LZ_DICT_SIZE);
+                cur_pos = (cur_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;
+                lookahead_size--;
+
+                if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) {
+                    int n;
+                    d->m_lookahead_pos = lookahead_pos;
+                    d->m_lookahead_size = lookahead_size;
+                    d->m_dict_size = dict_size;
+                    d->m_total_lz_bytes = total_lz_bytes;
+                    d->m_pLZ_code_buf = pLZ_code_buf;
+                    d->m_pLZ_flags = pLZ_flags;
+                    d->m_num_flags_left = num_flags_left;
+                    if ((n = tdefl_flush_block(d, 0)) != 0) return (n < 0) ? MZ_FALSE : MZ_TRUE;
+                    total_lz_bytes = d->m_total_lz_bytes;
+                    pLZ_code_buf = d->m_pLZ_code_buf;
+                    pLZ_flags = d->m_pLZ_flags;
+                    num_flags_left = d->m_num_flags_left;
+                }
+            }
+        }
+
+        d->m_lookahead_pos = lookahead_pos;
+        d->m_lookahead_size = lookahead_size;
+        d->m_dict_size = dict_size;
+        d->m_total_lz_bytes = total_lz_bytes;
+        d->m_pLZ_code_buf = pLZ_code_buf;
+        d->m_pLZ_flags = pLZ_flags;
+        d->m_num_flags_left = num_flags_left;
+        return MZ_TRUE;
+    }
+#    endif  // MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
+
+    static MZ_FORCEINLINE void tdefl_record_literal(tdefl_compressor* d, mz_uint8 lit) {
+        d->m_total_lz_bytes++;
+        *d->m_pLZ_code_buf++ = lit;
+        *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> 1);
+        if (--d->m_num_flags_left == 0) {
+            d->m_num_flags_left = 8;
+            d->m_pLZ_flags = d->m_pLZ_code_buf++;
+        }
+        d->m_huff_count[0][lit]++;
+    }
+
+    static MZ_FORCEINLINE void tdefl_record_match(tdefl_compressor* d, mz_uint match_len, mz_uint match_dist) {
+        mz_uint32 s0, s1;
+
+        MZ_ASSERT((match_len >= TDEFL_MIN_MATCH_LEN) && (match_dist >= 1) && (match_dist <= TDEFL_LZ_DICT_SIZE));
+
+        d->m_total_lz_bytes += match_len;
+
+        d->m_pLZ_code_buf[0] = (mz_uint8)(match_len - TDEFL_MIN_MATCH_LEN);
+
+        match_dist -= 1;
+        d->m_pLZ_code_buf[1] = (mz_uint8)(match_dist & 0xFF);
+        d->m_pLZ_code_buf[2] = (mz_uint8)(match_dist >> 8);
+        d->m_pLZ_code_buf += 3;
+
+        *d->m_pLZ_flags = (mz_uint8)((*d->m_pLZ_flags >> 1) | 0x80);
+        if (--d->m_num_flags_left == 0) {
+            d->m_num_flags_left = 8;
+            d->m_pLZ_flags = d->m_pLZ_code_buf++;
+        }
+
+        s0 = s_tdefl_small_dist_sym[match_dist & 511];
+        s1 = s_tdefl_large_dist_sym[(match_dist >> 8) & 127];
+        d->m_huff_count[1][(match_dist < 512) ? s0 : s1]++;
+
+        if (match_len >= TDEFL_MIN_MATCH_LEN) d->m_huff_count[0][s_tdefl_len_sym[match_len - TDEFL_MIN_MATCH_LEN]]++;
+    }
+
+    static mz_bool tdefl_compress_normal(tdefl_compressor* d) {
+        const mz_uint8* pSrc = d->m_pSrc;
+        size_t src_buf_left = d->m_src_buf_left;
+        tdefl_flush flush = d->m_flush;
+
+        while ((src_buf_left) || ((flush) && (d->m_lookahead_size))) {
+            mz_uint len_to_move, cur_match_dist, cur_match_len, cur_pos;
+            // Update dictionary and hash chains. Keeps the lookahead size equal to TDEFL_MAX_MATCH_LEN.
+            if ((d->m_lookahead_size + d->m_dict_size) >= (TDEFL_MIN_MATCH_LEN - 1)) {
+                mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK,
+                        ins_pos = d->m_lookahead_pos + d->m_lookahead_size - 2;
+                mz_uint hash =
+                  (d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK];
+                mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(src_buf_left, TDEFL_MAX_MATCH_LEN - d->m_lookahead_size);
+                const mz_uint8* pSrc_end = pSrc + num_bytes_to_process;
+                src_buf_left -= num_bytes_to_process;
+                d->m_lookahead_size += num_bytes_to_process;
+                while (pSrc != pSrc_end) {
+                    mz_uint8 c = *pSrc++;
+                    d->m_dict[dst_pos] = c;
+                    if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1)) d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;
+                    hash = ((hash << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);
+                    d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];
+                    d->m_hash[hash] = (mz_uint16)(ins_pos);
+                    dst_pos = (dst_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;
+                    ins_pos++;
+                }
+            } else {
+                while ((src_buf_left) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN)) {
+                    mz_uint8 c = *pSrc++;
+                    mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;
+                    src_buf_left--;
+                    d->m_dict[dst_pos] = c;
+                    if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1)) d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;
+                    if ((++d->m_lookahead_size + d->m_dict_size) >= TDEFL_MIN_MATCH_LEN) {
+                        mz_uint ins_pos = d->m_lookahead_pos + (d->m_lookahead_size - 1) - 2;
+                        mz_uint hash = ((d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << (TDEFL_LZ_HASH_SHIFT * 2))
+                                        ^ (d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ c)
+                                       & (TDEFL_LZ_HASH_SIZE - 1);
+                        d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];
+                        d->m_hash[hash] = (mz_uint16)(ins_pos);
+                    }
+                }
+            }
+            d->m_dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - d->m_lookahead_size, d->m_dict_size);
+            if ((!flush) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN)) break;
+
+            // Simple lazy/greedy parsing state machine.
+            len_to_move = 1;
+            cur_match_dist = 0;
+            cur_match_len = d->m_saved_match_len ? d->m_saved_match_len : (TDEFL_MIN_MATCH_LEN - 1);
+            cur_pos = d->m_lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;
+            if (d->m_flags & (TDEFL_RLE_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS)) {
+                if ((d->m_dict_size) && (!(d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS))) {
+                    mz_uint8 c = d->m_dict[(cur_pos - 1) & TDEFL_LZ_DICT_SIZE_MASK];
+                    cur_match_len = 0;
+                    while (cur_match_len < d->m_lookahead_size) {
+                        if (d->m_dict[cur_pos + cur_match_len] != c) break;
+                        cur_match_len++;
+                    }
+                    if (cur_match_len < TDEFL_MIN_MATCH_LEN)
+                        cur_match_len = 0;
+                    else
+                        cur_match_dist = 1;
+                }
+            } else {
+                tdefl_find_match(d, d->m_lookahead_pos, d->m_dict_size, d->m_lookahead_size, &cur_match_dist, &cur_match_len);
+            }
+            if (((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U * 1024U)) || (cur_pos == cur_match_dist)
+                || ((d->m_flags & TDEFL_FILTER_MATCHES) && (cur_match_len <= 5))) {
+                cur_match_dist = cur_match_len = 0;
+            }
+            if (d->m_saved_match_len) {
+                if (cur_match_len > d->m_saved_match_len) {
+                    tdefl_record_literal(d, (mz_uint8)d->m_saved_lit);
+                    if (cur_match_len >= 128) {
+                        tdefl_record_match(d, cur_match_len, cur_match_dist);
+                        d->m_saved_match_len = 0;
+                        len_to_move = cur_match_len;
+                    } else {
+                        d->m_saved_lit = d->m_dict[cur_pos];
+                        d->m_saved_match_dist = cur_match_dist;
+                        d->m_saved_match_len = cur_match_len;
+                    }
+                } else {
+                    tdefl_record_match(d, d->m_saved_match_len, d->m_saved_match_dist);
+                    len_to_move = d->m_saved_match_len - 1;
+                    d->m_saved_match_len = 0;
+                }
+            } else if (!cur_match_dist)
+                tdefl_record_literal(d, d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)]);
+            else if ((d->m_greedy_parsing) || (d->m_flags & TDEFL_RLE_MATCHES) || (cur_match_len >= 128)) {
+                tdefl_record_match(d, cur_match_len, cur_match_dist);
+                len_to_move = cur_match_len;
+            } else {
+                d->m_saved_lit = d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)];
+                d->m_saved_match_dist = cur_match_dist;
+                d->m_saved_match_len = cur_match_len;
+            }
+            // Move the lookahead forward by len_to_move bytes.
+            d->m_lookahead_pos += len_to_move;
+            MZ_ASSERT(d->m_lookahead_size >= len_to_move);
+            d->m_lookahead_size -= len_to_move;
+            d->m_dict_size = MZ_MIN(d->m_dict_size + len_to_move, TDEFL_LZ_DICT_SIZE);
+            // Check if it's time to flush the current LZ codes to the internal output buffer.
+            if ((d->m_pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])
+                || ((d->m_total_lz_bytes > 31 * 1024)
+                    && (((((mz_uint)(d->m_pLZ_code_buf - d->m_lz_code_buf) * 115) >> 7) >= d->m_total_lz_bytes)
+                        || (d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS)))) {
+                int n;
+                d->m_pSrc = pSrc;
+                d->m_src_buf_left = src_buf_left;
+                if ((n = tdefl_flush_block(d, 0)) != 0) return (n < 0) ? MZ_FALSE : MZ_TRUE;
+            }
+        }
+
+        d->m_pSrc = pSrc;
+        d->m_src_buf_left = src_buf_left;
+        return MZ_TRUE;
+    }
+
+    static tdefl_status tdefl_flush_output_buffer(tdefl_compressor* d) {
+        if (d->m_pIn_buf_size) {
+            *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8*)d->m_pIn_buf;
+        }
+
+        if (d->m_pOut_buf_size) {
+            size_t n = MZ_MIN(*d->m_pOut_buf_size - d->m_out_buf_ofs, d->m_output_flush_remaining);
+            memcpy((mz_uint8*)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf + d->m_output_flush_ofs, n);
+            d->m_output_flush_ofs += (mz_uint)n;
+            d->m_output_flush_remaining -= (mz_uint)n;
+            d->m_out_buf_ofs += n;
+
+            *d->m_pOut_buf_size = d->m_out_buf_ofs;
+        }
+
+        return (d->m_finished && !d->m_output_flush_remaining) ? TDEFL_STATUS_DONE : TDEFL_STATUS_OKAY;
+    }
+
+    tdefl_status tdefl_compress(tdefl_compressor* d, const void* pIn_buf, size_t* pIn_buf_size, void* pOut_buf, size_t* pOut_buf_size,
+                                tdefl_flush flush) {
+        if (!d) {
+            if (pIn_buf_size) *pIn_buf_size = 0;
+            if (pOut_buf_size) *pOut_buf_size = 0;
+            return TDEFL_STATUS_BAD_PARAM;
+        }
+
+        d->m_pIn_buf = pIn_buf;
+        d->m_pIn_buf_size = pIn_buf_size;
+        d->m_pOut_buf = pOut_buf;
+        d->m_pOut_buf_size = pOut_buf_size;
+        d->m_pSrc = (const mz_uint8*)(pIn_buf);
+        d->m_src_buf_left = pIn_buf_size ? *pIn_buf_size : 0;
+        d->m_out_buf_ofs = 0;
+        d->m_flush = flush;
+
+        if (((d->m_pPut_buf_func != NULL) == ((pOut_buf != NULL) || (pOut_buf_size != NULL))) || (d->m_prev_return_status != TDEFL_STATUS_OKAY)
+            || (d->m_wants_to_finish && (flush != TDEFL_FINISH)) || (pIn_buf_size && *pIn_buf_size && !pIn_buf)
+            || (pOut_buf_size && *pOut_buf_size && !pOut_buf)) {
+            if (pIn_buf_size) *pIn_buf_size = 0;
+            if (pOut_buf_size) *pOut_buf_size = 0;
+            return (d->m_prev_return_status = TDEFL_STATUS_BAD_PARAM);
+        }
+        d->m_wants_to_finish |= (flush == TDEFL_FINISH);
+
+        if ((d->m_output_flush_remaining) || (d->m_finished)) return (d->m_prev_return_status = tdefl_flush_output_buffer(d));
+
+#    if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
+        if (((d->m_flags & TDEFL_MAX_PROBES_MASK) == 1) && ((d->m_flags & TDEFL_GREEDY_PARSING_FLAG) != 0)
+            && ((d->m_flags & (TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS | TDEFL_RLE_MATCHES)) == 0)) {
+            if (!tdefl_compress_fast(d)) return d->m_prev_return_status;
+        } else
+#    endif  // #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
+        {
+            if (!tdefl_compress_normal(d)) return d->m_prev_return_status;
+        }
+
+        if ((d->m_flags & (TDEFL_WRITE_ZLIB_HEADER | TDEFL_COMPUTE_ADLER32)) && (pIn_buf))
+            d->m_adler32 = (mz_uint32)mz_adler32(d->m_adler32, (const mz_uint8*)pIn_buf, d->m_pSrc - (const mz_uint8*)pIn_buf);
+
+        if ((flush) && (!d->m_lookahead_size) && (!d->m_src_buf_left) && (!d->m_output_flush_remaining)) {
+            if (tdefl_flush_block(d, flush) < 0) return d->m_prev_return_status;
+            d->m_finished = (flush == TDEFL_FINISH);
+            if (flush == TDEFL_FULL_FLUSH) {
+                MZ_CLEAR_OBJ(d->m_hash);
+                MZ_CLEAR_OBJ(d->m_next);
+                d->m_dict_size = 0;
+            }
+        }
+
+        return (d->m_prev_return_status = tdefl_flush_output_buffer(d));
+    }
+
+    tdefl_status tdefl_compress_buffer(tdefl_compressor* d, const void* pIn_buf, size_t in_buf_size, tdefl_flush flush) {
+        MZ_ASSERT(d->m_pPut_buf_func);
+        return tdefl_compress(d, pIn_buf, &in_buf_size, NULL, NULL, flush);
+    }
+
+    tdefl_status tdefl_init(tdefl_compressor* d, tdefl_put_buf_func_ptr pPut_buf_func, void* pPut_buf_user, int flags) {
+        d->m_pPut_buf_func = pPut_buf_func;
+        d->m_pPut_buf_user = pPut_buf_user;
+        d->m_flags = (mz_uint)(flags);
+        d->m_max_probes[0] = 1 + ((flags & 0xFFF) + 2) / 3;
+        d->m_greedy_parsing = (flags & TDEFL_GREEDY_PARSING_FLAG) != 0;
+        d->m_max_probes[1] = 1 + (((flags & 0xFFF) >> 2) + 2) / 3;
+        if (!(flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG)) MZ_CLEAR_OBJ(d->m_hash);
+        d->m_lookahead_pos = d->m_lookahead_size = d->m_dict_size = d->m_total_lz_bytes = d->m_lz_code_buf_dict_pos = d->m_bits_in = 0;
+        d->m_output_flush_ofs = d->m_output_flush_remaining = d->m_finished = d->m_block_index = d->m_bit_buffer = d->m_wants_to_finish = 0;
+        d->m_pLZ_code_buf = d->m_lz_code_buf + 1;
+        d->m_pLZ_flags = d->m_lz_code_buf;
+        d->m_num_flags_left = 8;
+        d->m_pOutput_buf = d->m_output_buf;
+        d->m_pOutput_buf_end = d->m_output_buf;
+        d->m_prev_return_status = TDEFL_STATUS_OKAY;
+        d->m_saved_match_dist = d->m_saved_match_len = d->m_saved_lit = 0;
+        d->m_adler32 = 1;
+        d->m_pIn_buf = NULL;
+        d->m_pOut_buf = NULL;
+        d->m_pIn_buf_size = NULL;
+        d->m_pOut_buf_size = NULL;
+        d->m_flush = TDEFL_NO_FLUSH;
+        d->m_pSrc = NULL;
+        d->m_src_buf_left = 0;
+        d->m_out_buf_ofs = 0;
+        memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
+        memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);
+        return TDEFL_STATUS_OKAY;
+    }
+
+    tdefl_status tdefl_get_prev_return_status(tdefl_compressor* d) {
+        return d->m_prev_return_status;
+    }
+
+    mz_uint32 tdefl_get_adler32(tdefl_compressor* d) {
+        return d->m_adler32;
+    }
+
+    mz_bool tdefl_compress_mem_to_output(const void* pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void* pPut_buf_user, int flags) {
+        tdefl_compressor* pComp;
+        mz_bool succeeded;
+        if (((buf_len) && (!pBuf)) || (!pPut_buf_func)) return MZ_FALSE;
+        pComp = (tdefl_compressor*)MZ_MALLOC(sizeof(tdefl_compressor));
+        if (!pComp) return MZ_FALSE;
+        succeeded = (tdefl_init(pComp, pPut_buf_func, pPut_buf_user, flags) == TDEFL_STATUS_OKAY);
+        succeeded = succeeded && (tdefl_compress_buffer(pComp, pBuf, buf_len, TDEFL_FINISH) == TDEFL_STATUS_DONE);
+        MZ_FREE(pComp);
+        return succeeded;
+    }
+
+    typedef struct
+    {
+        size_t m_size, m_capacity;
+        mz_uint8* m_pBuf;
+        mz_bool m_expandable;
+    } tdefl_output_buffer;
+
+    static mz_bool tdefl_output_buffer_putter(const void* pBuf, int len, void* pUser) {
+        tdefl_output_buffer* p = (tdefl_output_buffer*)pUser;
+        size_t new_size = p->m_size + len;
+        if (new_size > p->m_capacity) {
+            size_t new_capacity = p->m_capacity;
+            mz_uint8* pNew_buf;
+            if (!p->m_expandable) return MZ_FALSE;
+            do {
+                new_capacity = MZ_MAX(128U, new_capacity << 1U);
+            } while (new_size > new_capacity);
+            pNew_buf = (mz_uint8*)MZ_REALLOC(p->m_pBuf, new_capacity);
+            if (!pNew_buf) return MZ_FALSE;
+            p->m_pBuf = pNew_buf;
+            p->m_capacity = new_capacity;
+        }
+        memcpy((mz_uint8*)p->m_pBuf + p->m_size, pBuf, len);
+        p->m_size = new_size;
+        return MZ_TRUE;
+    }
+
+    void* tdefl_compress_mem_to_heap(const void* pSrc_buf, size_t src_buf_len, size_t* pOut_len, int flags) {
+        tdefl_output_buffer out_buf;
+        MZ_CLEAR_OBJ(out_buf);
+        if (!pOut_len)
+            return MZ_FALSE;
+        else
+            *pOut_len = 0;
+        out_buf.m_expandable = MZ_TRUE;
+        if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags)) return NULL;
+        *pOut_len = out_buf.m_size;
+        return out_buf.m_pBuf;
+    }
+
+    size_t tdefl_compress_mem_to_mem(void* pOut_buf, size_t out_buf_len, const void* pSrc_buf, size_t src_buf_len, int flags) {
+        tdefl_output_buffer out_buf;
+        MZ_CLEAR_OBJ(out_buf);
+        if (!pOut_buf) return 0;
+        out_buf.m_pBuf = (mz_uint8*)pOut_buf;
+        out_buf.m_capacity = out_buf_len;
+        if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags)) return 0;
+        return out_buf.m_size;
+    }
+
+#    ifndef MINIZ_NO_ZLIB_APIS
+    static const mz_uint s_tdefl_num_probes[11] = {0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500};
+
+    // level may actually range from [0,10] (10 is a "hidden" max level, where we want a bit more compression and it's fine if throughput to fall off a cliff on some files).
+    mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy) {
+        mz_uint comp_flags = s_tdefl_num_probes[(level >= 0) ? MZ_MIN(10, level) : MZ_DEFAULT_LEVEL] | ((level <= 3) ? TDEFL_GREEDY_PARSING_FLAG : 0);
+        if (window_bits > 0) comp_flags |= TDEFL_WRITE_ZLIB_HEADER;
+
+        if (!level)
+            comp_flags |= TDEFL_FORCE_ALL_RAW_BLOCKS;
+        else if (strategy == MZ_FILTERED)
+            comp_flags |= TDEFL_FILTER_MATCHES;
+        else if (strategy == MZ_HUFFMAN_ONLY)
+            comp_flags &= ~TDEFL_MAX_PROBES_MASK;
+        else if (strategy == MZ_FIXED)
+            comp_flags |= TDEFL_FORCE_ALL_STATIC_BLOCKS;
+        else if (strategy == MZ_RLE)
+            comp_flags |= TDEFL_RLE_MATCHES;
+
+        return comp_flags;
+    }
+#    endif  //MINIZ_NO_ZLIB_APIS
+
+#    ifdef _MSC_VER
+#        pragma warning(push)
+#        pragma warning( \
+          disable : 4204)  // nonstandard extension used : non-constant aggregate initializer (also supported by GNU C and C99, so no big deal)
+#    endif
+
+    // Simple PNG writer function by Alex Evans, 2011. Released into the public domain: https://gist.github.com/908299, more context at
+    // http://altdevblogaday.org/2011/04/06/a-smaller-jpg-encoder/.
+    // This is actually a modification of Alex's original code so PNG files generated by this function pass pngcheck.
+    void* tdefl_write_image_to_png_file_in_memory_ex(const void* pImage, int w, int h, int num_chans, size_t* pLen_out, mz_uint level, mz_bool flip) {
+        // Using a local copy of this array here in case MINIZ_NO_ZLIB_APIS was defined.
+        static const mz_uint s_tdefl_png_num_probes[11] = {0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500};
+        tdefl_compressor* pComp = (tdefl_compressor*)MZ_MALLOC(sizeof(tdefl_compressor));
+        tdefl_output_buffer out_buf;
+        int i, bpl = w * num_chans, y, z;
+        mz_uint32 c;
+        *pLen_out = 0;
+        if (!pComp) return NULL;
+        MZ_CLEAR_OBJ(out_buf);
+        out_buf.m_expandable = MZ_TRUE;
+        out_buf.m_capacity = 57 + MZ_MAX(64, (1 + bpl) * h);
+        if (NULL == (out_buf.m_pBuf = (mz_uint8*)MZ_MALLOC(out_buf.m_capacity))) {
+            MZ_FREE(pComp);
+            return NULL;
+        }
+        // write dummy header
+        for (z = 41; z; --z)
+            tdefl_output_buffer_putter(&z, 1, &out_buf);
+        // compress image data
+        tdefl_init(pComp, tdefl_output_buffer_putter, &out_buf, s_tdefl_png_num_probes[MZ_MIN(10, level)] | TDEFL_WRITE_ZLIB_HEADER);
+        for (y = 0; y < h; ++y) {
+            tdefl_compress_buffer(pComp, &z, 1, TDEFL_NO_FLUSH);
+            tdefl_compress_buffer(pComp, (mz_uint8*)pImage + (flip ? (h - 1 - y) : y) * bpl, bpl, TDEFL_NO_FLUSH);
+        }
+        if (tdefl_compress_buffer(pComp, NULL, 0, TDEFL_FINISH) != TDEFL_STATUS_DONE) {
+            MZ_FREE(pComp);
+            MZ_FREE(out_buf.m_pBuf);
+            return NULL;
+        }
+        // write real header
+        *pLen_out = out_buf.m_size - 41;
+        {
+            static const mz_uint8 chans[] = {0x00, 0x00, 0x04, 0x02, 0x06};
+            mz_uint8 pnghdr[41] = {0x89,
+                                   0x50,
+                                   0x4e,
+                                   0x47,
+                                   0x0d,
+                                   0x0a,
+                                   0x1a,
+                                   0x0a,
+                                   0x00,
+                                   0x00,
+                                   0x00,
+                                   0x0d,
+                                   0x49,
+                                   0x48,
+                                   0x44,
+                                   0x52,
+                                   0,
+                                   0,
+                                   (mz_uint8)(w >> 8),
+                                   (mz_uint8)w,
+                                   0,
+                                   0,
+                                   (mz_uint8)(h >> 8),
+                                   (mz_uint8)h,
+                                   8,
+                                   chans[num_chans],
+                                   0,
+                                   0,
+                                   0,
+                                   0,
+                                   0,
+                                   0,
+                                   0,
+                                   (mz_uint8)(*pLen_out >> 24),
+                                   (mz_uint8)(*pLen_out >> 16),
+                                   (mz_uint8)(*pLen_out >> 8),
+                                   (mz_uint8)*pLen_out,
+                                   0x49,
+                                   0x44,
+                                   0x41,
+                                   0x54};
+            c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, pnghdr + 12, 17);
+            for (i = 0; i < 4; ++i, c <<= 8)
+                ((mz_uint8*)(pnghdr + 29))[i] = (mz_uint8)(c >> 24);
+            memcpy(out_buf.m_pBuf, pnghdr, 41);
+        }
+        // write footer (IDAT CRC-32, followed by IEND chunk)
+        if (!tdefl_output_buffer_putter("\0\0\0\0\0\0\0\0\x49\x45\x4e\x44\xae\x42\x60\x82", 16, &out_buf)) {
+            *pLen_out = 0;
+            MZ_FREE(pComp);
+            MZ_FREE(out_buf.m_pBuf);
+            return NULL;
+        }
+        c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, out_buf.m_pBuf + 41 - 4, *pLen_out + 4);
+        for (i = 0; i < 4; ++i, c <<= 8)
+            (out_buf.m_pBuf + out_buf.m_size - 16)[i] = (mz_uint8)(c >> 24);
+        // compute final size of file, grab compressed data buffer and return
+        *pLen_out += 57;
+        MZ_FREE(pComp);
+        return out_buf.m_pBuf;
+    }
+    void* tdefl_write_image_to_png_file_in_memory(const void* pImage, int w, int h, int num_chans, size_t* pLen_out) {
+        // Level 6 corresponds to TDEFL_DEFAULT_MAX_PROBES or MZ_DEFAULT_LEVEL (but we can't depend on MZ_DEFAULT_LEVEL being available in case the zlib API's where #defined out)
+        return tdefl_write_image_to_png_file_in_memory_ex(pImage, w, h, num_chans, pLen_out, 6, MZ_FALSE);
+    }
+
+#    ifdef _MSC_VER
+#        pragma warning(pop)
+#    endif
+
+    // ------------------- .ZIP archive reading
+
+#    ifndef MINIZ_NO_ARCHIVE_APIS
+
+#        ifdef MINIZ_NO_STDIO
+#            define MZ_FILE void*
+#        else
+#            include <stdio.h>
+#            include <sys/stat.h>
+
+#            if defined(_MSC_VER)
+    static FILE* mz_fopen(const char* pFilename, const char* pMode) {
+        FILE* pFile = NULL;
+        fopen_s(&pFile, pFilename, pMode);
+        return pFile;
+    }
+    static FILE* mz_freopen(const char* pPath, const char* pMode, FILE* pStream) {
+        FILE* pFile = NULL;
+        if (freopen_s(&pFile, pPath, pMode, pStream)) return NULL;
+        return pFile;
+    }
+#                ifndef MINIZ_NO_TIME
+#                    include <sys/utime.h>
+#                endif
+#                define MZ_FILE FILE
+#                define MZ_FOPEN mz_fopen
+#                define MZ_FCLOSE fclose
+#                define MZ_FREAD fread
+#                define MZ_FWRITE fwrite
+#                define MZ_FTELL64 _ftelli64
+#                define MZ_FSEEK64 _fseeki64
+#                define MZ_FILE_STAT_STRUCT _stat
+#                define MZ_FILE_STAT _stat
+#                define MZ_FFLUSH fflush
+#                define MZ_FREOPEN mz_freopen
+#                define MZ_DELETE_FILE remove
+#            elif defined(__MINGW32__)
+#                ifndef MINIZ_NO_TIME
+#                    include <sys/utime.h>
+#                endif
+#                define MZ_FILE FILE
+#                define MZ_FOPEN(f, m) fopen(f, m)
+#                define MZ_FCLOSE fclose
+#                define MZ_FREAD fread
+#                define MZ_FWRITE fwrite
+#                define MZ_FTELL64 ftello64
+#                define MZ_FSEEK64 fseeko64
+#                define MZ_FILE_STAT_STRUCT _stat
+#                define MZ_FILE_STAT _stat
+#                define MZ_FFLUSH fflush
+#                define MZ_FREOPEN(f, m, s) freopen(f, m, s)
+#                define MZ_DELETE_FILE remove
+#            elif defined(__TINYC__)
+#                ifndef MINIZ_NO_TIME
+#                    include <sys/utime.h>
+#                endif
+#                define MZ_FILE FILE
+#                define MZ_FOPEN(f, m) fopen(f, m)
+#                define MZ_FCLOSE fclose
+#                define MZ_FREAD fread
+#                define MZ_FWRITE fwrite
+#                define MZ_FTELL64 ftell
+#                define MZ_FSEEK64 fseek
+#                define MZ_FILE_STAT_STRUCT stat
+#                define MZ_FILE_STAT stat
+#                define MZ_FFLUSH fflush
+#                define MZ_FREOPEN(f, m, s) freopen(f, m, s)
+#                define MZ_DELETE_FILE remove
+#            elif defined(__GNUC__) && _LARGEFILE64_SOURCE
+#                ifndef MINIZ_NO_TIME
+#                    include <utime.h>
+#                endif
+#                define MZ_FILE FILE
+#                define MZ_FOPEN(f, m) fopen64(f, m)
+#                define MZ_FCLOSE fclose
+#                define MZ_FREAD fread
+#                define MZ_FWRITE fwrite
+#                define MZ_FTELL64 ftello64
+#                define MZ_FSEEK64 fseeko64
+#                define MZ_FILE_STAT_STRUCT stat64
+#                define MZ_FILE_STAT stat64
+#                define MZ_FFLUSH fflush
+#                define MZ_FREOPEN(p, m, s) freopen64(p, m, s)
+#                define MZ_DELETE_FILE remove
+#            else
+#                ifndef MINIZ_NO_TIME
+#                    include <utime.h>
+#                endif
+#                define MZ_FILE FILE
+#                define MZ_FOPEN(f, m) fopen(f, m)
+#                define MZ_FCLOSE fclose
+#                define MZ_FREAD fread
+#                define MZ_FWRITE fwrite
+#                define MZ_FTELL64 ftello
+#                define MZ_FSEEK64 fseeko
+#                define MZ_FILE_STAT_STRUCT stat
+#                define MZ_FILE_STAT stat
+#                define MZ_FFLUSH fflush
+#                define MZ_FREOPEN(f, m, s) freopen(f, m, s)
+#                define MZ_DELETE_FILE remove
+#            endif  // #ifdef _MSC_VER
+#        endif      // #ifdef MINIZ_NO_STDIO
+
+#        define MZ_TOLOWER(c) ((((c) >= 'A') && ((c) <= 'Z')) ? ((c) - 'A' + 'a') : (c))
+
+    // Various ZIP archive enums. To completely avoid cross platform compiler alignment and platform endian issues, miniz.c doesn't use structs for any of this stuff.
+    enum
+    {
+        // ZIP archive identifiers and record sizes
+        MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06054b50,
+        MZ_ZIP_CENTRAL_DIR_HEADER_SIG = 0x02014b50,
+        MZ_ZIP_LOCAL_DIR_HEADER_SIG = 0x04034b50,
+        MZ_ZIP_LOCAL_DIR_HEADER_SIZE = 30,
+        MZ_ZIP_CENTRAL_DIR_HEADER_SIZE = 46,
+        MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE = 22,
+        // Central directory header record offsets
+        MZ_ZIP_CDH_SIG_OFS = 0,
+        MZ_ZIP_CDH_VERSION_MADE_BY_OFS = 4,
+        MZ_ZIP_CDH_VERSION_NEEDED_OFS = 6,
+        MZ_ZIP_CDH_BIT_FLAG_OFS = 8,
+        MZ_ZIP_CDH_METHOD_OFS = 10,
+        MZ_ZIP_CDH_FILE_TIME_OFS = 12,
+        MZ_ZIP_CDH_FILE_DATE_OFS = 14,
+        MZ_ZIP_CDH_CRC32_OFS = 16,
+        MZ_ZIP_CDH_COMPRESSED_SIZE_OFS = 20,
+        MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS = 24,
+        MZ_ZIP_CDH_FILENAME_LEN_OFS = 28,
+        MZ_ZIP_CDH_EXTRA_LEN_OFS = 30,
+        MZ_ZIP_CDH_COMMENT_LEN_OFS = 32,
+        MZ_ZIP_CDH_DISK_START_OFS = 34,
+        MZ_ZIP_CDH_INTERNAL_ATTR_OFS = 36,
+        MZ_ZIP_CDH_EXTERNAL_ATTR_OFS = 38,
+        MZ_ZIP_CDH_LOCAL_HEADER_OFS = 42,
+        // Local directory header offsets
+        MZ_ZIP_LDH_SIG_OFS = 0,
+        MZ_ZIP_LDH_VERSION_NEEDED_OFS = 4,
+        MZ_ZIP_LDH_BIT_FLAG_OFS = 6,
+        MZ_ZIP_LDH_METHOD_OFS = 8,
+        MZ_ZIP_LDH_FILE_TIME_OFS = 10,
+        MZ_ZIP_LDH_FILE_DATE_OFS = 12,
+        MZ_ZIP_LDH_CRC32_OFS = 14,
+        MZ_ZIP_LDH_COMPRESSED_SIZE_OFS = 18,
+        MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS = 22,
+        MZ_ZIP_LDH_FILENAME_LEN_OFS = 26,
+        MZ_ZIP_LDH_EXTRA_LEN_OFS = 28,
+        // End of central directory offsets
+        MZ_ZIP_ECDH_SIG_OFS = 0,
+        MZ_ZIP_ECDH_NUM_THIS_DISK_OFS = 4,
+        MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS = 6,
+        MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 8,
+        MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS = 10,
+        MZ_ZIP_ECDH_CDIR_SIZE_OFS = 12,
+        MZ_ZIP_ECDH_CDIR_OFS_OFS = 16,
+        MZ_ZIP_ECDH_COMMENT_SIZE_OFS = 20,
+    };
+
+    typedef struct
+    {
+        void* m_p;
+        size_t m_size, m_capacity;
+        mz_uint m_element_size;
+    } mz_zip_array;
+
+    struct mz_zip_internal_state_tag
+    {
+        mz_zip_array m_central_dir;
+        mz_zip_array m_central_dir_offsets;
+        mz_zip_array m_sorted_central_dir_offsets;
+        MZ_FILE* m_pFile;
+        void* m_pMem;
+        size_t m_mem_size;
+        size_t m_mem_capacity;
+    };
+
+#        define MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(array_ptr, element_size) (array_ptr)->m_element_size = element_size
+#        define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index) ((element_type*)((array_ptr)->m_p))[index]
+
+    static MZ_FORCEINLINE void mz_zip_array_clear(mz_zip_archive* pZip, mz_zip_array* pArray) {
+        pZip->m_pFree(pZip->m_pAlloc_opaque, pArray->m_p);
+        memset(pArray, 0, sizeof(mz_zip_array));
+    }
+
+    static mz_bool mz_zip_array_ensure_capacity(mz_zip_archive* pZip, mz_zip_array* pArray, size_t min_new_capacity, mz_uint growing) {
+        void* pNew_p;
+        size_t new_capacity = min_new_capacity;
+        MZ_ASSERT(pArray->m_element_size);
+        if (pArray->m_capacity >= min_new_capacity) return MZ_TRUE;
+        if (growing) {
+            new_capacity = MZ_MAX(1, pArray->m_capacity);
+            while (new_capacity < min_new_capacity)
+                new_capacity *= 2;
+        }
+        if (NULL == (pNew_p = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pArray->m_p, pArray->m_element_size, new_capacity))) return MZ_FALSE;
+        pArray->m_p = pNew_p;
+        pArray->m_capacity = new_capacity;
+        return MZ_TRUE;
+    }
+
+    static MZ_FORCEINLINE mz_bool mz_zip_array_reserve(mz_zip_archive* pZip, mz_zip_array* pArray, size_t new_capacity, mz_uint growing) {
+        if (new_capacity > pArray->m_capacity) {
+            if (!mz_zip_array_ensure_capacity(pZip, pArray, new_capacity, growing)) return MZ_FALSE;
+        }
+        return MZ_TRUE;
+    }
+
+    static MZ_FORCEINLINE mz_bool mz_zip_array_resize(mz_zip_archive* pZip, mz_zip_array* pArray, size_t new_size, mz_uint growing) {
+        if (new_size > pArray->m_capacity) {
+            if (!mz_zip_array_ensure_capacity(pZip, pArray, new_size, growing)) return MZ_FALSE;
+        }
+        pArray->m_size = new_size;
+        return MZ_TRUE;
+    }
+
+    static MZ_FORCEINLINE mz_bool mz_zip_array_ensure_room(mz_zip_archive* pZip, mz_zip_array* pArray, size_t n) {
+        return mz_zip_array_reserve(pZip, pArray, pArray->m_size + n, MZ_TRUE);
+    }
+
+    static MZ_FORCEINLINE mz_bool mz_zip_array_push_back(mz_zip_archive* pZip, mz_zip_array* pArray, const void* pElements, size_t n) {
+        size_t orig_size = pArray->m_size;
+        if (!mz_zip_array_resize(pZip, pArray, orig_size + n, MZ_TRUE)) return MZ_FALSE;
+        memcpy((mz_uint8*)pArray->m_p + orig_size * pArray->m_element_size, pElements, n * pArray->m_element_size);
+        return MZ_TRUE;
+    }
+
+#        ifndef MINIZ_NO_TIME
+    static time_t mz_zip_dos_to_time_t(int dos_time, int dos_date) {
+        struct tm tm;
+        memset(&tm, 0, sizeof(tm));
+        tm.tm_isdst = -1;
+        tm.tm_year = ((dos_date >> 9) & 127) + 1980 - 1900;
+        tm.tm_mon = ((dos_date >> 5) & 15) - 1;
+        tm.tm_mday = dos_date & 31;
+        tm.tm_hour = (dos_time >> 11) & 31;
+        tm.tm_min = (dos_time >> 5) & 63;
+        tm.tm_sec = (dos_time << 1) & 62;
+        return mktime(&tm);
+    }
+
+    static void mz_zip_time_to_dos_time(time_t time, mz_uint16* pDOS_time, mz_uint16* pDOS_date) {
+#            ifdef _MSC_VER
+        struct tm tm_struct;
+        struct tm* tm = &tm_struct;
+        errno_t err = localtime_s(tm, &time);
+        if (err) {
+            *pDOS_date = 0;
+            *pDOS_time = 0;
+            return;
+        }
+#            else
+        struct tm* tm = localtime(&time);
+#            endif
+        *pDOS_time = (mz_uint16)(((tm->tm_hour) << 11) + ((tm->tm_min) << 5) + ((tm->tm_sec) >> 1));
+        *pDOS_date = (mz_uint16)(((tm->tm_year + 1900 - 1980) << 9) + ((tm->tm_mon + 1) << 5) + tm->tm_mday);
+    }
+#        endif
+
+#        ifndef MINIZ_NO_STDIO
+    static mz_bool mz_zip_get_file_modified_time(const char* pFilename, mz_uint16* pDOS_time, mz_uint16* pDOS_date) {
+#            ifdef MINIZ_NO_TIME
+        (void)pFilename;
+        *pDOS_date = *pDOS_time = 0;
+#            else
+        struct MZ_FILE_STAT_STRUCT file_stat;
+        // On Linux with x86 glibc, this call will fail on large files (>= 0x80000000 bytes) unless you compiled with _LARGEFILE64_SOURCE. Argh.
+        if (MZ_FILE_STAT(pFilename, &file_stat) != 0) return MZ_FALSE;
+        mz_zip_time_to_dos_time(file_stat.st_mtime, pDOS_time, pDOS_date);
+#            endif  // #ifdef MINIZ_NO_TIME
+        return MZ_TRUE;
+    }
+
+#            ifndef MINIZ_NO_TIME
+    static mz_bool mz_zip_set_file_times(const char* pFilename, time_t access_time, time_t modified_time) {
+        struct utimbuf t;
+        t.actime = access_time;
+        t.modtime = modified_time;
+        return !utime(pFilename, &t);
+    }
+#            endif  // #ifndef MINIZ_NO_TIME
+#        endif      // #ifndef MINIZ_NO_STDIO
+
+    static mz_bool mz_zip_reader_init_internal(mz_zip_archive* pZip, mz_uint32 flags) {
+        (void)flags;
+        if ((!pZip) || (pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID)) return MZ_FALSE;
+
+        if (!pZip->m_pAlloc) pZip->m_pAlloc = def_alloc_func;
+        if (!pZip->m_pFree) pZip->m_pFree = def_free_func;
+        if (!pZip->m_pRealloc) pZip->m_pRealloc = def_realloc_func;
+
+        pZip->m_zip_mode = MZ_ZIP_MODE_READING;
+        pZip->m_archive_size = 0;
+        pZip->m_central_directory_file_ofs = 0;
+        pZip->m_total_files = 0;
+
+        if (NULL == (pZip->m_pState = (mz_zip_internal_state*)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
+            return MZ_FALSE;
+        memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));
+        MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));
+        MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));
+        MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));
+        return MZ_TRUE;
+    }
+
+    static MZ_FORCEINLINE mz_bool mz_zip_reader_filename_less(const mz_zip_array* pCentral_dir_array, const mz_zip_array* pCentral_dir_offsets,
+                                                              mz_uint l_index, mz_uint r_index) {
+        const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;
+        const mz_uint8* pR = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, r_index));
+        mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS), r_len = MZ_READ_LE16(pR + MZ_ZIP_CDH_FILENAME_LEN_OFS);
+        mz_uint8 l = 0, r = 0;
+        pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
+        pR += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
+        pE = pL + MZ_MIN(l_len, r_len);
+        while (pL < pE) {
+            if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR))) break;
+            pL++;
+            pR++;
+        }
+        return (pL == pE) ? (l_len < r_len) : (l < r);
+    }
+
+#        define MZ_SWAP_UINT32(a, b) \
+            do {                     \
+                mz_uint32 t = a;     \
+                a = b;               \
+                b = t;               \
+            }                        \
+            MZ_MACRO_END
+
+    // Heap sort of lowercase filenames, used to help accelerate plain central directory searches by mz_zip_reader_locate_file(). (Could also use qsort(), but it could allocate memory.)
+    static void mz_zip_reader_sort_central_dir_offsets_by_filename(mz_zip_archive* pZip) {
+        mz_zip_internal_state* pState = pZip->m_pState;
+        const mz_zip_array* pCentral_dir_offsets = &pState->m_central_dir_offsets;
+        const mz_zip_array* pCentral_dir = &pState->m_central_dir;
+        mz_uint32* pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);
+        const int size = pZip->m_total_files;
+        int start = (size - 2) >> 1, end;
+        while (start >= 0) {
+            int child, root = start;
+            for (;;) {
+                if ((child = (root << 1) + 1) >= size) break;
+                child +=
+                  (((child + 1) < size) && (mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1])));
+                if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child])) break;
+                MZ_SWAP_UINT32(pIndices[root], pIndices[child]);
+                root = child;
+            }
+            start--;
+        }
+
+        end = size - 1;
+        while (end > 0) {
+            int child, root = 0;
+            MZ_SWAP_UINT32(pIndices[end], pIndices[0]);
+            for (;;) {
+                if ((child = (root << 1) + 1) >= end) break;
+                child +=
+                  (((child + 1) < end) && mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1]));
+                if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child])) break;
+                MZ_SWAP_UINT32(pIndices[root], pIndices[child]);
+                root = child;
+            }
+            end--;
+        }
+    }
+
+    static mz_bool mz_zip_reader_read_central_dir(mz_zip_archive* pZip, mz_uint32 flags) {
+        mz_uint cdir_size, num_this_disk, cdir_disk_index;
+        mz_uint64 cdir_ofs;
+        mz_int64 cur_file_ofs;
+        const mz_uint8* p;
+        mz_uint32 buf_u32[4096 / sizeof(mz_uint32)];
+        mz_uint8* pBuf = (mz_uint8*)buf_u32;
+        mz_bool sort_central_dir = ((flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0);
+        // Basic sanity checks - reject files which are too small, and check the first 4 bytes of the file to make sure a local header is there.
+        if (pZip->m_archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) return MZ_FALSE;
+        // Find the end of central directory record by scanning the file from the end towards the beginning.
+        cur_file_ofs = MZ_MAX((mz_int64)pZip->m_archive_size - (mz_int64)sizeof(buf_u32), 0);
+        for (;;) {
+            int i, n = (int)MZ_MIN(sizeof(buf_u32), pZip->m_archive_size - cur_file_ofs);
+            if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, n) != (mz_uint)n) return MZ_FALSE;
+            for (i = n - 4; i >= 0; --i)
+                if (MZ_READ_LE32(pBuf + i) == MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG) break;
+            if (i >= 0) {
+                cur_file_ofs += i;
+                break;
+            }
+            if ((!cur_file_ofs) || ((pZip->m_archive_size - cur_file_ofs) >= (0xFFFF + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE))) return MZ_FALSE;
+            cur_file_ofs = MZ_MAX(cur_file_ofs - (sizeof(buf_u32) - 3), 0);
+        }
+        // Read and verify the end of central directory record.
+        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
+            return MZ_FALSE;
+        if ((MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_SIG_OFS) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG)
+            || ((pZip->m_total_files = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS))
+                != MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS)))
+            return MZ_FALSE;
+
+        num_this_disk = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_THIS_DISK_OFS);
+        cdir_disk_index = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS);
+        if (((num_this_disk | cdir_disk_index) != 0) && ((num_this_disk != 1) || (cdir_disk_index != 1))) return MZ_FALSE;
+
+        if ((cdir_size = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_SIZE_OFS)) < pZip->m_total_files * MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) return MZ_FALSE;
+
+        cdir_ofs = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_OFS_OFS);
+        if ((cdir_ofs + (mz_uint64)cdir_size) > pZip->m_archive_size) return MZ_FALSE;
+
+        pZip->m_central_directory_file_ofs = cdir_ofs;
+
+        if (pZip->m_total_files) {
+            mz_uint i, n;
+
+            // Read the entire central directory into a heap block, and allocate another heap block to hold the unsorted central dir file record offsets, and another to hold the sorted indices.
+            if ((!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir, cdir_size, MZ_FALSE))
+                || (!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir_offsets, pZip->m_total_files, MZ_FALSE)))
+                return MZ_FALSE;
+
+            if (sort_central_dir) {
+                if (!mz_zip_array_resize(pZip, &pZip->m_pState->m_sorted_central_dir_offsets, pZip->m_total_files, MZ_FALSE)) return MZ_FALSE;
+            }
+
+            if (pZip->m_pRead(pZip->m_pIO_opaque, cdir_ofs, pZip->m_pState->m_central_dir.m_p, cdir_size) != cdir_size) return MZ_FALSE;
+
+            // Now create an index into the central directory file records, do some basic sanity checking on each record, and check for zip64 entries (which are not yet supported).
+            p = (const mz_uint8*)pZip->m_pState->m_central_dir.m_p;
+            for (n = cdir_size, i = 0; i < pZip->m_total_files; ++i) {
+                mz_uint total_header_size, comp_size, decomp_size, disk_index;
+                if ((n < MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) || (MZ_READ_LE32(p) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG)) return MZ_FALSE;
+                MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, i) =
+                  (mz_uint32)(p - (const mz_uint8*)pZip->m_pState->m_central_dir.m_p);
+                if (sort_central_dir) MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_sorted_central_dir_offsets, mz_uint32, i) = i;
+                comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
+                decomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
+                if (((!MZ_READ_LE32(p + MZ_ZIP_CDH_METHOD_OFS)) && (decomp_size != comp_size)) || (decomp_size && !comp_size)
+                    || (decomp_size == 0xFFFFFFFF) || (comp_size == 0xFFFFFFFF))
+                    return MZ_FALSE;
+                disk_index = MZ_READ_LE16(p + MZ_ZIP_CDH_DISK_START_OFS);
+                if ((disk_index != num_this_disk) && (disk_index != 1)) return MZ_FALSE;
+                if (((mz_uint64)MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS) + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + comp_size) > pZip->m_archive_size)
+                    return MZ_FALSE;
+                if ((total_header_size = MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS)
+                                         + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS))
+                    > n)
+                    return MZ_FALSE;
+                n -= total_header_size;
+                p += total_header_size;
+            }
+        }
+
+        if (sort_central_dir) mz_zip_reader_sort_central_dir_offsets_by_filename(pZip);
+
+        return MZ_TRUE;
+    }
+
+    mz_bool mz_zip_reader_init(mz_zip_archive* pZip, mz_uint64 size, mz_uint32 flags) {
+        if ((!pZip) || (!pZip->m_pRead)) return MZ_FALSE;
+        if (!mz_zip_reader_init_internal(pZip, flags)) return MZ_FALSE;
+        pZip->m_archive_size = size;
+        if (!mz_zip_reader_read_central_dir(pZip, flags)) {
+            mz_zip_reader_end(pZip);
+            return MZ_FALSE;
+        }
+        return MZ_TRUE;
+    }
+
+    static size_t mz_zip_mem_read_func(void* pOpaque, mz_uint64 file_ofs, void* pBuf, size_t n) {
+        mz_zip_archive* pZip = (mz_zip_archive*)pOpaque;
+        size_t s = (file_ofs >= pZip->m_archive_size) ? 0 : (size_t)MZ_MIN(pZip->m_archive_size - file_ofs, n);
+        memcpy(pBuf, (const mz_uint8*)pZip->m_pState->m_pMem + file_ofs, s);
+        return s;
+    }
+
+    mz_bool mz_zip_reader_init_mem(mz_zip_archive* pZip, const void* pMem, size_t size, mz_uint32 flags) {
+        if (!mz_zip_reader_init_internal(pZip, flags)) return MZ_FALSE;
+        pZip->m_archive_size = size;
+        pZip->m_pRead = mz_zip_mem_read_func;
+        pZip->m_pIO_opaque = pZip;
+#        ifdef __cplusplus
+        pZip->m_pState->m_pMem = const_cast<void*>(pMem);
+#        else
+        pZip->m_pState->m_pMem = (void*)pMem;
+#        endif
+        pZip->m_pState->m_mem_size = size;
+        if (!mz_zip_reader_read_central_dir(pZip, flags)) {
+            mz_zip_reader_end(pZip);
+            return MZ_FALSE;
+        }
+        return MZ_TRUE;
+    }
+
+#        ifndef MINIZ_NO_STDIO
+    static size_t mz_zip_file_read_func(void* pOpaque, mz_uint64 file_ofs, void* pBuf, size_t n) {
+        mz_zip_archive* pZip = (mz_zip_archive*)pOpaque;
+        mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
+        if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
+            return 0;
+        return MZ_FREAD(pBuf, 1, n, pZip->m_pState->m_pFile);
+    }
+
+    mz_bool mz_zip_reader_init_file(mz_zip_archive* pZip, const char* pFilename, mz_uint32 flags) {
+        mz_uint64 file_size;
+        MZ_FILE* pFile = MZ_FOPEN(pFilename, "rb");
+        if (!pFile) return MZ_FALSE;
+        if (MZ_FSEEK64(pFile, 0, SEEK_END)) {
+            MZ_FCLOSE(pFile);
+            return MZ_FALSE;
+        }
+        file_size = MZ_FTELL64(pFile);
+        if (!mz_zip_reader_init_internal(pZip, flags)) {
+            MZ_FCLOSE(pFile);
+            return MZ_FALSE;
+        }
+        pZip->m_pRead = mz_zip_file_read_func;
+        pZip->m_pIO_opaque = pZip;
+        pZip->m_pState->m_pFile = pFile;
+        pZip->m_archive_size = file_size;
+        if (!mz_zip_reader_read_central_dir(pZip, flags)) {
+            mz_zip_reader_end(pZip);
+            return MZ_FALSE;
+        }
+        return MZ_TRUE;
+    }
+#        endif  // #ifndef MINIZ_NO_STDIO
+
+    mz_uint mz_zip_reader_get_num_files(mz_zip_archive* pZip) {
+        return pZip ? pZip->m_total_files : 0;
+    }
+
+    static MZ_FORCEINLINE const mz_uint8* mz_zip_reader_get_cdh(mz_zip_archive* pZip, mz_uint file_index) {
+        if ((!pZip) || (!pZip->m_pState) || (file_index >= pZip->m_total_files) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING)) return NULL;
+        return &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8,
+                                     MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));
+    }
+
+    mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive* pZip, mz_uint file_index) {
+        mz_uint m_bit_flag;
+        const mz_uint8* p = mz_zip_reader_get_cdh(pZip, file_index);
+        if (!p) return MZ_FALSE;
+        m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
+        return (m_bit_flag & 1);
+    }
+
+    mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive* pZip, mz_uint file_index) {
+        mz_uint filename_len, external_attr;
+        const mz_uint8* p = mz_zip_reader_get_cdh(pZip, file_index);
+        if (!p) return MZ_FALSE;
+
+        // First see if the filename ends with a '/' character.
+        filename_len = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
+        if (filename_len) {
+            if (*(p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_len - 1) == '/') return MZ_TRUE;
+        }
+
+        // Bugfix: This code was also checking if the internal attribute was non-zero, which wasn't correct.
+        // Most/all zip writers (hopefully) set DOS file/directory attributes in the low 16-bits, so check for the DOS directory flag and ignore the source OS ID in the created by field.
+        // FIXME: Remove this check? Is it necessary - we already check the filename.
+        external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
+        if ((external_attr & 0x10) != 0) return MZ_TRUE;
+
+        return MZ_FALSE;
+    }
+
+    mz_bool mz_zip_reader_file_stat(mz_zip_archive* pZip, mz_uint file_index, mz_zip_archive_file_stat* pStat) {
+        mz_uint n;
+        const mz_uint8* p = mz_zip_reader_get_cdh(pZip, file_index);
+        if ((!p) || (!pStat)) return MZ_FALSE;
+
+        // Unpack the central directory record.
+        pStat->m_file_index = file_index;
+        pStat->m_central_dir_ofs = MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index);
+        pStat->m_version_made_by = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS);
+        pStat->m_version_needed = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_NEEDED_OFS);
+        pStat->m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
+        pStat->m_method = MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS);
+#        ifndef MINIZ_NO_TIME
+        pStat->m_time = mz_zip_dos_to_time_t(MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_TIME_OFS), MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_DATE_OFS));
+#        endif
+        pStat->m_crc32 = MZ_READ_LE32(p + MZ_ZIP_CDH_CRC32_OFS);
+        pStat->m_comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
+        pStat->m_uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
+        pStat->m_internal_attr = MZ_READ_LE16(p + MZ_ZIP_CDH_INTERNAL_ATTR_OFS);
+        pStat->m_external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
+        pStat->m_local_header_ofs = MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS);
+
+        // Copy as much of the filename and comment as possible.
+        n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
+        n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE - 1);
+        memcpy(pStat->m_filename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
+        pStat->m_filename[n] = '\0';
+
+        n = MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS);
+        n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE - 1);
+        pStat->m_comment_size = n;
+        memcpy(pStat->m_comment,
+               p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS), n);
+        pStat->m_comment[n] = '\0';
+
+        return MZ_TRUE;
+    }
+
+    mz_uint mz_zip_reader_get_filename(mz_zip_archive* pZip, mz_uint file_index, char* pFilename, mz_uint filename_buf_size) {
+        mz_uint n;
+        const mz_uint8* p = mz_zip_reader_get_cdh(pZip, file_index);
+        if (!p) {
+            if (filename_buf_size) pFilename[0] = '\0';
+            return 0;
+        }
+        n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
+        if (filename_buf_size) {
+            n = MZ_MIN(n, filename_buf_size - 1);
+            memcpy(pFilename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
+            pFilename[n] = '\0';
+        }
+        return n + 1;
+    }
+
+    static MZ_FORCEINLINE mz_bool mz_zip_reader_string_equal(const char* pA, const char* pB, mz_uint len, mz_uint flags) {
+        mz_uint i;
+        if (flags & MZ_ZIP_FLAG_CASE_SENSITIVE) return 0 == memcmp(pA, pB, len);
+        for (i = 0; i < len; ++i)
+            if (MZ_TOLOWER(pA[i]) != MZ_TOLOWER(pB[i])) return MZ_FALSE;
+        return MZ_TRUE;
+    }
+
+    static MZ_FORCEINLINE int mz_zip_reader_filename_compare(const mz_zip_array* pCentral_dir_array, const mz_zip_array* pCentral_dir_offsets,
+                                                             mz_uint l_index, const char* pR, mz_uint r_len) {
+        const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;
+        mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS);
+        mz_uint8 l = 0, r = 0;
+        pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
+        pE = pL + MZ_MIN(l_len, r_len);
+        while (pL < pE) {
+            if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR))) break;
+            pL++;
+            pR++;
+        }
+        return (pL == pE) ? (int)(l_len - r_len) : (l - r);
+    }
+
+    static int mz_zip_reader_locate_file_binary_search(mz_zip_archive* pZip, const char* pFilename) {
+        mz_zip_internal_state* pState = pZip->m_pState;
+        const mz_zip_array* pCentral_dir_offsets = &pState->m_central_dir_offsets;
+        const mz_zip_array* pCentral_dir = &pState->m_central_dir;
+        mz_uint32* pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);
+        const int size = pZip->m_total_files;
+        const mz_uint filename_len = (mz_uint)strlen(pFilename);
+        int l = 0, h = size - 1;
+        while (l <= h) {
+            int m = (l + h) >> 1, file_index = pIndices[m],
+                comp = mz_zip_reader_filename_compare(pCentral_dir, pCentral_dir_offsets, file_index, pFilename, filename_len);
+            if (!comp)
+                return file_index;
+            else if (comp < 0)
+                l = m + 1;
+            else
+                h = m - 1;
+        }
+        return -1;
+    }
+
+    int mz_zip_reader_locate_file(mz_zip_archive* pZip, const char* pName, const char* pComment, mz_uint flags) {
+        mz_uint file_index;
+        size_t name_len, comment_len;
+        if ((!pZip) || (!pZip->m_pState) || (!pName) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING)) return -1;
+        if (((flags & (MZ_ZIP_FLAG_IGNORE_PATH | MZ_ZIP_FLAG_CASE_SENSITIVE)) == 0) && (!pComment)
+            && (pZip->m_pState->m_sorted_central_dir_offsets.m_size))
+            return mz_zip_reader_locate_file_binary_search(pZip, pName);
+        name_len = strlen(pName);
+        if (name_len > 0xFFFF) return -1;
+        comment_len = pComment ? strlen(pComment) : 0;
+        if (comment_len > 0xFFFF) return -1;
+        for (file_index = 0; file_index < pZip->m_total_files; file_index++) {
+            const mz_uint8* pHeader = &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8,
+                                                            MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));
+            mz_uint filename_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_FILENAME_LEN_OFS);
+            const char* pFilename = (const char*)pHeader + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
+            if (filename_len < name_len) continue;
+            if (comment_len) {
+                mz_uint file_extra_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_EXTRA_LEN_OFS),
+                        file_comment_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_COMMENT_LEN_OFS);
+                const char* pFile_comment = pFilename + filename_len + file_extra_len;
+                if ((file_comment_len != comment_len) || (!mz_zip_reader_string_equal(pComment, pFile_comment, file_comment_len, flags))) continue;
+            }
+            if ((flags & MZ_ZIP_FLAG_IGNORE_PATH) && (filename_len)) {
+                int ofs = filename_len - 1;
+                do {
+                    if ((pFilename[ofs] == '/') || (pFilename[ofs] == '\\') || (pFilename[ofs] == ':')) break;
+                } while (--ofs >= 0);
+                ofs++;
+                pFilename += ofs;
+                filename_len -= ofs;
+            }
+            if ((filename_len == name_len) && (mz_zip_reader_string_equal(pName, pFilename, filename_len, flags))) return file_index;
+        }
+        return -1;
+    }
+
+    mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive* pZip, mz_uint file_index, void* pBuf, size_t buf_size, mz_uint flags,
+                                                  void* pUser_read_buf, size_t user_read_buf_size) {
+        int status = TINFL_STATUS_DONE;
+        mz_uint64 needed_size, cur_file_ofs, comp_remaining, out_buf_ofs = 0, read_buf_size, read_buf_ofs = 0, read_buf_avail;
+        mz_zip_archive_file_stat file_stat;
+        void* pRead_buf;
+        mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
+        mz_uint8* pLocal_header = (mz_uint8*)local_header_u32;
+        tinfl_decompressor inflator;
+
+        if ((buf_size) && (!pBuf)) return MZ_FALSE;
+
+        if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat)) return MZ_FALSE;
+
+        // Empty file, or a directory (but not always a directory - I've seen odd zips with directories that have compressed data which inflates to 0 bytes)
+        if (!file_stat.m_comp_size) return MZ_TRUE;
+
+        // Entry is a subdirectory (I've seen old zips with dir entries which have compressed deflate data which inflates to 0 bytes, but these entries claim to uncompress to 512 bytes in the headers).
+        // I'm torn how to handle this case - should it fail instead?
+        if (mz_zip_reader_is_file_a_directory(pZip, file_index)) return MZ_TRUE;
+
+        // Encryption and patch files are not supported.
+        if (file_stat.m_bit_flag & (1 | 32)) return MZ_FALSE;
+
+        // This function only supports stored and deflate.
+        if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED)) return MZ_FALSE;
+
+        // Ensure supplied output buffer is large enough.
+        needed_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? file_stat.m_comp_size : file_stat.m_uncomp_size;
+        if (buf_size < needed_size) return MZ_FALSE;
+
+        // Read and parse the local directory entry.
+        cur_file_ofs = file_stat.m_local_header_ofs;
+        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
+            return MZ_FALSE;
+        if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG) return MZ_FALSE;
+
+        cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS)
+                        + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
+        if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size) return MZ_FALSE;
+
+        if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method)) {
+            // The file is stored or the caller has requested the compressed data.
+            if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, (size_t)needed_size) != needed_size) return MZ_FALSE;
+            return ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) != 0)
+                   || (mz_crc32(MZ_CRC32_INIT, (const mz_uint8*)pBuf, (size_t)file_stat.m_uncomp_size) == file_stat.m_crc32);
+        }
+
+        // Decompress the file either directly from memory or from a file input buffer.
+        tinfl_init(&inflator);
+
+        if (pZip->m_pState->m_pMem) {
+            // Read directly from the archive in memory.
+            pRead_buf = (mz_uint8*)pZip->m_pState->m_pMem + cur_file_ofs;
+            read_buf_size = read_buf_avail = file_stat.m_comp_size;
+            comp_remaining = 0;
+        } else if (pUser_read_buf) {
+            // Use a user provided read buffer.
+            if (!user_read_buf_size) return MZ_FALSE;
+            pRead_buf = (mz_uint8*)pUser_read_buf;
+            read_buf_size = user_read_buf_size;
+            read_buf_avail = 0;
+            comp_remaining = file_stat.m_comp_size;
+        } else {
+            // Temporarily allocate a read buffer.
+            read_buf_size = MZ_MIN(file_stat.m_comp_size, MZ_ZIP_MAX_IO_BUF_SIZE);
+#        ifdef _MSC_VER
+            if (((0, sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))
+#        else
+            if (((sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))
+#        endif
+                return MZ_FALSE;
+            if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size))) return MZ_FALSE;
+            read_buf_avail = 0;
+            comp_remaining = file_stat.m_comp_size;
+        }
+
+        do {
+            size_t in_buf_size, out_buf_size = (size_t)(file_stat.m_uncomp_size - out_buf_ofs);
+            if ((!read_buf_avail) && (!pZip->m_pState->m_pMem)) {
+                read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
+                if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail) {
+                    status = TINFL_STATUS_FAILED;
+                    break;
+                }
+                cur_file_ofs += read_buf_avail;
+                comp_remaining -= read_buf_avail;
+                read_buf_ofs = 0;
+            }
+            in_buf_size = (size_t)read_buf_avail;
+            status = tinfl_decompress(&inflator, (mz_uint8*)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8*)pBuf, (mz_uint8*)pBuf + out_buf_ofs,
+                                      &out_buf_size, TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF | (comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0));
+            read_buf_avail -= in_buf_size;
+            read_buf_ofs += in_buf_size;
+            out_buf_ofs += out_buf_size;
+        } while (status == TINFL_STATUS_NEEDS_MORE_INPUT);
+
+        if (status == TINFL_STATUS_DONE) {
+            // Make sure the entire file was decompressed, and check its CRC.
+            if ((out_buf_ofs != file_stat.m_uncomp_size)
+                || (mz_crc32(MZ_CRC32_INIT, (const mz_uint8*)pBuf, (size_t)file_stat.m_uncomp_size) != file_stat.m_crc32))
+                status = TINFL_STATUS_FAILED;
+        }
+
+        if ((!pZip->m_pState->m_pMem) && (!pUser_read_buf)) pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
+
+        return status == TINFL_STATUS_DONE;
+    }
+
+    mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive* pZip, const char* pFilename, void* pBuf, size_t buf_size, mz_uint flags,
+                                                       void* pUser_read_buf, size_t user_read_buf_size) {
+        int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);
+        if (file_index < 0) return MZ_FALSE;
+        return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size, flags, pUser_read_buf, user_read_buf_size);
+    }
+
+    mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive* pZip, mz_uint file_index, void* pBuf, size_t buf_size, mz_uint flags) {
+        return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size, flags, NULL, 0);
+    }
+
+    mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive* pZip, const char* pFilename, void* pBuf, size_t buf_size, mz_uint flags) {
+        return mz_zip_reader_extract_file_to_mem_no_alloc(pZip, pFilename, pBuf, buf_size, flags, NULL, 0);
+    }
+
+    void* mz_zip_reader_extract_to_heap(mz_zip_archive* pZip, mz_uint file_index, size_t* pSize, mz_uint flags) {
+        mz_uint64 comp_size, uncomp_size, alloc_size;
+        const mz_uint8* p = mz_zip_reader_get_cdh(pZip, file_index);
+        void* pBuf;
+
+        if (pSize) *pSize = 0;
+        if (!p) return NULL;
+
+        comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
+        uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
+
+        alloc_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? comp_size : uncomp_size;
+#        ifdef _MSC_VER
+        if (((0, sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))
+#        else
+        if (((sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))
+#        endif
+            return NULL;
+        if (NULL == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)alloc_size))) return NULL;
+
+        if (!mz_zip_reader_extract_to_mem(pZip, file_index, pBuf, (size_t)alloc_size, flags)) {
+            pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
+            return NULL;
+        }
+
+        if (pSize) *pSize = (size_t)alloc_size;
+        return pBuf;
+    }
+
+    void* mz_zip_reader_extract_file_to_heap(mz_zip_archive* pZip, const char* pFilename, size_t* pSize, mz_uint flags) {
+        int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);
+        if (file_index < 0) {
+            if (pSize) *pSize = 0;
+            return MZ_FALSE;
+        }
+        return mz_zip_reader_extract_to_heap(pZip, file_index, pSize, flags);
+    }
+
+    mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive* pZip, mz_uint file_index, mz_file_write_func pCallback, void* pOpaque, mz_uint flags) {
+        int status = TINFL_STATUS_DONE;
+        mz_uint file_crc32 = MZ_CRC32_INIT;
+        mz_uint64 read_buf_size, read_buf_ofs = 0, read_buf_avail, comp_remaining, out_buf_ofs = 0, cur_file_ofs;
+        mz_zip_archive_file_stat file_stat;
+        void* pRead_buf = NULL;
+        void* pWrite_buf = NULL;
+        mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
+        mz_uint8* pLocal_header = (mz_uint8*)local_header_u32;
+
+        if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat)) return MZ_FALSE;
+
+        // Empty file, or a directory (but not always a directory - I've seen odd zips with directories that have compressed data which inflates to 0 bytes)
+        if (!file_stat.m_comp_size) return MZ_TRUE;
+
+        // Entry is a subdirectory (I've seen old zips with dir entries which have compressed deflate data which inflates to 0 bytes, but these entries claim to uncompress to 512 bytes in the headers).
+        // I'm torn how to handle this case - should it fail instead?
+        if (mz_zip_reader_is_file_a_directory(pZip, file_index)) return MZ_TRUE;
+
+        // Encryption and patch files are not supported.
+        if (file_stat.m_bit_flag & (1 | 32)) return MZ_FALSE;
+
+        // This function only supports stored and deflate.
+        if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED)) return MZ_FALSE;
+
+        // Read and parse the local directory entry.
+        cur_file_ofs = file_stat.m_local_header_ofs;
+        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
+            return MZ_FALSE;
+        if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG) return MZ_FALSE;
+
+        cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS)
+                        + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
+        if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size) return MZ_FALSE;
+
+        // Decompress the file either directly from memory or from a file input buffer.
+        if (pZip->m_pState->m_pMem) {
+            pRead_buf = (mz_uint8*)pZip->m_pState->m_pMem + cur_file_ofs;
+            read_buf_size = read_buf_avail = file_stat.m_comp_size;
+            comp_remaining = 0;
+        } else {
+            read_buf_size = MZ_MIN(file_stat.m_comp_size, MZ_ZIP_MAX_IO_BUF_SIZE);
+            if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size))) return MZ_FALSE;
+            read_buf_avail = 0;
+            comp_remaining = file_stat.m_comp_size;
+        }
+
+        if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method)) {
+            // The file is stored or the caller has requested the compressed data.
+            if (pZip->m_pState->m_pMem) {
+#        ifdef _MSC_VER
+                if (((0, sizeof(size_t) == sizeof(mz_uint32))) && (file_stat.m_comp_size > 0xFFFFFFFF))
+#        else
+                if (((sizeof(size_t) == sizeof(mz_uint32))) && (file_stat.m_comp_size > 0xFFFFFFFF))
+#        endif
+                    return MZ_FALSE;
+                if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)file_stat.m_comp_size) != file_stat.m_comp_size)
+                    status = TINFL_STATUS_FAILED;
+                else if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
+                    file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8*)pRead_buf, (size_t)file_stat.m_comp_size);
+                cur_file_ofs += file_stat.m_comp_size;
+                out_buf_ofs += file_stat.m_comp_size;
+                comp_remaining = 0;
+            } else {
+                while (comp_remaining) {
+                    read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
+                    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail) {
+                        status = TINFL_STATUS_FAILED;
+                        break;
+                    }
+
+                    if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
+                        file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8*)pRead_buf, (size_t)read_buf_avail);
+
+                    if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail) {
+                        status = TINFL_STATUS_FAILED;
+                        break;
+                    }
+                    cur_file_ofs += read_buf_avail;
+                    out_buf_ofs += read_buf_avail;
+                    comp_remaining -= read_buf_avail;
+                }
+            }
+        } else {
+            tinfl_decompressor inflator;
+            tinfl_init(&inflator);
+
+            if (NULL == (pWrite_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, TINFL_LZ_DICT_SIZE)))
+                status = TINFL_STATUS_FAILED;
+            else {
+                do {
+                    mz_uint8* pWrite_buf_cur = (mz_uint8*)pWrite_buf + (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
+                    size_t in_buf_size, out_buf_size = TINFL_LZ_DICT_SIZE - (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
+                    if ((!read_buf_avail) && (!pZip->m_pState->m_pMem)) {
+                        read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
+                        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail) {
+                            status = TINFL_STATUS_FAILED;
+                            break;
+                        }
+                        cur_file_ofs += read_buf_avail;
+                        comp_remaining -= read_buf_avail;
+                        read_buf_ofs = 0;
+                    }
+
+                    in_buf_size = (size_t)read_buf_avail;
+                    status = tinfl_decompress(&inflator, (const mz_uint8*)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8*)pWrite_buf,
+                                              pWrite_buf_cur, &out_buf_size, comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0);
+                    read_buf_avail -= in_buf_size;
+                    read_buf_ofs += in_buf_size;
+
+                    if (out_buf_size) {
+                        if (pCallback(pOpaque, out_buf_ofs, pWrite_buf_cur, out_buf_size) != out_buf_size) {
+                            status = TINFL_STATUS_FAILED;
+                            break;
+                        }
+                        file_crc32 = (mz_uint32)mz_crc32(file_crc32, pWrite_buf_cur, out_buf_size);
+                        if ((out_buf_ofs += out_buf_size) > file_stat.m_uncomp_size) {
+                            status = TINFL_STATUS_FAILED;
+                            break;
+                        }
+                    }
+                } while ((status == TINFL_STATUS_NEEDS_MORE_INPUT) || (status == TINFL_STATUS_HAS_MORE_OUTPUT));
+            }
+        }
+
+        if ((status == TINFL_STATUS_DONE) && (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))) {
+            // Make sure the entire file was decompressed, and check its CRC.
+            if ((out_buf_ofs != file_stat.m_uncomp_size) || (file_crc32 != file_stat.m_crc32)) status = TINFL_STATUS_FAILED;
+        }
+
+        if (!pZip->m_pState->m_pMem) pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
+        if (pWrite_buf) pZip->m_pFree(pZip->m_pAlloc_opaque, pWrite_buf);
+
+        return status == TINFL_STATUS_DONE;
+    }
+
+    mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive* pZip, const char* pFilename, mz_file_write_func pCallback, void* pOpaque,
+                                                   mz_uint flags) {
+        int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);
+        if (file_index < 0) return MZ_FALSE;
+        return mz_zip_reader_extract_to_callback(pZip, file_index, pCallback, pOpaque, flags);
+    }
+
+#        ifndef MINIZ_NO_STDIO
+    static size_t mz_zip_file_write_callback(void* pOpaque, mz_uint64 ofs, const void* pBuf, size_t n) {
+        (void)ofs;
+        return MZ_FWRITE(pBuf, 1, n, (MZ_FILE*)pOpaque);
+    }
+
+    mz_bool mz_zip_reader_extract_to_file(mz_zip_archive* pZip, mz_uint file_index, const char* pDst_filename, mz_uint flags) {
+        mz_bool status;
+        mz_zip_archive_file_stat file_stat;
+        MZ_FILE* pFile;
+        if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat)) return MZ_FALSE;
+        pFile = MZ_FOPEN(pDst_filename, "wb");
+        if (!pFile) return MZ_FALSE;
+        status = mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_file_write_callback, pFile, flags);
+        if (MZ_FCLOSE(pFile) == EOF) return MZ_FALSE;
+#            ifndef MINIZ_NO_TIME
+        if (status) mz_zip_set_file_times(pDst_filename, file_stat.m_time, file_stat.m_time);
+#            endif
+        return status;
+    }
+#        endif  // #ifndef MINIZ_NO_STDIO
+
+    mz_bool mz_zip_reader_end(mz_zip_archive* pZip) {
+        if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING)) return MZ_FALSE;
+
+        if (pZip->m_pState) {
+            mz_zip_internal_state* pState = pZip->m_pState;
+            pZip->m_pState = NULL;
+            mz_zip_array_clear(pZip, &pState->m_central_dir);
+            mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
+            mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);
+
+#        ifndef MINIZ_NO_STDIO
+            if (pState->m_pFile) {
+                MZ_FCLOSE(pState->m_pFile);
+                pState->m_pFile = NULL;
+            }
+#        endif  // #ifndef MINIZ_NO_STDIO
+
+            pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
+        }
+        pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;
+
+        return MZ_TRUE;
+    }
+
+#        ifndef MINIZ_NO_STDIO
+    mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive* pZip, const char* pArchive_filename, const char* pDst_filename, mz_uint flags) {
+        int file_index = mz_zip_reader_locate_file(pZip, pArchive_filename, NULL, flags);
+        if (file_index < 0) return MZ_FALSE;
+        return mz_zip_reader_extract_to_file(pZip, file_index, pDst_filename, flags);
+    }
+#        endif
+
+    // ------------------- .ZIP archive writing
+
+#        ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
+
+    static void mz_write_le16(mz_uint8* p, mz_uint16 v) {
+        p[0] = (mz_uint8)v;
+        p[1] = (mz_uint8)(v >> 8);
+    }
+    static void mz_write_le32(mz_uint8* p, mz_uint32 v) {
+        p[0] = (mz_uint8)v;
+        p[1] = (mz_uint8)(v >> 8);
+        p[2] = (mz_uint8)(v >> 16);
+        p[3] = (mz_uint8)(v >> 24);
+    }
+#            define MZ_WRITE_LE16(p, v) mz_write_le16((mz_uint8*)(p), (mz_uint16)(v))
+#            define MZ_WRITE_LE32(p, v) mz_write_le32((mz_uint8*)(p), (mz_uint32)(v))
+
+    mz_bool mz_zip_writer_init(mz_zip_archive* pZip, mz_uint64 existing_size) {
+        if ((!pZip) || (pZip->m_pState) || (!pZip->m_pWrite) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID)) return MZ_FALSE;
+
+        if (pZip->m_file_offset_alignment) {
+            // Ensure user specified file offset alignment is a power of 2.
+            if (pZip->m_file_offset_alignment & (pZip->m_file_offset_alignment - 1)) return MZ_FALSE;
+        }
+
+        if (!pZip->m_pAlloc) pZip->m_pAlloc = def_alloc_func;
+        if (!pZip->m_pFree) pZip->m_pFree = def_free_func;
+        if (!pZip->m_pRealloc) pZip->m_pRealloc = def_realloc_func;
+
+        pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;
+        pZip->m_archive_size = existing_size;
+        pZip->m_central_directory_file_ofs = 0;
+        pZip->m_total_files = 0;
+
+        if (NULL == (pZip->m_pState = (mz_zip_internal_state*)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
+            return MZ_FALSE;
+        memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));
+        MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));
+        MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));
+        MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));
+        return MZ_TRUE;
+    }
+
+    static size_t mz_zip_heap_write_func(void* pOpaque, mz_uint64 file_ofs, const void* pBuf, size_t n) {
+        mz_zip_archive* pZip = (mz_zip_archive*)pOpaque;
+        mz_zip_internal_state* pState = pZip->m_pState;
+        mz_uint64 new_size = MZ_MAX(file_ofs + n, pState->m_mem_size);
+#            ifdef _MSC_VER
+        if ((!n) || ((0, sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF)))
+#            else
+        if ((!n) || ((sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF)))
+#            endif
+            return 0;
+        if (new_size > pState->m_mem_capacity) {
+            void* pNew_block;
+            size_t new_capacity = MZ_MAX(64, pState->m_mem_capacity);
+            while (new_capacity < new_size)
+                new_capacity *= 2;
+            if (NULL == (pNew_block = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pState->m_pMem, 1, new_capacity))) return 0;
+            pState->m_pMem = pNew_block;
+            pState->m_mem_capacity = new_capacity;
+        }
+        memcpy((mz_uint8*)pState->m_pMem + file_ofs, pBuf, n);
+        pState->m_mem_size = (size_t)new_size;
+        return n;
+    }
+
+    mz_bool mz_zip_writer_init_heap(mz_zip_archive* pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size) {
+        pZip->m_pWrite = mz_zip_heap_write_func;
+        pZip->m_pIO_opaque = pZip;
+        if (!mz_zip_writer_init(pZip, size_to_reserve_at_beginning)) return MZ_FALSE;
+        if (0 != (initial_allocation_size = MZ_MAX(initial_allocation_size, size_to_reserve_at_beginning))) {
+            if (NULL == (pZip->m_pState->m_pMem = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, initial_allocation_size))) {
+                mz_zip_writer_end(pZip);
+                return MZ_FALSE;
+            }
+            pZip->m_pState->m_mem_capacity = initial_allocation_size;
+        }
+        return MZ_TRUE;
+    }
+
+#            ifndef MINIZ_NO_STDIO
+    static size_t mz_zip_file_write_func(void* pOpaque, mz_uint64 file_ofs, const void* pBuf, size_t n) {
+        mz_zip_archive* pZip = (mz_zip_archive*)pOpaque;
+        mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
+        if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
+            return 0;
+        return MZ_FWRITE(pBuf, 1, n, pZip->m_pState->m_pFile);
+    }
+
+    mz_bool mz_zip_writer_init_file(mz_zip_archive* pZip, const char* pFilename, mz_uint64 size_to_reserve_at_beginning) {
+        MZ_FILE* pFile;
+        pZip->m_pWrite = mz_zip_file_write_func;
+        pZip->m_pIO_opaque = pZip;
+        if (!mz_zip_writer_init(pZip, size_to_reserve_at_beginning)) return MZ_FALSE;
+        if (NULL == (pFile = MZ_FOPEN(pFilename, "wb"))) {
+            mz_zip_writer_end(pZip);
+            return MZ_FALSE;
+        }
+        pZip->m_pState->m_pFile = pFile;
+        if (size_to_reserve_at_beginning) {
+            mz_uint64 cur_ofs = 0;
+            char buf[4096];
+            MZ_CLEAR_OBJ(buf);
+            do {
+                size_t n = (size_t)MZ_MIN(sizeof(buf), size_to_reserve_at_beginning);
+                if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_ofs, buf, n) != n) {
+                    mz_zip_writer_end(pZip);
+                    return MZ_FALSE;
+                }
+                cur_ofs += n;
+                size_to_reserve_at_beginning -= n;
+            } while (size_to_reserve_at_beginning);
+        }
+        return MZ_TRUE;
+    }
+#            endif  // #ifndef MINIZ_NO_STDIO
+
+    mz_bool mz_zip_writer_init_from_reader(mz_zip_archive* pZip, const char* pFilename) {
+        mz_zip_internal_state* pState;
+        if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING)) return MZ_FALSE;
+        // No sense in trying to write to an archive that's already at the support max size
+        if ((pZip->m_total_files == 0xFFFF) || ((pZip->m_archive_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_ZIP_LOCAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))
+            return MZ_FALSE;
+
+        pState = pZip->m_pState;
+
+        if (pState->m_pFile) {
+#            ifdef MINIZ_NO_STDIO
+            pFilename;
+            return MZ_FALSE;
+#            else
+            // Archive is being read from stdio - try to reopen as writable.
+            if (pZip->m_pIO_opaque != pZip) return MZ_FALSE;
+            if (!pFilename) return MZ_FALSE;
+            pZip->m_pWrite = mz_zip_file_write_func;
+            if (NULL == (pState->m_pFile = MZ_FREOPEN(pFilename, "r+b", pState->m_pFile))) {
+                // The mz_zip_archive is now in a bogus state because pState->m_pFile is NULL, so just close it.
+                mz_zip_reader_end(pZip);
+                return MZ_FALSE;
+            }
+#            endif  // #ifdef MINIZ_NO_STDIO
+        } else if (pState->m_pMem) {
+            // Archive lives in a memory block. Assume it's from the heap that we can resize using the realloc callback.
+            if (pZip->m_pIO_opaque != pZip) return MZ_FALSE;
+            pState->m_mem_capacity = pState->m_mem_size;
+            pZip->m_pWrite = mz_zip_heap_write_func;
+        }
+        // Archive is being read via a user provided read function - make sure the user has specified a write function too.
+        else if (!pZip->m_pWrite)
+            return MZ_FALSE;
+
+        // Start writing new files at the archive's current central directory location.
+        pZip->m_archive_size = pZip->m_central_directory_file_ofs;
+        pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;
+        pZip->m_central_directory_file_ofs = 0;
+
+        return MZ_TRUE;
+    }
+
+    mz_bool mz_zip_writer_add_mem(mz_zip_archive* pZip, const char* pArchive_name, const void* pBuf, size_t buf_size, mz_uint level_and_flags) {
+        return mz_zip_writer_add_mem_ex(pZip, pArchive_name, pBuf, buf_size, NULL, 0, level_and_flags, 0, 0);
+    }
+
+    typedef struct
+    {
+        mz_zip_archive* m_pZip;
+        mz_uint64 m_cur_archive_file_ofs;
+        mz_uint64 m_comp_size;
+    } mz_zip_writer_add_state;
+
+    static mz_bool mz_zip_writer_add_put_buf_callback(const void* pBuf, int len, void* pUser) {
+        mz_zip_writer_add_state* pState = (mz_zip_writer_add_state*)pUser;
+        if ((int)pState->m_pZip->m_pWrite(pState->m_pZip->m_pIO_opaque, pState->m_cur_archive_file_ofs, pBuf, len) != len) return MZ_FALSE;
+        pState->m_cur_archive_file_ofs += len;
+        pState->m_comp_size += len;
+        return MZ_TRUE;
+    }
+
+    static mz_bool mz_zip_writer_create_local_dir_header(mz_zip_archive* pZip, mz_uint8* pDst, mz_uint16 filename_size, mz_uint16 extra_size,
+                                                         mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method,
+                                                         mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date) {
+        (void)pZip;
+        memset(pDst, 0, MZ_ZIP_LOCAL_DIR_HEADER_SIZE);
+        MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_SIG_OFS, MZ_ZIP_LOCAL_DIR_HEADER_SIG);
+        MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_VERSION_NEEDED_OFS, method ? 20 : 0);
+        MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_BIT_FLAG_OFS, bit_flags);
+        MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_METHOD_OFS, method);
+        MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_TIME_OFS, dos_time);
+        MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_DATE_OFS, dos_date);
+        MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_CRC32_OFS, uncomp_crc32);
+        MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS, comp_size);
+        MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS, uncomp_size);
+        MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILENAME_LEN_OFS, filename_size);
+        MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_EXTRA_LEN_OFS, extra_size);
+        return MZ_TRUE;
+    }
+
+    static mz_bool mz_zip_writer_create_central_dir_header(mz_zip_archive* pZip, mz_uint8* pDst, mz_uint16 filename_size, mz_uint16 extra_size,
+                                                           mz_uint16 comment_size, mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32,
+                                                           mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date,
+                                                           mz_uint64 local_header_ofs, mz_uint32 ext_attributes) {
+        (void)pZip;
+        memset(pDst, 0, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
+        MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_SIG_OFS, MZ_ZIP_CENTRAL_DIR_HEADER_SIG);
+        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_VERSION_NEEDED_OFS, method ? 20 : 0);
+        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_BIT_FLAG_OFS, bit_flags);
+        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_METHOD_OFS, method);
+        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_TIME_OFS, dos_time);
+        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_DATE_OFS, dos_date);
+        MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_CRC32_OFS, uncomp_crc32);
+        MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, comp_size);
+        MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, uncomp_size);
+        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILENAME_LEN_OFS, filename_size);
+        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_EXTRA_LEN_OFS, extra_size);
+        MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_COMMENT_LEN_OFS, comment_size);
+        MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS, ext_attributes);
+        MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_header_ofs);
+        return MZ_TRUE;
+    }
+
+    static mz_bool mz_zip_writer_add_to_central_dir(mz_zip_archive* pZip, const char* pFilename, mz_uint16 filename_size, const void* pExtra,
+                                                    mz_uint16 extra_size, const void* pComment, mz_uint16 comment_size, mz_uint64 uncomp_size,
+                                                    mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags,
+                                                    mz_uint16 dos_time, mz_uint16 dos_date, mz_uint64 local_header_ofs, mz_uint32 ext_attributes) {
+        mz_zip_internal_state* pState = pZip->m_pState;
+        mz_uint32 central_dir_ofs = (mz_uint32)pState->m_central_dir.m_size;
+        size_t orig_central_dir_size = pState->m_central_dir.m_size;
+        mz_uint8 central_dir_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];
+
+        // No zip64 support yet
+        if ((local_header_ofs > 0xFFFFFFFF)
+            || (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size + extra_size + comment_size) > 0xFFFFFFFF))
+            return MZ_FALSE;
+
+        if (!mz_zip_writer_create_central_dir_header(pZip, central_dir_header, filename_size, extra_size, comment_size, uncomp_size, comp_size,
+                                                     uncomp_crc32, method, bit_flags, dos_time, dos_date, local_header_ofs, ext_attributes))
+            return MZ_FALSE;
+
+        if ((!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_dir_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE))
+            || (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pFilename, filename_size))
+            || (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pExtra, extra_size))
+            || (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pComment, comment_size))
+            || (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &central_dir_ofs, 1))) {
+            // Try to push the central directory array back into its original state.
+            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
+            return MZ_FALSE;
+        }
+
+        return MZ_TRUE;
+    }
+
+    static mz_bool mz_zip_writer_validate_archive_name(const char* pArchive_name) {
+        // Basic ZIP archive filename validity checks: Valid filenames cannot start with a forward slash, cannot contain a drive letter, and cannot use DOS-style backward slashes.
+        if (*pArchive_name == '/') return MZ_FALSE;
+        while (*pArchive_name) {
+            if ((*pArchive_name == '\\') || (*pArchive_name == ':')) return MZ_FALSE;
+            pArchive_name++;
+        }
+        return MZ_TRUE;
+    }
+
+    static mz_uint mz_zip_writer_compute_padding_needed_for_file_alignment(mz_zip_archive* pZip) {
+        mz_uint32 n;
+        if (!pZip->m_file_offset_alignment) return 0;
+        n = (mz_uint32)(pZip->m_archive_size & (pZip->m_file_offset_alignment - 1));
+        return (pZip->m_file_offset_alignment - n) & (pZip->m_file_offset_alignment - 1);
+    }
+
+    static mz_bool mz_zip_writer_write_zeros(mz_zip_archive* pZip, mz_uint64 cur_file_ofs, mz_uint32 n) {
+        char buf[4096];
+        memset(buf, 0, MZ_MIN(sizeof(buf), n));
+        while (n) {
+            mz_uint32 s = MZ_MIN(sizeof(buf), n);
+            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_file_ofs, buf, s) != s) return MZ_FALSE;
+            cur_file_ofs += s;
+            n -= s;
+        }
+        return MZ_TRUE;
+    }
+
+    mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive* pZip, const char* pArchive_name, const void* pBuf, size_t buf_size, const void* pComment,
+                                     mz_uint16 comment_size, mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32) {
+        mz_uint16 method = 0, dos_time = 0, dos_date = 0;
+        mz_uint level, ext_attributes = 0, num_alignment_padding_bytes;
+        mz_uint64 local_dir_header_ofs = pZip->m_archive_size, cur_archive_file_ofs = pZip->m_archive_size, comp_size = 0;
+        size_t archive_name_size;
+        mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
+        tdefl_compressor* pComp = NULL;
+        mz_bool store_data_uncompressed;
+        mz_zip_internal_state* pState;
+
+        if ((int)level_and_flags < 0) level_and_flags = MZ_DEFAULT_LEVEL;
+        level = level_and_flags & 0xF;
+        store_data_uncompressed = ((!level) || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA));
+
+        if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || ((buf_size) && (!pBuf)) || (!pArchive_name)
+            || ((comment_size) && (!pComment)) || (pZip->m_total_files == 0xFFFF) || (level > MZ_UBER_COMPRESSION))
+            return MZ_FALSE;
+
+        pState = pZip->m_pState;
+
+        if ((!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (uncomp_size)) return MZ_FALSE;
+        // No zip64 support yet
+        if ((buf_size > 0xFFFFFFFF) || (uncomp_size > 0xFFFFFFFF)) return MZ_FALSE;
+        if (!mz_zip_writer_validate_archive_name(pArchive_name)) return MZ_FALSE;
+
+#            ifndef MINIZ_NO_TIME
+        {
+            time_t cur_time;
+            time(&cur_time);
+            mz_zip_time_to_dos_time(cur_time, &dos_time, &dos_date);
+        }
+#            endif  // #ifndef MINIZ_NO_TIME
+
+        archive_name_size = strlen(pArchive_name);
+        if (archive_name_size > 0xFFFF) return MZ_FALSE;
+
+        num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);
+
+        // no zip64 support yet
+        if ((pZip->m_total_files == 0xFFFF)
+            || ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + comment_size
+                 + archive_name_size)
+                > 0xFFFFFFFF))
+            return MZ_FALSE;
+
+        if ((archive_name_size) && (pArchive_name[archive_name_size - 1] == '/')) {
+            // Set DOS Subdirectory attribute bit.
+            ext_attributes |= 0x10;
+            // Subdirectories cannot contain data.
+            if ((buf_size) || (uncomp_size)) return MZ_FALSE;
+        }
+
+        // Try to do any allocations before writing to the archive, so if an allocation fails the file remains unmodified. (A good idea if we're doing an in-place modification.)
+        if ((!mz_zip_array_ensure_room(pZip, &pState->m_central_dir, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + comment_size))
+            || (!mz_zip_array_ensure_room(pZip, &pState->m_central_dir_offsets, 1)))
+            return MZ_FALSE;
+
+        if ((!store_data_uncompressed) && (buf_size)) {
+            if (NULL == (pComp = (tdefl_compressor*)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor)))) return MZ_FALSE;
+        }
+
+        if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes + sizeof(local_dir_header))) {
+            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
+            return MZ_FALSE;
+        }
+        local_dir_header_ofs += num_alignment_padding_bytes;
+        if (pZip->m_file_offset_alignment) {
+            MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0);
+        }
+        cur_archive_file_ofs += num_alignment_padding_bytes + sizeof(local_dir_header);
+
+        MZ_CLEAR_OBJ(local_dir_header);
+        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size) {
+            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
+            return MZ_FALSE;
+        }
+        cur_archive_file_ofs += archive_name_size;
+
+        if (!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) {
+            uncomp_crc32 = (mz_uint32)mz_crc32(MZ_CRC32_INIT, (const mz_uint8*)pBuf, buf_size);
+            uncomp_size = buf_size;
+            if (uncomp_size <= 3) {
+                level = 0;
+                store_data_uncompressed = MZ_TRUE;
+            }
+        }
+
+        if (store_data_uncompressed) {
+            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pBuf, buf_size) != buf_size) {
+                pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
+                return MZ_FALSE;
+            }
+
+            cur_archive_file_ofs += buf_size;
+            comp_size = buf_size;
+
+            if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA) method = MZ_DEFLATED;
+        } else if (buf_size) {
+            mz_zip_writer_add_state state;
+
+            state.m_pZip = pZip;
+            state.m_cur_archive_file_ofs = cur_archive_file_ofs;
+            state.m_comp_size = 0;
+
+            if ((tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state,
+                            tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY))
+                 != TDEFL_STATUS_OKAY)
+                || (tdefl_compress_buffer(pComp, pBuf, buf_size, TDEFL_FINISH) != TDEFL_STATUS_DONE)) {
+                pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
+                return MZ_FALSE;
+            }
+
+            comp_size = state.m_comp_size;
+            cur_archive_file_ofs = state.m_cur_archive_file_ofs;
+
+            method = MZ_DEFLATED;
+        }
+
+        pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
+        pComp = NULL;
+
+        // no zip64 support yet
+        if ((comp_size > 0xFFFFFFFF) || (cur_archive_file_ofs > 0xFFFFFFFF)) return MZ_FALSE;
+
+        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, 0, uncomp_size, comp_size, uncomp_crc32,
+                                                   method, 0, dos_time, dos_date))
+            return MZ_FALSE;
+
+        if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
+            return MZ_FALSE;
+
+        if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, NULL, 0, pComment, comment_size, uncomp_size,
+                                              comp_size, uncomp_crc32, method, 0, dos_time, dos_date, local_dir_header_ofs, ext_attributes))
+            return MZ_FALSE;
+
+        pZip->m_total_files++;
+        pZip->m_archive_size = cur_archive_file_ofs;
+
+        return MZ_TRUE;
+    }
+
+#            ifndef MINIZ_NO_STDIO
+    mz_bool mz_zip_writer_add_file(mz_zip_archive* pZip, const char* pArchive_name, const char* pSrc_filename, const void* pComment,
+                                   mz_uint16 comment_size, mz_uint level_and_flags) {
+        mz_uint uncomp_crc32 = MZ_CRC32_INIT, level, num_alignment_padding_bytes;
+        mz_uint16 method = 0, dos_time = 0, dos_date = 0, ext_attributes = 0;
+        mz_uint64 local_dir_header_ofs = pZip->m_archive_size, cur_archive_file_ofs = pZip->m_archive_size, uncomp_size = 0, comp_size = 0;
+        size_t archive_name_size;
+        mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
+        MZ_FILE* pSrc_file = NULL;
+
+        if ((int)level_and_flags < 0) level_and_flags = MZ_DEFAULT_LEVEL;
+        level = level_and_flags & 0xF;
+
+        if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pArchive_name) || ((comment_size) && (!pComment))
+            || (level > MZ_UBER_COMPRESSION))
+            return MZ_FALSE;
+        if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA) return MZ_FALSE;
+        if (!mz_zip_writer_validate_archive_name(pArchive_name)) return MZ_FALSE;
+
+        archive_name_size = strlen(pArchive_name);
+        if (archive_name_size > 0xFFFF) return MZ_FALSE;
+
+        num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);
+
+        // no zip64 support yet
+        if ((pZip->m_total_files == 0xFFFF)
+            || ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + comment_size
+                 + archive_name_size)
+                > 0xFFFFFFFF))
+            return MZ_FALSE;
+
+        if (!mz_zip_get_file_modified_time(pSrc_filename, &dos_time, &dos_date)) return MZ_FALSE;
+
+        pSrc_file = MZ_FOPEN(pSrc_filename, "rb");
+        if (!pSrc_file) return MZ_FALSE;
+        MZ_FSEEK64(pSrc_file, 0, SEEK_END);
+        uncomp_size = MZ_FTELL64(pSrc_file);
+        MZ_FSEEK64(pSrc_file, 0, SEEK_SET);
+
+        if (uncomp_size > 0xFFFFFFFF) {
+            // No zip64 support yet
+            MZ_FCLOSE(pSrc_file);
+            return MZ_FALSE;
+        }
+        if (uncomp_size <= 3) level = 0;
+
+        if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes + sizeof(local_dir_header))) {
+            MZ_FCLOSE(pSrc_file);
+            return MZ_FALSE;
+        }
+        local_dir_header_ofs += num_alignment_padding_bytes;
+        if (pZip->m_file_offset_alignment) {
+            MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0);
+        }
+        cur_archive_file_ofs += num_alignment_padding_bytes + sizeof(local_dir_header);
+
+        MZ_CLEAR_OBJ(local_dir_header);
+        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size) {
+            MZ_FCLOSE(pSrc_file);
+            return MZ_FALSE;
+        }
+        cur_archive_file_ofs += archive_name_size;
+
+        if (uncomp_size) {
+            mz_uint64 uncomp_remaining = uncomp_size;
+            void* pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, MZ_ZIP_MAX_IO_BUF_SIZE);
+            if (!pRead_buf) {
+                MZ_FCLOSE(pSrc_file);
+                return MZ_FALSE;
+            }
+
+            if (!level) {
+                while (uncomp_remaining) {
+                    mz_uint n = (mz_uint)MZ_MIN(MZ_ZIP_MAX_IO_BUF_SIZE, uncomp_remaining);
+                    if ((MZ_FREAD(pRead_buf, 1, n, pSrc_file) != n)
+                        || (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pRead_buf, n) != n)) {
+                        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
+                        MZ_FCLOSE(pSrc_file);
+                        return MZ_FALSE;
+                    }
+                    uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8*)pRead_buf, n);
+                    uncomp_remaining -= n;
+                    cur_archive_file_ofs += n;
+                }
+                comp_size = uncomp_size;
+            } else {
+                mz_bool result = MZ_FALSE;
+                mz_zip_writer_add_state state;
+                tdefl_compressor* pComp = (tdefl_compressor*)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor));
+                if (!pComp) {
+                    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
+                    MZ_FCLOSE(pSrc_file);
+                    return MZ_FALSE;
+                }
+
+                state.m_pZip = pZip;
+                state.m_cur_archive_file_ofs = cur_archive_file_ofs;
+                state.m_comp_size = 0;
+
+                if (tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state,
+                               tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY))
+                    != TDEFL_STATUS_OKAY) {
+                    pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
+                    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
+                    MZ_FCLOSE(pSrc_file);
+                    return MZ_FALSE;
+                }
+
+                for (;;) {
+                    size_t in_buf_size = (mz_uint32)MZ_MIN(uncomp_remaining, MZ_ZIP_MAX_IO_BUF_SIZE);
+                    tdefl_status status;
+
+                    if (MZ_FREAD(pRead_buf, 1, in_buf_size, pSrc_file) != in_buf_size) break;
+
+                    uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8*)pRead_buf, in_buf_size);
+                    uncomp_remaining -= in_buf_size;
+
+                    status = tdefl_compress_buffer(pComp, pRead_buf, in_buf_size, uncomp_remaining ? TDEFL_NO_FLUSH : TDEFL_FINISH);
+                    if (status == TDEFL_STATUS_DONE) {
+                        result = MZ_TRUE;
+                        break;
+                    } else if (status != TDEFL_STATUS_OKAY)
+                        break;
+                }
+
+                pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
+
+                if (!result) {
+                    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
+                    MZ_FCLOSE(pSrc_file);
+                    return MZ_FALSE;
+                }
+
+                comp_size = state.m_comp_size;
+                cur_archive_file_ofs = state.m_cur_archive_file_ofs;
+
+                method = MZ_DEFLATED;
+            }
+
+            pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
+        }
+
+        MZ_FCLOSE(pSrc_file);
+        pSrc_file = NULL;
+
+        // no zip64 support yet
+        if ((comp_size > 0xFFFFFFFF) || (cur_archive_file_ofs > 0xFFFFFFFF)) return MZ_FALSE;
+
+        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, 0, uncomp_size, comp_size, uncomp_crc32,
+                                                   method, 0, dos_time, dos_date))
+            return MZ_FALSE;
+
+        if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
+            return MZ_FALSE;
+
+        if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, NULL, 0, pComment, comment_size, uncomp_size,
+                                              comp_size, uncomp_crc32, method, 0, dos_time, dos_date, local_dir_header_ofs, ext_attributes))
+            return MZ_FALSE;
+
+        pZip->m_total_files++;
+        pZip->m_archive_size = cur_archive_file_ofs;
+
+        return MZ_TRUE;
+    }
+#            endif  // #ifndef MINIZ_NO_STDIO
+
+    mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive* pZip, mz_zip_archive* pSource_zip, mz_uint file_index) {
+        mz_uint n, bit_flags, num_alignment_padding_bytes;
+        mz_uint64 comp_bytes_remaining, local_dir_header_ofs;
+        mz_uint64 cur_src_file_ofs, cur_dst_file_ofs;
+        mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
+        mz_uint8* pLocal_header = (mz_uint8*)local_header_u32;
+        mz_uint8 central_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];
+        size_t orig_central_dir_size;
+        mz_zip_internal_state* pState;
+        void* pBuf;
+        const mz_uint8* pSrc_central_header;
+
+        if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING)) return MZ_FALSE;
+        if (NULL == (pSrc_central_header = mz_zip_reader_get_cdh(pSource_zip, file_index))) return MZ_FALSE;
+        pState = pZip->m_pState;
+
+        num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);
+
+        // no zip64 support yet
+        if ((pZip->m_total_files == 0xFFFF)
+            || ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))
+            return MZ_FALSE;
+
+        cur_src_file_ofs = MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS);
+        cur_dst_file_ofs = pZip->m_archive_size;
+
+        if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
+            != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
+            return MZ_FALSE;
+        if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG) return MZ_FALSE;
+        cur_src_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;
+
+        if (!mz_zip_writer_write_zeros(pZip, cur_dst_file_ofs, num_alignment_padding_bytes)) return MZ_FALSE;
+        cur_dst_file_ofs += num_alignment_padding_bytes;
+        local_dir_header_ofs = cur_dst_file_ofs;
+        if (pZip->m_file_offset_alignment) {
+            MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0);
+        }
+
+        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
+            return MZ_FALSE;
+        cur_dst_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;
+
+        n = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
+        comp_bytes_remaining = n + MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
+
+        if (NULL
+            == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1,
+                                      (size_t)MZ_MAX(sizeof(mz_uint32) * 4, MZ_MIN(MZ_ZIP_MAX_IO_BUF_SIZE, comp_bytes_remaining)))))
+            return MZ_FALSE;
+
+        while (comp_bytes_remaining) {
+            n = (mz_uint)MZ_MIN(MZ_ZIP_MAX_IO_BUF_SIZE, comp_bytes_remaining);
+            if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, n) != n) {
+                pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
+                return MZ_FALSE;
+            }
+            cur_src_file_ofs += n;
+
+            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n) {
+                pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
+                return MZ_FALSE;
+            }
+            cur_dst_file_ofs += n;
+
+            comp_bytes_remaining -= n;
+        }
+
+        bit_flags = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_BIT_FLAG_OFS);
+        if (bit_flags & 8) {
+            // Copy data descriptor
+            if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, sizeof(mz_uint32) * 4) != sizeof(mz_uint32) * 4) {
+                pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
+                return MZ_FALSE;
+            }
+
+            n = sizeof(mz_uint32) * ((MZ_READ_LE32(pBuf) == 0x08074b50) ? 4 : 3);
+            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n) {
+                pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
+                return MZ_FALSE;
+            }
+
+            cur_src_file_ofs += n;
+            cur_dst_file_ofs += n;
+        }
+        pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
+
+        // no zip64 support yet
+        if (cur_dst_file_ofs > 0xFFFFFFFF) return MZ_FALSE;
+
+        orig_central_dir_size = pState->m_central_dir.m_size;
+
+        memcpy(central_header, pSrc_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
+        MZ_WRITE_LE32(central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_dir_header_ofs);
+        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)) return MZ_FALSE;
+
+        n = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS)
+            + MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_COMMENT_LEN_OFS);
+        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n)) {
+            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
+            return MZ_FALSE;
+        }
+
+        if (pState->m_central_dir.m_size > 0xFFFFFFFF) return MZ_FALSE;
+        n = (mz_uint32)orig_central_dir_size;
+        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &n, 1)) {
+            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
+            return MZ_FALSE;
+        }
+
+        pZip->m_total_files++;
+        pZip->m_archive_size = cur_dst_file_ofs;
+
+        return MZ_TRUE;
+    }
+
+    mz_bool mz_zip_writer_finalize_archive(mz_zip_archive* pZip) {
+        mz_zip_internal_state* pState;
+        mz_uint64 central_dir_ofs, central_dir_size;
+        mz_uint8 hdr[MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE];
+
+        if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING)) return MZ_FALSE;
+
+        pState = pZip->m_pState;
+
+        // no zip64 support yet
+        if ((pZip->m_total_files > 0xFFFF)
+            || ((pZip->m_archive_size + pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))
+            return MZ_FALSE;
+
+        central_dir_ofs = 0;
+        central_dir_size = 0;
+        if (pZip->m_total_files) {
+            // Write central directory
+            central_dir_ofs = pZip->m_archive_size;
+            central_dir_size = pState->m_central_dir.m_size;
+            pZip->m_central_directory_file_ofs = central_dir_ofs;
+            if (pZip->m_pWrite(pZip->m_pIO_opaque, central_dir_ofs, pState->m_central_dir.m_p, (size_t)central_dir_size) != central_dir_size)
+                return MZ_FALSE;
+            pZip->m_archive_size += central_dir_size;
+        }
+
+        // Write end of central directory record
+        MZ_CLEAR_OBJ(hdr);
+        MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_SIG_OFS, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG);
+        MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS, pZip->m_total_files);
+        MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS, pZip->m_total_files);
+        MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_SIZE_OFS, central_dir_size);
+        MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_OFS_OFS, central_dir_ofs);
+
+        if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, sizeof(hdr)) != sizeof(hdr)) return MZ_FALSE;
+#            ifndef MINIZ_NO_STDIO
+        if ((pState->m_pFile) && (MZ_FFLUSH(pState->m_pFile) == EOF)) return MZ_FALSE;
+#            endif  // #ifndef MINIZ_NO_STDIO
+
+        pZip->m_archive_size += sizeof(hdr);
+
+        pZip->m_zip_mode = MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED;
+        return MZ_TRUE;
+    }
+
+    mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive* pZip, void** pBuf, size_t* pSize) {
+        if ((!pZip) || (!pZip->m_pState) || (!pBuf) || (!pSize)) return MZ_FALSE;
+        if (pZip->m_pWrite != mz_zip_heap_write_func) return MZ_FALSE;
+        if (!mz_zip_writer_finalize_archive(pZip)) return MZ_FALSE;
+
+        *pBuf = pZip->m_pState->m_pMem;
+        *pSize = pZip->m_pState->m_mem_size;
+        pZip->m_pState->m_pMem = NULL;
+        pZip->m_pState->m_mem_size = pZip->m_pState->m_mem_capacity = 0;
+        return MZ_TRUE;
+    }
+
+    mz_bool mz_zip_writer_end(mz_zip_archive* pZip) {
+        mz_zip_internal_state* pState;
+        mz_bool status = MZ_TRUE;
+        if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree)
+            || ((pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) && (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED)))
+            return MZ_FALSE;
+
+        pState = pZip->m_pState;
+        pZip->m_pState = NULL;
+        mz_zip_array_clear(pZip, &pState->m_central_dir);
+        mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
+        mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);
+
+#            ifndef MINIZ_NO_STDIO
+        if (pState->m_pFile) {
+            MZ_FCLOSE(pState->m_pFile);
+            pState->m_pFile = NULL;
+        }
+#            endif  // #ifndef MINIZ_NO_STDIO
+
+        if ((pZip->m_pWrite == mz_zip_heap_write_func) && (pState->m_pMem)) {
+            pZip->m_pFree(pZip->m_pAlloc_opaque, pState->m_pMem);
+            pState->m_pMem = NULL;
+        }
+
+        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
+        pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;
+        return status;
+    }
+
+#            ifndef MINIZ_NO_STDIO
+    mz_bool mz_zip_add_mem_to_archive_file_in_place(const char* pZip_filename, const char* pArchive_name, const void* pBuf, size_t buf_size,
+                                                    const void* pComment, mz_uint16 comment_size, mz_uint level_and_flags) {
+        mz_bool status, created_new_archive = MZ_FALSE;
+        mz_zip_archive zip_archive;
+        struct MZ_FILE_STAT_STRUCT file_stat;
+        MZ_CLEAR_OBJ(zip_archive);
+        if ((int)level_and_flags < 0) level_and_flags = MZ_DEFAULT_LEVEL;
+        if ((!pZip_filename) || (!pArchive_name) || ((buf_size) && (!pBuf)) || ((comment_size) && (!pComment))
+            || ((level_and_flags & 0xF) > MZ_UBER_COMPRESSION))
+            return MZ_FALSE;
+        if (!mz_zip_writer_validate_archive_name(pArchive_name)) return MZ_FALSE;
+        if (MZ_FILE_STAT(pZip_filename, &file_stat) != 0) {
+            // Create a new archive.
+            if (!mz_zip_writer_init_file(&zip_archive, pZip_filename, 0)) return MZ_FALSE;
+            created_new_archive = MZ_TRUE;
+        } else {
+            // Append to an existing archive.
+            if (!mz_zip_reader_init_file(&zip_archive, pZip_filename, level_and_flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY)) return MZ_FALSE;
+            if (!mz_zip_writer_init_from_reader(&zip_archive, pZip_filename)) {
+                mz_zip_reader_end(&zip_archive);
+                return MZ_FALSE;
+            }
+        }
+        status = mz_zip_writer_add_mem_ex(&zip_archive, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, 0, 0);
+        // Always finalize, even if adding failed for some reason, so we have a valid central directory. (This may not always succeed, but we can try.)
+        if (!mz_zip_writer_finalize_archive(&zip_archive)) status = MZ_FALSE;
+        if (!mz_zip_writer_end(&zip_archive)) status = MZ_FALSE;
+        if ((!status) && (created_new_archive)) {
+            // It's a new archive and something went wrong, so just delete it.
+            int ignoredStatus = MZ_DELETE_FILE(pZip_filename);
+            (void)ignoredStatus;
+        }
+        return status;
+    }
+
+    void* mz_zip_extract_archive_file_to_heap(const char* pZip_filename, const char* pArchive_name, size_t* pSize, mz_uint flags) {
+        int file_index;
+        mz_zip_archive zip_archive;
+        void* p = NULL;
+
+        if (pSize) *pSize = 0;
+
+        if ((!pZip_filename) || (!pArchive_name)) return NULL;
+
+        MZ_CLEAR_OBJ(zip_archive);
+        if (!mz_zip_reader_init_file(&zip_archive, pZip_filename, flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY)) return NULL;
+
+        if ((file_index = mz_zip_reader_locate_file(&zip_archive, pArchive_name, NULL, flags)) >= 0)
+            p = mz_zip_reader_extract_to_heap(&zip_archive, file_index, pSize, flags);
+
+        mz_zip_reader_end(&zip_archive);
+        return p;
+    }
+
+#            endif  // #ifndef MINIZ_NO_STDIO
+
+#        endif  // #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
+
+#    endif  // #ifndef MINIZ_NO_ARCHIVE_APIS
+
+#    ifdef __cplusplus
+}
+#    endif
+
+#endif  // MINIZ_HEADER_FILE_ONLY
+
+/*
+  This is free and unencumbered software released into the public domain.
+
+  Anyone is free to copy, modify, publish, use, compile, sell, or
+  distribute this software, either in source code form or as a compiled
+  binary, for any purpose, commercial or non-commercial, and by any
+  means.
+
+  In jurisdictions that recognize copyright laws, the author or authors
+  of this software dedicate any and all copyright interest in the
+  software to the public domain. We make this dedication for the benefit
+  of the public at large and to the detriment of our heirs and
+  successors. We intend this dedication to be an overt act of
+  relinquishment in perpetuity of all present and future rights to this
+  software under copyright law.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+  OTHER DEALINGS IN THE SOFTWARE.
+
+  For more information, please refer to <http://unlicense.org/>
+*/
```

## CoolProp/include/rapidjson_include.h

 * *Ordering differences only*

```diff
@@ -1,340 +1,340 @@
-#ifndef RAPIDJSON_COOLPROP_H
-#define RAPIDJSON_COOLPROP_H
-
-// On PowerPC, we are going to use the stdint.h integer types and not let rapidjson use its own
-#if defined(__powerpc__)
-typedef unsigned int UINT32;
-#    include "stdint.h"
-#    define RAPIDJSON_NO_INT64DEFINE
-#endif
-
-#include "Exceptions.h"
-#include "CoolPropTools.h"
-
-#include "externals/rapidjson/include/rapidjson/rapidjson.h"
-#include "externals/rapidjson/include/rapidjson/document.h"
-#include "externals/rapidjson/include/rapidjson/filewritestream.h"  // wrapper of C stream for prettywriter as output
-#include "externals/rapidjson/include/rapidjson/prettywriter.h"     // for stringify JSON
-#include "externals/rapidjson/include/rapidjson/stringbuffer.h"     // for string buffer
-#include "externals/rapidjson/include/rapidjson/schema.h"
-
-#include <cassert>
-
-namespace cpjson {
-
-/// Convert a JSON-formatted string to a rapidjson::Document object
-inline void JSON_string_to_rapidjson(const std::string& JSON_string, rapidjson::Document& doc) {
-    doc.Parse<0>(JSON_string.c_str());
-    if (doc.HasParseError()) {
-        throw CoolProp::ValueError("Unable to load JSON string");
-    }
-}
-
-struct value_information
-{
-    bool isnull, isfalse, istrue, isbool, isobject, isarray, isnumber, isint, isint64, isuint, isuint64, isdouble, isstring;
-};
-inline value_information get_information(rapidjson::Value& v) {
-    value_information i;
-    i.isnull = v.IsNull();
-    i.isfalse = v.IsFalse();
-    i.istrue = v.IsTrue();
-    i.isbool = v.IsBool();
-    i.isobject = v.IsObject();
-    i.isarray = v.IsArray();
-    i.isnumber = v.IsNumber();
-    i.isint = v.IsInt();
-    i.isuint = v.IsUint();
-    i.isint64 = v.IsInt64();
-    i.isuint64 = v.IsUint64();
-    i.isdouble = v.IsDouble();
-    i.isstring = v.IsString();
-    return i;
-};
-
-inline std::string json2string(const rapidjson::Value& v) {
-    rapidjson::StringBuffer buffer;
-    rapidjson::PrettyWriter<rapidjson::StringBuffer> writer(buffer);
-
-    v.Accept(writer);
-    return buffer.GetString();
-}
-/// A convenience function to get a double from a JSON value, including error checking
-inline int get_integer(const rapidjson::Value& v, std::string m) {
-    if (!v.HasMember(m.c_str())) {
-        throw CoolProp::ValueError(format("Does not have member [%s]", m.c_str()));
-    }
-    const rapidjson::Value& el = v[m.c_str()];
-    if (!el.IsInt()) {
-        throw CoolProp::ValueError(format("Member [%s] is not an integer", m.c_str()));
-    } else {
-        return el.GetInt();
-    }
-};
-/// A convenience function to get a double from a JSON value, including error checking
-inline double get_double(const rapidjson::Value& v, std::string m) {
-    if (!v.HasMember(m.c_str())) {
-        throw CoolProp::ValueError(format("Does not have member [%s]", m.c_str()));
-    }
-    const rapidjson::Value& el = v[m.c_str()];
-    if (!el.IsNumber()) {
-        throw CoolProp::ValueError(format("Member [%s] is not a number", m.c_str()));
-    } else {
-        return el.GetDouble();
-    }
-};
-/// A convenience function to get a bool from a JSON value, including error checking
-inline bool get_bool(const rapidjson::Value& v, std::string m) {
-    if (!v.HasMember(m.c_str())) {
-        throw CoolProp::ValueError(format("Does not have member [%s]", m.c_str()));
-    }
-    const rapidjson::Value& el = v[m.c_str()];
-    if (!el.IsBool()) {
-        throw CoolProp::ValueError(format("Member [%s] is not a boolean", m.c_str()));
-    } else {
-        return el.GetBool();
-    }
-};
-/// A convenience function to get a string from a JSON value, including error checking
-inline std::string get_string(const rapidjson::Value& v, std::string m) {
-    if (!v.HasMember(m.c_str())) {
-        throw CoolProp::ValueError(format("Does not have member [%s]", m.c_str()));
-    }
-    const rapidjson::Value& el = v[m.c_str()];
-    if (!el.IsString()) {
-        throw CoolProp::ValueError(format("Member [%s] is not a string", m.c_str()));
-    } else {
-        return el.GetString();
-    }
-};
-
-/// A convenience function to get a double array compactly
-inline std::vector<double> get_double_array(const rapidjson::Value& v) {
-    std::vector<double> out;
-    if (!v.IsArray()) {
-        throw CoolProp::ValueError("input is not an array");
-    }
-    for (rapidjson::Value::ConstValueIterator itr = v.Begin(); itr != v.End(); ++itr) {
-        if (!itr->IsNumber()) {
-            throw CoolProp::ValueError("input is not a number");
-        }
-        out.push_back(itr->GetDouble());
-    }
-    return out;
-};
-
-/// A convenience function to get a double array compactly
-inline std::vector<double> get_double_array(const rapidjson::Value& v, std::string m) {
-    if (!v.HasMember(m.c_str())) {
-        throw CoolProp::ValueError(format("Does not have member [%s]", m.c_str()));
-    } else {
-        return get_double_array(v[m.c_str()]);
-    }
-};
-
-/// A convenience function to get a long double array compactly
-inline std::vector<CoolPropDbl> get_long_double_array(const rapidjson::Value& v) {
-    std::vector<CoolPropDbl> out;
-    if (!v.IsArray()) {
-        throw CoolProp::ValueError("input is not an array");
-    }
-    for (rapidjson::Value::ConstValueIterator itr = v.Begin(); itr != v.End(); ++itr) {
-        if (!itr->IsNumber()) {
-            throw CoolProp::ValueError("input is not a number");
-        }
-        out.push_back(itr->GetDouble());
-    }
-    return out;
-};
-
-/// A convenience function to get a 2D double array compactly
-inline std::vector<std::vector<double>> get_double_array2D(const rapidjson::Value& v) {
-    std::vector<std::vector<double>> out;
-    std::vector<double> tmp;
-    if (!v.IsArray()) {
-        throw CoolProp::ValueError("input is not an array");
-    }
-    for (rapidjson::Value::ConstValueIterator itr = v.Begin(); itr != v.End(); ++itr) {
-        // This is here for debugging purposes
-        // cpjson::value_information vi = cpjson::get_information((*itr));
-        if (!(itr->IsArray())) {
-            throw CoolProp::ValueError(format("input \"%s\" is not a 2D array", cpjson::json2string(v).c_str()));
-        }
-        tmp.clear();
-        for (rapidjson::Value::ConstValueIterator i = itr->Begin(); i != itr->End(); ++i) {
-            if (!i->IsNumber()) {
-                throw CoolProp::ValueError("input is not a number");
-            }
-            tmp.push_back(i->GetDouble());
-        }
-        out.push_back(tmp);
-    }
-    return out;
-};
-
-/// A convenience function to get a 2D long double array compactly
-inline std::vector<std::vector<CoolPropDbl>> get_long_double_array2D(const rapidjson::Value& v) {
-    std::vector<std::vector<CoolPropDbl>> out;
-    std::vector<CoolPropDbl> tmp;
-    if (!v.IsArray()) {
-        throw CoolProp::ValueError("input is not an array");
-    }
-    for (rapidjson::Value::ConstValueIterator itr = v.Begin(); itr != v.End(); ++itr) {
-        if (!itr->IsArray()) {
-            throw CoolProp::ValueError("input is not a 2D array");
-        }
-        tmp.clear();
-        for (rapidjson::Value::ConstValueIterator i = itr->Begin(); i != itr->End(); ++i) {
-            if (!i->IsNumber()) {
-                throw CoolProp::ValueError("input is not a number");
-            }
-            tmp.push_back(i->GetDouble());
-        }
-        out.push_back(tmp);
-    }
-    return out;
-};
-
-/// A convenience function to get a long double array compactly
-inline std::vector<CoolPropDbl> get_long_double_array(const rapidjson::Value& v, std::string name) {
-    std::vector<CoolPropDbl> out;
-    if (!v.HasMember(name.c_str())) {
-        throw CoolProp::ValueError(format("Does not have member [%s]", name.c_str()));
-    }
-    if (!v[name.c_str()].IsArray()) {
-        throw CoolProp::ValueError("input is not an array");
-    }
-    for (rapidjson::Value::ConstValueIterator itr = v[name.c_str()].Begin(); itr != v[name.c_str()].End(); ++itr) {
-        if (!itr->IsNumber()) {
-            throw CoolProp::ValueError("input is not a number");
-        }
-        out.push_back(itr->GetDouble());
-    }
-    return out;
-};
-
-/// A convenience function to get a string array compactly
-inline std::vector<std::string> get_string_array(const rapidjson::Value& v) {
-    std::vector<std::string> out;
-    if (!v.IsArray()) {
-        throw CoolProp::ValueError("input is not an array");
-    }
-    for (rapidjson::Value::ConstValueIterator itr = v.Begin(); itr != v.End(); ++itr) {
-        out.push_back(itr->GetString());
-    }
-    return out;
-};
-
-/// A convenience function to get a string array compactly
-inline std::vector<std::string> get_string_array(const rapidjson::Value& v, std::string m) {
-    if (!v.HasMember(m.c_str())) {
-        throw CoolProp::ValueError(format("Does not have member [%s]", m.c_str()));
-    } else {
-        return get_string_array(v[m.c_str()]);
-    }
-};
-
-/// A convenience function to get a std::string from a JSON value
-template <typename T>
-inline std::string to_string(const T& v) {
-    rapidjson::StringBuffer buffer;
-    rapidjson::PrettyWriter<rapidjson::StringBuffer> writer(buffer);
-    v.Accept(writer);
-    return buffer.GetString();
-};
-
-/// A convenience function to set a 2D array of double compactly
-inline void set_double_array2D(const char* key, const std::vector<std::vector<double>>& vec, rapidjson::Value& value, rapidjson::Document& doc) {
-    rapidjson::Value _i(rapidjson::kArrayType);
-    for (unsigned int i = 0; i < vec.size(); ++i) {
-        rapidjson::Value _j(rapidjson::kArrayType);
-        for (unsigned int j = 0; j < vec[i].size(); ++j) {
-            rapidjson::Value v(rapidjson::kNumberType);
-            v.SetDouble(vec[i][j]);
-            _j.PushBack(v, doc.GetAllocator());
-        }
-        _i.PushBack(_j, doc.GetAllocator());
-    }
-    value.AddMember(rapidjson::Value(key, doc.GetAllocator()).Move(), _i, doc.GetAllocator());
-};
-
-/// A convenience function to set a string compactly
-inline void set_string(const std::string& key, const std::string& s, rapidjson::Value& value, rapidjson::Document& doc) {
-    value.AddMember(rapidjson::Value(key.c_str(), doc.GetAllocator()).Move(), rapidjson::Value(s.c_str(), doc.GetAllocator()).Move(),
-                    doc.GetAllocator());
-};
-
-/// A convenience function to set a string array compactly
-inline void set_string_array(const char* key, const std::vector<std::string>& vec, rapidjson::Value& value, rapidjson::Document& doc) {
-    rapidjson::Value _v(rapidjson::kArrayType);
-    for (unsigned int i = 0; i < vec.size(); ++i) {
-        _v.PushBack(rapidjson::Value(vec[i].c_str(), doc.GetAllocator()).Move(), doc.GetAllocator());
-    }
-    value.AddMember(rapidjson::Value(key, doc.GetAllocator()).Move(), _v, doc.GetAllocator());
-};
-
-/// A convenience function to set an integer array compactly
-inline void set_int_array(const char* key, const std::vector<int>& vec, rapidjson::Value& value, rapidjson::Document& doc) {
-    rapidjson::Value _v(rapidjson::kArrayType);
-    for (unsigned int i = 0; i < vec.size(); ++i) {
-        _v.PushBack(vec[i], doc.GetAllocator());
-    }
-    value.AddMember(rapidjson::Value(key, doc.GetAllocator()).Move(), _v, doc.GetAllocator());
-};
-
-/// A convenience function to set a double array compactly
-inline void set_double_array(const char* key, const std::vector<double>& vec, rapidjson::Value& value, rapidjson::Document& doc) {
-    rapidjson::Value _v(rapidjson::kArrayType);
-    for (unsigned int i = 0; i < vec.size(); ++i) {
-        _v.PushBack(vec[i], doc.GetAllocator());
-    }
-    value.AddMember(rapidjson::Value(key, doc.GetAllocator()).Move(), _v, doc.GetAllocator());
-};
-
-/// A convenience function to set a double array compactly
-inline void set_long_double_array(const char* const key, const std::vector<CoolPropDbl>& vec, rapidjson::Value& value, rapidjson::Document& doc) {
-    rapidjson::Value _v(rapidjson::kArrayType);
-    for (unsigned int i = 0; i < vec.size(); ++i) {
-        _v.PushBack(static_cast<double>(vec[i]), doc.GetAllocator());
-    }
-    value.AddMember(rapidjson::Value(key, doc.GetAllocator()).Move(), _v, doc.GetAllocator());
-};
-
-enum schema_validation_code
-{
-    SCHEMA_VALIDATION_OK = 0,
-    SCHEMA_INVALID_JSON,
-    INPUT_INVALID_JSON,
-    SCHEMA_NOT_VALIDATED
-};
-/**
-     * Validate a JSON-formatted string against a JSON-formatted schema string
-     */
-inline schema_validation_code validate_schema(const std::string& schemaJson, const std::string& inputJson, std::string& errstr) {
-    rapidjson::Document sd;
-    sd.Parse(schemaJson.c_str());
-    if (sd.HasParseError()) {
-        errstr = format("Invalid schema: %s\n", schemaJson.c_str());
-        return SCHEMA_INVALID_JSON;
-    }
-    rapidjson::SchemaDocument schema(sd);  // Compile a Document to SchemaDocument
-
-    rapidjson::Document d;
-    d.Parse(inputJson.c_str());
-    if (d.HasParseError()) {
-        errstr = format("Invalid input json: %s\n", inputJson.c_str());
-        return INPUT_INVALID_JSON;
-    }
-
-    rapidjson::SchemaValidator validator(schema);
-    if (!d.Accept(validator)) {
-        // Input JSON is invalid according to the schema
-        // Output diagnostic information
-        errstr = to_string(validator.GetError());
-        return SCHEMA_NOT_VALIDATED;
-    }
-    return SCHEMA_VALIDATION_OK;
-}
-
-}  // namespace cpjson
-#endif
+#ifndef RAPIDJSON_COOLPROP_H
+#define RAPIDJSON_COOLPROP_H
+
+// On PowerPC, we are going to use the stdint.h integer types and not let rapidjson use its own
+#if defined(__powerpc__)
+typedef unsigned int UINT32;
+#    include "stdint.h"
+#    define RAPIDJSON_NO_INT64DEFINE
+#endif
+
+#include "Exceptions.h"
+#include "CoolPropTools.h"
+
+#include "externals/rapidjson/include/rapidjson/rapidjson.h"
+#include "externals/rapidjson/include/rapidjson/document.h"
+#include "externals/rapidjson/include/rapidjson/filewritestream.h"  // wrapper of C stream for prettywriter as output
+#include "externals/rapidjson/include/rapidjson/prettywriter.h"     // for stringify JSON
+#include "externals/rapidjson/include/rapidjson/stringbuffer.h"     // for string buffer
+#include "externals/rapidjson/include/rapidjson/schema.h"
+
+#include <cassert>
+
+namespace cpjson {
+
+/// Convert a JSON-formatted string to a rapidjson::Document object
+inline void JSON_string_to_rapidjson(const std::string& JSON_string, rapidjson::Document& doc) {
+    doc.Parse<0>(JSON_string.c_str());
+    if (doc.HasParseError()) {
+        throw CoolProp::ValueError("Unable to load JSON string");
+    }
+}
+
+struct value_information
+{
+    bool isnull, isfalse, istrue, isbool, isobject, isarray, isnumber, isint, isint64, isuint, isuint64, isdouble, isstring;
+};
+inline value_information get_information(rapidjson::Value& v) {
+    value_information i;
+    i.isnull = v.IsNull();
+    i.isfalse = v.IsFalse();
+    i.istrue = v.IsTrue();
+    i.isbool = v.IsBool();
+    i.isobject = v.IsObject();
+    i.isarray = v.IsArray();
+    i.isnumber = v.IsNumber();
+    i.isint = v.IsInt();
+    i.isuint = v.IsUint();
+    i.isint64 = v.IsInt64();
+    i.isuint64 = v.IsUint64();
+    i.isdouble = v.IsDouble();
+    i.isstring = v.IsString();
+    return i;
+};
+
+inline std::string json2string(const rapidjson::Value& v) {
+    rapidjson::StringBuffer buffer;
+    rapidjson::PrettyWriter<rapidjson::StringBuffer> writer(buffer);
+
+    v.Accept(writer);
+    return buffer.GetString();
+}
+/// A convenience function to get a double from a JSON value, including error checking
+inline int get_integer(const rapidjson::Value& v, std::string m) {
+    if (!v.HasMember(m.c_str())) {
+        throw CoolProp::ValueError(format("Does not have member [%s]", m.c_str()));
+    }
+    const rapidjson::Value& el = v[m.c_str()];
+    if (!el.IsInt()) {
+        throw CoolProp::ValueError(format("Member [%s] is not an integer", m.c_str()));
+    } else {
+        return el.GetInt();
+    }
+};
+/// A convenience function to get a double from a JSON value, including error checking
+inline double get_double(const rapidjson::Value& v, std::string m) {
+    if (!v.HasMember(m.c_str())) {
+        throw CoolProp::ValueError(format("Does not have member [%s]", m.c_str()));
+    }
+    const rapidjson::Value& el = v[m.c_str()];
+    if (!el.IsNumber()) {
+        throw CoolProp::ValueError(format("Member [%s] is not a number", m.c_str()));
+    } else {
+        return el.GetDouble();
+    }
+};
+/// A convenience function to get a bool from a JSON value, including error checking
+inline bool get_bool(const rapidjson::Value& v, std::string m) {
+    if (!v.HasMember(m.c_str())) {
+        throw CoolProp::ValueError(format("Does not have member [%s]", m.c_str()));
+    }
+    const rapidjson::Value& el = v[m.c_str()];
+    if (!el.IsBool()) {
+        throw CoolProp::ValueError(format("Member [%s] is not a boolean", m.c_str()));
+    } else {
+        return el.GetBool();
+    }
+};
+/// A convenience function to get a string from a JSON value, including error checking
+inline std::string get_string(const rapidjson::Value& v, std::string m) {
+    if (!v.HasMember(m.c_str())) {
+        throw CoolProp::ValueError(format("Does not have member [%s]", m.c_str()));
+    }
+    const rapidjson::Value& el = v[m.c_str()];
+    if (!el.IsString()) {
+        throw CoolProp::ValueError(format("Member [%s] is not a string", m.c_str()));
+    } else {
+        return el.GetString();
+    }
+};
+
+/// A convenience function to get a double array compactly
+inline std::vector<double> get_double_array(const rapidjson::Value& v) {
+    std::vector<double> out;
+    if (!v.IsArray()) {
+        throw CoolProp::ValueError("input is not an array");
+    }
+    for (rapidjson::Value::ConstValueIterator itr = v.Begin(); itr != v.End(); ++itr) {
+        if (!itr->IsNumber()) {
+            throw CoolProp::ValueError("input is not a number");
+        }
+        out.push_back(itr->GetDouble());
+    }
+    return out;
+};
+
+/// A convenience function to get a double array compactly
+inline std::vector<double> get_double_array(const rapidjson::Value& v, std::string m) {
+    if (!v.HasMember(m.c_str())) {
+        throw CoolProp::ValueError(format("Does not have member [%s]", m.c_str()));
+    } else {
+        return get_double_array(v[m.c_str()]);
+    }
+};
+
+/// A convenience function to get a long double array compactly
+inline std::vector<CoolPropDbl> get_long_double_array(const rapidjson::Value& v) {
+    std::vector<CoolPropDbl> out;
+    if (!v.IsArray()) {
+        throw CoolProp::ValueError("input is not an array");
+    }
+    for (rapidjson::Value::ConstValueIterator itr = v.Begin(); itr != v.End(); ++itr) {
+        if (!itr->IsNumber()) {
+            throw CoolProp::ValueError("input is not a number");
+        }
+        out.push_back(itr->GetDouble());
+    }
+    return out;
+};
+
+/// A convenience function to get a 2D double array compactly
+inline std::vector<std::vector<double>> get_double_array2D(const rapidjson::Value& v) {
+    std::vector<std::vector<double>> out;
+    std::vector<double> tmp;
+    if (!v.IsArray()) {
+        throw CoolProp::ValueError("input is not an array");
+    }
+    for (rapidjson::Value::ConstValueIterator itr = v.Begin(); itr != v.End(); ++itr) {
+        // This is here for debugging purposes
+        // cpjson::value_information vi = cpjson::get_information((*itr));
+        if (!(itr->IsArray())) {
+            throw CoolProp::ValueError(format("input \"%s\" is not a 2D array", cpjson::json2string(v).c_str()));
+        }
+        tmp.clear();
+        for (rapidjson::Value::ConstValueIterator i = itr->Begin(); i != itr->End(); ++i) {
+            if (!i->IsNumber()) {
+                throw CoolProp::ValueError("input is not a number");
+            }
+            tmp.push_back(i->GetDouble());
+        }
+        out.push_back(tmp);
+    }
+    return out;
+};
+
+/// A convenience function to get a 2D long double array compactly
+inline std::vector<std::vector<CoolPropDbl>> get_long_double_array2D(const rapidjson::Value& v) {
+    std::vector<std::vector<CoolPropDbl>> out;
+    std::vector<CoolPropDbl> tmp;
+    if (!v.IsArray()) {
+        throw CoolProp::ValueError("input is not an array");
+    }
+    for (rapidjson::Value::ConstValueIterator itr = v.Begin(); itr != v.End(); ++itr) {
+        if (!itr->IsArray()) {
+            throw CoolProp::ValueError("input is not a 2D array");
+        }
+        tmp.clear();
+        for (rapidjson::Value::ConstValueIterator i = itr->Begin(); i != itr->End(); ++i) {
+            if (!i->IsNumber()) {
+                throw CoolProp::ValueError("input is not a number");
+            }
+            tmp.push_back(i->GetDouble());
+        }
+        out.push_back(tmp);
+    }
+    return out;
+};
+
+/// A convenience function to get a long double array compactly
+inline std::vector<CoolPropDbl> get_long_double_array(const rapidjson::Value& v, std::string name) {
+    std::vector<CoolPropDbl> out;
+    if (!v.HasMember(name.c_str())) {
+        throw CoolProp::ValueError(format("Does not have member [%s]", name.c_str()));
+    }
+    if (!v[name.c_str()].IsArray()) {
+        throw CoolProp::ValueError("input is not an array");
+    }
+    for (rapidjson::Value::ConstValueIterator itr = v[name.c_str()].Begin(); itr != v[name.c_str()].End(); ++itr) {
+        if (!itr->IsNumber()) {
+            throw CoolProp::ValueError("input is not a number");
+        }
+        out.push_back(itr->GetDouble());
+    }
+    return out;
+};
+
+/// A convenience function to get a string array compactly
+inline std::vector<std::string> get_string_array(const rapidjson::Value& v) {
+    std::vector<std::string> out;
+    if (!v.IsArray()) {
+        throw CoolProp::ValueError("input is not an array");
+    }
+    for (rapidjson::Value::ConstValueIterator itr = v.Begin(); itr != v.End(); ++itr) {
+        out.push_back(itr->GetString());
+    }
+    return out;
+};
+
+/// A convenience function to get a string array compactly
+inline std::vector<std::string> get_string_array(const rapidjson::Value& v, std::string m) {
+    if (!v.HasMember(m.c_str())) {
+        throw CoolProp::ValueError(format("Does not have member [%s]", m.c_str()));
+    } else {
+        return get_string_array(v[m.c_str()]);
+    }
+};
+
+/// A convenience function to get a std::string from a JSON value
+template <typename T>
+inline std::string to_string(const T& v) {
+    rapidjson::StringBuffer buffer;
+    rapidjson::PrettyWriter<rapidjson::StringBuffer> writer(buffer);
+    v.Accept(writer);
+    return buffer.GetString();
+};
+
+/// A convenience function to set a 2D array of double compactly
+inline void set_double_array2D(const char* key, const std::vector<std::vector<double>>& vec, rapidjson::Value& value, rapidjson::Document& doc) {
+    rapidjson::Value _i(rapidjson::kArrayType);
+    for (unsigned int i = 0; i < vec.size(); ++i) {
+        rapidjson::Value _j(rapidjson::kArrayType);
+        for (unsigned int j = 0; j < vec[i].size(); ++j) {
+            rapidjson::Value v(rapidjson::kNumberType);
+            v.SetDouble(vec[i][j]);
+            _j.PushBack(v, doc.GetAllocator());
+        }
+        _i.PushBack(_j, doc.GetAllocator());
+    }
+    value.AddMember(rapidjson::Value(key, doc.GetAllocator()).Move(), _i, doc.GetAllocator());
+};
+
+/// A convenience function to set a string compactly
+inline void set_string(const std::string& key, const std::string& s, rapidjson::Value& value, rapidjson::Document& doc) {
+    value.AddMember(rapidjson::Value(key.c_str(), doc.GetAllocator()).Move(), rapidjson::Value(s.c_str(), doc.GetAllocator()).Move(),
+                    doc.GetAllocator());
+};
+
+/// A convenience function to set a string array compactly
+inline void set_string_array(const char* key, const std::vector<std::string>& vec, rapidjson::Value& value, rapidjson::Document& doc) {
+    rapidjson::Value _v(rapidjson::kArrayType);
+    for (unsigned int i = 0; i < vec.size(); ++i) {
+        _v.PushBack(rapidjson::Value(vec[i].c_str(), doc.GetAllocator()).Move(), doc.GetAllocator());
+    }
+    value.AddMember(rapidjson::Value(key, doc.GetAllocator()).Move(), _v, doc.GetAllocator());
+};
+
+/// A convenience function to set an integer array compactly
+inline void set_int_array(const char* key, const std::vector<int>& vec, rapidjson::Value& value, rapidjson::Document& doc) {
+    rapidjson::Value _v(rapidjson::kArrayType);
+    for (unsigned int i = 0; i < vec.size(); ++i) {
+        _v.PushBack(vec[i], doc.GetAllocator());
+    }
+    value.AddMember(rapidjson::Value(key, doc.GetAllocator()).Move(), _v, doc.GetAllocator());
+};
+
+/// A convenience function to set a double array compactly
+inline void set_double_array(const char* key, const std::vector<double>& vec, rapidjson::Value& value, rapidjson::Document& doc) {
+    rapidjson::Value _v(rapidjson::kArrayType);
+    for (unsigned int i = 0; i < vec.size(); ++i) {
+        _v.PushBack(vec[i], doc.GetAllocator());
+    }
+    value.AddMember(rapidjson::Value(key, doc.GetAllocator()).Move(), _v, doc.GetAllocator());
+};
+
+/// A convenience function to set a double array compactly
+inline void set_long_double_array(const char* const key, const std::vector<CoolPropDbl>& vec, rapidjson::Value& value, rapidjson::Document& doc) {
+    rapidjson::Value _v(rapidjson::kArrayType);
+    for (unsigned int i = 0; i < vec.size(); ++i) {
+        _v.PushBack(static_cast<double>(vec[i]), doc.GetAllocator());
+    }
+    value.AddMember(rapidjson::Value(key, doc.GetAllocator()).Move(), _v, doc.GetAllocator());
+};
+
+enum schema_validation_code
+{
+    SCHEMA_VALIDATION_OK = 0,
+    SCHEMA_INVALID_JSON,
+    INPUT_INVALID_JSON,
+    SCHEMA_NOT_VALIDATED
+};
+/**
+     * Validate a JSON-formatted string against a JSON-formatted schema string
+     */
+inline schema_validation_code validate_schema(const std::string& schemaJson, const std::string& inputJson, std::string& errstr) {
+    rapidjson::Document sd;
+    sd.Parse(schemaJson.c_str());
+    if (sd.HasParseError()) {
+        errstr = format("Invalid schema: %s\n", schemaJson.c_str());
+        return SCHEMA_INVALID_JSON;
+    }
+    rapidjson::SchemaDocument schema(sd);  // Compile a Document to SchemaDocument
+
+    rapidjson::Document d;
+    d.Parse(inputJson.c_str());
+    if (d.HasParseError()) {
+        errstr = format("Invalid input json: %s\n", inputJson.c_str());
+        return INPUT_INVALID_JSON;
+    }
+
+    rapidjson::SchemaValidator validator(schema);
+    if (!d.Accept(validator)) {
+        // Input JSON is invalid according to the schema
+        // Output diagnostic information
+        errstr = to_string(validator.GetError());
+        return SCHEMA_NOT_VALIDATED;
+    }
+    return SCHEMA_VALIDATION_OK;
+}
+
+}  // namespace cpjson
+#endif
```

## CoolProp/include/fmt/format.h

```diff
@@ -1,4173 +1,4735 @@
-/*
- Formatting library for C++
-
- Copyright (c) 2012 - 2016, Victor Zverovich
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions are met:
-
- 1. Redistributions of source code must retain the above copyright notice, this
-    list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright notice,
-    this list of conditions and the following disclaimer in the documentation
-    and/or other materials provided with the distribution.
-
- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
- ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
- ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef FMT_FORMAT_H_
-#define FMT_FORMAT_H_
-
-#define FMT_INCLUDE
-#include <cassert>
-#include <clocale>
-#include <cmath>
-#include <cstdio>
-#include <cstring>
-#include <limits>
-#include <memory>
-#include <stdexcept>
-#include <string>
-#include <vector>
-#include <utility>  // for std::pair
-#undef FMT_INCLUDE
-
-// The fmt library version in the form major * 10000 + minor * 100 + patch.
-#define FMT_VERSION 40100
-
-#if defined(__has_include)
-# define FMT_HAS_INCLUDE(x) __has_include(x)
-#else
-# define FMT_HAS_INCLUDE(x) 0
-#endif
-
-#if (FMT_HAS_INCLUDE(<string_view>) && __cplusplus > 201402L) || \
-    (defined(_MSVC_LANG) && _MSVC_LANG > 201402L && _MSC_VER >= 1910)
-# include <string_view>
-# define FMT_HAS_STRING_VIEW 1
-#else
-# define FMT_HAS_STRING_VIEW 0
-#endif
-
-#if defined _SECURE_SCL && _SECURE_SCL
-# define FMT_SECURE_SCL _SECURE_SCL
-#else
-# define FMT_SECURE_SCL 0
-#endif
-
-#if FMT_SECURE_SCL
-# include <iterator>
-#endif
-
-#ifdef _MSC_VER
-# define FMT_MSC_VER _MSC_VER
-#else
-# define FMT_MSC_VER 0
-#endif
-
-#if FMT_MSC_VER && FMT_MSC_VER <= 1500
-typedef unsigned __int32 uint32_t;
-typedef unsigned __int64 uint64_t;
-typedef __int64          intmax_t;
-#else
-#include <stdint.h>
-#endif
-
-#if !defined(FMT_HEADER_ONLY) && defined(_WIN32)
-# ifdef FMT_EXPORT
-#  define FMT_API __declspec(dllexport)
-# elif defined(FMT_SHARED)
-#  define FMT_API __declspec(dllimport)
-# endif
-#endif
-#ifndef FMT_API
-# define FMT_API
-#endif
-
-#ifdef __GNUC__
-# define FMT_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
-# define FMT_GCC_EXTENSION __extension__
-# if FMT_GCC_VERSION >= 406
-#  pragma GCC diagnostic push
-// Disable the warning about "long long" which is sometimes reported even
-// when using __extension__.
-#  pragma GCC diagnostic ignored "-Wlong-long"
-// Disable the warning about declaration shadowing because it affects too
-// many valid cases.
-#  pragma GCC diagnostic ignored "-Wshadow"
-// Disable the warning about implicit conversions that may change the sign of
-// an integer; silencing it otherwise would require many explicit casts.
-#  pragma GCC diagnostic ignored "-Wsign-conversion"
-# endif
-# if __cplusplus >= 201103L || defined __GXX_EXPERIMENTAL_CXX0X__
-#  define FMT_HAS_GXX_CXX11 1
-# endif
-#else
-# define FMT_GCC_VERSION 0
-# define FMT_GCC_EXTENSION
-# define FMT_HAS_GXX_CXX11 0
-#endif
-
-#if defined(__INTEL_COMPILER)
-# define FMT_ICC_VERSION __INTEL_COMPILER
-#elif defined(__ICL)
-# define FMT_ICC_VERSION __ICL
-#endif
-
-#if defined(__clang__) && !defined(FMT_ICC_VERSION)
-# define FMT_CLANG_VERSION (__clang_major__ * 100 + __clang_minor__)
-# pragma clang diagnostic push
-# pragma clang diagnostic ignored "-Wdocumentation-unknown-command"
-# pragma clang diagnostic ignored "-Wpadded"
-#endif
-
-#ifdef __GNUC_LIBSTD__
-# define FMT_GNUC_LIBSTD_VERSION (__GNUC_LIBSTD__ * 100 + __GNUC_LIBSTD_MINOR__)
-#endif
-
-#ifdef __has_feature
-# define FMT_HAS_FEATURE(x) __has_feature(x)
-#else
-# define FMT_HAS_FEATURE(x) 0
-#endif
-
-#ifdef __has_builtin
-# define FMT_HAS_BUILTIN(x) __has_builtin(x)
-#else
-# define FMT_HAS_BUILTIN(x) 0
-#endif
-
-#ifdef __has_cpp_attribute
-# define FMT_HAS_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)
-#else
-# define FMT_HAS_CPP_ATTRIBUTE(x) 0
-#endif
-
-#if FMT_HAS_CPP_ATTRIBUTE(maybe_unused)
-# define FMT_HAS_CXX17_ATTRIBUTE_MAYBE_UNUSED
-// VC++ 1910 support /std: option and that will set _MSVC_LANG macro
-// Clang with Microsoft CodeGen doesn't define _MSVC_LANG macro
-#elif defined(_MSVC_LANG) && _MSVC_LANG > 201402 && _MSC_VER >= 1910
-# define FMT_HAS_CXX17_ATTRIBUTE_MAYBE_UNUSED
-#endif
-
-#ifdef FMT_HAS_CXX17_ATTRIBUTE_MAYBE_UNUSED
-# define FMT_MAYBE_UNUSED [[maybe_unused]]
-// g++/clang++ also support [[gnu::unused]]. However, we don't use it.
-#elif defined(__GNUC__)
-# define FMT_MAYBE_UNUSED __attribute__((unused))
-#else
-# define FMT_MAYBE_UNUSED
-#endif
-
-// Use the compiler's attribute noreturn
-#if defined(__MINGW32__) || defined(__MINGW64__)
-# define FMT_NORETURN __attribute__((noreturn))
-#elif FMT_HAS_CPP_ATTRIBUTE(noreturn) && __cplusplus >= 201103L
-# define FMT_NORETURN [[noreturn]]
-#else
-# define FMT_NORETURN
-#endif
-
-#ifndef FMT_USE_VARIADIC_TEMPLATES
-// Variadic templates are available in GCC since version 4.4
-// (http://gcc.gnu.org/projects/cxx0x.html) and in Visual C++
-// since version 2013.
-# define FMT_USE_VARIADIC_TEMPLATES \
-   (FMT_HAS_FEATURE(cxx_variadic_templates) || \
-       (FMT_GCC_VERSION >= 404 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1800)
-#endif
-
-#ifndef FMT_USE_RVALUE_REFERENCES
-// Don't use rvalue references when compiling with clang and an old libstdc++
-// as the latter doesn't provide std::move.
-# if defined(FMT_GNUC_LIBSTD_VERSION) && FMT_GNUC_LIBSTD_VERSION <= 402
-#  define FMT_USE_RVALUE_REFERENCES 0
-# else
-#  define FMT_USE_RVALUE_REFERENCES \
-    (FMT_HAS_FEATURE(cxx_rvalue_references) || \
-        (FMT_GCC_VERSION >= 403 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1600)
-# endif
-#endif
-
-#if __cplusplus >= 201103L || FMT_MSC_VER >= 1700
-# define FMT_USE_ALLOCATOR_TRAITS 1
-#else
-# define FMT_USE_ALLOCATOR_TRAITS 0
-#endif
-
-// Check if exceptions are disabled.
-#if defined(__GNUC__) && !defined(__EXCEPTIONS)
-# define FMT_EXCEPTIONS 0
-#endif
-#if FMT_MSC_VER && !_HAS_EXCEPTIONS
-# define FMT_EXCEPTIONS 0
-#endif
-#ifndef FMT_EXCEPTIONS
-# define FMT_EXCEPTIONS 1
-#endif
-
-#ifndef FMT_THROW
-# if FMT_EXCEPTIONS
-#  define FMT_THROW(x) throw x
-# else
-#  define FMT_THROW(x) assert(false)
-# endif
-#endif
-
-// Define FMT_USE_NOEXCEPT to make fmt use noexcept (C++11 feature).
-#ifndef FMT_USE_NOEXCEPT
-# define FMT_USE_NOEXCEPT 0
-#endif
-
-#if FMT_USE_NOEXCEPT || FMT_HAS_FEATURE(cxx_noexcept) || \
-    (FMT_GCC_VERSION >= 408 && FMT_HAS_GXX_CXX11) || \
-    FMT_MSC_VER >= 1900
-# define FMT_DETECTED_NOEXCEPT noexcept
-#else
-# define FMT_DETECTED_NOEXCEPT throw()
-#endif
-
-#ifndef FMT_NOEXCEPT
-# if FMT_EXCEPTIONS
-#  define FMT_NOEXCEPT FMT_DETECTED_NOEXCEPT
-# else
-#  define FMT_NOEXCEPT
-# endif
-#endif
-
-// This is needed because GCC still uses throw() in its headers when exceptions
-// are disabled.
-#if FMT_GCC_VERSION
-# define FMT_DTOR_NOEXCEPT FMT_DETECTED_NOEXCEPT
-#else
-# define FMT_DTOR_NOEXCEPT FMT_NOEXCEPT
-#endif
-
-#ifndef FMT_OVERRIDE
-# if (defined(FMT_USE_OVERRIDE) && FMT_USE_OVERRIDE) || FMT_HAS_FEATURE(cxx_override) || \
-   (FMT_GCC_VERSION >= 408 && FMT_HAS_GXX_CXX11) || \
-   FMT_MSC_VER >= 1900
-#  define FMT_OVERRIDE override
-# else
-#  define FMT_OVERRIDE
-# endif
-#endif
-
-#ifndef FMT_NULL
-# if FMT_HAS_FEATURE(cxx_nullptr) || \
-   (FMT_GCC_VERSION >= 408 && FMT_HAS_GXX_CXX11) || \
-   FMT_MSC_VER >= 1600
-#  define FMT_NULL nullptr
-# else
-#  define FMT_NULL NULL
-# endif
-#endif
-
-// A macro to disallow the copy constructor and operator= functions
-// This should be used in the private: declarations for a class
-#ifndef FMT_USE_DELETED_FUNCTIONS
-# define FMT_USE_DELETED_FUNCTIONS 0
-#endif
-
-#if FMT_USE_DELETED_FUNCTIONS || FMT_HAS_FEATURE(cxx_deleted_functions) || \
-  (FMT_GCC_VERSION >= 404 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1800
-# define FMT_DELETED_OR_UNDEFINED  = delete
-# define FMT_DISALLOW_COPY_AND_ASSIGN(TypeName) \
-    TypeName(const TypeName&) = delete; \
-    TypeName& operator=(const TypeName&) = delete
-#else
-# define FMT_DELETED_OR_UNDEFINED
-# define FMT_DISALLOW_COPY_AND_ASSIGN(TypeName) \
-    TypeName(const TypeName&); \
-    TypeName& operator=(const TypeName&)
-#endif
-
-#ifndef FMT_USE_DEFAULTED_FUNCTIONS
-# define FMT_USE_DEFAULTED_FUNCTIONS 0
-#endif
-
-#ifndef FMT_DEFAULTED_COPY_CTOR
-# if FMT_USE_DEFAULTED_FUNCTIONS || FMT_HAS_FEATURE(cxx_defaulted_functions) || \
-   (FMT_GCC_VERSION >= 404 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1800
-#  define FMT_DEFAULTED_COPY_CTOR(TypeName) \
-    TypeName(const TypeName&) = default;
-# else
-#  define FMT_DEFAULTED_COPY_CTOR(TypeName)
-# endif
-#endif
-
-#ifndef FMT_USE_USER_DEFINED_LITERALS
-// All compilers which support UDLs also support variadic templates. This
-// makes the fmt::literals implementation easier. However, an explicit check
-// for variadic templates is added here just in case.
-// For Intel's compiler both it and the system gcc/msc must support UDLs.
-# if FMT_USE_VARIADIC_TEMPLATES && FMT_USE_RVALUE_REFERENCES && \
-   (FMT_HAS_FEATURE(cxx_user_literals) || \
-     (FMT_GCC_VERSION >= 407 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1900) && \
-   (!defined(FMT_ICC_VERSION) || FMT_ICC_VERSION >= 1500)
-#  define FMT_USE_USER_DEFINED_LITERALS 1
-# else
-#  define FMT_USE_USER_DEFINED_LITERALS 0
-# endif
-#endif
-
-#ifndef FMT_USE_EXTERN_TEMPLATES
-# define FMT_USE_EXTERN_TEMPLATES \
-    (FMT_CLANG_VERSION >= 209 || (FMT_GCC_VERSION >= 303 && FMT_HAS_GXX_CXX11))
-#endif
-
-#ifdef FMT_HEADER_ONLY
-// If header only do not use extern templates.
-# undef FMT_USE_EXTERN_TEMPLATES
-# define FMT_USE_EXTERN_TEMPLATES 0
-#endif
-
-#ifndef FMT_ASSERT
-# define FMT_ASSERT(condition, message) assert((condition) && message)
-#endif
-
-// __builtin_clz is broken in clang with Microsoft CodeGen:
-// https://github.com/fmtlib/fmt/issues/519
-#ifndef _MSC_VER
-# if FMT_GCC_VERSION >= 400 || FMT_HAS_BUILTIN(__builtin_clz)
-#  define FMT_BUILTIN_CLZ(n) __builtin_clz(n)
-# endif
-
-# if FMT_GCC_VERSION >= 400 || FMT_HAS_BUILTIN(__builtin_clzll)
-#  define FMT_BUILTIN_CLZLL(n) __builtin_clzll(n)
-# endif
-#endif
-
-// Some compilers masquerade as both MSVC and GCC-likes or
-// otherwise support __builtin_clz and __builtin_clzll, so
-// only define FMT_BUILTIN_CLZ using the MSVC intrinsics
-// if the clz and clzll builtins are not available.
-#if FMT_MSC_VER && !defined(FMT_BUILTIN_CLZLL) && !defined(_MANAGED)
-# include <intrin.h>  // _BitScanReverse, _BitScanReverse64
-
-namespace fmt {
-namespace internal {
-// avoid Clang with Microsoft CodeGen's -Wunknown-pragmas warning
-# ifndef __clang__
-#  pragma intrinsic(_BitScanReverse)
-# endif
-inline uint32_t clz(uint32_t x) {
-  unsigned long r = 0;
-  _BitScanReverse(&r, x);
-
-  assert(x != 0);
-  // Static analysis complains about using uninitialized data
-  // "r", but the only way that can happen is if "x" is 0,
-  // which the callers guarantee to not happen.
-# pragma warning(suppress: 6102)
-  return 31 - r;
-}
-# define FMT_BUILTIN_CLZ(n) fmt::internal::clz(n)
-
-// avoid Clang with Microsoft CodeGen's -Wunknown-pragmas warning
-# if defined(_WIN64) && !defined(__clang__)
-#  pragma intrinsic(_BitScanReverse64)
-# endif
-
-inline uint32_t clzll(uint64_t x) {
-  unsigned long r = 0;
-# ifdef _WIN64
-  _BitScanReverse64(&r, x);
-# else
-  // Scan the high 32 bits.
-  if (_BitScanReverse(&r, static_cast<uint32_t>(x >> 32)))
-    return 63 - (r + 32);
-
-  // Scan the low 32 bits.
-  _BitScanReverse(&r, static_cast<uint32_t>(x));
-# endif
-
-  assert(x != 0);
-  // Static analysis complains about using uninitialized data
-  // "r", but the only way that can happen is if "x" is 0,
-  // which the callers guarantee to not happen.
-# pragma warning(suppress: 6102)
-  return 63 - r;
-}
-# define FMT_BUILTIN_CLZLL(n) fmt::internal::clzll(n)
-}
-}
-#endif
-
-namespace fmt {
-namespace internal {
-struct DummyInt {
-  int data[2];
-  operator int() const { return 0; }
-};
-typedef std::numeric_limits<fmt::internal::DummyInt> FPUtil;
-
-// Dummy implementations of system functions such as signbit and ecvt called
-// if the latter are not available.
-inline DummyInt signbit(...) { return DummyInt(); }
-inline DummyInt _ecvt_s(...) { return DummyInt(); }
-inline DummyInt isinf(...) { return DummyInt(); }
-inline DummyInt _finite(...) { return DummyInt(); }
-inline DummyInt isnan(...) { return DummyInt(); }
-inline DummyInt _isnan(...) { return DummyInt(); }
-
-// A helper function to suppress bogus "conditional expression is constant"
-// warnings.
-template <typename T>
-inline T const_check(T value) { return value; }
-}
-}  // namespace fmt
-
-namespace std {
-// Standard permits specialization of std::numeric_limits. This specialization
-// is used to resolve ambiguity between isinf and std::isinf in glibc:
-// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=48891
-// and the same for isnan and signbit.
-template <>
-class numeric_limits<fmt::internal::DummyInt> :
-    public std::numeric_limits<int> {
- public:
-  // Portable version of isinf.
-  template <typename T>
-  static bool isinfinity(T x) {
-    using namespace fmt::internal;
-    // The resolution "priority" is:
-    // isinf macro > std::isinf > ::isinf > fmt::internal::isinf
-    if (const_check(sizeof(isinf(x)) == sizeof(bool) ||
-                    sizeof(isinf(x)) == sizeof(int))) {
-      return isinf(x) != 0;
-    }
-    return !_finite(static_cast<double>(x));
-  }
-
-  // Portable version of isnan.
-  template <typename T>
-  static bool isnotanumber(T x) {
-    using namespace fmt::internal;
-    if (const_check(sizeof(isnan(x)) == sizeof(bool) ||
-                    sizeof(isnan(x)) == sizeof(int))) {
-      return isnan(x) != 0;
-    }
-    return _isnan(static_cast<double>(x)) != 0;
-  }
-
-  // Portable version of signbit.
-  static bool isnegative(double x) {
-    using namespace fmt::internal;
-    if (const_check(sizeof(signbit(x)) == sizeof(bool) ||
-                    sizeof(signbit(x)) == sizeof(int))) {
-      return signbit(x) != 0;
-    }
-    if (x < 0) return true;
-    if (!isnotanumber(x)) return false;
-    int dec = 0, sign = 0;
-    char buffer[2];  // The buffer size must be >= 2 or _ecvt_s will fail.
-    _ecvt_s(buffer, sizeof(buffer), x, 0, &dec, &sign);
-    return sign != 0;
-  }
-};
-}  // namespace std
-
-namespace fmt {
-
-// Fix the warning about long long on older versions of GCC
-// that don't support the diagnostic pragma.
-FMT_GCC_EXTENSION typedef long long LongLong;
-FMT_GCC_EXTENSION typedef unsigned long long ULongLong;
-
-#if FMT_USE_RVALUE_REFERENCES
-using std::move;
-#endif
-
-template <typename Char>
-class BasicWriter;
-
-typedef BasicWriter<char> Writer;
-typedef BasicWriter<wchar_t> WWriter;
-
-template <typename Char>
-class ArgFormatter;
-
-struct FormatSpec;
-
-template <typename Impl, typename Char, typename Spec = fmt::FormatSpec>
-class BasicPrintfArgFormatter;
-
-template <typename CharType,
-          typename ArgFormatter = fmt::ArgFormatter<CharType> >
-class BasicFormatter;
-
-/**
-  \rst
-  A string reference. It can be constructed from a C string or
-  ``std::basic_string``.
-
-  You can use one of the following typedefs for common character types:
-
-  +------------+-------------------------+
-  | Type       | Definition              |
-  +============+=========================+
-  | StringRef  | BasicStringRef<char>    |
-  +------------+-------------------------+
-  | WStringRef | BasicStringRef<wchar_t> |
-  +------------+-------------------------+
-
-  This class is most useful as a parameter type to allow passing
-  different types of strings to a function, for example::
-
-    template <typename... Args>
-    std::string format(StringRef format_str, const Args & ... args);
-
-    format("{}", 42);
-    format(std::string("{}"), 42);
-  \endrst
- */
-template <typename Char>
-class BasicStringRef {
- private:
-  const Char *data_;
-  std::size_t size_;
-
- public:
-  /** Constructs a string reference object from a C string and a size. */
-  BasicStringRef(const Char *s, std::size_t size) : data_(s), size_(size) {}
-
-  /**
-    \rst
-    Constructs a string reference object from a C string computing
-    the size with ``std::char_traits<Char>::length``.
-    \endrst
-   */
-  BasicStringRef(const Char *s)
-    : data_(s), size_(std::char_traits<Char>::length(s)) {}
-
-  /**
-    \rst
-    Constructs a string reference from a ``std::basic_string`` object.
-    \endrst
-   */
-  template <typename Allocator>
-  BasicStringRef(
-      const std::basic_string<Char, std::char_traits<Char>, Allocator> &s)
-  : data_(s.c_str()), size_(s.size()) {}
-
-#if FMT_HAS_STRING_VIEW
-  /**
-    \rst
-    Constructs a string reference from a ``std::basic_string_view`` object.
-    \endrst
-   */
-  BasicStringRef(
-      const std::basic_string_view<Char, std::char_traits<Char>> &s)
-  : data_(s.data()), size_(s.size()) {}
-
-  /**
-   \rst
-   Converts a string reference to an ``std::string_view`` object.
-   \endrst
-  */
-  explicit operator std::basic_string_view<Char>() const FMT_NOEXCEPT {
-    return std::basic_string_view<Char>(data_, size_);
-  }
-#endif
-
-  /**
-    \rst
-    Converts a string reference to an ``std::string`` object.
-    \endrst
-   */
-  std::basic_string<Char> to_string() const {
-    return std::basic_string<Char>(data_, size_);
-  }
-
-  /** Returns a pointer to the string data. */
-  const Char *data() const { return data_; }
-
-  /** Returns the string size. */
-  std::size_t size() const { return size_; }
-
-  // Lexicographically compare this string reference to other.
-  int compare(BasicStringRef other) const {
-    std::size_t size = size_ < other.size_ ? size_ : other.size_;
-    int result = std::char_traits<Char>::compare(data_, other.data_, size);
-    if (result == 0)
-      result = size_ == other.size_ ? 0 : (size_ < other.size_ ? -1 : 1);
-    return result;
-  }
-
-  friend bool operator==(BasicStringRef lhs, BasicStringRef rhs) {
-    return lhs.compare(rhs) == 0;
-  }
-  friend bool operator!=(BasicStringRef lhs, BasicStringRef rhs) {
-    return lhs.compare(rhs) != 0;
-  }
-  friend bool operator<(BasicStringRef lhs, BasicStringRef rhs) {
-    return lhs.compare(rhs) < 0;
-  }
-  friend bool operator<=(BasicStringRef lhs, BasicStringRef rhs) {
-    return lhs.compare(rhs) <= 0;
-  }
-  friend bool operator>(BasicStringRef lhs, BasicStringRef rhs) {
-    return lhs.compare(rhs) > 0;
-  }
-  friend bool operator>=(BasicStringRef lhs, BasicStringRef rhs) {
-    return lhs.compare(rhs) >= 0;
-  }
-};
-
-typedef BasicStringRef<char> StringRef;
-typedef BasicStringRef<wchar_t> WStringRef;
-
-/**
-  \rst
-  A reference to a null terminated string. It can be constructed from a C
-  string or ``std::basic_string``.
-
-  You can use one of the following typedefs for common character types:
-
-  +-------------+--------------------------+
-  | Type        | Definition               |
-  +=============+==========================+
-  | CStringRef  | BasicCStringRef<char>    |
-  +-------------+--------------------------+
-  | WCStringRef | BasicCStringRef<wchar_t> |
-  +-------------+--------------------------+
-
-  This class is most useful as a parameter type to allow passing
-  different types of strings to a function, for example::
-
-    template <typename... Args>
-    std::string format(CStringRef format_str, const Args & ... args);
-
-    format("{}", 42);
-    format(std::string("{}"), 42);
-  \endrst
- */
-template <typename Char>
-class BasicCStringRef {
- private:
-  const Char *data_;
-
- public:
-  /** Constructs a string reference object from a C string. */
-  BasicCStringRef(const Char *s) : data_(s) {}
-
-  /**
-    \rst
-    Constructs a string reference from a ``std::basic_string`` object.
-    \endrst
-   */
-  template <typename Allocator>
-  BasicCStringRef(
-      const std::basic_string<Char, std::char_traits<Char>, Allocator> &s)
-  : data_(s.c_str()) {}
-
-  /** Returns the pointer to a C string. */
-  const Char *c_str() const { return data_; }
-};
-
-typedef BasicCStringRef<char> CStringRef;
-typedef BasicCStringRef<wchar_t> WCStringRef;
-
-/** A formatting error such as invalid format string. */
-class FormatError : public std::runtime_error {
- public:
-  explicit FormatError(CStringRef message)
-  : std::runtime_error(message.c_str()) {}
-  FormatError(const FormatError &ferr) : std::runtime_error(ferr) {}
-  FMT_API ~FormatError() FMT_DTOR_NOEXCEPT FMT_OVERRIDE;
-};
-
-namespace internal {
-
-// MakeUnsigned<T>::Type gives an unsigned type corresponding to integer type T.
-template <typename T>
-struct MakeUnsigned { typedef T Type; };
-
-#define FMT_SPECIALIZE_MAKE_UNSIGNED(T, U) \
-  template <> \
-  struct MakeUnsigned<T> { typedef U Type; }
-
-FMT_SPECIALIZE_MAKE_UNSIGNED(char, unsigned char);
-FMT_SPECIALIZE_MAKE_UNSIGNED(signed char, unsigned char);
-FMT_SPECIALIZE_MAKE_UNSIGNED(short, unsigned short);
-FMT_SPECIALIZE_MAKE_UNSIGNED(int, unsigned);
-FMT_SPECIALIZE_MAKE_UNSIGNED(long, unsigned long);
-FMT_SPECIALIZE_MAKE_UNSIGNED(LongLong, ULongLong);
-
-// Casts nonnegative integer to unsigned.
-template <typename Int>
-inline typename MakeUnsigned<Int>::Type to_unsigned(Int value) {
-  FMT_ASSERT(value >= 0, "negative value");
-  return static_cast<typename MakeUnsigned<Int>::Type>(value);
-}
-
-// The number of characters to store in the MemoryBuffer object itself
-// to avoid dynamic memory allocation.
-enum { INLINE_BUFFER_SIZE = 500 };
-
-#if FMT_SECURE_SCL
-// Use checked iterator to avoid warnings on MSVC.
-template <typename T>
-inline stdext::checked_array_iterator<T*> make_ptr(T *ptr, std::size_t size) {
-  return stdext::checked_array_iterator<T*>(ptr, size);
-}
-#else
-template <typename T>
-inline T *make_ptr(T *ptr, std::size_t) { return ptr; }
-#endif
-}  // namespace internal
-
-/**
-  \rst
-  A buffer supporting a subset of ``std::vector``'s operations.
-  \endrst
- */
-template <typename T>
-class Buffer {
- private:
-  FMT_DISALLOW_COPY_AND_ASSIGN(Buffer);
-
- protected:
-  T *ptr_;
-  std::size_t size_;
-  std::size_t capacity_;
-
-  Buffer(T *ptr = FMT_NULL, std::size_t capacity = 0)
-    : ptr_(ptr), size_(0), capacity_(capacity) {}
-
-  /**
-    \rst
-    Increases the buffer capacity to hold at least *size* elements updating
-    ``ptr_`` and ``capacity_``.
-    \endrst
-   */
-  virtual void grow(std::size_t size) = 0;
-
- public:
-  virtual ~Buffer() {}
-
-  /** Returns the size of this buffer. */
-  std::size_t size() const { return size_; }
-
-  /** Returns the capacity of this buffer. */
-  std::size_t capacity() const { return capacity_; }
-
-  /**
-    Resizes the buffer. If T is a POD type new elements may not be initialized.
-   */
-  void resize(std::size_t new_size) {
-    if (new_size > capacity_)
-      grow(new_size);
-    size_ = new_size;
-  }
-
-  /**
-    \rst
-    Reserves space to store at least *capacity* elements.
-    \endrst
-   */
-  void reserve(std::size_t capacity) {
-    if (capacity > capacity_)
-      grow(capacity);
-  }
-
-  void clear() FMT_NOEXCEPT { size_ = 0; }
-
-  void push_back(const T &value) {
-    if (size_ == capacity_)
-      grow(size_ + 1);
-    ptr_[size_++] = value;
-  }
-
-  /** Appends data to the end of the buffer. */
-  template <typename U>
-  void append(const U *begin, const U *end);
-
-  T &operator[](std::size_t index) { return ptr_[index]; }
-  const T &operator[](std::size_t index) const { return ptr_[index]; }
-};
-
-template <typename T>
-template <typename U>
-void Buffer<T>::append(const U *begin, const U *end) {
-  FMT_ASSERT(end >= begin, "negative value");
-  std::size_t new_size = size_ + static_cast<std::size_t>(end - begin);
-  if (new_size > capacity_)
-    grow(new_size);
-  std::uninitialized_copy(begin, end,
-                          internal::make_ptr(ptr_, capacity_) + size_);
-  size_ = new_size;
-}
-
-namespace internal {
-
-// A memory buffer for trivially copyable/constructible types with the first
-// SIZE elements stored in the object itself.
-template <typename T, std::size_t SIZE, typename Allocator = std::allocator<T> >
-class MemoryBuffer : private Allocator, public Buffer<T> {
- private:
-  T data_[SIZE];
-
-  // Deallocate memory allocated by the buffer.
-  void deallocate() {
-    if (this->ptr_ != data_) Allocator::deallocate(this->ptr_, this->capacity_);
-  }
-
- protected:
-  void grow(std::size_t size) FMT_OVERRIDE;
-
- public:
-  explicit MemoryBuffer(const Allocator &alloc = Allocator())
-      : Allocator(alloc), Buffer<T>(data_, SIZE) {}
-  ~MemoryBuffer() FMT_OVERRIDE { deallocate(); }
-
-#if FMT_USE_RVALUE_REFERENCES
- private:
-  // Move data from other to this buffer.
-  void move(MemoryBuffer &other) {
-    Allocator &this_alloc = *this, &other_alloc = other;
-    this_alloc = std::move(other_alloc);
-    this->size_ = other.size_;
-    this->capacity_ = other.capacity_;
-    if (other.ptr_ == other.data_) {
-      this->ptr_ = data_;
-      std::uninitialized_copy(other.data_, other.data_ + this->size_,
-                              make_ptr(data_, this->capacity_));
-    } else {
-      this->ptr_ = other.ptr_;
-      // Set pointer to the inline array so that delete is not called
-      // when deallocating.
-      other.ptr_ = other.data_;
-    }
-  }
-
- public:
-  MemoryBuffer(MemoryBuffer &&other) {
-    move(other);
-  }
-
-  MemoryBuffer &operator=(MemoryBuffer &&other) {
-    assert(this != &other);
-    deallocate();
-    move(other);
-    return *this;
-  }
-#endif
-
-  // Returns a copy of the allocator associated with this buffer.
-  Allocator get_allocator() const { return *this; }
-};
-
-template <typename T, std::size_t SIZE, typename Allocator>
-void MemoryBuffer<T, SIZE, Allocator>::grow(std::size_t size) {
-  std::size_t new_capacity = this->capacity_ + this->capacity_ / 2;
-  if (size > new_capacity)
-      new_capacity = size;
-#if FMT_USE_ALLOCATOR_TRAITS
-  T *new_ptr =
-      std::allocator_traits<Allocator>::allocate(*this, new_capacity, FMT_NULL);
-#else
-  T *new_ptr = this->allocate(new_capacity, FMT_NULL);
-#endif
-  // The following code doesn't throw, so the raw pointer above doesn't leak.
-  std::uninitialized_copy(this->ptr_, this->ptr_ + this->size_,
-                          make_ptr(new_ptr, new_capacity));
-  std::size_t old_capacity = this->capacity_;
-  T *old_ptr = this->ptr_;
-  this->capacity_ = new_capacity;
-  this->ptr_ = new_ptr;
-  // deallocate may throw (at least in principle), but it doesn't matter since
-  // the buffer already uses the new storage and will deallocate it in case
-  // of exception.
-  if (old_ptr != data_)
-    Allocator::deallocate(old_ptr, old_capacity);
-}
-
-// A fixed-size buffer.
-template <typename Char>
-class FixedBuffer : public fmt::Buffer<Char> {
- public:
-  FixedBuffer(Char *array, std::size_t size) : fmt::Buffer<Char>(array, size) {}
-
- protected:
-  FMT_API void grow(std::size_t size) FMT_OVERRIDE;
-};
-
-template <typename Char>
-class BasicCharTraits {
- public:
-#if FMT_SECURE_SCL
-  typedef stdext::checked_array_iterator<Char*> CharPtr;
-#else
-  typedef Char *CharPtr;
-#endif
-  static Char cast(int value) { return static_cast<Char>(value); }
-};
-
-template <typename Char>
-class CharTraits;
-
-template <>
-class CharTraits<char> : public BasicCharTraits<char> {
- private:
-  // Conversion from wchar_t to char is not allowed.
-  static char convert(wchar_t);
-
- public:
-  static char convert(char value) { return value; }
-
-  // Formats a floating-point number.
-  template <typename T>
-  FMT_API static int format_float(char *buffer, std::size_t size,
-      const char *format, unsigned width, int precision, T value);
-};
-
-#if FMT_USE_EXTERN_TEMPLATES
-extern template int CharTraits<char>::format_float<double>
-        (char *buffer, std::size_t size,
-         const char* format, unsigned width, int precision, double value);
-extern template int CharTraits<char>::format_float<long double>
-        (char *buffer, std::size_t size,
-         const char* format, unsigned width, int precision, long double value);
-#endif
-
-template <>
-class CharTraits<wchar_t> : public BasicCharTraits<wchar_t> {
- public:
-  static wchar_t convert(char value) { return value; }
-  static wchar_t convert(wchar_t value) { return value; }
-
-  template <typename T>
-  FMT_API static int format_float(wchar_t *buffer, std::size_t size,
-      const wchar_t *format, unsigned width, int precision, T value);
-};
-
-#if FMT_USE_EXTERN_TEMPLATES
-extern template int CharTraits<wchar_t>::format_float<double>
-        (wchar_t *buffer, std::size_t size,
-         const wchar_t* format, unsigned width, int precision, double value);
-extern template int CharTraits<wchar_t>::format_float<long double>
-        (wchar_t *buffer, std::size_t size,
-         const wchar_t* format, unsigned width, int precision, long double value);
-#endif
-
-// Checks if a number is negative - used to avoid warnings.
-template <bool IsSigned>
-struct SignChecker {
-  template <typename T>
-  static bool is_negative(T value) { return value < 0; }
-};
-
-template <>
-struct SignChecker<false> {
-  template <typename T>
-  static bool is_negative(T) { return false; }
-};
-
-// Returns true if value is negative, false otherwise.
-// Same as (value < 0) but doesn't produce warnings if T is an unsigned type.
-template <typename T>
-inline bool is_negative(T value) {
-  return SignChecker<std::numeric_limits<T>::is_signed>::is_negative(value);
-}
-
-// Selects uint32_t if FitsIn32Bits is true, uint64_t otherwise.
-template <bool FitsIn32Bits>
-struct TypeSelector { typedef uint32_t Type; };
-
-template <>
-struct TypeSelector<false> { typedef uint64_t Type; };
-
-template <typename T>
-struct IntTraits {
-  // Smallest of uint32_t and uint64_t that is large enough to represent
-  // all values of T.
-  typedef typename
-    TypeSelector<std::numeric_limits<T>::digits <= 32>::Type MainType;
-};
-
-FMT_API FMT_NORETURN void report_unknown_type(char code, const char *type);
-
-// Static data is placed in this class template to allow header-only
-// configuration.
-template <typename T = void>
-struct FMT_API BasicData {
-  static const uint32_t POWERS_OF_10_32[];
-  static const uint64_t POWERS_OF_10_64[];
-  static const char DIGITS[];
-};
-
-#if FMT_USE_EXTERN_TEMPLATES
-extern template struct BasicData<void>;
-#endif
-
-typedef BasicData<> Data;
-
-#ifdef FMT_BUILTIN_CLZLL
-// Returns the number of decimal digits in n. Leading zeros are not counted
-// except for n == 0 in which case count_digits returns 1.
-inline unsigned count_digits(uint64_t n) {
-  // Based on http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10
-  // and the benchmark https://github.com/localvoid/cxx-benchmark-count-digits.
-  int t = (64 - FMT_BUILTIN_CLZLL(n | 1)) * 1233 >> 12;
-  return to_unsigned(t) - (n < Data::POWERS_OF_10_64[t]) + 1;
-}
-#else
-// Fallback version of count_digits used when __builtin_clz is not available.
-inline unsigned count_digits(uint64_t n) {
-  unsigned count = 1;
-  for (;;) {
-    // Integer division is slow so do it for a group of four digits instead
-    // of for every digit. The idea comes from the talk by Alexandrescu
-    // "Three Optimization Tips for C++". See speed-test for a comparison.
-    if (n < 10) return count;
-    if (n < 100) return count + 1;
-    if (n < 1000) return count + 2;
-    if (n < 10000) return count + 3;
-    n /= 10000u;
-    count += 4;
-  }
-}
-#endif
-
-#ifdef FMT_BUILTIN_CLZ
-// Optional version of count_digits for better performance on 32-bit platforms.
-inline unsigned count_digits(uint32_t n) {
-  int t = (32 - FMT_BUILTIN_CLZ(n | 1)) * 1233 >> 12;
-  return to_unsigned(t) - (n < Data::POWERS_OF_10_32[t]) + 1;
-}
-#endif
-
-// A functor that doesn't add a thousands separator.
-struct NoThousandsSep {
-  template <typename Char>
-  void operator()(Char *) {}
-};
-
-// A functor that adds a thousands separator.
-class ThousandsSep {
- private:
-  fmt::StringRef sep_;
-
-  // Index of a decimal digit with the least significant digit having index 0.
-  unsigned digit_index_;
-
- public:
-  explicit ThousandsSep(fmt::StringRef sep) : sep_(sep), digit_index_(0) {}
-
-  template <typename Char>
-  void operator()(Char *&buffer) {
-    if (++digit_index_ % 3 != 0)
-      return;
-    buffer -= sep_.size();
-    std::uninitialized_copy(sep_.data(), sep_.data() + sep_.size(),
-                            internal::make_ptr(buffer, sep_.size()));
-  }
-};
-
-// Formats a decimal unsigned integer value writing into buffer.
-// thousands_sep is a functor that is called after writing each char to
-// add a thousands separator if necessary.
-template <typename UInt, typename Char, typename ThousandsSep>
-inline void format_decimal(Char *buffer, UInt value, unsigned num_digits,
-                           ThousandsSep thousands_sep) {
-  buffer += num_digits;
-  while (value >= 100) {
-    // Integer division is slow so do it for a group of two digits instead
-    // of for every digit. The idea comes from the talk by Alexandrescu
-    // "Three Optimization Tips for C++". See speed-test for a comparison.
-    unsigned index = static_cast<unsigned>((value % 100) * 2);
-    value /= 100;
-    *--buffer = Data::DIGITS[index + 1];
-    thousands_sep(buffer);
-    *--buffer = Data::DIGITS[index];
-    thousands_sep(buffer);
-  }
-  if (value < 10) {
-    *--buffer = static_cast<char>('0' + value);
-    return;
-  }
-  unsigned index = static_cast<unsigned>(value * 2);
-  *--buffer = Data::DIGITS[index + 1];
-  thousands_sep(buffer);
-  *--buffer = Data::DIGITS[index];
-}
-
-template <typename UInt, typename Char>
-inline void format_decimal(Char *buffer, UInt value, unsigned num_digits) {
-  format_decimal(buffer, value, num_digits, NoThousandsSep());
-  return;
-}
-
-#ifndef _WIN32
-# define FMT_USE_WINDOWS_H 0
-#elif !defined(FMT_USE_WINDOWS_H)
-# define FMT_USE_WINDOWS_H 1
-#endif
-
-// Define FMT_USE_WINDOWS_H to 0 to disable use of windows.h.
-// All the functionality that relies on it will be disabled too.
-#if FMT_USE_WINDOWS_H
-// A converter from UTF-8 to UTF-16.
-// It is only provided for Windows since other systems support UTF-8 natively.
-class UTF8ToUTF16 {
- private:
-  MemoryBuffer<wchar_t, INLINE_BUFFER_SIZE> buffer_;
-
- public:
-  FMT_API explicit UTF8ToUTF16(StringRef s);
-  operator WStringRef() const { return WStringRef(&buffer_[0], size()); }
-  size_t size() const { return buffer_.size() - 1; }
-  const wchar_t *c_str() const { return &buffer_[0]; }
-  std::wstring str() const { return std::wstring(&buffer_[0], size()); }
-};
-
-// A converter from UTF-16 to UTF-8.
-// It is only provided for Windows since other systems support UTF-8 natively.
-class UTF16ToUTF8 {
- private:
-  MemoryBuffer<char, INLINE_BUFFER_SIZE> buffer_;
-
- public:
-  UTF16ToUTF8() {}
-  FMT_API explicit UTF16ToUTF8(WStringRef s);
-  operator StringRef() const { return StringRef(&buffer_[0], size()); }
-  size_t size() const { return buffer_.size() - 1; }
-  const char *c_str() const { return &buffer_[0]; }
-  std::string str() const { return std::string(&buffer_[0], size()); }
-
-  // Performs conversion returning a system error code instead of
-  // throwing exception on conversion error. This method may still throw
-  // in case of memory allocation error.
-  FMT_API int convert(WStringRef s);
-};
-
-FMT_API void format_windows_error(fmt::Writer &out, int error_code,
-                                  fmt::StringRef message) FMT_NOEXCEPT;
-#endif
-
-// A formatting argument value.
-struct Value {
-  template <typename Char>
-  struct StringValue {
-    const Char *value;
-    std::size_t size;
-  };
-
-  typedef void (*FormatFunc)(
-      void *formatter, const void *arg, void *format_str_ptr);
-
-  struct CustomValue {
-    const void *value;
-    FormatFunc format;
-  };
-
-  union {
-    int int_value;
-    unsigned uint_value;
-    LongLong long_long_value;
-    ULongLong ulong_long_value;
-    double double_value;
-    long double long_double_value;
-    const void *pointer;
-    StringValue<char> string;
-    StringValue<signed char> sstring;
-    StringValue<unsigned char> ustring;
-    StringValue<wchar_t> wstring;
-    CustomValue custom;
-  };
-
-  enum Type {
-    NONE, NAMED_ARG,
-    // Integer types should go first,
-    INT, UINT, LONG_LONG, ULONG_LONG, BOOL, CHAR, LAST_INTEGER_TYPE = CHAR,
-    // followed by floating-point types.
-    DOUBLE, LONG_DOUBLE, LAST_NUMERIC_TYPE = LONG_DOUBLE,
-    CSTRING, STRING, WSTRING, POINTER, CUSTOM
-  };
-};
-
-// A formatting argument. It is a trivially copyable/constructible type to
-// allow storage in internal::MemoryBuffer.
-struct Arg : Value {
-  Type type;
-};
-
-template <typename Char>
-struct NamedArg;
-template <typename Char, typename T>
-struct NamedArgWithType;
-
-template <typename T = void>
-struct Null {};
-
-// A helper class template to enable or disable overloads taking wide
-// characters and strings in MakeValue.
-template <typename T, typename Char>
-struct WCharHelper {
-  typedef Null<T> Supported;
-  typedef T Unsupported;
-};
-
-template <typename T>
-struct WCharHelper<T, wchar_t> {
-  typedef T Supported;
-  typedef Null<T> Unsupported;
-};
-
-typedef char Yes[1];
-typedef char No[2];
-
-template <typename T>
-T &get();
-
-// These are non-members to workaround an overload resolution bug in bcc32.
-Yes &convert(fmt::ULongLong);
-No &convert(...);
-
-template <typename T, bool ENABLE_CONVERSION>
-struct ConvertToIntImpl {
-  enum { value = ENABLE_CONVERSION };
-};
-
-template <typename T, bool ENABLE_CONVERSION>
-struct ConvertToIntImpl2 {
-  enum { value = false };
-};
-
-template <typename T>
-struct ConvertToIntImpl2<T, true> {
-  enum {
-    // Don't convert numeric types.
-    value = ConvertToIntImpl<T, !std::numeric_limits<T>::is_specialized>::value
-  };
-};
-
-template <typename T>
-struct ConvertToInt {
-  enum {
-    enable_conversion = sizeof(fmt::internal::convert(get<T>())) == sizeof(Yes)
-  };
-  enum { value = ConvertToIntImpl2<T, enable_conversion>::value };
-};
-
-#define FMT_DISABLE_CONVERSION_TO_INT(Type) \
-  template <> \
-  struct ConvertToInt<Type> {  enum { value = 0 }; }
-
-// Silence warnings about convering float to int.
-FMT_DISABLE_CONVERSION_TO_INT(float);
-FMT_DISABLE_CONVERSION_TO_INT(double);
-FMT_DISABLE_CONVERSION_TO_INT(long double);
-
-template <bool B, class T = void>
-struct EnableIf {};
-
-template <class T>
-struct EnableIf<true, T> { typedef T type; };
-
-template <bool B, class T, class F>
-struct Conditional { typedef T type; };
-
-template <class T, class F>
-struct Conditional<false, T, F> { typedef F type; };
-
-// For bcc32 which doesn't understand ! in template arguments.
-template <bool>
-struct Not { enum { value = 0 }; };
-
-template <>
-struct Not<false> { enum { value = 1 }; };
-
-template <typename T>
-struct FalseType { enum { value = 0 }; };
-
-template <typename T, T> struct LConvCheck {
-  LConvCheck(int) {}
-};
-
-// Returns the thousands separator for the current locale.
-// We check if ``lconv`` contains ``thousands_sep`` because on Android
-// ``lconv`` is stubbed as an empty struct.
-template <typename LConv>
-inline StringRef thousands_sep(
-    LConv *lc, LConvCheck<char *LConv::*, &LConv::thousands_sep> = 0) {
-  return lc->thousands_sep;
-}
-
-inline fmt::StringRef thousands_sep(...) { return ""; }
-
-#define FMT_CONCAT(a, b) a##b
-
-#if FMT_GCC_VERSION >= 303
-# define FMT_UNUSED __attribute__((unused))
-#else
-# define FMT_UNUSED
-#endif
-
-#ifndef FMT_USE_STATIC_ASSERT
-# define FMT_USE_STATIC_ASSERT 0
-#endif
-
-#if FMT_USE_STATIC_ASSERT || FMT_HAS_FEATURE(cxx_static_assert) || \
-  (FMT_GCC_VERSION >= 403 && FMT_HAS_GXX_CXX11) || _MSC_VER >= 1600
-# define FMT_STATIC_ASSERT(cond, message) static_assert(cond, message)
-#else
-# define FMT_CONCAT_(a, b) FMT_CONCAT(a, b)
-# define FMT_STATIC_ASSERT(cond, message) \
-  typedef int FMT_CONCAT_(Assert, __LINE__)[(cond) ? 1 : -1] FMT_UNUSED
-#endif
-
-template <typename Formatter>
-void format_arg(Formatter&, ...) {
-  FMT_STATIC_ASSERT(FalseType<Formatter>::value,
-                    "Cannot format argument. To enable the use of ostream "
-                    "operator<< include fmt/ostream.h. Otherwise provide "
-                    "an overload of format_arg.");
-}
-
-// Makes an Arg object from any type.
-template <typename Formatter>
-class MakeValue : public Arg {
- public:
-  typedef typename Formatter::Char Char;
-
- private:
-  // The following two methods are private to disallow formatting of
-  // arbitrary pointers. If you want to output a pointer cast it to
-  // "void *" or "const void *". In particular, this forbids formatting
-  // of "[const] volatile char *" which is printed as bool by iostreams.
-  // Do not implement!
-  template <typename T>
-  MakeValue(const T *value);
-  template <typename T>
-  MakeValue(T *value);
-
-  // The following methods are private to disallow formatting of wide
-  // characters and strings into narrow strings as in
-  //   fmt::format("{}", L"test");
-  // To fix this, use a wide format string: fmt::format(L"{}", L"test").
-#if !FMT_MSC_VER || defined(_NATIVE_WCHAR_T_DEFINED)
-  MakeValue(typename WCharHelper<wchar_t, Char>::Unsupported);
-#endif
-  MakeValue(typename WCharHelper<wchar_t *, Char>::Unsupported);
-  MakeValue(typename WCharHelper<const wchar_t *, Char>::Unsupported);
-  MakeValue(typename WCharHelper<const std::wstring &, Char>::Unsupported);
-#if FMT_HAS_STRING_VIEW
-  MakeValue(typename WCharHelper<const std::wstring_view &, Char>::Unsupported);
-#endif
-  MakeValue(typename WCharHelper<WStringRef, Char>::Unsupported);
-
-  void set_string(StringRef str) {
-    string.value = str.data();
-    string.size = str.size();
-  }
-
-  void set_string(WStringRef str) {
-    wstring.value = str.data();
-    wstring.size = str.size();
-  }
-
-  // Formats an argument of a custom type, such as a user-defined class.
-  template <typename T>
-  static void format_custom_arg(
-      void *formatter, const void *arg, void *format_str_ptr) {
-    format_arg(*static_cast<Formatter*>(formatter),
-               *static_cast<const Char**>(format_str_ptr),
-               *static_cast<const T*>(arg));
-  }
-
- public:
-  MakeValue() {}
-
-#define FMT_MAKE_VALUE_(Type, field, TYPE, rhs) \
-  MakeValue(Type value) { field = rhs; } \
-  static uint64_t type(Type) { return Arg::TYPE; }
-
-#define FMT_MAKE_VALUE(Type, field, TYPE) \
-  FMT_MAKE_VALUE_(Type, field, TYPE, value)
-
-  FMT_MAKE_VALUE(bool, int_value, BOOL)
-  FMT_MAKE_VALUE(short, int_value, INT)
-  FMT_MAKE_VALUE(unsigned short, uint_value, UINT)
-  FMT_MAKE_VALUE(int, int_value, INT)
-  FMT_MAKE_VALUE(unsigned, uint_value, UINT)
-
-  MakeValue(long value) {
-    // To minimize the number of types we need to deal with, long is
-    // translated either to int or to long long depending on its size.
-    if (const_check(sizeof(long) == sizeof(int)))
-      int_value = static_cast<int>(value);
-    else
-      long_long_value = value;
-  }
-  static uint64_t type(long) {
-    return sizeof(long) == sizeof(int) ? Arg::INT : Arg::LONG_LONG;
-  }
-
-  MakeValue(unsigned long value) {
-    if (const_check(sizeof(unsigned long) == sizeof(unsigned)))
-      uint_value = static_cast<unsigned>(value);
-    else
-      ulong_long_value = value;
-  }
-  static uint64_t type(unsigned long) {
-    return sizeof(unsigned long) == sizeof(unsigned) ?
-          Arg::UINT : Arg::ULONG_LONG;
-  }
-
-  FMT_MAKE_VALUE(LongLong, long_long_value, LONG_LONG)
-  FMT_MAKE_VALUE(ULongLong, ulong_long_value, ULONG_LONG)
-  FMT_MAKE_VALUE(float, double_value, DOUBLE)
-  FMT_MAKE_VALUE(double, double_value, DOUBLE)
-  FMT_MAKE_VALUE(long double, long_double_value, LONG_DOUBLE)
-  FMT_MAKE_VALUE(signed char, int_value, INT)
-  FMT_MAKE_VALUE(unsigned char, uint_value, UINT)
-  FMT_MAKE_VALUE(char, int_value, CHAR)
-
-#if __cplusplus >= 201103L
-  template <
-    typename T,
-    typename = typename std::enable_if<
-      std::is_enum<T>::value && ConvertToInt<T>::value>::type>
-   MakeValue(T value) { int_value = value; }
-
-  template <
-    typename T,
-    typename = typename std::enable_if<
-      std::is_enum<T>::value && ConvertToInt<T>::value>::type>
-  static uint64_t type(T) { return Arg::INT; }
-#endif
-
-#if !defined(_MSC_VER) || defined(_NATIVE_WCHAR_T_DEFINED)
-  MakeValue(typename WCharHelper<wchar_t, Char>::Supported value) {
-    int_value = value;
-  }
-  static uint64_t type(wchar_t) { return Arg::CHAR; }
-#endif
-
-#define FMT_MAKE_STR_VALUE(Type, TYPE) \
-  MakeValue(Type value) { set_string(value); } \
-  static uint64_t type(Type) { return Arg::TYPE; }
-
-  FMT_MAKE_VALUE(char *, string.value, CSTRING)
-  FMT_MAKE_VALUE(const char *, string.value, CSTRING)
-  FMT_MAKE_VALUE(signed char *, sstring.value, CSTRING)
-  FMT_MAKE_VALUE(const signed char *, sstring.value, CSTRING)
-  FMT_MAKE_VALUE(unsigned char *, ustring.value, CSTRING)
-  FMT_MAKE_VALUE(const unsigned char *, ustring.value, CSTRING)
-  FMT_MAKE_STR_VALUE(const std::string &, STRING)
-#if FMT_HAS_STRING_VIEW
-  FMT_MAKE_STR_VALUE(const std::string_view &, STRING)
-#endif
-  FMT_MAKE_STR_VALUE(StringRef, STRING)
-  FMT_MAKE_VALUE_(CStringRef, string.value, CSTRING, value.c_str())
-
-#define FMT_MAKE_WSTR_VALUE(Type, TYPE) \
-  MakeValue(typename WCharHelper<Type, Char>::Supported value) { \
-    set_string(value); \
-  } \
-  static uint64_t type(Type) { return Arg::TYPE; }
-
-  FMT_MAKE_WSTR_VALUE(wchar_t *, WSTRING)
-  FMT_MAKE_WSTR_VALUE(const wchar_t *, WSTRING)
-  FMT_MAKE_WSTR_VALUE(const std::wstring &, WSTRING)
-#if FMT_HAS_STRING_VIEW
-  FMT_MAKE_WSTR_VALUE(const std::wstring_view &, WSTRING)
-#endif
-  FMT_MAKE_WSTR_VALUE(WStringRef, WSTRING)
-
-  FMT_MAKE_VALUE(void *, pointer, POINTER)
-  FMT_MAKE_VALUE(const void *, pointer, POINTER)
-
-  template <typename T>
-  MakeValue(const T &value,
-            typename EnableIf<Not<
-              ConvertToInt<T>::value>::value, int>::type = 0) {
-    custom.value = &value;
-    custom.format = &format_custom_arg<T>;
-  }
-
-  template <typename T>
-  static typename EnableIf<Not<ConvertToInt<T>::value>::value, uint64_t>::type
-      type(const T &) {
-    return Arg::CUSTOM;
-  }
-
-  // Additional template param `Char_` is needed here because make_type always
-  // uses char.
-  template <typename Char_>
-  MakeValue(const NamedArg<Char_> &value) { pointer = &value; }
-  template <typename Char_, typename T>
-  MakeValue(const NamedArgWithType<Char_, T> &value) { pointer = &value; }
-
-  template <typename Char_>
-  static uint64_t type(const NamedArg<Char_> &) { return Arg::NAMED_ARG; }
-  template <typename Char_, typename T>
-  static uint64_t type(const NamedArgWithType<Char_, T> &) { return Arg::NAMED_ARG; }
-};
-
-template <typename Formatter>
-class MakeArg : public Arg {
-public:
-  MakeArg() {
-    type = Arg::NONE;
-  }
-
-  template <typename T>
-  MakeArg(const T &value)
-  : Arg(MakeValue<Formatter>(value)) {
-    type = static_cast<Arg::Type>(MakeValue<Formatter>::type(value));
-  }
-};
-
-template <typename Char>
-struct NamedArg : Arg {
-  BasicStringRef<Char> name;
-
-  template <typename T>
-  NamedArg(BasicStringRef<Char> argname, const T &value)
-  : Arg(MakeArg< BasicFormatter<Char> >(value)), name(argname) {}
-};
-
-template <typename Char, typename T>
-struct NamedArgWithType : NamedArg<Char> {
-  NamedArgWithType(BasicStringRef<Char> argname, const T &value)
-  : NamedArg<Char>(argname, value) {}
-};
-
-class RuntimeError : public std::runtime_error {
- protected:
-  RuntimeError() : std::runtime_error("") {}
-  RuntimeError(const RuntimeError &rerr) : std::runtime_error(rerr) {}
-  FMT_API ~RuntimeError() FMT_DTOR_NOEXCEPT FMT_OVERRIDE;
-};
-
-template <typename Char>
-class ArgMap;
-}  // namespace internal
-
-/** An argument list. */
-class ArgList {
- private:
-  // To reduce compiled code size per formatting function call, types of first
-  // MAX_PACKED_ARGS arguments are passed in the types_ field.
-  uint64_t types_;
-  union {
-    // If the number of arguments is less than MAX_PACKED_ARGS, the argument
-    // values are stored in values_, otherwise they are stored in args_.
-    // This is done to reduce compiled code size as storing larger objects
-    // may require more code (at least on x86-64) even if the same amount of
-    // data is actually copied to stack. It saves ~10% on the bloat test.
-    const internal::Value *values_;
-    const internal::Arg *args_;
-  };
-
-  internal::Arg::Type type(unsigned index) const {
-    return type(types_, index);
-  }
-
-  template <typename Char>
-  friend class internal::ArgMap;
-
- public:
-  // Maximum number of arguments with packed types.
-  enum { MAX_PACKED_ARGS = 16 };
-
-  ArgList() : types_(0) {}
-
-  ArgList(ULongLong types, const internal::Value *values)
-  : types_(types), values_(values) {}
-  ArgList(ULongLong types, const internal::Arg *args)
-  : types_(types), args_(args) {}
-
-  uint64_t types() const { return types_; }
-
-  /** Returns the argument at specified index. */
-  internal::Arg operator[](unsigned index) const {
-    using internal::Arg;
-    Arg arg;
-    bool use_values = type(MAX_PACKED_ARGS - 1) == Arg::NONE;
-    if (index < MAX_PACKED_ARGS) {
-      Arg::Type arg_type = type(index);
-      internal::Value &val = arg;
-      if (arg_type != Arg::NONE)
-        val = use_values ? values_[index] : args_[index];
-      arg.type = arg_type;
-      return arg;
-    }
-    if (use_values) {
-      // The index is greater than the number of arguments that can be stored
-      // in values, so return a "none" argument.
-      arg.type = Arg::NONE;
-      return arg;
-    }
-    for (unsigned i = MAX_PACKED_ARGS; i <= index; ++i) {
-      if (args_[i].type == Arg::NONE)
-        return args_[i];
-    }
-    return args_[index];
-  }
-
-  static internal::Arg::Type type(uint64_t types, unsigned index) {
-    unsigned shift = index * 4;
-    uint64_t mask = 0xf;
-    return static_cast<internal::Arg::Type>(
-          (types & (mask << shift)) >> shift);
-  }
-};
-
-#define FMT_DISPATCH(call) static_cast<Impl*>(this)->call
-
-/**
-  \rst
-  An argument visitor based on the `curiously recurring template pattern
-  <http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern>`_.
-
-  To use `~fmt::ArgVisitor` define a subclass that implements some or all of the
-  visit methods with the same signatures as the methods in `~fmt::ArgVisitor`,
-  for example, `~fmt::ArgVisitor::visit_int()`.
-  Pass the subclass as the *Impl* template parameter. Then calling
-  `~fmt::ArgVisitor::visit` for some argument will dispatch to a visit method
-  specific to the argument type. For example, if the argument type is
-  ``double`` then the `~fmt::ArgVisitor::visit_double()` method of a subclass
-  will be called. If the subclass doesn't contain a method with this signature,
-  then a corresponding method of `~fmt::ArgVisitor` will be called.
-
-  **Example**::
-
-    class MyArgVisitor : public fmt::ArgVisitor<MyArgVisitor, void> {
-     public:
-      void visit_int(int value) { fmt::print("{}", value); }
-      void visit_double(double value) { fmt::print("{}", value ); }
-    };
-  \endrst
- */
-template <typename Impl, typename Result>
-class ArgVisitor {
- private:
-  typedef internal::Arg Arg;
-
- public:
-  void report_unhandled_arg() {}
-
-  Result visit_unhandled_arg() {
-    FMT_DISPATCH(report_unhandled_arg());
-    return Result();
-  }
-
-  /** Visits an ``int`` argument. **/
-  Result visit_int(int value) {
-    return FMT_DISPATCH(visit_any_int(value));
-  }
-
-  /** Visits a ``long long`` argument. **/
-  Result visit_long_long(LongLong value) {
-    return FMT_DISPATCH(visit_any_int(value));
-  }
-
-  /** Visits an ``unsigned`` argument. **/
-  Result visit_uint(unsigned value) {
-    return FMT_DISPATCH(visit_any_int(value));
-  }
-
-  /** Visits an ``unsigned long long`` argument. **/
-  Result visit_ulong_long(ULongLong value) {
-    return FMT_DISPATCH(visit_any_int(value));
-  }
-
-  /** Visits a ``bool`` argument. **/
-  Result visit_bool(bool value) {
-    return FMT_DISPATCH(visit_any_int(value));
-  }
-
-  /** Visits a ``char`` or ``wchar_t`` argument. **/
-  Result visit_char(int value) {
-    return FMT_DISPATCH(visit_any_int(value));
-  }
-
-  /** Visits an argument of any integral type. **/
-  template <typename T>
-  Result visit_any_int(T) {
-    return FMT_DISPATCH(visit_unhandled_arg());
-  }
-
-  /** Visits a ``double`` argument. **/
-  Result visit_double(double value) {
-    return FMT_DISPATCH(visit_any_double(value));
-  }
-
-  /** Visits a ``long double`` argument. **/
-  Result visit_long_double(long double value) {
-    return FMT_DISPATCH(visit_any_double(value));
-  }
-
-  /** Visits a ``double`` or ``long double`` argument. **/
-  template <typename T>
-  Result visit_any_double(T) {
-    return FMT_DISPATCH(visit_unhandled_arg());
-  }
-
-  /** Visits a null-terminated C string (``const char *``) argument. **/
-  Result visit_cstring(const char *) {
-    return FMT_DISPATCH(visit_unhandled_arg());
-  }
-
-  /** Visits a string argument. **/
-  Result visit_string(Arg::StringValue<char>) {
-    return FMT_DISPATCH(visit_unhandled_arg());
-  }
-
-  /** Visits a wide string argument. **/
-  Result visit_wstring(Arg::StringValue<wchar_t>) {
-    return FMT_DISPATCH(visit_unhandled_arg());
-  }
-
-  /** Visits a pointer argument. **/
-  Result visit_pointer(const void *) {
-    return FMT_DISPATCH(visit_unhandled_arg());
-  }
-
-  /** Visits an argument of a custom (user-defined) type. **/
-  Result visit_custom(Arg::CustomValue) {
-    return FMT_DISPATCH(visit_unhandled_arg());
-  }
-
-  /**
-    \rst
-    Visits an argument dispatching to the appropriate visit method based on
-    the argument type. For example, if the argument type is ``double`` then
-    the `~fmt::ArgVisitor::visit_double()` method of the *Impl* class will be
-    called.
-    \endrst
-   */
-  Result visit(const Arg &arg) {
-    switch (arg.type) {
-    case Arg::NONE:
-    case Arg::NAMED_ARG:
-      FMT_ASSERT(false, "invalid argument type");
-      break;
-    case Arg::INT:
-      return FMT_DISPATCH(visit_int(arg.int_value));
-    case Arg::UINT:
-      return FMT_DISPATCH(visit_uint(arg.uint_value));
-    case Arg::LONG_LONG:
-      return FMT_DISPATCH(visit_long_long(arg.long_long_value));
-    case Arg::ULONG_LONG:
-      return FMT_DISPATCH(visit_ulong_long(arg.ulong_long_value));
-    case Arg::BOOL:
-      return FMT_DISPATCH(visit_bool(arg.int_value != 0));
-    case Arg::CHAR:
-      return FMT_DISPATCH(visit_char(arg.int_value));
-    case Arg::DOUBLE:
-      return FMT_DISPATCH(visit_double(arg.double_value));
-    case Arg::LONG_DOUBLE:
-      return FMT_DISPATCH(visit_long_double(arg.long_double_value));
-    case Arg::CSTRING:
-      return FMT_DISPATCH(visit_cstring(arg.string.value));
-    case Arg::STRING:
-      return FMT_DISPATCH(visit_string(arg.string));
-    case Arg::WSTRING:
-      return FMT_DISPATCH(visit_wstring(arg.wstring));
-    case Arg::POINTER:
-      return FMT_DISPATCH(visit_pointer(arg.pointer));
-    case Arg::CUSTOM:
-      return FMT_DISPATCH(visit_custom(arg.custom));
-    }
-    return Result();
-  }
-};
-
-enum Alignment {
-  ALIGN_DEFAULT, ALIGN_LEFT, ALIGN_RIGHT, ALIGN_CENTER, ALIGN_NUMERIC
-};
-
-// Flags.
-enum {
-  SIGN_FLAG = 1, PLUS_FLAG = 2, MINUS_FLAG = 4, HASH_FLAG = 8,
-  CHAR_FLAG = 0x10  // Argument has char type - used in error reporting.
-};
-
-// An empty format specifier.
-struct EmptySpec {};
-
-// A type specifier.
-template <char TYPE>
-struct TypeSpec : EmptySpec {
-  Alignment align() const { return ALIGN_DEFAULT; }
-  unsigned width() const { return 0; }
-  int precision() const { return -1; }
-  bool flag(unsigned) const { return false; }
-  char type() const { return TYPE; }
-  char type_prefix() const { return TYPE; }
-  char fill() const { return ' '; }
-};
-
-// A width specifier.
-struct WidthSpec {
-  unsigned width_;
-  // Fill is always wchar_t and cast to char if necessary to avoid having
-  // two specialization of WidthSpec and its subclasses.
-  wchar_t fill_;
-
-  WidthSpec(unsigned width, wchar_t fill) : width_(width), fill_(fill) {}
-
-  unsigned width() const { return width_; }
-  wchar_t fill() const { return fill_; }
-};
-
-// An alignment specifier.
-struct AlignSpec : WidthSpec {
-  Alignment align_;
-
-  AlignSpec(unsigned width, wchar_t fill, Alignment align = ALIGN_DEFAULT)
-  : WidthSpec(width, fill), align_(align) {}
-
-  Alignment align() const { return align_; }
-
-  int precision() const { return -1; }
-};
-
-// An alignment and type specifier.
-template <char TYPE>
-struct AlignTypeSpec : AlignSpec {
-  AlignTypeSpec(unsigned width, wchar_t fill) : AlignSpec(width, fill) {}
-
-  bool flag(unsigned) const { return false; }
-  char type() const { return TYPE; }
-  char type_prefix() const { return TYPE; }
-};
-
-// A full format specifier.
-struct FormatSpec : AlignSpec {
-  unsigned flags_;
-  int precision_;
-  char type_;
-
-  FormatSpec(
-    unsigned width = 0, char type = 0, wchar_t fill = ' ')
-  : AlignSpec(width, fill), flags_(0), precision_(-1), type_(type) {}
-
-  bool flag(unsigned f) const { return (flags_ & f) != 0; }
-  int precision() const { return precision_; }
-  char type() const { return type_; }
-  char type_prefix() const { return type_; }
-};
-
-// An integer format specifier.
-template <typename T, typename SpecT = TypeSpec<0>, typename Char = char>
-class IntFormatSpec : public SpecT {
- private:
-  T value_;
-
- public:
-  IntFormatSpec(T val, const SpecT &spec = SpecT())
-  : SpecT(spec), value_(val) {}
-
-  T value() const { return value_; }
-};
-
-// A string format specifier.
-template <typename Char>
-class StrFormatSpec : public AlignSpec {
- private:
-  const Char *str_;
-
- public:
-  template <typename FillChar>
-  StrFormatSpec(const Char *str, unsigned width, FillChar fill)
-  : AlignSpec(width, fill), str_(str) {
-    internal::CharTraits<Char>::convert(FillChar());
-  }
-
-  const Char *str() const { return str_; }
-};
-
-/**
-  Returns an integer format specifier to format the value in base 2.
- */
-IntFormatSpec<int, TypeSpec<'b'> > bin(int value);
-
-/**
-  Returns an integer format specifier to format the value in base 8.
- */
-IntFormatSpec<int, TypeSpec<'o'> > oct(int value);
-
-/**
-  Returns an integer format specifier to format the value in base 16 using
-  lower-case letters for the digits above 9.
- */
-IntFormatSpec<int, TypeSpec<'x'> > hex(int value);
-
-/**
-  Returns an integer formatter format specifier to format in base 16 using
-  upper-case letters for the digits above 9.
- */
-IntFormatSpec<int, TypeSpec<'X'> > hexu(int value);
-
-/**
-  \rst
-  Returns an integer format specifier to pad the formatted argument with the
-  fill character to the specified width using the default (right) numeric
-  alignment.
-
-  **Example**::
-
-    MemoryWriter out;
-    out << pad(hex(0xcafe), 8, '0');
-    // out.str() == "0000cafe"
-
-  \endrst
- */
-template <char TYPE_CODE, typename Char>
-IntFormatSpec<int, AlignTypeSpec<TYPE_CODE>, Char> pad(
-    int value, unsigned width, Char fill = ' ');
-
-#define FMT_DEFINE_INT_FORMATTERS(TYPE) \
-inline IntFormatSpec<TYPE, TypeSpec<'b'> > bin(TYPE value) { \
-  return IntFormatSpec<TYPE, TypeSpec<'b'> >(value, TypeSpec<'b'>()); \
-} \
- \
-inline IntFormatSpec<TYPE, TypeSpec<'o'> > oct(TYPE value) { \
-  return IntFormatSpec<TYPE, TypeSpec<'o'> >(value, TypeSpec<'o'>()); \
-} \
- \
-inline IntFormatSpec<TYPE, TypeSpec<'x'> > hex(TYPE value) { \
-  return IntFormatSpec<TYPE, TypeSpec<'x'> >(value, TypeSpec<'x'>()); \
-} \
- \
-inline IntFormatSpec<TYPE, TypeSpec<'X'> > hexu(TYPE value) { \
-  return IntFormatSpec<TYPE, TypeSpec<'X'> >(value, TypeSpec<'X'>()); \
-} \
- \
-template <char TYPE_CODE> \
-inline IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE> > pad( \
-    IntFormatSpec<TYPE, TypeSpec<TYPE_CODE> > f, unsigned width) { \
-  return IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE> >( \
-      f.value(), AlignTypeSpec<TYPE_CODE>(width, ' ')); \
-} \
- \
-/* For compatibility with older compilers we provide two overloads for pad, */ \
-/* one that takes a fill character and one that doesn't. In the future this */ \
-/* can be replaced with one overload making the template argument Char      */ \
-/* default to char (C++11). */ \
-template <char TYPE_CODE, typename Char> \
-inline IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE>, Char> pad( \
-    IntFormatSpec<TYPE, TypeSpec<TYPE_CODE>, Char> f, \
-    unsigned width, Char fill) { \
-  return IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE>, Char>( \
-      f.value(), AlignTypeSpec<TYPE_CODE>(width, fill)); \
-} \
- \
-inline IntFormatSpec<TYPE, AlignTypeSpec<0> > pad( \
-    TYPE value, unsigned width) { \
-  return IntFormatSpec<TYPE, AlignTypeSpec<0> >( \
-      value, AlignTypeSpec<0>(width, ' ')); \
-} \
- \
-template <typename Char> \
-inline IntFormatSpec<TYPE, AlignTypeSpec<0>, Char> pad( \
-   TYPE value, unsigned width, Char fill) { \
- return IntFormatSpec<TYPE, AlignTypeSpec<0>, Char>( \
-     value, AlignTypeSpec<0>(width, fill)); \
-}
-
-FMT_DEFINE_INT_FORMATTERS(int)
-FMT_DEFINE_INT_FORMATTERS(long)
-FMT_DEFINE_INT_FORMATTERS(unsigned)
-FMT_DEFINE_INT_FORMATTERS(unsigned long)
-FMT_DEFINE_INT_FORMATTERS(LongLong)
-FMT_DEFINE_INT_FORMATTERS(ULongLong)
-
-/**
-  \rst
-  Returns a string formatter that pads the formatted argument with the fill
-  character to the specified width using the default (left) string alignment.
-
-  **Example**::
-
-    std::string s = str(MemoryWriter() << pad("abc", 8));
-    // s == "abc     "
-
-  \endrst
- */
-template <typename Char>
-inline StrFormatSpec<Char> pad(
-    const Char *str, unsigned width, Char fill = ' ') {
-  return StrFormatSpec<Char>(str, width, fill);
-}
-
-inline StrFormatSpec<wchar_t> pad(
-    const wchar_t *str, unsigned width, char fill = ' ') {
-  return StrFormatSpec<wchar_t>(str, width, fill);
-}
-
-namespace internal {
-
-template <typename Char>
-class ArgMap {
- private:
-  typedef std::vector<
-    std::pair<fmt::BasicStringRef<Char>, internal::Arg> > MapType;
-  typedef typename MapType::value_type Pair;
-
-  MapType map_;
-
- public:
-  void init(const ArgList &args);
-
-  const internal::Arg *find(const fmt::BasicStringRef<Char> &name) const {
-    // The list is unsorted, so just return the first matching name.
-    for (typename MapType::const_iterator it = map_.begin(), end = map_.end();
-         it != end; ++it) {
-      if (it->first == name)
-        return &it->second;
-    }
-    return FMT_NULL;
-  }
-};
-
-template <typename Char>
-void ArgMap<Char>::init(const ArgList &args) {
-  if (!map_.empty())
-    return;
-  typedef internal::NamedArg<Char> NamedArg;
-  const NamedArg *named_arg = FMT_NULL;
-  bool use_values =
-      args.type(ArgList::MAX_PACKED_ARGS - 1) == internal::Arg::NONE;
-  if (use_values) {
-    for (unsigned i = 0;/*nothing*/; ++i) {
-      internal::Arg::Type arg_type = args.type(i);
-      switch (arg_type) {
-      case internal::Arg::NONE:
-        return;
-      case internal::Arg::NAMED_ARG:
-        named_arg = static_cast<const NamedArg*>(args.values_[i].pointer);
-        map_.push_back(Pair(named_arg->name, *named_arg));
-        break;
-      default:
-        /*nothing*/;
-      }
-    }
-    return;
-  }
-  for (unsigned i = 0; i != ArgList::MAX_PACKED_ARGS; ++i) {
-    internal::Arg::Type arg_type = args.type(i);
-    if (arg_type == internal::Arg::NAMED_ARG) {
-      named_arg = static_cast<const NamedArg*>(args.args_[i].pointer);
-      map_.push_back(Pair(named_arg->name, *named_arg));
-    }
-  }
-  for (unsigned i = ArgList::MAX_PACKED_ARGS;/*nothing*/; ++i) {
-    switch (args.args_[i].type) {
-    case internal::Arg::NONE:
-      return;
-    case internal::Arg::NAMED_ARG:
-      named_arg = static_cast<const NamedArg*>(args.args_[i].pointer);
-      map_.push_back(Pair(named_arg->name, *named_arg));
-      break;
-    default:
-      /*nothing*/;
-    }
-  }
-}
-
-template <typename Impl, typename Char, typename Spec = fmt::FormatSpec>
-class ArgFormatterBase : public ArgVisitor<Impl, void> {
- private:
-  BasicWriter<Char> &writer_;
-  Spec &spec_;
-
-  FMT_DISALLOW_COPY_AND_ASSIGN(ArgFormatterBase);
-
-  void write_pointer(const void *p) {
-    spec_.flags_ = HASH_FLAG;
-    spec_.type_ = 'x';
-    writer_.write_int(reinterpret_cast<uintptr_t>(p), spec_);
-  }
-
-  // workaround MSVC two-phase lookup issue
-  typedef internal::Arg Arg;
-
- protected:
-  BasicWriter<Char> &writer() { return writer_; }
-  Spec &spec() { return spec_; }
-
-  void write(bool value) {
-    const char *str_value = value ? "true" : "false";
-    Arg::StringValue<char> str = { str_value, std::strlen(str_value) };
-    writer_.write_str(str, spec_);
-  }
-
-  void write(const char *value) {
-    Arg::StringValue<char> str = {value, value ? std::strlen(value) : 0};
-    writer_.write_str(str, spec_);
-  }
-
- public:
-  typedef Spec SpecType;
-
-  ArgFormatterBase(BasicWriter<Char> &w, Spec &s)
-  : writer_(w), spec_(s) {}
-
-  template <typename T>
-  void visit_any_int(T value) { writer_.write_int(value, spec_); }
-
-  template <typename T>
-  void visit_any_double(T value) { writer_.write_double(value, spec_); }
-
-  void visit_bool(bool value) {
-    if (spec_.type_) {
-      visit_any_int(value);
-      return;
-    }
-    write(value);
-  }
-
-  void visit_char(int value) {
-    if (spec_.type_ && spec_.type_ != 'c') {
-      spec_.flags_ |= CHAR_FLAG;
-      writer_.write_int(value, spec_);
-      return;
-    }
-    if (spec_.align_ == ALIGN_NUMERIC || spec_.flags_ != 0)
-      FMT_THROW(FormatError("invalid format specifier for char"));
-    typedef typename BasicWriter<Char>::CharPtr CharPtr;
-    Char fill = internal::CharTraits<Char>::cast(spec_.fill());
-    CharPtr out = CharPtr();
-    const unsigned CHAR_SIZE = 1;
-    if (spec_.width_ > CHAR_SIZE) {
-      out = writer_.grow_buffer(spec_.width_);
-      if (spec_.align_ == ALIGN_RIGHT) {
-        std::uninitialized_fill_n(out, spec_.width_ - CHAR_SIZE, fill);
-        out += spec_.width_ - CHAR_SIZE;
-      } else if (spec_.align_ == ALIGN_CENTER) {
-        out = writer_.fill_padding(out, spec_.width_,
-                                   internal::const_check(CHAR_SIZE), fill);
-      } else {
-        std::uninitialized_fill_n(out + CHAR_SIZE,
-                                  spec_.width_ - CHAR_SIZE, fill);
-      }
-    } else {
-      out = writer_.grow_buffer(CHAR_SIZE);
-    }
-    *out = internal::CharTraits<Char>::cast(value);
-  }
-
-  void visit_cstring(const char *value) {
-    if (spec_.type_ == 'p')
-      return write_pointer(value);
-    write(value);
-  }
-
-  // Qualification with "internal" here and below is a workaround for nvcc.
-  void visit_string(internal::Arg::StringValue<char> value) {
-    writer_.write_str(value, spec_);
-  }
-
-  using ArgVisitor<Impl, void>::visit_wstring;
-
-  void visit_wstring(internal::Arg::StringValue<Char> value) {
-    writer_.write_str(value, spec_);
-  }
-
-  void visit_pointer(const void *value) {
-    if (spec_.type_ && spec_.type_ != 'p')
-      report_unknown_type(spec_.type_, "pointer");
-    write_pointer(value);
-  }
-};
-
-class FormatterBase {
- private:
-  ArgList args_;
-  int next_arg_index_;
-
-  // Returns the argument with specified index.
-  FMT_API Arg do_get_arg(unsigned arg_index, const char *&error);
-
- protected:
-  const ArgList &args() const { return args_; }
-
-  explicit FormatterBase(const ArgList &args) {
-    args_ = args;
-    next_arg_index_ = 0;
-  }
-
-  // Returns the next argument.
-  Arg next_arg(const char *&error) {
-    if (next_arg_index_ >= 0)
-      return do_get_arg(internal::to_unsigned(next_arg_index_++), error);
-    error = "cannot switch from manual to automatic argument indexing";
-    return Arg();
-  }
-
-  // Checks if manual indexing is used and returns the argument with
-  // specified index.
-  Arg get_arg(unsigned arg_index, const char *&error) {
-    return check_no_auto_index(error) ? do_get_arg(arg_index, error) : Arg();
-  }
-
-  bool check_no_auto_index(const char *&error) {
-    if (next_arg_index_ > 0) {
-      error = "cannot switch from automatic to manual argument indexing";
-      return false;
-    }
-    next_arg_index_ = -1;
-    return true;
-  }
-
-  template <typename Char>
-  void write(BasicWriter<Char> &w, const Char *start, const Char *end) {
-    if (start != end)
-      w << BasicStringRef<Char>(start, internal::to_unsigned(end - start));
-  }
-};
-}  // namespace internal
-
-/**
-  \rst
-  An argument formatter based on the `curiously recurring template pattern
-  <http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern>`_.
-
-  To use `~fmt::BasicArgFormatter` define a subclass that implements some or
-  all of the visit methods with the same signatures as the methods in
-  `~fmt::ArgVisitor`, for example, `~fmt::ArgVisitor::visit_int()`.
-  Pass the subclass as the *Impl* template parameter. When a formatting
-  function processes an argument, it will dispatch to a visit method
-  specific to the argument type. For example, if the argument type is
-  ``double`` then the `~fmt::ArgVisitor::visit_double()` method of a subclass
-  will be called. If the subclass doesn't contain a method with this signature,
-  then a corresponding method of `~fmt::BasicArgFormatter` or its superclass
-  will be called.
-  \endrst
- */
-template <typename Impl, typename Char, typename Spec = fmt::FormatSpec>
-class BasicArgFormatter : public internal::ArgFormatterBase<Impl, Char, Spec> {
- private:
-  BasicFormatter<Char, Impl> &formatter_;
-  const Char *format_;
-
- public:
-  /**
-    \rst
-    Constructs an argument formatter object.
-    *formatter* is a reference to the main formatter object, *spec* contains
-    format specifier information for standard argument types, and *fmt* points
-    to the part of the format string being parsed for custom argument types.
-    \endrst
-   */
-  BasicArgFormatter(BasicFormatter<Char, Impl> &formatter,
-                    Spec &spec, const Char *fmt)
-  : internal::ArgFormatterBase<Impl, Char, Spec>(formatter.writer(), spec),
-    formatter_(formatter), format_(fmt) {}
-
-  /** Formats an argument of a custom (user-defined) type. */
-  void visit_custom(internal::Arg::CustomValue c) {
-    c.format(&formatter_, c.value, &format_);
-  }
-};
-
-/** The default argument formatter. */
-template <typename Char>
-class ArgFormatter :
-    public BasicArgFormatter<ArgFormatter<Char>, Char, FormatSpec> {
- public:
-  /** Constructs an argument formatter object. */
-  ArgFormatter(BasicFormatter<Char> &formatter,
-               FormatSpec &spec, const Char *fmt)
-  : BasicArgFormatter<ArgFormatter<Char>,
-                      Char, FormatSpec>(formatter, spec, fmt) {}
-};
-
-/** This template formats data and writes the output to a writer. */
-template <typename CharType, typename ArgFormatter>
-class BasicFormatter : private internal::FormatterBase {
- public:
-  /** The character type for the output. */
-  typedef CharType Char;
-
- private:
-  BasicWriter<Char> &writer_;
-  internal::ArgMap<Char> map_;
-
-  FMT_DISALLOW_COPY_AND_ASSIGN(BasicFormatter);
-
-  using internal::FormatterBase::get_arg;
-
-  // Checks if manual indexing is used and returns the argument with
-  // specified name.
-  internal::Arg get_arg(BasicStringRef<Char> arg_name, const char *&error);
-
-  // Parses argument index and returns corresponding argument.
-  internal::Arg parse_arg_index(const Char *&s);
-
-  // Parses argument name and returns corresponding argument.
-  internal::Arg parse_arg_name(const Char *&s);
-
- public:
-  /**
-   \rst
-   Constructs a ``BasicFormatter`` object. References to the arguments and
-   the writer are stored in the formatter object so make sure they have
-   appropriate lifetimes.
-   \endrst
-   */
-  BasicFormatter(const ArgList &args, BasicWriter<Char> &w)
-    : internal::FormatterBase(args), writer_(w) {}
-
-  /** Returns a reference to the writer associated with this formatter. */
-  BasicWriter<Char> &writer() { return writer_; }
-
-  /** Formats stored arguments and writes the output to the writer. */
-  void format(BasicCStringRef<Char> format_str);
-
-  // Formats a single argument and advances format_str, a format string pointer.
-  const Char *format(const Char *&format_str, const internal::Arg &arg);
-};
-
-// Generates a comma-separated list with results of applying f to
-// numbers 0..n-1.
-# define FMT_GEN(n, f) FMT_GEN##n(f)
-# define FMT_GEN1(f)  f(0)
-# define FMT_GEN2(f)  FMT_GEN1(f),  f(1)
-# define FMT_GEN3(f)  FMT_GEN2(f),  f(2)
-# define FMT_GEN4(f)  FMT_GEN3(f),  f(3)
-# define FMT_GEN5(f)  FMT_GEN4(f),  f(4)
-# define FMT_GEN6(f)  FMT_GEN5(f),  f(5)
-# define FMT_GEN7(f)  FMT_GEN6(f),  f(6)
-# define FMT_GEN8(f)  FMT_GEN7(f),  f(7)
-# define FMT_GEN9(f)  FMT_GEN8(f),  f(8)
-# define FMT_GEN10(f) FMT_GEN9(f),  f(9)
-# define FMT_GEN11(f) FMT_GEN10(f), f(10)
-# define FMT_GEN12(f) FMT_GEN11(f), f(11)
-# define FMT_GEN13(f) FMT_GEN12(f), f(12)
-# define FMT_GEN14(f) FMT_GEN13(f), f(13)
-# define FMT_GEN15(f) FMT_GEN14(f), f(14)
-
-namespace internal {
-inline uint64_t make_type() { return 0; }
-
-template <typename T>
-inline uint64_t make_type(const T &arg) {
-  return MakeValue< BasicFormatter<char> >::type(arg);
-}
-
-template <std::size_t N, bool/*IsPacked*/= (N < ArgList::MAX_PACKED_ARGS)>
-struct ArgArray;
-
-template <std::size_t N>
-struct ArgArray<N, true/*IsPacked*/> {
-  // '+' is used to silence GCC -Wduplicated-branches warning.
-  typedef Value Type[N > 0 ? N : +1];
-
-  template <typename Formatter, typename T>
-  static Value make(const T &value) {
-#ifdef __clang__
-    Value result = MakeValue<Formatter>(value);
-    // Workaround a bug in Apple LLVM version 4.2 (clang-425.0.28) of clang:
-    // https://github.com/fmtlib/fmt/issues/276
-    (void)result.custom.format;
-    return result;
-#else
-    return MakeValue<Formatter>(value);
-#endif
-  }
-};
-
-template <std::size_t N>
-struct ArgArray<N, false/*IsPacked*/> {
-  typedef Arg Type[N + 1]; // +1 for the list end Arg::NONE
-
-  template <typename Formatter, typename T>
-  static Arg make(const T &value) { return MakeArg<Formatter>(value); }
-};
-
-#if FMT_USE_VARIADIC_TEMPLATES
-template <typename Arg, typename... Args>
-inline uint64_t make_type(const Arg &first, const Args & ... tail) {
-  return make_type(first) | (make_type(tail...) << 4);
-}
-
-#else
-
-struct ArgType {
-  uint64_t type;
-
-  ArgType() : type(0) {}
-
-  template <typename T>
-  ArgType(const T &arg) : type(make_type(arg)) {}
-};
-
-# define FMT_ARG_TYPE_DEFAULT(n) ArgType t##n = ArgType()
-
-inline uint64_t make_type(FMT_GEN15(FMT_ARG_TYPE_DEFAULT)) {
-  return t0.type | (t1.type << 4) | (t2.type << 8) | (t3.type << 12) |
-      (t4.type << 16) | (t5.type << 20) | (t6.type << 24) | (t7.type << 28) |
-      (t8.type << 32) | (t9.type << 36) | (t10.type << 40) | (t11.type << 44) |
-      (t12.type << 48) | (t13.type << 52) | (t14.type << 56);
-}
-#endif
-}  // namespace internal
-
-# define FMT_MAKE_TEMPLATE_ARG(n) typename T##n
-# define FMT_MAKE_ARG_TYPE(n) T##n
-# define FMT_MAKE_ARG(n) const T##n &v##n
-# define FMT_ASSIGN_char(n) \
-  arr[n] = fmt::internal::MakeValue< fmt::BasicFormatter<char> >(v##n)
-# define FMT_ASSIGN_wchar_t(n) \
-  arr[n] = fmt::internal::MakeValue< fmt::BasicFormatter<wchar_t> >(v##n)
-
-#if FMT_USE_VARIADIC_TEMPLATES
-// Defines a variadic function returning void.
-# define FMT_VARIADIC_VOID(func, arg_type) \
-  template <typename... Args> \
-  void func(arg_type arg0, const Args & ... args) { \
-    typedef fmt::internal::ArgArray<sizeof...(Args)> ArgArray; \
-    typename ArgArray::Type array{ \
-      ArgArray::template make<fmt::BasicFormatter<Char> >(args)...}; \
-    func(arg0, fmt::ArgList(fmt::internal::make_type(args...), array)); \
-  }
-
-// Defines a variadic constructor.
-# define FMT_VARIADIC_CTOR(ctor, func, arg0_type, arg1_type) \
-  template <typename... Args> \
-  ctor(arg0_type arg0, arg1_type arg1, const Args & ... args) { \
-    typedef fmt::internal::ArgArray<sizeof...(Args)> ArgArray; \
-    typename ArgArray::Type array{ \
-      ArgArray::template make<fmt::BasicFormatter<Char> >(args)...}; \
-    func(arg0, arg1, fmt::ArgList(fmt::internal::make_type(args...), array)); \
-  }
-
-#else
-
-# define FMT_MAKE_REF(n) \
-  fmt::internal::MakeValue< fmt::BasicFormatter<Char> >(v##n)
-# define FMT_MAKE_REF2(n) v##n
-
-// Defines a wrapper for a function taking one argument of type arg_type
-// and n additional arguments of arbitrary types.
-# define FMT_WRAP1(func, arg_type, n) \
-  template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \
-  inline void func(arg_type arg1, FMT_GEN(n, FMT_MAKE_ARG)) { \
-    const fmt::internal::ArgArray<n>::Type array = {FMT_GEN(n, FMT_MAKE_REF)}; \
-    func(arg1, fmt::ArgList( \
-      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), array)); \
-  }
-
-// Emulates a variadic function returning void on a pre-C++11 compiler.
-# define FMT_VARIADIC_VOID(func, arg_type) \
-  inline void func(arg_type arg) { func(arg, fmt::ArgList()); } \
-  FMT_WRAP1(func, arg_type, 1) FMT_WRAP1(func, arg_type, 2) \
-  FMT_WRAP1(func, arg_type, 3) FMT_WRAP1(func, arg_type, 4) \
-  FMT_WRAP1(func, arg_type, 5) FMT_WRAP1(func, arg_type, 6) \
-  FMT_WRAP1(func, arg_type, 7) FMT_WRAP1(func, arg_type, 8) \
-  FMT_WRAP1(func, arg_type, 9) FMT_WRAP1(func, arg_type, 10)
-
-# define FMT_CTOR(ctor, func, arg0_type, arg1_type, n) \
-  template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \
-  ctor(arg0_type arg0, arg1_type arg1, FMT_GEN(n, FMT_MAKE_ARG)) { \
-    const fmt::internal::ArgArray<n>::Type array = {FMT_GEN(n, FMT_MAKE_REF)}; \
-    func(arg0, arg1, fmt::ArgList( \
-      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), array)); \
-  }
-
-// Emulates a variadic constructor on a pre-C++11 compiler.
-# define FMT_VARIADIC_CTOR(ctor, func, arg0_type, arg1_type) \
-  FMT_CTOR(ctor, func, arg0_type, arg1_type, 1) \
-  FMT_CTOR(ctor, func, arg0_type, arg1_type, 2) \
-  FMT_CTOR(ctor, func, arg0_type, arg1_type, 3) \
-  FMT_CTOR(ctor, func, arg0_type, arg1_type, 4) \
-  FMT_CTOR(ctor, func, arg0_type, arg1_type, 5) \
-  FMT_CTOR(ctor, func, arg0_type, arg1_type, 6) \
-  FMT_CTOR(ctor, func, arg0_type, arg1_type, 7) \
-  FMT_CTOR(ctor, func, arg0_type, arg1_type, 8) \
-  FMT_CTOR(ctor, func, arg0_type, arg1_type, 9) \
-  FMT_CTOR(ctor, func, arg0_type, arg1_type, 10)
-#endif
-
-// Generates a comma-separated list with results of applying f to pairs
-// (argument, index).
-#define FMT_FOR_EACH1(f, x0) f(x0, 0)
-#define FMT_FOR_EACH2(f, x0, x1) \
-  FMT_FOR_EACH1(f, x0), f(x1, 1)
-#define FMT_FOR_EACH3(f, x0, x1, x2) \
-  FMT_FOR_EACH2(f, x0 ,x1), f(x2, 2)
-#define FMT_FOR_EACH4(f, x0, x1, x2, x3) \
-  FMT_FOR_EACH3(f, x0, x1, x2), f(x3, 3)
-#define FMT_FOR_EACH5(f, x0, x1, x2, x3, x4) \
-  FMT_FOR_EACH4(f, x0, x1, x2, x3), f(x4, 4)
-#define FMT_FOR_EACH6(f, x0, x1, x2, x3, x4, x5) \
-  FMT_FOR_EACH5(f, x0, x1, x2, x3, x4), f(x5, 5)
-#define FMT_FOR_EACH7(f, x0, x1, x2, x3, x4, x5, x6) \
-  FMT_FOR_EACH6(f, x0, x1, x2, x3, x4, x5), f(x6, 6)
-#define FMT_FOR_EACH8(f, x0, x1, x2, x3, x4, x5, x6, x7) \
-  FMT_FOR_EACH7(f, x0, x1, x2, x3, x4, x5, x6), f(x7, 7)
-#define FMT_FOR_EACH9(f, x0, x1, x2, x3, x4, x5, x6, x7, x8) \
-  FMT_FOR_EACH8(f, x0, x1, x2, x3, x4, x5, x6, x7), f(x8, 8)
-#define FMT_FOR_EACH10(f, x0, x1, x2, x3, x4, x5, x6, x7, x8, x9) \
-  FMT_FOR_EACH9(f, x0, x1, x2, x3, x4, x5, x6, x7, x8), f(x9, 9)
-
-/**
- An error returned by an operating system or a language runtime,
- for example a file opening error.
-*/
-class SystemError : public internal::RuntimeError {
- private:
-  FMT_API void init(int err_code, CStringRef format_str, ArgList args);
-
- protected:
-  int error_code_;
-
-  typedef char Char;  // For FMT_VARIADIC_CTOR.
-
-  SystemError() {}
-
- public:
-  /**
-   \rst
-   Constructs a :class:`fmt::SystemError` object with a description
-   formatted with `fmt::format_system_error`. *message* and additional
-   arguments passed into the constructor are formatted similarly to
-   `fmt::format`.
-
-   **Example**::
-
-     // This throws a SystemError with the description
-     //   cannot open file 'madeup': No such file or directory
-     // or similar (system message may vary).
-     const char *filename = "madeup";
-     std::FILE *file = std::fopen(filename, "r");
-     if (!file)
-       throw fmt::SystemError(errno, "cannot open file '{}'", filename);
-   \endrst
-  */
-  SystemError(int error_code, CStringRef message) {
-    init(error_code, message, ArgList());
-  }
-  FMT_DEFAULTED_COPY_CTOR(SystemError)
-  FMT_VARIADIC_CTOR(SystemError, init, int, CStringRef)
-
-  FMT_API ~SystemError() FMT_DTOR_NOEXCEPT FMT_OVERRIDE;
-
-  int error_code() const { return error_code_; }
-};
-
-/**
-  \rst
-  Formats an error returned by an operating system or a language runtime,
-  for example a file opening error, and writes it to *out* in the following
-  form:
-
-  .. parsed-literal::
-     *<message>*: *<system-message>*
-
-  where *<message>* is the passed message and *<system-message>* is
-  the system message corresponding to the error code.
-  *error_code* is a system error code as given by ``errno``.
-  If *error_code* is not a valid error code such as -1, the system message
-  may look like "Unknown error -1" and is platform-dependent.
-  \endrst
- */
-FMT_API void format_system_error(fmt::Writer &out, int error_code,
-                                 fmt::StringRef message) FMT_NOEXCEPT;
-
-/**
-  \rst
-  This template provides operations for formatting and writing data into
-  a character stream. The output is stored in a buffer provided by a subclass
-  such as :class:`fmt::BasicMemoryWriter`.
-
-  You can use one of the following typedefs for common character types:
-
-  +---------+----------------------+
-  | Type    | Definition           |
-  +=========+======================+
-  | Writer  | BasicWriter<char>    |
-  +---------+----------------------+
-  | WWriter | BasicWriter<wchar_t> |
-  +---------+----------------------+
-
-  \endrst
- */
-template <typename Char>
-class BasicWriter {
- private:
-  // Output buffer.
-  Buffer<Char> &buffer_;
-
-  FMT_DISALLOW_COPY_AND_ASSIGN(BasicWriter);
-
-  typedef typename internal::CharTraits<Char>::CharPtr CharPtr;
-
-#if FMT_SECURE_SCL
-  // Returns pointer value.
-  static Char *get(CharPtr p) { return p.base(); }
-#else
-  static Char *get(Char *p) { return p; }
-#endif
-
-  // Fills the padding around the content and returns the pointer to the
-  // content area.
-  static CharPtr fill_padding(CharPtr buffer,
-      unsigned total_size, std::size_t content_size, wchar_t fill);
-
-  // Grows the buffer by n characters and returns a pointer to the newly
-  // allocated area.
-  CharPtr grow_buffer(std::size_t n) {
-    std::size_t size = buffer_.size();
-    buffer_.resize(size + n);
-    return internal::make_ptr(&buffer_[size], n);
-  }
-
-  // Writes an unsigned decimal integer.
-  template <typename UInt>
-  Char *write_unsigned_decimal(UInt value, unsigned prefix_size = 0) {
-    unsigned num_digits = internal::count_digits(value);
-    Char *ptr = get(grow_buffer(prefix_size + num_digits));
-    internal::format_decimal(ptr + prefix_size, value, num_digits);
-    return ptr;
-  }
-
-  // Writes a decimal integer.
-  template <typename Int>
-  void write_decimal(Int value) {
-    typedef typename internal::IntTraits<Int>::MainType MainType;
-    MainType abs_value = static_cast<MainType>(value);
-    if (internal::is_negative(value)) {
-      abs_value = 0 - abs_value;
-      *write_unsigned_decimal(abs_value, 1) = '-';
-    } else {
-      write_unsigned_decimal(abs_value, 0);
-    }
-  }
-
-  // Prepare a buffer for integer formatting.
-  CharPtr prepare_int_buffer(unsigned num_digits,
-      const EmptySpec &, const char *prefix, unsigned prefix_size) {
-    unsigned size = prefix_size + num_digits;
-    CharPtr p = grow_buffer(size);
-    std::uninitialized_copy(prefix, prefix + prefix_size, p);
-    return p + size - 1;
-  }
-
-  template <typename Spec>
-  CharPtr prepare_int_buffer(unsigned num_digits,
-    const Spec &spec, const char *prefix, unsigned prefix_size);
-
-  // Formats an integer.
-  template <typename T, typename Spec>
-  void write_int(T value, Spec spec);
-
-  // Formats a floating-point number (double or long double).
-  template <typename T, typename Spec>
-  void write_double(T value, const Spec &spec);
-
-  // Writes a formatted string.
-  template <typename StrChar>
-  CharPtr write_str(const StrChar *s, std::size_t size, const AlignSpec &spec);
-
-  template <typename StrChar, typename Spec>
-  void write_str(const internal::Arg::StringValue<StrChar> &str,
-                 const Spec &spec);
-
-  // This following methods are private to disallow writing wide characters
-  // and strings to a char stream. If you want to print a wide string as a
-  // pointer as std::ostream does, cast it to const void*.
-  // Do not implement!
-  void operator<<(typename internal::WCharHelper<wchar_t, Char>::Unsupported);
-  void operator<<(
-      typename internal::WCharHelper<const wchar_t *, Char>::Unsupported);
-
-  // Appends floating-point length specifier to the format string.
-  // The second argument is only used for overload resolution.
-  void append_float_length(Char *&format_ptr, long double) {
-    *format_ptr++ = 'L';
-  }
-
-  template<typename T>
-  void append_float_length(Char *&, T) {}
-
-  template <typename Impl, typename Char_, typename Spec_>
-  friend class internal::ArgFormatterBase;
-
-  template <typename Impl, typename Char_, typename Spec_>
-  friend class BasicPrintfArgFormatter;
-
- protected:
-  /**
-    Constructs a ``BasicWriter`` object.
-   */
-  explicit BasicWriter(Buffer<Char> &b) : buffer_(b) {}
-
- public:
-  /**
-    \rst
-    Destroys a ``BasicWriter`` object.
-    \endrst
-   */
-  virtual ~BasicWriter() {}
-
-  /**
-    Returns the total number of characters written.
-   */
-  std::size_t size() const { return buffer_.size(); }
-
-  /**
-    Returns a pointer to the output buffer content. No terminating null
-    character is appended.
-   */
-  const Char *data() const FMT_NOEXCEPT { return &buffer_[0]; }
-
-  /**
-    Returns a pointer to the output buffer content with terminating null
-    character appended.
-   */
-  const Char *c_str() const {
-    std::size_t size = buffer_.size();
-    buffer_.reserve(size + 1);
-    buffer_[size] = '\0';
-    return &buffer_[0];
-  }
-
-  /**
-    \rst
-    Returns the content of the output buffer as an `std::string`.
-    \endrst
-   */
-  std::basic_string<Char> str() const {
-    return std::basic_string<Char>(&buffer_[0], buffer_.size());
-  }
-
-  /**
-    \rst
-    Writes formatted data.
-
-    *args* is an argument list representing arbitrary arguments.
-
-    **Example**::
-
-       MemoryWriter out;
-       out.write("Current point:\n");
-       out.write("({:+f}, {:+f})", -3.14, 3.14);
-
-    This will write the following output to the ``out`` object:
-
-    .. code-block:: none
-
-       Current point:
-       (-3.140000, +3.140000)
-
-    The output can be accessed using :func:`data()`, :func:`c_str` or
-    :func:`str` methods.
-
-    See also :ref:`syntax`.
-    \endrst
-   */
-  void write(BasicCStringRef<Char> format, ArgList args) {
-    BasicFormatter<Char>(args, *this).format(format);
-  }
-  FMT_VARIADIC_VOID(write, BasicCStringRef<Char>)
-
-  BasicWriter &operator<<(int value) {
-    write_decimal(value);
-    return *this;
-  }
-  BasicWriter &operator<<(unsigned value) {
-    return *this << IntFormatSpec<unsigned>(value);
-  }
-  BasicWriter &operator<<(long value) {
-    write_decimal(value);
-    return *this;
-  }
-  BasicWriter &operator<<(unsigned long value) {
-    return *this << IntFormatSpec<unsigned long>(value);
-  }
-  BasicWriter &operator<<(LongLong value) {
-    write_decimal(value);
-    return *this;
-  }
-
-  /**
-    \rst
-    Formats *value* and writes it to the stream.
-    \endrst
-   */
-  BasicWriter &operator<<(ULongLong value) {
-    return *this << IntFormatSpec<ULongLong>(value);
-  }
-
-  BasicWriter &operator<<(double value) {
-    write_double(value, FormatSpec());
-    return *this;
-  }
-
-  /**
-    \rst
-    Formats *value* using the general format for floating-point numbers
-    (``'g'``) and writes it to the stream.
-    \endrst
-   */
-  BasicWriter &operator<<(long double value) {
-    write_double(value, FormatSpec());
-    return *this;
-  }
-
-  /**
-    Writes a character to the stream.
-   */
-  BasicWriter &operator<<(char value) {
-    buffer_.push_back(value);
-    return *this;
-  }
-
-  BasicWriter &operator<<(
-      typename internal::WCharHelper<wchar_t, Char>::Supported value) {
-    buffer_.push_back(value);
-    return *this;
-  }
-
-  /**
-    \rst
-    Writes *value* to the stream.
-    \endrst
-   */
-  BasicWriter &operator<<(fmt::BasicStringRef<Char> value) {
-    const Char *str = value.data();
-    buffer_.append(str, str + value.size());
-    return *this;
-  }
-
-  BasicWriter &operator<<(
-      typename internal::WCharHelper<StringRef, Char>::Supported value) {
-    const char *str = value.data();
-    buffer_.append(str, str + value.size());
-    return *this;
-  }
-
-  template <typename T, typename Spec, typename FillChar>
-  BasicWriter &operator<<(IntFormatSpec<T, Spec, FillChar> spec) {
-    internal::CharTraits<Char>::convert(FillChar());
-    write_int(spec.value(), spec);
-    return *this;
-  }
-
-  template <typename StrChar>
-  BasicWriter &operator<<(const StrFormatSpec<StrChar> &spec) {
-    const StrChar *s = spec.str();
-    write_str(s, std::char_traits<Char>::length(s), spec);
-    return *this;
-  }
-
-  void clear() FMT_NOEXCEPT { buffer_.clear(); }
-
-  Buffer<Char> &buffer() FMT_NOEXCEPT { return buffer_; }
-};
-
-template <typename Char>
-template <typename StrChar>
-typename BasicWriter<Char>::CharPtr BasicWriter<Char>::write_str(
-      const StrChar *s, std::size_t size, const AlignSpec &spec) {
-  CharPtr out = CharPtr();
-  if (spec.width() > size) {
-    out = grow_buffer(spec.width());
-    Char fill = internal::CharTraits<Char>::cast(spec.fill());
-    if (spec.align() == ALIGN_RIGHT) {
-      std::uninitialized_fill_n(out, spec.width() - size, fill);
-      out += spec.width() - size;
-    } else if (spec.align() == ALIGN_CENTER) {
-      out = fill_padding(out, spec.width(), size, fill);
-    } else {
-      std::uninitialized_fill_n(out + size, spec.width() - size, fill);
-    }
-  } else {
-    out = grow_buffer(size);
-  }
-  std::uninitialized_copy(s, s + size, out);
-  return out;
-}
-
-template <typename Char>
-template <typename StrChar, typename Spec>
-void BasicWriter<Char>::write_str(
-    const internal::Arg::StringValue<StrChar> &s, const Spec &spec) {
-  // Check if StrChar is convertible to Char.
-  internal::CharTraits<Char>::convert(StrChar());
-  if (spec.type_ && spec.type_ != 's')
-    internal::report_unknown_type(spec.type_, "string");
-  const StrChar *str_value = s.value;
-  std::size_t str_size = s.size;
-  if (str_size == 0) {
-    if (!str_value) {
-      FMT_THROW(FormatError("string pointer is null"));
-    }
-  }
-  std::size_t precision = static_cast<std::size_t>(spec.precision_);
-  if (spec.precision_ >= 0 && precision < str_size)
-    str_size = precision;
-  write_str(str_value, str_size, spec);
-}
-
-template <typename Char>
-typename BasicWriter<Char>::CharPtr
-  BasicWriter<Char>::fill_padding(
-    CharPtr buffer, unsigned total_size,
-    std::size_t content_size, wchar_t fill) {
-  std::size_t padding = total_size - content_size;
-  std::size_t left_padding = padding / 2;
-  Char fill_char = internal::CharTraits<Char>::cast(fill);
-  std::uninitialized_fill_n(buffer, left_padding, fill_char);
-  buffer += left_padding;
-  CharPtr content = buffer;
-  std::uninitialized_fill_n(buffer + content_size,
-                            padding - left_padding, fill_char);
-  return content;
-}
-
-template <typename Char>
-template <typename Spec>
-typename BasicWriter<Char>::CharPtr
-  BasicWriter<Char>::prepare_int_buffer(
-    unsigned num_digits, const Spec &spec,
-    const char *prefix, unsigned prefix_size) {
-  unsigned width = spec.width();
-  Alignment align = spec.align();
-  Char fill = internal::CharTraits<Char>::cast(spec.fill());
-  if (spec.precision() > static_cast<int>(num_digits)) {
-    // Octal prefix '0' is counted as a digit, so ignore it if precision
-    // is specified.
-    if (prefix_size > 0 && prefix[prefix_size - 1] == '0')
-      --prefix_size;
-    unsigned number_size =
-        prefix_size + internal::to_unsigned(spec.precision());
-    AlignSpec subspec(number_size, '0', ALIGN_NUMERIC);
-    if (number_size >= width)
-      return prepare_int_buffer(num_digits, subspec, prefix, prefix_size);
-    buffer_.reserve(width);
-    unsigned fill_size = width - number_size;
-    if (align != ALIGN_LEFT) {
-      CharPtr p = grow_buffer(fill_size);
-      std::uninitialized_fill(p, p + fill_size, fill);
-    }
-    CharPtr result = prepare_int_buffer(
-        num_digits, subspec, prefix, prefix_size);
-    if (align == ALIGN_LEFT) {
-      CharPtr p = grow_buffer(fill_size);
-      std::uninitialized_fill(p, p + fill_size, fill);
-    }
-    return result;
-  }
-  unsigned size = prefix_size + num_digits;
-  if (width <= size) {
-    CharPtr p = grow_buffer(size);
-    std::uninitialized_copy(prefix, prefix + prefix_size, p);
-    return p + size - 1;
-  }
-  CharPtr p = grow_buffer(width);
-  CharPtr end = p + width;
-  if (align == ALIGN_LEFT) {
-    std::uninitialized_copy(prefix, prefix + prefix_size, p);
-    p += size;
-    std::uninitialized_fill(p, end, fill);
-  } else if (align == ALIGN_CENTER) {
-    p = fill_padding(p, width, size, fill);
-    std::uninitialized_copy(prefix, prefix + prefix_size, p);
-    p += size;
-  } else {
-    if (align == ALIGN_NUMERIC) {
-      if (prefix_size != 0) {
-        p = std::uninitialized_copy(prefix, prefix + prefix_size, p);
-        size -= prefix_size;
-      }
-    } else {
-      std::uninitialized_copy(prefix, prefix + prefix_size, end - size);
-    }
-    std::uninitialized_fill(p, end - size, fill);
-    p = end;
-  }
-  return p - 1;
-}
-
-template <typename Char>
-template <typename T, typename Spec>
-void BasicWriter<Char>::write_int(T value, Spec spec) {
-  unsigned prefix_size = 0;
-  typedef typename internal::IntTraits<T>::MainType UnsignedType;
-  UnsignedType abs_value = static_cast<UnsignedType>(value);
-  char prefix[4] = "";
-  if (internal::is_negative(value)) {
-    prefix[0] = '-';
-    ++prefix_size;
-    abs_value = 0 - abs_value;
-  } else if (spec.flag(SIGN_FLAG)) {
-    prefix[0] = spec.flag(PLUS_FLAG) ? '+' : ' ';
-    ++prefix_size;
-  }
-  switch (spec.type()) {
-  case 0: case 'd': {
-    unsigned num_digits = internal::count_digits(abs_value);
-    CharPtr p = prepare_int_buffer(num_digits, spec, prefix, prefix_size) + 1;
-    internal::format_decimal(get(p), abs_value, 0);
-    break;
-  }
-  case 'x': case 'X': {
-    UnsignedType n = abs_value;
-    if (spec.flag(HASH_FLAG)) {
-      prefix[prefix_size++] = '0';
-      prefix[prefix_size++] = spec.type_prefix();
-    }
-    unsigned num_digits = 0;
-    do {
-      ++num_digits;
-    } while ((n >>= 4) != 0);
-    Char *p = get(prepare_int_buffer(
-      num_digits, spec, prefix, prefix_size));
-    n = abs_value;
-    const char *digits = spec.type() == 'x' ?
-        "0123456789abcdef" : "0123456789ABCDEF";
-    do {
-      *p-- = digits[n & 0xf];
-    } while ((n >>= 4) != 0);
-    break;
-  }
-  case 'b': case 'B': {
-    UnsignedType n = abs_value;
-    if (spec.flag(HASH_FLAG)) {
-      prefix[prefix_size++] = '0';
-      prefix[prefix_size++] = spec.type_prefix();
-    }
-    unsigned num_digits = 0;
-    do {
-      ++num_digits;
-    } while ((n >>= 1) != 0);
-    Char *p = get(prepare_int_buffer(num_digits, spec, prefix, prefix_size));
-    n = abs_value;
-    do {
-      *p-- = static_cast<Char>('0' + (n & 1));
-    } while ((n >>= 1) != 0);
-    break;
-  }
-  case 'o': {
-    UnsignedType n = abs_value;
-    if (spec.flag(HASH_FLAG))
-      prefix[prefix_size++] = '0';
-    unsigned num_digits = 0;
-    do {
-      ++num_digits;
-    } while ((n >>= 3) != 0);
-    Char *p = get(prepare_int_buffer(num_digits, spec, prefix, prefix_size));
-    n = abs_value;
-    do {
-      *p-- = static_cast<Char>('0' + (n & 7));
-    } while ((n >>= 3) != 0);
-    break;
-  }
-  case 'n': {
-    unsigned num_digits = internal::count_digits(abs_value);
-    fmt::StringRef sep = "";
-#if !(defined(ANDROID) || defined(__ANDROID__))
-    sep = internal::thousands_sep(std::localeconv());
-#endif
-    unsigned size = static_cast<unsigned>(
-          num_digits + sep.size() * ((num_digits - 1) / 3));
-    CharPtr p = prepare_int_buffer(size, spec, prefix, prefix_size) + 1;
-    internal::format_decimal(get(p), abs_value, 0, internal::ThousandsSep(sep));
-    break;
-  }
-  default:
-    internal::report_unknown_type(
-      spec.type(), spec.flag(CHAR_FLAG) ? "char" : "integer");
-    break;
-  }
-}
-
-template <typename Char>
-template <typename T, typename Spec>
-void BasicWriter<Char>::write_double(T value, const Spec &spec) {
-  // Check type.
-  char type = spec.type();
-  bool upper = false;
-  switch (type) {
-  case 0:
-    type = 'g';
-    break;
-  case 'e': case 'f': case 'g': case 'a':
-    break;
-  case 'F':
-#if FMT_MSC_VER
-    // MSVC's printf doesn't support 'F'.
-    type = 'f';
-#endif
-    // Fall through.
-  case 'E': case 'G': case 'A':
-    upper = true;
-    break;
-  default:
-    internal::report_unknown_type(type, "double");
-    break;
-  }
-
-  char sign = 0;
-  // Use isnegative instead of value < 0 because the latter is always
-  // false for NaN.
-  if (internal::FPUtil::isnegative(static_cast<double>(value))) {
-    sign = '-';
-    value = -value;
-  } else if (spec.flag(SIGN_FLAG)) {
-    sign = spec.flag(PLUS_FLAG) ? '+' : ' ';
-  }
-
-  if (internal::FPUtil::isnotanumber(value)) {
-    // Format NaN ourselves because sprintf's output is not consistent
-    // across platforms.
-    std::size_t nan_size = 4;
-    const char *nan = upper ? " NAN" : " nan";
-    if (!sign) {
-      --nan_size;
-      ++nan;
-    }
-    CharPtr out = write_str(nan, nan_size, spec);
-    if (sign)
-      *out = sign;
-    return;
-  }
-
-  if (internal::FPUtil::isinfinity(value)) {
-    // Format infinity ourselves because sprintf's output is not consistent
-    // across platforms.
-    std::size_t inf_size = 4;
-    const char *inf = upper ? " INF" : " inf";
-    if (!sign) {
-      --inf_size;
-      ++inf;
-    }
-    CharPtr out = write_str(inf, inf_size, spec);
-    if (sign)
-      *out = sign;
-    return;
-  }
-
-  std::size_t offset = buffer_.size();
-  unsigned width = spec.width();
-  if (sign) {
-    buffer_.reserve(buffer_.size() + (width > 1u ? width : 1u));
-    if (width > 0)
-      --width;
-    ++offset;
-  }
-
-  // Build format string.
-  enum { MAX_FORMAT_SIZE = 10}; // longest format: %#-*.*Lg
-  Char format[MAX_FORMAT_SIZE];
-  Char *format_ptr = format;
-  *format_ptr++ = '%';
-  unsigned width_for_sprintf = width;
-  if (spec.flag(HASH_FLAG))
-    *format_ptr++ = '#';
-  if (spec.align() == ALIGN_CENTER) {
-    width_for_sprintf = 0;
-  } else {
-    if (spec.align() == ALIGN_LEFT)
-      *format_ptr++ = '-';
-    if (width != 0)
-      *format_ptr++ = '*';
-  }
-  if (spec.precision() >= 0) {
-    *format_ptr++ = '.';
-    *format_ptr++ = '*';
-  }
-
-  append_float_length(format_ptr, value);
-  *format_ptr++ = type;
-  *format_ptr = '\0';
-
-  // Format using snprintf.
-  Char fill = internal::CharTraits<Char>::cast(spec.fill());
-  unsigned n = 0;
-  Char *start = FMT_NULL;
-  for (;;) {
-    std::size_t buffer_size = buffer_.capacity() - offset;
-#if FMT_MSC_VER
-    // MSVC's vsnprintf_s doesn't work with zero size, so reserve
-    // space for at least one extra character to make the size non-zero.
-    // Note that the buffer's capacity will increase by more than 1.
-    if (buffer_size == 0) {
-      buffer_.reserve(offset + 1);
-      buffer_size = buffer_.capacity() - offset;
-    }
-#endif
-    start = &buffer_[offset];
-    int result = internal::CharTraits<Char>::format_float(
-        start, buffer_size, format, width_for_sprintf, spec.precision(), value);
-    if (result >= 0) {
-      n = internal::to_unsigned(result);
-      if (offset + n < buffer_.capacity())
-        break;  // The buffer is large enough - continue with formatting.
-      buffer_.reserve(offset + n + 1);
-    } else {
-      // If result is negative we ask to increase the capacity by at least 1,
-      // but as std::vector, the buffer grows exponentially.
-      buffer_.reserve(buffer_.capacity() + 1);
-    }
-  }
-  if (sign) {
-    if ((spec.align() != ALIGN_RIGHT && spec.align() != ALIGN_DEFAULT) ||
-        *start != ' ') {
-      *(start - 1) = sign;
-      sign = 0;
-    } else {
-      *(start - 1) = fill;
-    }
-    ++n;
-  }
-  if (spec.align() == ALIGN_CENTER && spec.width() > n) {
-    width = spec.width();
-    CharPtr p = grow_buffer(width);
-    std::memmove(get(p) + (width - n) / 2, get(p), n * sizeof(Char));
-    fill_padding(p, spec.width(), n, fill);
-    return;
-  }
-  if (spec.fill() != ' ' || sign) {
-    while (*start == ' ')
-      *start++ = fill;
-    if (sign)
-      *(start - 1) = sign;
-  }
-  grow_buffer(n);
-}
-
-/**
-  \rst
-  This class template provides operations for formatting and writing data
-  into a character stream. The output is stored in a memory buffer that grows
-  dynamically.
-
-  You can use one of the following typedefs for common character types
-  and the standard allocator:
-
-  +---------------+-----------------------------------------------------+
-  | Type          | Definition                                          |
-  +===============+=====================================================+
-  | MemoryWriter  | BasicMemoryWriter<char, std::allocator<char>>       |
-  +---------------+-----------------------------------------------------+
-  | WMemoryWriter | BasicMemoryWriter<wchar_t, std::allocator<wchar_t>> |
-  +---------------+-----------------------------------------------------+
-
-  **Example**::
-
-     MemoryWriter out;
-     out << "The answer is " << 42 << "\n";
-     out.write("({:+f}, {:+f})", -3.14, 3.14);
-
-  This will write the following output to the ``out`` object:
-
-  .. code-block:: none
-
-     The answer is 42
-     (-3.140000, +3.140000)
-
-  The output can be converted to an ``std::string`` with ``out.str()`` or
-  accessed as a C string with ``out.c_str()``.
-  \endrst
- */
-template <typename Char, typename Allocator = std::allocator<Char> >
-class BasicMemoryWriter : public BasicWriter<Char> {
- private:
-  internal::MemoryBuffer<Char, internal::INLINE_BUFFER_SIZE, Allocator> buffer_;
-
- public:
-  explicit BasicMemoryWriter(const Allocator& alloc = Allocator())
-    : BasicWriter<Char>(buffer_), buffer_(alloc) {}
-
-#if FMT_USE_RVALUE_REFERENCES
-  /**
-    \rst
-    Constructs a :class:`fmt::BasicMemoryWriter` object moving the content
-    of the other object to it.
-    \endrst
-   */
-  BasicMemoryWriter(BasicMemoryWriter &&other)
-    : BasicWriter<Char>(buffer_), buffer_(std::move(other.buffer_)) {
-  }
-
-  /**
-    \rst
-    Moves the content of the other ``BasicMemoryWriter`` object to this one.
-    \endrst
-   */
-  BasicMemoryWriter &operator=(BasicMemoryWriter &&other) {
-    buffer_ = std::move(other.buffer_);
-    return *this;
-  }
-#endif
-};
-
-typedef BasicMemoryWriter<char> MemoryWriter;
-typedef BasicMemoryWriter<wchar_t> WMemoryWriter;
-
-/**
-  \rst
-  This class template provides operations for formatting and writing data
-  into a fixed-size array. For writing into a dynamically growing buffer
-  use :class:`fmt::BasicMemoryWriter`.
-
-  Any write method will throw ``std::runtime_error`` if the output doesn't fit
-  into the array.
-
-  You can use one of the following typedefs for common character types:
-
-  +--------------+---------------------------+
-  | Type         | Definition                |
-  +==============+===========================+
-  | ArrayWriter  | BasicArrayWriter<char>    |
-  +--------------+---------------------------+
-  | WArrayWriter | BasicArrayWriter<wchar_t> |
-  +--------------+---------------------------+
-  \endrst
- */
-template <typename Char>
-class BasicArrayWriter : public BasicWriter<Char> {
- private:
-  internal::FixedBuffer<Char> buffer_;
-
- public:
-  /**
-   \rst
-   Constructs a :class:`fmt::BasicArrayWriter` object for *array* of the
-   given size.
-   \endrst
-   */
-  BasicArrayWriter(Char *array, std::size_t size)
-    : BasicWriter<Char>(buffer_), buffer_(array, size) {}
-
-  /**
-   \rst
-   Constructs a :class:`fmt::BasicArrayWriter` object for *array* of the
-   size known at compile time.
-   \endrst
-   */
-  template <std::size_t SIZE>
-  explicit BasicArrayWriter(Char (&array)[SIZE])
-    : BasicWriter<Char>(buffer_), buffer_(array, SIZE) {}
-};
-
-typedef BasicArrayWriter<char> ArrayWriter;
-typedef BasicArrayWriter<wchar_t> WArrayWriter;
-
-// Reports a system error without throwing an exception.
-// Can be used to report errors from destructors.
-FMT_API void report_system_error(int error_code,
-                                 StringRef message) FMT_NOEXCEPT;
-
-#if FMT_USE_WINDOWS_H
-
-/** A Windows error. */
-class WindowsError : public SystemError {
- private:
-  FMT_API void init(int error_code, CStringRef format_str, ArgList args);
-
- public:
-  /**
-   \rst
-   Constructs a :class:`fmt::WindowsError` object with the description
-   of the form
-
-   .. parsed-literal::
-     *<message>*: *<system-message>*
-
-   where *<message>* is the formatted message and *<system-message>* is the
-   system message corresponding to the error code.
-   *error_code* is a Windows error code as given by ``GetLastError``.
-   If *error_code* is not a valid error code such as -1, the system message
-   will look like "error -1".
-
-   **Example**::
-
-     // This throws a WindowsError with the description
-     //   cannot open file 'madeup': The system cannot find the file specified.
-     // or similar (system message may vary).
-     const char *filename = "madeup";
-     LPOFSTRUCT of = LPOFSTRUCT();
-     HFILE file = OpenFile(filename, &of, OF_READ);
-     if (file == HFILE_ERROR) {
-       throw fmt::WindowsError(GetLastError(),
-                               "cannot open file '{}'", filename);
-     }
-   \endrst
-  */
-  WindowsError(int error_code, CStringRef message) {
-    init(error_code, message, ArgList());
-  }
-  FMT_VARIADIC_CTOR(WindowsError, init, int, CStringRef)
-};
-
-// Reports a Windows error without throwing an exception.
-// Can be used to report errors from destructors.
-FMT_API void report_windows_error(int error_code,
-                                  StringRef message) FMT_NOEXCEPT;
-
-#endif
-
-enum Color { BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE };
-
-/**
-  Formats a string and prints it to stdout using ANSI escape sequences
-  to specify color (experimental).
-  Example:
-    print_colored(fmt::RED, "Elapsed time: {0:.2f} seconds", 1.23);
- */
-FMT_API void print_colored(Color c, CStringRef format, ArgList args);
-
-/**
-  \rst
-  Formats arguments and returns the result as a string.
-
-  **Example**::
-
-    std::string message = format("The answer is {}", 42);
-  \endrst
-*/
-inline std::string format(CStringRef format_str, ArgList args) {
-  MemoryWriter w;
-  w.write(format_str, args);
-  return w.str();
-}
-
-inline std::wstring format(WCStringRef format_str, ArgList args) {
-  WMemoryWriter w;
-  w.write(format_str, args);
-  return w.str();
-}
-
-/**
-  \rst
-  Prints formatted data to the file *f*.
-
-  **Example**::
-
-    print(stderr, "Don't {}!", "panic");
-  \endrst
- */
-FMT_API void print(std::FILE *f, CStringRef format_str, ArgList args);
-
-/**
-  \rst
-  Prints formatted data to ``stdout``.
-
-  **Example**::
-
-    print("Elapsed time: {0:.2f} seconds", 1.23);
-  \endrst
- */
-FMT_API void print(CStringRef format_str, ArgList args);
-
-/**
-  Fast integer formatter.
- */
-class FormatInt {
- private:
-  // Buffer should be large enough to hold all digits (digits10 + 1),
-  // a sign and a null character.
-  enum {BUFFER_SIZE = std::numeric_limits<ULongLong>::digits10 + 3};
-  mutable char buffer_[BUFFER_SIZE];
-  char *str_;
-
-  // Formats value in reverse and returns the number of digits.
-  char *format_decimal(ULongLong value) {
-    char *buffer_end = buffer_ + BUFFER_SIZE - 1;
-    while (value >= 100) {
-      // Integer division is slow so do it for a group of two digits instead
-      // of for every digit. The idea comes from the talk by Alexandrescu
-      // "Three Optimization Tips for C++". See speed-test for a comparison.
-      unsigned index = static_cast<unsigned>((value % 100) * 2);
-      value /= 100;
-      *--buffer_end = internal::Data::DIGITS[index + 1];
-      *--buffer_end = internal::Data::DIGITS[index];
-    }
-    if (value < 10) {
-      *--buffer_end = static_cast<char>('0' + value);
-      return buffer_end;
-    }
-    unsigned index = static_cast<unsigned>(value * 2);
-    *--buffer_end = internal::Data::DIGITS[index + 1];
-    *--buffer_end = internal::Data::DIGITS[index];
-    return buffer_end;
-  }
-
-  void FormatSigned(LongLong value) {
-    ULongLong abs_value = static_cast<ULongLong>(value);
-    bool negative = value < 0;
-    if (negative)
-      abs_value = 0 - abs_value;
-    str_ = format_decimal(abs_value);
-    if (negative)
-      *--str_ = '-';
-  }
-
- public:
-  explicit FormatInt(int value) { FormatSigned(value); }
-  explicit FormatInt(long value) { FormatSigned(value); }
-  explicit FormatInt(LongLong value) { FormatSigned(value); }
-  explicit FormatInt(unsigned value) : str_(format_decimal(value)) {}
-  explicit FormatInt(unsigned long value) : str_(format_decimal(value)) {}
-  explicit FormatInt(ULongLong value) : str_(format_decimal(value)) {}
-
-  /** Returns the number of characters written to the output buffer. */
-  std::size_t size() const {
-    return internal::to_unsigned(buffer_ - str_ + BUFFER_SIZE - 1);
-  }
-
-  /**
-    Returns a pointer to the output buffer content. No terminating null
-    character is appended.
-   */
-  const char *data() const { return str_; }
-
-  /**
-    Returns a pointer to the output buffer content with terminating null
-    character appended.
-   */
-  const char *c_str() const {
-    buffer_[BUFFER_SIZE - 1] = '\0';
-    return str_;
-  }
-
-  /**
-    \rst
-    Returns the content of the output buffer as an ``std::string``.
-    \endrst
-   */
-  std::string str() const { return std::string(str_, size()); }
-};
-
-// Formats a decimal integer value writing into buffer and returns
-// a pointer to the end of the formatted string. This function doesn't
-// write a terminating null character.
-template <typename T>
-inline void format_decimal(char *&buffer, T value) {
-  typedef typename internal::IntTraits<T>::MainType MainType;
-  MainType abs_value = static_cast<MainType>(value);
-  if (internal::is_negative(value)) {
-    *buffer++ = '-';
-    abs_value = 0 - abs_value;
-  }
-  if (abs_value < 100) {
-    if (abs_value < 10) {
-      *buffer++ = static_cast<char>('0' + abs_value);
-      return;
-    }
-    unsigned index = static_cast<unsigned>(abs_value * 2);
-    *buffer++ = internal::Data::DIGITS[index];
-    *buffer++ = internal::Data::DIGITS[index + 1];
-    return;
-  }
-  unsigned num_digits = internal::count_digits(abs_value);
-  internal::format_decimal(buffer, abs_value, num_digits);
-  buffer += num_digits;
-}
-
-/**
-  \rst
-  Returns a named argument for formatting functions.
-
-  **Example**::
-
-    print("Elapsed time: {s:.2f} seconds", arg("s", 1.23));
-
-  \endrst
- */
-template <typename T>
-inline internal::NamedArgWithType<char, T> arg(StringRef name, const T &arg) {
-  return internal::NamedArgWithType<char, T>(name, arg);
-}
-
-template <typename T>
-inline internal::NamedArgWithType<wchar_t, T> arg(WStringRef name, const T &arg) {
-  return internal::NamedArgWithType<wchar_t, T>(name, arg);
-}
-
-// The following two functions are deleted intentionally to disable
-// nested named arguments as in ``format("{}", arg("a", arg("b", 42)))``.
-template <typename Char>
-void arg(StringRef, const internal::NamedArg<Char>&) FMT_DELETED_OR_UNDEFINED;
-template <typename Char>
-void arg(WStringRef, const internal::NamedArg<Char>&) FMT_DELETED_OR_UNDEFINED;
-}
-
-#if FMT_GCC_VERSION
-// Use the system_header pragma to suppress warnings about variadic macros
-// because suppressing -Wvariadic-macros with the diagnostic pragma doesn't
-// work. It is used at the end because we want to suppress as little warnings
-// as possible.
-# pragma GCC system_header
-#endif
-
-// This is used to work around VC++ bugs in handling variadic macros.
-#define FMT_EXPAND(args) args
-
-// Returns the number of arguments.
-// Based on https://groups.google.com/forum/#!topic/comp.std.c/d-6Mj5Lko_s.
-#define FMT_NARG(...) FMT_NARG_(__VA_ARGS__, FMT_RSEQ_N())
-#define FMT_NARG_(...) FMT_EXPAND(FMT_ARG_N(__VA_ARGS__))
-#define FMT_ARG_N(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N
-#define FMT_RSEQ_N() 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
-
-#define FMT_FOR_EACH_(N, f, ...) \
-  FMT_EXPAND(FMT_CONCAT(FMT_FOR_EACH, N)(f, __VA_ARGS__))
-#define FMT_FOR_EACH(f, ...) \
-  FMT_EXPAND(FMT_FOR_EACH_(FMT_NARG(__VA_ARGS__), f, __VA_ARGS__))
-
-#define FMT_ADD_ARG_NAME(type, index) type arg##index
-#define FMT_GET_ARG_NAME(type, index) arg##index
-
-#if FMT_USE_VARIADIC_TEMPLATES
-# define FMT_VARIADIC_(Const, Char, ReturnType, func, call, ...) \
-  template <typename... Args> \
-  ReturnType func(FMT_FOR_EACH(FMT_ADD_ARG_NAME, __VA_ARGS__), \
-      const Args & ... args) Const { \
-    typedef fmt::internal::ArgArray<sizeof...(Args)> ArgArray; \
-    typename ArgArray::Type array{ \
-      ArgArray::template make<fmt::BasicFormatter<Char> >(args)...}; \
-    call(FMT_FOR_EACH(FMT_GET_ARG_NAME, __VA_ARGS__), \
-      fmt::ArgList(fmt::internal::make_type(args...), array)); \
-  }
-#else
-// Defines a wrapper for a function taking __VA_ARGS__ arguments
-// and n additional arguments of arbitrary types.
-# define FMT_WRAP(Const, Char, ReturnType, func, call, n, ...) \
-  template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \
-  inline ReturnType func(FMT_FOR_EACH(FMT_ADD_ARG_NAME, __VA_ARGS__), \
-      FMT_GEN(n, FMT_MAKE_ARG)) Const { \
-    fmt::internal::ArgArray<n>::Type arr; \
-    FMT_GEN(n, FMT_ASSIGN_##Char); \
-    call(FMT_FOR_EACH(FMT_GET_ARG_NAME, __VA_ARGS__), fmt::ArgList( \
-      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), arr)); \
-  }
-
-# define FMT_VARIADIC_(Const, Char, ReturnType, func, call, ...) \
-  inline ReturnType func(FMT_FOR_EACH(FMT_ADD_ARG_NAME, __VA_ARGS__)) Const { \
-    call(FMT_FOR_EACH(FMT_GET_ARG_NAME, __VA_ARGS__), fmt::ArgList()); \
-  } \
-  FMT_WRAP(Const, Char, ReturnType, func, call, 1, __VA_ARGS__) \
-  FMT_WRAP(Const, Char, ReturnType, func, call, 2, __VA_ARGS__) \
-  FMT_WRAP(Const, Char, ReturnType, func, call, 3, __VA_ARGS__) \
-  FMT_WRAP(Const, Char, ReturnType, func, call, 4, __VA_ARGS__) \
-  FMT_WRAP(Const, Char, ReturnType, func, call, 5, __VA_ARGS__) \
-  FMT_WRAP(Const, Char, ReturnType, func, call, 6, __VA_ARGS__) \
-  FMT_WRAP(Const, Char, ReturnType, func, call, 7, __VA_ARGS__) \
-  FMT_WRAP(Const, Char, ReturnType, func, call, 8, __VA_ARGS__) \
-  FMT_WRAP(Const, Char, ReturnType, func, call, 9, __VA_ARGS__) \
-  FMT_WRAP(Const, Char, ReturnType, func, call, 10, __VA_ARGS__) \
-  FMT_WRAP(Const, Char, ReturnType, func, call, 11, __VA_ARGS__) \
-  FMT_WRAP(Const, Char, ReturnType, func, call, 12, __VA_ARGS__) \
-  FMT_WRAP(Const, Char, ReturnType, func, call, 13, __VA_ARGS__) \
-  FMT_WRAP(Const, Char, ReturnType, func, call, 14, __VA_ARGS__) \
-  FMT_WRAP(Const, Char, ReturnType, func, call, 15, __VA_ARGS__)
-#endif  // FMT_USE_VARIADIC_TEMPLATES
-
-/**
-  \rst
-  Defines a variadic function with the specified return type, function name
-  and argument types passed as variable arguments to this macro.
-
-  **Example**::
-
-    void print_error(const char *file, int line, const char *format,
-                     fmt::ArgList args) {
-      fmt::print("{}: {}: ", file, line);
-      fmt::print(format, args);
-    }
-    FMT_VARIADIC(void, print_error, const char *, int, const char *)
-
-  ``FMT_VARIADIC`` is used for compatibility with legacy C++ compilers that
-  don't implement variadic templates. You don't have to use this macro if
-  you don't need legacy compiler support and can use variadic templates
-  directly::
-
-    template <typename... Args>
-    void print_error(const char *file, int line, const char *format,
-                     const Args & ... args) {
-      fmt::print("{}: {}: ", file, line);
-      fmt::print(format, args...);
-    }
-  \endrst
- */
-#define FMT_VARIADIC(ReturnType, func, ...) \
-  FMT_VARIADIC_(, char, ReturnType, func, return func, __VA_ARGS__)
-
-#define FMT_VARIADIC_CONST(ReturnType, func, ...) \
-  FMT_VARIADIC_(const, char, ReturnType, func, return func, __VA_ARGS__)
-
-#define FMT_VARIADIC_W(ReturnType, func, ...) \
-  FMT_VARIADIC_(, wchar_t, ReturnType, func, return func, __VA_ARGS__)
-
-#define FMT_VARIADIC_CONST_W(ReturnType, func, ...) \
-  FMT_VARIADIC_(const, wchar_t, ReturnType, func, return func, __VA_ARGS__)
-
-#define FMT_CAPTURE_ARG_(id, index) ::fmt::arg(#id, id)
-
-#define FMT_CAPTURE_ARG_W_(id, index) ::fmt::arg(L###id, id)
-
-/**
-  \rst
-  Convenient macro to capture the arguments' names and values into several
-  ``fmt::arg(name, value)``.
-
-  **Example**::
-
-    int x = 1, y = 2;
-    print("point: ({x}, {y})", FMT_CAPTURE(x, y));
-    // same as:
-    // print("point: ({x}, {y})", arg("x", x), arg("y", y));
-
-  \endrst
- */
-#define FMT_CAPTURE(...) FMT_FOR_EACH(FMT_CAPTURE_ARG_, __VA_ARGS__)
-
-#define FMT_CAPTURE_W(...) FMT_FOR_EACH(FMT_CAPTURE_ARG_W_, __VA_ARGS__)
-
-namespace fmt {
-FMT_VARIADIC(std::string, format, CStringRef)
-FMT_VARIADIC_W(std::wstring, format, WCStringRef)
-FMT_VARIADIC(void, print, CStringRef)
-FMT_VARIADIC(void, print, std::FILE *, CStringRef)
-FMT_VARIADIC(void, print_colored, Color, CStringRef)
-
-namespace internal {
-template <typename Char>
-inline bool is_name_start(Char c) {
-  return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || '_' == c;
-}
-
-// Parses an unsigned integer advancing s to the end of the parsed input.
-// This function assumes that the first character of s is a digit.
-template <typename Char>
-unsigned parse_nonnegative_int(const Char *&s) {
-  assert('0' <= *s && *s <= '9');
-  unsigned value = 0;
-  // Convert to unsigned to prevent a warning.
-  unsigned max_int = (std::numeric_limits<int>::max)();
-  unsigned big = max_int / 10;
-  do {
-    // Check for overflow.
-    if (value > big) {
-      value = max_int + 1;
-      break;
-    }
-    value = value * 10 + (*s - '0');
-    ++s;
-  } while ('0' <= *s && *s <= '9');
-  // Convert to unsigned to prevent a warning.
-  if (value > max_int)
-    FMT_THROW(FormatError("number is too big"));
-  return value;
-}
-
-inline void require_numeric_argument(const Arg &arg, char spec) {
-  if (arg.type > Arg::LAST_NUMERIC_TYPE) {
-    std::string message =
-        fmt::format("format specifier '{}' requires numeric argument", spec);
-    FMT_THROW(fmt::FormatError(message));
-  }
-}
-
-template <typename Char>
-void check_sign(const Char *&s, const Arg &arg) {
-  char sign = static_cast<char>(*s);
-  require_numeric_argument(arg, sign);
-  if (arg.type == Arg::UINT || arg.type == Arg::ULONG_LONG) {
-    FMT_THROW(FormatError(fmt::format(
-      "format specifier '{}' requires signed argument", sign)));
-  }
-  ++s;
-}
-}  // namespace internal
-
-template <typename Char, typename AF>
-inline internal::Arg BasicFormatter<Char, AF>::get_arg(
-    BasicStringRef<Char> arg_name, const char *&error) {
-  if (check_no_auto_index(error)) {
-    map_.init(args());
-    const internal::Arg *arg = map_.find(arg_name);
-    if (arg)
-      return *arg;
-    error = "argument not found";
-  }
-  return internal::Arg();
-}
-
-template <typename Char, typename AF>
-inline internal::Arg BasicFormatter<Char, AF>::parse_arg_index(const Char *&s) {
-  const char *error = FMT_NULL;
-  internal::Arg arg = *s < '0' || *s > '9' ?
-        next_arg(error) : get_arg(internal::parse_nonnegative_int(s), error);
-  if (error) {
-    FMT_THROW(FormatError(
-                *s != '}' && *s != ':' ? "invalid format string" : error));
-  }
-  return arg;
-}
-
-template <typename Char, typename AF>
-inline internal::Arg BasicFormatter<Char, AF>::parse_arg_name(const Char *&s) {
-  assert(internal::is_name_start(*s));
-  const Char *start = s;
-  Char c;
-  do {
-    c = *++s;
-  } while (internal::is_name_start(c) || ('0' <= c && c <= '9'));
-  const char *error = FMT_NULL;
-  internal::Arg arg = get_arg(BasicStringRef<Char>(start, s - start), error);
-  if (error)
-    FMT_THROW(FormatError(error));
-  return arg;
-}
-
-template <typename Char, typename ArgFormatter>
-const Char *BasicFormatter<Char, ArgFormatter>::format(
-    const Char *&format_str, const internal::Arg &arg) {
-  using internal::Arg;
-  const Char *s = format_str;
-  typename ArgFormatter::SpecType spec;
-  if (*s == ':') {
-    if (arg.type == Arg::CUSTOM) {
-      arg.custom.format(this, arg.custom.value, &s);
-      return s;
-    }
-    ++s;
-    // Parse fill and alignment.
-    if (Char c = *s) {
-      const Char *p = s + 1;
-      spec.align_ = ALIGN_DEFAULT;
-      do {
-        switch (*p) {
-          case '<':
-            spec.align_ = ALIGN_LEFT;
-            break;
-          case '>':
-            spec.align_ = ALIGN_RIGHT;
-            break;
-          case '=':
-            spec.align_ = ALIGN_NUMERIC;
-            break;
-          case '^':
-            spec.align_ = ALIGN_CENTER;
-            break;
-        }
-        if (spec.align_ != ALIGN_DEFAULT) {
-          if (p != s) {
-            if (c == '}') break;
-            if (c == '{')
-              FMT_THROW(FormatError("invalid fill character '{'"));
-            s += 2;
-            spec.fill_ = c;
-          } else ++s;
-          if (spec.align_ == ALIGN_NUMERIC)
-            require_numeric_argument(arg, '=');
-          break;
-        }
-      } while (--p >= s);
-    }
-
-    // Parse sign.
-    switch (*s) {
-      case '+':
-        check_sign(s, arg);
-        spec.flags_ |= SIGN_FLAG | PLUS_FLAG;
-        break;
-      case '-':
-        check_sign(s, arg);
-        spec.flags_ |= MINUS_FLAG;
-        break;
-      case ' ':
-        check_sign(s, arg);
-        spec.flags_ |= SIGN_FLAG;
-        break;
-    }
-
-    if (*s == '#') {
-      require_numeric_argument(arg, '#');
-      spec.flags_ |= HASH_FLAG;
-      ++s;
-    }
-
-    // Parse zero flag.
-    if (*s == '0') {
-      require_numeric_argument(arg, '0');
-      spec.align_ = ALIGN_NUMERIC;
-      spec.fill_ = '0';
-      ++s;
-    }
-
-    // Parse width.
-    if ('0' <= *s && *s <= '9') {
-      spec.width_ = internal::parse_nonnegative_int(s);
-    } else if (*s == '{') {
-      ++s;
-      Arg width_arg = internal::is_name_start(*s) ?
-            parse_arg_name(s) : parse_arg_index(s);
-      if (*s++ != '}')
-        FMT_THROW(FormatError("invalid format string"));
-      ULongLong value = 0;
-      switch (width_arg.type) {
-      case Arg::INT:
-        if (width_arg.int_value < 0)
-          FMT_THROW(FormatError("negative width"));
-        value = width_arg.int_value;
-        break;
-      case Arg::UINT:
-        value = width_arg.uint_value;
-        break;
-      case Arg::LONG_LONG:
-        if (width_arg.long_long_value < 0)
-          FMT_THROW(FormatError("negative width"));
-        value = width_arg.long_long_value;
-        break;
-      case Arg::ULONG_LONG:
-        value = width_arg.ulong_long_value;
-        break;
-      default:
-        FMT_THROW(FormatError("width is not integer"));
-      }
-      unsigned max_int = (std::numeric_limits<int>::max)();
-      if (value > max_int)
-        FMT_THROW(FormatError("number is too big"));
-      spec.width_ = static_cast<int>(value);
-    }
-
-    // Parse precision.
-    if (*s == '.') {
-      ++s;
-      spec.precision_ = 0;
-      if ('0' <= *s && *s <= '9') {
-        spec.precision_ = internal::parse_nonnegative_int(s);
-      } else if (*s == '{') {
-        ++s;
-        Arg precision_arg = internal::is_name_start(*s) ?
-              parse_arg_name(s) : parse_arg_index(s);
-        if (*s++ != '}')
-          FMT_THROW(FormatError("invalid format string"));
-        ULongLong value = 0;
-        switch (precision_arg.type) {
-          case Arg::INT:
-            if (precision_arg.int_value < 0)
-              FMT_THROW(FormatError("negative precision"));
-            value = precision_arg.int_value;
-            break;
-          case Arg::UINT:
-            value = precision_arg.uint_value;
-            break;
-          case Arg::LONG_LONG:
-            if (precision_arg.long_long_value < 0)
-              FMT_THROW(FormatError("negative precision"));
-            value = precision_arg.long_long_value;
-            break;
-          case Arg::ULONG_LONG:
-            value = precision_arg.ulong_long_value;
-            break;
-          default:
-            FMT_THROW(FormatError("precision is not integer"));
-        }
-        unsigned max_int = (std::numeric_limits<int>::max)();
-        if (value > max_int)
-          FMT_THROW(FormatError("number is too big"));
-        spec.precision_ = static_cast<int>(value);
-      } else {
-        FMT_THROW(FormatError("missing precision specifier"));
-      }
-      if (arg.type <= Arg::LAST_INTEGER_TYPE || arg.type == Arg::POINTER) {
-        FMT_THROW(FormatError(
-            fmt::format("precision not allowed in {} format specifier",
-            arg.type == Arg::POINTER ? "pointer" : "integer")));
-      }
-    }
-
-    // Parse type.
-    if (*s != '}' && *s)
-      spec.type_ = static_cast<char>(*s++);
-  }
-
-  if (*s++ != '}')
-    FMT_THROW(FormatError("missing '}' in format string"));
-
-  // Format argument.
-  ArgFormatter(*this, spec, s - 1).visit(arg);
-  return s;
-}
-
-template <typename Char, typename AF>
-void BasicFormatter<Char, AF>::format(BasicCStringRef<Char> format_str) {
-  const Char *s = format_str.c_str();
-  const Char *start = s;
-  while (*s) {
-    Char c = *s++;
-    if (c != '{' && c != '}') continue;
-    if (*s == c) {
-      write(writer_, start, s);
-      start = ++s;
-      continue;
-    }
-    if (c == '}')
-      FMT_THROW(FormatError("unmatched '}' in format string"));
-    write(writer_, start, s - 1);
-    internal::Arg arg = internal::is_name_start(*s) ?
-          parse_arg_name(s) : parse_arg_index(s);
-    start = s = format(s, arg);
-  }
-  write(writer_, start, s);
-}
-
-template <typename Char, typename It>
-struct ArgJoin {
-  It first;
-  It last;
-  BasicCStringRef<Char> sep;
-
-  ArgJoin(It first, It last, const BasicCStringRef<Char>& sep) :
-    first(first),
-    last(last),
-    sep(sep) {}
-};
-
-template <typename It>
-ArgJoin<char, It> join(It first, It last, const BasicCStringRef<char>& sep) {
-  return ArgJoin<char, It>(first, last, sep);
-}
-
-template <typename It>
-ArgJoin<wchar_t, It> join(It first, It last, const BasicCStringRef<wchar_t>& sep) {
-  return ArgJoin<wchar_t, It>(first, last, sep);
-}
-
-#if FMT_HAS_GXX_CXX11
-template <typename Range>
-auto join(const Range& range, const BasicCStringRef<char>& sep)
-    -> ArgJoin<char, decltype(std::begin(range))> {
-  return join(std::begin(range), std::end(range), sep);
-}
-
-template <typename Range>
-auto join(const Range& range, const BasicCStringRef<wchar_t>& sep)
-    -> ArgJoin<wchar_t, decltype(std::begin(range))> {
-  return join(std::begin(range), std::end(range), sep);
-}
-#endif
-
-template <typename ArgFormatter, typename Char, typename It>
-void format_arg(fmt::BasicFormatter<Char, ArgFormatter> &f,
-    const Char *&format_str, const ArgJoin<Char, It>& e) {
-  const Char* end = format_str;
-  if (*end == ':')
-    ++end;
-  while (*end && *end != '}')
-    ++end;
-  if (*end != '}')
-    FMT_THROW(FormatError("missing '}' in format string"));
-
-  It it = e.first;
-  if (it != e.last) {
-    const Char* save = format_str;
-    f.format(format_str, internal::MakeArg<fmt::BasicFormatter<Char, ArgFormatter> >(*it++));
-    while (it != e.last) {
-      f.writer().write(e.sep);
-      format_str = save;
-      f.format(format_str, internal::MakeArg<fmt::BasicFormatter<Char, ArgFormatter> >(*it++));
-    }
-  }
-  format_str = end + 1;
-}
-}  // namespace fmt
-
-#if FMT_USE_USER_DEFINED_LITERALS
-namespace fmt {
-namespace internal {
-
-template <typename Char>
-struct UdlFormat {
-  const Char *str;
-
-  template <typename... Args>
-  auto operator()(Args && ... args) const
-                  -> decltype(format(str, std::forward<Args>(args)...)) {
-    return format(str, std::forward<Args>(args)...);
-  }
-};
-
-template <typename Char>
-struct UdlArg {
-  const Char *str;
-
-  template <typename T>
-  NamedArgWithType<Char, T> operator=(T &&value) const {
-    return {str, std::forward<T>(value)};
-  }
-};
-
-} // namespace internal
-
-inline namespace literals {
-
-/**
-  \rst
-  C++11 literal equivalent of :func:`fmt::format`.
-
-  **Example**::
-
-    using namespace fmt::literals;
-    std::string message = "The answer is {}"_format(42);
-  \endrst
- */
-inline internal::UdlFormat<char>
-operator"" _format(const char *s, std::size_t) { return {s}; }
-inline internal::UdlFormat<wchar_t>
-operator"" _format(const wchar_t *s, std::size_t) { return {s}; }
-
-/**
-  \rst
-  C++11 literal equivalent of :func:`fmt::arg`.
-
-  **Example**::
-
-    using namespace fmt::literals;
-    print("Elapsed time: {s:.2f} seconds", "s"_a=1.23);
-  \endrst
- */
-inline internal::UdlArg<char>
-operator"" _a(const char *s, std::size_t) { return {s}; }
-inline internal::UdlArg<wchar_t>
-operator"" _a(const wchar_t *s, std::size_t) { return {s}; }
-
-} // inline namespace literals
-} // namespace fmt
-#endif // FMT_USE_USER_DEFINED_LITERALS
-
-// Restore warnings.
-#if FMT_GCC_VERSION >= 406
-# pragma GCC diagnostic pop
-#endif
-
-#if defined(__clang__) && !defined(FMT_ICC_VERSION)
-# pragma clang diagnostic pop
-#endif
-
-#ifdef FMT_HEADER_ONLY
-# define FMT_FUNC inline
-# include "format.cc"
-#else
-# define FMT_FUNC
-#endif
-
-#endif  // FMT_FORMAT_H_
+/*
+  Formatting library for C++
+
+  Copyright (c) 2012 - present, Victor Zverovich
+
+  Permission is hereby granted, free of charge, to any person obtaining
+  a copy of this software and associated documentation files (the
+  "Software"), to deal in the Software without restriction, including
+  without limitation the rights to use, copy, modify, merge, publish,
+  distribute, sublicense, and/or sell copies of the Software, and to
+  permit persons to whom the Software is furnished to do so, subject to
+  the following conditions:
+
+  The above copyright notice and this permission notice shall be
+  included in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+  --- Optional exception to the license ---
+
+  As an exception, if, as a result of your compiling your source code, portions
+  of this Software are embedded into a machine-executable object form of such
+  source code, you may redistribute such embedded portions in such object form
+  without including the above copyright and permission notices.
+ */
+
+#ifndef FMT_FORMAT_H_
+#define FMT_FORMAT_H_
+
+#include <cmath>             // std::signbit
+#include <cstdint>           // uint32_t
+#include <cstring>           // std::memcpy
+#include <initializer_list>  // std::initializer_list
+#include <limits>            // std::numeric_limits
+#include <memory>            // std::uninitialized_copy
+#include <stdexcept>         // std::runtime_error
+#include <system_error>      // std::system_error
+
+#ifdef __cpp_lib_bit_cast
+#  include <bit>  // std::bitcast
+#endif
+
+#include "core.h"
+
+#ifndef FMT_BEGIN_DETAIL_NAMESPACE
+#  define FMT_BEGIN_DETAIL_NAMESPACE namespace detail {
+#  define FMT_END_DETAIL_NAMESPACE }
+#endif
+
+#if FMT_HAS_CPP17_ATTRIBUTE(fallthrough)
+#  define FMT_FALLTHROUGH [[fallthrough]]
+#elif defined(__clang__)
+#  define FMT_FALLTHROUGH [[clang::fallthrough]]
+#elif FMT_GCC_VERSION >= 700 && \
+    (!defined(__EDG_VERSION__) || __EDG_VERSION__ >= 520)
+#  define FMT_FALLTHROUGH [[gnu::fallthrough]]
+#else
+#  define FMT_FALLTHROUGH
+#endif
+
+#ifndef FMT_DEPRECATED
+#  if FMT_HAS_CPP14_ATTRIBUTE(deprecated) || FMT_MSC_VERSION >= 1900
+#    define FMT_DEPRECATED [[deprecated]]
+#  else
+#    if (defined(__GNUC__) && !defined(__LCC__)) || defined(__clang__)
+#      define FMT_DEPRECATED __attribute__((deprecated))
+#    elif FMT_MSC_VERSION
+#      define FMT_DEPRECATED __declspec(deprecated)
+#    else
+#      define FMT_DEPRECATED /* deprecated */
+#    endif
+#  endif
+#endif
+
+#if FMT_GCC_VERSION
+#  define FMT_GCC_VISIBILITY_HIDDEN __attribute__((visibility("hidden")))
+#else
+#  define FMT_GCC_VISIBILITY_HIDDEN
+#endif
+
+#ifdef __NVCC__
+#  define FMT_CUDA_VERSION (__CUDACC_VER_MAJOR__ * 100 + __CUDACC_VER_MINOR__)
+#else
+#  define FMT_CUDA_VERSION 0
+#endif
+
+#ifdef __has_builtin
+#  define FMT_HAS_BUILTIN(x) __has_builtin(x)
+#else
+#  define FMT_HAS_BUILTIN(x) 0
+#endif
+
+#if FMT_GCC_VERSION || FMT_CLANG_VERSION
+#  define FMT_NOINLINE __attribute__((noinline))
+#else
+#  define FMT_NOINLINE
+#endif
+
+#ifndef FMT_THROW
+#  if FMT_EXCEPTIONS
+#    if FMT_MSC_VERSION || defined(__NVCC__)
+FMT_BEGIN_NAMESPACE
+namespace detail {
+template <typename Exception> inline void do_throw(const Exception& x) {
+  // Silence unreachable code warnings in MSVC and NVCC because these
+  // are nearly impossible to fix in a generic code.
+  volatile bool b = true;
+  if (b) throw x;
+}
+}  // namespace detail
+FMT_END_NAMESPACE
+#      define FMT_THROW(x) detail::do_throw(x)
+#    else
+#      define FMT_THROW(x) throw x
+#    endif
+#  else
+#    define FMT_THROW(x)               \
+      do {                             \
+        FMT_ASSERT(false, (x).what()); \
+      } while (false)
+#  endif
+#endif
+
+#if FMT_EXCEPTIONS
+#  define FMT_TRY try
+#  define FMT_CATCH(x) catch (x)
+#else
+#  define FMT_TRY if (true)
+#  define FMT_CATCH(x) if (false)
+#endif
+
+#ifndef FMT_MAYBE_UNUSED
+#  if FMT_HAS_CPP17_ATTRIBUTE(maybe_unused)
+#    define FMT_MAYBE_UNUSED [[maybe_unused]]
+#  else
+#    define FMT_MAYBE_UNUSED
+#  endif
+#endif
+
+#ifndef FMT_USE_USER_DEFINED_LITERALS
+// EDG based compilers (Intel, NVIDIA, Elbrus, etc), GCC and MSVC support UDLs.
+#  if (FMT_HAS_FEATURE(cxx_user_literals) || FMT_GCC_VERSION >= 407 || \
+       FMT_MSC_VERSION >= 1900) &&                                     \
+      (!defined(__EDG_VERSION__) || __EDG_VERSION__ >= /* UDL feature */ 480)
+#    define FMT_USE_USER_DEFINED_LITERALS 1
+#  else
+#    define FMT_USE_USER_DEFINED_LITERALS 0
+#  endif
+#endif
+
+// Defining FMT_REDUCE_INT_INSTANTIATIONS to 1, will reduce the number of
+// integer formatter template instantiations to just one by only using the
+// largest integer type. This results in a reduction in binary size but will
+// cause a decrease in integer formatting performance.
+#if !defined(FMT_REDUCE_INT_INSTANTIATIONS)
+#  define FMT_REDUCE_INT_INSTANTIATIONS 0
+#endif
+
+// __builtin_clz is broken in clang with Microsoft CodeGen:
+// https://github.com/fmtlib/fmt/issues/519.
+#if !FMT_MSC_VERSION
+#  if FMT_HAS_BUILTIN(__builtin_clz) || FMT_GCC_VERSION || FMT_ICC_VERSION
+#    define FMT_BUILTIN_CLZ(n) __builtin_clz(n)
+#  endif
+#  if FMT_HAS_BUILTIN(__builtin_clzll) || FMT_GCC_VERSION || FMT_ICC_VERSION
+#    define FMT_BUILTIN_CLZLL(n) __builtin_clzll(n)
+#  endif
+#endif
+
+// __builtin_ctz is broken in Intel Compiler Classic on Windows:
+// https://github.com/fmtlib/fmt/issues/2510.
+#ifndef __ICL
+#  if FMT_HAS_BUILTIN(__builtin_ctz) || FMT_GCC_VERSION || FMT_ICC_VERSION || \
+      defined(__NVCOMPILER)
+#    define FMT_BUILTIN_CTZ(n) __builtin_ctz(n)
+#  endif
+#  if FMT_HAS_BUILTIN(__builtin_ctzll) || FMT_GCC_VERSION || \
+      FMT_ICC_VERSION || defined(__NVCOMPILER)
+#    define FMT_BUILTIN_CTZLL(n) __builtin_ctzll(n)
+#  endif
+#endif
+
+#if FMT_MSC_VERSION
+#  include <intrin.h>  // _BitScanReverse[64], _BitScanForward[64], _umul128
+#endif
+
+// Some compilers masquerade as both MSVC and GCC-likes or otherwise support
+// __builtin_clz and __builtin_clzll, so only define FMT_BUILTIN_CLZ using the
+// MSVC intrinsics if the clz and clzll builtins are not available.
+#if FMT_MSC_VERSION && !defined(FMT_BUILTIN_CLZLL) && \
+    !defined(FMT_BUILTIN_CTZLL)
+FMT_BEGIN_NAMESPACE
+namespace detail {
+// Avoid Clang with Microsoft CodeGen's -Wunknown-pragmas warning.
+#  if !defined(__clang__)
+#    pragma intrinsic(_BitScanForward)
+#    pragma intrinsic(_BitScanReverse)
+#    if defined(_WIN64)
+#      pragma intrinsic(_BitScanForward64)
+#      pragma intrinsic(_BitScanReverse64)
+#    endif
+#  endif
+
+inline auto clz(uint32_t x) -> int {
+  unsigned long r = 0;
+  _BitScanReverse(&r, x);
+  FMT_ASSERT(x != 0, "");
+  // Static analysis complains about using uninitialized data
+  // "r", but the only way that can happen is if "x" is 0,
+  // which the callers guarantee to not happen.
+  FMT_MSC_WARNING(suppress : 6102)
+  return 31 ^ static_cast<int>(r);
+}
+#  define FMT_BUILTIN_CLZ(n) detail::clz(n)
+
+inline auto clzll(uint64_t x) -> int {
+  unsigned long r = 0;
+#  ifdef _WIN64
+  _BitScanReverse64(&r, x);
+#  else
+  // Scan the high 32 bits.
+  if (_BitScanReverse(&r, static_cast<uint32_t>(x >> 32)))
+    return 63 ^ static_cast<int>(r + 32);
+  // Scan the low 32 bits.
+  _BitScanReverse(&r, static_cast<uint32_t>(x));
+#  endif
+  FMT_ASSERT(x != 0, "");
+  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
+  return 63 ^ static_cast<int>(r);
+}
+#  define FMT_BUILTIN_CLZLL(n) detail::clzll(n)
+
+inline auto ctz(uint32_t x) -> int {
+  unsigned long r = 0;
+  _BitScanForward(&r, x);
+  FMT_ASSERT(x != 0, "");
+  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
+  return static_cast<int>(r);
+}
+#  define FMT_BUILTIN_CTZ(n) detail::ctz(n)
+
+inline auto ctzll(uint64_t x) -> int {
+  unsigned long r = 0;
+  FMT_ASSERT(x != 0, "");
+  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
+#  ifdef _WIN64
+  _BitScanForward64(&r, x);
+#  else
+  // Scan the low 32 bits.
+  if (_BitScanForward(&r, static_cast<uint32_t>(x))) return static_cast<int>(r);
+  // Scan the high 32 bits.
+  _BitScanForward(&r, static_cast<uint32_t>(x >> 32));
+  r += 32;
+#  endif
+  return static_cast<int>(r);
+}
+#  define FMT_BUILTIN_CTZLL(n) detail::ctzll(n)
+}  // namespace detail
+FMT_END_NAMESPACE
+#endif
+
+FMT_BEGIN_NAMESPACE
+
+template <typename...> struct disjunction : std::false_type {};
+template <typename P> struct disjunction<P> : P {};
+template <typename P1, typename... Pn>
+struct disjunction<P1, Pn...>
+    : conditional_t<bool(P1::value), P1, disjunction<Pn...>> {};
+
+template <typename...> struct conjunction : std::true_type {};
+template <typename P> struct conjunction<P> : P {};
+template <typename P1, typename... Pn>
+struct conjunction<P1, Pn...>
+    : conditional_t<bool(P1::value), conjunction<Pn...>, P1> {};
+
+namespace detail {
+
+FMT_CONSTEXPR inline void abort_fuzzing_if(bool condition) {
+  ignore_unused(condition);
+#ifdef FMT_FUZZ
+  if (condition) throw std::runtime_error("fuzzing limit reached");
+#endif
+}
+
+template <typename CharT, CharT... C> struct string_literal {
+  static constexpr CharT value[sizeof...(C)] = {C...};
+  constexpr operator basic_string_view<CharT>() const {
+    return {value, sizeof...(C)};
+  }
+};
+
+#if FMT_CPLUSPLUS < 201703L
+template <typename CharT, CharT... C>
+constexpr CharT string_literal<CharT, C...>::value[sizeof...(C)];
+#endif
+
+template <typename Streambuf> class formatbuf : public Streambuf {
+ private:
+  using char_type = typename Streambuf::char_type;
+  using streamsize = decltype(std::declval<Streambuf>().sputn(nullptr, 0));
+  using int_type = typename Streambuf::int_type;
+  using traits_type = typename Streambuf::traits_type;
+
+  buffer<char_type>& buffer_;
+
+ public:
+  explicit formatbuf(buffer<char_type>& buf) : buffer_(buf) {}
+
+ protected:
+  // The put area is always empty. This makes the implementation simpler and has
+  // the advantage that the streambuf and the buffer are always in sync and
+  // sputc never writes into uninitialized memory. A disadvantage is that each
+  // call to sputc always results in a (virtual) call to overflow. There is no
+  // disadvantage here for sputn since this always results in a call to xsputn.
+
+  auto overflow(int_type ch) -> int_type override {
+    if (!traits_type::eq_int_type(ch, traits_type::eof()))
+      buffer_.push_back(static_cast<char_type>(ch));
+    return ch;
+  }
+
+  auto xsputn(const char_type* s, streamsize count) -> streamsize override {
+    buffer_.append(s, s + count);
+    return count;
+  }
+};
+
+// Implementation of std::bit_cast for pre-C++20.
+template <typename To, typename From, FMT_ENABLE_IF(sizeof(To) == sizeof(From))>
+FMT_CONSTEXPR20 auto bit_cast(const From& from) -> To {
+#ifdef __cpp_lib_bit_cast
+  if (is_constant_evaluated()) return std::bit_cast<To>(from);
+#endif
+  auto to = To();
+  // The cast suppresses a bogus -Wclass-memaccess on GCC.
+  std::memcpy(static_cast<void*>(&to), &from, sizeof(to));
+  return to;
+}
+
+inline auto is_big_endian() -> bool {
+#ifdef _WIN32
+  return false;
+#elif defined(__BIG_ENDIAN__)
+  return true;
+#elif defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__)
+  return __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__;
+#else
+  struct bytes {
+    char data[sizeof(int)];
+  };
+  return bit_cast<bytes>(1).data[0] == 0;
+#endif
+}
+
+class uint128_fallback {
+ private:
+  uint64_t lo_, hi_;
+
+  friend uint128_fallback umul128(uint64_t x, uint64_t y) noexcept;
+
+ public:
+  constexpr uint128_fallback(uint64_t hi, uint64_t lo) : lo_(lo), hi_(hi) {}
+  constexpr uint128_fallback(uint64_t value = 0) : lo_(value), hi_(0) {}
+
+  constexpr uint64_t high() const noexcept { return hi_; }
+  constexpr uint64_t low() const noexcept { return lo_; }
+
+  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
+  constexpr explicit operator T() const {
+    return static_cast<T>(lo_);
+  }
+
+  friend constexpr auto operator==(const uint128_fallback& lhs,
+                                   const uint128_fallback& rhs) -> bool {
+    return lhs.hi_ == rhs.hi_ && lhs.lo_ == rhs.lo_;
+  }
+  friend constexpr auto operator!=(const uint128_fallback& lhs,
+                                   const uint128_fallback& rhs) -> bool {
+    return !(lhs == rhs);
+  }
+  friend constexpr auto operator>(const uint128_fallback& lhs,
+                                  const uint128_fallback& rhs) -> bool {
+    return lhs.hi_ != rhs.hi_ ? lhs.hi_ > rhs.hi_ : lhs.lo_ > rhs.lo_;
+  }
+  friend constexpr auto operator|(const uint128_fallback& lhs,
+                                  const uint128_fallback& rhs)
+      -> uint128_fallback {
+    return {lhs.hi_ | rhs.hi_, lhs.lo_ | rhs.lo_};
+  }
+  friend constexpr auto operator&(const uint128_fallback& lhs,
+                                  const uint128_fallback& rhs)
+      -> uint128_fallback {
+    return {lhs.hi_ & rhs.hi_, lhs.lo_ & rhs.lo_};
+  }
+  friend constexpr auto operator~(const uint128_fallback& n)
+      -> uint128_fallback {
+    return {~n.hi_, ~n.lo_};
+  }
+  friend auto operator+(const uint128_fallback& lhs,
+                        const uint128_fallback& rhs) -> uint128_fallback {
+    auto result = uint128_fallback(lhs);
+    result += rhs;
+    return result;
+  }
+  friend auto operator*(const uint128_fallback& lhs, uint32_t rhs)
+      -> uint128_fallback {
+    FMT_ASSERT(lhs.hi_ == 0, "");
+    uint64_t hi = (lhs.lo_ >> 32) * rhs;
+    uint64_t lo = (lhs.lo_ & ~uint32_t()) * rhs;
+    uint64_t new_lo = (hi << 32) + lo;
+    return {(hi >> 32) + (new_lo < lo ? 1 : 0), new_lo};
+  }
+  friend auto operator-(const uint128_fallback& lhs, uint64_t rhs)
+      -> uint128_fallback {
+    return {lhs.hi_ - (lhs.lo_ < rhs ? 1 : 0), lhs.lo_ - rhs};
+  }
+  FMT_CONSTEXPR auto operator>>(int shift) const -> uint128_fallback {
+    if (shift == 64) return {0, hi_};
+    if (shift > 64) return uint128_fallback(0, hi_) >> (shift - 64);
+    return {hi_ >> shift, (hi_ << (64 - shift)) | (lo_ >> shift)};
+  }
+  FMT_CONSTEXPR auto operator<<(int shift) const -> uint128_fallback {
+    if (shift == 64) return {lo_, 0};
+    if (shift > 64) return uint128_fallback(lo_, 0) << (shift - 64);
+    return {hi_ << shift | (lo_ >> (64 - shift)), (lo_ << shift)};
+  }
+  FMT_CONSTEXPR auto operator>>=(int shift) -> uint128_fallback& {
+    return *this = *this >> shift;
+  }
+  FMT_CONSTEXPR void operator+=(uint128_fallback n) {
+    uint64_t new_lo = lo_ + n.lo_;
+    uint64_t new_hi = hi_ + n.hi_ + (new_lo < lo_ ? 1 : 0);
+    FMT_ASSERT(new_hi >= hi_, "");
+    lo_ = new_lo;
+    hi_ = new_hi;
+  }
+  FMT_CONSTEXPR void operator&=(uint128_fallback n) {
+    lo_ &= n.lo_;
+    hi_ &= n.hi_;
+  }
+
+  FMT_CONSTEXPR20 uint128_fallback& operator+=(uint64_t n) noexcept {
+    if (is_constant_evaluated()) {
+      lo_ += n;
+      hi_ += (lo_ < n ? 1 : 0);
+      return *this;
+    }
+#if FMT_HAS_BUILTIN(__builtin_addcll) && !defined(__ibmxl__)
+    unsigned long long carry;
+    lo_ = __builtin_addcll(lo_, n, 0, &carry);
+    hi_ += carry;
+#elif FMT_HAS_BUILTIN(__builtin_ia32_addcarryx_u64) && !defined(__ibmxl__)
+    unsigned long long result;
+    auto carry = __builtin_ia32_addcarryx_u64(0, lo_, n, &result);
+    lo_ = result;
+    hi_ += carry;
+#elif defined(_MSC_VER) && defined(_M_X64)
+    auto carry = _addcarry_u64(0, lo_, n, &lo_);
+    _addcarry_u64(carry, hi_, 0, &hi_);
+#else
+    lo_ += n;
+    hi_ += (lo_ < n ? 1 : 0);
+#endif
+    return *this;
+  }
+};
+
+using uint128_t = conditional_t<FMT_USE_INT128, uint128_opt, uint128_fallback>;
+
+#ifdef UINTPTR_MAX
+using uintptr_t = ::uintptr_t;
+#else
+using uintptr_t = uint128_t;
+#endif
+
+// Returns the largest possible value for type T. Same as
+// std::numeric_limits<T>::max() but shorter and not affected by the max macro.
+template <typename T> constexpr auto max_value() -> T {
+  return (std::numeric_limits<T>::max)();
+}
+template <typename T> constexpr auto num_bits() -> int {
+  return std::numeric_limits<T>::digits;
+}
+// std::numeric_limits<T>::digits may return 0 for 128-bit ints.
+template <> constexpr auto num_bits<int128_opt>() -> int { return 128; }
+template <> constexpr auto num_bits<uint128_t>() -> int { return 128; }
+
+// A heterogeneous bit_cast used for converting 96-bit long double to uint128_t
+// and 128-bit pointers to uint128_fallback.
+template <typename To, typename From, FMT_ENABLE_IF(sizeof(To) > sizeof(From))>
+inline auto bit_cast(const From& from) -> To {
+  constexpr auto size = static_cast<int>(sizeof(From) / sizeof(unsigned));
+  struct data_t {
+    unsigned value[static_cast<unsigned>(size)];
+  } data = bit_cast<data_t>(from);
+  auto result = To();
+  if (const_check(is_big_endian())) {
+    for (int i = 0; i < size; ++i)
+      result = (result << num_bits<unsigned>()) | data.value[i];
+  } else {
+    for (int i = size - 1; i >= 0; --i)
+      result = (result << num_bits<unsigned>()) | data.value[i];
+  }
+  return result;
+}
+
+template <typename UInt>
+FMT_CONSTEXPR20 inline auto countl_zero_fallback(UInt n) -> int {
+  int lz = 0;
+  constexpr UInt msb_mask = static_cast<UInt>(1) << (num_bits<UInt>() - 1);
+  for (; (n & msb_mask) == 0; n <<= 1) lz++;
+  return lz;
+}
+
+FMT_CONSTEXPR20 inline auto countl_zero(uint32_t n) -> int {
+#ifdef FMT_BUILTIN_CLZ
+  if (!is_constant_evaluated()) return FMT_BUILTIN_CLZ(n);
+#endif
+  return countl_zero_fallback(n);
+}
+
+FMT_CONSTEXPR20 inline auto countl_zero(uint64_t n) -> int {
+#ifdef FMT_BUILTIN_CLZLL
+  if (!is_constant_evaluated()) return FMT_BUILTIN_CLZLL(n);
+#endif
+  return countl_zero_fallback(n);
+}
+
+FMT_INLINE void assume(bool condition) {
+  (void)condition;
+#if FMT_HAS_BUILTIN(__builtin_assume) && !FMT_ICC_VERSION
+  __builtin_assume(condition);
+#endif
+}
+
+// An approximation of iterator_t for pre-C++20 systems.
+template <typename T>
+using iterator_t = decltype(std::begin(std::declval<T&>()));
+template <typename T> using sentinel_t = decltype(std::end(std::declval<T&>()));
+
+// A workaround for std::string not having mutable data() until C++17.
+template <typename Char>
+inline auto get_data(std::basic_string<Char>& s) -> Char* {
+  return &s[0];
+}
+template <typename Container>
+inline auto get_data(Container& c) -> typename Container::value_type* {
+  return c.data();
+}
+
+#if defined(_SECURE_SCL) && _SECURE_SCL
+// Make a checked iterator to avoid MSVC warnings.
+template <typename T> using checked_ptr = stdext::checked_array_iterator<T*>;
+template <typename T>
+constexpr auto make_checked(T* p, size_t size) -> checked_ptr<T> {
+  return {p, size};
+}
+#else
+template <typename T> using checked_ptr = T*;
+template <typename T> constexpr auto make_checked(T* p, size_t) -> T* {
+  return p;
+}
+#endif
+
+// Attempts to reserve space for n extra characters in the output range.
+// Returns a pointer to the reserved range or a reference to it.
+template <typename Container, FMT_ENABLE_IF(is_contiguous<Container>::value)>
+#if FMT_CLANG_VERSION >= 307 && !FMT_ICC_VERSION
+__attribute__((no_sanitize("undefined")))
+#endif
+inline auto
+reserve(std::back_insert_iterator<Container> it, size_t n)
+    -> checked_ptr<typename Container::value_type> {
+  Container& c = get_container(it);
+  size_t size = c.size();
+  c.resize(size + n);
+  return make_checked(get_data(c) + size, n);
+}
+
+template <typename T>
+inline auto reserve(buffer_appender<T> it, size_t n) -> buffer_appender<T> {
+  buffer<T>& buf = get_container(it);
+  buf.try_reserve(buf.size() + n);
+  return it;
+}
+
+template <typename Iterator>
+constexpr auto reserve(Iterator& it, size_t) -> Iterator& {
+  return it;
+}
+
+template <typename OutputIt>
+using reserve_iterator =
+    remove_reference_t<decltype(reserve(std::declval<OutputIt&>(), 0))>;
+
+template <typename T, typename OutputIt>
+constexpr auto to_pointer(OutputIt, size_t) -> T* {
+  return nullptr;
+}
+template <typename T> auto to_pointer(buffer_appender<T> it, size_t n) -> T* {
+  buffer<T>& buf = get_container(it);
+  auto size = buf.size();
+  if (buf.capacity() < size + n) return nullptr;
+  buf.try_resize(size + n);
+  return buf.data() + size;
+}
+
+template <typename Container, FMT_ENABLE_IF(is_contiguous<Container>::value)>
+inline auto base_iterator(std::back_insert_iterator<Container>& it,
+                          checked_ptr<typename Container::value_type>)
+    -> std::back_insert_iterator<Container> {
+  return it;
+}
+
+template <typename Iterator>
+constexpr auto base_iterator(Iterator, Iterator it) -> Iterator {
+  return it;
+}
+
+// <algorithm> is spectacularly slow to compile in C++20 so use a simple fill_n
+// instead (#1998).
+template <typename OutputIt, typename Size, typename T>
+FMT_CONSTEXPR auto fill_n(OutputIt out, Size count, const T& value)
+    -> OutputIt {
+  for (Size i = 0; i < count; ++i) *out++ = value;
+  return out;
+}
+template <typename T, typename Size>
+FMT_CONSTEXPR20 auto fill_n(T* out, Size count, char value) -> T* {
+  if (is_constant_evaluated()) {
+    return fill_n<T*, Size, T>(out, count, value);
+  }
+  std::memset(out, value, to_unsigned(count));
+  return out + count;
+}
+
+#ifdef __cpp_char8_t
+using char8_type = char8_t;
+#else
+enum char8_type : unsigned char {};
+#endif
+
+template <typename OutChar, typename InputIt, typename OutputIt>
+FMT_CONSTEXPR FMT_NOINLINE auto copy_str_noinline(InputIt begin, InputIt end,
+                                                  OutputIt out) -> OutputIt {
+  return copy_str<OutChar>(begin, end, out);
+}
+
+// A public domain branchless UTF-8 decoder by Christopher Wellons:
+// https://github.com/skeeto/branchless-utf8
+/* Decode the next character, c, from s, reporting errors in e.
+ *
+ * Since this is a branchless decoder, four bytes will be read from the
+ * buffer regardless of the actual length of the next character. This
+ * means the buffer _must_ have at least three bytes of zero padding
+ * following the end of the data stream.
+ *
+ * Errors are reported in e, which will be non-zero if the parsed
+ * character was somehow invalid: invalid byte sequence, non-canonical
+ * encoding, or a surrogate half.
+ *
+ * The function returns a pointer to the next character. When an error
+ * occurs, this pointer will be a guess that depends on the particular
+ * error, but it will always advance at least one byte.
+ */
+FMT_CONSTEXPR inline auto utf8_decode(const char* s, uint32_t* c, int* e)
+    -> const char* {
+  constexpr const int masks[] = {0x00, 0x7f, 0x1f, 0x0f, 0x07};
+  constexpr const uint32_t mins[] = {4194304, 0, 128, 2048, 65536};
+  constexpr const int shiftc[] = {0, 18, 12, 6, 0};
+  constexpr const int shifte[] = {0, 6, 4, 2, 0};
+
+  int len = "\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\0\0\0\0\0\0\0\0\2\2\2\2\3\3\4"
+      [static_cast<unsigned char>(*s) >> 3];
+  // Compute the pointer to the next character early so that the next
+  // iteration can start working on the next character. Neither Clang
+  // nor GCC figure out this reordering on their own.
+  const char* next = s + len + !len;
+
+  using uchar = unsigned char;
+
+  // Assume a four-byte character and load four bytes. Unused bits are
+  // shifted out.
+  *c = uint32_t(uchar(s[0]) & masks[len]) << 18;
+  *c |= uint32_t(uchar(s[1]) & 0x3f) << 12;
+  *c |= uint32_t(uchar(s[2]) & 0x3f) << 6;
+  *c |= uint32_t(uchar(s[3]) & 0x3f) << 0;
+  *c >>= shiftc[len];
+
+  // Accumulate the various error conditions.
+  *e = (*c < mins[len]) << 6;       // non-canonical encoding
+  *e |= ((*c >> 11) == 0x1b) << 7;  // surrogate half?
+  *e |= (*c > 0x10FFFF) << 8;       // out of range?
+  *e |= (uchar(s[1]) & 0xc0) >> 2;
+  *e |= (uchar(s[2]) & 0xc0) >> 4;
+  *e |= uchar(s[3]) >> 6;
+  *e ^= 0x2a;  // top two bits of each tail byte correct?
+  *e >>= shifte[len];
+
+  return next;
+}
+
+constexpr FMT_INLINE_VARIABLE uint32_t invalid_code_point = ~uint32_t();
+
+// Invokes f(cp, sv) for every code point cp in s with sv being the string view
+// corresponding to the code point. cp is invalid_code_point on error.
+template <typename F>
+FMT_CONSTEXPR void for_each_codepoint(string_view s, F f) {
+  auto decode = [f](const char* buf_ptr, const char* ptr) {
+    auto cp = uint32_t();
+    auto error = 0;
+    auto end = utf8_decode(buf_ptr, &cp, &error);
+    bool result = f(error ? invalid_code_point : cp,
+                    string_view(ptr, error ? 1 : to_unsigned(end - buf_ptr)));
+    return result ? (error ? buf_ptr + 1 : end) : nullptr;
+  };
+  auto p = s.data();
+  const size_t block_size = 4;  // utf8_decode always reads blocks of 4 chars.
+  if (s.size() >= block_size) {
+    for (auto end = p + s.size() - block_size + 1; p < end;) {
+      p = decode(p, p);
+      if (!p) return;
+    }
+  }
+  if (auto num_chars_left = s.data() + s.size() - p) {
+    char buf[2 * block_size - 1] = {};
+    copy_str<char>(p, p + num_chars_left, buf);
+    const char* buf_ptr = buf;
+    do {
+      auto end = decode(buf_ptr, p);
+      if (!end) return;
+      p += end - buf_ptr;
+      buf_ptr = end;
+    } while (buf_ptr - buf < num_chars_left);
+  }
+}
+
+template <typename Char>
+inline auto compute_width(basic_string_view<Char> s) -> size_t {
+  return s.size();
+}
+
+// Computes approximate display width of a UTF-8 string.
+FMT_CONSTEXPR inline size_t compute_width(string_view s) {
+  size_t num_code_points = 0;
+  // It is not a lambda for compatibility with C++14.
+  struct count_code_points {
+    size_t* count;
+    FMT_CONSTEXPR auto operator()(uint32_t cp, string_view) const -> bool {
+      *count += detail::to_unsigned(
+          1 +
+          (cp >= 0x1100 &&
+           (cp <= 0x115f ||  // Hangul Jamo init. consonants
+            cp == 0x2329 ||  // LEFT-POINTING ANGLE BRACKET
+            cp == 0x232a ||  // RIGHT-POINTING ANGLE BRACKET
+            // CJK ... Yi except IDEOGRAPHIC HALF FILL SPACE:
+            (cp >= 0x2e80 && cp <= 0xa4cf && cp != 0x303f) ||
+            (cp >= 0xac00 && cp <= 0xd7a3) ||    // Hangul Syllables
+            (cp >= 0xf900 && cp <= 0xfaff) ||    // CJK Compatibility Ideographs
+            (cp >= 0xfe10 && cp <= 0xfe19) ||    // Vertical Forms
+            (cp >= 0xfe30 && cp <= 0xfe6f) ||    // CJK Compatibility Forms
+            (cp >= 0xff00 && cp <= 0xff60) ||    // Fullwidth Forms
+            (cp >= 0xffe0 && cp <= 0xffe6) ||    // Fullwidth Forms
+            (cp >= 0x20000 && cp <= 0x2fffd) ||  // CJK
+            (cp >= 0x30000 && cp <= 0x3fffd) ||
+            // Miscellaneous Symbols and Pictographs + Emoticons:
+            (cp >= 0x1f300 && cp <= 0x1f64f) ||
+            // Supplemental Symbols and Pictographs:
+            (cp >= 0x1f900 && cp <= 0x1f9ff))));
+      return true;
+    }
+  };
+  // We could avoid branches by using utf8_decode directly.
+  for_each_codepoint(s, count_code_points{&num_code_points});
+  return num_code_points;
+}
+
+inline auto compute_width(basic_string_view<char8_type> s) -> size_t {
+  return compute_width(
+      string_view(reinterpret_cast<const char*>(s.data()), s.size()));
+}
+
+template <typename Char>
+inline auto code_point_index(basic_string_view<Char> s, size_t n) -> size_t {
+  size_t size = s.size();
+  return n < size ? n : size;
+}
+
+// Calculates the index of the nth code point in a UTF-8 string.
+inline auto code_point_index(string_view s, size_t n) -> size_t {
+  const char* data = s.data();
+  size_t num_code_points = 0;
+  for (size_t i = 0, size = s.size(); i != size; ++i) {
+    if ((data[i] & 0xc0) != 0x80 && ++num_code_points > n) return i;
+  }
+  return s.size();
+}
+
+inline auto code_point_index(basic_string_view<char8_type> s, size_t n)
+    -> size_t {
+  return code_point_index(
+      string_view(reinterpret_cast<const char*>(s.data()), s.size()), n);
+}
+
+template <typename T> struct is_integral : std::is_integral<T> {};
+template <> struct is_integral<int128_opt> : std::true_type {};
+template <> struct is_integral<uint128_t> : std::true_type {};
+
+template <typename T>
+using is_signed =
+    std::integral_constant<bool, std::numeric_limits<T>::is_signed ||
+                                     std::is_same<T, int128_opt>::value>;
+
+template <typename T>
+using is_integer =
+    bool_constant<is_integral<T>::value && !std::is_same<T, bool>::value &&
+                  !std::is_same<T, char>::value &&
+                  !std::is_same<T, wchar_t>::value>;
+
+#ifndef FMT_USE_FLOAT
+#  define FMT_USE_FLOAT 1
+#endif
+#ifndef FMT_USE_DOUBLE
+#  define FMT_USE_DOUBLE 1
+#endif
+#ifndef FMT_USE_LONG_DOUBLE
+#  define FMT_USE_LONG_DOUBLE 1
+#endif
+
+#ifndef FMT_USE_FLOAT128
+#  ifdef __clang__
+// Clang emulates GCC, so it has to appear early.
+#    if FMT_HAS_INCLUDE(<quadmath.h>)
+#      define FMT_USE_FLOAT128 1
+#    endif
+#  elif defined(__GNUC__)
+// GNU C++:
+#    if defined(_GLIBCXX_USE_FLOAT128) && !defined(__STRICT_ANSI__)
+#      define FMT_USE_FLOAT128 1
+#    endif
+#  endif
+#  ifndef FMT_USE_FLOAT128
+#    define FMT_USE_FLOAT128 0
+#  endif
+#endif
+
+#if FMT_USE_FLOAT128
+using float128 = __float128;
+#else
+using float128 = void;
+#endif
+template <typename T> using is_float128 = std::is_same<T, float128>;
+
+template <typename T>
+using is_floating_point =
+    bool_constant<std::is_floating_point<T>::value || is_float128<T>::value>;
+
+template <typename T, bool = std::is_floating_point<T>::value>
+struct is_fast_float : bool_constant<std::numeric_limits<T>::is_iec559 &&
+                                     sizeof(T) <= sizeof(double)> {};
+template <typename T> struct is_fast_float<T, false> : std::false_type {};
+
+template <typename T>
+using is_double_double = bool_constant<std::numeric_limits<T>::digits == 106>;
+
+#ifndef FMT_USE_FULL_CACHE_DRAGONBOX
+#  define FMT_USE_FULL_CACHE_DRAGONBOX 0
+#endif
+
+template <typename T>
+template <typename U>
+void buffer<T>::append(const U* begin, const U* end) {
+  while (begin != end) {
+    auto count = to_unsigned(end - begin);
+    try_reserve(size_ + count);
+    auto free_cap = capacity_ - size_;
+    if (free_cap < count) count = free_cap;
+    std::uninitialized_copy_n(begin, count, make_checked(ptr_ + size_, count));
+    size_ += count;
+    begin += count;
+  }
+}
+
+template <typename T, typename Enable = void>
+struct is_locale : std::false_type {};
+template <typename T>
+struct is_locale<T, void_t<decltype(T::classic())>> : std::true_type {};
+}  // namespace detail
+
+FMT_BEGIN_EXPORT
+
+// The number of characters to store in the basic_memory_buffer object itself
+// to avoid dynamic memory allocation.
+enum { inline_buffer_size = 500 };
+
+/**
+  \rst
+  A dynamically growing memory buffer for trivially copyable/constructible types
+  with the first ``SIZE`` elements stored in the object itself.
+
+  You can use the ``memory_buffer`` type alias for ``char`` instead.
+
+  **Example**::
+
+     auto out = fmt::memory_buffer();
+     format_to(std::back_inserter(out), "The answer is {}.", 42);
+
+  This will append the following output to the ``out`` object:
+
+  .. code-block:: none
+
+     The answer is 42.
+
+  The output can be converted to an ``std::string`` with ``to_string(out)``.
+  \endrst
+ */
+template <typename T, size_t SIZE = inline_buffer_size,
+          typename Allocator = std::allocator<T>>
+class basic_memory_buffer final : public detail::buffer<T> {
+ private:
+  T store_[SIZE];
+
+  // Don't inherit from Allocator avoid generating type_info for it.
+  Allocator alloc_;
+
+  // Deallocate memory allocated by the buffer.
+  FMT_CONSTEXPR20 void deallocate() {
+    T* data = this->data();
+    if (data != store_) alloc_.deallocate(data, this->capacity());
+  }
+
+ protected:
+  FMT_CONSTEXPR20 void grow(size_t size) override {
+    detail::abort_fuzzing_if(size > 5000);
+    const size_t max_size = std::allocator_traits<Allocator>::max_size(alloc_);
+    size_t old_capacity = this->capacity();
+    size_t new_capacity = old_capacity + old_capacity / 2;
+    if (size > new_capacity)
+      new_capacity = size;
+    else if (new_capacity > max_size)
+      new_capacity = size > max_size ? size : max_size;
+    T* old_data = this->data();
+    T* new_data =
+        std::allocator_traits<Allocator>::allocate(alloc_, new_capacity);
+    // The following code doesn't throw, so the raw pointer above doesn't leak.
+    std::uninitialized_copy(old_data, old_data + this->size(),
+                            detail::make_checked(new_data, new_capacity));
+    this->set(new_data, new_capacity);
+    // deallocate must not throw according to the standard, but even if it does,
+    // the buffer already uses the new storage and will deallocate it in
+    // destructor.
+    if (old_data != store_) alloc_.deallocate(old_data, old_capacity);
+  }
+
+ public:
+  using value_type = T;
+  using const_reference = const T&;
+
+  FMT_CONSTEXPR20 explicit basic_memory_buffer(
+      const Allocator& alloc = Allocator())
+      : alloc_(alloc) {
+    this->set(store_, SIZE);
+    if (detail::is_constant_evaluated()) detail::fill_n(store_, SIZE, T());
+  }
+  FMT_CONSTEXPR20 ~basic_memory_buffer() { deallocate(); }
+
+ private:
+  // Move data from other to this buffer.
+  FMT_CONSTEXPR20 void move(basic_memory_buffer& other) {
+    alloc_ = std::move(other.alloc_);
+    T* data = other.data();
+    size_t size = other.size(), capacity = other.capacity();
+    if (data == other.store_) {
+      this->set(store_, capacity);
+      detail::copy_str<T>(other.store_, other.store_ + size,
+                          detail::make_checked(store_, capacity));
+    } else {
+      this->set(data, capacity);
+      // Set pointer to the inline array so that delete is not called
+      // when deallocating.
+      other.set(other.store_, 0);
+      other.clear();
+    }
+    this->resize(size);
+  }
+
+ public:
+  /**
+    \rst
+    Constructs a :class:`fmt::basic_memory_buffer` object moving the content
+    of the other object to it.
+    \endrst
+   */
+  FMT_CONSTEXPR20 basic_memory_buffer(basic_memory_buffer&& other) noexcept {
+    move(other);
+  }
+
+  /**
+    \rst
+    Moves the content of the other ``basic_memory_buffer`` object to this one.
+    \endrst
+   */
+  auto operator=(basic_memory_buffer&& other) noexcept -> basic_memory_buffer& {
+    FMT_ASSERT(this != &other, "");
+    deallocate();
+    move(other);
+    return *this;
+  }
+
+  // Returns a copy of the allocator associated with this buffer.
+  auto get_allocator() const -> Allocator { return alloc_; }
+
+  /**
+    Resizes the buffer to contain *count* elements. If T is a POD type new
+    elements may not be initialized.
+   */
+  FMT_CONSTEXPR20 void resize(size_t count) { this->try_resize(count); }
+
+  /** Increases the buffer capacity to *new_capacity*. */
+  void reserve(size_t new_capacity) { this->try_reserve(new_capacity); }
+
+  // Directly append data into the buffer
+  using detail::buffer<T>::append;
+  template <typename ContiguousRange>
+  void append(const ContiguousRange& range) {
+    append(range.data(), range.data() + range.size());
+  }
+};
+
+using memory_buffer = basic_memory_buffer<char>;
+
+template <typename T, size_t SIZE, typename Allocator>
+struct is_contiguous<basic_memory_buffer<T, SIZE, Allocator>> : std::true_type {
+};
+
+FMT_END_EXPORT
+namespace detail {
+FMT_API bool write_console(std::FILE* f, string_view text);
+FMT_API void print(std::FILE*, string_view);
+}  // namespace detail
+FMT_BEGIN_EXPORT
+
+// Suppress a misleading warning in older versions of clang.
+#if FMT_CLANG_VERSION
+#  pragma clang diagnostic ignored "-Wweak-vtables"
+#endif
+
+/** An error reported from a formatting function. */
+class FMT_API format_error : public std::runtime_error {
+ public:
+  using std::runtime_error::runtime_error;
+};
+
+namespace detail_exported {
+#if FMT_USE_NONTYPE_TEMPLATE_ARGS
+template <typename Char, size_t N> struct fixed_string {
+  constexpr fixed_string(const Char (&str)[N]) {
+    detail::copy_str<Char, const Char*, Char*>(static_cast<const Char*>(str),
+                                               str + N, data);
+  }
+  Char data[N] = {};
+};
+#endif
+
+// Converts a compile-time string to basic_string_view.
+template <typename Char, size_t N>
+constexpr auto compile_string_to_view(const Char (&s)[N])
+    -> basic_string_view<Char> {
+  // Remove trailing NUL character if needed. Won't be present if this is used
+  // with a raw character array (i.e. not defined as a string).
+  return {s, N - (std::char_traits<Char>::to_int_type(s[N - 1]) == 0 ? 1 : 0)};
+}
+template <typename Char>
+constexpr auto compile_string_to_view(detail::std_string_view<Char> s)
+    -> basic_string_view<Char> {
+  return {s.data(), s.size()};
+}
+}  // namespace detail_exported
+
+class loc_value {
+ private:
+  basic_format_arg<format_context> value_;
+
+ public:
+  template <typename T, FMT_ENABLE_IF(!detail::is_float128<T>::value)>
+  loc_value(T value) : value_(detail::make_arg<format_context>(value)) {}
+
+  template <typename T, FMT_ENABLE_IF(detail::is_float128<T>::value)>
+  loc_value(T) {}
+
+  template <typename Visitor> auto visit(Visitor&& vis) -> decltype(vis(0)) {
+    return visit_format_arg(vis, value_);
+  }
+};
+
+// A locale facet that formats values in UTF-8.
+// It is parameterized on the locale to avoid the heavy <locale> include.
+template <typename Locale> class format_facet : public Locale::facet {
+ private:
+  std::string separator_;
+  std::string grouping_;
+  std::string decimal_point_;
+
+ protected:
+  virtual auto do_put(appender out, loc_value val,
+                      const format_specs<>& specs) const -> bool;
+
+ public:
+  static FMT_API typename Locale::id id;
+
+  explicit format_facet(Locale& loc);
+  explicit format_facet(string_view sep = "",
+                        std::initializer_list<unsigned char> g = {3},
+                        std::string decimal_point = ".")
+      : separator_(sep.data(), sep.size()),
+        grouping_(g.begin(), g.end()),
+        decimal_point_(decimal_point) {}
+
+  auto put(appender out, loc_value val, const format_specs<>& specs) const
+      -> bool {
+    return do_put(out, val, specs);
+  }
+};
+
+FMT_BEGIN_DETAIL_NAMESPACE
+
+// Returns true if value is negative, false otherwise.
+// Same as `value < 0` but doesn't produce warnings if T is an unsigned type.
+template <typename T, FMT_ENABLE_IF(is_signed<T>::value)>
+constexpr auto is_negative(T value) -> bool {
+  return value < 0;
+}
+template <typename T, FMT_ENABLE_IF(!is_signed<T>::value)>
+constexpr auto is_negative(T) -> bool {
+  return false;
+}
+
+template <typename T>
+FMT_CONSTEXPR auto is_supported_floating_point(T) -> bool {
+  if (std::is_same<T, float>()) return FMT_USE_FLOAT;
+  if (std::is_same<T, double>()) return FMT_USE_DOUBLE;
+  if (std::is_same<T, long double>()) return FMT_USE_LONG_DOUBLE;
+  return true;
+}
+
+// Smallest of uint32_t, uint64_t, uint128_t that is large enough to
+// represent all values of an integral type T.
+template <typename T>
+using uint32_or_64_or_128_t =
+    conditional_t<num_bits<T>() <= 32 && !FMT_REDUCE_INT_INSTANTIATIONS,
+                  uint32_t,
+                  conditional_t<num_bits<T>() <= 64, uint64_t, uint128_t>>;
+template <typename T>
+using uint64_or_128_t = conditional_t<num_bits<T>() <= 64, uint64_t, uint128_t>;
+
+#define FMT_POWERS_OF_10(factor)                                             \
+  factor * 10, (factor)*100, (factor)*1000, (factor)*10000, (factor)*100000, \
+      (factor)*1000000, (factor)*10000000, (factor)*100000000,               \
+      (factor)*1000000000
+
+// Converts value in the range [0, 100) to a string.
+constexpr const char* digits2(size_t value) {
+  // GCC generates slightly better code when value is pointer-size.
+  return &"0001020304050607080910111213141516171819"
+         "2021222324252627282930313233343536373839"
+         "4041424344454647484950515253545556575859"
+         "6061626364656667686970717273747576777879"
+         "8081828384858687888990919293949596979899"[value * 2];
+}
+
+// Sign is a template parameter to workaround a bug in gcc 4.8.
+template <typename Char, typename Sign> constexpr Char sign(Sign s) {
+#if !FMT_GCC_VERSION || FMT_GCC_VERSION >= 604
+  static_assert(std::is_same<Sign, sign_t>::value, "");
+#endif
+  return static_cast<Char>("\0-+ "[s]);
+}
+
+template <typename T> FMT_CONSTEXPR auto count_digits_fallback(T n) -> int {
+  int count = 1;
+  for (;;) {
+    // Integer division is slow so do it for a group of four digits instead
+    // of for every digit. The idea comes from the talk by Alexandrescu
+    // "Three Optimization Tips for C++". See speed-test for a comparison.
+    if (n < 10) return count;
+    if (n < 100) return count + 1;
+    if (n < 1000) return count + 2;
+    if (n < 10000) return count + 3;
+    n /= 10000u;
+    count += 4;
+  }
+}
+#if FMT_USE_INT128
+FMT_CONSTEXPR inline auto count_digits(uint128_opt n) -> int {
+  return count_digits_fallback(n);
+}
+#endif
+
+#ifdef FMT_BUILTIN_CLZLL
+// It is a separate function rather than a part of count_digits to workaround
+// the lack of static constexpr in constexpr functions.
+inline auto do_count_digits(uint64_t n) -> int {
+  // This has comparable performance to the version by Kendall Willets
+  // (https://github.com/fmtlib/format-benchmark/blob/master/digits10)
+  // but uses smaller tables.
+  // Maps bsr(n) to ceil(log10(pow(2, bsr(n) + 1) - 1)).
+  static constexpr uint8_t bsr2log10[] = {
+      1,  1,  1,  2,  2,  2,  3,  3,  3,  4,  4,  4,  4,  5,  5,  5,
+      6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9,  10, 10, 10,
+      10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15,
+      15, 16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 19, 20};
+  auto t = bsr2log10[FMT_BUILTIN_CLZLL(n | 1) ^ 63];
+  static constexpr const uint64_t zero_or_powers_of_10[] = {
+      0, 0, FMT_POWERS_OF_10(1U), FMT_POWERS_OF_10(1000000000ULL),
+      10000000000000000000ULL};
+  return t - (n < zero_or_powers_of_10[t]);
+}
+#endif
+
+// Returns the number of decimal digits in n. Leading zeros are not counted
+// except for n == 0 in which case count_digits returns 1.
+FMT_CONSTEXPR20 inline auto count_digits(uint64_t n) -> int {
+#ifdef FMT_BUILTIN_CLZLL
+  if (!is_constant_evaluated()) {
+    return do_count_digits(n);
+  }
+#endif
+  return count_digits_fallback(n);
+}
+
+// Counts the number of digits in n. BITS = log2(radix).
+template <int BITS, typename UInt>
+FMT_CONSTEXPR auto count_digits(UInt n) -> int {
+#ifdef FMT_BUILTIN_CLZ
+  if (!is_constant_evaluated() && num_bits<UInt>() == 32)
+    return (FMT_BUILTIN_CLZ(static_cast<uint32_t>(n) | 1) ^ 31) / BITS + 1;
+#endif
+  // Lambda avoids unreachable code warnings from NVHPC.
+  return [](UInt m) {
+    int num_digits = 0;
+    do {
+      ++num_digits;
+    } while ((m >>= BITS) != 0);
+    return num_digits;
+  }(n);
+}
+
+#ifdef FMT_BUILTIN_CLZ
+// It is a separate function rather than a part of count_digits to workaround
+// the lack of static constexpr in constexpr functions.
+FMT_INLINE auto do_count_digits(uint32_t n) -> int {
+// An optimization by Kendall Willets from https://bit.ly/3uOIQrB.
+// This increments the upper 32 bits (log10(T) - 1) when >= T is added.
+#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
+  static constexpr uint64_t table[] = {
+      FMT_INC(0),          FMT_INC(0),          FMT_INC(0),           // 8
+      FMT_INC(10),         FMT_INC(10),         FMT_INC(10),          // 64
+      FMT_INC(100),        FMT_INC(100),        FMT_INC(100),         // 512
+      FMT_INC(1000),       FMT_INC(1000),       FMT_INC(1000),        // 4096
+      FMT_INC(10000),      FMT_INC(10000),      FMT_INC(10000),       // 32k
+      FMT_INC(100000),     FMT_INC(100000),     FMT_INC(100000),      // 256k
+      FMT_INC(1000000),    FMT_INC(1000000),    FMT_INC(1000000),     // 2048k
+      FMT_INC(10000000),   FMT_INC(10000000),   FMT_INC(10000000),    // 16M
+      FMT_INC(100000000),  FMT_INC(100000000),  FMT_INC(100000000),   // 128M
+      FMT_INC(1000000000), FMT_INC(1000000000), FMT_INC(1000000000),  // 1024M
+      FMT_INC(1000000000), FMT_INC(1000000000)                        // 4B
+  };
+  auto inc = table[FMT_BUILTIN_CLZ(n | 1) ^ 31];
+  return static_cast<int>((n + inc) >> 32);
+}
+#endif
+
+// Optional version of count_digits for better performance on 32-bit platforms.
+FMT_CONSTEXPR20 inline auto count_digits(uint32_t n) -> int {
+#ifdef FMT_BUILTIN_CLZ
+  if (!is_constant_evaluated()) {
+    return do_count_digits(n);
+  }
+#endif
+  return count_digits_fallback(n);
+}
+
+template <typename Int> constexpr auto digits10() noexcept -> int {
+  return std::numeric_limits<Int>::digits10;
+}
+template <> constexpr auto digits10<int128_opt>() noexcept -> int { return 38; }
+template <> constexpr auto digits10<uint128_t>() noexcept -> int { return 38; }
+
+template <typename Char> struct thousands_sep_result {
+  std::string grouping;
+  Char thousands_sep;
+};
+
+template <typename Char>
+FMT_API auto thousands_sep_impl(locale_ref loc) -> thousands_sep_result<Char>;
+template <typename Char>
+inline auto thousands_sep(locale_ref loc) -> thousands_sep_result<Char> {
+  auto result = thousands_sep_impl<char>(loc);
+  return {result.grouping, Char(result.thousands_sep)};
+}
+template <>
+inline auto thousands_sep(locale_ref loc) -> thousands_sep_result<wchar_t> {
+  return thousands_sep_impl<wchar_t>(loc);
+}
+
+template <typename Char>
+FMT_API auto decimal_point_impl(locale_ref loc) -> Char;
+template <typename Char> inline auto decimal_point(locale_ref loc) -> Char {
+  return Char(decimal_point_impl<char>(loc));
+}
+template <> inline auto decimal_point(locale_ref loc) -> wchar_t {
+  return decimal_point_impl<wchar_t>(loc);
+}
+
+// Compares two characters for equality.
+template <typename Char> auto equal2(const Char* lhs, const char* rhs) -> bool {
+  return lhs[0] == Char(rhs[0]) && lhs[1] == Char(rhs[1]);
+}
+inline auto equal2(const char* lhs, const char* rhs) -> bool {
+  return memcmp(lhs, rhs, 2) == 0;
+}
+
+// Copies two characters from src to dst.
+template <typename Char>
+FMT_CONSTEXPR20 FMT_INLINE void copy2(Char* dst, const char* src) {
+  if (!is_constant_evaluated() && sizeof(Char) == sizeof(char)) {
+    memcpy(dst, src, 2);
+    return;
+  }
+  *dst++ = static_cast<Char>(*src++);
+  *dst = static_cast<Char>(*src);
+}
+
+template <typename Iterator> struct format_decimal_result {
+  Iterator begin;
+  Iterator end;
+};
+
+// Formats a decimal unsigned integer value writing into out pointing to a
+// buffer of specified size. The caller must ensure that the buffer is large
+// enough.
+template <typename Char, typename UInt>
+FMT_CONSTEXPR20 auto format_decimal(Char* out, UInt value, int size)
+    -> format_decimal_result<Char*> {
+  FMT_ASSERT(size >= count_digits(value), "invalid digit count");
+  out += size;
+  Char* end = out;
+  while (value >= 100) {
+    // Integer division is slow so do it for a group of two digits instead
+    // of for every digit. The idea comes from the talk by Alexandrescu
+    // "Three Optimization Tips for C++". See speed-test for a comparison.
+    out -= 2;
+    copy2(out, digits2(static_cast<size_t>(value % 100)));
+    value /= 100;
+  }
+  if (value < 10) {
+    *--out = static_cast<Char>('0' + value);
+    return {out, end};
+  }
+  out -= 2;
+  copy2(out, digits2(static_cast<size_t>(value)));
+  return {out, end};
+}
+
+template <typename Char, typename UInt, typename Iterator,
+          FMT_ENABLE_IF(!std::is_pointer<remove_cvref_t<Iterator>>::value)>
+FMT_CONSTEXPR inline auto format_decimal(Iterator out, UInt value, int size)
+    -> format_decimal_result<Iterator> {
+  // Buffer is large enough to hold all digits (digits10 + 1).
+  Char buffer[digits10<UInt>() + 1] = {};
+  auto end = format_decimal(buffer, value, size).end;
+  return {out, detail::copy_str_noinline<Char>(buffer, end, out)};
+}
+
+template <unsigned BASE_BITS, typename Char, typename UInt>
+FMT_CONSTEXPR auto format_uint(Char* buffer, UInt value, int num_digits,
+                               bool upper = false) -> Char* {
+  buffer += num_digits;
+  Char* end = buffer;
+  do {
+    const char* digits = upper ? "0123456789ABCDEF" : "0123456789abcdef";
+    unsigned digit = static_cast<unsigned>(value & ((1 << BASE_BITS) - 1));
+    *--buffer = static_cast<Char>(BASE_BITS < 4 ? static_cast<char>('0' + digit)
+                                                : digits[digit]);
+  } while ((value >>= BASE_BITS) != 0);
+  return end;
+}
+
+template <unsigned BASE_BITS, typename Char, typename It, typename UInt>
+inline auto format_uint(It out, UInt value, int num_digits, bool upper = false)
+    -> It {
+  if (auto ptr = to_pointer<Char>(out, to_unsigned(num_digits))) {
+    format_uint<BASE_BITS>(ptr, value, num_digits, upper);
+    return out;
+  }
+  // Buffer should be large enough to hold all digits (digits / BASE_BITS + 1).
+  char buffer[num_bits<UInt>() / BASE_BITS + 1];
+  format_uint<BASE_BITS>(buffer, value, num_digits, upper);
+  return detail::copy_str_noinline<Char>(buffer, buffer + num_digits, out);
+}
+
+// A converter from UTF-8 to UTF-16.
+class utf8_to_utf16 {
+ private:
+  basic_memory_buffer<wchar_t> buffer_;
+
+ public:
+  FMT_API explicit utf8_to_utf16(string_view s);
+  operator basic_string_view<wchar_t>() const { return {&buffer_[0], size()}; }
+  auto size() const -> size_t { return buffer_.size() - 1; }
+  auto c_str() const -> const wchar_t* { return &buffer_[0]; }
+  auto str() const -> std::wstring { return {&buffer_[0], size()}; }
+};
+
+// A converter from UTF-16/UTF-32 (host endian) to UTF-8.
+template <typename WChar, typename Buffer = memory_buffer>
+class unicode_to_utf8 {
+ private:
+  Buffer buffer_;
+
+ public:
+  unicode_to_utf8() {}
+  explicit unicode_to_utf8(basic_string_view<WChar> s) {
+    static_assert(sizeof(WChar) == 2 || sizeof(WChar) == 4,
+                  "Expect utf16 or utf32");
+
+    if (!convert(s))
+      FMT_THROW(std::runtime_error(sizeof(WChar) == 2 ? "invalid utf16"
+                                                      : "invalid utf32"));
+  }
+  operator string_view() const { return string_view(&buffer_[0], size()); }
+  size_t size() const { return buffer_.size() - 1; }
+  const char* c_str() const { return &buffer_[0]; }
+  std::string str() const { return std::string(&buffer_[0], size()); }
+
+  // Performs conversion returning a bool instead of throwing exception on
+  // conversion error. This method may still throw in case of memory allocation
+  // error.
+  bool convert(basic_string_view<WChar> s) {
+    if (!convert(buffer_, s)) return false;
+    buffer_.push_back(0);
+    return true;
+  }
+  static bool convert(Buffer& buf, basic_string_view<WChar> s) {
+    for (auto p = s.begin(); p != s.end(); ++p) {
+      uint32_t c = static_cast<uint32_t>(*p);
+      if (sizeof(WChar) == 2 && c >= 0xd800 && c <= 0xdfff) {
+        // surrogate pair
+        ++p;
+        if (p == s.end() || (c & 0xfc00) != 0xd800 || (*p & 0xfc00) != 0xdc00) {
+          return false;
+        }
+        c = (c << 10) + static_cast<uint32_t>(*p) - 0x35fdc00;
+      }
+      if (c < 0x80) {
+        buf.push_back(static_cast<char>(c));
+      } else if (c < 0x800) {
+        buf.push_back(static_cast<char>(0xc0 | (c >> 6)));
+        buf.push_back(static_cast<char>(0x80 | (c & 0x3f)));
+      } else if ((c >= 0x800 && c <= 0xd7ff) || (c >= 0xe000 && c <= 0xffff)) {
+        buf.push_back(static_cast<char>(0xe0 | (c >> 12)));
+        buf.push_back(static_cast<char>(0x80 | ((c & 0xfff) >> 6)));
+        buf.push_back(static_cast<char>(0x80 | (c & 0x3f)));
+      } else if (c >= 0x10000 && c <= 0x10ffff) {
+        buf.push_back(static_cast<char>(0xf0 | (c >> 18)));
+        buf.push_back(static_cast<char>(0x80 | ((c & 0x3ffff) >> 12)));
+        buf.push_back(static_cast<char>(0x80 | ((c & 0xfff) >> 6)));
+        buf.push_back(static_cast<char>(0x80 | (c & 0x3f)));
+      } else {
+        return false;
+      }
+    }
+    return true;
+  }
+};
+
+// Computes 128-bit result of multiplication of two 64-bit unsigned integers.
+inline uint128_fallback umul128(uint64_t x, uint64_t y) noexcept {
+#if FMT_USE_INT128
+  auto p = static_cast<uint128_opt>(x) * static_cast<uint128_opt>(y);
+  return {static_cast<uint64_t>(p >> 64), static_cast<uint64_t>(p)};
+#elif defined(_MSC_VER) && defined(_M_X64)
+  auto result = uint128_fallback();
+  result.lo_ = _umul128(x, y, &result.hi_);
+  return result;
+#else
+  const uint64_t mask = static_cast<uint64_t>(max_value<uint32_t>());
+
+  uint64_t a = x >> 32;
+  uint64_t b = x & mask;
+  uint64_t c = y >> 32;
+  uint64_t d = y & mask;
+
+  uint64_t ac = a * c;
+  uint64_t bc = b * c;
+  uint64_t ad = a * d;
+  uint64_t bd = b * d;
+
+  uint64_t intermediate = (bd >> 32) + (ad & mask) + (bc & mask);
+
+  return {ac + (intermediate >> 32) + (ad >> 32) + (bc >> 32),
+          (intermediate << 32) + (bd & mask)};
+#endif
+}
+
+namespace dragonbox {
+// Computes floor(log10(pow(2, e))) for e in [-2620, 2620] using the method from
+// https://fmt.dev/papers/Dragonbox.pdf#page=28, section 6.1.
+inline int floor_log10_pow2(int e) noexcept {
+  FMT_ASSERT(e <= 2620 && e >= -2620, "too large exponent");
+  static_assert((-1 >> 1) == -1, "right shift is not arithmetic");
+  return (e * 315653) >> 20;
+}
+
+inline int floor_log2_pow10(int e) noexcept {
+  FMT_ASSERT(e <= 1233 && e >= -1233, "too large exponent");
+  return (e * 1741647) >> 19;
+}
+
+// Computes upper 64 bits of multiplication of two 64-bit unsigned integers.
+inline uint64_t umul128_upper64(uint64_t x, uint64_t y) noexcept {
+#if FMT_USE_INT128
+  auto p = static_cast<uint128_opt>(x) * static_cast<uint128_opt>(y);
+  return static_cast<uint64_t>(p >> 64);
+#elif defined(_MSC_VER) && defined(_M_X64)
+  return __umulh(x, y);
+#else
+  return umul128(x, y).high();
+#endif
+}
+
+// Computes upper 128 bits of multiplication of a 64-bit unsigned integer and a
+// 128-bit unsigned integer.
+inline uint128_fallback umul192_upper128(uint64_t x,
+                                         uint128_fallback y) noexcept {
+  uint128_fallback r = umul128(x, y.high());
+  r += umul128_upper64(x, y.low());
+  return r;
+}
+
+FMT_API uint128_fallback get_cached_power(int k) noexcept;
+
+// Type-specific information that Dragonbox uses.
+template <typename T, typename Enable = void> struct float_info;
+
+template <> struct float_info<float> {
+  using carrier_uint = uint32_t;
+  static const int exponent_bits = 8;
+  static const int kappa = 1;
+  static const int big_divisor = 100;
+  static const int small_divisor = 10;
+  static const int min_k = -31;
+  static const int max_k = 46;
+  static const int shorter_interval_tie_lower_threshold = -35;
+  static const int shorter_interval_tie_upper_threshold = -35;
+};
+
+template <> struct float_info<double> {
+  using carrier_uint = uint64_t;
+  static const int exponent_bits = 11;
+  static const int kappa = 2;
+  static const int big_divisor = 1000;
+  static const int small_divisor = 100;
+  static const int min_k = -292;
+  static const int max_k = 341;
+  static const int shorter_interval_tie_lower_threshold = -77;
+  static const int shorter_interval_tie_upper_threshold = -77;
+};
+
+// An 80- or 128-bit floating point number.
+template <typename T>
+struct float_info<T, enable_if_t<std::numeric_limits<T>::digits == 64 ||
+                                 std::numeric_limits<T>::digits == 113 ||
+                                 is_float128<T>::value>> {
+  using carrier_uint = detail::uint128_t;
+  static const int exponent_bits = 15;
+};
+
+// A double-double floating point number.
+template <typename T>
+struct float_info<T, enable_if_t<is_double_double<T>::value>> {
+  using carrier_uint = detail::uint128_t;
+};
+
+template <typename T> struct decimal_fp {
+  using significand_type = typename float_info<T>::carrier_uint;
+  significand_type significand;
+  int exponent;
+};
+
+template <typename T> FMT_API auto to_decimal(T x) noexcept -> decimal_fp<T>;
+}  // namespace dragonbox
+
+// Returns true iff Float has the implicit bit which is not stored.
+template <typename Float> constexpr bool has_implicit_bit() {
+  // An 80-bit FP number has a 64-bit significand an no implicit bit.
+  return std::numeric_limits<Float>::digits != 64;
+}
+
+// Returns the number of significand bits stored in Float. The implicit bit is
+// not counted since it is not stored.
+template <typename Float> constexpr int num_significand_bits() {
+  // std::numeric_limits may not support __float128.
+  return is_float128<Float>() ? 112
+                              : (std::numeric_limits<Float>::digits -
+                                 (has_implicit_bit<Float>() ? 1 : 0));
+}
+
+template <typename Float>
+constexpr auto exponent_mask() ->
+    typename dragonbox::float_info<Float>::carrier_uint {
+  using float_uint = typename dragonbox::float_info<Float>::carrier_uint;
+  return ((float_uint(1) << dragonbox::float_info<Float>::exponent_bits) - 1)
+         << num_significand_bits<Float>();
+}
+template <typename Float> constexpr auto exponent_bias() -> int {
+  // std::numeric_limits may not support __float128.
+  return is_float128<Float>() ? 16383
+                              : std::numeric_limits<Float>::max_exponent - 1;
+}
+
+// Writes the exponent exp in the form "[+-]d{2,3}" to buffer.
+template <typename Char, typename It>
+FMT_CONSTEXPR auto write_exponent(int exp, It it) -> It {
+  FMT_ASSERT(-10000 < exp && exp < 10000, "exponent out of range");
+  if (exp < 0) {
+    *it++ = static_cast<Char>('-');
+    exp = -exp;
+  } else {
+    *it++ = static_cast<Char>('+');
+  }
+  if (exp >= 100) {
+    const char* top = digits2(to_unsigned(exp / 100));
+    if (exp >= 1000) *it++ = static_cast<Char>(top[0]);
+    *it++ = static_cast<Char>(top[1]);
+    exp %= 100;
+  }
+  const char* d = digits2(to_unsigned(exp));
+  *it++ = static_cast<Char>(d[0]);
+  *it++ = static_cast<Char>(d[1]);
+  return it;
+}
+
+// A floating-point number f * pow(2, e) where F is an unsigned type.
+template <typename F> struct basic_fp {
+  F f;
+  int e;
+
+  static constexpr const int num_significand_bits =
+      static_cast<int>(sizeof(F) * num_bits<unsigned char>());
+
+  constexpr basic_fp() : f(0), e(0) {}
+  constexpr basic_fp(uint64_t f_val, int e_val) : f(f_val), e(e_val) {}
+
+  // Constructs fp from an IEEE754 floating-point number.
+  template <typename Float> FMT_CONSTEXPR basic_fp(Float n) { assign(n); }
+
+  // Assigns n to this and return true iff predecessor is closer than successor.
+  template <typename Float, FMT_ENABLE_IF(!is_double_double<Float>::value)>
+  FMT_CONSTEXPR auto assign(Float n) -> bool {
+    static_assert(std::numeric_limits<Float>::digits <= 113, "unsupported FP");
+    // Assume Float is in the format [sign][exponent][significand].
+    using carrier_uint = typename dragonbox::float_info<Float>::carrier_uint;
+    const auto num_float_significand_bits =
+        detail::num_significand_bits<Float>();
+    const auto implicit_bit = carrier_uint(1) << num_float_significand_bits;
+    const auto significand_mask = implicit_bit - 1;
+    auto u = bit_cast<carrier_uint>(n);
+    f = static_cast<F>(u & significand_mask);
+    auto biased_e = static_cast<int>((u & exponent_mask<Float>()) >>
+                                     num_float_significand_bits);
+    // The predecessor is closer if n is a normalized power of 2 (f == 0)
+    // other than the smallest normalized number (biased_e > 1).
+    auto is_predecessor_closer = f == 0 && biased_e > 1;
+    if (biased_e == 0)
+      biased_e = 1;  // Subnormals use biased exponent 1 (min exponent).
+    else if (has_implicit_bit<Float>())
+      f += static_cast<F>(implicit_bit);
+    e = biased_e - exponent_bias<Float>() - num_float_significand_bits;
+    if (!has_implicit_bit<Float>()) ++e;
+    return is_predecessor_closer;
+  }
+
+  template <typename Float, FMT_ENABLE_IF(is_double_double<Float>::value)>
+  FMT_CONSTEXPR auto assign(Float n) -> bool {
+    static_assert(std::numeric_limits<double>::is_iec559, "unsupported FP");
+    return assign(static_cast<double>(n));
+  }
+};
+
+using fp = basic_fp<unsigned long long>;
+
+// Normalizes the value converted from double and multiplied by (1 << SHIFT).
+template <int SHIFT = 0, typename F>
+FMT_CONSTEXPR basic_fp<F> normalize(basic_fp<F> value) {
+  // Handle subnormals.
+  const auto implicit_bit = F(1) << num_significand_bits<double>();
+  const auto shifted_implicit_bit = implicit_bit << SHIFT;
+  while ((value.f & shifted_implicit_bit) == 0) {
+    value.f <<= 1;
+    --value.e;
+  }
+  // Subtract 1 to account for hidden bit.
+  const auto offset = basic_fp<F>::num_significand_bits -
+                      num_significand_bits<double>() - SHIFT - 1;
+  value.f <<= offset;
+  value.e -= offset;
+  return value;
+}
+
+// Computes lhs * rhs / pow(2, 64) rounded to nearest with half-up tie breaking.
+FMT_CONSTEXPR inline uint64_t multiply(uint64_t lhs, uint64_t rhs) {
+#if FMT_USE_INT128
+  auto product = static_cast<__uint128_t>(lhs) * rhs;
+  auto f = static_cast<uint64_t>(product >> 64);
+  return (static_cast<uint64_t>(product) & (1ULL << 63)) != 0 ? f + 1 : f;
+#else
+  // Multiply 32-bit parts of significands.
+  uint64_t mask = (1ULL << 32) - 1;
+  uint64_t a = lhs >> 32, b = lhs & mask;
+  uint64_t c = rhs >> 32, d = rhs & mask;
+  uint64_t ac = a * c, bc = b * c, ad = a * d, bd = b * d;
+  // Compute mid 64-bit of result and round.
+  uint64_t mid = (bd >> 32) + (ad & mask) + (bc & mask) + (1U << 31);
+  return ac + (ad >> 32) + (bc >> 32) + (mid >> 32);
+#endif
+}
+
+FMT_CONSTEXPR inline fp operator*(fp x, fp y) {
+  return {multiply(x.f, y.f), x.e + y.e + 64};
+}
+
+template <typename T = void> struct basic_data {
+  // Normalized 64-bit significands of pow(10, k), for k = -348, -340, ..., 340.
+  // These are generated by support/compute-powers.py.
+  static constexpr uint64_t pow10_significands[87] = {
+      0xfa8fd5a0081c0288, 0xbaaee17fa23ebf76, 0x8b16fb203055ac76,
+      0xcf42894a5dce35ea, 0x9a6bb0aa55653b2d, 0xe61acf033d1a45df,
+      0xab70fe17c79ac6ca, 0xff77b1fcbebcdc4f, 0xbe5691ef416bd60c,
+      0x8dd01fad907ffc3c, 0xd3515c2831559a83, 0x9d71ac8fada6c9b5,
+      0xea9c227723ee8bcb, 0xaecc49914078536d, 0x823c12795db6ce57,
+      0xc21094364dfb5637, 0x9096ea6f3848984f, 0xd77485cb25823ac7,
+      0xa086cfcd97bf97f4, 0xef340a98172aace5, 0xb23867fb2a35b28e,
+      0x84c8d4dfd2c63f3b, 0xc5dd44271ad3cdba, 0x936b9fcebb25c996,
+      0xdbac6c247d62a584, 0xa3ab66580d5fdaf6, 0xf3e2f893dec3f126,
+      0xb5b5ada8aaff80b8, 0x87625f056c7c4a8b, 0xc9bcff6034c13053,
+      0x964e858c91ba2655, 0xdff9772470297ebd, 0xa6dfbd9fb8e5b88f,
+      0xf8a95fcf88747d94, 0xb94470938fa89bcf, 0x8a08f0f8bf0f156b,
+      0xcdb02555653131b6, 0x993fe2c6d07b7fac, 0xe45c10c42a2b3b06,
+      0xaa242499697392d3, 0xfd87b5f28300ca0e, 0xbce5086492111aeb,
+      0x8cbccc096f5088cc, 0xd1b71758e219652c, 0x9c40000000000000,
+      0xe8d4a51000000000, 0xad78ebc5ac620000, 0x813f3978f8940984,
+      0xc097ce7bc90715b3, 0x8f7e32ce7bea5c70, 0xd5d238a4abe98068,
+      0x9f4f2726179a2245, 0xed63a231d4c4fb27, 0xb0de65388cc8ada8,
+      0x83c7088e1aab65db, 0xc45d1df942711d9a, 0x924d692ca61be758,
+      0xda01ee641a708dea, 0xa26da3999aef774a, 0xf209787bb47d6b85,
+      0xb454e4a179dd1877, 0x865b86925b9bc5c2, 0xc83553c5c8965d3d,
+      0x952ab45cfa97a0b3, 0xde469fbd99a05fe3, 0xa59bc234db398c25,
+      0xf6c69a72a3989f5c, 0xb7dcbf5354e9bece, 0x88fcf317f22241e2,
+      0xcc20ce9bd35c78a5, 0x98165af37b2153df, 0xe2a0b5dc971f303a,
+      0xa8d9d1535ce3b396, 0xfb9b7cd9a4a7443c, 0xbb764c4ca7a44410,
+      0x8bab8eefb6409c1a, 0xd01fef10a657842c, 0x9b10a4e5e9913129,
+      0xe7109bfba19c0c9d, 0xac2820d9623bf429, 0x80444b5e7aa7cf85,
+      0xbf21e44003acdd2d, 0x8e679c2f5e44ff8f, 0xd433179d9c8cb841,
+      0x9e19db92b4e31ba9, 0xeb96bf6ebadf77d9, 0xaf87023b9bf0ee6b,
+  };
+
+#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
+#  pragma GCC diagnostic push
+#  pragma GCC diagnostic ignored "-Wnarrowing"
+#endif
+  // Binary exponents of pow(10, k), for k = -348, -340, ..., 340, corresponding
+  // to significands above.
+  static constexpr int16_t pow10_exponents[87] = {
+      -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007, -980, -954,
+      -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,  -688, -661,
+      -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,  -422,  -396, -369,
+      -343,  -316,  -289,  -263,  -236,  -210,  -183,  -157,  -130,  -103, -77,
+      -50,   -24,   3,     30,    56,    83,    109,   136,   162,   189,  216,
+      242,   269,   295,   322,   348,   375,   402,   428,   455,   481,  508,
+      534,   561,   588,   614,   641,   667,   694,   720,   747,   774,  800,
+      827,   853,   880,   907,   933,   960,   986,   1013,  1039,  1066};
+#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
+#  pragma GCC diagnostic pop
+#endif
+
+  static constexpr uint64_t power_of_10_64[20] = {
+      1, FMT_POWERS_OF_10(1ULL), FMT_POWERS_OF_10(1000000000ULL),
+      10000000000000000000ULL};
+
+  // For checking rounding thresholds.
+  // The kth entry is chosen to be the smallest integer such that the
+  // upper 32-bits of 10^(k+1) times it is strictly bigger than 5 * 10^k.
+  static constexpr uint32_t fractional_part_rounding_thresholds[8] = {
+      2576980378,  // ceil(2^31 + 2^32/10^1)
+      2190433321,  // ceil(2^31 + 2^32/10^2)
+      2151778616,  // ceil(2^31 + 2^32/10^3)
+      2147913145,  // ceil(2^31 + 2^32/10^4)
+      2147526598,  // ceil(2^31 + 2^32/10^5)
+      2147487943,  // ceil(2^31 + 2^32/10^6)
+      2147484078,  // ceil(2^31 + 2^32/10^7)
+      2147483691   // ceil(2^31 + 2^32/10^8)
+  };
+};
+
+#if FMT_CPLUSPLUS < 201703L
+template <typename T> constexpr uint64_t basic_data<T>::pow10_significands[];
+template <typename T> constexpr int16_t basic_data<T>::pow10_exponents[];
+template <typename T> constexpr uint64_t basic_data<T>::power_of_10_64[];
+template <typename T>
+constexpr uint32_t basic_data<T>::fractional_part_rounding_thresholds[];
+#endif
+
+// This is a struct rather than an alias to avoid shadowing warnings in gcc.
+struct data : basic_data<> {};
+
+// Returns a cached power of 10 `c_k = c_k.f * pow(2, c_k.e)` such that its
+// (binary) exponent satisfies `min_exponent <= c_k.e <= min_exponent + 28`.
+FMT_CONSTEXPR inline fp get_cached_power(int min_exponent,
+                                         int& pow10_exponent) {
+  const int shift = 32;
+  // log10(2) = 0x0.4d104d427de7fbcc...
+  const int64_t significand = 0x4d104d427de7fbcc;
+  int index = static_cast<int>(
+      ((min_exponent + fp::num_significand_bits - 1) * (significand >> shift) +
+       ((int64_t(1) << shift) - 1))  // ceil
+      >> 32                          // arithmetic shift
+  );
+  // Decimal exponent of the first (smallest) cached power of 10.
+  const int first_dec_exp = -348;
+  // Difference between 2 consecutive decimal exponents in cached powers of 10.
+  const int dec_exp_step = 8;
+  index = (index - first_dec_exp - 1) / dec_exp_step + 1;
+  pow10_exponent = first_dec_exp + index * dec_exp_step;
+  // Using *(x + index) instead of x[index] avoids an issue with some compilers
+  // using the EDG frontend (e.g. nvhpc/22.3 in C++17 mode).
+  return {*(data::pow10_significands + index),
+          *(data::pow10_exponents + index)};
+}
+
+template <typename T>
+using convert_float_result =
+    conditional_t<std::is_same<T, float>::value ||
+                      std::numeric_limits<T>::digits ==
+                          std::numeric_limits<double>::digits,
+                  double, T>;
+
+template <typename T>
+constexpr auto convert_float(T value) -> convert_float_result<T> {
+  return static_cast<convert_float_result<T>>(value);
+}
+
+template <typename OutputIt, typename Char>
+FMT_NOINLINE FMT_CONSTEXPR auto fill(OutputIt it, size_t n,
+                                     const fill_t<Char>& fill) -> OutputIt {
+  auto fill_size = fill.size();
+  if (fill_size == 1) return detail::fill_n(it, n, fill[0]);
+  auto data = fill.data();
+  for (size_t i = 0; i < n; ++i)
+    it = copy_str<Char>(data, data + fill_size, it);
+  return it;
+}
+
+// Writes the output of f, padded according to format specifications in specs.
+// size: output size in code units.
+// width: output display width in (terminal) column positions.
+template <align::type align = align::left, typename OutputIt, typename Char,
+          typename F>
+FMT_CONSTEXPR auto write_padded(OutputIt out, const format_specs<Char>& specs,
+                                size_t size, size_t width, F&& f) -> OutputIt {
+  static_assert(align == align::left || align == align::right, "");
+  unsigned spec_width = to_unsigned(specs.width);
+  size_t padding = spec_width > width ? spec_width - width : 0;
+  // Shifts are encoded as string literals because static constexpr is not
+  // supported in constexpr functions.
+  auto* shifts = align == align::left ? "\x1f\x1f\x00\x01" : "\x00\x1f\x00\x01";
+  size_t left_padding = padding >> shifts[specs.align];
+  size_t right_padding = padding - left_padding;
+  auto it = reserve(out, size + padding * specs.fill.size());
+  if (left_padding != 0) it = fill(it, left_padding, specs.fill);
+  it = f(it);
+  if (right_padding != 0) it = fill(it, right_padding, specs.fill);
+  return base_iterator(out, it);
+}
+
+template <align::type align = align::left, typename OutputIt, typename Char,
+          typename F>
+constexpr auto write_padded(OutputIt out, const format_specs<Char>& specs,
+                            size_t size, F&& f) -> OutputIt {
+  return write_padded<align>(out, specs, size, size, f);
+}
+
+template <align::type align = align::left, typename Char, typename OutputIt>
+FMT_CONSTEXPR auto write_bytes(OutputIt out, string_view bytes,
+                               const format_specs<Char>& specs) -> OutputIt {
+  return write_padded<align>(
+      out, specs, bytes.size(), [bytes](reserve_iterator<OutputIt> it) {
+        const char* data = bytes.data();
+        return copy_str<Char>(data, data + bytes.size(), it);
+      });
+}
+
+template <typename Char, typename OutputIt, typename UIntPtr>
+auto write_ptr(OutputIt out, UIntPtr value, const format_specs<Char>* specs)
+    -> OutputIt {
+  int num_digits = count_digits<4>(value);
+  auto size = to_unsigned(num_digits) + size_t(2);
+  auto write = [=](reserve_iterator<OutputIt> it) {
+    *it++ = static_cast<Char>('0');
+    *it++ = static_cast<Char>('x');
+    return format_uint<4, Char>(it, value, num_digits);
+  };
+  return specs ? write_padded<align::right>(out, *specs, size, write)
+               : base_iterator(out, write(reserve(out, size)));
+}
+
+// Returns true iff the code point cp is printable.
+FMT_API auto is_printable(uint32_t cp) -> bool;
+
+inline auto needs_escape(uint32_t cp) -> bool {
+  return cp < 0x20 || cp == 0x7f || cp == '"' || cp == '\\' ||
+         !is_printable(cp);
+}
+
+template <typename Char> struct find_escape_result {
+  const Char* begin;
+  const Char* end;
+  uint32_t cp;
+};
+
+template <typename Char>
+using make_unsigned_char =
+    typename conditional_t<std::is_integral<Char>::value,
+                           std::make_unsigned<Char>,
+                           type_identity<uint32_t>>::type;
+
+template <typename Char>
+auto find_escape(const Char* begin, const Char* end)
+    -> find_escape_result<Char> {
+  for (; begin != end; ++begin) {
+    uint32_t cp = static_cast<make_unsigned_char<Char>>(*begin);
+    if (const_check(sizeof(Char) == 1) && cp >= 0x80) continue;
+    if (needs_escape(cp)) return {begin, begin + 1, cp};
+  }
+  return {begin, nullptr, 0};
+}
+
+inline auto find_escape(const char* begin, const char* end)
+    -> find_escape_result<char> {
+  if (!is_utf8()) return find_escape<char>(begin, end);
+  auto result = find_escape_result<char>{end, nullptr, 0};
+  for_each_codepoint(string_view(begin, to_unsigned(end - begin)),
+                     [&](uint32_t cp, string_view sv) {
+                       if (needs_escape(cp)) {
+                         result = {sv.begin(), sv.end(), cp};
+                         return false;
+                       }
+                       return true;
+                     });
+  return result;
+}
+
+#define FMT_STRING_IMPL(s, base, explicit)                                    \
+  [] {                                                                        \
+    /* Use the hidden visibility as a workaround for a GCC bug (#1973). */    \
+    /* Use a macro-like name to avoid shadowing warnings. */                  \
+    struct FMT_GCC_VISIBILITY_HIDDEN FMT_COMPILE_STRING : base {              \
+      using char_type FMT_MAYBE_UNUSED = fmt::remove_cvref_t<decltype(s[0])>; \
+      FMT_MAYBE_UNUSED FMT_CONSTEXPR explicit                                 \
+      operator fmt::basic_string_view<char_type>() const {                    \
+        return fmt::detail_exported::compile_string_to_view<char_type>(s);    \
+      }                                                                       \
+    };                                                                        \
+    return FMT_COMPILE_STRING();                                              \
+  }()
+
+/**
+  \rst
+  Constructs a compile-time format string from a string literal *s*.
+
+  **Example**::
+
+    // A compile-time error because 'd' is an invalid specifier for strings.
+    std::string s = fmt::format(FMT_STRING("{:d}"), "foo");
+  \endrst
+ */
+#define FMT_STRING(s) FMT_STRING_IMPL(s, fmt::detail::compile_string, )
+
+template <size_t width, typename Char, typename OutputIt>
+auto write_codepoint(OutputIt out, char prefix, uint32_t cp) -> OutputIt {
+  *out++ = static_cast<Char>('\\');
+  *out++ = static_cast<Char>(prefix);
+  Char buf[width];
+  fill_n(buf, width, static_cast<Char>('0'));
+  format_uint<4>(buf, cp, width);
+  return copy_str<Char>(buf, buf + width, out);
+}
+
+template <typename OutputIt, typename Char>
+auto write_escaped_cp(OutputIt out, const find_escape_result<Char>& escape)
+    -> OutputIt {
+  auto c = static_cast<Char>(escape.cp);
+  switch (escape.cp) {
+  case '\n':
+    *out++ = static_cast<Char>('\\');
+    c = static_cast<Char>('n');
+    break;
+  case '\r':
+    *out++ = static_cast<Char>('\\');
+    c = static_cast<Char>('r');
+    break;
+  case '\t':
+    *out++ = static_cast<Char>('\\');
+    c = static_cast<Char>('t');
+    break;
+  case '"':
+    FMT_FALLTHROUGH;
+  case '\'':
+    FMT_FALLTHROUGH;
+  case '\\':
+    *out++ = static_cast<Char>('\\');
+    break;
+  default:
+    if (escape.cp < 0x100) {
+      return write_codepoint<2, Char>(out, 'x', escape.cp);
+    }
+    if (escape.cp < 0x10000) {
+      return write_codepoint<4, Char>(out, 'u', escape.cp);
+    }
+    if (escape.cp < 0x110000) {
+      return write_codepoint<8, Char>(out, 'U', escape.cp);
+    }
+    for (Char escape_char : basic_string_view<Char>(
+             escape.begin, to_unsigned(escape.end - escape.begin))) {
+      out = write_codepoint<2, Char>(out, 'x',
+                                     static_cast<uint32_t>(escape_char) & 0xFF);
+    }
+    return out;
+  }
+  *out++ = c;
+  return out;
+}
+
+template <typename Char, typename OutputIt>
+auto write_escaped_string(OutputIt out, basic_string_view<Char> str)
+    -> OutputIt {
+  *out++ = static_cast<Char>('"');
+  auto begin = str.begin(), end = str.end();
+  do {
+    auto escape = find_escape(begin, end);
+    out = copy_str<Char>(begin, escape.begin, out);
+    begin = escape.end;
+    if (!begin) break;
+    out = write_escaped_cp<OutputIt, Char>(out, escape);
+  } while (begin != end);
+  *out++ = static_cast<Char>('"');
+  return out;
+}
+
+template <typename Char, typename OutputIt>
+auto write_escaped_char(OutputIt out, Char v) -> OutputIt {
+  *out++ = static_cast<Char>('\'');
+  if ((needs_escape(static_cast<uint32_t>(v)) && v != static_cast<Char>('"')) ||
+      v == static_cast<Char>('\'')) {
+    out = write_escaped_cp(
+        out, find_escape_result<Char>{&v, &v + 1, static_cast<uint32_t>(v)});
+  } else {
+    *out++ = v;
+  }
+  *out++ = static_cast<Char>('\'');
+  return out;
+}
+
+template <typename Char, typename OutputIt>
+FMT_CONSTEXPR auto write_char(OutputIt out, Char value,
+                              const format_specs<Char>& specs) -> OutputIt {
+  bool is_debug = specs.type == presentation_type::debug;
+  return write_padded(out, specs, 1, [=](reserve_iterator<OutputIt> it) {
+    if (is_debug) return write_escaped_char(it, value);
+    *it++ = value;
+    return it;
+  });
+}
+template <typename Char, typename OutputIt>
+FMT_CONSTEXPR auto write(OutputIt out, Char value,
+                         const format_specs<Char>& specs, locale_ref loc = {})
+    -> OutputIt {
+  // char is formatted as unsigned char for consistency across platforms.
+  using unsigned_type =
+      conditional_t<std::is_same<Char, char>::value, unsigned char, unsigned>;
+  return check_char_specs(specs)
+             ? write_char(out, value, specs)
+             : write(out, static_cast<unsigned_type>(value), specs, loc);
+}
+
+// Data for write_int that doesn't depend on output iterator type. It is used to
+// avoid template code bloat.
+template <typename Char> struct write_int_data {
+  size_t size;
+  size_t padding;
+
+  FMT_CONSTEXPR write_int_data(int num_digits, unsigned prefix,
+                               const format_specs<Char>& specs)
+      : size((prefix >> 24) + to_unsigned(num_digits)), padding(0) {
+    if (specs.align == align::numeric) {
+      auto width = to_unsigned(specs.width);
+      if (width > size) {
+        padding = width - size;
+        size = width;
+      }
+    } else if (specs.precision > num_digits) {
+      size = (prefix >> 24) + to_unsigned(specs.precision);
+      padding = to_unsigned(specs.precision - num_digits);
+    }
+  }
+};
+
+// Writes an integer in the format
+//   <left-padding><prefix><numeric-padding><digits><right-padding>
+// where <digits> are written by write_digits(it).
+// prefix contains chars in three lower bytes and the size in the fourth byte.
+template <typename OutputIt, typename Char, typename W>
+FMT_CONSTEXPR FMT_INLINE auto write_int(OutputIt out, int num_digits,
+                                        unsigned prefix,
+                                        const format_specs<Char>& specs,
+                                        W write_digits) -> OutputIt {
+  // Slightly faster check for specs.width == 0 && specs.precision == -1.
+  if ((specs.width | (specs.precision + 1)) == 0) {
+    auto it = reserve(out, to_unsigned(num_digits) + (prefix >> 24));
+    if (prefix != 0) {
+      for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
+        *it++ = static_cast<Char>(p & 0xff);
+    }
+    return base_iterator(out, write_digits(it));
+  }
+  auto data = write_int_data<Char>(num_digits, prefix, specs);
+  return write_padded<align::right>(
+      out, specs, data.size, [=](reserve_iterator<OutputIt> it) {
+        for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
+          *it++ = static_cast<Char>(p & 0xff);
+        it = detail::fill_n(it, data.padding, static_cast<Char>('0'));
+        return write_digits(it);
+      });
+}
+
+template <typename Char> class digit_grouping {
+ private:
+  std::string grouping_;
+  std::basic_string<Char> thousands_sep_;
+
+  struct next_state {
+    std::string::const_iterator group;
+    int pos;
+  };
+  next_state initial_state() const { return {grouping_.begin(), 0}; }
+
+  // Returns the next digit group separator position.
+  int next(next_state& state) const {
+    if (thousands_sep_.empty()) return max_value<int>();
+    if (state.group == grouping_.end()) return state.pos += grouping_.back();
+    if (*state.group <= 0 || *state.group == max_value<char>())
+      return max_value<int>();
+    state.pos += *state.group++;
+    return state.pos;
+  }
+
+ public:
+  explicit digit_grouping(locale_ref loc, bool localized = true) {
+    if (!localized) return;
+    auto sep = thousands_sep<Char>(loc);
+    grouping_ = sep.grouping;
+    if (sep.thousands_sep) thousands_sep_.assign(1, sep.thousands_sep);
+  }
+  digit_grouping(std::string grouping, std::basic_string<Char> sep)
+      : grouping_(std::move(grouping)), thousands_sep_(std::move(sep)) {}
+
+  bool has_separator() const { return !thousands_sep_.empty(); }
+
+  int count_separators(int num_digits) const {
+    int count = 0;
+    auto state = initial_state();
+    while (num_digits > next(state)) ++count;
+    return count;
+  }
+
+  // Applies grouping to digits and write the output to out.
+  template <typename Out, typename C>
+  Out apply(Out out, basic_string_view<C> digits) const {
+    auto num_digits = static_cast<int>(digits.size());
+    auto separators = basic_memory_buffer<int>();
+    separators.push_back(0);
+    auto state = initial_state();
+    while (int i = next(state)) {
+      if (i >= num_digits) break;
+      separators.push_back(i);
+    }
+    for (int i = 0, sep_index = static_cast<int>(separators.size() - 1);
+         i < num_digits; ++i) {
+      if (num_digits - i == separators[sep_index]) {
+        out =
+            copy_str<Char>(thousands_sep_.data(),
+                           thousands_sep_.data() + thousands_sep_.size(), out);
+        --sep_index;
+      }
+      *out++ = static_cast<Char>(digits[to_unsigned(i)]);
+    }
+    return out;
+  }
+};
+
+// Writes a decimal integer with digit grouping.
+template <typename OutputIt, typename UInt, typename Char>
+auto write_int(OutputIt out, UInt value, unsigned prefix,
+               const format_specs<Char>& specs,
+               const digit_grouping<Char>& grouping) -> OutputIt {
+  static_assert(std::is_same<uint64_or_128_t<UInt>, UInt>::value, "");
+  int num_digits = count_digits(value);
+  char digits[40];
+  format_decimal(digits, value, num_digits);
+  unsigned size = to_unsigned((prefix != 0 ? 1 : 0) + num_digits +
+                              grouping.count_separators(num_digits));
+  return write_padded<align::right>(
+      out, specs, size, size, [&](reserve_iterator<OutputIt> it) {
+        if (prefix != 0) {
+          char sign = static_cast<char>(prefix);
+          *it++ = static_cast<Char>(sign);
+        }
+        return grouping.apply(it, string_view(digits, to_unsigned(num_digits)));
+      });
+}
+
+// Writes a localized value.
+FMT_API auto write_loc(appender out, loc_value value,
+                       const format_specs<>& specs, locale_ref loc) -> bool;
+template <typename OutputIt, typename Char>
+inline auto write_loc(OutputIt, loc_value, const format_specs<Char>&,
+                      locale_ref) -> bool {
+  return false;
+}
+
+FMT_CONSTEXPR inline void prefix_append(unsigned& prefix, unsigned value) {
+  prefix |= prefix != 0 ? value << 8 : value;
+  prefix += (1u + (value > 0xff ? 1 : 0)) << 24;
+}
+
+template <typename UInt> struct write_int_arg {
+  UInt abs_value;
+  unsigned prefix;
+};
+
+template <typename T>
+FMT_CONSTEXPR auto make_write_int_arg(T value, sign_t sign)
+    -> write_int_arg<uint32_or_64_or_128_t<T>> {
+  auto prefix = 0u;
+  auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
+  if (is_negative(value)) {
+    prefix = 0x01000000 | '-';
+    abs_value = 0 - abs_value;
+  } else {
+    constexpr const unsigned prefixes[4] = {0, 0, 0x1000000u | '+',
+                                            0x1000000u | ' '};
+    prefix = prefixes[sign];
+  }
+  return {abs_value, prefix};
+}
+
+template <typename Char = char> struct loc_writer {
+  buffer_appender<Char> out;
+  const format_specs<Char>& specs;
+  std::basic_string<Char> sep;
+  std::string grouping;
+  std::basic_string<Char> decimal_point;
+
+  template <typename T, FMT_ENABLE_IF(is_integer<T>::value)>
+  auto operator()(T value) -> bool {
+    auto arg = make_write_int_arg(value, specs.sign);
+    write_int(out, static_cast<uint64_or_128_t<T>>(arg.abs_value), arg.prefix,
+              specs, digit_grouping<Char>(grouping, sep));
+    return true;
+  }
+
+  template <typename T, FMT_ENABLE_IF(!is_integer<T>::value)>
+  auto operator()(T) -> bool {
+    return false;
+  }
+};
+
+template <typename Char, typename OutputIt, typename T>
+FMT_CONSTEXPR FMT_INLINE auto write_int(OutputIt out, write_int_arg<T> arg,
+                                        const format_specs<Char>& specs,
+                                        locale_ref) -> OutputIt {
+  static_assert(std::is_same<T, uint32_or_64_or_128_t<T>>::value, "");
+  auto abs_value = arg.abs_value;
+  auto prefix = arg.prefix;
+  switch (specs.type) {
+  case presentation_type::none:
+  case presentation_type::dec: {
+    auto num_digits = count_digits(abs_value);
+    return write_int(
+        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
+          return format_decimal<Char>(it, abs_value, num_digits).end;
+        });
+  }
+  case presentation_type::hex_lower:
+  case presentation_type::hex_upper: {
+    bool upper = specs.type == presentation_type::hex_upper;
+    if (specs.alt)
+      prefix_append(prefix, unsigned(upper ? 'X' : 'x') << 8 | '0');
+    int num_digits = count_digits<4>(abs_value);
+    return write_int(
+        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
+          return format_uint<4, Char>(it, abs_value, num_digits, upper);
+        });
+  }
+  case presentation_type::bin_lower:
+  case presentation_type::bin_upper: {
+    bool upper = specs.type == presentation_type::bin_upper;
+    if (specs.alt)
+      prefix_append(prefix, unsigned(upper ? 'B' : 'b') << 8 | '0');
+    int num_digits = count_digits<1>(abs_value);
+    return write_int(out, num_digits, prefix, specs,
+                     [=](reserve_iterator<OutputIt> it) {
+                       return format_uint<1, Char>(it, abs_value, num_digits);
+                     });
+  }
+  case presentation_type::oct: {
+    int num_digits = count_digits<3>(abs_value);
+    // Octal prefix '0' is counted as a digit, so only add it if precision
+    // is not greater than the number of digits.
+    if (specs.alt && specs.precision <= num_digits && abs_value != 0)
+      prefix_append(prefix, '0');
+    return write_int(out, num_digits, prefix, specs,
+                     [=](reserve_iterator<OutputIt> it) {
+                       return format_uint<3, Char>(it, abs_value, num_digits);
+                     });
+  }
+  case presentation_type::chr:
+    return write_char(out, static_cast<Char>(abs_value), specs);
+  default:
+    throw_format_error("invalid format specifier");
+  }
+  return out;
+}
+template <typename Char, typename OutputIt, typename T>
+FMT_CONSTEXPR FMT_NOINLINE auto write_int_noinline(
+    OutputIt out, write_int_arg<T> arg, const format_specs<Char>& specs,
+    locale_ref loc) -> OutputIt {
+  return write_int(out, arg, specs, loc);
+}
+template <typename Char, typename OutputIt, typename T,
+          FMT_ENABLE_IF(is_integral<T>::value &&
+                        !std::is_same<T, bool>::value &&
+                        std::is_same<OutputIt, buffer_appender<Char>>::value)>
+FMT_CONSTEXPR FMT_INLINE auto write(OutputIt out, T value,
+                                    const format_specs<Char>& specs,
+                                    locale_ref loc) -> OutputIt {
+  if (specs.localized && write_loc(out, value, specs, loc)) return out;
+  return write_int_noinline(out, make_write_int_arg(value, specs.sign), specs,
+                            loc);
+}
+// An inlined version of write used in format string compilation.
+template <typename Char, typename OutputIt, typename T,
+          FMT_ENABLE_IF(is_integral<T>::value &&
+                        !std::is_same<T, bool>::value &&
+                        !std::is_same<OutputIt, buffer_appender<Char>>::value)>
+FMT_CONSTEXPR FMT_INLINE auto write(OutputIt out, T value,
+                                    const format_specs<Char>& specs,
+                                    locale_ref loc) -> OutputIt {
+  if (specs.localized && write_loc(out, value, specs, loc)) return out;
+  return write_int(out, make_write_int_arg(value, specs.sign), specs, loc);
+}
+
+// An output iterator that counts the number of objects written to it and
+// discards them.
+class counting_iterator {
+ private:
+  size_t count_;
+
+ public:
+  using iterator_category = std::output_iterator_tag;
+  using difference_type = std::ptrdiff_t;
+  using pointer = void;
+  using reference = void;
+  FMT_UNCHECKED_ITERATOR(counting_iterator);
+
+  struct value_type {
+    template <typename T> FMT_CONSTEXPR void operator=(const T&) {}
+  };
+
+  FMT_CONSTEXPR counting_iterator() : count_(0) {}
+
+  FMT_CONSTEXPR size_t count() const { return count_; }
+
+  FMT_CONSTEXPR counting_iterator& operator++() {
+    ++count_;
+    return *this;
+  }
+  FMT_CONSTEXPR counting_iterator operator++(int) {
+    auto it = *this;
+    ++*this;
+    return it;
+  }
+
+  FMT_CONSTEXPR friend counting_iterator operator+(counting_iterator it,
+                                                   difference_type n) {
+    it.count_ += static_cast<size_t>(n);
+    return it;
+  }
+
+  FMT_CONSTEXPR value_type operator*() const { return {}; }
+};
+
+template <typename Char, typename OutputIt>
+FMT_CONSTEXPR auto write(OutputIt out, basic_string_view<Char> s,
+                         const format_specs<Char>& specs) -> OutputIt {
+  auto data = s.data();
+  auto size = s.size();
+  if (specs.precision >= 0 && to_unsigned(specs.precision) < size)
+    size = code_point_index(s, to_unsigned(specs.precision));
+  bool is_debug = specs.type == presentation_type::debug;
+  size_t width = 0;
+  if (specs.width != 0) {
+    if (is_debug)
+      width = write_escaped_string(counting_iterator{}, s).count();
+    else
+      width = compute_width(basic_string_view<Char>(data, size));
+  }
+  return write_padded(out, specs, size, width,
+                      [=](reserve_iterator<OutputIt> it) {
+                        if (is_debug) return write_escaped_string(it, s);
+                        return copy_str<Char>(data, data + size, it);
+                      });
+}
+template <typename Char, typename OutputIt>
+FMT_CONSTEXPR auto write(OutputIt out,
+                         basic_string_view<type_identity_t<Char>> s,
+                         const format_specs<Char>& specs, locale_ref)
+    -> OutputIt {
+  return write(out, s, specs);
+}
+template <typename Char, typename OutputIt>
+FMT_CONSTEXPR auto write(OutputIt out, const Char* s,
+                         const format_specs<Char>& specs, locale_ref)
+    -> OutputIt {
+  return specs.type != presentation_type::pointer
+             ? write(out, basic_string_view<Char>(s), specs, {})
+             : write_ptr<Char>(out, bit_cast<uintptr_t>(s), &specs);
+}
+
+template <typename Char, typename OutputIt, typename T,
+          FMT_ENABLE_IF(is_integral<T>::value &&
+                        !std::is_same<T, bool>::value &&
+                        !std::is_same<T, Char>::value)>
+FMT_CONSTEXPR auto write(OutputIt out, T value) -> OutputIt {
+  auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
+  bool negative = is_negative(value);
+  // Don't do -abs_value since it trips unsigned-integer-overflow sanitizer.
+  if (negative) abs_value = ~abs_value + 1;
+  int num_digits = count_digits(abs_value);
+  auto size = (negative ? 1 : 0) + static_cast<size_t>(num_digits);
+  auto it = reserve(out, size);
+  if (auto ptr = to_pointer<Char>(it, size)) {
+    if (negative) *ptr++ = static_cast<Char>('-');
+    format_decimal<Char>(ptr, abs_value, num_digits);
+    return out;
+  }
+  if (negative) *it++ = static_cast<Char>('-');
+  it = format_decimal<Char>(it, abs_value, num_digits).end;
+  return base_iterator(out, it);
+}
+
+// A floating-point presentation format.
+enum class float_format : unsigned char {
+  general,  // General: exponent notation or fixed point based on magnitude.
+  exp,      // Exponent notation with the default precision of 6, e.g. 1.2e-3.
+  fixed,    // Fixed point with the default precision of 6, e.g. 0.0012.
+  hex
+};
+
+struct float_specs {
+  int precision;
+  float_format format : 8;
+  sign_t sign : 8;
+  bool upper : 1;
+  bool locale : 1;
+  bool binary32 : 1;
+  bool showpoint : 1;
+};
+
+template <typename ErrorHandler = error_handler, typename Char>
+FMT_CONSTEXPR auto parse_float_type_spec(const format_specs<Char>& specs,
+                                         ErrorHandler&& eh = {})
+    -> float_specs {
+  auto result = float_specs();
+  result.showpoint = specs.alt;
+  result.locale = specs.localized;
+  switch (specs.type) {
+  case presentation_type::none:
+    result.format = float_format::general;
+    break;
+  case presentation_type::general_upper:
+    result.upper = true;
+    FMT_FALLTHROUGH;
+  case presentation_type::general_lower:
+    result.format = float_format::general;
+    break;
+  case presentation_type::exp_upper:
+    result.upper = true;
+    FMT_FALLTHROUGH;
+  case presentation_type::exp_lower:
+    result.format = float_format::exp;
+    result.showpoint |= specs.precision != 0;
+    break;
+  case presentation_type::fixed_upper:
+    result.upper = true;
+    FMT_FALLTHROUGH;
+  case presentation_type::fixed_lower:
+    result.format = float_format::fixed;
+    result.showpoint |= specs.precision != 0;
+    break;
+  case presentation_type::hexfloat_upper:
+    result.upper = true;
+    FMT_FALLTHROUGH;
+  case presentation_type::hexfloat_lower:
+    result.format = float_format::hex;
+    break;
+  default:
+    eh.on_error("invalid format specifier");
+    break;
+  }
+  return result;
+}
+
+template <typename Char, typename OutputIt>
+FMT_CONSTEXPR20 auto write_nonfinite(OutputIt out, bool isnan,
+                                     format_specs<Char> specs,
+                                     const float_specs& fspecs) -> OutputIt {
+  auto str =
+      isnan ? (fspecs.upper ? "NAN" : "nan") : (fspecs.upper ? "INF" : "inf");
+  constexpr size_t str_size = 3;
+  auto sign = fspecs.sign;
+  auto size = str_size + (sign ? 1 : 0);
+  // Replace '0'-padding with space for non-finite values.
+  const bool is_zero_fill =
+      specs.fill.size() == 1 && *specs.fill.data() == static_cast<Char>('0');
+  if (is_zero_fill) specs.fill[0] = static_cast<Char>(' ');
+  return write_padded(out, specs, size, [=](reserve_iterator<OutputIt> it) {
+    if (sign) *it++ = detail::sign<Char>(sign);
+    return copy_str<Char>(str, str + str_size, it);
+  });
+}
+
+// A decimal floating-point number significand * pow(10, exp).
+struct big_decimal_fp {
+  const char* significand;
+  int significand_size;
+  int exponent;
+};
+
+constexpr auto get_significand_size(const big_decimal_fp& f) -> int {
+  return f.significand_size;
+}
+template <typename T>
+inline auto get_significand_size(const dragonbox::decimal_fp<T>& f) -> int {
+  return count_digits(f.significand);
+}
+
+template <typename Char, typename OutputIt>
+constexpr auto write_significand(OutputIt out, const char* significand,
+                                 int significand_size) -> OutputIt {
+  return copy_str<Char>(significand, significand + significand_size, out);
+}
+template <typename Char, typename OutputIt, typename UInt>
+inline auto write_significand(OutputIt out, UInt significand,
+                              int significand_size) -> OutputIt {
+  return format_decimal<Char>(out, significand, significand_size).end;
+}
+template <typename Char, typename OutputIt, typename T, typename Grouping>
+FMT_CONSTEXPR20 auto write_significand(OutputIt out, T significand,
+                                       int significand_size, int exponent,
+                                       const Grouping& grouping) -> OutputIt {
+  if (!grouping.has_separator()) {
+    out = write_significand<Char>(out, significand, significand_size);
+    return detail::fill_n(out, exponent, static_cast<Char>('0'));
+  }
+  auto buffer = memory_buffer();
+  write_significand<char>(appender(buffer), significand, significand_size);
+  detail::fill_n(appender(buffer), exponent, '0');
+  return grouping.apply(out, string_view(buffer.data(), buffer.size()));
+}
+
+template <typename Char, typename UInt,
+          FMT_ENABLE_IF(std::is_integral<UInt>::value)>
+inline auto write_significand(Char* out, UInt significand, int significand_size,
+                              int integral_size, Char decimal_point) -> Char* {
+  if (!decimal_point)
+    return format_decimal(out, significand, significand_size).end;
+  out += significand_size + 1;
+  Char* end = out;
+  int floating_size = significand_size - integral_size;
+  for (int i = floating_size / 2; i > 0; --i) {
+    out -= 2;
+    copy2(out, digits2(static_cast<std::size_t>(significand % 100)));
+    significand /= 100;
+  }
+  if (floating_size % 2 != 0) {
+    *--out = static_cast<Char>('0' + significand % 10);
+    significand /= 10;
+  }
+  *--out = decimal_point;
+  format_decimal(out - integral_size, significand, integral_size);
+  return end;
+}
+
+template <typename OutputIt, typename UInt, typename Char,
+          FMT_ENABLE_IF(!std::is_pointer<remove_cvref_t<OutputIt>>::value)>
+inline auto write_significand(OutputIt out, UInt significand,
+                              int significand_size, int integral_size,
+                              Char decimal_point) -> OutputIt {
+  // Buffer is large enough to hold digits (digits10 + 1) and a decimal point.
+  Char buffer[digits10<UInt>() + 2];
+  auto end = write_significand(buffer, significand, significand_size,
+                               integral_size, decimal_point);
+  return detail::copy_str_noinline<Char>(buffer, end, out);
+}
+
+template <typename OutputIt, typename Char>
+FMT_CONSTEXPR auto write_significand(OutputIt out, const char* significand,
+                                     int significand_size, int integral_size,
+                                     Char decimal_point) -> OutputIt {
+  out = detail::copy_str_noinline<Char>(significand,
+                                        significand + integral_size, out);
+  if (!decimal_point) return out;
+  *out++ = decimal_point;
+  return detail::copy_str_noinline<Char>(significand + integral_size,
+                                         significand + significand_size, out);
+}
+
+template <typename OutputIt, typename Char, typename T, typename Grouping>
+FMT_CONSTEXPR20 auto write_significand(OutputIt out, T significand,
+                                       int significand_size, int integral_size,
+                                       Char decimal_point,
+                                       const Grouping& grouping) -> OutputIt {
+  if (!grouping.has_separator()) {
+    return write_significand(out, significand, significand_size, integral_size,
+                             decimal_point);
+  }
+  auto buffer = basic_memory_buffer<Char>();
+  write_significand(buffer_appender<Char>(buffer), significand,
+                    significand_size, integral_size, decimal_point);
+  grouping.apply(
+      out, basic_string_view<Char>(buffer.data(), to_unsigned(integral_size)));
+  return detail::copy_str_noinline<Char>(buffer.data() + integral_size,
+                                         buffer.end(), out);
+}
+
+template <typename OutputIt, typename DecimalFP, typename Char,
+          typename Grouping = digit_grouping<Char>>
+FMT_CONSTEXPR20 auto do_write_float(OutputIt out, const DecimalFP& f,
+                                    const format_specs<Char>& specs,
+                                    float_specs fspecs, locale_ref loc)
+    -> OutputIt {
+  auto significand = f.significand;
+  int significand_size = get_significand_size(f);
+  const Char zero = static_cast<Char>('0');
+  auto sign = fspecs.sign;
+  size_t size = to_unsigned(significand_size) + (sign ? 1 : 0);
+  using iterator = reserve_iterator<OutputIt>;
+
+  Char decimal_point =
+      fspecs.locale ? detail::decimal_point<Char>(loc) : static_cast<Char>('.');
+
+  int output_exp = f.exponent + significand_size - 1;
+  auto use_exp_format = [=]() {
+    if (fspecs.format == float_format::exp) return true;
+    if (fspecs.format != float_format::general) return false;
+    // Use the fixed notation if the exponent is in [exp_lower, exp_upper),
+    // e.g. 0.0001 instead of 1e-04. Otherwise use the exponent notation.
+    const int exp_lower = -4, exp_upper = 16;
+    return output_exp < exp_lower ||
+           output_exp >= (fspecs.precision > 0 ? fspecs.precision : exp_upper);
+  };
+  if (use_exp_format()) {
+    int num_zeros = 0;
+    if (fspecs.showpoint) {
+      num_zeros = fspecs.precision - significand_size;
+      if (num_zeros < 0) num_zeros = 0;
+      size += to_unsigned(num_zeros);
+    } else if (significand_size == 1) {
+      decimal_point = Char();
+    }
+    auto abs_output_exp = output_exp >= 0 ? output_exp : -output_exp;
+    int exp_digits = 2;
+    if (abs_output_exp >= 100) exp_digits = abs_output_exp >= 1000 ? 4 : 3;
+
+    size += to_unsigned((decimal_point ? 1 : 0) + 2 + exp_digits);
+    char exp_char = fspecs.upper ? 'E' : 'e';
+    auto write = [=](iterator it) {
+      if (sign) *it++ = detail::sign<Char>(sign);
+      // Insert a decimal point after the first digit and add an exponent.
+      it = write_significand(it, significand, significand_size, 1,
+                             decimal_point);
+      if (num_zeros > 0) it = detail::fill_n(it, num_zeros, zero);
+      *it++ = static_cast<Char>(exp_char);
+      return write_exponent<Char>(output_exp, it);
+    };
+    return specs.width > 0 ? write_padded<align::right>(out, specs, size, write)
+                           : base_iterator(out, write(reserve(out, size)));
+  }
+
+  int exp = f.exponent + significand_size;
+  if (f.exponent >= 0) {
+    // 1234e5 -> 123400000[.0+]
+    size += to_unsigned(f.exponent);
+    int num_zeros = fspecs.precision - exp;
+    abort_fuzzing_if(num_zeros > 5000);
+    if (fspecs.showpoint) {
+      ++size;
+      if (num_zeros <= 0 && fspecs.format != float_format::fixed) num_zeros = 0;
+      if (num_zeros > 0) size += to_unsigned(num_zeros);
+    }
+    auto grouping = Grouping(loc, fspecs.locale);
+    size += to_unsigned(grouping.count_separators(exp));
+    return write_padded<align::right>(out, specs, size, [&](iterator it) {
+      if (sign) *it++ = detail::sign<Char>(sign);
+      it = write_significand<Char>(it, significand, significand_size,
+                                   f.exponent, grouping);
+      if (!fspecs.showpoint) return it;
+      *it++ = decimal_point;
+      return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;
+    });
+  } else if (exp > 0) {
+    // 1234e-2 -> 12.34[0+]
+    int num_zeros = fspecs.showpoint ? fspecs.precision - significand_size : 0;
+    size += 1 + to_unsigned(num_zeros > 0 ? num_zeros : 0);
+    auto grouping = Grouping(loc, fspecs.locale);
+    size += to_unsigned(grouping.count_separators(exp));
+    return write_padded<align::right>(out, specs, size, [&](iterator it) {
+      if (sign) *it++ = detail::sign<Char>(sign);
+      it = write_significand(it, significand, significand_size, exp,
+                             decimal_point, grouping);
+      return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;
+    });
+  }
+  // 1234e-6 -> 0.001234
+  int num_zeros = -exp;
+  if (significand_size == 0 && fspecs.precision >= 0 &&
+      fspecs.precision < num_zeros) {
+    num_zeros = fspecs.precision;
+  }
+  bool pointy = num_zeros != 0 || significand_size != 0 || fspecs.showpoint;
+  size += 1 + (pointy ? 1 : 0) + to_unsigned(num_zeros);
+  return write_padded<align::right>(out, specs, size, [&](iterator it) {
+    if (sign) *it++ = detail::sign<Char>(sign);
+    *it++ = zero;
+    if (!pointy) return it;
+    *it++ = decimal_point;
+    it = detail::fill_n(it, num_zeros, zero);
+    return write_significand<Char>(it, significand, significand_size);
+  });
+}
+
+template <typename Char> class fallback_digit_grouping {
+ public:
+  constexpr fallback_digit_grouping(locale_ref, bool) {}
+
+  constexpr bool has_separator() const { return false; }
+
+  constexpr int count_separators(int) const { return 0; }
+
+  template <typename Out, typename C>
+  constexpr Out apply(Out out, basic_string_view<C>) const {
+    return out;
+  }
+};
+
+template <typename OutputIt, typename DecimalFP, typename Char>
+FMT_CONSTEXPR20 auto write_float(OutputIt out, const DecimalFP& f,
+                                 const format_specs<Char>& specs,
+                                 float_specs fspecs, locale_ref loc)
+    -> OutputIt {
+  if (is_constant_evaluated()) {
+    return do_write_float<OutputIt, DecimalFP, Char,
+                          fallback_digit_grouping<Char>>(out, f, specs, fspecs,
+                                                         loc);
+  } else {
+    return do_write_float(out, f, specs, fspecs, loc);
+  }
+}
+
+template <typename T> constexpr bool isnan(T value) {
+  return !(value >= value);  // std::isnan doesn't support __float128.
+}
+
+template <typename T, typename Enable = void>
+struct has_isfinite : std::false_type {};
+
+template <typename T>
+struct has_isfinite<T, enable_if_t<sizeof(std::isfinite(T())) != 0>>
+    : std::true_type {};
+
+template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value&&
+                                        has_isfinite<T>::value)>
+FMT_CONSTEXPR20 bool isfinite(T value) {
+  constexpr T inf = T(std::numeric_limits<double>::infinity());
+  if (is_constant_evaluated())
+    return !detail::isnan(value) && value < inf && value > -inf;
+  return std::isfinite(value);
+}
+template <typename T, FMT_ENABLE_IF(!has_isfinite<T>::value)>
+FMT_CONSTEXPR bool isfinite(T value) {
+  T inf = T(std::numeric_limits<double>::infinity());
+  // std::isfinite doesn't support __float128.
+  return !detail::isnan(value) && value < inf && value > -inf;
+}
+
+template <typename T, FMT_ENABLE_IF(is_floating_point<T>::value)>
+FMT_INLINE FMT_CONSTEXPR bool signbit(T value) {
+  if (is_constant_evaluated()) {
+#ifdef __cpp_if_constexpr
+    if constexpr (std::numeric_limits<double>::is_iec559) {
+      auto bits = detail::bit_cast<uint64_t>(static_cast<double>(value));
+      return (bits >> (num_bits<uint64_t>() - 1)) != 0;
+    }
+#endif
+  }
+  return std::signbit(static_cast<double>(value));
+}
+
+enum class round_direction { unknown, up, down };
+
+// Given the divisor (normally a power of 10), the remainder = v % divisor for
+// some number v and the error, returns whether v should be rounded up, down, or
+// whether the rounding direction can't be determined due to error.
+// error should be less than divisor / 2.
+FMT_CONSTEXPR inline round_direction get_round_direction(uint64_t divisor,
+                                                         uint64_t remainder,
+                                                         uint64_t error) {
+  FMT_ASSERT(remainder < divisor, "");  // divisor - remainder won't overflow.
+  FMT_ASSERT(error < divisor, "");      // divisor - error won't overflow.
+  FMT_ASSERT(error < divisor - error, "");  // error * 2 won't overflow.
+  // Round down if (remainder + error) * 2 <= divisor.
+  if (remainder <= divisor - remainder && error * 2 <= divisor - remainder * 2)
+    return round_direction::down;
+  // Round up if (remainder - error) * 2 >= divisor.
+  if (remainder >= error &&
+      remainder - error >= divisor - (remainder - error)) {
+    return round_direction::up;
+  }
+  return round_direction::unknown;
+}
+
+namespace digits {
+enum result {
+  more,  // Generate more digits.
+  done,  // Done generating digits.
+  error  // Digit generation cancelled due to an error.
+};
+}
+
+struct gen_digits_handler {
+  char* buf;
+  int size;
+  int precision;
+  int exp10;
+  bool fixed;
+
+  FMT_CONSTEXPR digits::result on_digit(char digit, uint64_t divisor,
+                                        uint64_t remainder, uint64_t error,
+                                        bool integral) {
+    FMT_ASSERT(remainder < divisor, "");
+    buf[size++] = digit;
+    if (!integral && error >= remainder) return digits::error;
+    if (size < precision) return digits::more;
+    if (!integral) {
+      // Check if error * 2 < divisor with overflow prevention.
+      // The check is not needed for the integral part because error = 1
+      // and divisor > (1 << 32) there.
+      if (error >= divisor || error >= divisor - error) return digits::error;
+    } else {
+      FMT_ASSERT(error == 1 && divisor > 2, "");
+    }
+    auto dir = get_round_direction(divisor, remainder, error);
+    if (dir != round_direction::up)
+      return dir == round_direction::down ? digits::done : digits::error;
+    ++buf[size - 1];
+    for (int i = size - 1; i > 0 && buf[i] > '9'; --i) {
+      buf[i] = '0';
+      ++buf[i - 1];
+    }
+    if (buf[0] > '9') {
+      buf[0] = '1';
+      if (fixed)
+        buf[size++] = '0';
+      else
+        ++exp10;
+    }
+    return digits::done;
+  }
+};
+
+inline FMT_CONSTEXPR20 void adjust_precision(int& precision, int exp10) {
+  // Adjust fixed precision by exponent because it is relative to decimal
+  // point.
+  if (exp10 > 0 && precision > max_value<int>() - exp10)
+    FMT_THROW(format_error("number is too big"));
+  precision += exp10;
+}
+
+// Generates output using the Grisu digit-gen algorithm.
+// error: the size of the region (lower, upper) outside of which numbers
+// definitely do not round to value (Delta in Grisu3).
+FMT_INLINE FMT_CONSTEXPR20 auto grisu_gen_digits(fp value, uint64_t error,
+                                                 int& exp,
+                                                 gen_digits_handler& handler)
+    -> digits::result {
+  const fp one(1ULL << -value.e, value.e);
+  // The integral part of scaled value (p1 in Grisu) = value / one. It cannot be
+  // zero because it contains a product of two 64-bit numbers with MSB set (due
+  // to normalization) - 1, shifted right by at most 60 bits.
+  auto integral = static_cast<uint32_t>(value.f >> -one.e);
+  FMT_ASSERT(integral != 0, "");
+  FMT_ASSERT(integral == value.f >> -one.e, "");
+  // The fractional part of scaled value (p2 in Grisu) c = value % one.
+  uint64_t fractional = value.f & (one.f - 1);
+  exp = count_digits(integral);  // kappa in Grisu.
+  // Non-fixed formats require at least one digit and no precision adjustment.
+  if (handler.fixed) {
+    adjust_precision(handler.precision, exp + handler.exp10);
+    // Check if precision is satisfied just by leading zeros, e.g.
+    // format("{:.2f}", 0.001) gives "0.00" without generating any digits.
+    if (handler.precision <= 0) {
+      if (handler.precision < 0) return digits::done;
+      // Divide by 10 to prevent overflow.
+      uint64_t divisor = data::power_of_10_64[exp - 1] << -one.e;
+      auto dir = get_round_direction(divisor, value.f / 10, error * 10);
+      if (dir == round_direction::unknown) return digits::error;
+      handler.buf[handler.size++] = dir == round_direction::up ? '1' : '0';
+      return digits::done;
+    }
+  }
+  // Generate digits for the integral part. This can produce up to 10 digits.
+  do {
+    uint32_t digit = 0;
+    auto divmod_integral = [&](uint32_t divisor) {
+      digit = integral / divisor;
+      integral %= divisor;
+    };
+    // This optimization by Milo Yip reduces the number of integer divisions by
+    // one per iteration.
+    switch (exp) {
+    case 10:
+      divmod_integral(1000000000);
+      break;
+    case 9:
+      divmod_integral(100000000);
+      break;
+    case 8:
+      divmod_integral(10000000);
+      break;
+    case 7:
+      divmod_integral(1000000);
+      break;
+    case 6:
+      divmod_integral(100000);
+      break;
+    case 5:
+      divmod_integral(10000);
+      break;
+    case 4:
+      divmod_integral(1000);
+      break;
+    case 3:
+      divmod_integral(100);
+      break;
+    case 2:
+      divmod_integral(10);
+      break;
+    case 1:
+      digit = integral;
+      integral = 0;
+      break;
+    default:
+      FMT_ASSERT(false, "invalid number of digits");
+    }
+    --exp;
+    auto remainder = (static_cast<uint64_t>(integral) << -one.e) + fractional;
+    auto result = handler.on_digit(static_cast<char>('0' + digit),
+                                   data::power_of_10_64[exp] << -one.e,
+                                   remainder, error, true);
+    if (result != digits::more) return result;
+  } while (exp > 0);
+  // Generate digits for the fractional part.
+  for (;;) {
+    fractional *= 10;
+    error *= 10;
+    char digit = static_cast<char>('0' + (fractional >> -one.e));
+    fractional &= one.f - 1;
+    --exp;
+    auto result = handler.on_digit(digit, one.f, fractional, error, false);
+    if (result != digits::more) return result;
+  }
+}
+
+class bigint {
+ private:
+  // A bigint is stored as an array of bigits (big digits), with bigit at index
+  // 0 being the least significant one.
+  using bigit = uint32_t;
+  using double_bigit = uint64_t;
+  enum { bigits_capacity = 32 };
+  basic_memory_buffer<bigit, bigits_capacity> bigits_;
+  int exp_;
+
+  FMT_CONSTEXPR20 bigit operator[](int index) const {
+    return bigits_[to_unsigned(index)];
+  }
+  FMT_CONSTEXPR20 bigit& operator[](int index) {
+    return bigits_[to_unsigned(index)];
+  }
+
+  static constexpr const int bigit_bits = num_bits<bigit>();
+
+  friend struct formatter<bigint>;
+
+  FMT_CONSTEXPR20 void subtract_bigits(int index, bigit other, bigit& borrow) {
+    auto result = static_cast<double_bigit>((*this)[index]) - other - borrow;
+    (*this)[index] = static_cast<bigit>(result);
+    borrow = static_cast<bigit>(result >> (bigit_bits * 2 - 1));
+  }
+
+  FMT_CONSTEXPR20 void remove_leading_zeros() {
+    int num_bigits = static_cast<int>(bigits_.size()) - 1;
+    while (num_bigits > 0 && (*this)[num_bigits] == 0) --num_bigits;
+    bigits_.resize(to_unsigned(num_bigits + 1));
+  }
+
+  // Computes *this -= other assuming aligned bigints and *this >= other.
+  FMT_CONSTEXPR20 void subtract_aligned(const bigint& other) {
+    FMT_ASSERT(other.exp_ >= exp_, "unaligned bigints");
+    FMT_ASSERT(compare(*this, other) >= 0, "");
+    bigit borrow = 0;
+    int i = other.exp_ - exp_;
+    for (size_t j = 0, n = other.bigits_.size(); j != n; ++i, ++j)
+      subtract_bigits(i, other.bigits_[j], borrow);
+    while (borrow > 0) subtract_bigits(i, 0, borrow);
+    remove_leading_zeros();
+  }
+
+  FMT_CONSTEXPR20 void multiply(uint32_t value) {
+    const double_bigit wide_value = value;
+    bigit carry = 0;
+    for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
+      double_bigit result = bigits_[i] * wide_value + carry;
+      bigits_[i] = static_cast<bigit>(result);
+      carry = static_cast<bigit>(result >> bigit_bits);
+    }
+    if (carry != 0) bigits_.push_back(carry);
+  }
+
+  template <typename UInt, FMT_ENABLE_IF(std::is_same<UInt, uint64_t>::value ||
+                                         std::is_same<UInt, uint128_t>::value)>
+  FMT_CONSTEXPR20 void multiply(UInt value) {
+    using half_uint =
+        conditional_t<std::is_same<UInt, uint128_t>::value, uint64_t, uint32_t>;
+    const int shift = num_bits<half_uint>() - bigit_bits;
+    const UInt lower = static_cast<half_uint>(value);
+    const UInt upper = value >> num_bits<half_uint>();
+    UInt carry = 0;
+    for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
+      UInt result = lower * bigits_[i] + static_cast<bigit>(carry);
+      carry = (upper * bigits_[i] << shift) + (result >> bigit_bits) +
+              (carry >> bigit_bits);
+      bigits_[i] = static_cast<bigit>(result);
+    }
+    while (carry != 0) {
+      bigits_.push_back(static_cast<bigit>(carry));
+      carry >>= bigit_bits;
+    }
+  }
+
+  template <typename UInt, FMT_ENABLE_IF(std::is_same<UInt, uint64_t>::value ||
+                                         std::is_same<UInt, uint128_t>::value)>
+  FMT_CONSTEXPR20 void assign(UInt n) {
+    size_t num_bigits = 0;
+    do {
+      bigits_[num_bigits++] = static_cast<bigit>(n);
+      n >>= bigit_bits;
+    } while (n != 0);
+    bigits_.resize(num_bigits);
+    exp_ = 0;
+  }
+
+ public:
+  FMT_CONSTEXPR20 bigint() : exp_(0) {}
+  explicit bigint(uint64_t n) { assign(n); }
+
+  bigint(const bigint&) = delete;
+  void operator=(const bigint&) = delete;
+
+  FMT_CONSTEXPR20 void assign(const bigint& other) {
+    auto size = other.bigits_.size();
+    bigits_.resize(size);
+    auto data = other.bigits_.data();
+    std::copy(data, data + size, make_checked(bigits_.data(), size));
+    exp_ = other.exp_;
+  }
+
+  template <typename Int> FMT_CONSTEXPR20 void operator=(Int n) {
+    FMT_ASSERT(n > 0, "");
+    assign(uint64_or_128_t<Int>(n));
+  }
+
+  FMT_CONSTEXPR20 int num_bigits() const {
+    return static_cast<int>(bigits_.size()) + exp_;
+  }
+
+  FMT_NOINLINE FMT_CONSTEXPR20 bigint& operator<<=(int shift) {
+    FMT_ASSERT(shift >= 0, "");
+    exp_ += shift / bigit_bits;
+    shift %= bigit_bits;
+    if (shift == 0) return *this;
+    bigit carry = 0;
+    for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
+      bigit c = bigits_[i] >> (bigit_bits - shift);
+      bigits_[i] = (bigits_[i] << shift) + carry;
+      carry = c;
+    }
+    if (carry != 0) bigits_.push_back(carry);
+    return *this;
+  }
+
+  template <typename Int> FMT_CONSTEXPR20 bigint& operator*=(Int value) {
+    FMT_ASSERT(value > 0, "");
+    multiply(uint32_or_64_or_128_t<Int>(value));
+    return *this;
+  }
+
+  friend FMT_CONSTEXPR20 int compare(const bigint& lhs, const bigint& rhs) {
+    int num_lhs_bigits = lhs.num_bigits(), num_rhs_bigits = rhs.num_bigits();
+    if (num_lhs_bigits != num_rhs_bigits)
+      return num_lhs_bigits > num_rhs_bigits ? 1 : -1;
+    int i = static_cast<int>(lhs.bigits_.size()) - 1;
+    int j = static_cast<int>(rhs.bigits_.size()) - 1;
+    int end = i - j;
+    if (end < 0) end = 0;
+    for (; i >= end; --i, --j) {
+      bigit lhs_bigit = lhs[i], rhs_bigit = rhs[j];
+      if (lhs_bigit != rhs_bigit) return lhs_bigit > rhs_bigit ? 1 : -1;
+    }
+    if (i != j) return i > j ? 1 : -1;
+    return 0;
+  }
+
+  // Returns compare(lhs1 + lhs2, rhs).
+  friend FMT_CONSTEXPR20 int add_compare(const bigint& lhs1, const bigint& lhs2,
+                                         const bigint& rhs) {
+    auto minimum = [](int a, int b) { return a < b ? a : b; };
+    auto maximum = [](int a, int b) { return a > b ? a : b; };
+    int max_lhs_bigits = maximum(lhs1.num_bigits(), lhs2.num_bigits());
+    int num_rhs_bigits = rhs.num_bigits();
+    if (max_lhs_bigits + 1 < num_rhs_bigits) return -1;
+    if (max_lhs_bigits > num_rhs_bigits) return 1;
+    auto get_bigit = [](const bigint& n, int i) -> bigit {
+      return i >= n.exp_ && i < n.num_bigits() ? n[i - n.exp_] : 0;
+    };
+    double_bigit borrow = 0;
+    int min_exp = minimum(minimum(lhs1.exp_, lhs2.exp_), rhs.exp_);
+    for (int i = num_rhs_bigits - 1; i >= min_exp; --i) {
+      double_bigit sum =
+          static_cast<double_bigit>(get_bigit(lhs1, i)) + get_bigit(lhs2, i);
+      bigit rhs_bigit = get_bigit(rhs, i);
+      if (sum > rhs_bigit + borrow) return 1;
+      borrow = rhs_bigit + borrow - sum;
+      if (borrow > 1) return -1;
+      borrow <<= bigit_bits;
+    }
+    return borrow != 0 ? -1 : 0;
+  }
+
+  // Assigns pow(10, exp) to this bigint.
+  FMT_CONSTEXPR20 void assign_pow10(int exp) {
+    FMT_ASSERT(exp >= 0, "");
+    if (exp == 0) return *this = 1;
+    // Find the top bit.
+    int bitmask = 1;
+    while (exp >= bitmask) bitmask <<= 1;
+    bitmask >>= 1;
+    // pow(10, exp) = pow(5, exp) * pow(2, exp). First compute pow(5, exp) by
+    // repeated squaring and multiplication.
+    *this = 5;
+    bitmask >>= 1;
+    while (bitmask != 0) {
+      square();
+      if ((exp & bitmask) != 0) *this *= 5;
+      bitmask >>= 1;
+    }
+    *this <<= exp;  // Multiply by pow(2, exp) by shifting.
+  }
+
+  FMT_CONSTEXPR20 void square() {
+    int num_bigits = static_cast<int>(bigits_.size());
+    int num_result_bigits = 2 * num_bigits;
+    basic_memory_buffer<bigit, bigits_capacity> n(std::move(bigits_));
+    bigits_.resize(to_unsigned(num_result_bigits));
+    auto sum = uint128_t();
+    for (int bigit_index = 0; bigit_index < num_bigits; ++bigit_index) {
+      // Compute bigit at position bigit_index of the result by adding
+      // cross-product terms n[i] * n[j] such that i + j == bigit_index.
+      for (int i = 0, j = bigit_index; j >= 0; ++i, --j) {
+        // Most terms are multiplied twice which can be optimized in the future.
+        sum += static_cast<double_bigit>(n[i]) * n[j];
+      }
+      (*this)[bigit_index] = static_cast<bigit>(sum);
+      sum >>= num_bits<bigit>();  // Compute the carry.
+    }
+    // Do the same for the top half.
+    for (int bigit_index = num_bigits; bigit_index < num_result_bigits;
+         ++bigit_index) {
+      for (int j = num_bigits - 1, i = bigit_index - j; i < num_bigits;)
+        sum += static_cast<double_bigit>(n[i++]) * n[j--];
+      (*this)[bigit_index] = static_cast<bigit>(sum);
+      sum >>= num_bits<bigit>();
+    }
+    remove_leading_zeros();
+    exp_ *= 2;
+  }
+
+  // If this bigint has a bigger exponent than other, adds trailing zero to make
+  // exponents equal. This simplifies some operations such as subtraction.
+  FMT_CONSTEXPR20 void align(const bigint& other) {
+    int exp_difference = exp_ - other.exp_;
+    if (exp_difference <= 0) return;
+    int num_bigits = static_cast<int>(bigits_.size());
+    bigits_.resize(to_unsigned(num_bigits + exp_difference));
+    for (int i = num_bigits - 1, j = i + exp_difference; i >= 0; --i, --j)
+      bigits_[j] = bigits_[i];
+    std::uninitialized_fill_n(bigits_.data(), exp_difference, 0);
+    exp_ -= exp_difference;
+  }
+
+  // Divides this bignum by divisor, assigning the remainder to this and
+  // returning the quotient.
+  FMT_CONSTEXPR20 int divmod_assign(const bigint& divisor) {
+    FMT_ASSERT(this != &divisor, "");
+    if (compare(*this, divisor) < 0) return 0;
+    FMT_ASSERT(divisor.bigits_[divisor.bigits_.size() - 1u] != 0, "");
+    align(divisor);
+    int quotient = 0;
+    do {
+      subtract_aligned(divisor);
+      ++quotient;
+    } while (compare(*this, divisor) >= 0);
+    return quotient;
+  }
+};
+
+// format_dragon flags.
+enum dragon {
+  predecessor_closer = 1,
+  fixup = 2,  // Run fixup to correct exp10 which can be off by one.
+  fixed = 4,
+};
+
+// Formats a floating-point number using a variation of the Fixed-Precision
+// Positive Floating-Point Printout ((FPP)^2) algorithm by Steele & White:
+// https://fmt.dev/papers/p372-steele.pdf.
+FMT_CONSTEXPR20 inline void format_dragon(basic_fp<uint128_t> value,
+                                          unsigned flags, int num_digits,
+                                          buffer<char>& buf, int& exp10) {
+  bigint numerator;    // 2 * R in (FPP)^2.
+  bigint denominator;  // 2 * S in (FPP)^2.
+  // lower and upper are differences between value and corresponding boundaries.
+  bigint lower;             // (M^- in (FPP)^2).
+  bigint upper_store;       // upper's value if different from lower.
+  bigint* upper = nullptr;  // (M^+ in (FPP)^2).
+  // Shift numerator and denominator by an extra bit or two (if lower boundary
+  // is closer) to make lower and upper integers. This eliminates multiplication
+  // by 2 during later computations.
+  bool is_predecessor_closer = (flags & dragon::predecessor_closer) != 0;
+  int shift = is_predecessor_closer ? 2 : 1;
+  if (value.e >= 0) {
+    numerator = value.f;
+    numerator <<= value.e + shift;
+    lower = 1;
+    lower <<= value.e;
+    if (is_predecessor_closer) {
+      upper_store = 1;
+      upper_store <<= value.e + 1;
+      upper = &upper_store;
+    }
+    denominator.assign_pow10(exp10);
+    denominator <<= shift;
+  } else if (exp10 < 0) {
+    numerator.assign_pow10(-exp10);
+    lower.assign(numerator);
+    if (is_predecessor_closer) {
+      upper_store.assign(numerator);
+      upper_store <<= 1;
+      upper = &upper_store;
+    }
+    numerator *= value.f;
+    numerator <<= shift;
+    denominator = 1;
+    denominator <<= shift - value.e;
+  } else {
+    numerator = value.f;
+    numerator <<= shift;
+    denominator.assign_pow10(exp10);
+    denominator <<= shift - value.e;
+    lower = 1;
+    if (is_predecessor_closer) {
+      upper_store = 1ULL << 1;
+      upper = &upper_store;
+    }
+  }
+  int even = static_cast<int>((value.f & 1) == 0);
+  if (!upper) upper = &lower;
+  if ((flags & dragon::fixup) != 0) {
+    if (add_compare(numerator, *upper, denominator) + even <= 0) {
+      --exp10;
+      numerator *= 10;
+      if (num_digits < 0) {
+        lower *= 10;
+        if (upper != &lower) *upper *= 10;
+      }
+    }
+    if ((flags & dragon::fixed) != 0) adjust_precision(num_digits, exp10 + 1);
+  }
+  // Invariant: value == (numerator / denominator) * pow(10, exp10).
+  if (num_digits < 0) {
+    // Generate the shortest representation.
+    num_digits = 0;
+    char* data = buf.data();
+    for (;;) {
+      int digit = numerator.divmod_assign(denominator);
+      bool low = compare(numerator, lower) - even < 0;  // numerator <[=] lower.
+      // numerator + upper >[=] pow10:
+      bool high = add_compare(numerator, *upper, denominator) + even > 0;
+      data[num_digits++] = static_cast<char>('0' + digit);
+      if (low || high) {
+        if (!low) {
+          ++data[num_digits - 1];
+        } else if (high) {
+          int result = add_compare(numerator, numerator, denominator);
+          // Round half to even.
+          if (result > 0 || (result == 0 && (digit % 2) != 0))
+            ++data[num_digits - 1];
+        }
+        buf.try_resize(to_unsigned(num_digits));
+        exp10 -= num_digits - 1;
+        return;
+      }
+      numerator *= 10;
+      lower *= 10;
+      if (upper != &lower) *upper *= 10;
+    }
+  }
+  // Generate the given number of digits.
+  exp10 -= num_digits - 1;
+  if (num_digits == 0) {
+    denominator *= 10;
+    auto digit = add_compare(numerator, numerator, denominator) > 0 ? '1' : '0';
+    buf.push_back(digit);
+    return;
+  }
+  buf.try_resize(to_unsigned(num_digits));
+  for (int i = 0; i < num_digits - 1; ++i) {
+    int digit = numerator.divmod_assign(denominator);
+    buf[i] = static_cast<char>('0' + digit);
+    numerator *= 10;
+  }
+  int digit = numerator.divmod_assign(denominator);
+  auto result = add_compare(numerator, numerator, denominator);
+  if (result > 0 || (result == 0 && (digit % 2) != 0)) {
+    if (digit == 9) {
+      const auto overflow = '0' + 10;
+      buf[num_digits - 1] = overflow;
+      // Propagate the carry.
+      for (int i = num_digits - 1; i > 0 && buf[i] == overflow; --i) {
+        buf[i] = '0';
+        ++buf[i - 1];
+      }
+      if (buf[0] == overflow) {
+        buf[0] = '1';
+        ++exp10;
+      }
+      return;
+    }
+    ++digit;
+  }
+  buf[num_digits - 1] = static_cast<char>('0' + digit);
+}
+
+// Formats a floating-point number using the hexfloat format.
+template <typename Float, FMT_ENABLE_IF(!is_double_double<Float>::value)>
+FMT_CONSTEXPR20 void format_hexfloat(Float value, int precision,
+                                     float_specs specs, buffer<char>& buf) {
+  // float is passed as double to reduce the number of instantiations and to
+  // simplify implementation.
+  static_assert(!std::is_same<Float, float>::value, "");
+
+  using info = dragonbox::float_info<Float>;
+
+  // Assume Float is in the format [sign][exponent][significand].
+  using carrier_uint = typename info::carrier_uint;
+
+  constexpr auto num_float_significand_bits =
+      detail::num_significand_bits<Float>();
+
+  basic_fp<carrier_uint> f(value);
+  f.e += num_float_significand_bits;
+  if (!has_implicit_bit<Float>()) --f.e;
+
+  constexpr auto num_fraction_bits =
+      num_float_significand_bits + (has_implicit_bit<Float>() ? 1 : 0);
+  constexpr auto num_xdigits = (num_fraction_bits + 3) / 4;
+
+  constexpr auto leading_shift = ((num_xdigits - 1) * 4);
+  const auto leading_mask = carrier_uint(0xF) << leading_shift;
+  const auto leading_xdigit =
+      static_cast<uint32_t>((f.f & leading_mask) >> leading_shift);
+  if (leading_xdigit > 1) f.e -= (32 - countl_zero(leading_xdigit) - 1);
+
+  int print_xdigits = num_xdigits - 1;
+  if (precision >= 0 && print_xdigits > precision) {
+    const int shift = ((print_xdigits - precision - 1) * 4);
+    const auto mask = carrier_uint(0xF) << shift;
+    const auto v = static_cast<uint32_t>((f.f & mask) >> shift);
+
+    if (v >= 8) {
+      const auto inc = carrier_uint(1) << (shift + 4);
+      f.f += inc;
+      f.f &= ~(inc - 1);
+    }
+
+    // Check long double overflow
+    if (!has_implicit_bit<Float>()) {
+      const auto implicit_bit = carrier_uint(1) << num_float_significand_bits;
+      if ((f.f & implicit_bit) == implicit_bit) {
+        f.f >>= 4;
+        f.e += 4;
+      }
+    }
+
+    print_xdigits = precision;
+  }
+
+  char xdigits[num_bits<carrier_uint>() / 4];
+  detail::fill_n(xdigits, sizeof(xdigits), '0');
+  format_uint<4>(xdigits, f.f, num_xdigits, specs.upper);
+
+  // Remove zero tail
+  while (print_xdigits > 0 && xdigits[print_xdigits] == '0') --print_xdigits;
+
+  buf.push_back('0');
+  buf.push_back(specs.upper ? 'X' : 'x');
+  buf.push_back(xdigits[0]);
+  if (specs.showpoint || print_xdigits > 0 || print_xdigits < precision)
+    buf.push_back('.');
+  buf.append(xdigits + 1, xdigits + 1 + print_xdigits);
+  for (; print_xdigits < precision; ++print_xdigits) buf.push_back('0');
+
+  buf.push_back(specs.upper ? 'P' : 'p');
+
+  uint32_t abs_e;
+  if (f.e < 0) {
+    buf.push_back('-');
+    abs_e = static_cast<uint32_t>(-f.e);
+  } else {
+    buf.push_back('+');
+    abs_e = static_cast<uint32_t>(f.e);
+  }
+  format_decimal<char>(appender(buf), abs_e, detail::count_digits(abs_e));
+}
+
+template <typename Float, FMT_ENABLE_IF(is_double_double<Float>::value)>
+FMT_CONSTEXPR20 void format_hexfloat(Float value, int precision,
+                                     float_specs specs, buffer<char>& buf) {
+  format_hexfloat(static_cast<double>(value), precision, specs, buf);
+}
+
+template <typename Float>
+FMT_CONSTEXPR20 auto format_float(Float value, int precision, float_specs specs,
+                                  buffer<char>& buf) -> int {
+  // float is passed as double to reduce the number of instantiations.
+  static_assert(!std::is_same<Float, float>::value, "");
+  FMT_ASSERT(value >= 0, "value is negative");
+  auto converted_value = convert_float(value);
+
+  const bool fixed = specs.format == float_format::fixed;
+  if (value <= 0) {  // <= instead of == to silence a warning.
+    if (precision <= 0 || !fixed) {
+      buf.push_back('0');
+      return 0;
+    }
+    buf.try_resize(to_unsigned(precision));
+    fill_n(buf.data(), precision, '0');
+    return -precision;
+  }
+
+  int exp = 0;
+  bool use_dragon = true;
+  unsigned dragon_flags = 0;
+  if (!is_fast_float<Float>()) {
+    const auto inv_log2_10 = 0.3010299956639812;  // 1 / log2(10)
+    using info = dragonbox::float_info<decltype(converted_value)>;
+    const auto f = basic_fp<typename info::carrier_uint>(converted_value);
+    // Compute exp, an approximate power of 10, such that
+    //   10^(exp - 1) <= value < 10^exp or 10^exp <= value < 10^(exp + 1).
+    // This is based on log10(value) == log2(value) / log2(10) and approximation
+    // of log2(value) by e + num_fraction_bits idea from double-conversion.
+    exp = static_cast<int>(
+        std::ceil((f.e + count_digits<1>(f.f) - 1) * inv_log2_10 - 1e-10));
+    dragon_flags = dragon::fixup;
+  } else if (!is_constant_evaluated() && precision < 0) {
+    // Use Dragonbox for the shortest format.
+    if (specs.binary32) {
+      auto dec = dragonbox::to_decimal(static_cast<float>(value));
+      write<char>(buffer_appender<char>(buf), dec.significand);
+      return dec.exponent;
+    }
+    auto dec = dragonbox::to_decimal(static_cast<double>(value));
+    write<char>(buffer_appender<char>(buf), dec.significand);
+    return dec.exponent;
+  } else if (is_constant_evaluated()) {
+    // Use Grisu + Dragon4 for the given precision:
+    // https://www.cs.tufts.edu/~nr/cs257/archive/florian-loitsch/printf.pdf.
+    const int min_exp = -60;  // alpha in Grisu.
+    int cached_exp10 = 0;     // K in Grisu.
+    fp normalized = normalize(fp(converted_value));
+    const auto cached_pow = get_cached_power(
+        min_exp - (normalized.e + fp::num_significand_bits), cached_exp10);
+    normalized = normalized * cached_pow;
+    gen_digits_handler handler{buf.data(), 0, precision, -cached_exp10, fixed};
+    if (grisu_gen_digits(normalized, 1, exp, handler) != digits::error &&
+        !is_constant_evaluated()) {
+      exp += handler.exp10;
+      buf.try_resize(to_unsigned(handler.size));
+      use_dragon = false;
+    } else {
+      exp += handler.size - cached_exp10 - 1;
+      precision = handler.precision;
+    }
+  } else {
+    // Extract significand bits and exponent bits.
+    using info = dragonbox::float_info<double>;
+    auto br = bit_cast<uint64_t>(static_cast<double>(value));
+
+    const uint64_t significand_mask =
+        (static_cast<uint64_t>(1) << num_significand_bits<double>()) - 1;
+    uint64_t significand = (br & significand_mask);
+    int exponent = static_cast<int>((br & exponent_mask<double>()) >>
+                                    num_significand_bits<double>());
+
+    if (exponent != 0) {  // Check if normal.
+      exponent -= exponent_bias<double>() + num_significand_bits<double>();
+      significand |=
+          (static_cast<uint64_t>(1) << num_significand_bits<double>());
+      significand <<= 1;
+    } else {
+      // Normalize subnormal inputs.
+      FMT_ASSERT(significand != 0, "zeros should not appear hear");
+      int shift = countl_zero(significand);
+      FMT_ASSERT(shift >= num_bits<uint64_t>() - num_significand_bits<double>(),
+                 "");
+      shift -= (num_bits<uint64_t>() - num_significand_bits<double>() - 2);
+      exponent = (std::numeric_limits<double>::min_exponent -
+                  num_significand_bits<double>()) -
+                 shift;
+      significand <<= shift;
+    }
+
+    // Compute the first several nonzero decimal significand digits.
+    // We call the number we get the first segment.
+    const int k = info::kappa - dragonbox::floor_log10_pow2(exponent);
+    exp = -k;
+    const int beta = exponent + dragonbox::floor_log2_pow10(k);
+    uint64_t first_segment;
+    bool has_more_segments;
+    int digits_in_the_first_segment;
+    {
+      const auto r = dragonbox::umul192_upper128(
+          significand << beta, dragonbox::get_cached_power(k));
+      first_segment = r.high();
+      has_more_segments = r.low() != 0;
+
+      // The first segment can have 18 ~ 19 digits.
+      if (first_segment >= 1000000000000000000ULL) {
+        digits_in_the_first_segment = 19;
+      } else {
+        // When it is of 18-digits, we align it to 19-digits by adding a bogus
+        // zero at the end.
+        digits_in_the_first_segment = 18;
+        first_segment *= 10;
+      }
+    }
+
+    // Compute the actual number of decimal digits to print.
+    if (fixed) {
+      adjust_precision(precision, exp + digits_in_the_first_segment);
+    }
+
+    // Use Dragon4 only when there might be not enough digits in the first
+    // segment.
+    if (digits_in_the_first_segment > precision) {
+      use_dragon = false;
+
+      if (precision <= 0) {
+        exp += digits_in_the_first_segment;
+
+        if (precision < 0) {
+          // Nothing to do, since all we have are just leading zeros.
+          buf.try_resize(0);
+        } else {
+          // We may need to round-up.
+          buf.try_resize(1);
+          if ((first_segment | static_cast<uint64_t>(has_more_segments)) >
+              5000000000000000000ULL) {
+            buf[0] = '1';
+          } else {
+            buf[0] = '0';
+          }
+        }
+      }  // precision <= 0
+      else {
+        exp += digits_in_the_first_segment - precision;
+
+        // When precision > 0, we divide the first segment into three
+        // subsegments, each with 9, 9, and 0 ~ 1 digits so that each fits
+        // in 32-bits which usually allows faster calculation than in
+        // 64-bits. Since some compiler (e.g. MSVC) doesn't know how to optimize
+        // division-by-constant for large 64-bit divisors, we do it here
+        // manually. The magic number 7922816251426433760 below is equal to
+        // ceil(2^(64+32) / 10^10).
+        const uint32_t first_subsegment = static_cast<uint32_t>(
+            dragonbox::umul128_upper64(first_segment, 7922816251426433760ULL) >>
+            32);
+        const uint64_t second_third_subsegments =
+            first_segment - first_subsegment * 10000000000ULL;
+
+        uint64_t prod;
+        uint32_t digits;
+        bool should_round_up;
+        int number_of_digits_to_print = precision > 9 ? 9 : precision;
+
+        // Print a 9-digits subsegment, either the first or the second.
+        auto print_subsegment = [&](uint32_t subsegment, char* buffer) {
+          int number_of_digits_printed = 0;
+
+          // If we want to print an odd number of digits from the subsegment,
+          if ((number_of_digits_to_print & 1) != 0) {
+            // Convert to 64-bit fixed-point fractional form with 1-digit
+            // integer part. The magic number 720575941 is a good enough
+            // approximation of 2^(32 + 24) / 10^8; see
+            // https://jk-jeon.github.io/posts/2022/12/fixed-precision-formatting/#fixed-length-case
+            // for details.
+            prod = ((subsegment * static_cast<uint64_t>(720575941)) >> 24) + 1;
+            digits = static_cast<uint32_t>(prod >> 32);
+            *buffer = static_cast<char>('0' + digits);
+            number_of_digits_printed++;
+          }
+          // If we want to print an even number of digits from the
+          // first_subsegment,
+          else {
+            // Convert to 64-bit fixed-point fractional form with 2-digits
+            // integer part. The magic number 450359963 is a good enough
+            // approximation of 2^(32 + 20) / 10^7; see
+            // https://jk-jeon.github.io/posts/2022/12/fixed-precision-formatting/#fixed-length-case
+            // for details.
+            prod = ((subsegment * static_cast<uint64_t>(450359963)) >> 20) + 1;
+            digits = static_cast<uint32_t>(prod >> 32);
+            copy2(buffer, digits2(digits));
+            number_of_digits_printed += 2;
+          }
+
+          // Print all digit pairs.
+          while (number_of_digits_printed < number_of_digits_to_print) {
+            prod = static_cast<uint32_t>(prod) * static_cast<uint64_t>(100);
+            digits = static_cast<uint32_t>(prod >> 32);
+            copy2(buffer + number_of_digits_printed, digits2(digits));
+            number_of_digits_printed += 2;
+          }
+        };
+
+        // Print first subsegment.
+        print_subsegment(first_subsegment, buf.data());
+
+        // Perform rounding if the first subsegment is the last subsegment to
+        // print.
+        if (precision <= 9) {
+          // Rounding inside the subsegment.
+          // We round-up if:
+          //  - either the fractional part is strictly larger than 1/2, or
+          //  - the fractional part is exactly 1/2 and the last digit is odd.
+          // We rely on the following observations:
+          //  - If fractional_part >= threshold, then the fractional part is
+          //    strictly larger than 1/2.
+          //  - If the MSB of fractional_part is set, then the fractional part
+          //    must be at least 1/2.
+          //  - When the MSB of fractional_part is set, either
+          //    second_third_subsegments being nonzero or has_more_segments
+          //    being true means there are further digits not printed, so the
+          //    fractional part is strictly larger than 1/2.
+          if (precision < 9) {
+            uint32_t fractional_part = static_cast<uint32_t>(prod);
+            should_round_up = fractional_part >=
+                                  data::fractional_part_rounding_thresholds
+                                      [8 - number_of_digits_to_print] ||
+                              ((fractional_part >> 31) &
+                               ((digits & 1) | (second_third_subsegments != 0) |
+                                has_more_segments)) != 0;
+          }
+          // Rounding at the subsegment boundary.
+          // In this case, the fractional part is at least 1/2 if and only if
+          // second_third_subsegments >= 5000000000ULL, and is strictly larger
+          // than 1/2 if we further have either second_third_subsegments >
+          // 5000000000ULL or has_more_segments == true.
+          else {
+            should_round_up = second_third_subsegments > 5000000000ULL ||
+                              (second_third_subsegments == 5000000000ULL &&
+                               ((digits & 1) != 0 || has_more_segments));
+          }
+        }
+        // Otherwise, print the second subsegment.
+        else {
+          // Compilers are not aware of how to leverage the maximum value of
+          // second_third_subsegments to find out a better magic number which
+          // allows us to eliminate an additional shift. 1844674407370955162 =
+          // ceil(2^64/10) < ceil(2^64*(10^9/(10^10 - 1))).
+          const uint32_t second_subsegment =
+              static_cast<uint32_t>(dragonbox::umul128_upper64(
+                  second_third_subsegments, 1844674407370955162ULL));
+          const uint32_t third_subsegment =
+              static_cast<uint32_t>(second_third_subsegments) -
+              second_subsegment * 10;
+
+          number_of_digits_to_print = precision - 9;
+          print_subsegment(second_subsegment, buf.data() + 9);
+
+          // Rounding inside the subsegment.
+          if (precision < 18) {
+            // The condition third_subsegment != 0 implies that the segment was
+            // of 19 digits, so in this case the third segment should be
+            // consisting of a genuine digit from the input.
+            uint32_t fractional_part = static_cast<uint32_t>(prod);
+            should_round_up = fractional_part >=
+                                  data::fractional_part_rounding_thresholds
+                                      [8 - number_of_digits_to_print] ||
+                              ((fractional_part >> 31) &
+                               ((digits & 1) | (third_subsegment != 0) |
+                                has_more_segments)) != 0;
+          }
+          // Rounding at the subsegment boundary.
+          else {
+            // In this case, the segment must be of 19 digits, thus
+            // the third subsegment should be consisting of a genuine digit from
+            // the input.
+            should_round_up = third_subsegment > 5 ||
+                              (third_subsegment == 5 &&
+                               ((digits & 1) != 0 || has_more_segments));
+          }
+        }
+
+        // Round-up if necessary.
+        if (should_round_up) {
+          ++buf[precision - 1];
+          for (int i = precision - 1; i > 0 && buf[i] > '9'; --i) {
+            buf[i] = '0';
+            ++buf[i - 1];
+          }
+          if (buf[0] > '9') {
+            buf[0] = '1';
+            if (fixed)
+              buf[precision++] = '0';
+            else
+              ++exp;
+          }
+        }
+        buf.try_resize(to_unsigned(precision));
+      }
+    }  // if (digits_in_the_first_segment > precision)
+    else {
+      // Adjust the exponent for its use in Dragon4.
+      exp += digits_in_the_first_segment - 1;
+    }
+  }
+  if (use_dragon) {
+    auto f = basic_fp<uint128_t>();
+    bool is_predecessor_closer = specs.binary32
+                                     ? f.assign(static_cast<float>(value))
+                                     : f.assign(converted_value);
+    if (is_predecessor_closer) dragon_flags |= dragon::predecessor_closer;
+    if (fixed) dragon_flags |= dragon::fixed;
+    // Limit precision to the maximum possible number of significant digits in
+    // an IEEE754 double because we don't need to generate zeros.
+    const int max_double_digits = 767;
+    if (precision > max_double_digits) precision = max_double_digits;
+    format_dragon(f, dragon_flags, precision, buf, exp);
+  }
+  if (!fixed && !specs.showpoint) {
+    // Remove trailing zeros.
+    auto num_digits = buf.size();
+    while (num_digits > 0 && buf[num_digits - 1] == '0') {
+      --num_digits;
+      ++exp;
+    }
+    buf.try_resize(num_digits);
+  }
+  return exp;
+}
+template <typename Char, typename OutputIt, typename T>
+FMT_CONSTEXPR20 auto write_float(OutputIt out, T value,
+                                 format_specs<Char> specs, locale_ref loc)
+    -> OutputIt {
+  float_specs fspecs = parse_float_type_spec(specs);
+  fspecs.sign = specs.sign;
+  if (detail::signbit(value)) {  // value < 0 is false for NaN so use signbit.
+    fspecs.sign = sign::minus;
+    value = -value;
+  } else if (fspecs.sign == sign::minus) {
+    fspecs.sign = sign::none;
+  }
+
+  if (!detail::isfinite(value))
+    return write_nonfinite(out, detail::isnan(value), specs, fspecs);
+
+  if (specs.align == align::numeric && fspecs.sign) {
+    auto it = reserve(out, 1);
+    *it++ = detail::sign<Char>(fspecs.sign);
+    out = base_iterator(out, it);
+    fspecs.sign = sign::none;
+    if (specs.width != 0) --specs.width;
+  }
+
+  memory_buffer buffer;
+  if (fspecs.format == float_format::hex) {
+    if (fspecs.sign) buffer.push_back(detail::sign<char>(fspecs.sign));
+    format_hexfloat(convert_float(value), specs.precision, fspecs, buffer);
+    return write_bytes<align::right>(out, {buffer.data(), buffer.size()},
+                                     specs);
+  }
+  int precision = specs.precision >= 0 || specs.type == presentation_type::none
+                      ? specs.precision
+                      : 6;
+  if (fspecs.format == float_format::exp) {
+    if (precision == max_value<int>())
+      throw_format_error("number is too big");
+    else
+      ++precision;
+  } else if (fspecs.format != float_format::fixed && precision == 0) {
+    precision = 1;
+  }
+  if (const_check(std::is_same<T, float>())) fspecs.binary32 = true;
+  int exp = format_float(convert_float(value), precision, fspecs, buffer);
+  fspecs.precision = precision;
+  auto f = big_decimal_fp{buffer.data(), static_cast<int>(buffer.size()), exp};
+  return write_float(out, f, specs, fspecs, loc);
+}
+
+template <typename Char, typename OutputIt, typename T,
+          FMT_ENABLE_IF(is_floating_point<T>::value)>
+FMT_CONSTEXPR20 auto write(OutputIt out, T value, format_specs<Char> specs,
+                           locale_ref loc = {}) -> OutputIt {
+  if (const_check(!is_supported_floating_point(value))) return out;
+  return specs.localized && write_loc(out, value, specs, loc)
+             ? out
+             : write_float(out, value, specs, loc);
+}
+
+template <typename Char, typename OutputIt, typename T,
+          FMT_ENABLE_IF(is_fast_float<T>::value)>
+FMT_CONSTEXPR20 auto write(OutputIt out, T value) -> OutputIt {
+  if (is_constant_evaluated()) return write(out, value, format_specs<Char>());
+  if (const_check(!is_supported_floating_point(value))) return out;
+
+  auto fspecs = float_specs();
+  if (detail::signbit(value)) {
+    fspecs.sign = sign::minus;
+    value = -value;
+  }
+
+  constexpr auto specs = format_specs<Char>();
+  using floaty = conditional_t<std::is_same<T, long double>::value, double, T>;
+  using floaty_uint = typename dragonbox::float_info<floaty>::carrier_uint;
+  floaty_uint mask = exponent_mask<floaty>();
+  if ((bit_cast<floaty_uint>(value) & mask) == mask)
+    return write_nonfinite(out, std::isnan(value), specs, fspecs);
+
+  auto dec = dragonbox::to_decimal(static_cast<floaty>(value));
+  return write_float(out, dec, specs, fspecs, {});
+}
+
+template <typename Char, typename OutputIt, typename T,
+          FMT_ENABLE_IF(is_floating_point<T>::value &&
+                        !is_fast_float<T>::value)>
+inline auto write(OutputIt out, T value) -> OutputIt {
+  return write(out, value, format_specs<Char>());
+}
+
+template <typename Char, typename OutputIt>
+auto write(OutputIt out, monostate, format_specs<Char> = {}, locale_ref = {})
+    -> OutputIt {
+  FMT_ASSERT(false, "");
+  return out;
+}
+
+template <typename Char, typename OutputIt>
+FMT_CONSTEXPR auto write(OutputIt out, basic_string_view<Char> value)
+    -> OutputIt {
+  auto it = reserve(out, value.size());
+  it = copy_str_noinline<Char>(value.begin(), value.end(), it);
+  return base_iterator(out, it);
+}
+
+template <typename Char, typename OutputIt, typename T,
+          FMT_ENABLE_IF(is_string<T>::value)>
+constexpr auto write(OutputIt out, const T& value) -> OutputIt {
+  return write<Char>(out, to_string_view(value));
+}
+
+// FMT_ENABLE_IF() condition separated to workaround an MSVC bug.
+template <
+    typename Char, typename OutputIt, typename T,
+    bool check =
+        std::is_enum<T>::value && !std::is_same<T, Char>::value &&
+        mapped_type_constant<T, basic_format_context<OutputIt, Char>>::value !=
+            type::custom_type,
+    FMT_ENABLE_IF(check)>
+FMT_CONSTEXPR auto write(OutputIt out, T value) -> OutputIt {
+  return write<Char>(out, static_cast<underlying_t<T>>(value));
+}
+
+template <typename Char, typename OutputIt, typename T,
+          FMT_ENABLE_IF(std::is_same<T, bool>::value)>
+FMT_CONSTEXPR auto write(OutputIt out, T value,
+                         const format_specs<Char>& specs = {}, locale_ref = {})
+    -> OutputIt {
+  return specs.type != presentation_type::none &&
+                 specs.type != presentation_type::string
+             ? write(out, value ? 1 : 0, specs, {})
+             : write_bytes(out, value ? "true" : "false", specs);
+}
+
+template <typename Char, typename OutputIt>
+FMT_CONSTEXPR auto write(OutputIt out, Char value) -> OutputIt {
+  auto it = reserve(out, 1);
+  *it++ = value;
+  return base_iterator(out, it);
+}
+
+template <typename Char, typename OutputIt>
+FMT_CONSTEXPR_CHAR_TRAITS auto write(OutputIt out, const Char* value)
+    -> OutputIt {
+  if (value) return write(out, basic_string_view<Char>(value));
+  throw_format_error("string pointer is null");
+  return out;
+}
+
+template <typename Char, typename OutputIt, typename T,
+          FMT_ENABLE_IF(std::is_same<T, void>::value)>
+auto write(OutputIt out, const T* value, const format_specs<Char>& specs = {},
+           locale_ref = {}) -> OutputIt {
+  return write_ptr<Char>(out, bit_cast<uintptr_t>(value), &specs);
+}
+
+// A write overload that handles implicit conversions.
+template <typename Char, typename OutputIt, typename T,
+          typename Context = basic_format_context<OutputIt, Char>>
+FMT_CONSTEXPR auto write(OutputIt out, const T& value) -> enable_if_t<
+    std::is_class<T>::value && !is_string<T>::value &&
+        !is_floating_point<T>::value && !std::is_same<T, Char>::value &&
+        !std::is_same<T, remove_cvref_t<decltype(arg_mapper<Context>().map(
+                             value))>>::value,
+    OutputIt> {
+  return write<Char>(out, arg_mapper<Context>().map(value));
+}
+
+template <typename Char, typename OutputIt, typename T,
+          typename Context = basic_format_context<OutputIt, Char>>
+FMT_CONSTEXPR auto write(OutputIt out, const T& value)
+    -> enable_if_t<mapped_type_constant<T, Context>::value == type::custom_type,
+                   OutputIt> {
+  auto ctx = Context(out, {}, {});
+  return typename Context::template formatter_type<T>().format(value, ctx);
+}
+
+// An argument visitor that formats the argument and writes it via the output
+// iterator. It's a class and not a generic lambda for compatibility with C++11.
+template <typename Char> struct default_arg_formatter {
+  using iterator = buffer_appender<Char>;
+  using context = buffer_context<Char>;
+
+  iterator out;
+  basic_format_args<context> args;
+  locale_ref loc;
+
+  template <typename T> auto operator()(T value) -> iterator {
+    return write<Char>(out, value);
+  }
+  auto operator()(typename basic_format_arg<context>::handle h) -> iterator {
+    basic_format_parse_context<Char> parse_ctx({});
+    context format_ctx(out, args, loc);
+    h.format(parse_ctx, format_ctx);
+    return format_ctx.out();
+  }
+};
+
+template <typename Char> struct arg_formatter {
+  using iterator = buffer_appender<Char>;
+  using context = buffer_context<Char>;
+
+  iterator out;
+  const format_specs<Char>& specs;
+  locale_ref locale;
+
+  template <typename T>
+  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
+    return detail::write(out, value, specs, locale);
+  }
+  auto operator()(typename basic_format_arg<context>::handle) -> iterator {
+    // User-defined types are handled separately because they require access
+    // to the parse context.
+    return out;
+  }
+};
+
+template <typename Char> struct custom_formatter {
+  basic_format_parse_context<Char>& parse_ctx;
+  buffer_context<Char>& ctx;
+
+  void operator()(
+      typename basic_format_arg<buffer_context<Char>>::handle h) const {
+    h.format(parse_ctx, ctx);
+  }
+  template <typename T> void operator()(T) const {}
+};
+
+template <typename ErrorHandler> class width_checker {
+ public:
+  explicit FMT_CONSTEXPR width_checker(ErrorHandler& eh) : handler_(eh) {}
+
+  template <typename T, FMT_ENABLE_IF(is_integer<T>::value)>
+  FMT_CONSTEXPR auto operator()(T value) -> unsigned long long {
+    if (is_negative(value)) handler_.on_error("negative width");
+    return static_cast<unsigned long long>(value);
+  }
+
+  template <typename T, FMT_ENABLE_IF(!is_integer<T>::value)>
+  FMT_CONSTEXPR auto operator()(T) -> unsigned long long {
+    handler_.on_error("width is not integer");
+    return 0;
+  }
+
+ private:
+  ErrorHandler& handler_;
+};
+
+template <typename ErrorHandler> class precision_checker {
+ public:
+  explicit FMT_CONSTEXPR precision_checker(ErrorHandler& eh) : handler_(eh) {}
+
+  template <typename T, FMT_ENABLE_IF(is_integer<T>::value)>
+  FMT_CONSTEXPR auto operator()(T value) -> unsigned long long {
+    if (is_negative(value)) handler_.on_error("negative precision");
+    return static_cast<unsigned long long>(value);
+  }
+
+  template <typename T, FMT_ENABLE_IF(!is_integer<T>::value)>
+  FMT_CONSTEXPR auto operator()(T) -> unsigned long long {
+    handler_.on_error("precision is not integer");
+    return 0;
+  }
+
+ private:
+  ErrorHandler& handler_;
+};
+
+template <template <typename> class Handler, typename FormatArg,
+          typename ErrorHandler>
+FMT_CONSTEXPR auto get_dynamic_spec(FormatArg arg, ErrorHandler eh) -> int {
+  unsigned long long value = visit_format_arg(Handler<ErrorHandler>(eh), arg);
+  if (value > to_unsigned(max_value<int>())) eh.on_error("number is too big");
+  return static_cast<int>(value);
+}
+
+template <typename Context, typename ID>
+FMT_CONSTEXPR auto get_arg(Context& ctx, ID id) ->
+    typename Context::format_arg {
+  auto arg = ctx.arg(id);
+  if (!arg) ctx.on_error("argument not found");
+  return arg;
+}
+
+template <template <typename> class Handler, typename Context>
+FMT_CONSTEXPR void handle_dynamic_spec(int& value,
+                                       arg_ref<typename Context::char_type> ref,
+                                       Context& ctx) {
+  switch (ref.kind) {
+  case arg_id_kind::none:
+    break;
+  case arg_id_kind::index:
+    value = detail::get_dynamic_spec<Handler>(get_arg(ctx, ref.val.index),
+                                              ctx.error_handler());
+    break;
+  case arg_id_kind::name:
+    value = detail::get_dynamic_spec<Handler>(get_arg(ctx, ref.val.name),
+                                              ctx.error_handler());
+    break;
+  }
+}
+
+#if FMT_USE_USER_DEFINED_LITERALS
+template <typename Char> struct udl_formatter {
+  basic_string_view<Char> str;
+
+  template <typename... T>
+  auto operator()(T&&... args) const -> std::basic_string<Char> {
+    return vformat(str, fmt::make_format_args<buffer_context<Char>>(args...));
+  }
+};
+
+#  if FMT_USE_NONTYPE_TEMPLATE_ARGS
+template <typename T, typename Char, size_t N,
+          fmt::detail_exported::fixed_string<Char, N> Str>
+struct statically_named_arg : view {
+  static constexpr auto name = Str.data;
+
+  const T& value;
+  statically_named_arg(const T& v) : value(v) {}
+};
+
+template <typename T, typename Char, size_t N,
+          fmt::detail_exported::fixed_string<Char, N> Str>
+struct is_named_arg<statically_named_arg<T, Char, N, Str>> : std::true_type {};
+
+template <typename T, typename Char, size_t N,
+          fmt::detail_exported::fixed_string<Char, N> Str>
+struct is_statically_named_arg<statically_named_arg<T, Char, N, Str>>
+    : std::true_type {};
+
+template <typename Char, size_t N,
+          fmt::detail_exported::fixed_string<Char, N> Str>
+struct udl_arg {
+  template <typename T> auto operator=(T&& value) const {
+    return statically_named_arg<T, Char, N, Str>(std::forward<T>(value));
+  }
+};
+#  else
+template <typename Char> struct udl_arg {
+  const Char* str;
+
+  template <typename T> auto operator=(T&& value) const -> named_arg<Char, T> {
+    return {str, std::forward<T>(value)};
+  }
+};
+#  endif
+#endif  // FMT_USE_USER_DEFINED_LITERALS
+
+template <typename Locale, typename Char>
+auto vformat(const Locale& loc, basic_string_view<Char> fmt,
+             basic_format_args<buffer_context<type_identity_t<Char>>> args)
+    -> std::basic_string<Char> {
+  auto buf = basic_memory_buffer<Char>();
+  detail::vformat_to(buf, fmt, args, detail::locale_ref(loc));
+  return {buf.data(), buf.size()};
+}
+
+using format_func = void (*)(detail::buffer<char>&, int, const char*);
+
+FMT_API void format_error_code(buffer<char>& out, int error_code,
+                               string_view message) noexcept;
+
+FMT_API void report_error(format_func func, int error_code,
+                          const char* message) noexcept;
+FMT_END_DETAIL_NAMESPACE
+
+FMT_API auto vsystem_error(int error_code, string_view format_str,
+                           format_args args) -> std::system_error;
+
+/**
+ \rst
+ Constructs :class:`std::system_error` with a message formatted with
+ ``fmt::format(fmt, args...)``.
+  *error_code* is a system error code as given by ``errno``.
+
+ **Example**::
+
+   // This throws std::system_error with the description
+   //   cannot open file 'madeup': No such file or directory
+   // or similar (system message may vary).
+   const char* filename = "madeup";
+   std::FILE* file = std::fopen(filename, "r");
+   if (!file)
+     throw fmt::system_error(errno, "cannot open file '{}'", filename);
+ \endrst
+*/
+template <typename... T>
+auto system_error(int error_code, format_string<T...> fmt, T&&... args)
+    -> std::system_error {
+  return vsystem_error(error_code, fmt, fmt::make_format_args(args...));
+}
+
+/**
+  \rst
+  Formats an error message for an error returned by an operating system or a
+  language runtime, for example a file opening error, and writes it to *out*.
+  The format is the same as the one used by ``std::system_error(ec, message)``
+  where ``ec`` is ``std::error_code(error_code, std::generic_category()})``.
+  It is implementation-defined but normally looks like:
+
+  .. parsed-literal::
+     *<message>*: *<system-message>*
+
+  where *<message>* is the passed message and *<system-message>* is the system
+  message corresponding to the error code.
+  *error_code* is a system error code as given by ``errno``.
+  \endrst
+ */
+FMT_API void format_system_error(detail::buffer<char>& out, int error_code,
+                                 const char* message) noexcept;
+
+// Reports a system error without throwing an exception.
+// Can be used to report errors from destructors.
+FMT_API void report_system_error(int error_code, const char* message) noexcept;
+
+/** Fast integer formatter. */
+class format_int {
+ private:
+  // Buffer should be large enough to hold all digits (digits10 + 1),
+  // a sign and a null character.
+  enum { buffer_size = std::numeric_limits<unsigned long long>::digits10 + 3 };
+  mutable char buffer_[buffer_size];
+  char* str_;
+
+  template <typename UInt> auto format_unsigned(UInt value) -> char* {
+    auto n = static_cast<detail::uint32_or_64_or_128_t<UInt>>(value);
+    return detail::format_decimal(buffer_, n, buffer_size - 1).begin;
+  }
+
+  template <typename Int> auto format_signed(Int value) -> char* {
+    auto abs_value = static_cast<detail::uint32_or_64_or_128_t<Int>>(value);
+    bool negative = value < 0;
+    if (negative) abs_value = 0 - abs_value;
+    auto begin = format_unsigned(abs_value);
+    if (negative) *--begin = '-';
+    return begin;
+  }
+
+ public:
+  explicit format_int(int value) : str_(format_signed(value)) {}
+  explicit format_int(long value) : str_(format_signed(value)) {}
+  explicit format_int(long long value) : str_(format_signed(value)) {}
+  explicit format_int(unsigned value) : str_(format_unsigned(value)) {}
+  explicit format_int(unsigned long value) : str_(format_unsigned(value)) {}
+  explicit format_int(unsigned long long value)
+      : str_(format_unsigned(value)) {}
+
+  /** Returns the number of characters written to the output buffer. */
+  auto size() const -> size_t {
+    return detail::to_unsigned(buffer_ - str_ + buffer_size - 1);
+  }
+
+  /**
+    Returns a pointer to the output buffer content. No terminating null
+    character is appended.
+   */
+  auto data() const -> const char* { return str_; }
+
+  /**
+    Returns a pointer to the output buffer content with terminating null
+    character appended.
+   */
+  auto c_str() const -> const char* {
+    buffer_[buffer_size - 1] = '\0';
+    return str_;
+  }
+
+  /**
+    \rst
+    Returns the content of the output buffer as an ``std::string``.
+    \endrst
+   */
+  auto str() const -> std::string { return std::string(str_, size()); }
+};
+
+template <typename T, typename Char>
+struct formatter<T, Char, enable_if_t<detail::has_format_as<T>::value>>
+    : private formatter<detail::format_as_t<T>> {
+  using base = formatter<detail::format_as_t<T>>;
+  using base::parse;
+
+  template <typename FormatContext>
+  auto format(const T& value, FormatContext& ctx) const -> decltype(ctx.out()) {
+    return base::format(format_as(value), ctx);
+  }
+};
+
+template <typename Char>
+struct formatter<void*, Char> : formatter<const void*, Char> {
+  template <typename FormatContext>
+  auto format(void* val, FormatContext& ctx) const -> decltype(ctx.out()) {
+    return formatter<const void*, Char>::format(val, ctx);
+  }
+};
+
+template <typename Char, size_t N>
+struct formatter<Char[N], Char> : formatter<basic_string_view<Char>, Char> {
+  template <typename FormatContext>
+  FMT_CONSTEXPR auto format(const Char* val, FormatContext& ctx) const
+      -> decltype(ctx.out()) {
+    return formatter<basic_string_view<Char>, Char>::format(val, ctx);
+  }
+};
+
+/**
+  \rst
+  Converts ``p`` to ``const void*`` for pointer formatting.
+
+  **Example**::
+
+    auto s = fmt::format("{}", fmt::ptr(p));
+  \endrst
+ */
+template <typename T> auto ptr(T p) -> const void* {
+  static_assert(std::is_pointer<T>::value, "");
+  return detail::bit_cast<const void*>(p);
+}
+template <typename T, typename Deleter>
+auto ptr(const std::unique_ptr<T, Deleter>& p) -> const void* {
+  return p.get();
+}
+template <typename T> auto ptr(const std::shared_ptr<T>& p) -> const void* {
+  return p.get();
+}
+
+/**
+  \rst
+  Converts ``e`` to the underlying type.
+
+  **Example**::
+
+    enum class color { red, green, blue };
+    auto s = fmt::format("{}", fmt::underlying(color::red));
+  \endrst
+ */
+template <typename Enum>
+constexpr auto underlying(Enum e) noexcept -> underlying_t<Enum> {
+  return static_cast<underlying_t<Enum>>(e);
+}
+
+namespace enums {
+template <typename Enum, FMT_ENABLE_IF(std::is_enum<Enum>::value)>
+constexpr auto format_as(Enum e) noexcept -> underlying_t<Enum> {
+  return static_cast<underlying_t<Enum>>(e);
+}
+}  // namespace enums
+
+class bytes {
+ private:
+  string_view data_;
+  friend struct formatter<bytes>;
+
+ public:
+  explicit bytes(string_view data) : data_(data) {}
+};
+
+template <> struct formatter<bytes> {
+ private:
+  detail::dynamic_format_specs<> specs_;
+
+ public:
+  template <typename ParseContext>
+  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> const char* {
+    return parse_format_specs(ctx.begin(), ctx.end(), specs_, ctx,
+                              detail::type::string_type);
+  }
+
+  template <typename FormatContext>
+  auto format(bytes b, FormatContext& ctx) -> decltype(ctx.out()) {
+    detail::handle_dynamic_spec<detail::width_checker>(specs_.width,
+                                                       specs_.width_ref, ctx);
+    detail::handle_dynamic_spec<detail::precision_checker>(
+        specs_.precision, specs_.precision_ref, ctx);
+    return detail::write_bytes(ctx.out(), b.data_, specs_);
+  }
+};
+
+// group_digits_view is not derived from view because it copies the argument.
+template <typename T> struct group_digits_view { T value; };
+
+/**
+  \rst
+  Returns a view that formats an integer value using ',' as a locale-independent
+  thousands separator.
+
+  **Example**::
+
+    fmt::print("{}", fmt::group_digits(12345));
+    // Output: "12,345"
+  \endrst
+ */
+template <typename T> auto group_digits(T value) -> group_digits_view<T> {
+  return {value};
+}
+
+template <typename T> struct formatter<group_digits_view<T>> : formatter<T> {
+ private:
+  detail::dynamic_format_specs<> specs_;
+
+ public:
+  template <typename ParseContext>
+  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> const char* {
+    return parse_format_specs(ctx.begin(), ctx.end(), specs_, ctx,
+                              detail::type::int_type);
+  }
+
+  template <typename FormatContext>
+  auto format(group_digits_view<T> t, FormatContext& ctx)
+      -> decltype(ctx.out()) {
+    detail::handle_dynamic_spec<detail::width_checker>(specs_.width,
+                                                       specs_.width_ref, ctx);
+    detail::handle_dynamic_spec<detail::precision_checker>(
+        specs_.precision, specs_.precision_ref, ctx);
+    return detail::write_int(
+        ctx.out(), static_cast<detail::uint64_or_128_t<T>>(t.value), 0, specs_,
+        detail::digit_grouping<char>("\3", ","));
+  }
+};
+
+// DEPRECATED! join_view will be moved to ranges.h.
+template <typename It, typename Sentinel, typename Char = char>
+struct join_view : detail::view {
+  It begin;
+  Sentinel end;
+  basic_string_view<Char> sep;
+
+  join_view(It b, Sentinel e, basic_string_view<Char> s)
+      : begin(b), end(e), sep(s) {}
+};
+
+template <typename It, typename Sentinel, typename Char>
+struct formatter<join_view<It, Sentinel, Char>, Char> {
+ private:
+  using value_type =
+#ifdef __cpp_lib_ranges
+      std::iter_value_t<It>;
+#else
+      typename std::iterator_traits<It>::value_type;
+#endif
+  formatter<remove_cvref_t<value_type>, Char> value_formatter_;
+
+ public:
+  template <typename ParseContext>
+  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> const Char* {
+    return value_formatter_.parse(ctx);
+  }
+
+  template <typename FormatContext>
+  auto format(const join_view<It, Sentinel, Char>& value,
+              FormatContext& ctx) const -> decltype(ctx.out()) {
+    auto it = value.begin;
+    auto out = ctx.out();
+    if (it != value.end) {
+      out = value_formatter_.format(*it, ctx);
+      ++it;
+      while (it != value.end) {
+        out = detail::copy_str<Char>(value.sep.begin(), value.sep.end(), out);
+        ctx.advance_to(out);
+        out = value_formatter_.format(*it, ctx);
+        ++it;
+      }
+    }
+    return out;
+  }
+};
+
+/**
+  Returns a view that formats the iterator range `[begin, end)` with elements
+  separated by `sep`.
+ */
+template <typename It, typename Sentinel>
+auto join(It begin, Sentinel end, string_view sep) -> join_view<It, Sentinel> {
+  return {begin, end, sep};
+}
+
+/**
+  \rst
+  Returns a view that formats `range` with elements separated by `sep`.
+
+  **Example**::
+
+    std::vector<int> v = {1, 2, 3};
+    fmt::print("{}", fmt::join(v, ", "));
+    // Output: "1, 2, 3"
+
+  ``fmt::join`` applies passed format specifiers to the range elements::
+
+    fmt::print("{:02}", fmt::join(v, ", "));
+    // Output: "01, 02, 03"
+  \endrst
+ */
+template <typename Range>
+auto join(Range&& range, string_view sep)
+    -> join_view<detail::iterator_t<Range>, detail::sentinel_t<Range>> {
+  return join(std::begin(range), std::end(range), sep);
+}
+
+/**
+  \rst
+  Converts *value* to ``std::string`` using the default format for type *T*.
+
+  **Example**::
+
+    #include <fmt/format.h>
+
+    std::string answer = fmt::to_string(42);
+  \endrst
+ */
+template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
+inline auto to_string(const T& value) -> std::string {
+  auto buffer = memory_buffer();
+  detail::write<char>(appender(buffer), value);
+  return {buffer.data(), buffer.size()};
+}
+
+template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
+FMT_NODISCARD inline auto to_string(T value) -> std::string {
+  // The buffer should be large enough to store the number including the sign
+  // or "false" for bool.
+  constexpr int max_size = detail::digits10<T>() + 2;
+  char buffer[max_size > 5 ? static_cast<unsigned>(max_size) : 5];
+  char* begin = buffer;
+  return std::string(begin, detail::write<char>(begin, value));
+}
+
+template <typename Char, size_t SIZE>
+FMT_NODISCARD auto to_string(const basic_memory_buffer<Char, SIZE>& buf)
+    -> std::basic_string<Char> {
+  auto size = buf.size();
+  detail::assume(size < std::basic_string<Char>().max_size());
+  return std::basic_string<Char>(buf.data(), size);
+}
+
+FMT_BEGIN_DETAIL_NAMESPACE
+
+template <typename Char>
+void vformat_to(buffer<Char>& buf, basic_string_view<Char> fmt,
+                typename vformat_args<Char>::type args, locale_ref loc) {
+  auto out = buffer_appender<Char>(buf);
+  if (fmt.size() == 2 && equal2(fmt.data(), "{}")) {
+    auto arg = args.get(0);
+    if (!arg) error_handler().on_error("argument not found");
+    visit_format_arg(default_arg_formatter<Char>{out, args, loc}, arg);
+    return;
+  }
+
+  struct format_handler : error_handler {
+    basic_format_parse_context<Char> parse_context;
+    buffer_context<Char> context;
+
+    format_handler(buffer_appender<Char> p_out, basic_string_view<Char> str,
+                   basic_format_args<buffer_context<Char>> p_args,
+                   locale_ref p_loc)
+        : parse_context(str), context(p_out, p_args, p_loc) {}
+
+    void on_text(const Char* begin, const Char* end) {
+      auto text = basic_string_view<Char>(begin, to_unsigned(end - begin));
+      context.advance_to(write<Char>(context.out(), text));
+    }
+
+    FMT_CONSTEXPR auto on_arg_id() -> int {
+      return parse_context.next_arg_id();
+    }
+    FMT_CONSTEXPR auto on_arg_id(int id) -> int {
+      return parse_context.check_arg_id(id), id;
+    }
+    FMT_CONSTEXPR auto on_arg_id(basic_string_view<Char> id) -> int {
+      int arg_id = context.arg_id(id);
+      if (arg_id < 0) on_error("argument not found");
+      return arg_id;
+    }
+
+    FMT_INLINE void on_replacement_field(int id, const Char*) {
+      auto arg = get_arg(context, id);
+      context.advance_to(visit_format_arg(
+          default_arg_formatter<Char>{context.out(), context.args(),
+                                      context.locale()},
+          arg));
+    }
+
+    auto on_format_specs(int id, const Char* begin, const Char* end)
+        -> const Char* {
+      auto arg = get_arg(context, id);
+      if (arg.type() == type::custom_type) {
+        parse_context.advance_to(begin);
+        visit_format_arg(custom_formatter<Char>{parse_context, context}, arg);
+        return parse_context.begin();
+      }
+      auto specs = detail::dynamic_format_specs<Char>();
+      begin = parse_format_specs(begin, end, specs, parse_context, arg.type());
+      detail::handle_dynamic_spec<detail::width_checker>(
+          specs.width, specs.width_ref, context);
+      detail::handle_dynamic_spec<detail::precision_checker>(
+          specs.precision, specs.precision_ref, context);
+      if (begin == end || *begin != '}')
+        on_error("missing '}' in format string");
+      auto f = arg_formatter<Char>{context.out(), specs, context.locale()};
+      context.advance_to(visit_format_arg(f, arg));
+      return begin;
+    }
+  };
+  detail::parse_format_string<false>(fmt, format_handler(out, fmt, args, loc));
+}
+
+#ifndef FMT_HEADER_ONLY
+extern template FMT_API void vformat_to(buffer<char>&, string_view,
+                                        typename vformat_args<>::type,
+                                        locale_ref);
+extern template FMT_API auto thousands_sep_impl<char>(locale_ref)
+    -> thousands_sep_result<char>;
+extern template FMT_API auto thousands_sep_impl<wchar_t>(locale_ref)
+    -> thousands_sep_result<wchar_t>;
+extern template FMT_API auto decimal_point_impl(locale_ref) -> char;
+extern template FMT_API auto decimal_point_impl(locale_ref) -> wchar_t;
+#endif  // FMT_HEADER_ONLY
+
+FMT_END_DETAIL_NAMESPACE
+
+#if FMT_USE_USER_DEFINED_LITERALS
+inline namespace literals {
+/**
+  \rst
+  User-defined literal equivalent of :func:`fmt::arg`.
+
+  **Example**::
+
+    using namespace fmt::literals;
+    fmt::print("Elapsed time: {s:.2f} seconds", "s"_a=1.23);
+  \endrst
+ */
+#  if FMT_USE_NONTYPE_TEMPLATE_ARGS
+template <detail_exported::fixed_string Str> constexpr auto operator""_a() {
+  using char_t = remove_cvref_t<decltype(Str.data[0])>;
+  return detail::udl_arg<char_t, sizeof(Str.data) / sizeof(char_t), Str>();
+}
+#  else
+constexpr auto operator"" _a(const char* s, size_t) -> detail::udl_arg<char> {
+  return {s};
+}
+#  endif
+}  // namespace literals
+#endif  // FMT_USE_USER_DEFINED_LITERALS
+
+template <typename Locale, FMT_ENABLE_IF(detail::is_locale<Locale>::value)>
+inline auto vformat(const Locale& loc, string_view fmt, format_args args)
+    -> std::string {
+  return detail::vformat(loc, fmt, args);
+}
+
+template <typename Locale, typename... T,
+          FMT_ENABLE_IF(detail::is_locale<Locale>::value)>
+inline auto format(const Locale& loc, format_string<T...> fmt, T&&... args)
+    -> std::string {
+  return fmt::vformat(loc, string_view(fmt), fmt::make_format_args(args...));
+}
+
+template <typename OutputIt, typename Locale,
+          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value&&
+                            detail::is_locale<Locale>::value)>
+auto vformat_to(OutputIt out, const Locale& loc, string_view fmt,
+                format_args args) -> OutputIt {
+  using detail::get_buffer;
+  auto&& buf = get_buffer<char>(out);
+  detail::vformat_to(buf, fmt, args, detail::locale_ref(loc));
+  return detail::get_iterator(buf, out);
+}
+
+template <typename OutputIt, typename Locale, typename... T,
+          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value&&
+                            detail::is_locale<Locale>::value)>
+FMT_INLINE auto format_to(OutputIt out, const Locale& loc,
+                          format_string<T...> fmt, T&&... args) -> OutputIt {
+  return vformat_to(out, loc, fmt, fmt::make_format_args(args...));
+}
+
+template <typename Locale, typename... T,
+          FMT_ENABLE_IF(detail::is_locale<Locale>::value)>
+FMT_NODISCARD FMT_INLINE auto formatted_size(const Locale& loc,
+                                             format_string<T...> fmt,
+                                             T&&... args) -> size_t {
+  auto buf = detail::counting_buffer<>();
+  detail::vformat_to<char>(buf, fmt, fmt::make_format_args(args...),
+                           detail::locale_ref(loc));
+  return buf.count();
+}
+
+FMT_END_EXPORT
+
+template <typename T, typename Char>
+template <typename FormatContext>
+FMT_CONSTEXPR FMT_INLINE auto
+formatter<T, Char,
+          enable_if_t<detail::type_constant<T, Char>::value !=
+                      detail::type::custom_type>>::format(const T& val,
+                                                          FormatContext& ctx)
+    const -> decltype(ctx.out()) {
+  if (specs_.width_ref.kind != detail::arg_id_kind::none ||
+      specs_.precision_ref.kind != detail::arg_id_kind::none) {
+    auto specs = specs_;
+    detail::handle_dynamic_spec<detail::width_checker>(specs.width,
+                                                       specs.width_ref, ctx);
+    detail::handle_dynamic_spec<detail::precision_checker>(
+        specs.precision, specs.precision_ref, ctx);
+    return detail::write<Char>(ctx.out(), val, specs, ctx.locale());
+  }
+  return detail::write<Char>(ctx.out(), val, specs_, ctx.locale());
+}
+
+FMT_END_NAMESPACE
+
+#ifdef FMT_HEADER_ONLY
+#  define FMT_FUNC inline
+#  include "format-inl.h"
+#else
+#  define FMT_FUNC
+#endif
+
+#endif  // FMT_FORMAT_H_
```

## CoolProp/include/fmt/ostream.h

```diff
@@ -1,108 +1,209 @@
-/*
- Formatting library for C++ - std::ostream support
-
- Copyright (c) 2012 - 2016, Victor Zverovich
- All rights reserved.
-
- For the license information refer to format.h.
- */
-
-#ifndef FMT_OSTREAM_H_
-#define FMT_OSTREAM_H_
-
-#include "format.h"
-#include <ostream>
-
-namespace fmt {
-
-namespace internal {
-
-template <class Char>
-class FormatBuf : public std::basic_streambuf<Char> {
- private:
-  typedef typename std::basic_streambuf<Char>::int_type int_type;
-  typedef typename std::basic_streambuf<Char>::traits_type traits_type;
-
-  Buffer<Char> &buffer_;
-
- public:
-  FormatBuf(Buffer<Char> &buffer) : buffer_(buffer) {}
-
- protected:
-  // The put-area is actually always empty. This makes the implementation
-  // simpler and has the advantage that the streambuf and the buffer are always
-  // in sync and sputc never writes into uninitialized memory. The obvious
-  // disadvantage is that each call to sputc always results in a (virtual) call
-  // to overflow. There is no disadvantage here for sputn since this always
-  // results in a call to xsputn.
-
-  int_type overflow(int_type ch = traits_type::eof()) FMT_OVERRIDE {
-    if (!traits_type::eq_int_type(ch, traits_type::eof()))
-      buffer_.push_back(static_cast<Char>(ch));
-    return ch;
-  }
-
-  std::streamsize xsputn(const Char *s, std::streamsize count) FMT_OVERRIDE {
-    buffer_.append(s, s + count);
-    return count;
-  }
-};
-
-Yes &convert(std::ostream &);
-
-struct DummyStream : std::ostream {
-  DummyStream();  // Suppress a bogus warning in MSVC.
-
-  // Hide all operator<< overloads from std::ostream.
-  template <typename T>
-  typename EnableIf<sizeof(T) == 0>::type operator<<(const T &);
-};
-
-No &operator<<(std::ostream &, int);
-
-template <typename T>
-struct ConvertToIntImpl<T, true> {
-  // Convert to int only if T doesn't have an overloaded operator<<.
-  enum {
-    value = sizeof(convert(get<DummyStream>() << get<T>())) == sizeof(No)
-  };
-};
-
-// Write the content of w to os.
-FMT_API void write(std::ostream &os, Writer &w);
-}  // namespace internal
-
-// Formats a value.
-template <typename Char, typename ArgFormatter_, typename T>
-void format_arg(BasicFormatter<Char, ArgFormatter_> &f,
-                const Char *&format_str, const T &value) {
-  internal::MemoryBuffer<Char, internal::INLINE_BUFFER_SIZE> buffer;
-
-  internal::FormatBuf<Char> format_buf(buffer);
-  std::basic_ostream<Char> output(&format_buf);
-  output.exceptions(std::ios_base::failbit | std::ios_base::badbit);
-  output << value;
-
-  BasicStringRef<Char> str(&buffer[0], buffer.size());
-  typedef internal::MakeArg< BasicFormatter<Char> > MakeArg;
-  format_str = f.format(format_str, MakeArg(str));
-}
-
-/**
-  \rst
-  Prints formatted data to the stream *os*.
-
-  **Example**::
-
-    print(cerr, "Don't {}!", "panic");
-  \endrst
- */
-FMT_API void print(std::ostream &os, CStringRef format_str, ArgList args);
-FMT_VARIADIC(void, print, std::ostream &, CStringRef)
-}  // namespace fmt
-
-#ifdef FMT_HEADER_ONLY
-# include "ostream.cc"
-#endif
-
-#endif  // FMT_OSTREAM_H_
+// Formatting library for C++ - std::ostream support
+//
+// Copyright (c) 2012 - present, Victor Zverovich
+// All rights reserved.
+//
+// For the license information refer to format.h.
+
+#ifndef FMT_OSTREAM_H_
+#define FMT_OSTREAM_H_
+
+#include <fstream>  // std::filebuf
+
+#if defined(_WIN32) && defined(__GLIBCXX__)
+#  include <ext/stdio_filebuf.h>
+#  include <ext/stdio_sync_filebuf.h>
+#elif defined(_WIN32) && defined(_LIBCPP_VERSION)
+#  include <__std_stream>
+#endif
+
+#include "format.h"
+
+FMT_BEGIN_NAMESPACE
+
+namespace detail {
+
+// Generate a unique explicit instantion in every translation unit using a tag
+// type in an anonymous namespace.
+namespace {
+struct file_access_tag {};
+}  // namespace
+template <typename Tag, typename BufType, FILE* BufType::*FileMemberPtr>
+class file_access {
+  friend auto get_file(BufType& obj) -> FILE* { return obj.*FileMemberPtr; }
+};
+
+#if FMT_MSC_VERSION
+template class file_access<file_access_tag, std::filebuf,
+                           &std::filebuf::_Myfile>;
+auto get_file(std::filebuf&) -> FILE*;
+#elif defined(_WIN32) && defined(_LIBCPP_VERSION)
+template class file_access<file_access_tag, std::__stdoutbuf<char>,
+                           &std::__stdoutbuf<char>::__file_>;
+auto get_file(std::__stdoutbuf<char>&) -> FILE*;
+#endif
+
+inline bool write_ostream_unicode(std::ostream& os, fmt::string_view data) {
+#if FMT_MSC_VERSION
+  if (auto* buf = dynamic_cast<std::filebuf*>(os.rdbuf()))
+    if (FILE* f = get_file(*buf)) return write_console(f, data);
+#elif defined(_WIN32) && defined(__GLIBCXX__)
+  auto* rdbuf = os.rdbuf();
+  FILE* c_file;
+  if (auto* sfbuf = dynamic_cast<__gnu_cxx::stdio_sync_filebuf<char>*>(rdbuf))
+    c_file = sfbuf->file();
+  else if (auto* fbuf = dynamic_cast<__gnu_cxx::stdio_filebuf<char>*>(rdbuf))
+    c_file = fbuf->file();
+  else
+    return false;
+  if (c_file) return write_console(c_file, data);
+#elif defined(_WIN32) && defined(_LIBCPP_VERSION)
+  if (auto* buf = dynamic_cast<std::__stdoutbuf<char>*>(os.rdbuf()))
+    if (FILE* f = get_file(*buf)) return write_console(f, data);
+#else
+  ignore_unused(os, data);
+#endif
+  return false;
+}
+inline bool write_ostream_unicode(std::wostream&,
+                                  fmt::basic_string_view<wchar_t>) {
+  return false;
+}
+
+// Write the content of buf to os.
+// It is a separate function rather than a part of vprint to simplify testing.
+template <typename Char>
+void write_buffer(std::basic_ostream<Char>& os, buffer<Char>& buf) {
+  const Char* buf_data = buf.data();
+  using unsigned_streamsize = std::make_unsigned<std::streamsize>::type;
+  unsigned_streamsize size = buf.size();
+  unsigned_streamsize max_size = to_unsigned(max_value<std::streamsize>());
+  do {
+    unsigned_streamsize n = size <= max_size ? size : max_size;
+    os.write(buf_data, static_cast<std::streamsize>(n));
+    buf_data += n;
+    size -= n;
+  } while (size != 0);
+}
+
+template <typename Char, typename T>
+void format_value(buffer<Char>& buf, const T& value,
+                  locale_ref loc = locale_ref()) {
+  auto&& format_buf = formatbuf<std::basic_streambuf<Char>>(buf);
+  auto&& output = std::basic_ostream<Char>(&format_buf);
+#if !defined(FMT_STATIC_THOUSANDS_SEPARATOR)
+  if (loc) output.imbue(loc.get<std::locale>());
+#endif
+  output << value;
+  output.exceptions(std::ios_base::failbit | std::ios_base::badbit);
+}
+
+template <typename T> struct streamed_view { const T& value; };
+
+}  // namespace detail
+
+// Formats an object of type T that has an overloaded ostream operator<<.
+template <typename Char>
+struct basic_ostream_formatter : formatter<basic_string_view<Char>, Char> {
+  void set_debug_format() = delete;
+
+  template <typename T, typename OutputIt>
+  auto format(const T& value, basic_format_context<OutputIt, Char>& ctx) const
+      -> OutputIt {
+    auto buffer = basic_memory_buffer<Char>();
+    detail::format_value(buffer, value, ctx.locale());
+    return formatter<basic_string_view<Char>, Char>::format(
+        {buffer.data(), buffer.size()}, ctx);
+  }
+};
+
+using ostream_formatter = basic_ostream_formatter<char>;
+
+template <typename T, typename Char>
+struct formatter<detail::streamed_view<T>, Char>
+    : basic_ostream_formatter<Char> {
+  template <typename OutputIt>
+  auto format(detail::streamed_view<T> view,
+              basic_format_context<OutputIt, Char>& ctx) const -> OutputIt {
+    return basic_ostream_formatter<Char>::format(view.value, ctx);
+  }
+};
+
+/**
+  \rst
+  Returns a view that formats `value` via an ostream ``operator<<``.
+
+  **Example**::
+
+    fmt::print("Current thread id: {}\n",
+               fmt::streamed(std::this_thread::get_id()));
+  \endrst
+ */
+template <typename T>
+auto streamed(const T& value) -> detail::streamed_view<T> {
+  return {value};
+}
+
+namespace detail {
+
+inline void vprint_directly(std::ostream& os, string_view format_str,
+                            format_args args) {
+  auto buffer = memory_buffer();
+  detail::vformat_to(buffer, format_str, args);
+  detail::write_buffer(os, buffer);
+}
+
+}  // namespace detail
+
+FMT_MODULE_EXPORT template <typename Char>
+void vprint(std::basic_ostream<Char>& os,
+            basic_string_view<type_identity_t<Char>> format_str,
+            basic_format_args<buffer_context<type_identity_t<Char>>> args) {
+  auto buffer = basic_memory_buffer<Char>();
+  detail::vformat_to(buffer, format_str, args);
+  if (detail::write_ostream_unicode(os, {buffer.data(), buffer.size()})) return;
+  detail::write_buffer(os, buffer);
+}
+
+/**
+  \rst
+  Prints formatted data to the stream *os*.
+
+  **Example**::
+
+    fmt::print(cerr, "Don't {}!", "panic");
+  \endrst
+ */
+FMT_MODULE_EXPORT template <typename... T>
+void print(std::ostream& os, format_string<T...> fmt, T&&... args) {
+  const auto& vargs = fmt::make_format_args(args...);
+  if (detail::is_utf8())
+    vprint(os, fmt, vargs);
+  else
+    detail::vprint_directly(os, fmt, vargs);
+}
+
+FMT_MODULE_EXPORT
+template <typename... Args>
+void print(std::wostream& os,
+           basic_format_string<wchar_t, type_identity_t<Args>...> fmt,
+           Args&&... args) {
+  vprint(os, fmt, fmt::make_format_args<buffer_context<wchar_t>>(args...));
+}
+
+FMT_MODULE_EXPORT template <typename... T>
+void println(std::ostream& os, format_string<T...> fmt, T&&... args) {
+  fmt::print(os, "{}\n", fmt::format(fmt, std::forward<T>(args)...));
+}
+
+FMT_MODULE_EXPORT
+template <typename... Args>
+void println(std::wostream& os,
+             basic_format_string<wchar_t, type_identity_t<Args>...> fmt,
+             Args&&... args) {
+  print(os, L"{}\n", fmt::format(fmt, std::forward<Args>(args)...));
+}
+
+FMT_END_NAMESPACE
+
+#endif  // FMT_OSTREAM_H_
```

## CoolProp/include/fmt/printf.h

```diff
@@ -1,603 +1,679 @@
-/*
- Formatting library for C++
-
- Copyright (c) 2012 - 2016, Victor Zverovich
- All rights reserved.
-
- For the license information refer to format.h.
- */
-
-#ifndef FMT_PRINTF_H_
-#define FMT_PRINTF_H_
-
-#include <algorithm>  // std::fill_n
-#include <limits>     // std::numeric_limits
-
-#include "ostream.h"
-
-namespace fmt {
-namespace internal {
-
-// Checks if a value fits in int - used to avoid warnings about comparing
-// signed and unsigned integers.
-template <bool IsSigned>
-struct IntChecker {
-  template <typename T>
-  static bool fits_in_int(T value) {
-    unsigned max = std::numeric_limits<int>::max();
-    return value <= max;
-  }
-  static bool fits_in_int(bool) { return true; }
-};
-
-template <>
-struct IntChecker<true> {
-  template <typename T>
-  static bool fits_in_int(T value) {
-    return value >= std::numeric_limits<int>::min() &&
-           value <= std::numeric_limits<int>::max();
-  }
-  static bool fits_in_int(int) { return true; }
-};
-
-class PrecisionHandler : public ArgVisitor<PrecisionHandler, int> {
- public:
-  void report_unhandled_arg() {
-    FMT_THROW(FormatError("precision is not integer"));
-  }
-
-  template <typename T>
-  int visit_any_int(T value) {
-    if (!IntChecker<std::numeric_limits<T>::is_signed>::fits_in_int(value))
-      FMT_THROW(FormatError("number is too big"));
-    return static_cast<int>(value);
-  }
-};
-
-// IsZeroInt::visit(arg) returns true iff arg is a zero integer.
-class IsZeroInt : public ArgVisitor<IsZeroInt, bool> {
- public:
-  template <typename T>
-  bool visit_any_int(T value) { return value == 0; }
-};
-
-// returns the default type for format specific "%s"
-class DefaultType : public ArgVisitor<DefaultType, char> {
- public:
-  char visit_char(int) { return 'c'; }
-
-  char visit_bool(bool) { return 's'; }
-
-  char visit_pointer(const void *) { return 'p'; }
-
-  template <typename T>
-  char visit_any_int(T) { return 'd'; }
-
-  template <typename T>
-  char visit_any_double(T) { return 'g'; }
-
-  char visit_unhandled_arg() { return 's'; }
-};
-
-template <typename T, typename U>
-struct is_same {
-  enum { value = 0 };
-};
-
-template <typename T>
-struct is_same<T, T> {
-  enum { value = 1 };
-};
-
-// An argument visitor that converts an integer argument to T for printf,
-// if T is an integral type. If T is void, the argument is converted to
-// corresponding signed or unsigned type depending on the type specifier:
-// 'd' and 'i' - signed, other - unsigned)
-template <typename T = void>
-class ArgConverter : public ArgVisitor<ArgConverter<T>, void> {
- private:
-  internal::Arg &arg_;
-  wchar_t type_;
-
-  FMT_DISALLOW_COPY_AND_ASSIGN(ArgConverter);
-
- public:
-  ArgConverter(internal::Arg &arg, wchar_t type)
-    : arg_(arg), type_(type) {}
-
-  void visit_bool(bool value) {
-    if (type_ != 's')
-      visit_any_int(value);
-  }
-
-  void visit_char(int value) {
-    if (type_ != 's')
-      visit_any_int(value);
-  }
-
-  template <typename U>
-  void visit_any_int(U value) {
-    bool is_signed = type_ == 'd' || type_ == 'i';
-    if (type_ == 's') {
-      is_signed = std::numeric_limits<U>::is_signed;
-    }
-
-    using internal::Arg;
-    typedef typename internal::Conditional<
-        is_same<T, void>::value, U, T>::type TargetType;
-    if (const_check(sizeof(TargetType) <= sizeof(int))) {
-      // Extra casts are used to silence warnings.
-      if (is_signed) {
-        arg_.type = Arg::INT;
-        arg_.int_value = static_cast<int>(static_cast<TargetType>(value));
-      } else {
-        arg_.type = Arg::UINT;
-        typedef typename internal::MakeUnsigned<TargetType>::Type Unsigned;
-        arg_.uint_value = static_cast<unsigned>(static_cast<Unsigned>(value));
-      }
-    } else {
-      if (is_signed) {
-        arg_.type = Arg::LONG_LONG;
-        // glibc's printf doesn't sign extend arguments of smaller types:
-        //   std::printf("%lld", -42);  // prints "4294967254"
-        // but we don't have to do the same because it's a UB.
-        arg_.long_long_value = static_cast<LongLong>(value);
-      } else {
-        arg_.type = Arg::ULONG_LONG;
-        arg_.ulong_long_value =
-            static_cast<typename internal::MakeUnsigned<U>::Type>(value);
-      }
-    }
-  }
-};
-
-// Converts an integer argument to char for printf.
-class CharConverter : public ArgVisitor<CharConverter, void> {
- private:
-  internal::Arg &arg_;
-
-  FMT_DISALLOW_COPY_AND_ASSIGN(CharConverter);
-
- public:
-  explicit CharConverter(internal::Arg &arg) : arg_(arg) {}
-
-  template <typename T>
-  void visit_any_int(T value) {
-    arg_.type = internal::Arg::CHAR;
-    arg_.int_value = static_cast<char>(value);
-  }
-};
-
-// Checks if an argument is a valid printf width specifier and sets
-// left alignment if it is negative.
-class WidthHandler : public ArgVisitor<WidthHandler, unsigned> {
- private:
-  FormatSpec &spec_;
-
-  FMT_DISALLOW_COPY_AND_ASSIGN(WidthHandler);
-
- public:
-  explicit WidthHandler(FormatSpec &spec) : spec_(spec) {}
-
-  void report_unhandled_arg() {
-    FMT_THROW(FormatError("width is not integer"));
-  }
-
-  template <typename T>
-  unsigned visit_any_int(T value) {
-    typedef typename internal::IntTraits<T>::MainType UnsignedType;
-    UnsignedType width = static_cast<UnsignedType>(value);
-    if (internal::is_negative(value)) {
-      spec_.align_ = ALIGN_LEFT;
-      width = 0 - width;
-    }
-    unsigned int_max = std::numeric_limits<int>::max();
-    if (width > int_max)
-      FMT_THROW(FormatError("number is too big"));
-    return static_cast<unsigned>(width);
-  }
-};
-}  // namespace internal
-
-/**
-  \rst
-  A ``printf`` argument formatter based on the `curiously recurring template
-  pattern <http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern>`_.
-
-  To use `~fmt::BasicPrintfArgFormatter` define a subclass that implements some
-  or all of the visit methods with the same signatures as the methods in
-  `~fmt::ArgVisitor`, for example, `~fmt::ArgVisitor::visit_int()`.
-  Pass the subclass as the *Impl* template parameter. When a formatting
-  function processes an argument, it will dispatch to a visit method
-  specific to the argument type. For example, if the argument type is
-  ``double`` then the `~fmt::ArgVisitor::visit_double()` method of a subclass
-  will be called. If the subclass doesn't contain a method with this signature,
-  then a corresponding method of `~fmt::BasicPrintfArgFormatter` or its
-  superclass will be called.
-  \endrst
- */
-template <typename Impl, typename Char, typename Spec>
-class BasicPrintfArgFormatter :
-    public internal::ArgFormatterBase<Impl, Char, Spec> {
- private:
-  void write_null_pointer() {
-    this->spec().type_ = 0;
-    this->write("(nil)");
-  }
-
-  typedef internal::ArgFormatterBase<Impl, Char, Spec> Base;
-
- public:
-  /**
-    \rst
-    Constructs an argument formatter object.
-    *writer* is a reference to the output writer and *spec* contains format
-    specifier information for standard argument types.
-    \endrst
-   */
-  BasicPrintfArgFormatter(BasicWriter<Char> &w, Spec &s)
-  : internal::ArgFormatterBase<Impl, Char, Spec>(w, s) {}
-
-  /** Formats an argument of type ``bool``. */
-  void visit_bool(bool value) {
-    Spec &fmt_spec = this->spec();
-    if (fmt_spec.type_ != 's')
-      return this->visit_any_int(value);
-    fmt_spec.type_ = 0;
-    this->write(value);
-  }
-
-  /** Formats a character. */
-  void visit_char(int value) {
-    const Spec &fmt_spec = this->spec();
-    BasicWriter<Char> &w = this->writer();
-    if (fmt_spec.type_ && fmt_spec.type_ != 'c')
-      w.write_int(value, fmt_spec);
-    typedef typename BasicWriter<Char>::CharPtr CharPtr;
-    CharPtr out = CharPtr();
-    if (fmt_spec.width_ > 1) {
-      Char fill = ' ';
-      out = w.grow_buffer(fmt_spec.width_);
-      if (fmt_spec.align_ != ALIGN_LEFT) {
-        std::fill_n(out, fmt_spec.width_ - 1, fill);
-        out += fmt_spec.width_ - 1;
-      } else {
-        std::fill_n(out + 1, fmt_spec.width_ - 1, fill);
-      }
-    } else {
-      out = w.grow_buffer(1);
-    }
-    *out = static_cast<Char>(value);
-  }
-
-  /** Formats a null-terminated C string. */
-  void visit_cstring(const char *value) {
-    if (value)
-      Base::visit_cstring(value);
-    else if (this->spec().type_ == 'p')
-      write_null_pointer();
-    else
-      this->write("(null)");
-  }
-
-  /** Formats a pointer. */
-  void visit_pointer(const void *value) {
-    if (value)
-      return Base::visit_pointer(value);
-    this->spec().type_ = 0;
-    write_null_pointer();
-  }
-
-  /** Formats an argument of a custom (user-defined) type. */
-  void visit_custom(internal::Arg::CustomValue c) {
-    BasicFormatter<Char> formatter(ArgList(), this->writer());
-    const Char format_str[] = {'}', 0};
-    const Char *format = format_str;
-    c.format(&formatter, c.value, &format);
-  }
-};
-
-/** The default printf argument formatter. */
-template <typename Char>
-class PrintfArgFormatter :
-    public BasicPrintfArgFormatter<PrintfArgFormatter<Char>, Char, FormatSpec> {
- public:
-  /** Constructs an argument formatter object. */
-  PrintfArgFormatter(BasicWriter<Char> &w, FormatSpec &s)
-  : BasicPrintfArgFormatter<PrintfArgFormatter<Char>, Char, FormatSpec>(w, s) {}
-};
-
-/** This template formats data and writes the output to a writer. */
-template <typename Char, typename ArgFormatter = PrintfArgFormatter<Char> >
-class PrintfFormatter : private internal::FormatterBase {
- private:
-  BasicWriter<Char> &writer_;
-
-  void parse_flags(FormatSpec &spec, const Char *&s);
-
-  // Returns the argument with specified index or, if arg_index is equal
-  // to the maximum unsigned value, the next argument.
-  internal::Arg get_arg(
-      const Char *s,
-      unsigned arg_index = (std::numeric_limits<unsigned>::max)());
-
-  // Parses argument index, flags and width and returns the argument index.
-  unsigned parse_header(const Char *&s, FormatSpec &spec);
-
- public:
-  /**
-   \rst
-   Constructs a ``PrintfFormatter`` object. References to the arguments and
-   the writer are stored in the formatter object so make sure they have
-   appropriate lifetimes.
-   \endrst
-   */
-  explicit PrintfFormatter(const ArgList &al, BasicWriter<Char> &w)
-    : FormatterBase(al), writer_(w) {}
-
-  /** Formats stored arguments and writes the output to the writer. */
-  void format(BasicCStringRef<Char> format_str);
-};
-
-template <typename Char, typename AF>
-void PrintfFormatter<Char, AF>::parse_flags(FormatSpec &spec, const Char *&s) {
-  for (;;) {
-    switch (*s++) {
-      case '-':
-        spec.align_ = ALIGN_LEFT;
-        break;
-      case '+':
-        spec.flags_ |= SIGN_FLAG | PLUS_FLAG;
-        break;
-      case '0':
-        spec.fill_ = '0';
-        break;
-      case ' ':
-        spec.flags_ |= SIGN_FLAG;
-        break;
-      case '#':
-        spec.flags_ |= HASH_FLAG;
-        break;
-      default:
-        --s;
-        return;
-    }
-  }
-}
-
-template <typename Char, typename AF>
-internal::Arg PrintfFormatter<Char, AF>::get_arg(const Char *s,
-                                                 unsigned arg_index) {
-  (void)s;
-  const char *error = FMT_NULL;
-  internal::Arg arg = arg_index == std::numeric_limits<unsigned>::max() ?
-    next_arg(error) : FormatterBase::get_arg(arg_index - 1, error);
-  if (error)
-    FMT_THROW(FormatError(!*s ? "invalid format string" : error));
-  return arg;
-}
-
-template <typename Char, typename AF>
-unsigned PrintfFormatter<Char, AF>::parse_header(
-  const Char *&s, FormatSpec &spec) {
-  unsigned arg_index = std::numeric_limits<unsigned>::max();
-  Char c = *s;
-  if (c >= '0' && c <= '9') {
-    // Parse an argument index (if followed by '$') or a width possibly
-    // preceded with '0' flag(s).
-    unsigned value = internal::parse_nonnegative_int(s);
-    if (*s == '$') {  // value is an argument index
-      ++s;
-      arg_index = value;
-    } else {
-      if (c == '0')
-        spec.fill_ = '0';
-      if (value != 0) {
-        // Nonzero value means that we parsed width and don't need to
-        // parse it or flags again, so return now.
-        spec.width_ = value;
-        return arg_index;
-      }
-    }
-  }
-  parse_flags(spec, s);
-  // Parse width.
-  if (*s >= '0' && *s <= '9') {
-    spec.width_ = internal::parse_nonnegative_int(s);
-  } else if (*s == '*') {
-    ++s;
-    spec.width_ = internal::WidthHandler(spec).visit(get_arg(s));
-  }
-  return arg_index;
-}
-
-template <typename Char, typename AF>
-void PrintfFormatter<Char, AF>::format(BasicCStringRef<Char> format_str) {
-  const Char *start = format_str.c_str();
-  const Char *s = start;
-  while (*s) {
-    Char c = *s++;
-    if (c != '%') continue;
-    if (*s == c) {
-      write(writer_, start, s);
-      start = ++s;
-      continue;
-    }
-    write(writer_, start, s - 1);
-
-    FormatSpec spec;
-    spec.align_ = ALIGN_RIGHT;
-
-    // Parse argument index, flags and width.
-    unsigned arg_index = parse_header(s, spec);
-
-    // Parse precision.
-    if (*s == '.') {
-      ++s;
-      if ('0' <= *s && *s <= '9') {
-        spec.precision_ = static_cast<int>(internal::parse_nonnegative_int(s));
-      } else if (*s == '*') {
-        ++s;
-        spec.precision_ = internal::PrecisionHandler().visit(get_arg(s));
-      } else {
-        spec.precision_ = 0;
-      }
-    }
-
-    using internal::Arg;
-    Arg arg = get_arg(s, arg_index);
-    if (spec.flag(HASH_FLAG) && internal::IsZeroInt().visit(arg))
-      spec.flags_ &= ~internal::to_unsigned<int>(HASH_FLAG);
-    if (spec.fill_ == '0') {
-      if (arg.type <= Arg::LAST_NUMERIC_TYPE)
-        spec.align_ = ALIGN_NUMERIC;
-      else
-        spec.fill_ = ' ';  // Ignore '0' flag for non-numeric types.
-    }
-
-    // Parse length and convert the argument to the required type.
-    using internal::ArgConverter;
-    switch (*s++) {
-    case 'h':
-      if (*s == 'h')
-        ArgConverter<signed char>(arg, *++s).visit(arg);
-      else
-        ArgConverter<short>(arg, *s).visit(arg);
-      break;
-    case 'l':
-      if (*s == 'l')
-        ArgConverter<fmt::LongLong>(arg, *++s).visit(arg);
-      else
-        ArgConverter<long>(arg, *s).visit(arg);
-      break;
-    case 'j':
-      ArgConverter<intmax_t>(arg, *s).visit(arg);
-      break;
-    case 'z':
-      ArgConverter<std::size_t>(arg, *s).visit(arg);
-      break;
-    case 't':
-      ArgConverter<std::ptrdiff_t>(arg, *s).visit(arg);
-      break;
-    case 'L':
-      // printf produces garbage when 'L' is omitted for long double, no
-      // need to do the same.
-      break;
-    default:
-      --s;
-      ArgConverter<void>(arg, *s).visit(arg);
-    }
-
-    // Parse type.
-    if (!*s)
-      FMT_THROW(FormatError("invalid format string"));
-    spec.type_ = static_cast<char>(*s++);
-
-    if (spec.type_ == 's') {
-      // set the format type to the default if 's' is specified
-      spec.type_ = internal::DefaultType().visit(arg);
-    }
-
-    if (arg.type <= Arg::LAST_INTEGER_TYPE) {
-      // Normalize type.
-      switch (spec.type_) {
-      case 'i': case 'u':
-        spec.type_ = 'd';
-        break;
-      case 'c':
-        // TODO: handle wchar_t
-        internal::CharConverter(arg).visit(arg);
-        break;
-      }
-    }
-
-    start = s;
-
-    // Format argument.
-    AF(writer_, spec).visit(arg);
-  }
-  write(writer_, start, s);
-}
-
-inline void printf(Writer &w, CStringRef format, ArgList args) {
-  PrintfFormatter<char>(args, w).format(format);
-}
-FMT_VARIADIC(void, printf, Writer &, CStringRef)
-
-inline void printf(WWriter &w, WCStringRef format, ArgList args) {
-  PrintfFormatter<wchar_t>(args, w).format(format);
-}
-FMT_VARIADIC(void, printf, WWriter &, WCStringRef)
-
-/**
-  \rst
-  Formats arguments and returns the result as a string.
-
-  **Example**::
-
-    std::string message = fmt::sprintf("The answer is %d", 42);
-  \endrst
-*/
-inline std::string sprintf(CStringRef format, ArgList args) {
-  MemoryWriter w;
-  printf(w, format, args);
-  return w.str();
-}
-FMT_VARIADIC(std::string, sprintf, CStringRef)
-
-inline std::wstring sprintf(WCStringRef format, ArgList args) {
-  WMemoryWriter w;
-  printf(w, format, args);
-  return w.str();
-}
-FMT_VARIADIC_W(std::wstring, sprintf, WCStringRef)
-
-/**
-  \rst
-  Prints formatted data to the file *f*.
-
-  **Example**::
-
-    fmt::fprintf(stderr, "Don't %s!", "panic");
-  \endrst
- */
-FMT_API int fprintf(std::FILE *f, CStringRef format, ArgList args);
-FMT_VARIADIC(int, fprintf, std::FILE *, CStringRef)
-
-/**
-  \rst
-  Prints formatted data to ``stdout``.
-
-  **Example**::
-
-    fmt::printf("Elapsed time: %.2f seconds", 1.23);
-  \endrst
- */
-inline int printf(CStringRef format, ArgList args) {
-  return fprintf(stdout, format, args);
-}
-FMT_VARIADIC(int, printf, CStringRef)
-
-/**
-  \rst
-  Prints formatted data to the stream *os*.
-
-  **Example**::
-
-    fprintf(cerr, "Don't %s!", "panic");
-  \endrst
- */
-inline int fprintf(std::ostream &os, CStringRef format_str, ArgList args) {
-  MemoryWriter w;
-  printf(w, format_str, args);
-  internal::write(os, w);
-  return static_cast<int>(w.size());
-}
-FMT_VARIADIC(int, fprintf, std::ostream &, CStringRef)
-}  // namespace fmt
-
-#ifdef FMT_HEADER_ONLY
-# include "printf.cc"
-#endif
-
-#endif  // FMT_PRINTF_H_
+// Formatting library for C++ - legacy printf implementation
+//
+// Copyright (c) 2012 - 2016, Victor Zverovich
+// All rights reserved.
+//
+// For the license information refer to format.h.
+
+#ifndef FMT_PRINTF_H_
+#define FMT_PRINTF_H_
+
+#include <algorithm>  // std::max
+#include <limits>     // std::numeric_limits
+
+#include "format.h"
+
+FMT_BEGIN_NAMESPACE
+FMT_BEGIN_EXPORT
+
+template <typename T> struct printf_formatter { printf_formatter() = delete; };
+
+template <typename Char>
+class basic_printf_parse_context : public basic_format_parse_context<Char> {
+  using basic_format_parse_context<Char>::basic_format_parse_context;
+};
+
+template <typename OutputIt, typename Char> class basic_printf_context {
+ private:
+  OutputIt out_;
+  basic_format_args<basic_printf_context> args_;
+
+ public:
+  using char_type = Char;
+  using format_arg = basic_format_arg<basic_printf_context>;
+  using parse_context_type = basic_printf_parse_context<Char>;
+  template <typename T> using formatter_type = printf_formatter<T>;
+
+  /**
+    \rst
+    Constructs a ``printf_context`` object. References to the arguments are
+    stored in the context object so make sure they have appropriate lifetimes.
+    \endrst
+   */
+  basic_printf_context(OutputIt out,
+                       basic_format_args<basic_printf_context> args)
+      : out_(out), args_(args) {}
+
+  OutputIt out() { return out_; }
+  void advance_to(OutputIt it) { out_ = it; }
+
+  detail::locale_ref locale() { return {}; }
+
+  format_arg arg(int id) const { return args_.get(id); }
+
+  FMT_CONSTEXPR void on_error(const char* message) {
+    detail::error_handler().on_error(message);
+  }
+};
+
+FMT_BEGIN_DETAIL_NAMESPACE
+
+// Checks if a value fits in int - used to avoid warnings about comparing
+// signed and unsigned integers.
+template <bool IsSigned> struct int_checker {
+  template <typename T> static bool fits_in_int(T value) {
+    unsigned max = max_value<int>();
+    return value <= max;
+  }
+  static bool fits_in_int(bool) { return true; }
+};
+
+template <> struct int_checker<true> {
+  template <typename T> static bool fits_in_int(T value) {
+    return value >= (std::numeric_limits<int>::min)() &&
+           value <= max_value<int>();
+  }
+  static bool fits_in_int(int) { return true; }
+};
+
+class printf_precision_handler {
+ public:
+  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
+  int operator()(T value) {
+    if (!int_checker<std::numeric_limits<T>::is_signed>::fits_in_int(value))
+      throw_format_error("number is too big");
+    return (std::max)(static_cast<int>(value), 0);
+  }
+
+  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
+  int operator()(T) {
+    throw_format_error("precision is not integer");
+    return 0;
+  }
+};
+
+// An argument visitor that returns true iff arg is a zero integer.
+class is_zero_int {
+ public:
+  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
+  bool operator()(T value) {
+    return value == 0;
+  }
+
+  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
+  bool operator()(T) {
+    return false;
+  }
+};
+
+template <typename T> struct make_unsigned_or_bool : std::make_unsigned<T> {};
+
+template <> struct make_unsigned_or_bool<bool> { using type = bool; };
+
+template <typename T, typename Context> class arg_converter {
+ private:
+  using char_type = typename Context::char_type;
+
+  basic_format_arg<Context>& arg_;
+  char_type type_;
+
+ public:
+  arg_converter(basic_format_arg<Context>& arg, char_type type)
+      : arg_(arg), type_(type) {}
+
+  void operator()(bool value) {
+    if (type_ != 's') operator()<bool>(value);
+  }
+
+  template <typename U, FMT_ENABLE_IF(std::is_integral<U>::value)>
+  void operator()(U value) {
+    bool is_signed = type_ == 'd' || type_ == 'i';
+    using target_type = conditional_t<std::is_same<T, void>::value, U, T>;
+    if (const_check(sizeof(target_type) <= sizeof(int))) {
+      // Extra casts are used to silence warnings.
+      if (is_signed) {
+        arg_ = detail::make_arg<Context>(
+            static_cast<int>(static_cast<target_type>(value)));
+      } else {
+        using unsigned_type = typename make_unsigned_or_bool<target_type>::type;
+        arg_ = detail::make_arg<Context>(
+            static_cast<unsigned>(static_cast<unsigned_type>(value)));
+      }
+    } else {
+      if (is_signed) {
+        // glibc's printf doesn't sign extend arguments of smaller types:
+        //   std::printf("%lld", -42);  // prints "4294967254"
+        // but we don't have to do the same because it's a UB.
+        arg_ = detail::make_arg<Context>(static_cast<long long>(value));
+      } else {
+        arg_ = detail::make_arg<Context>(
+            static_cast<typename make_unsigned_or_bool<U>::type>(value));
+      }
+    }
+  }
+
+  template <typename U, FMT_ENABLE_IF(!std::is_integral<U>::value)>
+  void operator()(U) {}  // No conversion needed for non-integral types.
+};
+
+// Converts an integer argument to T for printf, if T is an integral type.
+// If T is void, the argument is converted to corresponding signed or unsigned
+// type depending on the type specifier: 'd' and 'i' - signed, other -
+// unsigned).
+template <typename T, typename Context, typename Char>
+void convert_arg(basic_format_arg<Context>& arg, Char type) {
+  visit_format_arg(arg_converter<T, Context>(arg, type), arg);
+}
+
+// Converts an integer argument to char for printf.
+template <typename Context> class char_converter {
+ private:
+  basic_format_arg<Context>& arg_;
+
+ public:
+  explicit char_converter(basic_format_arg<Context>& arg) : arg_(arg) {}
+
+  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
+  void operator()(T value) {
+    arg_ = detail::make_arg<Context>(
+        static_cast<typename Context::char_type>(value));
+  }
+
+  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
+  void operator()(T) {}  // No conversion needed for non-integral types.
+};
+
+// An argument visitor that return a pointer to a C string if argument is a
+// string or null otherwise.
+template <typename Char> struct get_cstring {
+  template <typename T> const Char* operator()(T) { return nullptr; }
+  const Char* operator()(const Char* s) { return s; }
+};
+
+// Checks if an argument is a valid printf width specifier and sets
+// left alignment if it is negative.
+template <typename Char> class printf_width_handler {
+ private:
+  format_specs<Char>& specs_;
+
+ public:
+  explicit printf_width_handler(format_specs<Char>& specs) : specs_(specs) {}
+
+  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
+  unsigned operator()(T value) {
+    auto width = static_cast<uint32_or_64_or_128_t<T>>(value);
+    if (detail::is_negative(value)) {
+      specs_.align = align::left;
+      width = 0 - width;
+    }
+    unsigned int_max = max_value<int>();
+    if (width > int_max) throw_format_error("number is too big");
+    return static_cast<unsigned>(width);
+  }
+
+  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
+  unsigned operator()(T) {
+    throw_format_error("width is not integer");
+    return 0;
+  }
+};
+
+// Workaround for a bug with the XL compiler when initializing
+// printf_arg_formatter's base class.
+template <typename Char>
+auto make_arg_formatter(buffer_appender<Char> iter, format_specs<Char>& s)
+    -> arg_formatter<Char> {
+  return {iter, s, locale_ref()};
+}
+
+// The ``printf`` argument formatter.
+template <typename OutputIt, typename Char>
+class printf_arg_formatter : public arg_formatter<Char> {
+ private:
+  using base = arg_formatter<Char>;
+  using context_type = basic_printf_context<OutputIt, Char>;
+
+  context_type& context_;
+
+  OutputIt write_null_pointer(bool is_string = false) {
+    auto s = this->specs;
+    s.type = presentation_type::none;
+    return write_bytes(this->out, is_string ? "(null)" : "(nil)", s);
+  }
+
+ public:
+  printf_arg_formatter(OutputIt iter, format_specs<Char>& s, context_type& ctx)
+      : base(make_arg_formatter(iter, s)), context_(ctx) {}
+
+  OutputIt operator()(monostate value) { return base::operator()(value); }
+
+  template <typename T, FMT_ENABLE_IF(detail::is_integral<T>::value)>
+  OutputIt operator()(T value) {
+    // MSVC2013 fails to compile separate overloads for bool and Char so use
+    // std::is_same instead.
+    if (std::is_same<T, Char>::value) {
+      format_specs<Char> fmt_specs = this->specs;
+      if (fmt_specs.type != presentation_type::none &&
+          fmt_specs.type != presentation_type::chr) {
+        return (*this)(static_cast<int>(value));
+      }
+      fmt_specs.sign = sign::none;
+      fmt_specs.alt = false;
+      fmt_specs.fill[0] = ' ';  // Ignore '0' flag for char types.
+      // align::numeric needs to be overwritten here since the '0' flag is
+      // ignored for non-numeric types
+      if (fmt_specs.align == align::none || fmt_specs.align == align::numeric)
+        fmt_specs.align = align::right;
+      return write<Char>(this->out, static_cast<Char>(value), fmt_specs);
+    }
+    return base::operator()(value);
+  }
+
+  template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
+  OutputIt operator()(T value) {
+    return base::operator()(value);
+  }
+
+  /** Formats a null-terminated C string. */
+  OutputIt operator()(const char* value) {
+    if (value) return base::operator()(value);
+    return write_null_pointer(this->specs.type != presentation_type::pointer);
+  }
+
+  /** Formats a null-terminated wide C string. */
+  OutputIt operator()(const wchar_t* value) {
+    if (value) return base::operator()(value);
+    return write_null_pointer(this->specs.type != presentation_type::pointer);
+  }
+
+  OutputIt operator()(basic_string_view<Char> value) {
+    return base::operator()(value);
+  }
+
+  /** Formats a pointer. */
+  OutputIt operator()(const void* value) {
+    return value ? base::operator()(value) : write_null_pointer();
+  }
+
+  /** Formats an argument of a custom (user-defined) type. */
+  OutputIt operator()(typename basic_format_arg<context_type>::handle handle) {
+    auto parse_ctx =
+        basic_printf_parse_context<Char>(basic_string_view<Char>());
+    handle.format(parse_ctx, context_);
+    return this->out;
+  }
+};
+
+template <typename Char>
+void parse_flags(format_specs<Char>& specs, const Char*& it, const Char* end) {
+  for (; it != end; ++it) {
+    switch (*it) {
+    case '-':
+      specs.align = align::left;
+      break;
+    case '+':
+      specs.sign = sign::plus;
+      break;
+    case '0':
+      specs.fill[0] = '0';
+      break;
+    case ' ':
+      if (specs.sign != sign::plus) {
+        specs.sign = sign::space;
+      }
+      break;
+    case '#':
+      specs.alt = true;
+      break;
+    default:
+      return;
+    }
+  }
+}
+
+template <typename Char, typename GetArg>
+int parse_header(const Char*& it, const Char* end, format_specs<Char>& specs,
+                 GetArg get_arg) {
+  int arg_index = -1;
+  Char c = *it;
+  if (c >= '0' && c <= '9') {
+    // Parse an argument index (if followed by '$') or a width possibly
+    // preceded with '0' flag(s).
+    int value = parse_nonnegative_int(it, end, -1);
+    if (it != end && *it == '$') {  // value is an argument index
+      ++it;
+      arg_index = value != -1 ? value : max_value<int>();
+    } else {
+      if (c == '0') specs.fill[0] = '0';
+      if (value != 0) {
+        // Nonzero value means that we parsed width and don't need to
+        // parse it or flags again, so return now.
+        if (value == -1) throw_format_error("number is too big");
+        specs.width = value;
+        return arg_index;
+      }
+    }
+  }
+  parse_flags(specs, it, end);
+  // Parse width.
+  if (it != end) {
+    if (*it >= '0' && *it <= '9') {
+      specs.width = parse_nonnegative_int(it, end, -1);
+      if (specs.width == -1) throw_format_error("number is too big");
+    } else if (*it == '*') {
+      ++it;
+      specs.width = static_cast<int>(visit_format_arg(
+          detail::printf_width_handler<Char>(specs), get_arg(-1)));
+    }
+  }
+  return arg_index;
+}
+
+inline auto parse_printf_presentation_type(char c, type t)
+    -> presentation_type {
+  using pt = presentation_type;
+  constexpr auto integral_set = sint_set | uint_set | bool_set | char_set;
+  switch (c) {
+  case 'd':
+    return in(t, integral_set) ? pt::dec : pt::none;
+  case 'o':
+    return in(t, integral_set) ? pt::oct : pt::none;
+  case 'x':
+    return in(t, integral_set) ? pt::hex_lower : pt::none;
+  case 'X':
+    return in(t, integral_set) ? pt::hex_upper : pt::none;
+  case 'a':
+    return in(t, float_set) ? pt::hexfloat_lower : pt::none;
+  case 'A':
+    return in(t, float_set) ? pt::hexfloat_upper : pt::none;
+  case 'e':
+    return in(t, float_set) ? pt::exp_lower : pt::none;
+  case 'E':
+    return in(t, float_set) ? pt::exp_upper : pt::none;
+  case 'f':
+    return in(t, float_set) ? pt::fixed_lower : pt::none;
+  case 'F':
+    return in(t, float_set) ? pt::fixed_upper : pt::none;
+  case 'g':
+    return in(t, float_set) ? pt::general_lower : pt::none;
+  case 'G':
+    return in(t, float_set) ? pt::general_upper : pt::none;
+  case 'c':
+    return in(t, integral_set) ? pt::chr : pt::none;
+  case 's':
+    return in(t, string_set | cstring_set) ? pt::string : pt::none;
+  case 'p':
+    return in(t, pointer_set | cstring_set) ? pt::pointer : pt::none;
+  default:
+    return pt::none;
+  }
+}
+
+template <typename Char, typename Context>
+void vprintf(buffer<Char>& buf, basic_string_view<Char> format,
+             basic_format_args<Context> args) {
+  using iterator = buffer_appender<Char>;
+  auto out = iterator(buf);
+  auto context = basic_printf_context<iterator, Char>(out, args);
+  auto parse_ctx = basic_printf_parse_context<Char>(format);
+
+  // Returns the argument with specified index or, if arg_index is -1, the next
+  // argument.
+  auto get_arg = [&](int arg_index) {
+    if (arg_index < 0)
+      arg_index = parse_ctx.next_arg_id();
+    else
+      parse_ctx.check_arg_id(--arg_index);
+    return detail::get_arg(context, arg_index);
+  };
+
+  const Char* start = parse_ctx.begin();
+  const Char* end = parse_ctx.end();
+  auto it = start;
+  while (it != end) {
+    if (!find<false, Char>(it, end, '%', it)) {
+      it = end;  // find leaves it == nullptr if it doesn't find '%'.
+      break;
+    }
+    Char c = *it++;
+    if (it != end && *it == c) {
+      out = write(out, basic_string_view<Char>(start, to_unsigned(it - start)));
+      start = ++it;
+      continue;
+    }
+    out =
+        write(out, basic_string_view<Char>(start, to_unsigned(it - 1 - start)));
+
+    auto specs = format_specs<Char>();
+    specs.align = align::right;
+
+    // Parse argument index, flags and width.
+    int arg_index = parse_header(it, end, specs, get_arg);
+    if (arg_index == 0) throw_format_error("argument not found");
+
+    // Parse precision.
+    if (it != end && *it == '.') {
+      ++it;
+      c = it != end ? *it : 0;
+      if ('0' <= c && c <= '9') {
+        specs.precision = parse_nonnegative_int(it, end, 0);
+      } else if (c == '*') {
+        ++it;
+        specs.precision = static_cast<int>(
+            visit_format_arg(printf_precision_handler(), get_arg(-1)));
+      } else {
+        specs.precision = 0;
+      }
+    }
+
+    auto arg = get_arg(arg_index);
+    // For d, i, o, u, x, and X conversion specifiers, if a precision is
+    // specified, the '0' flag is ignored
+    if (specs.precision >= 0 && arg.is_integral())
+      specs.fill[0] =
+          ' ';  // Ignore '0' flag for non-numeric types or if '-' present.
+    if (specs.precision >= 0 && arg.type() == type::cstring_type) {
+      auto str = visit_format_arg(get_cstring<Char>(), arg);
+      auto str_end = str + specs.precision;
+      auto nul = std::find(str, str_end, Char());
+      arg = make_arg<basic_printf_context<iterator, Char>>(
+          basic_string_view<Char>(
+              str, to_unsigned(nul != str_end ? nul - str : specs.precision)));
+    }
+    if (specs.alt && visit_format_arg(is_zero_int(), arg)) specs.alt = false;
+    if (specs.fill[0] == '0') {
+      if (arg.is_arithmetic() && specs.align != align::left)
+        specs.align = align::numeric;
+      else
+        specs.fill[0] = ' ';  // Ignore '0' flag for non-numeric types or if '-'
+                              // flag is also present.
+    }
+
+    // Parse length and convert the argument to the required type.
+    c = it != end ? *it++ : 0;
+    Char t = it != end ? *it : 0;
+    switch (c) {
+    case 'h':
+      if (t == 'h') {
+        ++it;
+        t = it != end ? *it : 0;
+        convert_arg<signed char>(arg, t);
+      } else {
+        convert_arg<short>(arg, t);
+      }
+      break;
+    case 'l':
+      if (t == 'l') {
+        ++it;
+        t = it != end ? *it : 0;
+        convert_arg<long long>(arg, t);
+      } else {
+        convert_arg<long>(arg, t);
+      }
+      break;
+    case 'j':
+      convert_arg<intmax_t>(arg, t);
+      break;
+    case 'z':
+      convert_arg<size_t>(arg, t);
+      break;
+    case 't':
+      convert_arg<std::ptrdiff_t>(arg, t);
+      break;
+    case 'L':
+      // printf produces garbage when 'L' is omitted for long double, no
+      // need to do the same.
+      break;
+    default:
+      --it;
+      convert_arg<void>(arg, c);
+    }
+
+    // Parse type.
+    if (it == end) throw_format_error("invalid format string");
+    char type = static_cast<char>(*it++);
+    if (arg.is_integral()) {
+      // Normalize type.
+      switch (type) {
+      case 'i':
+      case 'u':
+        type = 'd';
+        break;
+      case 'c':
+        visit_format_arg(
+            char_converter<basic_printf_context<iterator, Char>>(arg), arg);
+        break;
+      }
+    }
+    specs.type = parse_printf_presentation_type(type, arg.type());
+    if (specs.type == presentation_type::none)
+      throw_format_error("invalid format specifier");
+
+    start = it;
+
+    // Format argument.
+    out = visit_format_arg(
+        printf_arg_formatter<iterator, Char>(out, specs, context), arg);
+  }
+  write(out, basic_string_view<Char>(start, to_unsigned(it - start)));
+}
+FMT_END_DETAIL_NAMESPACE
+
+template <typename Char>
+using basic_printf_context_t =
+    basic_printf_context<detail::buffer_appender<Char>, Char>;
+
+using printf_context = basic_printf_context_t<char>;
+using wprintf_context = basic_printf_context_t<wchar_t>;
+
+using printf_args = basic_format_args<printf_context>;
+using wprintf_args = basic_format_args<wprintf_context>;
+
+/**
+  \rst
+  Constructs an `~fmt::format_arg_store` object that contains references to
+  arguments and can be implicitly converted to `~fmt::printf_args`.
+  \endrst
+ */
+template <typename... T>
+inline auto make_printf_args(const T&... args)
+    -> format_arg_store<printf_context, T...> {
+  return {args...};
+}
+
+/**
+  \rst
+  Constructs an `~fmt::format_arg_store` object that contains references to
+  arguments and can be implicitly converted to `~fmt::wprintf_args`.
+  \endrst
+ */
+template <typename... T>
+inline auto make_wprintf_args(const T&... args)
+    -> format_arg_store<wprintf_context, T...> {
+  return {args...};
+}
+
+template <typename S, typename Char = char_t<S>>
+inline auto vsprintf(
+    const S& fmt,
+    basic_format_args<basic_printf_context_t<type_identity_t<Char>>> args)
+    -> std::basic_string<Char> {
+  auto buf = basic_memory_buffer<Char>();
+  detail::vprintf(buf, detail::to_string_view(fmt), args);
+  return to_string(buf);
+}
+
+/**
+  \rst
+  Formats arguments and returns the result as a string.
+
+  **Example**::
+
+    std::string message = fmt::sprintf("The answer is %d", 42);
+  \endrst
+*/
+template <typename S, typename... T,
+          typename Char = enable_if_t<detail::is_string<S>::value, char_t<S>>>
+inline auto sprintf(const S& fmt, const T&... args) -> std::basic_string<Char> {
+  using context = basic_printf_context_t<Char>;
+  return vsprintf(detail::to_string_view(fmt),
+                  fmt::make_format_args<context>(args...));
+}
+
+template <typename S, typename Char = char_t<S>>
+inline auto vfprintf(
+    std::FILE* f, const S& fmt,
+    basic_format_args<basic_printf_context_t<type_identity_t<Char>>> args)
+    -> int {
+  auto buf = basic_memory_buffer<Char>();
+  detail::vprintf(buf, detail::to_string_view(fmt), args);
+  size_t size = buf.size();
+  return std::fwrite(buf.data(), sizeof(Char), size, f) < size
+             ? -1
+             : static_cast<int>(size);
+}
+
+/**
+  \rst
+  Prints formatted data to the file *f*.
+
+  **Example**::
+
+    fmt::fprintf(stderr, "Don't %s!", "panic");
+  \endrst
+ */
+template <typename S, typename... T, typename Char = char_t<S>>
+inline auto fprintf(std::FILE* f, const S& fmt, const T&... args) -> int {
+  using context = basic_printf_context_t<Char>;
+  return vfprintf(f, detail::to_string_view(fmt),
+                  fmt::make_format_args<context>(args...));
+}
+
+template <typename S, typename Char = char_t<S>>
+inline auto vprintf(
+    const S& fmt,
+    basic_format_args<basic_printf_context_t<type_identity_t<Char>>> args)
+    -> int {
+  return vfprintf(stdout, detail::to_string_view(fmt), args);
+}
+
+/**
+  \rst
+  Prints formatted data to ``stdout``.
+
+  **Example**::
+
+    fmt::printf("Elapsed time: %.2f seconds", 1.23);
+  \endrst
+ */
+template <typename S, typename... T, FMT_ENABLE_IF(detail::is_string<S>::value)>
+inline auto printf(const S& fmt, const T&... args) -> int {
+  return vprintf(
+      detail::to_string_view(fmt),
+      fmt::make_format_args<basic_printf_context_t<char_t<S>>>(args...));
+}
+
+FMT_END_EXPORT
+FMT_END_NAMESPACE
+
+#endif  // FMT_PRINTF_H_
```

## CoolProp/tests/runner.py

 * *Ordering differences only*

```diff
@@ -1,13 +1,13 @@
-from __future__ import print_function
-
-
-def run():
-    import nose, os
-
-    print('about to run the tests, please be patient')
-    this_path, file = os.path.split(os.path.abspath(__file__))
-    nose.run(argv=['--where', this_path])
-
-
-if __name__ == '__main__':
-    run()
+from __future__ import print_function
+
+
+def run():
+    import nose, os
+
+    print('about to run the tests, please be patient')
+    this_path, file = os.path.split(os.path.abspath(__file__))
+    nose.run(argv=['--where', this_path])
+
+
+if __name__ == '__main__':
+    run()
```

## CoolProp/tests/test_CoolPropState.py

 * *Ordering differences only*

```diff
@@ -1,131 +1,131 @@
-from __future__ import division, print_function
-import CoolProp.CoolProp as CP
-from CoolProp.State import State
-
-
-def first_derivative(S, func, iVal, Val, iConstant, Constant, epsilon=1e-3):
-
-    S.update({iVal: Val, iConstant: Constant})
-    val1 = func()
-
-    S.update({iVal: Val + epsilon, iConstant: Constant})
-    val2 = func()
-
-    S.update({iVal: Val, iConstant: Constant})
-
-    return (val2 - val1) / epsilon
-
-
-def second_derivative(S, func, iVal, Val, iConstant, Constant, epsilon=2):
-
-    S.update({iVal: Val - epsilon, iConstant: Constant})
-    val1 = func()
-
-    S.update({iVal: Val, iConstant: Constant})
-    val2 = func()
-
-    S.update({iVal: Val + epsilon, iConstant: Constant})
-    val3 = func()
-
-    S.update({iVal: Val, iConstant: Constant})
-
-    print(val1, val2, val3, S.T, S.p, S.rho, (val1 - 2 * val2 + val3))
-
-    return (val1 - 2 * val2 + val3) / (epsilon * epsilon)
-
-
-def teest_1phase_first_derivatives():
-
-    for US in [CoolProp.UNIT_SYSTEM_SI, CoolProp.UNIT_SYSTEM_KSI]:
-        CP.set_standard_unit_system(US)
-
-        S = State('R134a', dict(T=300, D=1))
-
-        l = [(S.get_rho, 'T', S.T, 'P', S.p, S.PFC.drhodT_constp),
-             (S.get_rho, 'P', S.p, 'T', S.T, S.PFC.drhodp_constT),
-             (S.get_p, 'D', S.rho, 'T', S.T, S.PFC.dpdrho_constT),
-             # (S.get_p,'D',S.rho,'H',S.h,S.PFC.dpdrho_consth), #(these inputs not supported)
-             (S.get_p, 'T', S.T, 'D', S.rho, S.PFC.dpdT_constrho),
-             # (S.get_p,'T',S.T,'H',S.h,S.PFC.dpdT_consth),     #(these inputs not supported)
-             (S.get_h, 'D', S.rho, 'T', S.T, S.PFC.dhdrho_constT),
-             (S.get_h, 'D', S.rho, 'P', S.p, S.PFC.dhdrho_constp),
-             (S.get_h, 'T', S.T, 'D', S.rho, S.PFC.dhdT_constrho),
-             (S.get_h, 'T', S.T, 'P', S.p, S.PFC.dhdT_constp),
-             (S.get_h, 'P', S.p, 'T', S.T, S.PFC.dhdp_constT),
-             (S.get_s, 'D', S.rho, 'T', S.T, S.PFC.dsdrho_constT),
-             (S.get_s, 'T', S.T, 'D', S.rho, S.PFC.dsdT_constrho),
-             (S.get_s, 'D', S.rho, 'P', S.p, S.PFC.dsdrho_constp),
-             (S.get_s, 'T', S.T, 'P', S.p, S.PFC.dsdT_constp),
-             (S.get_s, 'P', S.p, 'T', S.T, S.PFC.dsdp_constT),
-
-            ]
-        for args in l:
-            yield (check_1phase_first_derivatives,) + (S,) + args
-
-
-def check_1phase_first_derivatives(S, func, iVal, Val, iConstant, Constant, deriv_func):
-
-    Deriv_val = first_derivative(S, func, iVal, Val, iConstant, Constant)
-    EOS_val = deriv_func()
-    if abs(EOS_val / Deriv_val - 1) > 1e-2:
-        raise ValueError('Finite Diff: ' + str(Deriv_val) + ' EOS: ' + str(EOS_val))
-
-
-def teest_sat_first_derivatives():
-
-    for US in [CoolProp.UNIT_SYSTEM_SI, CoolProp.UNIT_SYSTEM_KSI]:
-        CP.set_standard_unit_system(US)
-
-        S = State('R134a', dict(T=300, Q=1))
-
-        l = [(S.get_T, 'P', S.p, 'Q', 0, S.PFC.dTdp_along_sat),
-             (S.get_rho, 'P', S.p, 'Q', 0, S.PFC.drhodp_along_sat_liquid),
-             (S.get_rho, 'P', S.p, 'Q', 1, S.PFC.drhodp_along_sat_vapor),
-             (S.get_rho, 'T', S.T, 'Q', 0, S.PFC.drhodT_along_sat_liquid),
-             (S.get_rho, 'T', S.T, 'Q', 1, S.PFC.drhodT_along_sat_vapor),
-             (S.get_h, 'P', S.p, 'Q', 0, S.PFC.dhdp_along_sat_liquid),
-             (S.get_h, 'P', S.p, 'Q', 1, S.PFC.dhdp_along_sat_vapor),
-             (S.get_s, 'P', S.p, 'Q', 0, S.PFC.dsdp_along_sat_liquid),
-             (S.get_s, 'P', S.p, 'Q', 1, S.PFC.dsdp_along_sat_vapor),
-            ]
-        for args in l:
-            yield (check_sat_first_derivatives,) + (S,) + args
-
-
-def check_sat_first_derivatives(S, func, iVal, Val, iConstant, Constant, deriv_func):
-
-    Deriv_val = first_derivative(S, func, iVal, Val, iConstant, Constant)
-    EOS_val = deriv_func()
-    if abs(EOS_val / Deriv_val - 1) > 1e-2:
-        raise ValueError('Finite Diff: ' + str(Deriv_val) + ' EOS: ' + str(EOS_val))
-
-
-def teest_sat_second_derivatives():
-    for US in [CoolProp.UNIT_SYSTEM_SI, CoolProp.UNIT_SYSTEM_KSI]:
-        CP.set_standard_unit_system(US)
-
-        S = State('R134a', dict(T=290, Q=1))
-
-        l = [(S.get_T, 'P', S.p, 'Q', 0, S.PFC.d2Tdp2_along_sat),
-             (S.get_rho, 'P', S.p, 'Q', 0, S.PFC.d2rhodp2_along_sat_liquid),
-             (S.get_rho, 'P', S.p, 'Q', 1, S.PFC.d2rhodp2_along_sat_vapor),
-             (S.get_h, 'P', S.p, 'Q', 0, S.PFC.d2hdp2_along_sat_liquid),
-             (S.get_h, 'P', S.p, 'Q', 1, S.PFC.d2hdp2_along_sat_vapor),
-             (S.get_s, 'P', S.p, 'Q', 0, S.PFC.d2sdp2_along_sat_liquid),
-             (S.get_s, 'P', S.p, 'Q', 1, S.PFC.d2sdp2_along_sat_vapor),
-            ]
-        for args in l:
-            yield (check_sat_second_derivatives,) + (S,) + args
-
-
-def check_sat_second_derivatives(S, func, iVal, Val, iConstant, Constant, deriv_func):
-
-    Deriv_val = second_derivative(S, func, iVal, Val, iConstant, Constant)
-    EOS_val = deriv_func()
-    if abs(EOS_val / Deriv_val - 1) > 1e-2:
-        raise ValueError('Finite Diff: ' + str(Deriv_val) + ' EOS: ' + str(EOS_val))
-
-
-if __name__ == '__main__':
-    import nose
-    nose.runmodule()
+from __future__ import division, print_function
+import CoolProp.CoolProp as CP
+from CoolProp.State import State
+
+
+def first_derivative(S, func, iVal, Val, iConstant, Constant, epsilon=1e-3):
+
+    S.update({iVal: Val, iConstant: Constant})
+    val1 = func()
+
+    S.update({iVal: Val + epsilon, iConstant: Constant})
+    val2 = func()
+
+    S.update({iVal: Val, iConstant: Constant})
+
+    return (val2 - val1) / epsilon
+
+
+def second_derivative(S, func, iVal, Val, iConstant, Constant, epsilon=2):
+
+    S.update({iVal: Val - epsilon, iConstant: Constant})
+    val1 = func()
+
+    S.update({iVal: Val, iConstant: Constant})
+    val2 = func()
+
+    S.update({iVal: Val + epsilon, iConstant: Constant})
+    val3 = func()
+
+    S.update({iVal: Val, iConstant: Constant})
+
+    print(val1, val2, val3, S.T, S.p, S.rho, (val1 - 2 * val2 + val3))
+
+    return (val1 - 2 * val2 + val3) / (epsilon * epsilon)
+
+
+def teest_1phase_first_derivatives():
+
+    for US in [CoolProp.UNIT_SYSTEM_SI, CoolProp.UNIT_SYSTEM_KSI]:
+        CP.set_standard_unit_system(US)
+
+        S = State('R134a', dict(T=300, D=1))
+
+        l = [(S.get_rho, 'T', S.T, 'P', S.p, S.PFC.drhodT_constp),
+             (S.get_rho, 'P', S.p, 'T', S.T, S.PFC.drhodp_constT),
+             (S.get_p, 'D', S.rho, 'T', S.T, S.PFC.dpdrho_constT),
+             # (S.get_p,'D',S.rho,'H',S.h,S.PFC.dpdrho_consth), #(these inputs not supported)
+             (S.get_p, 'T', S.T, 'D', S.rho, S.PFC.dpdT_constrho),
+             # (S.get_p,'T',S.T,'H',S.h,S.PFC.dpdT_consth),     #(these inputs not supported)
+             (S.get_h, 'D', S.rho, 'T', S.T, S.PFC.dhdrho_constT),
+             (S.get_h, 'D', S.rho, 'P', S.p, S.PFC.dhdrho_constp),
+             (S.get_h, 'T', S.T, 'D', S.rho, S.PFC.dhdT_constrho),
+             (S.get_h, 'T', S.T, 'P', S.p, S.PFC.dhdT_constp),
+             (S.get_h, 'P', S.p, 'T', S.T, S.PFC.dhdp_constT),
+             (S.get_s, 'D', S.rho, 'T', S.T, S.PFC.dsdrho_constT),
+             (S.get_s, 'T', S.T, 'D', S.rho, S.PFC.dsdT_constrho),
+             (S.get_s, 'D', S.rho, 'P', S.p, S.PFC.dsdrho_constp),
+             (S.get_s, 'T', S.T, 'P', S.p, S.PFC.dsdT_constp),
+             (S.get_s, 'P', S.p, 'T', S.T, S.PFC.dsdp_constT),
+
+            ]
+        for args in l:
+            yield (check_1phase_first_derivatives,) + (S,) + args
+
+
+def check_1phase_first_derivatives(S, func, iVal, Val, iConstant, Constant, deriv_func):
+
+    Deriv_val = first_derivative(S, func, iVal, Val, iConstant, Constant)
+    EOS_val = deriv_func()
+    if abs(EOS_val / Deriv_val - 1) > 1e-2:
+        raise ValueError('Finite Diff: ' + str(Deriv_val) + ' EOS: ' + str(EOS_val))
+
+
+def teest_sat_first_derivatives():
+
+    for US in [CoolProp.UNIT_SYSTEM_SI, CoolProp.UNIT_SYSTEM_KSI]:
+        CP.set_standard_unit_system(US)
+
+        S = State('R134a', dict(T=300, Q=1))
+
+        l = [(S.get_T, 'P', S.p, 'Q', 0, S.PFC.dTdp_along_sat),
+             (S.get_rho, 'P', S.p, 'Q', 0, S.PFC.drhodp_along_sat_liquid),
+             (S.get_rho, 'P', S.p, 'Q', 1, S.PFC.drhodp_along_sat_vapor),
+             (S.get_rho, 'T', S.T, 'Q', 0, S.PFC.drhodT_along_sat_liquid),
+             (S.get_rho, 'T', S.T, 'Q', 1, S.PFC.drhodT_along_sat_vapor),
+             (S.get_h, 'P', S.p, 'Q', 0, S.PFC.dhdp_along_sat_liquid),
+             (S.get_h, 'P', S.p, 'Q', 1, S.PFC.dhdp_along_sat_vapor),
+             (S.get_s, 'P', S.p, 'Q', 0, S.PFC.dsdp_along_sat_liquid),
+             (S.get_s, 'P', S.p, 'Q', 1, S.PFC.dsdp_along_sat_vapor),
+            ]
+        for args in l:
+            yield (check_sat_first_derivatives,) + (S,) + args
+
+
+def check_sat_first_derivatives(S, func, iVal, Val, iConstant, Constant, deriv_func):
+
+    Deriv_val = first_derivative(S, func, iVal, Val, iConstant, Constant)
+    EOS_val = deriv_func()
+    if abs(EOS_val / Deriv_val - 1) > 1e-2:
+        raise ValueError('Finite Diff: ' + str(Deriv_val) + ' EOS: ' + str(EOS_val))
+
+
+def teest_sat_second_derivatives():
+    for US in [CoolProp.UNIT_SYSTEM_SI, CoolProp.UNIT_SYSTEM_KSI]:
+        CP.set_standard_unit_system(US)
+
+        S = State('R134a', dict(T=290, Q=1))
+
+        l = [(S.get_T, 'P', S.p, 'Q', 0, S.PFC.d2Tdp2_along_sat),
+             (S.get_rho, 'P', S.p, 'Q', 0, S.PFC.d2rhodp2_along_sat_liquid),
+             (S.get_rho, 'P', S.p, 'Q', 1, S.PFC.d2rhodp2_along_sat_vapor),
+             (S.get_h, 'P', S.p, 'Q', 0, S.PFC.d2hdp2_along_sat_liquid),
+             (S.get_h, 'P', S.p, 'Q', 1, S.PFC.d2hdp2_along_sat_vapor),
+             (S.get_s, 'P', S.p, 'Q', 0, S.PFC.d2sdp2_along_sat_liquid),
+             (S.get_s, 'P', S.p, 'Q', 1, S.PFC.d2sdp2_along_sat_vapor),
+            ]
+        for args in l:
+            yield (check_sat_second_derivatives,) + (S,) + args
+
+
+def check_sat_second_derivatives(S, func, iVal, Val, iConstant, Constant, deriv_func):
+
+    Deriv_val = second_derivative(S, func, iVal, Val, iConstant, Constant)
+    EOS_val = deriv_func()
+    if abs(EOS_val / Deriv_val - 1) > 1e-2:
+        raise ValueError('Finite Diff: ' + str(Deriv_val) + ' EOS: ' + str(EOS_val))
+
+
+if __name__ == '__main__':
+    import nose
+    nose.runmodule()
```

## CoolProp/tests/test_Props.py

 * *Ordering differences only*

```diff
@@ -1,30 +1,30 @@
-import unittest
-from CoolProp.CoolProp import PropsSI
-import CoolProp
-import numpy as np
-
-
-def test_input_types():
-    for Fluid in ['Water']:
-        for Tvals in [0.5 * PropsSI(Fluid, 'Tmin') + 0.5 * PropsSI(Fluid, 'Tcrit'),
-                      [PropsSI(Fluid, 'Tmin') + 1e-5, PropsSI(Fluid, 'Tcrit') - 1e-5],
-                      np.linspace(PropsSI(Fluid, 'Tmin') + 1e-5, PropsSI(Fluid, 'Tcrit') - 1e-5, 30)
-                      ]:
-            yield check_type, Fluid, Tvals
-
-
-def check_type(fluid, Tvals):
-    PropsSI('P', 'T', Tvals, 'Q', 0, fluid)
-
-
-class PropsFailures(unittest.TestCase):
-    def testUnmatchedLengths(self):
-        self.assertRaises(TypeError, PropsSI, 'P', 'T', [280, 290, 300], 'Q', [0, 1], 'R134a')
-
-    def testMatrix(self):
-        self.assertRaises(TypeError, PropsSI, 'P', 'T', np.array([280, 290, 300, 280, 290, 300]).reshape(2, 3), 'Q', np.array([0, 0.5, 1, 0.0, 0.5, 1]).reshape(2, 3), 'R134a')
-
-
-if __name__ == '__main__':
-    import nose
-    nose.runmodule()
+import unittest
+from CoolProp.CoolProp import PropsSI
+import CoolProp
+import numpy as np
+
+
+def test_input_types():
+    for Fluid in ['Water']:
+        for Tvals in [0.5 * PropsSI(Fluid, 'Tmin') + 0.5 * PropsSI(Fluid, 'Tcrit'),
+                      [PropsSI(Fluid, 'Tmin') + 1e-5, PropsSI(Fluid, 'Tcrit') - 1e-5],
+                      np.linspace(PropsSI(Fluid, 'Tmin') + 1e-5, PropsSI(Fluid, 'Tcrit') - 1e-5, 30)
+                      ]:
+            yield check_type, Fluid, Tvals
+
+
+def check_type(fluid, Tvals):
+    PropsSI('P', 'T', Tvals, 'Q', 0, fluid)
+
+
+class PropsFailures(unittest.TestCase):
+    def testUnmatchedLengths(self):
+        self.assertRaises(TypeError, PropsSI, 'P', 'T', [280, 290, 300], 'Q', [0, 1], 'R134a')
+
+    def testMatrix(self):
+        self.assertRaises(TypeError, PropsSI, 'P', 'T', np.array([280, 290, 300, 280, 290, 300]).reshape(2, 3), 'Q', np.array([0, 0.5, 1, 0.0, 0.5, 1]).reshape(2, 3), 'R134a')
+
+
+if __name__ == '__main__':
+    import nose
+    nose.runmodule()
```

## CoolProp/tests/test_plots.py

 * *Ordering differences only*

```diff
@@ -1,163 +1,163 @@
-import numpy as np
-import matplotlib.pyplot as plt
-
-
-def test_back_compatibility():
-    fluid_ref = 'R290'
-
-    def Ts_plot_tests():
-        from CoolProp.Plots import Ts
-        Ts(fluid_ref, show=False)
-
-        from matplotlib import pyplot
-        fig = pyplot.figure(2)
-        ax = fig.gca()
-        Ts(fluid_ref, show=False, axis=ax)
-        plt.close()
-        Ts(fluid_ref, show=False, Tmin=200, Tmax=300)
-        plt.close()
-
-    def Ph_plot_tests():
-        from CoolProp.Plots import Ph
-        Ph(fluid_ref, show=False)
-
-        from matplotlib import pyplot
-        fig = pyplot.figure(2)
-        ax = fig.gca()
-        Ph(fluid_ref, show=False, axis=ax)
-        plt.close()
-        Ph(fluid_ref, show=False, Tmin=200, Tmax=300)
-        plt.close()
-
-    def PT_plot_tests():
-        from CoolProp.Plots import PT
-        PT(fluid_ref, show=False)
-
-        from matplotlib import pyplot
-        fig = pyplot.figure(2)
-        ax = fig.gca()
-        PT(fluid_ref, show=False, axis=ax)
-        plt.close()
-        PT(fluid_ref, show=False, Tmin=200, Tmax=300)
-        plt.close()
-
-    def Ps_plot_tests():
-        from CoolProp.Plots import Ps
-        Ps(fluid_ref, show=False)
-
-        from matplotlib import pyplot
-        fig = pyplot.figure(2)
-        ax = fig.gca()
-        Ps(fluid_ref, show=False, axis=ax)
-        plt.close()
-        Ps(fluid_ref, show=False, Tmin=200, Tmax=300)
-        plt.close()
-
-    def Prho_plot_tests():
-        from CoolProp.Plots import Prho
-        Prho(fluid_ref, show=False)
-
-        from matplotlib import pyplot
-        fig = pyplot.figure(2)
-        ax = fig.gca()
-        Prho(fluid_ref, show=False, axis=ax)
-        plt.close()
-        Prho(fluid_ref, show=False, Tmin=200, Tmax=300)
-        plt.close()
-
-    def Trho_plot_tests():
-        from CoolProp.Plots import Trho
-        Trho(fluid_ref, show=False)
-
-        from matplotlib import pyplot
-        fig = pyplot.figure(2)
-        ax = fig.gca()
-        Trho(fluid_ref, show=False, axis=ax)
-        plt.close()
-        Trho(fluid_ref, show=False, Tmin=200, Tmax=300)
-        plt.close()
-
-    def hs_plot_tests():
-        from CoolProp.Plots import hs
-        hs(fluid_ref, show=False)
-
-        from matplotlib import pyplot
-        fig = pyplot.figure(2)
-        ax = fig.gca()
-        hs(fluid_ref, show=False, axis=ax)
-        plt.close()
-        hs(fluid_ref, show=False, Tmin=200, Tmax=300)
-        plt.close()
-
-    def Isolines_plot_tests():
-        from matplotlib import pyplot
-        from CoolProp.Plots import Ts, drawIsoLines
-        ax = Ts(fluid_ref)
-        #ax.set_xlim([-0.5, 1.5])
-        #ax.set_ylim([300, 530])
-        quality = drawIsoLines(fluid_ref, 'Ts', 'Q', [0.3, 0.5, 0.7, 0.8], axis=ax)
-        isobars = drawIsoLines(fluid_ref, 'Ts', 'P', [100, 2000], num=5, axis=ax)
-        isochores = drawIsoLines(fluid_ref, 'Ts', 'D', [2, 600], num=7, axis=ax)
-        pyplot.close()
-
-    Ts_plot_tests()
-    Ph_plot_tests()
-    Ps_plot_tests()
-    PT_plot_tests()
-    Prho_plot_tests()
-    Trho_plot_tests()
-    hs_plot_tests()
-    Isolines_plot_tests()
-
-
-def test_new_code():
-    fluid_ref = 'Water'
-
-    def Ts_plot_tests():
-        from CoolProp.Plots import PropsPlot
-        PP = PropsPlot(fluid_ref, 'Ts')
-        plt.close()
-
-    def Ph_plot_tests():
-        from CoolProp.Plots import PropsPlot
-        PP = PropsPlot(fluid_ref, 'Ph')
-        plt.close()
-
-    def Isolines_plot_tests():
-        from CoolProp.Plots import PropsPlot
-        PP = PropsPlot(fluid_ref, 'Ts')
-        #plt.set_axis_limits([-0.5, 1.5, 300, 530])
-        PP.draw_isolines('Q', [0.3, 0.5, 0.7, 0.8])
-        PP.draw_isolines('P', [100, 2000], num=5)
-        PP.draw_isolines('D', [2, 600], num=7)
-        plt.close()
-
-    def Graph_annotations():
-        from CoolProp.Plots import PropsPlot, IsoLines
-        PP = PropsPlot(fluid_ref, 'Ts')
-        PP.draw_isolines('Q', [0.3, 0.5, 0.7, 0.8])
-        PP.draw_isolines('P', [100, 2000], num=5)
-        PP.draw_isolines('D', [2, 600], num=7)
-        plt.title('New Title')
-        PP.xlabel('New x label')
-        PP.ylabel('New y label')
-        PP = IsoLines(fluid_ref, 'Ts', 'P')
-        PP.draw_isolines([100, 2000], num=5)
-        plt.close()
-
-    def Mixture():
-        from CoolProp.Plots import PropsPlot
-        PP = PropsPlot('REFPROP-MIX:R32[0.47319469]&R125[0.2051091]&R134a[0.32169621]', 'TD')
-        PP._plot_default_annotations()
-        plt.close()
-
-    Ts_plot_tests()
-    Ph_plot_tests()
-    Isolines_plot_tests()
-    Graph_annotations()
-    Mixture()
-
-
-if __name__ == '__main__':
-    import nose
-    nose.runmodule()
+import numpy as np
+import matplotlib.pyplot as plt
+
+
+def test_back_compatibility():
+    fluid_ref = 'R290'
+
+    def Ts_plot_tests():
+        from CoolProp.Plots import Ts
+        Ts(fluid_ref, show=False)
+
+        from matplotlib import pyplot
+        fig = pyplot.figure(2)
+        ax = fig.gca()
+        Ts(fluid_ref, show=False, axis=ax)
+        plt.close()
+        Ts(fluid_ref, show=False, Tmin=200, Tmax=300)
+        plt.close()
+
+    def Ph_plot_tests():
+        from CoolProp.Plots import Ph
+        Ph(fluid_ref, show=False)
+
+        from matplotlib import pyplot
+        fig = pyplot.figure(2)
+        ax = fig.gca()
+        Ph(fluid_ref, show=False, axis=ax)
+        plt.close()
+        Ph(fluid_ref, show=False, Tmin=200, Tmax=300)
+        plt.close()
+
+    def PT_plot_tests():
+        from CoolProp.Plots import PT
+        PT(fluid_ref, show=False)
+
+        from matplotlib import pyplot
+        fig = pyplot.figure(2)
+        ax = fig.gca()
+        PT(fluid_ref, show=False, axis=ax)
+        plt.close()
+        PT(fluid_ref, show=False, Tmin=200, Tmax=300)
+        plt.close()
+
+    def Ps_plot_tests():
+        from CoolProp.Plots import Ps
+        Ps(fluid_ref, show=False)
+
+        from matplotlib import pyplot
+        fig = pyplot.figure(2)
+        ax = fig.gca()
+        Ps(fluid_ref, show=False, axis=ax)
+        plt.close()
+        Ps(fluid_ref, show=False, Tmin=200, Tmax=300)
+        plt.close()
+
+    def Prho_plot_tests():
+        from CoolProp.Plots import Prho
+        Prho(fluid_ref, show=False)
+
+        from matplotlib import pyplot
+        fig = pyplot.figure(2)
+        ax = fig.gca()
+        Prho(fluid_ref, show=False, axis=ax)
+        plt.close()
+        Prho(fluid_ref, show=False, Tmin=200, Tmax=300)
+        plt.close()
+
+    def Trho_plot_tests():
+        from CoolProp.Plots import Trho
+        Trho(fluid_ref, show=False)
+
+        from matplotlib import pyplot
+        fig = pyplot.figure(2)
+        ax = fig.gca()
+        Trho(fluid_ref, show=False, axis=ax)
+        plt.close()
+        Trho(fluid_ref, show=False, Tmin=200, Tmax=300)
+        plt.close()
+
+    def hs_plot_tests():
+        from CoolProp.Plots import hs
+        hs(fluid_ref, show=False)
+
+        from matplotlib import pyplot
+        fig = pyplot.figure(2)
+        ax = fig.gca()
+        hs(fluid_ref, show=False, axis=ax)
+        plt.close()
+        hs(fluid_ref, show=False, Tmin=200, Tmax=300)
+        plt.close()
+
+    def Isolines_plot_tests():
+        from matplotlib import pyplot
+        from CoolProp.Plots import Ts, drawIsoLines
+        ax = Ts(fluid_ref)
+        #ax.set_xlim([-0.5, 1.5])
+        #ax.set_ylim([300, 530])
+        quality = drawIsoLines(fluid_ref, 'Ts', 'Q', [0.3, 0.5, 0.7, 0.8], axis=ax)
+        isobars = drawIsoLines(fluid_ref, 'Ts', 'P', [100, 2000], num=5, axis=ax)
+        isochores = drawIsoLines(fluid_ref, 'Ts', 'D', [2, 600], num=7, axis=ax)
+        pyplot.close()
+
+    Ts_plot_tests()
+    Ph_plot_tests()
+    Ps_plot_tests()
+    PT_plot_tests()
+    Prho_plot_tests()
+    Trho_plot_tests()
+    hs_plot_tests()
+    Isolines_plot_tests()
+
+
+def test_new_code():
+    fluid_ref = 'Water'
+
+    def Ts_plot_tests():
+        from CoolProp.Plots import PropsPlot
+        PP = PropsPlot(fluid_ref, 'Ts')
+        plt.close()
+
+    def Ph_plot_tests():
+        from CoolProp.Plots import PropsPlot
+        PP = PropsPlot(fluid_ref, 'Ph')
+        plt.close()
+
+    def Isolines_plot_tests():
+        from CoolProp.Plots import PropsPlot
+        PP = PropsPlot(fluid_ref, 'Ts')
+        #plt.set_axis_limits([-0.5, 1.5, 300, 530])
+        PP.draw_isolines('Q', [0.3, 0.5, 0.7, 0.8])
+        PP.draw_isolines('P', [100, 2000], num=5)
+        PP.draw_isolines('D', [2, 600], num=7)
+        plt.close()
+
+    def Graph_annotations():
+        from CoolProp.Plots import PropsPlot, IsoLines
+        PP = PropsPlot(fluid_ref, 'Ts')
+        PP.draw_isolines('Q', [0.3, 0.5, 0.7, 0.8])
+        PP.draw_isolines('P', [100, 2000], num=5)
+        PP.draw_isolines('D', [2, 600], num=7)
+        plt.title('New Title')
+        PP.xlabel('New x label')
+        PP.ylabel('New y label')
+        PP = IsoLines(fluid_ref, 'Ts', 'P')
+        PP.draw_isolines([100, 2000], num=5)
+        plt.close()
+
+    def Mixture():
+        from CoolProp.Plots import PropsPlot
+        PP = PropsPlot('REFPROP-MIX:R32[0.47319469]&R125[0.2051091]&R134a[0.32169621]', 'TD')
+        PP._plot_default_annotations()
+        plt.close()
+
+    Ts_plot_tests()
+    Ph_plot_tests()
+    Isolines_plot_tests()
+    Graph_annotations()
+    Mixture()
+
+
+if __name__ == '__main__':
+    import nose
+    nose.runmodule()
```

## Comparing `CoolProp-6.4.3.post1.dist-info/METADATA` & `CoolProp-6.5.0.dist-info/METADATA`

 * *Files 11% similar despite different names*

```diff
@@ -1,15 +1,15 @@
-Metadata-Version: 2.1
-Name: CoolProp
-Version: 6.4.3.post1
-Summary: Open-source thermodynamic and transport properties database
-Home-page: http://www.coolprop.org
-Author: Ian Bell
-Author-email: ian.h.bell@gmail.com
-Classifier: Programming Language :: Python
-Classifier: Development Status :: 4 - Beta
-Classifier: Environment :: Other Environment
-Classifier: Intended Audience :: Developers
-Classifier: License :: OSI Approved :: MIT License
-Classifier: Operating System :: OS Independent
-Classifier: Topic :: Software Development :: Libraries :: Python Modules
-
+Metadata-Version: 2.1
+Name: CoolProp
+Version: 6.5.0
+Summary: Open-source thermodynamic and transport properties database
+Home-page: http://www.coolprop.org
+Author: Ian Bell
+Author-email: ian.h.bell@gmail.com
+Classifier: Programming Language :: Python
+Classifier: Development Status :: 4 - Beta
+Classifier: Environment :: Other Environment
+Classifier: Intended Audience :: Developers
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Operating System :: OS Independent
+Classifier: Topic :: Software Development :: Libraries :: Python Modules
+
```

