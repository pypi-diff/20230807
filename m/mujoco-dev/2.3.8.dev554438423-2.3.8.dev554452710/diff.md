# Comparing `tmp/mujoco_dev-2.3.8.dev554438423-cp39-cp39-win_amd64.whl.zip` & `tmp/mujoco_dev-2.3.8.dev554452710-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl.zip`

## zipinfo {}

```diff
@@ -1,47 +1,57 @@
-Zip file size: 3333947 bytes, number of entries: 45
--rw-rw-rw-  2.0 fat     2446 b- defN 23-Aug-07 11:56 mujoco/__init__.py
--rw-rw-rw-  2.0 fat   251904 b- defN 23-Aug-07 12:06 mujoco/_callbacks.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat   161792 b- defN 23-Aug-07 12:06 mujoco/_constants.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat  1866240 b- defN 23-Aug-07 12:06 mujoco/_enums.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat   150528 b- defN 23-Aug-07 12:06 mujoco/_errors.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat   988160 b- defN 23-Aug-07 12:06 mujoco/_functions.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat   448512 b- defN 23-Aug-07 12:06 mujoco/_render.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat   201728 b- defN 23-Aug-07 12:06 mujoco/_rollout.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat   469504 b- defN 23-Aug-07 12:06 mujoco/_simulate.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat  4141056 b- defN 23-Aug-07 12:06 mujoco/_structs.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat    50950 b- defN 23-Aug-07 11:56 mujoco/bindings_test.py
--rw-rw-rw-  2.0 fat     1849 b- defN 23-Aug-07 11:56 mujoco/gl_context.py
--rw-rw-rw-  2.0 fat  3017216 b- defN 23-Aug-07 12:06 mujoco/mujoco.dll
--rw-rw-rw-  2.0 fat     3822 b- defN 23-Aug-07 11:56 mujoco/render_test.py
--rw-rw-rw-  2.0 fat     9101 b- defN 23-Aug-07 11:56 mujoco/renderer.py
--rw-rw-rw-  2.0 fat     3655 b- defN 23-Aug-07 11:56 mujoco/renderer_test.py
--rw-rw-rw-  2.0 fat     7793 b- defN 23-Aug-07 11:56 mujoco/rollout.py
--rw-rw-rw-  2.0 fat    18157 b- defN 23-Aug-07 11:56 mujoco/rollout_test.py
--rw-rw-rw-  2.0 fat    13230 b- defN 23-Aug-07 11:56 mujoco/viewer.py
--rw-rw-rw-  2.0 fat      979 b- defN 23-Aug-07 11:56 mujoco/viewer_test.py
--rw-rw-rw-  2.0 fat     2271 b- defN 23-Aug-07 11:56 mujoco/cgl/__init__.py
--rw-rw-rw-  2.0 fat     5204 b- defN 23-Aug-07 11:56 mujoco/cgl/cgl.py
--rw-rw-rw-  2.0 fat     4764 b- defN 23-Aug-07 11:56 mujoco/egl/__init__.py
--rw-rw-rw-  2.0 fat     2783 b- defN 23-Aug-07 11:56 mujoco/egl/egl_ext.py
--rw-rw-rw-  2.0 fat     1403 b- defN 23-Aug-07 11:56 mujoco/glfw/__init__.py
--rw-rw-rw-  2.0 fat    21478 b- defN 23-Aug-07 12:06 mujoco/include/mujoco/mjdata.h
--rw-rw-rw-  2.0 fat     1580 b- defN 23-Aug-07 12:06 mujoco/include/mujoco/mjexport.h
--rw-rw-rw-  2.0 fat     2321 b- defN 23-Aug-07 12:06 mujoco/include/mujoco/mjmacro.h
--rw-rw-rw-  2.0 fat    60337 b- defN 23-Aug-07 12:06 mujoco/include/mujoco/mjmodel.h
--rw-rw-rw-  2.0 fat     5807 b- defN 23-Aug-07 12:06 mujoco/include/mujoco/mjplugin.h
--rw-rw-rw-  2.0 fat     7167 b- defN 23-Aug-07 12:06 mujoco/include/mujoco/mjrender.h
--rw-rw-rw-  2.0 fat     1352 b- defN 23-Aug-07 12:06 mujoco/include/mujoco/mjtnum.h
--rw-rw-rw-  2.0 fat    13200 b- defN 23-Aug-07 12:06 mujoco/include/mujoco/mjui.h
--rw-rw-rw-  2.0 fat    21791 b- defN 23-Aug-07 12:06 mujoco/include/mujoco/mjvisualize.h
--rw-rw-rw-  2.0 fat    40524 b- defN 23-Aug-07 12:06 mujoco/include/mujoco/mjxmacro.h
--rw-rw-rw-  2.0 fat    55148 b- defN 23-Aug-07 12:06 mujoco/include/mujoco/mujoco.h
--rw-rw-rw-  2.0 fat     2556 b- defN 23-Aug-07 11:56 mujoco/osmesa/__init__.py
--rw-rw-rw-  2.0 fat    43008 b- defN 23-Aug-07 12:06 mujoco/plugin/elasticity.dll
--rw-rw-rw-  2.0 fat    41472 b- defN 23-Aug-07 12:06 mujoco/plugin/sensor.dll
--rw-rw-rw-  2.0 fat    11358 b- defN 23-Aug-07 12:06 mujoco_dev-2.3.8.dev554438423.dist-info/LICENSE
--rw-rw-rw-  2.0 fat    31030 b- defN 23-Aug-07 12:06 mujoco_dev-2.3.8.dev554438423.dist-info/LICENSES_THIRD_PARTY.md
--rw-rw-rw-  2.0 fat    35858 b- defN 23-Aug-07 12:06 mujoco_dev-2.3.8.dev554438423.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 23-Aug-07 12:06 mujoco_dev-2.3.8.dev554438423.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        7 b- defN 23-Aug-07 12:06 mujoco_dev-2.3.8.dev554438423.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     3895 b- defN 23-Aug-07 12:06 mujoco_dev-2.3.8.dev554438423.dist-info/RECORD
-45 files, 12225036 bytes uncompressed, 3327801 bytes compressed:  72.8%
+Zip file size: 4297694 bytes, number of entries: 55
+drwxr-xr-x  2.0 unx        0 b- stor 23-Aug-07 13:19 mujoco_dev-2.3.8.dev554452710.dist-info/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Aug-07 13:19 mujoco/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Aug-07 13:19 mujoco_dev.libs/
+-rw-rw-r--  2.0 unx     4071 b- defN 23-Aug-07 13:19 mujoco_dev-2.3.8.dev554452710.dist-info/RECORD
+-rw-r--r--  2.0 unx    11358 b- defN 23-Aug-07 13:19 mujoco_dev-2.3.8.dev554452710.dist-info/LICENSE
+-rw-r--r--  2.0 unx    35030 b- defN 23-Aug-07 13:19 mujoco_dev-2.3.8.dev554452710.dist-info/METADATA
+-rw-r--r--  2.0 unx    31030 b- defN 23-Aug-07 13:19 mujoco_dev-2.3.8.dev554452710.dist-info/LICENSES_THIRD_PARTY.md
+-rw-r--r--  2.0 unx      150 b- defN 23-Aug-07 13:19 mujoco_dev-2.3.8.dev554452710.dist-info/WHEEL
+-rw-r--r--  2.0 unx        7 b- defN 23-Aug-07 13:19 mujoco_dev-2.3.8.dev554452710.dist-info/top_level.txt
+drwxr-xr-x  2.0 unx        0 b- stor 23-Aug-07 13:19 mujoco/osmesa/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Aug-07 13:19 mujoco/include/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Aug-07 13:19 mujoco/glfw/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Aug-07 13:19 mujoco/egl/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Aug-07 13:19 mujoco/cgl/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Aug-07 13:19 mujoco/plugin/
+-rw-r--r--  2.0 unx   901136 b- defN 23-Aug-07 13:19 mujoco/_functions.cpython-39-aarch64-linux-gnu.so
+-rw-r--r--  2.0 unx     1849 b- defN 23-Aug-07 13:19 mujoco/gl_context.py
+-rw-r--r--  2.0 unx      979 b- defN 23-Aug-07 13:19 mujoco/viewer_test.py
+-rw-r--r--  2.0 unx     2446 b- defN 23-Aug-07 13:19 mujoco/__init__.py
+-rw-r--r--  2.0 unx     3822 b- defN 23-Aug-07 13:19 mujoco/render_test.py
+-rw-r--r--  2.0 unx     7793 b- defN 23-Aug-07 13:19 mujoco/rollout.py
+-rw-r--r--  2.0 unx   317560 b- defN 23-Aug-07 13:19 mujoco/_constants.cpython-39-aarch64-linux-gnu.so
+-rw-r--r--  2.0 unx   579392 b- defN 23-Aug-07 13:19 mujoco/_callbacks.cpython-39-aarch64-linux-gnu.so
+-rw-r--r--  2.0 unx     3655 b- defN 23-Aug-07 13:19 mujoco/renderer_test.py
+-rw-r--r--  2.0 unx  1691776 b- defN 23-Aug-07 13:19 mujoco/_enums.cpython-39-aarch64-linux-gnu.so
+-rw-r--r--  2.0 unx  3456768 b- defN 23-Aug-07 13:19 mujoco/libmujoco.so.2.3.8
+-rw-r--r--  2.0 unx   700152 b- defN 23-Aug-07 13:19 mujoco/_render.cpython-39-aarch64-linux-gnu.so
+-rw-r--r--  2.0 unx   543616 b- defN 23-Aug-07 13:19 mujoco/_rollout.cpython-39-aarch64-linux-gnu.so
+-rw-r--r--  2.0 unx   312440 b- defN 23-Aug-07 13:19 mujoco/_errors.cpython-39-aarch64-linux-gnu.so
+-rw-r--r--  2.0 unx    18157 b- defN 23-Aug-07 13:19 mujoco/rollout_test.py
+-rw-r--r--  2.0 unx    13230 b- defN 23-Aug-07 13:19 mujoco/viewer.py
+-rw-r--r--  2.0 unx    50950 b- defN 23-Aug-07 13:19 mujoco/bindings_test.py
+-rw-r--r--  2.0 unx     9101 b- defN 23-Aug-07 13:19 mujoco/renderer.py
+-rw-r--r--  2.0 unx  2572448 b- defN 23-Aug-07 13:19 mujoco/_structs.cpython-39-aarch64-linux-gnu.so
+-rw-r--r--  2.0 unx   773104 b- defN 23-Aug-07 13:19 mujoco/_simulate.cpython-39-aarch64-linux-gnu.so
+-rw-r--r--  2.0 unx     2556 b- defN 23-Aug-07 13:19 mujoco/osmesa/__init__.py
+drwxr-xr-x  2.0 unx        0 b- stor 23-Aug-07 13:19 mujoco/include/mujoco/
+-rw-r--r--  2.0 unx     5671 b- defN 23-Aug-07 13:19 mujoco/include/mujoco/mjplugin.h
+-rw-r--r--  2.0 unx     2260 b- defN 23-Aug-07 13:19 mujoco/include/mujoco/mjmacro.h
+-rw-r--r--  2.0 unx    59342 b- defN 23-Aug-07 13:19 mujoco/include/mujoco/mjmodel.h
+-rw-r--r--  2.0 unx     1311 b- defN 23-Aug-07 13:19 mujoco/include/mujoco/mjtnum.h
+-rw-r--r--  2.0 unx     1533 b- defN 23-Aug-07 13:19 mujoco/include/mujoco/mjexport.h
+-rw-r--r--  2.0 unx    12879 b- defN 23-Aug-07 13:19 mujoco/include/mujoco/mjui.h
+-rw-r--r--  2.0 unx    39883 b- defN 23-Aug-07 13:19 mujoco/include/mujoco/mjxmacro.h
+-rw-r--r--  2.0 unx    21207 b- defN 23-Aug-07 13:19 mujoco/include/mujoco/mjvisualize.h
+-rw-r--r--  2.0 unx     7007 b- defN 23-Aug-07 13:19 mujoco/include/mujoco/mjrender.h
+-rw-r--r--  2.0 unx    53846 b- defN 23-Aug-07 13:19 mujoco/include/mujoco/mujoco.h
+-rw-r--r--  2.0 unx    21063 b- defN 23-Aug-07 13:19 mujoco/include/mujoco/mjdata.h
+-rw-r--r--  2.0 unx     1403 b- defN 23-Aug-07 13:19 mujoco/glfw/__init__.py
+-rw-r--r--  2.0 unx     4764 b- defN 23-Aug-07 13:19 mujoco/egl/__init__.py
+-rw-r--r--  2.0 unx     2783 b- defN 23-Aug-07 13:19 mujoco/egl/egl_ext.py
+-rw-r--r--  2.0 unx     5204 b- defN 23-Aug-07 13:19 mujoco/cgl/cgl.py
+-rw-r--r--  2.0 unx     2271 b- defN 23-Aug-07 13:19 mujoco/cgl/__init__.py
+-rw-r--r--  2.0 unx   665456 b- defN 23-Aug-07 13:19 mujoco/plugin/libsensor.so
+-rw-r--r--  2.0 unx   353448 b- defN 23-Aug-07 13:19 mujoco/plugin/libelasticity.so
+55 files, 13305907 bytes uncompressed, 4290206 bytes compressed:  67.8%
```

## zipnote {}

```diff
@@ -1,136 +1,166 @@
-Filename: mujoco/__init__.py
+Filename: mujoco_dev-2.3.8.dev554452710.dist-info/
 Comment: 
 
-Filename: mujoco/_callbacks.cp39-win_amd64.pyd
+Filename: mujoco/
 Comment: 
 
-Filename: mujoco/_constants.cp39-win_amd64.pyd
+Filename: mujoco_dev.libs/
 Comment: 
 
-Filename: mujoco/_enums.cp39-win_amd64.pyd
+Filename: mujoco_dev-2.3.8.dev554452710.dist-info/RECORD
 Comment: 
 
-Filename: mujoco/_errors.cp39-win_amd64.pyd
+Filename: mujoco_dev-2.3.8.dev554452710.dist-info/LICENSE
 Comment: 
 
-Filename: mujoco/_functions.cp39-win_amd64.pyd
+Filename: mujoco_dev-2.3.8.dev554452710.dist-info/METADATA
 Comment: 
 
-Filename: mujoco/_render.cp39-win_amd64.pyd
+Filename: mujoco_dev-2.3.8.dev554452710.dist-info/LICENSES_THIRD_PARTY.md
 Comment: 
 
-Filename: mujoco/_rollout.cp39-win_amd64.pyd
+Filename: mujoco_dev-2.3.8.dev554452710.dist-info/WHEEL
 Comment: 
 
-Filename: mujoco/_simulate.cp39-win_amd64.pyd
+Filename: mujoco_dev-2.3.8.dev554452710.dist-info/top_level.txt
 Comment: 
 
-Filename: mujoco/_structs.cp39-win_amd64.pyd
+Filename: mujoco/osmesa/
 Comment: 
 
-Filename: mujoco/bindings_test.py
+Filename: mujoco/include/
+Comment: 
+
+Filename: mujoco/glfw/
+Comment: 
+
+Filename: mujoco/egl/
+Comment: 
+
+Filename: mujoco/cgl/
+Comment: 
+
+Filename: mujoco/plugin/
+Comment: 
+
+Filename: mujoco/_functions.cpython-39-aarch64-linux-gnu.so
 Comment: 
 
 Filename: mujoco/gl_context.py
 Comment: 
 
-Filename: mujoco/mujoco.dll
+Filename: mujoco/viewer_test.py
+Comment: 
+
+Filename: mujoco/__init__.py
 Comment: 
 
 Filename: mujoco/render_test.py
 Comment: 
 
-Filename: mujoco/renderer.py
+Filename: mujoco/rollout.py
+Comment: 
+
+Filename: mujoco/_constants.cpython-39-aarch64-linux-gnu.so
+Comment: 
+
+Filename: mujoco/_callbacks.cpython-39-aarch64-linux-gnu.so
 Comment: 
 
 Filename: mujoco/renderer_test.py
 Comment: 
 
-Filename: mujoco/rollout.py
+Filename: mujoco/_enums.cpython-39-aarch64-linux-gnu.so
 Comment: 
 
-Filename: mujoco/rollout_test.py
+Filename: mujoco/libmujoco.so.2.3.8
 Comment: 
 
-Filename: mujoco/viewer.py
+Filename: mujoco/_render.cpython-39-aarch64-linux-gnu.so
 Comment: 
 
-Filename: mujoco/viewer_test.py
+Filename: mujoco/_rollout.cpython-39-aarch64-linux-gnu.so
 Comment: 
 
-Filename: mujoco/cgl/__init__.py
+Filename: mujoco/_errors.cpython-39-aarch64-linux-gnu.so
 Comment: 
 
-Filename: mujoco/cgl/cgl.py
+Filename: mujoco/rollout_test.py
 Comment: 
 
-Filename: mujoco/egl/__init__.py
+Filename: mujoco/viewer.py
 Comment: 
 
-Filename: mujoco/egl/egl_ext.py
+Filename: mujoco/bindings_test.py
 Comment: 
 
-Filename: mujoco/glfw/__init__.py
+Filename: mujoco/renderer.py
 Comment: 
 
-Filename: mujoco/include/mujoco/mjdata.h
+Filename: mujoco/_structs.cpython-39-aarch64-linux-gnu.so
 Comment: 
 
-Filename: mujoco/include/mujoco/mjexport.h
+Filename: mujoco/_simulate.cpython-39-aarch64-linux-gnu.so
 Comment: 
 
-Filename: mujoco/include/mujoco/mjmacro.h
+Filename: mujoco/osmesa/__init__.py
 Comment: 
 
-Filename: mujoco/include/mujoco/mjmodel.h
+Filename: mujoco/include/mujoco/
 Comment: 
 
 Filename: mujoco/include/mujoco/mjplugin.h
 Comment: 
 
-Filename: mujoco/include/mujoco/mjrender.h
+Filename: mujoco/include/mujoco/mjmacro.h
+Comment: 
+
+Filename: mujoco/include/mujoco/mjmodel.h
 Comment: 
 
 Filename: mujoco/include/mujoco/mjtnum.h
 Comment: 
 
-Filename: mujoco/include/mujoco/mjui.h
+Filename: mujoco/include/mujoco/mjexport.h
 Comment: 
 
-Filename: mujoco/include/mujoco/mjvisualize.h
+Filename: mujoco/include/mujoco/mjui.h
 Comment: 
 
 Filename: mujoco/include/mujoco/mjxmacro.h
 Comment: 
 
-Filename: mujoco/include/mujoco/mujoco.h
+Filename: mujoco/include/mujoco/mjvisualize.h
 Comment: 
 
-Filename: mujoco/osmesa/__init__.py
+Filename: mujoco/include/mujoco/mjrender.h
 Comment: 
 
-Filename: mujoco/plugin/elasticity.dll
+Filename: mujoco/include/mujoco/mujoco.h
 Comment: 
 
-Filename: mujoco/plugin/sensor.dll
+Filename: mujoco/include/mujoco/mjdata.h
 Comment: 
 
-Filename: mujoco_dev-2.3.8.dev554438423.dist-info/LICENSE
+Filename: mujoco/glfw/__init__.py
 Comment: 
 
-Filename: mujoco_dev-2.3.8.dev554438423.dist-info/LICENSES_THIRD_PARTY.md
+Filename: mujoco/egl/__init__.py
 Comment: 
 
-Filename: mujoco_dev-2.3.8.dev554438423.dist-info/METADATA
+Filename: mujoco/egl/egl_ext.py
 Comment: 
 
-Filename: mujoco_dev-2.3.8.dev554438423.dist-info/WHEEL
+Filename: mujoco/cgl/cgl.py
+Comment: 
+
+Filename: mujoco/cgl/__init__.py
 Comment: 
 
-Filename: mujoco_dev-2.3.8.dev554438423.dist-info/top_level.txt
+Filename: mujoco/plugin/libsensor.so
 Comment: 
 
-Filename: mujoco_dev-2.3.8.dev554438423.dist-info/RECORD
+Filename: mujoco/plugin/libelasticity.so
 Comment: 
 
 Zip file comment:
```

## filetype from file(1)

```diff
@@ -1 +1 @@
-Zip archive data, at least v2.0 to extract, compression method=deflate
+Zip archive data, at least v2.0 to extract, compression method=store
```

## mujoco/include/mujoco/mjdata.h

 * *Ordering differences only*

```diff
@@ -1,415 +1,415 @@
-// Copyright 2021 DeepMind Technologies Limited
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#ifndef MUJOCO_MJDATA_H_
-#define MUJOCO_MJDATA_H_
-
-#include <stddef.h>
-#include <stdint.h>
-
-#include <mujoco/mjtnum.h>
-#include <mujoco/mjmodel.h>
-
-//---------------------------------- primitive types (mjt) -----------------------------------------
-
-typedef enum mjtState_ {          // state elements
-  mjSTATE_TIME          = 1<<0,   // time
-  mjSTATE_QPOS          = 1<<1,   // position
-  mjSTATE_QVEL          = 1<<2,   // velocity
-  mjSTATE_ACT           = 1<<3,   // actuator activation
-  mjSTATE_WARMSTART     = 1<<4,   // acceleration used for warmstart
-  mjSTATE_CTRL          = 1<<5,   // control
-  mjSTATE_QFRC_APPLIED  = 1<<6,   // applied generalized force
-  mjSTATE_XFRC_APPLIED  = 1<<7,   // applied Cartesian force/torque
-  mjSTATE_MOCAP_POS     = 1<<8,   // positions of mocap bodies
-  mjSTATE_MOCAP_QUAT    = 1<<9,   // orientations of mocap bodies
-  mjSTATE_USERDATA      = 1<<10,  // user data
-  mjSTATE_PLUGIN        = 1<<11,  // plugin state
-
-  mjNSTATE              = 12,     // number of state elements
-
-  // convenience values for commonly used state specifications
-  mjSTATE_PHYSICS       = mjSTATE_QPOS | mjSTATE_QVEL | mjSTATE_ACT,
-  mjSTATE_FULLPHYSICS   = mjSTATE_PHYSICS | mjSTATE_TIME | mjSTATE_PLUGIN,
-  mjSTATE_USER          = mjSTATE_CTRL | mjSTATE_QFRC_APPLIED | mjSTATE_XFRC_APPLIED |
-                          mjSTATE_MOCAP_POS | mjSTATE_MOCAP_QUAT | mjSTATE_USERDATA,
-  mjSTATE_INTEGRATION   = mjSTATE_FULLPHYSICS | mjSTATE_USER | mjSTATE_WARMSTART
-} mjtState;
-
-
-typedef enum mjtWarning_ {   // warning types
-  mjWARN_INERTIA      = 0,   // (near) singular inertia matrix
-  mjWARN_CONTACTFULL,        // too many contacts in contact list
-  mjWARN_CNSTRFULL,          // too many constraints
-  mjWARN_VGEOMFULL,          // too many visual geoms
-  mjWARN_BADQPOS,            // bad number in qpos
-  mjWARN_BADQVEL,            // bad number in qvel
-  mjWARN_BADQACC,            // bad number in qacc
-  mjWARN_BADCTRL,            // bad number in ctrl
-
-  mjNWARNING                 // number of warnings
-} mjtWarning;
-
-
-typedef enum mjtTimer_ {     // internal timers
-  // main api
-  mjTIMER_STEP        = 0,   // step
-  mjTIMER_FORWARD,           // forward
-  mjTIMER_INVERSE,           // inverse
-
-  // breakdown of step/forward
-  mjTIMER_POSITION,          // fwdPosition
-  mjTIMER_VELOCITY,          // fwdVelocity
-  mjTIMER_ACTUATION,         // fwdActuation
-  mjTIMER_ACCELERATION,      // fwdAcceleration
-  mjTIMER_CONSTRAINT,        // fwdConstraint
-
-  // breakdown of fwdPosition
-  mjTIMER_POS_KINEMATICS,    // kinematics, com, tendon, transmission
-  mjTIMER_POS_INERTIA,       // inertia computations
-  mjTIMER_POS_COLLISION,     // collision detection
-  mjTIMER_POS_MAKE,          // make constraints
-  mjTIMER_POS_PROJECT,       // project constraints
-
-  mjNTIMER                   // number of timers
-} mjtTimer;
-
-
-//---------------------------------- mjContact -----------------------------------------------------
-
-struct mjContact_ {                // result of collision detection functions
-  // contact parameters set by geom-specific collision detector
-  mjtNum  dist;                    // distance between nearest points; neg: penetration
-  mjtNum  pos[3];                  // position of contact point: midpoint between geoms
-  mjtNum  frame[9];                // normal is in [0-2]
-
-  // contact parameters set by mj_collideGeoms
-  mjtNum  includemargin;           // include if dist<includemargin=margin-gap
-  mjtNum  friction[5];             // tangent1, 2, spin, roll1, 2
-  mjtNum  solref[mjNREF];          // constraint solver reference, normal direction
-  mjtNum  solreffriction[mjNREF];  // constraint solver reference, friction directions
-  mjtNum  solimp[mjNIMP];          // constraint solver impedance
-
-  // internal storage used by solver
-  mjtNum  mu;                      // friction of regularized cone, set by mj_makeConstraint
-  mjtNum  H[36];                   // cone Hessian, set by mj_updateConstraint
-
-  // contact descriptors set by mj_collideGeoms
-  int     dim;                     // contact space dimensionality: 1, 3, 4 or 6
-  int     geom1;                   // id of geom 1
-  int     geom2;                   // id of geom 2
-
-  // flag set by mj_instantianteEquality
-  int     exclude;                 // 0: include, 1: in gap, 2: fused, 3: no dofs
-
-  // address computed by mj_instantiateContact
-  int     efc_address;             // address in efc; -1: not included
-};
-typedef struct mjContact_ mjContact;
-
-
-//---------------------------------- diagnostics ---------------------------------------------------
-
-struct mjWarningStat_ {      // warning statistics
-  int     lastinfo;          // info from last warning
-  int     number;            // how many times was warning raised
-};
-typedef struct mjWarningStat_ mjWarningStat;
-
-
-struct mjTimerStat_ {        // timer statistics
-  mjtNum  duration;          // cumulative duration
-  int     number;            // how many times was timer called
-};
-typedef struct mjTimerStat_ mjTimerStat;
-
-
-struct mjSolverStat_ {       // per-iteration solver statistics
-  mjtNum  improvement;       // cost reduction, scaled by 1/trace(M(qpos0))
-  mjtNum  gradient;          // gradient norm (primal only, scaled)
-  mjtNum  lineslope;         // slope in linesearch
-  int     nactive;           // number of active constraints
-  int     nchange;           // number of constraint state changes
-  int     neval;             // number of cost evaluations in line search
-  int     nupdate;           // number of Cholesky updates in line search
-};
-typedef struct mjSolverStat_ mjSolverStat;
-
-
-//---------------------------------- mjData --------------------------------------------------------
-
-struct mjData_ {
-  // constant sizes
-  int     nstack;            // number of mjtNums that can fit in the arena+stack space
-  int     nbuffer;           // size of main buffer in bytes
-  int     nplugin;           // number of plugin instances
-
-  // stack pointer
-  size_t  pstack;            // first available mjtNum address in stack
-
-  // arena pointer
-  size_t  parena;            // first available byte in arena
-
-  // memory utilization stats
-  int     maxuse_stack;      // maximum stack allocation
-  size_t  maxuse_arena;      // maximum arena allocation
-  int     maxuse_con;        // maximum number of contacts
-  int     maxuse_efc;        // maximum number of scalar constraints
-
-  // diagnostics
-  mjWarningStat warning[mjNWARNING];  // warning statistics
-  mjTimerStat   timer[mjNTIMER];      // timer statistics
-
-  // solver statistics
-  mjSolverStat  solver[mjNSOLVER];  // solver statistics per iteration
-  int     solver_iter;              // number of solver iterations
-  int     solver_nnz;               // number of non-zeros in Hessian or efc_AR
-  mjtNum  solver_fwdinv[2];         // forward-inverse comparison: qfrc, efc
-
-  // collision statistics
-  int     nbodypair_broad;   // number of body pairs in collision according to the broad-phase
-  int     nbodypair_narrow;  // number of body pairs actually in collision in the narrow-phase
-  int     ngeompair_mid;     // number of geom pairs in collision according to the mid-phase
-  int     ngeompair_narrow;  // number of geom pairs actually in collision in the narrow-phase
-
-  // variable sizes
-  int     ne;                // number of equality constraints
-  int     nf;                // number of friction constraints
-  int     nefc;              // number of constraints
-  int     nnzJ;              // number of non-zeros in constraint Jacobian
-  int     ncon;              // number of detected contacts
-
-  // global properties
-  mjtNum  time;              // simulation time
-  mjtNum  energy[2];         // potential, kinetic energy
-
-  //-------------------- end of info header
-
-  // buffers
-  void*   buffer;            // main buffer; all pointers point in it                (nbuffer bytes)
-  void*   arena;             // arena+stack buffer                     (nstack*sizeof(mjtNum) bytes)
-
-  //-------------------- main inputs and outputs of the computation
-
-  // state
-  mjtNum* qpos;              // position                                         (nq x 1)
-  mjtNum* qvel;              // velocity                                         (nv x 1)
-  mjtNum* act;               // actuator activation                              (na x 1)
-  mjtNum* qacc_warmstart;    // acceleration used for warmstart                  (nv x 1)
-  mjtNum* plugin_state;      // plugin state                                     (npluginstate x 1)
-
-  // control
-  mjtNum* ctrl;              // control                                          (nu x 1)
-  mjtNum* qfrc_applied;      // applied generalized force                        (nv x 1)
-  mjtNum* xfrc_applied;      // applied Cartesian force/torque                   (nbody x 6)
-
-  // mocap data
-  mjtNum* mocap_pos;         // positions of mocap bodies                        (nmocap x 3)
-  mjtNum* mocap_quat;        // orientations of mocap bodies                     (nmocap x 4)
-
-  // dynamics
-  mjtNum* qacc;              // acceleration                                     (nv x 1)
-  mjtNum* act_dot;           // time-derivative of actuator activation           (na x 1)
-
-  // user data
-  mjtNum* userdata;          // user data, not touched by engine                 (nuserdata x 1)
-
-  // sensors
-  mjtNum* sensordata;        // sensor data array                                (nsensordata x 1)
-
-  // plugins
-  int*        plugin;        // copy of m->plugin, required for deletion         (nplugin x 1)
-  uintptr_t*  plugin_data;   // pointer to plugin-managed data structure         (nplugin x 1)
-
-  //-------------------- POSITION dependent
-
-  // computed by mj_fwdPosition/mj_kinematics
-  mjtNum* xpos;              // Cartesian position of body frame                 (nbody x 3)
-  mjtNum* xquat;             // Cartesian orientation of body frame              (nbody x 4)
-  mjtNum* xmat;              // Cartesian orientation of body frame              (nbody x 9)
-  mjtNum* xipos;             // Cartesian position of body com                   (nbody x 3)
-  mjtNum* ximat;             // Cartesian orientation of body inertia            (nbody x 9)
-  mjtNum* xanchor;           // Cartesian position of joint anchor               (njnt x 3)
-  mjtNum* xaxis;             // Cartesian joint axis                             (njnt x 3)
-  mjtNum* geom_xpos;         // Cartesian geom position                          (ngeom x 3)
-  mjtNum* geom_xmat;         // Cartesian geom orientation                       (ngeom x 9)
-  mjtNum* site_xpos;         // Cartesian site position                          (nsite x 3)
-  mjtNum* site_xmat;         // Cartesian site orientation                       (nsite x 9)
-  mjtNum* cam_xpos;          // Cartesian camera position                        (ncam x 3)
-  mjtNum* cam_xmat;          // Cartesian camera orientation                     (ncam x 9)
-  mjtNum* light_xpos;        // Cartesian light position                         (nlight x 3)
-  mjtNum* light_xdir;        // Cartesian light direction                        (nlight x 3)
-
-  // computed by mj_fwdPosition/mj_comPos
-  mjtNum* subtree_com;       // center of mass of each subtree                   (nbody x 3)
-  mjtNum* cdof;              // com-based motion axis of each dof                (nv x 6)
-  mjtNum* cinert;            // com-based body inertia and mass                  (nbody x 10)
-
-  // computed by mj_fwdPosition/mj_tendon
-  int*    ten_wrapadr;       // start address of tendon's path                   (ntendon x 1)
-  int*    ten_wrapnum;       // number of wrap points in path                    (ntendon x 1)
-  int*    ten_J_rownnz;      // number of non-zeros in Jacobian row              (ntendon x 1)
-  int*    ten_J_rowadr;      // row start address in colind array                (ntendon x 1)
-  int*    ten_J_colind;      // column indices in sparse Jacobian                (ntendon x nv)
-  mjtNum* ten_length;        // tendon lengths                                   (ntendon x 1)
-  mjtNum* ten_J;             // tendon Jacobian                                  (ntendon x nv)
-  int*    wrap_obj;          // geom id; -1: site; -2: pulley                    (nwrap*2 x 1)
-  mjtNum* wrap_xpos;         // Cartesian 3D points in all path                  (nwrap*2 x 3)
-
-  // computed by mj_fwdPosition/mj_transmission
-  mjtNum* actuator_length;   // actuator lengths                                 (nu x 1)
-  mjtNum* actuator_moment;   // actuator moments                                 (nu x nv)
-
-  // computed by mj_fwdPosition/mj_crb
-  mjtNum* crb;               // com-based composite inertia and mass             (nbody x 10)
-  mjtNum* qM;                // total inertia (sparse)                           (nM x 1)
-
-  // computed by mj_fwdPosition/mj_factorM
-  mjtNum* qLD;               // L'*D*L factorization of M (sparse)               (nM x 1)
-  mjtNum* qLDiagInv;         // 1/diag(D)                                        (nv x 1)
-  mjtNum* qLDiagSqrtInv;     // 1/sqrt(diag(D))                                  (nv x 1)
-
-  // computed by mj_collisionTree
-  mjtByte* bvh_active;       // volume has been added to collisions              (nbvh x 1)
-
-  //-------------------- POSITION, VELOCITY dependent
-
-  // computed by mj_fwdVelocity
-  mjtNum* ten_velocity;      // tendon velocities                                (ntendon x 1)
-  mjtNum* actuator_velocity; // actuator velocities                              (nu x 1)
-
-  // computed by mj_fwdVelocity/mj_comVel
-  mjtNum* cvel;              // com-based velocity [3D rot; 3D tran]             (nbody x 6)
-  mjtNum* cdof_dot;          // time-derivative of cdof                          (nv x 6)
-
-  // computed by mj_fwdVelocity/mj_rne (without acceleration)
-  mjtNum* qfrc_bias;         // C(qpos,qvel)                                     (nv x 1)
-
-  // computed by mj_fwdVelocity/mj_passive
-  mjtNum* qfrc_passive;      // passive force                                    (nv x 1)
-
-  // computed by mj_sensorVel/mj_subtreeVel if needed
-  mjtNum* subtree_linvel;    // linear velocity of subtree com                   (nbody x 3)
-  mjtNum* subtree_angmom;    // angular momentum about subtree com               (nbody x 3)
-
-  // computed by mj_Euler or mj_implicit
-  mjtNum*   qH;              // L'*D*L factorization of modified M               (nM x 1)
-  mjtNum*   qHDiagInv;       // 1/diag(D) of modified M                          (nv x 1)
-
-  // computed by mj_resetData
-  int*    D_rownnz;          // non-zeros in each row                            (nv x 1)
-  int*    D_rowadr;          // address of each row in D_colind                  (nv x 1)
-  int*    D_colind;          // column indices of non-zeros                      (nD x 1)
-  int*    B_rownnz;          // non-zeros in each row                            (nbody x 1)
-  int*    B_rowadr;          // address of each row in B_colind                  (nbody x 1)
-  int*    B_colind;          // column indices of non-zeros                      (nB x 1)
-
-  // computed by mj_implicit/mj_derivative
-  mjtNum* qDeriv;            // d (passive + actuator - bias) / d qvel           (nD x 1)
-
-  // computed by mj_implicit/mju_factorLUSparse
-  mjtNum* qLU;               // sparse LU of (qM - dt*qDeriv)                    (nD x 1)
-
-  //-------------------- POSITION, VELOCITY, CONTROL/ACCELERATION dependent
-
-  // computed by mj_fwdActuation
-  mjtNum* actuator_force;    // actuator force in actuation space                (nu x 1)
-  mjtNum* qfrc_actuator;     // actuator force                                   (nv x 1)
-
-  // computed by mj_fwdAcceleration
-  mjtNum* qfrc_smooth;       // net unconstrained force                          (nv x 1)
-  mjtNum* qacc_smooth;       // unconstrained acceleration                       (nv x 1)
-
-  // computed by mj_fwdConstraint/mj_inverse
-  mjtNum* qfrc_constraint;   // constraint force                                 (nv x 1)
-
-  // computed by mj_inverse
-  mjtNum* qfrc_inverse;      // net external force; should equal:                (nv x 1)
-                             // qfrc_applied + J'*xfrc_applied + qfrc_actuator
-
-  // computed by mj_sensorAcc/mj_rnePostConstraint if needed; rotation:translation format
-  mjtNum* cacc;              // com-based acceleration                           (nbody x 6)
-  mjtNum* cfrc_int;          // com-based interaction force with parent          (nbody x 6)
-  mjtNum* cfrc_ext;          // com-based external force on body                 (nbody x 6)
-
-  //-------------------- arena-allocated: POSITION dependent
-
-  // computed by mj_collision
-  mjContact* contact;        // list of all detected contacts                    (ncon x 1)
-
-  // computed by mj_makeConstraint
-  int*    efc_type;          // constraint type (mjtConstraint)                  (nefc x 1)
-  int*    efc_id;            // id of object of specified type                   (nefc x 1)
-  int*    efc_J_rownnz;      // number of non-zeros in constraint Jacobian row   (nefc x 1)
-  int*    efc_J_rowadr;      // row start address in colind array                (nefc x 1)
-  int*    efc_J_rowsuper;    // number of subsequent rows in supernode           (nefc x 1)
-  int*    efc_J_colind;      // column indices in constraint Jacobian            (nnzJ x 1)
-  int*    efc_JT_rownnz;     // number of non-zeros in constraint Jacobian row T (nv x 1)
-  int*    efc_JT_rowadr;     // row start address in colind array              T (nv x 1)
-  int*    efc_JT_rowsuper;   // number of subsequent rows in supernode         T (nv x 1)
-  int*    efc_JT_colind;     // column indices in constraint Jacobian          T (nnzJ x 1)
-  mjtNum* efc_J;             // constraint Jacobian                              (nnzJ x 1)
-  mjtNum* efc_JT;            // constraint Jacobian transposed                   (nnzJ x 1)
-  mjtNum* efc_pos;           // constraint position (equality, contact)          (nefc x 1)
-  mjtNum* efc_margin;        // inclusion margin (contact)                       (nefc x 1)
-  mjtNum* efc_frictionloss;  // frictionloss (friction)                          (nefc x 1)
-  mjtNum* efc_diagApprox;    // approximation to diagonal of A                   (nefc x 1)
-  mjtNum* efc_KBIP;          // stiffness, damping, impedance, imp'              (nefc x 4)
-  mjtNum* efc_D;             // constraint mass                                  (nefc x 1)
-  mjtNum* efc_R;             // inverse constraint mass                          (nefc x 1)
-
-  // computed by mj_projectConstraint (dual solver)
-  int*    efc_AR_rownnz;     // number of non-zeros in AR                        (nefc x 1)
-  int*    efc_AR_rowadr;     // row start address in colind array                (nefc x 1)
-  int*    efc_AR_colind;     // column indices in sparse AR                      (nefc x nefc)
-  mjtNum* efc_AR;            // J*inv(M)*J' + R                                  (nefc x nefc)
-
-  //-------------------- arena-allocated: POSITION, VELOCITY dependent
-
-  // computed by mj_fwdVelocity/mj_referenceConstraint
-  mjtNum* efc_vel;           // velocity in constraint space: J*qvel             (nefc x 1)
-  mjtNum* efc_aref;          // reference pseudo-acceleration                    (nefc x 1)
-
-  //-------------------- arena-allocated: POSITION, VELOCITY, CONTROL/ACCELERATION dependent
-
-  // computed by mj_fwdConstraint/mj_inverse
-  mjtNum* efc_b;            // linear cost term: J*qacc_smooth - aref            (nefc x 1)
-  mjtNum* efc_force;        // constraint force in constraint space              (nefc x 1)
-  int*    efc_state;        // constraint state (mjtConstraintState)             (nefc x 1)
-};
-typedef struct mjData_ mjData;
-
-
-//---------------------------------- callback function types ---------------------------------------
-
-// generic MuJoCo function
-typedef void (*mjfGeneric)(const mjModel* m, mjData* d);
-
-// contact filter: 1- discard, 0- collide
-typedef int (*mjfConFilt)(const mjModel* m, mjData* d, int geom1, int geom2);
-
-// sensor simulation
-typedef void (*mjfSensor)(const mjModel* m, mjData* d, int stage);
-
-// timer
-typedef mjtNum (*mjfTime)(void);
-
-// actuator dynamics, gain, bias
-typedef mjtNum (*mjfAct)(const mjModel* m, const mjData* d, int id);
-
-// collision detection
-typedef int (*mjfCollision)(const mjModel* m, const mjData* d,
-                            mjContact* con, int g1, int g2, mjtNum margin);
-
-#endif  // MUJOCO_MJDATA_H_
+// Copyright 2021 DeepMind Technologies Limited
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef MUJOCO_MJDATA_H_
+#define MUJOCO_MJDATA_H_
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <mujoco/mjtnum.h>
+#include <mujoco/mjmodel.h>
+
+//---------------------------------- primitive types (mjt) -----------------------------------------
+
+typedef enum mjtState_ {          // state elements
+  mjSTATE_TIME          = 1<<0,   // time
+  mjSTATE_QPOS          = 1<<1,   // position
+  mjSTATE_QVEL          = 1<<2,   // velocity
+  mjSTATE_ACT           = 1<<3,   // actuator activation
+  mjSTATE_WARMSTART     = 1<<4,   // acceleration used for warmstart
+  mjSTATE_CTRL          = 1<<5,   // control
+  mjSTATE_QFRC_APPLIED  = 1<<6,   // applied generalized force
+  mjSTATE_XFRC_APPLIED  = 1<<7,   // applied Cartesian force/torque
+  mjSTATE_MOCAP_POS     = 1<<8,   // positions of mocap bodies
+  mjSTATE_MOCAP_QUAT    = 1<<9,   // orientations of mocap bodies
+  mjSTATE_USERDATA      = 1<<10,  // user data
+  mjSTATE_PLUGIN        = 1<<11,  // plugin state
+
+  mjNSTATE              = 12,     // number of state elements
+
+  // convenience values for commonly used state specifications
+  mjSTATE_PHYSICS       = mjSTATE_QPOS | mjSTATE_QVEL | mjSTATE_ACT,
+  mjSTATE_FULLPHYSICS   = mjSTATE_PHYSICS | mjSTATE_TIME | mjSTATE_PLUGIN,
+  mjSTATE_USER          = mjSTATE_CTRL | mjSTATE_QFRC_APPLIED | mjSTATE_XFRC_APPLIED |
+                          mjSTATE_MOCAP_POS | mjSTATE_MOCAP_QUAT | mjSTATE_USERDATA,
+  mjSTATE_INTEGRATION   = mjSTATE_FULLPHYSICS | mjSTATE_USER | mjSTATE_WARMSTART
+} mjtState;
+
+
+typedef enum mjtWarning_ {   // warning types
+  mjWARN_INERTIA      = 0,   // (near) singular inertia matrix
+  mjWARN_CONTACTFULL,        // too many contacts in contact list
+  mjWARN_CNSTRFULL,          // too many constraints
+  mjWARN_VGEOMFULL,          // too many visual geoms
+  mjWARN_BADQPOS,            // bad number in qpos
+  mjWARN_BADQVEL,            // bad number in qvel
+  mjWARN_BADQACC,            // bad number in qacc
+  mjWARN_BADCTRL,            // bad number in ctrl
+
+  mjNWARNING                 // number of warnings
+} mjtWarning;
+
+
+typedef enum mjtTimer_ {     // internal timers
+  // main api
+  mjTIMER_STEP        = 0,   // step
+  mjTIMER_FORWARD,           // forward
+  mjTIMER_INVERSE,           // inverse
+
+  // breakdown of step/forward
+  mjTIMER_POSITION,          // fwdPosition
+  mjTIMER_VELOCITY,          // fwdVelocity
+  mjTIMER_ACTUATION,         // fwdActuation
+  mjTIMER_ACCELERATION,      // fwdAcceleration
+  mjTIMER_CONSTRAINT,        // fwdConstraint
+
+  // breakdown of fwdPosition
+  mjTIMER_POS_KINEMATICS,    // kinematics, com, tendon, transmission
+  mjTIMER_POS_INERTIA,       // inertia computations
+  mjTIMER_POS_COLLISION,     // collision detection
+  mjTIMER_POS_MAKE,          // make constraints
+  mjTIMER_POS_PROJECT,       // project constraints
+
+  mjNTIMER                   // number of timers
+} mjtTimer;
+
+
+//---------------------------------- mjContact -----------------------------------------------------
+
+struct mjContact_ {                // result of collision detection functions
+  // contact parameters set by geom-specific collision detector
+  mjtNum  dist;                    // distance between nearest points; neg: penetration
+  mjtNum  pos[3];                  // position of contact point: midpoint between geoms
+  mjtNum  frame[9];                // normal is in [0-2]
+
+  // contact parameters set by mj_collideGeoms
+  mjtNum  includemargin;           // include if dist<includemargin=margin-gap
+  mjtNum  friction[5];             // tangent1, 2, spin, roll1, 2
+  mjtNum  solref[mjNREF];          // constraint solver reference, normal direction
+  mjtNum  solreffriction[mjNREF];  // constraint solver reference, friction directions
+  mjtNum  solimp[mjNIMP];          // constraint solver impedance
+
+  // internal storage used by solver
+  mjtNum  mu;                      // friction of regularized cone, set by mj_makeConstraint
+  mjtNum  H[36];                   // cone Hessian, set by mj_updateConstraint
+
+  // contact descriptors set by mj_collideGeoms
+  int     dim;                     // contact space dimensionality: 1, 3, 4 or 6
+  int     geom1;                   // id of geom 1
+  int     geom2;                   // id of geom 2
+
+  // flag set by mj_instantianteEquality
+  int     exclude;                 // 0: include, 1: in gap, 2: fused, 3: no dofs
+
+  // address computed by mj_instantiateContact
+  int     efc_address;             // address in efc; -1: not included
+};
+typedef struct mjContact_ mjContact;
+
+
+//---------------------------------- diagnostics ---------------------------------------------------
+
+struct mjWarningStat_ {      // warning statistics
+  int     lastinfo;          // info from last warning
+  int     number;            // how many times was warning raised
+};
+typedef struct mjWarningStat_ mjWarningStat;
+
+
+struct mjTimerStat_ {        // timer statistics
+  mjtNum  duration;          // cumulative duration
+  int     number;            // how many times was timer called
+};
+typedef struct mjTimerStat_ mjTimerStat;
+
+
+struct mjSolverStat_ {       // per-iteration solver statistics
+  mjtNum  improvement;       // cost reduction, scaled by 1/trace(M(qpos0))
+  mjtNum  gradient;          // gradient norm (primal only, scaled)
+  mjtNum  lineslope;         // slope in linesearch
+  int     nactive;           // number of active constraints
+  int     nchange;           // number of constraint state changes
+  int     neval;             // number of cost evaluations in line search
+  int     nupdate;           // number of Cholesky updates in line search
+};
+typedef struct mjSolverStat_ mjSolverStat;
+
+
+//---------------------------------- mjData --------------------------------------------------------
+
+struct mjData_ {
+  // constant sizes
+  int     nstack;            // number of mjtNums that can fit in the arena+stack space
+  int     nbuffer;           // size of main buffer in bytes
+  int     nplugin;           // number of plugin instances
+
+  // stack pointer
+  size_t  pstack;            // first available mjtNum address in stack
+
+  // arena pointer
+  size_t  parena;            // first available byte in arena
+
+  // memory utilization stats
+  int     maxuse_stack;      // maximum stack allocation
+  size_t  maxuse_arena;      // maximum arena allocation
+  int     maxuse_con;        // maximum number of contacts
+  int     maxuse_efc;        // maximum number of scalar constraints
+
+  // diagnostics
+  mjWarningStat warning[mjNWARNING];  // warning statistics
+  mjTimerStat   timer[mjNTIMER];      // timer statistics
+
+  // solver statistics
+  mjSolverStat  solver[mjNSOLVER];  // solver statistics per iteration
+  int     solver_iter;              // number of solver iterations
+  int     solver_nnz;               // number of non-zeros in Hessian or efc_AR
+  mjtNum  solver_fwdinv[2];         // forward-inverse comparison: qfrc, efc
+
+  // collision statistics
+  int     nbodypair_broad;   // number of body pairs in collision according to the broad-phase
+  int     nbodypair_narrow;  // number of body pairs actually in collision in the narrow-phase
+  int     ngeompair_mid;     // number of geom pairs in collision according to the mid-phase
+  int     ngeompair_narrow;  // number of geom pairs actually in collision in the narrow-phase
+
+  // variable sizes
+  int     ne;                // number of equality constraints
+  int     nf;                // number of friction constraints
+  int     nefc;              // number of constraints
+  int     nnzJ;              // number of non-zeros in constraint Jacobian
+  int     ncon;              // number of detected contacts
+
+  // global properties
+  mjtNum  time;              // simulation time
+  mjtNum  energy[2];         // potential, kinetic energy
+
+  //-------------------- end of info header
+
+  // buffers
+  void*   buffer;            // main buffer; all pointers point in it                (nbuffer bytes)
+  void*   arena;             // arena+stack buffer                     (nstack*sizeof(mjtNum) bytes)
+
+  //-------------------- main inputs and outputs of the computation
+
+  // state
+  mjtNum* qpos;              // position                                         (nq x 1)
+  mjtNum* qvel;              // velocity                                         (nv x 1)
+  mjtNum* act;               // actuator activation                              (na x 1)
+  mjtNum* qacc_warmstart;    // acceleration used for warmstart                  (nv x 1)
+  mjtNum* plugin_state;      // plugin state                                     (npluginstate x 1)
+
+  // control
+  mjtNum* ctrl;              // control                                          (nu x 1)
+  mjtNum* qfrc_applied;      // applied generalized force                        (nv x 1)
+  mjtNum* xfrc_applied;      // applied Cartesian force/torque                   (nbody x 6)
+
+  // mocap data
+  mjtNum* mocap_pos;         // positions of mocap bodies                        (nmocap x 3)
+  mjtNum* mocap_quat;        // orientations of mocap bodies                     (nmocap x 4)
+
+  // dynamics
+  mjtNum* qacc;              // acceleration                                     (nv x 1)
+  mjtNum* act_dot;           // time-derivative of actuator activation           (na x 1)
+
+  // user data
+  mjtNum* userdata;          // user data, not touched by engine                 (nuserdata x 1)
+
+  // sensors
+  mjtNum* sensordata;        // sensor data array                                (nsensordata x 1)
+
+  // plugins
+  int*        plugin;        // copy of m->plugin, required for deletion         (nplugin x 1)
+  uintptr_t*  plugin_data;   // pointer to plugin-managed data structure         (nplugin x 1)
+
+  //-------------------- POSITION dependent
+
+  // computed by mj_fwdPosition/mj_kinematics
+  mjtNum* xpos;              // Cartesian position of body frame                 (nbody x 3)
+  mjtNum* xquat;             // Cartesian orientation of body frame              (nbody x 4)
+  mjtNum* xmat;              // Cartesian orientation of body frame              (nbody x 9)
+  mjtNum* xipos;             // Cartesian position of body com                   (nbody x 3)
+  mjtNum* ximat;             // Cartesian orientation of body inertia            (nbody x 9)
+  mjtNum* xanchor;           // Cartesian position of joint anchor               (njnt x 3)
+  mjtNum* xaxis;             // Cartesian joint axis                             (njnt x 3)
+  mjtNum* geom_xpos;         // Cartesian geom position                          (ngeom x 3)
+  mjtNum* geom_xmat;         // Cartesian geom orientation                       (ngeom x 9)
+  mjtNum* site_xpos;         // Cartesian site position                          (nsite x 3)
+  mjtNum* site_xmat;         // Cartesian site orientation                       (nsite x 9)
+  mjtNum* cam_xpos;          // Cartesian camera position                        (ncam x 3)
+  mjtNum* cam_xmat;          // Cartesian camera orientation                     (ncam x 9)
+  mjtNum* light_xpos;        // Cartesian light position                         (nlight x 3)
+  mjtNum* light_xdir;        // Cartesian light direction                        (nlight x 3)
+
+  // computed by mj_fwdPosition/mj_comPos
+  mjtNum* subtree_com;       // center of mass of each subtree                   (nbody x 3)
+  mjtNum* cdof;              // com-based motion axis of each dof                (nv x 6)
+  mjtNum* cinert;            // com-based body inertia and mass                  (nbody x 10)
+
+  // computed by mj_fwdPosition/mj_tendon
+  int*    ten_wrapadr;       // start address of tendon's path                   (ntendon x 1)
+  int*    ten_wrapnum;       // number of wrap points in path                    (ntendon x 1)
+  int*    ten_J_rownnz;      // number of non-zeros in Jacobian row              (ntendon x 1)
+  int*    ten_J_rowadr;      // row start address in colind array                (ntendon x 1)
+  int*    ten_J_colind;      // column indices in sparse Jacobian                (ntendon x nv)
+  mjtNum* ten_length;        // tendon lengths                                   (ntendon x 1)
+  mjtNum* ten_J;             // tendon Jacobian                                  (ntendon x nv)
+  int*    wrap_obj;          // geom id; -1: site; -2: pulley                    (nwrap*2 x 1)
+  mjtNum* wrap_xpos;         // Cartesian 3D points in all path                  (nwrap*2 x 3)
+
+  // computed by mj_fwdPosition/mj_transmission
+  mjtNum* actuator_length;   // actuator lengths                                 (nu x 1)
+  mjtNum* actuator_moment;   // actuator moments                                 (nu x nv)
+
+  // computed by mj_fwdPosition/mj_crb
+  mjtNum* crb;               // com-based composite inertia and mass             (nbody x 10)
+  mjtNum* qM;                // total inertia (sparse)                           (nM x 1)
+
+  // computed by mj_fwdPosition/mj_factorM
+  mjtNum* qLD;               // L'*D*L factorization of M (sparse)               (nM x 1)
+  mjtNum* qLDiagInv;         // 1/diag(D)                                        (nv x 1)
+  mjtNum* qLDiagSqrtInv;     // 1/sqrt(diag(D))                                  (nv x 1)
+
+  // computed by mj_collisionTree
+  mjtByte* bvh_active;       // volume has been added to collisions              (nbvh x 1)
+
+  //-------------------- POSITION, VELOCITY dependent
+
+  // computed by mj_fwdVelocity
+  mjtNum* ten_velocity;      // tendon velocities                                (ntendon x 1)
+  mjtNum* actuator_velocity; // actuator velocities                              (nu x 1)
+
+  // computed by mj_fwdVelocity/mj_comVel
+  mjtNum* cvel;              // com-based velocity [3D rot; 3D tran]             (nbody x 6)
+  mjtNum* cdof_dot;          // time-derivative of cdof                          (nv x 6)
+
+  // computed by mj_fwdVelocity/mj_rne (without acceleration)
+  mjtNum* qfrc_bias;         // C(qpos,qvel)                                     (nv x 1)
+
+  // computed by mj_fwdVelocity/mj_passive
+  mjtNum* qfrc_passive;      // passive force                                    (nv x 1)
+
+  // computed by mj_sensorVel/mj_subtreeVel if needed
+  mjtNum* subtree_linvel;    // linear velocity of subtree com                   (nbody x 3)
+  mjtNum* subtree_angmom;    // angular momentum about subtree com               (nbody x 3)
+
+  // computed by mj_Euler or mj_implicit
+  mjtNum*   qH;              // L'*D*L factorization of modified M               (nM x 1)
+  mjtNum*   qHDiagInv;       // 1/diag(D) of modified M                          (nv x 1)
+
+  // computed by mj_resetData
+  int*    D_rownnz;          // non-zeros in each row                            (nv x 1)
+  int*    D_rowadr;          // address of each row in D_colind                  (nv x 1)
+  int*    D_colind;          // column indices of non-zeros                      (nD x 1)
+  int*    B_rownnz;          // non-zeros in each row                            (nbody x 1)
+  int*    B_rowadr;          // address of each row in B_colind                  (nbody x 1)
+  int*    B_colind;          // column indices of non-zeros                      (nB x 1)
+
+  // computed by mj_implicit/mj_derivative
+  mjtNum* qDeriv;            // d (passive + actuator - bias) / d qvel           (nD x 1)
+
+  // computed by mj_implicit/mju_factorLUSparse
+  mjtNum* qLU;               // sparse LU of (qM - dt*qDeriv)                    (nD x 1)
+
+  //-------------------- POSITION, VELOCITY, CONTROL/ACCELERATION dependent
+
+  // computed by mj_fwdActuation
+  mjtNum* actuator_force;    // actuator force in actuation space                (nu x 1)
+  mjtNum* qfrc_actuator;     // actuator force                                   (nv x 1)
+
+  // computed by mj_fwdAcceleration
+  mjtNum* qfrc_smooth;       // net unconstrained force                          (nv x 1)
+  mjtNum* qacc_smooth;       // unconstrained acceleration                       (nv x 1)
+
+  // computed by mj_fwdConstraint/mj_inverse
+  mjtNum* qfrc_constraint;   // constraint force                                 (nv x 1)
+
+  // computed by mj_inverse
+  mjtNum* qfrc_inverse;      // net external force; should equal:                (nv x 1)
+                             // qfrc_applied + J'*xfrc_applied + qfrc_actuator
+
+  // computed by mj_sensorAcc/mj_rnePostConstraint if needed; rotation:translation format
+  mjtNum* cacc;              // com-based acceleration                           (nbody x 6)
+  mjtNum* cfrc_int;          // com-based interaction force with parent          (nbody x 6)
+  mjtNum* cfrc_ext;          // com-based external force on body                 (nbody x 6)
+
+  //-------------------- arena-allocated: POSITION dependent
+
+  // computed by mj_collision
+  mjContact* contact;        // list of all detected contacts                    (ncon x 1)
+
+  // computed by mj_makeConstraint
+  int*    efc_type;          // constraint type (mjtConstraint)                  (nefc x 1)
+  int*    efc_id;            // id of object of specified type                   (nefc x 1)
+  int*    efc_J_rownnz;      // number of non-zeros in constraint Jacobian row   (nefc x 1)
+  int*    efc_J_rowadr;      // row start address in colind array                (nefc x 1)
+  int*    efc_J_rowsuper;    // number of subsequent rows in supernode           (nefc x 1)
+  int*    efc_J_colind;      // column indices in constraint Jacobian            (nnzJ x 1)
+  int*    efc_JT_rownnz;     // number of non-zeros in constraint Jacobian row T (nv x 1)
+  int*    efc_JT_rowadr;     // row start address in colind array              T (nv x 1)
+  int*    efc_JT_rowsuper;   // number of subsequent rows in supernode         T (nv x 1)
+  int*    efc_JT_colind;     // column indices in constraint Jacobian          T (nnzJ x 1)
+  mjtNum* efc_J;             // constraint Jacobian                              (nnzJ x 1)
+  mjtNum* efc_JT;            // constraint Jacobian transposed                   (nnzJ x 1)
+  mjtNum* efc_pos;           // constraint position (equality, contact)          (nefc x 1)
+  mjtNum* efc_margin;        // inclusion margin (contact)                       (nefc x 1)
+  mjtNum* efc_frictionloss;  // frictionloss (friction)                          (nefc x 1)
+  mjtNum* efc_diagApprox;    // approximation to diagonal of A                   (nefc x 1)
+  mjtNum* efc_KBIP;          // stiffness, damping, impedance, imp'              (nefc x 4)
+  mjtNum* efc_D;             // constraint mass                                  (nefc x 1)
+  mjtNum* efc_R;             // inverse constraint mass                          (nefc x 1)
+
+  // computed by mj_projectConstraint (dual solver)
+  int*    efc_AR_rownnz;     // number of non-zeros in AR                        (nefc x 1)
+  int*    efc_AR_rowadr;     // row start address in colind array                (nefc x 1)
+  int*    efc_AR_colind;     // column indices in sparse AR                      (nefc x nefc)
+  mjtNum* efc_AR;            // J*inv(M)*J' + R                                  (nefc x nefc)
+
+  //-------------------- arena-allocated: POSITION, VELOCITY dependent
+
+  // computed by mj_fwdVelocity/mj_referenceConstraint
+  mjtNum* efc_vel;           // velocity in constraint space: J*qvel             (nefc x 1)
+  mjtNum* efc_aref;          // reference pseudo-acceleration                    (nefc x 1)
+
+  //-------------------- arena-allocated: POSITION, VELOCITY, CONTROL/ACCELERATION dependent
+
+  // computed by mj_fwdConstraint/mj_inverse
+  mjtNum* efc_b;            // linear cost term: J*qacc_smooth - aref            (nefc x 1)
+  mjtNum* efc_force;        // constraint force in constraint space              (nefc x 1)
+  int*    efc_state;        // constraint state (mjtConstraintState)             (nefc x 1)
+};
+typedef struct mjData_ mjData;
+
+
+//---------------------------------- callback function types ---------------------------------------
+
+// generic MuJoCo function
+typedef void (*mjfGeneric)(const mjModel* m, mjData* d);
+
+// contact filter: 1- discard, 0- collide
+typedef int (*mjfConFilt)(const mjModel* m, mjData* d, int geom1, int geom2);
+
+// sensor simulation
+typedef void (*mjfSensor)(const mjModel* m, mjData* d, int stage);
+
+// timer
+typedef mjtNum (*mjfTime)(void);
+
+// actuator dynamics, gain, bias
+typedef mjtNum (*mjfAct)(const mjModel* m, const mjData* d, int id);
+
+// collision detection
+typedef int (*mjfCollision)(const mjModel* m, const mjData* d,
+                            mjContact* con, int g1, int g2, mjtNum margin);
+
+#endif  // MUJOCO_MJDATA_H_
```

## mujoco/include/mujoco/mjexport.h

 * *Ordering differences only*

```diff
@@ -1,47 +1,47 @@
-// Copyright 2021 DeepMind Technologies Limited
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#ifndef MUJOCO_MJEXPORT_H_
-#define MUJOCO_MJEXPORT_H_
-
-#if defined _WIN32 || defined __CYGWIN__
-  #define MUJOCO_HELPER_DLL_IMPORT __declspec(dllimport)
-  #define MUJOCO_HELPER_DLL_EXPORT __declspec(dllexport)
-  #define MUJOCO_HELPER_DLL_LOCAL
-#else
-  #if __GNUC__ >= 4
-    #define MUJOCO_HELPER_DLL_IMPORT __attribute__ ((visibility ("default")))
-    #define MUJOCO_HELPER_DLL_EXPORT __attribute__ ((visibility ("default")))
-    #define MUJOCO_HELPER_DLL_LOCAL  __attribute__ ((visibility ("hidden")))
-  #else
-    #define MUJOCO_HELPER_DLL_IMPORT
-    #define MUJOCO_HELPER_DLL_EXPORT
-    #define MUJOCO_HELPER_DLL_LOCAL
-  #endif
-#endif
-
-#ifdef MJ_STATIC
-  // static library
-  #define MJAPI
-  #define MJLOCAL
-#else
-  #ifdef MUJOCO_DLL_EXPORTS
-    #define MJAPI MUJOCO_HELPER_DLL_EXPORT
-  #else
-    #define MJAPI MUJOCO_HELPER_DLL_IMPORT
-  #endif
-  #define MJLOCAL MUJOCO_HELPER_DLL_LOCAL
-#endif
-
-#endif  // MUJOCO_MJEXPORT_H_
+// Copyright 2021 DeepMind Technologies Limited
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef MUJOCO_MJEXPORT_H_
+#define MUJOCO_MJEXPORT_H_
+
+#if defined _WIN32 || defined __CYGWIN__
+  #define MUJOCO_HELPER_DLL_IMPORT __declspec(dllimport)
+  #define MUJOCO_HELPER_DLL_EXPORT __declspec(dllexport)
+  #define MUJOCO_HELPER_DLL_LOCAL
+#else
+  #if __GNUC__ >= 4
+    #define MUJOCO_HELPER_DLL_IMPORT __attribute__ ((visibility ("default")))
+    #define MUJOCO_HELPER_DLL_EXPORT __attribute__ ((visibility ("default")))
+    #define MUJOCO_HELPER_DLL_LOCAL  __attribute__ ((visibility ("hidden")))
+  #else
+    #define MUJOCO_HELPER_DLL_IMPORT
+    #define MUJOCO_HELPER_DLL_EXPORT
+    #define MUJOCO_HELPER_DLL_LOCAL
+  #endif
+#endif
+
+#ifdef MJ_STATIC
+  // static library
+  #define MJAPI
+  #define MJLOCAL
+#else
+  #ifdef MUJOCO_DLL_EXPORTS
+    #define MJAPI MUJOCO_HELPER_DLL_EXPORT
+  #else
+    #define MJAPI MUJOCO_HELPER_DLL_IMPORT
+  #endif
+  #define MJLOCAL MUJOCO_HELPER_DLL_LOCAL
+#endif
+
+#endif  // MUJOCO_MJEXPORT_H_
```

## mujoco/include/mujoco/mjmacro.h

 * *Ordering differences only*

```diff
@@ -1,61 +1,61 @@
-// Copyright 2023 DeepMind Technologies Limited
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#ifndef MUJOCO_MJMACRO_H_
-#define MUJOCO_MJMACRO_H_
-
-// include asan interface header, or provide stubs for poison/unpoison macros when not using asan
-#ifdef ADDRESS_SANITIZER
-  #include <sanitizer/asan_interface.h>
-#elif defined(_MSC_VER)
-  #define ASAN_POISON_MEMORY_REGION(addr, size)
-  #define ASAN_UNPOISON_MEMORY_REGION(addr, size)
-#else
-  #define ASAN_POISON_MEMORY_REGION(addr, size) ((void)(addr), (void)(size))
-  #define ASAN_UNPOISON_MEMORY_REGION(addr, size) ((void)(addr), (void)(size))
-#endif
-
-// max and min (use only for primitive types)
-#define mjMAX(a, b) (((a) > (b)) ? (a) : (b))
-#define mjMIN(a, b) (((a) < (b)) ? (a) : (b))
-
-// mjData stack frame management
-#define mjMARKSTACK   int _mark = d->pstack;
-#define mjFREESTACK   d->pstack = _mark;
-
-// return current value of mjOption enable/disable flags
-#define mjDISABLED(x) (m->opt.disableflags & (x))
-#define mjENABLED(x)  (m->opt.enableflags & (x))
-
-// annotation for functions that accept printf-like variadic arguments
-#ifndef mjPRINTFLIKE
-  #if defined(__GNUC__)
-    #define mjPRINTFLIKE(n, m) __attribute__((format(printf, n, m)))
-  #else
-    #define mjPRINTFLIKE(n, m)
-  #endif
-#endif
-
-// implementation of mjFREESTACK when using the address sanitizer
-#ifdef ADDRESS_SANITIZER
-  #undef mjFREESTACK
-  #define mjFREESTACK {                                          \
-    d->pstack = _mark;                                           \
-    ASAN_POISON_MEMORY_REGION(                                   \
-        (char*)d->arena + d->parena,                             \
-        (d->nstack - d->pstack) * sizeof(mjtNum) - d->parena );  \
-  }
-#endif
-
-#endif  // MUJOCO_MJMACRO_H_
+// Copyright 2023 DeepMind Technologies Limited
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef MUJOCO_MJMACRO_H_
+#define MUJOCO_MJMACRO_H_
+
+// include asan interface header, or provide stubs for poison/unpoison macros when not using asan
+#ifdef ADDRESS_SANITIZER
+  #include <sanitizer/asan_interface.h>
+#elif defined(_MSC_VER)
+  #define ASAN_POISON_MEMORY_REGION(addr, size)
+  #define ASAN_UNPOISON_MEMORY_REGION(addr, size)
+#else
+  #define ASAN_POISON_MEMORY_REGION(addr, size) ((void)(addr), (void)(size))
+  #define ASAN_UNPOISON_MEMORY_REGION(addr, size) ((void)(addr), (void)(size))
+#endif
+
+// max and min (use only for primitive types)
+#define mjMAX(a, b) (((a) > (b)) ? (a) : (b))
+#define mjMIN(a, b) (((a) < (b)) ? (a) : (b))
+
+// mjData stack frame management
+#define mjMARKSTACK   int _mark = d->pstack;
+#define mjFREESTACK   d->pstack = _mark;
+
+// return current value of mjOption enable/disable flags
+#define mjDISABLED(x) (m->opt.disableflags & (x))
+#define mjENABLED(x)  (m->opt.enableflags & (x))
+
+// annotation for functions that accept printf-like variadic arguments
+#ifndef mjPRINTFLIKE
+  #if defined(__GNUC__)
+    #define mjPRINTFLIKE(n, m) __attribute__((format(printf, n, m)))
+  #else
+    #define mjPRINTFLIKE(n, m)
+  #endif
+#endif
+
+// implementation of mjFREESTACK when using the address sanitizer
+#ifdef ADDRESS_SANITIZER
+  #undef mjFREESTACK
+  #define mjFREESTACK {                                          \
+    d->pstack = _mark;                                           \
+    ASAN_POISON_MEMORY_REGION(                                   \
+        (char*)d->arena + d->parena,                             \
+        (d->nstack - d->pstack) * sizeof(mjtNum) - d->parena );  \
+  }
+#endif
+
+#endif  // MUJOCO_MJMACRO_H_
```

## mujoco/include/mujoco/mjmodel.h

 * *Ordering differences only*

```diff
@@ -1,995 +1,995 @@
-// Copyright 2021 DeepMind Technologies Limited
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#ifndef MUJOCO_MJMODEL_H_
-#define MUJOCO_MJMODEL_H_
-
-#include <mujoco/mjtnum.h>
-
-// global constants
-#define mjPI            3.14159265358979323846
-#define mjMAXVAL        1E+10     // maximum value in qpos, qvel, qacc
-#define mjMINMU         1E-5      // minimum friction coefficient
-#define mjMINIMP        0.0001    // minimum constraint impedance
-#define mjMAXIMP        0.9999    // maximum constraint impedance
-#define mjMAXCONPAIR    50        // maximum number of contacts per geom pair
-#define mjMAXTREEDEPTH  50        // maximum bounding volume hierarchy depth
-#define mjMAXVFS        2000      // maximum number of files in virtual file system
-#define mjMAXVFSNAME    1000      // maximum filename size in virtual file system
-
-
-//---------------------------------- sizes ---------------------------------------------------------
-
-#define mjNEQDATA       11        // number of eq_data fields
-#define mjNDYN          10        // number of actuator dynamics parameters
-#define mjNGAIN         10        // number of actuator gain parameters
-#define mjNBIAS         10        // number of actuator bias parameters
-#define mjNFLUID        12        // number of fluid interaction parameters
-#define mjNREF          2         // number of solver reference parameters
-#define mjNIMP          5         // number of solver impedance parameters
-#define mjNSOLVER       1000      // size of mjData.solver_XXX arrays
-
-
-//---------------------------------- enum types (mjt) ----------------------------------------------
-
-typedef enum mjtDisableBit_ {     // disable default feature bitflags
-  mjDSBL_CONSTRAINT   = 1<<0,     // entire constraint solver
-  mjDSBL_EQUALITY     = 1<<1,     // equality constraints
-  mjDSBL_FRICTIONLOSS = 1<<2,     // joint and tendon frictionloss constraints
-  mjDSBL_LIMIT        = 1<<3,     // joint and tendon limit constraints
-  mjDSBL_CONTACT      = 1<<4,     // contact constraints
-  mjDSBL_PASSIVE      = 1<<5,     // passive forces
-  mjDSBL_GRAVITY      = 1<<6,     // gravitational forces
-  mjDSBL_CLAMPCTRL    = 1<<7,     // clamp control to specified range
-  mjDSBL_WARMSTART    = 1<<8,     // warmstart constraint solver
-  mjDSBL_FILTERPARENT = 1<<9,     // remove collisions with parent body
-  mjDSBL_ACTUATION    = 1<<10,    // apply actuation forces
-  mjDSBL_REFSAFE      = 1<<11,    // integrator safety: make ref[0]>=2*timestep
-  mjDSBL_SENSOR       = 1<<12,    // sensors
-  mjDSBL_MIDPHASE     = 1<<13,    // mid-phase collision filtering
-
-  mjNDISABLE          = 14        // number of disable flags
-} mjtDisableBit;
-
-
-typedef enum mjtEnableBit_ {      // enable optional feature bitflags
-  mjENBL_OVERRIDE     = 1<<0,     // override contact parameters
-  mjENBL_ENERGY       = 1<<1,     // energy computation
-  mjENBL_FWDINV       = 1<<2,     // record solver statistics
-  mjENBL_SENSORNOISE  = 1<<3,     // add noise to sensor data
-                                  // experimental features:
-  mjENBL_MULTICCD     = 1<<4,     // multi-point convex collision detection
-
-  mjNENABLE           = 5         // number of enable flags
-} mjtEnableBit;
-
-
-typedef enum mjtJoint_ {          // type of degree of freedom
-  mjJNT_FREE          = 0,        // global position and orientation (quat)       (7)
-  mjJNT_BALL,                     // orientation (quat) relative to parent        (4)
-  mjJNT_SLIDE,                    // sliding distance along body-fixed axis       (1)
-  mjJNT_HINGE                     // rotation angle (rad) around body-fixed axis  (1)
-} mjtJoint;
-
-
-typedef enum mjtGeom_ {           // type of geometric shape
-  // regular geom types
-  mjGEOM_PLANE        = 0,        // plane
-  mjGEOM_HFIELD,                  // height field
-  mjGEOM_SPHERE,                  // sphere
-  mjGEOM_CAPSULE,                 // capsule
-  mjGEOM_ELLIPSOID,               // ellipsoid
-  mjGEOM_CYLINDER,                // cylinder
-  mjGEOM_BOX,                     // box
-  mjGEOM_MESH,                    // mesh
-
-  mjNGEOMTYPES,                   // number of regular geom types
-
-  // rendering-only geom types: not used in mjModel, not counted in mjNGEOMTYPES
-  mjGEOM_ARROW        = 100,      // arrow
-  mjGEOM_ARROW1,                  // arrow without wedges
-  mjGEOM_ARROW2,                  // arrow in both directions
-  mjGEOM_LINE,                    // line
-  mjGEOM_SKIN,                    // skin
-  mjGEOM_LABEL,                   // text label
-
-  mjGEOM_NONE         = 1001      // missing geom type
-} mjtGeom;
-
-
-typedef enum mjtCamLight_ {       // tracking mode for camera and light
-  mjCAMLIGHT_FIXED    = 0,        // pos and rot fixed in body
-  mjCAMLIGHT_TRACK,               // pos tracks body, rot fixed in global
-  mjCAMLIGHT_TRACKCOM,            // pos tracks subtree com, rot fixed in body
-  mjCAMLIGHT_TARGETBODY,          // pos fixed in body, rot tracks target body
-  mjCAMLIGHT_TARGETBODYCOM        // pos fixed in body, rot tracks target subtree com
-} mjtCamLight;
-
-
-typedef enum mjtTexture_ {        // type of texture
-  mjTEXTURE_2D        = 0,        // 2d texture, suitable for planes and hfields
-  mjTEXTURE_CUBE,                 // cube texture, suitable for all other geom types
-  mjTEXTURE_SKYBOX                // cube texture used as skybox
-} mjtTexture;
-
-
-typedef enum mjtIntegrator_ {     // integrator mode
-  mjINT_EULER         = 0,        // semi-implicit Euler
-  mjINT_RK4,                      // 4th-order Runge Kutta
-  mjINT_IMPLICIT,                 // implicit in velocity
-  mjINT_IMPLICITFAST              // implicit in velocity, no rne derivative
-} mjtIntegrator;
-
-
-typedef enum mjtCollision_ {      // collision mode for selecting geom pairs
-  mjCOL_ALL           = 0,        // test precomputed and dynamic pairs
-  mjCOL_PAIR,                     // test predefined pairs only
-  mjCOL_DYNAMIC                   // test dynamic pairs only
-} mjtCollision;
-
-
-typedef enum mjtCone_ {           // type of friction cone
-  mjCONE_PYRAMIDAL     = 0,       // pyramidal
-  mjCONE_ELLIPTIC                 // elliptic
-} mjtCone;
-
-
-typedef enum mjtJacobian_ {       // type of constraint Jacobian
-  mjJAC_DENSE          = 0,       // dense
-  mjJAC_SPARSE,                   // sparse
-  mjJAC_AUTO                      // dense if nv<60, sparse otherwise
-} mjtJacobian;
-
-
-typedef enum mjtSolver_ {         // constraint solver algorithm
-  mjSOL_PGS            = 0,       // PGS    (dual)
-  mjSOL_CG,                       // CG     (primal)
-  mjSOL_NEWTON                    // Newton (primal)
-} mjtSolver;
-
-
-typedef enum mjtEq_ {             // type of equality constraint
-  mjEQ_CONNECT        = 0,        // connect two bodies at a point (ball joint)
-  mjEQ_WELD,                      // fix relative position and orientation of two bodies
-  mjEQ_JOINT,                     // couple the values of two scalar joints with cubic
-  mjEQ_TENDON,                    // couple the lengths of two tendons with cubic
-  mjEQ_DISTANCE                   // unsupported, will cause an error if used
-} mjtEq;
-
-
-typedef enum mjtWrap_ {           // type of tendon wrap object
-  mjWRAP_NONE         = 0,        // null object
-  mjWRAP_JOINT,                   // constant moment arm
-  mjWRAP_PULLEY,                  // pulley used to split tendon
-  mjWRAP_SITE,                    // pass through site
-  mjWRAP_SPHERE,                  // wrap around sphere
-  mjWRAP_CYLINDER                 // wrap around (infinite) cylinder
-} mjtWrap;
-
-
-typedef enum mjtTrn_ {            // type of actuator transmission
-  mjTRN_JOINT         = 0,        // force on joint
-  mjTRN_JOINTINPARENT,            // force on joint, expressed in parent frame
-  mjTRN_SLIDERCRANK,              // force via slider-crank linkage
-  mjTRN_TENDON,                   // force on tendon
-  mjTRN_SITE,                     // force on site
-  mjTRN_BODY,                     // adhesion force on a body's geoms
-
-  mjTRN_UNDEFINED     = 1000      // undefined transmission type
-} mjtTrn;
-
-
-typedef enum mjtDyn_ {            // type of actuator dynamics
-  mjDYN_NONE          = 0,        // no internal dynamics; ctrl specifies force
-  mjDYN_INTEGRATOR,               // integrator: da/dt = u
-  mjDYN_FILTER,                   // linear filter: da/dt = (u-a) / tau
-  mjDYN_FILTEREXACT,              // linear filter: da/dt = (u-a) / tau, with exact integration
-  mjDYN_MUSCLE,                   // piece-wise linear filter with two time constants
-  mjDYN_USER                      // user-defined dynamics type
-} mjtDyn;
-
-
-typedef enum mjtGain_ {           // type of actuator gain
-  mjGAIN_FIXED        = 0,        // fixed gain
-  mjGAIN_AFFINE,                  // const + kp*length + kv*velocity
-  mjGAIN_MUSCLE,                  // muscle FLV curve computed by mju_muscleGain()
-  mjGAIN_USER                     // user-defined gain type
-} mjtGain;
-
-
-typedef enum mjtBias_ {           // type of actuator bias
-  mjBIAS_NONE         = 0,        // no bias
-  mjBIAS_AFFINE,                  // const + kp*length + kv*velocity
-  mjBIAS_MUSCLE,                  // muscle passive force computed by mju_muscleBias()
-  mjBIAS_USER                     // user-defined bias type
-} mjtBias;
-
-
-typedef enum mjtObj_ {            // type of MujoCo object
-  mjOBJ_UNKNOWN       = 0,        // unknown object type
-  mjOBJ_BODY,                     // body
-  mjOBJ_XBODY,                    // body, used to access regular frame instead of i-frame
-  mjOBJ_JOINT,                    // joint
-  mjOBJ_DOF,                      // dof
-  mjOBJ_GEOM,                     // geom
-  mjOBJ_SITE,                     // site
-  mjOBJ_CAMERA,                   // camera
-  mjOBJ_LIGHT,                    // light
-  mjOBJ_MESH,                     // mesh
-  mjOBJ_SKIN,                     // skin
-  mjOBJ_HFIELD,                   // heightfield
-  mjOBJ_TEXTURE,                  // texture
-  mjOBJ_MATERIAL,                 // material for rendering
-  mjOBJ_PAIR,                     // geom pair to include
-  mjOBJ_EXCLUDE,                  // body pair to exclude
-  mjOBJ_EQUALITY,                 // equality constraint
-  mjOBJ_TENDON,                   // tendon
-  mjOBJ_ACTUATOR,                 // actuator
-  mjOBJ_SENSOR,                   // sensor
-  mjOBJ_NUMERIC,                  // numeric
-  mjOBJ_TEXT,                     // text
-  mjOBJ_TUPLE,                    // tuple
-  mjOBJ_KEY,                      // keyframe
-  mjOBJ_PLUGIN                    // plugin instance
-} mjtObj;
-
-
-typedef enum mjtConstraint_ {     // type of constraint
-  mjCNSTR_EQUALITY    = 0,        // equality constraint
-  mjCNSTR_FRICTION_DOF,           // dof friction
-  mjCNSTR_FRICTION_TENDON,        // tendon friction
-  mjCNSTR_LIMIT_JOINT,            // joint limit
-  mjCNSTR_LIMIT_TENDON,           // tendon limit
-  mjCNSTR_CONTACT_FRICTIONLESS,   // frictionless contact
-  mjCNSTR_CONTACT_PYRAMIDAL,      // frictional contact, pyramidal friction cone
-  mjCNSTR_CONTACT_ELLIPTIC        // frictional contact, elliptic friction cone
-} mjtConstraint;
-
-
-typedef enum mjtConstraintState_ {  // constraint state
-  mjCNSTRSTATE_SATISFIED = 0,       // constraint satisfied, zero cost (limit, contact)
-  mjCNSTRSTATE_QUADRATIC,           // quadratic cost (equality, friction, limit, contact)
-  mjCNSTRSTATE_LINEARNEG,           // linear cost, negative side (friction)
-  mjCNSTRSTATE_LINEARPOS,           // linear cost, positive side (friction)
-  mjCNSTRSTATE_CONE                 // squared distance to cone cost (elliptic contact)
-} mjtConstraintState;
-
-
-typedef enum mjtSensor_ {         // type of sensor
-  // common robotic sensors, attached to a site
-  mjSENS_TOUCH        = 0,        // scalar contact normal forces summed over sensor zone
-  mjSENS_ACCELEROMETER,           // 3D linear acceleration, in local frame
-  mjSENS_VELOCIMETER,             // 3D linear velocity, in local frame
-  mjSENS_GYRO,                    // 3D angular velocity, in local frame
-  mjSENS_FORCE,                   // 3D force between site's body and its parent body
-  mjSENS_TORQUE,                  // 3D torque between site's body and its parent body
-  mjSENS_MAGNETOMETER,            // 3D magnetometer
-  mjSENS_RANGEFINDER,             // scalar distance to nearest geom or site along z-axis
-
-  // sensors related to scalar joints, tendons, actuators
-  mjSENS_JOINTPOS,                // scalar joint position (hinge and slide only)
-  mjSENS_JOINTVEL,                // scalar joint velocity (hinge and slide only)
-  mjSENS_TENDONPOS,               // scalar tendon position
-  mjSENS_TENDONVEL,               // scalar tendon velocity
-  mjSENS_ACTUATORPOS,             // scalar actuator position
-  mjSENS_ACTUATORVEL,             // scalar actuator velocity
-  mjSENS_ACTUATORFRC,             // scalar actuator force
-  mjSENS_JOINTACTFRC,             // scalar actuator force, measured at the joint
-
-  // sensors related to ball joints
-  mjSENS_BALLQUAT,                // 4D ball joint quaternion
-  mjSENS_BALLANGVEL,              // 3D ball joint angular velocity
-
-  // joint and tendon limit sensors, in constraint space
-  mjSENS_JOINTLIMITPOS,           // joint limit distance-margin
-  mjSENS_JOINTLIMITVEL,           // joint limit velocity
-  mjSENS_JOINTLIMITFRC,           // joint limit force
-  mjSENS_TENDONLIMITPOS,          // tendon limit distance-margin
-  mjSENS_TENDONLIMITVEL,          // tendon limit velocity
-  mjSENS_TENDONLIMITFRC,          // tendon limit force
-
-  // sensors attached to an object with spatial frame: (x)body, geom, site, camera
-  mjSENS_FRAMEPOS,                // 3D position
-  mjSENS_FRAMEQUAT,               // 4D unit quaternion orientation
-  mjSENS_FRAMEXAXIS,              // 3D unit vector: x-axis of object's frame
-  mjSENS_FRAMEYAXIS,              // 3D unit vector: y-axis of object's frame
-  mjSENS_FRAMEZAXIS,              // 3D unit vector: z-axis of object's frame
-  mjSENS_FRAMELINVEL,             // 3D linear velocity
-  mjSENS_FRAMEANGVEL,             // 3D angular velocity
-  mjSENS_FRAMELINACC,             // 3D linear acceleration
-  mjSENS_FRAMEANGACC,             // 3D angular acceleration
-
-  // sensors related to kinematic subtrees; attached to a body (which is the subtree root)
-  mjSENS_SUBTREECOM,              // 3D center of mass of subtree
-  mjSENS_SUBTREELINVEL,           // 3D linear velocity of subtree
-  mjSENS_SUBTREEANGMOM,           // 3D angular momentum of subtree
-
-  // global sensors
-  mjSENS_CLOCK,                   // simulation time
-
-  // plugin-controlled sensors
-  mjSENS_PLUGIN,                  // plugin-controlled
-
-  // user-defined sensor
-  mjSENS_USER                     // sensor data provided by mjcb_sensor callback
-} mjtSensor;
-
-
-typedef enum mjtStage_ {          // computation stage
-  mjSTAGE_NONE        = 0,        // no computations
-  mjSTAGE_POS,                    // position-dependent computations
-  mjSTAGE_VEL,                    // velocity-dependent computations
-  mjSTAGE_ACC                     // acceleration/force-dependent computations
-} mjtStage;
-
-
-typedef enum mjtDataType_ {       // data type for sensors
-  mjDATATYPE_REAL     = 0,        // real values, no constraints
-  mjDATATYPE_POSITIVE,            // positive values; 0 or negative: inactive
-  mjDATATYPE_AXIS,                // 3D unit vector
-  mjDATATYPE_QUATERNION           // unit quaternion
-} mjtDataType;
-
-
-typedef enum mjtLRMode_ {         // mode for actuator length range computation
-  mjLRMODE_NONE   = 0,            // do not process any actuators
-  mjLRMODE_MUSCLE,                // process muscle actuators
-  mjLRMODE_MUSCLEUSER,            // process muscle and user actuators
-  mjLRMODE_ALL                    // process all actuators
-} mjtLRMode;
-
-
-//---------------------------------- mjLROpt -------------------------------------------------------
-
-struct mjLROpt_ {                 // options for mj_setLengthRange()
-  // flags
-  int mode;                       // which actuators to process (mjtLRMode)
-  int useexisting;                // use existing length range if available
-  int uselimit;                   // use joint and tendon limits if available
-
-  // algorithm parameters
-  mjtNum accel;                   // target acceleration used to compute force
-  mjtNum maxforce;                // maximum force; 0: no limit
-  mjtNum timeconst;               // time constant for velocity reduction; min 0.01
-  mjtNum timestep;                // simulation timestep; 0: use mjOption.timestep
-  mjtNum inttotal;                // total simulation time interval
-  mjtNum interval;                // evaluation time interval (at the end)
-  mjtNum tolrange;                // convergence tolerance (relative to range)
-};
-typedef struct mjLROpt_ mjLROpt;
-
-
-//---------------------------------- mjVFS ---------------------------------------------------------
-
-struct mjVFS_ {                            // virtual file system for loading from memory
-  int   nfile;                             // number of files present
-  char  filename[mjMAXVFS][mjMAXVFSNAME];  // file name without path
-  int   filesize[mjMAXVFS];                // file size in bytes
-  void* filedata[mjMAXVFS];                // buffer with file data
-};
-typedef struct mjVFS_ mjVFS;
-
-
-//---------------------------------- mjResource ----------------------------------------------------
-
-struct mjResource_ {
-  char* name;                     // name of resource (filename, etc)
-  void* data;                     // opaque data pointer
-  const void* provider_data;      // opaque resource provider data
-
-  // reading callback from resource provider
-  int (*read)(struct mjResource_* resource, const void** buffer);
-
-  // closing callback from resource provider
-  void (*close)(struct mjResource_* resource);
-
-  // getdir callback from resource provider
-  void (*getdir)(struct mjResource_* resource, const char** dir, int* ndir);
-};
-typedef struct mjResource_ mjResource;
-
-
-//---------------------------------- mjOption ------------------------------------------------------
-
-struct mjOption_ {                // physics options
-  // timing parameters
-  mjtNum timestep;                // timestep
-  mjtNum apirate;                 // update rate for remote API (Hz)
-
-  // solver parameters
-  mjtNum impratio;                // ratio of friction-to-normal contact impedance
-  mjtNum tolerance;               // main solver tolerance
-  mjtNum noslip_tolerance;        // noslip solver tolerance
-  mjtNum mpr_tolerance;           // MPR solver tolerance
-
-  // physical constants
-  mjtNum gravity[3];              // gravitational acceleration
-  mjtNum wind[3];                 // wind (for lift, drag and viscosity)
-  mjtNum magnetic[3];             // global magnetic flux
-  mjtNum density;                 // density of medium
-  mjtNum viscosity;               // viscosity of medium
-
-  // override contact solver parameters (if enabled)
-  mjtNum o_margin;                // margin
-  mjtNum o_solref[mjNREF];        // solref
-  mjtNum o_solimp[mjNIMP];        // solimp
-
-  // discrete settings
-  int integrator;                 // integration mode (mjtIntegrator)
-  int collision;                  // collision mode (mjtCollision)
-  int cone;                       // type of friction cone (mjtCone)
-  int jacobian;                   // type of Jacobian (mjtJacobian)
-  int solver;                     // solver algorithm (mjtSolver)
-  int iterations;                 // maximum number of main solver iterations
-  int noslip_iterations;          // maximum number of noslip solver iterations
-  int mpr_iterations;             // maximum number of MPR solver iterations
-  int disableflags;               // bit flags for disabling standard features
-  int enableflags;                // bit flags for enabling optional features
-};
-typedef struct mjOption_ mjOption;
-
-
-//---------------------------------- mjVisual ------------------------------------------------------
-
-struct mjVisual_ {                // visualization options
-  struct {                        // global parameters
-    float fovy;                   // y-field of view for free camera (degrees)
-    float ipd;                    // inter-pupilary distance for free camera
-    float azimuth;                // initial azimuth of free camera (degrees)
-    float elevation;              // initial elevation of free camera (degrees)
-    float linewidth;              // line width for wireframe and ray rendering
-    float glow;                   // glow coefficient for selected body
-    float realtime;               // initial real-time factor (1: real time)
-    int offwidth;                 // width of offscreen buffer
-    int offheight;                // height of offscreen buffer
-    int ellipsoidinertia;         // geom for inertia visualization (0: box, 1: ellipsoid)
-  } global;
-
-  struct {                        // rendering quality
-    int   shadowsize;             // size of shadowmap texture
-    int   offsamples;             // number of multisamples for offscreen rendering
-    int   numslices;              // number of slices for builtin geom drawing
-    int   numstacks;              // number of stacks for builtin geom drawing
-    int   numquads;               // number of quads for box rendering
-  } quality;
-
-  struct {                        // head light
-    float ambient[3];             // ambient rgb (alpha=1)
-    float diffuse[3];             // diffuse rgb (alpha=1)
-    float specular[3];            // specular rgb (alpha=1)
-    int   active;                 // is headlight active
-  } headlight;
-
-  struct {                        // mapping
-    float stiffness;              // mouse perturbation stiffness (space->force)
-    float stiffnessrot;           // mouse perturbation stiffness (space->torque)
-    float force;                  // from force units to space units
-    float torque;                 // from torque units to space units
-    float alpha;                  // scale geom alphas when transparency is enabled
-    float fogstart;               // OpenGL fog starts at fogstart * mjModel.stat.extent
-    float fogend;                 // OpenGL fog ends at fogend * mjModel.stat.extent
-    float znear;                  // near clipping plane = znear * mjModel.stat.extent
-    float zfar;                   // far clipping plane = zfar * mjModel.stat.extent
-    float haze;                   // haze ratio
-    float shadowclip;             // directional light: shadowclip * mjModel.stat.extent
-    float shadowscale;            // spot light: shadowscale * light.cutoff
-    float actuatortendon;         // scale tendon width
-  } map;
-
-  struct {                        // scale of decor elements relative to mean body size
-    float forcewidth;             // width of force arrow
-    float contactwidth;           // contact width
-    float contactheight;          // contact height
-    float connect;                // autoconnect capsule width
-    float com;                    // com radius
-    float camera;                 // camera object
-    float light;                  // light object
-    float selectpoint;            // selection point
-    float jointlength;            // joint length
-    float jointwidth;             // joint width
-    float actuatorlength;         // actuator length
-    float actuatorwidth;          // actuator width
-    float framelength;            // bodyframe axis length
-    float framewidth;             // bodyframe axis width
-    float constraint;             // constraint width
-    float slidercrank;            // slidercrank width
-  } scale;
-
-  struct {                        // color of decor elements
-    float fog[4];                 // fog
-    float haze[4];                // haze
-    float force[4];               // external force
-    float inertia[4];             // inertia box
-    float joint[4];               // joint
-    float actuator[4];            // actuator, neutral
-    float actuatornegative[4];    // actuator, negative limit
-    float actuatorpositive[4];    // actuator, positive limit
-    float com[4];                 // center of mass
-    float camera[4];              // camera object
-    float light[4];               // light object
-    float selectpoint[4];         // selection point
-    float connect[4];             // auto connect
-    float contactpoint[4];        // contact point
-    float contactforce[4];        // contact force
-    float contactfriction[4];     // contact friction force
-    float contacttorque[4];       // contact torque
-    float contactgap[4];          // contact point in gap
-    float rangefinder[4];         // rangefinder ray
-    float constraint[4];          // constraint
-    float slidercrank[4];         // slidercrank
-    float crankbroken[4];         // used when crank must be stretched/broken
-  } rgba;
-};
-typedef struct mjVisual_ mjVisual;
-
-
-//---------------------------------- mjStatistic ---------------------------------------------------
-
-struct mjStatistic_ {             // model statistics (in qpos0)
-  mjtNum meaninertia;             // mean diagonal inertia
-  mjtNum meanmass;                // mean body mass
-  mjtNum meansize;                // mean body size
-  mjtNum extent;                  // spatial extent
-  mjtNum center[3];               // center of model
-};
-typedef struct mjStatistic_ mjStatistic;
-
-
-//---------------------------------- mjModel -------------------------------------------------------
-
-struct mjModel_ {
-  // ------------------------------- sizes
-
-  // sizes needed at mjModel construction
-  int nq;                         // number of generalized coordinates = dim(qpos)
-  int nv;                         // number of degrees of freedom = dim(qvel)
-  int nu;                         // number of actuators/controls = dim(ctrl)
-  int na;                         // number of activation states = dim(act)
-  int nbody;                      // number of bodies
-  int nbvh;                       // number of total bounding volumes in all bodies
-  int njnt;                       // number of joints
-  int ngeom;                      // number of geoms
-  int nsite;                      // number of sites
-  int ncam;                       // number of cameras
-  int nlight;                     // number of lights
-  int nmesh;                      // number of meshes
-  int nmeshvert;                  // number of vertices in all meshes
-  int nmeshnormal;                // number of normals in all meshes
-  int nmeshtexcoord;              // number of texcoords in all meshes
-  int nmeshface;                  // number of triangular faces in all meshes
-  int nmeshgraph;                 // number of ints in mesh auxiliary data
-  int nskin;                      // number of skins
-  int nskinvert;                  // number of vertices in all skins
-  int nskintexvert;               // number of vertiex with texcoords in all skins
-  int nskinface;                  // number of triangular faces in all skins
-  int nskinbone;                  // number of bones in all skins
-  int nskinbonevert;              // number of vertices in all skin bones
-  int nhfield;                    // number of heightfields
-  int nhfielddata;                // number of data points in all heightfields
-  int ntex;                       // number of textures
-  int ntexdata;                   // number of bytes in texture rgb data
-  int nmat;                       // number of materials
-  int npair;                      // number of predefined geom pairs
-  int nexclude;                   // number of excluded geom pairs
-  int neq;                        // number of equality constraints
-  int ntendon;                    // number of tendons
-  int nwrap;                      // number of wrap objects in all tendon paths
-  int nsensor;                    // number of sensors
-  int nnumeric;                   // number of numeric custom fields
-  int nnumericdata;               // number of mjtNums in all numeric fields
-  int ntext;                      // number of text custom fields
-  int ntextdata;                  // number of mjtBytes in all text fields
-  int ntuple;                     // number of tuple custom fields
-  int ntupledata;                 // number of objects in all tuple fields
-  int nkey;                       // number of keyframes
-  int nmocap;                     // number of mocap bodies
-  int nplugin;                    // number of plugin instances
-  int npluginattr;                // number of chars in all plugin config attributes
-  int nuser_body;                 // number of mjtNums in body_user
-  int nuser_jnt;                  // number of mjtNums in jnt_user
-  int nuser_geom;                 // number of mjtNums in geom_user
-  int nuser_site;                 // number of mjtNums in site_user
-  int nuser_cam;                  // number of mjtNums in cam_user
-  int nuser_tendon;               // number of mjtNums in tendon_user
-  int nuser_actuator;             // number of mjtNums in actuator_user
-  int nuser_sensor;               // number of mjtNums in sensor_user
-  int nnames;                     // number of chars in all names
-  int nnames_map;                 // number of slots in the names hash map
-
-  // sizes set after mjModel construction (only affect mjData)
-  int nM;                         // number of non-zeros in sparse inertia matrix
-  int nD;                         // number of non-zeros in sparse dof-dof matrix
-  int nB;                         // number of non-zeros in sparse body-dof matrix
-  int nemax;                      // number of potential equality-constraint rows
-  int njmax;                      // number of available rows in constraint Jacobian
-  int nconmax;                    // number of potential contacts in contact list
-  int nstack;                     // number of fields in mjData stack
-  int nuserdata;                  // number of extra fields in mjData
-  int nsensordata;                // number of fields in sensor data vector
-  int npluginstate;               // number of fields in the plugin state vector
-
-  int nbuffer;                    // number of bytes in buffer
-
-  // ------------------------------- options and statistics
-
-  mjOption opt;                   // physics options
-  mjVisual vis;                   // visualization options
-  mjStatistic stat;               // model statistics
-
-  // ------------------------------- buffers
-
-  // main buffer
-  void*     buffer;               // main buffer; all pointers point in it    (nbuffer)
-
-  // default generalized coordinates
-  mjtNum*   qpos0;                // qpos values at default pose              (nq x 1)
-  mjtNum*   qpos_spring;          // reference pose for springs               (nq x 1)
-
-  // bodies
-  int*      body_parentid;        // id of body's parent                      (nbody x 1)
-  int*      body_rootid;          // id of root above body                    (nbody x 1)
-  int*      body_weldid;          // id of body that this body is welded to   (nbody x 1)
-  int*      body_mocapid;         // id of mocap data; -1: none               (nbody x 1)
-  int*      body_jntnum;          // number of joints for this body           (nbody x 1)
-  int*      body_jntadr;          // start addr of joints; -1: no joints      (nbody x 1)
-  int*      body_dofnum;          // number of motion degrees of freedom      (nbody x 1)
-  int*      body_dofadr;          // start addr of dofs; -1: no dofs          (nbody x 1)
-  int*      body_geomnum;         // number of geoms                          (nbody x 1)
-  int*      body_geomadr;         // start addr of geoms; -1: no geoms        (nbody x 1)
-  mjtByte*  body_simple;          // body is simple (has diagonal M)          (nbody x 1)
-  mjtByte*  body_sameframe;       // inertial frame is same as body frame     (nbody x 1)
-  mjtNum*   body_pos;             // position offset rel. to parent body      (nbody x 3)
-  mjtNum*   body_quat;            // orientation offset rel. to parent body   (nbody x 4)
-  mjtNum*   body_ipos;            // local position of center of mass         (nbody x 3)
-  mjtNum*   body_iquat;           // local orientation of inertia ellipsoid   (nbody x 4)
-  mjtNum*   body_mass;            // mass                                     (nbody x 1)
-  mjtNum*   body_subtreemass;     // mass of subtree starting at this body    (nbody x 1)
-  mjtNum*   body_inertia;         // diagonal inertia in ipos/iquat frame     (nbody x 3)
-  mjtNum*   body_invweight0;      // mean inv inert in qpos0 (trn, rot)       (nbody x 2)
-  mjtNum*   body_gravcomp;        // antigravity force, units of body weight  (nbody x 1)
-  mjtNum*   body_user;            // user data                                (nbody x nuser_body)
-  int*      body_plugin;          // plugin instance id; -1: not in use       (nbody x 1)
-  int*      body_bvhadr;          // address of bvh root                      (nbody x 1)
-  int*      body_bvhnum;          // number of bounding volumes               (nbody x 1)
-
-  // bounding volume hierarchy
-  int*      bvh_depth;            // depth in the bounding volume hierarchy   (nbvh x 1)
-  int*      bvh_child;            // left and right children in tree          (nbvh x 2)
-  int*      bvh_geomid;           // geom id of the node; -1: non-leaf        (nbvh x 1)
-  mjtNum*   bvh_aabb;             // bounding box of node (center, size)      (nbvh x 6)
-
-  // joints
-  int*      jnt_type;             // type of joint (mjtJoint)                 (njnt x 1)
-  int*      jnt_qposadr;          // start addr in 'qpos' for joint's data    (njnt x 1)
-  int*      jnt_dofadr;           // start addr in 'qvel' for joint's data    (njnt x 1)
-  int*      jnt_bodyid;           // id of joint's body                       (njnt x 1)
-  int*      jnt_group;            // group for visibility                     (njnt x 1)
-  mjtByte*  jnt_limited;          // does joint have limits                   (njnt x 1)
-  mjtByte*  jnt_actfrclimited;    // does joint have actuator force limits    (njnt x 1)
-  mjtNum*   jnt_solref;           // constraint solver reference: limit       (njnt x mjNREF)
-  mjtNum*   jnt_solimp;           // constraint solver impedance: limit       (njnt x mjNIMP)
-  mjtNum*   jnt_pos;              // local anchor position                    (njnt x 3)
-  mjtNum*   jnt_axis;             // local joint axis                         (njnt x 3)
-  mjtNum*   jnt_stiffness;        // stiffness coefficient                    (njnt x 1)
-  mjtNum*   jnt_range;            // joint limits                             (njnt x 2)
-  mjtNum*   jnt_actfrcrange;      // range of total actuator force            (njnt x 2)
-  mjtNum*   jnt_margin;           // min distance for limit detection         (njnt x 1)
-  mjtNum*   jnt_user;             // user data                                (njnt x nuser_jnt)
-
-  // dofs
-  int*      dof_bodyid;           // id of dof's body                         (nv x 1)
-  int*      dof_jntid;            // id of dof's joint                        (nv x 1)
-  int*      dof_parentid;         // id of dof's parent; -1: none             (nv x 1)
-  int*      dof_Madr;             // dof address in M-diagonal                (nv x 1)
-  int*      dof_simplenum;        // number of consecutive simple dofs        (nv x 1)
-  mjtNum*   dof_solref;           // constraint solver reference:frictionloss (nv x mjNREF)
-  mjtNum*   dof_solimp;           // constraint solver impedance:frictionloss (nv x mjNIMP)
-  mjtNum*   dof_frictionloss;     // dof friction loss                        (nv x 1)
-  mjtNum*   dof_armature;         // dof armature inertia/mass                (nv x 1)
-  mjtNum*   dof_damping;          // damping coefficient                      (nv x 1)
-  mjtNum*   dof_invweight0;       // diag. inverse inertia in qpos0           (nv x 1)
-  mjtNum*   dof_M0;               // diag. inertia in qpos0                   (nv x 1)
-
-  // geoms
-  int*      geom_type;            // geometric type (mjtGeom)                 (ngeom x 1)
-  int*      geom_contype;         // geom contact type                        (ngeom x 1)
-  int*      geom_conaffinity;     // geom contact affinity                    (ngeom x 1)
-  int*      geom_condim;          // contact dimensionality (1, 3, 4, 6)      (ngeom x 1)
-  int*      geom_bodyid;          // id of geom's body                        (ngeom x 1)
-  int*      geom_dataid;          // id of geom's mesh/hfield; -1: none       (ngeom x 1)
-  int*      geom_matid;           // material id for rendering; -1: none      (ngeom x 1)
-  int*      geom_group;           // group for visibility                     (ngeom x 1)
-  int*      geom_priority;        // geom contact priority                    (ngeom x 1)
-  mjtByte*  geom_sameframe;       // same as body frame (1) or iframe (2)     (ngeom x 1)
-  mjtNum*   geom_solmix;          // mixing coef for solref/imp in geom pair  (ngeom x 1)
-  mjtNum*   geom_solref;          // constraint solver reference: contact     (ngeom x mjNREF)
-  mjtNum*   geom_solimp;          // constraint solver impedance: contact     (ngeom x mjNIMP)
-  mjtNum*   geom_size;            // geom-specific size parameters            (ngeom x 3)
-  mjtNum*   geom_aabb;            // bounding box, (center, size)             (ngeom x 6)
-  mjtNum*   geom_rbound;          // radius of bounding sphere                (ngeom x 1)
-  mjtNum*   geom_pos;             // local position offset rel. to body       (ngeom x 3)
-  mjtNum*   geom_quat;            // local orientation offset rel. to body    (ngeom x 4)
-  mjtNum*   geom_friction;        // friction for (slide, spin, roll)         (ngeom x 3)
-  mjtNum*   geom_margin;          // detect contact if dist<margin            (ngeom x 1)
-  mjtNum*   geom_gap;             // include in solver if dist<margin-gap     (ngeom x 1)
-  mjtNum*   geom_fluid;           // fluid interaction parameters             (ngeom x mjNFLUID)
-  mjtNum*   geom_user;            // user data                                (ngeom x nuser_geom)
-  float*    geom_rgba;            // rgba when material is omitted            (ngeom x 4)
-
-  // sites
-  int*      site_type;            // geom type for rendering (mjtGeom)        (nsite x 1)
-  int*      site_bodyid;          // id of site's body                        (nsite x 1)
-  int*      site_matid;           // material id for rendering; -1: none      (nsite x 1)
-  int*      site_group;           // group for visibility                     (nsite x 1)
-  mjtByte*  site_sameframe;       // same as body frame (1) or iframe (2)     (nsite x 1)
-  mjtNum*   site_size;            // geom size for rendering                  (nsite x 3)
-  mjtNum*   site_pos;             // local position offset rel. to body       (nsite x 3)
-  mjtNum*   site_quat;            // local orientation offset rel. to body    (nsite x 4)
-  mjtNum*   site_user;            // user data                                (nsite x nuser_site)
-  float*    site_rgba;            // rgba when material is omitted            (nsite x 4)
-
-  // cameras
-  int*      cam_mode;             // camera tracking mode (mjtCamLight)       (ncam x 1)
-  int*      cam_bodyid;           // id of camera's body                      (ncam x 1)
-  int*      cam_targetbodyid;     // id of targeted body; -1: none            (ncam x 1)
-  mjtNum*   cam_pos;              // position rel. to body frame              (ncam x 3)
-  mjtNum*   cam_quat;             // orientation rel. to body frame           (ncam x 4)
-  mjtNum*   cam_poscom0;          // global position rel. to sub-com in qpos0 (ncam x 3)
-  mjtNum*   cam_pos0;             // global position rel. to body in qpos0    (ncam x 3)
-  mjtNum*   cam_mat0;             // global orientation in qpos0              (ncam x 9)
-  mjtNum*   cam_fovy;             // y-field of view (deg)                    (ncam x 1)
-  mjtNum*   cam_ipd;              // inter-pupilary distance                  (ncam x 1)
-  mjtNum*   cam_user;             // user data                                (ncam x nuser_cam)
-
-  // lights
-  int*      light_mode;           // light tracking mode (mjtCamLight)        (nlight x 1)
-  int*      light_bodyid;         // id of light's body                       (nlight x 1)
-  int*      light_targetbodyid;   // id of targeted body; -1: none            (nlight x 1)
-  mjtByte*  light_directional;    // directional light                        (nlight x 1)
-  mjtByte*  light_castshadow;     // does light cast shadows                  (nlight x 1)
-  mjtByte*  light_active;         // is light on                              (nlight x 1)
-  mjtNum*   light_pos;            // position rel. to body frame              (nlight x 3)
-  mjtNum*   light_dir;            // direction rel. to body frame             (nlight x 3)
-  mjtNum*   light_poscom0;        // global position rel. to sub-com in qpos0 (nlight x 3)
-  mjtNum*   light_pos0;           // global position rel. to body in qpos0    (nlight x 3)
-  mjtNum*   light_dir0;           // global direction in qpos0                (nlight x 3)
-  float*    light_attenuation;    // OpenGL attenuation (quadratic model)     (nlight x 3)
-  float*    light_cutoff;         // OpenGL cutoff                            (nlight x 1)
-  float*    light_exponent;       // OpenGL exponent                          (nlight x 1)
-  float*    light_ambient;        // ambient rgb (alpha=1)                    (nlight x 3)
-  float*    light_diffuse;        // diffuse rgb (alpha=1)                    (nlight x 3)
-  float*    light_specular;       // specular rgb (alpha=1)                   (nlight x 3)
-
-  // meshes
-  int*      mesh_vertadr;         // first vertex address                     (nmesh x 1)
-  int*      mesh_vertnum;         // number of vertices                       (nmesh x 1)
-  int*      mesh_faceadr;         // first face address                       (nmesh x 1)
-  int*      mesh_facenum;         // number of faces                          (nmesh x 1)
-  int*      mesh_bvhadr;          // address of bvh root                      (nmesh x 1)
-  int*      mesh_bvhnum;          // number of bvh                            (nmesh x 1)
-  int*      mesh_normaladr;       // first normal address                     (nmesh x 1)
-  int*      mesh_normalnum;       // number of normals                        (nmesh x 1)
-  int*      mesh_texcoordadr;     // texcoord data address; -1: no texcoord   (nmesh x 1)
-  int*      mesh_texcoordnum;     // number of texcoord                       (nmesh x 1)
-  int*      mesh_graphadr;        // graph data address; -1: no graph         (nmesh x 1)
-  float*    mesh_vert;            // vertex positions for all meshes          (nmeshvert x 3)
-  float*    mesh_normal;          // normals for all meshes                   (nmeshnormal x 3)
-  float*    mesh_texcoord;        // vertex texcoords for all meshes          (nmeshtexcoord x 2)
-  int*      mesh_face;            // vertex face data                         (nmeshface x 3)
-  int*      mesh_facenormal;      // normal face data                         (nmeshface x 3)
-  int*      mesh_facetexcoord;    // texture face data                        (nmeshface x 3)
-  int*      mesh_graph;           // convex graph data                        (nmeshgraph x 1)
-
-  // skins
-  int*      skin_matid;           // skin material id; -1: none               (nskin x 1)
-  int*      skin_group;           // group for visibility                     (nskin x 1)
-  float*    skin_rgba;            // skin rgba                                (nskin x 4)
-  float*    skin_inflate;         // inflate skin in normal direction         (nskin x 1)
-  int*      skin_vertadr;         // first vertex address                     (nskin x 1)
-  int*      skin_vertnum;         // number of vertices                       (nskin x 1)
-  int*      skin_texcoordadr;     // texcoord data address; -1: no texcoord   (nskin x 1)
-  int*      skin_faceadr;         // first face address                       (nskin x 1)
-  int*      skin_facenum;         // number of faces                          (nskin x 1)
-  int*      skin_boneadr;         // first bone in skin                       (nskin x 1)
-  int*      skin_bonenum;         // number of bones in skin                  (nskin x 1)
-  float*    skin_vert;            // vertex positions for all skin meshes     (nskinvert x 3)
-  float*    skin_texcoord;        // vertex texcoords for all skin meshes     (nskintexvert x 2)
-  int*      skin_face;            // triangle faces for all skin meshes       (nskinface x 3)
-  int*      skin_bonevertadr;     // first vertex in each bone                (nskinbone x 1)
-  int*      skin_bonevertnum;     // number of vertices in each bone          (nskinbone x 1)
-  float*    skin_bonebindpos;     // bind pos of each bone                    (nskinbone x 3)
-  float*    skin_bonebindquat;    // bind quat of each bone                   (nskinbone x 4)
-  int*      skin_bonebodyid;      // body id of each bone                     (nskinbone x 1)
-  int*      skin_bonevertid;      // mesh ids of vertices in each bone        (nskinbonevert x 1)
-  float*    skin_bonevertweight;  // weights of vertices in each bone         (nskinbonevert x 1)
-
-  // height fields
-  mjtNum*   hfield_size;          // (x, y, z_top, z_bottom)                  (nhfield x 4)
-  int*      hfield_nrow;          // number of rows in grid                   (nhfield x 1)
-  int*      hfield_ncol;          // number of columns in grid                (nhfield x 1)
-  int*      hfield_adr;           // address in hfield_data                   (nhfield x 1)
-  float*    hfield_data;          // elevation data                           (nhfielddata x 1)
-
-  // textures
-  int*      tex_type;             // texture type (mjtTexture)                (ntex x 1)
-  int*      tex_height;           // number of rows in texture image          (ntex x 1)
-  int*      tex_width;            // number of columns in texture image       (ntex x 1)
-  int*      tex_adr;              // address in rgb                           (ntex x 1)
-  mjtByte*  tex_rgb;              // rgb (alpha = 1)                          (ntexdata x 1)
-
-  // materials
-  int*      mat_texid;            // texture id; -1: none                     (nmat x 1)
-  mjtByte*  mat_texuniform;       // make texture cube uniform                (nmat x 1)
-  float*    mat_texrepeat;        // texture repetition for 2d mapping        (nmat x 2)
-  float*    mat_emission;         // emission (x rgb)                         (nmat x 1)
-  float*    mat_specular;         // specular (x white)                       (nmat x 1)
-  float*    mat_shininess;        // shininess coef                           (nmat x 1)
-  float*    mat_reflectance;      // reflectance (0: disable)                 (nmat x 1)
-  float*    mat_rgba;             // rgba                                     (nmat x 4)
-
-  // predefined geom pairs for collision detection; has precedence over exclude
-  int*      pair_dim;             // contact dimensionality                   (npair x 1)
-  int*      pair_geom1;           // id of geom1                              (npair x 1)
-  int*      pair_geom2;           // id of geom2                              (npair x 1)
-  int*      pair_signature;       // (body1+1) << 16 + body2+1                (npair x 1)
-  mjtNum*   pair_solref;          // solver reference: contact normal         (npair x mjNREF)
-  mjtNum*   pair_solreffriction;  // solver reference: contact friction       (npair x mjNREF)
-  mjtNum*   pair_solimp;          // solver impedance: contact                (npair x mjNIMP)
-  mjtNum*   pair_margin;          // detect contact if dist<margin            (npair x 1)
-  mjtNum*   pair_gap;             // include in solver if dist<margin-gap     (npair x 1)
-  mjtNum*   pair_friction;        // tangent1, 2, spin, roll1, 2              (npair x 5)
-
-  // excluded body pairs for collision detection
-  int*      exclude_signature;    // (body1+1) << 16 + body2+1                (nexclude x 1)
-
-  // equality constraints
-  int*      eq_type;              // constraint type (mjtEq)                  (neq x 1)
-  int*      eq_obj1id;            // id of object 1                           (neq x 1)
-  int*      eq_obj2id;            // id of object 2                           (neq x 1)
-  mjtByte*  eq_active;            // enable/disable constraint                (neq x 1)
-  mjtNum*   eq_solref;            // constraint solver reference              (neq x mjNREF)
-  mjtNum*   eq_solimp;            // constraint solver impedance              (neq x mjNIMP)
-  mjtNum*   eq_data;              // numeric data for constraint              (neq x mjNEQDATA)
-
-  // tendons
-  int*      tendon_adr;           // address of first object in tendon's path (ntendon x 1)
-  int*      tendon_num;           // number of objects in tendon's path       (ntendon x 1)
-  int*      tendon_matid;         // material id for rendering                (ntendon x 1)
-  int*      tendon_group;         // group for visibility                     (ntendon x 1)
-  mjtByte*  tendon_limited;       // does tendon have length limits           (ntendon x 1)
-  mjtNum*   tendon_width;         // width for rendering                      (ntendon x 1)
-  mjtNum*   tendon_solref_lim;    // constraint solver reference: limit       (ntendon x mjNREF)
-  mjtNum*   tendon_solimp_lim;    // constraint solver impedance: limit       (ntendon x mjNIMP)
-  mjtNum*   tendon_solref_fri;    // constraint solver reference: friction    (ntendon x mjNREF)
-  mjtNum*   tendon_solimp_fri;    // constraint solver impedance: friction    (ntendon x mjNIMP)
-  mjtNum*   tendon_range;         // tendon length limits                     (ntendon x 2)
-  mjtNum*   tendon_margin;        // min distance for limit detection         (ntendon x 1)
-  mjtNum*   tendon_stiffness;     // stiffness coefficient                    (ntendon x 1)
-  mjtNum*   tendon_damping;       // damping coefficient                      (ntendon x 1)
-  mjtNum*   tendon_frictionloss;  // loss due to friction                     (ntendon x 1)
-  mjtNum*   tendon_lengthspring;  // spring resting length range              (ntendon x 2)
-  mjtNum*   tendon_length0;       // tendon length in qpos0                   (ntendon x 1)
-  mjtNum*   tendon_invweight0;    // inv. weight in qpos0                     (ntendon x 1)
-  mjtNum*   tendon_user;          // user data                                (ntendon x nuser_tendon)
-  float*    tendon_rgba;          // rgba when material is omitted            (ntendon x 4)
-
-  // list of all wrap objects in tendon paths
-  int*      wrap_type;            // wrap object type (mjtWrap)               (nwrap x 1)
-  int*      wrap_objid;           // object id: geom, site, joint             (nwrap x 1)
-  mjtNum*   wrap_prm;             // divisor, joint coef, or site id          (nwrap x 1)
-
-  // actuators
-  int*      actuator_trntype;     // transmission type (mjtTrn)               (nu x 1)
-  int*      actuator_dyntype;     // dynamics type (mjtDyn)                   (nu x 1)
-  int*      actuator_gaintype;    // gain type (mjtGain)                      (nu x 1)
-  int*      actuator_biastype;    // bias type (mjtBias)                      (nu x 1)
-  int*      actuator_trnid;       // transmission id: joint, tendon, site     (nu x 2)
-  int*      actuator_actadr;      // first activation address; -1: stateless  (nu x 1)
-  int*      actuator_actnum;      // number of activation variables           (nu x 1)
-  int*      actuator_group;       // group for visibility                     (nu x 1)
-  mjtByte*  actuator_ctrllimited; // is control limited                       (nu x 1)
-  mjtByte*  actuator_forcelimited;// is force limited                         (nu x 1)
-  mjtByte*  actuator_actlimited;  // is activation limited                    (nu x 1)
-  mjtNum*   actuator_dynprm;      // dynamics parameters                      (nu x mjNDYN)
-  mjtNum*   actuator_gainprm;     // gain parameters                          (nu x mjNGAIN)
-  mjtNum*   actuator_biasprm;     // bias parameters                          (nu x mjNBIAS)
-  mjtByte*  actuator_actearly;    // step activation before force             (nu x 1)
-  mjtNum*   actuator_ctrlrange;   // range of controls                        (nu x 2)
-  mjtNum*   actuator_forcerange;  // range of forces                          (nu x 2)
-  mjtNum*   actuator_actrange;    // range of activations                     (nu x 2)
-  mjtNum*   actuator_gear;        // scale length and transmitted force       (nu x 6)
-  mjtNum*   actuator_cranklength; // crank length for slider-crank            (nu x 1)
-  mjtNum*   actuator_acc0;        // acceleration from unit force in qpos0    (nu x 1)
-  mjtNum*   actuator_length0;     // actuator length in qpos0                 (nu x 1)
-  mjtNum*   actuator_lengthrange; // feasible actuator length range           (nu x 2)
-  mjtNum*   actuator_user;        // user data                                (nu x nuser_actuator)
-  int*      actuator_plugin;      // plugin instance id; -1: not a plugin     (nu x 1)
-
-  // sensors
-  int*      sensor_type;          // sensor type (mjtSensor)                  (nsensor x 1)
-  int*      sensor_datatype;      // numeric data type (mjtDataType)          (nsensor x 1)
-  int*      sensor_needstage;     // required compute stage (mjtStage)        (nsensor x 1)
-  int*      sensor_objtype;       // type of sensorized object (mjtObj)       (nsensor x 1)
-  int*      sensor_objid;         // id of sensorized object                  (nsensor x 1)
-  int*      sensor_reftype;       // type of reference frame (mjtObj)         (nsensor x 1)
-  int*      sensor_refid;         // id of reference frame; -1: global frame  (nsensor x 1)
-  int*      sensor_dim;           // number of scalar outputs                 (nsensor x 1)
-  int*      sensor_adr;           // address in sensor array                  (nsensor x 1)
-  mjtNum*   sensor_cutoff;        // cutoff for real and positive; 0: ignore  (nsensor x 1)
-  mjtNum*   sensor_noise;         // noise standard deviation                 (nsensor x 1)
-  mjtNum*   sensor_user;          // user data                                (nsensor x nuser_sensor)
-  int*      sensor_plugin;        // plugin instance id; -1: not a plugin     (nsensor x 1)
-
-  // plugin instances
-  int*      plugin;               // globally registered plugin slot number   (nplugin x 1)
-  int*      plugin_stateadr;      // address in the plugin state array        (nplugin x 1)
-  int*      plugin_statenum;      // number of states in the plugin instance  (nplugin x 1)
-  char*     plugin_attr;          // config attributes of plugin instances    (npluginattr x 1)
-  int*      plugin_attradr;       // address to each instance's config attrib (nplugin x 1)
-
-  // custom numeric fields
-  int*      numeric_adr;          // address of field in numeric_data         (nnumeric x 1)
-  int*      numeric_size;         // size of numeric field                    (nnumeric x 1)
-  mjtNum*   numeric_data;         // array of all numeric fields              (nnumericdata x 1)
-
-  // custom text fields
-  int*      text_adr;             // address of text in text_data             (ntext x 1)
-  int*      text_size;            // size of text field (strlen+1)            (ntext x 1)
-  char*     text_data;            // array of all text fields (0-terminated)  (ntextdata x 1)
-
-  // custom tuple fields
-  int*      tuple_adr;            // address of text in text_data             (ntuple x 1)
-  int*      tuple_size;           // number of objects in tuple               (ntuple x 1)
-  int*      tuple_objtype;        // array of object types in all tuples      (ntupledata x 1)
-  int*      tuple_objid;          // array of object ids in all tuples        (ntupledata x 1)
-  mjtNum*   tuple_objprm;         // array of object params in all tuples     (ntupledata x 1)
-
-  // keyframes
-  mjtNum*   key_time;             // key time                                 (nkey x 1)
-  mjtNum*   key_qpos;             // key position                             (nkey x nq)
-  mjtNum*   key_qvel;             // key velocity                             (nkey x nv)
-  mjtNum*   key_act;              // key activation                           (nkey x na)
-  mjtNum*   key_mpos;             // key mocap position                       (nkey x 3*nmocap)
-  mjtNum*   key_mquat;            // key mocap quaternion                     (nkey x 4*nmocap)
-  mjtNum*   key_ctrl;             // key control                              (nkey x nu)
-
-  // names
-  int*      name_bodyadr;         // body name pointers                       (nbody x 1)
-  int*      name_jntadr;          // joint name pointers                      (njnt x 1)
-  int*      name_geomadr;         // geom name pointers                       (ngeom x 1)
-  int*      name_siteadr;         // site name pointers                       (nsite x 1)
-  int*      name_camadr;          // camera name pointers                     (ncam x 1)
-  int*      name_lightadr;        // light name pointers                      (nlight x 1)
-  int*      name_meshadr;         // mesh name pointers                       (nmesh x 1)
-  int*      name_skinadr;         // skin name pointers                       (nskin x 1)
-  int*      name_hfieldadr;       // hfield name pointers                     (nhfield x 1)
-  int*      name_texadr;          // texture name pointers                    (ntex x 1)
-  int*      name_matadr;          // material name pointers                   (nmat x 1)
-  int*      name_pairadr;         // geom pair name pointers                  (npair x 1)
-  int*      name_excludeadr;      // exclude name pointers                    (nexclude x 1)
-  int*      name_eqadr;           // equality constraint name pointers        (neq x 1)
-  int*      name_tendonadr;       // tendon name pointers                     (ntendon x 1)
-  int*      name_actuatoradr;     // actuator name pointers                   (nu x 1)
-  int*      name_sensoradr;       // sensor name pointers                     (nsensor x 1)
-  int*      name_numericadr;      // numeric name pointers                    (nnumeric x 1)
-  int*      name_textadr;         // text name pointers                       (ntext x 1)
-  int*      name_tupleadr;        // tuple name pointers                      (ntuple x 1)
-  int*      name_keyadr;          // keyframe name pointers                   (nkey x 1)
-  int*      name_pluginadr;       // plugin instance name pointers            (nplugin x 1)
-  char*     names;                // names of all objects, 0-terminated       (nnames x 1)
-  int*      names_map;            // internal hash map of names               (nnames_map x 1)
-};
-typedef struct mjModel_ mjModel;
-
-#endif  // MUJOCO_MJMODEL_H_
+// Copyright 2021 DeepMind Technologies Limited
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef MUJOCO_MJMODEL_H_
+#define MUJOCO_MJMODEL_H_
+
+#include <mujoco/mjtnum.h>
+
+// global constants
+#define mjPI            3.14159265358979323846
+#define mjMAXVAL        1E+10     // maximum value in qpos, qvel, qacc
+#define mjMINMU         1E-5      // minimum friction coefficient
+#define mjMINIMP        0.0001    // minimum constraint impedance
+#define mjMAXIMP        0.9999    // maximum constraint impedance
+#define mjMAXCONPAIR    50        // maximum number of contacts per geom pair
+#define mjMAXTREEDEPTH  50        // maximum bounding volume hierarchy depth
+#define mjMAXVFS        2000      // maximum number of files in virtual file system
+#define mjMAXVFSNAME    1000      // maximum filename size in virtual file system
+
+
+//---------------------------------- sizes ---------------------------------------------------------
+
+#define mjNEQDATA       11        // number of eq_data fields
+#define mjNDYN          10        // number of actuator dynamics parameters
+#define mjNGAIN         10        // number of actuator gain parameters
+#define mjNBIAS         10        // number of actuator bias parameters
+#define mjNFLUID        12        // number of fluid interaction parameters
+#define mjNREF          2         // number of solver reference parameters
+#define mjNIMP          5         // number of solver impedance parameters
+#define mjNSOLVER       1000      // size of mjData.solver_XXX arrays
+
+
+//---------------------------------- enum types (mjt) ----------------------------------------------
+
+typedef enum mjtDisableBit_ {     // disable default feature bitflags
+  mjDSBL_CONSTRAINT   = 1<<0,     // entire constraint solver
+  mjDSBL_EQUALITY     = 1<<1,     // equality constraints
+  mjDSBL_FRICTIONLOSS = 1<<2,     // joint and tendon frictionloss constraints
+  mjDSBL_LIMIT        = 1<<3,     // joint and tendon limit constraints
+  mjDSBL_CONTACT      = 1<<4,     // contact constraints
+  mjDSBL_PASSIVE      = 1<<5,     // passive forces
+  mjDSBL_GRAVITY      = 1<<6,     // gravitational forces
+  mjDSBL_CLAMPCTRL    = 1<<7,     // clamp control to specified range
+  mjDSBL_WARMSTART    = 1<<8,     // warmstart constraint solver
+  mjDSBL_FILTERPARENT = 1<<9,     // remove collisions with parent body
+  mjDSBL_ACTUATION    = 1<<10,    // apply actuation forces
+  mjDSBL_REFSAFE      = 1<<11,    // integrator safety: make ref[0]>=2*timestep
+  mjDSBL_SENSOR       = 1<<12,    // sensors
+  mjDSBL_MIDPHASE     = 1<<13,    // mid-phase collision filtering
+
+  mjNDISABLE          = 14        // number of disable flags
+} mjtDisableBit;
+
+
+typedef enum mjtEnableBit_ {      // enable optional feature bitflags
+  mjENBL_OVERRIDE     = 1<<0,     // override contact parameters
+  mjENBL_ENERGY       = 1<<1,     // energy computation
+  mjENBL_FWDINV       = 1<<2,     // record solver statistics
+  mjENBL_SENSORNOISE  = 1<<3,     // add noise to sensor data
+                                  // experimental features:
+  mjENBL_MULTICCD     = 1<<4,     // multi-point convex collision detection
+
+  mjNENABLE           = 5         // number of enable flags
+} mjtEnableBit;
+
+
+typedef enum mjtJoint_ {          // type of degree of freedom
+  mjJNT_FREE          = 0,        // global position and orientation (quat)       (7)
+  mjJNT_BALL,                     // orientation (quat) relative to parent        (4)
+  mjJNT_SLIDE,                    // sliding distance along body-fixed axis       (1)
+  mjJNT_HINGE                     // rotation angle (rad) around body-fixed axis  (1)
+} mjtJoint;
+
+
+typedef enum mjtGeom_ {           // type of geometric shape
+  // regular geom types
+  mjGEOM_PLANE        = 0,        // plane
+  mjGEOM_HFIELD,                  // height field
+  mjGEOM_SPHERE,                  // sphere
+  mjGEOM_CAPSULE,                 // capsule
+  mjGEOM_ELLIPSOID,               // ellipsoid
+  mjGEOM_CYLINDER,                // cylinder
+  mjGEOM_BOX,                     // box
+  mjGEOM_MESH,                    // mesh
+
+  mjNGEOMTYPES,                   // number of regular geom types
+
+  // rendering-only geom types: not used in mjModel, not counted in mjNGEOMTYPES
+  mjGEOM_ARROW        = 100,      // arrow
+  mjGEOM_ARROW1,                  // arrow without wedges
+  mjGEOM_ARROW2,                  // arrow in both directions
+  mjGEOM_LINE,                    // line
+  mjGEOM_SKIN,                    // skin
+  mjGEOM_LABEL,                   // text label
+
+  mjGEOM_NONE         = 1001      // missing geom type
+} mjtGeom;
+
+
+typedef enum mjtCamLight_ {       // tracking mode for camera and light
+  mjCAMLIGHT_FIXED    = 0,        // pos and rot fixed in body
+  mjCAMLIGHT_TRACK,               // pos tracks body, rot fixed in global
+  mjCAMLIGHT_TRACKCOM,            // pos tracks subtree com, rot fixed in body
+  mjCAMLIGHT_TARGETBODY,          // pos fixed in body, rot tracks target body
+  mjCAMLIGHT_TARGETBODYCOM        // pos fixed in body, rot tracks target subtree com
+} mjtCamLight;
+
+
+typedef enum mjtTexture_ {        // type of texture
+  mjTEXTURE_2D        = 0,        // 2d texture, suitable for planes and hfields
+  mjTEXTURE_CUBE,                 // cube texture, suitable for all other geom types
+  mjTEXTURE_SKYBOX                // cube texture used as skybox
+} mjtTexture;
+
+
+typedef enum mjtIntegrator_ {     // integrator mode
+  mjINT_EULER         = 0,        // semi-implicit Euler
+  mjINT_RK4,                      // 4th-order Runge Kutta
+  mjINT_IMPLICIT,                 // implicit in velocity
+  mjINT_IMPLICITFAST              // implicit in velocity, no rne derivative
+} mjtIntegrator;
+
+
+typedef enum mjtCollision_ {      // collision mode for selecting geom pairs
+  mjCOL_ALL           = 0,        // test precomputed and dynamic pairs
+  mjCOL_PAIR,                     // test predefined pairs only
+  mjCOL_DYNAMIC                   // test dynamic pairs only
+} mjtCollision;
+
+
+typedef enum mjtCone_ {           // type of friction cone
+  mjCONE_PYRAMIDAL     = 0,       // pyramidal
+  mjCONE_ELLIPTIC                 // elliptic
+} mjtCone;
+
+
+typedef enum mjtJacobian_ {       // type of constraint Jacobian
+  mjJAC_DENSE          = 0,       // dense
+  mjJAC_SPARSE,                   // sparse
+  mjJAC_AUTO                      // dense if nv<60, sparse otherwise
+} mjtJacobian;
+
+
+typedef enum mjtSolver_ {         // constraint solver algorithm
+  mjSOL_PGS            = 0,       // PGS    (dual)
+  mjSOL_CG,                       // CG     (primal)
+  mjSOL_NEWTON                    // Newton (primal)
+} mjtSolver;
+
+
+typedef enum mjtEq_ {             // type of equality constraint
+  mjEQ_CONNECT        = 0,        // connect two bodies at a point (ball joint)
+  mjEQ_WELD,                      // fix relative position and orientation of two bodies
+  mjEQ_JOINT,                     // couple the values of two scalar joints with cubic
+  mjEQ_TENDON,                    // couple the lengths of two tendons with cubic
+  mjEQ_DISTANCE                   // unsupported, will cause an error if used
+} mjtEq;
+
+
+typedef enum mjtWrap_ {           // type of tendon wrap object
+  mjWRAP_NONE         = 0,        // null object
+  mjWRAP_JOINT,                   // constant moment arm
+  mjWRAP_PULLEY,                  // pulley used to split tendon
+  mjWRAP_SITE,                    // pass through site
+  mjWRAP_SPHERE,                  // wrap around sphere
+  mjWRAP_CYLINDER                 // wrap around (infinite) cylinder
+} mjtWrap;
+
+
+typedef enum mjtTrn_ {            // type of actuator transmission
+  mjTRN_JOINT         = 0,        // force on joint
+  mjTRN_JOINTINPARENT,            // force on joint, expressed in parent frame
+  mjTRN_SLIDERCRANK,              // force via slider-crank linkage
+  mjTRN_TENDON,                   // force on tendon
+  mjTRN_SITE,                     // force on site
+  mjTRN_BODY,                     // adhesion force on a body's geoms
+
+  mjTRN_UNDEFINED     = 1000      // undefined transmission type
+} mjtTrn;
+
+
+typedef enum mjtDyn_ {            // type of actuator dynamics
+  mjDYN_NONE          = 0,        // no internal dynamics; ctrl specifies force
+  mjDYN_INTEGRATOR,               // integrator: da/dt = u
+  mjDYN_FILTER,                   // linear filter: da/dt = (u-a) / tau
+  mjDYN_FILTEREXACT,              // linear filter: da/dt = (u-a) / tau, with exact integration
+  mjDYN_MUSCLE,                   // piece-wise linear filter with two time constants
+  mjDYN_USER                      // user-defined dynamics type
+} mjtDyn;
+
+
+typedef enum mjtGain_ {           // type of actuator gain
+  mjGAIN_FIXED        = 0,        // fixed gain
+  mjGAIN_AFFINE,                  // const + kp*length + kv*velocity
+  mjGAIN_MUSCLE,                  // muscle FLV curve computed by mju_muscleGain()
+  mjGAIN_USER                     // user-defined gain type
+} mjtGain;
+
+
+typedef enum mjtBias_ {           // type of actuator bias
+  mjBIAS_NONE         = 0,        // no bias
+  mjBIAS_AFFINE,                  // const + kp*length + kv*velocity
+  mjBIAS_MUSCLE,                  // muscle passive force computed by mju_muscleBias()
+  mjBIAS_USER                     // user-defined bias type
+} mjtBias;
+
+
+typedef enum mjtObj_ {            // type of MujoCo object
+  mjOBJ_UNKNOWN       = 0,        // unknown object type
+  mjOBJ_BODY,                     // body
+  mjOBJ_XBODY,                    // body, used to access regular frame instead of i-frame
+  mjOBJ_JOINT,                    // joint
+  mjOBJ_DOF,                      // dof
+  mjOBJ_GEOM,                     // geom
+  mjOBJ_SITE,                     // site
+  mjOBJ_CAMERA,                   // camera
+  mjOBJ_LIGHT,                    // light
+  mjOBJ_MESH,                     // mesh
+  mjOBJ_SKIN,                     // skin
+  mjOBJ_HFIELD,                   // heightfield
+  mjOBJ_TEXTURE,                  // texture
+  mjOBJ_MATERIAL,                 // material for rendering
+  mjOBJ_PAIR,                     // geom pair to include
+  mjOBJ_EXCLUDE,                  // body pair to exclude
+  mjOBJ_EQUALITY,                 // equality constraint
+  mjOBJ_TENDON,                   // tendon
+  mjOBJ_ACTUATOR,                 // actuator
+  mjOBJ_SENSOR,                   // sensor
+  mjOBJ_NUMERIC,                  // numeric
+  mjOBJ_TEXT,                     // text
+  mjOBJ_TUPLE,                    // tuple
+  mjOBJ_KEY,                      // keyframe
+  mjOBJ_PLUGIN                    // plugin instance
+} mjtObj;
+
+
+typedef enum mjtConstraint_ {     // type of constraint
+  mjCNSTR_EQUALITY    = 0,        // equality constraint
+  mjCNSTR_FRICTION_DOF,           // dof friction
+  mjCNSTR_FRICTION_TENDON,        // tendon friction
+  mjCNSTR_LIMIT_JOINT,            // joint limit
+  mjCNSTR_LIMIT_TENDON,           // tendon limit
+  mjCNSTR_CONTACT_FRICTIONLESS,   // frictionless contact
+  mjCNSTR_CONTACT_PYRAMIDAL,      // frictional contact, pyramidal friction cone
+  mjCNSTR_CONTACT_ELLIPTIC        // frictional contact, elliptic friction cone
+} mjtConstraint;
+
+
+typedef enum mjtConstraintState_ {  // constraint state
+  mjCNSTRSTATE_SATISFIED = 0,       // constraint satisfied, zero cost (limit, contact)
+  mjCNSTRSTATE_QUADRATIC,           // quadratic cost (equality, friction, limit, contact)
+  mjCNSTRSTATE_LINEARNEG,           // linear cost, negative side (friction)
+  mjCNSTRSTATE_LINEARPOS,           // linear cost, positive side (friction)
+  mjCNSTRSTATE_CONE                 // squared distance to cone cost (elliptic contact)
+} mjtConstraintState;
+
+
+typedef enum mjtSensor_ {         // type of sensor
+  // common robotic sensors, attached to a site
+  mjSENS_TOUCH        = 0,        // scalar contact normal forces summed over sensor zone
+  mjSENS_ACCELEROMETER,           // 3D linear acceleration, in local frame
+  mjSENS_VELOCIMETER,             // 3D linear velocity, in local frame
+  mjSENS_GYRO,                    // 3D angular velocity, in local frame
+  mjSENS_FORCE,                   // 3D force between site's body and its parent body
+  mjSENS_TORQUE,                  // 3D torque between site's body and its parent body
+  mjSENS_MAGNETOMETER,            // 3D magnetometer
+  mjSENS_RANGEFINDER,             // scalar distance to nearest geom or site along z-axis
+
+  // sensors related to scalar joints, tendons, actuators
+  mjSENS_JOINTPOS,                // scalar joint position (hinge and slide only)
+  mjSENS_JOINTVEL,                // scalar joint velocity (hinge and slide only)
+  mjSENS_TENDONPOS,               // scalar tendon position
+  mjSENS_TENDONVEL,               // scalar tendon velocity
+  mjSENS_ACTUATORPOS,             // scalar actuator position
+  mjSENS_ACTUATORVEL,             // scalar actuator velocity
+  mjSENS_ACTUATORFRC,             // scalar actuator force
+  mjSENS_JOINTACTFRC,             // scalar actuator force, measured at the joint
+
+  // sensors related to ball joints
+  mjSENS_BALLQUAT,                // 4D ball joint quaternion
+  mjSENS_BALLANGVEL,              // 3D ball joint angular velocity
+
+  // joint and tendon limit sensors, in constraint space
+  mjSENS_JOINTLIMITPOS,           // joint limit distance-margin
+  mjSENS_JOINTLIMITVEL,           // joint limit velocity
+  mjSENS_JOINTLIMITFRC,           // joint limit force
+  mjSENS_TENDONLIMITPOS,          // tendon limit distance-margin
+  mjSENS_TENDONLIMITVEL,          // tendon limit velocity
+  mjSENS_TENDONLIMITFRC,          // tendon limit force
+
+  // sensors attached to an object with spatial frame: (x)body, geom, site, camera
+  mjSENS_FRAMEPOS,                // 3D position
+  mjSENS_FRAMEQUAT,               // 4D unit quaternion orientation
+  mjSENS_FRAMEXAXIS,              // 3D unit vector: x-axis of object's frame
+  mjSENS_FRAMEYAXIS,              // 3D unit vector: y-axis of object's frame
+  mjSENS_FRAMEZAXIS,              // 3D unit vector: z-axis of object's frame
+  mjSENS_FRAMELINVEL,             // 3D linear velocity
+  mjSENS_FRAMEANGVEL,             // 3D angular velocity
+  mjSENS_FRAMELINACC,             // 3D linear acceleration
+  mjSENS_FRAMEANGACC,             // 3D angular acceleration
+
+  // sensors related to kinematic subtrees; attached to a body (which is the subtree root)
+  mjSENS_SUBTREECOM,              // 3D center of mass of subtree
+  mjSENS_SUBTREELINVEL,           // 3D linear velocity of subtree
+  mjSENS_SUBTREEANGMOM,           // 3D angular momentum of subtree
+
+  // global sensors
+  mjSENS_CLOCK,                   // simulation time
+
+  // plugin-controlled sensors
+  mjSENS_PLUGIN,                  // plugin-controlled
+
+  // user-defined sensor
+  mjSENS_USER                     // sensor data provided by mjcb_sensor callback
+} mjtSensor;
+
+
+typedef enum mjtStage_ {          // computation stage
+  mjSTAGE_NONE        = 0,        // no computations
+  mjSTAGE_POS,                    // position-dependent computations
+  mjSTAGE_VEL,                    // velocity-dependent computations
+  mjSTAGE_ACC                     // acceleration/force-dependent computations
+} mjtStage;
+
+
+typedef enum mjtDataType_ {       // data type for sensors
+  mjDATATYPE_REAL     = 0,        // real values, no constraints
+  mjDATATYPE_POSITIVE,            // positive values; 0 or negative: inactive
+  mjDATATYPE_AXIS,                // 3D unit vector
+  mjDATATYPE_QUATERNION           // unit quaternion
+} mjtDataType;
+
+
+typedef enum mjtLRMode_ {         // mode for actuator length range computation
+  mjLRMODE_NONE   = 0,            // do not process any actuators
+  mjLRMODE_MUSCLE,                // process muscle actuators
+  mjLRMODE_MUSCLEUSER,            // process muscle and user actuators
+  mjLRMODE_ALL                    // process all actuators
+} mjtLRMode;
+
+
+//---------------------------------- mjLROpt -------------------------------------------------------
+
+struct mjLROpt_ {                 // options for mj_setLengthRange()
+  // flags
+  int mode;                       // which actuators to process (mjtLRMode)
+  int useexisting;                // use existing length range if available
+  int uselimit;                   // use joint and tendon limits if available
+
+  // algorithm parameters
+  mjtNum accel;                   // target acceleration used to compute force
+  mjtNum maxforce;                // maximum force; 0: no limit
+  mjtNum timeconst;               // time constant for velocity reduction; min 0.01
+  mjtNum timestep;                // simulation timestep; 0: use mjOption.timestep
+  mjtNum inttotal;                // total simulation time interval
+  mjtNum interval;                // evaluation time interval (at the end)
+  mjtNum tolrange;                // convergence tolerance (relative to range)
+};
+typedef struct mjLROpt_ mjLROpt;
+
+
+//---------------------------------- mjVFS ---------------------------------------------------------
+
+struct mjVFS_ {                            // virtual file system for loading from memory
+  int   nfile;                             // number of files present
+  char  filename[mjMAXVFS][mjMAXVFSNAME];  // file name without path
+  int   filesize[mjMAXVFS];                // file size in bytes
+  void* filedata[mjMAXVFS];                // buffer with file data
+};
+typedef struct mjVFS_ mjVFS;
+
+
+//---------------------------------- mjResource ----------------------------------------------------
+
+struct mjResource_ {
+  char* name;                     // name of resource (filename, etc)
+  void* data;                     // opaque data pointer
+  const void* provider_data;      // opaque resource provider data
+
+  // reading callback from resource provider
+  int (*read)(struct mjResource_* resource, const void** buffer);
+
+  // closing callback from resource provider
+  void (*close)(struct mjResource_* resource);
+
+  // getdir callback from resource provider
+  void (*getdir)(struct mjResource_* resource, const char** dir, int* ndir);
+};
+typedef struct mjResource_ mjResource;
+
+
+//---------------------------------- mjOption ------------------------------------------------------
+
+struct mjOption_ {                // physics options
+  // timing parameters
+  mjtNum timestep;                // timestep
+  mjtNum apirate;                 // update rate for remote API (Hz)
+
+  // solver parameters
+  mjtNum impratio;                // ratio of friction-to-normal contact impedance
+  mjtNum tolerance;               // main solver tolerance
+  mjtNum noslip_tolerance;        // noslip solver tolerance
+  mjtNum mpr_tolerance;           // MPR solver tolerance
+
+  // physical constants
+  mjtNum gravity[3];              // gravitational acceleration
+  mjtNum wind[3];                 // wind (for lift, drag and viscosity)
+  mjtNum magnetic[3];             // global magnetic flux
+  mjtNum density;                 // density of medium
+  mjtNum viscosity;               // viscosity of medium
+
+  // override contact solver parameters (if enabled)
+  mjtNum o_margin;                // margin
+  mjtNum o_solref[mjNREF];        // solref
+  mjtNum o_solimp[mjNIMP];        // solimp
+
+  // discrete settings
+  int integrator;                 // integration mode (mjtIntegrator)
+  int collision;                  // collision mode (mjtCollision)
+  int cone;                       // type of friction cone (mjtCone)
+  int jacobian;                   // type of Jacobian (mjtJacobian)
+  int solver;                     // solver algorithm (mjtSolver)
+  int iterations;                 // maximum number of main solver iterations
+  int noslip_iterations;          // maximum number of noslip solver iterations
+  int mpr_iterations;             // maximum number of MPR solver iterations
+  int disableflags;               // bit flags for disabling standard features
+  int enableflags;                // bit flags for enabling optional features
+};
+typedef struct mjOption_ mjOption;
+
+
+//---------------------------------- mjVisual ------------------------------------------------------
+
+struct mjVisual_ {                // visualization options
+  struct {                        // global parameters
+    float fovy;                   // y-field of view for free camera (degrees)
+    float ipd;                    // inter-pupilary distance for free camera
+    float azimuth;                // initial azimuth of free camera (degrees)
+    float elevation;              // initial elevation of free camera (degrees)
+    float linewidth;              // line width for wireframe and ray rendering
+    float glow;                   // glow coefficient for selected body
+    float realtime;               // initial real-time factor (1: real time)
+    int offwidth;                 // width of offscreen buffer
+    int offheight;                // height of offscreen buffer
+    int ellipsoidinertia;         // geom for inertia visualization (0: box, 1: ellipsoid)
+  } global;
+
+  struct {                        // rendering quality
+    int   shadowsize;             // size of shadowmap texture
+    int   offsamples;             // number of multisamples for offscreen rendering
+    int   numslices;              // number of slices for builtin geom drawing
+    int   numstacks;              // number of stacks for builtin geom drawing
+    int   numquads;               // number of quads for box rendering
+  } quality;
+
+  struct {                        // head light
+    float ambient[3];             // ambient rgb (alpha=1)
+    float diffuse[3];             // diffuse rgb (alpha=1)
+    float specular[3];            // specular rgb (alpha=1)
+    int   active;                 // is headlight active
+  } headlight;
+
+  struct {                        // mapping
+    float stiffness;              // mouse perturbation stiffness (space->force)
+    float stiffnessrot;           // mouse perturbation stiffness (space->torque)
+    float force;                  // from force units to space units
+    float torque;                 // from torque units to space units
+    float alpha;                  // scale geom alphas when transparency is enabled
+    float fogstart;               // OpenGL fog starts at fogstart * mjModel.stat.extent
+    float fogend;                 // OpenGL fog ends at fogend * mjModel.stat.extent
+    float znear;                  // near clipping plane = znear * mjModel.stat.extent
+    float zfar;                   // far clipping plane = zfar * mjModel.stat.extent
+    float haze;                   // haze ratio
+    float shadowclip;             // directional light: shadowclip * mjModel.stat.extent
+    float shadowscale;            // spot light: shadowscale * light.cutoff
+    float actuatortendon;         // scale tendon width
+  } map;
+
+  struct {                        // scale of decor elements relative to mean body size
+    float forcewidth;             // width of force arrow
+    float contactwidth;           // contact width
+    float contactheight;          // contact height
+    float connect;                // autoconnect capsule width
+    float com;                    // com radius
+    float camera;                 // camera object
+    float light;                  // light object
+    float selectpoint;            // selection point
+    float jointlength;            // joint length
+    float jointwidth;             // joint width
+    float actuatorlength;         // actuator length
+    float actuatorwidth;          // actuator width
+    float framelength;            // bodyframe axis length
+    float framewidth;             // bodyframe axis width
+    float constraint;             // constraint width
+    float slidercrank;            // slidercrank width
+  } scale;
+
+  struct {                        // color of decor elements
+    float fog[4];                 // fog
+    float haze[4];                // haze
+    float force[4];               // external force
+    float inertia[4];             // inertia box
+    float joint[4];               // joint
+    float actuator[4];            // actuator, neutral
+    float actuatornegative[4];    // actuator, negative limit
+    float actuatorpositive[4];    // actuator, positive limit
+    float com[4];                 // center of mass
+    float camera[4];              // camera object
+    float light[4];               // light object
+    float selectpoint[4];         // selection point
+    float connect[4];             // auto connect
+    float contactpoint[4];        // contact point
+    float contactforce[4];        // contact force
+    float contactfriction[4];     // contact friction force
+    float contacttorque[4];       // contact torque
+    float contactgap[4];          // contact point in gap
+    float rangefinder[4];         // rangefinder ray
+    float constraint[4];          // constraint
+    float slidercrank[4];         // slidercrank
+    float crankbroken[4];         // used when crank must be stretched/broken
+  } rgba;
+};
+typedef struct mjVisual_ mjVisual;
+
+
+//---------------------------------- mjStatistic ---------------------------------------------------
+
+struct mjStatistic_ {             // model statistics (in qpos0)
+  mjtNum meaninertia;             // mean diagonal inertia
+  mjtNum meanmass;                // mean body mass
+  mjtNum meansize;                // mean body size
+  mjtNum extent;                  // spatial extent
+  mjtNum center[3];               // center of model
+};
+typedef struct mjStatistic_ mjStatistic;
+
+
+//---------------------------------- mjModel -------------------------------------------------------
+
+struct mjModel_ {
+  // ------------------------------- sizes
+
+  // sizes needed at mjModel construction
+  int nq;                         // number of generalized coordinates = dim(qpos)
+  int nv;                         // number of degrees of freedom = dim(qvel)
+  int nu;                         // number of actuators/controls = dim(ctrl)
+  int na;                         // number of activation states = dim(act)
+  int nbody;                      // number of bodies
+  int nbvh;                       // number of total bounding volumes in all bodies
+  int njnt;                       // number of joints
+  int ngeom;                      // number of geoms
+  int nsite;                      // number of sites
+  int ncam;                       // number of cameras
+  int nlight;                     // number of lights
+  int nmesh;                      // number of meshes
+  int nmeshvert;                  // number of vertices in all meshes
+  int nmeshnormal;                // number of normals in all meshes
+  int nmeshtexcoord;              // number of texcoords in all meshes
+  int nmeshface;                  // number of triangular faces in all meshes
+  int nmeshgraph;                 // number of ints in mesh auxiliary data
+  int nskin;                      // number of skins
+  int nskinvert;                  // number of vertices in all skins
+  int nskintexvert;               // number of vertiex with texcoords in all skins
+  int nskinface;                  // number of triangular faces in all skins
+  int nskinbone;                  // number of bones in all skins
+  int nskinbonevert;              // number of vertices in all skin bones
+  int nhfield;                    // number of heightfields
+  int nhfielddata;                // number of data points in all heightfields
+  int ntex;                       // number of textures
+  int ntexdata;                   // number of bytes in texture rgb data
+  int nmat;                       // number of materials
+  int npair;                      // number of predefined geom pairs
+  int nexclude;                   // number of excluded geom pairs
+  int neq;                        // number of equality constraints
+  int ntendon;                    // number of tendons
+  int nwrap;                      // number of wrap objects in all tendon paths
+  int nsensor;                    // number of sensors
+  int nnumeric;                   // number of numeric custom fields
+  int nnumericdata;               // number of mjtNums in all numeric fields
+  int ntext;                      // number of text custom fields
+  int ntextdata;                  // number of mjtBytes in all text fields
+  int ntuple;                     // number of tuple custom fields
+  int ntupledata;                 // number of objects in all tuple fields
+  int nkey;                       // number of keyframes
+  int nmocap;                     // number of mocap bodies
+  int nplugin;                    // number of plugin instances
+  int npluginattr;                // number of chars in all plugin config attributes
+  int nuser_body;                 // number of mjtNums in body_user
+  int nuser_jnt;                  // number of mjtNums in jnt_user
+  int nuser_geom;                 // number of mjtNums in geom_user
+  int nuser_site;                 // number of mjtNums in site_user
+  int nuser_cam;                  // number of mjtNums in cam_user
+  int nuser_tendon;               // number of mjtNums in tendon_user
+  int nuser_actuator;             // number of mjtNums in actuator_user
+  int nuser_sensor;               // number of mjtNums in sensor_user
+  int nnames;                     // number of chars in all names
+  int nnames_map;                 // number of slots in the names hash map
+
+  // sizes set after mjModel construction (only affect mjData)
+  int nM;                         // number of non-zeros in sparse inertia matrix
+  int nD;                         // number of non-zeros in sparse dof-dof matrix
+  int nB;                         // number of non-zeros in sparse body-dof matrix
+  int nemax;                      // number of potential equality-constraint rows
+  int njmax;                      // number of available rows in constraint Jacobian
+  int nconmax;                    // number of potential contacts in contact list
+  int nstack;                     // number of fields in mjData stack
+  int nuserdata;                  // number of extra fields in mjData
+  int nsensordata;                // number of fields in sensor data vector
+  int npluginstate;               // number of fields in the plugin state vector
+
+  int nbuffer;                    // number of bytes in buffer
+
+  // ------------------------------- options and statistics
+
+  mjOption opt;                   // physics options
+  mjVisual vis;                   // visualization options
+  mjStatistic stat;               // model statistics
+
+  // ------------------------------- buffers
+
+  // main buffer
+  void*     buffer;               // main buffer; all pointers point in it    (nbuffer)
+
+  // default generalized coordinates
+  mjtNum*   qpos0;                // qpos values at default pose              (nq x 1)
+  mjtNum*   qpos_spring;          // reference pose for springs               (nq x 1)
+
+  // bodies
+  int*      body_parentid;        // id of body's parent                      (nbody x 1)
+  int*      body_rootid;          // id of root above body                    (nbody x 1)
+  int*      body_weldid;          // id of body that this body is welded to   (nbody x 1)
+  int*      body_mocapid;         // id of mocap data; -1: none               (nbody x 1)
+  int*      body_jntnum;          // number of joints for this body           (nbody x 1)
+  int*      body_jntadr;          // start addr of joints; -1: no joints      (nbody x 1)
+  int*      body_dofnum;          // number of motion degrees of freedom      (nbody x 1)
+  int*      body_dofadr;          // start addr of dofs; -1: no dofs          (nbody x 1)
+  int*      body_geomnum;         // number of geoms                          (nbody x 1)
+  int*      body_geomadr;         // start addr of geoms; -1: no geoms        (nbody x 1)
+  mjtByte*  body_simple;          // body is simple (has diagonal M)          (nbody x 1)
+  mjtByte*  body_sameframe;       // inertial frame is same as body frame     (nbody x 1)
+  mjtNum*   body_pos;             // position offset rel. to parent body      (nbody x 3)
+  mjtNum*   body_quat;            // orientation offset rel. to parent body   (nbody x 4)
+  mjtNum*   body_ipos;            // local position of center of mass         (nbody x 3)
+  mjtNum*   body_iquat;           // local orientation of inertia ellipsoid   (nbody x 4)
+  mjtNum*   body_mass;            // mass                                     (nbody x 1)
+  mjtNum*   body_subtreemass;     // mass of subtree starting at this body    (nbody x 1)
+  mjtNum*   body_inertia;         // diagonal inertia in ipos/iquat frame     (nbody x 3)
+  mjtNum*   body_invweight0;      // mean inv inert in qpos0 (trn, rot)       (nbody x 2)
+  mjtNum*   body_gravcomp;        // antigravity force, units of body weight  (nbody x 1)
+  mjtNum*   body_user;            // user data                                (nbody x nuser_body)
+  int*      body_plugin;          // plugin instance id; -1: not in use       (nbody x 1)
+  int*      body_bvhadr;          // address of bvh root                      (nbody x 1)
+  int*      body_bvhnum;          // number of bounding volumes               (nbody x 1)
+
+  // bounding volume hierarchy
+  int*      bvh_depth;            // depth in the bounding volume hierarchy   (nbvh x 1)
+  int*      bvh_child;            // left and right children in tree          (nbvh x 2)
+  int*      bvh_geomid;           // geom id of the node; -1: non-leaf        (nbvh x 1)
+  mjtNum*   bvh_aabb;             // bounding box of node (center, size)      (nbvh x 6)
+
+  // joints
+  int*      jnt_type;             // type of joint (mjtJoint)                 (njnt x 1)
+  int*      jnt_qposadr;          // start addr in 'qpos' for joint's data    (njnt x 1)
+  int*      jnt_dofadr;           // start addr in 'qvel' for joint's data    (njnt x 1)
+  int*      jnt_bodyid;           // id of joint's body                       (njnt x 1)
+  int*      jnt_group;            // group for visibility                     (njnt x 1)
+  mjtByte*  jnt_limited;          // does joint have limits                   (njnt x 1)
+  mjtByte*  jnt_actfrclimited;    // does joint have actuator force limits    (njnt x 1)
+  mjtNum*   jnt_solref;           // constraint solver reference: limit       (njnt x mjNREF)
+  mjtNum*   jnt_solimp;           // constraint solver impedance: limit       (njnt x mjNIMP)
+  mjtNum*   jnt_pos;              // local anchor position                    (njnt x 3)
+  mjtNum*   jnt_axis;             // local joint axis                         (njnt x 3)
+  mjtNum*   jnt_stiffness;        // stiffness coefficient                    (njnt x 1)
+  mjtNum*   jnt_range;            // joint limits                             (njnt x 2)
+  mjtNum*   jnt_actfrcrange;      // range of total actuator force            (njnt x 2)
+  mjtNum*   jnt_margin;           // min distance for limit detection         (njnt x 1)
+  mjtNum*   jnt_user;             // user data                                (njnt x nuser_jnt)
+
+  // dofs
+  int*      dof_bodyid;           // id of dof's body                         (nv x 1)
+  int*      dof_jntid;            // id of dof's joint                        (nv x 1)
+  int*      dof_parentid;         // id of dof's parent; -1: none             (nv x 1)
+  int*      dof_Madr;             // dof address in M-diagonal                (nv x 1)
+  int*      dof_simplenum;        // number of consecutive simple dofs        (nv x 1)
+  mjtNum*   dof_solref;           // constraint solver reference:frictionloss (nv x mjNREF)
+  mjtNum*   dof_solimp;           // constraint solver impedance:frictionloss (nv x mjNIMP)
+  mjtNum*   dof_frictionloss;     // dof friction loss                        (nv x 1)
+  mjtNum*   dof_armature;         // dof armature inertia/mass                (nv x 1)
+  mjtNum*   dof_damping;          // damping coefficient                      (nv x 1)
+  mjtNum*   dof_invweight0;       // diag. inverse inertia in qpos0           (nv x 1)
+  mjtNum*   dof_M0;               // diag. inertia in qpos0                   (nv x 1)
+
+  // geoms
+  int*      geom_type;            // geometric type (mjtGeom)                 (ngeom x 1)
+  int*      geom_contype;         // geom contact type                        (ngeom x 1)
+  int*      geom_conaffinity;     // geom contact affinity                    (ngeom x 1)
+  int*      geom_condim;          // contact dimensionality (1, 3, 4, 6)      (ngeom x 1)
+  int*      geom_bodyid;          // id of geom's body                        (ngeom x 1)
+  int*      geom_dataid;          // id of geom's mesh/hfield; -1: none       (ngeom x 1)
+  int*      geom_matid;           // material id for rendering; -1: none      (ngeom x 1)
+  int*      geom_group;           // group for visibility                     (ngeom x 1)
+  int*      geom_priority;        // geom contact priority                    (ngeom x 1)
+  mjtByte*  geom_sameframe;       // same as body frame (1) or iframe (2)     (ngeom x 1)
+  mjtNum*   geom_solmix;          // mixing coef for solref/imp in geom pair  (ngeom x 1)
+  mjtNum*   geom_solref;          // constraint solver reference: contact     (ngeom x mjNREF)
+  mjtNum*   geom_solimp;          // constraint solver impedance: contact     (ngeom x mjNIMP)
+  mjtNum*   geom_size;            // geom-specific size parameters            (ngeom x 3)
+  mjtNum*   geom_aabb;            // bounding box, (center, size)             (ngeom x 6)
+  mjtNum*   geom_rbound;          // radius of bounding sphere                (ngeom x 1)
+  mjtNum*   geom_pos;             // local position offset rel. to body       (ngeom x 3)
+  mjtNum*   geom_quat;            // local orientation offset rel. to body    (ngeom x 4)
+  mjtNum*   geom_friction;        // friction for (slide, spin, roll)         (ngeom x 3)
+  mjtNum*   geom_margin;          // detect contact if dist<margin            (ngeom x 1)
+  mjtNum*   geom_gap;             // include in solver if dist<margin-gap     (ngeom x 1)
+  mjtNum*   geom_fluid;           // fluid interaction parameters             (ngeom x mjNFLUID)
+  mjtNum*   geom_user;            // user data                                (ngeom x nuser_geom)
+  float*    geom_rgba;            // rgba when material is omitted            (ngeom x 4)
+
+  // sites
+  int*      site_type;            // geom type for rendering (mjtGeom)        (nsite x 1)
+  int*      site_bodyid;          // id of site's body                        (nsite x 1)
+  int*      site_matid;           // material id for rendering; -1: none      (nsite x 1)
+  int*      site_group;           // group for visibility                     (nsite x 1)
+  mjtByte*  site_sameframe;       // same as body frame (1) or iframe (2)     (nsite x 1)
+  mjtNum*   site_size;            // geom size for rendering                  (nsite x 3)
+  mjtNum*   site_pos;             // local position offset rel. to body       (nsite x 3)
+  mjtNum*   site_quat;            // local orientation offset rel. to body    (nsite x 4)
+  mjtNum*   site_user;            // user data                                (nsite x nuser_site)
+  float*    site_rgba;            // rgba when material is omitted            (nsite x 4)
+
+  // cameras
+  int*      cam_mode;             // camera tracking mode (mjtCamLight)       (ncam x 1)
+  int*      cam_bodyid;           // id of camera's body                      (ncam x 1)
+  int*      cam_targetbodyid;     // id of targeted body; -1: none            (ncam x 1)
+  mjtNum*   cam_pos;              // position rel. to body frame              (ncam x 3)
+  mjtNum*   cam_quat;             // orientation rel. to body frame           (ncam x 4)
+  mjtNum*   cam_poscom0;          // global position rel. to sub-com in qpos0 (ncam x 3)
+  mjtNum*   cam_pos0;             // global position rel. to body in qpos0    (ncam x 3)
+  mjtNum*   cam_mat0;             // global orientation in qpos0              (ncam x 9)
+  mjtNum*   cam_fovy;             // y-field of view (deg)                    (ncam x 1)
+  mjtNum*   cam_ipd;              // inter-pupilary distance                  (ncam x 1)
+  mjtNum*   cam_user;             // user data                                (ncam x nuser_cam)
+
+  // lights
+  int*      light_mode;           // light tracking mode (mjtCamLight)        (nlight x 1)
+  int*      light_bodyid;         // id of light's body                       (nlight x 1)
+  int*      light_targetbodyid;   // id of targeted body; -1: none            (nlight x 1)
+  mjtByte*  light_directional;    // directional light                        (nlight x 1)
+  mjtByte*  light_castshadow;     // does light cast shadows                  (nlight x 1)
+  mjtByte*  light_active;         // is light on                              (nlight x 1)
+  mjtNum*   light_pos;            // position rel. to body frame              (nlight x 3)
+  mjtNum*   light_dir;            // direction rel. to body frame             (nlight x 3)
+  mjtNum*   light_poscom0;        // global position rel. to sub-com in qpos0 (nlight x 3)
+  mjtNum*   light_pos0;           // global position rel. to body in qpos0    (nlight x 3)
+  mjtNum*   light_dir0;           // global direction in qpos0                (nlight x 3)
+  float*    light_attenuation;    // OpenGL attenuation (quadratic model)     (nlight x 3)
+  float*    light_cutoff;         // OpenGL cutoff                            (nlight x 1)
+  float*    light_exponent;       // OpenGL exponent                          (nlight x 1)
+  float*    light_ambient;        // ambient rgb (alpha=1)                    (nlight x 3)
+  float*    light_diffuse;        // diffuse rgb (alpha=1)                    (nlight x 3)
+  float*    light_specular;       // specular rgb (alpha=1)                   (nlight x 3)
+
+  // meshes
+  int*      mesh_vertadr;         // first vertex address                     (nmesh x 1)
+  int*      mesh_vertnum;         // number of vertices                       (nmesh x 1)
+  int*      mesh_faceadr;         // first face address                       (nmesh x 1)
+  int*      mesh_facenum;         // number of faces                          (nmesh x 1)
+  int*      mesh_bvhadr;          // address of bvh root                      (nmesh x 1)
+  int*      mesh_bvhnum;          // number of bvh                            (nmesh x 1)
+  int*      mesh_normaladr;       // first normal address                     (nmesh x 1)
+  int*      mesh_normalnum;       // number of normals                        (nmesh x 1)
+  int*      mesh_texcoordadr;     // texcoord data address; -1: no texcoord   (nmesh x 1)
+  int*      mesh_texcoordnum;     // number of texcoord                       (nmesh x 1)
+  int*      mesh_graphadr;        // graph data address; -1: no graph         (nmesh x 1)
+  float*    mesh_vert;            // vertex positions for all meshes          (nmeshvert x 3)
+  float*    mesh_normal;          // normals for all meshes                   (nmeshnormal x 3)
+  float*    mesh_texcoord;        // vertex texcoords for all meshes          (nmeshtexcoord x 2)
+  int*      mesh_face;            // vertex face data                         (nmeshface x 3)
+  int*      mesh_facenormal;      // normal face data                         (nmeshface x 3)
+  int*      mesh_facetexcoord;    // texture face data                        (nmeshface x 3)
+  int*      mesh_graph;           // convex graph data                        (nmeshgraph x 1)
+
+  // skins
+  int*      skin_matid;           // skin material id; -1: none               (nskin x 1)
+  int*      skin_group;           // group for visibility                     (nskin x 1)
+  float*    skin_rgba;            // skin rgba                                (nskin x 4)
+  float*    skin_inflate;         // inflate skin in normal direction         (nskin x 1)
+  int*      skin_vertadr;         // first vertex address                     (nskin x 1)
+  int*      skin_vertnum;         // number of vertices                       (nskin x 1)
+  int*      skin_texcoordadr;     // texcoord data address; -1: no texcoord   (nskin x 1)
+  int*      skin_faceadr;         // first face address                       (nskin x 1)
+  int*      skin_facenum;         // number of faces                          (nskin x 1)
+  int*      skin_boneadr;         // first bone in skin                       (nskin x 1)
+  int*      skin_bonenum;         // number of bones in skin                  (nskin x 1)
+  float*    skin_vert;            // vertex positions for all skin meshes     (nskinvert x 3)
+  float*    skin_texcoord;        // vertex texcoords for all skin meshes     (nskintexvert x 2)
+  int*      skin_face;            // triangle faces for all skin meshes       (nskinface x 3)
+  int*      skin_bonevertadr;     // first vertex in each bone                (nskinbone x 1)
+  int*      skin_bonevertnum;     // number of vertices in each bone          (nskinbone x 1)
+  float*    skin_bonebindpos;     // bind pos of each bone                    (nskinbone x 3)
+  float*    skin_bonebindquat;    // bind quat of each bone                   (nskinbone x 4)
+  int*      skin_bonebodyid;      // body id of each bone                     (nskinbone x 1)
+  int*      skin_bonevertid;      // mesh ids of vertices in each bone        (nskinbonevert x 1)
+  float*    skin_bonevertweight;  // weights of vertices in each bone         (nskinbonevert x 1)
+
+  // height fields
+  mjtNum*   hfield_size;          // (x, y, z_top, z_bottom)                  (nhfield x 4)
+  int*      hfield_nrow;          // number of rows in grid                   (nhfield x 1)
+  int*      hfield_ncol;          // number of columns in grid                (nhfield x 1)
+  int*      hfield_adr;           // address in hfield_data                   (nhfield x 1)
+  float*    hfield_data;          // elevation data                           (nhfielddata x 1)
+
+  // textures
+  int*      tex_type;             // texture type (mjtTexture)                (ntex x 1)
+  int*      tex_height;           // number of rows in texture image          (ntex x 1)
+  int*      tex_width;            // number of columns in texture image       (ntex x 1)
+  int*      tex_adr;              // address in rgb                           (ntex x 1)
+  mjtByte*  tex_rgb;              // rgb (alpha = 1)                          (ntexdata x 1)
+
+  // materials
+  int*      mat_texid;            // texture id; -1: none                     (nmat x 1)
+  mjtByte*  mat_texuniform;       // make texture cube uniform                (nmat x 1)
+  float*    mat_texrepeat;        // texture repetition for 2d mapping        (nmat x 2)
+  float*    mat_emission;         // emission (x rgb)                         (nmat x 1)
+  float*    mat_specular;         // specular (x white)                       (nmat x 1)
+  float*    mat_shininess;        // shininess coef                           (nmat x 1)
+  float*    mat_reflectance;      // reflectance (0: disable)                 (nmat x 1)
+  float*    mat_rgba;             // rgba                                     (nmat x 4)
+
+  // predefined geom pairs for collision detection; has precedence over exclude
+  int*      pair_dim;             // contact dimensionality                   (npair x 1)
+  int*      pair_geom1;           // id of geom1                              (npair x 1)
+  int*      pair_geom2;           // id of geom2                              (npair x 1)
+  int*      pair_signature;       // (body1+1) << 16 + body2+1                (npair x 1)
+  mjtNum*   pair_solref;          // solver reference: contact normal         (npair x mjNREF)
+  mjtNum*   pair_solreffriction;  // solver reference: contact friction       (npair x mjNREF)
+  mjtNum*   pair_solimp;          // solver impedance: contact                (npair x mjNIMP)
+  mjtNum*   pair_margin;          // detect contact if dist<margin            (npair x 1)
+  mjtNum*   pair_gap;             // include in solver if dist<margin-gap     (npair x 1)
+  mjtNum*   pair_friction;        // tangent1, 2, spin, roll1, 2              (npair x 5)
+
+  // excluded body pairs for collision detection
+  int*      exclude_signature;    // (body1+1) << 16 + body2+1                (nexclude x 1)
+
+  // equality constraints
+  int*      eq_type;              // constraint type (mjtEq)                  (neq x 1)
+  int*      eq_obj1id;            // id of object 1                           (neq x 1)
+  int*      eq_obj2id;            // id of object 2                           (neq x 1)
+  mjtByte*  eq_active;            // enable/disable constraint                (neq x 1)
+  mjtNum*   eq_solref;            // constraint solver reference              (neq x mjNREF)
+  mjtNum*   eq_solimp;            // constraint solver impedance              (neq x mjNIMP)
+  mjtNum*   eq_data;              // numeric data for constraint              (neq x mjNEQDATA)
+
+  // tendons
+  int*      tendon_adr;           // address of first object in tendon's path (ntendon x 1)
+  int*      tendon_num;           // number of objects in tendon's path       (ntendon x 1)
+  int*      tendon_matid;         // material id for rendering                (ntendon x 1)
+  int*      tendon_group;         // group for visibility                     (ntendon x 1)
+  mjtByte*  tendon_limited;       // does tendon have length limits           (ntendon x 1)
+  mjtNum*   tendon_width;         // width for rendering                      (ntendon x 1)
+  mjtNum*   tendon_solref_lim;    // constraint solver reference: limit       (ntendon x mjNREF)
+  mjtNum*   tendon_solimp_lim;    // constraint solver impedance: limit       (ntendon x mjNIMP)
+  mjtNum*   tendon_solref_fri;    // constraint solver reference: friction    (ntendon x mjNREF)
+  mjtNum*   tendon_solimp_fri;    // constraint solver impedance: friction    (ntendon x mjNIMP)
+  mjtNum*   tendon_range;         // tendon length limits                     (ntendon x 2)
+  mjtNum*   tendon_margin;        // min distance for limit detection         (ntendon x 1)
+  mjtNum*   tendon_stiffness;     // stiffness coefficient                    (ntendon x 1)
+  mjtNum*   tendon_damping;       // damping coefficient                      (ntendon x 1)
+  mjtNum*   tendon_frictionloss;  // loss due to friction                     (ntendon x 1)
+  mjtNum*   tendon_lengthspring;  // spring resting length range              (ntendon x 2)
+  mjtNum*   tendon_length0;       // tendon length in qpos0                   (ntendon x 1)
+  mjtNum*   tendon_invweight0;    // inv. weight in qpos0                     (ntendon x 1)
+  mjtNum*   tendon_user;          // user data                                (ntendon x nuser_tendon)
+  float*    tendon_rgba;          // rgba when material is omitted            (ntendon x 4)
+
+  // list of all wrap objects in tendon paths
+  int*      wrap_type;            // wrap object type (mjtWrap)               (nwrap x 1)
+  int*      wrap_objid;           // object id: geom, site, joint             (nwrap x 1)
+  mjtNum*   wrap_prm;             // divisor, joint coef, or site id          (nwrap x 1)
+
+  // actuators
+  int*      actuator_trntype;     // transmission type (mjtTrn)               (nu x 1)
+  int*      actuator_dyntype;     // dynamics type (mjtDyn)                   (nu x 1)
+  int*      actuator_gaintype;    // gain type (mjtGain)                      (nu x 1)
+  int*      actuator_biastype;    // bias type (mjtBias)                      (nu x 1)
+  int*      actuator_trnid;       // transmission id: joint, tendon, site     (nu x 2)
+  int*      actuator_actadr;      // first activation address; -1: stateless  (nu x 1)
+  int*      actuator_actnum;      // number of activation variables           (nu x 1)
+  int*      actuator_group;       // group for visibility                     (nu x 1)
+  mjtByte*  actuator_ctrllimited; // is control limited                       (nu x 1)
+  mjtByte*  actuator_forcelimited;// is force limited                         (nu x 1)
+  mjtByte*  actuator_actlimited;  // is activation limited                    (nu x 1)
+  mjtNum*   actuator_dynprm;      // dynamics parameters                      (nu x mjNDYN)
+  mjtNum*   actuator_gainprm;     // gain parameters                          (nu x mjNGAIN)
+  mjtNum*   actuator_biasprm;     // bias parameters                          (nu x mjNBIAS)
+  mjtByte*  actuator_actearly;    // step activation before force             (nu x 1)
+  mjtNum*   actuator_ctrlrange;   // range of controls                        (nu x 2)
+  mjtNum*   actuator_forcerange;  // range of forces                          (nu x 2)
+  mjtNum*   actuator_actrange;    // range of activations                     (nu x 2)
+  mjtNum*   actuator_gear;        // scale length and transmitted force       (nu x 6)
+  mjtNum*   actuator_cranklength; // crank length for slider-crank            (nu x 1)
+  mjtNum*   actuator_acc0;        // acceleration from unit force in qpos0    (nu x 1)
+  mjtNum*   actuator_length0;     // actuator length in qpos0                 (nu x 1)
+  mjtNum*   actuator_lengthrange; // feasible actuator length range           (nu x 2)
+  mjtNum*   actuator_user;        // user data                                (nu x nuser_actuator)
+  int*      actuator_plugin;      // plugin instance id; -1: not a plugin     (nu x 1)
+
+  // sensors
+  int*      sensor_type;          // sensor type (mjtSensor)                  (nsensor x 1)
+  int*      sensor_datatype;      // numeric data type (mjtDataType)          (nsensor x 1)
+  int*      sensor_needstage;     // required compute stage (mjtStage)        (nsensor x 1)
+  int*      sensor_objtype;       // type of sensorized object (mjtObj)       (nsensor x 1)
+  int*      sensor_objid;         // id of sensorized object                  (nsensor x 1)
+  int*      sensor_reftype;       // type of reference frame (mjtObj)         (nsensor x 1)
+  int*      sensor_refid;         // id of reference frame; -1: global frame  (nsensor x 1)
+  int*      sensor_dim;           // number of scalar outputs                 (nsensor x 1)
+  int*      sensor_adr;           // address in sensor array                  (nsensor x 1)
+  mjtNum*   sensor_cutoff;        // cutoff for real and positive; 0: ignore  (nsensor x 1)
+  mjtNum*   sensor_noise;         // noise standard deviation                 (nsensor x 1)
+  mjtNum*   sensor_user;          // user data                                (nsensor x nuser_sensor)
+  int*      sensor_plugin;        // plugin instance id; -1: not a plugin     (nsensor x 1)
+
+  // plugin instances
+  int*      plugin;               // globally registered plugin slot number   (nplugin x 1)
+  int*      plugin_stateadr;      // address in the plugin state array        (nplugin x 1)
+  int*      plugin_statenum;      // number of states in the plugin instance  (nplugin x 1)
+  char*     plugin_attr;          // config attributes of plugin instances    (npluginattr x 1)
+  int*      plugin_attradr;       // address to each instance's config attrib (nplugin x 1)
+
+  // custom numeric fields
+  int*      numeric_adr;          // address of field in numeric_data         (nnumeric x 1)
+  int*      numeric_size;         // size of numeric field                    (nnumeric x 1)
+  mjtNum*   numeric_data;         // array of all numeric fields              (nnumericdata x 1)
+
+  // custom text fields
+  int*      text_adr;             // address of text in text_data             (ntext x 1)
+  int*      text_size;            // size of text field (strlen+1)            (ntext x 1)
+  char*     text_data;            // array of all text fields (0-terminated)  (ntextdata x 1)
+
+  // custom tuple fields
+  int*      tuple_adr;            // address of text in text_data             (ntuple x 1)
+  int*      tuple_size;           // number of objects in tuple               (ntuple x 1)
+  int*      tuple_objtype;        // array of object types in all tuples      (ntupledata x 1)
+  int*      tuple_objid;          // array of object ids in all tuples        (ntupledata x 1)
+  mjtNum*   tuple_objprm;         // array of object params in all tuples     (ntupledata x 1)
+
+  // keyframes
+  mjtNum*   key_time;             // key time                                 (nkey x 1)
+  mjtNum*   key_qpos;             // key position                             (nkey x nq)
+  mjtNum*   key_qvel;             // key velocity                             (nkey x nv)
+  mjtNum*   key_act;              // key activation                           (nkey x na)
+  mjtNum*   key_mpos;             // key mocap position                       (nkey x 3*nmocap)
+  mjtNum*   key_mquat;            // key mocap quaternion                     (nkey x 4*nmocap)
+  mjtNum*   key_ctrl;             // key control                              (nkey x nu)
+
+  // names
+  int*      name_bodyadr;         // body name pointers                       (nbody x 1)
+  int*      name_jntadr;          // joint name pointers                      (njnt x 1)
+  int*      name_geomadr;         // geom name pointers                       (ngeom x 1)
+  int*      name_siteadr;         // site name pointers                       (nsite x 1)
+  int*      name_camadr;          // camera name pointers                     (ncam x 1)
+  int*      name_lightadr;        // light name pointers                      (nlight x 1)
+  int*      name_meshadr;         // mesh name pointers                       (nmesh x 1)
+  int*      name_skinadr;         // skin name pointers                       (nskin x 1)
+  int*      name_hfieldadr;       // hfield name pointers                     (nhfield x 1)
+  int*      name_texadr;          // texture name pointers                    (ntex x 1)
+  int*      name_matadr;          // material name pointers                   (nmat x 1)
+  int*      name_pairadr;         // geom pair name pointers                  (npair x 1)
+  int*      name_excludeadr;      // exclude name pointers                    (nexclude x 1)
+  int*      name_eqadr;           // equality constraint name pointers        (neq x 1)
+  int*      name_tendonadr;       // tendon name pointers                     (ntendon x 1)
+  int*      name_actuatoradr;     // actuator name pointers                   (nu x 1)
+  int*      name_sensoradr;       // sensor name pointers                     (nsensor x 1)
+  int*      name_numericadr;      // numeric name pointers                    (nnumeric x 1)
+  int*      name_textadr;         // text name pointers                       (ntext x 1)
+  int*      name_tupleadr;        // tuple name pointers                      (ntuple x 1)
+  int*      name_keyadr;          // keyframe name pointers                   (nkey x 1)
+  int*      name_pluginadr;       // plugin instance name pointers            (nplugin x 1)
+  char*     names;                // names of all objects, 0-terminated       (nnames x 1)
+  int*      names_map;            // internal hash map of names               (nnames_map x 1)
+};
+typedef struct mjModel_ mjModel;
+
+#endif  // MUJOCO_MJMODEL_H_
```

## mujoco/include/mujoco/mjplugin.h

 * *Ordering differences only*

```diff
@@ -1,136 +1,136 @@
-// Copyright 2022 DeepMind Technologies Limited
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#ifndef MUJOCO_INCLUDE_MJPLUGIN_H_
-#define MUJOCO_INCLUDE_MJPLUGIN_H_
-
-#include <mujoco/mjdata.h>
-#include <mujoco/mjmodel.h>
-#include <mujoco/mjvisualize.h>
-
-
-//---------------------------------- Resource Provider ---------------------------------------------
-
-#define mjVFS_PREFIX    "vfs"  // prefix for VFS providers
-
-// callback for opeing a resource, returns zero on failure
-typedef int (*mjfOpenResource)(mjResource* resource);
-
-// callback for reading a resource
-// return number of bytes stored in buffer, return -1 if error
-typedef int (*mjfReadResource)(mjResource* resource, const void** buffer);
-
-// callback for closing a resource (responsible for freeing any allocated memory)
-typedef void (*mjfCloseResource)(mjResource* resource);
-
-// callback for returning the directory of a resource
-// sets dir to directory string with ndir being size of directory string
-typedef void (*mjfGetResourceDir)(mjResource* resource, const char** dir, int* ndir);
-
-// struct describing a single resource provider
-struct mjpResourceProvider_ {
-  const char* prefix;                // prefix for match against a resource name
-  mjfOpenResource open;              // opening callback
-  mjfReadResource read;              // reading callback
-  mjfCloseResource close;            // closing callback
-  mjfGetResourceDir getdir;          // getdir callback (optional)
-  void* data;                        // opaque data pointer (resource invariant)
-};
-typedef struct mjpResourceProvider_ mjpResourceProvider;
-
-
-//---------------------------------- Plugins -------------------------------------------------------
-
-typedef enum mjtPluginCapabilityBit_ {
-  mjPLUGIN_ACTUATOR = 1<<0,       // actuator forces
-  mjPLUGIN_SENSOR   = 1<<1,       // sensor measurements
-  mjPLUGIN_PASSIVE  = 1<<2,       // passive forces
-} mjtPluginCapabilityBit;
-
-struct mjpPlugin_ {
-  const char* name;               // globally unique name identifying the plugin
-
-  int nattribute;                 // number of configuration attributes
-  const char* const* attributes;  // name of configuration attributes
-
-  int capabilityflags;            // plugin capabilities: bitfield of mjtPluginCapabilityBit
-  int needstage;                  // sensor computation stage (mjtStage)
-
-  // number of mjtNums needed to store the state of a plugin instance (required)
-  int (*nstate)(const mjModel* m, int instance);
-
-  // dimension of the specified sensor's output (required only for sensor plugins)
-  int (*nsensordata)(const mjModel* m, int instance, int sensor_id);
-
-  // called when a new mjData is being created (required), returns 0 on success or -1 on failure
-  int (*init)(const mjModel* m, mjData* d, int instance);
-
-  // called when an mjData is being freed (optional)
-  void (*destroy)(mjData* d, int instance);
-
-  // called when an mjData is being copied (optional)
-  void (*copy)(mjData* dest, const mjModel* m, const mjData* src, int instance);
-
-  // called when an mjData is being reset (required)
-  void (*reset)(const mjModel* m, double* plugin_state, void* plugin_data, int instance);
-
-  // called when the plugin needs to update its outputs (required)
-  void (*compute)(const mjModel* m, mjData* d, int instance, int capability_bit);
-
-  // called when time integration occurs (optional)
-  void (*advance)(const mjModel* m, mjData* d, int instance);
-
-  // called by mjv_updateScene (optional)
-  void (*visualize)(const mjModel*m, mjData* d, const mjvOption* opt, mjvScene* scn, int instance);
-};
-typedef struct mjpPlugin_ mjpPlugin;
-
-#if defined(__has_attribute)
-
-  #if __has_attribute(constructor)
-    #define mjPLUGIN_LIB_INIT __attribute__((constructor)) static void _mjplugin_init(void)
-  #endif  // __has_attribute(constructor)
-
-#elif defined(_MSC_VER)
-
-  #ifndef mjDLLMAIN
-    #define mjDLLMAIN DllMain
-  #endif
-
-  #if !defined(mjEXTERNC)
-    #if defined(__cplusplus)
-      #define mjEXTERNC extern "C"
-    #else
-      #define mjEXTERNC
-    #endif  // defined(__cplusplus)
-  #endif  // !defined(mjEXTERNC)
-
-  // NOLINTBEGIN(runtime/int)
-  #define mjPLUGIN_LIB_INIT                                                                 \
-    static void _mjplugin_dllmain(void);                                                    \
-    mjEXTERNC int __stdcall mjDLLMAIN(void* hinst, unsigned long reason, void* reserved) {  \
-      if (reason == 1) {                                                                    \
-        _mjplugin_dllmain();                                                                \
-      }                                                                                     \
-      return 1;                                                                             \
-    }                                                                                       \
-    static void _mjplugin_dllmain(void)
-  // NOLINTEND(runtime/int)
-
-#endif  // defined(_MSC_VER)
-
-// function pointer type for mj_loadAllPluginLibraries callback
-typedef void (*mjfPluginLibraryLoadCallback)(const char* filename, int first, int count);
-
-#endif  // MUJOCO_INCLUDE_MJPLUGIN_H_
+// Copyright 2022 DeepMind Technologies Limited
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef MUJOCO_INCLUDE_MJPLUGIN_H_
+#define MUJOCO_INCLUDE_MJPLUGIN_H_
+
+#include <mujoco/mjdata.h>
+#include <mujoco/mjmodel.h>
+#include <mujoco/mjvisualize.h>
+
+
+//---------------------------------- Resource Provider ---------------------------------------------
+
+#define mjVFS_PREFIX    "vfs"  // prefix for VFS providers
+
+// callback for opeing a resource, returns zero on failure
+typedef int (*mjfOpenResource)(mjResource* resource);
+
+// callback for reading a resource
+// return number of bytes stored in buffer, return -1 if error
+typedef int (*mjfReadResource)(mjResource* resource, const void** buffer);
+
+// callback for closing a resource (responsible for freeing any allocated memory)
+typedef void (*mjfCloseResource)(mjResource* resource);
+
+// callback for returning the directory of a resource
+// sets dir to directory string with ndir being size of directory string
+typedef void (*mjfGetResourceDir)(mjResource* resource, const char** dir, int* ndir);
+
+// struct describing a single resource provider
+struct mjpResourceProvider_ {
+  const char* prefix;                // prefix for match against a resource name
+  mjfOpenResource open;              // opening callback
+  mjfReadResource read;              // reading callback
+  mjfCloseResource close;            // closing callback
+  mjfGetResourceDir getdir;          // getdir callback (optional)
+  void* data;                        // opaque data pointer (resource invariant)
+};
+typedef struct mjpResourceProvider_ mjpResourceProvider;
+
+
+//---------------------------------- Plugins -------------------------------------------------------
+
+typedef enum mjtPluginCapabilityBit_ {
+  mjPLUGIN_ACTUATOR = 1<<0,       // actuator forces
+  mjPLUGIN_SENSOR   = 1<<1,       // sensor measurements
+  mjPLUGIN_PASSIVE  = 1<<2,       // passive forces
+} mjtPluginCapabilityBit;
+
+struct mjpPlugin_ {
+  const char* name;               // globally unique name identifying the plugin
+
+  int nattribute;                 // number of configuration attributes
+  const char* const* attributes;  // name of configuration attributes
+
+  int capabilityflags;            // plugin capabilities: bitfield of mjtPluginCapabilityBit
+  int needstage;                  // sensor computation stage (mjtStage)
+
+  // number of mjtNums needed to store the state of a plugin instance (required)
+  int (*nstate)(const mjModel* m, int instance);
+
+  // dimension of the specified sensor's output (required only for sensor plugins)
+  int (*nsensordata)(const mjModel* m, int instance, int sensor_id);
+
+  // called when a new mjData is being created (required), returns 0 on success or -1 on failure
+  int (*init)(const mjModel* m, mjData* d, int instance);
+
+  // called when an mjData is being freed (optional)
+  void (*destroy)(mjData* d, int instance);
+
+  // called when an mjData is being copied (optional)
+  void (*copy)(mjData* dest, const mjModel* m, const mjData* src, int instance);
+
+  // called when an mjData is being reset (required)
+  void (*reset)(const mjModel* m, double* plugin_state, void* plugin_data, int instance);
+
+  // called when the plugin needs to update its outputs (required)
+  void (*compute)(const mjModel* m, mjData* d, int instance, int capability_bit);
+
+  // called when time integration occurs (optional)
+  void (*advance)(const mjModel* m, mjData* d, int instance);
+
+  // called by mjv_updateScene (optional)
+  void (*visualize)(const mjModel*m, mjData* d, const mjvOption* opt, mjvScene* scn, int instance);
+};
+typedef struct mjpPlugin_ mjpPlugin;
+
+#if defined(__has_attribute)
+
+  #if __has_attribute(constructor)
+    #define mjPLUGIN_LIB_INIT __attribute__((constructor)) static void _mjplugin_init(void)
+  #endif  // __has_attribute(constructor)
+
+#elif defined(_MSC_VER)
+
+  #ifndef mjDLLMAIN
+    #define mjDLLMAIN DllMain
+  #endif
+
+  #if !defined(mjEXTERNC)
+    #if defined(__cplusplus)
+      #define mjEXTERNC extern "C"
+    #else
+      #define mjEXTERNC
+    #endif  // defined(__cplusplus)
+  #endif  // !defined(mjEXTERNC)
+
+  // NOLINTBEGIN(runtime/int)
+  #define mjPLUGIN_LIB_INIT                                                                 \
+    static void _mjplugin_dllmain(void);                                                    \
+    mjEXTERNC int __stdcall mjDLLMAIN(void* hinst, unsigned long reason, void* reserved) {  \
+      if (reason == 1) {                                                                    \
+        _mjplugin_dllmain();                                                                \
+      }                                                                                     \
+      return 1;                                                                             \
+    }                                                                                       \
+    static void _mjplugin_dllmain(void)
+  // NOLINTEND(runtime/int)
+
+#endif  // defined(_MSC_VER)
+
+// function pointer type for mj_loadAllPluginLibraries callback
+typedef void (*mjfPluginLibraryLoadCallback)(const char* filename, int first, int count);
+
+#endif  // MUJOCO_INCLUDE_MJPLUGIN_H_
```

## mujoco/include/mujoco/mjrender.h

 * *Ordering differences only*

```diff
@@ -1,160 +1,160 @@
-// Copyright 2021 DeepMind Technologies Limited
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#ifndef MUJOCO_MJRENDER_H_
-#define MUJOCO_MJRENDER_H_
-
-
-#if defined(__cplusplus)
-extern "C" {
-#endif
-
-#define mjNAUX          10        // number of auxiliary buffers
-#define mjMAXTEXTURE    1000      // maximum number of textures
-
-
-//---------------------------------- primitive types (mjt) -----------------------------------------
-
-typedef enum mjtGridPos_ {        // grid position for overlay
-  mjGRID_TOPLEFT      = 0,        // top left
-  mjGRID_TOPRIGHT,                // top right
-  mjGRID_BOTTOMLEFT,              // bottom left
-  mjGRID_BOTTOMRIGHT              // bottom right
-} mjtGridPos;
-
-
-typedef enum mjtFramebuffer_ {    // OpenGL framebuffer option
-  mjFB_WINDOW         = 0,        // default/window buffer
-  mjFB_OFFSCREEN                  // offscreen buffer
-} mjtFramebuffer;
-
-
-typedef enum mjtFontScale_ {      // font scale, used at context creation
-  mjFONTSCALE_50      = 50,       // 50% scale, suitable for low-res rendering
-  mjFONTSCALE_100     = 100,      // normal scale, suitable in the absence of DPI scaling
-  mjFONTSCALE_150     = 150,      // 150% scale
-  mjFONTSCALE_200     = 200,      // 200% scale
-  mjFONTSCALE_250     = 250,      // 250% scale
-  mjFONTSCALE_300     = 300       // 300% scale
-} mjtFontScale;
-
-
-typedef enum mjtFont_ {           // font type, used at each text operation
-  mjFONT_NORMAL       = 0,        // normal font
-  mjFONT_SHADOW,                  // normal font with shadow (for higher contrast)
-  mjFONT_BIG                      // big font (for user alerts)
-} mjtFont;
-
-
-struct mjrRect_ {                 // OpenGL rectangle
-  int left;                       // left (usually 0)
-  int bottom;                     // bottom (usually 0)
-  int width;                      // width (usually buffer width)
-  int height;                     // height (usually buffer height)
-};
-typedef struct mjrRect_ mjrRect;
-
-
-//---------------------------------- mjrContext ----------------------------------------------------
-
-struct mjrContext_ {              // custom OpenGL context
-  // parameters copied from mjVisual
-  float lineWidth;                // line width for wireframe rendering
-  float shadowClip;               // clipping radius for directional lights
-  float shadowScale;              // fraction of light cutoff for spot lights
-  float fogStart;                 // fog start = stat.extent * vis.map.fogstart
-  float fogEnd;                   // fog end = stat.extent * vis.map.fogend
-  float fogRGBA[4];               // fog rgba
-  int shadowSize;                 // size of shadow map texture
-  int offWidth;                   // width of offscreen buffer
-  int offHeight;                  // height of offscreen buffer
-  int offSamples;                 // number of offscreen buffer multisamples
-
-  // parameters specified at creation
-  int fontScale;                  // font scale
-  int auxWidth[mjNAUX];           // auxiliary buffer width
-  int auxHeight[mjNAUX];          // auxiliary buffer height
-  int auxSamples[mjNAUX];         // auxiliary buffer multisamples
-
-  // offscreen rendering objects
-  unsigned int offFBO;            // offscreen framebuffer object
-  unsigned int offFBO_r;          // offscreen framebuffer for resolving multisamples
-  unsigned int offColor;          // offscreen color buffer
-  unsigned int offColor_r;        // offscreen color buffer for resolving multisamples
-  unsigned int offDepthStencil;   // offscreen depth and stencil buffer
-  unsigned int offDepthStencil_r; // offscreen depth and stencil buffer for resolving multisamples
-
-  // shadow rendering objects
-  unsigned int shadowFBO;         // shadow map framebuffer object
-  unsigned int shadowTex;         // shadow map texture
-
-  // auxiliary buffers
-  unsigned int auxFBO[mjNAUX];    // auxiliary framebuffer object
-  unsigned int auxFBO_r[mjNAUX];  // auxiliary framebuffer object for resolving
-  unsigned int auxColor[mjNAUX];  // auxiliary color buffer
-  unsigned int auxColor_r[mjNAUX];// auxiliary color buffer for resolving
-
-  // texture objects and info
-  int ntexture;                   // number of allocated textures
-  int textureType[100];           // type of texture (mjtTexture) (ntexture)
-  unsigned int texture[100];      // texture names
-
-  // displaylist starting positions
-  unsigned int basePlane;         // all planes from model
-  unsigned int baseMesh;          // all meshes from model
-  unsigned int baseHField;        // all hfields from model
-  unsigned int baseBuiltin;       // all buildin geoms, with quality from model
-  unsigned int baseFontNormal;    // normal font
-  unsigned int baseFontShadow;    // shadow font
-  unsigned int baseFontBig;       // big font
-
-  // displaylist ranges
-  int rangePlane;                 // all planes from model
-  int rangeMesh;                  // all meshes from model
-  int rangeHField;                // all hfields from model
-  int rangeBuiltin;               // all builtin geoms, with quality from model
-  int rangeFont;                  // all characters in font
-
-  // skin VBOs
-  int nskin;                      // number of skins
-  unsigned int* skinvertVBO;      // skin vertex position VBOs (nskin)
-  unsigned int* skinnormalVBO;    // skin vertex normal VBOs (nskin)
-  unsigned int* skintexcoordVBO;  // skin vertex texture coordinate VBOs (nskin)
-  unsigned int* skinfaceVBO;      // skin face index VBOs (nskin)
-
-  // character info
-  int charWidth[127];             // character widths: normal and shadow
-  int charWidthBig[127];          // chacarter widths: big
-  int charHeight;                 // character heights: normal and shadow
-  int charHeightBig;              // character heights: big
-
-  // capabilities
-  int glInitialized;              // is OpenGL initialized
-  int windowAvailable;            // is default/window framebuffer available
-  int windowSamples;              // number of samples for default/window framebuffer
-  int windowStereo;               // is stereo available for default/window framebuffer
-  int windowDoublebuffer;         // is default/window framebuffer double buffered
-
-  // framebuffer
-  int     currentBuffer;          // currently active framebuffer: mjFB_WINDOW or mjFB_OFFSCREEN
-
-  // pixel output format
-  int     readPixelFormat;        // default color pixel format for mjr_readPixels
-};
-typedef struct mjrContext_ mjrContext;
-
-#if defined(__cplusplus)
-}
-#endif
-#endif  // MUJOCO_MJRENDER_H_
+// Copyright 2021 DeepMind Technologies Limited
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef MUJOCO_MJRENDER_H_
+#define MUJOCO_MJRENDER_H_
+
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+#define mjNAUX          10        // number of auxiliary buffers
+#define mjMAXTEXTURE    1000      // maximum number of textures
+
+
+//---------------------------------- primitive types (mjt) -----------------------------------------
+
+typedef enum mjtGridPos_ {        // grid position for overlay
+  mjGRID_TOPLEFT      = 0,        // top left
+  mjGRID_TOPRIGHT,                // top right
+  mjGRID_BOTTOMLEFT,              // bottom left
+  mjGRID_BOTTOMRIGHT              // bottom right
+} mjtGridPos;
+
+
+typedef enum mjtFramebuffer_ {    // OpenGL framebuffer option
+  mjFB_WINDOW         = 0,        // default/window buffer
+  mjFB_OFFSCREEN                  // offscreen buffer
+} mjtFramebuffer;
+
+
+typedef enum mjtFontScale_ {      // font scale, used at context creation
+  mjFONTSCALE_50      = 50,       // 50% scale, suitable for low-res rendering
+  mjFONTSCALE_100     = 100,      // normal scale, suitable in the absence of DPI scaling
+  mjFONTSCALE_150     = 150,      // 150% scale
+  mjFONTSCALE_200     = 200,      // 200% scale
+  mjFONTSCALE_250     = 250,      // 250% scale
+  mjFONTSCALE_300     = 300       // 300% scale
+} mjtFontScale;
+
+
+typedef enum mjtFont_ {           // font type, used at each text operation
+  mjFONT_NORMAL       = 0,        // normal font
+  mjFONT_SHADOW,                  // normal font with shadow (for higher contrast)
+  mjFONT_BIG                      // big font (for user alerts)
+} mjtFont;
+
+
+struct mjrRect_ {                 // OpenGL rectangle
+  int left;                       // left (usually 0)
+  int bottom;                     // bottom (usually 0)
+  int width;                      // width (usually buffer width)
+  int height;                     // height (usually buffer height)
+};
+typedef struct mjrRect_ mjrRect;
+
+
+//---------------------------------- mjrContext ----------------------------------------------------
+
+struct mjrContext_ {              // custom OpenGL context
+  // parameters copied from mjVisual
+  float lineWidth;                // line width for wireframe rendering
+  float shadowClip;               // clipping radius for directional lights
+  float shadowScale;              // fraction of light cutoff for spot lights
+  float fogStart;                 // fog start = stat.extent * vis.map.fogstart
+  float fogEnd;                   // fog end = stat.extent * vis.map.fogend
+  float fogRGBA[4];               // fog rgba
+  int shadowSize;                 // size of shadow map texture
+  int offWidth;                   // width of offscreen buffer
+  int offHeight;                  // height of offscreen buffer
+  int offSamples;                 // number of offscreen buffer multisamples
+
+  // parameters specified at creation
+  int fontScale;                  // font scale
+  int auxWidth[mjNAUX];           // auxiliary buffer width
+  int auxHeight[mjNAUX];          // auxiliary buffer height
+  int auxSamples[mjNAUX];         // auxiliary buffer multisamples
+
+  // offscreen rendering objects
+  unsigned int offFBO;            // offscreen framebuffer object
+  unsigned int offFBO_r;          // offscreen framebuffer for resolving multisamples
+  unsigned int offColor;          // offscreen color buffer
+  unsigned int offColor_r;        // offscreen color buffer for resolving multisamples
+  unsigned int offDepthStencil;   // offscreen depth and stencil buffer
+  unsigned int offDepthStencil_r; // offscreen depth and stencil buffer for resolving multisamples
+
+  // shadow rendering objects
+  unsigned int shadowFBO;         // shadow map framebuffer object
+  unsigned int shadowTex;         // shadow map texture
+
+  // auxiliary buffers
+  unsigned int auxFBO[mjNAUX];    // auxiliary framebuffer object
+  unsigned int auxFBO_r[mjNAUX];  // auxiliary framebuffer object for resolving
+  unsigned int auxColor[mjNAUX];  // auxiliary color buffer
+  unsigned int auxColor_r[mjNAUX];// auxiliary color buffer for resolving
+
+  // texture objects and info
+  int ntexture;                   // number of allocated textures
+  int textureType[100];           // type of texture (mjtTexture) (ntexture)
+  unsigned int texture[100];      // texture names
+
+  // displaylist starting positions
+  unsigned int basePlane;         // all planes from model
+  unsigned int baseMesh;          // all meshes from model
+  unsigned int baseHField;        // all hfields from model
+  unsigned int baseBuiltin;       // all buildin geoms, with quality from model
+  unsigned int baseFontNormal;    // normal font
+  unsigned int baseFontShadow;    // shadow font
+  unsigned int baseFontBig;       // big font
+
+  // displaylist ranges
+  int rangePlane;                 // all planes from model
+  int rangeMesh;                  // all meshes from model
+  int rangeHField;                // all hfields from model
+  int rangeBuiltin;               // all builtin geoms, with quality from model
+  int rangeFont;                  // all characters in font
+
+  // skin VBOs
+  int nskin;                      // number of skins
+  unsigned int* skinvertVBO;      // skin vertex position VBOs (nskin)
+  unsigned int* skinnormalVBO;    // skin vertex normal VBOs (nskin)
+  unsigned int* skintexcoordVBO;  // skin vertex texture coordinate VBOs (nskin)
+  unsigned int* skinfaceVBO;      // skin face index VBOs (nskin)
+
+  // character info
+  int charWidth[127];             // character widths: normal and shadow
+  int charWidthBig[127];          // chacarter widths: big
+  int charHeight;                 // character heights: normal and shadow
+  int charHeightBig;              // character heights: big
+
+  // capabilities
+  int glInitialized;              // is OpenGL initialized
+  int windowAvailable;            // is default/window framebuffer available
+  int windowSamples;              // number of samples for default/window framebuffer
+  int windowStereo;               // is stereo available for default/window framebuffer
+  int windowDoublebuffer;         // is default/window framebuffer double buffered
+
+  // framebuffer
+  int     currentBuffer;          // currently active framebuffer: mjFB_WINDOW or mjFB_OFFSCREEN
+
+  // pixel output format
+  int     readPixelFormat;        // default color pixel format for mjr_readPixels
+};
+typedef struct mjrContext_ mjrContext;
+
+#if defined(__cplusplus)
+}
+#endif
+#endif  // MUJOCO_MJRENDER_H_
```

## mujoco/include/mujoco/mjtnum.h

 * *Ordering differences only*

```diff
@@ -1,41 +1,41 @@
-// Copyright 2021 DeepMind Technologies Limited
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#ifndef MUJOCO_INCLUDE_MJTNUM_H_
-#define MUJOCO_INCLUDE_MJTNUM_H_
-
-//---------------------------------- floating-point definition -------------------------------------
-
-// compile-time configuration options
-#define mjUSEDOUBLE               // single or double precision for mjtNum
-
-
-// floating point data type and minval
-#ifdef mjUSEDOUBLE
-  typedef double mjtNum;
-  #define mjMINVAL    1E-15       // minimum value in any denominator
-#else
-  typedef float mjtNum;
-  #define mjMINVAL    1E-15f
-#endif
-
-
-
-//-------------------------------------- byte definition -------------------------------------------
-
-typedef unsigned char mjtByte;    // used for true/false
-
-
-
-#endif  // MUJOCO_INCLUDE_MJTNUM_H_
+// Copyright 2021 DeepMind Technologies Limited
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef MUJOCO_INCLUDE_MJTNUM_H_
+#define MUJOCO_INCLUDE_MJTNUM_H_
+
+//---------------------------------- floating-point definition -------------------------------------
+
+// compile-time configuration options
+#define mjUSEDOUBLE               // single or double precision for mjtNum
+
+
+// floating point data type and minval
+#ifdef mjUSEDOUBLE
+  typedef double mjtNum;
+  #define mjMINVAL    1E-15       // minimum value in any denominator
+#else
+  typedef float mjtNum;
+  #define mjMINVAL    1E-15f
+#endif
+
+
+
+//-------------------------------------- byte definition -------------------------------------------
+
+typedef unsigned char mjtByte;    // used for true/false
+
+
+
+#endif  // MUJOCO_INCLUDE_MJTNUM_H_
```

## mujoco/include/mujoco/mjui.h

 * *Ordering differences only*

```diff
@@ -1,321 +1,321 @@
-// Copyright 2021 DeepMind Technologies Limited
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#ifndef MUJOCO_MJUI_H_
-#define MUJOCO_MJUI_H_
-
-#include <mujoco/mjrender.h>
-
-#define mjMAXUISECT     10      // maximum number of sections
-#define mjMAXUIITEM     100     // maximum number of items per section
-#define mjMAXUITEXT     300     // maximum number of chars in edittext and other
-#define mjMAXUINAME     40      // maximum number of chars in name
-#define mjMAXUIMULTI    35      // maximum number of radio/select items in group
-#define mjMAXUIEDIT     7       // maximum number of elements in edit list
-#define mjMAXUIRECT     25      // maximum number of rectangles
-
-#define mjSEPCLOSED     1000    // closed state of adjustable separator
-
-
-// key codes matching GLFW (user must remap for other frameworks)
-#define mjKEY_ESCAPE     256
-#define mjKEY_ENTER      257
-#define mjKEY_TAB        258
-#define mjKEY_BACKSPACE  259
-#define mjKEY_INSERT     260
-#define mjKEY_DELETE     261
-#define mjKEY_RIGHT      262
-#define mjKEY_LEFT       263
-#define mjKEY_DOWN       264
-#define mjKEY_UP         265
-#define mjKEY_PAGE_UP    266
-#define mjKEY_PAGE_DOWN  267
-#define mjKEY_HOME       268
-#define mjKEY_END        269
-#define mjKEY_F1         290
-#define mjKEY_F2         291
-#define mjKEY_F3         292
-#define mjKEY_F4         293
-#define mjKEY_F5         294
-#define mjKEY_F6         295
-#define mjKEY_F7         296
-#define mjKEY_F8         297
-#define mjKEY_F9         298
-#define mjKEY_F10        299
-#define mjKEY_F11        300
-#define mjKEY_F12        301
-#define mjKEY_NUMPAD_0   320
-#define mjKEY_NUMPAD_9   329
-
-
-//---------------------------------- primitive types (mjt) -----------------------------------------
-
-typedef enum mjtButton_ {         // mouse button
-  mjBUTTON_NONE = 0,              // no button
-  mjBUTTON_LEFT,                  // left button
-  mjBUTTON_RIGHT,                 // right button
-  mjBUTTON_MIDDLE                 // middle button
-} mjtButton;
-
-
-typedef enum mjtEvent_ {          // mouse and keyboard event type
-  mjEVENT_NONE = 0,               // no event
-  mjEVENT_MOVE,                   // mouse move
-  mjEVENT_PRESS,                  // mouse button press
-  mjEVENT_RELEASE,                // mouse button release
-  mjEVENT_SCROLL,                 // scroll
-  mjEVENT_KEY,                    // key press
-  mjEVENT_RESIZE,                 // resize
-  mjEVENT_REDRAW,                 // redraw
-  mjEVENT_FILESDROP               // files drop
-} mjtEvent;
-
-
-typedef enum mjtItem_ {           // UI item type
-  mjITEM_END = -2,                // end of definition list (not an item)
-  mjITEM_SECTION = -1,            // section (not an item)
-  mjITEM_SEPARATOR = 0,           // separator
-  mjITEM_STATIC,                  // static text
-  mjITEM_BUTTON,                  // button
-
-  // the rest have data pointer
-  mjITEM_CHECKINT,                // check box, int value
-  mjITEM_CHECKBYTE,               // check box, mjtByte value
-  mjITEM_RADIO,                   // radio group
-  mjITEM_RADIOLINE,               // radio group, single line
-  mjITEM_SELECT,                  // selection box
-  mjITEM_SLIDERINT,               // slider, int value
-  mjITEM_SLIDERNUM,               // slider, mjtNum value
-  mjITEM_EDITINT,                 // editable array, int values
-  mjITEM_EDITNUM,                 // editable array, mjtNum values
-  mjITEM_EDITFLOAT,               // editable array, float values
-  mjITEM_EDITTXT,                 // editable text
-
-  mjNITEM                         // number of item types
-} mjtItem;
-
-
-// predicate function: set enable/disable based on item category
-typedef int (*mjfItemEnable)(int category, void* data);
-
-
-//---------------------------------- mjuiState -----------------------------------------------------
-
-struct mjuiState_ {               // mouse and keyboard state
-  // constants set by user
-  int nrect;                      // number of rectangles used
-  mjrRect rect[mjMAXUIRECT];      // rectangles (index 0: entire window)
-  void* userdata;                 // pointer to user data (for callbacks)
-
-  // event type
-  int type;                       // (type mjtEvent)
-
-  // mouse buttons
-  int left;                       // is left button down
-  int right;                      // is right button down
-  int middle;                     // is middle button down
-  int doubleclick;                // is last press a double click
-  int button;                     // which button was pressed (mjtButton)
-  double buttontime;              // time of last button press
-
-  // mouse position
-  double x;                       // x position
-  double y;                       // y position
-  double dx;                      // x displacement
-  double dy;                      // y displacement
-  double sx;                      // x scroll
-  double sy;                      // y scroll
-
-  // keyboard
-  int control;                    // is control down
-  int shift;                      // is shift down
-  int alt;                        // is alt down
-  int key;                        // which key was pressed
-  double keytime;                 // time of last key press
-
-  // rectangle ownership and dragging
-  int mouserect;                  // which rectangle contains mouse
-  int dragrect;                   // which rectangle is dragged with mouse
-  int dragbutton;                 // which button started drag (mjtButton)
-
-  // files dropping (only valid when type == mjEVENT_FILESDROP)
-  int dropcount;                  // number of files dropped
-  const char** droppaths;         // paths to files dropped
-};
-typedef struct mjuiState_ mjuiState;
-
-
-//---------------------------------- mjuiThemeSpacing ----------------------------------------------
-
-struct mjuiThemeSpacing_ {        // UI visualization theme spacing
-  int total;                      // total width
-  int scroll;                     // scrollbar width
-  int label;                      // label width
-  int section;                    // section gap
-  int itemside;                   // item side gap
-  int itemmid;                    // item middle gap
-  int itemver;                    // item vertical gap
-  int texthor;                    // text horizontal gap
-  int textver;                    // text vertical gap
-  int linescroll;                 // number of pixels to scroll
-  int samples;                    // number of multisamples
-};
-typedef struct mjuiThemeSpacing_ mjuiThemeSpacing;
-
-
-//---------------------------------- mjuiThemeColor ------------------------------------------------
-
-struct mjuiThemeColor_ {          // UI visualization theme color
-  float master[3];                // master background
-  float thumb[3];                 // scrollbar thumb
-  float secttitle[3];             // section title
-  float sectfont[3];              // section font
-  float sectsymbol[3];            // section symbol
-  float sectpane[3];              // section pane
-  float shortcut[3];              // shortcut background
-  float fontactive[3];            // font active
-  float fontinactive[3];          // font inactive
-  float decorinactive[3];         // decor inactive
-  float decorinactive2[3];        // inactive slider color 2
-  float button[3];                // button
-  float check[3];                 // check
-  float radio[3];                 // radio
-  float select[3];                // select
-  float select2[3];               // select pane
-  float slider[3];                // slider
-  float slider2[3];               // slider color 2
-  float edit[3];                  // edit
-  float edit2[3];                 // edit invalid
-  float cursor[3];                // edit cursor
-};
-typedef struct mjuiThemeColor_ mjuiThemeColor;
-
-
-//---------------------------------- mjuiItem ------------------------------------------------------
-
-struct mjuiItemSingle_ {          // check and button-related
-  int modifier;                   // 0: none, 1: control, 2: shift; 4: alt
-  int shortcut;                   // shortcut key; 0: undefined
-};
-
-
-struct mjuiItemMulti_ {                  // static, radio and select-related
-  int nelem;                             // number of elements in group
-  char name[mjMAXUIMULTI][mjMAXUINAME];  // element names
-};
-
-
-struct mjuiItemSlider_ {          // slider-related
-  double range[2];                // slider range
-  double divisions;               // number of range divisions
-};
-
-
-struct mjuiItemEdit_ {            // edit-related
-  int nelem;                      // number of elements in list
-  double range[mjMAXUIEDIT][2];   // element range (min>=max: ignore)
-};
-
-
-struct mjuiItem_ {                // UI item
-  // common properties
-  int type;                       // type (mjtItem)
-  char name[mjMAXUINAME];         // name
-  int state;                      // 0: disable, 1: enable, 2+: use predicate
-  void *pdata;                    // data pointer (type-specific)
-  int sectionid;                  // id of section containing item
-  int itemid;                     // id of item within section
-
-  // type-specific properties
-  union {
-    struct mjuiItemSingle_ single;  // check and button
-    struct mjuiItemMulti_ multi;    // static, radio and select
-    struct mjuiItemSlider_ slider;  // slider
-    struct mjuiItemEdit_ edit;      // edit
-  };
-
-  // internal
-  mjrRect rect;                   // rectangle occupied by item
-};
-typedef struct mjuiItem_ mjuiItem;
-
-
-//---------------------------------- mjuiSection ---------------------------------------------------
-
-struct mjuiSection_ {             // UI section
-  // properties
-  char name[mjMAXUINAME];         // name
-  int state;                      // 0: closed, 1: open
-  int modifier;                   // 0: none, 1: control, 2: shift; 4: alt
-  int shortcut;                   // shortcut key; 0: undefined
-  int nitem;                      // number of items in use
-  mjuiItem item[mjMAXUIITEM];     // preallocated array of items
-
-  // internal
-  mjrRect rtitle;                 // rectangle occupied by title
-  mjrRect rcontent;               // rectangle occupied by content
-};
-typedef struct mjuiSection_ mjuiSection;
-
-
-//---------------------------------- mjUI ----------------------------------------------------------
-
-struct mjUI_ {                    // entire UI
-  // constants set by user
-  mjuiThemeSpacing spacing;       // UI theme spacing
-  mjuiThemeColor color;           // UI theme color
-  mjfItemEnable predicate;        // callback to set item state programmatically
-  void* userdata;                 // pointer to user data (passed to predicate)
-  int rectid;                     // index of this ui rectangle in mjuiState
-  int auxid;                      // aux buffer index of this ui
-  int radiocol;                   // number of radio columns (0 defaults to 2)
-
-  // UI sizes (framebuffer units)
-  int width;                      // width
-  int height;                     // current heigth
-  int maxheight;                  // height when all sections open
-  int scroll;                     // scroll from top of UI
-
-  // mouse focus
-  int mousesect;                  // 0: none, -1: scroll, otherwise 1+section
-  int mouseitem;                  // item within section
-  int mousehelp;                  // help button down: print shortcuts
-
-  // keyboard focus and edit
-  int editsect;                   // 0: none, otherwise 1+section
-  int edititem;                   // item within section
-  int editcursor;                 // cursor position
-  int editscroll;                 // horizontal scroll
-  char edittext[mjMAXUITEXT];     // current text
-  mjuiItem* editchanged;          // pointer to changed edit in last mjui_event
-
-  // sections
-  int nsect;                      // number of sections in use
-  mjuiSection sect[mjMAXUISECT];  // preallocated array of sections
-};
-typedef struct mjUI_ mjUI;
-
-
-//---------------------------------- mjuiDef -------------------------------------------------------
-
-struct mjuiDef_ {                 // table passed to mjui_add()
-  int type;                       // type (mjtItem); -1: section
-  char name[mjMAXUINAME];         // name
-  int state;                      // state
-  void* pdata;                    // pointer to data
-  char other[mjMAXUITEXT];        // string with type-specific properties
-};
-typedef struct mjuiDef_ mjuiDef;
-
-#endif  // MUJOCO_MJUI_H_
+// Copyright 2021 DeepMind Technologies Limited
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef MUJOCO_MJUI_H_
+#define MUJOCO_MJUI_H_
+
+#include <mujoco/mjrender.h>
+
+#define mjMAXUISECT     10      // maximum number of sections
+#define mjMAXUIITEM     100     // maximum number of items per section
+#define mjMAXUITEXT     300     // maximum number of chars in edittext and other
+#define mjMAXUINAME     40      // maximum number of chars in name
+#define mjMAXUIMULTI    35      // maximum number of radio/select items in group
+#define mjMAXUIEDIT     7       // maximum number of elements in edit list
+#define mjMAXUIRECT     25      // maximum number of rectangles
+
+#define mjSEPCLOSED     1000    // closed state of adjustable separator
+
+
+// key codes matching GLFW (user must remap for other frameworks)
+#define mjKEY_ESCAPE     256
+#define mjKEY_ENTER      257
+#define mjKEY_TAB        258
+#define mjKEY_BACKSPACE  259
+#define mjKEY_INSERT     260
+#define mjKEY_DELETE     261
+#define mjKEY_RIGHT      262
+#define mjKEY_LEFT       263
+#define mjKEY_DOWN       264
+#define mjKEY_UP         265
+#define mjKEY_PAGE_UP    266
+#define mjKEY_PAGE_DOWN  267
+#define mjKEY_HOME       268
+#define mjKEY_END        269
+#define mjKEY_F1         290
+#define mjKEY_F2         291
+#define mjKEY_F3         292
+#define mjKEY_F4         293
+#define mjKEY_F5         294
+#define mjKEY_F6         295
+#define mjKEY_F7         296
+#define mjKEY_F8         297
+#define mjKEY_F9         298
+#define mjKEY_F10        299
+#define mjKEY_F11        300
+#define mjKEY_F12        301
+#define mjKEY_NUMPAD_0   320
+#define mjKEY_NUMPAD_9   329
+
+
+//---------------------------------- primitive types (mjt) -----------------------------------------
+
+typedef enum mjtButton_ {         // mouse button
+  mjBUTTON_NONE = 0,              // no button
+  mjBUTTON_LEFT,                  // left button
+  mjBUTTON_RIGHT,                 // right button
+  mjBUTTON_MIDDLE                 // middle button
+} mjtButton;
+
+
+typedef enum mjtEvent_ {          // mouse and keyboard event type
+  mjEVENT_NONE = 0,               // no event
+  mjEVENT_MOVE,                   // mouse move
+  mjEVENT_PRESS,                  // mouse button press
+  mjEVENT_RELEASE,                // mouse button release
+  mjEVENT_SCROLL,                 // scroll
+  mjEVENT_KEY,                    // key press
+  mjEVENT_RESIZE,                 // resize
+  mjEVENT_REDRAW,                 // redraw
+  mjEVENT_FILESDROP               // files drop
+} mjtEvent;
+
+
+typedef enum mjtItem_ {           // UI item type
+  mjITEM_END = -2,                // end of definition list (not an item)
+  mjITEM_SECTION = -1,            // section (not an item)
+  mjITEM_SEPARATOR = 0,           // separator
+  mjITEM_STATIC,                  // static text
+  mjITEM_BUTTON,                  // button
+
+  // the rest have data pointer
+  mjITEM_CHECKINT,                // check box, int value
+  mjITEM_CHECKBYTE,               // check box, mjtByte value
+  mjITEM_RADIO,                   // radio group
+  mjITEM_RADIOLINE,               // radio group, single line
+  mjITEM_SELECT,                  // selection box
+  mjITEM_SLIDERINT,               // slider, int value
+  mjITEM_SLIDERNUM,               // slider, mjtNum value
+  mjITEM_EDITINT,                 // editable array, int values
+  mjITEM_EDITNUM,                 // editable array, mjtNum values
+  mjITEM_EDITFLOAT,               // editable array, float values
+  mjITEM_EDITTXT,                 // editable text
+
+  mjNITEM                         // number of item types
+} mjtItem;
+
+
+// predicate function: set enable/disable based on item category
+typedef int (*mjfItemEnable)(int category, void* data);
+
+
+//---------------------------------- mjuiState -----------------------------------------------------
+
+struct mjuiState_ {               // mouse and keyboard state
+  // constants set by user
+  int nrect;                      // number of rectangles used
+  mjrRect rect[mjMAXUIRECT];      // rectangles (index 0: entire window)
+  void* userdata;                 // pointer to user data (for callbacks)
+
+  // event type
+  int type;                       // (type mjtEvent)
+
+  // mouse buttons
+  int left;                       // is left button down
+  int right;                      // is right button down
+  int middle;                     // is middle button down
+  int doubleclick;                // is last press a double click
+  int button;                     // which button was pressed (mjtButton)
+  double buttontime;              // time of last button press
+
+  // mouse position
+  double x;                       // x position
+  double y;                       // y position
+  double dx;                      // x displacement
+  double dy;                      // y displacement
+  double sx;                      // x scroll
+  double sy;                      // y scroll
+
+  // keyboard
+  int control;                    // is control down
+  int shift;                      // is shift down
+  int alt;                        // is alt down
+  int key;                        // which key was pressed
+  double keytime;                 // time of last key press
+
+  // rectangle ownership and dragging
+  int mouserect;                  // which rectangle contains mouse
+  int dragrect;                   // which rectangle is dragged with mouse
+  int dragbutton;                 // which button started drag (mjtButton)
+
+  // files dropping (only valid when type == mjEVENT_FILESDROP)
+  int dropcount;                  // number of files dropped
+  const char** droppaths;         // paths to files dropped
+};
+typedef struct mjuiState_ mjuiState;
+
+
+//---------------------------------- mjuiThemeSpacing ----------------------------------------------
+
+struct mjuiThemeSpacing_ {        // UI visualization theme spacing
+  int total;                      // total width
+  int scroll;                     // scrollbar width
+  int label;                      // label width
+  int section;                    // section gap
+  int itemside;                   // item side gap
+  int itemmid;                    // item middle gap
+  int itemver;                    // item vertical gap
+  int texthor;                    // text horizontal gap
+  int textver;                    // text vertical gap
+  int linescroll;                 // number of pixels to scroll
+  int samples;                    // number of multisamples
+};
+typedef struct mjuiThemeSpacing_ mjuiThemeSpacing;
+
+
+//---------------------------------- mjuiThemeColor ------------------------------------------------
+
+struct mjuiThemeColor_ {          // UI visualization theme color
+  float master[3];                // master background
+  float thumb[3];                 // scrollbar thumb
+  float secttitle[3];             // section title
+  float sectfont[3];              // section font
+  float sectsymbol[3];            // section symbol
+  float sectpane[3];              // section pane
+  float shortcut[3];              // shortcut background
+  float fontactive[3];            // font active
+  float fontinactive[3];          // font inactive
+  float decorinactive[3];         // decor inactive
+  float decorinactive2[3];        // inactive slider color 2
+  float button[3];                // button
+  float check[3];                 // check
+  float radio[3];                 // radio
+  float select[3];                // select
+  float select2[3];               // select pane
+  float slider[3];                // slider
+  float slider2[3];               // slider color 2
+  float edit[3];                  // edit
+  float edit2[3];                 // edit invalid
+  float cursor[3];                // edit cursor
+};
+typedef struct mjuiThemeColor_ mjuiThemeColor;
+
+
+//---------------------------------- mjuiItem ------------------------------------------------------
+
+struct mjuiItemSingle_ {          // check and button-related
+  int modifier;                   // 0: none, 1: control, 2: shift; 4: alt
+  int shortcut;                   // shortcut key; 0: undefined
+};
+
+
+struct mjuiItemMulti_ {                  // static, radio and select-related
+  int nelem;                             // number of elements in group
+  char name[mjMAXUIMULTI][mjMAXUINAME];  // element names
+};
+
+
+struct mjuiItemSlider_ {          // slider-related
+  double range[2];                // slider range
+  double divisions;               // number of range divisions
+};
+
+
+struct mjuiItemEdit_ {            // edit-related
+  int nelem;                      // number of elements in list
+  double range[mjMAXUIEDIT][2];   // element range (min>=max: ignore)
+};
+
+
+struct mjuiItem_ {                // UI item
+  // common properties
+  int type;                       // type (mjtItem)
+  char name[mjMAXUINAME];         // name
+  int state;                      // 0: disable, 1: enable, 2+: use predicate
+  void *pdata;                    // data pointer (type-specific)
+  int sectionid;                  // id of section containing item
+  int itemid;                     // id of item within section
+
+  // type-specific properties
+  union {
+    struct mjuiItemSingle_ single;  // check and button
+    struct mjuiItemMulti_ multi;    // static, radio and select
+    struct mjuiItemSlider_ slider;  // slider
+    struct mjuiItemEdit_ edit;      // edit
+  };
+
+  // internal
+  mjrRect rect;                   // rectangle occupied by item
+};
+typedef struct mjuiItem_ mjuiItem;
+
+
+//---------------------------------- mjuiSection ---------------------------------------------------
+
+struct mjuiSection_ {             // UI section
+  // properties
+  char name[mjMAXUINAME];         // name
+  int state;                      // 0: closed, 1: open
+  int modifier;                   // 0: none, 1: control, 2: shift; 4: alt
+  int shortcut;                   // shortcut key; 0: undefined
+  int nitem;                      // number of items in use
+  mjuiItem item[mjMAXUIITEM];     // preallocated array of items
+
+  // internal
+  mjrRect rtitle;                 // rectangle occupied by title
+  mjrRect rcontent;               // rectangle occupied by content
+};
+typedef struct mjuiSection_ mjuiSection;
+
+
+//---------------------------------- mjUI ----------------------------------------------------------
+
+struct mjUI_ {                    // entire UI
+  // constants set by user
+  mjuiThemeSpacing spacing;       // UI theme spacing
+  mjuiThemeColor color;           // UI theme color
+  mjfItemEnable predicate;        // callback to set item state programmatically
+  void* userdata;                 // pointer to user data (passed to predicate)
+  int rectid;                     // index of this ui rectangle in mjuiState
+  int auxid;                      // aux buffer index of this ui
+  int radiocol;                   // number of radio columns (0 defaults to 2)
+
+  // UI sizes (framebuffer units)
+  int width;                      // width
+  int height;                     // current heigth
+  int maxheight;                  // height when all sections open
+  int scroll;                     // scroll from top of UI
+
+  // mouse focus
+  int mousesect;                  // 0: none, -1: scroll, otherwise 1+section
+  int mouseitem;                  // item within section
+  int mousehelp;                  // help button down: print shortcuts
+
+  // keyboard focus and edit
+  int editsect;                   // 0: none, otherwise 1+section
+  int edititem;                   // item within section
+  int editcursor;                 // cursor position
+  int editscroll;                 // horizontal scroll
+  char edittext[mjMAXUITEXT];     // current text
+  mjuiItem* editchanged;          // pointer to changed edit in last mjui_event
+
+  // sections
+  int nsect;                      // number of sections in use
+  mjuiSection sect[mjMAXUISECT];  // preallocated array of sections
+};
+typedef struct mjUI_ mjUI;
+
+
+//---------------------------------- mjuiDef -------------------------------------------------------
+
+struct mjuiDef_ {                 // table passed to mjui_add()
+  int type;                       // type (mjtItem); -1: section
+  char name[mjMAXUINAME];         // name
+  int state;                      // state
+  void* pdata;                    // pointer to data
+  char other[mjMAXUITEXT];        // string with type-specific properties
+};
+typedef struct mjuiDef_ mjuiDef;
+
+#endif  // MUJOCO_MJUI_H_
```

## mujoco/include/mujoco/mjvisualize.h

 * *Ordering differences only*

```diff
@@ -1,584 +1,584 @@
-// Copyright 2021 DeepMind Technologies Limited
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#ifndef MUJOCO_MJVISUALIZE_H_
-#define MUJOCO_MJVISUALIZE_H_
-
-#include <mujoco/mjdata.h>
-#include <mujoco/mjmodel.h>
-#include <mujoco/mjtnum.h>
-
-
-#define mjNGROUP        6         // number of geom, site, joint, skin groups with visflags
-#define mjMAXLIGHT      100       // maximum number of lights in a scene
-#define mjMAXOVERLAY    500       // maximum number of characters in overlay text
-#define mjMAXLINE       100       // maximum number of lines per plot
-#define mjMAXLINEPNT    1000      // maximum number points per line
-#define mjMAXPLANEGRID  200       // maximum number of grid divisions for plane
-
-
-//---------------------------------- primitive types (mjt) -----------------------------------------
-
-typedef enum mjtCatBit_ {         // bitflags for mjvGeom category
-  mjCAT_STATIC        = 1,        // model elements in body 0
-  mjCAT_DYNAMIC       = 2,        // model elements in all other bodies
-  mjCAT_DECOR         = 4,        // decorative geoms
-  mjCAT_ALL           = 7         // select all categories
-} mjtCatBit;
-
-
-typedef enum mjtMouse_ {          // mouse interaction mode
-  mjMOUSE_NONE        = 0,        // no action
-  mjMOUSE_ROTATE_V,               // rotate, vertical plane
-  mjMOUSE_ROTATE_H,               // rotate, horizontal plane
-  mjMOUSE_MOVE_V,                 // move, vertical plane
-  mjMOUSE_MOVE_H,                 // move, horizontal plane
-  mjMOUSE_ZOOM,                   // zoom
-  mjMOUSE_SELECT                  // selection
-} mjtMouse;
-
-
-typedef enum mjtPertBit_ {        // mouse perturbations
-  mjPERT_TRANSLATE    = 1,        // translation
-  mjPERT_ROTATE       = 2         // rotation
-} mjtPertBit;
-
-
-typedef enum mjtCamera_ {         // abstract camera type
-  mjCAMERA_FREE       = 0,        // free camera
-  mjCAMERA_TRACKING,              // tracking camera; uses trackbodyid
-  mjCAMERA_FIXED,                 // fixed camera; uses fixedcamid
-  mjCAMERA_USER                   // user is responsible for setting OpenGL camera
-} mjtCamera;
-
-
-typedef enum mjtLabel_ {          // object labeling
-  mjLABEL_NONE        = 0,        // nothing
-  mjLABEL_BODY,                   // body labels
-  mjLABEL_JOINT,                  // joint labels
-  mjLABEL_GEOM,                   // geom labels
-  mjLABEL_SITE,                   // site labels
-  mjLABEL_CAMERA,                 // camera labels
-  mjLABEL_LIGHT,                  // light labels
-  mjLABEL_TENDON,                 // tendon labels
-  mjLABEL_ACTUATOR,               // actuator labels
-  mjLABEL_CONSTRAINT,             // constraint labels
-  mjLABEL_SKIN,                   // skin labels
-  mjLABEL_SELECTION,              // selected object
-  mjLABEL_SELPNT,                 // coordinates of selection point
-  mjLABEL_CONTACTPOINT,           // contact information
-  mjLABEL_CONTACTFORCE,           // magnitude of contact force
-
-  mjNLABEL                        // number of label types
-} mjtLabel;
-
-
-typedef enum mjtFrame_ {          // frame visualization
-  mjFRAME_NONE        = 0,        // no frames
-  mjFRAME_BODY,                   // body frames
-  mjFRAME_GEOM,                   // geom frames
-  mjFRAME_SITE,                   // site frames
-  mjFRAME_CAMERA,                 // camera frames
-  mjFRAME_LIGHT,                  // light frames
-  mjFRAME_CONTACT,                // contact frames
-  mjFRAME_WORLD,                  // world frame
-
-  mjNFRAME                        // number of visualization frames
-} mjtFrame;
-
-
-typedef enum mjtVisFlag_ {        // flags enabling model element visualization
-  mjVIS_CONVEXHULL    = 0,        // mesh convex hull
-  mjVIS_TEXTURE,                  // textures
-  mjVIS_JOINT,                    // joints
-  mjVIS_CAMERA,                   // cameras
-  mjVIS_ACTUATOR,                 // actuators
-  mjVIS_ACTIVATION,               // activations
-  mjVIS_LIGHT,                    // lights
-  mjVIS_TENDON,                   // tendons
-  mjVIS_RANGEFINDER,              // rangefinder sensors
-  mjVIS_CONSTRAINT,               // point constraints
-  mjVIS_INERTIA,                  // equivalent inertia boxes
-  mjVIS_SCLINERTIA,               // scale equivalent inertia boxes with mass
-  mjVIS_PERTFORCE,                // perturbation force
-  mjVIS_PERTOBJ,                  // perturbation object
-  mjVIS_CONTACTPOINT,             // contact points
-  mjVIS_CONTACTFORCE,             // contact force
-  mjVIS_CONTACTSPLIT,             // split contact force into normal and tangent
-  mjVIS_TRANSPARENT,              // make dynamic geoms more transparent
-  mjVIS_AUTOCONNECT,              // auto connect joints and body coms
-  mjVIS_COM,                      // center of mass
-  mjVIS_SELECT,                   // selection point
-  mjVIS_STATIC,                   // static bodies
-  mjVIS_SKIN,                     // skin
-  mjVIS_MIDPHASE,                 // mid-phase bounding volume hierarchy
-  mjVIS_MESHBVH,                  // mesh bounding volume hierarchy
-
-  mjNVISFLAG                      // number of visualization flags
-} mjtVisFlag;
-
-
-typedef enum mjtRndFlag_ {        // flags enabling rendering effects
-  mjRND_SHADOW        = 0,        // shadows
-  mjRND_WIREFRAME,                // wireframe
-  mjRND_REFLECTION,               // reflections
-  mjRND_ADDITIVE,                 // additive transparency
-  mjRND_SKYBOX,                   // skybox
-  mjRND_FOG,                      // fog
-  mjRND_HAZE,                     // haze
-  mjRND_SEGMENT,                  // segmentation with random color
-  mjRND_IDCOLOR,                  // segmentation with segid+1 color
-  mjRND_CULL_FACE,                // cull backward faces
-
-  mjNRNDFLAG                      // number of rendering flags
-} mjtRndFlag;
-
-
-typedef enum mjtStereo_ {         // type of stereo rendering
-  mjSTEREO_NONE       = 0,        // no stereo; use left eye only
-  mjSTEREO_QUADBUFFERED,          // quad buffered; revert to side-by-side if no hardware support
-  mjSTEREO_SIDEBYSIDE             // side-by-side
-} mjtStereo;
-
-
-//---------------------------------- mjvPerturb ----------------------------------------------------
-
-struct mjvPerturb_ {              // object selection and perturbation
-  int      select;                // selected body id; non-positive: none
-  int      skinselect;            // selected skin id; negative: none
-  int      active;                // perturbation bitmask (mjtPertBit)
-  int      active2;               // secondary perturbation bitmask (mjtPertBit)
-  mjtNum   refpos[3];             // reference position for selected object
-  mjtNum   refquat[4];            // reference orientation for selected object
-  mjtNum   refselpos[3];          // reference position for selection point
-  mjtNum   localpos[3];           // selection point in object coordinates
-  mjtNum   localmass;             // spatial inertia at selection point
-  mjtNum   scale;                 // relative mouse motion-to-space scaling (set by initPerturb)
-};
-typedef struct mjvPerturb_ mjvPerturb;
-
-
-//---------------------------------- mjvCamera -----------------------------------------------------
-
-struct mjvCamera_ {               // abstract camera
-  // type and ids
-  int      type;                  // camera type (mjtCamera)
-  int      fixedcamid;            // fixed camera id
-  int      trackbodyid;           // body id to track
-
-  // abstract camera pose specification
-  mjtNum   lookat[3];             // lookat point
-  mjtNum   distance;              // distance to lookat point or tracked body
-  mjtNum   azimuth;               // camera azimuth (deg)
-  mjtNum   elevation;             // camera elevation (deg)
-};
-typedef struct mjvCamera_ mjvCamera;
-
-
-//---------------------------------- mjvGLCamera ---------------------------------------------------
-
-struct mjvGLCamera_ {             // OpenGL camera
-  // camera frame
-  float    pos[3];                // position
-  float    forward[3];            // forward direction
-  float    up[3];                 // up direction
-
-  // camera projection
-  float    frustum_center;        // hor. center (left,right set to match aspect)
-  float    frustum_bottom;        // bottom
-  float    frustum_top;           // top
-  float    frustum_near;          // near
-  float    frustum_far;           // far
-};
-typedef struct mjvGLCamera_ mjvGLCamera;
-
-
-//---------------------------------- mjvGeom -------------------------------------------------------
-
-struct mjvGeom_ {                 // abstract geom
-  // type info
-  int      type;                  // geom type (mjtGeom)
-  int      dataid;                // mesh, hfield or plane id; -1: none
-  int      objtype;               // mujoco object type; mjOBJ_UNKNOWN for decor
-  int      objid;                 // mujoco object id; -1 for decor
-  int      category;              // visual category
-  int      texid;                 // texture id; -1: no texture
-  int      texuniform;            // uniform cube mapping
-  int      texcoord;              // mesh geom has texture coordinates
-  int      segid;                 // segmentation id; -1: not shown
-
-  // OpenGL info
-  float    texrepeat[2];          // texture repetition for 2D mapping
-  float    size[3];               // size parameters
-  float    pos[3];                // Cartesian position
-  float    mat[9];                // Cartesian orientation
-  float    rgba[4];               // color and transparency
-  float    emission;              // emission coef
-  float    specular;              // specular coef
-  float    shininess;             // shininess coef
-  float    reflectance;           // reflectance coef
-  char     label[100];            // text label
-
-  // transparency rendering (set internally)
-  float    camdist;               // distance to camera (used by sorter)
-  float    modelrbound;           // geom rbound from model, 0 if not model geom
-  mjtByte  transparent;           // treat geom as transparent
-};
-typedef struct mjvGeom_ mjvGeom;
-
-
-//---------------------------------- mjvLight ------------------------------------------------------
-
-struct mjvLight_ {                // OpenGL light
-  float    pos[3];                // position rel. to body frame
-  float    dir[3];                // direction rel. to body frame
-  float    attenuation[3];        // OpenGL attenuation (quadratic model)
-  float    cutoff;                // OpenGL cutoff
-  float    exponent;              // OpenGL exponent
-  float    ambient[3];            // ambient rgb (alpha=1)
-  float    diffuse[3];            // diffuse rgb (alpha=1)
-  float    specular[3];           // specular rgb (alpha=1)
-  mjtByte  headlight;             // headlight
-  mjtByte  directional;           // directional light
-  mjtByte  castshadow;            // does light cast shadows
-};
-typedef struct mjvLight_ mjvLight;
-
-
-//---------------------------------- mjvOption -----------------------------------------------------
-
-struct mjvOption_ {                  // abstract visualization options
-  int      label;                    // what objects to label (mjtLabel)
-  int      frame;                    // which frame to show (mjtFrame)
-  mjtByte  geomgroup[mjNGROUP];      // geom visualization by group
-  mjtByte  sitegroup[mjNGROUP];      // site visualization by group
-  mjtByte  jointgroup[mjNGROUP];     // joint visualization by group
-  mjtByte  tendongroup[mjNGROUP];    // tendon visualization by group
-  mjtByte  actuatorgroup[mjNGROUP];  // actuator visualization by group
-  mjtByte  skingroup[mjNGROUP];      // skin visualization by group
-  mjtByte  flags[mjNVISFLAG];        // visualization flags (indexed by mjtVisFlag)
-  int bvh_depth;                     // depth of the bounding volume hierarchy to be visualized
-};
-typedef struct mjvOption_ mjvOption;
-
-
-//---------------------------------- mjvScene ------------------------------------------------------
-
-struct mjvScene_ {                // abstract scene passed to OpenGL renderer
-  // abstract geoms
-  int      maxgeom;               // size of allocated geom buffer
-  int      ngeom;                 // number of geoms currently in buffer
-  mjvGeom* geoms;                 // buffer for geoms (ngeom)
-  int*     geomorder;             // buffer for ordering geoms by distance to camera (ngeom)
-
-  // skin data
-  int      nskin;                 // number of skins
-  int*     skinfacenum;           // number of faces in skin (nskin)
-  int*     skinvertadr;           // address of skin vertices (nskin)
-  int*     skinvertnum;           // number of vertices in skin (nskin)
-  float*   skinvert;              // skin vertex data (nskin)
-  float*   skinnormal;            // skin normal data (nskin)
-
-  // OpenGL lights
-  int      nlight;                // number of lights currently in buffer
-  mjvLight lights[mjMAXLIGHT];    // buffer for lights (nlight)
-
-  // OpenGL cameras
-  mjvGLCamera camera[2];          // left and right camera
-
-  // OpenGL model transformation
-  mjtByte  enabletransform;       // enable model transformation
-  float    translate[3];          // model translation
-  float    rotate[4];             // model quaternion rotation
-  float    scale;                 // model scaling
-
-  // OpenGL rendering effects
-  int      stereo;                // stereoscopic rendering (mjtStereo)
-  mjtByte  flags[mjNRNDFLAG];     // rendering flags (indexed by mjtRndFlag)
-
-  // framing
-  int      framewidth;            // frame pixel width; 0: disable framing
-  float    framergb[3];           // frame color
-};
-typedef struct mjvScene_ mjvScene;
-
-
-//---------------------------------- mjvFigure -----------------------------------------------------
-
-struct mjvFigure_ {               // abstract 2D figure passed to OpenGL renderer
-  // enable flags
-  int     flg_legend;             // show legend
-  int     flg_ticklabel[2];       // show grid tick labels (x,y)
-  int     flg_extend;             // automatically extend axis ranges to fit data
-  int     flg_barplot;            // isolated line segments (i.e. GL_LINES)
-  int     flg_selection;          // vertical selection line
-  int     flg_symmetric;          // symmetric y-axis
-
-  // style settings
-  float   linewidth;              // line width
-  float   gridwidth;              // grid line width
-  int     gridsize[2];            // number of grid points in (x,y)
-  float   gridrgb[3];             // grid line rgb
-  float   figurergba[4];          // figure color and alpha
-  float   panergba[4];            // pane color and alpha
-  float   legendrgba[4];          // legend color and alpha
-  float   textrgb[3];             // text color
-  float   linergb[mjMAXLINE][3];  // line colors
-  float   range[2][2];            // axis ranges; (min>=max) automatic
-  char    xformat[20];            // x-tick label format for sprintf
-  char    yformat[20];            // y-tick label format for sprintf
-  char    minwidth[20];           // string used to determine min y-tick width
-
-  // text labels
-  char    title[1000];            // figure title; subplots separated with 2+ spaces
-  char    xlabel[100];            // x-axis label
-  char    linename[mjMAXLINE][100];  // line names for legend
-
-  // dynamic settings
-  int     legendoffset;           // number of lines to offset legend
-  int     subplot;                // selected subplot (for title rendering)
-  int     highlight[2];           // if point is in legend rect, highlight line
-  int     highlightid;            // if id>=0 and no point, highlight id
-  float   selection;              // selection line x-value
-
-  // line data
-  int     linepnt[mjMAXLINE];     // number of points in line; (0) disable
-  float   linedata[mjMAXLINE][2*mjMAXLINEPNT]; // line data (x,y)
-
-  // output from renderer
-  int     xaxispixel[2];          // range of x-axis in pixels
-  int     yaxispixel[2];          // range of y-axis in pixels
-  float   xaxisdata[2];           // range of x-axis in data units
-  float   yaxisdata[2];           // range of y-axis in data units
-};
-typedef struct mjvFigure_ mjvFigure;
-
-
-//---------------------------------- mjvSceneState -------------------------------------------------
-
-struct mjvSceneState_ {
-  int nbuffer;                     // size of the buffer in bytes
-  void* buffer;                    // heap-allocated memory for all arrays in this struct
-  int maxgeom;                     // maximum number of mjvGeom supported by this state object
-  mjvScene plugincache;            // scratch space for vis geoms inserted by plugins
-
-  // fields in mjModel that are necessary to re-render a scene
-  struct {
-    int nu;
-    int na;
-    int nbody;
-    int nbvh;
-    int njnt;
-    int ngeom;
-    int nsite;
-    int ncam;
-    int nlight;
-    int nmesh;
-    int nskin;
-    int nskinvert;
-    int nskinface;
-    int nskinbone;
-    int nskinbonevert;
-    int nmat;
-    int neq;
-    int ntendon;
-    int nwrap;
-    int nsensor;
-    int nnames;
-    int nsensordata;
-
-    mjOption opt;
-    mjVisual vis;
-    mjStatistic stat;
-
-    int* body_parentid;
-    int* body_rootid;
-    int* body_weldid;
-    int* body_mocapid;
-    int* body_jntnum;
-    int* body_jntadr;
-    int* body_geomnum;
-    int* body_geomadr;
-    mjtNum* body_iquat;
-    mjtNum* body_mass;
-    mjtNum* body_inertia;
-    int* body_bvhadr;
-    int* body_bvhnum;
-
-    int* bvh_depth;
-    int* bvh_child;
-    int* bvh_geomid;
-    mjtNum* bvh_aabb;
-
-    int* jnt_type;
-    int* jnt_bodyid;
-    int* jnt_group;
-
-    int* geom_type;
-    int* geom_bodyid;
-    int* geom_dataid;
-    int* geom_matid;
-    int* geom_group;
-    mjtNum* geom_size;
-    mjtNum* geom_aabb;
-    mjtNum* geom_rbound;
-    float* geom_rgba;
-
-    int* site_type;
-    int* site_bodyid;
-    int* site_matid;
-    int* site_group;
-    mjtNum* site_size;
-    float* site_rgba;
-
-    mjtNum* cam_fovy;
-    mjtNum* cam_ipd;
-
-    mjtByte* light_directional;
-    mjtByte* light_castshadow;
-    mjtByte* light_active;
-    float* light_attenuation;
-    float* light_cutoff;
-    float* light_exponent;
-    float* light_ambient;
-    float* light_diffuse;
-    float* light_specular;
-
-    int* mesh_texcoordadr;
-    int* mesh_graphadr;
-
-    int* skin_matid;
-    int* skin_group;
-    float* skin_rgba;
-    float* skin_inflate;
-    int* skin_vertadr;
-    int* skin_vertnum;
-    int* skin_texcoordadr;
-    int* skin_faceadr;
-    int* skin_facenum;
-    int* skin_boneadr;
-    int* skin_bonenum;
-    float* skin_vert;
-    int* skin_face;
-    int* skin_bonevertadr;
-    int* skin_bonevertnum;
-    float* skin_bonebindpos;
-    float* skin_bonebindquat;
-    int* skin_bonebodyid;
-    int* skin_bonevertid;
-    float* skin_bonevertweight;
-
-    int* mat_texid;
-    mjtByte* mat_texuniform;
-    float* mat_texrepeat;
-    float* mat_emission;
-    float* mat_specular;
-    float* mat_shininess;
-    float* mat_reflectance;
-    float* mat_rgba;
-
-    int* eq_type;
-    int* eq_obj1id;
-    int* eq_obj2id;
-    mjtByte* eq_active;
-    mjtNum* eq_data;
-
-    int* tendon_num;
-    int* tendon_matid;
-    int* tendon_group;
-    mjtByte* tendon_limited;
-    mjtNum* tendon_width;
-    mjtNum* tendon_range;
-    mjtNum* tendon_stiffness;
-    mjtNum* tendon_damping;
-    mjtNum* tendon_frictionloss;
-    mjtNum* tendon_lengthspring;
-    float* tendon_rgba;
-
-    int* actuator_trntype;
-    int* actuator_dyntype;
-    int* actuator_trnid;
-    int* actuator_actadr;
-    int* actuator_actnum;
-    int* actuator_group;
-    mjtByte* actuator_ctrllimited;
-    mjtByte* actuator_actlimited;
-    mjtNum* actuator_ctrlrange;
-    mjtNum* actuator_actrange;
-    mjtNum* actuator_cranklength;
-
-    int* sensor_type;
-    int* sensor_objid;
-    int* sensor_adr;
-
-    int* name_bodyadr;
-    int* name_jntadr;
-    int* name_geomadr;
-    int* name_siteadr;
-    int* name_camadr;
-    int* name_lightadr;
-    int* name_eqadr;
-    int* name_tendonadr;
-    int* name_actuatoradr;
-    char* names;
-  } model;
-
-  // fields in mjData that are necessary to re-render a scene
-  struct {
-    mjWarningStat warning[mjNWARNING];
-
-    int nefc;
-    int ncon;
-
-    mjtNum time;
-
-    mjtNum* act;
-
-    mjtNum* ctrl;
-    mjtNum* xfrc_applied;
-
-    mjtNum* sensordata;
-
-    mjtNum* xpos;
-    mjtNum* xquat;
-    mjtNum* xmat;
-    mjtNum* xipos;
-    mjtNum* ximat;
-    mjtNum* xanchor;
-    mjtNum* xaxis;
-    mjtNum* geom_xpos;
-    mjtNum* geom_xmat;
-    mjtNum* site_xpos;
-    mjtNum* site_xmat;
-    mjtNum* cam_xpos;
-    mjtNum* cam_xmat;
-    mjtNum* light_xpos;
-    mjtNum* light_xdir;
-
-    mjtNum* subtree_com;
-
-    int* ten_wrapadr;
-    int* ten_wrapnum;
-    int* wrap_obj;
-    mjtNum* wrap_xpos;
-
-    mjtByte* bvh_active;
-
-    mjContact* contact;
-    mjtNum* efc_force;
-  } data;
-};
-typedef struct mjvSceneState_ mjvSceneState;
-
-#endif  // MUJOCO_MJVISUALIZE_H_
+// Copyright 2021 DeepMind Technologies Limited
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef MUJOCO_MJVISUALIZE_H_
+#define MUJOCO_MJVISUALIZE_H_
+
+#include <mujoco/mjdata.h>
+#include <mujoco/mjmodel.h>
+#include <mujoco/mjtnum.h>
+
+
+#define mjNGROUP        6         // number of geom, site, joint, skin groups with visflags
+#define mjMAXLIGHT      100       // maximum number of lights in a scene
+#define mjMAXOVERLAY    500       // maximum number of characters in overlay text
+#define mjMAXLINE       100       // maximum number of lines per plot
+#define mjMAXLINEPNT    1000      // maximum number points per line
+#define mjMAXPLANEGRID  200       // maximum number of grid divisions for plane
+
+
+//---------------------------------- primitive types (mjt) -----------------------------------------
+
+typedef enum mjtCatBit_ {         // bitflags for mjvGeom category
+  mjCAT_STATIC        = 1,        // model elements in body 0
+  mjCAT_DYNAMIC       = 2,        // model elements in all other bodies
+  mjCAT_DECOR         = 4,        // decorative geoms
+  mjCAT_ALL           = 7         // select all categories
+} mjtCatBit;
+
+
+typedef enum mjtMouse_ {          // mouse interaction mode
+  mjMOUSE_NONE        = 0,        // no action
+  mjMOUSE_ROTATE_V,               // rotate, vertical plane
+  mjMOUSE_ROTATE_H,               // rotate, horizontal plane
+  mjMOUSE_MOVE_V,                 // move, vertical plane
+  mjMOUSE_MOVE_H,                 // move, horizontal plane
+  mjMOUSE_ZOOM,                   // zoom
+  mjMOUSE_SELECT                  // selection
+} mjtMouse;
+
+
+typedef enum mjtPertBit_ {        // mouse perturbations
+  mjPERT_TRANSLATE    = 1,        // translation
+  mjPERT_ROTATE       = 2         // rotation
+} mjtPertBit;
+
+
+typedef enum mjtCamera_ {         // abstract camera type
+  mjCAMERA_FREE       = 0,        // free camera
+  mjCAMERA_TRACKING,              // tracking camera; uses trackbodyid
+  mjCAMERA_FIXED,                 // fixed camera; uses fixedcamid
+  mjCAMERA_USER                   // user is responsible for setting OpenGL camera
+} mjtCamera;
+
+
+typedef enum mjtLabel_ {          // object labeling
+  mjLABEL_NONE        = 0,        // nothing
+  mjLABEL_BODY,                   // body labels
+  mjLABEL_JOINT,                  // joint labels
+  mjLABEL_GEOM,                   // geom labels
+  mjLABEL_SITE,                   // site labels
+  mjLABEL_CAMERA,                 // camera labels
+  mjLABEL_LIGHT,                  // light labels
+  mjLABEL_TENDON,                 // tendon labels
+  mjLABEL_ACTUATOR,               // actuator labels
+  mjLABEL_CONSTRAINT,             // constraint labels
+  mjLABEL_SKIN,                   // skin labels
+  mjLABEL_SELECTION,              // selected object
+  mjLABEL_SELPNT,                 // coordinates of selection point
+  mjLABEL_CONTACTPOINT,           // contact information
+  mjLABEL_CONTACTFORCE,           // magnitude of contact force
+
+  mjNLABEL                        // number of label types
+} mjtLabel;
+
+
+typedef enum mjtFrame_ {          // frame visualization
+  mjFRAME_NONE        = 0,        // no frames
+  mjFRAME_BODY,                   // body frames
+  mjFRAME_GEOM,                   // geom frames
+  mjFRAME_SITE,                   // site frames
+  mjFRAME_CAMERA,                 // camera frames
+  mjFRAME_LIGHT,                  // light frames
+  mjFRAME_CONTACT,                // contact frames
+  mjFRAME_WORLD,                  // world frame
+
+  mjNFRAME                        // number of visualization frames
+} mjtFrame;
+
+
+typedef enum mjtVisFlag_ {        // flags enabling model element visualization
+  mjVIS_CONVEXHULL    = 0,        // mesh convex hull
+  mjVIS_TEXTURE,                  // textures
+  mjVIS_JOINT,                    // joints
+  mjVIS_CAMERA,                   // cameras
+  mjVIS_ACTUATOR,                 // actuators
+  mjVIS_ACTIVATION,               // activations
+  mjVIS_LIGHT,                    // lights
+  mjVIS_TENDON,                   // tendons
+  mjVIS_RANGEFINDER,              // rangefinder sensors
+  mjVIS_CONSTRAINT,               // point constraints
+  mjVIS_INERTIA,                  // equivalent inertia boxes
+  mjVIS_SCLINERTIA,               // scale equivalent inertia boxes with mass
+  mjVIS_PERTFORCE,                // perturbation force
+  mjVIS_PERTOBJ,                  // perturbation object
+  mjVIS_CONTACTPOINT,             // contact points
+  mjVIS_CONTACTFORCE,             // contact force
+  mjVIS_CONTACTSPLIT,             // split contact force into normal and tangent
+  mjVIS_TRANSPARENT,              // make dynamic geoms more transparent
+  mjVIS_AUTOCONNECT,              // auto connect joints and body coms
+  mjVIS_COM,                      // center of mass
+  mjVIS_SELECT,                   // selection point
+  mjVIS_STATIC,                   // static bodies
+  mjVIS_SKIN,                     // skin
+  mjVIS_MIDPHASE,                 // mid-phase bounding volume hierarchy
+  mjVIS_MESHBVH,                  // mesh bounding volume hierarchy
+
+  mjNVISFLAG                      // number of visualization flags
+} mjtVisFlag;
+
+
+typedef enum mjtRndFlag_ {        // flags enabling rendering effects
+  mjRND_SHADOW        = 0,        // shadows
+  mjRND_WIREFRAME,                // wireframe
+  mjRND_REFLECTION,               // reflections
+  mjRND_ADDITIVE,                 // additive transparency
+  mjRND_SKYBOX,                   // skybox
+  mjRND_FOG,                      // fog
+  mjRND_HAZE,                     // haze
+  mjRND_SEGMENT,                  // segmentation with random color
+  mjRND_IDCOLOR,                  // segmentation with segid+1 color
+  mjRND_CULL_FACE,                // cull backward faces
+
+  mjNRNDFLAG                      // number of rendering flags
+} mjtRndFlag;
+
+
+typedef enum mjtStereo_ {         // type of stereo rendering
+  mjSTEREO_NONE       = 0,        // no stereo; use left eye only
+  mjSTEREO_QUADBUFFERED,          // quad buffered; revert to side-by-side if no hardware support
+  mjSTEREO_SIDEBYSIDE             // side-by-side
+} mjtStereo;
+
+
+//---------------------------------- mjvPerturb ----------------------------------------------------
+
+struct mjvPerturb_ {              // object selection and perturbation
+  int      select;                // selected body id; non-positive: none
+  int      skinselect;            // selected skin id; negative: none
+  int      active;                // perturbation bitmask (mjtPertBit)
+  int      active2;               // secondary perturbation bitmask (mjtPertBit)
+  mjtNum   refpos[3];             // reference position for selected object
+  mjtNum   refquat[4];            // reference orientation for selected object
+  mjtNum   refselpos[3];          // reference position for selection point
+  mjtNum   localpos[3];           // selection point in object coordinates
+  mjtNum   localmass;             // spatial inertia at selection point
+  mjtNum   scale;                 // relative mouse motion-to-space scaling (set by initPerturb)
+};
+typedef struct mjvPerturb_ mjvPerturb;
+
+
+//---------------------------------- mjvCamera -----------------------------------------------------
+
+struct mjvCamera_ {               // abstract camera
+  // type and ids
+  int      type;                  // camera type (mjtCamera)
+  int      fixedcamid;            // fixed camera id
+  int      trackbodyid;           // body id to track
+
+  // abstract camera pose specification
+  mjtNum   lookat[3];             // lookat point
+  mjtNum   distance;              // distance to lookat point or tracked body
+  mjtNum   azimuth;               // camera azimuth (deg)
+  mjtNum   elevation;             // camera elevation (deg)
+};
+typedef struct mjvCamera_ mjvCamera;
+
+
+//---------------------------------- mjvGLCamera ---------------------------------------------------
+
+struct mjvGLCamera_ {             // OpenGL camera
+  // camera frame
+  float    pos[3];                // position
+  float    forward[3];            // forward direction
+  float    up[3];                 // up direction
+
+  // camera projection
+  float    frustum_center;        // hor. center (left,right set to match aspect)
+  float    frustum_bottom;        // bottom
+  float    frustum_top;           // top
+  float    frustum_near;          // near
+  float    frustum_far;           // far
+};
+typedef struct mjvGLCamera_ mjvGLCamera;
+
+
+//---------------------------------- mjvGeom -------------------------------------------------------
+
+struct mjvGeom_ {                 // abstract geom
+  // type info
+  int      type;                  // geom type (mjtGeom)
+  int      dataid;                // mesh, hfield or plane id; -1: none
+  int      objtype;               // mujoco object type; mjOBJ_UNKNOWN for decor
+  int      objid;                 // mujoco object id; -1 for decor
+  int      category;              // visual category
+  int      texid;                 // texture id; -1: no texture
+  int      texuniform;            // uniform cube mapping
+  int      texcoord;              // mesh geom has texture coordinates
+  int      segid;                 // segmentation id; -1: not shown
+
+  // OpenGL info
+  float    texrepeat[2];          // texture repetition for 2D mapping
+  float    size[3];               // size parameters
+  float    pos[3];                // Cartesian position
+  float    mat[9];                // Cartesian orientation
+  float    rgba[4];               // color and transparency
+  float    emission;              // emission coef
+  float    specular;              // specular coef
+  float    shininess;             // shininess coef
+  float    reflectance;           // reflectance coef
+  char     label[100];            // text label
+
+  // transparency rendering (set internally)
+  float    camdist;               // distance to camera (used by sorter)
+  float    modelrbound;           // geom rbound from model, 0 if not model geom
+  mjtByte  transparent;           // treat geom as transparent
+};
+typedef struct mjvGeom_ mjvGeom;
+
+
+//---------------------------------- mjvLight ------------------------------------------------------
+
+struct mjvLight_ {                // OpenGL light
+  float    pos[3];                // position rel. to body frame
+  float    dir[3];                // direction rel. to body frame
+  float    attenuation[3];        // OpenGL attenuation (quadratic model)
+  float    cutoff;                // OpenGL cutoff
+  float    exponent;              // OpenGL exponent
+  float    ambient[3];            // ambient rgb (alpha=1)
+  float    diffuse[3];            // diffuse rgb (alpha=1)
+  float    specular[3];           // specular rgb (alpha=1)
+  mjtByte  headlight;             // headlight
+  mjtByte  directional;           // directional light
+  mjtByte  castshadow;            // does light cast shadows
+};
+typedef struct mjvLight_ mjvLight;
+
+
+//---------------------------------- mjvOption -----------------------------------------------------
+
+struct mjvOption_ {                  // abstract visualization options
+  int      label;                    // what objects to label (mjtLabel)
+  int      frame;                    // which frame to show (mjtFrame)
+  mjtByte  geomgroup[mjNGROUP];      // geom visualization by group
+  mjtByte  sitegroup[mjNGROUP];      // site visualization by group
+  mjtByte  jointgroup[mjNGROUP];     // joint visualization by group
+  mjtByte  tendongroup[mjNGROUP];    // tendon visualization by group
+  mjtByte  actuatorgroup[mjNGROUP];  // actuator visualization by group
+  mjtByte  skingroup[mjNGROUP];      // skin visualization by group
+  mjtByte  flags[mjNVISFLAG];        // visualization flags (indexed by mjtVisFlag)
+  int bvh_depth;                     // depth of the bounding volume hierarchy to be visualized
+};
+typedef struct mjvOption_ mjvOption;
+
+
+//---------------------------------- mjvScene ------------------------------------------------------
+
+struct mjvScene_ {                // abstract scene passed to OpenGL renderer
+  // abstract geoms
+  int      maxgeom;               // size of allocated geom buffer
+  int      ngeom;                 // number of geoms currently in buffer
+  mjvGeom* geoms;                 // buffer for geoms (ngeom)
+  int*     geomorder;             // buffer for ordering geoms by distance to camera (ngeom)
+
+  // skin data
+  int      nskin;                 // number of skins
+  int*     skinfacenum;           // number of faces in skin (nskin)
+  int*     skinvertadr;           // address of skin vertices (nskin)
+  int*     skinvertnum;           // number of vertices in skin (nskin)
+  float*   skinvert;              // skin vertex data (nskin)
+  float*   skinnormal;            // skin normal data (nskin)
+
+  // OpenGL lights
+  int      nlight;                // number of lights currently in buffer
+  mjvLight lights[mjMAXLIGHT];    // buffer for lights (nlight)
+
+  // OpenGL cameras
+  mjvGLCamera camera[2];          // left and right camera
+
+  // OpenGL model transformation
+  mjtByte  enabletransform;       // enable model transformation
+  float    translate[3];          // model translation
+  float    rotate[4];             // model quaternion rotation
+  float    scale;                 // model scaling
+
+  // OpenGL rendering effects
+  int      stereo;                // stereoscopic rendering (mjtStereo)
+  mjtByte  flags[mjNRNDFLAG];     // rendering flags (indexed by mjtRndFlag)
+
+  // framing
+  int      framewidth;            // frame pixel width; 0: disable framing
+  float    framergb[3];           // frame color
+};
+typedef struct mjvScene_ mjvScene;
+
+
+//---------------------------------- mjvFigure -----------------------------------------------------
+
+struct mjvFigure_ {               // abstract 2D figure passed to OpenGL renderer
+  // enable flags
+  int     flg_legend;             // show legend
+  int     flg_ticklabel[2];       // show grid tick labels (x,y)
+  int     flg_extend;             // automatically extend axis ranges to fit data
+  int     flg_barplot;            // isolated line segments (i.e. GL_LINES)
+  int     flg_selection;          // vertical selection line
+  int     flg_symmetric;          // symmetric y-axis
+
+  // style settings
+  float   linewidth;              // line width
+  float   gridwidth;              // grid line width
+  int     gridsize[2];            // number of grid points in (x,y)
+  float   gridrgb[3];             // grid line rgb
+  float   figurergba[4];          // figure color and alpha
+  float   panergba[4];            // pane color and alpha
+  float   legendrgba[4];          // legend color and alpha
+  float   textrgb[3];             // text color
+  float   linergb[mjMAXLINE][3];  // line colors
+  float   range[2][2];            // axis ranges; (min>=max) automatic
+  char    xformat[20];            // x-tick label format for sprintf
+  char    yformat[20];            // y-tick label format for sprintf
+  char    minwidth[20];           // string used to determine min y-tick width
+
+  // text labels
+  char    title[1000];            // figure title; subplots separated with 2+ spaces
+  char    xlabel[100];            // x-axis label
+  char    linename[mjMAXLINE][100];  // line names for legend
+
+  // dynamic settings
+  int     legendoffset;           // number of lines to offset legend
+  int     subplot;                // selected subplot (for title rendering)
+  int     highlight[2];           // if point is in legend rect, highlight line
+  int     highlightid;            // if id>=0 and no point, highlight id
+  float   selection;              // selection line x-value
+
+  // line data
+  int     linepnt[mjMAXLINE];     // number of points in line; (0) disable
+  float   linedata[mjMAXLINE][2*mjMAXLINEPNT]; // line data (x,y)
+
+  // output from renderer
+  int     xaxispixel[2];          // range of x-axis in pixels
+  int     yaxispixel[2];          // range of y-axis in pixels
+  float   xaxisdata[2];           // range of x-axis in data units
+  float   yaxisdata[2];           // range of y-axis in data units
+};
+typedef struct mjvFigure_ mjvFigure;
+
+
+//---------------------------------- mjvSceneState -------------------------------------------------
+
+struct mjvSceneState_ {
+  int nbuffer;                     // size of the buffer in bytes
+  void* buffer;                    // heap-allocated memory for all arrays in this struct
+  int maxgeom;                     // maximum number of mjvGeom supported by this state object
+  mjvScene plugincache;            // scratch space for vis geoms inserted by plugins
+
+  // fields in mjModel that are necessary to re-render a scene
+  struct {
+    int nu;
+    int na;
+    int nbody;
+    int nbvh;
+    int njnt;
+    int ngeom;
+    int nsite;
+    int ncam;
+    int nlight;
+    int nmesh;
+    int nskin;
+    int nskinvert;
+    int nskinface;
+    int nskinbone;
+    int nskinbonevert;
+    int nmat;
+    int neq;
+    int ntendon;
+    int nwrap;
+    int nsensor;
+    int nnames;
+    int nsensordata;
+
+    mjOption opt;
+    mjVisual vis;
+    mjStatistic stat;
+
+    int* body_parentid;
+    int* body_rootid;
+    int* body_weldid;
+    int* body_mocapid;
+    int* body_jntnum;
+    int* body_jntadr;
+    int* body_geomnum;
+    int* body_geomadr;
+    mjtNum* body_iquat;
+    mjtNum* body_mass;
+    mjtNum* body_inertia;
+    int* body_bvhadr;
+    int* body_bvhnum;
+
+    int* bvh_depth;
+    int* bvh_child;
+    int* bvh_geomid;
+    mjtNum* bvh_aabb;
+
+    int* jnt_type;
+    int* jnt_bodyid;
+    int* jnt_group;
+
+    int* geom_type;
+    int* geom_bodyid;
+    int* geom_dataid;
+    int* geom_matid;
+    int* geom_group;
+    mjtNum* geom_size;
+    mjtNum* geom_aabb;
+    mjtNum* geom_rbound;
+    float* geom_rgba;
+
+    int* site_type;
+    int* site_bodyid;
+    int* site_matid;
+    int* site_group;
+    mjtNum* site_size;
+    float* site_rgba;
+
+    mjtNum* cam_fovy;
+    mjtNum* cam_ipd;
+
+    mjtByte* light_directional;
+    mjtByte* light_castshadow;
+    mjtByte* light_active;
+    float* light_attenuation;
+    float* light_cutoff;
+    float* light_exponent;
+    float* light_ambient;
+    float* light_diffuse;
+    float* light_specular;
+
+    int* mesh_texcoordadr;
+    int* mesh_graphadr;
+
+    int* skin_matid;
+    int* skin_group;
+    float* skin_rgba;
+    float* skin_inflate;
+    int* skin_vertadr;
+    int* skin_vertnum;
+    int* skin_texcoordadr;
+    int* skin_faceadr;
+    int* skin_facenum;
+    int* skin_boneadr;
+    int* skin_bonenum;
+    float* skin_vert;
+    int* skin_face;
+    int* skin_bonevertadr;
+    int* skin_bonevertnum;
+    float* skin_bonebindpos;
+    float* skin_bonebindquat;
+    int* skin_bonebodyid;
+    int* skin_bonevertid;
+    float* skin_bonevertweight;
+
+    int* mat_texid;
+    mjtByte* mat_texuniform;
+    float* mat_texrepeat;
+    float* mat_emission;
+    float* mat_specular;
+    float* mat_shininess;
+    float* mat_reflectance;
+    float* mat_rgba;
+
+    int* eq_type;
+    int* eq_obj1id;
+    int* eq_obj2id;
+    mjtByte* eq_active;
+    mjtNum* eq_data;
+
+    int* tendon_num;
+    int* tendon_matid;
+    int* tendon_group;
+    mjtByte* tendon_limited;
+    mjtNum* tendon_width;
+    mjtNum* tendon_range;
+    mjtNum* tendon_stiffness;
+    mjtNum* tendon_damping;
+    mjtNum* tendon_frictionloss;
+    mjtNum* tendon_lengthspring;
+    float* tendon_rgba;
+
+    int* actuator_trntype;
+    int* actuator_dyntype;
+    int* actuator_trnid;
+    int* actuator_actadr;
+    int* actuator_actnum;
+    int* actuator_group;
+    mjtByte* actuator_ctrllimited;
+    mjtByte* actuator_actlimited;
+    mjtNum* actuator_ctrlrange;
+    mjtNum* actuator_actrange;
+    mjtNum* actuator_cranklength;
+
+    int* sensor_type;
+    int* sensor_objid;
+    int* sensor_adr;
+
+    int* name_bodyadr;
+    int* name_jntadr;
+    int* name_geomadr;
+    int* name_siteadr;
+    int* name_camadr;
+    int* name_lightadr;
+    int* name_eqadr;
+    int* name_tendonadr;
+    int* name_actuatoradr;
+    char* names;
+  } model;
+
+  // fields in mjData that are necessary to re-render a scene
+  struct {
+    mjWarningStat warning[mjNWARNING];
+
+    int nefc;
+    int ncon;
+
+    mjtNum time;
+
+    mjtNum* act;
+
+    mjtNum* ctrl;
+    mjtNum* xfrc_applied;
+
+    mjtNum* sensordata;
+
+    mjtNum* xpos;
+    mjtNum* xquat;
+    mjtNum* xmat;
+    mjtNum* xipos;
+    mjtNum* ximat;
+    mjtNum* xanchor;
+    mjtNum* xaxis;
+    mjtNum* geom_xpos;
+    mjtNum* geom_xmat;
+    mjtNum* site_xpos;
+    mjtNum* site_xmat;
+    mjtNum* cam_xpos;
+    mjtNum* cam_xmat;
+    mjtNum* light_xpos;
+    mjtNum* light_xdir;
+
+    mjtNum* subtree_com;
+
+    int* ten_wrapadr;
+    int* ten_wrapnum;
+    int* wrap_obj;
+    mjtNum* wrap_xpos;
+
+    mjtByte* bvh_active;
+
+    mjContact* contact;
+    mjtNum* efc_force;
+  } data;
+};
+typedef struct mjvSceneState_ mjvSceneState;
+
+#endif  // MUJOCO_MJVISUALIZE_H_
```

## mujoco/include/mujoco/mjxmacro.h

 * *Ordering differences only*

```diff
@@ -1,641 +1,641 @@
-// Copyright 2021 DeepMind Technologies Limited
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#ifndef MUJOCO_MJXMACRO_H_
-#define MUJOCO_MJXMACRO_H_
-
-
-//-------------------------------- mjOption --------------------------------------------------------
-
-// scalar fields of mjOption
-#define MJOPTION_FLOATS             \
-    X( mjtNum,  timestep         )  \
-    X( mjtNum,  apirate          )  \
-    X( mjtNum,  impratio         )  \
-    X( mjtNum,  tolerance        )  \
-    X( mjtNum,  noslip_tolerance )  \
-    X( mjtNum,  mpr_tolerance    )  \
-    X( mjtNum,  density          )  \
-    X( mjtNum,  viscosity        )  \
-    X( mjtNum,  o_margin         )  \
-
-
-#define MJOPTION_INTS               \
-    X( int,     integrator        ) \
-    X( int,     collision         ) \
-    X( int,     cone              ) \
-    X( int,     jacobian          ) \
-    X( int,     solver            ) \
-    X( int,     iterations        ) \
-    X( int,     noslip_iterations ) \
-    X( int,     mpr_iterations    ) \
-    X( int,     disableflags      ) \
-    X( int,     enableflags       )
-
-
-#define MJOPTION_SCALARS            \
-    MJOPTION_FLOATS                 \
-    MJOPTION_INTS
-
-
-// vector fields of mjOption
-#define MJOPTION_VECTORS            \
-    X( gravity,         3       )   \
-    X( wind,            3       )   \
-    X( magnetic,        3       )   \
-    X( o_solref,        mjNREF  )   \
-    X( o_solimp,        mjNIMP  )
-
-
-//-------------------------------- mjModel ---------------------------------------------------------
-
-// int fields of mjModel
-#define MJMODEL_INTS        \
-    X   ( nq )                 \
-    X   ( nv )                 \
-    XMJV( nu )                 \
-    XMJV( na )                 \
-    XMJV( nbody )              \
-    XMJV( nbvh )               \
-    XMJV( njnt )               \
-    XMJV( ngeom )              \
-    XMJV( nsite )              \
-    XMJV( ncam )               \
-    XMJV( nlight )             \
-    XMJV( nmesh )              \
-    X   ( nmeshvert )          \
-    X   ( nmeshnormal )        \
-    X   ( nmeshtexcoord )      \
-    X   ( nmeshface )          \
-    X   ( nmeshgraph )         \
-    XMJV( nskin )              \
-    XMJV( nskinvert )          \
-    X   ( nskintexvert )       \
-    XMJV( nskinface )          \
-    XMJV( nskinbone )          \
-    XMJV( nskinbonevert )      \
-    X   ( nhfield )            \
-    X   ( nhfielddata )        \
-    X   ( ntex )               \
-    X   ( ntexdata )           \
-    XMJV( nmat )               \
-    X   ( npair )              \
-    X   ( nexclude )           \
-    XMJV( neq )                \
-    XMJV( ntendon )            \
-    XMJV( nwrap )              \
-    XMJV( nsensor )            \
-    X   ( nnumeric )           \
-    X   ( nnumericdata )       \
-    X   ( ntext )              \
-    X   ( ntextdata )          \
-    X   ( ntuple )             \
-    X   ( ntupledata )         \
-    X   ( nkey )               \
-    X   ( nmocap )             \
-    X   ( nplugin )            \
-    X   ( npluginattr )        \
-    X   ( nuser_body )         \
-    X   ( nuser_jnt )          \
-    X   ( nuser_geom )         \
-    X   ( nuser_site )         \
-    X   ( nuser_cam )          \
-    X   ( nuser_tendon )       \
-    X   ( nuser_actuator )     \
-    X   ( nuser_sensor )       \
-    XMJV( nnames )             \
-    X   ( nnames_map )         \
-    X   ( nM )                 \
-    X   ( nD )                 \
-    X   ( nB )                 \
-    X   ( nemax )              \
-    X   ( njmax )              \
-    X   ( nconmax )            \
-    X   ( nstack )             \
-    X   ( nuserdata )          \
-    XMJV( nsensordata )        \
-    X   ( npluginstate )       \
-    X   ( nbuffer )
-
-
-// define symbols needed in MJMODEL_POINTERS (corresponding to number of columns)
-#define MJMODEL_POINTERS_PREAMBLE( m )      \
-    int nuser_body = m->nuser_body;         \
-    int nuser_jnt = m->nuser_jnt;           \
-    int nuser_geom = m->nuser_geom;         \
-    int nuser_site = m->nuser_site;         \
-    int nuser_cam = m->nuser_cam;           \
-    int nuser_tendon = m->nuser_tendon;     \
-    int nuser_actuator = m->nuser_actuator; \
-    int nuser_sensor = m->nuser_sensor;     \
-    int nq = m->nq;                         \
-    int nv = m->nv;                         \
-    int na = m->na;                         \
-    int nu = m->nu;                         \
-    int nmocap = m->nmocap;
-
-// macro for annotating that an array size in an X macro is a member of mjModel
-// by default this macro does nothing, but users can redefine it as necessary
-#define MJ_M(n) n
-
-
-// pointer fields of mjModel
-// XMJV means that the field is required to construct mjvScene
-// (by default we define XMJV to be the same as X)
-#define MJMODEL_POINTERS                                                     \
-    X   ( mjtNum,  qpos0,                 nq,            1                    ) \
-    X   ( mjtNum,  qpos_spring,           nq,            1                    ) \
-    XMJV( int,     body_parentid,         nbody,         1                    ) \
-    XMJV( int,     body_rootid,           nbody,         1                    ) \
-    XMJV( int,     body_weldid,           nbody,         1                    ) \
-    XMJV( int,     body_mocapid,          nbody,         1                    ) \
-    XMJV( int,     body_jntnum,           nbody,         1                    ) \
-    XMJV( int,     body_jntadr,           nbody,         1                    ) \
-    X   ( int,     body_dofnum,           nbody,         1                    ) \
-    X   ( int,     body_dofadr,           nbody,         1                    ) \
-    XMJV( int,     body_geomnum,          nbody,         1                    ) \
-    XMJV( int,     body_geomadr,          nbody,         1                    ) \
-    X   ( mjtByte, body_simple,           nbody,         1                    ) \
-    X   ( mjtByte, body_sameframe,        nbody,         1                    ) \
-    X   ( mjtNum,  body_pos,              nbody,         3                    ) \
-    X   ( mjtNum,  body_quat,             nbody,         4                    ) \
-    X   ( mjtNum,  body_ipos,             nbody,         3                    ) \
-    XMJV( mjtNum,  body_iquat,            nbody,         4                    ) \
-    XMJV( mjtNum,  body_mass,             nbody,         1                    ) \
-    X   ( mjtNum,  body_subtreemass,      nbody,         1                    ) \
-    XMJV( mjtNum,  body_inertia,          nbody,         3                    ) \
-    X   ( mjtNum,  body_invweight0,       nbody,         2                    ) \
-    X   ( mjtNum,  body_gravcomp,         nbody,         1                    ) \
-    X   ( mjtNum,  body_user,             nbody,         MJ_M(nuser_body)     ) \
-    X   ( int,     body_plugin,           nbody,         1                    ) \
-    XMJV( int,     body_bvhadr,           nbody,         1                    ) \
-    XMJV( int,     body_bvhnum,           nbody,         1                    ) \
-    XMJV( int,     bvh_depth,             nbvh,          1                    ) \
-    XMJV( int,     bvh_child,             nbvh,          2                    ) \
-    XMJV( int,     bvh_geomid,            nbvh,          1                    ) \
-    XMJV( mjtNum,  bvh_aabb,              nbvh,          6                    ) \
-    XMJV( int,     jnt_type,              njnt,          1                    ) \
-    X   ( int,     jnt_qposadr,           njnt,          1                    ) \
-    X   ( int,     jnt_dofadr,            njnt,          1                    ) \
-    XMJV( int,     jnt_bodyid,            njnt,          1                    ) \
-    XMJV( int,     jnt_group,             njnt,          1                    ) \
-    X   ( mjtByte, jnt_limited,           njnt,          1                    ) \
-    X   ( mjtByte, jnt_actfrclimited,     njnt,          1                    ) \
-    X   ( mjtNum,  jnt_solref,            njnt,          mjNREF               ) \
-    X   ( mjtNum,  jnt_solimp,            njnt,          mjNIMP               ) \
-    X   ( mjtNum,  jnt_pos,               njnt,          3                    ) \
-    X   ( mjtNum,  jnt_axis,              njnt,          3                    ) \
-    X   ( mjtNum,  jnt_stiffness,         njnt,          1                    ) \
-    X   ( mjtNum,  jnt_range,             njnt,          2                    ) \
-    X   ( mjtNum,  jnt_actfrcrange,       njnt,          2                    ) \
-    X   ( mjtNum,  jnt_margin,            njnt,          1                    ) \
-    X   ( mjtNum,  jnt_user,              njnt,          MJ_M(nuser_jnt)      ) \
-    X   ( int,     dof_bodyid,            nv,            1                    ) \
-    X   ( int,     dof_jntid,             nv,            1                    ) \
-    X   ( int,     dof_parentid,          nv,            1                    ) \
-    X   ( int,     dof_Madr,              nv,            1                    ) \
-    X   ( int,     dof_simplenum,         nv,            1                    ) \
-    X   ( mjtNum,  dof_solref,            nv,            mjNREF               ) \
-    X   ( mjtNum,  dof_solimp,            nv,            mjNIMP               ) \
-    X   ( mjtNum,  dof_frictionloss,      nv,            1                    ) \
-    X   ( mjtNum,  dof_armature,          nv,            1                    ) \
-    X   ( mjtNum,  dof_damping,           nv,            1                    ) \
-    X   ( mjtNum,  dof_invweight0,        nv,            1                    ) \
-    X   ( mjtNum,  dof_M0,                nv,            1                    ) \
-    XMJV( int,     geom_type,             ngeom,         1                    ) \
-    X   ( int,     geom_contype,          ngeom,         1                    ) \
-    X   ( int,     geom_conaffinity,      ngeom,         1                    ) \
-    X   ( int,     geom_condim,           ngeom,         1                    ) \
-    XMJV( int,     geom_bodyid,           ngeom,         1                    ) \
-    XMJV( int,     geom_dataid,           ngeom,         1                    ) \
-    XMJV( int,     geom_matid,            ngeom,         1                    ) \
-    XMJV( int,     geom_group,            ngeom,         1                    ) \
-    X   ( int,     geom_priority,         ngeom,         1                    ) \
-    X   ( mjtByte, geom_sameframe,        ngeom,         1                    ) \
-    X   ( mjtNum,  geom_solmix,           ngeom,         1                    ) \
-    X   ( mjtNum,  geom_solref,           ngeom,         mjNREF               ) \
-    X   ( mjtNum,  geom_solimp,           ngeom,         mjNIMP               ) \
-    XMJV( mjtNum,  geom_size,             ngeom,         3                    ) \
-    XMJV( mjtNum,  geom_aabb,             ngeom,         6                    ) \
-    XMJV( mjtNum,  geom_rbound,           ngeom,         1                    ) \
-    X   ( mjtNum,  geom_pos,              ngeom,         3                    ) \
-    X   ( mjtNum,  geom_quat,             ngeom,         4                    ) \
-    X   ( mjtNum,  geom_friction,         ngeom,         3                    ) \
-    X   ( mjtNum,  geom_margin,           ngeom,         1                    ) \
-    X   ( mjtNum,  geom_gap,              ngeom,         1                    ) \
-    X   ( mjtNum,  geom_fluid,            ngeom,         mjNFLUID             ) \
-    X   ( mjtNum,  geom_user,             ngeom,         MJ_M(nuser_geom)     ) \
-    XMJV( float,   geom_rgba,             ngeom,         4                    ) \
-    XMJV( int,     site_type,             nsite,         1                    ) \
-    XMJV( int,     site_bodyid,           nsite,         1                    ) \
-    XMJV( int,     site_matid,            nsite,         1                    ) \
-    XMJV( int,     site_group,            nsite,         1                    ) \
-    X   ( mjtByte, site_sameframe,        nsite,         1                    ) \
-    XMJV( mjtNum,  site_size,             nsite,         3                    ) \
-    X   ( mjtNum,  site_pos,              nsite,         3                    ) \
-    X   ( mjtNum,  site_quat,             nsite,         4                    ) \
-    X   ( mjtNum,  site_user,             nsite,         MJ_M(nuser_site)     ) \
-    XMJV( float,   site_rgba,             nsite,         4                    ) \
-    X   ( int,     cam_mode,              ncam,          1                    ) \
-    X   ( int,     cam_bodyid,            ncam,          1                    ) \
-    X   ( int,     cam_targetbodyid,      ncam,          1                    ) \
-    X   ( mjtNum,  cam_pos,               ncam,          3                    ) \
-    X   ( mjtNum,  cam_quat,              ncam,          4                    ) \
-    X   ( mjtNum,  cam_poscom0,           ncam,          3                    ) \
-    X   ( mjtNum,  cam_pos0,              ncam,          3                    ) \
-    X   ( mjtNum,  cam_mat0,              ncam,          9                    ) \
-    XMJV( mjtNum,  cam_fovy,              ncam,          1                    ) \
-    XMJV( mjtNum,  cam_ipd,               ncam,          1                    ) \
-    X   ( mjtNum,  cam_user,              ncam,          MJ_M(nuser_cam)      ) \
-    X   ( int,     light_mode,            nlight,        1                    ) \
-    X   ( int,     light_bodyid,          nlight,        1                    ) \
-    X   ( int,     light_targetbodyid,    nlight,        1                    ) \
-    XMJV( mjtByte, light_directional,     nlight,        1                    ) \
-    XMJV( mjtByte, light_castshadow,      nlight,        1                    ) \
-    XMJV( mjtByte, light_active,          nlight,        1                    ) \
-    X   ( mjtNum,  light_pos,             nlight,        3                    ) \
-    X   ( mjtNum,  light_dir,             nlight,        3                    ) \
-    X   ( mjtNum,  light_poscom0,         nlight,        3                    ) \
-    X   ( mjtNum,  light_pos0,            nlight,        3                    ) \
-    X   ( mjtNum,  light_dir0,            nlight,        3                    ) \
-    XMJV( float,   light_attenuation,     nlight,        3                    ) \
-    XMJV( float,   light_cutoff,          nlight,        1                    ) \
-    XMJV( float,   light_exponent,        nlight,        1                    ) \
-    XMJV( float,   light_ambient,         nlight,        3                    ) \
-    XMJV( float,   light_diffuse,         nlight,        3                    ) \
-    XMJV( float,   light_specular,        nlight,        3                    ) \
-    X   ( int,     mesh_vertadr,          nmesh,         1                    ) \
-    X   ( int,     mesh_vertnum,          nmesh,         1                    ) \
-    X   ( int,     mesh_normaladr,        nmesh,         1                    ) \
-    X   ( int,     mesh_normalnum,        nmesh,         1                    ) \
-    XMJV( int,     mesh_texcoordadr,      nmesh,         1                    ) \
-    X   ( int,     mesh_texcoordnum,      nmesh,         1                    ) \
-    X   ( int,     mesh_faceadr,          nmesh,         1                    ) \
-    X   ( int,     mesh_facenum,          nmesh,         1                    ) \
-    X   ( int,     mesh_bvhadr,           nmesh,         1                    ) \
-    X   ( int,     mesh_bvhnum,           nmesh,         1                    ) \
-    XMJV( int,     mesh_graphadr,         nmesh,         1                    ) \
-    X   ( float,   mesh_vert,             nmeshvert,     3                    ) \
-    X   ( float,   mesh_normal,           nmeshnormal,   3                    ) \
-    X   ( float,   mesh_texcoord,         nmeshtexcoord, 2                    ) \
-    X   ( int,     mesh_face,             nmeshface,     3                    ) \
-    X   ( int,     mesh_facenormal,       nmeshface,     3                    ) \
-    X   ( int,     mesh_facetexcoord,     nmeshface,     3                    ) \
-    X   ( int,     mesh_graph,            nmeshgraph,    1                    ) \
-    XMJV( int,     skin_matid,            nskin,         1                    ) \
-    XMJV( int,     skin_group,            nskin,         1                    ) \
-    XMJV( float,   skin_rgba,             nskin,         4                    ) \
-    XMJV( float,   skin_inflate,          nskin,         1                    ) \
-    XMJV( int,     skin_vertadr,          nskin,         1                    ) \
-    XMJV( int,     skin_vertnum,          nskin,         1                    ) \
-    XMJV( int,     skin_texcoordadr,      nskin,         1                    ) \
-    XMJV( int,     skin_faceadr,          nskin,         1                    ) \
-    XMJV( int,     skin_facenum,          nskin,         1                    ) \
-    XMJV( int,     skin_boneadr,          nskin,         1                    ) \
-    XMJV( int,     skin_bonenum,          nskin,         1                    ) \
-    XMJV( float,   skin_vert,             nskinvert,     3                    ) \
-    X   ( float,   skin_texcoord,         nskintexvert,  2                    ) \
-    XMJV( int,     skin_face,             nskinface,     3                    ) \
-    XMJV( int,     skin_bonevertadr,      nskinbone,     1                    ) \
-    XMJV( int,     skin_bonevertnum,      nskinbone,     1                    ) \
-    XMJV( float,   skin_bonebindpos,      nskinbone,     3                    ) \
-    XMJV( float,   skin_bonebindquat,     nskinbone,     4                    ) \
-    XMJV( int,     skin_bonebodyid,       nskinbone,     1                    ) \
-    XMJV( int,     skin_bonevertid,       nskinbonevert, 1                    ) \
-    XMJV( float,   skin_bonevertweight,   nskinbonevert, 1                    ) \
-    X   ( mjtNum,  hfield_size,           nhfield,       4                    ) \
-    X   ( int,     hfield_nrow,           nhfield,       1                    ) \
-    X   ( int,     hfield_ncol,           nhfield,       1                    ) \
-    X   ( int,     hfield_adr,            nhfield,       1                    ) \
-    X   ( float,   hfield_data,           nhfielddata,   1                    ) \
-    X   ( int,     tex_type,              ntex,          1                    ) \
-    X   ( int,     tex_height,            ntex,          1                    ) \
-    X   ( int,     tex_width,             ntex,          1                    ) \
-    X   ( int,     tex_adr,               ntex,          1                    ) \
-    X   ( mjtByte, tex_rgb,               ntexdata,      1                    ) \
-    XMJV( int,     mat_texid,             nmat,          1                    ) \
-    XMJV( mjtByte, mat_texuniform,        nmat,          1                    ) \
-    XMJV( float,   mat_texrepeat,         nmat,          2                    ) \
-    XMJV( float,   mat_emission,          nmat,          1                    ) \
-    XMJV( float,   mat_specular,          nmat,          1                    ) \
-    XMJV( float,   mat_shininess,         nmat,          1                    ) \
-    XMJV( float,   mat_reflectance,       nmat,          1                    ) \
-    XMJV( float,   mat_rgba,              nmat,          4                    ) \
-    X   ( int,     pair_dim,              npair,         1                    ) \
-    X   ( int,     pair_geom1,            npair,         1                    ) \
-    X   ( int,     pair_geom2,            npair,         1                    ) \
-    X   ( int,     pair_signature,        npair,         1                    ) \
-    X   ( mjtNum,  pair_solref,           npair,         mjNREF               ) \
-    X   ( mjtNum,  pair_solreffriction,   npair,         mjNREF               ) \
-    X   ( mjtNum,  pair_solimp,           npair,         mjNIMP               ) \
-    X   ( mjtNum,  pair_margin,           npair,         1                    ) \
-    X   ( mjtNum,  pair_gap,              npair,         1                    ) \
-    X   ( mjtNum,  pair_friction,         npair,         5                    ) \
-    X   ( int,     exclude_signature,     nexclude,      1                    ) \
-    XMJV( int,     eq_type,               neq,           1                    ) \
-    XMJV( int,     eq_obj1id,             neq,           1                    ) \
-    XMJV( int,     eq_obj2id,             neq,           1                    ) \
-    XMJV( mjtByte, eq_active,             neq,           1                    ) \
-    X   ( mjtNum,  eq_solref,             neq,           mjNREF               ) \
-    X   ( mjtNum,  eq_solimp,             neq,           mjNIMP               ) \
-    XMJV( mjtNum,  eq_data,               neq,           mjNEQDATA            ) \
-    X   ( int,     tendon_adr,            ntendon,       1                    ) \
-    XMJV( int,     tendon_num,            ntendon,       1                    ) \
-    XMJV( int,     tendon_matid,          ntendon,       1                    ) \
-    XMJV( int,     tendon_group,          ntendon,       1                    ) \
-    XMJV( mjtByte, tendon_limited,        ntendon,       1                    ) \
-    XMJV( mjtNum,  tendon_width,          ntendon,       1                    ) \
-    X   ( mjtNum,  tendon_solref_lim,     ntendon,       mjNREF               ) \
-    X   ( mjtNum,  tendon_solimp_lim,     ntendon,       mjNIMP               ) \
-    X   ( mjtNum,  tendon_solref_fri,     ntendon,       mjNREF               ) \
-    X   ( mjtNum,  tendon_solimp_fri,     ntendon,       mjNIMP               ) \
-    XMJV( mjtNum,  tendon_range,          ntendon,       2                    ) \
-    X   ( mjtNum,  tendon_margin,         ntendon,       1                    ) \
-    XMJV( mjtNum,  tendon_stiffness,      ntendon,       1                    ) \
-    XMJV( mjtNum,  tendon_damping,        ntendon,       1                    ) \
-    XMJV( mjtNum,  tendon_frictionloss,   ntendon,       1                    ) \
-    XMJV( mjtNum,  tendon_lengthspring,   ntendon,       2                    ) \
-    X   ( mjtNum,  tendon_length0,        ntendon,       1                    ) \
-    X   ( mjtNum,  tendon_invweight0,     ntendon,       1                    ) \
-    X   ( mjtNum,  tendon_user,           ntendon,       MJ_M(nuser_tendon)   ) \
-    XMJV( float,   tendon_rgba,           ntendon,       4                    ) \
-    X   ( int,     wrap_type,             nwrap,         1                    ) \
-    X   ( int,     wrap_objid,            nwrap,         1                    ) \
-    X   ( mjtNum,  wrap_prm,              nwrap,         1                    ) \
-    XMJV( int,     actuator_trntype,      nu,            1                    ) \
-    XMJV( int,     actuator_dyntype,      nu,            1                    ) \
-    X   ( int,     actuator_gaintype,     nu,            1                    ) \
-    X   ( int,     actuator_biastype,     nu,            1                    ) \
-    XMJV( int,     actuator_trnid,        nu,            2                    ) \
-    XMJV( int,     actuator_actadr,       nu,            1                    ) \
-    XMJV( int,     actuator_actnum,       nu,            1                    ) \
-    XMJV( int,     actuator_group,        nu,            1                    ) \
-    XMJV( mjtByte, actuator_ctrllimited,  nu,            1                    ) \
-    X   ( mjtByte, actuator_forcelimited, nu,            1                    ) \
-    XMJV( mjtByte, actuator_actlimited,   nu,            1                    ) \
-    X   ( mjtNum,  actuator_dynprm,       nu,            mjNDYN               ) \
-    X   ( mjtNum,  actuator_gainprm,      nu,            mjNGAIN              ) \
-    X   ( mjtNum,  actuator_biasprm,      nu,            mjNBIAS              ) \
-    X   ( mjtByte, actuator_actearly,     nu,            1                    ) \
-    XMJV( mjtNum,  actuator_ctrlrange,    nu,            2                    ) \
-    X   ( mjtNum,  actuator_forcerange,   nu,            2                    ) \
-    XMJV( mjtNum,  actuator_actrange,     nu,            2                    ) \
-    X   ( mjtNum,  actuator_gear,         nu,            6                    ) \
-    XMJV( mjtNum,  actuator_cranklength,  nu,            1                    ) \
-    X   ( mjtNum,  actuator_acc0,         nu,            1                    ) \
-    X   ( mjtNum,  actuator_length0,      nu,            1                    ) \
-    X   ( mjtNum,  actuator_lengthrange,  nu,            2                    ) \
-    X   ( mjtNum,  actuator_user,         nu,            MJ_M(nuser_actuator) ) \
-    X   ( int,     actuator_plugin,       nu,            1                    ) \
-    XMJV( int,     sensor_type,           nsensor,       1                    ) \
-    X   ( int,     sensor_datatype,       nsensor,       1                    ) \
-    X   ( int,     sensor_needstage,      nsensor,       1                    ) \
-    X   ( int,     sensor_objtype,        nsensor,       1                    ) \
-    XMJV( int,     sensor_objid,          nsensor,       1                    ) \
-    X   ( int,     sensor_reftype,        nsensor,       1                    ) \
-    X   ( int,     sensor_refid,          nsensor,       1                    ) \
-    X   ( int,     sensor_dim,            nsensor,       1                    ) \
-    XMJV( int,     sensor_adr,            nsensor,       1                    ) \
-    X   ( mjtNum,  sensor_cutoff,         nsensor,       1                    ) \
-    X   ( mjtNum,  sensor_noise,          nsensor,       1                    ) \
-    X   ( mjtNum,  sensor_user,           nsensor,       MJ_M(nuser_sensor)   ) \
-    X   ( int,     sensor_plugin,         nsensor,       1                    ) \
-    X   ( int,     plugin,                nplugin,       1                    ) \
-    X   ( int,     plugin_stateadr,       nplugin,       1                    ) \
-    X   ( int,     plugin_statenum,       nplugin,       1                    ) \
-    X   ( char,    plugin_attr,           npluginattr,   1                    ) \
-    X   ( int,     plugin_attradr,        nplugin,       1                    ) \
-    X   ( int,     numeric_adr,           nnumeric,      1                    ) \
-    X   ( int,     numeric_size,          nnumeric,      1                    ) \
-    X   ( mjtNum,  numeric_data,          nnumericdata,  1                    ) \
-    X   ( int,     text_adr,              ntext,         1                    ) \
-    X   ( int,     text_size,             ntext,         1                    ) \
-    X   ( char,    text_data,             ntextdata,     1                    ) \
-    X   ( int,     tuple_adr,             ntuple,        1                    ) \
-    X   ( int,     tuple_size,            ntuple,        1                    ) \
-    X   ( int,     tuple_objtype,         ntupledata,    1                    ) \
-    X   ( int,     tuple_objid,           ntupledata,    1                    ) \
-    X   ( mjtNum,  tuple_objprm,          ntupledata,    1                    ) \
-    X   ( mjtNum,  key_time,              nkey,          1                    ) \
-    X   ( mjtNum,  key_qpos,              nkey,          MJ_M(nq)             ) \
-    X   ( mjtNum,  key_qvel,              nkey,          MJ_M(nv)             ) \
-    X   ( mjtNum,  key_act,               nkey,          MJ_M(na)             ) \
-    X   ( mjtNum,  key_mpos,              nkey,          MJ_M(nmocap)*3       ) \
-    X   ( mjtNum,  key_mquat,             nkey,          MJ_M(nmocap)*4       ) \
-    X   ( mjtNum,  key_ctrl,              nkey,          MJ_M(nu)             ) \
-    XMJV( int,     name_bodyadr,          nbody,         1                    ) \
-    XMJV( int,     name_jntadr,           njnt,          1                    ) \
-    XMJV( int,     name_geomadr,          ngeom,         1                    ) \
-    XMJV( int,     name_siteadr,          nsite,         1                    ) \
-    XMJV( int,     name_camadr,           ncam,          1                    ) \
-    XMJV( int,     name_lightadr,         nlight,        1                    ) \
-    X   ( int,     name_meshadr,          nmesh,         1                    ) \
-    X   ( int,     name_skinadr,          nskin,         1                    ) \
-    X   ( int,     name_hfieldadr,        nhfield,       1                    ) \
-    X   ( int,     name_texadr,           ntex,          1                    ) \
-    X   ( int,     name_matadr,           nmat,          1                    ) \
-    X   ( int,     name_pairadr,          npair,         1                    ) \
-    X   ( int,     name_excludeadr,       nexclude,      1                    ) \
-    XMJV( int,     name_eqadr,            neq,           1                    ) \
-    XMJV( int,     name_tendonadr,        ntendon,       1                    ) \
-    XMJV( int,     name_actuatoradr,      nu,            1                    ) \
-    X   ( int,     name_sensoradr,        nsensor,       1                    ) \
-    X   ( int,     name_numericadr,       nnumeric,      1                    ) \
-    X   ( int,     name_textadr,          ntext,         1                    ) \
-    X   ( int,     name_tupleadr,         ntuple,        1                    ) \
-    X   ( int,     name_keyadr,           nkey,          1                    ) \
-    X   ( int,     name_pluginadr,        nplugin,       1                    ) \
-    XMJV( char,    names,                 nnames,        1                    ) \
-    X   ( int,     names_map,             nnames_map,    1                    ) \
-
-//-------------------------------- mjData ----------------------------------------------------------
-
-// define symbols needed in MJDATA_POINTERS (corresponding to number of columns)
-#define MJDATA_POINTERS_PREAMBLE( m ) \
-    int nv = m->nv;
-
-
-// pointer fields of mjData
-// XMJV means that the field is required to construct mjvScene
-// (by default we define XMJV to be the same as X)
-#define MJDATA_POINTERS                                            \
-    X   ( mjtNum,    qpos,              nq,          1           ) \
-    X   ( mjtNum,    qvel,              nv,          1           ) \
-    XMJV( mjtNum,    act,               na,          1           ) \
-    X   ( mjtNum,    qacc_warmstart,    nv,          1           ) \
-    X   ( mjtNum,    plugin_state,      npluginstate, 1          ) \
-    XMJV( mjtNum,    ctrl,              nu,          1           ) \
-    X   ( mjtNum,    qfrc_applied,      nv,          1           ) \
-    XMJV( mjtNum,    xfrc_applied,      nbody,       6           ) \
-    X   ( mjtNum,    mocap_pos,         nmocap,      3           ) \
-    X   ( mjtNum,    mocap_quat,        nmocap,      4           ) \
-    X   ( mjtNum,    qacc,              nv,          1           ) \
-    X   ( mjtNum,    act_dot,           na,          1           ) \
-    X   ( mjtNum,    userdata,          nuserdata,   1           ) \
-    XMJV( mjtNum,    sensordata,        nsensordata, 1           ) \
-    X   ( int,       plugin,            nplugin,     1           ) \
-    X   ( uintptr_t, plugin_data,       nplugin,     1           ) \
-    XMJV( mjtNum,    xpos,              nbody,       3           ) \
-    XMJV( mjtNum,    xquat,             nbody,       4           ) \
-    XMJV( mjtNum,    xmat,              nbody,       9           ) \
-    XMJV( mjtNum,    xipos,             nbody,       3           ) \
-    XMJV( mjtNum,    ximat,             nbody,       9           ) \
-    XMJV( mjtNum,    xanchor,           njnt,        3           ) \
-    XMJV( mjtNum,    xaxis,             njnt,        3           ) \
-    XMJV( mjtNum,    geom_xpos,         ngeom,       3           ) \
-    XMJV( mjtNum,    geom_xmat,         ngeom,       9           ) \
-    XMJV( mjtNum,    site_xpos,         nsite,       3           ) \
-    XMJV( mjtNum,    site_xmat,         nsite,       9           ) \
-    XMJV( mjtNum,    cam_xpos,          ncam,        3           ) \
-    XMJV( mjtNum,    cam_xmat,          ncam,        9           ) \
-    XMJV( mjtNum,    light_xpos,        nlight,      3           ) \
-    XMJV( mjtNum,    light_xdir,        nlight,      3           ) \
-    XMJV( mjtNum,    subtree_com,       nbody,       3           ) \
-    X   ( mjtNum,    cdof,              nv,          6           ) \
-    X   ( mjtNum,    cinert,            nbody,       10          ) \
-    XMJV( int,       ten_wrapadr,       ntendon,     1           ) \
-    XMJV( int,       ten_wrapnum,       ntendon,     1           ) \
-    X   ( int,       ten_J_rownnz,      ntendon,     1           ) \
-    X   ( int,       ten_J_rowadr,      ntendon,     1           ) \
-    X   ( int,       ten_J_colind,      ntendon,     MJ_M(nv)    ) \
-    X   ( mjtNum,    ten_length,        ntendon,     1           ) \
-    X   ( mjtNum,    ten_J,             ntendon,     MJ_M(nv)    ) \
-    XMJV( int,       wrap_obj,          nwrap,       2           ) \
-    XMJV( mjtNum,    wrap_xpos,         nwrap,       6           ) \
-    X   ( mjtNum,    actuator_length,   nu,          1           ) \
-    X   ( mjtNum,    actuator_moment,   nu,          MJ_M(nv)    ) \
-    X   ( mjtNum,    crb,               nbody,       10          ) \
-    X   ( mjtNum,    qM,                nM,          1           ) \
-    X   ( mjtNum,    qLD,               nM,          1           ) \
-    X   ( mjtNum,    qLDiagInv,         nv,          1           ) \
-    X   ( mjtNum,    qLDiagSqrtInv,     nv,          1           ) \
-    XMJV( mjtByte,   bvh_active,        nbvh,        1           ) \
-    X   ( mjtNum,    ten_velocity,      ntendon,     1           ) \
-    X   ( mjtNum,    actuator_velocity, nu,          1           ) \
-    X   ( mjtNum,    cvel,              nbody,       6           ) \
-    X   ( mjtNum,    cdof_dot,          nv,          6           ) \
-    X   ( mjtNum,    qfrc_bias,         nv,          1           ) \
-    X   ( mjtNum,    qfrc_passive,      nv,          1           ) \
-    X   ( mjtNum,    subtree_linvel,    nbody,       3           ) \
-    X   ( mjtNum,    subtree_angmom,    nbody,       3           ) \
-    X   ( mjtNum,    qH,                nM,          1           ) \
-    X   ( mjtNum,    qHDiagInv,         nv,          1           ) \
-    X   ( int,       D_rownnz,          nv,          1           ) \
-    X   ( int,       D_rowadr,          nv,          1           ) \
-    X   ( int,       D_colind,          nD,          1           ) \
-    X   ( int,       B_rownnz,          nbody,       1           ) \
-    X   ( int,       B_rowadr,          nbody,       1           ) \
-    X   ( int,       B_colind,          nB,          1           ) \
-    X   ( mjtNum,    qDeriv,            nD,          1           ) \
-    X   ( mjtNum,    qLU,               nD,          1           ) \
-    X   ( mjtNum,    actuator_force,    nu,          1           ) \
-    X   ( mjtNum,    qfrc_actuator,     nv,          1           ) \
-    X   ( mjtNum,    qfrc_smooth,       nv,          1           ) \
-    X   ( mjtNum,    qacc_smooth,       nv,          1           ) \
-    X   ( mjtNum,    qfrc_constraint,   nv,          1           ) \
-    X   ( mjtNum,    qfrc_inverse,      nv,          1           ) \
-    X   ( mjtNum,    cacc,              nbody,       6           ) \
-    X   ( mjtNum,    cfrc_int,          nbody,       6           ) \
-    X   ( mjtNum,    cfrc_ext,          nbody,       6           )
-
-
-// macro for annotating that an array size in an X macro is a member of mjData
-// by default this macro does nothing, but users can redefine it as necessary
-#define MJ_D(n) n
-
-// array of contacts
-#define MJDATA_ARENA_POINTERS_CONTACT      \
-    X( mjContact, contact, MJ_D(ncon), 1 )
-
-// array fields of mjData that are used in the primal problem
-#define MJDATA_ARENA_POINTERS_PRIMAL              \
-  X(int,      efc_type,          MJ_D(nefc),  1)  \
-  X(int,      efc_id,            MJ_D(nefc),  1)  \
-  X(int,      efc_J_rownnz,      MJ_D(nefc),  1)  \
-  X(int,      efc_J_rowadr,      MJ_D(nefc),  1)  \
-  X(int,      efc_J_rowsuper,    MJ_D(nefc),  1)  \
-  X(int,      efc_J_colind,      MJ_D(nnzJ),  1)  \
-  X(int,      efc_JT_rownnz,     MJ_M(nv),    1)  \
-  X(int,      efc_JT_rowadr,     MJ_M(nv),    1)  \
-  X(int,      efc_JT_rowsuper,   MJ_M(nv),    1)  \
-  X(int,      efc_JT_colind,     MJ_D(nnzJ),  1)  \
-  X(mjtNum,   efc_J,             MJ_D(nnzJ),  1)  \
-  X(mjtNum,   efc_JT,            MJ_D(nnzJ),  1)  \
-  X(mjtNum,   efc_pos,           MJ_D(nefc),  1)  \
-  X(mjtNum,   efc_margin,        MJ_D(nefc),  1)  \
-  X(mjtNum,   efc_frictionloss,  MJ_D(nefc),  1)  \
-  X(mjtNum,   efc_diagApprox,    MJ_D(nefc),  1)  \
-  X(mjtNum,   efc_KBIP,          MJ_D(nefc),  4)  \
-  X(mjtNum,   efc_D,             MJ_D(nefc),  1)  \
-  X(mjtNum,   efc_R,             MJ_D(nefc),  1)  \
-  X(mjtNum,   efc_vel,           MJ_D(nefc),  1)  \
-  X(mjtNum,   efc_aref,          MJ_D(nefc),  1)  \
-  X(mjtNum,   efc_b,             MJ_D(nefc),  1)  \
-  X(mjtNum,   efc_force,         MJ_D(nefc),  1)  \
-  X(int,      efc_state,         MJ_D(nefc),  1)
-
-// array fields of mjData that are used in the dual problem
-#define MJDATA_ARENA_POINTERS_DUAL                            \
-    X( int,       efc_AR_rownnz,     MJ_D(nefc), 1          ) \
-    X( int,       efc_AR_rowadr,     MJ_D(nefc), 1          ) \
-    X( int,       efc_AR_colind,     MJ_D(nefc), MJ_D(nefc) ) \
-    X( mjtNum,    efc_AR,            MJ_D(nefc), MJ_D(nefc) )
-
-// array fields of mjData that live in d->arena
-#define MJDATA_ARENA_POINTERS              \
-    MJDATA_ARENA_POINTERS_CONTACT          \
-    MJDATA_ARENA_POINTERS_PRIMAL           \
-    MJDATA_ARENA_POINTERS_DUAL
-
-
-// scalar fields of mjData
-#define MJDATA_SCALAR                  \
-    X( int,       nstack             ) \
-    X( int,       nbuffer            ) \
-    X( int,       nplugin            ) \
-    X( int,       pstack             ) \
-    X( int,       parena             ) \
-    X( int,       maxuse_stack       ) \
-    X( int,       maxuse_arena       ) \
-    X( int,       maxuse_con         ) \
-    X( int,       maxuse_efc         ) \
-    X( int,       solver_iter        ) \
-    X( int,       solver_nnz         ) \
-    X( int,       nbodypair_broad    ) \
-    X( int,       nbodypair_narrow   ) \
-    X( int,       ngeompair_mid      ) \
-    X( int,       ngeompair_narrow   ) \
-    X( int,       ne                 ) \
-    X( int,       nf                 ) \
-    X( int,       nefc               ) \
-    X( int,       nnzJ               ) \
-    X( int,       ncon               ) \
-    X( mjtNum,    time               )
-
-
-// vector fields of mjData
-#define MJDATA_VECTOR                                   \
-    X( mjWarningStat,  warning,        mjNWARNING,  1 ) \
-    X( mjTimerStat,    timer,          mjNTIMER,    1 ) \
-    X( mjSolverStat,   solver,         mjNSOLVER,   1 ) \
-    X( mjtNum,         solver_fwdinv,  2,           1 ) \
-    X( mjtNum,         energy,         2,           1 )
-
-
-// alias XMJV to be the same as X
-// to obtain only X macros for fields that are relevant for mjvScene creation,
-// redefine X to expand to nothing, and XMJV to do what's required
-#define XMJV X
-
-#endif  // MUJOCO_MJXMACRO_H_
+// Copyright 2021 DeepMind Technologies Limited
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef MUJOCO_MJXMACRO_H_
+#define MUJOCO_MJXMACRO_H_
+
+
+//-------------------------------- mjOption --------------------------------------------------------
+
+// scalar fields of mjOption
+#define MJOPTION_FLOATS             \
+    X( mjtNum,  timestep         )  \
+    X( mjtNum,  apirate          )  \
+    X( mjtNum,  impratio         )  \
+    X( mjtNum,  tolerance        )  \
+    X( mjtNum,  noslip_tolerance )  \
+    X( mjtNum,  mpr_tolerance    )  \
+    X( mjtNum,  density          )  \
+    X( mjtNum,  viscosity        )  \
+    X( mjtNum,  o_margin         )  \
+
+
+#define MJOPTION_INTS               \
+    X( int,     integrator        ) \
+    X( int,     collision         ) \
+    X( int,     cone              ) \
+    X( int,     jacobian          ) \
+    X( int,     solver            ) \
+    X( int,     iterations        ) \
+    X( int,     noslip_iterations ) \
+    X( int,     mpr_iterations    ) \
+    X( int,     disableflags      ) \
+    X( int,     enableflags       )
+
+
+#define MJOPTION_SCALARS            \
+    MJOPTION_FLOATS                 \
+    MJOPTION_INTS
+
+
+// vector fields of mjOption
+#define MJOPTION_VECTORS            \
+    X( gravity,         3       )   \
+    X( wind,            3       )   \
+    X( magnetic,        3       )   \
+    X( o_solref,        mjNREF  )   \
+    X( o_solimp,        mjNIMP  )
+
+
+//-------------------------------- mjModel ---------------------------------------------------------
+
+// int fields of mjModel
+#define MJMODEL_INTS        \
+    X   ( nq )                 \
+    X   ( nv )                 \
+    XMJV( nu )                 \
+    XMJV( na )                 \
+    XMJV( nbody )              \
+    XMJV( nbvh )               \
+    XMJV( njnt )               \
+    XMJV( ngeom )              \
+    XMJV( nsite )              \
+    XMJV( ncam )               \
+    XMJV( nlight )             \
+    XMJV( nmesh )              \
+    X   ( nmeshvert )          \
+    X   ( nmeshnormal )        \
+    X   ( nmeshtexcoord )      \
+    X   ( nmeshface )          \
+    X   ( nmeshgraph )         \
+    XMJV( nskin )              \
+    XMJV( nskinvert )          \
+    X   ( nskintexvert )       \
+    XMJV( nskinface )          \
+    XMJV( nskinbone )          \
+    XMJV( nskinbonevert )      \
+    X   ( nhfield )            \
+    X   ( nhfielddata )        \
+    X   ( ntex )               \
+    X   ( ntexdata )           \
+    XMJV( nmat )               \
+    X   ( npair )              \
+    X   ( nexclude )           \
+    XMJV( neq )                \
+    XMJV( ntendon )            \
+    XMJV( nwrap )              \
+    XMJV( nsensor )            \
+    X   ( nnumeric )           \
+    X   ( nnumericdata )       \
+    X   ( ntext )              \
+    X   ( ntextdata )          \
+    X   ( ntuple )             \
+    X   ( ntupledata )         \
+    X   ( nkey )               \
+    X   ( nmocap )             \
+    X   ( nplugin )            \
+    X   ( npluginattr )        \
+    X   ( nuser_body )         \
+    X   ( nuser_jnt )          \
+    X   ( nuser_geom )         \
+    X   ( nuser_site )         \
+    X   ( nuser_cam )          \
+    X   ( nuser_tendon )       \
+    X   ( nuser_actuator )     \
+    X   ( nuser_sensor )       \
+    XMJV( nnames )             \
+    X   ( nnames_map )         \
+    X   ( nM )                 \
+    X   ( nD )                 \
+    X   ( nB )                 \
+    X   ( nemax )              \
+    X   ( njmax )              \
+    X   ( nconmax )            \
+    X   ( nstack )             \
+    X   ( nuserdata )          \
+    XMJV( nsensordata )        \
+    X   ( npluginstate )       \
+    X   ( nbuffer )
+
+
+// define symbols needed in MJMODEL_POINTERS (corresponding to number of columns)
+#define MJMODEL_POINTERS_PREAMBLE( m )      \
+    int nuser_body = m->nuser_body;         \
+    int nuser_jnt = m->nuser_jnt;           \
+    int nuser_geom = m->nuser_geom;         \
+    int nuser_site = m->nuser_site;         \
+    int nuser_cam = m->nuser_cam;           \
+    int nuser_tendon = m->nuser_tendon;     \
+    int nuser_actuator = m->nuser_actuator; \
+    int nuser_sensor = m->nuser_sensor;     \
+    int nq = m->nq;                         \
+    int nv = m->nv;                         \
+    int na = m->na;                         \
+    int nu = m->nu;                         \
+    int nmocap = m->nmocap;
+
+// macro for annotating that an array size in an X macro is a member of mjModel
+// by default this macro does nothing, but users can redefine it as necessary
+#define MJ_M(n) n
+
+
+// pointer fields of mjModel
+// XMJV means that the field is required to construct mjvScene
+// (by default we define XMJV to be the same as X)
+#define MJMODEL_POINTERS                                                     \
+    X   ( mjtNum,  qpos0,                 nq,            1                    ) \
+    X   ( mjtNum,  qpos_spring,           nq,            1                    ) \
+    XMJV( int,     body_parentid,         nbody,         1                    ) \
+    XMJV( int,     body_rootid,           nbody,         1                    ) \
+    XMJV( int,     body_weldid,           nbody,         1                    ) \
+    XMJV( int,     body_mocapid,          nbody,         1                    ) \
+    XMJV( int,     body_jntnum,           nbody,         1                    ) \
+    XMJV( int,     body_jntadr,           nbody,         1                    ) \
+    X   ( int,     body_dofnum,           nbody,         1                    ) \
+    X   ( int,     body_dofadr,           nbody,         1                    ) \
+    XMJV( int,     body_geomnum,          nbody,         1                    ) \
+    XMJV( int,     body_geomadr,          nbody,         1                    ) \
+    X   ( mjtByte, body_simple,           nbody,         1                    ) \
+    X   ( mjtByte, body_sameframe,        nbody,         1                    ) \
+    X   ( mjtNum,  body_pos,              nbody,         3                    ) \
+    X   ( mjtNum,  body_quat,             nbody,         4                    ) \
+    X   ( mjtNum,  body_ipos,             nbody,         3                    ) \
+    XMJV( mjtNum,  body_iquat,            nbody,         4                    ) \
+    XMJV( mjtNum,  body_mass,             nbody,         1                    ) \
+    X   ( mjtNum,  body_subtreemass,      nbody,         1                    ) \
+    XMJV( mjtNum,  body_inertia,          nbody,         3                    ) \
+    X   ( mjtNum,  body_invweight0,       nbody,         2                    ) \
+    X   ( mjtNum,  body_gravcomp,         nbody,         1                    ) \
+    X   ( mjtNum,  body_user,             nbody,         MJ_M(nuser_body)     ) \
+    X   ( int,     body_plugin,           nbody,         1                    ) \
+    XMJV( int,     body_bvhadr,           nbody,         1                    ) \
+    XMJV( int,     body_bvhnum,           nbody,         1                    ) \
+    XMJV( int,     bvh_depth,             nbvh,          1                    ) \
+    XMJV( int,     bvh_child,             nbvh,          2                    ) \
+    XMJV( int,     bvh_geomid,            nbvh,          1                    ) \
+    XMJV( mjtNum,  bvh_aabb,              nbvh,          6                    ) \
+    XMJV( int,     jnt_type,              njnt,          1                    ) \
+    X   ( int,     jnt_qposadr,           njnt,          1                    ) \
+    X   ( int,     jnt_dofadr,            njnt,          1                    ) \
+    XMJV( int,     jnt_bodyid,            njnt,          1                    ) \
+    XMJV( int,     jnt_group,             njnt,          1                    ) \
+    X   ( mjtByte, jnt_limited,           njnt,          1                    ) \
+    X   ( mjtByte, jnt_actfrclimited,     njnt,          1                    ) \
+    X   ( mjtNum,  jnt_solref,            njnt,          mjNREF               ) \
+    X   ( mjtNum,  jnt_solimp,            njnt,          mjNIMP               ) \
+    X   ( mjtNum,  jnt_pos,               njnt,          3                    ) \
+    X   ( mjtNum,  jnt_axis,              njnt,          3                    ) \
+    X   ( mjtNum,  jnt_stiffness,         njnt,          1                    ) \
+    X   ( mjtNum,  jnt_range,             njnt,          2                    ) \
+    X   ( mjtNum,  jnt_actfrcrange,       njnt,          2                    ) \
+    X   ( mjtNum,  jnt_margin,            njnt,          1                    ) \
+    X   ( mjtNum,  jnt_user,              njnt,          MJ_M(nuser_jnt)      ) \
+    X   ( int,     dof_bodyid,            nv,            1                    ) \
+    X   ( int,     dof_jntid,             nv,            1                    ) \
+    X   ( int,     dof_parentid,          nv,            1                    ) \
+    X   ( int,     dof_Madr,              nv,            1                    ) \
+    X   ( int,     dof_simplenum,         nv,            1                    ) \
+    X   ( mjtNum,  dof_solref,            nv,            mjNREF               ) \
+    X   ( mjtNum,  dof_solimp,            nv,            mjNIMP               ) \
+    X   ( mjtNum,  dof_frictionloss,      nv,            1                    ) \
+    X   ( mjtNum,  dof_armature,          nv,            1                    ) \
+    X   ( mjtNum,  dof_damping,           nv,            1                    ) \
+    X   ( mjtNum,  dof_invweight0,        nv,            1                    ) \
+    X   ( mjtNum,  dof_M0,                nv,            1                    ) \
+    XMJV( int,     geom_type,             ngeom,         1                    ) \
+    X   ( int,     geom_contype,          ngeom,         1                    ) \
+    X   ( int,     geom_conaffinity,      ngeom,         1                    ) \
+    X   ( int,     geom_condim,           ngeom,         1                    ) \
+    XMJV( int,     geom_bodyid,           ngeom,         1                    ) \
+    XMJV( int,     geom_dataid,           ngeom,         1                    ) \
+    XMJV( int,     geom_matid,            ngeom,         1                    ) \
+    XMJV( int,     geom_group,            ngeom,         1                    ) \
+    X   ( int,     geom_priority,         ngeom,         1                    ) \
+    X   ( mjtByte, geom_sameframe,        ngeom,         1                    ) \
+    X   ( mjtNum,  geom_solmix,           ngeom,         1                    ) \
+    X   ( mjtNum,  geom_solref,           ngeom,         mjNREF               ) \
+    X   ( mjtNum,  geom_solimp,           ngeom,         mjNIMP               ) \
+    XMJV( mjtNum,  geom_size,             ngeom,         3                    ) \
+    XMJV( mjtNum,  geom_aabb,             ngeom,         6                    ) \
+    XMJV( mjtNum,  geom_rbound,           ngeom,         1                    ) \
+    X   ( mjtNum,  geom_pos,              ngeom,         3                    ) \
+    X   ( mjtNum,  geom_quat,             ngeom,         4                    ) \
+    X   ( mjtNum,  geom_friction,         ngeom,         3                    ) \
+    X   ( mjtNum,  geom_margin,           ngeom,         1                    ) \
+    X   ( mjtNum,  geom_gap,              ngeom,         1                    ) \
+    X   ( mjtNum,  geom_fluid,            ngeom,         mjNFLUID             ) \
+    X   ( mjtNum,  geom_user,             ngeom,         MJ_M(nuser_geom)     ) \
+    XMJV( float,   geom_rgba,             ngeom,         4                    ) \
+    XMJV( int,     site_type,             nsite,         1                    ) \
+    XMJV( int,     site_bodyid,           nsite,         1                    ) \
+    XMJV( int,     site_matid,            nsite,         1                    ) \
+    XMJV( int,     site_group,            nsite,         1                    ) \
+    X   ( mjtByte, site_sameframe,        nsite,         1                    ) \
+    XMJV( mjtNum,  site_size,             nsite,         3                    ) \
+    X   ( mjtNum,  site_pos,              nsite,         3                    ) \
+    X   ( mjtNum,  site_quat,             nsite,         4                    ) \
+    X   ( mjtNum,  site_user,             nsite,         MJ_M(nuser_site)     ) \
+    XMJV( float,   site_rgba,             nsite,         4                    ) \
+    X   ( int,     cam_mode,              ncam,          1                    ) \
+    X   ( int,     cam_bodyid,            ncam,          1                    ) \
+    X   ( int,     cam_targetbodyid,      ncam,          1                    ) \
+    X   ( mjtNum,  cam_pos,               ncam,          3                    ) \
+    X   ( mjtNum,  cam_quat,              ncam,          4                    ) \
+    X   ( mjtNum,  cam_poscom0,           ncam,          3                    ) \
+    X   ( mjtNum,  cam_pos0,              ncam,          3                    ) \
+    X   ( mjtNum,  cam_mat0,              ncam,          9                    ) \
+    XMJV( mjtNum,  cam_fovy,              ncam,          1                    ) \
+    XMJV( mjtNum,  cam_ipd,               ncam,          1                    ) \
+    X   ( mjtNum,  cam_user,              ncam,          MJ_M(nuser_cam)      ) \
+    X   ( int,     light_mode,            nlight,        1                    ) \
+    X   ( int,     light_bodyid,          nlight,        1                    ) \
+    X   ( int,     light_targetbodyid,    nlight,        1                    ) \
+    XMJV( mjtByte, light_directional,     nlight,        1                    ) \
+    XMJV( mjtByte, light_castshadow,      nlight,        1                    ) \
+    XMJV( mjtByte, light_active,          nlight,        1                    ) \
+    X   ( mjtNum,  light_pos,             nlight,        3                    ) \
+    X   ( mjtNum,  light_dir,             nlight,        3                    ) \
+    X   ( mjtNum,  light_poscom0,         nlight,        3                    ) \
+    X   ( mjtNum,  light_pos0,            nlight,        3                    ) \
+    X   ( mjtNum,  light_dir0,            nlight,        3                    ) \
+    XMJV( float,   light_attenuation,     nlight,        3                    ) \
+    XMJV( float,   light_cutoff,          nlight,        1                    ) \
+    XMJV( float,   light_exponent,        nlight,        1                    ) \
+    XMJV( float,   light_ambient,         nlight,        3                    ) \
+    XMJV( float,   light_diffuse,         nlight,        3                    ) \
+    XMJV( float,   light_specular,        nlight,        3                    ) \
+    X   ( int,     mesh_vertadr,          nmesh,         1                    ) \
+    X   ( int,     mesh_vertnum,          nmesh,         1                    ) \
+    X   ( int,     mesh_normaladr,        nmesh,         1                    ) \
+    X   ( int,     mesh_normalnum,        nmesh,         1                    ) \
+    XMJV( int,     mesh_texcoordadr,      nmesh,         1                    ) \
+    X   ( int,     mesh_texcoordnum,      nmesh,         1                    ) \
+    X   ( int,     mesh_faceadr,          nmesh,         1                    ) \
+    X   ( int,     mesh_facenum,          nmesh,         1                    ) \
+    X   ( int,     mesh_bvhadr,           nmesh,         1                    ) \
+    X   ( int,     mesh_bvhnum,           nmesh,         1                    ) \
+    XMJV( int,     mesh_graphadr,         nmesh,         1                    ) \
+    X   ( float,   mesh_vert,             nmeshvert,     3                    ) \
+    X   ( float,   mesh_normal,           nmeshnormal,   3                    ) \
+    X   ( float,   mesh_texcoord,         nmeshtexcoord, 2                    ) \
+    X   ( int,     mesh_face,             nmeshface,     3                    ) \
+    X   ( int,     mesh_facenormal,       nmeshface,     3                    ) \
+    X   ( int,     mesh_facetexcoord,     nmeshface,     3                    ) \
+    X   ( int,     mesh_graph,            nmeshgraph,    1                    ) \
+    XMJV( int,     skin_matid,            nskin,         1                    ) \
+    XMJV( int,     skin_group,            nskin,         1                    ) \
+    XMJV( float,   skin_rgba,             nskin,         4                    ) \
+    XMJV( float,   skin_inflate,          nskin,         1                    ) \
+    XMJV( int,     skin_vertadr,          nskin,         1                    ) \
+    XMJV( int,     skin_vertnum,          nskin,         1                    ) \
+    XMJV( int,     skin_texcoordadr,      nskin,         1                    ) \
+    XMJV( int,     skin_faceadr,          nskin,         1                    ) \
+    XMJV( int,     skin_facenum,          nskin,         1                    ) \
+    XMJV( int,     skin_boneadr,          nskin,         1                    ) \
+    XMJV( int,     skin_bonenum,          nskin,         1                    ) \
+    XMJV( float,   skin_vert,             nskinvert,     3                    ) \
+    X   ( float,   skin_texcoord,         nskintexvert,  2                    ) \
+    XMJV( int,     skin_face,             nskinface,     3                    ) \
+    XMJV( int,     skin_bonevertadr,      nskinbone,     1                    ) \
+    XMJV( int,     skin_bonevertnum,      nskinbone,     1                    ) \
+    XMJV( float,   skin_bonebindpos,      nskinbone,     3                    ) \
+    XMJV( float,   skin_bonebindquat,     nskinbone,     4                    ) \
+    XMJV( int,     skin_bonebodyid,       nskinbone,     1                    ) \
+    XMJV( int,     skin_bonevertid,       nskinbonevert, 1                    ) \
+    XMJV( float,   skin_bonevertweight,   nskinbonevert, 1                    ) \
+    X   ( mjtNum,  hfield_size,           nhfield,       4                    ) \
+    X   ( int,     hfield_nrow,           nhfield,       1                    ) \
+    X   ( int,     hfield_ncol,           nhfield,       1                    ) \
+    X   ( int,     hfield_adr,            nhfield,       1                    ) \
+    X   ( float,   hfield_data,           nhfielddata,   1                    ) \
+    X   ( int,     tex_type,              ntex,          1                    ) \
+    X   ( int,     tex_height,            ntex,          1                    ) \
+    X   ( int,     tex_width,             ntex,          1                    ) \
+    X   ( int,     tex_adr,               ntex,          1                    ) \
+    X   ( mjtByte, tex_rgb,               ntexdata,      1                    ) \
+    XMJV( int,     mat_texid,             nmat,          1                    ) \
+    XMJV( mjtByte, mat_texuniform,        nmat,          1                    ) \
+    XMJV( float,   mat_texrepeat,         nmat,          2                    ) \
+    XMJV( float,   mat_emission,          nmat,          1                    ) \
+    XMJV( float,   mat_specular,          nmat,          1                    ) \
+    XMJV( float,   mat_shininess,         nmat,          1                    ) \
+    XMJV( float,   mat_reflectance,       nmat,          1                    ) \
+    XMJV( float,   mat_rgba,              nmat,          4                    ) \
+    X   ( int,     pair_dim,              npair,         1                    ) \
+    X   ( int,     pair_geom1,            npair,         1                    ) \
+    X   ( int,     pair_geom2,            npair,         1                    ) \
+    X   ( int,     pair_signature,        npair,         1                    ) \
+    X   ( mjtNum,  pair_solref,           npair,         mjNREF               ) \
+    X   ( mjtNum,  pair_solreffriction,   npair,         mjNREF               ) \
+    X   ( mjtNum,  pair_solimp,           npair,         mjNIMP               ) \
+    X   ( mjtNum,  pair_margin,           npair,         1                    ) \
+    X   ( mjtNum,  pair_gap,              npair,         1                    ) \
+    X   ( mjtNum,  pair_friction,         npair,         5                    ) \
+    X   ( int,     exclude_signature,     nexclude,      1                    ) \
+    XMJV( int,     eq_type,               neq,           1                    ) \
+    XMJV( int,     eq_obj1id,             neq,           1                    ) \
+    XMJV( int,     eq_obj2id,             neq,           1                    ) \
+    XMJV( mjtByte, eq_active,             neq,           1                    ) \
+    X   ( mjtNum,  eq_solref,             neq,           mjNREF               ) \
+    X   ( mjtNum,  eq_solimp,             neq,           mjNIMP               ) \
+    XMJV( mjtNum,  eq_data,               neq,           mjNEQDATA            ) \
+    X   ( int,     tendon_adr,            ntendon,       1                    ) \
+    XMJV( int,     tendon_num,            ntendon,       1                    ) \
+    XMJV( int,     tendon_matid,          ntendon,       1                    ) \
+    XMJV( int,     tendon_group,          ntendon,       1                    ) \
+    XMJV( mjtByte, tendon_limited,        ntendon,       1                    ) \
+    XMJV( mjtNum,  tendon_width,          ntendon,       1                    ) \
+    X   ( mjtNum,  tendon_solref_lim,     ntendon,       mjNREF               ) \
+    X   ( mjtNum,  tendon_solimp_lim,     ntendon,       mjNIMP               ) \
+    X   ( mjtNum,  tendon_solref_fri,     ntendon,       mjNREF               ) \
+    X   ( mjtNum,  tendon_solimp_fri,     ntendon,       mjNIMP               ) \
+    XMJV( mjtNum,  tendon_range,          ntendon,       2                    ) \
+    X   ( mjtNum,  tendon_margin,         ntendon,       1                    ) \
+    XMJV( mjtNum,  tendon_stiffness,      ntendon,       1                    ) \
+    XMJV( mjtNum,  tendon_damping,        ntendon,       1                    ) \
+    XMJV( mjtNum,  tendon_frictionloss,   ntendon,       1                    ) \
+    XMJV( mjtNum,  tendon_lengthspring,   ntendon,       2                    ) \
+    X   ( mjtNum,  tendon_length0,        ntendon,       1                    ) \
+    X   ( mjtNum,  tendon_invweight0,     ntendon,       1                    ) \
+    X   ( mjtNum,  tendon_user,           ntendon,       MJ_M(nuser_tendon)   ) \
+    XMJV( float,   tendon_rgba,           ntendon,       4                    ) \
+    X   ( int,     wrap_type,             nwrap,         1                    ) \
+    X   ( int,     wrap_objid,            nwrap,         1                    ) \
+    X   ( mjtNum,  wrap_prm,              nwrap,         1                    ) \
+    XMJV( int,     actuator_trntype,      nu,            1                    ) \
+    XMJV( int,     actuator_dyntype,      nu,            1                    ) \
+    X   ( int,     actuator_gaintype,     nu,            1                    ) \
+    X   ( int,     actuator_biastype,     nu,            1                    ) \
+    XMJV( int,     actuator_trnid,        nu,            2                    ) \
+    XMJV( int,     actuator_actadr,       nu,            1                    ) \
+    XMJV( int,     actuator_actnum,       nu,            1                    ) \
+    XMJV( int,     actuator_group,        nu,            1                    ) \
+    XMJV( mjtByte, actuator_ctrllimited,  nu,            1                    ) \
+    X   ( mjtByte, actuator_forcelimited, nu,            1                    ) \
+    XMJV( mjtByte, actuator_actlimited,   nu,            1                    ) \
+    X   ( mjtNum,  actuator_dynprm,       nu,            mjNDYN               ) \
+    X   ( mjtNum,  actuator_gainprm,      nu,            mjNGAIN              ) \
+    X   ( mjtNum,  actuator_biasprm,      nu,            mjNBIAS              ) \
+    X   ( mjtByte, actuator_actearly,     nu,            1                    ) \
+    XMJV( mjtNum,  actuator_ctrlrange,    nu,            2                    ) \
+    X   ( mjtNum,  actuator_forcerange,   nu,            2                    ) \
+    XMJV( mjtNum,  actuator_actrange,     nu,            2                    ) \
+    X   ( mjtNum,  actuator_gear,         nu,            6                    ) \
+    XMJV( mjtNum,  actuator_cranklength,  nu,            1                    ) \
+    X   ( mjtNum,  actuator_acc0,         nu,            1                    ) \
+    X   ( mjtNum,  actuator_length0,      nu,            1                    ) \
+    X   ( mjtNum,  actuator_lengthrange,  nu,            2                    ) \
+    X   ( mjtNum,  actuator_user,         nu,            MJ_M(nuser_actuator) ) \
+    X   ( int,     actuator_plugin,       nu,            1                    ) \
+    XMJV( int,     sensor_type,           nsensor,       1                    ) \
+    X   ( int,     sensor_datatype,       nsensor,       1                    ) \
+    X   ( int,     sensor_needstage,      nsensor,       1                    ) \
+    X   ( int,     sensor_objtype,        nsensor,       1                    ) \
+    XMJV( int,     sensor_objid,          nsensor,       1                    ) \
+    X   ( int,     sensor_reftype,        nsensor,       1                    ) \
+    X   ( int,     sensor_refid,          nsensor,       1                    ) \
+    X   ( int,     sensor_dim,            nsensor,       1                    ) \
+    XMJV( int,     sensor_adr,            nsensor,       1                    ) \
+    X   ( mjtNum,  sensor_cutoff,         nsensor,       1                    ) \
+    X   ( mjtNum,  sensor_noise,          nsensor,       1                    ) \
+    X   ( mjtNum,  sensor_user,           nsensor,       MJ_M(nuser_sensor)   ) \
+    X   ( int,     sensor_plugin,         nsensor,       1                    ) \
+    X   ( int,     plugin,                nplugin,       1                    ) \
+    X   ( int,     plugin_stateadr,       nplugin,       1                    ) \
+    X   ( int,     plugin_statenum,       nplugin,       1                    ) \
+    X   ( char,    plugin_attr,           npluginattr,   1                    ) \
+    X   ( int,     plugin_attradr,        nplugin,       1                    ) \
+    X   ( int,     numeric_adr,           nnumeric,      1                    ) \
+    X   ( int,     numeric_size,          nnumeric,      1                    ) \
+    X   ( mjtNum,  numeric_data,          nnumericdata,  1                    ) \
+    X   ( int,     text_adr,              ntext,         1                    ) \
+    X   ( int,     text_size,             ntext,         1                    ) \
+    X   ( char,    text_data,             ntextdata,     1                    ) \
+    X   ( int,     tuple_adr,             ntuple,        1                    ) \
+    X   ( int,     tuple_size,            ntuple,        1                    ) \
+    X   ( int,     tuple_objtype,         ntupledata,    1                    ) \
+    X   ( int,     tuple_objid,           ntupledata,    1                    ) \
+    X   ( mjtNum,  tuple_objprm,          ntupledata,    1                    ) \
+    X   ( mjtNum,  key_time,              nkey,          1                    ) \
+    X   ( mjtNum,  key_qpos,              nkey,          MJ_M(nq)             ) \
+    X   ( mjtNum,  key_qvel,              nkey,          MJ_M(nv)             ) \
+    X   ( mjtNum,  key_act,               nkey,          MJ_M(na)             ) \
+    X   ( mjtNum,  key_mpos,              nkey,          MJ_M(nmocap)*3       ) \
+    X   ( mjtNum,  key_mquat,             nkey,          MJ_M(nmocap)*4       ) \
+    X   ( mjtNum,  key_ctrl,              nkey,          MJ_M(nu)             ) \
+    XMJV( int,     name_bodyadr,          nbody,         1                    ) \
+    XMJV( int,     name_jntadr,           njnt,          1                    ) \
+    XMJV( int,     name_geomadr,          ngeom,         1                    ) \
+    XMJV( int,     name_siteadr,          nsite,         1                    ) \
+    XMJV( int,     name_camadr,           ncam,          1                    ) \
+    XMJV( int,     name_lightadr,         nlight,        1                    ) \
+    X   ( int,     name_meshadr,          nmesh,         1                    ) \
+    X   ( int,     name_skinadr,          nskin,         1                    ) \
+    X   ( int,     name_hfieldadr,        nhfield,       1                    ) \
+    X   ( int,     name_texadr,           ntex,          1                    ) \
+    X   ( int,     name_matadr,           nmat,          1                    ) \
+    X   ( int,     name_pairadr,          npair,         1                    ) \
+    X   ( int,     name_excludeadr,       nexclude,      1                    ) \
+    XMJV( int,     name_eqadr,            neq,           1                    ) \
+    XMJV( int,     name_tendonadr,        ntendon,       1                    ) \
+    XMJV( int,     name_actuatoradr,      nu,            1                    ) \
+    X   ( int,     name_sensoradr,        nsensor,       1                    ) \
+    X   ( int,     name_numericadr,       nnumeric,      1                    ) \
+    X   ( int,     name_textadr,          ntext,         1                    ) \
+    X   ( int,     name_tupleadr,         ntuple,        1                    ) \
+    X   ( int,     name_keyadr,           nkey,          1                    ) \
+    X   ( int,     name_pluginadr,        nplugin,       1                    ) \
+    XMJV( char,    names,                 nnames,        1                    ) \
+    X   ( int,     names_map,             nnames_map,    1                    ) \
+
+//-------------------------------- mjData ----------------------------------------------------------
+
+// define symbols needed in MJDATA_POINTERS (corresponding to number of columns)
+#define MJDATA_POINTERS_PREAMBLE( m ) \
+    int nv = m->nv;
+
+
+// pointer fields of mjData
+// XMJV means that the field is required to construct mjvScene
+// (by default we define XMJV to be the same as X)
+#define MJDATA_POINTERS                                            \
+    X   ( mjtNum,    qpos,              nq,          1           ) \
+    X   ( mjtNum,    qvel,              nv,          1           ) \
+    XMJV( mjtNum,    act,               na,          1           ) \
+    X   ( mjtNum,    qacc_warmstart,    nv,          1           ) \
+    X   ( mjtNum,    plugin_state,      npluginstate, 1          ) \
+    XMJV( mjtNum,    ctrl,              nu,          1           ) \
+    X   ( mjtNum,    qfrc_applied,      nv,          1           ) \
+    XMJV( mjtNum,    xfrc_applied,      nbody,       6           ) \
+    X   ( mjtNum,    mocap_pos,         nmocap,      3           ) \
+    X   ( mjtNum,    mocap_quat,        nmocap,      4           ) \
+    X   ( mjtNum,    qacc,              nv,          1           ) \
+    X   ( mjtNum,    act_dot,           na,          1           ) \
+    X   ( mjtNum,    userdata,          nuserdata,   1           ) \
+    XMJV( mjtNum,    sensordata,        nsensordata, 1           ) \
+    X   ( int,       plugin,            nplugin,     1           ) \
+    X   ( uintptr_t, plugin_data,       nplugin,     1           ) \
+    XMJV( mjtNum,    xpos,              nbody,       3           ) \
+    XMJV( mjtNum,    xquat,             nbody,       4           ) \
+    XMJV( mjtNum,    xmat,              nbody,       9           ) \
+    XMJV( mjtNum,    xipos,             nbody,       3           ) \
+    XMJV( mjtNum,    ximat,             nbody,       9           ) \
+    XMJV( mjtNum,    xanchor,           njnt,        3           ) \
+    XMJV( mjtNum,    xaxis,             njnt,        3           ) \
+    XMJV( mjtNum,    geom_xpos,         ngeom,       3           ) \
+    XMJV( mjtNum,    geom_xmat,         ngeom,       9           ) \
+    XMJV( mjtNum,    site_xpos,         nsite,       3           ) \
+    XMJV( mjtNum,    site_xmat,         nsite,       9           ) \
+    XMJV( mjtNum,    cam_xpos,          ncam,        3           ) \
+    XMJV( mjtNum,    cam_xmat,          ncam,        9           ) \
+    XMJV( mjtNum,    light_xpos,        nlight,      3           ) \
+    XMJV( mjtNum,    light_xdir,        nlight,      3           ) \
+    XMJV( mjtNum,    subtree_com,       nbody,       3           ) \
+    X   ( mjtNum,    cdof,              nv,          6           ) \
+    X   ( mjtNum,    cinert,            nbody,       10          ) \
+    XMJV( int,       ten_wrapadr,       ntendon,     1           ) \
+    XMJV( int,       ten_wrapnum,       ntendon,     1           ) \
+    X   ( int,       ten_J_rownnz,      ntendon,     1           ) \
+    X   ( int,       ten_J_rowadr,      ntendon,     1           ) \
+    X   ( int,       ten_J_colind,      ntendon,     MJ_M(nv)    ) \
+    X   ( mjtNum,    ten_length,        ntendon,     1           ) \
+    X   ( mjtNum,    ten_J,             ntendon,     MJ_M(nv)    ) \
+    XMJV( int,       wrap_obj,          nwrap,       2           ) \
+    XMJV( mjtNum,    wrap_xpos,         nwrap,       6           ) \
+    X   ( mjtNum,    actuator_length,   nu,          1           ) \
+    X   ( mjtNum,    actuator_moment,   nu,          MJ_M(nv)    ) \
+    X   ( mjtNum,    crb,               nbody,       10          ) \
+    X   ( mjtNum,    qM,                nM,          1           ) \
+    X   ( mjtNum,    qLD,               nM,          1           ) \
+    X   ( mjtNum,    qLDiagInv,         nv,          1           ) \
+    X   ( mjtNum,    qLDiagSqrtInv,     nv,          1           ) \
+    XMJV( mjtByte,   bvh_active,        nbvh,        1           ) \
+    X   ( mjtNum,    ten_velocity,      ntendon,     1           ) \
+    X   ( mjtNum,    actuator_velocity, nu,          1           ) \
+    X   ( mjtNum,    cvel,              nbody,       6           ) \
+    X   ( mjtNum,    cdof_dot,          nv,          6           ) \
+    X   ( mjtNum,    qfrc_bias,         nv,          1           ) \
+    X   ( mjtNum,    qfrc_passive,      nv,          1           ) \
+    X   ( mjtNum,    subtree_linvel,    nbody,       3           ) \
+    X   ( mjtNum,    subtree_angmom,    nbody,       3           ) \
+    X   ( mjtNum,    qH,                nM,          1           ) \
+    X   ( mjtNum,    qHDiagInv,         nv,          1           ) \
+    X   ( int,       D_rownnz,          nv,          1           ) \
+    X   ( int,       D_rowadr,          nv,          1           ) \
+    X   ( int,       D_colind,          nD,          1           ) \
+    X   ( int,       B_rownnz,          nbody,       1           ) \
+    X   ( int,       B_rowadr,          nbody,       1           ) \
+    X   ( int,       B_colind,          nB,          1           ) \
+    X   ( mjtNum,    qDeriv,            nD,          1           ) \
+    X   ( mjtNum,    qLU,               nD,          1           ) \
+    X   ( mjtNum,    actuator_force,    nu,          1           ) \
+    X   ( mjtNum,    qfrc_actuator,     nv,          1           ) \
+    X   ( mjtNum,    qfrc_smooth,       nv,          1           ) \
+    X   ( mjtNum,    qacc_smooth,       nv,          1           ) \
+    X   ( mjtNum,    qfrc_constraint,   nv,          1           ) \
+    X   ( mjtNum,    qfrc_inverse,      nv,          1           ) \
+    X   ( mjtNum,    cacc,              nbody,       6           ) \
+    X   ( mjtNum,    cfrc_int,          nbody,       6           ) \
+    X   ( mjtNum,    cfrc_ext,          nbody,       6           )
+
+
+// macro for annotating that an array size in an X macro is a member of mjData
+// by default this macro does nothing, but users can redefine it as necessary
+#define MJ_D(n) n
+
+// array of contacts
+#define MJDATA_ARENA_POINTERS_CONTACT      \
+    X( mjContact, contact, MJ_D(ncon), 1 )
+
+// array fields of mjData that are used in the primal problem
+#define MJDATA_ARENA_POINTERS_PRIMAL              \
+  X(int,      efc_type,          MJ_D(nefc),  1)  \
+  X(int,      efc_id,            MJ_D(nefc),  1)  \
+  X(int,      efc_J_rownnz,      MJ_D(nefc),  1)  \
+  X(int,      efc_J_rowadr,      MJ_D(nefc),  1)  \
+  X(int,      efc_J_rowsuper,    MJ_D(nefc),  1)  \
+  X(int,      efc_J_colind,      MJ_D(nnzJ),  1)  \
+  X(int,      efc_JT_rownnz,     MJ_M(nv),    1)  \
+  X(int,      efc_JT_rowadr,     MJ_M(nv),    1)  \
+  X(int,      efc_JT_rowsuper,   MJ_M(nv),    1)  \
+  X(int,      efc_JT_colind,     MJ_D(nnzJ),  1)  \
+  X(mjtNum,   efc_J,             MJ_D(nnzJ),  1)  \
+  X(mjtNum,   efc_JT,            MJ_D(nnzJ),  1)  \
+  X(mjtNum,   efc_pos,           MJ_D(nefc),  1)  \
+  X(mjtNum,   efc_margin,        MJ_D(nefc),  1)  \
+  X(mjtNum,   efc_frictionloss,  MJ_D(nefc),  1)  \
+  X(mjtNum,   efc_diagApprox,    MJ_D(nefc),  1)  \
+  X(mjtNum,   efc_KBIP,          MJ_D(nefc),  4)  \
+  X(mjtNum,   efc_D,             MJ_D(nefc),  1)  \
+  X(mjtNum,   efc_R,             MJ_D(nefc),  1)  \
+  X(mjtNum,   efc_vel,           MJ_D(nefc),  1)  \
+  X(mjtNum,   efc_aref,          MJ_D(nefc),  1)  \
+  X(mjtNum,   efc_b,             MJ_D(nefc),  1)  \
+  X(mjtNum,   efc_force,         MJ_D(nefc),  1)  \
+  X(int,      efc_state,         MJ_D(nefc),  1)
+
+// array fields of mjData that are used in the dual problem
+#define MJDATA_ARENA_POINTERS_DUAL                            \
+    X( int,       efc_AR_rownnz,     MJ_D(nefc), 1          ) \
+    X( int,       efc_AR_rowadr,     MJ_D(nefc), 1          ) \
+    X( int,       efc_AR_colind,     MJ_D(nefc), MJ_D(nefc) ) \
+    X( mjtNum,    efc_AR,            MJ_D(nefc), MJ_D(nefc) )
+
+// array fields of mjData that live in d->arena
+#define MJDATA_ARENA_POINTERS              \
+    MJDATA_ARENA_POINTERS_CONTACT          \
+    MJDATA_ARENA_POINTERS_PRIMAL           \
+    MJDATA_ARENA_POINTERS_DUAL
+
+
+// scalar fields of mjData
+#define MJDATA_SCALAR                  \
+    X( int,       nstack             ) \
+    X( int,       nbuffer            ) \
+    X( int,       nplugin            ) \
+    X( int,       pstack             ) \
+    X( int,       parena             ) \
+    X( int,       maxuse_stack       ) \
+    X( int,       maxuse_arena       ) \
+    X( int,       maxuse_con         ) \
+    X( int,       maxuse_efc         ) \
+    X( int,       solver_iter        ) \
+    X( int,       solver_nnz         ) \
+    X( int,       nbodypair_broad    ) \
+    X( int,       nbodypair_narrow   ) \
+    X( int,       ngeompair_mid      ) \
+    X( int,       ngeompair_narrow   ) \
+    X( int,       ne                 ) \
+    X( int,       nf                 ) \
+    X( int,       nefc               ) \
+    X( int,       nnzJ               ) \
+    X( int,       ncon               ) \
+    X( mjtNum,    time               )
+
+
+// vector fields of mjData
+#define MJDATA_VECTOR                                   \
+    X( mjWarningStat,  warning,        mjNWARNING,  1 ) \
+    X( mjTimerStat,    timer,          mjNTIMER,    1 ) \
+    X( mjSolverStat,   solver,         mjNSOLVER,   1 ) \
+    X( mjtNum,         solver_fwdinv,  2,           1 ) \
+    X( mjtNum,         energy,         2,           1 )
+
+
+// alias XMJV to be the same as X
+// to obtain only X macros for fields that are relevant for mjvScene creation,
+// redefine X to expand to nothing, and XMJV to do what's required
+#define XMJV X
+
+#endif  // MUJOCO_MJXMACRO_H_
```

## mujoco/include/mujoco/mujoco.h

 * *Ordering differences only*

```diff
@@ -1,1302 +1,1302 @@
-// Copyright 2021 DeepMind Technologies Limited
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#ifndef MUJOCO_MUJOCO_H_
-#define MUJOCO_MUJOCO_H_
-
-#include <mujoco/mjexport.h>
-
-
-// this is a C-API
-#if defined(__cplusplus)
-extern "C" {
-#endif
-
-// header version; should match the library version as returned by mj_version()
-#define mjVERSION_HEADER 238
-
-// needed to define size_t, fabs and log10
-#include <stdlib.h>
-#include <math.h>
-
-#ifdef ADDRESS_SANITIZER
-#include <sanitizer/asan_interface.h>
-#endif
-
-// type definitions
-#include <mujoco/mjdata.h>
-#include <mujoco/mjmodel.h>
-#include <mujoco/mjmacro.h>
-#include <mujoco/mjplugin.h>
-#include <mujoco/mjrender.h>
-#include <mujoco/mjtnum.h>
-#include <mujoco/mjui.h>
-#include <mujoco/mjvisualize.h>
-
-
-// user error and memory handlers
-MJAPI extern void  (*mju_user_error)(const char*);
-MJAPI extern void  (*mju_user_warning)(const char*);
-MJAPI extern void* (*mju_user_malloc)(size_t);
-MJAPI extern void  (*mju_user_free)(void*);
-
-
-// callbacks extending computation pipeline
-MJAPI extern mjfGeneric  mjcb_passive;
-MJAPI extern mjfGeneric  mjcb_control;
-MJAPI extern mjfConFilt  mjcb_contactfilter;
-MJAPI extern mjfSensor   mjcb_sensor;
-MJAPI extern mjfTime     mjcb_time;
-MJAPI extern mjfAct      mjcb_act_dyn;
-MJAPI extern mjfAct      mjcb_act_gain;
-MJAPI extern mjfAct      mjcb_act_bias;
-
-
-// collision function table
-MJAPI extern mjfCollision mjCOLLISIONFUNC[mjNGEOMTYPES][mjNGEOMTYPES];
-
-
-// string names
-MJAPI extern const char* mjDISABLESTRING[mjNDISABLE];
-MJAPI extern const char* mjENABLESTRING[mjNENABLE];
-MJAPI extern const char* mjTIMERSTRING[mjNTIMER];
-MJAPI extern const char* mjLABELSTRING[mjNLABEL];
-MJAPI extern const char* mjFRAMESTRING[mjNFRAME];
-MJAPI extern const char* mjVISSTRING[mjNVISFLAG][3];
-MJAPI extern const char* mjRNDSTRING[mjNRNDFLAG][3];
-
-
-//---------------------------------- Virtual file system -------------------------------------------
-
-// Initialize VFS to empty (no deallocation).
-MJAPI void mj_defaultVFS(mjVFS* vfs);
-
-// Add file to VFS, return 0: success, 1: full, 2: repeated name, -1: failed to load.
-MJAPI int mj_addFileVFS(mjVFS* vfs, const char* directory, const char* filename);
-
-// Make empty file in VFS, return 0: success, 1: full, 2: repeated name.
-MJAPI int mj_makeEmptyFileVFS(mjVFS* vfs, const char* filename, int filesize);
-
-// Return file index in VFS, or -1 if not found in VFS.
-MJAPI int mj_findFileVFS(const mjVFS* vfs, const char* filename);
-
-// Delete file from VFS, return 0: success, -1: not found in VFS.
-MJAPI int mj_deleteFileVFS(mjVFS* vfs, const char* filename);
-
-// Delete all files from VFS.
-MJAPI void mj_deleteVFS(mjVFS* vfs);
-
-
-//---------------------------------- Parse and compile ---------------------------------------------
-
-// Parse XML file in MJCF or URDF format, compile it, return low-level model.
-// If vfs is not NULL, look up files in vfs before reading from disk.
-// If error is not NULL, it must have size error_sz.
-MJAPI mjModel* mj_loadXML(const char* filename, const mjVFS* vfs, char* error, int error_sz);
-
-// Update XML data structures with info from low-level model, save as MJCF.
-// If error is not NULL, it must have size error_sz.
-MJAPI int mj_saveLastXML(const char* filename, const mjModel* m, char* error, int error_sz);
-
-// Free last XML model if loaded. Called internally at each load.
-MJAPI void mj_freeLastXML(void);
-
-// Print internal XML schema as plain text or HTML, with style-padding or &nbsp;.
-MJAPI int mj_printSchema(const char* filename, char* buffer, int buffer_sz,
-                         int flg_html, int flg_pad);
-
-
-//---------------------------------- Main simulation -----------------------------------------------
-
-// Advance simulation, use control callback to obtain external force and control.
-MJAPI void mj_step(const mjModel* m, mjData* d);
-
-// Advance simulation in two steps: before external force and control is set by user.
-MJAPI void mj_step1(const mjModel* m, mjData* d);
-
-// Advance simulation in two steps: after external force and control is set by user.
-MJAPI void mj_step2(const mjModel* m, mjData* d);
-
-// Forward dynamics: same as mj_step but do not integrate in time.
-MJAPI void mj_forward(const mjModel* m, mjData* d);
-
-// Inverse dynamics: qacc must be set before calling.
-MJAPI void mj_inverse(const mjModel* m, mjData* d);
-
-// Forward dynamics with skip; skipstage is mjtStage.
-MJAPI void mj_forwardSkip(const mjModel* m, mjData* d, int skipstage, int skipsensor);
-
-// Inverse dynamics with skip; skipstage is mjtStage.
-MJAPI void mj_inverseSkip(const mjModel* m, mjData* d, int skipstage, int skipsensor);
-
-
-//---------------------------------- Initialization ------------------------------------------------
-
-// Set default options for length range computation.
-MJAPI void mj_defaultLROpt(mjLROpt* opt);
-
-// Set solver parameters to default values.
-MJAPI void mj_defaultSolRefImp(mjtNum* solref, mjtNum* solimp);
-
-// Set physics options to default values.
-MJAPI void mj_defaultOption(mjOption* opt);
-
-// Set visual options to default values.
-MJAPI void mj_defaultVisual(mjVisual* vis);
-
-// Copy mjModel, allocate new if dest is NULL.
-MJAPI mjModel* mj_copyModel(mjModel* dest, const mjModel* src);
-
-// Save model to binary MJB file or memory buffer; buffer has precedence when given.
-MJAPI void mj_saveModel(const mjModel* m, const char* filename, void* buffer, int buffer_sz);
-
-// Load model from binary MJB file.
-// If vfs is not NULL, look up file in vfs before reading from disk.
-MJAPI mjModel* mj_loadModel(const char* filename, const mjVFS* vfs);
-
-// Free memory allocation in model.
-MJAPI void mj_deleteModel(mjModel* m);
-
-// Return size of buffer needed to hold model.
-MJAPI int mj_sizeModel(const mjModel* m);
-
-// Allocate mjData corresponding to given model.
-// If the model buffer is unallocated the initial configuration will not be set.
-MJAPI mjData* mj_makeData(const mjModel* m);
-
-// Copy mjData.
-// m is only required to contain the size fields from MJMODEL_INTS.
-MJAPI mjData* mj_copyData(mjData* dest, const mjModel* m, const mjData* src);
-
-// Reset data to defaults.
-MJAPI void mj_resetData(const mjModel* m, mjData* d);
-
-// Reset data to defaults, fill everything else with debug_value.
-MJAPI void mj_resetDataDebug(const mjModel* m, mjData* d, unsigned char debug_value);
-
-// Reset data, set fields from specified keyframe.
-MJAPI void mj_resetDataKeyframe(const mjModel* m, mjData* d, int key);
-
-// Allocate array of mjtNums on mjData stack. Call mju_error on stack overflow.
-MJAPI mjtNum* mj_stackAlloc(mjData* d, int size);
-
-// Allocate array of ints on mjData stack. Call mju_error on stack overflow.
-MJAPI int* mj_stackAllocInt(mjData* d, int size);
-
-// Free memory allocation in mjData.
-MJAPI void mj_deleteData(mjData* d);
-
-// Reset all callbacks to NULL pointers (NULL is the default).
-MJAPI void mj_resetCallbacks(void);
-
-// Set constant fields of mjModel, corresponding to qpos0 configuration.
-MJAPI void mj_setConst(mjModel* m, mjData* d);
-
-// Set actuator_lengthrange for specified actuator; return 1 if ok, 0 if error.
-MJAPI int mj_setLengthRange(mjModel* m, mjData* d, int index,
-                            const mjLROpt* opt, char* error, int error_sz);
-
-
-//---------------------------------- Printing ------------------------------------------------------
-
-// Print mjModel to text file, specifying format.
-// float_format must be a valid printf-style format string for a single float value.
-MJAPI void mj_printFormattedModel(const mjModel* m, const char* filename, const char* float_format);
-
-// Print model to text file.
-MJAPI void mj_printModel(const mjModel* m, const char* filename);
-
-// Print mjData to text file, specifying format.
-// float_format must be a valid printf-style format string for a single float value
-MJAPI void mj_printFormattedData(const mjModel* m, mjData* d, const char* filename,
-                                 const char* float_format);
-
-// Print data to text file.
-MJAPI void mj_printData(const mjModel* m, mjData* d, const char* filename);
-
-// Print matrix to screen.
-MJAPI void mju_printMat(const mjtNum* mat, int nr, int nc);
-
-// Print sparse matrix to screen.
-MJAPI void mju_printMatSparse(const mjtNum* mat, int nr,
-                              const int* rownnz, const int* rowadr, const int* colind);
-
-
-//---------------------------------- Components ----------------------------------------------------
-
-// Run position-dependent computations.
-MJAPI void mj_fwdPosition(const mjModel* m, mjData* d);
-
-// Run velocity-dependent computations.
-MJAPI void mj_fwdVelocity(const mjModel* m, mjData* d);
-
-// Compute actuator force qfrc_actuator.
-MJAPI void mj_fwdActuation(const mjModel* m, mjData* d);
-
-// Add up all non-constraint forces, compute qacc_smooth.
-MJAPI void mj_fwdAcceleration(const mjModel* m, mjData* d);
-
-// Run selected constraint solver.
-MJAPI void mj_fwdConstraint(const mjModel* m, mjData* d);
-
-// Euler integrator, semi-implicit in velocity.
-MJAPI void mj_Euler(const mjModel* m, mjData* d);
-
-// Runge-Kutta explicit order-N integrator.
-MJAPI void mj_RungeKutta(const mjModel* m, mjData* d, int N);
-
-// Run position-dependent computations in inverse dynamics.
-MJAPI void mj_invPosition(const mjModel* m, mjData* d);
-
-// Run velocity-dependent computations in inverse dynamics.
-MJAPI void mj_invVelocity(const mjModel* m, mjData* d);
-
-// Apply the analytical formula for inverse constraint dynamics.
-MJAPI void mj_invConstraint(const mjModel* m, mjData* d);
-
-// Compare forward and inverse dynamics, save results in fwdinv.
-MJAPI void mj_compareFwdInv(const mjModel* m, mjData* d);
-
-
-//---------------------------------- Sub components ------------------------------------------------
-
-// Evaluate position-dependent sensors.
-MJAPI void mj_sensorPos(const mjModel* m, mjData* d);
-
-// Evaluate velocity-dependent sensors.
-MJAPI void mj_sensorVel(const mjModel* m, mjData* d);
-
-// Evaluate acceleration and force-dependent sensors.
-MJAPI void mj_sensorAcc(const mjModel* m, mjData* d);
-
-// Evaluate position-dependent energy (potential).
-MJAPI void mj_energyPos(const mjModel* m, mjData* d);
-
-// Evaluate velocity-dependent energy (kinetic).
-MJAPI void mj_energyVel(const mjModel* m, mjData* d);
-
-// Check qpos, reset if any element is too big or nan.
-MJAPI void mj_checkPos(const mjModel* m, mjData* d);
-
-// Check qvel, reset if any element is too big or nan.
-MJAPI void mj_checkVel(const mjModel* m, mjData* d);
-
-// Check qacc, reset if any element is too big or nan.
-MJAPI void mj_checkAcc(const mjModel* m, mjData* d);
-
-// Run forward kinematics.
-MJAPI void mj_kinematics(const mjModel* m, mjData* d);
-
-// Map inertias and motion dofs to global frame centered at CoM.
-MJAPI void mj_comPos(const mjModel* m, mjData* d);
-
-// Compute camera and light positions and orientations.
-MJAPI void mj_camlight(const mjModel* m, mjData* d);
-
-// Compute tendon lengths, velocities and moment arms.
-MJAPI void mj_tendon(const mjModel* m, mjData* d);
-
-// Compute actuator transmission lengths and moments.
-MJAPI void mj_transmission(const mjModel* m, mjData* d);
-
-// Run composite rigid body inertia algorithm (CRB).
-MJAPI void mj_crb(const mjModel* m, mjData* d);
-
-// Compute sparse L'*D*L factorizaton of inertia matrix.
-MJAPI void mj_factorM(const mjModel* m, mjData* d);
-
-// Solve linear system M * x = y using factorization:  x = inv(L'*D*L)*y
-MJAPI void mj_solveM(const mjModel* m, mjData* d, mjtNum* x, const mjtNum* y, int n);
-
-// Half of linear solve:  x = sqrt(inv(D))*inv(L')*y
-MJAPI void mj_solveM2(const mjModel* m, mjData* d, mjtNum* x, const mjtNum* y, int n);
-
-// Compute cvel, cdof_dot.
-MJAPI void mj_comVel(const mjModel* m, mjData* d);
-
-// Compute qfrc_passive from spring-dampers, viscosity and density.
-MJAPI void mj_passive(const mjModel* m, mjData* d);
-
-// subtree linear velocity and angular momentum
-MJAPI void mj_subtreeVel(const mjModel* m, mjData* d);
-
-// RNE: compute M(qpos)*qacc + C(qpos,qvel); flg_acc=0 removes inertial term.
-MJAPI void mj_rne(const mjModel* m, mjData* d, int flg_acc, mjtNum* result);
-
-// RNE with complete data: compute cacc, cfrc_ext, cfrc_int.
-MJAPI void mj_rnePostConstraint(const mjModel* m, mjData* d);
-
-// Run collision detection.
-MJAPI void mj_collision(const mjModel* m, mjData* d);
-
-// Construct constraints.
-MJAPI void mj_makeConstraint(const mjModel* m, mjData* d);
-
-// Compute inverse constraint inertia efc_AR.
-MJAPI void mj_projectConstraint(const mjModel* m, mjData* d);
-
-// Compute efc_vel, efc_aref.
-MJAPI void mj_referenceConstraint(const mjModel* m, mjData* d);
-
-// Compute efc_state, efc_force, qfrc_constraint, and (optionally) cone Hessians.
-// If cost is not NULL, set *cost = s(jar) where jar = Jac*qacc-aref.
-MJAPI void mj_constraintUpdate(const mjModel* m, mjData* d, const mjtNum* jar,
-                               mjtNum cost[1], int flg_coneHessian);
-
-
-//---------------------------------- Support -------------------------------------------------------
-
-// Return size of state specification.
-MJAPI int mj_stateSize(const mjModel* m, unsigned int spec);
-
-// Get state.
-MJAPI void mj_getState(const mjModel* m, const mjData* d, mjtNum* state, unsigned int spec);
-
-// Set state.
-MJAPI void mj_setState(const mjModel* m, mjData* d, const mjtNum* state, unsigned int spec);
-
-// Add contact to d->contact list; return 0 if success; 1 if buffer full.
-MJAPI int mj_addContact(const mjModel* m, mjData* d, const mjContact* con);
-
-// Determine type of friction cone.
-MJAPI int mj_isPyramidal(const mjModel* m);
-
-// Determine type of constraint Jacobian.
-MJAPI int mj_isSparse(const mjModel* m);
-
-// Determine type of solver (PGS is dual, CG and Newton are primal).
-MJAPI int mj_isDual(const mjModel* m);
-
-// Multiply dense or sparse constraint Jacobian by vector.
-MJAPI void mj_mulJacVec(const mjModel* m, mjData* d, mjtNum* res, const mjtNum* vec);
-
-// Multiply dense or sparse constraint Jacobian transpose by vector.
-MJAPI void mj_mulJacTVec(const mjModel* m, mjData* d, mjtNum* res, const mjtNum* vec);
-
-// Compute 3/6-by-nv end-effector Jacobian of global point attached to given body.
-MJAPI void mj_jac(const mjModel* m, const mjData* d, mjtNum* jacp, mjtNum* jacr,
-                  const mjtNum point[3], int body);
-
-// Compute body frame end-effector Jacobian.
-MJAPI void mj_jacBody(const mjModel* m, const mjData* d, mjtNum* jacp, mjtNum* jacr, int body);
-
-// Compute body center-of-mass end-effector Jacobian.
-MJAPI void mj_jacBodyCom(const mjModel* m, const mjData* d, mjtNum* jacp, mjtNum* jacr, int body);
-
-// Compute subtree center-of-mass end-effector Jacobian.
-MJAPI void mj_jacSubtreeCom(const mjModel* m, mjData* d, mjtNum* jacp, int body);
-
-// Compute geom end-effector Jacobian.
-MJAPI void mj_jacGeom(const mjModel* m, const mjData* d, mjtNum* jacp, mjtNum* jacr, int geom);
-
-// Compute site end-effector Jacobian.
-MJAPI void mj_jacSite(const mjModel* m, const mjData* d, mjtNum* jacp, mjtNum* jacr, int site);
-
-// Compute translation end-effector Jacobian of point, and rotation Jacobian of axis.
-MJAPI void mj_jacPointAxis(const mjModel* m, mjData* d, mjtNum* jacPoint, mjtNum* jacAxis,
-                           const mjtNum point[3], const mjtNum axis[3], int body);
-
-// Get id of object with the specified mjtObj type and name, returns -1 if id not found.
-MJAPI int mj_name2id(const mjModel* m, int type, const char* name);
-
-// Get name of object with the specified mjtObj type and id, returns NULL if name not found.
-MJAPI const char* mj_id2name(const mjModel* m, int type, int id);
-
-// Convert sparse inertia matrix M into full (i.e. dense) matrix.
-MJAPI void mj_fullM(const mjModel* m, mjtNum* dst, const mjtNum* M);
-
-// Multiply vector by inertia matrix.
-MJAPI void mj_mulM(const mjModel* m, const mjData* d, mjtNum* res, const mjtNum* vec);
-
-// Multiply vector by (inertia matrix)^(1/2).
-MJAPI void mj_mulM2(const mjModel* m, const mjData* d, mjtNum* res, const mjtNum* vec);
-
-// Add inertia matrix to destination matrix.
-// Destination can be sparse uncompressed, or dense when all int* are NULL
-MJAPI void mj_addM(const mjModel* m, mjData* d, mjtNum* dst, int* rownnz, int* rowadr, int* colind);
-
-// Apply Cartesian force and torque (outside xfrc_applied mechanism).
-MJAPI void mj_applyFT(const mjModel* m, mjData* d, const mjtNum force[3], const mjtNum torque[3],
-                      const mjtNum point[3], int body, mjtNum* qfrc_target);
-
-// Compute object 6D velocity (rot:lin) in object-centered frame, world/local orientation.
-MJAPI void mj_objectVelocity(const mjModel* m, const mjData* d,
-                             int objtype, int objid, mjtNum res[6], int flg_local);
-
-// Compute object 6D acceleration (rot:lin) in object-centered frame, world/local orientation.
-MJAPI void mj_objectAcceleration(const mjModel* m, const mjData* d,
-                                 int objtype, int objid, mjtNum res[6], int flg_local);
-
-// Extract 6D force:torque given contact id, in the contact frame.
-MJAPI void mj_contactForce(const mjModel* m, const mjData* d, int id, mjtNum result[6]);
-
-// Compute velocity by finite-differencing two positions.
-MJAPI void mj_differentiatePos(const mjModel* m, mjtNum* qvel, mjtNum dt,
-                               const mjtNum* qpos1, const mjtNum* qpos2);
-
-// Integrate position with given velocity.
-MJAPI void mj_integratePos(const mjModel* m, mjtNum* qpos, const mjtNum* qvel, mjtNum dt);
-
-// Normalize all quaternions in qpos-type vector.
-MJAPI void mj_normalizeQuat(const mjModel* m, mjtNum* qpos);
-
-// Map from body local to global Cartesian coordinates.
-MJAPI void mj_local2Global(mjData* d, mjtNum xpos[3], mjtNum xmat[9], const mjtNum pos[3],
-                           const mjtNum quat[4], int body, mjtByte sameframe);
-
-// Sum all body masses.
-MJAPI mjtNum mj_getTotalmass(const mjModel* m);
-
-// Scale body masses and inertias to achieve specified total mass.
-MJAPI void mj_setTotalmass(mjModel* m, mjtNum newmass);
-
-// Return a config attribute value of a plugin instance;
-// NULL: invalid plugin instance ID or attribute name
-MJAPI const char* mj_getPluginConfig(const mjModel* m, int plugin_id, const char* attrib);
-
-// Load a dynamic library. The dynamic library is assumed to register one or more plugins.
-MJAPI void mj_loadPluginLibrary(const char* path);
-
-// Scan a directory and load all dynamic libraries. Dynamic libraries in the specified directory
-// are assumed to register one or more plugins. Optionally, if a callback is specified, it is called
-// for each dynamic library encountered that registers plugins.
-MJAPI void mj_loadAllPluginLibraries(const char* directory, mjfPluginLibraryLoadCallback callback);
-
-// Return version number: 1.0.2 is encoded as 102.
-MJAPI int mj_version(void);
-
-// Return the current version of MuJoCo as a null-terminated string.
-MJAPI const char* mj_versionString();
-
-
-//---------------------------------- Ray collisions ------------------------------------------------
-
-// Intersect multiple rays emanating from a single point.
-// Similar semantics to mj_ray, but vec is an array of (nray x 3) directions.
-MJAPI void mj_multiRay(const mjModel* m, mjData* d, const mjtNum pnt[3], const mjtNum* vec,
-                       const mjtByte* geomgroup, mjtByte flg_static, int bodyexclude,
-                       int* geomid, mjtNum* dist, int nray, mjtNum cutoff);
-
-// Intersect ray (pnt+x*vec, x>=0) with visible geoms, except geoms in bodyexclude.
-// Return distance (x) to nearest surface, or -1 if no intersection and output geomid.
-// geomgroup, flg_static are as in mjvOption; geomgroup==NULL skips group exclusion.
-MJAPI mjtNum mj_ray(const mjModel* m, const mjData* d, const mjtNum pnt[3], const mjtNum vec[3],
-                    const mjtByte* geomgroup, mjtByte flg_static, int bodyexclude,
-                    int geomid[1]);
-
-// Intersect ray with hfield, return nearest distance or -1 if no intersection.
-MJAPI mjtNum mj_rayHfield(const mjModel* m, const mjData* d, int geomid,
-                          const mjtNum pnt[3], const mjtNum vec[3]);
-
-// Intersect ray with mesh, return nearest distance or -1 if no intersection.
-MJAPI mjtNum mj_rayMesh(const mjModel* m, const mjData* d, int geomid,
-                        const mjtNum pnt[3], const mjtNum vec[3]);
-
-// Intersect ray with pure geom, return nearest distance or -1 if no intersection.
-MJAPI mjtNum mju_rayGeom(const mjtNum pos[3], const mjtNum mat[9], const mjtNum size[3],
-                         const mjtNum pnt[3], const mjtNum vec[3], int geomtype);
-
-// Intersect ray with skin, return nearest distance or -1 if no intersection,
-// and also output nearest vertex id.
-MJAPI mjtNum mju_raySkin(int nface, int nvert, const int* face, const float* vert,
-                         const mjtNum pnt[3], const mjtNum vec[3], int vertid[1]);
-
-
-//---------------------------------- Interaction ---------------------------------------------------
-
-// Set default camera.
-MJAPI void mjv_defaultCamera(mjvCamera* cam);
-
-// Set default free camera.
-MJAPI void mjv_defaultFreeCamera(const mjModel* m, mjvCamera* cam);
-
-// Set default perturbation.
-MJAPI void mjv_defaultPerturb(mjvPerturb* pert);
-
-// Transform pose from room to model space.
-MJAPI void mjv_room2model(mjtNum modelpos[3], mjtNum modelquat[4], const mjtNum roompos[3],
-                          const mjtNum roomquat[4], const mjvScene* scn);
-
-// Transform pose from model to room space.
-MJAPI void mjv_model2room(mjtNum roompos[3], mjtNum roomquat[4], const mjtNum modelpos[3],
-                          const mjtNum modelquat[4], const mjvScene* scn);
-
-// Get camera info in model space; average left and right OpenGL cameras.
-MJAPI void mjv_cameraInModel(mjtNum headpos[3], mjtNum forward[3], mjtNum up[3],
-                             const mjvScene* scn);
-
-// Get camera info in room space; average left and right OpenGL cameras.
-MJAPI void mjv_cameraInRoom(mjtNum headpos[3], mjtNum forward[3], mjtNum up[3],
-                            const mjvScene* scn);
-
-// Get frustum height at unit distance from camera; average left and right OpenGL cameras.
-MJAPI mjtNum mjv_frustumHeight(const mjvScene* scn);
-
-// Rotate 3D vec in horizontal plane by angle between (0,1) and (forward_x,forward_y).
-MJAPI void mjv_alignToCamera(mjtNum res[3], const mjtNum vec[3], const mjtNum forward[3]);
-
-// Move camera with mouse; action is mjtMouse.
-MJAPI void mjv_moveCamera(const mjModel* m, int action, mjtNum reldx, mjtNum reldy,
-                          const mjvScene* scn, mjvCamera* cam);
-
-// Move camera with mouse given a scene state; action is mjtMouse.
-MJAPI void mjv_moveCameraFromState(const mjvSceneState* scnstate, int action,
-                                   mjtNum reldx, mjtNum reldy,
-                                   const mjvScene* scn, mjvCamera* cam);
-
-// Move perturb object with mouse; action is mjtMouse.
-MJAPI void mjv_movePerturb(const mjModel* m, const mjData* d, int action, mjtNum reldx,
-                           mjtNum reldy, const mjvScene* scn, mjvPerturb* pert);
-
-// Move perturb object with mouse given a scene state; action is mjtMouse.
-MJAPI void mjv_movePerturbFromState(const mjvSceneState* scnstate, int action,
-                                    mjtNum reldx, mjtNum reldy,
-                                    const mjvScene* scn, mjvPerturb* pert);
-
-// Move model with mouse; action is mjtMouse.
-MJAPI void mjv_moveModel(const mjModel* m, int action, mjtNum reldx, mjtNum reldy,
-                         const mjtNum roomup[3], mjvScene* scn);
-
-// Copy perturb pos,quat from selected body; set scale for perturbation.
-MJAPI void mjv_initPerturb(const mjModel* m, mjData* d, const mjvScene* scn, mjvPerturb* pert);
-
-// Set perturb pos,quat in d->mocap when selected body is mocap, and in d->qpos otherwise.
-// Write d->qpos only if flg_paused and subtree root for selected body has free joint.
-MJAPI void mjv_applyPerturbPose(const mjModel* m, mjData* d, const mjvPerturb* pert,
-                                int flg_paused);
-
-// Set perturb force,torque in d->xfrc_applied, if selected body is dynamic.
-MJAPI void mjv_applyPerturbForce(const mjModel* m, mjData* d, const mjvPerturb* pert);
-
-// Return the average of two OpenGL cameras.
-MJAPI mjvGLCamera mjv_averageCamera(const mjvGLCamera* cam1, const mjvGLCamera* cam2);
-
-// Select geom or skin with mouse, return bodyid; -1: none selected.
-MJAPI int mjv_select(const mjModel* m, const mjData* d, const mjvOption* vopt,
-                     mjtNum aspectratio, mjtNum relx, mjtNum rely,
-                     const mjvScene* scn, mjtNum selpnt[3], int geomid[1], int skinid[1]);
-
-
-//---------------------------------- Visualization -------------------------------------------------
-
-// Set default visualization options.
-MJAPI void mjv_defaultOption(mjvOption* opt);
-
-// Set default figure.
-MJAPI void mjv_defaultFigure(mjvFigure* fig);
-
-// Initialize given geom fields when not NULL, set the rest to their default values.
-MJAPI void mjv_initGeom(mjvGeom* geom, int type, const mjtNum size[3],
-                        const mjtNum pos[3], const mjtNum mat[9], const float rgba[4]);
-
-// Set (type, size, pos, mat) for connector-type geom between given points.
-// Assume that mjv_initGeom was already called to set all other properties.
-// Width of mjGEOM_LINE is denominated in pixels.
-// Deprecated: use mjv_connector.
-MJAPI void mjv_makeConnector(mjvGeom* geom, int type, mjtNum width,
-                             mjtNum a0, mjtNum a1, mjtNum a2,
-                             mjtNum b0, mjtNum b1, mjtNum b2);
-
-// Set (type, size, pos, mat) for connector-type geom between given points.
-// Assume that mjv_initGeom was already called to set all other properties.
-// Width of mjGEOM_LINE is denominated in pixels.
-MJAPI void mjv_connector(mjvGeom* geom, int type, mjtNum width,
-                         const mjtNum from[3], const mjtNum to[3]);
-
-// Set default abstract scene.
-MJAPI void mjv_defaultScene(mjvScene* scn);
-
-// Allocate resources in abstract scene.
-MJAPI void mjv_makeScene(const mjModel* m, mjvScene* scn, int maxgeom);
-
-// Free abstract scene.
-MJAPI void mjv_freeScene(mjvScene* scn);
-
-// Update entire scene given model state.
-MJAPI void mjv_updateScene(const mjModel* m, mjData* d, const mjvOption* opt,
-                           const mjvPerturb* pert, mjvCamera* cam, int catmask, mjvScene* scn);
-
-// Update entire scene from a scene state, return the number of new mjWARN_VGEOMFULL warnings.
-MJAPI int mjv_updateSceneFromState(const mjvSceneState* scnstate, const mjvOption* opt,
-                                   const mjvPerturb* pert, mjvCamera* cam, int catmask,
-                                   mjvScene* scn);
-
-// Set default scene state.
-MJAPI void mjv_defaultSceneState(mjvSceneState* scnstate);
-
-// Allocate resources and initialize a scene state object.
-MJAPI void mjv_makeSceneState(const mjModel* m, const mjData* d,
-                              mjvSceneState* scnstate, int maxgeom);
-
-// Free scene state.
-MJAPI void mjv_freeSceneState(mjvSceneState* scnstate);
-
-// Update a scene state from model and data.
-MJAPI void mjv_updateSceneState(const mjModel* m, mjData* d, const mjvOption* opt,
-                                mjvSceneState* scnstate);
-
-// Add geoms from selected categories.
-MJAPI void mjv_addGeoms(const mjModel* m, mjData* d, const mjvOption* opt,
-                        const mjvPerturb* pert, int catmask, mjvScene* scn);
-
-// Make list of lights.
-MJAPI void mjv_makeLights(const mjModel* m, mjData* d, mjvScene* scn);
-
-// Update camera.
-MJAPI void mjv_updateCamera(const mjModel* m, mjData* d, mjvCamera* cam, mjvScene* scn);
-
-// Update skins.
-MJAPI void mjv_updateSkin(const mjModel* m, mjData* d, mjvScene* scn);
-
-
-//---------------------------------- OpenGL rendering ----------------------------------------------
-
-// Set default mjrContext.
-MJAPI void mjr_defaultContext(mjrContext* con);
-
-// Allocate resources in custom OpenGL context; fontscale is mjtFontScale.
-MJAPI void mjr_makeContext(const mjModel* m, mjrContext* con, int fontscale);
-
-// Change font of existing context.
-MJAPI void mjr_changeFont(int fontscale, mjrContext* con);
-
-// Add Aux buffer with given index to context; free previous Aux buffer.
-MJAPI void mjr_addAux(int index, int width, int height, int samples, mjrContext* con);
-
-// Free resources in custom OpenGL context, set to default.
-MJAPI void mjr_freeContext(mjrContext* con);
-
-// Resize offscreen buffers.
-MJAPI void mjr_resizeOffscreen(int width, int height, mjrContext* con);
-
-// Upload texture to GPU, overwriting previous upload if any.
-MJAPI void mjr_uploadTexture(const mjModel* m, const mjrContext* con, int texid);
-
-// Upload mesh to GPU, overwriting previous upload if any.
-MJAPI void mjr_uploadMesh(const mjModel* m, const mjrContext* con, int meshid);
-
-// Upload height field to GPU, overwriting previous upload if any.
-MJAPI void mjr_uploadHField(const mjModel* m, const mjrContext* con, int hfieldid);
-
-// Make con->currentBuffer current again.
-MJAPI void mjr_restoreBuffer(const mjrContext* con);
-
-// Set OpenGL framebuffer for rendering: mjFB_WINDOW or mjFB_OFFSCREEN.
-// If only one buffer is available, set that buffer and ignore framebuffer argument.
-MJAPI void mjr_setBuffer(int framebuffer, mjrContext* con);
-
-// Read pixels from current OpenGL framebuffer to client buffer.
-// Viewport is in OpenGL framebuffer; client buffer starts at (0,0).
-MJAPI void mjr_readPixels(unsigned char* rgb, float* depth,
-                          mjrRect viewport, const mjrContext* con);
-
-// Draw pixels from client buffer to current OpenGL framebuffer.
-// Viewport is in OpenGL framebuffer; client buffer starts at (0,0).
-MJAPI void mjr_drawPixels(const unsigned char* rgb, const float* depth,
-                          mjrRect viewport, const mjrContext* con);
-
-// Blit from src viewpoint in current framebuffer to dst viewport in other framebuffer.
-// If src, dst have different size and flg_depth==0, color is interpolated with GL_LINEAR.
-MJAPI void mjr_blitBuffer(mjrRect src, mjrRect dst,
-                          int flg_color, int flg_depth, const mjrContext* con);
-
-// Set Aux buffer for custom OpenGL rendering (call restoreBuffer when done).
-MJAPI void mjr_setAux(int index, const mjrContext* con);
-
-// Blit from Aux buffer to con->currentBuffer.
-MJAPI void mjr_blitAux(int index, mjrRect src, int left, int bottom, const mjrContext* con);
-
-// Draw text at (x,y) in relative coordinates; font is mjtFont.
-MJAPI void mjr_text(int font, const char* txt, const mjrContext* con,
-                    float x, float y, float r, float g, float b);
-
-// Draw text overlay; font is mjtFont; gridpos is mjtGridPos.
-MJAPI void mjr_overlay(int font, int gridpos, mjrRect viewport,
-                       const char* overlay, const char* overlay2, const mjrContext* con);
-
-// Get maximum viewport for active buffer.
-MJAPI mjrRect mjr_maxViewport(const mjrContext* con);
-
-// Draw rectangle.
-MJAPI void mjr_rectangle(mjrRect viewport, float r, float g, float b, float a);
-
-// Draw rectangle with centered text.
-MJAPI void mjr_label(mjrRect viewport, int font, const char* txt,
-                     float r, float g, float b, float a, float rt, float gt, float bt,
-                     const mjrContext* con);
-
-// Draw 2D figure.
-MJAPI void mjr_figure(mjrRect viewport, mjvFigure* fig, const mjrContext* con);
-
-// Render 3D scene.
-MJAPI void mjr_render(mjrRect viewport, mjvScene* scn, const mjrContext* con);
-
-// Call glFinish.
-MJAPI void mjr_finish(void);
-
-// Call glGetError and return result.
-MJAPI int mjr_getError(void);
-
-// Find first rectangle containing mouse, -1: not found.
-MJAPI int mjr_findRect(int x, int y, int nrect, const mjrRect* rect);
-
-
-//---------------------------------- UI framework --------------------------------------------------
-
-// Get builtin UI theme spacing (ind: 0-1).
-MJAPI mjuiThemeSpacing mjui_themeSpacing(int ind);
-
-// Get builtin UI theme color (ind: 0-3).
-MJAPI mjuiThemeColor mjui_themeColor(int ind);
-
-// Add definitions to UI.
-MJAPI void mjui_add(mjUI* ui, const mjuiDef* def);
-
-// Add definitions to UI section.
-MJAPI void mjui_addToSection(mjUI* ui, int sect, const mjuiDef* def);
-
-// Compute UI sizes.
-MJAPI void mjui_resize(mjUI* ui, const mjrContext* con);
-
-// Update specific section/item; -1: update all.
-MJAPI void mjui_update(int section, int item, const mjUI* ui,
-                       const mjuiState* state, const mjrContext* con);
-
-// Handle UI event, return pointer to changed item, NULL if no change.
-MJAPI mjuiItem* mjui_event(mjUI* ui, mjuiState* state, const mjrContext* con);
-
-// Copy UI image to current buffer.
-MJAPI void mjui_render(mjUI* ui, const mjuiState* state, const mjrContext* con);
-
-
-//---------------------------------- Error and memory ----------------------------------------------
-
-// Main error function; does not return to caller.
-MJAPI void mju_error(const char* msg, ...) mjPRINTFLIKE(1, 2);
-
-// Deprecated: use mju_error.
-MJAPI void mju_error_i(const char* msg, int i);
-
-// Deprecated: use mju_error.
-MJAPI void mju_error_s(const char* msg, const char* text);
-
-// Main warning function; returns to caller.
-MJAPI void mju_warning(const char* msg, ...) mjPRINTFLIKE(1, 2);
-
-// Deprecated: use mju_warning.
-MJAPI void mju_warning_i(const char* msg, int i);
-
-// Deprecated: use mju_warning.
-MJAPI void mju_warning_s(const char* msg, const char* text);
-
-// Clear user error and memory handlers.
-MJAPI void mju_clearHandlers(void);
-
-// Allocate memory; byte-align on 64; pad size to multiple of 64.
-MJAPI void* mju_malloc(size_t size);
-
-// Free memory, using free() by default.
-MJAPI void mju_free(void* ptr);
-
-// High-level warning function: count warnings in mjData, print only the first.
-MJAPI void mj_warning(mjData* d, int warning, int info);
-
-// Write [datetime, type: message] to MUJOCO_LOG.TXT.
-MJAPI void mju_writeLog(const char* type, const char* msg);
-
-
-//---------------------------------- Standard math -------------------------------------------------
-
-#ifdef mjUSEDOUBLE
-  #define mju_sqrt    sqrt
-  #define mju_exp     exp
-  #define mju_sin     sin
-  #define mju_cos     cos
-  #define mju_tan     tan
-  #define mju_asin    asin
-  #define mju_acos    acos
-  #define mju_atan2   atan2
-  #define mju_tanh    tanh
-  #define mju_pow     pow
-  #define mju_abs     fabs
-  #define mju_log     log
-  #define mju_log10   log10
-  #define mju_floor   floor
-  #define mju_ceil    ceil
-
-#else
-  #define mju_sqrt    sqrtf
-  #define mju_exp     expf
-  #define mju_sin     sinf
-  #define mju_cos     cosf
-  #define mju_tan     tanf
-  #define mju_asin    asinf
-  #define mju_acos    acosf
-  #define mju_atan2   atan2f
-  #define mju_tanh    tanhf
-  #define mju_pow     powf
-  #define mju_abs     fabsf
-  #define mju_log     logf
-  #define mju_log10   log10f
-  #define mju_floor   floorf
-  #define mju_ceil    ceilf
-#endif
-
-
-//---------------------------------- Vector math ---------------------------------------------------
-
-// Set res = 0.
-MJAPI void mju_zero3(mjtNum res[3]);
-
-// Set res = vec.
-MJAPI void mju_copy3(mjtNum res[3], const mjtNum data[3]);
-
-// Set res = vec*scl.
-MJAPI void mju_scl3(mjtNum res[3], const mjtNum vec[3], mjtNum scl);
-
-// Set res = vec1 + vec2.
-MJAPI void mju_add3(mjtNum res[3], const mjtNum vec1[3], const mjtNum vec2[3]);
-
-// Set res = vec1 - vec2.
-MJAPI void mju_sub3(mjtNum res[3], const mjtNum vec1[3], const mjtNum vec2[3]);
-
-// Set res = res + vec.
-MJAPI void mju_addTo3(mjtNum res[3], const mjtNum vec[3]);
-
-// Set res = res - vec.
-MJAPI void mju_subFrom3(mjtNum res[3], const mjtNum vec[3]);
-
-// Set res = res + vec*scl.
-MJAPI void mju_addToScl3(mjtNum res[3], const mjtNum vec[3], mjtNum scl);
-
-// Set res = vec1 + vec2*scl.
-MJAPI void mju_addScl3(mjtNum res[3], const mjtNum vec1[3], const mjtNum vec2[3], mjtNum scl);
-
-// Normalize vector, return length before normalization.
-MJAPI mjtNum mju_normalize3(mjtNum res[3]);
-
-// Return vector length (without normalizing the vector).
-MJAPI mjtNum mju_norm3(const mjtNum vec[3]);
-
-// Return dot-product of vec1 and vec2.
-MJAPI mjtNum mju_dot3(const mjtNum vec1[3], const mjtNum vec2[3]);
-
-// Return Cartesian distance between 3D vectors pos1 and pos2.
-MJAPI mjtNum mju_dist3(const mjtNum pos1[3], const mjtNum pos2[3]);
-
-// Multiply vector by 3D rotation matrix: res = mat * vec.
-MJAPI void mju_rotVecMat(mjtNum res[3], const mjtNum vec[3], const mjtNum mat[9]);
-
-// Multiply vector by transposed 3D rotation matrix: res = mat' * vec.
-MJAPI void mju_rotVecMatT(mjtNum res[3], const mjtNum vec[3], const mjtNum mat[9]);
-
-// Compute cross-product: res = cross(a, b).
-MJAPI void mju_cross(mjtNum res[3], const mjtNum a[3], const mjtNum b[3]);
-
-// Set res = 0.
-MJAPI void mju_zero4(mjtNum res[4]);
-
-// Set res = (1,0,0,0).
-MJAPI void mju_unit4(mjtNum res[4]);
-
-// Set res = vec.
-MJAPI void mju_copy4(mjtNum res[4], const mjtNum data[4]);
-
-// Normalize vector, return length before normalization.
-MJAPI mjtNum mju_normalize4(mjtNum res[4]);
-
-// Set res = 0.
-MJAPI void mju_zero(mjtNum* res, int n);
-
-// Set res = val.
-MJAPI void mju_fill(mjtNum* res, mjtNum val, int n);
-
-// Set res = vec.
-MJAPI void mju_copy(mjtNum* res, const mjtNum* data, int n);
-
-// Return sum(vec).
-MJAPI mjtNum mju_sum(const mjtNum* vec, int n);
-
-// Return L1 norm: sum(abs(vec)).
-MJAPI mjtNum mju_L1(const mjtNum* vec, int n);
-
-// Set res = vec*scl.
-MJAPI void mju_scl(mjtNum* res, const mjtNum* vec, mjtNum scl, int n);
-
-// Set res = vec1 + vec2.
-MJAPI void mju_add(mjtNum* res, const mjtNum* vec1, const mjtNum* vec2, int n);
-
-// Set res = vec1 - vec2.
-MJAPI void mju_sub(mjtNum* res, const mjtNum* vec1, const mjtNum* vec2, int n);
-
-// Set res = res + vec.
-MJAPI void mju_addTo(mjtNum* res, const mjtNum* vec, int n);
-
-// Set res = res - vec.
-MJAPI void mju_subFrom(mjtNum* res, const mjtNum* vec, int n);
-
-// Set res = res + vec*scl.
-MJAPI void mju_addToScl(mjtNum* res, const mjtNum* vec, mjtNum scl, int n);
-
-// Set res = vec1 + vec2*scl.
-MJAPI void mju_addScl(mjtNum* res, const mjtNum* vec1, const mjtNum* vec2, mjtNum scl, int n);
-
-// Normalize vector, return length before normalization.
-MJAPI mjtNum mju_normalize(mjtNum* res, int n);
-
-// Return vector length (without normalizing vector).
-MJAPI mjtNum mju_norm(const mjtNum* res, int n);
-
-// Return dot-product of vec1 and vec2.
-MJAPI mjtNum mju_dot(const mjtNum* vec1, const mjtNum* vec2, int n);
-
-// Multiply matrix and vector: res = mat * vec.
-MJAPI void mju_mulMatVec(mjtNum* res, const mjtNum* mat, const mjtNum* vec, int nr, int nc);
-
-// Multiply transposed matrix and vector: res = mat' * vec.
-MJAPI void mju_mulMatTVec(mjtNum* res, const mjtNum* mat, const mjtNum* vec, int nr, int nc);
-
-// Multiply square matrix with vectors on both sides: returns vec1' * mat * vec2.
-MJAPI mjtNum mju_mulVecMatVec(const mjtNum* vec1, const mjtNum* mat, const mjtNum* vec2, int n);
-
-// Transpose matrix: res = mat'.
-MJAPI void mju_transpose(mjtNum* res, const mjtNum* mat, int nr, int nc);
-
-// Symmetrize square matrix res = (mat + mat')/2.
-MJAPI void mju_symmetrize(mjtNum* res, const mjtNum* mat, int n);
-
-// Set mat to the identity matrix.
-MJAPI void mju_eye(mjtNum* mat, int n);
-
-// Multiply matrices: res = mat1 * mat2.
-MJAPI void mju_mulMatMat(mjtNum* res, const mjtNum* mat1, const mjtNum* mat2,
-                         int r1, int c1, int c2);
-
-// Multiply matrices, second argument transposed: res = mat1 * mat2'.
-MJAPI void mju_mulMatMatT(mjtNum* res, const mjtNum* mat1, const mjtNum* mat2,
-                          int r1, int c1, int r2);
-
-// Multiply matrices, first argument transposed: res = mat1' * mat2.
-MJAPI void mju_mulMatTMat(mjtNum* res, const mjtNum* mat1, const mjtNum* mat2,
-                          int r1, int c1, int c2);
-
-// Set res = mat' * diag * mat if diag is not NULL, and res = mat' * mat otherwise.
-MJAPI void mju_sqrMatTD(mjtNum* res, const mjtNum* mat, const mjtNum* diag, int nr, int nc);
-
-// Coordinate transform of 6D motion or force vector in rotation:translation format.
-// rotnew2old is 3-by-3, NULL means no rotation; flg_force specifies force or motion type.
-MJAPI void mju_transformSpatial(mjtNum res[6], const mjtNum vec[6], int flg_force,
-                                const mjtNum newpos[3], const mjtNum oldpos[3],
-                                const mjtNum rotnew2old[9]);
-
-
-//---------------------------------- Quaternions ---------------------------------------------------
-
-// Rotate vector by quaternion.
-MJAPI void mju_rotVecQuat(mjtNum res[3], const mjtNum vec[3], const mjtNum quat[4]);
-
-// Conjugate quaternion, corresponding to opposite rotation.
-MJAPI void mju_negQuat(mjtNum res[4], const mjtNum quat[4]);
-
-// Multiply quaternions.
-MJAPI void mju_mulQuat(mjtNum res[4], const mjtNum quat1[4], const mjtNum quat2[4]);
-
-// Multiply quaternion and axis.
-MJAPI void mju_mulQuatAxis(mjtNum res[4], const mjtNum quat[4], const mjtNum axis[3]);
-
-// Convert axisAngle to quaternion.
-MJAPI void mju_axisAngle2Quat(mjtNum res[4], const mjtNum axis[3], mjtNum angle);
-
-// Convert quaternion (corresponding to orientation difference) to 3D velocity.
-MJAPI void mju_quat2Vel(mjtNum res[3], const mjtNum quat[4], mjtNum dt);
-
-// Subtract quaternions, express as 3D velocity: qb*quat(res) = qa.
-MJAPI void mju_subQuat(mjtNum res[3], const mjtNum qa[4], const mjtNum qb[4]);
-
-// Convert quaternion to 3D rotation matrix.
-MJAPI void mju_quat2Mat(mjtNum res[9], const mjtNum quat[4]);
-
-// Convert 3D rotation matrix to quaternion.
-MJAPI void mju_mat2Quat(mjtNum quat[4], const mjtNum mat[9]);
-
-// Compute time-derivative of quaternion, given 3D rotational velocity.
-MJAPI void mju_derivQuat(mjtNum res[4], const mjtNum quat[4], const mjtNum vel[3]);
-
-// Integrate quaternion given 3D angular velocity.
-MJAPI void mju_quatIntegrate(mjtNum quat[4], const mjtNum vel[3], mjtNum scale);
-
-// Construct quaternion performing rotation from z-axis to given vector.
-MJAPI void mju_quatZ2Vec(mjtNum quat[4], const mjtNum vec[3]);
-
-
-//---------------------------------- Poses ---------------------------------------------------------
-
-// Multiply two poses.
-MJAPI void mju_mulPose(mjtNum posres[3], mjtNum quatres[4],
-                       const mjtNum pos1[3], const mjtNum quat1[4],
-                       const mjtNum pos2[3], const mjtNum quat2[4]);
-
-// Conjugate pose, corresponding to the opposite spatial transformation.
-MJAPI void mju_negPose(mjtNum posres[3], mjtNum quatres[4],
-                       const mjtNum pos[3], const mjtNum quat[4]);
-
-// Transform vector by pose.
-MJAPI void mju_trnVecPose(mjtNum res[3], const mjtNum pos[3], const mjtNum quat[4],
-                          const mjtNum vec[3]);
-
-
-//--------------------------------- Decompositions / Solvers ---------------------------------------
-
-// Cholesky decomposition: mat = L*L'; return rank, decomposition performed in-place into mat.
-MJAPI int mju_cholFactor(mjtNum* mat, int n, mjtNum mindiag);
-
-// Solve (mat*mat') * res = vec, where mat is a Cholesky factor.
-MJAPI void mju_cholSolve(mjtNum* res, const mjtNum* mat, const mjtNum* vec, int n);
-
-// Cholesky rank-one update: L*L' +/- x*x'; return rank.
-MJAPI int mju_cholUpdate(mjtNum* mat, mjtNum* x, int n, int flg_plus);
-
-// Band-dense Cholesky decomposition.
-//  Returns minimum value in the factorized diagonal, or 0 if rank-deficient.
-//  mat has (ntotal-ndense) x nband + ndense x ntotal elements.
-//  The first (ntotal-ndense) x nband store the band part, left of diagonal, inclusive.
-//  The second ndense x ntotal store the band part as entire dense rows.
-//  Add diagadd+diagmul*mat_ii to diagonal before factorization.
-MJAPI mjtNum mju_cholFactorBand(mjtNum* mat, int ntotal, int nband, int ndense,
-                                mjtNum diagadd, mjtNum diagmul);
-
-// Solve (mat*mat')*res = vec where mat is a band-dense Cholesky factor.
-MJAPI void mju_cholSolveBand(mjtNum* res, const mjtNum* mat, const mjtNum* vec,
-                             int ntotal, int nband, int ndense);
-
-// Convert banded matrix to dense matrix, fill upper triangle if flg_sym>0.
-MJAPI void mju_band2Dense(mjtNum* res, const mjtNum* mat, int ntotal, int nband, int ndense,
-                          mjtByte flg_sym);
-
-// Convert dense matrix to banded matrix.
-MJAPI void mju_dense2Band(mjtNum* res, const mjtNum* mat, int ntotal, int nband, int ndense);
-
-// Multiply band-diagonal matrix with nvec vectors, include upper triangle if flg_sym>0.
-MJAPI void mju_bandMulMatVec(mjtNum* res, const mjtNum* mat, const mjtNum* vec,
-                             int ntotal, int nband, int ndense, int nvec, mjtByte flg_sym);
-
-// Address of diagonal element i in band-dense matrix representation.
-MJAPI int mju_bandDiag(int i, int ntotal, int nband, int ndense);
-
-// Eigenvalue decomposition of symmetric 3x3 matrix.
-MJAPI int mju_eig3(mjtNum eigval[3], mjtNum eigvec[9], mjtNum quat[4], const mjtNum mat[9]);
-
-// minimize 0.5*x'*H*x + x'*g  s.t. lower <= x <= upper, return rank or -1 if failed
-//   inputs:
-//     n           - problem dimension
-//     H           - SPD matrix                n*n
-//     g           - bias vector               n
-//     lower       - lower bounds              n
-//     upper       - upper bounds              n
-//     res         - solution warmstart        n
-//   return value:
-//     nfree <= n  - rank of unconstrained subspace, -1 if failure
-//   outputs (required):
-//     res         - solution                  n
-//     R           - subspace Cholesky factor  nfree*nfree    allocated: n*(n+7)
-//   outputs (optional):
-//     index       - set of free dimensions    nfree          allocated: n
-//   notes:
-//     the initial value of res is used to warmstart the solver
-//     R must have allocatd size n*(n+7), but only nfree*nfree values are used in output
-//     index (if given) must have allocated size n, but only nfree values are used in output
-//     only the lower triangles of H and R and are read from and written to, respectively
-//     the convenience function mju_boxQPmalloc allocates the required data structures
-MJAPI int mju_boxQP(mjtNum* res, mjtNum* R, int* index, const mjtNum* H, const mjtNum* g, int n,
-                    const mjtNum* lower, const mjtNum* upper);
-
-// allocate heap memory for box-constrained Quadratic Program
-//   as in mju_boxQP, index, lower, and upper are optional
-//   free all pointers with mju_free()
-MJAPI void mju_boxQPmalloc(mjtNum** res, mjtNum** R, int** index, mjtNum** H, mjtNum** g, int n,
-                           mjtNum** lower, mjtNum** upper);
-
-//---------------------- Miscellaneous -------------------------------------------------------------
-
-// Muscle active force, prm = (range[2], force, scale, lmin, lmax, vmax, fpmax, fvmax).
-MJAPI mjtNum mju_muscleGain(mjtNum len, mjtNum vel, const mjtNum lengthrange[2],
-                            mjtNum acc0, const mjtNum prm[9]);
-
-// Muscle passive force, prm = (range[2], force, scale, lmin, lmax, vmax, fpmax, fvmax).
-MJAPI mjtNum mju_muscleBias(mjtNum len, const mjtNum lengthrange[2],
-                            mjtNum acc0, const mjtNum prm[9]);
-
-// Muscle activation dynamics, prm = (tau_act, tau_deact, smoothing_width).
-MJAPI mjtNum mju_muscleDynamics(mjtNum ctrl, mjtNum act, const mjtNum prm[3]);
-
-// Convert contact force to pyramid representation.
-MJAPI void mju_encodePyramid(mjtNum* pyramid, const mjtNum* force, const mjtNum* mu, int dim);
-
-// Convert pyramid representation to contact force.
-MJAPI void mju_decodePyramid(mjtNum* force, const mjtNum* pyramid, const mjtNum* mu, int dim);
-
-// Integrate spring-damper analytically, return pos(dt).
-MJAPI mjtNum mju_springDamper(mjtNum pos0, mjtNum vel0, mjtNum Kp, mjtNum Kv, mjtNum dt);
-
-// Return min(a,b) with single evaluation of a and b.
-MJAPI mjtNum mju_min(mjtNum a, mjtNum b);
-
-// Return max(a,b) with single evaluation of a and b.
-MJAPI mjtNum mju_max(mjtNum a, mjtNum b);
-
-// Clip x to the range [min, max].
-MJAPI mjtNum mju_clip(mjtNum x, mjtNum min, mjtNum max);
-
-// Return sign of x: +1, -1 or 0.
-MJAPI mjtNum mju_sign(mjtNum x);
-
-// Round x to nearest integer.
-MJAPI int mju_round(mjtNum x);
-
-// Convert type id (mjtObj) to type name.
-MJAPI const char* mju_type2Str(int type);
-
-// Convert type name to type id (mjtObj).
-MJAPI int mju_str2Type(const char* str);
-
-// Return human readable number of bytes using standard letter suffix.
-MJAPI const char* mju_writeNumBytes(size_t nbytes);
-
-// Construct a warning message given the warning type and info.
-MJAPI const char* mju_warningText(int warning, size_t info);
-
-// Return 1 if nan or abs(x)>mjMAXVAL, 0 otherwise. Used by check functions.
-MJAPI int mju_isBad(mjtNum x);
-
-// Return 1 if all elements are 0.
-MJAPI int mju_isZero(mjtNum* vec, int n);
-
-// Standard normal random number generator (optional second number).
-MJAPI mjtNum mju_standardNormal(mjtNum* num2);
-
-// Convert from float to mjtNum.
-MJAPI void mju_f2n(mjtNum* res, const float* vec, int n);
-
-// Convert from mjtNum to float.
-MJAPI void mju_n2f(float* res, const mjtNum* vec, int n);
-
-// Convert from double to mjtNum.
-MJAPI void mju_d2n(mjtNum* res, const double* vec, int n);
-
-// Convert from mjtNum to double.
-MJAPI void mju_n2d(double* res, const mjtNum* vec, int n);
-
-// Insertion sort, resulting list is in increasing order.
-MJAPI void mju_insertionSort(mjtNum* list, int n);
-
-// Integer insertion sort, resulting list is in increasing order.
-MJAPI void mju_insertionSortInt(int* list, int n);
-
-// Generate Halton sequence.
-MJAPI mjtNum mju_Halton(int index, int base);
-
-// Call strncpy, then set dst[n-1] = 0.
-MJAPI char* mju_strncpy(char *dst, const char *src, int n);
-
-// Sigmoid function over 0<=x<=1 using quintic polynomial.
-MJAPI mjtNum mju_sigmoid(mjtNum x);
-
-
-//---------------------- Derivatives ---------------------------------------------------------------
-
-// Finite differenced transition matrices (control theory notation)
-//   d(x_next) = A*dx + B*du
-//   d(sensor) = C*dx + D*du
-//   required output matrix dimensions:
-//      A: (2*nv+na x 2*nv+na)
-//      B: (2*nv+na x nu)
-//      D: (nsensordata x 2*nv+na)
-//      C: (nsensordata x nu)
-MJAPI void mjd_transitionFD(const mjModel* m, mjData* d, mjtNum eps, mjtByte flg_centered,
-                            mjtNum* A, mjtNum* B, mjtNum* C, mjtNum* D);
-
-// Finite differenced Jacobians of (force, sensors) = mj_inverse(state, acceleration)
-//   All outputs are optional. Output dimensions (transposed w.r.t Control Theory convention):
-//     DfDq: (nv x nv)
-//     DfDv: (nv x nv)
-//     DfDa: (nv x nv)
-//     DsDq: (nv x nsensordata)
-//     DsDv: (nv x nsensordata)
-//     DsDa: (nv x nsensordata)
-//     DmDq: (nv x nM)
-//   single-letter shortcuts:
-//     inputs: q=qpos, v=qvel, a=qacc
-//     outputs: f=qfrc_inverse, s=sensordata, m=qM
-//   notes:
-//     optionally computes mass matrix Jacobian DmDq
-//     flg_actuation specifies whether to subtract qfrc_actuator from qfrc_inverse
-MJAPI void mjd_inverseFD(const mjModel* m, mjData* d, mjtNum eps, mjtByte flg_actuation,
-                         mjtNum *DfDq, mjtNum *DfDv, mjtNum *DfDa,
-                         mjtNum *DsDq, mjtNum *DsDv, mjtNum *DsDa,
-                         mjtNum *DmDq);
-
-// Derivatives of mju_subQuat.
-MJAPI void mjd_subQuat(const mjtNum qa[4], const mjtNum qb[4], mjtNum Da[9], mjtNum Db[9]);
-
-// Derivatives of mju_quatIntegrate.
-MJAPI void mjd_quatIntegrate(const mjtNum vel[3], mjtNum scale,
-                             mjtNum Dquat[9], mjtNum Dvel[9], mjtNum Dscale[3]);
-
-//---------------------- Plugins -------------------------------------------------------------------
-
-// Set default plugin definition.
-MJAPI void mjp_defaultPlugin(mjpPlugin* plugin);
-
-// Globally register a plugin. This function is thread-safe.
-// If an identical mjpPlugin is already registered, this function does nothing.
-// If a non-identical mjpPlugin with the same name is already registered, an mju_error is raised.
-// Two mjpPlugins are considered identical if all member function pointers and numbers are equal,
-// and the name and attribute strings are all identical, however the char pointers to the strings
-// need not be the same.
-MJAPI int mjp_registerPlugin(const mjpPlugin* plugin);
-
-// Return the number of globally registered plugins.
-MJAPI int mjp_pluginCount();
-
-// Look up a plugin by name. If slot is not NULL, also write its registered slot number into it.
-MJAPI const mjpPlugin* mjp_getPlugin(const char* name, int* slot);
-
-// Look up a plugin by the registered slot number that was returned by mjp_registerPlugin.
-MJAPI const mjpPlugin* mjp_getPluginAtSlot(int slot);
-
-// Set default resource provider definition.
-MJAPI void mjp_defaultResourceProvider(mjpResourceProvider* provider);
-
-// Globally register a resource provider in a thread-safe manner. The provider must have a prefix
-// that is not a sub-prefix or super-prefix of any current registered providers.  This function
-// returns a slot number > 0 on success.
-MJAPI int mjp_registerResourceProvider(const mjpResourceProvider* provider);
-
-// Return the number of globally registered resource providers.
-MJAPI int mjp_resourceProviderCount();
-
-// Return the resource provider with the prefix that matches against the resource name.
-// If no match, return NULL.
-MJAPI const mjpResourceProvider* mjp_getResourceProvider(const char* resource_name);
-
-// Look up a resource provider by slot number returned by mjp_registerResourceProvider.
-// If invalid slot number, return NULL.
-MJAPI const mjpResourceProvider* mjp_getResourceProviderAtSlot(int slot);
-
-
-#if defined(__cplusplus)
-}
-#endif
-
-#endif  // MUJOCO_MUJOCO_H_
+// Copyright 2021 DeepMind Technologies Limited
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef MUJOCO_MUJOCO_H_
+#define MUJOCO_MUJOCO_H_
+
+#include <mujoco/mjexport.h>
+
+
+// this is a C-API
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+// header version; should match the library version as returned by mj_version()
+#define mjVERSION_HEADER 238
+
+// needed to define size_t, fabs and log10
+#include <stdlib.h>
+#include <math.h>
+
+#ifdef ADDRESS_SANITIZER
+#include <sanitizer/asan_interface.h>
+#endif
+
+// type definitions
+#include <mujoco/mjdata.h>
+#include <mujoco/mjmodel.h>
+#include <mujoco/mjmacro.h>
+#include <mujoco/mjplugin.h>
+#include <mujoco/mjrender.h>
+#include <mujoco/mjtnum.h>
+#include <mujoco/mjui.h>
+#include <mujoco/mjvisualize.h>
+
+
+// user error and memory handlers
+MJAPI extern void  (*mju_user_error)(const char*);
+MJAPI extern void  (*mju_user_warning)(const char*);
+MJAPI extern void* (*mju_user_malloc)(size_t);
+MJAPI extern void  (*mju_user_free)(void*);
+
+
+// callbacks extending computation pipeline
+MJAPI extern mjfGeneric  mjcb_passive;
+MJAPI extern mjfGeneric  mjcb_control;
+MJAPI extern mjfConFilt  mjcb_contactfilter;
+MJAPI extern mjfSensor   mjcb_sensor;
+MJAPI extern mjfTime     mjcb_time;
+MJAPI extern mjfAct      mjcb_act_dyn;
+MJAPI extern mjfAct      mjcb_act_gain;
+MJAPI extern mjfAct      mjcb_act_bias;
+
+
+// collision function table
+MJAPI extern mjfCollision mjCOLLISIONFUNC[mjNGEOMTYPES][mjNGEOMTYPES];
+
+
+// string names
+MJAPI extern const char* mjDISABLESTRING[mjNDISABLE];
+MJAPI extern const char* mjENABLESTRING[mjNENABLE];
+MJAPI extern const char* mjTIMERSTRING[mjNTIMER];
+MJAPI extern const char* mjLABELSTRING[mjNLABEL];
+MJAPI extern const char* mjFRAMESTRING[mjNFRAME];
+MJAPI extern const char* mjVISSTRING[mjNVISFLAG][3];
+MJAPI extern const char* mjRNDSTRING[mjNRNDFLAG][3];
+
+
+//---------------------------------- Virtual file system -------------------------------------------
+
+// Initialize VFS to empty (no deallocation).
+MJAPI void mj_defaultVFS(mjVFS* vfs);
+
+// Add file to VFS, return 0: success, 1: full, 2: repeated name, -1: failed to load.
+MJAPI int mj_addFileVFS(mjVFS* vfs, const char* directory, const char* filename);
+
+// Make empty file in VFS, return 0: success, 1: full, 2: repeated name.
+MJAPI int mj_makeEmptyFileVFS(mjVFS* vfs, const char* filename, int filesize);
+
+// Return file index in VFS, or -1 if not found in VFS.
+MJAPI int mj_findFileVFS(const mjVFS* vfs, const char* filename);
+
+// Delete file from VFS, return 0: success, -1: not found in VFS.
+MJAPI int mj_deleteFileVFS(mjVFS* vfs, const char* filename);
+
+// Delete all files from VFS.
+MJAPI void mj_deleteVFS(mjVFS* vfs);
+
+
+//---------------------------------- Parse and compile ---------------------------------------------
+
+// Parse XML file in MJCF or URDF format, compile it, return low-level model.
+// If vfs is not NULL, look up files in vfs before reading from disk.
+// If error is not NULL, it must have size error_sz.
+MJAPI mjModel* mj_loadXML(const char* filename, const mjVFS* vfs, char* error, int error_sz);
+
+// Update XML data structures with info from low-level model, save as MJCF.
+// If error is not NULL, it must have size error_sz.
+MJAPI int mj_saveLastXML(const char* filename, const mjModel* m, char* error, int error_sz);
+
+// Free last XML model if loaded. Called internally at each load.
+MJAPI void mj_freeLastXML(void);
+
+// Print internal XML schema as plain text or HTML, with style-padding or &nbsp;.
+MJAPI int mj_printSchema(const char* filename, char* buffer, int buffer_sz,
+                         int flg_html, int flg_pad);
+
+
+//---------------------------------- Main simulation -----------------------------------------------
+
+// Advance simulation, use control callback to obtain external force and control.
+MJAPI void mj_step(const mjModel* m, mjData* d);
+
+// Advance simulation in two steps: before external force and control is set by user.
+MJAPI void mj_step1(const mjModel* m, mjData* d);
+
+// Advance simulation in two steps: after external force and control is set by user.
+MJAPI void mj_step2(const mjModel* m, mjData* d);
+
+// Forward dynamics: same as mj_step but do not integrate in time.
+MJAPI void mj_forward(const mjModel* m, mjData* d);
+
+// Inverse dynamics: qacc must be set before calling.
+MJAPI void mj_inverse(const mjModel* m, mjData* d);
+
+// Forward dynamics with skip; skipstage is mjtStage.
+MJAPI void mj_forwardSkip(const mjModel* m, mjData* d, int skipstage, int skipsensor);
+
+// Inverse dynamics with skip; skipstage is mjtStage.
+MJAPI void mj_inverseSkip(const mjModel* m, mjData* d, int skipstage, int skipsensor);
+
+
+//---------------------------------- Initialization ------------------------------------------------
+
+// Set default options for length range computation.
+MJAPI void mj_defaultLROpt(mjLROpt* opt);
+
+// Set solver parameters to default values.
+MJAPI void mj_defaultSolRefImp(mjtNum* solref, mjtNum* solimp);
+
+// Set physics options to default values.
+MJAPI void mj_defaultOption(mjOption* opt);
+
+// Set visual options to default values.
+MJAPI void mj_defaultVisual(mjVisual* vis);
+
+// Copy mjModel, allocate new if dest is NULL.
+MJAPI mjModel* mj_copyModel(mjModel* dest, const mjModel* src);
+
+// Save model to binary MJB file or memory buffer; buffer has precedence when given.
+MJAPI void mj_saveModel(const mjModel* m, const char* filename, void* buffer, int buffer_sz);
+
+// Load model from binary MJB file.
+// If vfs is not NULL, look up file in vfs before reading from disk.
+MJAPI mjModel* mj_loadModel(const char* filename, const mjVFS* vfs);
+
+// Free memory allocation in model.
+MJAPI void mj_deleteModel(mjModel* m);
+
+// Return size of buffer needed to hold model.
+MJAPI int mj_sizeModel(const mjModel* m);
+
+// Allocate mjData corresponding to given model.
+// If the model buffer is unallocated the initial configuration will not be set.
+MJAPI mjData* mj_makeData(const mjModel* m);
+
+// Copy mjData.
+// m is only required to contain the size fields from MJMODEL_INTS.
+MJAPI mjData* mj_copyData(mjData* dest, const mjModel* m, const mjData* src);
+
+// Reset data to defaults.
+MJAPI void mj_resetData(const mjModel* m, mjData* d);
+
+// Reset data to defaults, fill everything else with debug_value.
+MJAPI void mj_resetDataDebug(const mjModel* m, mjData* d, unsigned char debug_value);
+
+// Reset data, set fields from specified keyframe.
+MJAPI void mj_resetDataKeyframe(const mjModel* m, mjData* d, int key);
+
+// Allocate array of mjtNums on mjData stack. Call mju_error on stack overflow.
+MJAPI mjtNum* mj_stackAlloc(mjData* d, int size);
+
+// Allocate array of ints on mjData stack. Call mju_error on stack overflow.
+MJAPI int* mj_stackAllocInt(mjData* d, int size);
+
+// Free memory allocation in mjData.
+MJAPI void mj_deleteData(mjData* d);
+
+// Reset all callbacks to NULL pointers (NULL is the default).
+MJAPI void mj_resetCallbacks(void);
+
+// Set constant fields of mjModel, corresponding to qpos0 configuration.
+MJAPI void mj_setConst(mjModel* m, mjData* d);
+
+// Set actuator_lengthrange for specified actuator; return 1 if ok, 0 if error.
+MJAPI int mj_setLengthRange(mjModel* m, mjData* d, int index,
+                            const mjLROpt* opt, char* error, int error_sz);
+
+
+//---------------------------------- Printing ------------------------------------------------------
+
+// Print mjModel to text file, specifying format.
+// float_format must be a valid printf-style format string for a single float value.
+MJAPI void mj_printFormattedModel(const mjModel* m, const char* filename, const char* float_format);
+
+// Print model to text file.
+MJAPI void mj_printModel(const mjModel* m, const char* filename);
+
+// Print mjData to text file, specifying format.
+// float_format must be a valid printf-style format string for a single float value
+MJAPI void mj_printFormattedData(const mjModel* m, mjData* d, const char* filename,
+                                 const char* float_format);
+
+// Print data to text file.
+MJAPI void mj_printData(const mjModel* m, mjData* d, const char* filename);
+
+// Print matrix to screen.
+MJAPI void mju_printMat(const mjtNum* mat, int nr, int nc);
+
+// Print sparse matrix to screen.
+MJAPI void mju_printMatSparse(const mjtNum* mat, int nr,
+                              const int* rownnz, const int* rowadr, const int* colind);
+
+
+//---------------------------------- Components ----------------------------------------------------
+
+// Run position-dependent computations.
+MJAPI void mj_fwdPosition(const mjModel* m, mjData* d);
+
+// Run velocity-dependent computations.
+MJAPI void mj_fwdVelocity(const mjModel* m, mjData* d);
+
+// Compute actuator force qfrc_actuator.
+MJAPI void mj_fwdActuation(const mjModel* m, mjData* d);
+
+// Add up all non-constraint forces, compute qacc_smooth.
+MJAPI void mj_fwdAcceleration(const mjModel* m, mjData* d);
+
+// Run selected constraint solver.
+MJAPI void mj_fwdConstraint(const mjModel* m, mjData* d);
+
+// Euler integrator, semi-implicit in velocity.
+MJAPI void mj_Euler(const mjModel* m, mjData* d);
+
+// Runge-Kutta explicit order-N integrator.
+MJAPI void mj_RungeKutta(const mjModel* m, mjData* d, int N);
+
+// Run position-dependent computations in inverse dynamics.
+MJAPI void mj_invPosition(const mjModel* m, mjData* d);
+
+// Run velocity-dependent computations in inverse dynamics.
+MJAPI void mj_invVelocity(const mjModel* m, mjData* d);
+
+// Apply the analytical formula for inverse constraint dynamics.
+MJAPI void mj_invConstraint(const mjModel* m, mjData* d);
+
+// Compare forward and inverse dynamics, save results in fwdinv.
+MJAPI void mj_compareFwdInv(const mjModel* m, mjData* d);
+
+
+//---------------------------------- Sub components ------------------------------------------------
+
+// Evaluate position-dependent sensors.
+MJAPI void mj_sensorPos(const mjModel* m, mjData* d);
+
+// Evaluate velocity-dependent sensors.
+MJAPI void mj_sensorVel(const mjModel* m, mjData* d);
+
+// Evaluate acceleration and force-dependent sensors.
+MJAPI void mj_sensorAcc(const mjModel* m, mjData* d);
+
+// Evaluate position-dependent energy (potential).
+MJAPI void mj_energyPos(const mjModel* m, mjData* d);
+
+// Evaluate velocity-dependent energy (kinetic).
+MJAPI void mj_energyVel(const mjModel* m, mjData* d);
+
+// Check qpos, reset if any element is too big or nan.
+MJAPI void mj_checkPos(const mjModel* m, mjData* d);
+
+// Check qvel, reset if any element is too big or nan.
+MJAPI void mj_checkVel(const mjModel* m, mjData* d);
+
+// Check qacc, reset if any element is too big or nan.
+MJAPI void mj_checkAcc(const mjModel* m, mjData* d);
+
+// Run forward kinematics.
+MJAPI void mj_kinematics(const mjModel* m, mjData* d);
+
+// Map inertias and motion dofs to global frame centered at CoM.
+MJAPI void mj_comPos(const mjModel* m, mjData* d);
+
+// Compute camera and light positions and orientations.
+MJAPI void mj_camlight(const mjModel* m, mjData* d);
+
+// Compute tendon lengths, velocities and moment arms.
+MJAPI void mj_tendon(const mjModel* m, mjData* d);
+
+// Compute actuator transmission lengths and moments.
+MJAPI void mj_transmission(const mjModel* m, mjData* d);
+
+// Run composite rigid body inertia algorithm (CRB).
+MJAPI void mj_crb(const mjModel* m, mjData* d);
+
+// Compute sparse L'*D*L factorizaton of inertia matrix.
+MJAPI void mj_factorM(const mjModel* m, mjData* d);
+
+// Solve linear system M * x = y using factorization:  x = inv(L'*D*L)*y
+MJAPI void mj_solveM(const mjModel* m, mjData* d, mjtNum* x, const mjtNum* y, int n);
+
+// Half of linear solve:  x = sqrt(inv(D))*inv(L')*y
+MJAPI void mj_solveM2(const mjModel* m, mjData* d, mjtNum* x, const mjtNum* y, int n);
+
+// Compute cvel, cdof_dot.
+MJAPI void mj_comVel(const mjModel* m, mjData* d);
+
+// Compute qfrc_passive from spring-dampers, viscosity and density.
+MJAPI void mj_passive(const mjModel* m, mjData* d);
+
+// subtree linear velocity and angular momentum
+MJAPI void mj_subtreeVel(const mjModel* m, mjData* d);
+
+// RNE: compute M(qpos)*qacc + C(qpos,qvel); flg_acc=0 removes inertial term.
+MJAPI void mj_rne(const mjModel* m, mjData* d, int flg_acc, mjtNum* result);
+
+// RNE with complete data: compute cacc, cfrc_ext, cfrc_int.
+MJAPI void mj_rnePostConstraint(const mjModel* m, mjData* d);
+
+// Run collision detection.
+MJAPI void mj_collision(const mjModel* m, mjData* d);
+
+// Construct constraints.
+MJAPI void mj_makeConstraint(const mjModel* m, mjData* d);
+
+// Compute inverse constraint inertia efc_AR.
+MJAPI void mj_projectConstraint(const mjModel* m, mjData* d);
+
+// Compute efc_vel, efc_aref.
+MJAPI void mj_referenceConstraint(const mjModel* m, mjData* d);
+
+// Compute efc_state, efc_force, qfrc_constraint, and (optionally) cone Hessians.
+// If cost is not NULL, set *cost = s(jar) where jar = Jac*qacc-aref.
+MJAPI void mj_constraintUpdate(const mjModel* m, mjData* d, const mjtNum* jar,
+                               mjtNum cost[1], int flg_coneHessian);
+
+
+//---------------------------------- Support -------------------------------------------------------
+
+// Return size of state specification.
+MJAPI int mj_stateSize(const mjModel* m, unsigned int spec);
+
+// Get state.
+MJAPI void mj_getState(const mjModel* m, const mjData* d, mjtNum* state, unsigned int spec);
+
+// Set state.
+MJAPI void mj_setState(const mjModel* m, mjData* d, const mjtNum* state, unsigned int spec);
+
+// Add contact to d->contact list; return 0 if success; 1 if buffer full.
+MJAPI int mj_addContact(const mjModel* m, mjData* d, const mjContact* con);
+
+// Determine type of friction cone.
+MJAPI int mj_isPyramidal(const mjModel* m);
+
+// Determine type of constraint Jacobian.
+MJAPI int mj_isSparse(const mjModel* m);
+
+// Determine type of solver (PGS is dual, CG and Newton are primal).
+MJAPI int mj_isDual(const mjModel* m);
+
+// Multiply dense or sparse constraint Jacobian by vector.
+MJAPI void mj_mulJacVec(const mjModel* m, mjData* d, mjtNum* res, const mjtNum* vec);
+
+// Multiply dense or sparse constraint Jacobian transpose by vector.
+MJAPI void mj_mulJacTVec(const mjModel* m, mjData* d, mjtNum* res, const mjtNum* vec);
+
+// Compute 3/6-by-nv end-effector Jacobian of global point attached to given body.
+MJAPI void mj_jac(const mjModel* m, const mjData* d, mjtNum* jacp, mjtNum* jacr,
+                  const mjtNum point[3], int body);
+
+// Compute body frame end-effector Jacobian.
+MJAPI void mj_jacBody(const mjModel* m, const mjData* d, mjtNum* jacp, mjtNum* jacr, int body);
+
+// Compute body center-of-mass end-effector Jacobian.
+MJAPI void mj_jacBodyCom(const mjModel* m, const mjData* d, mjtNum* jacp, mjtNum* jacr, int body);
+
+// Compute subtree center-of-mass end-effector Jacobian.
+MJAPI void mj_jacSubtreeCom(const mjModel* m, mjData* d, mjtNum* jacp, int body);
+
+// Compute geom end-effector Jacobian.
+MJAPI void mj_jacGeom(const mjModel* m, const mjData* d, mjtNum* jacp, mjtNum* jacr, int geom);
+
+// Compute site end-effector Jacobian.
+MJAPI void mj_jacSite(const mjModel* m, const mjData* d, mjtNum* jacp, mjtNum* jacr, int site);
+
+// Compute translation end-effector Jacobian of point, and rotation Jacobian of axis.
+MJAPI void mj_jacPointAxis(const mjModel* m, mjData* d, mjtNum* jacPoint, mjtNum* jacAxis,
+                           const mjtNum point[3], const mjtNum axis[3], int body);
+
+// Get id of object with the specified mjtObj type and name, returns -1 if id not found.
+MJAPI int mj_name2id(const mjModel* m, int type, const char* name);
+
+// Get name of object with the specified mjtObj type and id, returns NULL if name not found.
+MJAPI const char* mj_id2name(const mjModel* m, int type, int id);
+
+// Convert sparse inertia matrix M into full (i.e. dense) matrix.
+MJAPI void mj_fullM(const mjModel* m, mjtNum* dst, const mjtNum* M);
+
+// Multiply vector by inertia matrix.
+MJAPI void mj_mulM(const mjModel* m, const mjData* d, mjtNum* res, const mjtNum* vec);
+
+// Multiply vector by (inertia matrix)^(1/2).
+MJAPI void mj_mulM2(const mjModel* m, const mjData* d, mjtNum* res, const mjtNum* vec);
+
+// Add inertia matrix to destination matrix.
+// Destination can be sparse uncompressed, or dense when all int* are NULL
+MJAPI void mj_addM(const mjModel* m, mjData* d, mjtNum* dst, int* rownnz, int* rowadr, int* colind);
+
+// Apply Cartesian force and torque (outside xfrc_applied mechanism).
+MJAPI void mj_applyFT(const mjModel* m, mjData* d, const mjtNum force[3], const mjtNum torque[3],
+                      const mjtNum point[3], int body, mjtNum* qfrc_target);
+
+// Compute object 6D velocity (rot:lin) in object-centered frame, world/local orientation.
+MJAPI void mj_objectVelocity(const mjModel* m, const mjData* d,
+                             int objtype, int objid, mjtNum res[6], int flg_local);
+
+// Compute object 6D acceleration (rot:lin) in object-centered frame, world/local orientation.
+MJAPI void mj_objectAcceleration(const mjModel* m, const mjData* d,
+                                 int objtype, int objid, mjtNum res[6], int flg_local);
+
+// Extract 6D force:torque given contact id, in the contact frame.
+MJAPI void mj_contactForce(const mjModel* m, const mjData* d, int id, mjtNum result[6]);
+
+// Compute velocity by finite-differencing two positions.
+MJAPI void mj_differentiatePos(const mjModel* m, mjtNum* qvel, mjtNum dt,
+                               const mjtNum* qpos1, const mjtNum* qpos2);
+
+// Integrate position with given velocity.
+MJAPI void mj_integratePos(const mjModel* m, mjtNum* qpos, const mjtNum* qvel, mjtNum dt);
+
+// Normalize all quaternions in qpos-type vector.
+MJAPI void mj_normalizeQuat(const mjModel* m, mjtNum* qpos);
+
+// Map from body local to global Cartesian coordinates.
+MJAPI void mj_local2Global(mjData* d, mjtNum xpos[3], mjtNum xmat[9], const mjtNum pos[3],
+                           const mjtNum quat[4], int body, mjtByte sameframe);
+
+// Sum all body masses.
+MJAPI mjtNum mj_getTotalmass(const mjModel* m);
+
+// Scale body masses and inertias to achieve specified total mass.
+MJAPI void mj_setTotalmass(mjModel* m, mjtNum newmass);
+
+// Return a config attribute value of a plugin instance;
+// NULL: invalid plugin instance ID or attribute name
+MJAPI const char* mj_getPluginConfig(const mjModel* m, int plugin_id, const char* attrib);
+
+// Load a dynamic library. The dynamic library is assumed to register one or more plugins.
+MJAPI void mj_loadPluginLibrary(const char* path);
+
+// Scan a directory and load all dynamic libraries. Dynamic libraries in the specified directory
+// are assumed to register one or more plugins. Optionally, if a callback is specified, it is called
+// for each dynamic library encountered that registers plugins.
+MJAPI void mj_loadAllPluginLibraries(const char* directory, mjfPluginLibraryLoadCallback callback);
+
+// Return version number: 1.0.2 is encoded as 102.
+MJAPI int mj_version(void);
+
+// Return the current version of MuJoCo as a null-terminated string.
+MJAPI const char* mj_versionString();
+
+
+//---------------------------------- Ray collisions ------------------------------------------------
+
+// Intersect multiple rays emanating from a single point.
+// Similar semantics to mj_ray, but vec is an array of (nray x 3) directions.
+MJAPI void mj_multiRay(const mjModel* m, mjData* d, const mjtNum pnt[3], const mjtNum* vec,
+                       const mjtByte* geomgroup, mjtByte flg_static, int bodyexclude,
+                       int* geomid, mjtNum* dist, int nray, mjtNum cutoff);
+
+// Intersect ray (pnt+x*vec, x>=0) with visible geoms, except geoms in bodyexclude.
+// Return distance (x) to nearest surface, or -1 if no intersection and output geomid.
+// geomgroup, flg_static are as in mjvOption; geomgroup==NULL skips group exclusion.
+MJAPI mjtNum mj_ray(const mjModel* m, const mjData* d, const mjtNum pnt[3], const mjtNum vec[3],
+                    const mjtByte* geomgroup, mjtByte flg_static, int bodyexclude,
+                    int geomid[1]);
+
+// Intersect ray with hfield, return nearest distance or -1 if no intersection.
+MJAPI mjtNum mj_rayHfield(const mjModel* m, const mjData* d, int geomid,
+                          const mjtNum pnt[3], const mjtNum vec[3]);
+
+// Intersect ray with mesh, return nearest distance or -1 if no intersection.
+MJAPI mjtNum mj_rayMesh(const mjModel* m, const mjData* d, int geomid,
+                        const mjtNum pnt[3], const mjtNum vec[3]);
+
+// Intersect ray with pure geom, return nearest distance or -1 if no intersection.
+MJAPI mjtNum mju_rayGeom(const mjtNum pos[3], const mjtNum mat[9], const mjtNum size[3],
+                         const mjtNum pnt[3], const mjtNum vec[3], int geomtype);
+
+// Intersect ray with skin, return nearest distance or -1 if no intersection,
+// and also output nearest vertex id.
+MJAPI mjtNum mju_raySkin(int nface, int nvert, const int* face, const float* vert,
+                         const mjtNum pnt[3], const mjtNum vec[3], int vertid[1]);
+
+
+//---------------------------------- Interaction ---------------------------------------------------
+
+// Set default camera.
+MJAPI void mjv_defaultCamera(mjvCamera* cam);
+
+// Set default free camera.
+MJAPI void mjv_defaultFreeCamera(const mjModel* m, mjvCamera* cam);
+
+// Set default perturbation.
+MJAPI void mjv_defaultPerturb(mjvPerturb* pert);
+
+// Transform pose from room to model space.
+MJAPI void mjv_room2model(mjtNum modelpos[3], mjtNum modelquat[4], const mjtNum roompos[3],
+                          const mjtNum roomquat[4], const mjvScene* scn);
+
+// Transform pose from model to room space.
+MJAPI void mjv_model2room(mjtNum roompos[3], mjtNum roomquat[4], const mjtNum modelpos[3],
+                          const mjtNum modelquat[4], const mjvScene* scn);
+
+// Get camera info in model space; average left and right OpenGL cameras.
+MJAPI void mjv_cameraInModel(mjtNum headpos[3], mjtNum forward[3], mjtNum up[3],
+                             const mjvScene* scn);
+
+// Get camera info in room space; average left and right OpenGL cameras.
+MJAPI void mjv_cameraInRoom(mjtNum headpos[3], mjtNum forward[3], mjtNum up[3],
+                            const mjvScene* scn);
+
+// Get frustum height at unit distance from camera; average left and right OpenGL cameras.
+MJAPI mjtNum mjv_frustumHeight(const mjvScene* scn);
+
+// Rotate 3D vec in horizontal plane by angle between (0,1) and (forward_x,forward_y).
+MJAPI void mjv_alignToCamera(mjtNum res[3], const mjtNum vec[3], const mjtNum forward[3]);
+
+// Move camera with mouse; action is mjtMouse.
+MJAPI void mjv_moveCamera(const mjModel* m, int action, mjtNum reldx, mjtNum reldy,
+                          const mjvScene* scn, mjvCamera* cam);
+
+// Move camera with mouse given a scene state; action is mjtMouse.
+MJAPI void mjv_moveCameraFromState(const mjvSceneState* scnstate, int action,
+                                   mjtNum reldx, mjtNum reldy,
+                                   const mjvScene* scn, mjvCamera* cam);
+
+// Move perturb object with mouse; action is mjtMouse.
+MJAPI void mjv_movePerturb(const mjModel* m, const mjData* d, int action, mjtNum reldx,
+                           mjtNum reldy, const mjvScene* scn, mjvPerturb* pert);
+
+// Move perturb object with mouse given a scene state; action is mjtMouse.
+MJAPI void mjv_movePerturbFromState(const mjvSceneState* scnstate, int action,
+                                    mjtNum reldx, mjtNum reldy,
+                                    const mjvScene* scn, mjvPerturb* pert);
+
+// Move model with mouse; action is mjtMouse.
+MJAPI void mjv_moveModel(const mjModel* m, int action, mjtNum reldx, mjtNum reldy,
+                         const mjtNum roomup[3], mjvScene* scn);
+
+// Copy perturb pos,quat from selected body; set scale for perturbation.
+MJAPI void mjv_initPerturb(const mjModel* m, mjData* d, const mjvScene* scn, mjvPerturb* pert);
+
+// Set perturb pos,quat in d->mocap when selected body is mocap, and in d->qpos otherwise.
+// Write d->qpos only if flg_paused and subtree root for selected body has free joint.
+MJAPI void mjv_applyPerturbPose(const mjModel* m, mjData* d, const mjvPerturb* pert,
+                                int flg_paused);
+
+// Set perturb force,torque in d->xfrc_applied, if selected body is dynamic.
+MJAPI void mjv_applyPerturbForce(const mjModel* m, mjData* d, const mjvPerturb* pert);
+
+// Return the average of two OpenGL cameras.
+MJAPI mjvGLCamera mjv_averageCamera(const mjvGLCamera* cam1, const mjvGLCamera* cam2);
+
+// Select geom or skin with mouse, return bodyid; -1: none selected.
+MJAPI int mjv_select(const mjModel* m, const mjData* d, const mjvOption* vopt,
+                     mjtNum aspectratio, mjtNum relx, mjtNum rely,
+                     const mjvScene* scn, mjtNum selpnt[3], int geomid[1], int skinid[1]);
+
+
+//---------------------------------- Visualization -------------------------------------------------
+
+// Set default visualization options.
+MJAPI void mjv_defaultOption(mjvOption* opt);
+
+// Set default figure.
+MJAPI void mjv_defaultFigure(mjvFigure* fig);
+
+// Initialize given geom fields when not NULL, set the rest to their default values.
+MJAPI void mjv_initGeom(mjvGeom* geom, int type, const mjtNum size[3],
+                        const mjtNum pos[3], const mjtNum mat[9], const float rgba[4]);
+
+// Set (type, size, pos, mat) for connector-type geom between given points.
+// Assume that mjv_initGeom was already called to set all other properties.
+// Width of mjGEOM_LINE is denominated in pixels.
+// Deprecated: use mjv_connector.
+MJAPI void mjv_makeConnector(mjvGeom* geom, int type, mjtNum width,
+                             mjtNum a0, mjtNum a1, mjtNum a2,
+                             mjtNum b0, mjtNum b1, mjtNum b2);
+
+// Set (type, size, pos, mat) for connector-type geom between given points.
+// Assume that mjv_initGeom was already called to set all other properties.
+// Width of mjGEOM_LINE is denominated in pixels.
+MJAPI void mjv_connector(mjvGeom* geom, int type, mjtNum width,
+                         const mjtNum from[3], const mjtNum to[3]);
+
+// Set default abstract scene.
+MJAPI void mjv_defaultScene(mjvScene* scn);
+
+// Allocate resources in abstract scene.
+MJAPI void mjv_makeScene(const mjModel* m, mjvScene* scn, int maxgeom);
+
+// Free abstract scene.
+MJAPI void mjv_freeScene(mjvScene* scn);
+
+// Update entire scene given model state.
+MJAPI void mjv_updateScene(const mjModel* m, mjData* d, const mjvOption* opt,
+                           const mjvPerturb* pert, mjvCamera* cam, int catmask, mjvScene* scn);
+
+// Update entire scene from a scene state, return the number of new mjWARN_VGEOMFULL warnings.
+MJAPI int mjv_updateSceneFromState(const mjvSceneState* scnstate, const mjvOption* opt,
+                                   const mjvPerturb* pert, mjvCamera* cam, int catmask,
+                                   mjvScene* scn);
+
+// Set default scene state.
+MJAPI void mjv_defaultSceneState(mjvSceneState* scnstate);
+
+// Allocate resources and initialize a scene state object.
+MJAPI void mjv_makeSceneState(const mjModel* m, const mjData* d,
+                              mjvSceneState* scnstate, int maxgeom);
+
+// Free scene state.
+MJAPI void mjv_freeSceneState(mjvSceneState* scnstate);
+
+// Update a scene state from model and data.
+MJAPI void mjv_updateSceneState(const mjModel* m, mjData* d, const mjvOption* opt,
+                                mjvSceneState* scnstate);
+
+// Add geoms from selected categories.
+MJAPI void mjv_addGeoms(const mjModel* m, mjData* d, const mjvOption* opt,
+                        const mjvPerturb* pert, int catmask, mjvScene* scn);
+
+// Make list of lights.
+MJAPI void mjv_makeLights(const mjModel* m, mjData* d, mjvScene* scn);
+
+// Update camera.
+MJAPI void mjv_updateCamera(const mjModel* m, mjData* d, mjvCamera* cam, mjvScene* scn);
+
+// Update skins.
+MJAPI void mjv_updateSkin(const mjModel* m, mjData* d, mjvScene* scn);
+
+
+//---------------------------------- OpenGL rendering ----------------------------------------------
+
+// Set default mjrContext.
+MJAPI void mjr_defaultContext(mjrContext* con);
+
+// Allocate resources in custom OpenGL context; fontscale is mjtFontScale.
+MJAPI void mjr_makeContext(const mjModel* m, mjrContext* con, int fontscale);
+
+// Change font of existing context.
+MJAPI void mjr_changeFont(int fontscale, mjrContext* con);
+
+// Add Aux buffer with given index to context; free previous Aux buffer.
+MJAPI void mjr_addAux(int index, int width, int height, int samples, mjrContext* con);
+
+// Free resources in custom OpenGL context, set to default.
+MJAPI void mjr_freeContext(mjrContext* con);
+
+// Resize offscreen buffers.
+MJAPI void mjr_resizeOffscreen(int width, int height, mjrContext* con);
+
+// Upload texture to GPU, overwriting previous upload if any.
+MJAPI void mjr_uploadTexture(const mjModel* m, const mjrContext* con, int texid);
+
+// Upload mesh to GPU, overwriting previous upload if any.
+MJAPI void mjr_uploadMesh(const mjModel* m, const mjrContext* con, int meshid);
+
+// Upload height field to GPU, overwriting previous upload if any.
+MJAPI void mjr_uploadHField(const mjModel* m, const mjrContext* con, int hfieldid);
+
+// Make con->currentBuffer current again.
+MJAPI void mjr_restoreBuffer(const mjrContext* con);
+
+// Set OpenGL framebuffer for rendering: mjFB_WINDOW or mjFB_OFFSCREEN.
+// If only one buffer is available, set that buffer and ignore framebuffer argument.
+MJAPI void mjr_setBuffer(int framebuffer, mjrContext* con);
+
+// Read pixels from current OpenGL framebuffer to client buffer.
+// Viewport is in OpenGL framebuffer; client buffer starts at (0,0).
+MJAPI void mjr_readPixels(unsigned char* rgb, float* depth,
+                          mjrRect viewport, const mjrContext* con);
+
+// Draw pixels from client buffer to current OpenGL framebuffer.
+// Viewport is in OpenGL framebuffer; client buffer starts at (0,0).
+MJAPI void mjr_drawPixels(const unsigned char* rgb, const float* depth,
+                          mjrRect viewport, const mjrContext* con);
+
+// Blit from src viewpoint in current framebuffer to dst viewport in other framebuffer.
+// If src, dst have different size and flg_depth==0, color is interpolated with GL_LINEAR.
+MJAPI void mjr_blitBuffer(mjrRect src, mjrRect dst,
+                          int flg_color, int flg_depth, const mjrContext* con);
+
+// Set Aux buffer for custom OpenGL rendering (call restoreBuffer when done).
+MJAPI void mjr_setAux(int index, const mjrContext* con);
+
+// Blit from Aux buffer to con->currentBuffer.
+MJAPI void mjr_blitAux(int index, mjrRect src, int left, int bottom, const mjrContext* con);
+
+// Draw text at (x,y) in relative coordinates; font is mjtFont.
+MJAPI void mjr_text(int font, const char* txt, const mjrContext* con,
+                    float x, float y, float r, float g, float b);
+
+// Draw text overlay; font is mjtFont; gridpos is mjtGridPos.
+MJAPI void mjr_overlay(int font, int gridpos, mjrRect viewport,
+                       const char* overlay, const char* overlay2, const mjrContext* con);
+
+// Get maximum viewport for active buffer.
+MJAPI mjrRect mjr_maxViewport(const mjrContext* con);
+
+// Draw rectangle.
+MJAPI void mjr_rectangle(mjrRect viewport, float r, float g, float b, float a);
+
+// Draw rectangle with centered text.
+MJAPI void mjr_label(mjrRect viewport, int font, const char* txt,
+                     float r, float g, float b, float a, float rt, float gt, float bt,
+                     const mjrContext* con);
+
+// Draw 2D figure.
+MJAPI void mjr_figure(mjrRect viewport, mjvFigure* fig, const mjrContext* con);
+
+// Render 3D scene.
+MJAPI void mjr_render(mjrRect viewport, mjvScene* scn, const mjrContext* con);
+
+// Call glFinish.
+MJAPI void mjr_finish(void);
+
+// Call glGetError and return result.
+MJAPI int mjr_getError(void);
+
+// Find first rectangle containing mouse, -1: not found.
+MJAPI int mjr_findRect(int x, int y, int nrect, const mjrRect* rect);
+
+
+//---------------------------------- UI framework --------------------------------------------------
+
+// Get builtin UI theme spacing (ind: 0-1).
+MJAPI mjuiThemeSpacing mjui_themeSpacing(int ind);
+
+// Get builtin UI theme color (ind: 0-3).
+MJAPI mjuiThemeColor mjui_themeColor(int ind);
+
+// Add definitions to UI.
+MJAPI void mjui_add(mjUI* ui, const mjuiDef* def);
+
+// Add definitions to UI section.
+MJAPI void mjui_addToSection(mjUI* ui, int sect, const mjuiDef* def);
+
+// Compute UI sizes.
+MJAPI void mjui_resize(mjUI* ui, const mjrContext* con);
+
+// Update specific section/item; -1: update all.
+MJAPI void mjui_update(int section, int item, const mjUI* ui,
+                       const mjuiState* state, const mjrContext* con);
+
+// Handle UI event, return pointer to changed item, NULL if no change.
+MJAPI mjuiItem* mjui_event(mjUI* ui, mjuiState* state, const mjrContext* con);
+
+// Copy UI image to current buffer.
+MJAPI void mjui_render(mjUI* ui, const mjuiState* state, const mjrContext* con);
+
+
+//---------------------------------- Error and memory ----------------------------------------------
+
+// Main error function; does not return to caller.
+MJAPI void mju_error(const char* msg, ...) mjPRINTFLIKE(1, 2);
+
+// Deprecated: use mju_error.
+MJAPI void mju_error_i(const char* msg, int i);
+
+// Deprecated: use mju_error.
+MJAPI void mju_error_s(const char* msg, const char* text);
+
+// Main warning function; returns to caller.
+MJAPI void mju_warning(const char* msg, ...) mjPRINTFLIKE(1, 2);
+
+// Deprecated: use mju_warning.
+MJAPI void mju_warning_i(const char* msg, int i);
+
+// Deprecated: use mju_warning.
+MJAPI void mju_warning_s(const char* msg, const char* text);
+
+// Clear user error and memory handlers.
+MJAPI void mju_clearHandlers(void);
+
+// Allocate memory; byte-align on 64; pad size to multiple of 64.
+MJAPI void* mju_malloc(size_t size);
+
+// Free memory, using free() by default.
+MJAPI void mju_free(void* ptr);
+
+// High-level warning function: count warnings in mjData, print only the first.
+MJAPI void mj_warning(mjData* d, int warning, int info);
+
+// Write [datetime, type: message] to MUJOCO_LOG.TXT.
+MJAPI void mju_writeLog(const char* type, const char* msg);
+
+
+//---------------------------------- Standard math -------------------------------------------------
+
+#ifdef mjUSEDOUBLE
+  #define mju_sqrt    sqrt
+  #define mju_exp     exp
+  #define mju_sin     sin
+  #define mju_cos     cos
+  #define mju_tan     tan
+  #define mju_asin    asin
+  #define mju_acos    acos
+  #define mju_atan2   atan2
+  #define mju_tanh    tanh
+  #define mju_pow     pow
+  #define mju_abs     fabs
+  #define mju_log     log
+  #define mju_log10   log10
+  #define mju_floor   floor
+  #define mju_ceil    ceil
+
+#else
+  #define mju_sqrt    sqrtf
+  #define mju_exp     expf
+  #define mju_sin     sinf
+  #define mju_cos     cosf
+  #define mju_tan     tanf
+  #define mju_asin    asinf
+  #define mju_acos    acosf
+  #define mju_atan2   atan2f
+  #define mju_tanh    tanhf
+  #define mju_pow     powf
+  #define mju_abs     fabsf
+  #define mju_log     logf
+  #define mju_log10   log10f
+  #define mju_floor   floorf
+  #define mju_ceil    ceilf
+#endif
+
+
+//---------------------------------- Vector math ---------------------------------------------------
+
+// Set res = 0.
+MJAPI void mju_zero3(mjtNum res[3]);
+
+// Set res = vec.
+MJAPI void mju_copy3(mjtNum res[3], const mjtNum data[3]);
+
+// Set res = vec*scl.
+MJAPI void mju_scl3(mjtNum res[3], const mjtNum vec[3], mjtNum scl);
+
+// Set res = vec1 + vec2.
+MJAPI void mju_add3(mjtNum res[3], const mjtNum vec1[3], const mjtNum vec2[3]);
+
+// Set res = vec1 - vec2.
+MJAPI void mju_sub3(mjtNum res[3], const mjtNum vec1[3], const mjtNum vec2[3]);
+
+// Set res = res + vec.
+MJAPI void mju_addTo3(mjtNum res[3], const mjtNum vec[3]);
+
+// Set res = res - vec.
+MJAPI void mju_subFrom3(mjtNum res[3], const mjtNum vec[3]);
+
+// Set res = res + vec*scl.
+MJAPI void mju_addToScl3(mjtNum res[3], const mjtNum vec[3], mjtNum scl);
+
+// Set res = vec1 + vec2*scl.
+MJAPI void mju_addScl3(mjtNum res[3], const mjtNum vec1[3], const mjtNum vec2[3], mjtNum scl);
+
+// Normalize vector, return length before normalization.
+MJAPI mjtNum mju_normalize3(mjtNum res[3]);
+
+// Return vector length (without normalizing the vector).
+MJAPI mjtNum mju_norm3(const mjtNum vec[3]);
+
+// Return dot-product of vec1 and vec2.
+MJAPI mjtNum mju_dot3(const mjtNum vec1[3], const mjtNum vec2[3]);
+
+// Return Cartesian distance between 3D vectors pos1 and pos2.
+MJAPI mjtNum mju_dist3(const mjtNum pos1[3], const mjtNum pos2[3]);
+
+// Multiply vector by 3D rotation matrix: res = mat * vec.
+MJAPI void mju_rotVecMat(mjtNum res[3], const mjtNum vec[3], const mjtNum mat[9]);
+
+// Multiply vector by transposed 3D rotation matrix: res = mat' * vec.
+MJAPI void mju_rotVecMatT(mjtNum res[3], const mjtNum vec[3], const mjtNum mat[9]);
+
+// Compute cross-product: res = cross(a, b).
+MJAPI void mju_cross(mjtNum res[3], const mjtNum a[3], const mjtNum b[3]);
+
+// Set res = 0.
+MJAPI void mju_zero4(mjtNum res[4]);
+
+// Set res = (1,0,0,0).
+MJAPI void mju_unit4(mjtNum res[4]);
+
+// Set res = vec.
+MJAPI void mju_copy4(mjtNum res[4], const mjtNum data[4]);
+
+// Normalize vector, return length before normalization.
+MJAPI mjtNum mju_normalize4(mjtNum res[4]);
+
+// Set res = 0.
+MJAPI void mju_zero(mjtNum* res, int n);
+
+// Set res = val.
+MJAPI void mju_fill(mjtNum* res, mjtNum val, int n);
+
+// Set res = vec.
+MJAPI void mju_copy(mjtNum* res, const mjtNum* data, int n);
+
+// Return sum(vec).
+MJAPI mjtNum mju_sum(const mjtNum* vec, int n);
+
+// Return L1 norm: sum(abs(vec)).
+MJAPI mjtNum mju_L1(const mjtNum* vec, int n);
+
+// Set res = vec*scl.
+MJAPI void mju_scl(mjtNum* res, const mjtNum* vec, mjtNum scl, int n);
+
+// Set res = vec1 + vec2.
+MJAPI void mju_add(mjtNum* res, const mjtNum* vec1, const mjtNum* vec2, int n);
+
+// Set res = vec1 - vec2.
+MJAPI void mju_sub(mjtNum* res, const mjtNum* vec1, const mjtNum* vec2, int n);
+
+// Set res = res + vec.
+MJAPI void mju_addTo(mjtNum* res, const mjtNum* vec, int n);
+
+// Set res = res - vec.
+MJAPI void mju_subFrom(mjtNum* res, const mjtNum* vec, int n);
+
+// Set res = res + vec*scl.
+MJAPI void mju_addToScl(mjtNum* res, const mjtNum* vec, mjtNum scl, int n);
+
+// Set res = vec1 + vec2*scl.
+MJAPI void mju_addScl(mjtNum* res, const mjtNum* vec1, const mjtNum* vec2, mjtNum scl, int n);
+
+// Normalize vector, return length before normalization.
+MJAPI mjtNum mju_normalize(mjtNum* res, int n);
+
+// Return vector length (without normalizing vector).
+MJAPI mjtNum mju_norm(const mjtNum* res, int n);
+
+// Return dot-product of vec1 and vec2.
+MJAPI mjtNum mju_dot(const mjtNum* vec1, const mjtNum* vec2, int n);
+
+// Multiply matrix and vector: res = mat * vec.
+MJAPI void mju_mulMatVec(mjtNum* res, const mjtNum* mat, const mjtNum* vec, int nr, int nc);
+
+// Multiply transposed matrix and vector: res = mat' * vec.
+MJAPI void mju_mulMatTVec(mjtNum* res, const mjtNum* mat, const mjtNum* vec, int nr, int nc);
+
+// Multiply square matrix with vectors on both sides: returns vec1' * mat * vec2.
+MJAPI mjtNum mju_mulVecMatVec(const mjtNum* vec1, const mjtNum* mat, const mjtNum* vec2, int n);
+
+// Transpose matrix: res = mat'.
+MJAPI void mju_transpose(mjtNum* res, const mjtNum* mat, int nr, int nc);
+
+// Symmetrize square matrix res = (mat + mat')/2.
+MJAPI void mju_symmetrize(mjtNum* res, const mjtNum* mat, int n);
+
+// Set mat to the identity matrix.
+MJAPI void mju_eye(mjtNum* mat, int n);
+
+// Multiply matrices: res = mat1 * mat2.
+MJAPI void mju_mulMatMat(mjtNum* res, const mjtNum* mat1, const mjtNum* mat2,
+                         int r1, int c1, int c2);
+
+// Multiply matrices, second argument transposed: res = mat1 * mat2'.
+MJAPI void mju_mulMatMatT(mjtNum* res, const mjtNum* mat1, const mjtNum* mat2,
+                          int r1, int c1, int r2);
+
+// Multiply matrices, first argument transposed: res = mat1' * mat2.
+MJAPI void mju_mulMatTMat(mjtNum* res, const mjtNum* mat1, const mjtNum* mat2,
+                          int r1, int c1, int c2);
+
+// Set res = mat' * diag * mat if diag is not NULL, and res = mat' * mat otherwise.
+MJAPI void mju_sqrMatTD(mjtNum* res, const mjtNum* mat, const mjtNum* diag, int nr, int nc);
+
+// Coordinate transform of 6D motion or force vector in rotation:translation format.
+// rotnew2old is 3-by-3, NULL means no rotation; flg_force specifies force or motion type.
+MJAPI void mju_transformSpatial(mjtNum res[6], const mjtNum vec[6], int flg_force,
+                                const mjtNum newpos[3], const mjtNum oldpos[3],
+                                const mjtNum rotnew2old[9]);
+
+
+//---------------------------------- Quaternions ---------------------------------------------------
+
+// Rotate vector by quaternion.
+MJAPI void mju_rotVecQuat(mjtNum res[3], const mjtNum vec[3], const mjtNum quat[4]);
+
+// Conjugate quaternion, corresponding to opposite rotation.
+MJAPI void mju_negQuat(mjtNum res[4], const mjtNum quat[4]);
+
+// Multiply quaternions.
+MJAPI void mju_mulQuat(mjtNum res[4], const mjtNum quat1[4], const mjtNum quat2[4]);
+
+// Multiply quaternion and axis.
+MJAPI void mju_mulQuatAxis(mjtNum res[4], const mjtNum quat[4], const mjtNum axis[3]);
+
+// Convert axisAngle to quaternion.
+MJAPI void mju_axisAngle2Quat(mjtNum res[4], const mjtNum axis[3], mjtNum angle);
+
+// Convert quaternion (corresponding to orientation difference) to 3D velocity.
+MJAPI void mju_quat2Vel(mjtNum res[3], const mjtNum quat[4], mjtNum dt);
+
+// Subtract quaternions, express as 3D velocity: qb*quat(res) = qa.
+MJAPI void mju_subQuat(mjtNum res[3], const mjtNum qa[4], const mjtNum qb[4]);
+
+// Convert quaternion to 3D rotation matrix.
+MJAPI void mju_quat2Mat(mjtNum res[9], const mjtNum quat[4]);
+
+// Convert 3D rotation matrix to quaternion.
+MJAPI void mju_mat2Quat(mjtNum quat[4], const mjtNum mat[9]);
+
+// Compute time-derivative of quaternion, given 3D rotational velocity.
+MJAPI void mju_derivQuat(mjtNum res[4], const mjtNum quat[4], const mjtNum vel[3]);
+
+// Integrate quaternion given 3D angular velocity.
+MJAPI void mju_quatIntegrate(mjtNum quat[4], const mjtNum vel[3], mjtNum scale);
+
+// Construct quaternion performing rotation from z-axis to given vector.
+MJAPI void mju_quatZ2Vec(mjtNum quat[4], const mjtNum vec[3]);
+
+
+//---------------------------------- Poses ---------------------------------------------------------
+
+// Multiply two poses.
+MJAPI void mju_mulPose(mjtNum posres[3], mjtNum quatres[4],
+                       const mjtNum pos1[3], const mjtNum quat1[4],
+                       const mjtNum pos2[3], const mjtNum quat2[4]);
+
+// Conjugate pose, corresponding to the opposite spatial transformation.
+MJAPI void mju_negPose(mjtNum posres[3], mjtNum quatres[4],
+                       const mjtNum pos[3], const mjtNum quat[4]);
+
+// Transform vector by pose.
+MJAPI void mju_trnVecPose(mjtNum res[3], const mjtNum pos[3], const mjtNum quat[4],
+                          const mjtNum vec[3]);
+
+
+//--------------------------------- Decompositions / Solvers ---------------------------------------
+
+// Cholesky decomposition: mat = L*L'; return rank, decomposition performed in-place into mat.
+MJAPI int mju_cholFactor(mjtNum* mat, int n, mjtNum mindiag);
+
+// Solve (mat*mat') * res = vec, where mat is a Cholesky factor.
+MJAPI void mju_cholSolve(mjtNum* res, const mjtNum* mat, const mjtNum* vec, int n);
+
+// Cholesky rank-one update: L*L' +/- x*x'; return rank.
+MJAPI int mju_cholUpdate(mjtNum* mat, mjtNum* x, int n, int flg_plus);
+
+// Band-dense Cholesky decomposition.
+//  Returns minimum value in the factorized diagonal, or 0 if rank-deficient.
+//  mat has (ntotal-ndense) x nband + ndense x ntotal elements.
+//  The first (ntotal-ndense) x nband store the band part, left of diagonal, inclusive.
+//  The second ndense x ntotal store the band part as entire dense rows.
+//  Add diagadd+diagmul*mat_ii to diagonal before factorization.
+MJAPI mjtNum mju_cholFactorBand(mjtNum* mat, int ntotal, int nband, int ndense,
+                                mjtNum diagadd, mjtNum diagmul);
+
+// Solve (mat*mat')*res = vec where mat is a band-dense Cholesky factor.
+MJAPI void mju_cholSolveBand(mjtNum* res, const mjtNum* mat, const mjtNum* vec,
+                             int ntotal, int nband, int ndense);
+
+// Convert banded matrix to dense matrix, fill upper triangle if flg_sym>0.
+MJAPI void mju_band2Dense(mjtNum* res, const mjtNum* mat, int ntotal, int nband, int ndense,
+                          mjtByte flg_sym);
+
+// Convert dense matrix to banded matrix.
+MJAPI void mju_dense2Band(mjtNum* res, const mjtNum* mat, int ntotal, int nband, int ndense);
+
+// Multiply band-diagonal matrix with nvec vectors, include upper triangle if flg_sym>0.
+MJAPI void mju_bandMulMatVec(mjtNum* res, const mjtNum* mat, const mjtNum* vec,
+                             int ntotal, int nband, int ndense, int nvec, mjtByte flg_sym);
+
+// Address of diagonal element i in band-dense matrix representation.
+MJAPI int mju_bandDiag(int i, int ntotal, int nband, int ndense);
+
+// Eigenvalue decomposition of symmetric 3x3 matrix.
+MJAPI int mju_eig3(mjtNum eigval[3], mjtNum eigvec[9], mjtNum quat[4], const mjtNum mat[9]);
+
+// minimize 0.5*x'*H*x + x'*g  s.t. lower <= x <= upper, return rank or -1 if failed
+//   inputs:
+//     n           - problem dimension
+//     H           - SPD matrix                n*n
+//     g           - bias vector               n
+//     lower       - lower bounds              n
+//     upper       - upper bounds              n
+//     res         - solution warmstart        n
+//   return value:
+//     nfree <= n  - rank of unconstrained subspace, -1 if failure
+//   outputs (required):
+//     res         - solution                  n
+//     R           - subspace Cholesky factor  nfree*nfree    allocated: n*(n+7)
+//   outputs (optional):
+//     index       - set of free dimensions    nfree          allocated: n
+//   notes:
+//     the initial value of res is used to warmstart the solver
+//     R must have allocatd size n*(n+7), but only nfree*nfree values are used in output
+//     index (if given) must have allocated size n, but only nfree values are used in output
+//     only the lower triangles of H and R and are read from and written to, respectively
+//     the convenience function mju_boxQPmalloc allocates the required data structures
+MJAPI int mju_boxQP(mjtNum* res, mjtNum* R, int* index, const mjtNum* H, const mjtNum* g, int n,
+                    const mjtNum* lower, const mjtNum* upper);
+
+// allocate heap memory for box-constrained Quadratic Program
+//   as in mju_boxQP, index, lower, and upper are optional
+//   free all pointers with mju_free()
+MJAPI void mju_boxQPmalloc(mjtNum** res, mjtNum** R, int** index, mjtNum** H, mjtNum** g, int n,
+                           mjtNum** lower, mjtNum** upper);
+
+//---------------------- Miscellaneous -------------------------------------------------------------
+
+// Muscle active force, prm = (range[2], force, scale, lmin, lmax, vmax, fpmax, fvmax).
+MJAPI mjtNum mju_muscleGain(mjtNum len, mjtNum vel, const mjtNum lengthrange[2],
+                            mjtNum acc0, const mjtNum prm[9]);
+
+// Muscle passive force, prm = (range[2], force, scale, lmin, lmax, vmax, fpmax, fvmax).
+MJAPI mjtNum mju_muscleBias(mjtNum len, const mjtNum lengthrange[2],
+                            mjtNum acc0, const mjtNum prm[9]);
+
+// Muscle activation dynamics, prm = (tau_act, tau_deact, smoothing_width).
+MJAPI mjtNum mju_muscleDynamics(mjtNum ctrl, mjtNum act, const mjtNum prm[3]);
+
+// Convert contact force to pyramid representation.
+MJAPI void mju_encodePyramid(mjtNum* pyramid, const mjtNum* force, const mjtNum* mu, int dim);
+
+// Convert pyramid representation to contact force.
+MJAPI void mju_decodePyramid(mjtNum* force, const mjtNum* pyramid, const mjtNum* mu, int dim);
+
+// Integrate spring-damper analytically, return pos(dt).
+MJAPI mjtNum mju_springDamper(mjtNum pos0, mjtNum vel0, mjtNum Kp, mjtNum Kv, mjtNum dt);
+
+// Return min(a,b) with single evaluation of a and b.
+MJAPI mjtNum mju_min(mjtNum a, mjtNum b);
+
+// Return max(a,b) with single evaluation of a and b.
+MJAPI mjtNum mju_max(mjtNum a, mjtNum b);
+
+// Clip x to the range [min, max].
+MJAPI mjtNum mju_clip(mjtNum x, mjtNum min, mjtNum max);
+
+// Return sign of x: +1, -1 or 0.
+MJAPI mjtNum mju_sign(mjtNum x);
+
+// Round x to nearest integer.
+MJAPI int mju_round(mjtNum x);
+
+// Convert type id (mjtObj) to type name.
+MJAPI const char* mju_type2Str(int type);
+
+// Convert type name to type id (mjtObj).
+MJAPI int mju_str2Type(const char* str);
+
+// Return human readable number of bytes using standard letter suffix.
+MJAPI const char* mju_writeNumBytes(size_t nbytes);
+
+// Construct a warning message given the warning type and info.
+MJAPI const char* mju_warningText(int warning, size_t info);
+
+// Return 1 if nan or abs(x)>mjMAXVAL, 0 otherwise. Used by check functions.
+MJAPI int mju_isBad(mjtNum x);
+
+// Return 1 if all elements are 0.
+MJAPI int mju_isZero(mjtNum* vec, int n);
+
+// Standard normal random number generator (optional second number).
+MJAPI mjtNum mju_standardNormal(mjtNum* num2);
+
+// Convert from float to mjtNum.
+MJAPI void mju_f2n(mjtNum* res, const float* vec, int n);
+
+// Convert from mjtNum to float.
+MJAPI void mju_n2f(float* res, const mjtNum* vec, int n);
+
+// Convert from double to mjtNum.
+MJAPI void mju_d2n(mjtNum* res, const double* vec, int n);
+
+// Convert from mjtNum to double.
+MJAPI void mju_n2d(double* res, const mjtNum* vec, int n);
+
+// Insertion sort, resulting list is in increasing order.
+MJAPI void mju_insertionSort(mjtNum* list, int n);
+
+// Integer insertion sort, resulting list is in increasing order.
+MJAPI void mju_insertionSortInt(int* list, int n);
+
+// Generate Halton sequence.
+MJAPI mjtNum mju_Halton(int index, int base);
+
+// Call strncpy, then set dst[n-1] = 0.
+MJAPI char* mju_strncpy(char *dst, const char *src, int n);
+
+// Sigmoid function over 0<=x<=1 using quintic polynomial.
+MJAPI mjtNum mju_sigmoid(mjtNum x);
+
+
+//---------------------- Derivatives ---------------------------------------------------------------
+
+// Finite differenced transition matrices (control theory notation)
+//   d(x_next) = A*dx + B*du
+//   d(sensor) = C*dx + D*du
+//   required output matrix dimensions:
+//      A: (2*nv+na x 2*nv+na)
+//      B: (2*nv+na x nu)
+//      D: (nsensordata x 2*nv+na)
+//      C: (nsensordata x nu)
+MJAPI void mjd_transitionFD(const mjModel* m, mjData* d, mjtNum eps, mjtByte flg_centered,
+                            mjtNum* A, mjtNum* B, mjtNum* C, mjtNum* D);
+
+// Finite differenced Jacobians of (force, sensors) = mj_inverse(state, acceleration)
+//   All outputs are optional. Output dimensions (transposed w.r.t Control Theory convention):
+//     DfDq: (nv x nv)
+//     DfDv: (nv x nv)
+//     DfDa: (nv x nv)
+//     DsDq: (nv x nsensordata)
+//     DsDv: (nv x nsensordata)
+//     DsDa: (nv x nsensordata)
+//     DmDq: (nv x nM)
+//   single-letter shortcuts:
+//     inputs: q=qpos, v=qvel, a=qacc
+//     outputs: f=qfrc_inverse, s=sensordata, m=qM
+//   notes:
+//     optionally computes mass matrix Jacobian DmDq
+//     flg_actuation specifies whether to subtract qfrc_actuator from qfrc_inverse
+MJAPI void mjd_inverseFD(const mjModel* m, mjData* d, mjtNum eps, mjtByte flg_actuation,
+                         mjtNum *DfDq, mjtNum *DfDv, mjtNum *DfDa,
+                         mjtNum *DsDq, mjtNum *DsDv, mjtNum *DsDa,
+                         mjtNum *DmDq);
+
+// Derivatives of mju_subQuat.
+MJAPI void mjd_subQuat(const mjtNum qa[4], const mjtNum qb[4], mjtNum Da[9], mjtNum Db[9]);
+
+// Derivatives of mju_quatIntegrate.
+MJAPI void mjd_quatIntegrate(const mjtNum vel[3], mjtNum scale,
+                             mjtNum Dquat[9], mjtNum Dvel[9], mjtNum Dscale[3]);
+
+//---------------------- Plugins -------------------------------------------------------------------
+
+// Set default plugin definition.
+MJAPI void mjp_defaultPlugin(mjpPlugin* plugin);
+
+// Globally register a plugin. This function is thread-safe.
+// If an identical mjpPlugin is already registered, this function does nothing.
+// If a non-identical mjpPlugin with the same name is already registered, an mju_error is raised.
+// Two mjpPlugins are considered identical if all member function pointers and numbers are equal,
+// and the name and attribute strings are all identical, however the char pointers to the strings
+// need not be the same.
+MJAPI int mjp_registerPlugin(const mjpPlugin* plugin);
+
+// Return the number of globally registered plugins.
+MJAPI int mjp_pluginCount();
+
+// Look up a plugin by name. If slot is not NULL, also write its registered slot number into it.
+MJAPI const mjpPlugin* mjp_getPlugin(const char* name, int* slot);
+
+// Look up a plugin by the registered slot number that was returned by mjp_registerPlugin.
+MJAPI const mjpPlugin* mjp_getPluginAtSlot(int slot);
+
+// Set default resource provider definition.
+MJAPI void mjp_defaultResourceProvider(mjpResourceProvider* provider);
+
+// Globally register a resource provider in a thread-safe manner. The provider must have a prefix
+// that is not a sub-prefix or super-prefix of any current registered providers.  This function
+// returns a slot number > 0 on success.
+MJAPI int mjp_registerResourceProvider(const mjpResourceProvider* provider);
+
+// Return the number of globally registered resource providers.
+MJAPI int mjp_resourceProviderCount();
+
+// Return the resource provider with the prefix that matches against the resource name.
+// If no match, return NULL.
+MJAPI const mjpResourceProvider* mjp_getResourceProvider(const char* resource_name);
+
+// Look up a resource provider by slot number returned by mjp_registerResourceProvider.
+// If invalid slot number, return NULL.
+MJAPI const mjpResourceProvider* mjp_getResourceProviderAtSlot(int slot);
+
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  // MUJOCO_MUJOCO_H_
```

## Comparing `mujoco_dev-2.3.8.dev554438423.dist-info/LICENSE` & `mujoco_dev-2.3.8.dev554452710.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `mujoco_dev-2.3.8.dev554438423.dist-info/LICENSES_THIRD_PARTY.md` & `mujoco_dev-2.3.8.dev554452710.dist-info/LICENSES_THIRD_PARTY.md`

 * *Files identical despite different names*

## Comparing `mujoco_dev-2.3.8.dev554438423.dist-info/METADATA` & `mujoco_dev-2.3.8.dev554452710.dist-info/METADATA`

 * *Files 7% similar despite different names*

```diff
@@ -1,826 +1,826 @@
-Metadata-Version: 2.1
-Name: mujoco-dev
-Version: 2.3.8.dev554438423
-Summary: MuJoCo Physics Simulator (unstable dev build)
-Home-page: https://github.com/deepmind/mujoco
-Author: Google DeepMind
-Author-email: mujoco@deepmind.com
-License: Apache License 2.0
-Classifier: Development Status :: 2 - Pre-Alpha
-Classifier: Intended Audience :: Developers
-Classifier: Intended Audience :: Science/Research
-Classifier: License :: OSI Approved :: Apache Software License
-Classifier: Natural Language :: English
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-Classifier: Topic :: Scientific/Engineering
-Requires-Python: >=3.8
-Description-Content-Type: text/markdown
-License-File: LICENSE
-License-File: LICENSES_THIRD_PARTY.md
-Requires-Dist: absl-py
-Requires-Dist: glfw
-Requires-Dist: numpy
-Requires-Dist: pyopengl
-
-# MuJoCo Python Bindings
-
-[![PyPI Python Version][pypi-versions-badge]][pypi]
-[![PyPI version][pypi-badge]][pypi]
-
-[pypi-versions-badge]: https://img.shields.io/pypi/pyversions/mujoco
-[pypi-badge]: https://badge.fury.io/py/mujoco.svg
-[pypi]: https://pypi.org/project/mujoco/
-
-This package is the canonical Python bindings for the
-[MuJoCo physics engine](https://github.com/deepmind/mujoco).
-These bindings are developed and maintained by Google DeepMind, and is kept
-up-to-date with the latest developments in MuJoCo itself.
-
-The `mujoco` package provides direct access to raw MuJoCo C API functions,
-structs, constants, and enumerations. Structs are provided as Python classes,
-with Pythonic initialization and deletion semantics.
-
-It is not the aim of this package to provide fully fledged
-scene/environment/game authoring API, as there are already a number of existing
-packages that do this well. However, this package does provide a number of
-lower-level components outside of MuJoCo itself that are likely to be useful to
-most users who access MuJoCo through Python. For example, the `egl`, `glfw`, and
-`osmesa` subpackages contain utilities for setting up OpenGL rendering contexts.
-
-## Installation
-
-The recommended way to install this package is via [PyPI](https://pypi.org/project/mujoco/):
-
-```sh
-pip install mujoco
-```
-
-A copy of the MuJoCo library is provided as part of the package and does **not**
-need to be downloaded or installed separately.
-
-### Source
-
-**IMPORTANT:** Building from source is only necessary if you are modifying the
-Python bindings (or are trying to run on exceptionally old Linux systems).
-If that's not the case, then we recommend installing the prebuilt binaries from
-PyPI.
-
-If you need to build the Python bindings from source, please consult
-[the documentation](https://mujoco.readthedocs.io/en/latest/python.html#building-from-source).
-
-## Usage
-
-Once installed, the package can be imported via `import mujoco`. Please consult
-our [documentation](https://mujoco.readthedocs.io/en/stable/python.html) for
-further detail on the package's API.
-
-We recommend going through the tutorial notebook which covers the basics of
-MuJoCo using Python:
-[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/deepmind/mujoco/blob/main/python/tutorial.ipynb)
-
-## Versioning
-
-The `major.minor.micro` portion of the version number matches the version of
-MuJoCo that the bindings provide. Optionally, if we release updates to the
-Python bindings themselves that target the same version of MuJoCo, a `.postN`
-suffix is added, for example `2.1.2.post2` represents the second update to the
-bindings for MuJoCo 2.1.2.
-
-## License and Disclaimer
-
-Copyright 2022 DeepMind Technologies Limited
-
-MuJoCo and its Python bindings are licensed under the Apache License,
-Version 2.0. You may obtain a copy of the License at
-https://www.apache.org/licenses/LICENSE-2.0.
-
-This is not an officially supported Google product.
-
-## Third-party licenses
-
-### Abseil C++ Common Libraries
-
-```
-Copyright 2016 Google Inc.
-Copyright 2017 The Abseil Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-     https://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-```
-
-### Collisions
-
-```
-Copyright (c) 2015 Svetoslav Kolev
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
-```
-
-### Eigen
-
-We build with the `EIGEN_MPL2_ONLY` preprocessor macro set.
-
-```
-Eigen is primarily MPL2 licensed. See COPYING.MPL2 and these links:
-  http://www.mozilla.org/MPL/2.0/
-  http://www.mozilla.org/MPL/2.0/FAQ.html
-
-Some files contain third-party code under BSD or LGPL licenses, whence the other
-COPYING.* files here.
-
-All the LGPL code is either LGPL 2.1-only, or LGPL 2.1-or-later.
-For this reason, the COPYING.LGPL file contains the LGPL 2.1 text.
-
-If you want to guarantee that the Eigen code that you are #including is licensed
-under the MPL2 and possibly more permissive licenses (like BSD), #define this
-preprocessor symbol:
-  EIGEN_MPL2_ONLY
-For example, with most compilers, you could add this to your project CXXFLAGS:
-  -DEIGEN_MPL2_ONLY
-This will cause a compilation error to be generated if you #include any code that is
-LGPL licensed.
-
-
-Mozilla Public License Version 2.0
-==================================
-
-1. Definitions
---------------
-
-1.1. "Contributor"
-    means each individual or legal entity that creates, contributes to
-    the creation of, or owns Covered Software.
-
-1.2. "Contributor Version"
-    means the combination of the Contributions of others (if any) used
-    by a Contributor and that particular Contributor's Contribution.
-
-1.3. "Contribution"
-    means Covered Software of a particular Contributor.
-
-1.4. "Covered Software"
-    means Source Code Form to which the initial Contributor has attached
-    the notice in Exhibit A, the Executable Form of such Source Code
-    Form, and Modifications of such Source Code Form, in each case
-    including portions thereof.
-
-1.5. "Incompatible With Secondary Licenses"
-    means
-
-    (a) that the initial Contributor has attached the notice described
-        in Exhibit B to the Covered Software; or
-
-    (b) that the Covered Software was made available under the terms of
-        version 1.1 or earlier of the License, but not also under the
-        terms of a Secondary License.
-
-1.6. "Executable Form"
-    means any form of the work other than Source Code Form.
-
-1.7. "Larger Work"
-    means a work that combines Covered Software with other material, in 
-    a separate file or files, that is not Covered Software.
-
-1.8. "License"
-    means this document.
-
-1.9. "Licensable"
-    means having the right to grant, to the maximum extent possible,
-    whether at the time of the initial grant or subsequently, any and
-    all of the rights conveyed by this License.
-
-1.10. "Modifications"
-    means any of the following:
-
-    (a) any file in Source Code Form that results from an addition to,
-        deletion from, or modification of the contents of Covered
-        Software; or
-
-    (b) any new file in Source Code Form that contains any Covered
-        Software.
-
-1.11. "Patent Claims" of a Contributor
-    means any patent claim(s), including without limitation, method,
-    process, and apparatus claims, in any patent Licensable by such
-    Contributor that would be infringed, but for the grant of the
-    License, by the making, using, selling, offering for sale, having
-    made, import, or transfer of either its Contributions or its
-    Contributor Version.
-
-1.12. "Secondary License"
-    means either the GNU General Public License, Version 2.0, the GNU
-    Lesser General Public License, Version 2.1, the GNU Affero General
-    Public License, Version 3.0, or any later versions of those
-    licenses.
-
-1.13. "Source Code Form"
-    means the form of the work preferred for making modifications.
-
-1.14. "You" (or "Your")
-    means an individual or a legal entity exercising rights under this
-    License. For legal entities, "You" includes any entity that
-    controls, is controlled by, or is under common control with You. For
-    purposes of this definition, "control" means (a) the power, direct
-    or indirect, to cause the direction or management of such entity,
-    whether by contract or otherwise, or (b) ownership of more than
-    fifty percent (50%) of the outstanding shares or beneficial
-    ownership of such entity.
-
-2. License Grants and Conditions
---------------------------------
-
-2.1. Grants
-
-Each Contributor hereby grants You a world-wide, royalty-free,
-non-exclusive license:
-
-(a) under intellectual property rights (other than patent or trademark)
-    Licensable by such Contributor to use, reproduce, make available,
-    modify, display, perform, distribute, and otherwise exploit its
-    Contributions, either on an unmodified basis, with Modifications, or
-    as part of a Larger Work; and
-
-(b) under Patent Claims of such Contributor to make, use, sell, offer
-    for sale, have made, import, and otherwise transfer either its
-    Contributions or its Contributor Version.
-
-2.2. Effective Date
-
-The licenses granted in Section 2.1 with respect to any Contribution
-become effective for each Contribution on the date the Contributor first
-distributes such Contribution.
-
-2.3. Limitations on Grant Scope
-
-The licenses granted in this Section 2 are the only rights granted under
-this License. No additional rights or licenses will be implied from the
-distribution or licensing of Covered Software under this License.
-Notwithstanding Section 2.1(b) above, no patent license is granted by a
-Contributor:
-
-(a) for any code that a Contributor has removed from Covered Software;
-    or
-
-(b) for infringements caused by: (i) Your and any other third party's
-    modifications of Covered Software, or (ii) the combination of its
-    Contributions with other software (except as part of its Contributor
-    Version); or
-
-(c) under Patent Claims infringed by Covered Software in the absence of
-    its Contributions.
-
-This License does not grant any rights in the trademarks, service marks,
-or logos of any Contributor (except as may be necessary to comply with
-the notice requirements in Section 3.4).
-
-2.4. Subsequent Licenses
-
-No Contributor makes additional grants as a result of Your choice to
-distribute the Covered Software under a subsequent version of this
-License (see Section 10.2) or under the terms of a Secondary License (if
-permitted under the terms of Section 3.3).
-
-2.5. Representation
-
-Each Contributor represents that the Contributor believes its
-Contributions are its original creation(s) or it has sufficient rights
-to grant the rights to its Contributions conveyed by this License.
-
-2.6. Fair Use
-
-This License is not intended to limit any rights You have under
-applicable copyright doctrines of fair use, fair dealing, or other
-equivalents.
-
-2.7. Conditions
-
-Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted
-in Section 2.1.
-
-3. Responsibilities
--------------------
-
-3.1. Distribution of Source Form
-
-All distribution of Covered Software in Source Code Form, including any
-Modifications that You create or to which You contribute, must be under
-the terms of this License. You must inform recipients that the Source
-Code Form of the Covered Software is governed by the terms of this
-License, and how they can obtain a copy of this License. You may not
-attempt to alter or restrict the recipients' rights in the Source Code
-Form.
-
-3.2. Distribution of Executable Form
-
-If You distribute Covered Software in Executable Form then:
-
-(a) such Covered Software must also be made available in Source Code
-    Form, as described in Section 3.1, and You must inform recipients of
-    the Executable Form how they can obtain a copy of such Source Code
-    Form by reasonable means in a timely manner, at a charge no more
-    than the cost of distribution to the recipient; and
-
-(b) You may distribute such Executable Form under the terms of this
-    License, or sublicense it under different terms, provided that the
-    license for the Executable Form does not attempt to limit or alter
-    the recipients' rights in the Source Code Form under this License.
-
-3.3. Distribution of a Larger Work
-
-You may create and distribute a Larger Work under terms of Your choice,
-provided that You also comply with the requirements of this License for
-the Covered Software. If the Larger Work is a combination of Covered
-Software with a work governed by one or more Secondary Licenses, and the
-Covered Software is not Incompatible With Secondary Licenses, this
-License permits You to additionally distribute such Covered Software
-under the terms of such Secondary License(s), so that the recipient of
-the Larger Work may, at their option, further distribute the Covered
-Software under the terms of either this License or such Secondary
-License(s).
-
-3.4. Notices
-
-You may not remove or alter the substance of any license notices
-(including copyright notices, patent notices, disclaimers of warranty,
-or limitations of liability) contained within the Source Code Form of
-the Covered Software, except that You may alter any license notices to
-the extent required to remedy known factual inaccuracies.
-
-3.5. Application of Additional Terms
-
-You may choose to offer, and to charge a fee for, warranty, support,
-indemnity or liability obligations to one or more recipients of Covered
-Software. However, You may do so only on Your own behalf, and not on
-behalf of any Contributor. You must make it absolutely clear that any
-such warranty, support, indemnity, or liability obligation is offered by
-You alone, and You hereby agree to indemnify every Contributor for any
-liability incurred by such Contributor as a result of warranty, support,
-indemnity or liability terms You offer. You may include additional
-disclaimers of warranty and limitations of liability specific to any
-jurisdiction.
-
-4. Inability to Comply Due to Statute or Regulation
----------------------------------------------------
-
-If it is impossible for You to comply with any of the terms of this
-License with respect to some or all of the Covered Software due to
-statute, judicial order, or regulation then You must: (a) comply with
-the terms of this License to the maximum extent possible; and (b)
-describe the limitations and the code they affect. Such description must
-be placed in a text file included with all distributions of the Covered
-Software under this License. Except to the extent prohibited by statute
-or regulation, such description must be sufficiently detailed for a
-recipient of ordinary skill to be able to understand it.
-
-5. Termination
---------------
-
-5.1. The rights granted under this License will terminate automatically
-if You fail to comply with any of its terms. However, if You become
-compliant, then the rights granted under this License from a particular
-Contributor are reinstated (a) provisionally, unless and until such
-Contributor explicitly and finally terminates Your grants, and (b) on an
-ongoing basis, if such Contributor fails to notify You of the
-non-compliance by some reasonable means prior to 60 days after You have
-come back into compliance. Moreover, Your grants from a particular
-Contributor are reinstated on an ongoing basis if such Contributor
-notifies You of the non-compliance by some reasonable means, this is the
-first time You have received notice of non-compliance with this License
-from such Contributor, and You become compliant prior to 30 days after
-Your receipt of the notice.
-
-5.2. If You initiate litigation against any entity by asserting a patent
-infringement claim (excluding declaratory judgment actions,
-counter-claims, and cross-claims) alleging that a Contributor Version
-directly or indirectly infringes any patent, then the rights granted to
-You by any and all Contributors for the Covered Software under Section
-2.1 of this License shall terminate.
-
-5.3. In the event of termination under Sections 5.1 or 5.2 above, all
-end user license agreements (excluding distributors and resellers) which
-have been validly granted by You or Your distributors under this License
-prior to termination shall survive termination.
-
-************************************************************************
-*                                                                      *
-*  6. Disclaimer of Warranty                                           *
-*  -------------------------                                           *
-*                                                                      *
-*  Covered Software is provided under this License on an "as is"       *
-*  basis, without warranty of any kind, either expressed, implied, or  *
-*  statutory, including, without limitation, warranties that the       *
-*  Covered Software is free of defects, merchantable, fit for a        *
-*  particular purpose or non-infringing. The entire risk as to the     *
-*  quality and performance of the Covered Software is with You.        *
-*  Should any Covered Software prove defective in any respect, You     *
-*  (not any Contributor) assume the cost of any necessary servicing,   *
-*  repair, or correction. This disclaimer of warranty constitutes an   *
-*  essential part of this License. No use of any Covered Software is   *
-*  authorized under this License except under this disclaimer.         *
-*                                                                      *
-************************************************************************
-
-************************************************************************
-*                                                                      *
-*  7. Limitation of Liability                                          *
-*  --------------------------                                          *
-*                                                                      *
-*  Under no circumstances and under no legal theory, whether tort      *
-*  (including negligence), contract, or otherwise, shall any           *
-*  Contributor, or anyone who distributes Covered Software as          *
-*  permitted above, be liable to You for any direct, indirect,         *
-*  special, incidental, or consequential damages of any character      *
-*  including, without limitation, damages for lost profits, loss of    *
-*  goodwill, work stoppage, computer failure or malfunction, or any    *
-*  and all other commercial damages or losses, even if such party      *
-*  shall have been informed of the possibility of such damages. This   *
-*  limitation of liability shall not apply to liability for death or   *
-*  personal injury resulting from such party's negligence to the       *
-*  extent applicable law prohibits such limitation. Some               *
-*  jurisdictions do not allow the exclusion or limitation of           *
-*  incidental or consequential damages, so this exclusion and          *
-*  limitation may not apply to You.                                    *
-*                                                                      *
-************************************************************************
-
-8. Litigation
--------------
-
-Any litigation relating to this License may be brought only in the
-courts of a jurisdiction where the defendant maintains its principal
-place of business and such litigation shall be governed by laws of that
-jurisdiction, without reference to its conflict-of-law provisions.
-Nothing in this Section shall prevent a party's ability to bring
-cross-claims or counter-claims.
-
-9. Miscellaneous
-----------------
-
-This License represents the complete agreement concerning the subject
-matter hereof. If any provision of this License is held to be
-unenforceable, such provision shall be reformed only to the extent
-necessary to make it enforceable. Any law or regulation which provides
-that the language of a contract shall be construed against the drafter
-shall not be used to construe this License against a Contributor.
-
-10. Versions of the License
----------------------------
-
-10.1. New Versions
-
-Mozilla Foundation is the license steward. Except as provided in Section
-10.3, no one other than the license steward has the right to modify or
-publish new versions of this License. Each version will be given a
-distinguishing version number.
-
-10.2. Effect of New Versions
-
-You may distribute the Covered Software under the terms of the version
-of the License under which You originally received the Covered Software,
-or under the terms of any subsequent version published by the license
-steward.
-
-10.3. Modified Versions
-
-If you create software not governed by this License, and you want to
-create a new license for such software, you may create and use a
-modified version of this License if you rename the license and remove
-any references to the name of the license steward (except to note that
-such modified license differs from this License).
-
-10.4. Distributing Source Code Form that is Incompatible With Secondary
-Licenses
-
-If You choose to distribute Source Code Form that is Incompatible With
-Secondary Licenses under the terms of this version of the License, the
-notice described in Exhibit B of this License must be attached.
-
-Exhibit A - Source Code Form License Notice
--------------------------------------------
-
-  This Source Code Form is subject to the terms of the Mozilla Public
-  License, v. 2.0. If a copy of the MPL was not distributed with this
-  file, You can obtain one at https://mozilla.org/MPL/2.0/.
-
-If it is not possible or desirable to put the notice in a particular
-file, then You may include the notice in a location (such as a LICENSE
-file in a relevant directory) where a recipient would be likely to look
-for such a notice.
-
-You may add additional accurate notices of copyright ownership.
-
-Exhibit B - "Incompatible With Secondary Licenses" Notice
----------------------------------------------------------
-
-  This Source Code Form is "Incompatible With Secondary Licenses", as
-  defined by the Mozilla Public License, v. 2.0.
-```
-
-### GLAD
-
-```
-The glad generated code itself is CC0. The source files for the generated code
-are under various licenses from Khronos.
-
---------------------------------------------------------------------------------
-
-Copyright 2013-2020 The Khronos Group Inc.
-
-Permission is hereby granted, free of charge, to any person obtaining a
-copy of this software and/or associated documentation files (the
-"Materials"), to deal in the Materials without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Materials, and to
-permit persons to whom the Materials are furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be included
-in all copies or substantial portions of the Materials.
-
-THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
-```
-
-### GLFW
-
-```
-Copyright (c) 2002-2006 Marcus Geelnard
-
-Copyright (c) 2006-2019 Camilla Lwy
-
-This software is provided 'as-is', without any express or implied
-warranty. In no event will the authors be held liable for any damages
-arising from the use of this software.
-
-Permission is granted to anyone to use this software for any purpose,
-including commercial applications, and to alter it and redistribute it
-freely, subject to the following restrictions:
-
-1. The origin of this software must not be misrepresented; you must not
-   claim that you wrote the original software. If you use this software
-   in a product, an acknowledgment in the product documentation would
-   be appreciated but is not required.
-
-2. Altered source versions must be plainly marked as such, and must not
-   be misrepresented as being the original software.
-
-3. This notice may not be removed or altered from any source
-   distribution.
-```
-
-### libccd
-
-```
-Copyright (c)2010-2012 Daniel Fiser <danfis@danfis.cz>,
-Intelligent and Mobile Robotics Group, Department of Cybernetics,
-Faculty of Electrical Engineering, Czech Technical University in Prague.
-All rights reserved.
-
-
-This work was supported by SYMBRION and REPLICATOR projects.
-The SYMBRION project is funded by European Commission within the work
-"Future and Emergent Technologies Proactive" under grant agreement no.
-216342.
-The REPLICATOR project is funded within the work programme "Cognitive
-Systems, Interaction, Robotics" under grant agreement no. 216240.
-http://www.symbrion.eu/
-http://www.replicators.eu/
-
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
- - Redistributions of source code must retain the above copyright notice,
-   this list of conditions and the following disclaimer.
-
- - Redistributions in binary form must reproduce the above copyright
-   notice, this list of conditions and the following disclaimer in the
-   documentation and/or other materials provided with the distribution.
-
- - Neither the name of the University nor the names of its contributors
-   may be used to endorse or promote products derived from this software
-   without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-```
-
-### LLVM runtime libraries (`compiler_rt`, `libc++`, `libc++abi`, `libunwind`)
-
-```
-The LLVM Project is under the Apache License v2.0 with LLVM Exceptions.
-You may obtain a copy of the Apache 2.0 License at
-
-     https://www.apache.org/licenses/LICENSE-2.0
-
----- LLVM Exceptions to the Apache 2.0 License ----
-
-As an exception, if, as a result of your compiling your source code, portions
-of this Software are embedded into an Object form of such source code, you
-may redistribute such embedded portions in such Object form without complying
-with the conditions of Sections 4(a), 4(b) and 4(d) of the License.
-
-In addition, if you combine or link compiled forms of this Software with
-software that is licensed under the GPLv2 ("Combined Software") and if a
-court of competent jurisdiction determines that the patent provision (Section
-3), the indemnity provision (Section 9) or other Section of the License
-conflicts with the conditions of the GPLv2, you may retroactively and
-prospectively choose to deem waived or otherwise exclude such Section(s) of
-the License, but only in their entirety and only with respect to the Combined
-Software.
-```
-
-### LodePNG
-
-```
-Copyright (c) 2005-2018 Lode Vandevenne
-
-This software is provided 'as-is', without any express or implied
-warranty. In no event will the authors be held liable for any damages
-arising from the use of this software.
-
-Permission is granted to anyone to use this software for any purpose,
-including commercial applications, and to alter it and redistribute it
-freely, subject to the following restrictions:
-
-    1. The origin of this software must not be misrepresented; you must not
-    claim that you wrote the original software. If you use this software
-    in a product, an acknowledgment in the product documentation would be
-    appreciated but is not required.
-
-    2. Altered source versions must be plainly marked as such, and must not be
-    misrepresented as being the original software.
-
-    3. This notice may not be removed or altered from any source
-    distribution.
-```
-
-### pybind11
-
-```
-Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>, All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-1. Redistributions of source code must retain the above copyright notice, this
-   list of conditions and the following disclaimer.
-
-2. Redistributions in binary form must reproduce the above copyright notice,
-   this list of conditions and the following disclaimer in the documentation
-   and/or other materials provided with the distribution.
-
-3. Neither the name of the copyright holder nor the names of its contributors
-   may be used to endorse or promote products derived from this software
-   without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-Please also refer to the file .github/CONTRIBUTING.md, which clarifies licensing of
-external contributions to this project including patches, pull requests, etc.
-```
-
-### Qhull
-
-```
-                    Qhull, Copyright (c) 1993-2020
-
-                            C.B. Barber
-                           Arlington, MA
-
-                               and
-
-       The National Science and Technology Research Center for
-        Computation and Visualization of Geometric Structures
-                        (The Geometry Center)
-                       University of Minnesota
-
-                       email: qhull@qhull.org
-
-This software includes Qhull from C.B. Barber and The Geometry Center.
-Files derived from Qhull 1.0 are copyrighted by the Geometry Center.  The
-remaining files are copyrighted by C.B. Barber.  Qhull is free software
-and may be obtained via http from www.qhull.org.  It may be freely copied,
-modified, and redistributed under the following conditions:
-
-1. All copyright notices must remain intact in all files.
-
-2. A copy of this text file must be distributed along with any copies
-   of Qhull that you redistribute; this includes copies that you have
-   modified, or copies of programs or other software products that
-   include Qhull.
-
-3. If you modify Qhull, you must include a notice giving the
-   name of the person performing the modification, the date of
-   modification, and the reason for such modification.
-
-4. When distributing modified versions of Qhull, or other software
-   products that include Qhull, you must provide notice that the original
-   source code may be obtained as noted above.
-
-5. There is no warranty or other guarantee of fitness for Qhull, it is
-   provided solely "as is".  Bug reports or fixes may be sent to
-   qhull_bug@qhull.org; the authors may or may not act on them as
-   they desire.
-```
-
-### TinyXML2
-
-```
-This software is provided 'as-is', without any express or implied
-warranty. In no event will the authors be held liable for any
-damages arising from the use of this software.
-
-Permission is granted to anyone to use this software for any
-purpose, including commercial applications, and to alter it and
-redistribute it freely, subject to the following restrictions:
-
-1. The origin of this software must not be misrepresented; you must
-not claim that you wrote the original software. If you use this
-software in a product, an acknowledgment in the product documentation
-would be appreciated but is not required.
-
-2. Altered source versions must be plainly marked as such, and
-must not be misrepresented as being the original software.
-
-3. This notice may not be removed or altered from any source
-distribution.
-```
-
-### TinyOBJLoader
-
-```
-The MIT License (MIT)
-
-Copyright (c) 2012-2019 Syoyo Fujita and many contributors.
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
-```
+Metadata-Version: 2.1
+Name: mujoco-dev
+Version: 2.3.8.dev554452710
+Summary: MuJoCo Physics Simulator (unstable dev build)
+Home-page: https://github.com/deepmind/mujoco
+Author: Google DeepMind
+Author-email: mujoco@deepmind.com
+License: Apache License 2.0
+Classifier: Development Status :: 2 - Pre-Alpha
+Classifier: Intended Audience :: Developers
+Classifier: Intended Audience :: Science/Research
+Classifier: License :: OSI Approved :: Apache Software License
+Classifier: Natural Language :: English
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Topic :: Scientific/Engineering
+Requires-Python: >=3.8
+Description-Content-Type: text/markdown
+License-File: LICENSE
+License-File: LICENSES_THIRD_PARTY.md
+Requires-Dist: absl-py
+Requires-Dist: glfw
+Requires-Dist: numpy
+Requires-Dist: pyopengl
+
+# MuJoCo Python Bindings
+
+[![PyPI Python Version][pypi-versions-badge]][pypi]
+[![PyPI version][pypi-badge]][pypi]
+
+[pypi-versions-badge]: https://img.shields.io/pypi/pyversions/mujoco
+[pypi-badge]: https://badge.fury.io/py/mujoco.svg
+[pypi]: https://pypi.org/project/mujoco/
+
+This package is the canonical Python bindings for the
+[MuJoCo physics engine](https://github.com/deepmind/mujoco).
+These bindings are developed and maintained by Google DeepMind, and is kept
+up-to-date with the latest developments in MuJoCo itself.
+
+The `mujoco` package provides direct access to raw MuJoCo C API functions,
+structs, constants, and enumerations. Structs are provided as Python classes,
+with Pythonic initialization and deletion semantics.
+
+It is not the aim of this package to provide fully fledged
+scene/environment/game authoring API, as there are already a number of existing
+packages that do this well. However, this package does provide a number of
+lower-level components outside of MuJoCo itself that are likely to be useful to
+most users who access MuJoCo through Python. For example, the `egl`, `glfw`, and
+`osmesa` subpackages contain utilities for setting up OpenGL rendering contexts.
+
+## Installation
+
+The recommended way to install this package is via [PyPI](https://pypi.org/project/mujoco/):
+
+```sh
+pip install mujoco
+```
+
+A copy of the MuJoCo library is provided as part of the package and does **not**
+need to be downloaded or installed separately.
+
+### Source
+
+**IMPORTANT:** Building from source is only necessary if you are modifying the
+Python bindings (or are trying to run on exceptionally old Linux systems).
+If that's not the case, then we recommend installing the prebuilt binaries from
+PyPI.
+
+If you need to build the Python bindings from source, please consult
+[the documentation](https://mujoco.readthedocs.io/en/latest/python.html#building-from-source).
+
+## Usage
+
+Once installed, the package can be imported via `import mujoco`. Please consult
+our [documentation](https://mujoco.readthedocs.io/en/stable/python.html) for
+further detail on the package's API.
+
+We recommend going through the tutorial notebook which covers the basics of
+MuJoCo using Python:
+[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/deepmind/mujoco/blob/main/python/tutorial.ipynb)
+
+## Versioning
+
+The `major.minor.micro` portion of the version number matches the version of
+MuJoCo that the bindings provide. Optionally, if we release updates to the
+Python bindings themselves that target the same version of MuJoCo, a `.postN`
+suffix is added, for example `2.1.2.post2` represents the second update to the
+bindings for MuJoCo 2.1.2.
+
+## License and Disclaimer
+
+Copyright 2022 DeepMind Technologies Limited
+
+MuJoCo and its Python bindings are licensed under the Apache License,
+Version 2.0. You may obtain a copy of the License at
+https://www.apache.org/licenses/LICENSE-2.0.
+
+This is not an officially supported Google product.
+
+## Third-party licenses
+
+### Abseil C++ Common Libraries
+
+```
+Copyright 2016 Google Inc.
+Copyright 2017 The Abseil Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+     https://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+```
+
+### Collisions
+
+```
+Copyright (c) 2015 Svetoslav Kolev
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+```
+
+### Eigen
+
+We build with the `EIGEN_MPL2_ONLY` preprocessor macro set.
+
+```
+Eigen is primarily MPL2 licensed. See COPYING.MPL2 and these links:
+  http://www.mozilla.org/MPL/2.0/
+  http://www.mozilla.org/MPL/2.0/FAQ.html
+
+Some files contain third-party code under BSD or LGPL licenses, whence the other
+COPYING.* files here.
+
+All the LGPL code is either LGPL 2.1-only, or LGPL 2.1-or-later.
+For this reason, the COPYING.LGPL file contains the LGPL 2.1 text.
+
+If you want to guarantee that the Eigen code that you are #including is licensed
+under the MPL2 and possibly more permissive licenses (like BSD), #define this
+preprocessor symbol:
+  EIGEN_MPL2_ONLY
+For example, with most compilers, you could add this to your project CXXFLAGS:
+  -DEIGEN_MPL2_ONLY
+This will cause a compilation error to be generated if you #include any code that is
+LGPL licensed.
+
+
+Mozilla Public License Version 2.0
+==================================
+
+1. Definitions
+--------------
+
+1.1. "Contributor"
+    means each individual or legal entity that creates, contributes to
+    the creation of, or owns Covered Software.
+
+1.2. "Contributor Version"
+    means the combination of the Contributions of others (if any) used
+    by a Contributor and that particular Contributor's Contribution.
+
+1.3. "Contribution"
+    means Covered Software of a particular Contributor.
+
+1.4. "Covered Software"
+    means Source Code Form to which the initial Contributor has attached
+    the notice in Exhibit A, the Executable Form of such Source Code
+    Form, and Modifications of such Source Code Form, in each case
+    including portions thereof.
+
+1.5. "Incompatible With Secondary Licenses"
+    means
+
+    (a) that the initial Contributor has attached the notice described
+        in Exhibit B to the Covered Software; or
+
+    (b) that the Covered Software was made available under the terms of
+        version 1.1 or earlier of the License, but not also under the
+        terms of a Secondary License.
+
+1.6. "Executable Form"
+    means any form of the work other than Source Code Form.
+
+1.7. "Larger Work"
+    means a work that combines Covered Software with other material, in 
+    a separate file or files, that is not Covered Software.
+
+1.8. "License"
+    means this document.
+
+1.9. "Licensable"
+    means having the right to grant, to the maximum extent possible,
+    whether at the time of the initial grant or subsequently, any and
+    all of the rights conveyed by this License.
+
+1.10. "Modifications"
+    means any of the following:
+
+    (a) any file in Source Code Form that results from an addition to,
+        deletion from, or modification of the contents of Covered
+        Software; or
+
+    (b) any new file in Source Code Form that contains any Covered
+        Software.
+
+1.11. "Patent Claims" of a Contributor
+    means any patent claim(s), including without limitation, method,
+    process, and apparatus claims, in any patent Licensable by such
+    Contributor that would be infringed, but for the grant of the
+    License, by the making, using, selling, offering for sale, having
+    made, import, or transfer of either its Contributions or its
+    Contributor Version.
+
+1.12. "Secondary License"
+    means either the GNU General Public License, Version 2.0, the GNU
+    Lesser General Public License, Version 2.1, the GNU Affero General
+    Public License, Version 3.0, or any later versions of those
+    licenses.
+
+1.13. "Source Code Form"
+    means the form of the work preferred for making modifications.
+
+1.14. "You" (or "Your")
+    means an individual or a legal entity exercising rights under this
+    License. For legal entities, "You" includes any entity that
+    controls, is controlled by, or is under common control with You. For
+    purposes of this definition, "control" means (a) the power, direct
+    or indirect, to cause the direction or management of such entity,
+    whether by contract or otherwise, or (b) ownership of more than
+    fifty percent (50%) of the outstanding shares or beneficial
+    ownership of such entity.
+
+2. License Grants and Conditions
+--------------------------------
+
+2.1. Grants
+
+Each Contributor hereby grants You a world-wide, royalty-free,
+non-exclusive license:
+
+(a) under intellectual property rights (other than patent or trademark)
+    Licensable by such Contributor to use, reproduce, make available,
+    modify, display, perform, distribute, and otherwise exploit its
+    Contributions, either on an unmodified basis, with Modifications, or
+    as part of a Larger Work; and
+
+(b) under Patent Claims of such Contributor to make, use, sell, offer
+    for sale, have made, import, and otherwise transfer either its
+    Contributions or its Contributor Version.
+
+2.2. Effective Date
+
+The licenses granted in Section 2.1 with respect to any Contribution
+become effective for each Contribution on the date the Contributor first
+distributes such Contribution.
+
+2.3. Limitations on Grant Scope
+
+The licenses granted in this Section 2 are the only rights granted under
+this License. No additional rights or licenses will be implied from the
+distribution or licensing of Covered Software under this License.
+Notwithstanding Section 2.1(b) above, no patent license is granted by a
+Contributor:
+
+(a) for any code that a Contributor has removed from Covered Software;
+    or
+
+(b) for infringements caused by: (i) Your and any other third party's
+    modifications of Covered Software, or (ii) the combination of its
+    Contributions with other software (except as part of its Contributor
+    Version); or
+
+(c) under Patent Claims infringed by Covered Software in the absence of
+    its Contributions.
+
+This License does not grant any rights in the trademarks, service marks,
+or logos of any Contributor (except as may be necessary to comply with
+the notice requirements in Section 3.4).
+
+2.4. Subsequent Licenses
+
+No Contributor makes additional grants as a result of Your choice to
+distribute the Covered Software under a subsequent version of this
+License (see Section 10.2) or under the terms of a Secondary License (if
+permitted under the terms of Section 3.3).
+
+2.5. Representation
+
+Each Contributor represents that the Contributor believes its
+Contributions are its original creation(s) or it has sufficient rights
+to grant the rights to its Contributions conveyed by this License.
+
+2.6. Fair Use
+
+This License is not intended to limit any rights You have under
+applicable copyright doctrines of fair use, fair dealing, or other
+equivalents.
+
+2.7. Conditions
+
+Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted
+in Section 2.1.
+
+3. Responsibilities
+-------------------
+
+3.1. Distribution of Source Form
+
+All distribution of Covered Software in Source Code Form, including any
+Modifications that You create or to which You contribute, must be under
+the terms of this License. You must inform recipients that the Source
+Code Form of the Covered Software is governed by the terms of this
+License, and how they can obtain a copy of this License. You may not
+attempt to alter or restrict the recipients' rights in the Source Code
+Form.
+
+3.2. Distribution of Executable Form
+
+If You distribute Covered Software in Executable Form then:
+
+(a) such Covered Software must also be made available in Source Code
+    Form, as described in Section 3.1, and You must inform recipients of
+    the Executable Form how they can obtain a copy of such Source Code
+    Form by reasonable means in a timely manner, at a charge no more
+    than the cost of distribution to the recipient; and
+
+(b) You may distribute such Executable Form under the terms of this
+    License, or sublicense it under different terms, provided that the
+    license for the Executable Form does not attempt to limit or alter
+    the recipients' rights in the Source Code Form under this License.
+
+3.3. Distribution of a Larger Work
+
+You may create and distribute a Larger Work under terms of Your choice,
+provided that You also comply with the requirements of this License for
+the Covered Software. If the Larger Work is a combination of Covered
+Software with a work governed by one or more Secondary Licenses, and the
+Covered Software is not Incompatible With Secondary Licenses, this
+License permits You to additionally distribute such Covered Software
+under the terms of such Secondary License(s), so that the recipient of
+the Larger Work may, at their option, further distribute the Covered
+Software under the terms of either this License or such Secondary
+License(s).
+
+3.4. Notices
+
+You may not remove or alter the substance of any license notices
+(including copyright notices, patent notices, disclaimers of warranty,
+or limitations of liability) contained within the Source Code Form of
+the Covered Software, except that You may alter any license notices to
+the extent required to remedy known factual inaccuracies.
+
+3.5. Application of Additional Terms
+
+You may choose to offer, and to charge a fee for, warranty, support,
+indemnity or liability obligations to one or more recipients of Covered
+Software. However, You may do so only on Your own behalf, and not on
+behalf of any Contributor. You must make it absolutely clear that any
+such warranty, support, indemnity, or liability obligation is offered by
+You alone, and You hereby agree to indemnify every Contributor for any
+liability incurred by such Contributor as a result of warranty, support,
+indemnity or liability terms You offer. You may include additional
+disclaimers of warranty and limitations of liability specific to any
+jurisdiction.
+
+4. Inability to Comply Due to Statute or Regulation
+---------------------------------------------------
+
+If it is impossible for You to comply with any of the terms of this
+License with respect to some or all of the Covered Software due to
+statute, judicial order, or regulation then You must: (a) comply with
+the terms of this License to the maximum extent possible; and (b)
+describe the limitations and the code they affect. Such description must
+be placed in a text file included with all distributions of the Covered
+Software under this License. Except to the extent prohibited by statute
+or regulation, such description must be sufficiently detailed for a
+recipient of ordinary skill to be able to understand it.
+
+5. Termination
+--------------
+
+5.1. The rights granted under this License will terminate automatically
+if You fail to comply with any of its terms. However, if You become
+compliant, then the rights granted under this License from a particular
+Contributor are reinstated (a) provisionally, unless and until such
+Contributor explicitly and finally terminates Your grants, and (b) on an
+ongoing basis, if such Contributor fails to notify You of the
+non-compliance by some reasonable means prior to 60 days after You have
+come back into compliance. Moreover, Your grants from a particular
+Contributor are reinstated on an ongoing basis if such Contributor
+notifies You of the non-compliance by some reasonable means, this is the
+first time You have received notice of non-compliance with this License
+from such Contributor, and You become compliant prior to 30 days after
+Your receipt of the notice.
+
+5.2. If You initiate litigation against any entity by asserting a patent
+infringement claim (excluding declaratory judgment actions,
+counter-claims, and cross-claims) alleging that a Contributor Version
+directly or indirectly infringes any patent, then the rights granted to
+You by any and all Contributors for the Covered Software under Section
+2.1 of this License shall terminate.
+
+5.3. In the event of termination under Sections 5.1 or 5.2 above, all
+end user license agreements (excluding distributors and resellers) which
+have been validly granted by You or Your distributors under this License
+prior to termination shall survive termination.
+
+************************************************************************
+*                                                                      *
+*  6. Disclaimer of Warranty                                           *
+*  -------------------------                                           *
+*                                                                      *
+*  Covered Software is provided under this License on an "as is"       *
+*  basis, without warranty of any kind, either expressed, implied, or  *
+*  statutory, including, without limitation, warranties that the       *
+*  Covered Software is free of defects, merchantable, fit for a        *
+*  particular purpose or non-infringing. The entire risk as to the     *
+*  quality and performance of the Covered Software is with You.        *
+*  Should any Covered Software prove defective in any respect, You     *
+*  (not any Contributor) assume the cost of any necessary servicing,   *
+*  repair, or correction. This disclaimer of warranty constitutes an   *
+*  essential part of this License. No use of any Covered Software is   *
+*  authorized under this License except under this disclaimer.         *
+*                                                                      *
+************************************************************************
+
+************************************************************************
+*                                                                      *
+*  7. Limitation of Liability                                          *
+*  --------------------------                                          *
+*                                                                      *
+*  Under no circumstances and under no legal theory, whether tort      *
+*  (including negligence), contract, or otherwise, shall any           *
+*  Contributor, or anyone who distributes Covered Software as          *
+*  permitted above, be liable to You for any direct, indirect,         *
+*  special, incidental, or consequential damages of any character      *
+*  including, without limitation, damages for lost profits, loss of    *
+*  goodwill, work stoppage, computer failure or malfunction, or any    *
+*  and all other commercial damages or losses, even if such party      *
+*  shall have been informed of the possibility of such damages. This   *
+*  limitation of liability shall not apply to liability for death or   *
+*  personal injury resulting from such party's negligence to the       *
+*  extent applicable law prohibits such limitation. Some               *
+*  jurisdictions do not allow the exclusion or limitation of           *
+*  incidental or consequential damages, so this exclusion and          *
+*  limitation may not apply to You.                                    *
+*                                                                      *
+************************************************************************
+
+8. Litigation
+-------------
+
+Any litigation relating to this License may be brought only in the
+courts of a jurisdiction where the defendant maintains its principal
+place of business and such litigation shall be governed by laws of that
+jurisdiction, without reference to its conflict-of-law provisions.
+Nothing in this Section shall prevent a party's ability to bring
+cross-claims or counter-claims.
+
+9. Miscellaneous
+----------------
+
+This License represents the complete agreement concerning the subject
+matter hereof. If any provision of this License is held to be
+unenforceable, such provision shall be reformed only to the extent
+necessary to make it enforceable. Any law or regulation which provides
+that the language of a contract shall be construed against the drafter
+shall not be used to construe this License against a Contributor.
+
+10. Versions of the License
+---------------------------
+
+10.1. New Versions
+
+Mozilla Foundation is the license steward. Except as provided in Section
+10.3, no one other than the license steward has the right to modify or
+publish new versions of this License. Each version will be given a
+distinguishing version number.
+
+10.2. Effect of New Versions
+
+You may distribute the Covered Software under the terms of the version
+of the License under which You originally received the Covered Software,
+or under the terms of any subsequent version published by the license
+steward.
+
+10.3. Modified Versions
+
+If you create software not governed by this License, and you want to
+create a new license for such software, you may create and use a
+modified version of this License if you rename the license and remove
+any references to the name of the license steward (except to note that
+such modified license differs from this License).
+
+10.4. Distributing Source Code Form that is Incompatible With Secondary
+Licenses
+
+If You choose to distribute Source Code Form that is Incompatible With
+Secondary Licenses under the terms of this version of the License, the
+notice described in Exhibit B of this License must be attached.
+
+Exhibit A - Source Code Form License Notice
+-------------------------------------------
+
+  This Source Code Form is subject to the terms of the Mozilla Public
+  License, v. 2.0. If a copy of the MPL was not distributed with this
+  file, You can obtain one at https://mozilla.org/MPL/2.0/.
+
+If it is not possible or desirable to put the notice in a particular
+file, then You may include the notice in a location (such as a LICENSE
+file in a relevant directory) where a recipient would be likely to look
+for such a notice.
+
+You may add additional accurate notices of copyright ownership.
+
+Exhibit B - "Incompatible With Secondary Licenses" Notice
+---------------------------------------------------------
+
+  This Source Code Form is "Incompatible With Secondary Licenses", as
+  defined by the Mozilla Public License, v. 2.0.
+```
+
+### GLAD
+
+```
+The glad generated code itself is CC0. The source files for the generated code
+are under various licenses from Khronos.
+
+--------------------------------------------------------------------------------
+
+Copyright 2013-2020 The Khronos Group Inc.
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and/or associated documentation files (the
+"Materials"), to deal in the Materials without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Materials, and to
+permit persons to whom the Materials are furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Materials.
+
+THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
+```
+
+### GLFW
+
+```
+Copyright (c) 2002-2006 Marcus Geelnard
+
+Copyright (c) 2006-2019 Camilla Lwy
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must not
+   claim that you wrote the original software. If you use this software
+   in a product, an acknowledgment in the product documentation would
+   be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and must not
+   be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+   distribution.
+```
+
+### libccd
+
+```
+Copyright (c)2010-2012 Daniel Fiser <danfis@danfis.cz>,
+Intelligent and Mobile Robotics Group, Department of Cybernetics,
+Faculty of Electrical Engineering, Czech Technical University in Prague.
+All rights reserved.
+
+
+This work was supported by SYMBRION and REPLICATOR projects.
+The SYMBRION project is funded by European Commission within the work
+"Future and Emergent Technologies Proactive" under grant agreement no.
+216342.
+The REPLICATOR project is funded within the work programme "Cognitive
+Systems, Interaction, Robotics" under grant agreement no. 216240.
+http://www.symbrion.eu/
+http://www.replicators.eu/
+
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ - Redistributions of source code must retain the above copyright notice,
+   this list of conditions and the following disclaimer.
+
+ - Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+
+ - Neither the name of the University nor the names of its contributors
+   may be used to endorse or promote products derived from this software
+   without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+```
+
+### LLVM runtime libraries (`compiler_rt`, `libc++`, `libc++abi`, `libunwind`)
+
+```
+The LLVM Project is under the Apache License v2.0 with LLVM Exceptions.
+You may obtain a copy of the Apache 2.0 License at
+
+     https://www.apache.org/licenses/LICENSE-2.0
+
+---- LLVM Exceptions to the Apache 2.0 License ----
+
+As an exception, if, as a result of your compiling your source code, portions
+of this Software are embedded into an Object form of such source code, you
+may redistribute such embedded portions in such Object form without complying
+with the conditions of Sections 4(a), 4(b) and 4(d) of the License.
+
+In addition, if you combine or link compiled forms of this Software with
+software that is licensed under the GPLv2 ("Combined Software") and if a
+court of competent jurisdiction determines that the patent provision (Section
+3), the indemnity provision (Section 9) or other Section of the License
+conflicts with the conditions of the GPLv2, you may retroactively and
+prospectively choose to deem waived or otherwise exclude such Section(s) of
+the License, but only in their entirety and only with respect to the Combined
+Software.
+```
+
+### LodePNG
+
+```
+Copyright (c) 2005-2018 Lode Vandevenne
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source
+    distribution.
+```
+
+### pybind11
+
+```
+Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>, All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+1. Redistributions of source code must retain the above copyright notice, this
+   list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice,
+   this list of conditions and the following disclaimer in the documentation
+   and/or other materials provided with the distribution.
+
+3. Neither the name of the copyright holder nor the names of its contributors
+   may be used to endorse or promote products derived from this software
+   without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+Please also refer to the file .github/CONTRIBUTING.md, which clarifies licensing of
+external contributions to this project including patches, pull requests, etc.
+```
+
+### Qhull
+
+```
+                    Qhull, Copyright (c) 1993-2020
+
+                            C.B. Barber
+                           Arlington, MA
+
+                               and
+
+       The National Science and Technology Research Center for
+        Computation and Visualization of Geometric Structures
+                        (The Geometry Center)
+                       University of Minnesota
+
+                       email: qhull@qhull.org
+
+This software includes Qhull from C.B. Barber and The Geometry Center.
+Files derived from Qhull 1.0 are copyrighted by the Geometry Center.  The
+remaining files are copyrighted by C.B. Barber.  Qhull is free software
+and may be obtained via http from www.qhull.org.  It may be freely copied,
+modified, and redistributed under the following conditions:
+
+1. All copyright notices must remain intact in all files.
+
+2. A copy of this text file must be distributed along with any copies
+   of Qhull that you redistribute; this includes copies that you have
+   modified, or copies of programs or other software products that
+   include Qhull.
+
+3. If you modify Qhull, you must include a notice giving the
+   name of the person performing the modification, the date of
+   modification, and the reason for such modification.
+
+4. When distributing modified versions of Qhull, or other software
+   products that include Qhull, you must provide notice that the original
+   source code may be obtained as noted above.
+
+5. There is no warranty or other guarantee of fitness for Qhull, it is
+   provided solely "as is".  Bug reports or fixes may be sent to
+   qhull_bug@qhull.org; the authors may or may not act on them as
+   they desire.
+```
+
+### TinyXML2
+
+```
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+```
+
+### TinyOBJLoader
+
+```
+The MIT License (MIT)
+
+Copyright (c) 2012-2019 Syoyo Fujita and many contributors.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+```
```

## Comparing `mujoco_dev-2.3.8.dev554438423.dist-info/RECORD` & `mujoco_dev-2.3.8.dev554452710.dist-info/RECORD`

 * *Files 19% similar despite different names*

```diff
@@ -1,45 +1,45 @@
-mujoco/__init__.py,sha256=EHIeSa89HCYm-L3fDT2Q0g_4FNrAHKhvR-7a8eHfhRk,2446
-mujoco/_callbacks.cp39-win_amd64.pyd,sha256=0wTBjvDwp4_t87zSOs3Ev6qoB9R-Ejs34eFNdmGocCs,251904
-mujoco/_constants.cp39-win_amd64.pyd,sha256=DIqhrKgIXk95wAfdOUGzjTGiDAX4lHgRrhrE-2CSJnw,161792
-mujoco/_enums.cp39-win_amd64.pyd,sha256=psO6ws9qGyezlauJcm-zYsicEJs6-ojYGUMKKyYVv44,1866240
-mujoco/_errors.cp39-win_amd64.pyd,sha256=4kwmg5hXRpDpwhdu5htyLghUvgxwwYF_0yiA2MbeyQ0,150528
-mujoco/_functions.cp39-win_amd64.pyd,sha256=FBCJssFDgHBdPMIXeVMm7V_Y-WbWM0WyBhNrbpaNdkQ,988160
-mujoco/_render.cp39-win_amd64.pyd,sha256=UdxSfRQIU9mGGsMFAJ8H2tupUkYE956Jka52YfSB8QE,448512
-mujoco/_rollout.cp39-win_amd64.pyd,sha256=Wv73COcILy-ssgserkLhOaryGd1-DroR-xHNePLFf7Q,201728
-mujoco/_simulate.cp39-win_amd64.pyd,sha256=sv_1KaR-94E_WbWAympXLeCayYbUT1oYGEwutrHxSXQ,469504
-mujoco/_structs.cp39-win_amd64.pyd,sha256=cO9p7_tVQNjbJZNIkrvofclsnoi72QD_yxH4HEfNGvY,4141056
-mujoco/bindings_test.py,sha256=b3UF_snBn5kUCSCD0lSrk07XbulA8WPlR7aKQZQEKZs,50950
-mujoco/gl_context.py,sha256=o8rDttWCwUmpPpXkdCx_1K0gg9MaMp7ltnXlnlN3_3U,1849
-mujoco/mujoco.dll,sha256=w1xraVFWY2XPSymhPJp2EigXjAPB1UHn-MUW2MnldTA,3017216
-mujoco/render_test.py,sha256=ft5tluZV0vUv5bRZPuzxC-JjXbX4M6vvNI0b1VVZPPI,3822
-mujoco/renderer.py,sha256=b4WQYQbugXEYBlBkJdWj5L4Zkzvzpzi5tvz3SSsusjI,9101
-mujoco/renderer_test.py,sha256=I6psTde7c6dxJ-nLwjxMS4T-UJqpzF6mLnWoI-a-ivo,3655
-mujoco/rollout.py,sha256=IYAnVOa7YK6Z_HEdEGkbGx9Qna4lqVzo-6PBH2OsU7k,7793
-mujoco/rollout_test.py,sha256=YjD12wkkUqzMx1TgXDft2Df7bbl9QWgb3WSkYeH0UJw,18157
-mujoco/viewer.py,sha256=2sJUSrlZeyWvGk1wqFLikrynHdBFJxFyVp4mjID_aL4,13230
-mujoco/viewer_test.py,sha256=eiLyUsurTOpDUhSCH96TTzV4lycqJSeGteYaM79if0Q,979
-mujoco/cgl/__init__.py,sha256=Rdfy4WgWm42XeqYJDkGx-qUpQSX7OSk_3Mi_vNd-bmI,2271
-mujoco/cgl/cgl.py,sha256=AQWP6fKXRZa-i7h3QaFjbCR8dncwZmN91p9pz6OvbZI,5204
-mujoco/egl/__init__.py,sha256=sAg0kx04S96xuitVypAplYib2z75F-muubiptSvKhyE,4764
-mujoco/egl/egl_ext.py,sha256=09JhxRBwSCynSe_hTMtd61bGq68YAJLyDIuVSm-n7QU,2783
-mujoco/glfw/__init__.py,sha256=tFYB5ZryaTjFaLaQXMRGHjB5qKFz9p_TlUgQXMKgE14,1403
-mujoco/include/mujoco/mjdata.h,sha256=TW6oQ-tN5XdC0uPDQLBNqLaeyfDtDANFmZyjxM6e8js,21478
-mujoco/include/mujoco/mjexport.h,sha256=skyTLvv8mBnuhCckAeSLJ7tAugNZEhTWvG4mrxxdVJ4,1580
-mujoco/include/mujoco/mjmacro.h,sha256=4p5EK6AuLlxUoQqYJ4XJLCtZUIQXB_l_2Xsuk5ujsNI,2321
-mujoco/include/mujoco/mjmodel.h,sha256=ayrMfK-4I9jon9zUJkIG_COyTJEBZO_yDJczPucPn7k,60337
-mujoco/include/mujoco/mjplugin.h,sha256=wUAIMkD-ocA8dNivjjeLZxsc0vOqKrQTkxv5Oqm2Sgc,5807
-mujoco/include/mujoco/mjrender.h,sha256=BVaafL7PQ6-w1KIaRirTX2rJ2yH73BEBGbUB30eqpIA,7167
-mujoco/include/mujoco/mjtnum.h,sha256=tYq2Tx4pLSbTgkD2JghDA1vsz2AstPhiCBkj2_2p8oE,1352
-mujoco/include/mujoco/mjui.h,sha256=p5Avy0Vfs31n9az_ui14xkWgRt4qJYH6EnB31m_LSZI,13200
-mujoco/include/mujoco/mjvisualize.h,sha256=XH8X-Jcte-VrWlnm-4Cu278Un2WBqL4qOoG_Zi-dwr4,21791
-mujoco/include/mujoco/mjxmacro.h,sha256=n6qhFSK4r2fzC5gMVA1vhOGxB090MDr1yaf9EmO4mQk,40524
-mujoco/include/mujoco/mujoco.h,sha256=tvdnTkdkYf3QzmmDou_EtBSd3TAYiK9mf9mYlA-kVyM,55148
-mujoco/osmesa/__init__.py,sha256=Pz3Wn2LQNipYMjh_UXGsVr3w_AxOM-hiwbtQhv4KJsA,2556
-mujoco/plugin/elasticity.dll,sha256=GdXt5Q9XltSpuPcTBNt6rMh_o_JZmjSAsfwjpuAVNz0,43008
-mujoco/plugin/sensor.dll,sha256=WyStSJJvgyykLy5yzeCCY31VzbelFJ1Sb4O2UBft-IM,41472
-mujoco_dev-2.3.8.dev554438423.dist-info/LICENSE,sha256=z8d0m5b2O9McPEK1xHG_dWgUBT6EfBDz6wA0F7xSPTA,11358
-mujoco_dev-2.3.8.dev554438423.dist-info/LICENSES_THIRD_PARTY.md,sha256=wQiT5IyeqM4nMJ5vDGWPSCPlr8S7GjPgP7uyaO5xApU,31030
-mujoco_dev-2.3.8.dev554438423.dist-info/METADATA,sha256=iO7LRUy00WJAj4H6_4Hh6lEorbzSDTptzaqWrsuH1SI,35858
-mujoco_dev-2.3.8.dev554438423.dist-info/WHEEL,sha256=eep6QWEFiQfg2wcclssb_WY-D33AnLYLnEKGA9Rn-VU,100
-mujoco_dev-2.3.8.dev554438423.dist-info/top_level.txt,sha256=DduZTDzrRJfZp0pSRFEPFp2oPtDngfqYQSInojh4sRc,7
-mujoco_dev-2.3.8.dev554438423.dist-info/RECORD,,
+mujoco_dev-2.3.8.dev554452710.dist-info/RECORD,,
+mujoco_dev-2.3.8.dev554452710.dist-info/LICENSE,sha256=z8d0m5b2O9McPEK1xHG_dWgUBT6EfBDz6wA0F7xSPTA,11358
+mujoco_dev-2.3.8.dev554452710.dist-info/METADATA,sha256=7Nwiz7_7CmWBxeAQeuyIYedRC3f_iBo9aJ6S-q7sd6Y,35030
+mujoco_dev-2.3.8.dev554452710.dist-info/LICENSES_THIRD_PARTY.md,sha256=wQiT5IyeqM4nMJ5vDGWPSCPlr8S7GjPgP7uyaO5xApU,31030
+mujoco_dev-2.3.8.dev554452710.dist-info/WHEEL,sha256=WmgP0K1kdqJz8z1pv4uWmQ_zr3BEvqOuA4KvS4Wklqs,150
+mujoco_dev-2.3.8.dev554452710.dist-info/top_level.txt,sha256=DduZTDzrRJfZp0pSRFEPFp2oPtDngfqYQSInojh4sRc,7
+mujoco/_functions.cpython-39-aarch64-linux-gnu.so,sha256=Ud9gbyQL20Nom2DfNuZnGrEuWg4GcyASrEvNpgyoSWA,901136
+mujoco/gl_context.py,sha256=o8rDttWCwUmpPpXkdCx_1K0gg9MaMp7ltnXlnlN3_3U,1849
+mujoco/viewer_test.py,sha256=eiLyUsurTOpDUhSCH96TTzV4lycqJSeGteYaM79if0Q,979
+mujoco/__init__.py,sha256=EHIeSa89HCYm-L3fDT2Q0g_4FNrAHKhvR-7a8eHfhRk,2446
+mujoco/render_test.py,sha256=ft5tluZV0vUv5bRZPuzxC-JjXbX4M6vvNI0b1VVZPPI,3822
+mujoco/rollout.py,sha256=IYAnVOa7YK6Z_HEdEGkbGx9Qna4lqVzo-6PBH2OsU7k,7793
+mujoco/_constants.cpython-39-aarch64-linux-gnu.so,sha256=isopC28PCHu2mMvnnLLW4ZfukF16teRklHgsDOfZvPc,317560
+mujoco/_callbacks.cpython-39-aarch64-linux-gnu.so,sha256=MDJBu9BSP4xgGw7zdisDKo4TOXTIF54hKNTOZVOEBkM,579392
+mujoco/renderer_test.py,sha256=I6psTde7c6dxJ-nLwjxMS4T-UJqpzF6mLnWoI-a-ivo,3655
+mujoco/_enums.cpython-39-aarch64-linux-gnu.so,sha256=XgJ4U-HvwonS2uIM65riestAesgsIhN_SHbUQd56Jfs,1691776
+mujoco/libmujoco.so.2.3.8,sha256=4fH6EHtyi-WP3Kd7g3N8xbYBlIOqjt-IW8BFTyCW8qE,3456768
+mujoco/_render.cpython-39-aarch64-linux-gnu.so,sha256=wByekpb9p7raDF_uTRaGVn67ciyvGTBE_1BAkkVZfds,700152
+mujoco/_rollout.cpython-39-aarch64-linux-gnu.so,sha256=pW4Zb82oj4lQVC8DPDxpavp66TJTEfwG2enssfqsHQo,543616
+mujoco/_errors.cpython-39-aarch64-linux-gnu.so,sha256=zc0TSUPMsbLNSwBVm0nPZh9f-C6KaZykdiYito9LR7I,312440
+mujoco/rollout_test.py,sha256=YjD12wkkUqzMx1TgXDft2Df7bbl9QWgb3WSkYeH0UJw,18157
+mujoco/viewer.py,sha256=2sJUSrlZeyWvGk1wqFLikrynHdBFJxFyVp4mjID_aL4,13230
+mujoco/bindings_test.py,sha256=b3UF_snBn5kUCSCD0lSrk07XbulA8WPlR7aKQZQEKZs,50950
+mujoco/renderer.py,sha256=b4WQYQbugXEYBlBkJdWj5L4Zkzvzpzi5tvz3SSsusjI,9101
+mujoco/_structs.cpython-39-aarch64-linux-gnu.so,sha256=mme5ZSGtS4HW-DCpsILfG5LzVpw4p50YZBVZKKwESRc,2572448
+mujoco/_simulate.cpython-39-aarch64-linux-gnu.so,sha256=uXmJizZjfG918uxBkV06OO2Ssg9Mc9lhA1p24-GOvEc,773104
+mujoco/osmesa/__init__.py,sha256=Pz3Wn2LQNipYMjh_UXGsVr3w_AxOM-hiwbtQhv4KJsA,2556
+mujoco/include/mujoco/mjplugin.h,sha256=llHh2gfrcU8rUo9U7THDFDv6RVImSFkPpUgmwYZwkMU,5671
+mujoco/include/mujoco/mjmacro.h,sha256=7xyQ7iJK4m3z0pmOJNRR5cEW-P2zbqLYb3lw-jUx4x0,2260
+mujoco/include/mujoco/mjmodel.h,sha256=x2F991JE9JpBEtxcatfUHyrGXU3tKVx2Mph3h6xMtPc,59342
+mujoco/include/mujoco/mjtnum.h,sha256=RGzyWYxSlpZY-nk_-xGmwMG0IDPSNvfgIoC7YatD_E4,1311
+mujoco/include/mujoco/mjexport.h,sha256=LQ7ERhXOng3T2AzpyiqLytGQaEDSq2tamveF976Yn4s,1533
+mujoco/include/mujoco/mjui.h,sha256=InvTx33P22X3qbpOr0WnG6hhDceeMfnfu_kP3MLzHS8,12879
+mujoco/include/mujoco/mjxmacro.h,sha256=Xb4loRQoV2ouSXdC6F0exn7dqWe_ZsMKq6co1uNUMSA,39883
+mujoco/include/mujoco/mjvisualize.h,sha256=wcU3DCo_rWyY9Ws8UNid911AAk-ckDWsCLV5fkSdkfI,21207
+mujoco/include/mujoco/mjrender.h,sha256=YyWB95fhyyHHnipIAgmTnS3-qYdGCphj5kOzle5ktRs,7007
+mujoco/include/mujoco/mujoco.h,sha256=GUZPMhiXxIsHsmD3usPldf0PMOoz0Wb8fvIiC6az3fM,53846
+mujoco/include/mujoco/mjdata.h,sha256=_7mimpB5KlLtzCzXTFGNnYj091JYizzIxHruD58ZCLc,21063
+mujoco/glfw/__init__.py,sha256=tFYB5ZryaTjFaLaQXMRGHjB5qKFz9p_TlUgQXMKgE14,1403
+mujoco/egl/__init__.py,sha256=sAg0kx04S96xuitVypAplYib2z75F-muubiptSvKhyE,4764
+mujoco/egl/egl_ext.py,sha256=09JhxRBwSCynSe_hTMtd61bGq68YAJLyDIuVSm-n7QU,2783
+mujoco/cgl/cgl.py,sha256=AQWP6fKXRZa-i7h3QaFjbCR8dncwZmN91p9pz6OvbZI,5204
+mujoco/cgl/__init__.py,sha256=Rdfy4WgWm42XeqYJDkGx-qUpQSX7OSk_3Mi_vNd-bmI,2271
+mujoco/plugin/libsensor.so,sha256=CHyk6AqfIrrtDgGtg4BbO5-TEzE9f0HFQjSLWjWON_8,665456
+mujoco/plugin/libelasticity.so,sha256=XiiWhPk2oa9WGrx0OBcFfv2AnlP6_vuLA-8oQsVjBJc,353448
```

