# Comparing `tmp/scaleway_async-0.9.0.tar.gz` & `tmp/scaleway_async-1.0.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "scaleway_async-0.9.0.tar", max compression
+gzip compressed data, was "scaleway_async-1.0.0.tar", max compression
```

## Comparing `scaleway_async-0.9.0.tar` & `scaleway_async-1.0.0.tar`

### file list

```diff
@@ -1,149 +1,162 @@
--rw-r--r--   0        0        0       30 2023-03-08 16:40:37.480112 scaleway_async-0.9.0/README.md
--rw-r--r--   0        0        0     1124 2023-03-08 16:40:57.464228 scaleway_async-0.9.0/pyproject.toml
--rw-r--r--   0        0        0      913 2023-03-08 16:40:37.480112 scaleway_async-0.9.0/scaleway_async/__init__.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.480112 scaleway_async-0.9.0/scaleway_async/account/__init__.py
--rw-r--r--   0        0        0      382 2023-03-08 16:40:37.480112 scaleway_async-0.9.0/scaleway_async/account/v2/__init__.py
--rw-r--r--   0        0        0     6931 2023-03-08 16:40:37.480112 scaleway_async-0.9.0/scaleway_async/account/v2/api.py
--rw-r--r--   0        0        0     2093 2023-03-08 16:40:37.480112 scaleway_async-0.9.0/scaleway_async/account/v2/marshalling.py
--rw-r--r--   0        0        0     2649 2023-03-08 16:40:37.480112 scaleway_async-0.9.0/scaleway_async/account/v2/types.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.480112 scaleway_async-0.9.0/scaleway_async/applesilicon/__init__.py
--rw-r--r--   0        0        0      968 2023-03-08 16:40:37.480112 scaleway_async-0.9.0/scaleway_async/applesilicon/v1alpha1/__init__.py
--rw-r--r--   0        0        0    17002 2023-03-08 16:40:37.480112 scaleway_async-0.9.0/scaleway_async/applesilicon/v1alpha1/api.py
--rw-r--r--   0        0        0      497 2023-03-08 16:40:37.480112 scaleway_async-0.9.0/scaleway_async/applesilicon/v1alpha1/content.py
--rw-r--r--   0        0        0     5992 2023-03-08 16:40:37.480112 scaleway_async-0.9.0/scaleway_async/applesilicon/v1alpha1/marshalling.py
--rw-r--r--   0        0        0     7236 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/applesilicon/v1alpha1/types.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/baremetal/__init__.py
--rw-r--r--   0        0        0     3212 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/baremetal/v1/__init__.py
--rw-r--r--   0        0        0    51541 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/baremetal/v1/api.py
--rw-r--r--   0        0        0     1066 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/baremetal/v1/content.py
--rw-r--r--   0        0        0    23419 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/baremetal/v1/marshalling.py
--rw-r--r--   0        0        0    27948 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/baremetal/v1/types.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/cockpit/__init__.py
--rw-r--r--   0        0        0     1132 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/cockpit/v1beta1/__init__.py
--rw-r--r--   0        0        0    20461 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/cockpit/v1beta1/api.py
--rw-r--r--   0        0        0      419 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/cockpit/v1beta1/content.py
--rw-r--r--   0        0        0    10976 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/cockpit/v1beta1/marshalling.py
--rw-r--r--   0        0        0     5403 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/cockpit/v1beta1/types.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/container/__init__.py
--rw-r--r--   0        0        0     2364 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/container/v1beta1/__init__.py
--rw-r--r--   0        0        0    49036 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/container/v1beta1/api.py
--rw-r--r--   0        0        0     1345 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/container/v1beta1/content.py
--rw-r--r--   0        0        0    14231 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/container/v1beta1/marshalling.py
--rw-r--r--   0        0        0    15235 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/container/v1beta1/types.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/domain/__init__.py
--rw-r--r--   0        0        0     8352 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/domain/v2beta1/__init__.py
--rw-r--r--   0        0        0    83638 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/domain/v2beta1/api.py
--rw-r--r--   0        0        0     1955 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/domain/v2beta1/content.py
--rw-r--r--   0        0        0    69133 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/domain/v2beta1/marshalling.py
--rw-r--r--   0        0        0    40060 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/domain/v2beta1/types.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/flexibleip/__init__.py
--rw-r--r--   0        0        0      978 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/flexibleip/v1alpha1/__init__.py
--rw-r--r--   0        0        0    18507 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/flexibleip/v1alpha1/api.py
--rw-r--r--   0        0        0      651 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/flexibleip/v1alpha1/content.py
--rw-r--r--   0        0        0     5916 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/flexibleip/v1alpha1/marshalling.py
--rw-r--r--   0        0        0     8562 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/flexibleip/v1alpha1/types.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/function/__init__.py
--rw-r--r--   0        0        0     3852 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/function/v1beta1/__init__.py
--rw-r--r--   0        0        0    59692 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/function/v1beta1/api.py
--rw-r--r--   0        0        0     1579 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/function/v1beta1/content.py
--rw-r--r--   0        0        0    23167 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/function/v1beta1/marshalling.py
--rw-r--r--   0        0        0    22306 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/function/v1beta1/types.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/iam/__init__.py
--rw-r--r--   0        0        0     2300 2023-03-08 16:40:37.484112 scaleway_async-0.9.0/scaleway_async/iam/v1alpha1/__init__.py
--rw-r--r--   0        0        0    61207 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/iam/v1alpha1/api.py
--rw-r--r--   0        0        0    20377 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/iam/v1alpha1/marshalling.py
--rw-r--r--   0        0        0    29047 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/iam/v1alpha1/types.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/instance/__init__.py
--rw-r--r--   0        0        0     7904 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/instance/v1/__init__.py
--rw-r--r--   0        0        0   124439 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/instance/v1/api.py
--rw-r--r--   0        0        0     2059 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/instance/v1/content.py
--rw-r--r--   0        0        0    77638 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/instance/v1/marshalling.py
--rw-r--r--   0        0        0    53721 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/instance/v1/types.py
--rw-r--r--   0        0        0     9591 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/instance/v1/types_private.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/iot/__init__.py
--rw-r--r--   0        0        0     3456 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/iot/v1/__init__.py
--rw-r--r--   0        0        0    57153 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/iot/v1/api.py
--rw-r--r--   0        0        0      364 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/iot/v1/content.py
--rw-r--r--   0        0        0    25767 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/iot/v1/marshalling.py
--rw-r--r--   0        0        0    31600 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/iot/v1/types.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/k8s/__init__.py
--rw-r--r--   0        0        0     3066 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/k8s/v1/__init__.py
--rw-r--r--   0        0        0    50917 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/k8s/v1/api.py
--rw-r--r--   0        0        0      937 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/k8s/v1/content.py
--rw-r--r--   0        0        0    24665 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/k8s/v1/marshalling.py
--rw-r--r--   0        0        0    42707 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/k8s/v1/types.py
--rw-r--r--   0        0        0      544 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/k8s/v1/types_private.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/lb/__init__.py
--rw-r--r--   0        0        0     5060 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/lb/v1/__init__.py
--rw-r--r--   0        0        0   201004 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/lb/v1/api.py
--rw-r--r--   0        0        0     1111 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/lb/v1/content.py
--rw-r--r--   0        0        0    58137 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/lb/v1/marshalling.py
--rw-r--r--   0        0        0    90813 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/lb/v1/types.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/marketplace/__init__.py
--rw-r--r--   0        0        0      636 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/marketplace/v1/__init__.py
--rw-r--r--   0        0        0     4142 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/marketplace/v1/api.py
--rw-r--r--   0        0        0     5060 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/marketplace/v1/marshalling.py
--rw-r--r--   0        0        0     3082 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/marketplace/v1/types.py
--rw-r--r--   0        0        0      892 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/marketplace/v2/__init__.py
--rw-r--r--   0        0        0    12138 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/marketplace/v2/api.py
--rw-r--r--   0        0        0     5014 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/marketplace/v2/marshalling.py
--rw-r--r--   0        0        0     4980 2023-03-08 16:40:37.488112 scaleway_async-0.9.0/scaleway_async/marketplace/v2/types.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/mnq/__init__.py
--rw-r--r--   0        0        0     1008 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/mnq/v1alpha1/__init__.py
--rw-r--r--   0        0        0    16288 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/mnq/v1alpha1/api.py
--rw-r--r--   0        0        0     7563 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/mnq/v1alpha1/marshalling.py
--rw-r--r--   0        0        0     8725 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/mnq/v1alpha1/types.py
--rw-r--r--   0        0        0        0 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/py.typed
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/rdb/__init__.py
--rw-r--r--   0        0        0     5874 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/rdb/v1/__init__.py
--rw-r--r--   0        0        0   103268 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/rdb/v1/api.py
--rw-r--r--   0        0        0     1923 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/rdb/v1/content.py
--rw-r--r--   0        0        0    41536 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/rdb/v1/marshalling.py
--rw-r--r--   0        0        0    50927 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/rdb/v1/types.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/redis/__init__.py
--rw-r--r--   0        0        0     1934 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/redis/v1/__init__.py
--rw-r--r--   0        0        0    38169 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/redis/v1/api.py
--rw-r--r--   0        0        0      489 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/redis/v1/content.py
--rw-r--r--   0        0        0    16095 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/redis/v1/marshalling.py
--rw-r--r--   0        0        0    18601 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/redis/v1/types.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/registry/__init__.py
--rw-r--r--   0        0        0     1190 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/registry/v1/__init__.py
--rw-r--r--   0        0        0    25059 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/registry/v1/api.py
--rw-r--r--   0        0        0      713 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/registry/v1/content.py
--rw-r--r--   0        0        0     6029 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/registry/v1/marshalling.py
--rw-r--r--   0        0        0    10933 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/registry/v1/types.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/secret/__init__.py
--rw-r--r--   0        0        0      720 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/secret/v1alpha1/__init__.py
--rw-r--r--   0        0        0    27369 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/secret/v1alpha1/api.py
--rw-r--r--   0        0        0     4727 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/secret/v1alpha1/marshalling.py
--rw-r--r--   0        0        0     9711 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/secret/v1alpha1/types.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/tem/__init__.py
--rw-r--r--   0        0        0     1098 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/tem/v1alpha1/__init__.py
--rw-r--r--   0        0        0    20587 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/tem/v1alpha1/api.py
--rw-r--r--   0        0        0      551 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/tem/v1alpha1/content.py
--rw-r--r--   0        0        0     8098 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/tem/v1alpha1/marshalling.py
--rw-r--r--   0        0        0    10633 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/tem/v1alpha1/types.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/test/__init__.py
--rw-r--r--   0        0        0      598 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/test/v1/__init__.py
--rw-r--r--   0        0        0    11879 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/test/v1/api.py
--rw-r--r--   0        0        0      350 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/test/v1/content.py
--rw-r--r--   0        0        0     4376 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/test/v1/marshalling.py
--rw-r--r--   0        0        0     3298 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/test/v1/types.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/vpc/__init__.py
--rw-r--r--   0        0        0      416 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/vpc/v1/__init__.py
--rw-r--r--   0        0        0    10109 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/vpc/v1/api.py
--rw-r--r--   0        0        0     2448 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/vpc/v1/marshalling.py
--rw-r--r--   0        0        0     4014 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/vpc/v1/types.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/vpcgw/__init__.py
--rw-r--r--   0        0        0     2168 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/vpcgw/v1/__init__.py
--rw-r--r--   0        0        0    68382 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/vpcgw/v1/api.py
--rw-r--r--   0        0        0      757 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/vpcgw/v1/content.py
--rw-r--r--   0        0        0    19645 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/vpcgw/v1/marshalling.py
--rw-r--r--   0        0        0    33321 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/vpcgw/v1/types.py
--rw-r--r--   0        0        0      127 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/webhosting/__init__.py
--rw-r--r--   0        0        0     1316 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/webhosting/v1alpha1/__init__.py
--rw-r--r--   0        0        0    14508 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/webhosting/v1alpha1/api.py
--rw-r--r--   0        0        0      393 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/webhosting/v1alpha1/content.py
--rw-r--r--   0        0        0     7639 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/webhosting/v1alpha1/marshalling.py
--rw-r--r--   0        0        0     8918 2023-03-08 16:40:37.492112 scaleway_async-0.9.0/scaleway_async/webhosting/v1alpha1/types.py
--rw-r--r--   0        0        0     1258 1970-01-01 00:00:00.000000 scaleway_async-0.9.0/PKG-INFO
+-rw-r--r--   0        0        0       30 2023-08-07 09:31:21.967370 scaleway_async-1.0.0/README.md
+-rw-r--r--   0        0        0     1123 2023-08-07 09:31:44.879675 scaleway_async-1.0.0/pyproject.toml
+-rw-r--r--   0        0        0      913 2023-08-07 09:31:21.967370 scaleway_async-1.0.0/scaleway_async/__init__.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.967370 scaleway_async-1.0.0/scaleway_async/account/__init__.py
+-rw-r--r--   0        0        0      382 2023-08-07 09:31:21.967370 scaleway_async-1.0.0/scaleway_async/account/v2/__init__.py
+-rw-r--r--   0        0        0     8672 2023-08-07 09:31:21.967370 scaleway_async-1.0.0/scaleway_async/account/v2/api.py
+-rw-r--r--   0        0        0     2500 2023-08-07 09:31:21.967370 scaleway_async-1.0.0/scaleway_async/account/v2/marshalling.py
+-rw-r--r--   0        0        0     2636 2023-08-07 09:31:21.967370 scaleway_async-1.0.0/scaleway_async/account/v2/types.py
+-rw-r--r--   0        0        0      396 2023-08-07 09:31:21.967370 scaleway_async-1.0.0/scaleway_async/account/v3/__init__.py
+-rw-r--r--   0        0        0     8342 2023-08-07 09:31:21.967370 scaleway_async-1.0.0/scaleway_async/account/v3/api.py
+-rw-r--r--   0        0        0     2560 2023-08-07 09:31:21.967370 scaleway_async-1.0.0/scaleway_async/account/v3/marshalling.py
+-rw-r--r--   0        0        0     2676 2023-08-07 09:31:21.967370 scaleway_async-1.0.0/scaleway_async/account/v3/types.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/applesilicon/__init__.py
+-rw-r--r--   0        0        0      968 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/applesilicon/v1alpha1/__init__.py
+-rw-r--r--   0        0        0    18230 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/applesilicon/v1alpha1/api.py
+-rw-r--r--   0        0        0      497 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/applesilicon/v1alpha1/content.py
+-rw-r--r--   0        0        0     6527 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/applesilicon/v1alpha1/marshalling.py
+-rw-r--r--   0        0        0     7305 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/applesilicon/v1alpha1/types.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/baremetal/__init__.py
+-rw-r--r--   0        0        0     3212 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/baremetal/v1/__init__.py
+-rw-r--r--   0        0        0    53458 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/baremetal/v1/api.py
+-rw-r--r--   0        0        0     1066 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/baremetal/v1/content.py
+-rw-r--r--   0        0        0    26856 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/baremetal/v1/marshalling.py
+-rw-r--r--   0        0        0    28859 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/baremetal/v1/types.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/billing/__init__.py
+-rw-r--r--   0        0        0      698 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/billing/v2alpha1/__init__.py
+-rw-r--r--   0        0        0     4436 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/billing/v2alpha1/api.py
+-rw-r--r--   0        0        0     3385 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/billing/v2alpha1/marshalling.py
+-rw-r--r--   0        0        0     4206 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/billing/v2alpha1/types.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/cockpit/__init__.py
+-rw-r--r--   0        0        0     1468 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/cockpit/v1beta1/__init__.py
+-rw-r--r--   0        0        0    26849 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/cockpit/v1beta1/api.py
+-rw-r--r--   0        0        0      419 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/cockpit/v1beta1/content.py
+-rw-r--r--   0        0        0    15740 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/cockpit/v1beta1/marshalling.py
+-rw-r--r--   0        0        0    10634 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/cockpit/v1beta1/types.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/container/__init__.py
+-rw-r--r--   0        0        0     3386 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/container/v1beta1/__init__.py
+-rw-r--r--   0        0        0    65864 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/container/v1beta1/api.py
+-rw-r--r--   0        0        0     1587 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/container/v1beta1/content.py
+-rw-r--r--   0        0        0    26245 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/container/v1beta1/marshalling.py
+-rw-r--r--   0        0        0    28456 2023-08-07 09:31:21.971370 scaleway_async-1.0.0/scaleway_async/container/v1beta1/types.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/domain/__init__.py
+-rw-r--r--   0        0        0     8426 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/domain/v2beta1/__init__.py
+-rw-r--r--   0        0        0    87528 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/domain/v2beta1/api.py
+-rw-r--r--   0        0        0     1955 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/domain/v2beta1/content.py
+-rw-r--r--   0        0        0    88058 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/domain/v2beta1/marshalling.py
+-rw-r--r--   0        0        0    40494 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/domain/v2beta1/types.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/flexibleip/__init__.py
+-rw-r--r--   0        0        0      978 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/flexibleip/v1alpha1/__init__.py
+-rw-r--r--   0        0        0    20847 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/flexibleip/v1alpha1/api.py
+-rw-r--r--   0        0        0      651 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/flexibleip/v1alpha1/content.py
+-rw-r--r--   0        0        0     7038 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/flexibleip/v1alpha1/marshalling.py
+-rw-r--r--   0        0        0     9176 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/flexibleip/v1alpha1/types.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/function/__init__.py
+-rw-r--r--   0        0        0     3642 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/function/v1beta1/__init__.py
+-rw-r--r--   0        0        0    64980 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/function/v1beta1/api.py
+-rw-r--r--   0        0        0     1579 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/function/v1beta1/content.py
+-rw-r--r--   0        0        0    28021 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/function/v1beta1/marshalling.py
+-rw-r--r--   0        0        0    30155 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/function/v1beta1/types.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/iam/__init__.py
+-rw-r--r--   0        0        0     2300 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/iam/v1alpha1/__init__.py
+-rw-r--r--   0        0        0    74957 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/iam/v1alpha1/api.py
+-rw-r--r--   0        0        0    26114 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/iam/v1alpha1/marshalling.py
+-rw-r--r--   0        0        0    30264 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/iam/v1alpha1/types.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/instance/__init__.py
+-rw-r--r--   0        0        0     8194 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/instance/v1/__init__.py
+-rw-r--r--   0        0        0   131162 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/instance/v1/api.py
+-rw-r--r--   0        0        0     2210 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/instance/v1/content.py
+-rw-r--r--   0        0        0    97574 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/instance/v1/marshalling.py
+-rw-r--r--   0        0        0    57214 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/instance/v1/types.py
+-rw-r--r--   0        0        0    11049 2023-08-07 09:31:21.975370 scaleway_async-1.0.0/scaleway_async/instance/v1/types_private.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/iot/__init__.py
+-rw-r--r--   0        0        0     3456 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/iot/v1/__init__.py
+-rw-r--r--   0        0        0    62302 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/iot/v1/api.py
+-rw-r--r--   0        0        0      364 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/iot/v1/content.py
+-rw-r--r--   0        0        0    31989 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/iot/v1/marshalling.py
+-rw-r--r--   0        0        0    33256 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/iot/v1/types.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/k8s/__init__.py
+-rw-r--r--   0        0        0     3430 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/k8s/v1/__init__.py
+-rw-r--r--   0        0        0    58254 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/k8s/v1/api.py
+-rw-r--r--   0        0        0      937 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/k8s/v1/content.py
+-rw-r--r--   0        0        0    34447 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/k8s/v1/marshalling.py
+-rw-r--r--   0        0        0    45370 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/k8s/v1/types.py
+-rw-r--r--   0        0        0      540 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/k8s/v1/types_private.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/lb/__init__.py
+-rw-r--r--   0        0        0     5060 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/lb/v1/__init__.py
+-rw-r--r--   0        0        0   226461 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/lb/v1/api.py
+-rw-r--r--   0        0        0     1111 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/lb/v1/content.py
+-rw-r--r--   0        0        0    83655 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/lb/v1/marshalling.py
+-rw-r--r--   0        0        0   102503 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/lb/v1/types.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/marketplace/__init__.py
+-rw-r--r--   0        0        0      636 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/marketplace/v1/__init__.py
+-rw-r--r--   0        0        0     4172 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/marketplace/v1/api.py
+-rw-r--r--   0        0        0     5360 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/marketplace/v1/marshalling.py
+-rw-r--r--   0        0        0     3161 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/marketplace/v1/types.py
+-rw-r--r--   0        0        0      948 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/marketplace/v2/__init__.py
+-rw-r--r--   0        0        0    14905 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/marketplace/v2/api.py
+-rw-r--r--   0        0        0     5380 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/marketplace/v2/marshalling.py
+-rw-r--r--   0        0        0     5365 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/marketplace/v2/types.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/mnq/__init__.py
+-rw-r--r--   0        0        0     1008 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/mnq/v1alpha1/__init__.py
+-rw-r--r--   0        0        0    18549 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/mnq/v1alpha1/api.py
+-rw-r--r--   0        0        0     8332 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/mnq/v1alpha1/marshalling.py
+-rw-r--r--   0        0        0     9028 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/mnq/v1alpha1/types.py
+-rw-r--r--   0        0        0        0 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/py.typed
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/rdb/__init__.py
+-rw-r--r--   0        0        0     5874 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/rdb/v1/__init__.py
+-rw-r--r--   0        0        0   118057 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/rdb/v1/api.py
+-rw-r--r--   0        0        0     1956 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/rdb/v1/content.py
+-rw-r--r--   0        0        0    50774 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/rdb/v1/marshalling.py
+-rw-r--r--   0        0        0    53443 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/rdb/v1/types.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/redis/__init__.py
+-rw-r--r--   0        0        0     2130 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/redis/v1/__init__.py
+-rw-r--r--   0        0        0    44493 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/redis/v1/api.py
+-rw-r--r--   0        0        0      489 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/redis/v1/content.py
+-rw-r--r--   0        0        0    20527 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/redis/v1/marshalling.py
+-rw-r--r--   0        0        0    19830 2023-08-07 09:31:21.979370 scaleway_async-1.0.0/scaleway_async/redis/v1/types.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/registry/__init__.py
+-rw-r--r--   0        0        0     1190 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/registry/v1/__init__.py
+-rw-r--r--   0        0        0    29053 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/registry/v1/api.py
+-rw-r--r--   0        0        0      713 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/registry/v1/content.py
+-rw-r--r--   0        0        0     7013 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/registry/v1/marshalling.py
+-rw-r--r--   0        0        0    11691 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/registry/v1/types.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/secret/__init__.py
+-rw-r--r--   0        0        0      946 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/secret/v1alpha1/__init__.py
+-rw-r--r--   0        0        0    42808 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/secret/v1alpha1/api.py
+-rw-r--r--   0        0        0     9169 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/secret/v1alpha1/marshalling.py
+-rw-r--r--   0        0        0    16883 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/secret/v1alpha1/types.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/tem/__init__.py
+-rw-r--r--   0        0        0     1522 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/tem/v1alpha1/__init__.py
+-rw-r--r--   0        0        0    24987 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/tem/v1alpha1/api.py
+-rw-r--r--   0        0        0      551 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/tem/v1alpha1/content.py
+-rw-r--r--   0        0        0    11457 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/tem/v1alpha1/marshalling.py
+-rw-r--r--   0        0        0    14380 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/tem/v1alpha1/types.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/test/__init__.py
+-rw-r--r--   0        0        0      598 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/test/v1/__init__.py
+-rw-r--r--   0        0        0    12099 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/test/v1/api.py
+-rw-r--r--   0        0        0      350 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/test/v1/content.py
+-rw-r--r--   0        0        0     5840 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/test/v1/marshalling.py
+-rw-r--r--   0        0        0     3303 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/test/v1/types.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/vpc/__init__.py
+-rw-r--r--   0        0        0      416 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/vpc/v1/__init__.py
+-rw-r--r--   0        0        0    11833 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/vpc/v1/api.py
+-rw-r--r--   0        0        0     2898 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/vpc/v1/marshalling.py
+-rw-r--r--   0        0        0     4346 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/vpc/v1/types.py
+-rw-r--r--   0        0        0      820 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/vpc/v2/__init__.py
+-rw-r--r--   0        0        0    29529 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/vpc/v2/api.py
+-rw-r--r--   0        0        0     9247 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/vpc/v2/marshalling.py
+-rw-r--r--   0        0        0    10566 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/vpc/v2/types.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/vpcgw/__init__.py
+-rw-r--r--   0        0        0     2168 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/vpcgw/v1/__init__.py
+-rw-r--r--   0        0        0    79348 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/vpcgw/v1/api.py
+-rw-r--r--   0        0        0      757 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/vpcgw/v1/content.py
+-rw-r--r--   0        0        0    25219 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/vpcgw/v1/marshalling.py
+-rw-r--r--   0        0        0    35284 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/vpcgw/v1/types.py
+-rw-r--r--   0        0        0      127 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/webhosting/__init__.py
+-rw-r--r--   0        0        0     1378 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/webhosting/v1alpha1/__init__.py
+-rw-r--r--   0        0        0    17184 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/webhosting/v1alpha1/api.py
+-rw-r--r--   0        0        0      422 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/webhosting/v1alpha1/content.py
+-rw-r--r--   0        0        0     8924 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/webhosting/v1alpha1/marshalling.py
+-rw-r--r--   0        0        0    10942 2023-08-07 09:31:21.983370 scaleway_async-1.0.0/scaleway_async/webhosting/v1alpha1/types.py
+-rw-r--r--   0        0        0     1059 1970-01-01 00:00:00.000000 scaleway_async-1.0.0/PKG-INFO
```

### Comparing `scaleway_async-0.9.0/pyproject.toml` & `scaleway_async-1.0.0/pyproject.toml`

 * *Files 10% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 [tool.poetry]
 name = "scaleway-async"
-version = "0.9.0"
+version = "1.0.0"
 description = "Scaleway SDK for Python"
 authors = ["Scaleway <opensource@scaleway.com>"]
 license = "BSD"
 readme = "README.md"
 classifiers = [
     "Development Status :: 3 - Alpha",
     "Environment :: Console",
@@ -20,18 +20,18 @@
     "Programming Language :: Python :: 3.9",
     "Programming Language :: Python :: 3.10",
     "Topic :: Software Development",
 ]
 
 [tool.poetry.dependencies]
 python = "^3.8"
-scaleway-core = "^0"
+scaleway-core = "^1"
 
 [tool.poetry.group.dev.dependencies]
-mypy = "^0"
+mypy = "*"
 black = "^22.10.0"
 bandit = { extras = ["toml"], version = "^1.7.4" }
 scaleway-core = { path = "../scaleway-core", develop = true }
 
 [build-system]
 requires = ["poetry-core"]
 build-backend = "poetry.core.masonry.api"
```

### Comparing `scaleway_async-0.9.0/scaleway_async/__init__.py` & `scaleway_async-1.0.0/scaleway_async/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-0.9.0/scaleway_async/account/v2/api.py` & `scaleway_async-1.0.0/scaleway_async/account/v3/api.py`

 * *Files 24% similar despite different names*

```diff
@@ -2,66 +2,68 @@
 # If you have any remark or suggestion do not hesitate to open an issue.
 
 from typing import List, Optional
 
 from scaleway_core.api import API
 from scaleway_core.utils import (
     fetch_all_pages_async,
+    random_name,
     validate_path_param,
 )
 from .types import (
     ListProjectsRequestOrderBy,
     ListProjectsResponse,
     Project,
-    CreateProjectRequest,
-    UpdateProjectRequest,
+    ProjectApiCreateProjectRequest,
+    ProjectApiUpdateProjectRequest,
 )
 from .marshalling import (
-    marshal_CreateProjectRequest,
-    marshal_UpdateProjectRequest,
+    marshal_ProjectApiCreateProjectRequest,
+    marshal_ProjectApiUpdateProjectRequest,
     unmarshal_Project,
     unmarshal_ListProjectsResponse,
 )
 
 
-class AccountV2API(API):
+class AccountProjectV3API(API):
     """
     Account API.
 
     This API allows you to manage projects.
     """
 
     async def create_project(
         self,
         *,
-        name: str,
+        description: str,
+        name: Optional[str] = None,
         organization_id: Optional[str] = None,
-        description: Optional[str] = None,
     ) -> Project:
         """
-        Create project
-        :param name: The name of the project.
-        :param organization_id: The organization ID of the project.
-        :param description: The description of the project.
+        Create a new Project for an Organization.
+        Generate a new Project for an Organization, specifying its configuration including name and description.
+        :param name: Name of the Project.
+        :param organization_id: Organization ID of the Project.
+        :param description: Description of the Project.
         :return: :class:`Project <Project>`
 
         Usage:
         ::
 
-            result = await api.create_project(name="example")
+            result = await api.create_project(description="example")
         """
 
         res = self._request(
             "POST",
-            f"/account/v2/projects",
-            body=marshal_CreateProjectRequest(
-                CreateProjectRequest(
-                    name=name,
-                    organization_id=organization_id,
+            f"/account/v3/projects",
+            body=marshal_ProjectApiCreateProjectRequest(
+                ProjectApiCreateProjectRequest(
                     description=description,
+                    name=name or random_name(prefix="proj"),
+                    organization_id=organization_id,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_Project(res.json())
@@ -73,32 +75,33 @@
         name: Optional[str] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListProjectsRequestOrderBy = ListProjectsRequestOrderBy.CREATED_AT_ASC,
         project_ids: Optional[List[str]] = None,
     ) -> ListProjectsResponse:
         """
-        List projects
-        :param organization_id: The organization ID of the project.
-        :param name: The name of the project.
-        :param page: The page number for the returned projects.
-        :param page_size: The maximum number of project per page.
-        :param order_by: The sort order of the returned projects.
-        :param project_ids: Filter out by a list of project ID.
+        List all Projects of an Organization.
+        List all Projects of an Organization. The response will include the total number of Projects as well as their associated Organizations, names, and IDs. Other information includes the creation and update date of the Project.
+        :param organization_id: Organization ID of the Project.
+        :param name: Name of the Project.
+        :param page: Page number for the returned Projects.
+        :param page_size: Maximum number of Project per page.
+        :param order_by: Sort order of the returned Projects.
+        :param project_ids: Project IDs to filter for. The results will be limited to any Projects with an ID in this array.
         :return: :class:`ListProjectsResponse <ListProjectsResponse>`
 
         Usage:
         ::
 
             result = await api.list_projects()
         """
 
         res = self._request(
             "GET",
-            f"/account/v2/projects",
+            f"/account/v3/projects",
             params={
                 "name": name,
                 "order_by": order_by,
                 "organization_id": organization_id
                 or self.client.default_organization_id,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
@@ -116,21 +119,22 @@
         name: Optional[str] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListProjectsRequestOrderBy] = None,
         project_ids: Optional[List[str]] = None,
     ) -> List[Project]:
         """
-        List projects
-        :param organization_id: The organization ID of the project.
-        :param name: The name of the project.
-        :param page: The page number for the returned projects.
-        :param page_size: The maximum number of project per page.
-        :param order_by: The sort order of the returned projects.
-        :param project_ids: Filter out by a list of project ID.
+        List all Projects of an Organization.
+        List all Projects of an Organization. The response will include the total number of Projects as well as their associated Organizations, names, and IDs. Other information includes the creation and update date of the Project.
+        :param organization_id: Organization ID of the Project.
+        :param name: Name of the Project.
+        :param page: Page number for the returned Projects.
+        :param page_size: Maximum number of Project per page.
+        :param order_by: Sort order of the returned Projects.
+        :param project_ids: Project IDs to filter for. The results will be limited to any Projects with an ID in this array.
         :return: :class:`List[ListProjectsResponse] <List[ListProjectsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_projects_all()
         """
@@ -151,92 +155,95 @@
 
     async def get_project(
         self,
         *,
         project_id: Optional[str] = None,
     ) -> Project:
         """
-        Get project
-        :param project_id: The project ID of the project.
+        Get an existing Project.
+        Retrieve information about an existing Project, specified by its Project ID. Its full details, including ID, name and description, are returned in the response object.
+        :param project_id: Project ID of the Project.
         :return: :class:`Project <Project>`
 
         Usage:
         ::
 
             result = await api.get_project()
         """
 
         param_project_id = validate_path_param(
             "project_id", project_id or self.client.default_project_id
         )
 
         res = self._request(
             "GET",
-            f"/account/v2/projects/{param_project_id}",
+            f"/account/v3/projects/{param_project_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_Project(res.json())
 
     async def delete_project(
         self,
         *,
         project_id: Optional[str] = None,
     ) -> Optional[None]:
         """
-        Delete project
-        :param project_id: The project ID of the project.
+        Delete an existing Project.
+        Delete an existing Project, specified by its Project ID. The Project needs to be empty (meaning there are no resources left in it) to be deleted effectively. Note that deleting a Project is permanent, and cannot be undone.
+        :param project_id: Project ID of the Project.
 
         Usage:
         ::
 
             result = await api.delete_project()
         """
 
         param_project_id = validate_path_param(
             "project_id", project_id or self.client.default_project_id
         )
 
         res = self._request(
             "DELETE",
-            f"/account/v2/projects/{param_project_id}",
+            f"/account/v3/projects/{param_project_id}",
         )
 
         self._throw_on_error(res)
         return None
 
     async def update_project(
         self,
         *,
         project_id: Optional[str] = None,
         name: Optional[str] = None,
         description: Optional[str] = None,
     ) -> Project:
         """
-        Update project
-        :param project_id: The project ID of the project.
-        :param name: The name of the project.
-        :param description: The description of the project.
+        Update Project.
+        Update the parameters of an existing Project, specified by its Project ID. These parameters include the name and description.
+        :param project_id: Project ID of the Project.
+        :param name: Name of the Project.
+        :param description: Description of the Project.
         :return: :class:`Project <Project>`
 
         Usage:
         ::
 
             result = await api.update_project()
         """
 
         param_project_id = validate_path_param(
             "project_id", project_id or self.client.default_project_id
         )
 
         res = self._request(
             "PATCH",
-            f"/account/v2/projects/{param_project_id}",
-            body=marshal_UpdateProjectRequest(
-                UpdateProjectRequest(
+            f"/account/v3/projects/{param_project_id}",
+            body=marshal_ProjectApiUpdateProjectRequest(
+                ProjectApiUpdateProjectRequest(
                     project_id=project_id,
                     name=name,
                     description=description,
                 ),
                 self.client,
             ),
         )
```

### Comparing `scaleway_async-0.9.0/scaleway_async/account/v2/marshalling.py` & `scaleway_async-1.0.0/scaleway_async/account/v3/marshalling.py`

 * *Files 13% similar despite different names*

```diff
@@ -4,77 +4,93 @@
 from typing import Any, Dict
 
 from scaleway_core.profile import ProfileDefaults
 from dateutil import parser
 from .types import (
     ListProjectsResponse,
     Project,
-    CreateProjectRequest,
-    UpdateProjectRequest,
+    ProjectApiCreateProjectRequest,
+    ProjectApiUpdateProjectRequest,
 )
 
 
 def unmarshal_Project(data: Any) -> Project:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Project' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("description")
+    field = data.get("description", None)
     args["description"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("organization_id")
+    field = data.get("organization_id", None)
     args["organization_id"] = field
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
     return Project(**args)
 
 
 def unmarshal_ListProjectsResponse(data: Any) -> ListProjectsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListProjectsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("projects")
-    args["projects"] = [unmarshal_Project(v) for v in data["projects"]]
+    field = data.get("projects", None)
+    args["projects"] = (
+        [unmarshal_Project(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListProjectsResponse(**args)
 
 
-def marshal_CreateProjectRequest(
-    request: CreateProjectRequest,
+def marshal_ProjectApiCreateProjectRequest(
+    request: ProjectApiCreateProjectRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "description": request.description,
-        "name": request.name,
-        "organization_id": request.organization_id or defaults.default_organization_id,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.description is not None:
+        output["description"] = request.description
 
-def marshal_UpdateProjectRequest(
-    request: UpdateProjectRequest,
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.organization_id is not None:
+        output["organization_id"] = (
+            request.organization_id or defaults.default_organization_id
+        )
+
+    return output
+
+
+def marshal_ProjectApiUpdateProjectRequest(
+    request: ProjectApiUpdateProjectRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "description": request.description,
-        "name": request.name,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
```

### Comparing `scaleway_async-0.9.0/scaleway_async/account/v2/types.py` & `scaleway_async-1.0.0/scaleway_async/account/v2/types.py`

 * *Files 10% similar despite different names*

```diff
@@ -22,136 +22,136 @@
 class ListProjectsResponse:
     """
     List projects response.
     """
 
     total_count: int
     """
-    The total number of projects.
+    Total number of Projects.
     """
 
     projects: List[Project]
     """
-    The paginated returned projects.
+    Paginated returned Projects.
     """
 
 
 @dataclass
 class Project:
     """
     Project.
     """
 
     id: str
     """
-    The ID of the project.
+    ID of the Project.
     """
 
     name: str
     """
-    The name of the project.
+    Name of the Project.
     """
 
     organization_id: str
     """
-    The organization ID of the project.
+    Organization ID of the Project.
     """
 
     created_at: Optional[datetime]
     """
-    The creation date of the project.
+    Creation date of the Project.
     """
 
     updated_at: Optional[datetime]
     """
-    The update date of the project.
+    Update date of the Project.
     """
 
     description: str
     """
-    The description of the project.
+    Description of the Project.
     """
 
 
 @dataclass
 class CreateProjectRequest:
-    name: str
+    name: Optional[str]
     """
-    The name of the project.
+    Name of the Project.
     """
 
     organization_id: Optional[str]
     """
-    The organization ID of the project.
+    Organization ID of the Project.
     """
 
     description: Optional[str]
     """
-    The description of the project.
+    Description of the Project.
     """
 
 
 @dataclass
 class ListProjectsRequest:
     organization_id: Optional[str]
     """
-    The organization ID of the project.
+    Organization ID of the Project.
     """
 
     name: Optional[str]
     """
-    The name of the project.
+    Name of the Project.
     """
 
     page: Optional[int]
     """
-    The page number for the returned projects.
+    Page number for the returned Projects.
     """
 
     page_size: Optional[int]
     """
-    The maximum number of project per page.
+    Maximum number of Project per page.
     """
 
     order_by: Optional[ListProjectsRequestOrderBy]
     """
-    The sort order of the returned projects.
+    Sort order of the returned Projects.
     """
 
     project_ids: Optional[List[str]]
     """
-    Filter out by a list of project ID.
+    Project IDs to filter for. The results will be limited to any Projects with an ID in this array.
     """
 
 
 @dataclass
 class GetProjectRequest:
     project_id: Optional[str]
     """
-    The project ID of the project.
+    Project ID of the Project.
     """
 
 
 @dataclass
 class DeleteProjectRequest:
     project_id: Optional[str]
     """
-    The project ID of the project.
+    Project ID of the Project.
     """
 
 
 @dataclass
 class UpdateProjectRequest:
     project_id: Optional[str]
     """
-    The project ID of the project.
+    Project ID of the Project.
     """
 
     name: Optional[str]
     """
-    The name of the project.
+    Name of the Project.
     """
 
     description: Optional[str]
     """
-    The description of the project.
+    Description of the Project.
     """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/applesilicon/v1alpha1/__init__.py` & `scaleway_async-1.0.0/scaleway_async/applesilicon/v1alpha1/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-0.9.0/scaleway_async/applesilicon/v1alpha1/api.py` & `scaleway_async-1.0.0/scaleway_async/applesilicon/v1alpha1/api.py`

 * *Files 18% similar despite different names*

```diff
@@ -38,37 +38,28 @@
     unmarshal_ListServerTypesResponse,
     unmarshal_ListServersResponse,
 )
 
 
 class ApplesiliconV1Alpha1API(API):
     """
-    Apple silicon.
+    Apple silicon API.
 
-    Scaleway Apple silicon M1 as-a-Service is built using the latest generation of Apple Mac mini hardware (fifth generation).
-
-    These dedicated Mac mini M1s are designed for developing, building, testing, and signing applications for Apple devices, including iPhones, iPads, Mac computers and much more.
-
-    Get set to explore, learn and build on a dedicated Mac mini M1 with more performance and speed than you ever thought possible.
-
-    **Apple silicon as a Service comes with a minimum allocation period of 24 hours**.
-
-    Mac mini and macOS are trademarks of Apple Inc., registered in the U.S. and other countries and regions.
-    IOS is a trademark or registered trademark of Cisco in the U.S. and other countries and is used by Apple under license.
-    Scaleway is not affiliated with Apple Inc.
+    Apple silicon API.
     """
 
     async def list_server_types(
         self,
         *,
         zone: Optional[Zone] = None,
     ) -> ListServerTypesResponse:
         """
-        List all server types technical details.
-        :param zone: Zone to target. If none is passed will use default zone from the config
+        List server types.
+        List all technical details about Apple silicon server types available in the specified zone. Since there is only one Availability Zone for Apple silicon servers, the targeted value is `fr-par-3`.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
         :return: :class:`ListServerTypesResponse <ListServerTypesResponse>`
 
         Usage:
         ::
 
             result = await api.list_server_types()
         """
@@ -86,17 +77,18 @@
     async def get_server_type(
         self,
         *,
         server_type: str,
         zone: Optional[Zone] = None,
     ) -> ServerType:
         """
-        Get a server technical details.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_type: Server type identifier
+        Get a server type.
+        Get technical details (CPU, disk size etc.) of a server type.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_type: Server type identifier.
         :return: :class:`ServerType <ServerType>`
 
         Usage:
         ::
 
             result = await api.get_server_type(server_type="example")
         """
@@ -118,18 +110,19 @@
         type_: str,
         zone: Optional[Zone] = None,
         name: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> Server:
         """
         Create a server.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param name: Create a server with this given name
-        :param project_id: Create a server in the given project ID
-        :param type_: Create a server of the given type
+        Create a new server in the targeted zone, specifying its configuration including name and type.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param name: Create a server with this given name.
+        :param project_id: Create a server in the given project ID.
+        :param type_: Create a server of the given type.
         :return: :class:`Server <Server>`
 
         Usage:
         ::
 
             result = await api.create_server(type_="example")
         """
@@ -161,20 +154,21 @@
         project_id: Optional[str] = None,
         organization_id: Optional[str] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListServersResponse:
         """
         List all servers.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param order_by: The sort order of the returned servers
-        :param project_id: List only servers of this project ID
-        :param organization_id: List only servers of this organization ID
-        :param page: A positive integer to choose the page to return
-        :param page_size: A positive integer lower or equal to 100 to select the number of items to return
+        List all servers in the specified zone. By default, returned servers in the list are ordered by creation date in ascending order, though this can be modified via the `order_by` field.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param order_by: Sort order of the returned servers.
+        :param project_id: Only list servers of this project ID.
+        :param organization_id: Only list servers of this Organization ID.
+        :param page: Positive integer to choose the page to return.
+        :param page_size: Positive integer lower or equal to 100 to select the number of items to return.
         :return: :class:`ListServersResponse <ListServersResponse>`
 
         Usage:
         ::
 
             result = await api.list_servers()
         """
@@ -205,20 +199,21 @@
         project_id: Optional[str] = None,
         organization_id: Optional[str] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[Server]:
         """
         List all servers.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param order_by: The sort order of the returned servers
-        :param project_id: List only servers of this project ID
-        :param organization_id: List only servers of this organization ID
-        :param page: A positive integer to choose the page to return
-        :param page_size: A positive integer lower or equal to 100 to select the number of items to return
+        List all servers in the specified zone. By default, returned servers in the list are ordered by creation date in ascending order, though this can be modified via the `order_by` field.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param order_by: Sort order of the returned servers.
+        :param project_id: Only list servers of this project ID.
+        :param organization_id: Only list servers of this Organization ID.
+        :param page: Positive integer to choose the page to return.
+        :param page_size: Positive integer lower or equal to 100 to select the number of items to return.
         :return: :class:`List[ListServersResponse] <List[ListServersResponse]>`
 
         Usage:
         ::
 
             result = await api.list_servers_all()
         """
@@ -243,20 +238,21 @@
         zone: Optional[Zone] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         server_type: Optional[str] = None,
         name: Optional[str] = None,
     ) -> ListOSResponse:
         """
-        List all Operating System (OS).
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param page: A positive integer to choose the page to return
-        :param page_size: A positive integer lower or equal to 100 to select the number of items to return
-        :param server_type: List of compatible server type
-        :param name: Filter os by name (for eg. "11.1" will return "11.1.2" and "11.1" but not "12")
+        List all Operating Systems (OS).
+        List all Operating Systems (OS). The response will include the total number of OS as well as their associated IDs, names and labels.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param page: Positive integer to choose the page to return.
+        :param page_size: Positive integer lower or equal to 100 to select the number of items to return.
+        :param server_type: List of compatible server types.
+        :param name: Filter OS by name (note that "11.1" will return "11.1.2" and "11.1" but not "12")).
         :return: :class:`ListOSResponse <ListOSResponse>`
 
         Usage:
         ::
 
             result = await api.list_os()
         """
@@ -283,20 +279,21 @@
         zone: Optional[Zone] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         server_type: Optional[str] = None,
         name: Optional[str] = None,
     ) -> List[OS]:
         """
-        List all Operating System (OS).
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param page: A positive integer to choose the page to return
-        :param page_size: A positive integer lower or equal to 100 to select the number of items to return
-        :param server_type: List of compatible server type
-        :param name: Filter os by name (for eg. "11.1" will return "11.1.2" and "11.1" but not "12")
+        List all Operating Systems (OS).
+        List all Operating Systems (OS). The response will include the total number of OS as well as their associated IDs, names and labels.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param page: Positive integer to choose the page to return.
+        :param page_size: Positive integer lower or equal to 100 to select the number of items to return.
+        :param server_type: List of compatible server types.
+        :param name: Filter OS by name (note that "11.1" will return "11.1.2" and "11.1" but not "12")).
         :return: :class:`List[ListOSResponse] <List[ListOSResponse]>`
 
         Usage:
         ::
 
             result = await api.list_os_all()
         """
@@ -318,16 +315,17 @@
         self,
         *,
         os_id: str,
         zone: Optional[Zone] = None,
     ) -> OS:
         """
         Get an Operating System (OS).
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param os_id: UUID of the OS you want to get
+        Get an Operating System (OS).  The response will include the OS's unique ID as well as its name and label.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param os_id: UUID of the OS you want to get.
         :return: :class:`OS <OS>`
 
         Usage:
         ::
 
             result = await api.get_os(os_id="example")
         """
@@ -347,16 +345,17 @@
         self,
         *,
         server_id: str,
         zone: Optional[Zone] = None,
     ) -> Server:
         """
         Get a server.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: UUID of the server you want to get
+        Retrieve information about an existing Apple silicon server, specified by its server ID. Its full details, including name, status and IP address, are returned in the response object.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: UUID of the server you want to get.
         :return: :class:`Server <Server>`
 
         Usage:
         ::
 
             result = await api.get_server(server_id="example")
         """
@@ -377,16 +376,16 @@
         *,
         server_id: str,
         zone: Optional[Zone] = None,
         options: Optional[WaitForOptions[Server, Union[bool, Awaitable[bool]]]] = None,
     ) -> Server:
         """
         Waits for :class:`Server <Server>` to be in a final state.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: UUID of the server you want to get
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: UUID of the server you want to get.
         :param options: The options for the waiter
         :return: :class:`Server <Server>`
 
         Usage:
         ::
 
             result = api.wait_for_server(server_id="example")
@@ -412,17 +411,18 @@
         *,
         server_id: str,
         name: str,
         zone: Optional[Zone] = None,
     ) -> Server:
         """
         Update a server.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: UUID of the server you want to update
-        :param name: Updated name for your server
+        Update the parameters of an existing Apple silicon server, specified by its server ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: UUID of the server you want to update.
+        :param name: Updated name for your server.
         :return: :class:`Server <Server>`
 
         Usage:
         ::
 
             result = await api.update_server(
                 server_id="example",
@@ -453,16 +453,17 @@
         self,
         *,
         server_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
         Delete a server.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: UUID of the server you want to delete
+        Delete an existing Apple silicon server, specified by its server ID. Deleting a server is permanent, and cannot be undone. Note that the minimum allocation period for Apple silicon-as-a-service is 24 hours, meaning you cannot delete your server prior to that.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: UUID of the server you want to delete.
 
         Usage:
         ::
 
             result = await api.delete_server(server_id="example")
         """
 
@@ -481,16 +482,17 @@
         self,
         *,
         server_id: str,
         zone: Optional[Zone] = None,
     ) -> Server:
         """
         Reboot a server.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: UUID of the server you want to reboot
+        Reboot an existing Apple silicon server, specified by its server ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: UUID of the server you want to reboot.
         :return: :class:`Server <Server>`
 
         Usage:
         ::
 
             result = await api.reboot_server(server_id="example")
         """
@@ -510,16 +512,17 @@
         self,
         *,
         server_id: str,
         zone: Optional[Zone] = None,
     ) -> Server:
         """
         Reinstall a server.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: UUID of the server you want to reinstall
+        Reinstall an existing Apple silicon server (specified by its server ID) from a new image (OS). All the data on the disk is deleted and all configuration is reset to the defailt configuration values of the image (OS).
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: UUID of the server you want to reinstall.
         :return: :class:`Server <Server>`
 
         Usage:
         ::
 
             result = await api.reinstall_server(server_id="example")
         """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/applesilicon/v1alpha1/marshalling.py` & `scaleway_async-1.0.0/scaleway_async/applesilicon/v1alpha1/marshalling.py`

 * *Files 20% similar despite different names*

```diff
@@ -24,218 +24,232 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ServerTypeCPU' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("core_count")
+    field = data.get("core_count", None)
     args["core_count"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
     return ServerTypeCPU(**args)
 
 
 def unmarshal_ServerTypeDisk(data: Any) -> ServerTypeDisk:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ServerTypeDisk' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("capacity")
+    field = data.get("capacity", None)
     args["capacity"] = field
 
-    field = data.get("type_")
+    field = data.get("type", None)
     args["type_"] = field
 
     return ServerTypeDisk(**args)
 
 
 def unmarshal_ServerTypeMemory(data: Any) -> ServerTypeMemory:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ServerTypeMemory' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("capacity")
+    field = data.get("capacity", None)
     args["capacity"] = field
 
-    field = data.get("type_")
+    field = data.get("type", None)
     args["type_"] = field
 
     return ServerTypeMemory(**args)
 
 
 def unmarshal_OS(data: Any) -> OS:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'OS' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("compatible_server_types")
+    field = data.get("compatible_server_types", None)
     args["compatible_server_types"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("image_url")
+    field = data.get("image_url", None)
     args["image_url"] = field
 
-    field = data.get("label")
+    field = data.get("label", None)
     args["label"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
     return OS(**args)
 
 
 def unmarshal_Server(data: Any) -> Server:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Server' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("deletable_at")
+    field = data.get("deletable_at", None)
     args["deletable_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("ip")
+    field = data.get("ip", None)
     args["ip"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("organization_id")
+    field = data.get("organization_id", None)
     args["organization_id"] = field
 
-    field = data.get("project_id")
+    field = data.get("project_id", None)
     args["project_id"] = field
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("type_")
+    field = data.get("type", None)
     args["type_"] = field
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("vnc_url")
+    field = data.get("vnc_url", None)
     args["vnc_url"] = field
 
-    field = data.get("zone")
+    field = data.get("zone", None)
     args["zone"] = field
 
     return Server(**args)
 
 
 def unmarshal_ServerType(data: Any) -> ServerType:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ServerType' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("cpu")
+    field = data.get("cpu", None)
     args["cpu"] = unmarshal_ServerTypeCPU(field) if field is not None else None
 
-    field = data.get("disk")
+    field = data.get("disk", None)
     args["disk"] = unmarshal_ServerTypeDisk(field) if field is not None else None
 
-    field = data.get("memory")
+    field = data.get("memory", None)
     args["memory"] = unmarshal_ServerTypeMemory(field) if field is not None else None
 
-    field = data.get("minimum_lease_duration")
+    field = data.get("minimum_lease_duration", None)
     args["minimum_lease_duration"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("stock")
+    field = data.get("stock", None)
     args["stock"] = field
 
     return ServerType(**args)
 
 
 def unmarshal_ListOSResponse(data: Any) -> ListOSResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListOSResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("os")
-    args["os"] = [unmarshal_OS(v) for v in data["os"]]
+    field = data.get("os", None)
+    args["os"] = [unmarshal_OS(v) for v in field] if field is not None else None
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListOSResponse(**args)
 
 
 def unmarshal_ListServerTypesResponse(data: Any) -> ListServerTypesResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListServerTypesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("server_types")
-    args["server_types"] = [unmarshal_ServerType(v) for v in data["server_types"]]
+    field = data.get("server_types", None)
+    args["server_types"] = (
+        [unmarshal_ServerType(v) for v in field] if field is not None else None
+    )
 
     return ListServerTypesResponse(**args)
 
 
 def unmarshal_ListServersResponse(data: Any) -> ListServersResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListServersResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("servers")
-    args["servers"] = [unmarshal_Server(v) for v in data["servers"]]
+    field = data.get("servers", None)
+    args["servers"] = (
+        [unmarshal_Server(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListServersResponse(**args)
 
 
 def marshal_CreateServerRequest(
     request: CreateServerRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "name": request.name,
-        "project_id": request.project_id or defaults.default_project_id,
-        "type": request.type_,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    if request.type_ is not None:
+        output["type"] = request.type_
+
+    return output
 
 
 def marshal_UpdateServerRequest(
     request: UpdateServerRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "name": request.name,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
```

### Comparing `scaleway_async-0.9.0/scaleway_async/applesilicon/v1alpha1/types.py` & `scaleway_async-1.0.0/scaleway_async/applesilicon/v1alpha1/types.py`

 * *Files 19% similar despite different names*

```diff
@@ -45,189 +45,190 @@
     def __str__(self) -> str:
         return str(self.value)
 
 
 @dataclass
 class ListOSResponse:
     """
-    List os response
+    List os response.
     """
 
     total_count: int
     """
-    Total number of os
+    Total number of OS.
     """
 
     os: List[OS]
     """
-    List of OS
+    List of OS.
     """
 
 
 @dataclass
 class ListServerTypesResponse:
     """
-    List server types response
+    List server types response.
     """
 
     server_types: List[ServerType]
     """
-    The available server types
+    Available server types.
     """
 
 
 @dataclass
 class ListServersResponse:
     """
-    List servers response
+    List servers response.
     """
 
     total_count: int
     """
-    The total number of servers
+    Total number of servers.
     """
 
     servers: List[Server]
     """
-    The paginated returned servers
+    Paginated returned servers.
     """
 
 
 @dataclass
 class OS:
     """
-    Os
+    Os.
     """
 
     id: str
     """
-    The OS unique ID
+    Unique ID of the OS.
     """
 
     name: str
     """
-    The OS name
+    OS name.
     """
 
     label: str
     """
-    The OS name as it should be displayed
+    OS name as it should be displayed.
     """
 
     image_url: str
     """
-    URL of the image
+    URL of the image.
     """
 
     compatible_server_types: List[str]
     """
-    List of compatible server types
+    List of compatible server types.
     """
 
 
 @dataclass
 class Server:
     """
-    Server
+    Server.
     """
 
     id: str
     """
-    UUID of the server
+    UUID of the server.
     """
 
     type_: str
     """
-    Type of the server
+    Type of the server.
     """
 
     name: str
     """
-    Name of the server
+    Name of the server.
     """
 
     project_id: str
     """
-    Project this server is associated with
+    Project this server is associated with.
     """
 
     organization_id: str
     """
-    Organization this server is associated with
+    Organization this server is associated with.
     """
 
     ip: str
     """
-    IPv4 address of the server
+    IPv4 address of the server.
     """
 
     vnc_url: str
     """
-    URL of the VNC
+    URL of the VNC.
     """
 
     status: ServerStatus
     """
-    Current status of the server
+    Current status of the server.
     """
 
     created_at: Optional[datetime]
     """
-    The date at which the server was created
+    Date on which the server was created.
     """
 
     updated_at: Optional[datetime]
     """
-    The date at which the server was last updated
+    Date on which the server was last updated.
     """
 
     deletable_at: Optional[datetime]
     """
-    The date at which the server was last deleted
+    Date on which the server was last deleted.
     """
 
     zone: Zone
     """
-    The zone of the server
+    Zone of the server.
     """
 
 
 @dataclass
 class ServerType:
     """
-    Server type
+    Server type.
     """
 
     cpu: Optional[ServerTypeCPU]
     """
-    CPU description
+    CPU description.
     """
 
     disk: Optional[ServerTypeDisk]
     """
-    Size of the local disk of the server
+    Size of the local disk of the server.
     """
 
     name: str
     """
-    Name of the type
+    Name of the type.
     """
 
     memory: Optional[ServerTypeMemory]
     """
-    Size of memory available
+    Size of memory available.
     """
 
     stock: ServerTypeStock
     """
-    Current stock
+    Current stock.
     """
 
     minimum_lease_duration: Optional[str]
     """
+    Minimum duration of the lease in seconds.
     Minimum duration of the lease in seconds (example. 3.4s).
     """
 
 
 @dataclass
 class ServerTypeCPU:
     name: str
@@ -249,189 +250,189 @@
     type_: str
 
 
 @dataclass
 class ListServerTypesRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
 
 @dataclass
 class GetServerTypeRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_type: str
     """
-    Server type identifier
+    Server type identifier.
     """
 
 
 @dataclass
 class CreateServerRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     name: Optional[str]
     """
-    Create a server with this given name
+    Create a server with this given name.
     """
 
     project_id: Optional[str]
     """
-    Create a server in the given project ID
+    Create a server in the given project ID.
     """
 
     type_: str
     """
-    Create a server of the given type
+    Create a server of the given type.
     """
 
 
 @dataclass
 class ListServersRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     order_by: Optional[ListServersRequestOrderBy]
     """
-    The sort order of the returned servers
+    Sort order of the returned servers.
     """
 
     project_id: Optional[str]
     """
-    List only servers of this project ID
+    Only list servers of this project ID.
     """
 
     organization_id: Optional[str]
     """
-    List only servers of this organization ID
+    Only list servers of this Organization ID.
     """
 
     page: Optional[int]
     """
-    A positive integer to choose the page to return
+    Positive integer to choose the page to return.
     """
 
     page_size: Optional[int]
     """
-    A positive integer lower or equal to 100 to select the number of items to return
+    Positive integer lower or equal to 100 to select the number of items to return.
     """
 
 
 @dataclass
 class ListOSRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     page: Optional[int]
     """
-    A positive integer to choose the page to return
+    Positive integer to choose the page to return.
     """
 
     page_size: Optional[int]
     """
-    A positive integer lower or equal to 100 to select the number of items to return
+    Positive integer lower or equal to 100 to select the number of items to return.
     """
 
     server_type: Optional[str]
     """
-    List of compatible server type
+    List of compatible server types.
     """
 
     name: Optional[str]
     """
-    Filter os by name (for eg. "11.1" will return "11.1.2" and "11.1" but not "12")
+    Filter OS by name (note that "11.1" will return "11.1.2" and "11.1" but not "12")).
     """
 
 
 @dataclass
 class GetOSRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     os_id: str
     """
-    UUID of the OS you want to get
+    UUID of the OS you want to get.
     """
 
 
 @dataclass
 class GetServerRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    UUID of the server you want to get
+    UUID of the server you want to get.
     """
 
 
 @dataclass
 class UpdateServerRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    UUID of the server you want to update
+    UUID of the server you want to update.
     """
 
     name: str
     """
-    Updated name for your server
+    Updated name for your server.
     """
 
 
 @dataclass
 class DeleteServerRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    UUID of the server you want to delete
+    UUID of the server you want to delete.
     """
 
 
 @dataclass
 class RebootServerRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    UUID of the server you want to reboot
+    UUID of the server you want to reboot.
     """
 
 
 @dataclass
 class ReinstallServerRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    UUID of the server you want to reinstall
+    UUID of the server you want to reinstall.
     """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/baremetal/v1/__init__.py` & `scaleway_async-1.0.0/scaleway_async/baremetal/v1/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-0.9.0/scaleway_async/baremetal/v1/api.py` & `scaleway_async-1.0.0/scaleway_async/baremetal/v1/api.py`

 * *Files 7% similar despite different names*

```diff
@@ -85,17 +85,18 @@
     unmarshal_ListSettingsResponse,
     unmarshal_SetServerPrivateNetworksResponse,
 )
 
 
 class BaremetalV1API(API):
     """
-    Elastic metal API.
+    Elastic Metal API.
 
-    This API allows to manage your Bare metal server.
+    This API allows to manage your Elastic Metal server.
+    Elastic Metal API.
     """
 
     async def list_servers(
         self,
         *,
         zone: Optional[Zone] = None,
         page: Optional[int] = None,
@@ -105,25 +106,26 @@
         status: Optional[List[str]] = None,
         name: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         option_id: Optional[str] = None,
     ) -> ListServersResponse:
         """
-        List elastic metal servers for organization.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param page: Page number
-        :param page_size: Number of server per page
-        :param order_by: Order of the servers
-        :param tags: Filter by tags
-        :param status: Filter by status
-        :param name: Filter by name
-        :param organization_id: Filter by organization ID
-        :param project_id: Filter by project ID
-        :param option_id: Filter by option ID
+        List Elastic Metal servers for an Organization.
+        List Elastic Metal servers for a specific Organization.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param page: Page number.
+        :param page_size: Number of servers per page.
+        :param order_by: Order of the servers.
+        :param tags: Tags to filter for.
+        :param status: Status to filter for.
+        :param name: Names to filter for.
+        :param organization_id: Organization ID to filter for.
+        :param project_id: Project ID to filter for.
+        :param option_id: Option ID to filter for.
         :return: :class:`ListServersResponse <ListServersResponse>`
 
         Usage:
         ::
 
             result = await api.list_servers()
         """
@@ -161,25 +163,26 @@
         status: Optional[List[str]] = None,
         name: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         option_id: Optional[str] = None,
     ) -> List[Server]:
         """
-        List elastic metal servers for organization.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param page: Page number
-        :param page_size: Number of server per page
-        :param order_by: Order of the servers
-        :param tags: Filter by tags
-        :param status: Filter by status
-        :param name: Filter by name
-        :param organization_id: Filter by organization ID
-        :param project_id: Filter by project ID
-        :param option_id: Filter by option ID
+        List Elastic Metal servers for an Organization.
+        List Elastic Metal servers for a specific Organization.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param page: Page number.
+        :param page_size: Number of servers per page.
+        :param order_by: Order of the servers.
+        :param tags: Tags to filter for.
+        :param status: Status to filter for.
+        :param name: Names to filter for.
+        :param organization_id: Organization ID to filter for.
+        :param project_id: Project ID to filter for.
+        :param option_id: Option ID to filter for.
         :return: :class:`List[ListServersResponse] <List[ListServersResponse]>`
 
         Usage:
         ::
 
             result = await api.list_servers_all()
         """
@@ -205,17 +208,18 @@
     async def get_server(
         self,
         *,
         server_id: str,
         zone: Optional[Zone] = None,
     ) -> Server:
         """
-        Get the server associated with the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: ID of the server
+        Get a specific Elastic Metal server.
+        Get full details of an existing Elastic Metal server associated with the ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: ID of the server.
         :return: :class:`Server <Server>`
 
         Usage:
         ::
 
             result = await api.get_server(server_id="example")
         """
@@ -236,16 +240,16 @@
         *,
         server_id: str,
         zone: Optional[Zone] = None,
         options: Optional[WaitForOptions[Server, Union[bool, Awaitable[bool]]]] = None,
     ) -> Server:
         """
         Waits for :class:`Server <Server>` to be in a final state.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: ID of the server
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: ID of the server.
         :param options: The options for the waiter
         :return: :class:`Server <Server>`
 
         Usage:
         ::
 
             result = api.wait_for_server(server_id="example")
@@ -276,28 +280,29 @@
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         tags: Optional[List[str]] = None,
         install: Optional[CreateServerRequestInstall] = None,
         option_ids: Optional[List[str]] = None,
     ) -> Server:
         """
-        Create a new elastic metal server. Once the server is created, you probably want to install an OS.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param offer_id: Offer ID of the new server
+        Create an Elastic Metal server.
+        Create a new Elastic Metal server. Once the server is created, proceed with the [installation of an OS](#post-3e949e).
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param offer_id: Offer ID of the new server.
         :param organization_id: Organization ID with which the server will be created.
 
         One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
         :param project_id: Project ID with which the server will be created.
 
         One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
-        :param name: Name of the server (hostname)
-        :param description: Description associated to the server, max 255 characters
-        :param tags: Tags to associate to the server
-        :param install: Configuration of installation
-        :param option_ids: IDs of options to enable on server
+        :param name: Name of the server (hostname).
+        :param description: Description associated with the server, max 255 characters.
+        :param tags: Tags to associate to the server.
+        :param install: Object describing the configuration details of the OS installation on the server.
+        :param option_ids: IDs of options to enable on server.
         :return: :class:`Server <Server>`
 
         Usage:
         ::
 
             result = await api.create_server(
                 offer_id="example",
@@ -336,20 +341,21 @@
         server_id: str,
         zone: Optional[Zone] = None,
         name: Optional[str] = None,
         description: Optional[str] = None,
         tags: Optional[List[str]] = None,
     ) -> Server:
         """
-        Update the server associated with the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: ID of the server to update
-        :param name: Name of the server (hostname), not updated if null
-        :param description: Description associated to the server, max 255 characters, not updated if null
-        :param tags: Tags associated to the server, not updated if null
+        Update an Elastic Metal server.
+        Update the server associated with the ID. You can update parameters such as the server's name, tags and description. Any parameters left null in the request body are not updated.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: ID of the server to update.
+        :param name: Name of the server (hostname), not updated if null.
+        :param description: Description associated with the server, max 255 characters, not updated if null.
+        :param tags: Tags associated with the server, not updated if null.
         :return: :class:`Server <Server>`
 
         Usage:
         ::
 
             result = await api.update_server(server_id="example")
         """
@@ -385,24 +391,25 @@
         zone: Optional[Zone] = None,
         user: Optional[str] = None,
         password: Optional[str] = None,
         service_user: Optional[str] = None,
         service_password: Optional[str] = None,
     ) -> Server:
         """
-        Install an OS on the server associated with the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: Server ID to install
-        :param os_id: ID of the OS to install on the server
-        :param hostname: Hostname of the server
-        :param ssh_key_ids: SSH key IDs authorized on the server
-        :param user: User used for the installation
-        :param password: Password used for the installation
-        :param service_user: User used for the service to install
-        :param service_password: Password used for the service to install
+        Install an Elastic Metal server.
+        Install an Operating System (OS) on the Elastic Metal server with a specific ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: Server ID to install.
+        :param os_id: ID of the OS to installation on the server.
+        :param hostname: Hostname of the server.
+        :param ssh_key_ids: SSH key IDs authorized on the server.
+        :param user: User used for the installation.
+        :param password: Password used for the installation.
+        :param service_user: User used for the service to install.
+        :param service_password: Password used for the service to install.
         :return: :class:`Server <Server>`
 
         Usage:
         ::
 
             result = await api.install_server(
                 server_id="example",
@@ -440,17 +447,18 @@
     async def get_server_metrics(
         self,
         *,
         server_id: str,
         zone: Optional[Zone] = None,
     ) -> GetServerMetricsResponse:
         """
-        Give the ping status on the server associated with the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: Server ID to get the metrics
+        Return server metrics.
+        Get the ping status of the server associated with the ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: Server ID to get the metrics.
         :return: :class:`GetServerMetricsResponse <GetServerMetricsResponse>`
 
         Usage:
         ::
 
             result = await api.get_server_metrics(server_id="example")
         """
@@ -469,17 +477,18 @@
     async def delete_server(
         self,
         *,
         server_id: str,
         zone: Optional[Zone] = None,
     ) -> Server:
         """
-        Delete the server associated with the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: ID of the server to delete
+        Delete an Elastic Metal server.
+        Delete the server associated with the ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: ID of the server to delete.
         :return: :class:`Server <Server>`
 
         Usage:
         ::
 
             result = await api.delete_server(server_id="example")
         """
@@ -499,18 +508,19 @@
         self,
         *,
         server_id: str,
         boot_type: ServerBootType,
         zone: Optional[Zone] = None,
     ) -> Server:
         """
-        Reboot the server associated with the given ID, use boot param to reboot in rescue.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: ID of the server to reboot
-        :param boot_type: The type of boot
+        Reboot an Elastic Metal server.
+        Reboot the Elastic Metal server associated with the ID, use the `boot_type` `rescue` to reboot the server in rescue mode.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: ID of the server to reboot.
+        :param boot_type: The type of boot.
         :return: :class:`Server <Server>`
 
         Usage:
         ::
 
             result = await api.reboot_server(
                 server_id="example",
@@ -541,18 +551,19 @@
         self,
         *,
         server_id: str,
         boot_type: ServerBootType,
         zone: Optional[Zone] = None,
     ) -> Server:
         """
-        Start the server associated with the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: ID of the server to start
-        :param boot_type: The type of boot
+        Start an Elastic Metal server.
+        Start the server associated with the ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: ID of the server to start.
+        :param boot_type: The type of boot.
         :return: :class:`Server <Server>`
 
         Usage:
         ::
 
             result = await api.start_server(
                 server_id="example",
@@ -582,17 +593,18 @@
     async def stop_server(
         self,
         *,
         server_id: str,
         zone: Optional[Zone] = None,
     ) -> Server:
         """
-        Stop the server associated with the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: ID of the server to stop
+        Stop an Elastic Metal server.
+        Stop the server associated with the ID. The server remains allocated to your account and all data remains on the local storage of the server.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: ID of the server to stop.
         :return: :class:`Server <Server>`
 
         Usage:
         ::
 
             result = await api.stop_server(server_id="example")
         """
@@ -614,20 +626,21 @@
         server_id: str,
         zone: Optional[Zone] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListServerEventsRequestOrderBy = ListServerEventsRequestOrderBy.CREATED_AT_ASC,
     ) -> ListServerEventsResponse:
         """
-        List events associated to the given server ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: ID of the server events searched
-        :param page: Page number
-        :param page_size: Number of server events per page
-        :param order_by: Order of the server events
+        List server events.
+        List event (i.e. start/stop/reboot) associated to the server ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: ID of the server events searched.
+        :param page: Page number.
+        :param page_size: Number of server events per page.
+        :param order_by: Order of the server events.
         :return: :class:`ListServerEventsResponse <ListServerEventsResponse>`
 
         Usage:
         ::
 
             result = await api.list_server_events(server_id="example")
         """
@@ -654,20 +667,21 @@
         server_id: str,
         zone: Optional[Zone] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListServerEventsRequestOrderBy] = None,
     ) -> List[ServerEvent]:
         """
-        List events associated to the given server ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: ID of the server events searched
-        :param page: Page number
-        :param page_size: Number of server events per page
-        :param order_by: Order of the server events
+        List server events.
+        List event (i.e. start/stop/reboot) associated to the server ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: ID of the server events searched.
+        :param page: Page number.
+        :param page_size: Number of server events per page.
+        :param order_by: Order of the server events.
         :return: :class:`List[ListServerEventsResponse] <List[ListServerEventsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_server_events_all(server_id="example")
         """
@@ -689,22 +703,22 @@
         self,
         *,
         server_id: str,
         ip: str,
         zone: Optional[Zone] = None,
     ) -> BMCAccess:
         """
-        Start BMC (Baseboard Management Controller) access associated with the given ID.
+        Start BMC access.
+        Start BMC (Baseboard Management Controller) access associated with the ID.
         The BMC (Baseboard Management Controller) access is available one hour after the installation of the server.
-        You need first to create an option Remote Access. You will find the ID and the price with a call to listOffers (https://developers.scaleway.com/en/products/baremetal/api/#get-78db92). Then you can add the option https://developers.scaleway.com/en/products/baremetal/api/#post-b14abd. Do not forget to delete the Option.
-         After start BMC, you need to Get Remote Access to get the login/password https://developers.scaleway.com/en/products/baremetal/api/#get-cefc0f.
-
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: ID of the server
-        :param ip: The IP authorized to connect to the given server
+        You need first to create an option Remote Access. You will find the ID and the price with a call to listOffers (https://developers.scaleway.com/en/products/baremetal/api/#get-78db92). Then add the option https://developers.scaleway.com/en/products/baremetal/api/#post-b14abd.
+        After adding the BMC option, you need to Get Remote Access to get the login/password https://developers.scaleway.com/en/products/baremetal/api/#get-cefc0f. Do not forget to delete the Option after use.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: ID of the server.
+        :param ip: The IP authorized to connect to the server.
         :return: :class:`BMCAccess <BMCAccess>`
 
         Usage:
         ::
 
             result = await api.start_bmc_access(
                 server_id="example",
@@ -734,17 +748,18 @@
     async def get_bmc_access(
         self,
         *,
         server_id: str,
         zone: Optional[Zone] = None,
     ) -> BMCAccess:
         """
-        Get the BMC (Baseboard Management Controller) access associated with the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: ID of the server
+        Get BMC access.
+        Get the BMC (Baseboard Management Controller) access associated with the ID, including the URL and login information needed to connect.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: ID of the server.
         :return: :class:`BMCAccess <BMCAccess>`
 
         Usage:
         ::
 
             result = await api.get_bmc_access(server_id="example")
         """
@@ -763,17 +778,18 @@
     async def stop_bmc_access(
         self,
         *,
         server_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Stop BMC (Baseboard Management Controller) access associated with the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: ID of the server
+        Stop BMC access.
+        Stop BMC (Baseboard Management Controller) access associated with the ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: ID of the server.
 
         Usage:
         ::
 
             result = await api.stop_bmc_access(server_id="example")
         """
 
@@ -793,19 +809,20 @@
         *,
         server_id: str,
         ip_id: str,
         zone: Optional[Zone] = None,
         reverse: Optional[str] = None,
     ) -> IP:
         """
-        Configure ip associated with the given server ID and ipID. You can use this method to set a reverse dns for an IP.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: ID of the server
-        :param ip_id: ID of the IP to update
-        :param reverse: New reverse IP to update, not updated if null
+        Update IP.
+        Configure the IP address associated with the server ID and IP ID. You can use this method to set a reverse DNS for an IP address.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: ID of the server.
+        :param ip_id: ID of the IP to update.
+        :param reverse: New reverse IP to update, not updated if null.
         :return: :class:`IP <IP>`
 
         Usage:
         ::
 
             result = await api.update_ip(
                 server_id="example",
@@ -839,19 +856,20 @@
         *,
         server_id: str,
         option_id: str,
         zone: Optional[Zone] = None,
         expires_at: Optional[datetime] = None,
     ) -> Server:
         """
-        Add an option to a specific server.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: ID of the server
-        :param option_id: ID of the option to add
-        :param expires_at: Auto expire the option after this date
+        Add server option.
+        Add an option, such as Private Networks, to a specific server.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: ID of the server.
+        :param option_id: ID of the option to add.
+        :param expires_at: Auto expire the option after this date.
         :return: :class:`Server <Server>`
 
         Usage:
         ::
 
             result = await api.add_option_server(
                 server_id="example",
@@ -884,18 +902,19 @@
         self,
         *,
         server_id: str,
         option_id: str,
         zone: Optional[Zone] = None,
     ) -> Server:
         """
+        Delete server option.
         Delete an option from a specific server.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: ID of the server
-        :param option_id: ID of the option to delete
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: ID of the server.
+        :param option_id: ID of the option to delete.
         :return: :class:`Server <Server>`
 
         Usage:
         ::
 
             result = await api.delete_option_server(
                 server_id="example",
@@ -920,19 +939,20 @@
         *,
         zone: Optional[Zone] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         subscription_period: OfferSubscriptionPeriod = OfferSubscriptionPeriod.UNKNOWN_SUBSCRIPTION_PERIOD,
     ) -> ListOffersResponse:
         """
-        List all available server offers.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param page: Page number
-        :param page_size: Number of offers per page
-        :param subscription_period: Period of subscription to filter offers
+        List offers.
+        List all available Elastic Metal server configurations.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param page: Page number.
+        :param page_size: Number of offers per page.
+        :param subscription_period: Subscription period type to filter offers by.
         :return: :class:`ListOffersResponse <ListOffersResponse>`
 
         Usage:
         ::
 
             result = await api.list_offers()
         """
@@ -957,19 +977,20 @@
         *,
         zone: Optional[Zone] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         subscription_period: Optional[OfferSubscriptionPeriod] = None,
     ) -> List[Offer]:
         """
-        List all available server offers.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param page: Page number
-        :param page_size: Number of offers per page
-        :param subscription_period: Period of subscription to filter offers
+        List offers.
+        List all available Elastic Metal server configurations.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param page: Page number.
+        :param page_size: Number of offers per page.
+        :param subscription_period: Subscription period type to filter offers by.
         :return: :class:`List[ListOffersResponse] <List[ListOffersResponse]>`
 
         Usage:
         ::
 
             result = await api.list_offers_all()
         """
@@ -989,17 +1010,18 @@
     async def get_offer(
         self,
         *,
         offer_id: str,
         zone: Optional[Zone] = None,
     ) -> Offer:
         """
-        Return specific offer for the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param offer_id: ID of the researched Offer
+        Get offer.
+        Get details of an offer identified by its offer ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param offer_id: ID of the researched Offer.
         :return: :class:`Offer <Offer>`
 
         Usage:
         ::
 
             result = await api.get_offer(offer_id="example")
         """
@@ -1018,17 +1040,18 @@
     async def get_option(
         self,
         *,
         option_id: str,
         zone: Optional[Zone] = None,
     ) -> Option:
         """
-        Return specific option for the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param option_id: ID of the option
+        Get option.
+        Return specific option for the ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param option_id: ID of the option.
         :return: :class:`Option <Option>`
 
         Usage:
         ::
 
             result = await api.get_option(option_id="example")
         """
@@ -1050,20 +1073,21 @@
         zone: Optional[Zone] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         offer_id: Optional[str] = None,
         name: Optional[str] = None,
     ) -> ListOptionsResponse:
         """
+        List options.
         List all options matching with filters.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param page: Page number
-        :param page_size: Number of options per page
-        :param offer_id: Filter options by offer_id
-        :param name: Filter options by name
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param page: Page number.
+        :param page_size: Number of options per page.
+        :param offer_id: Offer ID to filter options for.
+        :param name: Name to filter options for.
         :return: :class:`ListOptionsResponse <ListOptionsResponse>`
 
         Usage:
         ::
 
             result = await api.list_options()
         """
@@ -1090,20 +1114,21 @@
         zone: Optional[Zone] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         offer_id: Optional[str] = None,
         name: Optional[str] = None,
     ) -> List[Option]:
         """
+        List options.
         List all options matching with filters.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param page: Page number
-        :param page_size: Number of options per page
-        :param offer_id: Filter options by offer_id
-        :param name: Filter options by name
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param page: Page number.
+        :param page_size: Number of options per page.
+        :param offer_id: Offer ID to filter options for.
+        :param name: Name to filter options for.
         :return: :class:`List[ListOptionsResponse] <List[ListOptionsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_options_all()
         """
@@ -1127,20 +1152,21 @@
         zone: Optional[Zone] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListSettingsRequestOrderBy = ListSettingsRequestOrderBy.CREATED_AT_ASC,
         project_id: Optional[str] = None,
     ) -> ListSettingsResponse:
         """
-        Return all settings for a project ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param page: Page number
-        :param page_size: Set the maximum list size
-        :param order_by: Order the response
-        :param project_id: ID of the project
+        List all settings.
+        Return all settings for a Project ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param page: Page number.
+        :param page_size: Set the maximum list size.
+        :param order_by: Sort order for items in the response.
+        :param project_id: ID of the Project.
         :return: :class:`ListSettingsResponse <ListSettingsResponse>`
 
         Usage:
         ::
 
             result = await api.list_settings()
         """
@@ -1167,20 +1193,21 @@
         zone: Optional[Zone] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListSettingsRequestOrderBy] = None,
         project_id: Optional[str] = None,
     ) -> List[Setting]:
         """
-        Return all settings for a project ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param page: Page number
-        :param page_size: Set the maximum list size
-        :param order_by: Order the response
-        :param project_id: ID of the project
+        List all settings.
+        Return all settings for a Project ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param page: Page number.
+        :param page_size: Set the maximum list size.
+        :param order_by: Sort order for items in the response.
+        :param project_id: ID of the Project.
         :return: :class:`List[ListSettingsResponse] <List[ListSettingsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_settings_all()
         """
@@ -1202,18 +1229,19 @@
         self,
         *,
         setting_id: str,
         zone: Optional[Zone] = None,
         enabled: Optional[bool] = None,
     ) -> Setting:
         """
-        Update a setting for a project ID (enable or disable).
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param setting_id: ID of the setting
-        :param enabled: Enable/Disable the setting
+        Update setting.
+        Update a setting for a Project ID (enable or disable).
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param setting_id: ID of the setting.
+        :param enabled: Defines whether the setting is enabled.
         :return: :class:`Setting <Setting>`
 
         Usage:
         ::
 
             result = await api.update_setting(setting_id="example")
         """
@@ -1242,19 +1270,20 @@
         *,
         zone: Optional[Zone] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         offer_id: Optional[str] = None,
     ) -> ListOSResponse:
         """
-        List all available OS that can be install on an elastic metal server.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param page: Page number
-        :param page_size: Number of OS per page
-        :param offer_id: Filter OS by offer ID
+        List available OSes.
+        List all OSes that are available for installation on Elastic Metal servers.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param page: Page number.
+        :param page_size: Number of OS per page.
+        :param offer_id: Offer IDs to filter OSes for.
         :return: :class:`ListOSResponse <ListOSResponse>`
 
         Usage:
         ::
 
             result = await api.list_os()
         """
@@ -1279,19 +1308,20 @@
         *,
         zone: Optional[Zone] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         offer_id: Optional[str] = None,
     ) -> List[OS]:
         """
-        List all available OS that can be install on an elastic metal server.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param page: Page number
-        :param page_size: Number of OS per page
-        :param offer_id: Filter OS by offer ID
+        List available OSes.
+        List all OSes that are available for installation on Elastic Metal servers.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param page: Page number.
+        :param page_size: Number of OS per page.
+        :param offer_id: Offer IDs to filter OSes for.
         :return: :class:`List[ListOSResponse] <List[ListOSResponse]>`
 
         Usage:
         ::
 
             result = await api.list_os_all()
         """
@@ -1311,17 +1341,18 @@
     async def get_os(
         self,
         *,
         os_id: str,
         zone: Optional[Zone] = None,
     ) -> OS:
         """
-        Return specific OS for the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param os_id: ID of the OS
+        Get OS with an ID.
+        Return the specific OS for the ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param os_id: ID of the OS.
         :return: :class:`OS <OS>`
 
         Usage:
         ::
 
             result = await api.get_os(os_id="example")
         """
@@ -1337,28 +1368,30 @@
         self._throw_on_error(res)
         return unmarshal_OS(res.json())
 
 
 class BaremetalPrivateNetworkV1API(API):
     """
     Elastic Metal Private Network API.
+
+    Elastic Metal Private Network API.
     """
 
     async def add_server_private_network(
         self,
         *,
         server_id: str,
         private_network_id: str,
         zone: Optional[Zone] = None,
     ) -> ServerPrivateNetwork:
         """
-        Add a server to a private network
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: The ID of the server
-        :param private_network_id: The ID of the private network
+        Add a server to a Private Network.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: The ID of the server.
+        :param private_network_id: The ID of the Private Network.
         :return: :class:`ServerPrivateNetwork <ServerPrivateNetwork>`
 
         Usage:
         ::
 
             result = await api.add_server_private_network(
                 server_id="example",
@@ -1389,18 +1422,18 @@
         self,
         *,
         server_id: str,
         private_network_ids: List[str],
         zone: Optional[Zone] = None,
     ) -> SetServerPrivateNetworksResponse:
         """
-        Set multiple private networks on a server
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: The ID of the server
-        :param private_network_ids: The IDs of the private networks
+        Set multiple Private Networks on a server.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: The ID of the server.
+        :param private_network_ids: The IDs of the Private Networks.
         :return: :class:`SetServerPrivateNetworksResponse <SetServerPrivateNetworksResponse>`
 
         Usage:
         ::
 
             result = await api.set_server_private_networks(
                 server_id="example",
@@ -1436,23 +1469,23 @@
         page_size: Optional[int] = None,
         server_id: Optional[str] = None,
         private_network_id: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> ListServerPrivateNetworksResponse:
         """
-        List the private networks of a server
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param order_by: The sort order for the returned private networks
-        :param page: The page number for the returned private networks
-        :param page_size: The maximum number of private networks per page
-        :param server_id: Filter private networks by server ID
-        :param private_network_id: Filter private networks by private network ID
-        :param organization_id: Filter private networks by organization ID
-        :param project_id: Filter private networks by project ID
+        List the Private Networks of a server.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param order_by: The sort order for the returned Private Networks.
+        :param page: The page number for the returned Private Networks.
+        :param page_size: The maximum number of Private Networks per page.
+        :param server_id: Filter Private Networks by server ID.
+        :param private_network_id: Filter Private Networks by Private Network ID.
+        :param organization_id: Filter Private Networks by Organization ID.
+        :param project_id: Filter Private Networks by Project ID.
         :return: :class:`ListServerPrivateNetworksResponse <ListServerPrivateNetworksResponse>`
 
         Usage:
         ::
 
             result = await api.list_server_private_networks()
         """
@@ -1486,23 +1519,23 @@
         page_size: Optional[int] = None,
         server_id: Optional[str] = None,
         private_network_id: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> List[ServerPrivateNetwork]:
         """
-        List the private networks of a server
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param order_by: The sort order for the returned private networks
-        :param page: The page number for the returned private networks
-        :param page_size: The maximum number of private networks per page
-        :param server_id: Filter private networks by server ID
-        :param private_network_id: Filter private networks by private network ID
-        :param organization_id: Filter private networks by organization ID
-        :param project_id: Filter private networks by project ID
+        List the Private Networks of a server.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param order_by: The sort order for the returned Private Networks.
+        :param page: The page number for the returned Private Networks.
+        :param page_size: The maximum number of Private Networks per page.
+        :param server_id: Filter Private Networks by server ID.
+        :param private_network_id: Filter Private Networks by Private Network ID.
+        :param organization_id: Filter Private Networks by Organization ID.
+        :param project_id: Filter Private Networks by Project ID.
         :return: :class:`List[ListServerPrivateNetworksResponse] <List[ListServerPrivateNetworksResponse]>`
 
         Usage:
         ::
 
             result = await api.list_server_private_networks_all()
         """
@@ -1527,18 +1560,18 @@
         self,
         *,
         server_id: str,
         private_network_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete a private network
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: The ID of the server
-        :param private_network_id: The ID of the private network
+        Delete a Private Network.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: The ID of the server.
+        :param private_network_id: The ID of the Private Network.
 
         Usage:
         ::
 
             result = await api.delete_server_private_network(
                 server_id="example",
                 private_network_id="example",
```

### Comparing `scaleway_async-0.9.0/scaleway_async/baremetal/v1/content.py` & `scaleway_async-1.0.0/scaleway_async/baremetal/v1/content.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-0.9.0/scaleway_async/baremetal/v1/marshalling.py` & `scaleway_async-1.0.0/scaleway_async/baremetal/v1/marshalling.py`

 * *Files 16% similar despite different names*

```diff
@@ -62,661 +62,674 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'CPU' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("benchmark")
+    field = data.get("benchmark", None)
     args["benchmark"] = field
 
-    field = data.get("core_count")
+    field = data.get("core_count", None)
     args["core_count"] = field
 
-    field = data.get("frequency")
+    field = data.get("frequency", None)
     args["frequency"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("thread_count")
+    field = data.get("thread_count", None)
     args["thread_count"] = field
 
     return CPU(**args)
 
 
 def unmarshal_Disk(data: Any) -> Disk:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Disk' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("capacity")
+    field = data.get("capacity", None)
     args["capacity"] = field
 
-    field = data.get("type_")
+    field = data.get("type", None)
     args["type_"] = field
 
     return Disk(**args)
 
 
 def unmarshal_IP(data: Any) -> IP:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'IP' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("address")
+    field = data.get("address", None)
     args["address"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("reverse")
+    field = data.get("reverse", None)
     args["reverse"] = field
 
-    field = data.get("reverse_status")
+    field = data.get("reverse_status", None)
     args["reverse_status"] = field
 
-    field = data.get("reverse_status_message")
+    field = data.get("reverse_status_message", None)
     args["reverse_status_message"] = field
 
-    field = data.get("version")
+    field = data.get("version", None)
     args["version"] = field
 
     return IP(**args)
 
 
 def unmarshal_Memory(data: Any) -> Memory:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Memory' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("capacity")
+    field = data.get("capacity", None)
     args["capacity"] = field
 
-    field = data.get("frequency")
+    field = data.get("frequency", None)
     args["frequency"] = field
 
-    field = data.get("is_ecc")
+    field = data.get("is_ecc", None)
     args["is_ecc"] = field
 
-    field = data.get("type_")
+    field = data.get("type", None)
     args["type_"] = field
 
     return Memory(**args)
 
 
 def unmarshal_OSOSField(data: Any) -> OSOSField:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'OSOSField' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("default_value")
+    field = data.get("default_value", None)
     args["default_value"] = field
 
-    field = data.get("editable")
+    field = data.get("editable", None)
     args["editable"] = field
 
-    field = data.get("required")
+    field = data.get("required", None)
     args["required"] = field
 
     return OSOSField(**args)
 
 
 def unmarshal_OfferOptionOffer(data: Any) -> OfferOptionOffer:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'OfferOptionOffer' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("enabled")
+    field = data.get("enabled", None)
     args["enabled"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("manageable")
+    field = data.get("manageable", None)
     args["manageable"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("os_id")
+    field = data.get("os_id", None)
     args["os_id"] = field
 
-    field = data.get("price")
+    field = data.get("price", None)
     args["price"] = unmarshal_Money(field) if field is not None else None
 
-    field = data.get("subscription_period")
+    field = data.get("subscription_period", None)
     args["subscription_period"] = field
 
     return OfferOptionOffer(**args)
 
 
 def unmarshal_PersistentMemory(data: Any) -> PersistentMemory:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'PersistentMemory' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("capacity")
+    field = data.get("capacity", None)
     args["capacity"] = field
 
-    field = data.get("frequency")
+    field = data.get("frequency", None)
     args["frequency"] = field
 
-    field = data.get("type_")
+    field = data.get("type", None)
     args["type_"] = field
 
     return PersistentMemory(**args)
 
 
 def unmarshal_RaidController(data: Any) -> RaidController:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'RaidController' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("model")
+    field = data.get("model", None)
     args["model"] = field
 
-    field = data.get("raid_level")
+    field = data.get("raid_level", None)
     args["raid_level"] = field
 
     return RaidController(**args)
 
 
 def unmarshal_ServerInstall(data: Any) -> ServerInstall:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ServerInstall' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("hostname")
+    field = data.get("hostname", None)
     args["hostname"] = field
 
-    field = data.get("os_id")
+    field = data.get("os_id", None)
     args["os_id"] = field
 
-    field = data.get("service_url")
+    field = data.get("service_url", None)
     args["service_url"] = field
 
-    field = data.get("service_user")
+    field = data.get("service_user", None)
     args["service_user"] = field
 
-    field = data.get("ssh_key_ids")
+    field = data.get("ssh_key_ids", None)
     args["ssh_key_ids"] = field
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("user")
+    field = data.get("user", None)
     args["user"] = field
 
     return ServerInstall(**args)
 
 
 def unmarshal_ServerOption(data: Any) -> ServerOption:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ServerOption' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("expires_at")
+    field = data.get("expires_at", None)
     args["expires_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("manageable")
+    field = data.get("manageable", None)
     args["manageable"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
     return ServerOption(**args)
 
 
 def unmarshal_ServerRescueServer(data: Any) -> ServerRescueServer:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ServerRescueServer' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("password")
+    field = data.get("password", None)
     args["password"] = field
 
-    field = data.get("user")
+    field = data.get("user", None)
     args["user"] = field
 
     return ServerRescueServer(**args)
 
 
 def unmarshal_OS(data: Any) -> OS:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'OS' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("enabled")
+    field = data.get("allowed", None)
+    args["allowed"] = field
+
+    field = data.get("enabled", None)
     args["enabled"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("license_required")
+    field = data.get("license_required", None)
     args["license_required"] = field
 
-    field = data.get("logo_url")
+    field = data.get("logo_url", None)
     args["logo_url"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("password")
+    field = data.get("password", None)
     args["password"] = unmarshal_OSOSField(field) if field is not None else None
 
-    field = data.get("service_password")
+    field = data.get("service_password", None)
     args["service_password"] = unmarshal_OSOSField(field) if field is not None else None
 
-    field = data.get("service_user")
+    field = data.get("service_user", None)
     args["service_user"] = unmarshal_OSOSField(field) if field is not None else None
 
-    field = data.get("ssh")
+    field = data.get("ssh", None)
     args["ssh"] = unmarshal_OSOSField(field) if field is not None else None
 
-    field = data.get("user")
+    field = data.get("user", None)
     args["user"] = unmarshal_OSOSField(field) if field is not None else None
 
-    field = data.get("version")
+    field = data.get("version", None)
     args["version"] = field
 
     return OS(**args)
 
 
 def unmarshal_Offer(data: Any) -> Offer:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Offer' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("bandwidth")
+    field = data.get("bandwidth", None)
     args["bandwidth"] = field
 
-    field = data.get("commercial_range")
+    field = data.get("commercial_range", None)
     args["commercial_range"] = field
 
-    field = data.get("cpus")
-    args["cpus"] = [unmarshal_CPU(v) for v in data["cpus"]]
+    field = data.get("cpus", None)
+    args["cpus"] = [unmarshal_CPU(v) for v in field] if field is not None else None
 
-    field = data.get("disks")
-    args["disks"] = [unmarshal_Disk(v) for v in data["disks"]]
+    field = data.get("disks", None)
+    args["disks"] = [unmarshal_Disk(v) for v in field] if field is not None else None
 
-    field = data.get("enable")
+    field = data.get("enable", None)
     args["enable"] = field
 
-    field = data.get("fee")
+    field = data.get("fee", None)
     args["fee"] = unmarshal_Money(field) if field is not None else None
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("incompatible_os_ids")
+    field = data.get("incompatible_os_ids", None)
     args["incompatible_os_ids"] = field
 
-    field = data.get("memories")
-    args["memories"] = [unmarshal_Memory(v) for v in data["memories"]]
+    field = data.get("memories", None)
+    args["memories"] = (
+        [unmarshal_Memory(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("operation_path")
+    field = data.get("operation_path", None)
     args["operation_path"] = field
 
-    field = data.get("options")
-    args["options"] = [unmarshal_OfferOptionOffer(v) for v in data["options"]]
+    field = data.get("options", None)
+    args["options"] = (
+        [unmarshal_OfferOptionOffer(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("persistent_memories")
-    args["persistent_memories"] = [
-        unmarshal_PersistentMemory(v) for v in data["persistent_memories"]
-    ]
+    field = data.get("persistent_memories", None)
+    args["persistent_memories"] = (
+        [unmarshal_PersistentMemory(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("price_per_hour")
+    field = data.get("price_per_hour", None)
     args["price_per_hour"] = unmarshal_Money(field) if field is not None else None
 
-    field = data.get("price_per_month")
+    field = data.get("price_per_month", None)
     args["price_per_month"] = unmarshal_Money(field) if field is not None else None
 
-    field = data.get("private_bandwidth")
+    field = data.get("private_bandwidth", None)
     args["private_bandwidth"] = field
 
-    field = data.get("quota_name")
+    field = data.get("quota_name", None)
     args["quota_name"] = field
 
-    field = data.get("raid_controllers")
-    args["raid_controllers"] = [
-        unmarshal_RaidController(v) for v in data["raid_controllers"]
-    ]
+    field = data.get("raid_controllers", None)
+    args["raid_controllers"] = (
+        [unmarshal_RaidController(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("shared_bandwidth")
+    field = data.get("shared_bandwidth", None)
     args["shared_bandwidth"] = field
 
-    field = data.get("stock")
+    field = data.get("stock", None)
     args["stock"] = field
 
-    field = data.get("subscription_period")
+    field = data.get("subscription_period", None)
     args["subscription_period"] = field
 
-    field = data.get("tags")
+    field = data.get("tags", None)
     args["tags"] = field
 
     return Offer(**args)
 
 
 def unmarshal_Option(data: Any) -> Option:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Option' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("manageable")
+    field = data.get("manageable", None)
     args["manageable"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
     return Option(**args)
 
 
 def unmarshal_Server(data: Any) -> Server:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Server' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("boot_type")
+    field = data.get("boot_type", None)
     args["boot_type"] = field
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("description")
+    field = data.get("description", None)
     args["description"] = field
 
-    field = data.get("domain")
+    field = data.get("domain", None)
     args["domain"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("install")
+    field = data.get("install", None)
     args["install"] = unmarshal_ServerInstall(field) if field is not None else None
 
-    field = data.get("ips")
-    args["ips"] = [unmarshal_IP(v) for v in data["ips"]]
+    field = data.get("ips", None)
+    args["ips"] = [unmarshal_IP(v) for v in field] if field is not None else None
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("offer_id")
+    field = data.get("offer_id", None)
     args["offer_id"] = field
 
-    field = data.get("offer_name")
+    field = data.get("offer_name", None)
     args["offer_name"] = field
 
-    field = data.get("options")
-    args["options"] = [unmarshal_ServerOption(v) for v in data["options"]]
+    field = data.get("options", None)
+    args["options"] = (
+        [unmarshal_ServerOption(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("organization_id")
+    field = data.get("organization_id", None)
     args["organization_id"] = field
 
-    field = data.get("ping_status")
+    field = data.get("ping_status", None)
     args["ping_status"] = field
 
-    field = data.get("project_id")
+    field = data.get("project_id", None)
     args["project_id"] = field
 
-    field = data.get("rescue_server")
+    field = data.get("rescue_server", None)
     args["rescue_server"] = (
         unmarshal_ServerRescueServer(field) if field is not None else None
     )
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("tags")
+    field = data.get("tags", None)
     args["tags"] = field
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("zone")
+    field = data.get("zone", None)
     args["zone"] = field
 
     return Server(**args)
 
 
 def unmarshal_ServerEvent(data: Any) -> ServerEvent:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ServerEvent' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("action")
+    field = data.get("action", None)
     args["action"] = field
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
     return ServerEvent(**args)
 
 
 def unmarshal_ServerPrivateNetwork(data: Any) -> ServerPrivateNetwork:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ServerPrivateNetwork' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("private_network_id")
+    field = data.get("private_network_id", None)
     args["private_network_id"] = field
 
-    field = data.get("project_id")
+    field = data.get("project_id", None)
     args["project_id"] = field
 
-    field = data.get("server_id")
+    field = data.get("server_id", None)
     args["server_id"] = field
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("vlan")
+    field = data.get("vlan", None)
     args["vlan"] = field
 
     return ServerPrivateNetwork(**args)
 
 
 def unmarshal_Setting(data: Any) -> Setting:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Setting' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("enabled")
+    field = data.get("enabled", None)
     args["enabled"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("project_id")
+    field = data.get("project_id", None)
     args["project_id"] = field
 
-    field = data.get("type_")
+    field = data.get("type", None)
     args["type_"] = field
 
     return Setting(**args)
 
 
 def unmarshal_BMCAccess(data: Any) -> BMCAccess:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'BMCAccess' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("expires_at")
+    field = data.get("expires_at", None)
     args["expires_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("login")
+    field = data.get("login", None)
     args["login"] = field
 
-    field = data.get("password")
+    field = data.get("password", None)
     args["password"] = field
 
-    field = data.get("url")
+    field = data.get("url", None)
     args["url"] = field
 
     return BMCAccess(**args)
 
 
 def unmarshal_GetServerMetricsResponse(data: Any) -> GetServerMetricsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'GetServerMetricsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("pings")
+    field = data.get("pings", None)
     args["pings"] = unmarshal_TimeSeries(field) if field is not None else None
 
     return GetServerMetricsResponse(**args)
 
 
 def unmarshal_ListOSResponse(data: Any) -> ListOSResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListOSResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("os")
-    args["os"] = [unmarshal_OS(v) for v in data["os"]]
+    field = data.get("os", None)
+    args["os"] = [unmarshal_OS(v) for v in field] if field is not None else None
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListOSResponse(**args)
 
 
 def unmarshal_ListOffersResponse(data: Any) -> ListOffersResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListOffersResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("offers")
-    args["offers"] = [unmarshal_Offer(v) for v in data["offers"]]
+    field = data.get("offers", None)
+    args["offers"] = [unmarshal_Offer(v) for v in field] if field is not None else None
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListOffersResponse(**args)
 
 
 def unmarshal_ListOptionsResponse(data: Any) -> ListOptionsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListOptionsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("options")
-    args["options"] = [unmarshal_Option(v) for v in data["options"]]
+    field = data.get("options", None)
+    args["options"] = (
+        [unmarshal_Option(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListOptionsResponse(**args)
 
 
 def unmarshal_ListServerEventsResponse(data: Any) -> ListServerEventsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListServerEventsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("events")
-    args["events"] = [unmarshal_ServerEvent(v) for v in data["events"]]
+    field = data.get("events", None)
+    args["events"] = (
+        [unmarshal_ServerEvent(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListServerEventsResponse(**args)
 
 
 def unmarshal_ListServerPrivateNetworksResponse(
     data: Any,
@@ -724,54 +737,60 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListServerPrivateNetworksResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("server_private_networks")
-    args["server_private_networks"] = [
-        unmarshal_ServerPrivateNetwork(v) for v in data["server_private_networks"]
-    ]
+    field = data.get("server_private_networks", None)
+    args["server_private_networks"] = (
+        [unmarshal_ServerPrivateNetwork(v) for v in field]
+        if field is not None
+        else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListServerPrivateNetworksResponse(**args)
 
 
 def unmarshal_ListServersResponse(data: Any) -> ListServersResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListServersResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("servers")
-    args["servers"] = [unmarshal_Server(v) for v in data["servers"]]
+    field = data.get("servers", None)
+    args["servers"] = (
+        [unmarshal_Server(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListServersResponse(**args)
 
 
 def unmarshal_ListSettingsResponse(data: Any) -> ListSettingsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListSettingsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("settings")
-    args["settings"] = [unmarshal_Setting(v) for v in data["settings"]]
+    field = data.get("settings", None)
+    args["settings"] = (
+        [unmarshal_Setting(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListSettingsResponse(**args)
 
 
 def unmarshal_SetServerPrivateNetworksResponse(
     data: Any,
@@ -779,154 +798,238 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'SetServerPrivateNetworksResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("server_private_networks")
-    args["server_private_networks"] = [
-        unmarshal_ServerPrivateNetwork(v) for v in data["server_private_networks"]
-    ]
+    field = data.get("server_private_networks", None)
+    args["server_private_networks"] = (
+        [unmarshal_ServerPrivateNetwork(v) for v in field]
+        if field is not None
+        else None
+    )
 
     return SetServerPrivateNetworksResponse(**args)
 
 
 def marshal_CreateServerRequestInstall(
     request: CreateServerRequestInstall,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "hostname": request.hostname,
-        "os_id": request.os_id,
-        "password": request.password,
-        "service_password": request.service_password,
-        "service_user": request.service_user,
-        "ssh_key_ids": request.ssh_key_ids,
-        "user": request.user,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.hostname is not None:
+        output["hostname"] = request.hostname
+
+    if request.os_id is not None:
+        output["os_id"] = request.os_id
+
+    if request.password is not None:
+        output["password"] = request.password
+
+    if request.service_password is not None:
+        output["service_password"] = request.service_password
+
+    if request.service_user is not None:
+        output["service_user"] = request.service_user
+
+    if request.ssh_key_ids is not None:
+        output["ssh_key_ids"] = request.ssh_key_ids
+
+    if request.user is not None:
+        output["user"] = request.user
+
+    return output
 
 
 def marshal_AddOptionServerRequest(
     request: AddOptionServerRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "expires_at": request.expires_at,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.expires_at is not None:
+        output["expires_at"] = request.expires_at
+
+    return output
 
 
 def marshal_CreateServerRequest(
     request: CreateServerRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
                 OneOfPossibility(
-                    "project_id", request.project_id, defaults.default_project_id
+                    "project_id",
+                    request.project_id or defaults.default_project_id
+                    if request.project_id is not None
+                    else None,
+                    defaults.default_project_id,
                 ),
                 OneOfPossibility(
                     "organization_id",
-                    request.organization_id,
+                    request.organization_id or defaults.default_organization_id
+                    if request.organization_id is not None
+                    else None,
                     defaults.default_organization_id,
                 ),
             ]
         ),
-        "description": request.description,
-        "install": marshal_CreateServerRequestInstall(request.install, defaults)
-        if request.install is not None
-        else None,
-        "name": request.name,
-        "offer_id": request.offer_id,
-        "option_ids": request.option_ids,
-        "tags": request.tags,
-    }
+    )
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.install is not None:
+        output["install"] = marshal_CreateServerRequestInstall(
+            request.install, defaults
+        )
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.offer_id is not None:
+        output["offer_id"] = request.offer_id
+
+    if request.option_ids is not None:
+        output["option_ids"] = request.option_ids
+
+    if request.tags is not None:
+        output["tags"] = request.tags
+
+    return output
 
 
 def marshal_InstallServerRequest(
     request: InstallServerRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "hostname": request.hostname,
-        "os_id": request.os_id,
-        "password": request.password,
-        "service_password": request.service_password,
-        "service_user": request.service_user,
-        "ssh_key_ids": request.ssh_key_ids,
-        "user": request.user,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.hostname is not None:
+        output["hostname"] = request.hostname
+
+    if request.os_id is not None:
+        output["os_id"] = request.os_id
+
+    if request.password is not None:
+        output["password"] = request.password
+
+    if request.service_password is not None:
+        output["service_password"] = request.service_password
+
+    if request.service_user is not None:
+        output["service_user"] = request.service_user
+
+    if request.ssh_key_ids is not None:
+        output["ssh_key_ids"] = request.ssh_key_ids
+
+    if request.user is not None:
+        output["user"] = request.user
+
+    return output
 
 
 def marshal_PrivateNetworkApiAddServerPrivateNetworkRequest(
     request: PrivateNetworkApiAddServerPrivateNetworkRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "private_network_id": request.private_network_id,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.private_network_id is not None:
+        output["private_network_id"] = request.private_network_id
+
+    return output
 
 
 def marshal_PrivateNetworkApiSetServerPrivateNetworksRequest(
     request: PrivateNetworkApiSetServerPrivateNetworksRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "private_network_ids": request.private_network_ids,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.private_network_ids is not None:
+        output["private_network_ids"] = request.private_network_ids
+
+    return output
 
 
 def marshal_RebootServerRequest(
     request: RebootServerRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "boot_type": ServerBootType(request.boot_type),
-    }
+    output: Dict[str, Any] = {}
+
+    if request.boot_type is not None:
+        output["boot_type"] = ServerBootType(request.boot_type)
+
+    return output
 
 
 def marshal_StartBMCAccessRequest(
     request: StartBMCAccessRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "ip": request.ip,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.ip is not None:
+        output["ip"] = request.ip
+
+    return output
 
 
 def marshal_StartServerRequest(
     request: StartServerRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "boot_type": ServerBootType(request.boot_type),
-    }
+    output: Dict[str, Any] = {}
+
+    if request.boot_type is not None:
+        output["boot_type"] = ServerBootType(request.boot_type)
+
+    return output
 
 
 def marshal_UpdateIPRequest(
     request: UpdateIPRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "reverse": request.reverse,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.reverse is not None:
+        output["reverse"] = request.reverse
+
+    return output
 
 
 def marshal_UpdateServerRequest(
     request: UpdateServerRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "description": request.description,
-        "name": request.name,
-        "tags": request.tags,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.tags is not None:
+        output["tags"] = request.tags
+
+    return output
 
 
 def marshal_UpdateSettingRequest(
     request: UpdateSettingRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "enabled": request.enabled,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.enabled is not None:
+        output["enabled"] = request.enabled
+
+    return output
```

### Comparing `scaleway_async-0.9.0/scaleway_async/baremetal/v1/types.py` & `scaleway_async-1.0.0/scaleway_async/baremetal/v1/types.py`

 * *Files 8% similar despite different names*

```diff
@@ -161,373 +161,378 @@
     def __str__(self) -> str:
         return str(self.value)
 
 
 @dataclass
 class BMCAccess:
     """
-    Bmc access
+    Bmc access.
     """
 
     url: str
     """
-    URL to access to the server console
+    URL to access to the server console.
     """
 
     login: str
     """
-    The login to use for the BMC (Baseboard Management Controller) access authentification
+    The login to use for the BMC (Baseboard Management Controller) access authentification.
     """
 
     password: str
     """
-    The password to use for the BMC (Baseboard Management Controller) access authentification
+    The password to use for the BMC (Baseboard Management Controller) access authentification.
     """
 
     expires_at: Optional[datetime]
     """
-    The date after which the BMC (Baseboard Management Controller) access will be closed
+    The date after which the BMC (Baseboard Management Controller) access will be closed.
     """
 
 
 @dataclass
 class CPU:
     """
-    Cpu
+    Cpu.
     """
 
     name: str
     """
-    Name of the CPU
+    Name of the CPU.
     """
 
     core_count: int
     """
-    Number of cores of the CPU
+    Number of CPU cores.
     """
 
     thread_count: int
     """
-    Number of threads of the CPU
+    Number CPU threads.
     """
 
     frequency: int
     """
-    Frequency of the CPU in MHz
+    Frequency of the CPU in MHz.
     """
 
     benchmark: str
     """
-    Benchmark of the CPU
+    Benchmark of the CPU.
     """
 
 
 @dataclass
 class CreateServerRequestInstall:
     """
-    Create server request. install
+    Create server request. install.
     """
 
     os_id: str
     """
-    ID of the OS to install on the server
+    ID of the OS to installation on the server.
     """
 
     hostname: str
     """
-    Hostname of the server
+    Hostname of the server.
     """
 
     ssh_key_ids: List[str]
     """
-    SSH key IDs authorized on the server
+    SSH key IDs authorized on the server.
     """
 
     user: Optional[str]
     """
-    User used for the installation
+    User for the installation.
     """
 
     password: Optional[str]
     """
-    Password used for the installation
+    Password for the installation.
     """
 
     service_user: Optional[str]
     """
-    User used for the service to install
+    Regular user that runs the service to be installed on the server.
     """
 
     service_password: Optional[str]
     """
-    Password used for the service to install
+    Password used for the service to install.
     """
 
 
 @dataclass
 class Disk:
     """
-    Disk
+    Disk.
     """
 
     capacity: int
     """
-    Capacity of the disk in bytes
+    Capacity of the disk in bytes.
     """
 
     type_: str
     """
-    Type of the disk
+    Type of the disk.
     """
 
 
 @dataclass
 class GetServerMetricsResponse:
     """
-    Get server metrics response
+    Get server metrics response.
     """
 
     pings: Optional[TimeSeries]
     """
-    Timeseries of ping on the server
+    Timeseries object representing pings on the server.
     """
 
 
 @dataclass
 class IP:
     """
-    Ip
+    Ip.
     """
 
     id: str
     """
-    ID of the IP
+    ID of the IP.
     """
 
     address: str
     """
-    Address of the IP
+    Address of the IP.
     """
 
     reverse: str
     """
-    Reverse IP value
+    Reverse IP value.
     """
 
     version: IPVersion
     """
-    Version of IP (v4 or v6)
+    Version of IP (v4 or v6).
     """
 
     reverse_status: IPReverseStatus
     """
-    Status of the reverse
+    Status of the reverse.
     """
 
     reverse_status_message: str
     """
-    A message related to the reverse status, in case of an error for example
+    A message related to the reverse status, e.g. in case of an error.
     """
 
 
 @dataclass
 class ListOSResponse:
     """
-    List os response
+    List os response.
     """
 
     total_count: int
     """
-    Total count of matching OS
+    Total count of matching OS.
     """
 
     os: List[OS]
     """
-    OS that match filters
+    OS that match filters.
     """
 
 
 @dataclass
 class ListOffersResponse:
     """
-    List offers response
+    List offers response.
     """
 
     total_count: int
     """
-    Total count of matching offers
+    Total count of matching offers.
     """
 
     offers: List[Offer]
     """
-    Offers that match filters
+    Offers that match filters.
     """
 
 
 @dataclass
 class ListOptionsResponse:
     """
-    List options response
+    List options response.
     """
 
     total_count: int
     """
-    Total count of matching options
+    Total count of matching options.
     """
 
     options: List[Option]
     """
-    Options that match filters
+    Options that match filters.
     """
 
 
 @dataclass
 class ListServerEventsResponse:
     """
-    List server events response
+    List server events response.
     """
 
     total_count: int
     """
-    Total count of matching events
+    Total count of matching events.
     """
 
     events: List[ServerEvent]
     """
-    Server events that match filters
+    Server events that match filters.
     """
 
 
 @dataclass
 class ListServerPrivateNetworksResponse:
     server_private_networks: List[ServerPrivateNetwork]
 
     total_count: int
 
 
 @dataclass
 class ListServersResponse:
     """
-    List servers response
+    List servers response.
     """
 
     total_count: int
     """
-    Total count of matching servers
+    Total count of matching servers.
     """
 
     servers: List[Server]
     """
-    Servers that match filters
+    Array of Elastic Metal server objects matching the filters in the request.
     """
 
 
 @dataclass
 class ListSettingsResponse:
     """
-    List settings response
+    List settings response.
     """
 
     total_count: int
     """
-    Total count of matching sttings
+    Total count of matching settings.
     """
 
     settings: List[Setting]
     """
-    Settings that match filters
+    Settings that match filters.
     """
 
 
 @dataclass
 class Memory:
     """
-    Memory
+    Memory.
     """
 
     capacity: int
     """
-    Capacity of the memory in bytes
+    Capacity of the memory in bytes.
     """
 
     type_: str
     """
-    Type of the memory
+    Type of the memory.
     """
 
     frequency: int
     """
-    Frequency of the memory in MHz
+    Frequency of the memory in MHz.
     """
 
     is_ecc: bool
     """
-    True if the memory is an error-correcting code memory
+    True if the memory is an error-correcting code memory.
     """
 
 
 @dataclass
 class OS:
     """
-    Os
+    Os.
     """
 
     id: str
     """
-    ID of the OS
+    ID of the OS.
     """
 
     name: str
     """
-    Name of the OS
+    Name of the OS.
     """
 
     version: str
     """
-    Version of the OS
+    Version of the OS.
     """
 
     logo_url: str
     """
-    URL of this os's logo
+    URL of this OS's logo.
     """
 
     ssh: Optional[OSOSField]
     """
-    Define the SSH requirements to install the OS
+    Object defining the SSH requirements to install the OS.
     """
 
     user: Optional[OSOSField]
     """
-    Define the username requirements to install the OS
+    Object defining the username requirements to install the OS.
     """
 
     password: Optional[OSOSField]
     """
-    Define the password requirements to install the OS
+    Object defining the password requirements to install the OS.
     """
 
     service_user: Optional[OSOSField]
     """
-    Define the username requirements to install the service
+    Object defining the username requirements to install the service.
     """
 
     service_password: Optional[OSOSField]
     """
-    Define the password requirements to install the service
+    Object defining the password requirements to install the service.
     """
 
     enabled: bool
     """
-    State of OS
+    Defines if the operating system is enabled or not.
     """
 
     license_required: bool
     """
-    License required (check server options for pricing details)
+    License required (check server options for pricing details).
+    """
+
+    allowed: bool
+    """
+    Defines if a specific Organization is allowed to install this OS type.
     """
 
 
 @dataclass
 class OSOSField:
     editable: bool
 
@@ -535,598 +540,597 @@
 
     default_value: Optional[str]
 
 
 @dataclass
 class Offer:
     """
-    Offer
+    Offer.
     """
 
     id: str
     """
-    ID of the offer
+    ID of the offer.
     """
 
     name: str
     """
-    Name of the offer
+    Name of the offer.
     """
 
     stock: OfferStock
     """
-    Stock level
+    Stock level.
     """
 
     bandwidth: int
     """
-    Public Bandwidth available in bits/s with the offer
+    Public bandwidth available (in bits/s) with the offer.
     """
 
     commercial_range: str
     """
-    Commercial range of the offer
+    Commercial range of the offer.
     """
 
     price_per_hour: Optional[Money]
     """
-    Price of the offer for the next 60 minutes (a server order at 11h32 will be payed until 12h32)
+    Price of the offer for the next 60 minutes (a server order at 11h32 will be payed until 12h32).
     """
 
     price_per_month: Optional[Money]
     """
-    Price of the offer per months
+    Monthly price of the offer, if subscribing on a monthly basis.
     """
 
     disks: List[Disk]
     """
-    Disks specifications of the offer
+    Disks specifications of the offer.
     """
 
     enable: bool
     """
-    True if the offer is currently available
+    Defines whether the offer is currently available.
     """
 
     cpus: List[CPU]
     """
-    CPU specifications of the offer
+    CPU specifications of the offer.
     """
 
     memories: List[Memory]
     """
-    Memory specifications of the offer
+    Memory specifications of the offer.
     """
 
     quota_name: str
     """
-    Name of the quota associated to the offer
+    Name of the quota associated to the offer.
     """
 
     persistent_memories: List[PersistentMemory]
     """
-    Persistent memory specifications of the offer
+    Persistent memory specifications of the offer.
     """
 
     raid_controllers: List[RaidController]
     """
-    Raid controller specifications of the offer
+    Raid controller specifications of the offer.
     """
 
     incompatible_os_ids: List[str]
     """
-    Array of incompatible OS ids
+    Array of OS images IDs incompatible with the server.
     """
 
     subscription_period: OfferSubscriptionPeriod
     """
-    Period of subscription for the offer
+    Period of subscription for the offer.
     """
 
     operation_path: str
     """
-    Operation path of the service
+    Operation path of the service.
     """
 
     fee: Optional[Money]
     """
-    Fee to pay on order
+    One time fee invoiced by Scaleway for the setup and activation of the server.
     """
 
     options: List[OfferOptionOffer]
     """
-    Options available on offer
+    Available options for customization of the server.
     """
 
     private_bandwidth: int
     """
-    Private bandwidth available in bits/s with the offer
+    Private bandwidth available in bits/s with the offer.
     """
 
     shared_bandwidth: bool
     """
-    The offer is shared or not
+    Defines whether the offer's bandwidth is shared or not.
     """
 
     tags: List[str]
     """
-    Array of tags attached to the offer
+    Array of tags attached to the offer.
     """
 
 
 @dataclass
 class OfferOptionOffer:
     """
-    Offer. option offer
+    Offer. option offer.
     """
 
     id: str
     """
-    ID of the option
+    ID of the option.
     """
 
     name: str
     """
-    Name of the option
+    Name of the option.
     """
 
     enabled: bool
     """
-    If true the option is enabled and included by default in the offer
-    If false the option is available for the offer but not included by default
-    
+    If true the option is enabled and included by default in the offer.
+    If false the option is available for the offer but not included by default.
     """
 
     subscription_period: OfferSubscriptionPeriod
     """
-    Period of subscription for the offer
+    Period of subscription for the offer.
     """
 
     price: Optional[Money]
     """
-    Price of the option
+    Price of the option.
     """
 
     manageable: bool
     """
-    Boolean to know if option could be managed
+    Boolean to know if option could be managed.
     """
 
     os_id: Optional[str]
     """
-    ID of the OS linked to the option
+    ID of the OS linked to the option.
     """
 
 
 @dataclass
 class Option:
     """
-    Option
+    Option.
     """
 
     id: str
     """
-    ID of the option
+    ID of the option.
     """
 
     name: str
     """
-    Name of the option
+    Name of the option.
     """
 
     manageable: bool
     """
-    Is false if the option could not be added or removed
+    Defines whether the option is manageable (could be added or removed).
     """
 
 
 @dataclass
 class PersistentMemory:
     """
-    Persistent memory
+    Persistent memory.
     """
 
     capacity: int
     """
-    Capacity of the memory in bytes
+    Capacity of the memory in bytes.
     """
 
     type_: str
     """
-    Type of the memory
+    Type of the memory.
     """
 
     frequency: int
     """
-    Frequency of the memory in MHz
+    Frequency of the memory in MHz.
     """
 
 
 @dataclass
 class RaidController:
     model: str
 
     raid_level: List[str]
 
 
 @dataclass
 class Server:
     """
-    Server
+    Server.
     """
 
     id: str
     """
-    ID of the server
+    ID of the server.
     """
 
     organization_id: str
     """
-    Organization ID the server is attached to
+    Organization ID the server is attached to.
     """
 
     project_id: str
     """
-    Project ID the server is attached to
+    Project ID the server is attached to.
     """
 
     name: str
     """
-    Name of the server
+    Name of the server.
     """
 
     description: str
     """
-    Description of the server
+    Description of the server.
     """
 
     updated_at: Optional[datetime]
     """
-    Date of last modification of the server
+    Last modification date of the server.
     """
 
     created_at: Optional[datetime]
     """
-    Date of creation of the server
+    Creation date of the server.
     """
 
     status: ServerStatus
     """
-    Status of the server
+    Status of the server.
     """
 
     offer_id: str
     """
-    Offer ID of the server
+    Offer ID of the server.
     """
 
     offer_name: str
     """
-    Offer name of the server
+    Offer name of the server.
     """
 
     tags: List[str]
     """
-    Array of customs tags attached to the server
+    Array of custom tags attached to the server.
     """
 
     ips: List[IP]
     """
-    Array of IPs attached to the server
+    Array of IPs attached to the server.
     """
 
     domain: str
     """
-    Domain of the server
+    Domain of the server.
     """
 
     boot_type: ServerBootType
     """
-    Boot type of the server
+    Boot type of the server.
     """
 
     zone: Zone
     """
-    The zone in which is the server
+    Zone in which is the server located.
     """
 
     install: Optional[ServerInstall]
     """
-    Configuration of installation
+    Configuration of the installation.
     """
 
     ping_status: ServerPingStatus
     """
-    Server status of ping
+    Status of server ping.
     """
 
     options: List[ServerOption]
     """
-    Options enabled on server
+    Options enabled on the server.
     """
 
     rescue_server: Optional[ServerRescueServer]
     """
-    Configuration of rescue boot
+    Configuration of rescue boot.
     """
 
 
 @dataclass
 class ServerEvent:
     """
-    Server event
+    Server event.
     """
 
     id: str
     """
-    ID of the server for whom the action will be applied
+    ID of the server to which the action will be applied.
     """
 
     action: str
     """
-    The action that will be applied to the server
+    The action that will be applied to the server.
     """
 
     updated_at: Optional[datetime]
     """
-    Date of last modification of the action
+    Date of last modification of the action.
     """
 
     created_at: Optional[datetime]
     """
-    Date of creation of the action
+    Date of creation of the action.
     """
 
 
 @dataclass
 class ServerInstall:
     """
-    Server. install
+    Server. install.
     """
 
     os_id: str
     """
-    ID of the OS
+    ID of the OS.
     """
 
     hostname: str
     """
-    Host defined in the server install
+    Host defined during the server installation.
     """
 
     ssh_key_ids: List[str]
     """
-    SSH public key IDs defined in the server install
+    SSH public key IDs defined during server installation.
     """
 
     status: ServerInstallStatus
     """
-    Status of the server install
+    Status of the server installation.
     """
 
     user: str
     """
-    User defined in the server install or the default one if none were specified
+    User defined in the server installation, or the default user if none were specified.
     """
 
     service_user: str
     """
-    Service user defined in the server install or the default one if none were specified
+    Service user defined in the server installation, or the default user if none were specified.
     """
 
     service_url: str
     """
-    The address of the installed service
+    Address of the installed service.
     """
 
 
 @dataclass
 class ServerOption:
     """
-    Server. option
+    Server. option.
     """
 
     id: str
     """
-    ID of the option
+    ID of the option.
     """
 
     name: str
     """
-    Name of the option
+    Name of the option.
     """
 
     status: ServerOptionOptionStatus
     """
-    Status of the option
+    Status of the option on this server.
     """
 
     manageable: bool
     """
-    Is false if the option could not be added or removed
+    Defines whether the option can be managed (added or removed).
     """
 
     expires_at: Optional[datetime]
     """
-    Auto expiration date for compatible options
+    Auto expiration date for compatible options.
     """
 
 
 @dataclass
 class ServerPrivateNetwork:
     """
-    Server private network
+    Server private network.
     """
 
     id: str
     """
-    The private network ID
+    The Private Network ID.
     """
 
     project_id: str
     """
-    The private network project ID
+    The Private Network Project ID.
     """
 
     server_id: str
     """
-    The server ID
+    The server ID.
     """
 
     private_network_id: str
     """
-    The private network ID
+    The Private Network ID.
     """
 
     vlan: Optional[int]
     """
-    The VLAN ID associated to the private network
+    The VLAN ID associated to the Private Network.
     """
 
     status: ServerPrivateNetworkStatus
     """
-    The configuration status of the private network
+    The configuration status of the Private Network.
     """
 
     created_at: Optional[datetime]
     """
-    The private network creation date
+    The Private Network creation date.
     """
 
     updated_at: Optional[datetime]
     """
-    The date the private network was last modified
+    The date the Private Network was last modified.
     """
 
 
 @dataclass
 class ServerRescueServer:
     """
-    Server. rescue server
+    Server. rescue server.
     """
 
     user: str
     """
-    Rescue user name
+    Rescue user name.
     """
 
     password: str
     """
-    Rescue password
+    Rescue password.
     """
 
 
 @dataclass
 class SetServerPrivateNetworksResponse:
     server_private_networks: List[ServerPrivateNetwork]
 
 
 @dataclass
 class Setting:
     """
-    Setting
+    Setting.
     """
 
     id: str
     """
-    ID of the setting
+    ID of the setting.
     """
 
     type_: SettingType
     """
-    Type of the setting
+    Type of the setting.
     """
 
     project_id: str
     """
-    ID of the project ID
+    ID of the Project ID.
     """
 
     enabled: bool
     """
-    The setting is enable or disable
+    Defines whether the setting is enabled.
     """
 
 
 @dataclass
 class ListServersRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     page: Optional[int]
     """
-    Page number
+    Page number.
     """
 
     page_size: Optional[int]
     """
-    Number of server per page
+    Number of servers per page.
     """
 
     order_by: Optional[ListServersRequestOrderBy]
     """
-    Order of the servers
+    Order of the servers.
     """
 
     tags: Optional[List[str]]
     """
-    Filter by tags
+    Tags to filter for.
     """
 
     status: Optional[List[str]]
     """
-    Filter by status
+    Status to filter for.
     """
 
     name: Optional[str]
     """
-    Filter by name
+    Names to filter for.
     """
 
     organization_id: Optional[str]
     """
-    Filter by organization ID
+    Organization ID to filter for.
     """
 
     project_id: Optional[str]
     """
-    Filter by project ID
+    Project ID to filter for.
     """
 
     option_id: Optional[str]
     """
-    Filter by option ID
+    Option ID to filter for.
     """
 
 
 @dataclass
 class GetServerRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    ID of the server
+    ID of the server.
     """
 
 
 @dataclass
 class CreateServerRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     offer_id: str
     """
-    Offer ID of the new server
+    Offer ID of the new server.
     """
 
     organization_id: Optional[str]
     """
     Organization ID with which the server will be created.
     
     One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
@@ -1138,572 +1142,572 @@
     Project ID with which the server will be created.
     
     One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
     """
 
     name: str
     """
-    Name of the server (hostname)
+    Name of the server (hostname).
     """
 
     description: str
     """
-    Description associated to the server, max 255 characters
+    Description associated with the server, max 255 characters.
     """
 
     tags: Optional[List[str]]
     """
-    Tags to associate to the server
+    Tags to associate to the server.
     """
 
     install: Optional[CreateServerRequestInstall]
     """
-    Configuration of installation
+    Object describing the configuration details of the OS installation on the server.
     """
 
     option_ids: Optional[List[str]]
     """
-    IDs of options to enable on server
+    IDs of options to enable on server.
     """
 
 
 @dataclass
 class UpdateServerRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    ID of the server to update
+    ID of the server to update.
     """
 
     name: Optional[str]
     """
-    Name of the server (hostname), not updated if null
+    Name of the server (hostname), not updated if null.
     """
 
     description: Optional[str]
     """
-    Description associated to the server, max 255 characters, not updated if null
+    Description associated with the server, max 255 characters, not updated if null.
     """
 
     tags: Optional[List[str]]
     """
-    Tags associated to the server, not updated if null
+    Tags associated with the server, not updated if null.
     """
 
 
 @dataclass
 class InstallServerRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    Server ID to install
+    Server ID to install.
     """
 
     os_id: str
     """
-    ID of the OS to install on the server
+    ID of the OS to installation on the server.
     """
 
     hostname: str
     """
-    Hostname of the server
+    Hostname of the server.
     """
 
     ssh_key_ids: List[str]
     """
-    SSH key IDs authorized on the server
+    SSH key IDs authorized on the server.
     """
 
     user: Optional[str]
     """
-    User used for the installation
+    User used for the installation.
     """
 
     password: Optional[str]
     """
-    Password used for the installation
+    Password used for the installation.
     """
 
     service_user: Optional[str]
     """
-    User used for the service to install
+    User used for the service to install.
     """
 
     service_password: Optional[str]
     """
-    Password used for the service to install
+    Password used for the service to install.
     """
 
 
 @dataclass
 class GetServerMetricsRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    Server ID to get the metrics
+    Server ID to get the metrics.
     """
 
 
 @dataclass
 class DeleteServerRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    ID of the server to delete
+    ID of the server to delete.
     """
 
 
 @dataclass
 class RebootServerRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    ID of the server to reboot
+    ID of the server to reboot.
     """
 
     boot_type: ServerBootType
     """
-    The type of boot
+    The type of boot.
     """
 
 
 @dataclass
 class StartServerRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    ID of the server to start
+    ID of the server to start.
     """
 
     boot_type: ServerBootType
     """
-    The type of boot
+    The type of boot.
     """
 
 
 @dataclass
 class StopServerRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    ID of the server to stop
+    ID of the server to stop.
     """
 
 
 @dataclass
 class ListServerEventsRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    ID of the server events searched
+    ID of the server events searched.
     """
 
     page: Optional[int]
     """
-    Page number
+    Page number.
     """
 
     page_size: Optional[int]
     """
-    Number of server events per page
+    Number of server events per page.
     """
 
     order_by: Optional[ListServerEventsRequestOrderBy]
     """
-    Order of the server events
+    Order of the server events.
     """
 
 
 @dataclass
 class StartBMCAccessRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    ID of the server
+    ID of the server.
     """
 
     ip: str
     """
-    The IP authorized to connect to the given server
+    The IP authorized to connect to the server.
     """
 
 
 @dataclass
 class GetBMCAccessRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    ID of the server
+    ID of the server.
     """
 
 
 @dataclass
 class StopBMCAccessRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    ID of the server
+    ID of the server.
     """
 
 
 @dataclass
 class UpdateIPRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    ID of the server
+    ID of the server.
     """
 
     ip_id: str
     """
-    ID of the IP to update
+    ID of the IP to update.
     """
 
     reverse: Optional[str]
     """
-    New reverse IP to update, not updated if null
+    New reverse IP to update, not updated if null.
     """
 
 
 @dataclass
 class AddOptionServerRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    ID of the server
+    ID of the server.
     """
 
     option_id: str
     """
-    ID of the option to add
+    ID of the option to add.
     """
 
     expires_at: Optional[datetime]
     """
-    Auto expire the option after this date
+    Auto expire the option after this date.
     """
 
 
 @dataclass
 class DeleteOptionServerRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    ID of the server
+    ID of the server.
     """
 
     option_id: str
     """
-    ID of the option to delete
+    ID of the option to delete.
     """
 
 
 @dataclass
 class ListOffersRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     page: Optional[int]
     """
-    Page number
+    Page number.
     """
 
     page_size: Optional[int]
     """
-    Number of offers per page
+    Number of offers per page.
     """
 
     subscription_period: Optional[OfferSubscriptionPeriod]
     """
-    Period of subscription to filter offers
+    Subscription period type to filter offers by.
     """
 
 
 @dataclass
 class GetOfferRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     offer_id: str
     """
-    ID of the researched Offer
+    ID of the researched Offer.
     """
 
 
 @dataclass
 class GetOptionRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     option_id: str
     """
-    ID of the option
+    ID of the option.
     """
 
 
 @dataclass
 class ListOptionsRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     page: Optional[int]
     """
-    Page number
+    Page number.
     """
 
     page_size: Optional[int]
     """
-    Number of options per page
+    Number of options per page.
     """
 
     offer_id: Optional[str]
     """
-    Filter options by offer_id
+    Offer ID to filter options for.
     """
 
     name: Optional[str]
     """
-    Filter options by name
+    Name to filter options for.
     """
 
 
 @dataclass
 class ListSettingsRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     page: Optional[int]
     """
-    Page number
+    Page number.
     """
 
     page_size: Optional[int]
     """
-    Set the maximum list size
+    Set the maximum list size.
     """
 
     order_by: Optional[ListSettingsRequestOrderBy]
     """
-    Order the response
+    Sort order for items in the response.
     """
 
     project_id: Optional[str]
     """
-    ID of the project
+    ID of the Project.
     """
 
 
 @dataclass
 class UpdateSettingRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     setting_id: str
     """
-    ID of the setting
+    ID of the setting.
     """
 
     enabled: Optional[bool]
     """
-    Enable/Disable the setting
+    Defines whether the setting is enabled.
     """
 
 
 @dataclass
 class ListOSRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     page: Optional[int]
     """
-    Page number
+    Page number.
     """
 
     page_size: Optional[int]
     """
-    Number of OS per page
+    Number of OS per page.
     """
 
     offer_id: Optional[str]
     """
-    Filter OS by offer ID
+    Offer IDs to filter OSes for.
     """
 
 
 @dataclass
 class GetOSRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     os_id: str
     """
-    ID of the OS
+    ID of the OS.
     """
 
 
 @dataclass
 class PrivateNetworkApiAddServerPrivateNetworkRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    The ID of the server
+    The ID of the server.
     """
 
     private_network_id: str
     """
-    The ID of the private network
+    The ID of the Private Network.
     """
 
 
 @dataclass
 class PrivateNetworkApiSetServerPrivateNetworksRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    The ID of the server
+    The ID of the server.
     """
 
     private_network_ids: List[str]
     """
-    The IDs of the private networks
+    The IDs of the Private Networks.
     """
 
 
 @dataclass
 class PrivateNetworkApiListServerPrivateNetworksRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     order_by: Optional[ListServerPrivateNetworksRequestOrderBy]
     """
-    The sort order for the returned private networks
+    The sort order for the returned Private Networks.
     """
 
     page: Optional[int]
     """
-    The page number for the returned private networks
+    The page number for the returned Private Networks.
     """
 
     page_size: Optional[int]
     """
-    The maximum number of private networks per page
+    The maximum number of Private Networks per page.
     """
 
     server_id: Optional[str]
     """
-    Filter private networks by server ID
+    Filter Private Networks by server ID.
     """
 
     private_network_id: Optional[str]
     """
-    Filter private networks by private network ID
+    Filter Private Networks by Private Network ID.
     """
 
     organization_id: Optional[str]
     """
-    Filter private networks by organization ID
+    Filter Private Networks by Organization ID.
     """
 
     project_id: Optional[str]
     """
-    Filter private networks by project ID
+    Filter Private Networks by Project ID.
     """
 
 
 @dataclass
 class PrivateNetworkApiDeleteServerPrivateNetworkRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    The ID of the server
+    The ID of the server.
     """
 
     private_network_id: str
     """
-    The ID of the private network
+    The ID of the Private Network.
     """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/cockpit/v1beta1/__init__.py` & `scaleway_async-1.0.0/scaleway_async/cockpit/v1beta1/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,37 +1,49 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 from .types import CockpitStatus
 from .types import GrafanaUserRole
 from .types import ListGrafanaUsersRequestOrderBy
+from .types import ListPlansRequestOrderBy
 from .types import ListTokensRequestOrderBy
+from .types import PlanName
 from .types import Cockpit
 from .types import CockpitEndpoints
+from .types import CockpitMetrics
 from .types import ContactPoint
 from .types import ContactPointEmail
 from .types import GrafanaUser
 from .types import ListContactPointsResponse
 from .types import ListGrafanaUsersResponse
+from .types import ListPlansResponse
 from .types import ListTokensResponse
+from .types import Plan
+from .types import SelectPlanResponse
 from .types import Token
 from .types import TokenScopes
 from .content import COCKPIT_TRANSIENT_STATUSES
 from .api import CockpitV1Beta1API
 
 __all__ = [
     "CockpitStatus",
     "GrafanaUserRole",
     "ListGrafanaUsersRequestOrderBy",
+    "ListPlansRequestOrderBy",
     "ListTokensRequestOrderBy",
+    "PlanName",
     "Cockpit",
     "CockpitEndpoints",
+    "CockpitMetrics",
     "ContactPoint",
     "ContactPointEmail",
     "GrafanaUser",
     "ListContactPointsResponse",
     "ListGrafanaUsersResponse",
+    "ListPlansResponse",
     "ListTokensResponse",
+    "Plan",
+    "SelectPlanResponse",
     "Token",
     "TokenScopes",
     "COCKPIT_TRANSIENT_STATUSES",
     "CockpitV1Beta1API",
 ]
```

### Comparing `scaleway_async-0.9.0/scaleway_async/cockpit/v1beta1/api.py` & `scaleway_async-1.0.0/scaleway_async/cockpit/v1beta1/api.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,43 +1,51 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 
+from datetime import datetime
 from typing import Awaitable, List, Optional, Union
 
 from scaleway_core.api import API
 from scaleway_core.utils import (
     WaitForOptions,
     fetch_all_pages_async,
+    random_name,
     validate_path_param,
     wait_for_resource_async,
 )
 from .types import (
     GrafanaUserRole,
     ListGrafanaUsersRequestOrderBy,
+    ListPlansRequestOrderBy,
     ListTokensRequestOrderBy,
     Cockpit,
+    CockpitMetrics,
     ContactPoint,
     GrafanaUser,
     ListContactPointsResponse,
     ListGrafanaUsersResponse,
+    ListPlansResponse,
     ListTokensResponse,
+    Plan,
+    SelectPlanResponse,
     Token,
     TokenScopes,
     ActivateCockpitRequest,
     DeactivateCockpitRequest,
     ResetCockpitGrafanaRequest,
     CreateTokenRequest,
     CreateContactPointRequest,
     DeleteContactPointRequest,
     EnableManagedAlertsRequest,
     DisableManagedAlertsRequest,
     TriggerTestAlertRequest,
     CreateGrafanaUserRequest,
     DeleteGrafanaUserRequest,
     ResetGrafanaUserPasswordRequest,
+    SelectPlanRequest,
 )
 from .content import (
     COCKPIT_TRANSIENT_STATUSES,
 )
 from .marshalling import (
     marshal_ActivateCockpitRequest,
     marshal_CreateContactPointRequest,
@@ -46,40 +54,46 @@
     marshal_DeactivateCockpitRequest,
     marshal_DeleteContactPointRequest,
     marshal_DeleteGrafanaUserRequest,
     marshal_DisableManagedAlertsRequest,
     marshal_EnableManagedAlertsRequest,
     marshal_ResetCockpitGrafanaRequest,
     marshal_ResetGrafanaUserPasswordRequest,
+    marshal_SelectPlanRequest,
     marshal_TriggerTestAlertRequest,
     unmarshal_ContactPoint,
     unmarshal_GrafanaUser,
     unmarshal_Token,
     unmarshal_Cockpit,
+    unmarshal_CockpitMetrics,
     unmarshal_ListContactPointsResponse,
     unmarshal_ListGrafanaUsersResponse,
+    unmarshal_ListPlansResponse,
     unmarshal_ListTokensResponse,
+    unmarshal_SelectPlanResponse,
 )
 
 
 class CockpitV1Beta1API(API):
     """
     Cockpit API.
 
-    This API allows to manage Cockpits.
+    Cockpit API.
+    Cockpit's API allows you to activate your Cockpit on your Projects. Scaleway's Cockpit stores metrics and logs and provides a dedicated Grafana for dashboarding to visualize them.
     """
 
     async def activate_cockpit(
         self,
         *,
         project_id: Optional[str] = None,
     ) -> Cockpit:
         """
-        Activate a cockpit associated with the given project ID.
-        :param project_id:
+        Activate a Cockpit.
+        Activate the Cockpit of the specified Project ID.
+        :param project_id: ID of the Project the Cockpit belongs to.
         :return: :class:`Cockpit <Cockpit>`
 
         Usage:
         ::
 
             result = await api.activate_cockpit()
         """
@@ -100,16 +114,17 @@
 
     async def get_cockpit(
         self,
         *,
         project_id: Optional[str] = None,
     ) -> Cockpit:
         """
-        Get the cockpit associated with the given project ID.
-        :param project_id:
+        Get a Cockpit.
+        Retrieve the Cockpit of the specified Project ID.
+        :param project_id: ID of the Project the Cockpit belongs to.
         :return: :class:`Cockpit <Cockpit>`
 
         Usage:
         ::
 
             result = await api.get_cockpit()
         """
@@ -129,15 +144,15 @@
         self,
         *,
         project_id: Optional[str] = None,
         options: Optional[WaitForOptions[Cockpit, Union[bool, Awaitable[bool]]]] = None,
     ) -> Cockpit:
         """
         Waits for :class:`Cockpit <Cockpit>` to be in a final state.
-        :param project_id:
+        :param project_id: ID of the Project the Cockpit belongs to.
         :param options: The options for the waiter
         :return: :class:`Cockpit <Cockpit>`
 
         Usage:
         ::
 
             result = api.wait_for_cockpit()
@@ -153,22 +168,60 @@
             fetcher=self.get_cockpit,
             options=options,
             args={
                 "project_id": project_id,
             },
         )
 
+    async def get_cockpit_metrics(
+        self,
+        *,
+        project_id: Optional[str] = None,
+        start_date: Optional[datetime] = None,
+        end_date: Optional[datetime] = None,
+        metric_name: Optional[str] = None,
+    ) -> CockpitMetrics:
+        """
+        Get Cockpit metrics.
+        Get metrics from your Cockpit with the specified Project ID.
+        :param project_id: ID of the Project the Cockpit belongs to.
+        :param start_date: Desired time range's start date for the metrics.
+        :param end_date: Desired time range's end date for the metrics.
+        :param metric_name: Name of the metric requested.
+        :return: :class:`CockpitMetrics <CockpitMetrics>`
+
+        Usage:
+        ::
+
+            result = await api.get_cockpit_metrics()
+        """
+
+        res = self._request(
+            "GET",
+            f"/cockpit/v1beta1/cockpit/metrics",
+            params={
+                "end_date": end_date,
+                "metric_name": metric_name,
+                "project_id": project_id or self.client.default_project_id,
+                "start_date": start_date,
+            },
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_CockpitMetrics(res.json())
+
     async def deactivate_cockpit(
         self,
         *,
         project_id: Optional[str] = None,
     ) -> Cockpit:
         """
-        Deactivate a cockpit associated with the given project ID.
-        :param project_id:
+        Deactivate a Cockpit.
+        Deactivate the Cockpit of the specified Project ID.
+        :param project_id: ID of the Project the Cockpit belongs to.
         :return: :class:`Cockpit <Cockpit>`
 
         Usage:
         ::
 
             result = await api.deactivate_cockpit()
         """
@@ -189,16 +242,17 @@
 
     async def reset_cockpit_grafana(
         self,
         *,
         project_id: Optional[str] = None,
     ) -> Cockpit:
         """
-        Reset the Grafana of your cockpit associated with the given project ID.
-        :param project_id:
+        Reset a Grafana.
+        Reset your Cockpit's Grafana associated with the specified Project ID.
+        :param project_id: ID of the Project the Cockpit belongs to.
         :return: :class:`Cockpit <Cockpit>`
 
         Usage:
         ::
 
             result = await api.reset_cockpit_grafana()
         """
@@ -216,38 +270,39 @@
 
         self._throw_on_error(res)
         return unmarshal_Cockpit(res.json())
 
     async def create_token(
         self,
         *,
-        name: str,
         project_id: Optional[str] = None,
+        name: Optional[str] = None,
         scopes: Optional[TokenScopes] = None,
     ) -> Token:
         """
-        Create a token associated with the given project ID.
-        :param project_id:
-        :param name:
-        :param scopes:
+        Create a token.
+        Create a token associated with the specified Project ID.
+        :param project_id: ID of the Project.
+        :param name: Name of the token.
+        :param scopes: Token's permissions.
         :return: :class:`Token <Token>`
 
         Usage:
         ::
 
-            result = await api.create_token(name="example")
+            result = await api.create_token()
         """
 
         res = self._request(
             "POST",
             f"/cockpit/v1beta1/tokens",
             body=marshal_CreateTokenRequest(
                 CreateTokenRequest(
-                    name=name,
                     project_id=project_id,
+                    name=name or random_name(prefix="token"),
                     scopes=scopes,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
@@ -258,19 +313,20 @@
         *,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListTokensRequestOrderBy = ListTokensRequestOrderBy.CREATED_AT_ASC,
         project_id: Optional[str] = None,
     ) -> ListTokensResponse:
         """
-        List tokens associated with the given project ID.
-        :param page:
-        :param page_size:
+        List tokens.
+        Get a list of tokens associated with the specified Project ID.
+        :param page: Page number.
+        :param page_size: Page size.
         :param order_by:
-        :param project_id:
+        :param project_id: ID of the Project.
         :return: :class:`ListTokensResponse <ListTokensResponse>`
 
         Usage:
         ::
 
             result = await api.list_tokens()
         """
@@ -294,19 +350,20 @@
         *,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListTokensRequestOrderBy] = None,
         project_id: Optional[str] = None,
     ) -> List[Token]:
         """
-        List tokens associated with the given project ID.
-        :param page:
-        :param page_size:
+        List tokens.
+        Get a list of tokens associated with the specified Project ID.
+        :param page: Page number.
+        :param page_size: Page size.
         :param order_by:
-        :param project_id:
+        :param project_id: ID of the Project.
         :return: :class:`List[ListTokensResponse] <List[ListTokensResponse]>`
 
         Usage:
         ::
 
             result = await api.list_tokens_all()
         """
@@ -325,16 +382,17 @@
 
     async def get_token(
         self,
         *,
         token_id: str,
     ) -> Token:
         """
-        Get the token associated with the given ID.
-        :param token_id:
+        Get a token.
+        Retrieve the token associated with the specified token ID.
+        :param token_id: ID of the token.
         :return: :class:`Token <Token>`
 
         Usage:
         ::
 
             result = await api.get_token(token_id="example")
         """
@@ -351,16 +409,17 @@
 
     async def delete_token(
         self,
         *,
         token_id: str,
     ) -> Optional[None]:
         """
-        Delete the token associated with the given ID.
-        :param token_id:
+        Delete a token.
+        Delete the token associated with the specified token ID.
+        :param token_id: ID of the token.
 
         Usage:
         ::
 
             result = await api.delete_token(token_id="example")
         """
 
@@ -377,16 +436,17 @@
     async def create_contact_point(
         self,
         *,
         project_id: Optional[str] = None,
         contact_point: Optional[ContactPoint] = None,
     ) -> ContactPoint:
         """
-        Create an alert contact point for the default receiver.
-        :param project_id: Project ID.
+        Create a contact point.
+        Create a contact point to receive alerts for the default receiver.
+        :param project_id: ID of the Project in which to create the contact point.
         :param contact_point: Contact point to create.
         :return: :class:`ContactPoint <ContactPoint>`
 
         Usage:
         ::
 
             result = await api.create_contact_point()
@@ -411,18 +471,19 @@
         self,
         *,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         project_id: Optional[str] = None,
     ) -> ListContactPointsResponse:
         """
-        List alert contact points associated with the given cockpit ID.
+        List contact points.
+        Get a list of contact points for the Cockpit associated with the specified Project ID.
         :param page: Page number.
         :param page_size: Page size.
-        :param project_id: Project ID.
+        :param project_id: ID of the Project from which to list the contact points.
         :return: :class:`ListContactPointsResponse <ListContactPointsResponse>`
 
         Usage:
         ::
 
             result = await api.list_contact_points()
         """
@@ -444,18 +505,19 @@
         self,
         *,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         project_id: Optional[str] = None,
     ) -> List[ContactPoint]:
         """
-        List alert contact points associated with the given cockpit ID.
+        List contact points.
+        Get a list of contact points for the Cockpit associated with the specified Project ID.
         :param page: Page number.
         :param page_size: Page size.
-        :param project_id: Project ID.
+        :param project_id: ID of the Project from which to list the contact points.
         :return: :class:`List[ListContactPointsResponse] <List[ListContactPointsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_contact_points_all()
         """
@@ -474,16 +536,17 @@
     async def delete_contact_point(
         self,
         *,
         project_id: Optional[str] = None,
         contact_point: Optional[ContactPoint] = None,
     ) -> Optional[None]:
         """
-        Delete an alert contact point for the default receiver.
-        :param project_id:
+        Delete an alert contact point.
+        Delete a contact point for the default receiver.
+        :param project_id: ID of the Project.
         :param contact_point: Contact point to delete.
 
         Usage:
         ::
 
             result = await api.delete_contact_point()
         """
@@ -506,15 +569,16 @@
     async def enable_managed_alerts(
         self,
         *,
         project_id: Optional[str] = None,
     ) -> Optional[None]:
         """
         Enable managed alerts.
-        :param project_id:
+        Enable the sending of managed alerts for the specified Project's Cockpit.
+        :param project_id: ID of the Project.
 
         Usage:
         ::
 
             result = await api.enable_managed_alerts()
         """
 
@@ -535,15 +599,16 @@
     async def disable_managed_alerts(
         self,
         *,
         project_id: Optional[str] = None,
     ) -> Optional[None]:
         """
         Disable managed alerts.
-        :param project_id:
+        Disable the sending of managed alerts for the specified Project's Cockpit.
+        :param project_id: ID of the Project.
 
         Usage:
         ::
 
             result = await api.disable_managed_alerts()
         """
 
@@ -563,15 +628,16 @@
 
     async def trigger_test_alert(
         self,
         *,
         project_id: Optional[str] = None,
     ) -> Optional[None]:
         """
-        Trigger a test alert to all receivers.
+        Trigger a test alert.
+        Trigger a test alert to all of the Cockpit's receivers.
         :param project_id:
 
         Usage:
         ::
 
             result = await api.trigger_test_alert()
         """
@@ -594,18 +660,19 @@
         self,
         *,
         login: str,
         role: GrafanaUserRole,
         project_id: Optional[str] = None,
     ) -> GrafanaUser:
         """
-        Create a grafana user for your grafana instance.
-        :param project_id:
-        :param login:
-        :param role:
+        Create a Grafana user.
+        Create a Grafana user for your Cockpit's Grafana instance. Make sure you save the automatically-generated password and the Grafana user ID.
+        :param project_id: ID of the Project.
+        :param login: Username of the Grafana user.
+        :param role: Role assigned to the Grafana user.
         :return: :class:`GrafanaUser <GrafanaUser>`
 
         Usage:
         ::
 
             result = await api.create_grafana_user(
                 login="example",
@@ -634,19 +701,20 @@
         *,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListGrafanaUsersRequestOrderBy = ListGrafanaUsersRequestOrderBy.LOGIN_ASC,
         project_id: Optional[str] = None,
     ) -> ListGrafanaUsersResponse:
         """
-        List grafana users who are able to connect to your grafana instance.
-        :param page:
-        :param page_size:
+        List Grafana users.
+        Get a list of Grafana users who are able to connect to the Cockpit's Grafana instance.
+        :param page: Page number.
+        :param page_size: Page size.
         :param order_by:
-        :param project_id:
+        :param project_id: ID of the Project.
         :return: :class:`ListGrafanaUsersResponse <ListGrafanaUsersResponse>`
 
         Usage:
         ::
 
             result = await api.list_grafana_users()
         """
@@ -670,19 +738,20 @@
         *,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListGrafanaUsersRequestOrderBy] = None,
         project_id: Optional[str] = None,
     ) -> List[GrafanaUser]:
         """
-        List grafana users who are able to connect to your grafana instance.
-        :param page:
-        :param page_size:
+        List Grafana users.
+        Get a list of Grafana users who are able to connect to the Cockpit's Grafana instance.
+        :param page: Page number.
+        :param page_size: Page size.
         :param order_by:
-        :param project_id:
+        :param project_id: ID of the Project.
         :return: :class:`List[ListGrafanaUsersResponse] <List[ListGrafanaUsersResponse]>`
 
         Usage:
         ::
 
             result = await api.list_grafana_users_all()
         """
@@ -702,17 +771,18 @@
     async def delete_grafana_user(
         self,
         *,
         grafana_user_id: int,
         project_id: Optional[str] = None,
     ) -> Optional[None]:
         """
-        Delete a grafana user from your grafana instance.
-        :param grafana_user_id:
-        :param project_id:
+        Delete a Grafana user.
+        Delete a Grafana user from a Grafana instance, specified by the Cockpit's Project ID and the Grafana user ID.
+        :param grafana_user_id: ID of the Grafana user.
+        :param project_id: ID of the Project.
 
         Usage:
         ::
 
             result = await api.delete_grafana_user(grafana_user_id=1)
         """
 
@@ -736,17 +806,18 @@
     async def reset_grafana_user_password(
         self,
         *,
         grafana_user_id: int,
         project_id: Optional[str] = None,
     ) -> GrafanaUser:
         """
-        Reset the Grafana user password from your grafana instance.
-        :param grafana_user_id:
-        :param project_id:
+        Reset a Grafana user's password.
+        Reset a Grafana user's password specified by the Cockpit's Project ID and the Grafana user ID.
+        :param grafana_user_id: ID of the Grafana user.
+        :param project_id: ID of the Project.
         :return: :class:`GrafanaUser <GrafanaUser>`
 
         Usage:
         ::
 
             result = await api.reset_grafana_user_password(grafana_user_id=1)
         """
@@ -763,7 +834,107 @@
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_GrafanaUser(res.json())
+
+    async def list_plans(
+        self,
+        *,
+        page: Optional[int] = None,
+        page_size: Optional[int] = None,
+        order_by: ListPlansRequestOrderBy = ListPlansRequestOrderBy.NAME_ASC,
+    ) -> ListPlansResponse:
+        """
+        List pricing plans.
+        Get a list of all pricing plans available.
+        :param page: Page number.
+        :param page_size: Page size.
+        :param order_by:
+        :return: :class:`ListPlansResponse <ListPlansResponse>`
+
+        Usage:
+        ::
+
+            result = await api.list_plans()
+        """
+
+        res = self._request(
+            "GET",
+            f"/cockpit/v1beta1/plans",
+            params={
+                "order_by": order_by,
+                "page": page,
+                "page_size": page_size or self.client.default_page_size,
+            },
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_ListPlansResponse(res.json())
+
+    async def list_plans_all(
+        self,
+        *,
+        page: Optional[int] = None,
+        page_size: Optional[int] = None,
+        order_by: Optional[ListPlansRequestOrderBy] = None,
+    ) -> List[Plan]:
+        """
+        List pricing plans.
+        Get a list of all pricing plans available.
+        :param page: Page number.
+        :param page_size: Page size.
+        :param order_by:
+        :return: :class:`List[ListPlansResponse] <List[ListPlansResponse]>`
+
+        Usage:
+        ::
+
+            result = await api.list_plans_all()
+        """
+
+        return await fetch_all_pages_async(
+            type=ListPlansResponse,
+            key="plans",
+            fetcher=self.list_plans,
+            args={
+                "page": page,
+                "page_size": page_size,
+                "order_by": order_by,
+            },
+        )
+
+    async def select_plan(
+        self,
+        *,
+        plan_id: str,
+        project_id: Optional[str] = None,
+    ) -> SelectPlanResponse:
+        """
+        Select pricing plan.
+        Select your chosen pricing plan for your Cockpit, specifying the Cockpit's Project ID and the pricing plan's ID in the request.
+        :param project_id: ID of the Project.
+        :param plan_id: ID of the pricing plan.
+        :return: :class:`SelectPlanResponse <SelectPlanResponse>`
+
+        Usage:
+        ::
+
+            result = await api.select_plan(plan_id="example")
+        """
+
+        res = self._request(
+            "POST",
+            f"/cockpit/v1beta1/select-plan",
+            body=marshal_SelectPlanRequest(
+                SelectPlanRequest(
+                    plan_id=plan_id,
+                    project_id=project_id,
+                ),
+                self.client,
+            ),
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_SelectPlanResponse(res.json())
```

### Comparing `scaleway_async-0.9.0/scaleway_async/cockpit/v1beta1/marshalling.py` & `scaleway_async-1.0.0/scaleway_async/cockpit/v1beta1/marshalling.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,417 +1,591 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 
 from typing import Any, Dict
 
 from scaleway_core.profile import ProfileDefaults
+from scaleway_core.bridge import (
+    unmarshal_TimeSeries,
+)
 from scaleway_core.utils import (
     OneOfPossibility,
     resolve_one_of,
 )
 from dateutil import parser
 from .types import (
     GrafanaUserRole,
     Cockpit,
     CockpitEndpoints,
+    CockpitMetrics,
     ContactPoint,
     ContactPointEmail,
     GrafanaUser,
     ListContactPointsResponse,
     ListGrafanaUsersResponse,
+    ListPlansResponse,
     ListTokensResponse,
+    Plan,
+    SelectPlanResponse,
     Token,
     TokenScopes,
     ActivateCockpitRequest,
     DeactivateCockpitRequest,
     ResetCockpitGrafanaRequest,
     CreateTokenRequest,
     CreateContactPointRequest,
     DeleteContactPointRequest,
     EnableManagedAlertsRequest,
     DisableManagedAlertsRequest,
     TriggerTestAlertRequest,
     CreateGrafanaUserRequest,
     DeleteGrafanaUserRequest,
     ResetGrafanaUserPasswordRequest,
+    SelectPlanRequest,
 )
 
 
 def unmarshal_ContactPointEmail(data: Any) -> ContactPointEmail:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ContactPointEmail' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("to")
+    field = data.get("to", None)
     args["to"] = field
 
     return ContactPointEmail(**args)
 
 
 def unmarshal_TokenScopes(data: Any) -> TokenScopes:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'TokenScopes' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("query_logs")
+    field = data.get("query_logs", None)
     args["query_logs"] = field
 
-    field = data.get("query_metrics")
+    field = data.get("query_metrics", None)
     args["query_metrics"] = field
 
-    field = data.get("setup_alerts")
+    field = data.get("setup_alerts", None)
     args["setup_alerts"] = field
 
-    field = data.get("setup_logs_rules")
+    field = data.get("setup_logs_rules", None)
     args["setup_logs_rules"] = field
 
-    field = data.get("setup_metrics_rules")
+    field = data.get("setup_metrics_rules", None)
     args["setup_metrics_rules"] = field
 
-    field = data.get("write_logs")
+    field = data.get("write_logs", None)
     args["write_logs"] = field
 
-    field = data.get("write_metrics")
+    field = data.get("write_metrics", None)
     args["write_metrics"] = field
 
     return TokenScopes(**args)
 
 
 def unmarshal_CockpitEndpoints(data: Any) -> CockpitEndpoints:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'CockpitEndpoints' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("alertmanager_url")
+    field = data.get("alertmanager_url", None)
     args["alertmanager_url"] = field
 
-    field = data.get("grafana_url")
+    field = data.get("grafana_url", None)
     args["grafana_url"] = field
 
-    field = data.get("logs_url")
+    field = data.get("logs_url", None)
     args["logs_url"] = field
 
-    field = data.get("metrics_url")
+    field = data.get("metrics_url", None)
     args["metrics_url"] = field
 
     return CockpitEndpoints(**args)
 
 
 def unmarshal_ContactPoint(data: Any) -> ContactPoint:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ContactPoint' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("email")
+    field = data.get("email", None)
     args["email"] = unmarshal_ContactPointEmail(field) if field is not None else None
 
     return ContactPoint(**args)
 
 
 def unmarshal_GrafanaUser(data: Any) -> GrafanaUser:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'GrafanaUser' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("login")
+    field = data.get("login", None)
     args["login"] = field
 
-    field = data.get("password")
+    field = data.get("password", None)
     args["password"] = field
 
-    field = data.get("role")
+    field = data.get("role", None)
     args["role"] = field
 
     return GrafanaUser(**args)
 
 
+def unmarshal_Plan(data: Any) -> Plan:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'Plan' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("id", None)
+    args["id"] = field
+
+    field = data.get("logs_ingestion_price", None)
+    args["logs_ingestion_price"] = field
+
+    field = data.get("name", None)
+    args["name"] = field
+
+    field = data.get("retention_logs_interval", None)
+    args["retention_logs_interval"] = field
+
+    field = data.get("retention_metrics_interval", None)
+    args["retention_metrics_interval"] = field
+
+    field = data.get("retention_price", None)
+    args["retention_price"] = field
+
+    field = data.get("sample_ingestion_price", None)
+    args["sample_ingestion_price"] = field
+
+    return Plan(**args)
+
+
 def unmarshal_Token(data: Any) -> Token:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Token' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("project_id")
+    field = data.get("project_id", None)
     args["project_id"] = field
 
-    field = data.get("scopes")
+    field = data.get("scopes", None)
     args["scopes"] = unmarshal_TokenScopes(field) if field is not None else None
 
-    field = data.get("secret_key")
+    field = data.get("secret_key", None)
     args["secret_key"] = field
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
     return Token(**args)
 
 
 def unmarshal_Cockpit(data: Any) -> Cockpit:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Cockpit' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("endpoints")
+    field = data.get("endpoints", None)
     args["endpoints"] = unmarshal_CockpitEndpoints(field) if field is not None else None
 
-    field = data.get("managed_alerts_enabled")
+    field = data.get("managed_alerts_enabled", None)
     args["managed_alerts_enabled"] = field
 
-    field = data.get("project_id")
+    field = data.get("plan", None)
+    args["plan"] = unmarshal_Plan(field) if field is not None else None
+
+    field = data.get("project_id", None)
     args["project_id"] = field
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
     return Cockpit(**args)
 
 
+def unmarshal_CockpitMetrics(data: Any) -> CockpitMetrics:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'CockpitMetrics' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("timeseries", None)
+    args["timeseries"] = (
+        [unmarshal_TimeSeries(v) for v in field] if field is not None else None
+    )
+
+    return CockpitMetrics(**args)
+
+
 def unmarshal_ListContactPointsResponse(data: Any) -> ListContactPointsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListContactPointsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("contact_points")
-    args["contact_points"] = [unmarshal_ContactPoint(v) for v in data["contact_points"]]
+    field = data.get("contact_points", None)
+    args["contact_points"] = (
+        [unmarshal_ContactPoint(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("has_additional_contact_points")
+    field = data.get("has_additional_contact_points", None)
     args["has_additional_contact_points"] = field
 
-    field = data.get("has_additional_receivers")
+    field = data.get("has_additional_receivers", None)
     args["has_additional_receivers"] = field
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListContactPointsResponse(**args)
 
 
 def unmarshal_ListGrafanaUsersResponse(data: Any) -> ListGrafanaUsersResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListGrafanaUsersResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("grafana_users")
-    args["grafana_users"] = [unmarshal_GrafanaUser(v) for v in data["grafana_users"]]
+    field = data.get("grafana_users", None)
+    args["grafana_users"] = (
+        [unmarshal_GrafanaUser(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListGrafanaUsersResponse(**args)
 
 
+def unmarshal_ListPlansResponse(data: Any) -> ListPlansResponse:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'ListPlansResponse' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("plans", None)
+    args["plans"] = [unmarshal_Plan(v) for v in field] if field is not None else None
+
+    field = data.get("total_count", None)
+    args["total_count"] = field
+
+    return ListPlansResponse(**args)
+
+
 def unmarshal_ListTokensResponse(data: Any) -> ListTokensResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListTokensResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("tokens")
-    args["tokens"] = [unmarshal_Token(v) for v in data["tokens"]]
+    field = data.get("tokens", None)
+    args["tokens"] = [unmarshal_Token(v) for v in field] if field is not None else None
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListTokensResponse(**args)
 
 
+def unmarshal_SelectPlanResponse(data: Any) -> SelectPlanResponse:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'SelectPlanResponse' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    return SelectPlanResponse(**args)
+
+
 def marshal_ContactPointEmail(
     request: ContactPointEmail,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "to": request.to,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.to is not None:
+        output["to"] = request.to
+
+    return output
 
 
 def marshal_ContactPoint(
     request: ContactPoint,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("email", request.email),
+                OneOfPossibility(
+                    "email",
+                    marshal_ContactPointEmail(request.email, defaults)
+                    if request.email is not None
+                    else None,
+                ),
             ]
         ),
-    }
+    )
+
+    return output
 
 
 def marshal_TokenScopes(
     request: TokenScopes,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "query_logs": request.query_logs,
-        "query_metrics": request.query_metrics,
-        "setup_alerts": request.setup_alerts,
-        "setup_logs_rules": request.setup_logs_rules,
-        "setup_metrics_rules": request.setup_metrics_rules,
-        "write_logs": request.write_logs,
-        "write_metrics": request.write_metrics,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.query_logs is not None:
+        output["query_logs"] = request.query_logs
+
+    if request.query_metrics is not None:
+        output["query_metrics"] = request.query_metrics
+
+    if request.setup_alerts is not None:
+        output["setup_alerts"] = request.setup_alerts
+
+    if request.setup_logs_rules is not None:
+        output["setup_logs_rules"] = request.setup_logs_rules
+
+    if request.setup_metrics_rules is not None:
+        output["setup_metrics_rules"] = request.setup_metrics_rules
+
+    if request.write_logs is not None:
+        output["write_logs"] = request.write_logs
+
+    if request.write_metrics is not None:
+        output["write_metrics"] = request.write_metrics
+
+    return output
 
 
 def marshal_ActivateCockpitRequest(
     request: ActivateCockpitRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "project_id": request.project_id or defaults.default_project_id,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    return output
 
 
 def marshal_CreateContactPointRequest(
     request: CreateContactPointRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "contact_point": marshal_ContactPoint(request.contact_point, defaults)
-        if request.contact_point is not None
-        else None,
-        "project_id": request.project_id or defaults.default_project_id,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.contact_point is not None:
+        output["contact_point"] = marshal_ContactPoint(request.contact_point, defaults)
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    return output
 
 
 def marshal_CreateGrafanaUserRequest(
     request: CreateGrafanaUserRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "login": request.login,
-        "project_id": request.project_id or defaults.default_project_id,
-        "role": GrafanaUserRole(request.role),
-    }
+    output: Dict[str, Any] = {}
+
+    if request.login is not None:
+        output["login"] = request.login
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    if request.role is not None:
+        output["role"] = GrafanaUserRole(request.role)
+
+    return output
 
 
 def marshal_CreateTokenRequest(
     request: CreateTokenRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "name": request.name,
-        "project_id": request.project_id or defaults.default_project_id,
-        "scopes": marshal_TokenScopes(request.scopes, defaults)
-        if request.scopes is not None
-        else None,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    if request.scopes is not None:
+        output["scopes"] = marshal_TokenScopes(request.scopes, defaults)
+
+    return output
 
 
 def marshal_DeactivateCockpitRequest(
     request: DeactivateCockpitRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "project_id": request.project_id or defaults.default_project_id,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    return output
 
 
 def marshal_DeleteContactPointRequest(
     request: DeleteContactPointRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "contact_point": marshal_ContactPoint(request.contact_point, defaults)
-        if request.contact_point is not None
-        else None,
-        "project_id": request.project_id or defaults.default_project_id,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.contact_point is not None:
+        output["contact_point"] = marshal_ContactPoint(request.contact_point, defaults)
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    return output
 
 
 def marshal_DeleteGrafanaUserRequest(
     request: DeleteGrafanaUserRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "project_id": request.project_id or defaults.default_project_id,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    return output
 
 
 def marshal_DisableManagedAlertsRequest(
     request: DisableManagedAlertsRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "project_id": request.project_id or defaults.default_project_id,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    return output
 
 
 def marshal_EnableManagedAlertsRequest(
     request: EnableManagedAlertsRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "project_id": request.project_id or defaults.default_project_id,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    return output
 
 
 def marshal_ResetCockpitGrafanaRequest(
     request: ResetCockpitGrafanaRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "project_id": request.project_id or defaults.default_project_id,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    return output
 
 
 def marshal_ResetGrafanaUserPasswordRequest(
     request: ResetGrafanaUserPasswordRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "project_id": request.project_id or defaults.default_project_id,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    return output
+
+
+def marshal_SelectPlanRequest(
+    request: SelectPlanRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.plan_id is not None:
+        output["plan_id"] = request.plan_id
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    return output
 
 
 def marshal_TriggerTestAlertRequest(
     request: TriggerTestAlertRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "project_id": request.project_id or defaults.default_project_id,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    return output
```

### Comparing `scaleway_async-0.9.0/scaleway_async/container/v1beta1/__init__.py` & `scaleway_async-1.0.0/scaleway_async/function/v1beta1/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,77 +1,113 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
-from .types import ContainerHttpOption
-from .types import ContainerPrivacy
-from .types import ContainerProtocol
-from .types import ContainerStatus
 from .types import CronStatus
 from .types import DomainStatus
-from .types import ListContainersRequestOrderBy
+from .types import FunctionHttpOption
+from .types import FunctionPrivacy
+from .types import FunctionRuntime
+from .types import FunctionStatus
 from .types import ListCronsRequestOrderBy
 from .types import ListDomainsRequestOrderBy
+from .types import ListFunctionsRequestOrderBy
 from .types import ListLogsRequestOrderBy
 from .types import ListNamespacesRequestOrderBy
 from .types import ListTokensRequestOrderBy
+from .types import ListTriggersRequestOrderBy
 from .types import LogStream
 from .types import NamespaceStatus
 from .types import NullValue
+from .types import RuntimeStatus
 from .types import TokenStatus
-from .types import Container
+from .types import TriggerInputType
+from .types import TriggerStatus
+from .types import CreateTriggerRequestMnqNatsClientConfig
+from .types import CreateTriggerRequestMnqSqsClientConfig
+from .types import CreateTriggerRequestSqsClientConfig
 from .types import Cron
 from .types import Domain
-from .types import ListContainersResponse
+from .types import DownloadURL
+from .types import Function
 from .types import ListCronsResponse
 from .types import ListDomainsResponse
+from .types import ListFunctionRuntimesResponse
+from .types import ListFunctionsResponse
 from .types import ListLogsResponse
 from .types import ListNamespacesResponse
 from .types import ListTokensResponse
+from .types import ListTriggersResponse
 from .types import Log
 from .types import Namespace
+from .types import Runtime
 from .types import Secret
 from .types import SecretHashedValue
 from .types import Token
-from .content import CONTAINER_TRANSIENT_STATUSES
+from .types import Trigger
+from .types import TriggerMnqNatsClientConfig
+from .types import TriggerMnqSqsClientConfig
+from .types import TriggerSqsClientConfig
+from .types import UpdateTriggerRequestSqsClientConfig
+from .types import UploadURL
 from .content import CRON_TRANSIENT_STATUSES
 from .content import DOMAIN_TRANSIENT_STATUSES
+from .content import FUNCTION_TRANSIENT_STATUSES
 from .content import NAMESPACE_TRANSIENT_STATUSES
 from .content import TOKEN_TRANSIENT_STATUSES
-from .api import ContainerV1Beta1API
+from .content import TRIGGER_TRANSIENT_STATUSES
+from .api import FunctionV1Beta1API
 
 __all__ = [
-    "ContainerHttpOption",
-    "ContainerPrivacy",
-    "ContainerProtocol",
-    "ContainerStatus",
     "CronStatus",
     "DomainStatus",
-    "ListContainersRequestOrderBy",
+    "FunctionHttpOption",
+    "FunctionPrivacy",
+    "FunctionRuntime",
+    "FunctionStatus",
     "ListCronsRequestOrderBy",
     "ListDomainsRequestOrderBy",
+    "ListFunctionsRequestOrderBy",
     "ListLogsRequestOrderBy",
     "ListNamespacesRequestOrderBy",
     "ListTokensRequestOrderBy",
+    "ListTriggersRequestOrderBy",
     "LogStream",
     "NamespaceStatus",
     "NullValue",
+    "RuntimeStatus",
     "TokenStatus",
-    "Container",
+    "TriggerInputType",
+    "TriggerStatus",
+    "CreateTriggerRequestMnqNatsClientConfig",
+    "CreateTriggerRequestMnqSqsClientConfig",
+    "CreateTriggerRequestSqsClientConfig",
     "Cron",
     "Domain",
-    "ListContainersResponse",
+    "DownloadURL",
+    "Function",
     "ListCronsResponse",
     "ListDomainsResponse",
+    "ListFunctionRuntimesResponse",
+    "ListFunctionsResponse",
     "ListLogsResponse",
     "ListNamespacesResponse",
     "ListTokensResponse",
+    "ListTriggersResponse",
     "Log",
     "Namespace",
+    "Runtime",
     "Secret",
     "SecretHashedValue",
     "Token",
-    "CONTAINER_TRANSIENT_STATUSES",
+    "Trigger",
+    "TriggerMnqNatsClientConfig",
+    "TriggerMnqSqsClientConfig",
+    "TriggerSqsClientConfig",
+    "UpdateTriggerRequestSqsClientConfig",
+    "UploadURL",
     "CRON_TRANSIENT_STATUSES",
     "DOMAIN_TRANSIENT_STATUSES",
+    "FUNCTION_TRANSIENT_STATUSES",
     "NAMESPACE_TRANSIENT_STATUSES",
     "TOKEN_TRANSIENT_STATUSES",
-    "ContainerV1Beta1API",
+    "TRIGGER_TRANSIENT_STATUSES",
+    "FunctionV1Beta1API",
 ]
```

### Comparing `scaleway_async-0.9.0/scaleway_async/container/v1beta1/api.py` & `scaleway_async-1.0.0/scaleway_async/function/v1beta1/api.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,117 +14,138 @@
     fetch_all_pages_async,
     random_name,
     resolve_one_of,
     validate_path_param,
     wait_for_resource_async,
 )
 from .types import (
-    ContainerHttpOption,
-    ContainerPrivacy,
-    ContainerProtocol,
-    ListContainersRequestOrderBy,
+    FunctionHttpOption,
+    FunctionPrivacy,
+    FunctionRuntime,
     ListCronsRequestOrderBy,
     ListDomainsRequestOrderBy,
+    ListFunctionsRequestOrderBy,
     ListLogsRequestOrderBy,
     ListNamespacesRequestOrderBy,
     ListTokensRequestOrderBy,
-    Container,
+    ListTriggersRequestOrderBy,
+    CreateTriggerRequestMnqNatsClientConfig,
+    CreateTriggerRequestMnqSqsClientConfig,
+    CreateTriggerRequestSqsClientConfig,
     Cron,
     Domain,
-    ListContainersResponse,
+    DownloadURL,
+    Function,
     ListCronsResponse,
     ListDomainsResponse,
+    ListFunctionRuntimesResponse,
+    ListFunctionsResponse,
     ListLogsResponse,
     ListNamespacesResponse,
     ListTokensResponse,
+    ListTriggersResponse,
     Log,
     Namespace,
     Secret,
     Token,
+    Trigger,
+    UpdateTriggerRequestSqsClientConfig,
+    UploadURL,
     CreateNamespaceRequest,
     UpdateNamespaceRequest,
-    CreateContainerRequest,
-    UpdateContainerRequest,
+    CreateFunctionRequest,
+    UpdateFunctionRequest,
     CreateCronRequest,
     UpdateCronRequest,
     CreateDomainRequest,
     CreateTokenRequest,
+    CreateTriggerRequest,
+    UpdateTriggerRequest,
 )
 from .content import (
-    CONTAINER_TRANSIENT_STATUSES,
     CRON_TRANSIENT_STATUSES,
     DOMAIN_TRANSIENT_STATUSES,
+    FUNCTION_TRANSIENT_STATUSES,
     NAMESPACE_TRANSIENT_STATUSES,
     TOKEN_TRANSIENT_STATUSES,
+    TRIGGER_TRANSIENT_STATUSES,
 )
 from .marshalling import (
-    marshal_CreateContainerRequest,
     marshal_CreateCronRequest,
     marshal_CreateDomainRequest,
+    marshal_CreateFunctionRequest,
     marshal_CreateNamespaceRequest,
     marshal_CreateTokenRequest,
-    marshal_UpdateContainerRequest,
+    marshal_CreateTriggerRequest,
     marshal_UpdateCronRequest,
+    marshal_UpdateFunctionRequest,
     marshal_UpdateNamespaceRequest,
-    unmarshal_Container,
+    marshal_UpdateTriggerRequest,
     unmarshal_Cron,
     unmarshal_Domain,
+    unmarshal_Function,
     unmarshal_Namespace,
     unmarshal_Token,
-    unmarshal_ListContainersResponse,
+    unmarshal_Trigger,
+    unmarshal_DownloadURL,
     unmarshal_ListCronsResponse,
     unmarshal_ListDomainsResponse,
+    unmarshal_ListFunctionRuntimesResponse,
+    unmarshal_ListFunctionsResponse,
     unmarshal_ListLogsResponse,
     unmarshal_ListNamespacesResponse,
     unmarshal_ListTokensResponse,
+    unmarshal_ListTriggersResponse,
+    unmarshal_UploadURL,
 )
 
 
-class ContainerV1Beta1API(API):
+class FunctionV1Beta1API(API):
     """
-    Containers API.
+    Serverless Functions API.
 
-    Serverless Containers API.
+    Serverless Functions API.
     """
 
     async def list_namespaces(
         self,
         *,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListNamespacesRequestOrderBy = ListNamespacesRequestOrderBy.CREATED_AT_ASC,
         name: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> ListNamespacesResponse:
         """
-        List all your namespaces
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page:
-        :param page_size:
-        :param order_by:
-        :param name:
-        :param organization_id:
-        :param project_id:
+        List all your namespaces.
+        List all existing namespaces in the specified region.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number.
+        :param page_size: Number of namespaces per page.
+        :param order_by: Order of the namespaces.
+        :param name: Name of the namespace.
+        :param organization_id: UUID of the Organization the namespace belongs to.
+        :param project_id: UUID of the Project the namespace belongs to.
         :return: :class:`ListNamespacesResponse <ListNamespacesResponse>`
 
         Usage:
         ::
 
             result = await api.list_namespaces()
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "GET",
-            f"/containers/v1beta1/regions/{param_region}/namespaces",
+            f"/functions/v1beta1/regions/{param_region}/namespaces",
             params={
                 "name": name,
                 "order_by": order_by,
                 "organization_id": organization_id
                 or self.client.default_organization_id,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
@@ -143,22 +164,23 @@
         page_size: Optional[int] = None,
         order_by: Optional[ListNamespacesRequestOrderBy] = None,
         name: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> List[Namespace]:
         """
-        List all your namespaces
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page:
-        :param page_size:
-        :param order_by:
-        :param name:
-        :param organization_id:
-        :param project_id:
+        List all your namespaces.
+        List all existing namespaces in the specified region.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number.
+        :param page_size: Number of namespaces per page.
+        :param order_by: Order of the namespaces.
+        :param name: Name of the namespace.
+        :param organization_id: UUID of the Organization the namespace belongs to.
+        :param project_id: UUID of the Project the namespace belongs to.
         :return: :class:`List[ListNamespacesResponse] <List[ListNamespacesResponse]>`
 
         Usage:
         ::
 
             result = await api.list_namespaces_all()
         """
@@ -181,17 +203,18 @@
     async def get_namespace(
         self,
         *,
         namespace_id: str,
         region: Optional[Region] = None,
     ) -> Namespace:
         """
-        Get the namespace associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param namespace_id:
+        Get a namespace.
+        Get the namespace associated with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param namespace_id: UUID of the namespace.
         :return: :class:`Namespace <Namespace>`
 
         Usage:
         ::
 
             result = await api.get_namespace(namespace_id="example")
         """
@@ -199,15 +222,15 @@
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_namespace_id = validate_path_param("namespace_id", namespace_id)
 
         res = self._request(
             "GET",
-            f"/containers/v1beta1/regions/{param_region}/namespaces/{param_namespace_id}",
+            f"/functions/v1beta1/regions/{param_region}/namespaces/{param_namespace_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_Namespace(res.json())
 
     async def wait_for_namespace(
         self,
@@ -216,16 +239,16 @@
         region: Optional[Region] = None,
         options: Optional[
             WaitForOptions[Namespace, Union[bool, Awaitable[bool]]]
         ] = None,
     ) -> Namespace:
         """
         Waits for :class:`Namespace <Namespace>` to be in a final state.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param namespace_id:
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param namespace_id: UUID of the namespace.
         :param options: The options for the waiter
         :return: :class:`Namespace <Namespace>`
 
         Usage:
         ::
 
             result = api.wait_for_namespace(namespace_id="example")
@@ -253,40 +276,41 @@
         name: Optional[str] = None,
         environment_variables: Optional[Dict[str, str]] = None,
         project_id: Optional[str] = None,
         description: Optional[str] = None,
         secret_environment_variables: Optional[List[Secret]] = None,
     ) -> Namespace:
         """
-        Create a new namespace
-        :param region: Region to target. If none is passed will use default region from the config
+        Create a new namespace.
+        Create a new namespace in a specified Organization or Project.
+        :param region: Region to target. If none is passed will use default region from the config.
         :param name:
-        :param environment_variables:
-        :param project_id:
-        :param description:
-        :param secret_environment_variables:
+        :param environment_variables: Environment variables of the namespace.
+        :param project_id: UUID of the project in which the namespace will be created.
+        :param description: Description of the namespace.
+        :param secret_environment_variables: Secret environment variables of the namespace.
         :return: :class:`Namespace <Namespace>`
 
         Usage:
         ::
 
             result = await api.create_namespace()
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "POST",
-            f"/containers/v1beta1/regions/{param_region}/namespaces",
+            f"/functions/v1beta1/regions/{param_region}/namespaces",
             body=marshal_CreateNamespaceRequest(
                 CreateNamespaceRequest(
                     region=region,
-                    name=name or random_name(prefix="cns"),
+                    name=name or random_name(prefix="ns"),
                     environment_variables=environment_variables,
                     project_id=project_id,
                     description=description,
                     secret_environment_variables=secret_environment_variables,
                 ),
                 self.client,
             ),
@@ -301,20 +325,21 @@
         namespace_id: str,
         region: Optional[Region] = None,
         environment_variables: Optional[Dict[str, str]] = None,
         description: Optional[str] = None,
         secret_environment_variables: Optional[List[Secret]] = None,
     ) -> Namespace:
         """
-        Update the space associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param namespace_id:
-        :param environment_variables:
-        :param description:
-        :param secret_environment_variables:
+        Update an existing namespace.
+        Update the namespace associated with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param namespace_id: UUID of the namespapce.
+        :param environment_variables: Environment variables of the namespace.
+        :param description: Description of the namespace.
+        :param secret_environment_variables: Secret environment variables of the namespace.
         :return: :class:`Namespace <Namespace>`
 
         Usage:
         ::
 
             result = await api.update_namespace(namespace_id="example")
         """
@@ -322,15 +347,15 @@
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_namespace_id = validate_path_param("namespace_id", namespace_id)
 
         res = self._request(
             "PATCH",
-            f"/containers/v1beta1/regions/{param_region}/namespaces/{param_namespace_id}",
+            f"/functions/v1beta1/regions/{param_region}/namespaces/{param_namespace_id}",
             body=marshal_UpdateNamespaceRequest(
                 UpdateNamespaceRequest(
                     namespace_id=namespace_id,
                     region=region,
                     environment_variables=environment_variables,
                     description=description,
                     secret_environment_variables=secret_environment_variables,
@@ -345,17 +370,18 @@
     async def delete_namespace(
         self,
         *,
         namespace_id: str,
         region: Optional[Region] = None,
     ) -> Namespace:
         """
-        Delete the namespace associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param namespace_id:
+        Delete an existing namespace.
+        Delete the namespace associated with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param namespace_id: UUID of the namespace.
         :return: :class:`Namespace <Namespace>`
 
         Usage:
         ::
 
             result = await api.delete_namespace(namespace_id="example")
         """
@@ -363,512 +389,609 @@
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_namespace_id = validate_path_param("namespace_id", namespace_id)
 
         res = self._request(
             "DELETE",
-            f"/containers/v1beta1/regions/{param_region}/namespaces/{param_namespace_id}",
+            f"/functions/v1beta1/regions/{param_region}/namespaces/{param_namespace_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_Namespace(res.json())
 
-    async def list_containers(
+    async def list_functions(
         self,
         *,
         namespace_id: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
-        order_by: ListContainersRequestOrderBy = ListContainersRequestOrderBy.CREATED_AT_ASC,
+        order_by: ListFunctionsRequestOrderBy = ListFunctionsRequestOrderBy.CREATED_AT_ASC,
         name: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
-    ) -> ListContainersResponse:
+    ) -> ListFunctionsResponse:
         """
-        List all your containers
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page:
-        :param page_size:
-        :param order_by:
-        :param namespace_id:
-        :param name:
-        :param organization_id:
-        :param project_id:
-        :return: :class:`ListContainersResponse <ListContainersResponse>`
+        List all your functions.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number.
+        :param page_size: Number of functions per page.
+        :param order_by: Order of the functions.
+        :param namespace_id: UUID of the namespace the function belongs to.
+        :param name: Name of the function.
+        :param organization_id: UUID of the Organziation the function belongs to.
+        :param project_id: UUID of the Project the function belongs to.
+        :return: :class:`ListFunctionsResponse <ListFunctionsResponse>`
 
         Usage:
         ::
 
-            result = await api.list_containers(namespace_id="example")
+            result = await api.list_functions(namespace_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "GET",
-            f"/containers/v1beta1/regions/{param_region}/containers",
+            f"/functions/v1beta1/regions/{param_region}/functions",
             params={
                 "name": name,
                 "namespace_id": namespace_id,
                 "order_by": order_by,
                 "organization_id": organization_id
                 or self.client.default_organization_id,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
                 "project_id": project_id or self.client.default_project_id,
             },
         )
 
         self._throw_on_error(res)
-        return unmarshal_ListContainersResponse(res.json())
+        return unmarshal_ListFunctionsResponse(res.json())
 
-    async def list_containers_all(
+    async def list_functions_all(
         self,
         *,
         namespace_id: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
-        order_by: Optional[ListContainersRequestOrderBy] = None,
+        order_by: Optional[ListFunctionsRequestOrderBy] = None,
         name: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
-    ) -> List[Container]:
+    ) -> List[Function]:
         """
-        List all your containers
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page:
-        :param page_size:
-        :param order_by:
-        :param namespace_id:
-        :param name:
-        :param organization_id:
-        :param project_id:
-        :return: :class:`List[ListContainersResponse] <List[ListContainersResponse]>`
+        List all your functions.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number.
+        :param page_size: Number of functions per page.
+        :param order_by: Order of the functions.
+        :param namespace_id: UUID of the namespace the function belongs to.
+        :param name: Name of the function.
+        :param organization_id: UUID of the Organziation the function belongs to.
+        :param project_id: UUID of the Project the function belongs to.
+        :return: :class:`List[ListFunctionsResponse] <List[ListFunctionsResponse]>`
 
         Usage:
         ::
 
-            result = await api.list_containers_all(namespace_id="example")
+            result = await api.list_functions_all(namespace_id="example")
         """
 
         return await fetch_all_pages_async(
-            type=ListContainersResponse,
-            key="containers",
-            fetcher=self.list_containers,
+            type=ListFunctionsResponse,
+            key="functions",
+            fetcher=self.list_functions,
             args={
                 "namespace_id": namespace_id,
                 "region": region,
                 "page": page,
                 "page_size": page_size,
                 "order_by": order_by,
                 "name": name,
                 "organization_id": organization_id,
                 "project_id": project_id,
             },
         )
 
-    async def get_container(
+    async def get_function(
         self,
         *,
-        container_id: str,
+        function_id: str,
         region: Optional[Region] = None,
-    ) -> Container:
+    ) -> Function:
         """
-        Get the container associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param container_id:
-        :return: :class:`Container <Container>`
+        Get a function.
+        Get the function associated with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param function_id: UUID of the function.
+        :return: :class:`Function <Function>`
 
         Usage:
         ::
 
-            result = await api.get_container(container_id="example")
+            result = await api.get_function(function_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_container_id = validate_path_param("container_id", container_id)
+        param_function_id = validate_path_param("function_id", function_id)
 
         res = self._request(
             "GET",
-            f"/containers/v1beta1/regions/{param_region}/containers/{param_container_id}",
+            f"/functions/v1beta1/regions/{param_region}/functions/{param_function_id}",
         )
 
         self._throw_on_error(res)
-        return unmarshal_Container(res.json())
+        return unmarshal_Function(res.json())
 
-    async def wait_for_container(
+    async def wait_for_function(
         self,
         *,
-        container_id: str,
+        function_id: str,
         region: Optional[Region] = None,
         options: Optional[
-            WaitForOptions[Container, Union[bool, Awaitable[bool]]]
+            WaitForOptions[Function, Union[bool, Awaitable[bool]]]
         ] = None,
-    ) -> Container:
+    ) -> Function:
         """
-        Waits for :class:`Container <Container>` to be in a final state.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param container_id:
+        Waits for :class:`Function <Function>` to be in a final state.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param function_id: UUID of the function.
         :param options: The options for the waiter
-        :return: :class:`Container <Container>`
+        :return: :class:`Function <Function>`
 
         Usage:
         ::
 
-            result = api.wait_for_container(container_id="example")
+            result = api.wait_for_function(function_id="example")
         """
 
         if not options:
             options = WaitForOptions()
 
         if not options.stop:
-            options.stop = lambda res: res.status not in CONTAINER_TRANSIENT_STATUSES
+            options.stop = lambda res: res.status not in FUNCTION_TRANSIENT_STATUSES
 
         return await wait_for_resource_async(
-            fetcher=self.get_container,
+            fetcher=self.get_function,
             options=options,
             args={
-                "container_id": container_id,
+                "function_id": function_id,
                 "region": region,
             },
         )
 
-    async def create_container(
+    async def create_function(
         self,
         *,
         namespace_id: str,
-        privacy: ContainerPrivacy,
-        protocol: ContainerProtocol,
-        http_option: ContainerHttpOption,
+        runtime: FunctionRuntime,
+        privacy: FunctionPrivacy,
+        http_option: FunctionHttpOption,
         region: Optional[Region] = None,
         name: Optional[str] = None,
         environment_variables: Optional[Dict[str, str]] = None,
         min_scale: Optional[int] = None,
         max_scale: Optional[int] = None,
         memory_limit: Optional[int] = None,
         timeout: Optional[str] = None,
+        handler: Optional[str] = None,
         description: Optional[str] = None,
-        registry_image: Optional[str] = None,
-        max_concurrency: Optional[int] = None,
-        port: Optional[int] = None,
         secret_environment_variables: Optional[List[Secret]] = None,
-    ) -> Container:
+    ) -> Function:
         """
-        Create a new container
-        :param region: Region to target. If none is passed will use default region from the config
-        :param namespace_id:
-        :param name:
-        :param environment_variables:
-        :param min_scale:
-        :param max_scale:
-        :param memory_limit:
-        :param timeout:
-        :param privacy:
-        :param description:
-        :param registry_image:
-        :param max_concurrency:
-        :param protocol:
-        :param port:
+        Create a new function.
+        Create a new function in the specified region for a specified Organization or Project.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param name: Name of the function to create.
+        :param namespace_id: UUID of the namespace the function will be created in.
+        :param environment_variables: Environment variables of the function.
+        :param min_scale: Minumum number of instances to scale the function to.
+        :param max_scale: Maximum number of instances to scale the function to.
+        :param runtime: Runtime to use with the function.
+        :param memory_limit: Memory limit of the function in MB.
+        :param timeout: Request processing time limit for the function.
+        :param handler: Handler to use with the function.
+        :param privacy: Privacy setting of the function.
+        :param description: Description of the function.
         :param secret_environment_variables:
-        :param http_option: possible values:
+        :param http_option: Configure how HTTP and HTTPS requests are handled.
+        Possible values:
          - redirected: Responds to HTTP request with a 301 redirect to ask the clients to use HTTPS.
          - enabled: Serve both HTTP and HTTPS traffic.
-
-        :return: :class:`Container <Container>`
+        :return: :class:`Function <Function>`
 
         Usage:
         ::
 
-            result = await api.create_container(
+            result = await api.create_function(
                 namespace_id="example",
+                runtime=unknown_runtime,
                 privacy=unknown_privacy,
-                protocol=unknown_protocol,
                 http_option=unknown_http_option,
             )
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "POST",
-            f"/containers/v1beta1/regions/{param_region}/containers",
-            body=marshal_CreateContainerRequest(
-                CreateContainerRequest(
+            f"/functions/v1beta1/regions/{param_region}/functions",
+            body=marshal_CreateFunctionRequest(
+                CreateFunctionRequest(
                     namespace_id=namespace_id,
+                    runtime=runtime,
                     privacy=privacy,
-                    protocol=protocol,
                     http_option=http_option,
                     region=region,
-                    name=name or random_name(prefix="ctnr"),
+                    name=name or random_name(prefix="fn"),
                     environment_variables=environment_variables,
                     min_scale=min_scale,
                     max_scale=max_scale,
                     memory_limit=memory_limit,
                     timeout=timeout,
+                    handler=handler,
                     description=description,
-                    registry_image=registry_image,
-                    max_concurrency=max_concurrency,
-                    port=port,
                     secret_environment_variables=secret_environment_variables,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
-        return unmarshal_Container(res.json())
+        return unmarshal_Function(res.json())
 
-    async def update_container(
+    async def update_function(
         self,
         *,
-        container_id: str,
-        privacy: ContainerPrivacy,
-        protocol: ContainerProtocol,
-        http_option: ContainerHttpOption,
+        function_id: str,
+        runtime: FunctionRuntime,
+        privacy: FunctionPrivacy,
+        http_option: FunctionHttpOption,
         region: Optional[Region] = None,
         environment_variables: Optional[Dict[str, str]] = None,
         min_scale: Optional[int] = None,
         max_scale: Optional[int] = None,
         memory_limit: Optional[int] = None,
         timeout: Optional[str] = None,
         redeploy: Optional[bool] = None,
+        handler: Optional[str] = None,
         description: Optional[str] = None,
-        registry_image: Optional[str] = None,
-        max_concurrency: Optional[int] = None,
-        port: Optional[int] = None,
         secret_environment_variables: Optional[List[Secret]] = None,
-    ) -> Container:
+    ) -> Function:
         """
-        Update the container associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param container_id:
-        :param environment_variables:
-        :param min_scale:
-        :param max_scale:
-        :param memory_limit:
-        :param timeout:
-        :param redeploy:
-        :param privacy:
-        :param description:
-        :param registry_image:
-        :param max_concurrency:
-        :param protocol:
-        :param port:
-        :param secret_environment_variables:
-        :param http_option: possible values:
+        Update an existing function.
+        Update the function associated with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param function_id: UUID of the function to update.
+        :param environment_variables: Environment variables of the function to update.
+        :param min_scale: Minumum number of instances to scale the function to.
+        :param max_scale: Maximum number of instances to scale the function to.
+        :param runtime: Runtime to use with the function.
+        :param memory_limit: Memory limit of the function in MB.
+        :param timeout: Processing time limit for the function.
+        :param redeploy: Redeploy failed function.
+        :param handler: Handler to use with the function.
+        :param privacy: Privacy setting of the function.
+        :param description: Description of the function.
+        :param secret_environment_variables: Secret environment variables of the function.
+        :param http_option: Configure how HTTP and HTTPS requests are handled.
+        Possible values:
          - redirected: Responds to HTTP request with a 301 redirect to ask the clients to use HTTPS.
          - enabled: Serve both HTTP and HTTPS traffic.
-
-        :return: :class:`Container <Container>`
+        :return: :class:`Function <Function>`
 
         Usage:
         ::
 
-            result = await api.update_container(
-                container_id="example",
+            result = await api.update_function(
+                function_id="example",
+                runtime=unknown_runtime,
                 privacy=unknown_privacy,
-                protocol=unknown_protocol,
                 http_option=unknown_http_option,
             )
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_container_id = validate_path_param("container_id", container_id)
+        param_function_id = validate_path_param("function_id", function_id)
 
         res = self._request(
             "PATCH",
-            f"/containers/v1beta1/regions/{param_region}/containers/{param_container_id}",
-            body=marshal_UpdateContainerRequest(
-                UpdateContainerRequest(
-                    container_id=container_id,
+            f"/functions/v1beta1/regions/{param_region}/functions/{param_function_id}",
+            body=marshal_UpdateFunctionRequest(
+                UpdateFunctionRequest(
+                    function_id=function_id,
+                    runtime=runtime,
                     privacy=privacy,
-                    protocol=protocol,
                     http_option=http_option,
                     region=region,
                     environment_variables=environment_variables,
                     min_scale=min_scale,
                     max_scale=max_scale,
                     memory_limit=memory_limit,
                     timeout=timeout,
                     redeploy=redeploy,
+                    handler=handler,
                     description=description,
-                    registry_image=registry_image,
-                    max_concurrency=max_concurrency,
-                    port=port,
                     secret_environment_variables=secret_environment_variables,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
-        return unmarshal_Container(res.json())
+        return unmarshal_Function(res.json())
 
-    async def delete_container(
+    async def delete_function(
         self,
         *,
-        container_id: str,
+        function_id: str,
         region: Optional[Region] = None,
-    ) -> Container:
+    ) -> Function:
         """
-        Delete the container associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param container_id:
-        :return: :class:`Container <Container>`
+        Delete a function.
+        Delete the function associated with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param function_id: UUID of the function to delete.
+        :return: :class:`Function <Function>`
 
         Usage:
         ::
 
-            result = await api.delete_container(container_id="example")
+            result = await api.delete_function(function_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_container_id = validate_path_param("container_id", container_id)
+        param_function_id = validate_path_param("function_id", function_id)
 
         res = self._request(
             "DELETE",
-            f"/containers/v1beta1/regions/{param_region}/containers/{param_container_id}",
+            f"/functions/v1beta1/regions/{param_region}/functions/{param_function_id}",
         )
 
         self._throw_on_error(res)
-        return unmarshal_Container(res.json())
+        return unmarshal_Function(res.json())
 
-    async def deploy_container(
+    async def deploy_function(
         self,
         *,
-        container_id: str,
+        function_id: str,
         region: Optional[Region] = None,
-    ) -> Container:
+    ) -> Function:
         """
-        Deploy a container associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param container_id:
-        :return: :class:`Container <Container>`
+        Deploy a function.
+        Deploy a function associated with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param function_id: UUID of the function to deploy.
+        :return: :class:`Function <Function>`
 
         Usage:
         ::
 
-            result = await api.deploy_container(container_id="example")
+            result = await api.deploy_function(function_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_container_id = validate_path_param("container_id", container_id)
+        param_function_id = validate_path_param("function_id", function_id)
 
         res = self._request(
             "POST",
-            f"/containers/v1beta1/regions/{param_region}/containers/{param_container_id}/deploy",
+            f"/functions/v1beta1/regions/{param_region}/functions/{param_function_id}/deploy",
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_Function(res.json())
+
+    async def list_function_runtimes(
+        self,
+        *,
+        region: Optional[Region] = None,
+    ) -> ListFunctionRuntimesResponse:
+        """
+        List function runtimes.
+        List available function runtimes.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :return: :class:`ListFunctionRuntimesResponse <ListFunctionRuntimesResponse>`
+
+        Usage:
+        ::
+
+            result = await api.list_function_runtimes()
+        """
+
+        param_region = validate_path_param(
+            "region", region or self.client.default_region
+        )
+
+        res = self._request(
+            "GET",
+            f"/functions/v1beta1/regions/{param_region}/runtimes",
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_ListFunctionRuntimesResponse(res.json())
+
+    async def get_function_upload_url(
+        self,
+        *,
+        function_id: str,
+        content_length: int,
+        region: Optional[Region] = None,
+    ) -> UploadURL:
+        """
+        Get an upload URL of a function.
+        Get an upload URL of a function associated with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param function_id: UUID of the function to get the upload URL for.
+        :param content_length:
+        :return: :class:`UploadURL <UploadURL>`
+
+        Usage:
+        ::
+
+            result = await api.get_function_upload_url(
+                function_id="example",
+                content_length=1,
+            )
+        """
+
+        param_region = validate_path_param(
+            "region", region or self.client.default_region
+        )
+        param_function_id = validate_path_param("function_id", function_id)
+
+        res = self._request(
+            "GET",
+            f"/functions/v1beta1/regions/{param_region}/functions/{param_function_id}/upload-url",
+            params={
+                "content_length": content_length,
+            },
         )
 
         self._throw_on_error(res)
-        return unmarshal_Container(res.json())
+        return unmarshal_UploadURL(res.json())
+
+    async def get_function_download_url(
+        self,
+        *,
+        function_id: str,
+        region: Optional[Region] = None,
+    ) -> DownloadURL:
+        """
+        Get a download URL of a function.
+        Get a download URL for a function associated with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param function_id: UUID of the function to get the the download URL for.
+        :return: :class:`DownloadURL <DownloadURL>`
+
+        Usage:
+        ::
+
+            result = await api.get_function_download_url(function_id="example")
+        """
+
+        param_region = validate_path_param(
+            "region", region or self.client.default_region
+        )
+        param_function_id = validate_path_param("function_id", function_id)
+
+        res = self._request(
+            "GET",
+            f"/functions/v1beta1/regions/{param_region}/functions/{param_function_id}/download-url",
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_DownloadURL(res.json())
 
     async def list_crons(
         self,
         *,
-        container_id: str,
+        function_id: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListCronsRequestOrderBy = ListCronsRequestOrderBy.CREATED_AT_ASC,
     ) -> ListCronsResponse:
         """
-        List all your crons
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page:
-        :param page_size:
-        :param order_by:
-        :param container_id:
+        List all crons.
+        List all the cronjobs in a specified region.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number.
+        :param page_size: Number of crons per page.
+        :param order_by: Order of the crons.
+        :param function_id: UUID of the function.
         :return: :class:`ListCronsResponse <ListCronsResponse>`
 
         Usage:
         ::
 
-            result = await api.list_crons(container_id="example")
+            result = await api.list_crons(function_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "GET",
-            f"/containers/v1beta1/regions/{param_region}/crons",
+            f"/functions/v1beta1/regions/{param_region}/crons",
             params={
-                "container_id": container_id,
+                "function_id": function_id,
                 "order_by": order_by,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
             },
         )
 
         self._throw_on_error(res)
         return unmarshal_ListCronsResponse(res.json())
 
     async def list_crons_all(
         self,
         *,
-        container_id: str,
+        function_id: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListCronsRequestOrderBy] = None,
     ) -> List[Cron]:
         """
-        List all your crons
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page:
-        :param page_size:
-        :param order_by:
-        :param container_id:
+        List all crons.
+        List all the cronjobs in a specified region.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number.
+        :param page_size: Number of crons per page.
+        :param order_by: Order of the crons.
+        :param function_id: UUID of the function.
         :return: :class:`List[ListCronsResponse] <List[ListCronsResponse]>`
 
         Usage:
         ::
 
-            result = await api.list_crons_all(container_id="example")
+            result = await api.list_crons_all(function_id="example")
         """
 
         return await fetch_all_pages_async(
             type=ListCronsResponse,
             key="crons",
             fetcher=self.list_crons,
             args={
-                "container_id": container_id,
+                "function_id": function_id,
                 "region": region,
                 "page": page,
                 "page_size": page_size,
                 "order_by": order_by,
             },
         )
 
     async def get_cron(
         self,
         *,
         cron_id: str,
         region: Optional[Region] = None,
     ) -> Cron:
         """
-        Get the cron associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param cron_id:
+        Get a cron.
+        Get the cron associated with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cron_id: UUID of the cron to get.
         :return: :class:`Cron <Cron>`
 
         Usage:
         ::
 
             result = await api.get_cron(cron_id="example")
         """
@@ -876,31 +999,31 @@
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_cron_id = validate_path_param("cron_id", cron_id)
 
         res = self._request(
             "GET",
-            f"/containers/v1beta1/regions/{param_region}/crons/{param_cron_id}",
+            f"/functions/v1beta1/regions/{param_region}/crons/{param_cron_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_Cron(res.json())
 
     async def wait_for_cron(
         self,
         *,
         cron_id: str,
         region: Optional[Region] = None,
         options: Optional[WaitForOptions[Cron, Union[bool, Awaitable[bool]]]] = None,
     ) -> Cron:
         """
         Waits for :class:`Cron <Cron>` to be in a final state.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param cron_id:
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cron_id: UUID of the cron to get.
         :param options: The options for the waiter
         :return: :class:`Cron <Cron>`
 
         Usage:
         ::
 
             result = api.wait_for_cron(cron_id="example")
@@ -920,48 +1043,49 @@
                 "region": region,
             },
         )
 
     async def create_cron(
         self,
         *,
-        container_id: str,
+        function_id: str,
         schedule: str,
         region: Optional[Region] = None,
         args: Optional[Dict[str, Any]] = None,
         name: Optional[str] = None,
     ) -> Cron:
         """
-        Create a new cron
-        :param region: Region to target. If none is passed will use default region from the config
-        :param container_id:
-        :param schedule:
-        :param args:
-        :param name:
+        Create a new cron.
+        Create a new cronjob for a function with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param function_id: UUID of the function to use the cron with.
+        :param schedule: Schedule of the cron in UNIX cron format.
+        :param args: Arguments to use with the cron.
+        :param name: Name of the cron.
         :return: :class:`Cron <Cron>`
 
         Usage:
         ::
 
             result = await api.create_cron(
-                container_id="example",
+                function_id="example",
                 schedule="example",
             )
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "POST",
-            f"/containers/v1beta1/regions/{param_region}/crons",
+            f"/functions/v1beta1/regions/{param_region}/crons",
             body=marshal_CreateCronRequest(
                 CreateCronRequest(
-                    container_id=container_id,
+                    function_id=function_id,
                     schedule=schedule,
                     region=region,
                     args=args,
                     name=name,
                 ),
                 self.client,
             ),
@@ -971,27 +1095,28 @@
         return unmarshal_Cron(res.json())
 
     async def update_cron(
         self,
         *,
         cron_id: str,
         region: Optional[Region] = None,
-        container_id: Optional[str] = None,
+        function_id: Optional[str] = None,
         schedule: Optional[str] = None,
         args: Optional[Dict[str, Any]] = None,
         name: Optional[str] = None,
     ) -> Cron:
         """
-        Update the cron associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param cron_id:
-        :param container_id:
-        :param schedule:
-        :param args:
-        :param name:
+        Update an existing cron.
+        Update the cron associated with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cron_id: UUID of the cron to update.
+        :param function_id: UUID of the function to use the cron with.
+        :param schedule: Schedule of the cron in UNIX cron format.
+        :param args: Arguments to use with the cron.
+        :param name: Name of the cron.
         :return: :class:`Cron <Cron>`
 
         Usage:
         ::
 
             result = await api.update_cron(cron_id="example")
         """
@@ -999,20 +1124,20 @@
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_cron_id = validate_path_param("cron_id", cron_id)
 
         res = self._request(
             "PATCH",
-            f"/containers/v1beta1/regions/{param_region}/crons/{param_cron_id}",
+            f"/functions/v1beta1/regions/{param_region}/crons/{param_cron_id}",
             body=marshal_UpdateCronRequest(
                 UpdateCronRequest(
                     cron_id=cron_id,
                     region=region,
-                    container_id=container_id,
+                    function_id=function_id,
                     schedule=schedule,
                     args=args,
                     name=name,
                 ),
                 self.client,
             ),
         )
@@ -1023,17 +1148,18 @@
     async def delete_cron(
         self,
         *,
         cron_id: str,
         region: Optional[Region] = None,
     ) -> Cron:
         """
-        Delete the cron associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param cron_id:
+        Delete an existing cron.
+        Delete the cron associated with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cron_id: UUID of the cron to delete.
         :return: :class:`Cron <Cron>`
 
         Usage:
         ::
 
             result = await api.delete_cron(cron_id="example")
         """
@@ -1041,188 +1167,193 @@
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_cron_id = validate_path_param("cron_id", cron_id)
 
         res = self._request(
             "DELETE",
-            f"/containers/v1beta1/regions/{param_region}/crons/{param_cron_id}",
+            f"/functions/v1beta1/regions/{param_region}/crons/{param_cron_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_Cron(res.json())
 
     async def list_logs(
         self,
         *,
-        container_id: str,
+        function_id: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListLogsRequestOrderBy = ListLogsRequestOrderBy.TIMESTAMP_DESC,
     ) -> ListLogsResponse:
         """
-        List your container logs
-        :param region: Region to target. If none is passed will use default region from the config
-        :param container_id:
-        :param page:
-        :param page_size:
-        :param order_by:
+        List application logs.
+        List the application logs of the function with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param function_id: UUID of the function to get the logs for.
+        :param page: Page number.
+        :param page_size: Number of logs per page.
+        :param order_by: Order of the logs.
         :return: :class:`ListLogsResponse <ListLogsResponse>`
 
         Usage:
         ::
 
-            result = await api.list_logs(container_id="example")
+            result = await api.list_logs(function_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_container_id = validate_path_param("container_id", container_id)
+        param_function_id = validate_path_param("function_id", function_id)
 
         res = self._request(
             "GET",
-            f"/containers/v1beta1/regions/{param_region}/containers/{param_container_id}/logs",
+            f"/functions/v1beta1/regions/{param_region}/functions/{param_function_id}/logs",
             params={
                 "order_by": order_by,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
             },
         )
 
         self._throw_on_error(res)
         return unmarshal_ListLogsResponse(res.json())
 
     async def list_logs_all(
         self,
         *,
-        container_id: str,
+        function_id: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListLogsRequestOrderBy] = None,
     ) -> List[Log]:
         """
-        List your container logs
-        :param region: Region to target. If none is passed will use default region from the config
-        :param container_id:
-        :param page:
-        :param page_size:
-        :param order_by:
+        List application logs.
+        List the application logs of the function with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param function_id: UUID of the function to get the logs for.
+        :param page: Page number.
+        :param page_size: Number of logs per page.
+        :param order_by: Order of the logs.
         :return: :class:`List[ListLogsResponse] <List[ListLogsResponse]>`
 
         Usage:
         ::
 
-            result = await api.list_logs_all(container_id="example")
+            result = await api.list_logs_all(function_id="example")
         """
 
         return await fetch_all_pages_async(
             type=ListLogsResponse,
             key="logs",
             fetcher=self.list_logs,
             args={
-                "container_id": container_id,
+                "function_id": function_id,
                 "region": region,
                 "page": page,
                 "page_size": page_size,
                 "order_by": order_by,
             },
         )
 
     async def list_domains(
         self,
         *,
-        container_id: str,
+        function_id: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListDomainsRequestOrderBy = ListDomainsRequestOrderBy.CREATED_AT_ASC,
     ) -> ListDomainsResponse:
         """
-        List all domain name bindings
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page:
-        :param page_size:
-        :param order_by:
-        :param container_id:
+        List all domain name bindings.
+        List all domain name bindings in a specified region.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number.
+        :param page_size: Number of domains per page.
+        :param order_by: Order of the domains.
+        :param function_id: UUID of the function the domain is assoicated with.
         :return: :class:`ListDomainsResponse <ListDomainsResponse>`
 
         Usage:
         ::
 
-            result = await api.list_domains(container_id="example")
+            result = await api.list_domains(function_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "GET",
-            f"/containers/v1beta1/regions/{param_region}/domains",
+            f"/functions/v1beta1/regions/{param_region}/domains",
             params={
-                "container_id": container_id,
+                "function_id": function_id,
                 "order_by": order_by,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
             },
         )
 
         self._throw_on_error(res)
         return unmarshal_ListDomainsResponse(res.json())
 
     async def list_domains_all(
         self,
         *,
-        container_id: str,
+        function_id: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListDomainsRequestOrderBy] = None,
     ) -> List[Domain]:
         """
-        List all domain name bindings
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page:
-        :param page_size:
-        :param order_by:
-        :param container_id:
+        List all domain name bindings.
+        List all domain name bindings in a specified region.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number.
+        :param page_size: Number of domains per page.
+        :param order_by: Order of the domains.
+        :param function_id: UUID of the function the domain is assoicated with.
         :return: :class:`List[ListDomainsResponse] <List[ListDomainsResponse]>`
 
         Usage:
         ::
 
-            result = await api.list_domains_all(container_id="example")
+            result = await api.list_domains_all(function_id="example")
         """
 
         return await fetch_all_pages_async(
             type=ListDomainsResponse,
             key="domains",
             fetcher=self.list_domains,
             args={
-                "container_id": container_id,
+                "function_id": function_id,
                 "region": region,
                 "page": page,
                 "page_size": page_size,
                 "order_by": order_by,
             },
         )
 
     async def get_domain(
         self,
         *,
         domain_id: str,
         region: Optional[Region] = None,
     ) -> Domain:
         """
-        Get a domain name binding
-        :param region: Region to target. If none is passed will use default region from the config
-        :param domain_id:
+        Get a domain name binding.
+        Get a domain name binding for the function with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param domain_id: UUID of the domain to get.
         :return: :class:`Domain <Domain>`
 
         Usage:
         ::
 
             result = await api.get_domain(domain_id="example")
         """
@@ -1230,31 +1361,31 @@
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_domain_id = validate_path_param("domain_id", domain_id)
 
         res = self._request(
             "GET",
-            f"/containers/v1beta1/regions/{param_region}/domains/{param_domain_id}",
+            f"/functions/v1beta1/regions/{param_region}/domains/{param_domain_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_Domain(res.json())
 
     async def wait_for_domain(
         self,
         *,
         domain_id: str,
         region: Optional[Region] = None,
         options: Optional[WaitForOptions[Domain, Union[bool, Awaitable[bool]]]] = None,
     ) -> Domain:
         """
         Waits for :class:`Domain <Domain>` to be in a final state.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param domain_id:
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param domain_id: UUID of the domain to get.
         :param options: The options for the waiter
         :return: :class:`Domain <Domain>`
 
         Usage:
         ::
 
             result = api.wait_for_domain(domain_id="example")
@@ -1275,44 +1406,45 @@
             },
         )
 
     async def create_domain(
         self,
         *,
         hostname: str,
-        container_id: str,
+        function_id: str,
         region: Optional[Region] = None,
     ) -> Domain:
         """
-        Create a domain name binding
-        :param region: Region to target. If none is passed will use default region from the config
-        :param hostname:
-        :param container_id:
+        Create a domain name binding.
+        Create a domain name binding for the function with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param hostname: Hostame to create.
+        :param function_id: UUID of the function to associate the domain with.
         :return: :class:`Domain <Domain>`
 
         Usage:
         ::
 
             result = await api.create_domain(
                 hostname="example",
-                container_id="example",
+                function_id="example",
             )
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "POST",
-            f"/containers/v1beta1/regions/{param_region}/domains",
+            f"/functions/v1beta1/regions/{param_region}/domains",
             body=marshal_CreateDomainRequest(
                 CreateDomainRequest(
                     hostname=hostname,
-                    container_id=container_id,
+                    function_id=function_id,
                     region=region,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
@@ -1321,17 +1453,18 @@
     async def delete_domain(
         self,
         *,
         domain_id: str,
         region: Optional[Region] = None,
     ) -> Domain:
         """
-        Delete a domain name binding
-        :param region: Region to target. If none is passed will use default region from the config
-        :param domain_id:
+        Delete a domain name binding.
+        Delete a domain name binding for the function with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param domain_id: UUID of the domain to delete.
         :return: :class:`Domain <Domain>`
 
         Usage:
         ::
 
             result = await api.delete_domain(domain_id="example")
         """
@@ -1339,25 +1472,25 @@
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_domain_id = validate_path_param("domain_id", domain_id)
 
         res = self._request(
             "DELETE",
-            f"/containers/v1beta1/regions/{param_region}/domains/{param_domain_id}",
+            f"/functions/v1beta1/regions/{param_region}/domains/{param_domain_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_Domain(res.json())
 
     async def issue_jwt(
         self,
         *,
         region: Optional[Region] = None,
-        container_id: Optional[str] = None,
+        function_id: Optional[str] = None,
         namespace_id: Optional[str] = None,
         expires_at: Optional[datetime] = None,
     ) -> Token:
         """
         :deprecated
 
         Usage:
@@ -1368,64 +1501,68 @@
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "GET",
-            f"/containers/v1beta1/regions/{param_region}/issue-jwt",
+            f"/functions/v1beta1/regions/{param_region}/issue-jwt",
             params={
                 "expires_at": expires_at,
                 **resolve_one_of(
                     [
-                        OneOfPossibility("container_id", container_id),
+                        OneOfPossibility("function_id", function_id),
                         OneOfPossibility("namespace_id", namespace_id),
                     ]
                 ),
             },
         )
 
         self._throw_on_error(res)
         return unmarshal_Token(res.json())
 
     async def create_token(
         self,
         *,
         region: Optional[Region] = None,
-        container_id: Optional[str] = None,
+        function_id: Optional[str] = None,
         namespace_id: Optional[str] = None,
         description: Optional[str] = None,
         expires_at: Optional[datetime] = None,
     ) -> Token:
         """
-        Create a new revocable token
-        :param region: Region to target. If none is passed will use default region from the config
-        :param container_id: One-of ('scope'): at most one of 'container_id', 'namespace_id' could be set.
-        :param namespace_id: One-of ('scope'): at most one of 'container_id', 'namespace_id' could be set.
-        :param description:
-        :param expires_at:
+        Create a new revocable token.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param function_id: UUID of the function to associate the token with.
+
+        One-of ('scope'): at most one of 'function_id', 'namespace_id' could be set.
+        :param namespace_id: UUID of the namespace to associate the token with.
+
+        One-of ('scope'): at most one of 'function_id', 'namespace_id' could be set.
+        :param description: Description of the token.
+        :param expires_at: Date on which the token expires.
         :return: :class:`Token <Token>`
 
         Usage:
         ::
 
             result = await api.create_token()
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "POST",
-            f"/containers/v1beta1/regions/{param_region}/tokens",
+            f"/functions/v1beta1/regions/{param_region}/tokens",
             body=marshal_CreateTokenRequest(
                 CreateTokenRequest(
                     region=region,
-                    container_id=container_id,
+                    function_id=function_id,
                     namespace_id=namespace_id,
                     description=description,
                     expires_at=expires_at,
                 ),
                 self.client,
             ),
         )
@@ -1436,17 +1573,17 @@
     async def get_token(
         self,
         *,
         token_id: str,
         region: Optional[Region] = None,
     ) -> Token:
         """
-        Get a token
-        :param region: Region to target. If none is passed will use default region from the config
-        :param token_id:
+        Get a token.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param token_id: UUID of the token to get.
         :return: :class:`Token <Token>`
 
         Usage:
         ::
 
             result = await api.get_token(token_id="example")
         """
@@ -1454,31 +1591,31 @@
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_token_id = validate_path_param("token_id", token_id)
 
         res = self._request(
             "GET",
-            f"/containers/v1beta1/regions/{param_region}/tokens/{param_token_id}",
+            f"/functions/v1beta1/regions/{param_region}/tokens/{param_token_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_Token(res.json())
 
     async def wait_for_token(
         self,
         *,
         token_id: str,
         region: Optional[Region] = None,
         options: Optional[WaitForOptions[Token, Union[bool, Awaitable[bool]]]] = None,
     ) -> Token:
         """
         Waits for :class:`Token <Token>` to be in a final state.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param token_id:
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param token_id: UUID of the token to get.
         :param options: The options for the waiter
         :return: :class:`Token <Token>`
 
         Usage:
         ::
 
             result = api.wait_for_token(token_id="example")
@@ -1502,42 +1639,42 @@
     async def list_tokens(
         self,
         *,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListTokensRequestOrderBy = ListTokensRequestOrderBy.CREATED_AT_ASC,
-        container_id: Optional[str] = None,
+        function_id: Optional[str] = None,
         namespace_id: Optional[str] = None,
     ) -> ListTokensResponse:
         """
-        List all tokens
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page:
-        :param page_size:
-        :param order_by:
-        :param container_id:
-        :param namespace_id:
+        List all tokens.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number.
+        :param page_size: Number of tokens per page.
+        :param order_by: Sort order for the tokens.
+        :param function_id: UUID of the function the token is assoicated with.
+        :param namespace_id: UUID of the namespace the token is associated with.
         :return: :class:`ListTokensResponse <ListTokensResponse>`
 
         Usage:
         ::
 
             result = await api.list_tokens()
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "GET",
-            f"/containers/v1beta1/regions/{param_region}/tokens",
+            f"/functions/v1beta1/regions/{param_region}/tokens",
             params={
-                "container_id": container_id,
+                "function_id": function_id,
                 "namespace_id": namespace_id,
                 "order_by": order_by,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
             },
         )
 
@@ -1547,25 +1684,25 @@
     async def list_tokens_all(
         self,
         *,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListTokensRequestOrderBy] = None,
-        container_id: Optional[str] = None,
+        function_id: Optional[str] = None,
         namespace_id: Optional[str] = None,
     ) -> List[Token]:
         """
-        List all tokens
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page:
-        :param page_size:
-        :param order_by:
-        :param container_id:
-        :param namespace_id:
+        List all tokens.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number.
+        :param page_size: Number of tokens per page.
+        :param order_by: Sort order for the tokens.
+        :param function_id: UUID of the function the token is assoicated with.
+        :param namespace_id: UUID of the namespace the token is associated with.
         :return: :class:`List[ListTokensResponse] <List[ListTokensResponse]>`
 
         Usage:
         ::
 
             result = await api.list_tokens_all()
         """
@@ -1575,29 +1712,29 @@
             key="tokens",
             fetcher=self.list_tokens,
             args={
                 "region": region,
                 "page": page,
                 "page_size": page_size,
                 "order_by": order_by,
-                "container_id": container_id,
+                "function_id": function_id,
                 "namespace_id": namespace_id,
             },
         )
 
     async def delete_token(
         self,
         *,
         token_id: str,
         region: Optional[Region] = None,
     ) -> Token:
         """
-        Delete a token
-        :param region: Region to target. If none is passed will use default region from the config
-        :param token_id:
+        Delete a token.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param token_id: UUID of the token to delete.
         :return: :class:`Token <Token>`
 
         Usage:
         ::
 
             result = await api.delete_token(token_id="example")
         """
@@ -1605,12 +1742,267 @@
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_token_id = validate_path_param("token_id", token_id)
 
         res = self._request(
             "DELETE",
-            f"/containers/v1beta1/regions/{param_region}/tokens/{param_token_id}",
+            f"/functions/v1beta1/regions/{param_region}/tokens/{param_token_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_Token(res.json())
+
+    async def create_trigger(
+        self,
+        *,
+        name: str,
+        function_id: str,
+        region: Optional[Region] = None,
+        description: Optional[str] = None,
+        scw_sqs_config: Optional[CreateTriggerRequestMnqSqsClientConfig] = None,
+        sqs_config: Optional[CreateTriggerRequestSqsClientConfig] = None,
+        scw_nats_config: Optional[CreateTriggerRequestMnqNatsClientConfig] = None,
+    ) -> Trigger:
+        """
+
+        Usage:
+        ::
+
+            result = await api.create_trigger(
+                name="example",
+                function_id="example",
+            )
+        """
+
+        param_region = validate_path_param(
+            "region", region or self.client.default_region
+        )
+
+        res = self._request(
+            "POST",
+            f"/functions/v1beta1/regions/{param_region}/triggers",
+            body=marshal_CreateTriggerRequest(
+                CreateTriggerRequest(
+                    name=name,
+                    function_id=function_id,
+                    region=region,
+                    description=description,
+                    scw_sqs_config=scw_sqs_config,
+                    sqs_config=sqs_config,
+                    scw_nats_config=scw_nats_config,
+                ),
+                self.client,
+            ),
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_Trigger(res.json())
+
+    async def get_trigger(
+        self,
+        *,
+        trigger_id: str,
+        region: Optional[Region] = None,
+    ) -> Trigger:
+        """
+
+        Usage:
+        ::
+
+            result = await api.get_trigger(trigger_id="example")
+        """
+
+        param_region = validate_path_param(
+            "region", region or self.client.default_region
+        )
+        param_trigger_id = validate_path_param("trigger_id", trigger_id)
+
+        res = self._request(
+            "GET",
+            f"/functions/v1beta1/regions/{param_region}/triggers/{param_trigger_id}",
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_Trigger(res.json())
+
+    async def wait_for_trigger(
+        self,
+        *,
+        trigger_id: str,
+        region: Optional[Region] = None,
+        options: Optional[WaitForOptions[Trigger, Union[bool, Awaitable[bool]]]] = None,
+    ) -> Trigger:
+        """
+        Waits for :class:`Trigger <Trigger>` to be in a final state.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param trigger_id:
+        :param options: The options for the waiter
+        :return: :class:`Trigger <Trigger>`
+
+        Usage:
+        ::
+
+            result = api.wait_for_trigger(trigger_id="example")
+        """
+
+        if not options:
+            options = WaitForOptions()
+
+        if not options.stop:
+            options.stop = lambda res: res.status not in TRIGGER_TRANSIENT_STATUSES
+
+        return await wait_for_resource_async(
+            fetcher=self.get_trigger,
+            options=options,
+            args={
+                "trigger_id": trigger_id,
+                "region": region,
+            },
+        )
+
+    async def list_triggers(
+        self,
+        *,
+        region: Optional[Region] = None,
+        page: Optional[int] = None,
+        page_size: Optional[int] = None,
+        order_by: ListTriggersRequestOrderBy = ListTriggersRequestOrderBy.CREATED_AT_ASC,
+        function_id: Optional[str] = None,
+        namespace_id: Optional[str] = None,
+        project_id: Optional[str] = None,
+    ) -> ListTriggersResponse:
+        """
+
+        Usage:
+        ::
+
+            result = await api.list_triggers()
+        """
+
+        param_region = validate_path_param(
+            "region", region or self.client.default_region
+        )
+
+        res = self._request(
+            "GET",
+            f"/functions/v1beta1/regions/{param_region}/triggers",
+            params={
+                "order_by": order_by,
+                "page": page,
+                "page_size": page_size or self.client.default_page_size,
+                **resolve_one_of(
+                    [
+                        OneOfPossibility(
+                            "project_id", project_id, self.client.default_project_id
+                        ),
+                        OneOfPossibility("function_id", function_id),
+                        OneOfPossibility("namespace_id", namespace_id),
+                    ]
+                ),
+            },
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_ListTriggersResponse(res.json())
+
+    async def list_triggers_all(
+        self,
+        *,
+        region: Optional[Region] = None,
+        page: Optional[int] = None,
+        page_size: Optional[int] = None,
+        order_by: Optional[ListTriggersRequestOrderBy] = None,
+        function_id: Optional[str] = None,
+        namespace_id: Optional[str] = None,
+        project_id: Optional[str] = None,
+    ) -> List[Trigger]:
+        """
+        :return: :class:`List[ListTriggersResponse] <List[ListTriggersResponse]>`
+
+        Usage:
+        ::
+
+            result = await api.list_triggers_all()
+        """
+
+        return await fetch_all_pages_async(
+            type=ListTriggersResponse,
+            key="triggers",
+            fetcher=self.list_triggers,
+            args={
+                "region": region,
+                "page": page,
+                "page_size": page_size,
+                "order_by": order_by,
+                "function_id": function_id,
+                "namespace_id": namespace_id,
+                "project_id": project_id,
+            },
+        )
+
+    async def update_trigger(
+        self,
+        *,
+        trigger_id: str,
+        region: Optional[Region] = None,
+        name: Optional[str] = None,
+        description: Optional[str] = None,
+        sqs_config: Optional[UpdateTriggerRequestSqsClientConfig] = None,
+    ) -> Trigger:
+        """
+
+        Usage:
+        ::
+
+            result = await api.update_trigger(trigger_id="example")
+        """
+
+        param_region = validate_path_param(
+            "region", region or self.client.default_region
+        )
+        param_trigger_id = validate_path_param("trigger_id", trigger_id)
+
+        res = self._request(
+            "PATCH",
+            f"/functions/v1beta1/regions/{param_region}/triggers/{param_trigger_id}",
+            body=marshal_UpdateTriggerRequest(
+                UpdateTriggerRequest(
+                    trigger_id=trigger_id,
+                    region=region,
+                    name=name,
+                    description=description,
+                    sqs_config=sqs_config,
+                ),
+                self.client,
+            ),
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_Trigger(res.json())
+
+    async def delete_trigger(
+        self,
+        *,
+        trigger_id: str,
+        region: Optional[Region] = None,
+    ) -> Trigger:
+        """
+
+        Usage:
+        ::
+
+            result = await api.delete_trigger(trigger_id="example")
+        """
+
+        param_region = validate_path_param(
+            "region", region or self.client.default_region
+        )
+        param_trigger_id = validate_path_param("trigger_id", trigger_id)
+
+        res = self._request(
+            "DELETE",
+            f"/functions/v1beta1/regions/{param_region}/triggers/{param_trigger_id}",
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_Trigger(res.json())
```

### Comparing `scaleway_async-0.9.0/scaleway_async/container/v1beta1/content.py` & `scaleway_async-1.0.0/scaleway_async/container/v1beta1/content.py`

 * *Files 24% similar despite different names*

```diff
@@ -4,14 +4,15 @@
 
 from .types import (
     ContainerStatus,
     CronStatus,
     DomainStatus,
     NamespaceStatus,
     TokenStatus,
+    TriggerStatus,
 )
 
 
 CONTAINER_TRANSIENT_STATUSES: List[ContainerStatus] = [
     ContainerStatus.DELETING,
     ContainerStatus.CREATING,
     ContainerStatus.PENDING,
@@ -50,7 +51,16 @@
 TOKEN_TRANSIENT_STATUSES: List[TokenStatus] = [
     TokenStatus.DELETING,
     TokenStatus.CREATING,
 ]
 """
 Lists transient statutes of the enum :class:`TokenStatus <TokenStatus>`.
 """
+
+TRIGGER_TRANSIENT_STATUSES: List[TriggerStatus] = [
+    TriggerStatus.DELETING,
+    TriggerStatus.CREATING,
+    TriggerStatus.PENDING,
+]
+"""
+Lists transient statutes of the enum :class:`TriggerStatus <TriggerStatus>`.
+"""
```

### Comparing `scaleway_async-0.9.0/scaleway_async/container/v1beta1/marshalling.py` & `scaleway_async-1.0.0/scaleway_async/tem/v1alpha1/marshalling.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,549 +1,428 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 
 from typing import Any, Dict
 
 from scaleway_core.profile import ProfileDefaults
-from scaleway_core.utils import (
-    OneOfPossibility,
-    resolve_one_of,
-)
 from dateutil import parser
 from .types import (
-    ContainerHttpOption,
-    ContainerPrivacy,
-    ContainerProtocol,
-    Container,
-    Cron,
+    CreateEmailRequestAddress,
+    CreateEmailRequestAttachment,
+    CreateEmailResponse,
     Domain,
-    ListContainersResponse,
-    ListCronsResponse,
+    DomainLastStatus,
+    DomainLastStatusDkimRecord,
+    DomainLastStatusSpfRecord,
+    DomainStatistics,
+    Email,
+    EmailTry,
     ListDomainsResponse,
-    ListLogsResponse,
-    ListNamespacesResponse,
-    ListTokensResponse,
-    Log,
-    Namespace,
-    Secret,
-    SecretHashedValue,
-    Token,
-    CreateNamespaceRequest,
-    UpdateNamespaceRequest,
-    CreateContainerRequest,
-    UpdateContainerRequest,
-    CreateCronRequest,
-    UpdateCronRequest,
+    ListEmailsResponse,
+    Statistics,
+    CreateEmailRequest,
     CreateDomainRequest,
-    CreateTokenRequest,
 )
 
 
-def unmarshal_SecretHashedValue(data: Any) -> SecretHashedValue:
+def unmarshal_DomainStatistics(data: Any) -> DomainStatistics:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'SecretHashedValue' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'DomainStatistics' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("hashed_value")
-    args["hashed_value"] = field
+    field = data.get("canceled_count", None)
+    args["canceled_count"] = field
+
+    field = data.get("failed_count", None)
+    args["failed_count"] = field
 
-    field = data.get("key")
-    args["key"] = field
+    field = data.get("sent_count", None)
+    args["sent_count"] = field
+
+    field = data.get("total_count", None)
+    args["total_count"] = field
 
-    return SecretHashedValue(**args)
+    return DomainStatistics(**args)
 
 
-def unmarshal_Container(data: Any) -> Container:
+def unmarshal_EmailTry(data: Any) -> EmailTry:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Container' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'EmailTry' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("cpu_limit")
-    args["cpu_limit"] = field
-
-    field = data.get("description")
-    args["description"] = field
-
-    field = data.get("domain_name")
-    args["domain_name"] = field
-
-    field = data.get("environment_variables")
-    args["environment_variables"] = field
-
-    field = data.get("error_message")
-    args["error_message"] = field
-
-    field = data.get("http_option")
-    args["http_option"] = field
-
-    field = data.get("id")
-    args["id"] = field
-
-    field = data.get("max_concurrency")
-    args["max_concurrency"] = field
-
-    field = data.get("max_scale")
-    args["max_scale"] = field
+    field = data.get("code", None)
+    args["code"] = field
 
-    field = data.get("memory_limit")
-    args["memory_limit"] = field
+    field = data.get("message", None)
+    args["message"] = field
 
-    field = data.get("min_scale")
-    args["min_scale"] = field
+    field = data.get("rank", None)
+    args["rank"] = field
 
-    field = data.get("name")
-    args["name"] = field
+    field = data.get("tried_at", None)
+    args["tried_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("namespace_id")
-    args["namespace_id"] = field
+    return EmailTry(**args)
 
-    field = data.get("port")
-    args["port"] = field
 
-    field = data.get("privacy")
-    args["privacy"] = field
+def unmarshal_Domain(data: Any) -> Domain:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'Domain' failed as data isn't a dictionary."
+        )
 
-    field = data.get("protocol")
-    args["protocol"] = field
+    args: Dict[str, Any] = {}
 
-    field = data.get("region")
-    args["region"] = field
+    field = data.get("created_at", None)
+    args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("registry_image")
-    args["registry_image"] = field
+    field = data.get("dkim_config", None)
+    args["dkim_config"] = field
 
-    field = data.get("secret_environment_variables")
-    args["secret_environment_variables"] = [
-        unmarshal_SecretHashedValue(v) for v in data["secret_environment_variables"]
-    ]
+    field = data.get("id", None)
+    args["id"] = field
 
-    field = data.get("status")
-    args["status"] = field
+    field = data.get("last_error", None)
+    args["last_error"] = field
 
-    field = data.get("timeout")
-    args["timeout"] = field
+    field = data.get("last_valid_at", None)
+    args["last_valid_at"] = parser.isoparse(field) if type(field) is str else field
 
-    return Container(**args)
+    field = data.get("name", None)
+    args["name"] = field
 
+    field = data.get("next_check_at", None)
+    args["next_check_at"] = parser.isoparse(field) if type(field) is str else field
 
-def unmarshal_Cron(data: Any) -> Cron:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'Cron' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
+    field = data.get("organization_id", None)
+    args["organization_id"] = field
 
-    field = data.get("args")
-    args["args"] = field
+    field = data.get("project_id", None)
+    args["project_id"] = field
 
-    field = data.get("container_id")
-    args["container_id"] = field
+    field = data.get("region", None)
+    args["region"] = field
 
-    field = data.get("id")
-    args["id"] = field
+    field = data.get("revoked_at", None)
+    args["revoked_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("name")
-    args["name"] = field
+    field = data.get("spf_config", None)
+    args["spf_config"] = field
 
-    field = data.get("schedule")
-    args["schedule"] = field
+    field = data.get("statistics", None)
+    args["statistics"] = (
+        unmarshal_DomainStatistics(field) if field is not None else None
+    )
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    return Cron(**args)
+    return Domain(**args)
 
 
-def unmarshal_Domain(data: Any) -> Domain:
+def unmarshal_DomainLastStatusDkimRecord(data: Any) -> DomainLastStatusDkimRecord:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Domain' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'DomainLastStatusDkimRecord' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("container_id")
-    args["container_id"] = field
+    field = data.get("error", None)
+    args["error"] = field
 
-    field = data.get("error_message")
-    args["error_message"] = field
-
-    field = data.get("hostname")
-    args["hostname"] = field
-
-    field = data.get("id")
-    args["id"] = field
+    field = data.get("last_valid_at", None)
+    args["last_valid_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("url")
-    args["url"] = field
-
-    return Domain(**args)
+    return DomainLastStatusDkimRecord(**args)
 
 
-def unmarshal_Log(data: Any) -> Log:
+def unmarshal_DomainLastStatusSpfRecord(data: Any) -> DomainLastStatusSpfRecord:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Log' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'DomainLastStatusSpfRecord' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("id")
-    args["id"] = field
-
-    field = data.get("level")
-    args["level"] = field
-
-    field = data.get("message")
-    args["message"] = field
-
-    field = data.get("source")
-    args["source"] = field
+    field = data.get("error", None)
+    args["error"] = field
 
-    field = data.get("stream")
-    args["stream"] = field
+    field = data.get("last_valid_at", None)
+    args["last_valid_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("timestamp")
-    args["timestamp"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("status", None)
+    args["status"] = field
 
-    return Log(**args)
+    return DomainLastStatusSpfRecord(**args)
 
 
-def unmarshal_Namespace(data: Any) -> Namespace:
+def unmarshal_Email(data: Any) -> Email:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Namespace' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Email' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("description")
-    args["description"] = field
-
-    field = data.get("environment_variables")
-    args["environment_variables"] = field
+    field = data.get("created_at", None)
+    args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("error_message")
-    args["error_message"] = field
+    field = data.get("flags", None)
+    args["flags"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("name")
-    args["name"] = field
+    field = data.get("last_tries", None)
+    args["last_tries"] = (
+        [unmarshal_EmailTry(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("organization_id")
-    args["organization_id"] = field
+    field = data.get("mail_from", None)
+    args["mail_from"] = field
 
-    field = data.get("project_id")
-    args["project_id"] = field
+    field = data.get("mail_rcpt", None)
+    args["mail_rcpt"] = field
 
-    field = data.get("region")
-    args["region"] = field
+    field = data.get("message_id", None)
+    args["message_id"] = field
 
-    field = data.get("registry_endpoint")
-    args["registry_endpoint"] = field
+    field = data.get("project_id", None)
+    args["project_id"] = field
 
-    field = data.get("registry_namespace_id")
-    args["registry_namespace_id"] = field
+    field = data.get("rcpt_to", None)
+    args["rcpt_to"] = field
 
-    field = data.get("secret_environment_variables")
-    args["secret_environment_variables"] = [
-        unmarshal_SecretHashedValue(v) for v in data["secret_environment_variables"]
-    ]
+    field = data.get("rcpt_type", None)
+    args["rcpt_type"] = field
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    return Namespace(**args)
-
-
-def unmarshal_Token(data: Any) -> Token:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'Token' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
-
-    field = data.get("container_id")
-    args["container_id"] = field
+    field = data.get("status_details", None)
+    args["status_details"] = field
 
-    field = data.get("description")
-    args["description"] = field
+    field = data.get("subject", None)
+    args["subject"] = field
 
-    field = data.get("expires_at")
-    args["expires_at"] = parser.isoparse(field) if type(field) is str else field
-
-    field = data.get("id")
-    args["id"] = field
+    field = data.get("try_count", None)
+    args["try_count"] = field
 
-    field = data.get("namespace_id")
-    args["namespace_id"] = field
-
-    field = data.get("public_key")
-    args["public_key"] = field
-
-    field = data.get("status")
-    args["status"] = field
+    field = data.get("updated_at", None)
+    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("token")
-    args["token"] = field
+    return Email(**args)
 
-    return Token(**args)
 
-
-def unmarshal_ListContainersResponse(data: Any) -> ListContainersResponse:
+def unmarshal_CreateEmailResponse(data: Any) -> CreateEmailResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListContainersResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'CreateEmailResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("containers")
-    args["containers"] = [unmarshal_Container(v) for v in data["containers"]]
-
-    field = data.get("total_count")
-    args["total_count"] = field
+    field = data.get("emails", None)
+    args["emails"] = [unmarshal_Email(v) for v in field] if field is not None else None
 
-    return ListContainersResponse(**args)
+    return CreateEmailResponse(**args)
 
 
-def unmarshal_ListCronsResponse(data: Any) -> ListCronsResponse:
+def unmarshal_DomainLastStatus(data: Any) -> DomainLastStatus:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListCronsResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'DomainLastStatus' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("crons")
-    args["crons"] = [unmarshal_Cron(v) for v in data["crons"]]
+    field = data.get("dkim_record", None)
+    args["dkim_record"] = (
+        unmarshal_DomainLastStatusDkimRecord(field) if field is not None else None
+    )
 
-    field = data.get("total_count")
-    args["total_count"] = field
+    field = data.get("domain_id", None)
+    args["domain_id"] = field
+
+    field = data.get("domain_name", None)
+    args["domain_name"] = field
+
+    field = data.get("spf_record", None)
+    args["spf_record"] = (
+        unmarshal_DomainLastStatusSpfRecord(field) if field is not None else None
+    )
 
-    return ListCronsResponse(**args)
+    return DomainLastStatus(**args)
 
 
 def unmarshal_ListDomainsResponse(data: Any) -> ListDomainsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListDomainsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("domains")
-    args["domains"] = [unmarshal_Domain(v) for v in data["domains"]]
+    field = data.get("domains", None)
+    args["domains"] = (
+        [unmarshal_Domain(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListDomainsResponse(**args)
 
 
-def unmarshal_ListLogsResponse(data: Any) -> ListLogsResponse:
+def unmarshal_ListEmailsResponse(data: Any) -> ListEmailsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListLogsResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListEmailsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("logs")
-    args["logs"] = [unmarshal_Log(v) for v in data["logs"]]
+    field = data.get("emails", None)
+    args["emails"] = [unmarshal_Email(v) for v in field] if field is not None else None
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListLogsResponse(**args)
+    return ListEmailsResponse(**args)
 
 
-def unmarshal_ListNamespacesResponse(data: Any) -> ListNamespacesResponse:
+def unmarshal_Statistics(data: Any) -> Statistics:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListNamespacesResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Statistics' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("namespaces")
-    args["namespaces"] = [unmarshal_Namespace(v) for v in data["namespaces"]]
-
-    field = data.get("total_count")
-    args["total_count"] = field
-
-    return ListNamespacesResponse(**args)
+    field = data.get("canceled_count", None)
+    args["canceled_count"] = field
 
+    field = data.get("failed_count", None)
+    args["failed_count"] = field
 
-def unmarshal_ListTokensResponse(data: Any) -> ListTokensResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ListTokensResponse' failed as data isn't a dictionary."
-        )
+    field = data.get("new_count", None)
+    args["new_count"] = field
 
-    args: Dict[str, Any] = {}
+    field = data.get("sending_count", None)
+    args["sending_count"] = field
 
-    field = data.get("tokens")
-    args["tokens"] = [unmarshal_Token(v) for v in data["tokens"]]
+    field = data.get("sent_count", None)
+    args["sent_count"] = field
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListTokensResponse(**args)
+    return Statistics(**args)
 
 
-def marshal_Secret(
-    request: Secret,
+def marshal_CreateEmailRequestAddress(
+    request: CreateEmailRequestAddress,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "key": request.key,
-        "value": request.value,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.email is not None:
+        output["email"] = request.email
 
-def marshal_CreateContainerRequest(
-    request: CreateContainerRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "description": request.description,
-        "environment_variables": request.environment_variables,
-        "http_option": ContainerHttpOption(request.http_option),
-        "max_concurrency": request.max_concurrency,
-        "max_scale": request.max_scale,
-        "memory_limit": request.memory_limit,
-        "min_scale": request.min_scale,
-        "name": request.name,
-        "namespace_id": request.namespace_id,
-        "port": request.port,
-        "privacy": ContainerPrivacy(request.privacy),
-        "protocol": ContainerProtocol(request.protocol),
-        "registry_image": request.registry_image,
-        "secret_environment_variables": [
-            marshal_Secret(v, defaults) for v in request.secret_environment_variables
-        ]
-        if request.secret_environment_variables is not None
-        else None,
-        "timeout": request.timeout,
-    }
+    if request.name is not None:
+        output["name"] = request.name
 
+    return output
 
-def marshal_CreateCronRequest(
-    request: CreateCronRequest,
+
+def marshal_CreateEmailRequestAttachment(
+    request: CreateEmailRequestAttachment,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "args": request.args,
-        "container_id": request.container_id,
-        "name": request.name,
-        "schedule": request.schedule,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.content is not None:
+        output["content"] = request.content
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.type_ is not None:
+        output["type"] = request.type_
+
+    return output
 
 
 def marshal_CreateDomainRequest(
     request: CreateDomainRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "container_id": request.container_id,
-        "hostname": request.hostname,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.accept_tos is not None:
+        output["accept_tos"] = request.accept_tos
 
-def marshal_CreateNamespaceRequest(
-    request: CreateNamespaceRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "description": request.description,
-        "environment_variables": request.environment_variables,
-        "name": request.name,
-        "project_id": request.project_id or defaults.default_project_id,
-        "secret_environment_variables": [
-            marshal_Secret(v, defaults) for v in request.secret_environment_variables
-        ]
-        if request.secret_environment_variables is not None
-        else None,
-    }
+    if request.domain_name is not None:
+        output["domain_name"] = request.domain_name
 
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
 
-def marshal_CreateTokenRequest(
-    request: CreateTokenRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
-            [
-                OneOfPossibility("container_id", request.container_id),
-                OneOfPossibility("namespace_id", request.namespace_id),
-            ]
-        ),
-        "description": request.description,
-        "expires_at": request.expires_at,
-    }
+    return output
 
 
-def marshal_UpdateContainerRequest(
-    request: UpdateContainerRequest,
+def marshal_CreateEmailRequest(
+    request: CreateEmailRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "description": request.description,
-        "environment_variables": request.environment_variables,
-        "http_option": ContainerHttpOption(request.http_option),
-        "max_concurrency": request.max_concurrency,
-        "max_scale": request.max_scale,
-        "memory_limit": request.memory_limit,
-        "min_scale": request.min_scale,
-        "port": request.port,
-        "privacy": ContainerPrivacy(request.privacy),
-        "protocol": ContainerProtocol(request.protocol),
-        "redeploy": request.redeploy,
-        "registry_image": request.registry_image,
-        "secret_environment_variables": [
-            marshal_Secret(v, defaults) for v in request.secret_environment_variables
+    output: Dict[str, Any] = {}
+
+    if request.attachments is not None:
+        output["attachments"] = [
+            marshal_CreateEmailRequestAttachment(v, defaults)
+            for v in request.attachments
         ]
-        if request.secret_environment_variables is not None
-        else None,
-        "timeout": request.timeout,
-    }
 
+    if request.bcc is not None:
+        output["bcc"] = [
+            marshal_CreateEmailRequestAddress(v, defaults) for v in request.bcc
+        ]
 
-def marshal_UpdateCronRequest(
-    request: UpdateCronRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "args": request.args,
-        "container_id": request.container_id,
-        "name": request.name,
-        "schedule": request.schedule,
-    }
+    if request.cc is not None:
+        output["cc"] = [
+            marshal_CreateEmailRequestAddress(v, defaults) for v in request.cc
+        ]
 
+    if request.from_ is not None:
+        output["from"] = marshal_CreateEmailRequestAddress(request.from_, defaults)
 
-def marshal_UpdateNamespaceRequest(
-    request: UpdateNamespaceRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "description": request.description,
-        "environment_variables": request.environment_variables,
-        "secret_environment_variables": [
-            marshal_Secret(v, defaults) for v in request.secret_environment_variables
+    if request.html is not None:
+        output["html"] = request.html
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    if request.send_before is not None:
+        output["send_before"] = request.send_before
+
+    if request.subject is not None:
+        output["subject"] = request.subject
+
+    if request.text is not None:
+        output["text"] = request.text
+
+    if request.to is not None:
+        output["to"] = [
+            marshal_CreateEmailRequestAddress(v, defaults) for v in request.to
         ]
-        if request.secret_environment_variables is not None
-        else None,
-    }
+
+    return output
```

### Comparing `scaleway_async-0.9.0/scaleway_async/container/v1beta1/types.py` & `scaleway_async-1.0.0/scaleway_async/tem/v1alpha1/types.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,860 +1,768 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 from __future__ import annotations
 
 from dataclasses import dataclass
 from datetime import datetime
 from enum import Enum
-from typing import Any, Dict, List, Optional
+from typing import List, Optional
 
 from scaleway_core.bridge import (
     Region,
 )
 
 
-class ContainerHttpOption(str, Enum):
-    UNKNOWN_HTTP_OPTION = "unknown_http_option"
-    ENABLED = "enabled"
-    REDIRECTED = "redirected"
+class DomainLastStatusRecordStatus(str, Enum):
+    UNKNOWN_RECORD_STATUS = "unknown_record_status"
+    VALID = "valid"
+    INVALID = "invalid"
+    NOT_FOUND = "not_found"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ContainerPrivacy(str, Enum):
-    UNKNOWN_PRIVACY = "unknown_privacy"
-    PUBLIC = "public"
-    PRIVATE = "private"
-
-    def __str__(self) -> str:
-        return str(self.value)
-
-
-class ContainerProtocol(str, Enum):
-    UNKNOWN_PROTOCOL = "unknown_protocol"
-    HTTP1 = "http1"
-    H2C = "h2c"
-
-    def __str__(self) -> str:
-        return str(self.value)
-
-
-class ContainerStatus(str, Enum):
-    UNKNOWN = "unknown"
-    READY = "ready"
-    DELETING = "deleting"
-    ERROR = "error"
-    LOCKED = "locked"
-    CREATING = "creating"
-    PENDING = "pending"
-    CREATED = "created"
-
-    def __str__(self) -> str:
-        return str(self.value)
-
-
-class CronStatus(str, Enum):
+class DomainStatus(str, Enum):
     UNKNOWN = "unknown"
-    READY = "ready"
-    DELETING = "deleting"
-    ERROR = "error"
+    CHECKED = "checked"
+    UNCHECKED = "unchecked"
+    INVALID = "invalid"
     LOCKED = "locked"
-    CREATING = "creating"
+    REVOKED = "revoked"
     PENDING = "pending"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class DomainStatus(str, Enum):
-    UNKNOWN = "unknown"
-    READY = "ready"
-    DELETING = "deleting"
-    ERROR = "error"
-    CREATING = "creating"
-    PENDING = "pending"
+class EmailFlag(str, Enum):
+    UNKNOWN_FLAG = "unknown_flag"
+    SOFT_BOUNCE = "soft_bounce"
+    HARD_BOUNCE = "hard_bounce"
+    SPAM = "spam"
+    MAILBOX_FULL = "mailbox_full"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ListContainersRequestOrderBy(str, Enum):
-    CREATED_AT_ASC = "created_at_asc"
-    CREATED_AT_DESC = "created_at_desc"
-    NAME_ASC = "name_asc"
-    NAME_DESC = "name_desc"
+class EmailRcptType(str, Enum):
+    UNKNOWN_RCPT_TYPE = "unknown_rcpt_type"
+    TO = "to"
+    CC = "cc"
+    BCC = "bcc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ListCronsRequestOrderBy(str, Enum):
-    CREATED_AT_ASC = "created_at_asc"
-    CREATED_AT_DESC = "created_at_desc"
-
-    def __str__(self) -> str:
-        return str(self.value)
-
-
-class ListDomainsRequestOrderBy(str, Enum):
-    CREATED_AT_ASC = "created_at_asc"
-    CREATED_AT_DESC = "created_at_desc"
-    HOSTNAME_ASC = "hostname_asc"
-    HOSTNAME_DESC = "hostname_desc"
-
-    def __str__(self) -> str:
-        return str(self.value)
-
-
-class ListLogsRequestOrderBy(str, Enum):
-    TIMESTAMP_DESC = "timestamp_desc"
-    TIMESTAMP_ASC = "timestamp_asc"
+class EmailStatus(str, Enum):
+    UNKNOWN = "unknown"
+    NEW = "new"
+    SENDING = "sending"
+    SENT = "sent"
+    FAILED = "failed"
+    CANCELED = "canceled"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ListNamespacesRequestOrderBy(str, Enum):
-    CREATED_AT_ASC = "created_at_asc"
+class ListEmailsRequestOrderBy(str, Enum):
     CREATED_AT_DESC = "created_at_desc"
-    NAME_ASC = "name_asc"
-    NAME_DESC = "name_desc"
-
-    def __str__(self) -> str:
-        return str(self.value)
-
-
-class ListTokensRequestOrderBy(str, Enum):
     CREATED_AT_ASC = "created_at_asc"
-    CREATED_AT_DESC = "created_at_desc"
-
-    def __str__(self) -> str:
-        return str(self.value)
-
-
-class LogStream(str, Enum):
-    UNKNOWN = "unknown"
-    STDOUT = "stdout"
-    STDERR = "stderr"
-
-    def __str__(self) -> str:
-        return str(self.value)
-
-
-class NamespaceStatus(str, Enum):
-    UNKNOWN = "unknown"
-    READY = "ready"
-    DELETING = "deleting"
-    ERROR = "error"
-    LOCKED = "locked"
-    CREATING = "creating"
-    PENDING = "pending"
+    UPDATED_AT_DESC = "updated_at_desc"
+    UPDATED_AT_ASC = "updated_at_asc"
+    STATUS_DESC = "status_desc"
+    STATUS_ASC = "status_asc"
+    MAIL_FROM_DESC = "mail_from_desc"
+    MAIL_FROM_ASC = "mail_from_asc"
+    MAIL_RCPT_DESC = "mail_rcpt_desc"
+    MAIL_RCPT_ASC = "mail_rcpt_asc"
+    SUBJECT_DESC = "subject_desc"
+    SUBJECT_ASC = "subject_asc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class NullValue(str, Enum):
-    NULL_VALUE = "NULL_VALUE"
-
-    def __str__(self) -> str:
-        return str(self.value)
-
+@dataclass
+class CreateEmailRequestAddress:
+    """
+    Create email request. address.
+    """
 
-class TokenStatus(str, Enum):
-    UNKNOWN = "unknown"
-    READY = "ready"
-    DELETING = "deleting"
-    ERROR = "error"
-    CREATING = "creating"
+    email: str
+    """
+    Email address.
+    """
 
-    def __str__(self) -> str:
-        return str(self.value)
+    name: Optional[str]
+    """
+    (Optional) Name displayed.
+    """
 
 
 @dataclass
-class Container:
+class CreateEmailRequestAttachment:
     """
-    Container
+    Create email request. attachment.
     """
 
-    id: str
-
     name: str
+    """
+    Filename of the attachment.
+    """
 
-    namespace_id: str
-
-    status: ContainerStatus
-
-    environment_variables: Dict[str, str]
-
-    min_scale: int
-
-    max_scale: int
-
-    memory_limit: int
-
-    cpu_limit: int
-
-    timeout: Optional[str]
-
-    error_message: Optional[str]
-
-    privacy: ContainerPrivacy
-
-    description: Optional[str]
-
-    registry_image: str
-
-    max_concurrency: int
-
-    domain_name: str
-
-    protocol: ContainerProtocol
-
-    port: int
-
-    secret_environment_variables: List[SecretHashedValue]
-
-    http_option: ContainerHttpOption
+    type_: str
     """
-    possible values:
-     - redirected: Responds to HTTP request with a 301 redirect to ask the clients to use HTTPS.
-     - enabled: Serve both HTTP and HTTPS traffic.
-    
+    MIME type of the attachment.
     """
 
-    region: Region
+    content: str
+    """
+    Content of the attachment encoded in base64.
+    """
 
 
 @dataclass
-class Cron:
+class CreateEmailResponse:
     """
-    Cron
+    Create email response.
     """
 
-    id: str
-
-    container_id: str
-
-    schedule: str
-
-    args: Optional[Dict[str, Any]]
-
-    status: CronStatus
-
-    name: str
+    emails: List[Email]
+    """
+    Single page of emails matching the requested criteria.
+    """
 
 
 @dataclass
 class Domain:
     """
-    Domain
+    Domain.
     """
 
     id: str
+    """
+    ID of the domain.
+    """
 
-    hostname: str
+    organization_id: str
+    """
+    ID of the domain's Organization.
+    """
 
-    container_id: str
+    project_id: str
+    """
+    ID of the domain's Project.
+    """
 
-    url: str
+    name: str
+    """
+    Domain name (example.com).
+    """
 
     status: DomainStatus
-
-    error_message: Optional[str]
-
-
-@dataclass
-class ListContainersResponse:
     """
-    List containers response
+    Status of the domain.
     """
 
-    containers: List[Container]
-
-    total_count: int
-
-
-@dataclass
-class ListCronsResponse:
+    created_at: Optional[datetime]
     """
-    List crons response
+    Date and time of domain creation.
     """
 
-    crons: List[Cron]
-
-    total_count: int
-
+    next_check_at: Optional[datetime]
+    """
+    Date and time of the next scheduled check.
+    """
 
-@dataclass
-class ListDomainsResponse:
+    last_valid_at: Optional[datetime]
     """
-    List domains response
+    Date and time the domain was last valid.
     """
 
-    domains: List[Domain]
+    revoked_at: Optional[datetime]
+    """
+    Date and time of the domain's deletion.
+    """
 
-    total_count: int
+    last_error: Optional[str]
+    """
+    Error message returned if the last check failed.
+    :deprecated
+    """
 
+    spf_config: str
+    """
+    Snippet of the SPF record to register in the DNS zone.
+    """
 
-@dataclass
-class ListLogsResponse:
+    dkim_config: str
     """
-    List logs response
+    DKIM public key to record in the DNS zone.
     """
 
-    logs: List[Log]
+    statistics: Optional[DomainStatistics]
+    """
+    Domain's statistics.
+    """
 
-    total_count: int
+    region: Region
 
 
 @dataclass
-class ListNamespacesResponse:
+class DomainLastStatus:
     """
-    List namespaces response
+    Domain last status.
     """
 
-    namespaces: List[Namespace]
-
-    total_count: int
+    domain_id: str
+    """
+    The id of the domain.
+    """
 
+    domain_name: str
+    """
+    The domain name (example.com).
+    """
 
-@dataclass
-class ListTokensResponse:
-    tokens: List[Token]
+    spf_record: Optional[DomainLastStatusSpfRecord]
+    """
+    The SPF record verification data.
+    """
 
-    total_count: int
+    dkim_record: Optional[DomainLastStatusDkimRecord]
+    """
+    The DKIM record verification data.
+    """
 
 
 @dataclass
-class Log:
+class DomainLastStatusDkimRecord:
     """
-    Log
+    Domain last status. dkim record.
     """
 
-    message: str
-
-    timestamp: Optional[datetime]
-
-    id: str
-
-    level: str
+    status: DomainLastStatusRecordStatus
     """
-    Contains the severity of the log (info, debug, error, ...)
+    Status of the DKIM record's configurartion.
     """
 
-    source: str
+    last_valid_at: Optional[datetime]
     """
-    Source of the log (core runtime or user code)
+    Time and date the DKIM record was last valid.
     """
 
-    stream: LogStream
+    error: Optional[str]
     """
-    Can be stdout or stderr
+    An error text displays in case the record is not valid.
     """
 
 
 @dataclass
-class Namespace:
+class DomainLastStatusSpfRecord:
     """
-    Namespace
+    Domain last status. spf record.
     """
 
-    id: str
-
-    name: str
-
-    environment_variables: Dict[str, str]
-
-    organization_id: str
-
-    project_id: str
-
-    status: NamespaceStatus
-
-    registry_namespace_id: str
-
-    error_message: Optional[str]
-
-    registry_endpoint: str
-
-    description: Optional[str]
+    status: DomainLastStatusRecordStatus
+    """
+    Status of the SPF record's configurartion.
+    """
 
-    secret_environment_variables: List[SecretHashedValue]
+    last_valid_at: Optional[datetime]
+    """
+    Time and date the SPF record was last valid.
+    """
 
-    region: Region
+    error: Optional[str]
+    """
+    An error text displays in case the record is not valid.
+    """
 
 
 @dataclass
-class Secret:
-    key: str
-
-    value: Optional[str]
+class DomainStatistics:
+    total_count: int
 
+    sent_count: int
 
-@dataclass
-class SecretHashedValue:
-    key: str
+    failed_count: int
 
-    hashed_value: str
+    canceled_count: int
 
 
 @dataclass
-class Token:
+class Email:
     """
-    Token
+    Email.
     """
 
     id: str
+    """
+    Technical ID of the email.
+    """
 
-    token: str
+    message_id: str
+    """
+    Message ID of the email.
+    """
 
-    container_id: Optional[str]
+    project_id: str
     """
-    One-of ('scope'): at most one of 'container_id', 'namespace_id' could be set.
+    ID of the Project to which the email belongs.
     """
 
-    namespace_id: Optional[str]
+    mail_from: str
     """
-    One-of ('scope'): at most one of 'container_id', 'namespace_id' could be set.
+    Email address of the sender.
     """
 
-    public_key: Optional[str]
+    rcpt_to: Optional[str]
     """
+    Email address of the recipient.
     :deprecated
     """
 
-    status: TokenStatus
-
-    description: Optional[str]
-
-    expires_at: Optional[datetime]
-
-
-@dataclass
-class ListNamespacesRequest:
-    region: Optional[Region]
+    mail_rcpt: str
     """
-    Region to target. If none is passed will use default region from the config
+    Email address of the recipient.
     """
 
-    page: Optional[int]
+    rcpt_type: EmailRcptType
+    """
+    Type of recipient.
+    """
 
-    page_size: Optional[int]
+    subject: str
+    """
+    Subject of the email.
+    """
 
-    order_by: Optional[ListNamespacesRequestOrderBy]
+    created_at: Optional[datetime]
+    """
+    Creation date of the email object.
+    """
 
-    name: Optional[str]
+    updated_at: Optional[datetime]
+    """
+    Last update of the email object.
+    """
 
-    organization_id: Optional[str]
+    status: EmailStatus
+    """
+    Status of the email.
+    """
 
-    project_id: Optional[str]
+    status_details: Optional[str]
+    """
+    Additional status information.
+    """
 
+    try_count: int
+    """
+    Number of attempts to send the email.
+    """
 
-@dataclass
-class GetNamespaceRequest:
-    region: Optional[Region]
+    last_tries: List[EmailTry]
     """
-    Region to target. If none is passed will use default region from the config
+    Information about the last three attempts to send the email.
     """
 
-    namespace_id: str
+    flags: List[EmailFlag]
+    """
+    Flags categorize emails. They allow you to obtain more information about recurring errors, for example.
+    """
 
 
 @dataclass
-class CreateNamespaceRequest:
-    region: Optional[Region]
+class EmailTry:
     """
-    Region to target. If none is passed will use default region from the config
+    Email. try.
     """
 
-    name: Optional[str]
-
-    environment_variables: Optional[Dict[str, str]]
+    rank: int
+    """
+    Rank number of this attempt to send the email.
+    """
 
-    project_id: Optional[str]
+    tried_at: Optional[datetime]
+    """
+    Date of the attempt to send the email.
+    """
 
-    description: Optional[str]
+    code: int
+    """
+    The SMTP status code received after the attempt. 0 if the attempt did not reach an SMTP server.
+    """
 
-    secret_environment_variables: Optional[List[Secret]]
+    message: str
+    """
+    The SMTP message received. If the attempt did not reach an SMTP server, the message returned explains what happened.
+    """
 
 
 @dataclass
-class UpdateNamespaceRequest:
-    region: Optional[Region]
+class ListDomainsResponse:
     """
-    Region to target. If none is passed will use default region from the config
+    List domains response.
     """
 
-    namespace_id: str
-
-    environment_variables: Optional[Dict[str, str]]
-
-    description: Optional[str]
-
-    secret_environment_variables: Optional[List[Secret]]
-
-
-@dataclass
-class DeleteNamespaceRequest:
-    region: Optional[Region]
+    total_count: int
     """
-    Region to target. If none is passed will use default region from the config
+    Number of domains that match the request (without pagination).
     """
 
-    namespace_id: str
+    domains: List[Domain]
 
 
 @dataclass
-class ListContainersRequest:
-    region: Optional[Region]
+class ListEmailsResponse:
     """
-    Region to target. If none is passed will use default region from the config
+    List emails response.
     """
 
-    page: Optional[int]
-
-    page_size: Optional[int]
-
-    order_by: Optional[ListContainersRequestOrderBy]
-
-    namespace_id: str
-
-    name: Optional[str]
-
-    organization_id: Optional[str]
-
-    project_id: Optional[str]
-
-
-@dataclass
-class GetContainerRequest:
-    region: Optional[Region]
+    total_count: int
     """
-    Region to target. If none is passed will use default region from the config
+    Number of emails matching the requested criteria.
     """
 
-    container_id: str
+    emails: List[Email]
+    """
+    Single page of emails matching the requested criteria.
+    """
 
 
 @dataclass
-class CreateContainerRequest:
-    region: Optional[Region]
+class Statistics:
     """
-    Region to target. If none is passed will use default region from the config
+    Statistics.
     """
 
-    namespace_id: str
-
-    name: Optional[str]
-
-    environment_variables: Optional[Dict[str, str]]
-
-    min_scale: Optional[int]
-
-    max_scale: Optional[int]
-
-    memory_limit: Optional[int]
-
-    timeout: Optional[str]
-
-    privacy: ContainerPrivacy
-
-    description: Optional[str]
-
-    registry_image: Optional[str]
+    total_count: int
+    """
+    Total number of emails matching the requested criteria.
+    """
 
-    max_concurrency: Optional[int]
+    new_count: int
+    """
+    Number of emails still in the `new` transient state. This means emails received from the API but not yet processed.
+    """
 
-    protocol: ContainerProtocol
+    sending_count: int
+    """
+    Number of emails still in the `sending` transient state. This means emails received from the API but not yet in their final status.
+    """
 
-    port: Optional[int]
+    sent_count: int
+    """
+    Number of emails in the final `sent` state. This means emails that have been delivered to the target mail system.
+    """
 
-    secret_environment_variables: Optional[List[Secret]]
+    failed_count: int
+    """
+    Number of emails in the final `failed` state. This means emails that have been refused by the target mail system with a final error status.
+    """
 
-    http_option: ContainerHttpOption
+    canceled_count: int
     """
-    possible values:
-     - redirected: Responds to HTTP request with a 301 redirect to ask the clients to use HTTPS.
-     - enabled: Serve both HTTP and HTTPS traffic.
-    
+    Number of emails in the final `canceled` state. This means emails that have been canceled upon request.
     """
 
 
 @dataclass
-class UpdateContainerRequest:
+class CreateEmailRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    container_id: str
-
-    environment_variables: Optional[Dict[str, str]]
-
-    min_scale: Optional[int]
-
-    max_scale: Optional[int]
-
-    memory_limit: Optional[int]
-
-    timeout: Optional[str]
-
-    redeploy: Optional[bool]
-
-    privacy: ContainerPrivacy
-
-    description: Optional[str]
+    from_: Optional[CreateEmailRequestAddress]
+    """
+    Sender information. Must be from a checked domain declared in the Project.
+    """
 
-    registry_image: Optional[str]
+    to: Optional[List[CreateEmailRequestAddress]]
+    """
+    An array of the primary recipient's information.
+    """
 
-    max_concurrency: Optional[int]
+    cc: Optional[List[CreateEmailRequestAddress]]
+    """
+    An array of the carbon copy recipient's information.
+    """
 
-    protocol: ContainerProtocol
+    bcc: Optional[List[CreateEmailRequestAddress]]
+    """
+    An array of the blind carbon copy recipient's information.
+    """
 
-    port: Optional[int]
+    subject: str
+    """
+    Subject of the email.
+    """
 
-    secret_environment_variables: Optional[List[Secret]]
+    text: str
+    """
+    Text content.
+    """
 
-    http_option: ContainerHttpOption
+    html: str
     """
-    possible values:
-     - redirected: Responds to HTTP request with a 301 redirect to ask the clients to use HTTPS.
-     - enabled: Serve both HTTP and HTTPS traffic.
-    
+    HTML content.
     """
 
+    project_id: Optional[str]
+    """
+    ID of the Project in which to create the email.
+    """
 
-@dataclass
-class DeleteContainerRequest:
-    region: Optional[Region]
+    attachments: Optional[List[CreateEmailRequestAttachment]]
     """
-    Region to target. If none is passed will use default region from the config
+    Array of attachments.
     """
 
-    container_id: str
+    send_before: Optional[datetime]
+    """
+    Maximum date to deliver the email.
+    """
 
 
 @dataclass
-class DeployContainerRequest:
+class GetEmailRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    container_id: str
+    email_id: str
+    """
+    ID of the email to retrieve.
+    """
 
 
 @dataclass
-class ListCronsRequest:
+class ListEmailsRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     page: Optional[int]
 
     page_size: Optional[int]
 
-    order_by: Optional[ListCronsRequestOrderBy]
-
-    container_id: str
-
-
-@dataclass
-class GetCronRequest:
-    region: Optional[Region]
+    project_id: Optional[str]
     """
-    Region to target. If none is passed will use default region from the config
+    (Optional) ID of the Project in which to list the emails.
     """
 
-    cron_id: str
-
-
-@dataclass
-class CreateCronRequest:
-    region: Optional[Region]
+    domain_id: Optional[str]
     """
-    Region to target. If none is passed will use default region from the config
+    (Optional) ID of the domain for which to list the emails.
     """
 
-    container_id: str
-
-    schedule: str
-
-    args: Optional[Dict[str, Any]]
-
-    name: Optional[str]
+    message_id: Optional[str]
+    """
+    (Optional) ID of the message for which to list the emails.
+    """
 
+    since: Optional[datetime]
+    """
+    (Optional) List emails created after this date.
+    """
 
-@dataclass
-class UpdateCronRequest:
-    region: Optional[Region]
+    until: Optional[datetime]
     """
-    Region to target. If none is passed will use default region from the config
+    (Optional) List emails created before this date.
     """
 
-    cron_id: str
+    mail_from: Optional[str]
+    """
+    (Optional) List emails sent with this sender's email address.
+    """
 
-    container_id: Optional[str]
+    mail_to: Optional[str]
+    """
+    List emails sent to this recipient's email address.
+    :deprecated
+    """
 
-    schedule: Optional[str]
+    mail_rcpt: Optional[str]
+    """
+    (Optional) List emails sent to this recipient's email address.
+    """
 
-    args: Optional[Dict[str, Any]]
+    statuses: Optional[List[EmailStatus]]
+    """
+    (Optional) List emails with any of these statuses.
+    """
 
-    name: Optional[str]
+    subject: Optional[str]
+    """
+    (Optional) List emails with this subject.
+    """
 
+    search: Optional[str]
+    """
+    (Optional) List emails by searching to all fields.
+    """
 
-@dataclass
-class DeleteCronRequest:
-    region: Optional[Region]
+    order_by: Optional[ListEmailsRequestOrderBy]
     """
-    Region to target. If none is passed will use default region from the config
+    (Optional) List emails corresponding to specific criteria.
     """
 
-    cron_id: str
+    flags: Optional[List[EmailFlag]]
+    """
+    (Optional) List emails containing only specific flags.
+    """
 
 
 @dataclass
-class ListLogsRequest:
+class GetStatisticsRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    container_id: str
-
-    page: Optional[int]
-
-    page_size: Optional[int]
-
-    order_by: Optional[ListLogsRequestOrderBy]
-
-
-@dataclass
-class ListDomainsRequest:
-    region: Optional[Region]
+    project_id: Optional[str]
     """
-    Region to target. If none is passed will use default region from the config
+    (Optional) Number of emails for this Project.
     """
 
-    page: Optional[int]
+    domain_id: Optional[str]
+    """
+    (Optional) Number of emails sent from this domain (must be coherent with the `project_id` and the `organization_id`).
+    """
 
-    page_size: Optional[int]
+    since: Optional[datetime]
+    """
+    (Optional) Number of emails created after this date.
+    """
 
-    order_by: Optional[ListDomainsRequestOrderBy]
+    until: Optional[datetime]
+    """
+    (Optional) Number of emails created before this date.
+    """
 
-    container_id: str
+    mail_from: Optional[str]
+    """
+    (Optional) Number of emails sent with this sender's email address.
+    """
 
 
 @dataclass
-class GetDomainRequest:
+class CancelEmailRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    domain_id: str
+    email_id: str
+    """
+    ID of the email to cancel.
+    """
 
 
 @dataclass
 class CreateDomainRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    hostname: str
-
-    container_id: str
-
+    project_id: Optional[str]
+    """
+    ID of the project to which the domain belongs.
+    """
 
-@dataclass
-class DeleteDomainRequest:
-    region: Optional[Region]
+    domain_name: str
     """
-    Region to target. If none is passed will use default region from the config
+    Fully qualified domain dame.
     """
 
-    domain_id: str
+    accept_tos: bool
+    """
+    Accept Scaleway's Terms of Service.
+    """
 
 
 @dataclass
-class IssueJWTRequest:
+class GetDomainRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
-    """
-
-    container_id: Optional[str]
-    """
-    One-of ('scope'): at most one of 'container_id', 'namespace_id' could be set.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    namespace_id: Optional[str]
+    domain_id: str
     """
-    One-of ('scope'): at most one of 'container_id', 'namespace_id' could be set.
+    ID of the domain.
     """
 
-    expires_at: Optional[datetime]
-
 
 @dataclass
-class CreateTokenRequest:
+class ListDomainsRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    container_id: Optional[str]
+    page: Optional[int]
     """
-    One-of ('scope'): at most one of 'container_id', 'namespace_id' could be set.
+    Requested page number. Value must be greater or equal to 1.
     """
 
-    namespace_id: Optional[str]
+    page_size: Optional[int]
     """
-    One-of ('scope'): at most one of 'container_id', 'namespace_id' could be set.
+    Page size.
     """
 
-    description: Optional[str]
+    project_id: Optional[str]
 
-    expires_at: Optional[datetime]
+    status: Optional[List[DomainStatus]]
+
+    organization_id: Optional[str]
+
+    name: Optional[str]
 
 
 @dataclass
-class GetTokenRequest:
+class RevokeDomainRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    token_id: str
+    domain_id: str
+    """
+    ID of the domain to delete.
+    """
 
 
 @dataclass
-class ListTokensRequest:
+class CheckDomainRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    page: Optional[int]
-
-    page_size: Optional[int]
-
-    order_by: Optional[ListTokensRequestOrderBy]
-
-    container_id: Optional[str]
-
-    namespace_id: Optional[str]
+    domain_id: str
+    """
+    ID of the domain to check.
+    """
 
 
 @dataclass
-class DeleteTokenRequest:
+class GetDomainLastStatusRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    token_id: str
+    domain_id: str
+    """
+    ID of the domain to delete.
+    """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/domain/v2beta1/__init__.py` & `scaleway_async-1.0.0/scaleway_async/domain/v2beta1/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -10,14 +10,15 @@
 from .types import DomainFeatureStatus
 from .types import DomainRecordHTTPServiceConfigStrategy
 from .types import DomainRecordType
 from .types import DomainRegistrationStatusTransferStatus
 from .types import DomainStatus
 from .types import HostStatus
 from .types import LanguageCode
+from .types import ListContactsRequestRole
 from .types import ListDNSZoneRecordsRequestOrderBy
 from .types import ListDNSZonesRequestOrderBy
 from .types import ListDomainsRequestOrderBy
 from .types import ListRenewableDomainsRequestOrderBy
 from .types import ListTasksRequestOrderBy
 from .types import RawFormat
 from .types import RenewableDomainStatus
@@ -125,14 +126,15 @@
     "DomainFeatureStatus",
     "DomainRecordHTTPServiceConfigStrategy",
     "DomainRecordType",
     "DomainRegistrationStatusTransferStatus",
     "DomainStatus",
     "HostStatus",
     "LanguageCode",
+    "ListContactsRequestRole",
     "ListDNSZoneRecordsRequestOrderBy",
     "ListDNSZonesRequestOrderBy",
     "ListDomainsRequestOrderBy",
     "ListRenewableDomainsRequestOrderBy",
     "ListTasksRequestOrderBy",
     "RawFormat",
     "RenewableDomainStatus",
```

### Comparing `scaleway_async-0.9.0/scaleway_async/domain/v2beta1/api.py` & `scaleway_async-1.0.0/scaleway_async/domain/v2beta1/api.py`

 * *Files 5% similar despite different names*

```diff
@@ -11,17 +11,19 @@
 from scaleway_core.utils import (
     WaitForOptions,
     fetch_all_pages_async,
     validate_path_param,
     wait_for_resource_async,
 )
 from .types import (
+    ContactEmailStatus,
     DomainRecordType,
     DomainStatus,
     LanguageCode,
+    ListContactsRequestRole,
     ListDNSZoneRecordsRequestOrderBy,
     ListDNSZonesRequestOrderBy,
     ListDomainsRequestOrderBy,
     ListRenewableDomainsRequestOrderBy,
     ListTasksRequestOrderBy,
     RawFormat,
     TaskStatus,
@@ -157,41 +159,41 @@
     unmarshal_UpdateDNSZoneNameserversResponse,
     unmarshal_UpdateDNSZoneRecordsResponse,
 )
 
 
 class DomainV2Beta1API(API):
     """
-    DNS API.
+    Domains and DNS API.
 
-    Manage your DNS zones and records.
+    Domains and DNS API.
+    Manage your domains, DNS zones and records with the Domains and DNS API.
     """
 
     async def list_dns_zones(
         self,
         *,
         domain: str,
         dns_zone: str,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         order_by: ListDNSZonesRequestOrderBy = ListDNSZonesRequestOrderBy.DOMAIN_ASC,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListDNSZonesResponse:
         """
-        Returns a list of manageable DNS zones.
-        You can filter the DNS zones by domain name.
-
-        :param organization_id: The organization ID on which to filter the returned DNS zones
-        :param project_id: The project ID on which to filter the returned DNS zones
-        :param order_by: The sort order of the returned DNS zones
-        :param page: The page number for the returned DNS zones
-        :param page_size: The maximum number of DNS zones per page
-        :param domain: The domain on which to filter the returned DNS zones
-        :param dns_zone: The DNS zone on which to filter the returned DNS zones
+        List DNS zones.
+        Retrieve the list of DNS zones you can manage and filter DNS zones associated with specific domain names.
+        :param organization_id: Organization ID on which to filter the returned DNS zones.
+        :param project_id: Project ID on which to filter the returned DNS zones.
+        :param order_by: Sort order of the returned DNS zones.
+        :param page: Page number to return, from the paginated results.
+        :param page_size: Maximum number of DNS zones to return per page.
+        :param domain: Domain on which to filter the returned DNS zones.
+        :param dns_zone: DNS zone on which to filter the returned DNS zones.
         :return: :class:`ListDNSZonesResponse <ListDNSZonesResponse>`
 
         Usage:
         ::
 
             result = await api.list_dns_zones(
                 domain="example",
@@ -225,24 +227,23 @@
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         order_by: Optional[ListDNSZonesRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[DNSZone]:
         """
-        Returns a list of manageable DNS zones.
-        You can filter the DNS zones by domain name.
-
-        :param organization_id: The organization ID on which to filter the returned DNS zones
-        :param project_id: The project ID on which to filter the returned DNS zones
-        :param order_by: The sort order of the returned DNS zones
-        :param page: The page number for the returned DNS zones
-        :param page_size: The maximum number of DNS zones per page
-        :param domain: The domain on which to filter the returned DNS zones
-        :param dns_zone: The DNS zone on which to filter the returned DNS zones
+        List DNS zones.
+        Retrieve the list of DNS zones you can manage and filter DNS zones associated with specific domain names.
+        :param organization_id: Organization ID on which to filter the returned DNS zones.
+        :param project_id: Project ID on which to filter the returned DNS zones.
+        :param order_by: Sort order of the returned DNS zones.
+        :param page: Page number to return, from the paginated results.
+        :param page_size: Maximum number of DNS zones to return per page.
+        :param domain: Domain on which to filter the returned DNS zones.
+        :param dns_zone: DNS zone on which to filter the returned DNS zones.
         :return: :class:`List[ListDNSZonesResponse] <List[ListDNSZonesResponse]>`
 
         Usage:
         ::
 
             result = await api.list_dns_zones_all(
                 domain="example",
@@ -269,18 +270,19 @@
         self,
         *,
         domain: str,
         subdomain: str,
         project_id: Optional[str] = None,
     ) -> DNSZone:
         """
-        Create a new DNS zone.
-        :param domain: The domain of the DNS zone to create
-        :param subdomain: The subdomain of the DNS zone to create
-        :param project_id: The project ID where the DNS zone will be created
+        Create a DNS zone.
+        Create a new DNS zone specified by the domain name, the subdomain and the Project ID.
+        :param domain: Domain in which to crreate the DNS zone.
+        :param subdomain: Subdomain of the DNS zone to create.
+        :param project_id: Project ID in which to create the DNS zone.
         :return: :class:`DNSZone <DNSZone>`
 
         Usage:
         ::
 
             result = await api.create_dns_zone(
                 domain="example",
@@ -308,18 +310,19 @@
         self,
         *,
         dns_zone: str,
         new_dns_zone: str,
         project_id: Optional[str] = None,
     ) -> DNSZone:
         """
-        Update the name and/or the organizations for a DNS zone.
-        :param dns_zone: The DNS zone to update
-        :param new_dns_zone: The new DNS zone
-        :param project_id: The project ID of the new DNS zone
+        Update a DNS zone.
+        Update the name and/or the Organizations for a DNS zone.
+        :param dns_zone: DNS zone to update.
+        :param new_dns_zone: Name of the new DNS zone to create.
+        :param project_id: Project ID in which to create the new DNS zone.
         :return: :class:`DNSZone <DNSZone>`
 
         Usage:
         ::
 
             result = await api.update_dns_zone(
                 dns_zone="example",
@@ -350,19 +353,20 @@
         *,
         dns_zone: str,
         dest_dns_zone: str,
         overwrite: bool,
         project_id: Optional[str] = None,
     ) -> DNSZone:
         """
-        Clone an existed DNS zone with all its records into a new one.
-        :param dns_zone: The DNS zone to clone
-        :param dest_dns_zone: The destinaton DNS zone
-        :param overwrite: Whether or not the destination DNS zone will be overwritten
-        :param project_id: The project ID of the destination DNS zone
+        Clone a DNS zone.
+        Clone an existing DNS zone with all its records into a new DNS zone.
+        :param dns_zone: DNS zone to clone.
+        :param dest_dns_zone: Destination DNS zone in which to clone the chosen DNS zone.
+        :param overwrite: Specifies whether or not the destination DNS zone will be overwritten.
+        :param project_id: Project ID of the destination DNS zone.
         :return: :class:`DNSZone <DNSZone>`
 
         Usage:
         ::
 
             result = await api.clone_dns_zone(
                 dns_zone="example",
@@ -393,17 +397,18 @@
     async def delete_dns_zone(
         self,
         *,
         dns_zone: str,
         project_id: Optional[str] = None,
     ) -> DeleteDNSZoneResponse:
         """
-        Delete a DNS zone and all it's records.
-        :param dns_zone: The DNS zone to delete
-        :param project_id: The project ID of the DNS zone to delete
+        Delete a DNS zone.
+        Delete a DNS zone and all its records.
+        :param dns_zone: DNS zone to delete.
+        :param project_id: Project ID of the DNS zone to delete.
         :return: :class:`DeleteDNSZoneResponse <DeleteDNSZoneResponse>`
 
         Usage:
         ::
 
             result = await api.delete_dns_zone(dns_zone="example")
         """
@@ -430,25 +435,25 @@
         order_by: ListDNSZoneRecordsRequestOrderBy = ListDNSZoneRecordsRequestOrderBy.NAME_ASC,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         type_: DomainRecordType = DomainRecordType.UNKNOWN,
         id: Optional[str] = None,
     ) -> ListDNSZoneRecordsResponse:
         """
-        Returns a list of DNS records of a DNS zone with default NS.
-        You can filter the records by type and name.
-
-        :param dns_zone: The DNS zone on which to filter the returned DNS zone records
-        :param project_id: The project ID on which to filter the returned DNS zone records
-        :param order_by: The sort order of the returned DNS zone records
-        :param page: The page number for the returned DNS zone records
-        :param page_size: The maximum number of DNS zone records per page
-        :param name: The name on which to filter the returned DNS zone records
-        :param type_: The record type on which to filter the returned DNS zone records
-        :param id: The record ID on which to filter the returned DNS zone records
+        List records within a DNS zone.
+        Retrieve a list of DNS records within a DNS zone that has default name servers.
+        You can filter records by type and name.
+        :param dns_zone: DNS zone on which to filter the returned DNS zone records.
+        :param project_id: Project ID on which to filter the returned DNS zone records.
+        :param order_by: Sort order of the returned DNS zone records.
+        :param page: Page number to return, from the paginated results.
+        :param page_size: Maximum number of DNS zone records per page.
+        :param name: Name on which to filter the returned DNS zone records.
+        :param type_: Record type on which to filter the returned DNS zone records.
+        :param id: Record ID on which to filter the returned DNS zone records.
         :return: :class:`ListDNSZoneRecordsResponse <ListDNSZoneRecordsResponse>`
 
         Usage:
         ::
 
             result = await api.list_dns_zone_records(
                 dns_zone="example",
@@ -484,25 +489,25 @@
         order_by: Optional[ListDNSZoneRecordsRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         type_: Optional[DomainRecordType] = None,
         id: Optional[str] = None,
     ) -> List[DomainRecord]:
         """
-        Returns a list of DNS records of a DNS zone with default NS.
-        You can filter the records by type and name.
-
-        :param dns_zone: The DNS zone on which to filter the returned DNS zone records
-        :param project_id: The project ID on which to filter the returned DNS zone records
-        :param order_by: The sort order of the returned DNS zone records
-        :param page: The page number for the returned DNS zone records
-        :param page_size: The maximum number of DNS zone records per page
-        :param name: The name on which to filter the returned DNS zone records
-        :param type_: The record type on which to filter the returned DNS zone records
-        :param id: The record ID on which to filter the returned DNS zone records
+        List records within a DNS zone.
+        Retrieve a list of DNS records within a DNS zone that has default name servers.
+        You can filter records by type and name.
+        :param dns_zone: DNS zone on which to filter the returned DNS zone records.
+        :param project_id: Project ID on which to filter the returned DNS zone records.
+        :param order_by: Sort order of the returned DNS zone records.
+        :param page: Page number to return, from the paginated results.
+        :param page_size: Maximum number of DNS zone records per page.
+        :param name: Name on which to filter the returned DNS zone records.
+        :param type_: Record type on which to filter the returned DNS zone records.
+        :param id: Record ID on which to filter the returned DNS zone records.
         :return: :class:`List[ListDNSZoneRecordsResponse] <List[ListDNSZoneRecordsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_dns_zone_records_all(
                 dns_zone="example",
@@ -532,37 +537,29 @@
         dns_zone: str,
         changes: List[RecordChange],
         disallow_new_zone_creation: bool,
         return_all_records: Optional[bool] = None,
         serial: Optional[int] = None,
     ) -> UpdateDNSZoneRecordsResponse:
         """
-        Only available with default NS.<br/>
-        Send a list of actions and records.
+        Update records within a DNS zone.
+        Update records within a DNS zone that has default name servers and perform several actions on your records.
 
-        Action can be:
-         - add:
-          - Add new record
-          - Can be more specific and add a new IP to an existing A record for example
-         - set:
-          - Edit a record
-          - Can be more specific and edit an IP from an existing A record for example
-         - delete:
-          - Delete a record
-          - Can be more specific and delete an IP from an existing A record for example
-         - clear:
-          - Delete all records from a DNS zone
+        Actions include:
+         - add: allows you to add a new record or add a new IP to an existing A record, for example
+         - set: allows you to edit a record or edit an IP from an existing A record, for example
+         - delete: allows you to delete a record or delete an IP from an existing A record, for example
+         - clear: allows you to delete all records from a DNS zone
 
         All edits will be versioned.
-
-        :param dns_zone: The DNS zone where the DNS zone records will be updated
-        :param changes: The changes made to the records
-        :param return_all_records: Whether or not to return all the records
-        :param disallow_new_zone_creation: Forbid the creation of the target zone if not existing (default action is yes)
-        :param serial: Don't use the autoincremenent serial but the provided one (0 to keep the same)
+        :param dns_zone: DNS zone in which to update the DNS zone records.
+        :param changes: Changes made to the records.
+        :param return_all_records: Specifies whether or not to return all the records.
+        :param disallow_new_zone_creation: Disable the creation of the target zone if it does not exist. Target zone creation is disabled by default.
+        :param serial: Use the provided serial (0) instead of the auto-increment serial.
         :return: :class:`UpdateDNSZoneRecordsResponse <UpdateDNSZoneRecordsResponse>`
 
         Usage:
         ::
 
             result = await api.update_dns_zone_records(
                 dns_zone="example",
@@ -594,17 +591,18 @@
     async def list_dns_zone_nameservers(
         self,
         *,
         dns_zone: str,
         project_id: Optional[str] = None,
     ) -> ListDNSZoneNameserversResponse:
         """
-        Returns a list of Nameservers and their optional glue records for a DNS zone.
-        :param dns_zone: The DNS zone on which to filter the returned DNS zone nameservers
-        :param project_id: The project ID on which to filter the returned DNS zone nameservers
+        List name servers within a DNS zone.
+        Retrieve a list of name servers within a DNS zone and their optional glue records.
+        :param dns_zone: DNS zone on which to filter the returned DNS zone name servers.
+        :param project_id: Project ID on which to filter the returned DNS zone name servers.
         :return: :class:`ListDNSZoneNameserversResponse <ListDNSZoneNameserversResponse>`
 
         Usage:
         ::
 
             result = await api.list_dns_zone_nameservers(dns_zone="example")
         """
@@ -625,17 +623,18 @@
     async def update_dns_zone_nameservers(
         self,
         *,
         dns_zone: str,
         ns: List[Nameserver],
     ) -> UpdateDNSZoneNameserversResponse:
         """
-        Update DNS zone nameservers and set optional glue records.
-        :param dns_zone: The DNS zone where the DNS zone nameservers will be updated
-        :param ns: The new DNS zone nameservers
+        Update name servers within a DNS zone.
+        Update name servers within a DNS zone and set optional glue records.
+        :param dns_zone: DNS zone in which to update the DNS zone name servers.
+        :param ns: New DNS zone name servers.
         :return: :class:`UpdateDNSZoneNameserversResponse <UpdateDNSZoneNameserversResponse>`
 
         Usage:
         ::
 
             result = await api.update_dns_zone_nameservers(
                 dns_zone="example",
@@ -662,19 +661,18 @@
 
     async def clear_dns_zone_records(
         self,
         *,
         dns_zone: str,
     ) -> ClearDNSZoneRecordsResponse:
         """
-        Only available with default NS.<br/>
-        Delete all the records from a DNS zone.
+        Clear records within a DNS zone.
+        Delete all records within a DNS zone that has default name servers.<br/>
         All edits will be versioned.
-
-        :param dns_zone: The DNS zone to clear
+        :param dns_zone: DNS zone to clear.
         :return: :class:`ClearDNSZoneRecordsResponse <ClearDNSZoneRecordsResponse>`
 
         Usage:
         ::
 
             result = await api.clear_dns_zone_records(dns_zone="example")
         """
@@ -692,17 +690,18 @@
     async def export_raw_dns_zone(
         self,
         *,
         dns_zone: str,
         format: RawFormat,
     ) -> Optional[ScwFile]:
         """
-        Get a DNS zone in a given format with default NS.
-        :param dns_zone: The DNS zone to export
-        :param format: Format for DNS zone
+        Export a raw DNS zone.
+        Export a DNS zone with default name servers, in a specific format.
+        :param dns_zone: DNS zone to export.
+        :param format: DNS zone format.
         :return: :class:`Optional[ScwFile] <Optional[ScwFile]>`
 
         Usage:
         ::
 
             result = await api.export_raw_dns_zone(
                 dns_zone="example",
@@ -731,23 +730,24 @@
         content: Optional[str] = None,
         project_id: Optional[str] = None,
         format: Optional[RawFormat] = None,
         bind_source: Optional[ImportRawDNSZoneRequestBindSource] = None,
         axfr_source: Optional[ImportRawDNSZoneRequestAXFRSource] = None,
     ) -> ImportRawDNSZoneResponse:
         """
-        Import and replace records from a given provider format with default NS.
-        :param dns_zone: The DNS zone to import
+        Import a raw DNS zone.
+        Import and replace the format of records from a given provider, with default name servers.
+        :param dns_zone: DNS zone to import.
         :param content:
         :param project_id:
         :param format:
         :param bind_source: Import a bind file format.
 
         One-of ('source'): at most one of 'bind_source', 'axfr_source' could be set.
-        :param axfr_source: Import from the nameserver given with tsig use or not.
+        :param axfr_source: Import from the name server given with TSIG, to use or not.
 
         One-of ('source'): at most one of 'bind_source', 'axfr_source' could be set.
         :return: :class:`ImportRawDNSZoneResponse <ImportRawDNSZoneResponse>`
 
         Usage:
         ::
 
@@ -778,15 +778,16 @@
     async def import_provider_dns_zone(
         self,
         *,
         dns_zone: str,
         online_v1: Optional[ImportProviderDNSZoneRequestOnlineV1] = None,
     ) -> ImportProviderDNSZoneResponse:
         """
-        Import and replace records from a given provider format with default NS.
+        Import a DNS zone from another provider.
+        Import and replace the format of records from a given provider, with default name servers.
         :param dns_zone:
         :param online_v1: One-of ('provider'): at most one of 'online_v1' could be set.
         :return: :class:`ImportProviderDNSZoneResponse <ImportProviderDNSZoneResponse>`
 
         Usage:
         ::
 
@@ -814,20 +815,20 @@
         self,
         *,
         dns_zone: str,
         recreate_dns_zone: bool,
         recreate_sub_dns_zone: bool,
     ) -> RefreshDNSZoneResponse:
         """
-        Refresh SOA DNS zone.
+        Refresh a DNS zone.
+        Refresh an SOA DNS zone to reload the records in the DNS zone and update the SOA serial.
         You can recreate the given DNS zone and its sub DNS zone if needed.
-
-        :param dns_zone: The DNS zone to refresh
-        :param recreate_dns_zone: Whether or not to recreate the DNS zone
-        :param recreate_sub_dns_zone: Whether or not to recreate the sub DNS zone
+        :param dns_zone: DNS zone to refresh.
+        :param recreate_dns_zone: Specifies whether or not to recreate the DNS zone.
+        :param recreate_sub_dns_zone: Specifies whether or not to recreate the sub DNS zone.
         :return: :class:`RefreshDNSZoneResponse <RefreshDNSZoneResponse>`
 
         Usage:
         ::
 
             result = await api.refresh_dns_zone(
                 dns_zone="example",
@@ -858,21 +859,20 @@
         self,
         *,
         dns_zone: str,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListDNSZoneVersionsResponse:
         """
-        Get a list of DNS zone versions.<br/>
-        The maximum version count is 100.<br/>
-        If the count reaches this limit, the oldest version will be deleted after each new modification.
-
+        List versions of a DNS zone.
+        Retrieve a list of a DNS zone's versions.<br/>
+        The maximum version count is 100. If the count reaches this limit, the oldest version will be deleted after each new modification.
         :param dns_zone:
-        :param page: The page number for the returned DNS zones versions
-        :param page_size: The maximum number of DNS zones versions per page
+        :param page: Page number to return, from the paginated results.
+        :param page_size: Maximum number of DNS zones versions per page.
         :return: :class:`ListDNSZoneVersionsResponse <ListDNSZoneVersionsResponse>`
 
         Usage:
         ::
 
             result = await api.list_dns_zone_versions(dns_zone="example")
         """
@@ -895,21 +895,20 @@
         self,
         *,
         dns_zone: str,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[DNSZoneVersion]:
         """
-        Get a list of DNS zone versions.<br/>
-        The maximum version count is 100.<br/>
-        If the count reaches this limit, the oldest version will be deleted after each new modification.
-
+        List versions of a DNS zone.
+        Retrieve a list of a DNS zone's versions.<br/>
+        The maximum version count is 100. If the count reaches this limit, the oldest version will be deleted after each new modification.
         :param dns_zone:
-        :param page: The page number for the returned DNS zones versions
-        :param page_size: The maximum number of DNS zones versions per page
+        :param page: Page number to return, from the paginated results.
+        :param page_size: Maximum number of DNS zones versions per page.
         :return: :class:`List[ListDNSZoneVersionsResponse] <List[ListDNSZoneVersionsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_dns_zone_versions_all(dns_zone="example")
         """
@@ -929,18 +928,19 @@
         self,
         *,
         dns_zone_version_id: str,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListDNSZoneVersionRecordsResponse:
         """
-        Get a list of records from a previous DNS zone version.
+        List records from a given version of a specific DNS zone.
+        Retrieve a list of records from a specific DNS zone version.
         :param dns_zone_version_id:
-        :param page: The page number for the returned DNS zones versions records
-        :param page_size: The maximum number of DNS zones versions records per page
+        :param page: Page number to return, from the paginated results.
+        :param page_size: Maximum number of DNS zones versions records per page.
         :return: :class:`ListDNSZoneVersionRecordsResponse <ListDNSZoneVersionRecordsResponse>`
 
         Usage:
         ::
 
             result = await api.list_dns_zone_version_records(dns_zone_version_id="example")
         """
@@ -965,18 +965,19 @@
         self,
         *,
         dns_zone_version_id: str,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[DomainRecord]:
         """
-        Get a list of records from a previous DNS zone version.
+        List records from a given version of a specific DNS zone.
+        Retrieve a list of records from a specific DNS zone version.
         :param dns_zone_version_id:
-        :param page: The page number for the returned DNS zones versions records
-        :param page_size: The maximum number of DNS zones versions records per page
+        :param page: Page number to return, from the paginated results.
+        :param page_size: Maximum number of DNS zones versions records per page.
         :return: :class:`List[ListDNSZoneVersionRecordsResponse] <List[ListDNSZoneVersionRecordsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_dns_zone_version_records_all(dns_zone_version_id="example")
         """
@@ -994,15 +995,16 @@
 
     async def get_dns_zone_version_diff(
         self,
         *,
         dns_zone_version_id: str,
     ) -> GetDNSZoneVersionDiffResponse:
         """
-        Get all differences from a previous DNS zone version.
+        Access differences from a specific DNS zone version.
+        Access a previous DNS zone version to see the differences from another specific version.
         :param dns_zone_version_id:
         :return: :class:`GetDNSZoneVersionDiffResponse <GetDNSZoneVersionDiffResponse>`
 
         Usage:
         ::
 
             result = await api.get_dns_zone_version_diff(dns_zone_version_id="example")
@@ -1022,15 +1024,16 @@
 
     async def restore_dns_zone_version(
         self,
         *,
         dns_zone_version_id: str,
     ) -> RestoreDNSZoneVersionResponse:
         """
-        Restore and activate a previous DNS zone version.
+        Restore a DNS zone version.
+        Restore and activate a version of a specific DNS zone.
         :param dns_zone_version_id:
         :return: :class:`RestoreDNSZoneVersionResponse <RestoreDNSZoneVersionResponse>`
 
         Usage:
         ::
 
             result = await api.restore_dns_zone_version(dns_zone_version_id="example")
@@ -1050,15 +1053,16 @@
 
     async def get_ssl_certificate(
         self,
         *,
         dns_zone: str,
     ) -> SSLCertificate:
         """
-        Get the zone TLS certificate if it exists
+        Get a DNS zone's TLS certificate.
+        Get the DNS zone's TLS certificate. If you do not have a certificate, the ouptut returns `no certificate found`.
         :param dns_zone:
         :return: :class:`SSLCertificate <SSLCertificate>`
 
         Usage:
         ::
 
             result = await api.get_ssl_certificate(dns_zone="example")
@@ -1113,15 +1117,16 @@
     async def create_ssl_certificate(
         self,
         *,
         dns_zone: str,
         alternative_dns_zones: Optional[List[str]] = None,
     ) -> SSLCertificate:
         """
-        Create or return the zone TLS certificate
+        Create or get the DNS zone's TLS certificate.
+        Create a new TLS certificate or retrieve information about an existing TLS certificate.
         :param dns_zone:
         :param alternative_dns_zones:
         :return: :class:`SSLCertificate <SSLCertificate>`
 
         Usage:
         ::
 
@@ -1148,15 +1153,16 @@
         *,
         dns_zone: str,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         project_id: Optional[str] = None,
     ) -> ListSSLCertificatesResponse:
         """
-        List all user TLS certificates
+        List a user's TLS certificates.
+        List all the TLS certificates a user has created, specified by the user's Project ID and the DNS zone.
         :param dns_zone:
         :param page:
         :param page_size:
         :param project_id:
         :return: :class:`ListSSLCertificatesResponse <ListSSLCertificatesResponse>`
 
         Usage:
@@ -1184,15 +1190,16 @@
         *,
         dns_zone: str,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         project_id: Optional[str] = None,
     ) -> List[SSLCertificate]:
         """
-        List all user TLS certificates
+        List a user's TLS certificates.
+        List all the TLS certificates a user has created, specified by the user's Project ID and the DNS zone.
         :param dns_zone:
         :param page:
         :param page_size:
         :param project_id:
         :return: :class:`List[ListSSLCertificatesResponse] <List[ListSSLCertificatesResponse]>`
 
         Usage:
@@ -1215,15 +1222,16 @@
 
     async def delete_ssl_certificate(
         self,
         *,
         dns_zone: str,
     ) -> DeleteSSLCertificateResponse:
         """
-        Delete an TLS certificate
+        Delete a TLS certificate.
+        Delete an existing TLS certificate specified by its DNS zone. Deleting a TLS certificate is permanent and cannot be undone.
         :param dns_zone:
         :return: :class:`DeleteSSLCertificateResponse <DeleteSSLCertificateResponse>`
 
         Usage:
         ::
 
             result = await api.delete_ssl_certificate(dns_zone="example")
@@ -1241,15 +1249,16 @@
 
     async def get_dns_zone_tsig_key(
         self,
         *,
         dns_zone: str,
     ) -> GetDNSZoneTsigKeyResponse:
         """
-        Get the DNS zone TSIG Key to allow AXFR request.
+        Get the DNS zone's TSIG key.
+        Retrieve information about the TSIG key of a given DNS zone to allow AXFR requests.
         :param dns_zone:
         :return: :class:`GetDNSZoneTsigKeyResponse <GetDNSZoneTsigKeyResponse>`
 
         Usage:
         ::
 
             result = await api.get_dns_zone_tsig_key(dns_zone="example")
@@ -1267,15 +1276,16 @@
 
     async def delete_dns_zone_tsig_key(
         self,
         *,
         dns_zone: str,
     ) -> Optional[None]:
         """
-        Delete the DNS zone TSIG Key
+        Delete the DNS zone's TSIG key.
+        Delete an existing TSIG key specified by its DNS zone. Deleting a TSIG key is permanent and cannot be undone.
         :param dns_zone:
 
         Usage:
         ::
 
             result = await api.delete_dns_zone_tsig_key(dns_zone="example")
         """
@@ -1289,16 +1299,17 @@
 
         self._throw_on_error(res)
         return None
 
 
 class DomainRegistrarV2Beta1API(API):
     """
-    Domains registrar API.
+    Domains and DNS - Registrar API.
 
+    Domains and DNS - Registrar API.
     Manage your domains and contacts.
     """
 
     async def list_tasks(
         self,
         *,
         page: Optional[int] = None,
@@ -1307,17 +1318,17 @@
         organization_id: Optional[str] = None,
         domain: Optional[str] = None,
         types: Optional[List[TaskType]] = None,
         statuses: Optional[List[TaskStatus]] = None,
         order_by: ListTasksRequestOrderBy = ListTasksRequestOrderBy.DOMAIN_DESC,
     ) -> ListTasksResponse:
         """
-        List all account tasks.
-        You can filter the list by domain name.
-
+        List tasks.
+        List all operations performed on the account.
+        You can filter the list of tasks by domain name.
         :param page:
         :param page_size:
         :param project_id:
         :param organization_id:
         :param domain:
         :param types:
         :param statuses:
@@ -1358,17 +1369,17 @@
         organization_id: Optional[str] = None,
         domain: Optional[str] = None,
         types: Optional[List[TaskType]] = None,
         statuses: Optional[List[TaskStatus]] = None,
         order_by: Optional[ListTasksRequestOrderBy] = None,
     ) -> List[Task]:
         """
-        List all account tasks.
-        You can filter the list by domain name.
-
+        List tasks.
+        List all operations performed on the account.
+        You can filter the list of tasks by domain name.
         :param page:
         :param page_size:
         :param project_id:
         :param organization_id:
         :param domain:
         :param types:
         :param statuses:
@@ -1407,17 +1418,17 @@
         owner_contact: Optional[NewContact] = None,
         administrative_contact_id: Optional[str] = None,
         administrative_contact: Optional[NewContact] = None,
         technical_contact_id: Optional[str] = None,
         technical_contact: Optional[NewContact] = None,
     ) -> OrderResponse:
         """
+        Purchase domains.
         Request the registration of domain names.
-        You can provide an already existing domain's contact or a new contact.
-
+        You can provide a domain's already existing contact or a new contact.
         :param domains:
         :param duration_in_years:
         :param project_id:
         :param owner_contact_id: One-of ('owner_contact_type'): at most one of 'owner_contact_id', 'owner_contact' could be set.
         :param owner_contact: One-of ('owner_contact_type'): at most one of 'owner_contact_id', 'owner_contact' could be set.
         :param administrative_contact_id: One-of ('administrative_contact_type'): at most one of 'administrative_contact_id', 'administrative_contact' could be set.
         :param administrative_contact: One-of ('administrative_contact_type'): at most one of 'administrative_contact_id', 'administrative_contact' could be set.
@@ -1460,16 +1471,16 @@
         self,
         *,
         domains: List[str],
         duration_in_years: int,
         force_late_renewal: Optional[bool] = None,
     ) -> OrderResponse:
         """
-        Request the renewal of domain names.
-
+        Renew domains.
+        Request the renewal of one or more domain names.
         :param domains:
         :param duration_in_years:
         :param force_late_renewal:
         :return: :class:`OrderResponse <OrderResponse>`
 
         Usage:
         ::
@@ -1505,16 +1516,16 @@
         owner_contact: Optional[NewContact] = None,
         administrative_contact_id: Optional[str] = None,
         administrative_contact: Optional[NewContact] = None,
         technical_contact_id: Optional[str] = None,
         technical_contact: Optional[NewContact] = None,
     ) -> OrderResponse:
         """
-        Request the transfer from another registrar domain to Scaleway.
-
+        Transfer a domain.
+        Request the transfer of a domain from another registrar to Scaleway Domains and DNS.
         :param domains:
         :param project_id:
         :param owner_contact_id: One-of ('owner_contact_type'): at most one of 'owner_contact_id', 'owner_contact' could be set.
         :param owner_contact: One-of ('owner_contact_type'): at most one of 'owner_contact_id', 'owner_contact' could be set.
         :param administrative_contact_id: One-of ('administrative_contact_type'): at most one of 'administrative_contact_id', 'administrative_contact' could be set.
         :param administrative_contact: One-of ('administrative_contact_type'): at most one of 'administrative_contact_id', 'administrative_contact' could be set.
         :param technical_contact_id: One-of ('technical_contact_type'): at most one of 'technical_contact_id', 'technical_contact' could be set.
@@ -1553,19 +1564,19 @@
         *,
         domain: str,
         project_id: Optional[str] = None,
         new_owner_contact_id: Optional[str] = None,
         new_owner_contact: Optional[NewContact] = None,
     ) -> OrderResponse:
         """
-        Request a trade for the contact owner.<br/>
-        If an `organization_id` is given, the change is from the current Scaleway account to another Scaleway account.<br/>
-        If no contact is given, the first contact of the other Scaleway account is taken.<br/>
-        If the other Scaleway account has no contact. An error occurs.
-
+        Trade a domain's contact.
+        Request to change a domain's contact owner.<br/>
+        If you specify the `organization_id` of the domain's new owner, the contact will change from the current owner's Scaleway account to the new owner's Scaleway account.<br/>
+        If the new owner's current contact information is not available, the first ever contact they have created for previous domains is taken into account to operate the change.<br/>
+        If the new owner has never created a contact to register domains before, an error message displays.
         :param domain:
         :param project_id:
         :param new_owner_contact_id: One-of ('new_owner_contact_type'): at most one of 'new_owner_contact_id', 'new_owner_contact' could be set.
         :param new_owner_contact: One-of ('new_owner_contact_type'): at most one of 'new_owner_contact_id', 'new_owner_contact' could be set.
         :return: :class:`OrderResponse <OrderResponse>`
 
         Usage:
@@ -1596,16 +1607,16 @@
     async def register_external_domain(
         self,
         *,
         domain: str,
         project_id: Optional[str] = None,
     ) -> RegisterExternalDomainResponse:
         """
+        Register an external domain.
         Request the registration of an external domain name.
-
         :param domain:
         :param project_id:
         :return: :class:`RegisterExternalDomainResponse <RegisterExternalDomainResponse>`
 
         Usage:
         ::
 
@@ -1629,16 +1640,16 @@
 
     async def delete_external_domain(
         self,
         *,
         domain: str,
     ) -> DeleteExternalDomainResponse:
         """
+        Delete an external domain.
         Delete an external domain name.
-
         :param domain:
         :return: :class:`DeleteExternalDomainResponse <DeleteExternalDomainResponse>`
 
         Usage:
         ::
 
             result = await api.delete_external_domain(domain="example")
@@ -1663,17 +1674,17 @@
         owner_contact: Optional[NewContact] = None,
         administrative_contact_id: Optional[str] = None,
         administrative_contact: Optional[NewContact] = None,
         technical_contact_id: Optional[str] = None,
         technical_contact: Optional[NewContact] = None,
     ) -> CheckContactsCompatibilityResponse:
         """
-        Check if contacts are compatible against a domain or a tld.
-        If not, it will return the information requiring a correction.
-
+        Check if contacts are compatible with a domain or a TLD.
+        Check whether contacts are compatible with a domain or a TLD.
+        If contacts are not compatible with either the domain or the TLD, the information that needs to be corrected is returned.
         :param domains:
         :param tlds:
         :param owner_contact_id: One-of ('owner_contact_type'): at most one of 'owner_contact_id', 'owner_contact' could be set.
         :param owner_contact: One-of ('owner_contact_type'): at most one of 'owner_contact_id', 'owner_contact' could be set.
         :param administrative_contact_id: One-of ('administrative_contact_type'): at most one of 'administrative_contact_id', 'administrative_contact' could be set.
         :param administrative_contact: One-of ('administrative_contact_type'): at most one of 'administrative_contact_id', 'administrative_contact' could be set.
         :param technical_contact_id: One-of ('technical_contact_type'): at most one of 'technical_contact_id', 'technical_contact' could be set.
@@ -1711,66 +1722,76 @@
         self,
         *,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         domain: Optional[str] = None,
         project_id: Optional[str] = None,
         organization_id: Optional[str] = None,
+        role: ListContactsRequestRole = ListContactsRequestRole.UNKNOWN_ROLE,
+        email_status: ContactEmailStatus = ContactEmailStatus.EMAIL_STATUS_UNKNOWN,
     ) -> ListContactsResponse:
         """
-        Return a list of contacts with their domains and roles.
+        List contacts.
+        Retrieve the list of contacts and their associated domains and roles.
         You can filter the list by domain name.
-
         :param page:
         :param page_size:
         :param domain:
         :param project_id:
         :param organization_id:
+        :param role:
+        :param email_status:
         :return: :class:`ListContactsResponse <ListContactsResponse>`
 
         Usage:
         ::
 
             result = await api.list_contacts()
         """
 
         res = self._request(
             "GET",
             f"/domain/v2beta1/contacts",
             params={
                 "domain": domain,
+                "email_status": email_status,
                 "organization_id": organization_id
                 or self.client.default_organization_id,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
                 "project_id": project_id or self.client.default_project_id,
+                "role": role,
             },
         )
 
         self._throw_on_error(res)
         return unmarshal_ListContactsResponse(res.json())
 
     async def list_contacts_all(
         self,
         *,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         domain: Optional[str] = None,
         project_id: Optional[str] = None,
         organization_id: Optional[str] = None,
+        role: Optional[ListContactsRequestRole] = None,
+        email_status: Optional[ContactEmailStatus] = None,
     ) -> List[ContactRoles]:
         """
-        Return a list of contacts with their domains and roles.
+        List contacts.
+        Retrieve the list of contacts and their associated domains and roles.
         You can filter the list by domain name.
-
         :param page:
         :param page_size:
         :param domain:
         :param project_id:
         :param organization_id:
+        :param role:
+        :param email_status:
         :return: :class:`List[ListContactsResponse] <List[ListContactsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_contacts_all()
         """
@@ -1781,24 +1802,27 @@
             fetcher=self.list_contacts,
             args={
                 "page": page,
                 "page_size": page_size,
                 "domain": domain,
                 "project_id": project_id,
                 "organization_id": organization_id,
+                "role": role,
+                "email_status": email_status,
             },
         )
 
     async def get_contact(
         self,
         *,
         contact_id: str,
     ) -> Contact:
         """
-        Return a contact details retrieved from the registrar using a given contact ID.
+        Get a contact.
+        Retrieve a contact's details from the registrar using the given contact's ID.
         :param contact_id:
         :return: :class:`Contact <Contact>`
 
         Usage:
         ::
 
             result = await api.get_contact(contact_id="example")
@@ -1835,15 +1859,16 @@
         extension_fr: Optional[ContactExtensionFR] = None,
         extension_eu: Optional[ContactExtensionEU] = None,
         whois_opt_in: Optional[bool] = None,
         state: Optional[str] = None,
         extension_nl: Optional[ContactExtensionNL] = None,
     ) -> Contact:
         """
-        You can edit the contact coordinates.
+        Update contact.
+        Edit the contact's information.
         :param contact_id:
         :param email:
         :param email_alt:
         :param phone_number:
         :param fax_number:
         :param address_line_1:
         :param address_line_2:
@@ -1916,15 +1941,16 @@
         status: DomainStatus = DomainStatus.STATUS_UNKNOWN,
         project_id: Optional[str] = None,
         organization_id: Optional[str] = None,
         is_external: Optional[bool] = None,
         domain: Optional[str] = None,
     ) -> ListDomainsResponse:
         """
-        Returns a list of domains owned by the user.
+        List domains.
+        Retrieve the list of domains you own.
         :param page:
         :param page_size:
         :param order_by:
         :param registrar:
         :param status:
         :param project_id:
         :param organization_id:
@@ -1968,15 +1994,16 @@
         status: Optional[DomainStatus] = None,
         project_id: Optional[str] = None,
         organization_id: Optional[str] = None,
         is_external: Optional[bool] = None,
         domain: Optional[str] = None,
     ) -> List[DomainSummary]:
         """
-        Returns a list of domains owned by the user.
+        List domains.
+        Retrieve the list of domains you own.
         :param page:
         :param page_size:
         :param order_by:
         :param registrar:
         :param status:
         :param project_id:
         :param organization_id:
@@ -2013,15 +2040,16 @@
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListRenewableDomainsRequestOrderBy = ListRenewableDomainsRequestOrderBy.DOMAIN_ASC,
         project_id: Optional[str] = None,
         organization_id: Optional[str] = None,
     ) -> ListRenewableDomainsResponse:
         """
-        Returns a list of domains owned by the user with a renew status and if renewable, the maximum renew duration in years.
+        List domains that can be renewed.
+        Retrieve the list of domains you own that can be renewed. You can also see the maximum renewal duration in years for your domains that are renewable.
         :param page:
         :param page_size:
         :param order_by:
         :param project_id:
         :param organization_id:
         :return: :class:`ListRenewableDomainsResponse <ListRenewableDomainsResponse>`
 
@@ -2053,15 +2081,16 @@
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListRenewableDomainsRequestOrderBy] = None,
         project_id: Optional[str] = None,
         organization_id: Optional[str] = None,
     ) -> List[RenewableDomain]:
         """
-        Returns a list of domains owned by the user with a renew status and if renewable, the maximum renew duration in years.
+        List domains that can be renewed.
+        Retrieve the list of domains you own that can be renewed. You can also see the maximum renewal duration in years for your domains that are renewable.
         :param page:
         :param page_size:
         :param order_by:
         :param project_id:
         :param organization_id:
         :return: :class:`List[ListRenewableDomainsResponse] <List[ListRenewableDomainsResponse]>`
 
@@ -2086,15 +2115,16 @@
 
     async def get_domain(
         self,
         *,
         domain: str,
     ) -> Domain:
         """
-        Returns a the domain with more informations.
+        Get domain.
+        Retrieve a specific domain and display the domain's information.
         :param domain:
         :return: :class:`Domain <Domain>`
 
         Usage:
         ::
 
             result = await api.get_domain(domain="example")
@@ -2150,17 +2180,17 @@
         technical_contact: Optional[NewContact] = None,
         owner_contact_id: Optional[str] = None,
         owner_contact: Optional[NewContact] = None,
         administrative_contact_id: Optional[str] = None,
         administrative_contact: Optional[NewContact] = None,
     ) -> Domain:
         """
-        Update the domain contacts or create a new one.<br/>
-        If you add the same contact for multiple roles. Only one ID will be created and used for all of them.
-
+        Update a domain's contacts.
+        Update contacts for a specific domain or create a new contact.<br/>
+        If you add the same contact for multiple roles (owner, administrative, technical), only one ID will be created and used for all of the roles.
         :param domain:
         :param technical_contact_id: One-of ('technical_contact_info'): at most one of 'technical_contact_id', 'technical_contact' could be set.
         :param technical_contact: One-of ('technical_contact_info'): at most one of 'technical_contact_id', 'technical_contact' could be set.
         :param owner_contact_id: One-of ('owner_contact_info'): at most one of 'owner_contact_id', 'owner_contact' could be set.
         :param owner_contact: One-of ('owner_contact_info'): at most one of 'owner_contact_id', 'owner_contact' could be set.
         :param administrative_contact_id: One-of ('administrative_contact_info'): at most one of 'administrative_contact_id', 'administrative_contact' could be set.
         :param administrative_contact: One-of ('administrative_contact_info'): at most one of 'administrative_contact_id', 'administrative_contact' could be set.
@@ -2196,16 +2226,16 @@
 
     async def lock_domain_transfer(
         self,
         *,
         domain: str,
     ) -> Domain:
         """
-        Lock domain transfer. A locked domain transfer can't be transferred and the auth code can't be requested.
-
+        Lock the transfer of a domain.
+        Lock the transfer of a domain. This means that the domain cannot be transferred and the authorization code cannot be requested to your current registrar.
         :param domain:
         :return: :class:`Domain <Domain>`
 
         Usage:
         ::
 
             result = await api.lock_domain_transfer(domain="example")
@@ -2223,16 +2253,16 @@
 
     async def unlock_domain_transfer(
         self,
         *,
         domain: str,
     ) -> Domain:
         """
-        Unlock domain transfer. An unlocked domain can be transferred and the auth code can be requested for this.
-
+        Unlock the transfer of a domain.
+        Unlock the transfer of a domain. This means that the domain can be transferred and the authorization code can be requested to your current registrar.
         :param domain:
         :return: :class:`Domain <Domain>`
 
         Usage:
         ::
 
             result = await api.unlock_domain_transfer(domain="example")
@@ -2250,15 +2280,16 @@
 
     async def enable_domain_auto_renew(
         self,
         *,
         domain: str,
     ) -> Domain:
         """
-        Enable domain auto renew
+        Enable auto renew.
+        Enable the `auto renew` feature for a domain. This means the domain will be automatically renewed before its expiry date.
         :param domain:
         :return: :class:`Domain <Domain>`
 
         Usage:
         ::
 
             result = await api.enable_domain_auto_renew(domain="example")
@@ -2276,15 +2307,16 @@
 
     async def disable_domain_auto_renew(
         self,
         *,
         domain: str,
     ) -> Domain:
         """
-        Disable domain auto renew
+        Disable auto renew.
+        Disable the `auto renew` feature for a domain. This means the domain will not be renewed before its expiry date.
         :param domain:
         :return: :class:`Domain <Domain>`
 
         Usage:
         ::
 
             result = await api.disable_domain_auto_renew(domain="example")
@@ -2302,17 +2334,17 @@
 
     async def get_domain_auth_code(
         self,
         *,
         domain: str,
     ) -> GetDomainAuthCodeResponse:
         """
-        If possible, return the auth code for an unlocked domain transfer, or an error if the domain is locked.
-        Some TLD may have a different procedure to retrieve the auth code, in that case, the information is given in the message field.
-
+        Get a domain's authorization code.
+        Retrieve the authorization code to tranfer an unlocked domain. The output returns an error if the domain is locked.
+        Some TLDs may have a different procedure to retrieve the authorization code. In that case, the information displays in the message field.
         :param domain:
         :return: :class:`GetDomainAuthCodeResponse <GetDomainAuthCodeResponse>`
 
         Usage:
         ::
 
             result = await api.get_domain_auth_code(domain="example")
@@ -2331,34 +2363,16 @@
     async def enable_domain_dnssec(
         self,
         *,
         domain: str,
         ds_record: Optional[DSRecord] = None,
     ) -> Domain:
         """
+        Update domain DNSSEC.
         If your domain has the default Scaleway NS and uses another registrar, you have to update the DS record manually.
-        For the algorithm, here are the code numbers for each type:
-          - 1: RSAMD5
-          - 2: DIFFIE_HELLMAN
-          - 3: DSA_SHA1
-          - 5: RSA_SHA1
-          - 6: DSA_NSEC3_SHA1
-          - 7: RSASHA1_NSEC3_SHA1
-          - 8: RSASHA256
-          - 10: RSASHA512
-          - 12: ECC_GOST
-          - 13: ECDSAP256SHA256
-          - 14: ECDSAP384SHA384
-
-        And for the digest type:
-          - 1: SHA_1
-          - 2: SHA_256
-          - 3: GOST_R_34_11_94
-          - 4: SHA_384
-
         :param domain:
         :param ds_record:
         :return: :class:`Domain <Domain>`
 
         Usage:
         ::
 
@@ -2384,15 +2398,16 @@
 
     async def disable_domain_dnssec(
         self,
         *,
         domain: str,
     ) -> Domain:
         """
-        Disable domain DNSSEC
+        Disable a domain's DNSSEC.
+        Disable DNSSEC for a domain.
         :param domain:
         :return: :class:`Domain <Domain>`
 
         Usage:
         ::
 
             result = await api.disable_domain_dnssec(domain="example")
@@ -2412,21 +2427,21 @@
         self,
         *,
         domains: List[str],
         strict_search: bool,
         tlds: Optional[List[str]] = None,
     ) -> SearchAvailableDomainsResponse:
         """
-        Search a domain (or at maximum, 10 domains).
-
-        If the TLD list is empty or not set the search returns the results from the most popular TLDs.
+        Search available domains.
+        Search a domain or a maximum of 10 domains that are available.
 
-        :param domains: A list of domain to search, TLD is optional
-        :param tlds: Array of tlds to search on
-        :param strict_search: Search exact match
+        If the TLD list is empty or not set, the search returns the results from the most popular TLDs.
+        :param domains: A list of domain to search, TLD is optional.
+        :param tlds: Array of tlds to search on.
+        :param strict_search: Search exact match.
         :return: :class:`SearchAvailableDomainsResponse <SearchAvailableDomainsResponse>`
 
         Usage:
         ::
 
             result = await api.search_available_domains(
                 domains=["example"],
@@ -2451,15 +2466,16 @@
         self,
         *,
         domain: str,
         name: str,
         ips: Optional[List[str]] = None,
     ) -> Host:
         """
-        Create domain hostname with glue IPs
+        Create a hostname for a domain.
+        Create a hostname for a domain with glue IPs.
         :param domain:
         :param name:
         :param ips:
         :return: :class:`Host <Host>`
 
         Usage:
         ::
@@ -2492,15 +2508,16 @@
         self,
         *,
         domain: str,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListDomainHostsResponse:
         """
-        List domain hostnames with they glue IPs
+        List a domain's hostnames.
+        List a domain's hostnames using their glue IPs.
         :param domain:
         :param page:
         :param page_size:
         :return: :class:`ListDomainHostsResponse <ListDomainHostsResponse>`
 
         Usage:
         ::
@@ -2526,15 +2543,16 @@
         self,
         *,
         domain: str,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[Host]:
         """
-        List domain hostnames with they glue IPs
+        List a domain's hostnames.
+        List a domain's hostnames using their glue IPs.
         :param domain:
         :param page:
         :param page_size:
         :return: :class:`List[ListDomainHostsResponse] <List[ListDomainHostsResponse]>`
 
         Usage:
         ::
@@ -2557,15 +2575,16 @@
         self,
         *,
         domain: str,
         name: str,
         ips: Optional[List[str]] = None,
     ) -> Host:
         """
-        Update domain hostname with glue IPs
+        Update a domain's hostname.
+        Update a domain's hostname with glue IPs.
         :param domain:
         :param name:
         :param ips:
         :return: :class:`Host <Host>`
 
         Usage:
         ::
@@ -2598,15 +2617,16 @@
     async def delete_domain_host(
         self,
         *,
         domain: str,
         name: str,
     ) -> Host:
         """
-        Delete domain hostname
+        Delete a domain's hostname.
+        Delete a domain's hostname.
         :param domain:
         :param name:
         :return: :class:`Host <Host>`
 
         Usage:
         ::
```

### Comparing `scaleway_async-0.9.0/scaleway_async/domain/v2beta1/content.py` & `scaleway_async-1.0.0/scaleway_async/domain/v2beta1/content.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-0.9.0/scaleway_async/domain/v2beta1/marshalling.py` & `scaleway_async-1.0.0/scaleway_async/domain/v2beta1/marshalling.py`

 * *Files 18% similar despite different names*

```diff
@@ -129,38 +129,38 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'DomainRecordGeoIPConfigMatch' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("continents")
+    field = data.get("continents", None)
     args["continents"] = field
 
-    field = data.get("countries")
+    field = data.get("countries", None)
     args["countries"] = field
 
-    field = data.get("data")
+    field = data.get("data", None)
     args["data"] = field
 
     return DomainRecordGeoIPConfigMatch(**args)
 
 
 def unmarshal_DomainRecordViewConfigView(data: Any) -> DomainRecordViewConfigView:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'DomainRecordViewConfigView' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("data")
+    field = data.get("data", None)
     args["data"] = field
 
-    field = data.get("subnet")
+    field = data.get("subnet", None)
     args["subnet"] = field
 
     return DomainRecordViewConfigView(**args)
 
 
 def unmarshal_DomainRecordWeightedConfigWeightedIP(
     data: Any,
@@ -168,18 +168,18 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'DomainRecordWeightedConfigWeightedIP' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("ip")
+    field = data.get("ip", None)
     args["ip"] = field
 
-    field = data.get("weight")
+    field = data.get("weight", None)
     args["weight"] = field
 
     return DomainRecordWeightedConfigWeightedIP(**args)
 
 
 def unmarshal_ContactExtensionFRAssociationInfo(
     data: Any,
@@ -187,18 +187,18 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ContactExtensionFRAssociationInfo' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("publication_jo")
+    field = data.get("publication_jo", None)
     args["publication_jo"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("publication_jo_page")
+    field = data.get("publication_jo_page", None)
     args["publication_jo_page"] = field
 
     return ContactExtensionFRAssociationInfo(**args)
 
 
 def unmarshal_ContactExtensionFRCodeAuthAfnicInfo(
     data: Any,
@@ -206,32 +206,32 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ContactExtensionFRCodeAuthAfnicInfo' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("code_auth_afnic")
+    field = data.get("code_auth_afnic", None)
     args["code_auth_afnic"] = field
 
     return ContactExtensionFRCodeAuthAfnicInfo(**args)
 
 
 def unmarshal_ContactExtensionFRDunsInfo(data: Any) -> ContactExtensionFRDunsInfo:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ContactExtensionFRDunsInfo' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("duns_id")
+    field = data.get("duns_id", None)
     args["duns_id"] = field
 
-    field = data.get("local_id")
+    field = data.get("local_id", None)
     args["local_id"] = field
 
     return ContactExtensionFRDunsInfo(**args)
 
 
 def unmarshal_ContactExtensionFRIndividualInfo(
     data: Any,
@@ -239,15 +239,15 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ContactExtensionFRIndividualInfo' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("whois_opt_in")
+    field = data.get("whois_opt_in", None)
     args["whois_opt_in"] = field
 
     return ContactExtensionFRIndividualInfo(**args)
 
 
 def unmarshal_ContactExtensionFRTrademarkInfo(
     data: Any,
@@ -255,159 +255,167 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ContactExtensionFRTrademarkInfo' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("trademark_inpi")
+    field = data.get("trademark_inpi", None)
     args["trademark_inpi"] = field
 
     return ContactExtensionFRTrademarkInfo(**args)
 
 
 def unmarshal_DSRecordPublicKey(data: Any) -> DSRecordPublicKey:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'DSRecordPublicKey' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("key")
+    field = data.get("key", None)
     args["key"] = field
 
     return DSRecordPublicKey(**args)
 
 
 def unmarshal_DomainRecordGeoIPConfig(data: Any) -> DomainRecordGeoIPConfig:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'DomainRecordGeoIPConfig' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("default")
+    field = data.get("default", None)
     args["default"] = field
 
-    field = data.get("matches")
-    args["matches"] = [
-        unmarshal_DomainRecordGeoIPConfigMatch(v) for v in data["matches"]
-    ]
+    field = data.get("matches", None)
+    args["matches"] = (
+        [unmarshal_DomainRecordGeoIPConfigMatch(v) for v in field]
+        if field is not None
+        else None
+    )
 
     return DomainRecordGeoIPConfig(**args)
 
 
 def unmarshal_DomainRecordHTTPServiceConfig(data: Any) -> DomainRecordHTTPServiceConfig:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'DomainRecordHTTPServiceConfig' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("ips")
+    field = data.get("ips", None)
     args["ips"] = field
 
-    field = data.get("must_contain")
+    field = data.get("must_contain", None)
     args["must_contain"] = field
 
-    field = data.get("strategy")
+    field = data.get("strategy", None)
     args["strategy"] = field
 
-    field = data.get("url")
+    field = data.get("url", None)
     args["url"] = field
 
-    field = data.get("user_agent")
+    field = data.get("user_agent", None)
     args["user_agent"] = field
 
     return DomainRecordHTTPServiceConfig(**args)
 
 
 def unmarshal_DomainRecordViewConfig(data: Any) -> DomainRecordViewConfig:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'DomainRecordViewConfig' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("views")
-    args["views"] = [unmarshal_DomainRecordViewConfigView(v) for v in data["views"]]
+    field = data.get("views", None)
+    args["views"] = (
+        [unmarshal_DomainRecordViewConfigView(v) for v in field]
+        if field is not None
+        else None
+    )
 
     return DomainRecordViewConfig(**args)
 
 
 def unmarshal_DomainRecordWeightedConfig(data: Any) -> DomainRecordWeightedConfig:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'DomainRecordWeightedConfig' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("weighted_ips")
-    args["weighted_ips"] = [
-        unmarshal_DomainRecordWeightedConfigWeightedIP(v) for v in data["weighted_ips"]
-    ]
+    field = data.get("weighted_ips", None)
+    args["weighted_ips"] = (
+        [unmarshal_DomainRecordWeightedConfigWeightedIP(v) for v in field]
+        if field is not None
+        else None
+    )
 
     return DomainRecordWeightedConfig(**args)
 
 
 def unmarshal_ContactExtensionEU(data: Any) -> ContactExtensionEU:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ContactExtensionEU' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("european_citizenship")
+    field = data.get("european_citizenship", None)
     args["european_citizenship"] = field
 
     return ContactExtensionEU(**args)
 
 
 def unmarshal_ContactExtensionFR(data: Any) -> ContactExtensionFR:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ContactExtensionFR' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("association_info")
+    field = data.get("association_info", None)
     args["association_info"] = (
         unmarshal_ContactExtensionFRAssociationInfo(field)
         if field is not None
         else None
     )
 
-    field = data.get("code_auth_afnic_info")
+    field = data.get("code_auth_afnic_info", None)
     args["code_auth_afnic_info"] = (
         unmarshal_ContactExtensionFRCodeAuthAfnicInfo(field)
         if field is not None
         else None
     )
 
-    field = data.get("duns_info")
+    field = data.get("duns_info", None)
     args["duns_info"] = (
         unmarshal_ContactExtensionFRDunsInfo(field) if field is not None else None
     )
 
-    field = data.get("individual_info")
+    field = data.get("individual_info", None)
     args["individual_info"] = (
         unmarshal_ContactExtensionFRIndividualInfo(field) if field is not None else None
     )
 
-    field = data.get("mode")
+    field = data.get("mode", None)
     args["mode"] = field
 
-    field = data.get("trademark_info")
+    field = data.get("trademark_info", None)
     args["trademark_info"] = (
         unmarshal_ContactExtensionFRTrademarkInfo(field) if field is not None else None
     )
 
     return ContactExtensionFR(**args)
 
 
@@ -415,107 +423,107 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ContactExtensionNL' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("legal_form")
+    field = data.get("legal_form", None)
     args["legal_form"] = field
 
-    field = data.get("legal_form_registration_number")
+    field = data.get("legal_form_registration_number", None)
     args["legal_form_registration_number"] = field
 
     return ContactExtensionNL(**args)
 
 
 def unmarshal_ContactQuestion(data: Any) -> ContactQuestion:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ContactQuestion' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("answer")
+    field = data.get("answer", None)
     args["answer"] = field
 
-    field = data.get("question")
+    field = data.get("question", None)
     args["question"] = field
 
     return ContactQuestion(**args)
 
 
 def unmarshal_DSRecordDigest(data: Any) -> DSRecordDigest:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'DSRecordDigest' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("digest")
+    field = data.get("digest", None)
     args["digest"] = field
 
-    field = data.get("public_key")
+    field = data.get("public_key", None)
     args["public_key"] = (
         unmarshal_DSRecordPublicKey(field) if field is not None else None
     )
 
-    field = data.get("type_")
+    field = data.get("type", None)
     args["type_"] = field
 
     return DSRecordDigest(**args)
 
 
 def unmarshal_DomainRecord(data: Any) -> DomainRecord:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'DomainRecord' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("comment")
+    field = data.get("comment", None)
     args["comment"] = field
 
-    field = data.get("data")
+    field = data.get("data", None)
     args["data"] = field
 
-    field = data.get("geo_ip_config")
+    field = data.get("geo_ip_config", None)
     args["geo_ip_config"] = (
         unmarshal_DomainRecordGeoIPConfig(field) if field is not None else None
     )
 
-    field = data.get("http_service_config")
+    field = data.get("http_service_config", None)
     args["http_service_config"] = (
         unmarshal_DomainRecordHTTPServiceConfig(field) if field is not None else None
     )
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("priority")
+    field = data.get("priority", None)
     args["priority"] = field
 
-    field = data.get("ttl")
+    field = data.get("ttl", None)
     args["ttl"] = field
 
-    field = data.get("type_")
+    field = data.get("type", None)
     args["type_"] = field
 
-    field = data.get("view_config")
+    field = data.get("view_config", None)
     args["view_config"] = (
         unmarshal_DomainRecordViewConfig(field) if field is not None else None
     )
 
-    field = data.get("weighted_config")
+    field = data.get("weighted_config", None)
     args["weighted_config"] = (
         unmarshal_DomainRecordWeightedConfig(field) if field is not None else None
     )
 
     return DomainRecord(**args)
 
 
@@ -523,183 +531,181 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'RecordIdentifier' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("data")
+    field = data.get("data", None)
     args["data"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("ttl")
+    field = data.get("ttl", None)
     args["ttl"] = field
 
-    field = data.get("type_")
+    field = data.get("type", None)
     args["type_"] = field
 
     return RecordIdentifier(**args)
 
 
 def unmarshal_TldOffer(data: Any) -> TldOffer:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'TldOffer' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("action")
+    field = data.get("action", None)
     args["action"] = field
 
-    field = data.get("operation_path")
+    field = data.get("operation_path", None)
     args["operation_path"] = field
 
-    field = data.get("price")
+    field = data.get("price", None)
     args["price"] = unmarshal_Money(field) if field is not None else None
 
     return TldOffer(**args)
 
 
 def unmarshal_Contact(data: Any) -> Contact:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Contact' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("address_line_1")
+    field = data.get("address_line_1", None)
     args["address_line_1"] = field
 
-    field = data.get("address_line_2")
+    field = data.get("address_line_2", None)
     args["address_line_2"] = field
 
-    field = data.get("city")
+    field = data.get("city", None)
     args["city"] = field
 
-    field = data.get("company_identification_code")
+    field = data.get("company_identification_code", None)
     args["company_identification_code"] = field
 
-    field = data.get("company_name")
+    field = data.get("company_name", None)
     args["company_name"] = field
 
-    field = data.get("country")
+    field = data.get("country", None)
     args["country"] = field
 
-    field = data.get("email")
+    field = data.get("email", None)
     args["email"] = field
 
-    field = data.get("email_alt")
+    field = data.get("email_alt", None)
     args["email_alt"] = field
 
-    field = data.get("email_status")
+    field = data.get("email_status", None)
     args["email_status"] = field
 
-    field = data.get("extension_eu")
+    field = data.get("extension_eu", None)
     args["extension_eu"] = (
         unmarshal_ContactExtensionEU(field) if field is not None else None
     )
 
-    field = data.get("extension_fr")
+    field = data.get("extension_fr", None)
     args["extension_fr"] = (
         unmarshal_ContactExtensionFR(field) if field is not None else None
     )
 
-    field = data.get("extension_nl")
+    field = data.get("extension_nl", None)
     args["extension_nl"] = (
         unmarshal_ContactExtensionNL(field) if field is not None else None
     )
 
-    field = data.get("fax_number")
+    field = data.get("fax_number", None)
     args["fax_number"] = field
 
-    field = data.get("firstname")
+    field = data.get("firstname", None)
     args["firstname"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("lang")
+    field = data.get("lang", None)
     args["lang"] = field
 
-    field = data.get("lastname")
+    field = data.get("lastname", None)
     args["lastname"] = field
 
-    field = data.get("legal_form")
+    field = data.get("legal_form", None)
     args["legal_form"] = field
 
-    field = data.get("phone_number")
+    field = data.get("phone_number", None)
     args["phone_number"] = field
 
-    field = data.get("questions")
+    field = data.get("questions", None)
     args["questions"] = (
-        [unmarshal_ContactQuestion(v) for v in data["questions"]]
-        if field is not None
-        else None
+        [unmarshal_ContactQuestion(v) for v in field] if field is not None else None
     )
 
-    field = data.get("resale")
+    field = data.get("resale", None)
     args["resale"] = field
 
-    field = data.get("state")
+    field = data.get("state", None)
     args["state"] = field
 
-    field = data.get("vat_identification_code")
+    field = data.get("vat_identification_code", None)
     args["vat_identification_code"] = field
 
-    field = data.get("whois_opt_in")
+    field = data.get("whois_opt_in", None)
     args["whois_opt_in"] = field
 
-    field = data.get("zip")
+    field = data.get("zip", None)
     args["zip"] = field
 
     return Contact(**args)
 
 
 def unmarshal_ContactRolesRoles(data: Any) -> ContactRolesRoles:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ContactRolesRoles' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("is_administrative")
+    field = data.get("is_administrative", None)
     args["is_administrative"] = field
 
-    field = data.get("is_owner")
+    field = data.get("is_owner", None)
     args["is_owner"] = field
 
-    field = data.get("is_technical")
+    field = data.get("is_technical", None)
     args["is_technical"] = field
 
     return ContactRolesRoles(**args)
 
 
 def unmarshal_DSRecord(data: Any) -> DSRecord:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'DSRecord' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("algorithm")
+    field = data.get("algorithm", None)
     args["algorithm"] = field
 
-    field = data.get("digest")
+    field = data.get("digest", None)
     args["digest"] = unmarshal_DSRecordDigest(field) if field is not None else None
 
-    field = data.get("key_id")
+    field = data.get("key_id", None)
     args["key_id"] = field
 
-    field = data.get("public_key")
+    field = data.get("public_key", None)
     args["public_key"] = (
         unmarshal_DSRecordPublicKey(field) if field is not None else None
     )
 
     return DSRecord(**args)
 
 
@@ -709,15 +715,15 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'DomainRegistrationStatusExternalDomain' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("validation_token")
+    field = data.get("validation_token", None)
     args["validation_token"] = field
 
     return DomainRegistrationStatusExternalDomain(**args)
 
 
 def unmarshal_DomainRegistrationStatusTransfer(
     data: Any,
@@ -725,36 +731,38 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'DomainRegistrationStatusTransfer' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("vote_current_owner")
+    field = data.get("vote_current_owner", None)
     args["vote_current_owner"] = field
 
-    field = data.get("vote_new_owner")
+    field = data.get("vote_new_owner", None)
     args["vote_new_owner"] = field
 
     return DomainRegistrationStatusTransfer(**args)
 
 
 def unmarshal_RecordChangeAdd(data: Any) -> RecordChangeAdd:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'RecordChangeAdd' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("records")
-    args["records"] = [unmarshal_DomainRecord(v) for v in data["records"]]
+    field = data.get("records", None)
+    args["records"] = (
+        [unmarshal_DomainRecord(v) for v in field] if field is not None else None
+    )
 
     return RecordChangeAdd(**args)
 
 
 def unmarshal_RecordChangeClear(data: Any) -> RecordChangeClear:
     if type(data) is not dict:
         raise TypeError(
@@ -770,90 +778,96 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'RecordChangeDelete' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("id_fields")
+    field = data.get("id_fields", None)
     args["id_fields"] = unmarshal_RecordIdentifier(field) if field is not None else None
 
     return RecordChangeDelete(**args)
 
 
 def unmarshal_RecordChangeSet(data: Any) -> RecordChangeSet:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'RecordChangeSet' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("id_fields")
+    field = data.get("id_fields", None)
     args["id_fields"] = unmarshal_RecordIdentifier(field) if field is not None else None
 
-    field = data.get("records")
-    args["records"] = [unmarshal_DomainRecord(v) for v in data["records"]]
+    field = data.get("records", None)
+    args["records"] = (
+        [unmarshal_DomainRecord(v) for v in field] if field is not None else None
+    )
 
     return RecordChangeSet(**args)
 
 
 def unmarshal_Tld(data: Any) -> Tld:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Tld' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("dnssec_support")
+    field = data.get("dnssec_support", None)
     args["dnssec_support"] = field
 
-    field = data.get("duration_in_years_max")
+    field = data.get("duration_in_years_max", None)
     args["duration_in_years_max"] = field
 
-    field = data.get("duration_in_years_min")
+    field = data.get("duration_in_years_min", None)
     args["duration_in_years_min"] = field
 
-    field = data.get("idn_support")
+    field = data.get("idn_support", None)
     args["idn_support"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("offers")
-    args["offers"] = {k: unmarshal_TldOffer(v) for k, v in data["offers"].items()}
+    field = data.get("offers", None)
+    args["offers"] = (
+        {k: unmarshal_TldOffer(v) for k, v in field.items()}
+        if field is not None
+        else None
+    )
 
-    field = data.get("specifications")
+    field = data.get("specifications", None)
     args["specifications"] = field
 
     return Tld(**args)
 
 
 def unmarshal_AvailableDomain(data: Any) -> AvailableDomain:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'AvailableDomain' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("available")
+    field = data.get("available", None)
     args["available"] = field
 
-    field = data.get("domain")
+    field = data.get("domain", None)
     args["domain"] = field
 
-    field = data.get("tld")
+    field = data.get("tld", None)
     args["tld"] = unmarshal_Tld(field) if field is not None else None
 
     return AvailableDomain(**args)
 
 
 def unmarshal_CheckContactsCompatibilityResponseContactCheckResult(
     data: Any,
@@ -861,343 +875,347 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'CheckContactsCompatibilityResponseContactCheckResult' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("compatible")
+    field = data.get("compatible", None)
     args["compatible"] = field
 
-    field = data.get("error_message")
+    field = data.get("error_message", None)
     args["error_message"] = field
 
     return CheckContactsCompatibilityResponseContactCheckResult(**args)
 
 
 def unmarshal_ContactRoles(data: Any) -> ContactRoles:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ContactRoles' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("contact")
+    field = data.get("contact", None)
     args["contact"] = unmarshal_Contact(field) if field is not None else None
 
-    field = data.get("roles")
-    args["roles"] = {
-        k: unmarshal_ContactRolesRoles(v) for k, v in data["roles"].items()
-    }
+    field = data.get("roles", None)
+    args["roles"] = (
+        {k: unmarshal_ContactRolesRoles(v) for k, v in field.items()}
+        if field is not None
+        else None
+    )
 
     return ContactRoles(**args)
 
 
 def unmarshal_DNSZone(data: Any) -> DNSZone:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'DNSZone' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("domain")
+    field = data.get("domain", None)
     args["domain"] = field
 
-    field = data.get("message")
+    field = data.get("message", None)
     args["message"] = field
 
-    field = data.get("ns")
+    field = data.get("ns", None)
     args["ns"] = field
 
-    field = data.get("ns_default")
+    field = data.get("ns_default", None)
     args["ns_default"] = field
 
-    field = data.get("ns_master")
+    field = data.get("ns_master", None)
     args["ns_master"] = field
 
-    field = data.get("project_id")
+    field = data.get("project_id", None)
     args["project_id"] = field
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("subdomain")
+    field = data.get("subdomain", None)
     args["subdomain"] = field
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
     return DNSZone(**args)
 
 
 def unmarshal_DNSZoneVersion(data: Any) -> DNSZoneVersion:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'DNSZoneVersion' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
     return DNSZoneVersion(**args)
 
 
 def unmarshal_DomainDNSSEC(data: Any) -> DomainDNSSEC:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'DomainDNSSEC' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("ds_records")
-    args["ds_records"] = [unmarshal_DSRecord(v) for v in data["ds_records"]]
+    field = data.get("ds_records", None)
+    args["ds_records"] = (
+        [unmarshal_DSRecord(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
     return DomainDNSSEC(**args)
 
 
 def unmarshal_DomainSummary(data: Any) -> DomainSummary:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'DomainSummary' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("auto_renew_status")
+    field = data.get("auto_renew_status", None)
     args["auto_renew_status"] = field
 
-    field = data.get("dnssec_status")
+    field = data.get("dnssec_status", None)
     args["dnssec_status"] = field
 
-    field = data.get("domain")
+    field = data.get("domain", None)
     args["domain"] = field
 
-    field = data.get("epp_code")
+    field = data.get("epp_code", None)
     args["epp_code"] = field
 
-    field = data.get("expired_at")
+    field = data.get("expired_at", None)
     args["expired_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("external_domain_registration_status")
+    field = data.get("external_domain_registration_status", None)
     args["external_domain_registration_status"] = (
         unmarshal_DomainRegistrationStatusExternalDomain(field)
         if field is not None
         else None
     )
 
-    field = data.get("is_external")
+    field = data.get("is_external", None)
     args["is_external"] = field
 
-    field = data.get("organization_id")
+    field = data.get("organization_id", None)
     args["organization_id"] = field
 
-    field = data.get("project_id")
+    field = data.get("project_id", None)
     args["project_id"] = field
 
-    field = data.get("registrar")
+    field = data.get("registrar", None)
     args["registrar"] = field
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("transfer_registration_status")
+    field = data.get("transfer_registration_status", None)
     args["transfer_registration_status"] = (
         unmarshal_DomainRegistrationStatusTransfer(field) if field is not None else None
     )
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
     return DomainSummary(**args)
 
 
 def unmarshal_Host(data: Any) -> Host:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Host' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("domain")
+    field = data.get("domain", None)
     args["domain"] = field
 
-    field = data.get("ips")
+    field = data.get("ips", None)
     args["ips"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
     return Host(**args)
 
 
 def unmarshal_Nameserver(data: Any) -> Nameserver:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Nameserver' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("ip")
+    field = data.get("ip", None)
     args["ip"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
     return Nameserver(**args)
 
 
 def unmarshal_RecordChange(data: Any) -> RecordChange:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'RecordChange' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("add")
+    field = data.get("add", None)
     args["add"] = unmarshal_RecordChangeAdd(field) if field is not None else None
 
-    field = data.get("clear")
+    field = data.get("clear", None)
     args["clear"] = unmarshal_RecordChangeClear(field) if field is not None else None
 
-    field = data.get("delete")
+    field = data.get("delete", None)
     args["delete"] = unmarshal_RecordChangeDelete(field) if field is not None else None
 
-    field = data.get("set_")
+    field = data.get("set", None)
     args["set_"] = unmarshal_RecordChangeSet(field) if field is not None else None
 
     return RecordChange(**args)
 
 
 def unmarshal_RenewableDomain(data: Any) -> RenewableDomain:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'RenewableDomain' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("domain")
+    field = data.get("domain", None)
     args["domain"] = field
 
-    field = data.get("estimated_delete_at")
+    field = data.get("estimated_delete_at", None)
     args["estimated_delete_at"] = (
         parser.isoparse(field) if type(field) is str else field
     )
 
-    field = data.get("expired_at")
+    field = data.get("expired_at", None)
     args["expired_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("limit_redemption_at")
+    field = data.get("limit_redemption_at", None)
     args["limit_redemption_at"] = (
         parser.isoparse(field) if type(field) is str else field
     )
 
-    field = data.get("limit_renew_at")
+    field = data.get("limit_renew_at", None)
     args["limit_renew_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("organization_id")
+    field = data.get("organization_id", None)
     args["organization_id"] = field
 
-    field = data.get("project_id")
+    field = data.get("project_id", None)
     args["project_id"] = field
 
-    field = data.get("renewable_duration_in_years")
+    field = data.get("renewable_duration_in_years", None)
     args["renewable_duration_in_years"] = field
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("tld")
+    field = data.get("tld", None)
     args["tld"] = unmarshal_Tld(field) if field is not None else None
 
     return RenewableDomain(**args)
 
 
 def unmarshal_SSLCertificate(data: Any) -> SSLCertificate:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'SSLCertificate' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("alternative_dns_zones")
+    field = data.get("alternative_dns_zones", None)
     args["alternative_dns_zones"] = field
 
-    field = data.get("certificate_chain")
+    field = data.get("certificate_chain", None)
     args["certificate_chain"] = field
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("dns_zone")
+    field = data.get("dns_zone", None)
     args["dns_zone"] = field
 
-    field = data.get("expired_at")
+    field = data.get("expired_at", None)
     args["expired_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("private_key")
+    field = data.get("private_key", None)
     args["private_key"] = field
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
     return SSLCertificate(**args)
 
 
 def unmarshal_Task(data: Any) -> Task:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Task' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("domain")
+    field = data.get("domain", None)
     args["domain"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("message")
+    field = data.get("message", None)
     args["message"] = field
 
-    field = data.get("organization_id")
+    field = data.get("organization_id", None)
     args["organization_id"] = field
 
-    field = data.get("project_id")
+    field = data.get("project_id", None)
     args["project_id"] = field
 
-    field = data.get("started_at")
+    field = data.get("started_at", None)
     args["started_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("type_")
+    field = data.get("type", None)
     args["type_"] = field
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
     return Task(**args)
 
 
 def unmarshal_CheckContactsCompatibilityResponse(
     data: Any,
@@ -1205,32 +1223,32 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'CheckContactsCompatibilityResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("administrative_check_result")
+    field = data.get("administrative_check_result", None)
     args["administrative_check_result"] = (
         unmarshal_CheckContactsCompatibilityResponseContactCheckResult(field)
         if field is not None
         else None
     )
 
-    field = data.get("compatible")
+    field = data.get("compatible", None)
     args["compatible"] = field
 
-    field = data.get("owner_check_result")
+    field = data.get("owner_check_result", None)
     args["owner_check_result"] = (
         unmarshal_CheckContactsCompatibilityResponseContactCheckResult(field)
         if field is not None
         else None
     )
 
-    field = data.get("technical_check_result")
+    field = data.get("technical_check_result", None)
     args["technical_check_result"] = (
         unmarshal_CheckContactsCompatibilityResponseContactCheckResult(field)
         if field is not None
         else None
     )
 
     return CheckContactsCompatibilityResponse(**args)
@@ -1284,167 +1302,177 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Domain' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("administrative_contact")
+    field = data.get("administrative_contact", None)
     args["administrative_contact"] = (
         unmarshal_Contact(field) if field is not None else None
     )
 
-    field = data.get("auto_renew_status")
+    field = data.get("auto_renew_status", None)
     args["auto_renew_status"] = field
 
-    field = data.get("dns_zones")
-    args["dns_zones"] = [unmarshal_DNSZone(v) for v in data["dns_zones"]]
+    field = data.get("dns_zones", None)
+    args["dns_zones"] = (
+        [unmarshal_DNSZone(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("dnssec")
+    field = data.get("dnssec", None)
     args["dnssec"] = unmarshal_DomainDNSSEC(field) if field is not None else None
 
-    field = data.get("domain")
+    field = data.get("domain", None)
     args["domain"] = field
 
-    field = data.get("epp_code")
+    field = data.get("epp_code", None)
     args["epp_code"] = field
 
-    field = data.get("expired_at")
+    field = data.get("expired_at", None)
     args["expired_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("external_domain_registration_status")
+    field = data.get("external_domain_registration_status", None)
     args["external_domain_registration_status"] = (
         unmarshal_DomainRegistrationStatusExternalDomain(field)
         if field is not None
         else None
     )
 
-    field = data.get("is_external")
+    field = data.get("is_external", None)
     args["is_external"] = field
 
-    field = data.get("organization_id")
+    field = data.get("organization_id", None)
     args["organization_id"] = field
 
-    field = data.get("owner_contact")
+    field = data.get("owner_contact", None)
     args["owner_contact"] = unmarshal_Contact(field) if field is not None else None
 
-    field = data.get("project_id")
+    field = data.get("project_id", None)
     args["project_id"] = field
 
-    field = data.get("registrar")
+    field = data.get("registrar", None)
     args["registrar"] = field
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("technical_contact")
+    field = data.get("technical_contact", None)
     args["technical_contact"] = unmarshal_Contact(field) if field is not None else None
 
-    field = data.get("tld")
+    field = data.get("tld", None)
     args["tld"] = unmarshal_Tld(field) if field is not None else None
 
-    field = data.get("transfer_registration_status")
+    field = data.get("transfer_registration_status", None)
     args["transfer_registration_status"] = (
         unmarshal_DomainRegistrationStatusTransfer(field) if field is not None else None
     )
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
     return Domain(**args)
 
 
 def unmarshal_GetDNSZoneTsigKeyResponse(data: Any) -> GetDNSZoneTsigKeyResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'GetDNSZoneTsigKeyResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("algorithm")
+    field = data.get("algorithm", None)
     args["algorithm"] = field
 
-    field = data.get("key")
+    field = data.get("key", None)
     args["key"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
     return GetDNSZoneTsigKeyResponse(**args)
 
 
 def unmarshal_GetDNSZoneVersionDiffResponse(data: Any) -> GetDNSZoneVersionDiffResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'GetDNSZoneVersionDiffResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("changes")
-    args["changes"] = [unmarshal_RecordChange(v) for v in data["changes"]]
+    field = data.get("changes", None)
+    args["changes"] = (
+        [unmarshal_RecordChange(v) for v in field] if field is not None else None
+    )
 
     return GetDNSZoneVersionDiffResponse(**args)
 
 
 def unmarshal_GetDomainAuthCodeResponse(data: Any) -> GetDomainAuthCodeResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'GetDomainAuthCodeResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("auth_code")
+    field = data.get("auth_code", None)
     args["auth_code"] = field
 
     return GetDomainAuthCodeResponse(**args)
 
 
 def unmarshal_ImportProviderDNSZoneResponse(data: Any) -> ImportProviderDNSZoneResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ImportProviderDNSZoneResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("records")
-    args["records"] = [unmarshal_DomainRecord(v) for v in data["records"]]
+    field = data.get("records", None)
+    args["records"] = (
+        [unmarshal_DomainRecord(v) for v in field] if field is not None else None
+    )
 
     return ImportProviderDNSZoneResponse(**args)
 
 
 def unmarshal_ImportRawDNSZoneResponse(data: Any) -> ImportRawDNSZoneResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ImportRawDNSZoneResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("records")
-    args["records"] = [unmarshal_DomainRecord(v) for v in data["records"]]
+    field = data.get("records", None)
+    args["records"] = (
+        [unmarshal_DomainRecord(v) for v in field] if field is not None else None
+    )
 
     return ImportRawDNSZoneResponse(**args)
 
 
 def unmarshal_ListContactsResponse(data: Any) -> ListContactsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListContactsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("contacts")
-    args["contacts"] = [unmarshal_ContactRoles(v) for v in data["contacts"]]
+    field = data.get("contacts", None)
+    args["contacts"] = (
+        [unmarshal_ContactRoles(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListContactsResponse(**args)
 
 
 def unmarshal_ListDNSZoneNameserversResponse(
     data: Any,
@@ -1452,32 +1480,34 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListDNSZoneNameserversResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("ns")
-    args["ns"] = [unmarshal_Nameserver(v) for v in data["ns"]]
+    field = data.get("ns", None)
+    args["ns"] = [unmarshal_Nameserver(v) for v in field] if field is not None else None
 
     return ListDNSZoneNameserversResponse(**args)
 
 
 def unmarshal_ListDNSZoneRecordsResponse(data: Any) -> ListDNSZoneRecordsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListDNSZoneRecordsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("records")
-    args["records"] = [unmarshal_DomainRecord(v) for v in data["records"]]
+    field = data.get("records", None)
+    args["records"] = (
+        [unmarshal_DomainRecord(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListDNSZoneRecordsResponse(**args)
 
 
 def unmarshal_ListDNSZoneVersionRecordsResponse(
     data: Any,
@@ -1485,205 +1515,219 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListDNSZoneVersionRecordsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("records")
-    args["records"] = [unmarshal_DomainRecord(v) for v in data["records"]]
+    field = data.get("records", None)
+    args["records"] = (
+        [unmarshal_DomainRecord(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListDNSZoneVersionRecordsResponse(**args)
 
 
 def unmarshal_ListDNSZoneVersionsResponse(data: Any) -> ListDNSZoneVersionsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListDNSZoneVersionsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    field = data.get("versions")
-    args["versions"] = [unmarshal_DNSZoneVersion(v) for v in data["versions"]]
+    field = data.get("versions", None)
+    args["versions"] = (
+        [unmarshal_DNSZoneVersion(v) for v in field] if field is not None else None
+    )
 
     return ListDNSZoneVersionsResponse(**args)
 
 
 def unmarshal_ListDNSZonesResponse(data: Any) -> ListDNSZonesResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListDNSZonesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("dns_zones")
-    args["dns_zones"] = [unmarshal_DNSZone(v) for v in data["dns_zones"]]
+    field = data.get("dns_zones", None)
+    args["dns_zones"] = (
+        [unmarshal_DNSZone(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListDNSZonesResponse(**args)
 
 
 def unmarshal_ListDomainHostsResponse(data: Any) -> ListDomainHostsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListDomainHostsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("hosts")
-    args["hosts"] = [unmarshal_Host(v) for v in data["hosts"]]
+    field = data.get("hosts", None)
+    args["hosts"] = [unmarshal_Host(v) for v in field] if field is not None else None
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListDomainHostsResponse(**args)
 
 
 def unmarshal_ListDomainsResponse(data: Any) -> ListDomainsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListDomainsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("domains")
-    args["domains"] = [unmarshal_DomainSummary(v) for v in data["domains"]]
+    field = data.get("domains", None)
+    args["domains"] = (
+        [unmarshal_DomainSummary(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListDomainsResponse(**args)
 
 
 def unmarshal_ListRenewableDomainsResponse(data: Any) -> ListRenewableDomainsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListRenewableDomainsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("domains")
-    args["domains"] = [unmarshal_RenewableDomain(v) for v in data["domains"]]
+    field = data.get("domains", None)
+    args["domains"] = (
+        [unmarshal_RenewableDomain(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListRenewableDomainsResponse(**args)
 
 
 def unmarshal_ListSSLCertificatesResponse(data: Any) -> ListSSLCertificatesResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListSSLCertificatesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("certificates")
-    args["certificates"] = [unmarshal_SSLCertificate(v) for v in data["certificates"]]
+    field = data.get("certificates", None)
+    args["certificates"] = (
+        [unmarshal_SSLCertificate(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListSSLCertificatesResponse(**args)
 
 
 def unmarshal_ListTasksResponse(data: Any) -> ListTasksResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListTasksResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("tasks")
-    args["tasks"] = [unmarshal_Task(v) for v in data["tasks"]]
+    field = data.get("tasks", None)
+    args["tasks"] = [unmarshal_Task(v) for v in field] if field is not None else None
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListTasksResponse(**args)
 
 
 def unmarshal_OrderResponse(data: Any) -> OrderResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'OrderResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("domains")
+    field = data.get("domains", None)
     args["domains"] = field
 
-    field = data.get("organization_id")
+    field = data.get("organization_id", None)
     args["organization_id"] = field
 
-    field = data.get("project_id")
+    field = data.get("project_id", None)
     args["project_id"] = field
 
-    field = data.get("task_id")
+    field = data.get("task_id", None)
     args["task_id"] = field
 
     return OrderResponse(**args)
 
 
 def unmarshal_RefreshDNSZoneResponse(data: Any) -> RefreshDNSZoneResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'RefreshDNSZoneResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("dns_zones")
-    args["dns_zones"] = [unmarshal_DNSZone(v) for v in data["dns_zones"]]
+    field = data.get("dns_zones", None)
+    args["dns_zones"] = (
+        [unmarshal_DNSZone(v) for v in field] if field is not None else None
+    )
 
     return RefreshDNSZoneResponse(**args)
 
 
 def unmarshal_RegisterExternalDomainResponse(
     data: Any,
 ) -> RegisterExternalDomainResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'RegisterExternalDomainResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("domain")
+    field = data.get("domain", None)
     args["domain"] = field
 
-    field = data.get("organization_id")
+    field = data.get("organization_id", None)
     args["organization_id"] = field
 
-    field = data.get("project_id")
+    field = data.get("project_id", None)
     args["project_id"] = field
 
-    field = data.get("validation_token")
+    field = data.get("validation_token", None)
     args["validation_token"] = field
 
     return RegisterExternalDomainResponse(**args)
 
 
 def unmarshal_RestoreDNSZoneVersionResponse(data: Any) -> RestoreDNSZoneVersionResponse:
     if type(data) is not dict:
@@ -1702,796 +1746,1403 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'SearchAvailableDomainsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("available_domains")
-    args["available_domains"] = [
-        unmarshal_AvailableDomain(v) for v in data["available_domains"]
-    ]
+    field = data.get("available_domains", None)
+    args["available_domains"] = (
+        [unmarshal_AvailableDomain(v) for v in field] if field is not None else None
+    )
 
     return SearchAvailableDomainsResponse(**args)
 
 
 def unmarshal_UpdateDNSZoneNameserversResponse(
     data: Any,
 ) -> UpdateDNSZoneNameserversResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'UpdateDNSZoneNameserversResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("ns")
-    args["ns"] = [unmarshal_Nameserver(v) for v in data["ns"]]
+    field = data.get("ns", None)
+    args["ns"] = [unmarshal_Nameserver(v) for v in field] if field is not None else None
 
     return UpdateDNSZoneNameserversResponse(**args)
 
 
 def unmarshal_UpdateDNSZoneRecordsResponse(data: Any) -> UpdateDNSZoneRecordsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'UpdateDNSZoneRecordsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("records")
-    args["records"] = [unmarshal_DomainRecord(v) for v in data["records"]]
+    field = data.get("records", None)
+    args["records"] = (
+        [unmarshal_DomainRecord(v) for v in field] if field is not None else None
+    )
 
     return UpdateDNSZoneRecordsResponse(**args)
 
 
 def marshal_DomainRecordGeoIPConfigMatch(
     request: DomainRecordGeoIPConfigMatch,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "continents": request.continents,
-        "countries": request.countries,
-        "data": request.data,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.continents is not None:
+        output["continents"] = request.continents
+
+    if request.countries is not None:
+        output["countries"] = request.countries
+
+    if request.data is not None:
+        output["data"] = request.data
+
+    return output
 
 
 def marshal_DomainRecordViewConfigView(
     request: DomainRecordViewConfigView,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "data": request.data,
-        "subnet": request.subnet,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.data is not None:
+        output["data"] = request.data
+
+    if request.subnet is not None:
+        output["subnet"] = request.subnet
+
+    return output
 
 
 def marshal_DomainRecordWeightedConfigWeightedIP(
     request: DomainRecordWeightedConfigWeightedIP,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "ip": request.ip,
-        "weight": request.weight,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.ip is not None:
+        output["ip"] = request.ip
+
+    if request.weight is not None:
+        output["weight"] = request.weight
+
+    return output
 
 
 def marshal_DomainRecordGeoIPConfig(
     request: DomainRecordGeoIPConfig,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "default": request.default,
-        "matches": [
+    output: Dict[str, Any] = {}
+
+    if request.default is not None:
+        output["default"] = request.default
+
+    if request.matches is not None:
+        output["matches"] = [
             marshal_DomainRecordGeoIPConfigMatch(v, defaults) for v in request.matches
-        ],
-    }
+        ]
+
+    return output
 
 
 def marshal_DomainRecordHTTPServiceConfig(
     request: DomainRecordHTTPServiceConfig,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "ips": request.ips,
-        "must_contain": request.must_contain,
-        "strategy": DomainRecordHTTPServiceConfigStrategy(request.strategy),
-        "url": request.url,
-        "user_agent": request.user_agent,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.ips is not None:
+        output["ips"] = request.ips
+
+    if request.must_contain is not None:
+        output["must_contain"] = request.must_contain
+
+    if request.strategy is not None:
+        output["strategy"] = DomainRecordHTTPServiceConfigStrategy(request.strategy)
+
+    if request.url is not None:
+        output["url"] = request.url
+
+    if request.user_agent is not None:
+        output["user_agent"] = request.user_agent
+
+    return output
 
 
 def marshal_DomainRecordViewConfig(
     request: DomainRecordViewConfig,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "views": [
+    output: Dict[str, Any] = {}
+
+    if request.views is not None:
+        output["views"] = [
             marshal_DomainRecordViewConfigView(v, defaults) for v in request.views
-        ],
-    }
+        ]
+
+    return output
 
 
 def marshal_DomainRecordWeightedConfig(
     request: DomainRecordWeightedConfig,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "weighted_ips": [
+    output: Dict[str, Any] = {}
+
+    if request.weighted_ips is not None:
+        output["weighted_ips"] = [
             marshal_DomainRecordWeightedConfigWeightedIP(v, defaults)
             for v in request.weighted_ips
-        ],
-    }
+        ]
+
+    return output
 
 
 def marshal_ContactExtensionFRAssociationInfo(
     request: ContactExtensionFRAssociationInfo,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "publication_jo": request.publication_jo,
-        "publication_jo_page": request.publication_jo_page,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.publication_jo is not None:
+        output["publication_jo"] = request.publication_jo
+
+    if request.publication_jo_page is not None:
+        output["publication_jo_page"] = request.publication_jo_page
+
+    return output
 
 
 def marshal_ContactExtensionFRCodeAuthAfnicInfo(
     request: ContactExtensionFRCodeAuthAfnicInfo,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "code_auth_afnic": request.code_auth_afnic,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.code_auth_afnic is not None:
+        output["code_auth_afnic"] = request.code_auth_afnic
+
+    return output
 
 
 def marshal_ContactExtensionFRDunsInfo(
     request: ContactExtensionFRDunsInfo,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "duns_id": request.duns_id,
-        "local_id": request.local_id,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.duns_id is not None:
+        output["duns_id"] = request.duns_id
+
+    if request.local_id is not None:
+        output["local_id"] = request.local_id
+
+    return output
 
 
 def marshal_ContactExtensionFRIndividualInfo(
     request: ContactExtensionFRIndividualInfo,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "whois_opt_in": request.whois_opt_in,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.whois_opt_in is not None:
+        output["whois_opt_in"] = request.whois_opt_in
+
+    return output
 
 
 def marshal_ContactExtensionFRTrademarkInfo(
     request: ContactExtensionFRTrademarkInfo,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "trademark_inpi": request.trademark_inpi,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.trademark_inpi is not None:
+        output["trademark_inpi"] = request.trademark_inpi
+
+    return output
 
 
 def marshal_DSRecordPublicKey(
     request: DSRecordPublicKey,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "key": request.key,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.key is not None:
+        output["key"] = request.key
+
+    return output
 
 
 def marshal_DomainRecord(
     request: DomainRecord,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("geo_ip_config", request.geo_ip_config),
-                OneOfPossibility("http_service_config", request.http_service_config),
-                OneOfPossibility("weighted_config", request.weighted_config),
-                OneOfPossibility("view_config", request.view_config),
-            ]
-        ),
-        "comment": request.comment,
-        "data": request.data,
-        "id": request.id,
-        "name": request.name,
-        "priority": request.priority,
-        "ttl": request.ttl,
-        "type": DomainRecordType(request.type_),
-    }
+                OneOfPossibility(
+                    "geo_ip_config",
+                    marshal_DomainRecordGeoIPConfig(request.geo_ip_config, defaults)
+                    if request.geo_ip_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "http_service_config",
+                    marshal_DomainRecordHTTPServiceConfig(
+                        request.http_service_config, defaults
+                    )
+                    if request.http_service_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "weighted_config",
+                    marshal_DomainRecordWeightedConfig(
+                        request.weighted_config, defaults
+                    )
+                    if request.weighted_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "view_config",
+                    marshal_DomainRecordViewConfig(request.view_config, defaults)
+                    if request.view_config is not None
+                    else None,
+                ),
+            ]
+        ),
+    )
+
+    if request.comment is not None:
+        output["comment"] = request.comment
+
+    if request.data is not None:
+        output["data"] = request.data
+
+    if request.id is not None:
+        output["id"] = request.id
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.priority is not None:
+        output["priority"] = request.priority
+
+    if request.ttl is not None:
+        output["ttl"] = request.ttl
+
+    if request.type_ is not None:
+        output["type"] = DomainRecordType(request.type_)
+
+    return output
 
 
 def marshal_RecordIdentifier(
     request: RecordIdentifier,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "data": request.data,
-        "name": request.name,
-        "ttl": request.ttl,
-        "type": DomainRecordType(request.type_),
-    }
+    output: Dict[str, Any] = {}
+
+    if request.data is not None:
+        output["data"] = request.data
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.ttl is not None:
+        output["ttl"] = request.ttl
+
+    if request.type_ is not None:
+        output["type"] = DomainRecordType(request.type_)
+
+    return output
 
 
 def marshal_ContactExtensionEU(
     request: ContactExtensionEU,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "european_citizenship": request.european_citizenship,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.european_citizenship is not None:
+        output["european_citizenship"] = request.european_citizenship
+
+    return output
 
 
 def marshal_ContactExtensionFR(
     request: ContactExtensionFR,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("individual_info", request.individual_info),
-                OneOfPossibility("duns_info", request.duns_info),
-                OneOfPossibility("association_info", request.association_info),
-                OneOfPossibility("trademark_info", request.trademark_info),
-                OneOfPossibility("code_auth_afnic_info", request.code_auth_afnic_info),
+                OneOfPossibility(
+                    "individual_info",
+                    marshal_ContactExtensionFRIndividualInfo(
+                        request.individual_info, defaults
+                    )
+                    if request.individual_info is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "duns_info",
+                    marshal_ContactExtensionFRDunsInfo(request.duns_info, defaults)
+                    if request.duns_info is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "association_info",
+                    marshal_ContactExtensionFRAssociationInfo(
+                        request.association_info, defaults
+                    )
+                    if request.association_info is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "trademark_info",
+                    marshal_ContactExtensionFRTrademarkInfo(
+                        request.trademark_info, defaults
+                    )
+                    if request.trademark_info is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "code_auth_afnic_info",
+                    marshal_ContactExtensionFRCodeAuthAfnicInfo(
+                        request.code_auth_afnic_info, defaults
+                    )
+                    if request.code_auth_afnic_info is not None
+                    else None,
+                ),
             ]
         ),
-        "mode": ContactExtensionFRMode(request.mode),
-    }
+    )
+
+    if request.mode is not None:
+        output["mode"] = ContactExtensionFRMode(request.mode)
+
+    return output
 
 
 def marshal_ContactExtensionNL(
     request: ContactExtensionNL,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "legal_form": ContactExtensionNLLegalForm(request.legal_form),
-        "legal_form_registration_number": request.legal_form_registration_number,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.legal_form is not None:
+        output["legal_form"] = ContactExtensionNLLegalForm(request.legal_form)
+
+    if request.legal_form_registration_number is not None:
+        output[
+            "legal_form_registration_number"
+        ] = request.legal_form_registration_number
+
+    return output
 
 
 def marshal_ContactQuestion(
     request: ContactQuestion,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "answer": request.answer,
-        "question": request.question,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.answer is not None:
+        output["answer"] = request.answer
+
+    if request.question is not None:
+        output["question"] = request.question
+
+    return output
 
 
 def marshal_DSRecordDigest(
     request: DSRecordDigest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "digest": request.digest,
-        "public_key": marshal_DSRecordPublicKey(request.public_key, defaults)
-        if request.public_key is not None
-        else None,
-        "type": DSRecordDigestType(request.type_),
-    }
+    output: Dict[str, Any] = {}
+
+    if request.digest is not None:
+        output["digest"] = request.digest
+
+    if request.public_key is not None:
+        output["public_key"] = marshal_DSRecordPublicKey(request.public_key, defaults)
+
+    if request.type_ is not None:
+        output["type"] = DSRecordDigestType(request.type_)
+
+    return output
 
 
 def marshal_ImportRawDNSZoneRequestTsigKey(
     request: ImportRawDNSZoneRequestTsigKey,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "algorithm": request.algorithm,
-        "key": request.key,
-        "name": request.name,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.algorithm is not None:
+        output["algorithm"] = request.algorithm
+
+    if request.key is not None:
+        output["key"] = request.key
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
 
 
 def marshal_RecordChangeAdd(
     request: RecordChangeAdd,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "records": [marshal_DomainRecord(v, defaults) for v in request.records],
-    }
+    output: Dict[str, Any] = {}
+
+    if request.records is not None:
+        output["records"] = [marshal_DomainRecord(v, defaults) for v in request.records]
+
+    return output
 
 
 def marshal_RecordChangeClear(
     request: RecordChangeClear,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {}
+    output: Dict[str, Any] = {}
+
+    return output
 
 
 def marshal_RecordChangeDelete(
     request: RecordChangeDelete,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("id", request.id),
-                OneOfPossibility("id_fields", request.id_fields),
+                OneOfPossibility("id", request.id if request.id is not None else None),
+                OneOfPossibility(
+                    "id_fields",
+                    marshal_RecordIdentifier(request.id_fields, defaults)
+                    if request.id_fields is not None
+                    else None,
+                ),
             ]
         ),
-    }
+    )
+
+    return output
 
 
 def marshal_RecordChangeSet(
     request: RecordChangeSet,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("id", request.id),
-                OneOfPossibility("id_fields", request.id_fields),
+                OneOfPossibility("id", request.id if request.id is not None else None),
+                OneOfPossibility(
+                    "id_fields",
+                    marshal_RecordIdentifier(request.id_fields, defaults)
+                    if request.id_fields is not None
+                    else None,
+                ),
             ]
         ),
-        "records": [marshal_DomainRecord(v, defaults) for v in request.records],
-    }
+    )
+
+    if request.records is not None:
+        output["records"] = [marshal_DomainRecord(v, defaults) for v in request.records]
+
+    return output
 
 
 def marshal_DSRecord(
     request: DSRecord,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("digest", request.digest),
-                OneOfPossibility("public_key", request.public_key),
+                OneOfPossibility(
+                    "digest",
+                    marshal_DSRecordDigest(request.digest, defaults)
+                    if request.digest is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "public_key",
+                    marshal_DSRecordPublicKey(request.public_key, defaults)
+                    if request.public_key is not None
+                    else None,
+                ),
             ]
         ),
-        "algorithm": DSRecordAlgorithm(request.algorithm),
-        "key_id": request.key_id,
-    }
+    )
+
+    if request.algorithm is not None:
+        output["algorithm"] = DSRecordAlgorithm(request.algorithm)
+
+    if request.key_id is not None:
+        output["key_id"] = request.key_id
+
+    return output
 
 
 def marshal_ImportProviderDNSZoneRequestOnlineV1(
     request: ImportProviderDNSZoneRequestOnlineV1,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "token": request.token,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.token is not None:
+        output["token"] = request.token
+
+    return output
 
 
 def marshal_ImportRawDNSZoneRequestAXFRSource(
     request: ImportRawDNSZoneRequestAXFRSource,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "name_server": request.name_server,
-        "tsig_key": marshal_ImportRawDNSZoneRequestTsigKey(request.tsig_key, defaults)
-        if request.tsig_key is not None
-        else None,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.name_server is not None:
+        output["name_server"] = request.name_server
+
+    if request.tsig_key is not None:
+        output["tsig_key"] = marshal_ImportRawDNSZoneRequestTsigKey(
+            request.tsig_key, defaults
+        )
+
+    return output
 
 
 def marshal_ImportRawDNSZoneRequestBindSource(
     request: ImportRawDNSZoneRequestBindSource,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "content": request.content,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.content is not None:
+        output["content"] = request.content
+
+    return output
 
 
 def marshal_Nameserver(
     request: Nameserver,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "ip": request.ip,
-        "name": request.name,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.ip is not None:
+        output["ip"] = request.ip
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
 
 
 def marshal_NewContact(
     request: NewContact,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "address_line_1": request.address_line_1,
-        "address_line_2": request.address_line_2,
-        "city": request.city,
-        "company_identification_code": request.company_identification_code,
-        "company_name": request.company_name,
-        "country": request.country,
-        "email": request.email,
-        "email_alt": request.email_alt,
-        "extension_eu": marshal_ContactExtensionEU(request.extension_eu, defaults)
-        if request.extension_eu is not None
-        else None,
-        "extension_fr": marshal_ContactExtensionFR(request.extension_fr, defaults)
-        if request.extension_fr is not None
-        else None,
-        "extension_nl": marshal_ContactExtensionNL(request.extension_nl, defaults)
-        if request.extension_nl is not None
-        else None,
-        "fax_number": request.fax_number,
-        "firstname": request.firstname,
-        "lang": LanguageCode(request.lang),
-        "lastname": request.lastname,
-        "legal_form": ContactLegalForm(request.legal_form),
-        "phone_number": request.phone_number,
-        "questions": [marshal_ContactQuestion(v, defaults) for v in request.questions]
-        if request.questions is not None
-        else None,
-        "resale": request.resale,
-        "state": request.state,
-        "vat_identification_code": request.vat_identification_code,
-        "whois_opt_in": request.whois_opt_in,
-        "zip": request.zip,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.address_line_1 is not None:
+        output["address_line_1"] = request.address_line_1
+
+    if request.address_line_2 is not None:
+        output["address_line_2"] = request.address_line_2
+
+    if request.city is not None:
+        output["city"] = request.city
+
+    if request.company_identification_code is not None:
+        output["company_identification_code"] = request.company_identification_code
+
+    if request.company_name is not None:
+        output["company_name"] = request.company_name
+
+    if request.country is not None:
+        output["country"] = request.country
+
+    if request.email is not None:
+        output["email"] = request.email
+
+    if request.email_alt is not None:
+        output["email_alt"] = request.email_alt
+
+    if request.extension_eu is not None:
+        output["extension_eu"] = marshal_ContactExtensionEU(
+            request.extension_eu, defaults
+        )
+
+    if request.extension_fr is not None:
+        output["extension_fr"] = marshal_ContactExtensionFR(
+            request.extension_fr, defaults
+        )
+
+    if request.extension_nl is not None:
+        output["extension_nl"] = marshal_ContactExtensionNL(
+            request.extension_nl, defaults
+        )
+
+    if request.fax_number is not None:
+        output["fax_number"] = request.fax_number
+
+    if request.firstname is not None:
+        output["firstname"] = request.firstname
+
+    if request.lang is not None:
+        output["lang"] = LanguageCode(request.lang)
+
+    if request.lastname is not None:
+        output["lastname"] = request.lastname
+
+    if request.legal_form is not None:
+        output["legal_form"] = ContactLegalForm(request.legal_form)
+
+    if request.phone_number is not None:
+        output["phone_number"] = request.phone_number
+
+    if request.questions is not None:
+        output["questions"] = [
+            marshal_ContactQuestion(v, defaults) for v in request.questions
+        ]
+
+    if request.resale is not None:
+        output["resale"] = request.resale
+
+    if request.state is not None:
+        output["state"] = request.state
+
+    if request.vat_identification_code is not None:
+        output["vat_identification_code"] = request.vat_identification_code
+
+    if request.whois_opt_in is not None:
+        output["whois_opt_in"] = request.whois_opt_in
+
+    if request.zip is not None:
+        output["zip"] = request.zip
+
+    return output
 
 
 def marshal_RecordChange(
     request: RecordChange,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("add", request.add),
-                OneOfPossibility("set", request.set_),
-                OneOfPossibility("delete", request.delete),
-                OneOfPossibility("clear", request.clear),
+                OneOfPossibility(
+                    "add",
+                    marshal_RecordChangeAdd(request.add, defaults)
+                    if request.add is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "set",
+                    marshal_RecordChangeSet(request.set_, defaults)
+                    if request.set_ is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "delete",
+                    marshal_RecordChangeDelete(request.delete, defaults)
+                    if request.delete is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "clear",
+                    marshal_RecordChangeClear(request.clear, defaults)
+                    if request.clear is not None
+                    else None,
+                ),
             ]
         ),
-    }
+    )
+
+    return output
 
 
 def marshal_TransferInDomainRequestTransferRequest(
     request: TransferInDomainRequestTransferRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "auth_code": request.auth_code,
-        "domain": request.domain,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.auth_code is not None:
+        output["auth_code"] = request.auth_code
+
+    if request.domain is not None:
+        output["domain"] = request.domain
+
+    return output
 
 
 def marshal_UpdateContactRequestQuestion(
     request: UpdateContactRequestQuestion,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "answer": request.answer,
-        "question": request.question,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.answer is not None:
+        output["answer"] = request.answer
+
+    if request.question is not None:
+        output["question"] = request.question
+
+    return output
 
 
 def marshal_CloneDNSZoneRequest(
     request: CloneDNSZoneRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "dest_dns_zone": request.dest_dns_zone,
-        "overwrite": request.overwrite,
-        "project_id": request.project_id or defaults.default_project_id,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.dest_dns_zone is not None:
+        output["dest_dns_zone"] = request.dest_dns_zone
+
+    if request.overwrite is not None:
+        output["overwrite"] = request.overwrite
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    return output
 
 
 def marshal_CreateDNSZoneRequest(
     request: CreateDNSZoneRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "domain": request.domain,
-        "project_id": request.project_id or defaults.default_project_id,
-        "subdomain": request.subdomain,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.domain is not None:
+        output["domain"] = request.domain
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    if request.subdomain is not None:
+        output["subdomain"] = request.subdomain
+
+    return output
 
 
 def marshal_CreateSSLCertificateRequest(
     request: CreateSSLCertificateRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "alternative_dns_zones": request.alternative_dns_zones,
-        "dns_zone": request.dns_zone,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.alternative_dns_zones is not None:
+        output["alternative_dns_zones"] = request.alternative_dns_zones
+
+    if request.dns_zone is not None:
+        output["dns_zone"] = request.dns_zone
+
+    return output
 
 
 def marshal_ImportProviderDNSZoneRequest(
     request: ImportProviderDNSZoneRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("online_v1", request.online_v1),
+                OneOfPossibility(
+                    "online_v1",
+                    marshal_ImportProviderDNSZoneRequestOnlineV1(
+                        request.online_v1, defaults
+                    )
+                    if request.online_v1 is not None
+                    else None,
+                ),
             ]
         ),
-    }
+    )
+
+    return output
 
 
 def marshal_ImportRawDNSZoneRequest(
     request: ImportRawDNSZoneRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("bind_source", request.bind_source),
-                OneOfPossibility("axfr_source", request.axfr_source),
+                OneOfPossibility(
+                    "bind_source",
+                    marshal_ImportRawDNSZoneRequestBindSource(
+                        request.bind_source, defaults
+                    )
+                    if request.bind_source is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "axfr_source",
+                    marshal_ImportRawDNSZoneRequestAXFRSource(
+                        request.axfr_source, defaults
+                    )
+                    if request.axfr_source is not None
+                    else None,
+                ),
             ]
         ),
-        "content": request.content,
-        "format": RawFormat(request.format) if request.format is not None else None,
-        "project_id": request.project_id or defaults.default_project_id,
-    }
+    )
+
+    if request.content is not None:
+        output["content"] = request.content
+
+    if request.format is not None:
+        output["format"] = RawFormat(request.format)
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    return output
 
 
 def marshal_RefreshDNSZoneRequest(
     request: RefreshDNSZoneRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "recreate_dns_zone": request.recreate_dns_zone,
-        "recreate_sub_dns_zone": request.recreate_sub_dns_zone,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.recreate_dns_zone is not None:
+        output["recreate_dns_zone"] = request.recreate_dns_zone
+
+    if request.recreate_sub_dns_zone is not None:
+        output["recreate_sub_dns_zone"] = request.recreate_sub_dns_zone
+
+    return output
 
 
 def marshal_RegistrarApiBuyDomainsRequest(
     request: RegistrarApiBuyDomainsRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
                 OneOfPossibility(
-                    "administrative_contact_id", request.administrative_contact_id
+                    "administrative_contact_id",
+                    request.administrative_contact_id
+                    if request.administrative_contact_id is not None
+                    else None,
                 ),
                 OneOfPossibility(
-                    "administrative_contact", request.administrative_contact
+                    "administrative_contact",
+                    marshal_NewContact(request.administrative_contact, defaults)
+                    if request.administrative_contact is not None
+                    else None,
                 ),
             ]
         ),
-        **resolve_one_of(
+    )
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("owner_contact_id", request.owner_contact_id),
-                OneOfPossibility("owner_contact", request.owner_contact),
+                OneOfPossibility(
+                    "owner_contact_id",
+                    request.owner_contact_id
+                    if request.owner_contact_id is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "owner_contact",
+                    marshal_NewContact(request.owner_contact, defaults)
+                    if request.owner_contact is not None
+                    else None,
+                ),
             ]
         ),
-        **resolve_one_of(
+    )
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("technical_contact_id", request.technical_contact_id),
-                OneOfPossibility("technical_contact", request.technical_contact),
+                OneOfPossibility(
+                    "technical_contact_id",
+                    request.technical_contact_id
+                    if request.technical_contact_id is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "technical_contact",
+                    marshal_NewContact(request.technical_contact, defaults)
+                    if request.technical_contact is not None
+                    else None,
+                ),
             ]
         ),
-        "domains": request.domains,
-        "duration_in_years": request.duration_in_years,
-        "project_id": request.project_id or defaults.default_project_id,
-    }
+    )
+
+    if request.domains is not None:
+        output["domains"] = request.domains
+
+    if request.duration_in_years is not None:
+        output["duration_in_years"] = request.duration_in_years
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    return output
 
 
 def marshal_RegistrarApiCheckContactsCompatibilityRequest(
     request: RegistrarApiCheckContactsCompatibilityRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
                 OneOfPossibility(
-                    "administrative_contact_id", request.administrative_contact_id
+                    "administrative_contact_id",
+                    request.administrative_contact_id
+                    if request.administrative_contact_id is not None
+                    else None,
                 ),
                 OneOfPossibility(
-                    "administrative_contact", request.administrative_contact
+                    "administrative_contact",
+                    marshal_NewContact(request.administrative_contact, defaults)
+                    if request.administrative_contact is not None
+                    else None,
                 ),
             ]
         ),
-        **resolve_one_of(
+    )
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("owner_contact_id", request.owner_contact_id),
-                OneOfPossibility("owner_contact", request.owner_contact),
+                OneOfPossibility(
+                    "owner_contact_id",
+                    request.owner_contact_id
+                    if request.owner_contact_id is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "owner_contact",
+                    marshal_NewContact(request.owner_contact, defaults)
+                    if request.owner_contact is not None
+                    else None,
+                ),
             ]
         ),
-        **resolve_one_of(
+    )
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("technical_contact_id", request.technical_contact_id),
-                OneOfPossibility("technical_contact", request.technical_contact),
+                OneOfPossibility(
+                    "technical_contact_id",
+                    request.technical_contact_id
+                    if request.technical_contact_id is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "technical_contact",
+                    marshal_NewContact(request.technical_contact, defaults)
+                    if request.technical_contact is not None
+                    else None,
+                ),
             ]
         ),
-        "domains": request.domains,
-        "tlds": request.tlds,
-    }
+    )
+
+    if request.domains is not None:
+        output["domains"] = request.domains
+
+    if request.tlds is not None:
+        output["tlds"] = request.tlds
+
+    return output
 
 
 def marshal_RegistrarApiCreateDomainHostRequest(
     request: RegistrarApiCreateDomainHostRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "ips": request.ips,
-        "name": request.name,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.ips is not None:
+        output["ips"] = request.ips
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
 
 
 def marshal_RegistrarApiEnableDomainDNSSECRequest(
     request: RegistrarApiEnableDomainDNSSECRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "ds_record": marshal_DSRecord(request.ds_record, defaults)
-        if request.ds_record is not None
-        else None,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.ds_record is not None:
+        output["ds_record"] = marshal_DSRecord(request.ds_record, defaults)
+
+    return output
 
 
 def marshal_RegistrarApiRegisterExternalDomainRequest(
     request: RegistrarApiRegisterExternalDomainRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "domain": request.domain,
-        "project_id": request.project_id or defaults.default_project_id,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.domain is not None:
+        output["domain"] = request.domain
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    return output
 
 
 def marshal_RegistrarApiRenewDomainsRequest(
     request: RegistrarApiRenewDomainsRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "domains": request.domains,
-        "duration_in_years": request.duration_in_years,
-        "force_late_renewal": request.force_late_renewal,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.domains is not None:
+        output["domains"] = request.domains
+
+    if request.duration_in_years is not None:
+        output["duration_in_years"] = request.duration_in_years
+
+    if request.force_late_renewal is not None:
+        output["force_late_renewal"] = request.force_late_renewal
+
+    return output
 
 
 def marshal_RegistrarApiTradeDomainRequest(
     request: RegistrarApiTradeDomainRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("new_owner_contact_id", request.new_owner_contact_id),
-                OneOfPossibility("new_owner_contact", request.new_owner_contact),
+                OneOfPossibility(
+                    "new_owner_contact_id",
+                    request.new_owner_contact_id
+                    if request.new_owner_contact_id is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "new_owner_contact",
+                    marshal_NewContact(request.new_owner_contact, defaults)
+                    if request.new_owner_contact is not None
+                    else None,
+                ),
             ]
         ),
-        "project_id": request.project_id or defaults.default_project_id,
-    }
+    )
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    return output
 
 
 def marshal_RegistrarApiTransferInDomainRequest(
     request: RegistrarApiTransferInDomainRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
                 OneOfPossibility(
-                    "administrative_contact_id", request.administrative_contact_id
+                    "administrative_contact_id",
+                    request.administrative_contact_id
+                    if request.administrative_contact_id is not None
+                    else None,
                 ),
                 OneOfPossibility(
-                    "administrative_contact", request.administrative_contact
+                    "administrative_contact",
+                    marshal_NewContact(request.administrative_contact, defaults)
+                    if request.administrative_contact is not None
+                    else None,
                 ),
             ]
         ),
-        **resolve_one_of(
+    )
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("owner_contact_id", request.owner_contact_id),
-                OneOfPossibility("owner_contact", request.owner_contact),
+                OneOfPossibility(
+                    "owner_contact_id",
+                    request.owner_contact_id
+                    if request.owner_contact_id is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "owner_contact",
+                    marshal_NewContact(request.owner_contact, defaults)
+                    if request.owner_contact is not None
+                    else None,
+                ),
             ]
         ),
-        **resolve_one_of(
+    )
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("technical_contact_id", request.technical_contact_id),
-                OneOfPossibility("technical_contact", request.technical_contact),
+                OneOfPossibility(
+                    "technical_contact_id",
+                    request.technical_contact_id
+                    if request.technical_contact_id is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "technical_contact",
+                    marshal_NewContact(request.technical_contact, defaults)
+                    if request.technical_contact is not None
+                    else None,
+                ),
             ]
         ),
-        "domains": [
+    )
+
+    if request.domains is not None:
+        output["domains"] = [
             marshal_TransferInDomainRequestTransferRequest(v, defaults)
             for v in request.domains
-        ],
-        "project_id": request.project_id or defaults.default_project_id,
-    }
+        ]
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    return output
 
 
 def marshal_RegistrarApiUpdateContactRequest(
     request: RegistrarApiUpdateContactRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "address_line_1": request.address_line_1,
-        "address_line_2": request.address_line_2,
-        "city": request.city,
-        "company_identification_code": request.company_identification_code,
-        "country": request.country,
-        "email": request.email,
-        "email_alt": request.email_alt,
-        "extension_eu": marshal_ContactExtensionEU(request.extension_eu, defaults)
-        if request.extension_eu is not None
-        else None,
-        "extension_fr": marshal_ContactExtensionFR(request.extension_fr, defaults)
-        if request.extension_fr is not None
-        else None,
-        "extension_nl": marshal_ContactExtensionNL(request.extension_nl, defaults)
-        if request.extension_nl is not None
-        else None,
-        "fax_number": request.fax_number,
-        "lang": LanguageCode(request.lang),
-        "phone_number": request.phone_number,
-        "questions": [
+    output: Dict[str, Any] = {}
+
+    if request.address_line_1 is not None:
+        output["address_line_1"] = request.address_line_1
+
+    if request.address_line_2 is not None:
+        output["address_line_2"] = request.address_line_2
+
+    if request.city is not None:
+        output["city"] = request.city
+
+    if request.company_identification_code is not None:
+        output["company_identification_code"] = request.company_identification_code
+
+    if request.country is not None:
+        output["country"] = request.country
+
+    if request.email is not None:
+        output["email"] = request.email
+
+    if request.email_alt is not None:
+        output["email_alt"] = request.email_alt
+
+    if request.extension_eu is not None:
+        output["extension_eu"] = marshal_ContactExtensionEU(
+            request.extension_eu, defaults
+        )
+
+    if request.extension_fr is not None:
+        output["extension_fr"] = marshal_ContactExtensionFR(
+            request.extension_fr, defaults
+        )
+
+    if request.extension_nl is not None:
+        output["extension_nl"] = marshal_ContactExtensionNL(
+            request.extension_nl, defaults
+        )
+
+    if request.fax_number is not None:
+        output["fax_number"] = request.fax_number
+
+    if request.lang is not None:
+        output["lang"] = LanguageCode(request.lang)
+
+    if request.phone_number is not None:
+        output["phone_number"] = request.phone_number
+
+    if request.questions is not None:
+        output["questions"] = [
             marshal_UpdateContactRequestQuestion(v, defaults) for v in request.questions
         ]
-        if request.questions is not None
-        else None,
-        "resale": request.resale,
-        "state": request.state,
-        "vat_identification_code": request.vat_identification_code,
-        "whois_opt_in": request.whois_opt_in,
-        "zip": request.zip,
-    }
+
+    if request.resale is not None:
+        output["resale"] = request.resale
+
+    if request.state is not None:
+        output["state"] = request.state
+
+    if request.vat_identification_code is not None:
+        output["vat_identification_code"] = request.vat_identification_code
+
+    if request.whois_opt_in is not None:
+        output["whois_opt_in"] = request.whois_opt_in
+
+    if request.zip is not None:
+        output["zip"] = request.zip
+
+    return output
 
 
 def marshal_RegistrarApiUpdateDomainHostRequest(
     request: RegistrarApiUpdateDomainHostRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "ips": request.ips,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.ips is not None:
+        output["ips"] = request.ips
+
+    return output
 
 
 def marshal_RegistrarApiUpdateDomainRequest(
     request: RegistrarApiUpdateDomainRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
                 OneOfPossibility(
-                    "administrative_contact_id", request.administrative_contact_id
+                    "administrative_contact_id",
+                    request.administrative_contact_id
+                    if request.administrative_contact_id is not None
+                    else None,
                 ),
                 OneOfPossibility(
-                    "administrative_contact", request.administrative_contact
+                    "administrative_contact",
+                    marshal_NewContact(request.administrative_contact, defaults)
+                    if request.administrative_contact is not None
+                    else None,
                 ),
             ]
         ),
-        **resolve_one_of(
+    )
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("owner_contact_id", request.owner_contact_id),
-                OneOfPossibility("owner_contact", request.owner_contact),
+                OneOfPossibility(
+                    "owner_contact_id",
+                    request.owner_contact_id
+                    if request.owner_contact_id is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "owner_contact",
+                    marshal_NewContact(request.owner_contact, defaults)
+                    if request.owner_contact is not None
+                    else None,
+                ),
             ]
         ),
-        **resolve_one_of(
+    )
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("technical_contact_id", request.technical_contact_id),
-                OneOfPossibility("technical_contact", request.technical_contact),
+                OneOfPossibility(
+                    "technical_contact_id",
+                    request.technical_contact_id
+                    if request.technical_contact_id is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "technical_contact",
+                    marshal_NewContact(request.technical_contact, defaults)
+                    if request.technical_contact is not None
+                    else None,
+                ),
             ]
         ),
-    }
+    )
+
+    return output
 
 
 def marshal_UpdateDNSZoneNameserversRequest(
     request: UpdateDNSZoneNameserversRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "ns": [marshal_Nameserver(v, defaults) for v in request.ns],
-    }
+    output: Dict[str, Any] = {}
+
+    if request.ns is not None:
+        output["ns"] = [marshal_Nameserver(v, defaults) for v in request.ns]
+
+    return output
 
 
 def marshal_UpdateDNSZoneRecordsRequest(
     request: UpdateDNSZoneRecordsRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "changes": [marshal_RecordChange(v, defaults) for v in request.changes],
-        "disallow_new_zone_creation": request.disallow_new_zone_creation,
-        "return_all_records": request.return_all_records,
-        "serial": request.serial,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.changes is not None:
+        output["changes"] = [marshal_RecordChange(v, defaults) for v in request.changes]
+
+    if request.disallow_new_zone_creation is not None:
+        output["disallow_new_zone_creation"] = request.disallow_new_zone_creation
+
+    if request.return_all_records is not None:
+        output["return_all_records"] = request.return_all_records
+
+    if request.serial is not None:
+        output["serial"] = request.serial
+
+    return output
 
 
 def marshal_UpdateDNSZoneRequest(
     request: UpdateDNSZoneRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "new_dns_zone": request.new_dns_zone,
-        "project_id": request.project_id or defaults.default_project_id,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.new_dns_zone is not None:
+        output["new_dns_zone"] = request.new_dns_zone
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    return output
```

### Comparing `scaleway_async-0.9.0/scaleway_async/domain/v2beta1/types.py` & `scaleway_async-1.0.0/scaleway_async/domain/v2beta1/types.py`

 * *Files 6% similar despite different names*

```diff
@@ -54,14 +54,15 @@
     PUBLIC_COMPANY = "public_company"
     MUTUAL_BENEFIT_COMPANY = "mutual_benefit_company"
     RESIDENTIAL = "residential"
     SHIPPING_COMPANY = "shipping_company"
     FOUNDATION = "foundation"
     ASSOCIATION = "association"
     TRADING_PARTNERSHIP = "trading_partnership"
+    NATURAL_PERSON = "natural_person"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
 class ContactLegalForm(str, Enum):
     LEGAL_FORM_UNKNOWN = "legal_form_unknown"
@@ -208,14 +209,24 @@
     FR_FR = "fr_FR"
     DE_DE = "de_DE"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
+class ListContactsRequestRole(str, Enum):
+    UNKNOWN_ROLE = "unknown_role"
+    OWNER = "owner"
+    ADMINISTRATIVE = "administrative"
+    TECHNICAL = "technical"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
 class ListDNSZoneRecordsRequestOrderBy(str, Enum):
     NAME_ASC = "name_asc"
     NAME_DESC = "name_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
@@ -337,15 +348,15 @@
 
     tld: Optional[Tld]
 
 
 @dataclass
 class CheckContactsCompatibilityResponse:
     """
-    Check contacts compatibility response
+    Check contacts compatibility response.
     """
 
     compatible: bool
 
     owner_check_result: Optional[CheckContactsCompatibilityResponseContactCheckResult]
 
     administrative_check_result: Optional[
@@ -363,22 +374,22 @@
 
     error_message: Optional[str]
 
 
 @dataclass
 class ClearDNSZoneRecordsResponse:
     """
-    Clear dns zone records response
+    Clear dns zone records response.
     """
 
 
 @dataclass
 class Contact:
     """
-    Contact
+    Contact.
     """
 
     id: str
 
     legal_form: ContactLegalForm
 
     firstname: str
@@ -583,36 +594,36 @@
 class DSRecordPublicKey:
     key: str
 
 
 @dataclass
 class DeleteDNSZoneResponse:
     """
-    Delete dns zone response
+    Delete dns zone response.
     """
 
 
 @dataclass
 class DeleteExternalDomainResponse:
     """
-    Delete external domain response
+    Delete external domain response.
     """
 
 
 @dataclass
 class DeleteSSLCertificateResponse:
     """
-    Delete ssl certificate response
+    Delete ssl certificate response.
     """
 
 
 @dataclass
 class Domain:
     """
-    Domain
+    Domain.
     """
 
     domain: str
 
     organization_id: str
 
     project_id: str
@@ -803,37 +814,37 @@
 
     organization_id: str
 
 
 @dataclass
 class GetDNSZoneTsigKeyResponse:
     """
-    Get dns zone tsig key response
+    Get dns zone tsig key response.
     """
 
     name: str
 
     key: str
 
     algorithm: str
 
 
 @dataclass
 class GetDNSZoneVersionDiffResponse:
     """
-    Get dns zone version diff response
+    Get dns zone version diff response.
     """
 
     changes: List[RecordChange]
 
 
 @dataclass
 class GetDomainAuthCodeResponse:
     """
-    Get domain auth code response
+    Get domain auth code response.
     """
 
     auth_code: str
 
 
 @dataclass
 class Host:
@@ -850,15 +861,15 @@
 class ImportProviderDNSZoneRequestOnlineV1:
     token: str
 
 
 @dataclass
 class ImportProviderDNSZoneResponse:
     """
-    Import provider dns zone response
+    Import provider dns zone response.
     """
 
     records: List[DomainRecord]
 
 
 @dataclass
 class ImportRawDNSZoneRequestAXFRSource:
@@ -880,153 +891,153 @@
 
     algorithm: str
 
 
 @dataclass
 class ImportRawDNSZoneResponse:
     """
-    Import raw dns zone response
+    Import raw dns zone response.
     """
 
     records: List[DomainRecord]
 
 
 @dataclass
 class ListContactsResponse:
     """
-    List contacts response
+    List contacts response.
     """
 
     total_count: int
 
     contacts: List[ContactRoles]
 
 
 @dataclass
 class ListDNSZoneNameserversResponse:
     """
-    List dns zone nameservers response
+    List dns zone nameservers response.
     """
 
     ns: List[Nameserver]
     """
-    The returned DNS zone nameservers
+    DNS zone name servers returned.
     """
 
 
 @dataclass
 class ListDNSZoneRecordsResponse:
     """
-    List dns zone records response
+    List dns zone records response.
     """
 
     total_count: int
     """
-    The total number of DNS zone records
+    Total number of DNS zone records.
     """
 
     records: List[DomainRecord]
     """
-    The paginated returned DNS zone records
+    Paginated returned DNS zone records.
     """
 
 
 @dataclass
 class ListDNSZoneVersionRecordsResponse:
     """
-    List dns zone version records response
+    List dns zone version records response.
     """
 
     total_count: int
     """
-    The total number of DNS zones versions records
+    Total number of DNS zones versions records.
     """
 
     records: List[DomainRecord]
 
 
 @dataclass
 class ListDNSZoneVersionsResponse:
     """
-    List dns zone versions response
+    List dns zone versions response.
     """
 
     total_count: int
     """
-    The total number of DNS zones versions
+    Total number of DNS zones versions.
     """
 
     versions: List[DNSZoneVersion]
 
 
 @dataclass
 class ListDNSZonesResponse:
     """
-    List dns zones response
+    List dns zones response.
     """
 
     total_count: int
     """
-    The total number of DNS zones
+    Total number of DNS zones matching the requested criteria.
     """
 
     dns_zones: List[DNSZone]
     """
-    The paginated returned DNS zones
+    Paginated returned DNS zones.
     """
 
 
 @dataclass
 class ListDomainHostsResponse:
     """
-    List domain hosts response
+    List domain hosts response.
     """
 
     total_count: int
 
     hosts: List[Host]
 
 
 @dataclass
 class ListDomainsResponse:
     """
-    List domains response
+    List domains response.
     """
 
     total_count: int
 
     domains: List[DomainSummary]
 
 
 @dataclass
 class ListRenewableDomainsResponse:
     """
-    List renewable domains response
+    List renewable domains response.
     """
 
     total_count: int
 
     domains: List[RenewableDomain]
 
 
 @dataclass
 class ListSSLCertificatesResponse:
     """
-    List ssl certificates response
+    List ssl certificates response.
     """
 
     total_count: int
 
     certificates: List[SSLCertificate]
 
 
 @dataclass
 class ListTasksResponse:
     """
-    List tasks response
+    List tasks response.
     """
 
     total_count: int
 
     tasks: List[Task]
 
 
@@ -1173,20 +1184,20 @@
 
     ttl: Optional[int]
 
 
 @dataclass
 class RefreshDNSZoneResponse:
     """
-    Refresh dns zone response
+    Refresh dns zone response.
     """
 
     dns_zones: List[DNSZone]
     """
-    The returned DNS zones
+    DNS zones returned.
     """
 
 
 @dataclass
 class RegisterExternalDomainResponse:
     domain: str
 
@@ -1221,15 +1232,15 @@
 
     tld: Optional[Tld]
 
 
 @dataclass
 class RestoreDNSZoneVersionResponse:
     """
-    Restore dns zone version response
+    Restore dns zone version response.
     """
 
 
 @dataclass
 class SSLCertificate:
     dns_zone: str
 
@@ -1245,20 +1256,20 @@
 
     expired_at: Optional[datetime]
 
 
 @dataclass
 class SearchAvailableDomainsResponse:
     """
-    Search available domains response
+    Search available domains response.
     """
 
     available_domains: List[AvailableDomain]
     """
-    Array of available domains
+    Array of available domains.
     """
 
 
 @dataclass
 class Task:
     id: str
 
@@ -1318,268 +1329,268 @@
 
     answer: Optional[str]
 
 
 @dataclass
 class UpdateDNSZoneNameserversResponse:
     """
-    Update dns zone nameservers response
+    Update dns zone nameservers response.
     """
 
     ns: List[Nameserver]
     """
-    The returned DNS zone nameservers
+    DNS zone name servers returned.
     """
 
 
 @dataclass
 class UpdateDNSZoneRecordsResponse:
     """
-    Update dns zone records response
+    Update dns zone records response.
     """
 
     records: List[DomainRecord]
     """
-    The returned DNS zone records
+    DNS zone records returned.
     """
 
 
 @dataclass
 class ListDNSZonesRequest:
     organization_id: Optional[str]
     """
-    The organization ID on which to filter the returned DNS zones
+    Organization ID on which to filter the returned DNS zones.
     """
 
     project_id: Optional[str]
     """
-    The project ID on which to filter the returned DNS zones
+    Project ID on which to filter the returned DNS zones.
     """
 
     order_by: Optional[ListDNSZonesRequestOrderBy]
     """
-    The sort order of the returned DNS zones
+    Sort order of the returned DNS zones.
     """
 
     page: Optional[int]
     """
-    The page number for the returned DNS zones
+    Page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    The maximum number of DNS zones per page
+    Maximum number of DNS zones to return per page.
     """
 
     domain: str
     """
-    The domain on which to filter the returned DNS zones
+    Domain on which to filter the returned DNS zones.
     """
 
     dns_zone: str
     """
-    The DNS zone on which to filter the returned DNS zones
+    DNS zone on which to filter the returned DNS zones.
     """
 
 
 @dataclass
 class CreateDNSZoneRequest:
     domain: str
     """
-    The domain of the DNS zone to create
+    Domain in which to crreate the DNS zone.
     """
 
     subdomain: str
     """
-    The subdomain of the DNS zone to create
+    Subdomain of the DNS zone to create.
     """
 
     project_id: Optional[str]
     """
-    The project ID where the DNS zone will be created
+    Project ID in which to create the DNS zone.
     """
 
 
 @dataclass
 class UpdateDNSZoneRequest:
     dns_zone: str
     """
-    The DNS zone to update
+    DNS zone to update.
     """
 
     new_dns_zone: str
     """
-    The new DNS zone
+    Name of the new DNS zone to create.
     """
 
     project_id: Optional[str]
     """
-    The project ID of the new DNS zone
+    Project ID in which to create the new DNS zone.
     """
 
 
 @dataclass
 class CloneDNSZoneRequest:
     dns_zone: str
     """
-    The DNS zone to clone
+    DNS zone to clone.
     """
 
     dest_dns_zone: str
     """
-    The destinaton DNS zone
+    Destination DNS zone in which to clone the chosen DNS zone.
     """
 
     overwrite: bool
     """
-    Whether or not the destination DNS zone will be overwritten
+    Specifies whether or not the destination DNS zone will be overwritten.
     """
 
     project_id: Optional[str]
     """
-    The project ID of the destination DNS zone
+    Project ID of the destination DNS zone.
     """
 
 
 @dataclass
 class DeleteDNSZoneRequest:
     dns_zone: str
     """
-    The DNS zone to delete
+    DNS zone to delete.
     """
 
     project_id: Optional[str]
     """
-    The project ID of the DNS zone to delete
+    Project ID of the DNS zone to delete.
     """
 
 
 @dataclass
 class ListDNSZoneRecordsRequest:
     dns_zone: str
     """
-    The DNS zone on which to filter the returned DNS zone records
+    DNS zone on which to filter the returned DNS zone records.
     """
 
     project_id: Optional[str]
     """
-    The project ID on which to filter the returned DNS zone records
+    Project ID on which to filter the returned DNS zone records.
     """
 
     order_by: Optional[ListDNSZoneRecordsRequestOrderBy]
     """
-    The sort order of the returned DNS zone records
+    Sort order of the returned DNS zone records.
     """
 
     page: Optional[int]
     """
-    The page number for the returned DNS zone records
+    Page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    The maximum number of DNS zone records per page
+    Maximum number of DNS zone records per page.
     """
 
     name: str
     """
-    The name on which to filter the returned DNS zone records
+    Name on which to filter the returned DNS zone records.
     """
 
     type_: Optional[DomainRecordType]
     """
-    The record type on which to filter the returned DNS zone records
+    Record type on which to filter the returned DNS zone records.
     """
 
     id: Optional[str]
     """
-    The record ID on which to filter the returned DNS zone records
+    Record ID on which to filter the returned DNS zone records.
     """
 
 
 @dataclass
 class UpdateDNSZoneRecordsRequest:
     dns_zone: str
     """
-    The DNS zone where the DNS zone records will be updated
+    DNS zone in which to update the DNS zone records.
     """
 
     changes: List[RecordChange]
     """
-    The changes made to the records
+    Changes made to the records.
     """
 
     return_all_records: Optional[bool]
     """
-    Whether or not to return all the records
+    Specifies whether or not to return all the records.
     """
 
     disallow_new_zone_creation: bool
     """
-    Forbid the creation of the target zone if not existing (default action is yes)
+    Disable the creation of the target zone if it does not exist. Target zone creation is disabled by default.
     """
 
     serial: Optional[int]
     """
-    Don't use the autoincremenent serial but the provided one (0 to keep the same)
+    Use the provided serial (0) instead of the auto-increment serial.
     """
 
 
 @dataclass
 class ListDNSZoneNameserversRequest:
     dns_zone: str
     """
-    The DNS zone on which to filter the returned DNS zone nameservers
+    DNS zone on which to filter the returned DNS zone name servers.
     """
 
     project_id: Optional[str]
     """
-    The project ID on which to filter the returned DNS zone nameservers
+    Project ID on which to filter the returned DNS zone name servers.
     """
 
 
 @dataclass
 class UpdateDNSZoneNameserversRequest:
     dns_zone: str
     """
-    The DNS zone where the DNS zone nameservers will be updated
+    DNS zone in which to update the DNS zone name servers.
     """
 
     ns: List[Nameserver]
     """
-    The new DNS zone nameservers
+    New DNS zone name servers.
     """
 
 
 @dataclass
 class ClearDNSZoneRecordsRequest:
     dns_zone: str
     """
-    The DNS zone to clear
+    DNS zone to clear.
     """
 
 
 @dataclass
 class ExportRawDNSZoneRequest:
     dns_zone: str
     """
-    The DNS zone to export
+    DNS zone to export.
     """
 
     format: RawFormat
     """
-    Format for DNS zone
+    DNS zone format.
     """
 
 
 @dataclass
 class ImportRawDNSZoneRequest:
     dns_zone: str
     """
-    The DNS zone to import
+    DNS zone to import.
     """
 
     content: Optional[str]
     """
     :deprecated
     """
 
@@ -1595,15 +1606,15 @@
     Import a bind file format.
     
     One-of ('source'): at most one of 'bind_source', 'axfr_source' could be set.
     """
 
     axfr_source: Optional[ImportRawDNSZoneRequestAXFRSource]
     """
-    Import from the nameserver given with tsig use or not.
+    Import from the name server given with TSIG, to use or not.
     
     One-of ('source'): at most one of 'bind_source', 'axfr_source' could be set.
     """
 
 
 @dataclass
 class ImportProviderDNSZoneRequest:
@@ -1615,55 +1626,55 @@
     """
 
 
 @dataclass
 class RefreshDNSZoneRequest:
     dns_zone: str
     """
-    The DNS zone to refresh
+    DNS zone to refresh.
     """
 
     recreate_dns_zone: bool
     """
-    Whether or not to recreate the DNS zone
+    Specifies whether or not to recreate the DNS zone.
     """
 
     recreate_sub_dns_zone: bool
     """
-    Whether or not to recreate the sub DNS zone
+    Specifies whether or not to recreate the sub DNS zone.
     """
 
 
 @dataclass
 class ListDNSZoneVersionsRequest:
     dns_zone: str
 
     page: Optional[int]
     """
-    The page number for the returned DNS zones versions
+    Page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    The maximum number of DNS zones versions per page
+    Maximum number of DNS zones versions per page.
     """
 
 
 @dataclass
 class ListDNSZoneVersionRecordsRequest:
     dns_zone_version_id: str
 
     page: Optional[int]
     """
-    The page number for the returned DNS zones versions records
+    Page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    The maximum number of DNS zones versions records per page
+    Maximum number of DNS zones versions records per page.
     """
 
 
 @dataclass
 class GetDNSZoneVersionDiffRequest:
     dns_zone_version_id: str
 
@@ -1889,14 +1900,18 @@
 
     domain: Optional[str]
 
     project_id: Optional[str]
 
     organization_id: Optional[str]
 
+    role: Optional[ListContactsRequestRole]
+
+    email_status: Optional[ContactEmailStatus]
+
 
 @dataclass
 class RegistrarApiGetContactRequest:
     contact_id: str
 
 
 @dataclass
@@ -2056,25 +2071,25 @@
     domain: str
 
 
 @dataclass
 class RegistrarApiSearchAvailableDomainsRequest:
     domains: List[str]
     """
-    A list of domain to search, TLD is optional
+    A list of domain to search, TLD is optional.
     """
 
     tlds: Optional[List[str]]
     """
-    Array of tlds to search on
+    Array of tlds to search on.
     """
 
     strict_search: bool
     """
-    Search exact match
+    Search exact match.
     """
 
 
 @dataclass
 class RegistrarApiCreateDomainHostRequest:
     domain: str
```

### Comparing `scaleway_async-0.9.0/scaleway_async/flexibleip/v1alpha1/__init__.py` & `scaleway_async-1.0.0/scaleway_async/flexibleip/v1alpha1/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-0.9.0/scaleway_async/flexibleip/v1alpha1/api.py` & `scaleway_async-1.0.0/scaleway_async/flexibleip/v1alpha1/api.py`

 * *Files 7% similar despite different names*

```diff
@@ -45,37 +45,40 @@
     unmarshal_DetachFlexibleIPsResponse,
     unmarshal_ListFlexibleIPsResponse,
 )
 
 
 class FlexibleipV1Alpha1API(API):
     """
-    Flexible IP API.
+    Elastic Metal - Flexible IP API.
+
+    Elastic Metal - Flexible IP API.
     """
 
     async def create_flexible_ip(
         self,
         *,
         description: str,
         is_ipv6: bool,
         zone: Optional[Zone] = None,
         project_id: Optional[str] = None,
         tags: Optional[List[str]] = None,
         server_id: Optional[str] = None,
         reverse: Optional[str] = None,
     ) -> FlexibleIP:
         """
-        Create a Flexible IP
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param project_id: ID of the project to associate with the Flexible IP
-        :param description: Description to associate with the Flexible IP, max 255 characters
-        :param tags: Tags to associate to the Flexible IP
-        :param server_id: Server ID on which to attach the created Flexible IP
-        :param reverse: Reverse DNS value
-        :param is_ipv6: If true, creates a Flexible IP with an ipv6 address
+        Create a new flexible IP.
+        Generate a new flexible IP within a given zone, specifying its configuration including Project ID and description.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param project_id: ID of the project to associate with the Flexible IP.
+        :param description: Flexible IP description (max. of 255 characters).
+        :param tags: Tags to associate to the flexible IP.
+        :param server_id: ID of the server to which the newly created flexible IP will be attached.
+        :param reverse: Value of the reverse DNS.
+        :param is_ipv6: Defines whether the flexible IP has an IPv6 address.
         :return: :class:`FlexibleIP <FlexibleIP>`
 
         Usage:
         ::
 
             result = await api.create_flexible_ip(
                 description="example",
@@ -108,17 +111,18 @@
     async def get_flexible_ip(
         self,
         *,
         fip_id: str,
         zone: Optional[Zone] = None,
     ) -> FlexibleIP:
         """
-        Get a Flexible IP
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param fip_id: Flexible IP ID
+        Get an existing flexible IP.
+        Retrieve information about an existing flexible IP, specified by its ID and zone. Its full details, including Project ID, description and status, are returned in the response object.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param fip_id: ID of the flexible IP.
         :return: :class:`FlexibleIP <FlexibleIP>`
 
         Usage:
         ::
 
             result = await api.get_flexible_ip(fip_id="example")
         """
@@ -141,16 +145,16 @@
         zone: Optional[Zone] = None,
         options: Optional[
             WaitForOptions[FlexibleIP, Union[bool, Awaitable[bool]]]
         ] = None,
     ) -> FlexibleIP:
         """
         Waits for :class:`FlexibleIP <FlexibleIP>` to be in a final state.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param fip_id: Flexible IP ID
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param fip_id: ID of the flexible IP.
         :param options: The options for the waiter
         :return: :class:`FlexibleIP <FlexibleIP>`
 
         Usage:
         ::
 
             result = api.wait_for_flexible_ip(fip_id="example")
@@ -181,24 +185,25 @@
         tags: Optional[List[str]] = None,
         status: Optional[List[FlexibleIPStatus]] = None,
         server_ids: Optional[List[str]] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> ListFlexibleIPsResponse:
         """
-        List Flexible IPs
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param order_by: The sort order of the returned Flexible IPs
-        :param page: The page number for the returned Flexible IPs
-        :param page_size: The maximum number of Flexible IPs per page
-        :param tags: Filter Flexible IPs with one or more matching tags
-        :param status: Filter Flexible IPs by status
-        :param server_ids: Filter Flexible IPs by server IDs
-        :param organization_id: Filter Flexible IPs by organization ID
-        :param project_id: Filter Flexible IPs by project ID
+        List flexible IPs.
+        List all flexible IPs within a given zone.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param order_by: Sort order of the returned flexible IPs.
+        :param page: Page number.
+        :param page_size: Maximum number of flexible IPs per page.
+        :param tags: Filter by tag, only flexible IPs with one or more matching tags will be returned.
+        :param status: Filter by status, only flexible IPs with this status will be returned.
+        :param server_ids: Filter by server IDs, only flexible IPs with these server IDs will be returned.
+        :param organization_id: Filter by Organization ID, only flexible IPs from this Organization will be returned.
+        :param project_id: Filter by Project ID, only flexible IPs from this Project will be returned.
         :return: :class:`ListFlexibleIPsResponse <ListFlexibleIPsResponse>`
 
         Usage:
         ::
 
             result = await api.list_flexible_i_ps()
         """
@@ -234,24 +239,25 @@
         tags: Optional[List[str]] = None,
         status: Optional[List[FlexibleIPStatus]] = None,
         server_ids: Optional[List[str]] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> List[FlexibleIP]:
         """
-        List Flexible IPs
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param order_by: The sort order of the returned Flexible IPs
-        :param page: The page number for the returned Flexible IPs
-        :param page_size: The maximum number of Flexible IPs per page
-        :param tags: Filter Flexible IPs with one or more matching tags
-        :param status: Filter Flexible IPs by status
-        :param server_ids: Filter Flexible IPs by server IDs
-        :param organization_id: Filter Flexible IPs by organization ID
-        :param project_id: Filter Flexible IPs by project ID
+        List flexible IPs.
+        List all flexible IPs within a given zone.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param order_by: Sort order of the returned flexible IPs.
+        :param page: Page number.
+        :param page_size: Maximum number of flexible IPs per page.
+        :param tags: Filter by tag, only flexible IPs with one or more matching tags will be returned.
+        :param status: Filter by status, only flexible IPs with this status will be returned.
+        :param server_ids: Filter by server IDs, only flexible IPs with these server IDs will be returned.
+        :param organization_id: Filter by Organization ID, only flexible IPs from this Organization will be returned.
+        :param project_id: Filter by Project ID, only flexible IPs from this Project will be returned.
         :return: :class:`List[ListFlexibleIPsResponse] <List[ListFlexibleIPsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_flexible_i_ps_all()
         """
@@ -279,20 +285,21 @@
         fip_id: str,
         zone: Optional[Zone] = None,
         description: Optional[str] = None,
         tags: Optional[List[str]] = None,
         reverse: Optional[str] = None,
     ) -> FlexibleIP:
         """
-        Update a Flexible IP
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param fip_id: ID of the Flexible IP to update
-        :param description: Description to associate with the Flexible IP, max 255 characters
-        :param tags: Tags to associate with the Flexible IP
-        :param reverse: Reverse DNS value
+        Update an existing flexible IP.
+        Update the parameters of an existing flexible IP, specified by its ID and zone. These parameters include tags and description.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param fip_id: ID of the flexible IP to update.
+        :param description: Flexible IP description (max. 255 characters).
+        :param tags: Tags associated with the flexible IP.
+        :param reverse: Value of the reverse DNS.
         :return: :class:`FlexibleIP <FlexibleIP>`
 
         Usage:
         ::
 
             result = await api.update_flexible_ip(fip_id="example")
         """
@@ -321,17 +328,18 @@
     async def delete_flexible_ip(
         self,
         *,
         fip_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete a Flexible IP
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param fip_id: ID of the Flexible IP to delete
+        Delete an existing flexible IP.
+        Delete an existing flexible IP, specified by its ID and zone. Note that deleting a flexible IP is permanent and cannot be undone.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param fip_id: ID of the flexible IP to delete.
 
         Usage:
         ::
 
             result = await api.delete_flexible_ip(fip_id="example")
         """
 
@@ -350,18 +358,20 @@
         self,
         *,
         fips_ids: List[str],
         server_id: str,
         zone: Optional[Zone] = None,
     ) -> AttachFlexibleIPsResponse:
         """
-        Attach a Flexible IP to a server
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param fips_ids: Multiple IDs can be provided as long as Flexible IPs belong to the same MAC groups (see details about MAC groups).
-        :param server_id: A server ID on which to attach the Flexible IPs
+        Attach an existing flexible IP to a server.
+        Attach an existing flexible IP to a specified Elastic Metal server.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param fips_ids: List of flexible IP IDs to attach to a server.
+        Multiple IDs can be provided, but note that flexible IPs must belong to the same MAC group (see details about MAC groups).
+        :param server_id: ID of the server on which to attach the flexible IPs.
         :return: :class:`AttachFlexibleIPsResponse <AttachFlexibleIPsResponse>`
 
         Usage:
         ::
 
             result = await api.attach_flexible_ip(
                 fips_ids=["example"],
@@ -390,17 +400,18 @@
     async def detach_flexible_ip(
         self,
         *,
         fips_ids: List[str],
         zone: Optional[Zone] = None,
     ) -> DetachFlexibleIPsResponse:
         """
-        Detach a Flexible IP from a server
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param fips_ids: Multiple IDs can be provided as long as Flexible IPs belong to the same MAC groups (see details about MAC groups).
+        Detach an existing flexible IP from a server.
+        Detach an existing flexible IP from a specified Elastic Metal server.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param fips_ids: List of flexible IP IDs to detach from a server. Multiple IDs can be provided. Note that flexible IPs must belong to the same MAC group.
         :return: :class:`DetachFlexibleIPsResponse <DetachFlexibleIPsResponse>`
 
         Usage:
         ::
 
             result = await api.detach_flexible_ip(fips_ids=["example"])
         """
@@ -426,18 +437,19 @@
         self,
         *,
         fip_id: str,
         zone: Optional[Zone] = None,
         mac_type: MACAddressType = MACAddressType.UNKNOWN_TYPE,
     ) -> FlexibleIP:
         """
-        Generate a virtual MAC on a given Flexible IP
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param fip_id: Flexible IP ID on which to generate a Virtual MAC
-        :param mac_type: TODO
+        Generate a virtual MAC address on an existing flexible IP.
+        Generate a virtual MAC (Media Access Control) address on an existing flexible IP.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param fip_id: ID of the flexible IP for which to generate a virtual MAC.
+        :param mac_type: TODO.
         :return: :class:`FlexibleIP <FlexibleIP>`
 
         Usage:
         ::
 
             result = await api.generate_mac_addr(fip_id="example")
         """
@@ -465,18 +477,21 @@
         self,
         *,
         fip_id: str,
         duplicate_from_fip_id: str,
         zone: Optional[Zone] = None,
     ) -> FlexibleIP:
         """
-        Duplicate a Virtual MAC from a given Flexible IP onto another attached on the same server.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param fip_id: Flexible IPs need to be attached to the same server.
-        :param duplicate_from_fip_id: Flexible IPs need to be attached to the same server.
+        Duplicate a virtual MAC address to another flexible IP.
+        Duplicate a virtual MAC address from a given flexible IP to another flexible IP attached to the same server.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param fip_id: ID of the flexible IP on which to duplicate the virtual MAC.
+        Note that the flexible IPs need to be attached to the same server.
+        :param duplicate_from_fip_id: ID of the flexible IP to duplicate the Virtual MAC from.
+        Note that flexible IPs need to be attached to the same server.
         :return: :class:`FlexibleIP <FlexibleIP>`
 
         Usage:
         ::
 
             result = await api.duplicate_mac_addr(
                 fip_id="example",
@@ -507,14 +522,20 @@
         self,
         *,
         fip_id: str,
         dst_fip_id: str,
         zone: Optional[Zone] = None,
     ) -> FlexibleIP:
         """
+        Relocate an existing virtual MAC address to a different flexible IP.
+        Relocate a virtual MAC (Media Access Control) address from an existing flexible IP to a different flexible IP.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param fip_id:
+        :param dst_fip_id:
+        :return: :class:`FlexibleIP <FlexibleIP>`
 
         Usage:
         ::
 
             result = await api.move_mac_addr(
                 fip_id="example",
                 dst_fip_id="example",
@@ -543,17 +564,19 @@
     async def delete_mac_addr(
         self,
         *,
         fip_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Remove a virtual MAC from a Flexible IP
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param fip_id: If the Flexible IP belongs to a MAC group, the MAC will be removed from the MAC group and from the Flexible IP.
+        Detach a given virtual MAC address from an existing flexible IP.
+        Detach a given MAC (Media Access Control) address from an existing flexible IP.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param fip_id: ID of the flexible IP from which to delete the virtual MAC.
+        If the flexible IP belongs to a MAC group, the MAC will be removed from both the MAC group and flexible IP.
 
         Usage:
         ::
 
             result = await api.delete_mac_addr(fip_id="example")
         """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/flexibleip/v1alpha1/content.py` & `scaleway_async-1.0.0/scaleway_async/flexibleip/v1alpha1/content.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-0.9.0/scaleway_async/flexibleip/v1alpha1/marshalling.py` & `scaleway_async-1.0.0/scaleway_async/flexibleip/v1alpha1/marshalling.py`

 * *Files 27% similar despite different names*

```diff
@@ -26,203 +26,244 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'MACAddress' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("mac_address")
+    field = data.get("mac_address", None)
     args["mac_address"] = field
 
-    field = data.get("mac_type")
+    field = data.get("mac_type", None)
     args["mac_type"] = field
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("zone")
+    field = data.get("zone", None)
     args["zone"] = field
 
     return MACAddress(**args)
 
 
 def unmarshal_FlexibleIP(data: Any) -> FlexibleIP:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'FlexibleIP' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("description")
+    field = data.get("description", None)
     args["description"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("ip_address")
+    field = data.get("ip_address", None)
     args["ip_address"] = field
 
-    field = data.get("mac_address")
+    field = data.get("mac_address", None)
     args["mac_address"] = unmarshal_MACAddress(field) if field is not None else None
 
-    field = data.get("organization_id")
+    field = data.get("organization_id", None)
     args["organization_id"] = field
 
-    field = data.get("project_id")
+    field = data.get("project_id", None)
     args["project_id"] = field
 
-    field = data.get("reverse")
+    field = data.get("reverse", None)
     args["reverse"] = field
 
-    field = data.get("server_id")
+    field = data.get("server_id", None)
     args["server_id"] = field
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("tags")
+    field = data.get("tags", None)
     args["tags"] = field
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("zone")
+    field = data.get("zone", None)
     args["zone"] = field
 
     return FlexibleIP(**args)
 
 
 def unmarshal_AttachFlexibleIPsResponse(data: Any) -> AttachFlexibleIPsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'AttachFlexibleIPsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("flexible_ips")
-    args["flexible_ips"] = [unmarshal_FlexibleIP(v) for v in data["flexible_ips"]]
+    field = data.get("flexible_ips", None)
+    args["flexible_ips"] = (
+        [unmarshal_FlexibleIP(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return AttachFlexibleIPsResponse(**args)
 
 
 def unmarshal_DetachFlexibleIPsResponse(data: Any) -> DetachFlexibleIPsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'DetachFlexibleIPsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("flexible_ips")
-    args["flexible_ips"] = [unmarshal_FlexibleIP(v) for v in data["flexible_ips"]]
+    field = data.get("flexible_ips", None)
+    args["flexible_ips"] = (
+        [unmarshal_FlexibleIP(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return DetachFlexibleIPsResponse(**args)
 
 
 def unmarshal_ListFlexibleIPsResponse(data: Any) -> ListFlexibleIPsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListFlexibleIPsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("flexible_ips")
-    args["flexible_ips"] = [unmarshal_FlexibleIP(v) for v in data["flexible_ips"]]
+    field = data.get("flexible_ips", None)
+    args["flexible_ips"] = (
+        [unmarshal_FlexibleIP(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListFlexibleIPsResponse(**args)
 
 
 def marshal_AttachFlexibleIPRequest(
     request: AttachFlexibleIPRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "fips_ids": request.fips_ids,
-        "server_id": request.server_id,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.fips_ids is not None:
+        output["fips_ids"] = request.fips_ids
+
+    if request.server_id is not None:
+        output["server_id"] = request.server_id
+
+    return output
 
 
 def marshal_CreateFlexibleIPRequest(
     request: CreateFlexibleIPRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "description": request.description,
-        "is_ipv6": request.is_ipv6,
-        "project_id": request.project_id or defaults.default_project_id,
-        "reverse": request.reverse,
-        "server_id": request.server_id,
-        "tags": request.tags,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.is_ipv6 is not None:
+        output["is_ipv6"] = request.is_ipv6
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    if request.reverse is not None:
+        output["reverse"] = request.reverse
+
+    if request.server_id is not None:
+        output["server_id"] = request.server_id
+
+    if request.tags is not None:
+        output["tags"] = request.tags
+
+    return output
 
 
 def marshal_DetachFlexibleIPRequest(
     request: DetachFlexibleIPRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "fips_ids": request.fips_ids,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.fips_ids is not None:
+        output["fips_ids"] = request.fips_ids
+
+    return output
 
 
 def marshal_DuplicateMACAddrRequest(
     request: DuplicateMACAddrRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "duplicate_from_fip_id": request.duplicate_from_fip_id,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.duplicate_from_fip_id is not None:
+        output["duplicate_from_fip_id"] = request.duplicate_from_fip_id
+
+    return output
 
 
 def marshal_GenerateMACAddrRequest(
     request: GenerateMACAddrRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "mac_type": MACAddressType(request.mac_type)
-        if request.mac_type is not None
-        else None,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.mac_type is not None:
+        output["mac_type"] = MACAddressType(request.mac_type)
+
+    return output
 
 
 def marshal_MoveMACAddrRequest(
     request: MoveMACAddrRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "dst_fip_id": request.dst_fip_id,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.dst_fip_id is not None:
+        output["dst_fip_id"] = request.dst_fip_id
+
+    return output
 
 
 def marshal_UpdateFlexibleIPRequest(
     request: UpdateFlexibleIPRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "description": request.description,
-        "reverse": request.reverse,
-        "tags": request.tags,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.reverse is not None:
+        output["reverse"] = request.reverse
+
+    if request.tags is not None:
+        output["tags"] = request.tags
+
+    return output
```

### Comparing `scaleway_async-0.9.0/scaleway_async/function/v1beta1/__init__.py` & `scaleway_async-1.0.0/scaleway_async/container/v1beta1/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,117 +1,103 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
+from .types import ContainerHttpOption
+from .types import ContainerPrivacy
+from .types import ContainerProtocol
+from .types import ContainerStatus
 from .types import CronStatus
 from .types import DomainStatus
-from .types import FunctionHttpOption
-from .types import FunctionPrivacy
-from .types import FunctionRuntime
-from .types import FunctionStatus
+from .types import ListContainersRequestOrderBy
 from .types import ListCronsRequestOrderBy
 from .types import ListDomainsRequestOrderBy
-from .types import ListFunctionsRequestOrderBy
 from .types import ListLogsRequestOrderBy
 from .types import ListNamespacesRequestOrderBy
 from .types import ListTokensRequestOrderBy
 from .types import ListTriggersRequestOrderBy
 from .types import LogStream
 from .types import NamespaceStatus
 from .types import NullValue
-from .types import RuntimeStatus
 from .types import TokenStatus
 from .types import TriggerInputType
 from .types import TriggerStatus
+from .types import Container
 from .types import CreateTriggerRequestMnqNatsClientConfig
 from .types import CreateTriggerRequestMnqSqsClientConfig
 from .types import CreateTriggerRequestSqsClientConfig
 from .types import Cron
 from .types import Domain
-from .types import DownloadURL
-from .types import Function
+from .types import ListContainersResponse
 from .types import ListCronsResponse
 from .types import ListDomainsResponse
-from .types import ListFunctionRuntimesResponse
-from .types import ListFunctionsResponse
 from .types import ListLogsResponse
 from .types import ListNamespacesResponse
 from .types import ListTokensResponse
 from .types import ListTriggersResponse
 from .types import Log
 from .types import Namespace
-from .types import Runtime
 from .types import Secret
 from .types import SecretHashedValue
 from .types import Token
 from .types import Trigger
 from .types import TriggerMnqNatsClientConfig
 from .types import TriggerMnqSqsClientConfig
 from .types import TriggerSqsClientConfig
-from .types import UpdateTriggerRequestMnqNatsClientConfig
-from .types import UpdateTriggerRequestMnqSqsClientConfig
 from .types import UpdateTriggerRequestSqsClientConfig
-from .types import UploadURL
+from .content import CONTAINER_TRANSIENT_STATUSES
 from .content import CRON_TRANSIENT_STATUSES
 from .content import DOMAIN_TRANSIENT_STATUSES
-from .content import FUNCTION_TRANSIENT_STATUSES
 from .content import NAMESPACE_TRANSIENT_STATUSES
 from .content import TOKEN_TRANSIENT_STATUSES
 from .content import TRIGGER_TRANSIENT_STATUSES
-from .api import FunctionV1Beta1API
+from .api import ContainerV1Beta1API
 
 __all__ = [
+    "ContainerHttpOption",
+    "ContainerPrivacy",
+    "ContainerProtocol",
+    "ContainerStatus",
     "CronStatus",
     "DomainStatus",
-    "FunctionHttpOption",
-    "FunctionPrivacy",
-    "FunctionRuntime",
-    "FunctionStatus",
+    "ListContainersRequestOrderBy",
     "ListCronsRequestOrderBy",
     "ListDomainsRequestOrderBy",
-    "ListFunctionsRequestOrderBy",
     "ListLogsRequestOrderBy",
     "ListNamespacesRequestOrderBy",
     "ListTokensRequestOrderBy",
     "ListTriggersRequestOrderBy",
     "LogStream",
     "NamespaceStatus",
     "NullValue",
-    "RuntimeStatus",
     "TokenStatus",
     "TriggerInputType",
     "TriggerStatus",
+    "Container",
     "CreateTriggerRequestMnqNatsClientConfig",
     "CreateTriggerRequestMnqSqsClientConfig",
     "CreateTriggerRequestSqsClientConfig",
     "Cron",
     "Domain",
-    "DownloadURL",
-    "Function",
+    "ListContainersResponse",
     "ListCronsResponse",
     "ListDomainsResponse",
-    "ListFunctionRuntimesResponse",
-    "ListFunctionsResponse",
     "ListLogsResponse",
     "ListNamespacesResponse",
     "ListTokensResponse",
     "ListTriggersResponse",
     "Log",
     "Namespace",
-    "Runtime",
     "Secret",
     "SecretHashedValue",
     "Token",
     "Trigger",
     "TriggerMnqNatsClientConfig",
     "TriggerMnqSqsClientConfig",
     "TriggerSqsClientConfig",
-    "UpdateTriggerRequestMnqNatsClientConfig",
-    "UpdateTriggerRequestMnqSqsClientConfig",
     "UpdateTriggerRequestSqsClientConfig",
-    "UploadURL",
+    "CONTAINER_TRANSIENT_STATUSES",
     "CRON_TRANSIENT_STATUSES",
     "DOMAIN_TRANSIENT_STATUSES",
-    "FUNCTION_TRANSIENT_STATUSES",
     "NAMESPACE_TRANSIENT_STATUSES",
     "TOKEN_TRANSIENT_STATUSES",
     "TRIGGER_TRANSIENT_STATUSES",
-    "FunctionV1Beta1API",
+    "ContainerV1Beta1API",
 ]
```

### Comparing `scaleway_async-0.9.0/scaleway_async/function/v1beta1/api.py` & `scaleway_async-1.0.0/scaleway_async/container/v1beta1/api.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,139 +14,132 @@
     fetch_all_pages_async,
     random_name,
     resolve_one_of,
     validate_path_param,
     wait_for_resource_async,
 )
 from .types import (
-    FunctionHttpOption,
-    FunctionPrivacy,
-    FunctionRuntime,
+    ContainerHttpOption,
+    ContainerPrivacy,
+    ContainerProtocol,
+    ListContainersRequestOrderBy,
     ListCronsRequestOrderBy,
     ListDomainsRequestOrderBy,
-    ListFunctionsRequestOrderBy,
     ListLogsRequestOrderBy,
     ListNamespacesRequestOrderBy,
     ListTokensRequestOrderBy,
     ListTriggersRequestOrderBy,
+    Container,
     CreateTriggerRequestMnqNatsClientConfig,
     CreateTriggerRequestMnqSqsClientConfig,
     CreateTriggerRequestSqsClientConfig,
     Cron,
     Domain,
-    DownloadURL,
-    Function,
+    ListContainersResponse,
     ListCronsResponse,
     ListDomainsResponse,
-    ListFunctionRuntimesResponse,
-    ListFunctionsResponse,
     ListLogsResponse,
     ListNamespacesResponse,
     ListTokensResponse,
     ListTriggersResponse,
     Log,
     Namespace,
     Secret,
     Token,
     Trigger,
-    UpdateTriggerRequestMnqNatsClientConfig,
-    UpdateTriggerRequestMnqSqsClientConfig,
     UpdateTriggerRequestSqsClientConfig,
-    UploadURL,
     CreateNamespaceRequest,
     UpdateNamespaceRequest,
-    CreateFunctionRequest,
-    UpdateFunctionRequest,
+    CreateContainerRequest,
+    UpdateContainerRequest,
     CreateCronRequest,
     UpdateCronRequest,
     CreateDomainRequest,
     CreateTokenRequest,
     CreateTriggerRequest,
     UpdateTriggerRequest,
 )
 from .content import (
+    CONTAINER_TRANSIENT_STATUSES,
     CRON_TRANSIENT_STATUSES,
     DOMAIN_TRANSIENT_STATUSES,
-    FUNCTION_TRANSIENT_STATUSES,
     NAMESPACE_TRANSIENT_STATUSES,
     TOKEN_TRANSIENT_STATUSES,
     TRIGGER_TRANSIENT_STATUSES,
 )
 from .marshalling import (
+    marshal_CreateContainerRequest,
     marshal_CreateCronRequest,
     marshal_CreateDomainRequest,
-    marshal_CreateFunctionRequest,
     marshal_CreateNamespaceRequest,
     marshal_CreateTokenRequest,
     marshal_CreateTriggerRequest,
+    marshal_UpdateContainerRequest,
     marshal_UpdateCronRequest,
-    marshal_UpdateFunctionRequest,
     marshal_UpdateNamespaceRequest,
     marshal_UpdateTriggerRequest,
+    unmarshal_Container,
     unmarshal_Cron,
     unmarshal_Domain,
-    unmarshal_Function,
     unmarshal_Namespace,
     unmarshal_Token,
     unmarshal_Trigger,
-    unmarshal_DownloadURL,
+    unmarshal_ListContainersResponse,
     unmarshal_ListCronsResponse,
     unmarshal_ListDomainsResponse,
-    unmarshal_ListFunctionRuntimesResponse,
-    unmarshal_ListFunctionsResponse,
     unmarshal_ListLogsResponse,
     unmarshal_ListNamespacesResponse,
     unmarshal_ListTokensResponse,
     unmarshal_ListTriggersResponse,
-    unmarshal_UploadURL,
 )
 
 
-class FunctionV1Beta1API(API):
+class ContainerV1Beta1API(API):
     """
-    Functions API.
+    Serverless Containers API.
 
-    Serverless functions API.
+    Serverless Containers API.
     """
 
     async def list_namespaces(
         self,
         *,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListNamespacesRequestOrderBy = ListNamespacesRequestOrderBy.CREATED_AT_ASC,
         name: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> ListNamespacesResponse:
         """
-        List all your namespaces
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page:
-        :param page_size:
-        :param order_by:
-        :param name:
-        :param organization_id:
-        :param project_id:
+        List all your namespaces.
+        List all namespaces in a specified region.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number.
+        :param page_size: Number of namespaces per page.
+        :param order_by: Order of the namespaces.
+        :param name: Name of the namespaces.
+        :param organization_id: UUID of the Organization the namespace belongs to.
+        :param project_id: UUID of the Project the namespace belongs to.
         :return: :class:`ListNamespacesResponse <ListNamespacesResponse>`
 
         Usage:
         ::
 
             result = await api.list_namespaces()
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "GET",
-            f"/functions/v1beta1/regions/{param_region}/namespaces",
+            f"/containers/v1beta1/regions/{param_region}/namespaces",
             params={
                 "name": name,
                 "order_by": order_by,
                 "organization_id": organization_id
                 or self.client.default_organization_id,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
@@ -165,22 +158,23 @@
         page_size: Optional[int] = None,
         order_by: Optional[ListNamespacesRequestOrderBy] = None,
         name: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> List[Namespace]:
         """
-        List all your namespaces
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page:
-        :param page_size:
-        :param order_by:
-        :param name:
-        :param organization_id:
-        :param project_id:
+        List all your namespaces.
+        List all namespaces in a specified region.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number.
+        :param page_size: Number of namespaces per page.
+        :param order_by: Order of the namespaces.
+        :param name: Name of the namespaces.
+        :param organization_id: UUID of the Organization the namespace belongs to.
+        :param project_id: UUID of the Project the namespace belongs to.
         :return: :class:`List[ListNamespacesResponse] <List[ListNamespacesResponse]>`
 
         Usage:
         ::
 
             result = await api.list_namespaces_all()
         """
@@ -203,17 +197,18 @@
     async def get_namespace(
         self,
         *,
         namespace_id: str,
         region: Optional[Region] = None,
     ) -> Namespace:
         """
-        Get the namespace associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param namespace_id:
+        Get a namespace.
+        Get the namespace associated with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param namespace_id: UUID of the namespace to get.
         :return: :class:`Namespace <Namespace>`
 
         Usage:
         ::
 
             result = await api.get_namespace(namespace_id="example")
         """
@@ -221,15 +216,15 @@
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_namespace_id = validate_path_param("namespace_id", namespace_id)
 
         res = self._request(
             "GET",
-            f"/functions/v1beta1/regions/{param_region}/namespaces/{param_namespace_id}",
+            f"/containers/v1beta1/regions/{param_region}/namespaces/{param_namespace_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_Namespace(res.json())
 
     async def wait_for_namespace(
         self,
@@ -238,16 +233,16 @@
         region: Optional[Region] = None,
         options: Optional[
             WaitForOptions[Namespace, Union[bool, Awaitable[bool]]]
         ] = None,
     ) -> Namespace:
         """
         Waits for :class:`Namespace <Namespace>` to be in a final state.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param namespace_id:
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param namespace_id: UUID of the namespace to get.
         :param options: The options for the waiter
         :return: :class:`Namespace <Namespace>`
 
         Usage:
         ::
 
             result = api.wait_for_namespace(namespace_id="example")
@@ -275,40 +270,41 @@
         name: Optional[str] = None,
         environment_variables: Optional[Dict[str, str]] = None,
         project_id: Optional[str] = None,
         description: Optional[str] = None,
         secret_environment_variables: Optional[List[Secret]] = None,
     ) -> Namespace:
         """
-        Create a new namespace
-        :param region: Region to target. If none is passed will use default region from the config
-        :param name:
-        :param environment_variables:
-        :param project_id:
-        :param description:
-        :param secret_environment_variables:
+        Create a new namespace.
+        Create a new namespace in a specified region.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param name: Name of the namespace to create.
+        :param environment_variables: Environment variables of the namespace to create.
+        :param project_id: UUID of the Project in which the namespace will be created.
+        :param description: Description of the namespace to create.
+        :param secret_environment_variables: Secret environment variables of the namespace to create.
         :return: :class:`Namespace <Namespace>`
 
         Usage:
         ::
 
             result = await api.create_namespace()
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "POST",
-            f"/functions/v1beta1/regions/{param_region}/namespaces",
+            f"/containers/v1beta1/regions/{param_region}/namespaces",
             body=marshal_CreateNamespaceRequest(
                 CreateNamespaceRequest(
                     region=region,
-                    name=name or random_name(prefix="ns"),
+                    name=name or random_name(prefix="cns"),
                     environment_variables=environment_variables,
                     project_id=project_id,
                     description=description,
                     secret_environment_variables=secret_environment_variables,
                 ),
                 self.client,
             ),
@@ -323,20 +319,21 @@
         namespace_id: str,
         region: Optional[Region] = None,
         environment_variables: Optional[Dict[str, str]] = None,
         description: Optional[str] = None,
         secret_environment_variables: Optional[List[Secret]] = None,
     ) -> Namespace:
         """
-        Update the space associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param namespace_id:
-        :param environment_variables:
-        :param description:
-        :param secret_environment_variables:
+        Update an existing namespace.
+        Update the space associated with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param namespace_id: UUID of the namespace to update.
+        :param environment_variables: Environment variables of the namespace to update.
+        :param description: Description of the namespace to update.
+        :param secret_environment_variables: Secret environment variables of the namespace to update.
         :return: :class:`Namespace <Namespace>`
 
         Usage:
         ::
 
             result = await api.update_namespace(namespace_id="example")
         """
@@ -344,15 +341,15 @@
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_namespace_id = validate_path_param("namespace_id", namespace_id)
 
         res = self._request(
             "PATCH",
-            f"/functions/v1beta1/regions/{param_region}/namespaces/{param_namespace_id}",
+            f"/containers/v1beta1/regions/{param_region}/namespaces/{param_namespace_id}",
             body=marshal_UpdateNamespaceRequest(
                 UpdateNamespaceRequest(
                     namespace_id=namespace_id,
                     region=region,
                     environment_variables=environment_variables,
                     description=description,
                     secret_environment_variables=secret_environment_variables,
@@ -367,17 +364,18 @@
     async def delete_namespace(
         self,
         *,
         namespace_id: str,
         region: Optional[Region] = None,
     ) -> Namespace:
         """
-        Delete the namespace associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param namespace_id:
+        Delete an existing namespace.
+        Delete the namespace associated with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param namespace_id: UUID of the namespace to delete.
         :return: :class:`Namespace <Namespace>`
 
         Usage:
         ::
 
             result = await api.delete_namespace(namespace_id="example")
         """
@@ -385,598 +383,527 @@
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_namespace_id = validate_path_param("namespace_id", namespace_id)
 
         res = self._request(
             "DELETE",
-            f"/functions/v1beta1/regions/{param_region}/namespaces/{param_namespace_id}",
+            f"/containers/v1beta1/regions/{param_region}/namespaces/{param_namespace_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_Namespace(res.json())
 
-    async def list_functions(
+    async def list_containers(
         self,
         *,
         namespace_id: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
-        order_by: ListFunctionsRequestOrderBy = ListFunctionsRequestOrderBy.CREATED_AT_ASC,
+        order_by: ListContainersRequestOrderBy = ListContainersRequestOrderBy.CREATED_AT_ASC,
         name: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
-    ) -> ListFunctionsResponse:
+    ) -> ListContainersResponse:
         """
-        List all your functions
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page:
-        :param page_size:
-        :param order_by:
-        :param namespace_id:
-        :param name:
-        :param organization_id:
-        :param project_id:
-        :return: :class:`ListFunctionsResponse <ListFunctionsResponse>`
+        List all your containers.
+        List all containers for a specified region.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number.
+        :param page_size: Number of containers per page.
+        :param order_by: Order of the containers.
+        :param namespace_id: UUID of the namespace the container belongs to.
+        :param name: Name of the container.
+        :param organization_id: UUID of the Organization the container belongs to.
+        :param project_id: UUID of the Project the container belongs to.
+        :return: :class:`ListContainersResponse <ListContainersResponse>`
 
         Usage:
         ::
 
-            result = await api.list_functions(namespace_id="example")
+            result = await api.list_containers(namespace_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "GET",
-            f"/functions/v1beta1/regions/{param_region}/functions",
+            f"/containers/v1beta1/regions/{param_region}/containers",
             params={
                 "name": name,
                 "namespace_id": namespace_id,
                 "order_by": order_by,
                 "organization_id": organization_id
                 or self.client.default_organization_id,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
                 "project_id": project_id or self.client.default_project_id,
             },
         )
 
         self._throw_on_error(res)
-        return unmarshal_ListFunctionsResponse(res.json())
+        return unmarshal_ListContainersResponse(res.json())
 
-    async def list_functions_all(
+    async def list_containers_all(
         self,
         *,
         namespace_id: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
-        order_by: Optional[ListFunctionsRequestOrderBy] = None,
+        order_by: Optional[ListContainersRequestOrderBy] = None,
         name: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
-    ) -> List[Function]:
+    ) -> List[Container]:
         """
-        List all your functions
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page:
-        :param page_size:
-        :param order_by:
-        :param namespace_id:
-        :param name:
-        :param organization_id:
-        :param project_id:
-        :return: :class:`List[ListFunctionsResponse] <List[ListFunctionsResponse]>`
+        List all your containers.
+        List all containers for a specified region.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number.
+        :param page_size: Number of containers per page.
+        :param order_by: Order of the containers.
+        :param namespace_id: UUID of the namespace the container belongs to.
+        :param name: Name of the container.
+        :param organization_id: UUID of the Organization the container belongs to.
+        :param project_id: UUID of the Project the container belongs to.
+        :return: :class:`List[ListContainersResponse] <List[ListContainersResponse]>`
 
         Usage:
         ::
 
-            result = await api.list_functions_all(namespace_id="example")
+            result = await api.list_containers_all(namespace_id="example")
         """
 
         return await fetch_all_pages_async(
-            type=ListFunctionsResponse,
-            key="functions",
-            fetcher=self.list_functions,
+            type=ListContainersResponse,
+            key="containers",
+            fetcher=self.list_containers,
             args={
                 "namespace_id": namespace_id,
                 "region": region,
                 "page": page,
                 "page_size": page_size,
                 "order_by": order_by,
                 "name": name,
                 "organization_id": organization_id,
                 "project_id": project_id,
             },
         )
 
-    async def get_function(
+    async def get_container(
         self,
         *,
-        function_id: str,
+        container_id: str,
         region: Optional[Region] = None,
-    ) -> Function:
+    ) -> Container:
         """
-        Get the function associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param function_id:
-        :return: :class:`Function <Function>`
+        Get a container.
+        Get the container associated with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param container_id: UUID of the container to get.
+        :return: :class:`Container <Container>`
 
         Usage:
         ::
 
-            result = await api.get_function(function_id="example")
+            result = await api.get_container(container_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_function_id = validate_path_param("function_id", function_id)
+        param_container_id = validate_path_param("container_id", container_id)
 
         res = self._request(
             "GET",
-            f"/functions/v1beta1/regions/{param_region}/functions/{param_function_id}",
+            f"/containers/v1beta1/regions/{param_region}/containers/{param_container_id}",
         )
 
         self._throw_on_error(res)
-        return unmarshal_Function(res.json())
+        return unmarshal_Container(res.json())
 
-    async def wait_for_function(
+    async def wait_for_container(
         self,
         *,
-        function_id: str,
+        container_id: str,
         region: Optional[Region] = None,
         options: Optional[
-            WaitForOptions[Function, Union[bool, Awaitable[bool]]]
+            WaitForOptions[Container, Union[bool, Awaitable[bool]]]
         ] = None,
-    ) -> Function:
+    ) -> Container:
         """
-        Waits for :class:`Function <Function>` to be in a final state.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param function_id:
+        Waits for :class:`Container <Container>` to be in a final state.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param container_id: UUID of the container to get.
         :param options: The options for the waiter
-        :return: :class:`Function <Function>`
+        :return: :class:`Container <Container>`
 
         Usage:
         ::
 
-            result = api.wait_for_function(function_id="example")
+            result = api.wait_for_container(container_id="example")
         """
 
         if not options:
             options = WaitForOptions()
 
         if not options.stop:
-            options.stop = lambda res: res.status not in FUNCTION_TRANSIENT_STATUSES
+            options.stop = lambda res: res.status not in CONTAINER_TRANSIENT_STATUSES
 
         return await wait_for_resource_async(
-            fetcher=self.get_function,
+            fetcher=self.get_container,
             options=options,
             args={
-                "function_id": function_id,
+                "container_id": container_id,
                 "region": region,
             },
         )
 
-    async def create_function(
+    async def create_container(
         self,
         *,
         namespace_id: str,
-        runtime: FunctionRuntime,
-        privacy: FunctionPrivacy,
-        http_option: FunctionHttpOption,
+        name: str,
+        privacy: ContainerPrivacy,
+        protocol: ContainerProtocol,
+        http_option: ContainerHttpOption,
         region: Optional[Region] = None,
-        name: Optional[str] = None,
         environment_variables: Optional[Dict[str, str]] = None,
         min_scale: Optional[int] = None,
         max_scale: Optional[int] = None,
         memory_limit: Optional[int] = None,
+        cpu_limit: Optional[int] = None,
         timeout: Optional[str] = None,
-        handler: Optional[str] = None,
         description: Optional[str] = None,
+        registry_image: Optional[str] = None,
+        max_concurrency: Optional[int] = None,
+        port: Optional[int] = None,
         secret_environment_variables: Optional[List[Secret]] = None,
-    ) -> Function:
+    ) -> Container:
         """
-        Create a new function
-        :param region: Region to target. If none is passed will use default region from the config
-        :param name:
-        :param namespace_id:
-        :param environment_variables:
-        :param min_scale:
-        :param max_scale:
-        :param runtime:
-        :param memory_limit:
-        :param timeout:
-        :param handler:
-        :param privacy:
-        :param description:
-        :param secret_environment_variables:
-        :param http_option: possible values:
+        Create a new container.
+        Create a new container in the specified region.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param namespace_id: UUID of the namespace the container belongs to.
+        :param name: Name of the container.
+        :param environment_variables: Environment variables of the container.
+        :param min_scale: Minimum number of instances to scale the container to.
+        :param max_scale: Maximum number of instances to scale the container to.
+        :param memory_limit: Memory limit of the container in MB.
+        :param cpu_limit: CPU limit of the container in mvCPU.
+        :param timeout: Processing time limit for the container.
+        :param privacy: Privacy setting of the container.
+        :param description: Description of the container.
+        :param registry_image: Name of the registry image (e.g. "rg.fr-par.scw.cloud/something/image:tag").
+        :param max_concurrency: Number of maximum concurrent executions of the container.
+        :param protocol: Protocol the container uses.
+        :param port: Port the container listens on.
+        :param secret_environment_variables: Secret environment variables of the container.
+        :param http_option: Configure how HTTP and HTTPS requests are handled.
+        Possible values:
          - redirected: Responds to HTTP request with a 301 redirect to ask the clients to use HTTPS.
          - enabled: Serve both HTTP and HTTPS traffic.
-
-        :return: :class:`Function <Function>`
+        :return: :class:`Container <Container>`
 
         Usage:
         ::
 
-            result = await api.create_function(
+            result = await api.create_container(
                 namespace_id="example",
-                runtime=unknown_runtime,
+                name="example",
                 privacy=unknown_privacy,
+                protocol=unknown_protocol,
                 http_option=unknown_http_option,
             )
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "POST",
-            f"/functions/v1beta1/regions/{param_region}/functions",
-            body=marshal_CreateFunctionRequest(
-                CreateFunctionRequest(
+            f"/containers/v1beta1/regions/{param_region}/containers",
+            body=marshal_CreateContainerRequest(
+                CreateContainerRequest(
                     namespace_id=namespace_id,
-                    runtime=runtime,
+                    name=name,
                     privacy=privacy,
+                    protocol=protocol,
                     http_option=http_option,
                     region=region,
-                    name=name or random_name(prefix="fn"),
                     environment_variables=environment_variables,
                     min_scale=min_scale,
                     max_scale=max_scale,
                     memory_limit=memory_limit,
+                    cpu_limit=cpu_limit,
                     timeout=timeout,
-                    handler=handler,
                     description=description,
+                    registry_image=registry_image,
+                    max_concurrency=max_concurrency,
+                    port=port,
                     secret_environment_variables=secret_environment_variables,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
-        return unmarshal_Function(res.json())
+        return unmarshal_Container(res.json())
 
-    async def update_function(
+    async def update_container(
         self,
         *,
-        function_id: str,
-        runtime: FunctionRuntime,
-        privacy: FunctionPrivacy,
-        http_option: FunctionHttpOption,
+        container_id: str,
+        privacy: ContainerPrivacy,
+        protocol: ContainerProtocol,
+        http_option: ContainerHttpOption,
         region: Optional[Region] = None,
         environment_variables: Optional[Dict[str, str]] = None,
         min_scale: Optional[int] = None,
         max_scale: Optional[int] = None,
         memory_limit: Optional[int] = None,
+        cpu_limit: Optional[int] = None,
         timeout: Optional[str] = None,
         redeploy: Optional[bool] = None,
-        handler: Optional[str] = None,
         description: Optional[str] = None,
+        registry_image: Optional[str] = None,
+        max_concurrency: Optional[int] = None,
+        port: Optional[int] = None,
         secret_environment_variables: Optional[List[Secret]] = None,
-    ) -> Function:
+    ) -> Container:
         """
-        Update the function associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param function_id:
-        :param environment_variables:
-        :param min_scale:
-        :param max_scale:
-        :param runtime:
-        :param memory_limit:
-        :param timeout:
-        :param redeploy:
-        :param handler:
-        :param privacy:
-        :param description:
+        Update an existing container.
+        Update the container associated with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param container_id: UUID of the container to update.
+        :param environment_variables: Environment variables of the container.
+        :param min_scale: Minimum number of instances to scale the container to.
+        :param max_scale: Maximum number of instances to scale the container to.
+        :param memory_limit: Memory limit of the container in MB.
+        :param cpu_limit: CPU limit of the container in mvCPU.
+        :param timeout: Processing time limit for the container.
+        :param redeploy: Defines whether to redeploy failed containers.
+        :param privacy: Privacy settings of the container.
+        :param description: Description of the container.
+        :param registry_image: Name of the registry image (e.g. "rg.fr-par.scw.cloud/something/image:tag").
+        :param max_concurrency: Number of maximum concurrent executions of the container.
+        :param protocol:
+        :param port:
         :param secret_environment_variables:
-        :param http_option: possible values:
+        :param http_option: Configure how HTTP and HTTPS requests are handled.
+        Possible values:
          - redirected: Responds to HTTP request with a 301 redirect to ask the clients to use HTTPS.
          - enabled: Serve both HTTP and HTTPS traffic.
-
-        :return: :class:`Function <Function>`
+        :return: :class:`Container <Container>`
 
         Usage:
         ::
 
-            result = await api.update_function(
-                function_id="example",
-                runtime=unknown_runtime,
+            result = await api.update_container(
+                container_id="example",
                 privacy=unknown_privacy,
+                protocol=unknown_protocol,
                 http_option=unknown_http_option,
             )
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_function_id = validate_path_param("function_id", function_id)
+        param_container_id = validate_path_param("container_id", container_id)
 
         res = self._request(
             "PATCH",
-            f"/functions/v1beta1/regions/{param_region}/functions/{param_function_id}",
-            body=marshal_UpdateFunctionRequest(
-                UpdateFunctionRequest(
-                    function_id=function_id,
-                    runtime=runtime,
+            f"/containers/v1beta1/regions/{param_region}/containers/{param_container_id}",
+            body=marshal_UpdateContainerRequest(
+                UpdateContainerRequest(
+                    container_id=container_id,
                     privacy=privacy,
+                    protocol=protocol,
                     http_option=http_option,
                     region=region,
                     environment_variables=environment_variables,
                     min_scale=min_scale,
                     max_scale=max_scale,
                     memory_limit=memory_limit,
+                    cpu_limit=cpu_limit,
                     timeout=timeout,
                     redeploy=redeploy,
-                    handler=handler,
                     description=description,
+                    registry_image=registry_image,
+                    max_concurrency=max_concurrency,
+                    port=port,
                     secret_environment_variables=secret_environment_variables,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
-        return unmarshal_Function(res.json())
+        return unmarshal_Container(res.json())
 
-    async def delete_function(
+    async def delete_container(
         self,
         *,
-        function_id: str,
+        container_id: str,
         region: Optional[Region] = None,
-    ) -> Function:
+    ) -> Container:
         """
-        Delete the function associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param function_id:
-        :return: :class:`Function <Function>`
+        Delete a container.
+        Delete the container associated with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param container_id: UUID of the container to delete.
+        :return: :class:`Container <Container>`
 
         Usage:
         ::
 
-            result = await api.delete_function(function_id="example")
+            result = await api.delete_container(container_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_function_id = validate_path_param("function_id", function_id)
+        param_container_id = validate_path_param("container_id", container_id)
 
         res = self._request(
             "DELETE",
-            f"/functions/v1beta1/regions/{param_region}/functions/{param_function_id}",
+            f"/containers/v1beta1/regions/{param_region}/containers/{param_container_id}",
         )
 
         self._throw_on_error(res)
-        return unmarshal_Function(res.json())
+        return unmarshal_Container(res.json())
 
-    async def deploy_function(
+    async def deploy_container(
         self,
         *,
-        function_id: str,
+        container_id: str,
         region: Optional[Region] = None,
-    ) -> Function:
+    ) -> Container:
         """
-        Deploy a function associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param function_id:
-        :return: :class:`Function <Function>`
+        Deploy a container.
+        Deploy a container associated with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param container_id: UUID of the container to deploy.
+        :return: :class:`Container <Container>`
 
         Usage:
         ::
 
-            result = await api.deploy_function(function_id="example")
+            result = await api.deploy_container(container_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_function_id = validate_path_param("function_id", function_id)
+        param_container_id = validate_path_param("container_id", container_id)
 
         res = self._request(
             "POST",
-            f"/functions/v1beta1/regions/{param_region}/functions/{param_function_id}/deploy",
-        )
-
-        self._throw_on_error(res)
-        return unmarshal_Function(res.json())
-
-    async def list_function_runtimes(
-        self,
-        *,
-        region: Optional[Region] = None,
-    ) -> ListFunctionRuntimesResponse:
-        """
-        List available function runtimes.
-        :param region: Region to target. If none is passed will use default region from the config
-        :return: :class:`ListFunctionRuntimesResponse <ListFunctionRuntimesResponse>`
-
-        Usage:
-        ::
-
-            result = await api.list_function_runtimes()
-        """
-
-        param_region = validate_path_param(
-            "region", region or self.client.default_region
-        )
-
-        res = self._request(
-            "GET",
-            f"/functions/v1beta1/regions/{param_region}/runtimes",
+            f"/containers/v1beta1/regions/{param_region}/containers/{param_container_id}/deploy",
         )
 
         self._throw_on_error(res)
-        return unmarshal_ListFunctionRuntimesResponse(res.json())
-
-    async def get_function_upload_url(
-        self,
-        *,
-        function_id: str,
-        content_length: int,
-        region: Optional[Region] = None,
-    ) -> UploadURL:
-        """
-        Get an upload URL of a function associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param function_id:
-        :param content_length:
-        :return: :class:`UploadURL <UploadURL>`
-
-        Usage:
-        ::
-
-            result = await api.get_function_upload_url(
-                function_id="example",
-                content_length=1,
-            )
-        """
-
-        param_region = validate_path_param(
-            "region", region or self.client.default_region
-        )
-        param_function_id = validate_path_param("function_id", function_id)
-
-        res = self._request(
-            "GET",
-            f"/functions/v1beta1/regions/{param_region}/functions/{param_function_id}/upload-url",
-            params={
-                "content_length": content_length,
-            },
-        )
-
-        self._throw_on_error(res)
-        return unmarshal_UploadURL(res.json())
-
-    async def get_function_download_url(
-        self,
-        *,
-        function_id: str,
-        region: Optional[Region] = None,
-    ) -> DownloadURL:
-        """
-        Get a download URL for a function associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param function_id:
-        :return: :class:`DownloadURL <DownloadURL>`
-
-        Usage:
-        ::
-
-            result = await api.get_function_download_url(function_id="example")
-        """
-
-        param_region = validate_path_param(
-            "region", region or self.client.default_region
-        )
-        param_function_id = validate_path_param("function_id", function_id)
-
-        res = self._request(
-            "GET",
-            f"/functions/v1beta1/regions/{param_region}/functions/{param_function_id}/download-url",
-        )
-
-        self._throw_on_error(res)
-        return unmarshal_DownloadURL(res.json())
+        return unmarshal_Container(res.json())
 
     async def list_crons(
         self,
         *,
-        function_id: str,
+        container_id: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListCronsRequestOrderBy = ListCronsRequestOrderBy.CREATED_AT_ASC,
     ) -> ListCronsResponse:
         """
-        List all your crons
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page:
-        :param page_size:
-        :param order_by:
-        :param function_id:
+        List all your crons.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number.
+        :param page_size: Number of crons per page.
+        :param order_by: Order of the crons.
+        :param container_id: UUID of the container invoked by the cron.
         :return: :class:`ListCronsResponse <ListCronsResponse>`
 
         Usage:
         ::
 
-            result = await api.list_crons(function_id="example")
+            result = await api.list_crons(container_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "GET",
-            f"/functions/v1beta1/regions/{param_region}/crons",
+            f"/containers/v1beta1/regions/{param_region}/crons",
             params={
-                "function_id": function_id,
+                "container_id": container_id,
                 "order_by": order_by,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
             },
         )
 
         self._throw_on_error(res)
         return unmarshal_ListCronsResponse(res.json())
 
     async def list_crons_all(
         self,
         *,
-        function_id: str,
+        container_id: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListCronsRequestOrderBy] = None,
     ) -> List[Cron]:
         """
-        List all your crons
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page:
-        :param page_size:
-        :param order_by:
-        :param function_id:
+        List all your crons.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number.
+        :param page_size: Number of crons per page.
+        :param order_by: Order of the crons.
+        :param container_id: UUID of the container invoked by the cron.
         :return: :class:`List[ListCronsResponse] <List[ListCronsResponse]>`
 
         Usage:
         ::
 
-            result = await api.list_crons_all(function_id="example")
+            result = await api.list_crons_all(container_id="example")
         """
 
         return await fetch_all_pages_async(
             type=ListCronsResponse,
             key="crons",
             fetcher=self.list_crons,
             args={
-                "function_id": function_id,
+                "container_id": container_id,
                 "region": region,
                 "page": page,
                 "page_size": page_size,
                 "order_by": order_by,
             },
         )
 
     async def get_cron(
         self,
         *,
         cron_id: str,
         region: Optional[Region] = None,
     ) -> Cron:
         """
-        Get the cron associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param cron_id:
+        Get a cron.
+        Get the cron associated with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cron_id: UUID of the cron to get.
         :return: :class:`Cron <Cron>`
 
         Usage:
         ::
 
             result = await api.get_cron(cron_id="example")
         """
@@ -984,31 +911,31 @@
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_cron_id = validate_path_param("cron_id", cron_id)
 
         res = self._request(
             "GET",
-            f"/functions/v1beta1/regions/{param_region}/crons/{param_cron_id}",
+            f"/containers/v1beta1/regions/{param_region}/crons/{param_cron_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_Cron(res.json())
 
     async def wait_for_cron(
         self,
         *,
         cron_id: str,
         region: Optional[Region] = None,
         options: Optional[WaitForOptions[Cron, Union[bool, Awaitable[bool]]]] = None,
     ) -> Cron:
         """
         Waits for :class:`Cron <Cron>` to be in a final state.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param cron_id:
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cron_id: UUID of the cron to get.
         :param options: The options for the waiter
         :return: :class:`Cron <Cron>`
 
         Usage:
         ::
 
             result = api.wait_for_cron(cron_id="example")
@@ -1028,48 +955,48 @@
                 "region": region,
             },
         )
 
     async def create_cron(
         self,
         *,
-        function_id: str,
+        container_id: str,
         schedule: str,
         region: Optional[Region] = None,
         args: Optional[Dict[str, Any]] = None,
         name: Optional[str] = None,
     ) -> Cron:
         """
-        Create a new cron
-        :param region: Region to target. If none is passed will use default region from the config
-        :param function_id:
-        :param schedule:
-        :param args:
-        :param name:
+        Create a new cron.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param container_id: UUID of the container to invoke by the cron.
+        :param schedule: UNIX cron shedule.
+        :param args: Arguments to pass with the cron.
+        :param name: Name of the cron to create.
         :return: :class:`Cron <Cron>`
 
         Usage:
         ::
 
             result = await api.create_cron(
-                function_id="example",
+                container_id="example",
                 schedule="example",
             )
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "POST",
-            f"/functions/v1beta1/regions/{param_region}/crons",
+            f"/containers/v1beta1/regions/{param_region}/crons",
             body=marshal_CreateCronRequest(
                 CreateCronRequest(
-                    function_id=function_id,
+                    container_id=container_id,
                     schedule=schedule,
                     region=region,
                     args=args,
                     name=name,
                 ),
                 self.client,
             ),
@@ -1079,27 +1006,28 @@
         return unmarshal_Cron(res.json())
 
     async def update_cron(
         self,
         *,
         cron_id: str,
         region: Optional[Region] = None,
-        function_id: Optional[str] = None,
+        container_id: Optional[str] = None,
         schedule: Optional[str] = None,
         args: Optional[Dict[str, Any]] = None,
         name: Optional[str] = None,
     ) -> Cron:
         """
-        Update the cron associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param cron_id:
-        :param function_id:
-        :param schedule:
-        :param args:
-        :param name:
+        Update an existing cron.
+        Update the cron associated with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cron_id: UUID of the cron to update.
+        :param container_id: UUID of the container invoked by the cron.
+        :param schedule: UNIX cron schedule.
+        :param args: Arguments to pass with the cron.
+        :param name: Name of the cron.
         :return: :class:`Cron <Cron>`
 
         Usage:
         ::
 
             result = await api.update_cron(cron_id="example")
         """
@@ -1107,20 +1035,20 @@
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_cron_id = validate_path_param("cron_id", cron_id)
 
         res = self._request(
             "PATCH",
-            f"/functions/v1beta1/regions/{param_region}/crons/{param_cron_id}",
+            f"/containers/v1beta1/regions/{param_region}/crons/{param_cron_id}",
             body=marshal_UpdateCronRequest(
                 UpdateCronRequest(
                     cron_id=cron_id,
                     region=region,
-                    function_id=function_id,
+                    container_id=container_id,
                     schedule=schedule,
                     args=args,
                     name=name,
                 ),
                 self.client,
             ),
         )
@@ -1131,17 +1059,18 @@
     async def delete_cron(
         self,
         *,
         cron_id: str,
         region: Optional[Region] = None,
     ) -> Cron:
         """
-        Delete the cron associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param cron_id:
+        Delete an existing cron.
+        Delete the cron associated with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cron_id: UUID of the cron to delete.
         :return: :class:`Cron <Cron>`
 
         Usage:
         ::
 
             result = await api.delete_cron(cron_id="example")
         """
@@ -1149,188 +1078,193 @@
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_cron_id = validate_path_param("cron_id", cron_id)
 
         res = self._request(
             "DELETE",
-            f"/functions/v1beta1/regions/{param_region}/crons/{param_cron_id}",
+            f"/containers/v1beta1/regions/{param_region}/crons/{param_cron_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_Cron(res.json())
 
     async def list_logs(
         self,
         *,
-        function_id: str,
+        container_id: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListLogsRequestOrderBy = ListLogsRequestOrderBy.TIMESTAMP_DESC,
     ) -> ListLogsResponse:
         """
-        List your application logs
-        :param region: Region to target. If none is passed will use default region from the config
-        :param function_id:
-        :param page:
-        :param page_size:
-        :param order_by:
+        List your container logs.
+        List the logs of the container with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param container_id: UUID of the container.
+        :param page: Page number.
+        :param page_size: Number of logs per page.
+        :param order_by: Order of the logs.
         :return: :class:`ListLogsResponse <ListLogsResponse>`
 
         Usage:
         ::
 
-            result = await api.list_logs(function_id="example")
+            result = await api.list_logs(container_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_function_id = validate_path_param("function_id", function_id)
+        param_container_id = validate_path_param("container_id", container_id)
 
         res = self._request(
             "GET",
-            f"/functions/v1beta1/regions/{param_region}/functions/{param_function_id}/logs",
+            f"/containers/v1beta1/regions/{param_region}/containers/{param_container_id}/logs",
             params={
                 "order_by": order_by,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
             },
         )
 
         self._throw_on_error(res)
         return unmarshal_ListLogsResponse(res.json())
 
     async def list_logs_all(
         self,
         *,
-        function_id: str,
+        container_id: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListLogsRequestOrderBy] = None,
     ) -> List[Log]:
         """
-        List your application logs
-        :param region: Region to target. If none is passed will use default region from the config
-        :param function_id:
-        :param page:
-        :param page_size:
-        :param order_by:
+        List your container logs.
+        List the logs of the container with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param container_id: UUID of the container.
+        :param page: Page number.
+        :param page_size: Number of logs per page.
+        :param order_by: Order of the logs.
         :return: :class:`List[ListLogsResponse] <List[ListLogsResponse]>`
 
         Usage:
         ::
 
-            result = await api.list_logs_all(function_id="example")
+            result = await api.list_logs_all(container_id="example")
         """
 
         return await fetch_all_pages_async(
             type=ListLogsResponse,
             key="logs",
             fetcher=self.list_logs,
             args={
-                "function_id": function_id,
+                "container_id": container_id,
                 "region": region,
                 "page": page,
                 "page_size": page_size,
                 "order_by": order_by,
             },
         )
 
     async def list_domains(
         self,
         *,
-        function_id: str,
+        container_id: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListDomainsRequestOrderBy = ListDomainsRequestOrderBy.CREATED_AT_ASC,
     ) -> ListDomainsResponse:
         """
-        List all domain name bindings
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page:
-        :param page_size:
-        :param order_by:
-        :param function_id:
+        List all domain name bindings.
+        List all domain name bindings in a specified region.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number.
+        :param page_size: Number of domains per page.
+        :param order_by: Order of the domains.
+        :param container_id: UUID of the container the domain belongs to.
         :return: :class:`ListDomainsResponse <ListDomainsResponse>`
 
         Usage:
         ::
 
-            result = await api.list_domains(function_id="example")
+            result = await api.list_domains(container_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "GET",
-            f"/functions/v1beta1/regions/{param_region}/domains",
+            f"/containers/v1beta1/regions/{param_region}/domains",
             params={
-                "function_id": function_id,
+                "container_id": container_id,
                 "order_by": order_by,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
             },
         )
 
         self._throw_on_error(res)
         return unmarshal_ListDomainsResponse(res.json())
 
     async def list_domains_all(
         self,
         *,
-        function_id: str,
+        container_id: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListDomainsRequestOrderBy] = None,
     ) -> List[Domain]:
         """
-        List all domain name bindings
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page:
-        :param page_size:
-        :param order_by:
-        :param function_id:
+        List all domain name bindings.
+        List all domain name bindings in a specified region.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number.
+        :param page_size: Number of domains per page.
+        :param order_by: Order of the domains.
+        :param container_id: UUID of the container the domain belongs to.
         :return: :class:`List[ListDomainsResponse] <List[ListDomainsResponse]>`
 
         Usage:
         ::
 
-            result = await api.list_domains_all(function_id="example")
+            result = await api.list_domains_all(container_id="example")
         """
 
         return await fetch_all_pages_async(
             type=ListDomainsResponse,
             key="domains",
             fetcher=self.list_domains,
             args={
-                "function_id": function_id,
+                "container_id": container_id,
                 "region": region,
                 "page": page,
                 "page_size": page_size,
                 "order_by": order_by,
             },
         )
 
     async def get_domain(
         self,
         *,
         domain_id: str,
         region: Optional[Region] = None,
     ) -> Domain:
         """
-        Get a domain name binding
-        :param region: Region to target. If none is passed will use default region from the config
-        :param domain_id:
+        Get a domain name binding.
+        Get a domain name binding for the container with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param domain_id: UUID of the domain to get.
         :return: :class:`Domain <Domain>`
 
         Usage:
         ::
 
             result = await api.get_domain(domain_id="example")
         """
@@ -1338,31 +1272,31 @@
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_domain_id = validate_path_param("domain_id", domain_id)
 
         res = self._request(
             "GET",
-            f"/functions/v1beta1/regions/{param_region}/domains/{param_domain_id}",
+            f"/containers/v1beta1/regions/{param_region}/domains/{param_domain_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_Domain(res.json())
 
     async def wait_for_domain(
         self,
         *,
         domain_id: str,
         region: Optional[Region] = None,
         options: Optional[WaitForOptions[Domain, Union[bool, Awaitable[bool]]]] = None,
     ) -> Domain:
         """
         Waits for :class:`Domain <Domain>` to be in a final state.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param domain_id:
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param domain_id: UUID of the domain to get.
         :param options: The options for the waiter
         :return: :class:`Domain <Domain>`
 
         Usage:
         ::
 
             result = api.wait_for_domain(domain_id="example")
@@ -1383,44 +1317,45 @@
             },
         )
 
     async def create_domain(
         self,
         *,
         hostname: str,
-        function_id: str,
+        container_id: str,
         region: Optional[Region] = None,
     ) -> Domain:
         """
-        Create a domain name binding
-        :param region: Region to target. If none is passed will use default region from the config
-        :param hostname:
-        :param function_id:
+        Create a domain name binding.
+        Create a domain name binding for the container with the specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param hostname: Domain to assign.
+        :param container_id: UUID of the container to assign the domain to.
         :return: :class:`Domain <Domain>`
 
         Usage:
         ::
 
             result = await api.create_domain(
                 hostname="example",
-                function_id="example",
+                container_id="example",
             )
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "POST",
-            f"/functions/v1beta1/regions/{param_region}/domains",
+            f"/containers/v1beta1/regions/{param_region}/domains",
             body=marshal_CreateDomainRequest(
                 CreateDomainRequest(
                     hostname=hostname,
-                    function_id=function_id,
+                    container_id=container_id,
                     region=region,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
@@ -1429,17 +1364,18 @@
     async def delete_domain(
         self,
         *,
         domain_id: str,
         region: Optional[Region] = None,
     ) -> Domain:
         """
-        Delete a domain name binding
-        :param region: Region to target. If none is passed will use default region from the config
-        :param domain_id:
+        Delete a domain name binding.
+        Delete the domain name binding with the specific ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param domain_id: UUID of the domain to delete.
         :return: :class:`Domain <Domain>`
 
         Usage:
         ::
 
             result = await api.delete_domain(domain_id="example")
         """
@@ -1447,25 +1383,25 @@
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_domain_id = validate_path_param("domain_id", domain_id)
 
         res = self._request(
             "DELETE",
-            f"/functions/v1beta1/regions/{param_region}/domains/{param_domain_id}",
+            f"/containers/v1beta1/regions/{param_region}/domains/{param_domain_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_Domain(res.json())
 
     async def issue_jwt(
         self,
         *,
         region: Optional[Region] = None,
-        function_id: Optional[str] = None,
+        container_id: Optional[str] = None,
         namespace_id: Optional[str] = None,
         expires_at: Optional[datetime] = None,
     ) -> Token:
         """
         :deprecated
 
         Usage:
@@ -1476,64 +1412,68 @@
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "GET",
-            f"/functions/v1beta1/regions/{param_region}/issue-jwt",
+            f"/containers/v1beta1/regions/{param_region}/issue-jwt",
             params={
                 "expires_at": expires_at,
                 **resolve_one_of(
                     [
-                        OneOfPossibility("function_id", function_id),
+                        OneOfPossibility("container_id", container_id),
                         OneOfPossibility("namespace_id", namespace_id),
                     ]
                 ),
             },
         )
 
         self._throw_on_error(res)
         return unmarshal_Token(res.json())
 
     async def create_token(
         self,
         *,
         region: Optional[Region] = None,
-        function_id: Optional[str] = None,
+        container_id: Optional[str] = None,
         namespace_id: Optional[str] = None,
         description: Optional[str] = None,
         expires_at: Optional[datetime] = None,
     ) -> Token:
         """
-        Create a new revocable token
-        :param region: Region to target. If none is passed will use default region from the config
-        :param function_id: One-of ('scope'): at most one of 'function_id', 'namespace_id' could be set.
-        :param namespace_id: One-of ('scope'): at most one of 'function_id', 'namespace_id' could be set.
-        :param description:
-        :param expires_at:
+        Create a new revocable token.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param container_id: UUID of the container to create the token for.
+
+        One-of ('scope'): at most one of 'container_id', 'namespace_id' could be set.
+        :param namespace_id: UUID of the namespace to create the token for.
+
+        One-of ('scope'): at most one of 'container_id', 'namespace_id' could be set.
+        :param description: Description of the token.
+        :param expires_at: Expiry date of the token.
         :return: :class:`Token <Token>`
 
         Usage:
         ::
 
             result = await api.create_token()
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "POST",
-            f"/functions/v1beta1/regions/{param_region}/tokens",
+            f"/containers/v1beta1/regions/{param_region}/tokens",
             body=marshal_CreateTokenRequest(
                 CreateTokenRequest(
                     region=region,
-                    function_id=function_id,
+                    container_id=container_id,
                     namespace_id=namespace_id,
                     description=description,
                     expires_at=expires_at,
                 ),
                 self.client,
             ),
         )
@@ -1544,17 +1484,18 @@
     async def get_token(
         self,
         *,
         token_id: str,
         region: Optional[Region] = None,
     ) -> Token:
         """
-        Get a token
-        :param region: Region to target. If none is passed will use default region from the config
-        :param token_id:
+        Get a token.
+        Get a token with a specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param token_id: UUID of the token to get.
         :return: :class:`Token <Token>`
 
         Usage:
         ::
 
             result = await api.get_token(token_id="example")
         """
@@ -1562,31 +1503,31 @@
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_token_id = validate_path_param("token_id", token_id)
 
         res = self._request(
             "GET",
-            f"/functions/v1beta1/regions/{param_region}/tokens/{param_token_id}",
+            f"/containers/v1beta1/regions/{param_region}/tokens/{param_token_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_Token(res.json())
 
     async def wait_for_token(
         self,
         *,
         token_id: str,
         region: Optional[Region] = None,
         options: Optional[WaitForOptions[Token, Union[bool, Awaitable[bool]]]] = None,
     ) -> Token:
         """
         Waits for :class:`Token <Token>` to be in a final state.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param token_id:
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param token_id: UUID of the token to get.
         :param options: The options for the waiter
         :return: :class:`Token <Token>`
 
         Usage:
         ::
 
             result = api.wait_for_token(token_id="example")
@@ -1610,42 +1551,43 @@
     async def list_tokens(
         self,
         *,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListTokensRequestOrderBy = ListTokensRequestOrderBy.CREATED_AT_ASC,
-        function_id: Optional[str] = None,
+        container_id: Optional[str] = None,
         namespace_id: Optional[str] = None,
     ) -> ListTokensResponse:
         """
-        List all tokens
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page:
-        :param page_size:
-        :param order_by:
-        :param function_id:
-        :param namespace_id:
+        List all tokens.
+        List all tokens belonging to a specified Organization or Project.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number.
+        :param page_size: Number of tokens per page.
+        :param order_by: Order of the tokens.
+        :param container_id: UUID of the container the token belongs to.
+        :param namespace_id: UUID of the namespace the token belongs to.
         :return: :class:`ListTokensResponse <ListTokensResponse>`
 
         Usage:
         ::
 
             result = await api.list_tokens()
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "GET",
-            f"/functions/v1beta1/regions/{param_region}/tokens",
+            f"/containers/v1beta1/regions/{param_region}/tokens",
             params={
-                "function_id": function_id,
+                "container_id": container_id,
                 "namespace_id": namespace_id,
                 "order_by": order_by,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
             },
         )
 
@@ -1655,25 +1597,26 @@
     async def list_tokens_all(
         self,
         *,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListTokensRequestOrderBy] = None,
-        function_id: Optional[str] = None,
+        container_id: Optional[str] = None,
         namespace_id: Optional[str] = None,
     ) -> List[Token]:
         """
-        List all tokens
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page:
-        :param page_size:
-        :param order_by:
-        :param function_id:
-        :param namespace_id:
+        List all tokens.
+        List all tokens belonging to a specified Organization or Project.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number.
+        :param page_size: Number of tokens per page.
+        :param order_by: Order of the tokens.
+        :param container_id: UUID of the container the token belongs to.
+        :param namespace_id: UUID of the namespace the token belongs to.
         :return: :class:`List[ListTokensResponse] <List[ListTokensResponse]>`
 
         Usage:
         ::
 
             result = await api.list_tokens_all()
         """
@@ -1683,29 +1626,30 @@
             key="tokens",
             fetcher=self.list_tokens,
             args={
                 "region": region,
                 "page": page,
                 "page_size": page_size,
                 "order_by": order_by,
-                "function_id": function_id,
+                "container_id": container_id,
                 "namespace_id": namespace_id,
             },
         )
 
     async def delete_token(
         self,
         *,
         token_id: str,
         region: Optional[Region] = None,
     ) -> Token:
         """
-        Delete a token
-        :param region: Region to target. If none is passed will use default region from the config
-        :param token_id:
+        Delete a token.
+        Delete a token with a specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param token_id: UUID of the token to delete.
         :return: :class:`Token <Token>`
 
         Usage:
         ::
 
             result = await api.delete_token(token_id="example")
         """
@@ -1713,56 +1657,65 @@
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_token_id = validate_path_param("token_id", token_id)
 
         res = self._request(
             "DELETE",
-            f"/functions/v1beta1/regions/{param_region}/tokens/{param_token_id}",
+            f"/containers/v1beta1/regions/{param_region}/tokens/{param_token_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_Token(res.json())
 
     async def create_trigger(
         self,
         *,
         name: str,
-        description: str,
-        function_id: str,
+        container_id: str,
         region: Optional[Region] = None,
+        description: Optional[str] = None,
         scw_sqs_config: Optional[CreateTriggerRequestMnqSqsClientConfig] = None,
         sqs_config: Optional[CreateTriggerRequestSqsClientConfig] = None,
         scw_nats_config: Optional[CreateTriggerRequestMnqNatsClientConfig] = None,
     ) -> Trigger:
         """
+        Create a trigger.
+        Create a new trigger for a specified container.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param name:
+        :param description:
+        :param container_id:
+        :param scw_sqs_config: One-of ('config'): at most one of 'scw_sqs_config', 'sqs_config', 'scw_nats_config' could be set.
+        :param sqs_config: One-of ('config'): at most one of 'scw_sqs_config', 'sqs_config', 'scw_nats_config' could be set.
+        :param scw_nats_config: One-of ('config'): at most one of 'scw_sqs_config', 'sqs_config', 'scw_nats_config' could be set.
+        :return: :class:`Trigger <Trigger>`
 
         Usage:
         ::
 
             result = await api.create_trigger(
                 name="example",
-                description="example",
-                function_id="example",
+                container_id="example",
             )
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "POST",
-            f"/functions/v1beta1/regions/{param_region}/triggers",
+            f"/containers/v1beta1/regions/{param_region}/triggers",
             body=marshal_CreateTriggerRequest(
                 CreateTriggerRequest(
                     name=name,
-                    description=description,
-                    function_id=function_id,
+                    container_id=container_id,
                     region=region,
+                    description=description,
                     scw_sqs_config=scw_sqs_config,
                     sqs_config=sqs_config,
                     scw_nats_config=scw_nats_config,
                 ),
                 self.client,
             ),
         )
@@ -1773,44 +1726,49 @@
     async def get_trigger(
         self,
         *,
         trigger_id: str,
         region: Optional[Region] = None,
     ) -> Trigger:
         """
+        Get a trigger.
+        Get a trigger with a specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param trigger_id:
+        :return: :class:`Trigger <Trigger>`
 
         Usage:
         ::
 
             result = await api.get_trigger(trigger_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_trigger_id = validate_path_param("trigger_id", trigger_id)
 
         res = self._request(
             "GET",
-            f"/functions/v1beta1/regions/{param_region}/triggers/{param_trigger_id}",
+            f"/containers/v1beta1/regions/{param_region}/triggers/{param_trigger_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_Trigger(res.json())
 
     async def wait_for_trigger(
         self,
         *,
         trigger_id: str,
         region: Optional[Region] = None,
         options: Optional[WaitForOptions[Trigger, Union[bool, Awaitable[bool]]]] = None,
     ) -> Trigger:
         """
         Waits for :class:`Trigger <Trigger>` to be in a final state.
-        :param region: Region to target. If none is passed will use default region from the config
+        :param region: Region to target. If none is passed will use default region from the config.
         :param trigger_id:
         :param options: The options for the waiter
         :return: :class:`Trigger <Trigger>`
 
         Usage:
         ::
 
@@ -1835,43 +1793,53 @@
     async def list_triggers(
         self,
         *,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListTriggersRequestOrderBy = ListTriggersRequestOrderBy.CREATED_AT_ASC,
-        function_id: Optional[str] = None,
+        container_id: Optional[str] = None,
         namespace_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> ListTriggersResponse:
         """
+        List all triggers.
+        List all triggers belonging to a specified Organization or Project.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page:
+        :param page_size:
+        :param order_by:
+        :param container_id: One-of ('scope'): at most one of 'container_id', 'namespace_id', 'project_id' could be set.
+        :param namespace_id: One-of ('scope'): at most one of 'container_id', 'namespace_id', 'project_id' could be set.
+        :param project_id: One-of ('scope'): at most one of 'container_id', 'namespace_id', 'project_id' could be set.
+        :return: :class:`ListTriggersResponse <ListTriggersResponse>`
 
         Usage:
         ::
 
             result = await api.list_triggers()
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "GET",
-            f"/functions/v1beta1/regions/{param_region}/triggers",
+            f"/containers/v1beta1/regions/{param_region}/triggers",
             params={
                 "order_by": order_by,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
                 **resolve_one_of(
                     [
                         OneOfPossibility(
                             "project_id", project_id, self.client.default_project_id
                         ),
-                        OneOfPossibility("function_id", function_id),
+                        OneOfPossibility("container_id", container_id),
                         OneOfPossibility("namespace_id", namespace_id),
                     ]
                 ),
             },
         )
 
         self._throw_on_error(res)
@@ -1880,19 +1848,28 @@
     async def list_triggers_all(
         self,
         *,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListTriggersRequestOrderBy] = None,
-        function_id: Optional[str] = None,
+        container_id: Optional[str] = None,
         namespace_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> List[Trigger]:
         """
+        List all triggers.
+        List all triggers belonging to a specified Organization or Project.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page:
+        :param page_size:
+        :param order_by:
+        :param container_id: One-of ('scope'): at most one of 'container_id', 'namespace_id', 'project_id' could be set.
+        :param namespace_id: One-of ('scope'): at most one of 'container_id', 'namespace_id', 'project_id' could be set.
+        :param project_id: One-of ('scope'): at most one of 'container_id', 'namespace_id', 'project_id' could be set.
         :return: :class:`List[ListTriggersResponse] <List[ListTriggersResponse]>`
 
         Usage:
         ::
 
             result = await api.list_triggers_all()
         """
@@ -1902,56 +1879,60 @@
             key="triggers",
             fetcher=self.list_triggers,
             args={
                 "region": region,
                 "page": page,
                 "page_size": page_size,
                 "order_by": order_by,
-                "function_id": function_id,
+                "container_id": container_id,
                 "namespace_id": namespace_id,
                 "project_id": project_id,
             },
         )
 
     async def update_trigger(
         self,
         *,
         trigger_id: str,
         region: Optional[Region] = None,
         name: Optional[str] = None,
         description: Optional[str] = None,
-        scw_sqs_config: Optional[UpdateTriggerRequestMnqSqsClientConfig] = None,
         sqs_config: Optional[UpdateTriggerRequestSqsClientConfig] = None,
-        scw_nats_config: Optional[UpdateTriggerRequestMnqNatsClientConfig] = None,
     ) -> Trigger:
         """
+        Update a trigger.
+        Update a trigger with a specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param trigger_id:
+        :param name:
+        :param description:
+        :param sqs_config: One-of ('config'): at most one of 'sqs_config' could be set.
+        :return: :class:`Trigger <Trigger>`
 
         Usage:
         ::
 
             result = await api.update_trigger(trigger_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_trigger_id = validate_path_param("trigger_id", trigger_id)
 
         res = self._request(
             "PATCH",
-            f"/functions/v1beta1/regions/{param_region}/triggers/{param_trigger_id}",
+            f"/containers/v1beta1/regions/{param_region}/triggers/{param_trigger_id}",
             body=marshal_UpdateTriggerRequest(
                 UpdateTriggerRequest(
                     trigger_id=trigger_id,
                     region=region,
                     name=name,
                     description=description,
-                    scw_sqs_config=scw_sqs_config,
                     sqs_config=sqs_config,
-                    scw_nats_config=scw_nats_config,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_Trigger(res.json())
@@ -1959,26 +1940,31 @@
     async def delete_trigger(
         self,
         *,
         trigger_id: str,
         region: Optional[Region] = None,
     ) -> Trigger:
         """
+        Delete a trigger.
+        Delete a trigger with a specified ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param trigger_id:
+        :return: :class:`Trigger <Trigger>`
 
         Usage:
         ::
 
             result = await api.delete_trigger(trigger_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_trigger_id = validate_path_param("trigger_id", trigger_id)
 
         res = self._request(
             "DELETE",
-            f"/functions/v1beta1/regions/{param_region}/triggers/{param_trigger_id}",
+            f"/containers/v1beta1/regions/{param_region}/triggers/{param_trigger_id}",
         )
 
         self._throw_on_error(res)
         return unmarshal_Trigger(res.json())
```

### Comparing `scaleway_async-0.9.0/scaleway_async/function/v1beta1/content.py` & `scaleway_async-1.0.0/scaleway_async/function/v1beta1/content.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-0.9.0/scaleway_async/function/v1beta1/marshalling.py` & `scaleway_async-1.0.0/scaleway_async/function/v1beta1/marshalling.py`

 * *Files 16% similar despite different names*

```diff
@@ -34,16 +34,14 @@
     Secret,
     SecretHashedValue,
     Token,
     Trigger,
     TriggerMnqNatsClientConfig,
     TriggerMnqSqsClientConfig,
     TriggerSqsClientConfig,
-    UpdateTriggerRequestMnqNatsClientConfig,
-    UpdateTriggerRequestMnqSqsClientConfig,
     UpdateTriggerRequestSqsClientConfig,
     UploadURL,
     CreateNamespaceRequest,
     UpdateNamespaceRequest,
     CreateFunctionRequest,
     UpdateFunctionRequest,
     CreateCronRequest,
@@ -59,830 +57,1003 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'SecretHashedValue' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("hashed_value")
+    field = data.get("hashed_value", None)
     args["hashed_value"] = field
 
-    field = data.get("key")
+    field = data.get("key", None)
     args["key"] = field
 
     return SecretHashedValue(**args)
 
 
 def unmarshal_TriggerMnqNatsClientConfig(data: Any) -> TriggerMnqNatsClientConfig:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'TriggerMnqNatsClientConfig' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("mnq_namespace_id")
+    field = data.get("mnq_credential_id", None)
+    args["mnq_credential_id"] = field
+
+    field = data.get("mnq_namespace_id", None)
     args["mnq_namespace_id"] = field
 
-    field = data.get("mnq_project_id")
+    field = data.get("mnq_project_id", None)
     args["mnq_project_id"] = field
 
-    field = data.get("mnq_region")
+    field = data.get("mnq_region", None)
     args["mnq_region"] = field
 
-    field = data.get("subject")
+    field = data.get("subject", None)
     args["subject"] = field
 
     return TriggerMnqNatsClientConfig(**args)
 
 
 def unmarshal_TriggerMnqSqsClientConfig(data: Any) -> TriggerMnqSqsClientConfig:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'TriggerMnqSqsClientConfig' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("mnq_namespace_id")
+    field = data.get("mnq_credential_id", None)
+    args["mnq_credential_id"] = field
+
+    field = data.get("mnq_namespace_id", None)
     args["mnq_namespace_id"] = field
 
-    field = data.get("mnq_project_id")
+    field = data.get("mnq_project_id", None)
     args["mnq_project_id"] = field
 
-    field = data.get("mnq_region")
+    field = data.get("mnq_region", None)
     args["mnq_region"] = field
 
-    field = data.get("queue")
+    field = data.get("queue", None)
     args["queue"] = field
 
     return TriggerMnqSqsClientConfig(**args)
 
 
 def unmarshal_TriggerSqsClientConfig(data: Any) -> TriggerSqsClientConfig:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'TriggerSqsClientConfig' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("access_key")
+    field = data.get("access_key", None)
     args["access_key"] = field
 
-    field = data.get("endpoint")
+    field = data.get("endpoint", None)
     args["endpoint"] = field
 
-    field = data.get("queue_url")
+    field = data.get("queue_url", None)
     args["queue_url"] = field
 
-    field = data.get("secret_key")
+    field = data.get("secret_key", None)
     args["secret_key"] = field
 
     return TriggerSqsClientConfig(**args)
 
 
 def unmarshal_Cron(data: Any) -> Cron:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Cron' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("args")
+    field = data.get("args", None)
     args["args"] = field
 
-    field = data.get("function_id")
+    field = data.get("function_id", None)
     args["function_id"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("schedule")
+    field = data.get("schedule", None)
     args["schedule"] = field
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
     return Cron(**args)
 
 
 def unmarshal_Domain(data: Any) -> Domain:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Domain' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("error_message")
+    field = data.get("error_message", None)
     args["error_message"] = field
 
-    field = data.get("function_id")
+    field = data.get("function_id", None)
     args["function_id"] = field
 
-    field = data.get("hostname")
+    field = data.get("hostname", None)
     args["hostname"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("url")
+    field = data.get("url", None)
     args["url"] = field
 
     return Domain(**args)
 
 
 def unmarshal_Function(data: Any) -> Function:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Function' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("cpu_limit")
+    field = data.get("build_message", None)
+    args["build_message"] = field
+
+    field = data.get("cpu_limit", None)
     args["cpu_limit"] = field
 
-    field = data.get("description")
+    field = data.get("description", None)
     args["description"] = field
 
-    field = data.get("domain_name")
+    field = data.get("domain_name", None)
     args["domain_name"] = field
 
-    field = data.get("environment_variables")
+    field = data.get("environment_variables", None)
     args["environment_variables"] = field
 
-    field = data.get("error_message")
+    field = data.get("error_message", None)
     args["error_message"] = field
 
-    field = data.get("handler")
+    field = data.get("handler", None)
     args["handler"] = field
 
-    field = data.get("http_option")
+    field = data.get("http_option", None)
     args["http_option"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("max_scale")
+    field = data.get("max_scale", None)
     args["max_scale"] = field
 
-    field = data.get("memory_limit")
+    field = data.get("memory_limit", None)
     args["memory_limit"] = field
 
-    field = data.get("min_scale")
+    field = data.get("min_scale", None)
     args["min_scale"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("namespace_id")
+    field = data.get("namespace_id", None)
     args["namespace_id"] = field
 
-    field = data.get("privacy")
+    field = data.get("privacy", None)
     args["privacy"] = field
 
-    field = data.get("region")
+    field = data.get("region", None)
     args["region"] = field
 
-    field = data.get("runtime")
+    field = data.get("runtime", None)
     args["runtime"] = field
 
-    field = data.get("runtime_message")
+    field = data.get("runtime_message", None)
     args["runtime_message"] = field
 
-    field = data.get("secret_environment_variables")
-    args["secret_environment_variables"] = [
-        unmarshal_SecretHashedValue(v) for v in data["secret_environment_variables"]
-    ]
+    field = data.get("secret_environment_variables", None)
+    args["secret_environment_variables"] = (
+        [unmarshal_SecretHashedValue(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("timeout")
+    field = data.get("timeout", None)
     args["timeout"] = field
 
     return Function(**args)
 
 
 def unmarshal_Log(data: Any) -> Log:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Log' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("level")
+    field = data.get("level", None)
     args["level"] = field
 
-    field = data.get("message")
+    field = data.get("message", None)
     args["message"] = field
 
-    field = data.get("source")
+    field = data.get("source", None)
     args["source"] = field
 
-    field = data.get("stream")
+    field = data.get("stream", None)
     args["stream"] = field
 
-    field = data.get("timestamp")
+    field = data.get("timestamp", None)
     args["timestamp"] = parser.isoparse(field) if type(field) is str else field
 
     return Log(**args)
 
 
 def unmarshal_Namespace(data: Any) -> Namespace:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Namespace' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("description")
+    field = data.get("description", None)
     args["description"] = field
 
-    field = data.get("environment_variables")
+    field = data.get("environment_variables", None)
     args["environment_variables"] = field
 
-    field = data.get("error_message")
+    field = data.get("error_message", None)
     args["error_message"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("organization_id")
+    field = data.get("organization_id", None)
     args["organization_id"] = field
 
-    field = data.get("project_id")
+    field = data.get("project_id", None)
     args["project_id"] = field
 
-    field = data.get("region")
+    field = data.get("region", None)
     args["region"] = field
 
-    field = data.get("registry_endpoint")
+    field = data.get("registry_endpoint", None)
     args["registry_endpoint"] = field
 
-    field = data.get("registry_namespace_id")
+    field = data.get("registry_namespace_id", None)
     args["registry_namespace_id"] = field
 
-    field = data.get("secret_environment_variables")
-    args["secret_environment_variables"] = [
-        unmarshal_SecretHashedValue(v) for v in data["secret_environment_variables"]
-    ]
+    field = data.get("secret_environment_variables", None)
+    args["secret_environment_variables"] = (
+        [unmarshal_SecretHashedValue(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
     return Namespace(**args)
 
 
 def unmarshal_Runtime(data: Any) -> Runtime:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Runtime' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("code_sample")
+    field = data.get("code_sample", None)
     args["code_sample"] = field
 
-    field = data.get("default_handler")
+    field = data.get("default_handler", None)
     args["default_handler"] = field
 
-    field = data.get("extension")
+    field = data.get("extension", None)
     args["extension"] = field
 
-    field = data.get("implementation")
+    field = data.get("implementation", None)
     args["implementation"] = field
 
-    field = data.get("language")
+    field = data.get("language", None)
     args["language"] = field
 
-    field = data.get("name")
+    field = data.get("logo_url", None)
+    args["logo_url"] = field
+
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("status_message")
+    field = data.get("status_message", None)
     args["status_message"] = field
 
-    field = data.get("version")
+    field = data.get("version", None)
     args["version"] = field
 
     return Runtime(**args)
 
 
 def unmarshal_Token(data: Any) -> Token:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Token' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("description")
+    field = data.get("description", None)
     args["description"] = field
 
-    field = data.get("expires_at")
+    field = data.get("expires_at", None)
     args["expires_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("function_id")
+    field = data.get("function_id", None)
     args["function_id"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("namespace_id")
+    field = data.get("namespace_id", None)
     args["namespace_id"] = field
 
-    field = data.get("public_key")
+    field = data.get("public_key", None)
     args["public_key"] = field
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("token")
+    field = data.get("token", None)
     args["token"] = field
 
     return Token(**args)
 
 
 def unmarshal_Trigger(data: Any) -> Trigger:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Trigger' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("description")
+    field = data.get("description", None)
     args["description"] = field
 
-    field = data.get("error_message")
+    field = data.get("error_message", None)
     args["error_message"] = field
 
-    field = data.get("function_id")
+    field = data.get("function_id", None)
     args["function_id"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("input_type")
+    field = data.get("input_type", None)
     args["input_type"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("scw_nats_config")
+    field = data.get("scw_nats_config", None)
     args["scw_nats_config"] = (
         unmarshal_TriggerMnqNatsClientConfig(field) if field is not None else None
     )
 
-    field = data.get("scw_sqs_config")
+    field = data.get("scw_sqs_config", None)
     args["scw_sqs_config"] = (
         unmarshal_TriggerMnqSqsClientConfig(field) if field is not None else None
     )
 
-    field = data.get("sqs_config")
+    field = data.get("sqs_config", None)
     args["sqs_config"] = (
         unmarshal_TriggerSqsClientConfig(field) if field is not None else None
     )
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
     return Trigger(**args)
 
 
 def unmarshal_DownloadURL(data: Any) -> DownloadURL:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'DownloadURL' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("headers")
+    field = data.get("headers", None)
     args["headers"] = field
 
-    field = data.get("url")
+    field = data.get("url", None)
     args["url"] = field
 
     return DownloadURL(**args)
 
 
 def unmarshal_ListCronsResponse(data: Any) -> ListCronsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListCronsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("crons")
-    args["crons"] = [unmarshal_Cron(v) for v in data["crons"]]
+    field = data.get("crons", None)
+    args["crons"] = [unmarshal_Cron(v) for v in field] if field is not None else None
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListCronsResponse(**args)
 
 
 def unmarshal_ListDomainsResponse(data: Any) -> ListDomainsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListDomainsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("domains")
-    args["domains"] = [unmarshal_Domain(v) for v in data["domains"]]
+    field = data.get("domains", None)
+    args["domains"] = (
+        [unmarshal_Domain(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListDomainsResponse(**args)
 
 
 def unmarshal_ListFunctionRuntimesResponse(data: Any) -> ListFunctionRuntimesResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListFunctionRuntimesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("runtimes")
-    args["runtimes"] = [unmarshal_Runtime(v) for v in data["runtimes"]]
+    field = data.get("runtimes", None)
+    args["runtimes"] = (
+        [unmarshal_Runtime(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListFunctionRuntimesResponse(**args)
 
 
 def unmarshal_ListFunctionsResponse(data: Any) -> ListFunctionsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListFunctionsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("functions")
-    args["functions"] = [unmarshal_Function(v) for v in data["functions"]]
+    field = data.get("functions", None)
+    args["functions"] = (
+        [unmarshal_Function(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListFunctionsResponse(**args)
 
 
 def unmarshal_ListLogsResponse(data: Any) -> ListLogsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListLogsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("logs")
-    args["logs"] = [unmarshal_Log(v) for v in data["logs"]]
+    field = data.get("logs", None)
+    args["logs"] = [unmarshal_Log(v) for v in field] if field is not None else None
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListLogsResponse(**args)
 
 
 def unmarshal_ListNamespacesResponse(data: Any) -> ListNamespacesResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListNamespacesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("namespaces")
-    args["namespaces"] = [unmarshal_Namespace(v) for v in data["namespaces"]]
+    field = data.get("namespaces", None)
+    args["namespaces"] = (
+        [unmarshal_Namespace(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListNamespacesResponse(**args)
 
 
 def unmarshal_ListTokensResponse(data: Any) -> ListTokensResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListTokensResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("tokens")
-    args["tokens"] = [unmarshal_Token(v) for v in data["tokens"]]
+    field = data.get("tokens", None)
+    args["tokens"] = [unmarshal_Token(v) for v in field] if field is not None else None
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListTokensResponse(**args)
 
 
 def unmarshal_ListTriggersResponse(data: Any) -> ListTriggersResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListTriggersResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    field = data.get("triggers")
-    args["triggers"] = [unmarshal_Trigger(v) for v in data["triggers"]]
+    field = data.get("triggers", None)
+    args["triggers"] = (
+        [unmarshal_Trigger(v) for v in field] if field is not None else None
+    )
 
     return ListTriggersResponse(**args)
 
 
 def unmarshal_UploadURL(data: Any) -> UploadURL:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'UploadURL' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("headers")
+    field = data.get("headers", None)
     args["headers"] = field
 
-    field = data.get("url")
+    field = data.get("url", None)
     args["url"] = field
 
     return UploadURL(**args)
 
 
 def marshal_CreateTriggerRequestMnqNatsClientConfig(
     request: CreateTriggerRequestMnqNatsClientConfig,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "mnq_namespace_id": request.mnq_namespace_id,
-        "mnq_project_id": request.mnq_project_id,
-        "mnq_region": request.mnq_region,
-        "subject": request.subject,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.mnq_namespace_id is not None:
+        output["mnq_namespace_id"] = request.mnq_namespace_id
+
+    if request.mnq_project_id is not None:
+        output["mnq_project_id"] = request.mnq_project_id
+
+    if request.mnq_region is not None:
+        output["mnq_region"] = request.mnq_region
+
+    if request.subject is not None:
+        output["subject"] = request.subject
+
+    return output
 
 
 def marshal_CreateTriggerRequestMnqSqsClientConfig(
     request: CreateTriggerRequestMnqSqsClientConfig,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "mnq_namespace_id": request.mnq_namespace_id,
-        "mnq_project_id": request.mnq_project_id,
-        "mnq_region": request.mnq_region,
-        "queue": request.queue,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.mnq_namespace_id is not None:
+        output["mnq_namespace_id"] = request.mnq_namespace_id
+
+    if request.mnq_project_id is not None:
+        output["mnq_project_id"] = request.mnq_project_id
+
+    if request.mnq_region is not None:
+        output["mnq_region"] = request.mnq_region
+
+    if request.queue is not None:
+        output["queue"] = request.queue
+
+    return output
 
 
 def marshal_CreateTriggerRequestSqsClientConfig(
     request: CreateTriggerRequestSqsClientConfig,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "access_key": request.access_key,
-        "endpoint": request.endpoint,
-        "queue_url": request.queue_url,
-        "secret_key": request.secret_key,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.access_key is not None:
+        output["access_key"] = request.access_key
+
+    if request.endpoint is not None:
+        output["endpoint"] = request.endpoint
+
+    if request.queue_url is not None:
+        output["queue_url"] = request.queue_url
+
+    if request.secret_key is not None:
+        output["secret_key"] = request.secret_key
+
+    return output
 
 
 def marshal_Secret(
     request: Secret,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "key": request.key,
-        "value": request.value,
-    }
-
+    output: Dict[str, Any] = {}
 
-def marshal_UpdateTriggerRequestMnqNatsClientConfig(
-    request: UpdateTriggerRequestMnqNatsClientConfig,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "mnq_namespace_id": request.mnq_namespace_id,
-        "mnq_project_id": request.mnq_project_id,
-        "mnq_region": request.mnq_region,
-        "subject": request.subject,
-    }
+    if request.key is not None:
+        output["key"] = request.key
 
+    if request.value is not None:
+        output["value"] = request.value
 
-def marshal_UpdateTriggerRequestMnqSqsClientConfig(
-    request: UpdateTriggerRequestMnqSqsClientConfig,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "mnq_namespace_id": request.mnq_namespace_id,
-        "mnq_project_id": request.mnq_project_id,
-        "mnq_region": request.mnq_region,
-        "queue": request.queue,
-    }
+    return output
 
 
 def marshal_UpdateTriggerRequestSqsClientConfig(
     request: UpdateTriggerRequestSqsClientConfig,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "access_key": request.access_key,
-        "endpoint": request.endpoint,
-        "queue_url": request.queue_url,
-        "secret_key": request.secret_key,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.access_key is not None:
+        output["access_key"] = request.access_key
+
+    if request.secret_key is not None:
+        output["secret_key"] = request.secret_key
+
+    return output
 
 
 def marshal_CreateCronRequest(
     request: CreateCronRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "args": request.args,
-        "function_id": request.function_id,
-        "name": request.name,
-        "schedule": request.schedule,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.args is not None:
+        output["args"] = request.args
+
+    if request.function_id is not None:
+        output["function_id"] = request.function_id
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.schedule is not None:
+        output["schedule"] = request.schedule
+
+    return output
 
 
 def marshal_CreateDomainRequest(
     request: CreateDomainRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "function_id": request.function_id,
-        "hostname": request.hostname,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.function_id is not None:
+        output["function_id"] = request.function_id
+
+    if request.hostname is not None:
+        output["hostname"] = request.hostname
+
+    return output
 
 
 def marshal_CreateFunctionRequest(
     request: CreateFunctionRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "description": request.description,
-        "environment_variables": request.environment_variables,
-        "handler": request.handler,
-        "http_option": FunctionHttpOption(request.http_option),
-        "max_scale": request.max_scale,
-        "memory_limit": request.memory_limit,
-        "min_scale": request.min_scale,
-        "name": request.name,
-        "namespace_id": request.namespace_id,
-        "privacy": FunctionPrivacy(request.privacy),
-        "runtime": FunctionRuntime(request.runtime),
-        "secret_environment_variables": [
+    output: Dict[str, Any] = {}
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.environment_variables is not None:
+        output["environment_variables"] = request.environment_variables
+
+    if request.handler is not None:
+        output["handler"] = request.handler
+
+    if request.http_option is not None:
+        output["http_option"] = FunctionHttpOption(request.http_option)
+
+    if request.max_scale is not None:
+        output["max_scale"] = request.max_scale
+
+    if request.memory_limit is not None:
+        output["memory_limit"] = request.memory_limit
+
+    if request.min_scale is not None:
+        output["min_scale"] = request.min_scale
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.namespace_id is not None:
+        output["namespace_id"] = request.namespace_id
+
+    if request.privacy is not None:
+        output["privacy"] = FunctionPrivacy(request.privacy)
+
+    if request.runtime is not None:
+        output["runtime"] = FunctionRuntime(request.runtime)
+
+    if request.secret_environment_variables is not None:
+        output["secret_environment_variables"] = [
             marshal_Secret(v, defaults) for v in request.secret_environment_variables
         ]
-        if request.secret_environment_variables is not None
-        else None,
-        "timeout": request.timeout,
-    }
+
+    if request.timeout is not None:
+        output["timeout"] = request.timeout
+
+    return output
 
 
 def marshal_CreateNamespaceRequest(
     request: CreateNamespaceRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "description": request.description,
-        "environment_variables": request.environment_variables,
-        "name": request.name,
-        "project_id": request.project_id or defaults.default_project_id,
-        "secret_environment_variables": [
+    output: Dict[str, Any] = {}
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.environment_variables is not None:
+        output["environment_variables"] = request.environment_variables
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    if request.secret_environment_variables is not None:
+        output["secret_environment_variables"] = [
             marshal_Secret(v, defaults) for v in request.secret_environment_variables
         ]
-        if request.secret_environment_variables is not None
-        else None,
-    }
+
+    return output
 
 
 def marshal_CreateTokenRequest(
     request: CreateTokenRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("function_id", request.function_id),
-                OneOfPossibility("namespace_id", request.namespace_id),
+                OneOfPossibility(
+                    "function_id",
+                    request.function_id if request.function_id is not None else None,
+                ),
+                OneOfPossibility(
+                    "namespace_id",
+                    request.namespace_id if request.namespace_id is not None else None,
+                ),
             ]
         ),
-        "description": request.description,
-        "expires_at": request.expires_at,
-    }
+    )
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.expires_at is not None:
+        output["expires_at"] = request.expires_at
+
+    return output
 
 
 def marshal_CreateTriggerRequest(
     request: CreateTriggerRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("scw_sqs_config", request.scw_sqs_config),
-                OneOfPossibility("sqs_config", request.sqs_config),
-                OneOfPossibility("scw_nats_config", request.scw_nats_config),
+                OneOfPossibility(
+                    "scw_sqs_config",
+                    marshal_CreateTriggerRequestMnqSqsClientConfig(
+                        request.scw_sqs_config, defaults
+                    )
+                    if request.scw_sqs_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "sqs_config",
+                    marshal_CreateTriggerRequestSqsClientConfig(
+                        request.sqs_config, defaults
+                    )
+                    if request.sqs_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "scw_nats_config",
+                    marshal_CreateTriggerRequestMnqNatsClientConfig(
+                        request.scw_nats_config, defaults
+                    )
+                    if request.scw_nats_config is not None
+                    else None,
+                ),
             ]
         ),
-        "description": request.description,
-        "function_id": request.function_id,
-        "name": request.name,
-    }
+    )
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.function_id is not None:
+        output["function_id"] = request.function_id
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
 
 
 def marshal_UpdateCronRequest(
     request: UpdateCronRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "args": request.args,
-        "function_id": request.function_id,
-        "name": request.name,
-        "schedule": request.schedule,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.args is not None:
+        output["args"] = request.args
+
+    if request.function_id is not None:
+        output["function_id"] = request.function_id
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.schedule is not None:
+        output["schedule"] = request.schedule
+
+    return output
 
 
 def marshal_UpdateFunctionRequest(
     request: UpdateFunctionRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "description": request.description,
-        "environment_variables": request.environment_variables,
-        "handler": request.handler,
-        "http_option": FunctionHttpOption(request.http_option),
-        "max_scale": request.max_scale,
-        "memory_limit": request.memory_limit,
-        "min_scale": request.min_scale,
-        "privacy": FunctionPrivacy(request.privacy),
-        "redeploy": request.redeploy,
-        "runtime": FunctionRuntime(request.runtime),
-        "secret_environment_variables": [
+    output: Dict[str, Any] = {}
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.environment_variables is not None:
+        output["environment_variables"] = request.environment_variables
+
+    if request.handler is not None:
+        output["handler"] = request.handler
+
+    if request.http_option is not None:
+        output["http_option"] = FunctionHttpOption(request.http_option)
+
+    if request.max_scale is not None:
+        output["max_scale"] = request.max_scale
+
+    if request.memory_limit is not None:
+        output["memory_limit"] = request.memory_limit
+
+    if request.min_scale is not None:
+        output["min_scale"] = request.min_scale
+
+    if request.privacy is not None:
+        output["privacy"] = FunctionPrivacy(request.privacy)
+
+    if request.redeploy is not None:
+        output["redeploy"] = request.redeploy
+
+    if request.runtime is not None:
+        output["runtime"] = FunctionRuntime(request.runtime)
+
+    if request.secret_environment_variables is not None:
+        output["secret_environment_variables"] = [
             marshal_Secret(v, defaults) for v in request.secret_environment_variables
         ]
-        if request.secret_environment_variables is not None
-        else None,
-        "timeout": request.timeout,
-    }
+
+    if request.timeout is not None:
+        output["timeout"] = request.timeout
+
+    return output
 
 
 def marshal_UpdateNamespaceRequest(
     request: UpdateNamespaceRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "description": request.description,
-        "environment_variables": request.environment_variables,
-        "secret_environment_variables": [
+    output: Dict[str, Any] = {}
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.environment_variables is not None:
+        output["environment_variables"] = request.environment_variables
+
+    if request.secret_environment_variables is not None:
+        output["secret_environment_variables"] = [
             marshal_Secret(v, defaults) for v in request.secret_environment_variables
         ]
-        if request.secret_environment_variables is not None
-        else None,
-    }
+
+    return output
 
 
 def marshal_UpdateTriggerRequest(
     request: UpdateTriggerRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("scw_sqs_config", request.scw_sqs_config),
-                OneOfPossibility("sqs_config", request.sqs_config),
-                OneOfPossibility("scw_nats_config", request.scw_nats_config),
+                OneOfPossibility(
+                    "sqs_config",
+                    marshal_UpdateTriggerRequestSqsClientConfig(
+                        request.sqs_config, defaults
+                    )
+                    if request.sqs_config is not None
+                    else None,
+                ),
             ]
         ),
-        "description": request.description,
-        "name": request.name,
-    }
+    )
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
```

### Comparing `scaleway_async-0.9.0/scaleway_async/iam/v1alpha1/__init__.py` & `scaleway_async-1.0.0/scaleway_async/iam/v1alpha1/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-0.9.0/scaleway_async/iam/v1alpha1/api.py` & `scaleway_async-1.0.0/scaleway_async/iam/v1alpha1/api.py`

 * *Files 11% similar despite different names*

```diff
@@ -43,34 +43,38 @@
     Rule,
     RuleSpecs,
     SSHKey,
     SetRulesResponse,
     User,
     CreateSSHKeyRequest,
     UpdateSSHKeyRequest,
+    CreateUserRequest,
     CreateApplicationRequest,
     UpdateApplicationRequest,
     CreateGroupRequest,
     UpdateGroupRequest,
     SetGroupMembersRequest,
     AddGroupMemberRequest,
+    AddGroupMembersRequest,
     RemoveGroupMemberRequest,
     CreatePolicyRequest,
     UpdatePolicyRequest,
     SetRulesRequest,
     CreateAPIKeyRequest,
     UpdateAPIKeyRequest,
 )
 from .marshalling import (
     marshal_AddGroupMemberRequest,
+    marshal_AddGroupMembersRequest,
     marshal_CreateAPIKeyRequest,
     marshal_CreateApplicationRequest,
     marshal_CreateGroupRequest,
     marshal_CreatePolicyRequest,
     marshal_CreateSSHKeyRequest,
+    marshal_CreateUserRequest,
     marshal_RemoveGroupMemberRequest,
     marshal_SetGroupMembersRequest,
     marshal_SetRulesRequest,
     marshal_UpdateAPIKeyRequest,
     marshal_UpdateApplicationRequest,
     marshal_UpdateGroupRequest,
     marshal_UpdatePolicyRequest,
@@ -96,36 +100,39 @@
     unmarshal_SetRulesResponse,
 )
 
 
 class IamV1Alpha1API(API):
     """
     IAM API.
+
+    IAM API.
     """
 
     async def list_ssh_keys(
         self,
         *,
         order_by: ListSSHKeysRequestOrderBy = ListSSHKeysRequestOrderBy.CREATED_AT_ASC,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         organization_id: Optional[str] = None,
         name: Optional[str] = None,
         project_id: Optional[str] = None,
         disabled: Optional[bool] = None,
     ) -> ListSSHKeysResponse:
         """
-        List SSH keys
-        :param order_by: Sort order of SSH keys.
-        :param page: Requested page number. Value must be greater or equals to 1.
+        List SSH keys.
+        List SSH keys. By default, the SSH keys listed are ordered by creation date in ascending order. This can be modified via the `order_by` field. You can define additional parameters for your query such as `organization_id`, `name`, `project_id` and `disabled`.
+        :param order_by: Sort order of the SSH keys.
+        :param page: Requested page number. Value must be greater or equal to 1.
         :param page_size: Number of items per page. Value must be between 1 and 100.
-        :param organization_id: Filter by organization ID.
+        :param organization_id: Filter by Organization ID.
         :param name: Name of group to find.
-        :param project_id: Filter by project ID.
-        :param disabled: Filter out disabled SSH keys or not.
+        :param project_id: Filter by Project ID.
+        :param disabled: Defines whether to include disabled SSH keys or not.
         :return: :class:`ListSSHKeysResponse <ListSSHKeysResponse>`
 
         Usage:
         ::
 
             result = await api.list_ssh_keys()
         """
@@ -156,22 +163,23 @@
         page_size: Optional[int] = None,
         organization_id: Optional[str] = None,
         name: Optional[str] = None,
         project_id: Optional[str] = None,
         disabled: Optional[bool] = None,
     ) -> List[SSHKey]:
         """
-        List SSH keys
-        :param order_by: Sort order of SSH keys.
-        :param page: Requested page number. Value must be greater or equals to 1.
+        List SSH keys.
+        List SSH keys. By default, the SSH keys listed are ordered by creation date in ascending order. This can be modified via the `order_by` field. You can define additional parameters for your query such as `organization_id`, `name`, `project_id` and `disabled`.
+        :param order_by: Sort order of the SSH keys.
+        :param page: Requested page number. Value must be greater or equal to 1.
         :param page_size: Number of items per page. Value must be between 1 and 100.
-        :param organization_id: Filter by organization ID.
+        :param organization_id: Filter by Organization ID.
         :param name: Name of group to find.
-        :param project_id: Filter by project ID.
-        :param disabled: Filter out disabled SSH keys or not.
+        :param project_id: Filter by Project ID.
+        :param disabled: Defines whether to include disabled SSH keys or not.
         :return: :class:`List[ListSSHKeysResponse] <List[ListSSHKeysResponse]>`
 
         Usage:
         ::
 
             result = await api.list_ssh_keys_all()
         """
@@ -195,18 +203,19 @@
         self,
         *,
         public_key: str,
         name: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> SSHKey:
         """
-        Create an SSH key
-        :param name: The name of the SSH key. Max length is 1000.
-        :param public_key: SSH public key. Currently ssh-rsa, ssh-dss (DSA), ssh-ed25519 and ecdsa keys with NIST curves are supported. Max length is 65000.
-        :param project_id: Project owning the resource.
+        Create an SSH key.
+        Add a new SSH key to a Scaleway Project. You must specify the `name`, `public_key` and `project_id`.
+        :param name: Name of the SSH key. Max length is 1000.
+        :param public_key: SSH public key. Currently only the ssh-rsa, ssh-dss (DSA), ssh-ed25519 and ecdsa keys with NIST curves are supported. Max length is 65000.
+        :param project_id: Project the resource is attributed to.
         :return: :class:`SSHKey <SSHKey>`
 
         Usage:
         ::
 
             result = await api.create_ssh_key(public_key="example")
         """
@@ -229,16 +238,17 @@
 
     async def get_ssh_key(
         self,
         *,
         ssh_key_id: str,
     ) -> SSHKey:
         """
-        Get an SSH key
-        :param ssh_key_id: The ID of the SSH key.
+        Get an SSH key.
+        Retrieve information about a given SSH key, specified by the `ssh_key_id` parameter. The SSH key's full details, including `id`, `name`, `public_key`, and `project_id` are returned in the response.
+        :param ssh_key_id: ID of the SSH key.
         :return: :class:`SSHKey <SSHKey>`
 
         Usage:
         ::
 
             result = await api.get_ssh_key(ssh_key_id="example")
         """
@@ -257,15 +267,16 @@
         self,
         *,
         ssh_key_id: str,
         name: Optional[str] = None,
         disabled: Optional[bool] = None,
     ) -> SSHKey:
         """
-        Update an SSH key
+        Update an SSH key.
+        Update the parameters of an SSH key, including `name` and `disable`.
         :param ssh_key_id:
         :param name: Name of the SSH key. Max length is 1000.
         :param disabled: Enable or disable the SSH key.
         :return: :class:`SSHKey <SSHKey>`
 
         Usage:
         ::
@@ -293,15 +304,16 @@
 
     async def delete_ssh_key(
         self,
         *,
         ssh_key_id: str,
     ) -> Optional[None]:
         """
-        Delete an SSH key
+        Delete an SSH key.
+        Delete a given SSH key, specified by the `ssh_key_id`. Deleting an SSH is permanent, and cannot be undone. Note that you might need to update any configurations that used the SSH key.
         :param ssh_key_id:
 
         Usage:
         ::
 
             result = await api.delete_ssh_key(ssh_key_id="example")
         """
@@ -320,34 +332,38 @@
         self,
         *,
         order_by: ListUsersRequestOrderBy = ListUsersRequestOrderBy.CREATED_AT_ASC,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         organization_id: Optional[str] = None,
         user_ids: Optional[List[str]] = None,
+        mfa: Optional[bool] = None,
     ) -> ListUsersResponse:
         """
-        List users of an organization
+        List users of an Organization.
+        List the users of an Organization. By default, the users listed are ordered by creation date in ascending order. This can be modified via the `order_by` field. You must define the `organization_id` in the query path of your request. You can also define additional parameters for your query such as `user_ids`.
         :param order_by: Criteria for sorting results.
         :param page_size: Number of results per page. Value must be between 1 and 100.
-        :param page: Number of page. Value must be greater or equals to 1.
-        :param organization_id: ID of organization to filter.
-        :param user_ids: Filter out by a list of ID.
+        :param page: Page number. Value must be greater or equal to 1.
+        :param organization_id: ID of the Organization to filter.
+        :param user_ids: Filter by list of IDs.
+        :param mfa: Filter by MFA status.
         :return: :class:`ListUsersResponse <ListUsersResponse>`
 
         Usage:
         ::
 
             result = await api.list_users()
         """
 
         res = self._request(
             "GET",
             f"/iam/v1alpha1/users",
             params={
+                "mfa": mfa,
                 "order_by": order_by,
                 "organization_id": organization_id
                 or self.client.default_organization_id,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
                 "user_ids": user_ids,
             },
@@ -360,22 +376,25 @@
         self,
         *,
         order_by: Optional[ListUsersRequestOrderBy] = None,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         organization_id: Optional[str] = None,
         user_ids: Optional[List[str]] = None,
+        mfa: Optional[bool] = None,
     ) -> List[User]:
         """
-        List users of an organization
+        List users of an Organization.
+        List the users of an Organization. By default, the users listed are ordered by creation date in ascending order. This can be modified via the `order_by` field. You must define the `organization_id` in the query path of your request. You can also define additional parameters for your query such as `user_ids`.
         :param order_by: Criteria for sorting results.
         :param page_size: Number of results per page. Value must be between 1 and 100.
-        :param page: Number of page. Value must be greater or equals to 1.
-        :param organization_id: ID of organization to filter.
-        :param user_ids: Filter out by a list of ID.
+        :param page: Page number. Value must be greater or equal to 1.
+        :param organization_id: ID of the Organization to filter.
+        :param user_ids: Filter by list of IDs.
+        :param mfa: Filter by MFA status.
         :return: :class:`List[ListUsersResponse] <List[ListUsersResponse]>`
 
         Usage:
         ::
 
             result = await api.list_users_all()
         """
@@ -386,25 +405,27 @@
             fetcher=self.list_users,
             args={
                 "order_by": order_by,
                 "page_size": page_size,
                 "page": page,
                 "organization_id": organization_id,
                 "user_ids": user_ids,
+                "mfa": mfa,
             },
         )
 
     async def get_user(
         self,
         *,
         user_id: str,
     ) -> User:
         """
-        Retrieve a user from its ID
-        :param user_id: ID of user to find.
+        Get a given user.
+        Retrieve information about a user, specified by the `user_id` parameter. The user's full details, including `id`, `email`, `organization_id`, `status` and `mfa` are returned in the response.
+        :param user_id: ID of the user to find.
         :return: :class:`User <User>`
 
         Usage:
         ::
 
             result = await api.get_user(user_id="example")
         """
@@ -421,16 +442,17 @@
 
     async def delete_user(
         self,
         *,
         user_id: str,
     ) -> Optional[None]:
         """
-        Delete a guest user from an organization
-        :param user_id: ID of user to delete.
+        Delete a guest user from an Organization.
+        Remove a user from an Organization in which they are a guest. You must define the `user_id` in your request. Note that removing a user from an Organization automatically deletes their API keys, and any policies directly attached to them become orphaned.
+        :param user_id: ID of the user to delete.
 
         Usage:
         ::
 
             result = await api.delete_user(user_id="example")
         """
 
@@ -440,34 +462,69 @@
             "DELETE",
             f"/iam/v1alpha1/users/{param_user_id}",
         )
 
         self._throw_on_error(res)
         return None
 
+    async def create_user(
+        self,
+        *,
+        email: str,
+        organization_id: Optional[str] = None,
+    ) -> User:
+        """
+        Create a new user.
+        Create a new user. You must define the `organization_id` and the `email` in your request.
+        :param organization_id: ID of the Organization.
+        :param email: Email of the user.
+        :return: :class:`User <User>`
+
+        Usage:
+        ::
+
+            result = await api.create_user(email="example")
+        """
+
+        res = self._request(
+            "POST",
+            f"/iam/v1alpha1/users",
+            body=marshal_CreateUserRequest(
+                CreateUserRequest(
+                    email=email,
+                    organization_id=organization_id,
+                ),
+                self.client,
+            ),
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_User(res.json())
+
     async def list_applications(
         self,
         *,
         order_by: ListApplicationsRequestOrderBy = ListApplicationsRequestOrderBy.CREATED_AT_ASC,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         name: Optional[str] = None,
         organization_id: Optional[str] = None,
         editable: Optional[bool] = None,
         application_ids: Optional[List[str]] = None,
     ) -> ListApplicationsResponse:
         """
-        List applications of an organization
+        List applications of an Organization.
+        List the applications of an Organization. By default, the applications listed are ordered by creation date in ascending order. This can be modified via the `order_by` field. You must define the `organization_id` in the query path of your request. You can also define additional parameters for your query such as `application_ids`.
         :param order_by: Criteria for sorting results.
         :param page_size: Number of results per page. Value must be between 1 and 100.
-        :param page: Number of page. Value must be greater to 1.
-        :param name: Name of application to filter.
-        :param organization_id: ID of organization to filter.
-        :param editable: Filter out editable applications or not.
-        :param application_ids: Filter out by a list of ID.
+        :param page: Page number. Value must be greater than 1.
+        :param name: Name of the application to filter.
+        :param organization_id: ID of the Organization to filter.
+        :param editable: Defines whether to filter out editable applications or not.
+        :param application_ids: Filter by list of IDs.
         :return: :class:`ListApplicationsResponse <ListApplicationsResponse>`
 
         Usage:
         ::
 
             result = await api.list_applications()
         """
@@ -498,22 +555,23 @@
         page: Optional[int] = None,
         name: Optional[str] = None,
         organization_id: Optional[str] = None,
         editable: Optional[bool] = None,
         application_ids: Optional[List[str]] = None,
     ) -> List[Application]:
         """
-        List applications of an organization
+        List applications of an Organization.
+        List the applications of an Organization. By default, the applications listed are ordered by creation date in ascending order. This can be modified via the `order_by` field. You must define the `organization_id` in the query path of your request. You can also define additional parameters for your query such as `application_ids`.
         :param order_by: Criteria for sorting results.
         :param page_size: Number of results per page. Value must be between 1 and 100.
-        :param page: Number of page. Value must be greater to 1.
-        :param name: Name of application to filter.
-        :param organization_id: ID of organization to filter.
-        :param editable: Filter out editable applications or not.
-        :param application_ids: Filter out by a list of ID.
+        :param page: Page number. Value must be greater than 1.
+        :param name: Name of the application to filter.
+        :param organization_id: ID of the Organization to filter.
+        :param editable: Defines whether to filter out editable applications or not.
+        :param application_ids: Filter by list of IDs.
         :return: :class:`List[ListApplicationsResponse] <List[ListApplicationsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_applications_all()
         """
@@ -537,18 +595,19 @@
         self,
         *,
         description: str,
         name: Optional[str] = None,
         organization_id: Optional[str] = None,
     ) -> Application:
         """
-        Create a new application
-        :param name: Name of application to create (max length is 64 chars).
-        :param organization_id: ID of organization.
-        :param description: Description of application (max length is 200 chars).
+        Create a new application.
+        Create a new application. You must define the `name` parameter in the request.
+        :param name: Name of the application to create (max length is 64 characters).
+        :param organization_id: ID of the Organization.
+        :param description: Description of the application (max length is 200 characters).
         :return: :class:`Application <Application>`
 
         Usage:
         ::
 
             result = await api.create_application(description="example")
         """
@@ -571,16 +630,17 @@
 
     async def get_application(
         self,
         *,
         application_id: str,
     ) -> Application:
         """
-        Get an existing application
-        :param application_id: ID of application to find.
+        Get a given application.
+        Retrieve information about an application, specified by the `application_id` parameter. The application's full details, including `id`, `email`, `organization_id`, `status` and `two_factor_enabled` are returned in the response.
+        :param application_id: ID of the application to find.
         :return: :class:`Application <Application>`
 
         Usage:
         ::
 
             result = await api.get_application(application_id="example")
         """
@@ -599,18 +659,19 @@
         self,
         *,
         application_id: str,
         name: Optional[str] = None,
         description: Optional[str] = None,
     ) -> Application:
         """
-        Update an existing application
-        :param application_id: ID of application to update.
-        :param name: New name of application (max length is 64 chars).
-        :param description: New description of application (max length is 200 chars).
+        Update an application.
+        Update the parameters of an application, including `name` and `description`.
+        :param application_id: ID of the application to update.
+        :param name: New name for the application (max length is 64 chars).
+        :param description: New description for the application (max length is 200 chars).
         :return: :class:`Application <Application>`
 
         Usage:
         ::
 
             result = await api.update_application(application_id="example")
         """
@@ -635,16 +696,17 @@
 
     async def delete_application(
         self,
         *,
         application_id: str,
     ) -> Optional[None]:
         """
-        Delete an application
-        :param application_id: ID of application to delete.
+        Delete an application.
+        Delete an application. Note that this action is irreversible and will automatically delete the application's API keys. Policies attached to users and applications via this group will no longer apply.
+        :param application_id: ID of the application to delete.
 
         Usage:
         ::
 
             result = await api.delete_application(application_id="example")
         """
 
@@ -667,23 +729,24 @@
         organization_id: Optional[str] = None,
         name: Optional[str] = None,
         application_ids: Optional[List[str]] = None,
         user_ids: Optional[List[str]] = None,
         group_ids: Optional[List[str]] = None,
     ) -> ListGroupsResponse:
         """
-        List groups
+        List groups.
+        List groups. By default, the groups listed are ordered by creation date in ascending order. This can be modified via the `order_by` field. You can define additional parameters to filter your query. Use `user_ids` or `application_ids` to list all groups certain users or applications belong to.
         :param order_by: Sort order of groups.
-        :param page: Requested page number. Value must be greater or equals to 1.
+        :param page: Requested page number. Value must be greater or equal to 1.
         :param page_size: Number of items per page. Value must be between 1 and 100.
-        :param organization_id: Filter by organization ID.
+        :param organization_id: Filter by Organization ID.
         :param name: Name of group to find.
-        :param application_ids: Filter out by a list of application ID.
-        :param user_ids: Filter out by a list of user ID.
-        :param group_ids: Filter out by a list of group ID.
+        :param application_ids: Filter by a list of application IDs.
+        :param user_ids: Filter by a list of user IDs.
+        :param group_ids: Filter by a list of group IDs.
         :return: :class:`ListGroupsResponse <ListGroupsResponse>`
 
         Usage:
         ::
 
             result = await api.list_groups()
         """
@@ -716,23 +779,24 @@
         organization_id: Optional[str] = None,
         name: Optional[str] = None,
         application_ids: Optional[List[str]] = None,
         user_ids: Optional[List[str]] = None,
         group_ids: Optional[List[str]] = None,
     ) -> List[Group]:
         """
-        List groups
+        List groups.
+        List groups. By default, the groups listed are ordered by creation date in ascending order. This can be modified via the `order_by` field. You can define additional parameters to filter your query. Use `user_ids` or `application_ids` to list all groups certain users or applications belong to.
         :param order_by: Sort order of groups.
-        :param page: Requested page number. Value must be greater or equals to 1.
+        :param page: Requested page number. Value must be greater or equal to 1.
         :param page_size: Number of items per page. Value must be between 1 and 100.
-        :param organization_id: Filter by organization ID.
+        :param organization_id: Filter by Organization ID.
         :param name: Name of group to find.
-        :param application_ids: Filter out by a list of application ID.
-        :param user_ids: Filter out by a list of user ID.
-        :param group_ids: Filter out by a list of group ID.
+        :param application_ids: Filter by a list of application IDs.
+        :param user_ids: Filter by a list of user IDs.
+        :param group_ids: Filter by a list of group IDs.
         :return: :class:`List[ListGroupsResponse] <List[ListGroupsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_groups_all()
         """
@@ -757,17 +821,18 @@
         self,
         *,
         description: str,
         organization_id: Optional[str] = None,
         name: Optional[str] = None,
     ) -> Group:
         """
-        Create a new group
-        :param organization_id: ID of organization linked to the group.
-        :param name: Name of the group to create (max length is 64 chars). MUST be unique inside an organization.
+        Create a group.
+        Create a new group. You must define the `name` and `organization_id` parameters in the request.
+        :param organization_id: ID of Organization linked to the group.
+        :param name: Name of the group to create (max length is 64 chars). MUST be unique inside an Organization.
         :param description: Description of the group to create (max length is 200 chars).
         :return: :class:`Group <Group>`
 
         Usage:
         ::
 
             result = await api.create_group(description="example")
@@ -791,16 +856,17 @@
 
     async def get_group(
         self,
         *,
         group_id: str,
     ) -> Group:
         """
-        Get a group
-        :param group_id: ID of group.
+        Get a group.
+        Retrive information about a given group, specified by the `group_id` parameter. The group's full details, including `user_ids` and `application_ids` are returned in the response.
+        :param group_id: ID of the group.
         :return: :class:`Group <Group>`
 
         Usage:
         ::
 
             result = await api.get_group(group_id="example")
         """
@@ -819,17 +885,18 @@
         self,
         *,
         group_id: str,
         name: Optional[str] = None,
         description: Optional[str] = None,
     ) -> Group:
         """
-        Update a group
-        :param group_id: ID of group to update.
-        :param name: New name for the group (max length is 64 chars). MUST be unique inside an organization.
+        Update a group.
+        Update the parameters of group, including `name` and `description`.
+        :param group_id: ID of the group to update.
+        :param name: New name for the group (max length is 64 chars). MUST be unique inside an Organization.
         :param description: New description for the group (max length is 200 chars).
         :return: :class:`Group <Group>`
 
         Usage:
         ::
 
             result = await api.update_group(group_id="example")
@@ -857,15 +924,16 @@
         self,
         *,
         group_id: str,
         user_ids: List[str],
         application_ids: List[str],
     ) -> Group:
         """
-        Overwrite users and applications of a group
+        Overwrite users and applications of a group.
+        Overwrite users and applications configuration in a group. Any information that you add using this command will overwrite the previous configuration.
         :param group_id:
         :param user_ids:
         :param application_ids:
         :return: :class:`Group <Group>`
 
         Usage:
         ::
@@ -899,16 +967,17 @@
         self,
         *,
         group_id: str,
         user_id: Optional[str] = None,
         application_id: Optional[str] = None,
     ) -> Group:
         """
-        Add a user of an application to a group
-        :param group_id: ID of group.
+        Add a user or an application to a group.
+        Add a user or an application to a group. You can specify a `user_id` and and `application_id` in the body of your request. Note that you can only add one of each per request.
+        :param group_id: ID of the group.
         :param user_id: ID of the user to add.
 
         One-of ('member'): at most one of 'user_id', 'application_id' could be set.
         :param application_id: ID of the application to add.
 
         One-of ('member'): at most one of 'user_id', 'application_id' could be set.
         :return: :class:`Group <Group>`
@@ -933,24 +1002,64 @@
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_Group(res.json())
 
+    async def add_group_members(
+        self,
+        *,
+        group_id: str,
+        user_ids: Optional[List[str]] = None,
+        application_ids: Optional[List[str]] = None,
+    ) -> Group:
+        """
+        Add multiple users and applications to a group.
+        Add multiple users and applications to a group in a single call. You can specify an array of `user_id`s and `application_id`s. Note that any existing users and applications in the group will remain. To add new users/applications and delete pre-existing ones, use the [Overwrite users and applications of a group](#path-groups-overwrite-users-and-applications-of-a-group) method.
+        :param group_id: ID of the group.
+        :param user_ids: IDs of the users to add.
+        :param application_ids: IDs of the applications to add.
+        :return: :class:`Group <Group>`
+
+        Usage:
+        ::
+
+            result = await api.add_group_members(group_id="example")
+        """
+
+        param_group_id = validate_path_param("group_id", group_id)
+
+        res = self._request(
+            "POST",
+            f"/iam/v1alpha1/groups/{param_group_id}/add-members",
+            body=marshal_AddGroupMembersRequest(
+                AddGroupMembersRequest(
+                    group_id=group_id,
+                    user_ids=user_ids,
+                    application_ids=application_ids,
+                ),
+                self.client,
+            ),
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_Group(res.json())
+
     async def remove_group_member(
         self,
         *,
         group_id: str,
         user_id: Optional[str] = None,
         application_id: Optional[str] = None,
     ) -> Group:
         """
-        Remove a user or an application from a group
-        :param group_id: ID of group.
+        Remove a user or an application from a group.
+        Remove a user or an application from a group. You can specify a `user_id` and and `application_id` in the body of your request. Note that you can only remove one of each per request. Removing a user from a group means that any permissions given to them via the group (i.e. from an attached policy) will no longer apply. Be sure you want to remove these permissions from the user before proceeding.
+        :param group_id: ID of the group.
         :param user_id: ID of the user to remove.
 
         One-of ('member'): at most one of 'user_id', 'application_id' could be set.
         :param application_id: ID of the application to remove.
 
         One-of ('member'): at most one of 'user_id', 'application_id' could be set.
         :return: :class:`Group <Group>`
@@ -981,16 +1090,17 @@
 
     async def delete_group(
         self,
         *,
         group_id: str,
     ) -> Optional[None]:
         """
-        Delete a group
-        :param group_id: ID of group to delete.
+        Delete a group.
+        Delete a group. Note that this action is irreversible and could delete permissions for group members. Policies attached to users and applications via this group will no longer apply.
+        :param group_id: ID of the group to delete.
 
         Usage:
         ::
 
             result = await api.delete_group(group_id="example")
         """
 
@@ -1015,25 +1125,26 @@
         user_ids: Optional[List[str]] = None,
         group_ids: Optional[List[str]] = None,
         application_ids: Optional[List[str]] = None,
         no_principal: Optional[bool] = None,
         policy_name: Optional[str] = None,
     ) -> ListPoliciesResponse:
         """
-        List policies of an organization
+        List policies of an Organization.
+        List the policies of an Organization. By default, the policies listed are ordered by creation date in ascending order. This can be modified via the `order_by` field. You must define the `organization_id` in the query path of your request. You can also define additional parameters to filter your query, such as `user_ids`, `groups_ids`, `application_ids`, and `policy_name`.
         :param order_by: Criteria for sorting results.
         :param page_size: Number of results per page. Value must be between 1 and 100.
-        :param page: Number of page. Value must be greater to 1.
-        :param organization_id: ID of organization to filter.
-        :param editable: Filter out editable policies or not.
-        :param user_ids: Filter out by a list of user ID.
-        :param group_ids: Filter out by a list of group ID.
-        :param application_ids: Filter out by a list of application ID.
-        :param no_principal: True when the policy do not belong to any principal.
-        :param policy_name: Name of policy to fetch.
+        :param page: Page number. Value must be greater than 1.
+        :param organization_id: ID of the Organization to filter.
+        :param editable: Defines whether or not filter out editable policies.
+        :param user_ids: Defines whether or not to filter by list of user IDs.
+        :param group_ids: Defines whether or not to filter by list of group IDs.
+        :param application_ids: Filter by a list of application IDs.
+        :param no_principal: Defines whether or not the policy is attributed to a principal.
+        :param policy_name: Name of the policy to fetch.
         :return: :class:`ListPoliciesResponse <ListPoliciesResponse>`
 
         Usage:
         ::
 
             result = await api.list_policies()
         """
@@ -1070,25 +1181,26 @@
         user_ids: Optional[List[str]] = None,
         group_ids: Optional[List[str]] = None,
         application_ids: Optional[List[str]] = None,
         no_principal: Optional[bool] = None,
         policy_name: Optional[str] = None,
     ) -> List[Policy]:
         """
-        List policies of an organization
+        List policies of an Organization.
+        List the policies of an Organization. By default, the policies listed are ordered by creation date in ascending order. This can be modified via the `order_by` field. You must define the `organization_id` in the query path of your request. You can also define additional parameters to filter your query, such as `user_ids`, `groups_ids`, `application_ids`, and `policy_name`.
         :param order_by: Criteria for sorting results.
         :param page_size: Number of results per page. Value must be between 1 and 100.
-        :param page: Number of page. Value must be greater to 1.
-        :param organization_id: ID of organization to filter.
-        :param editable: Filter out editable policies or not.
-        :param user_ids: Filter out by a list of user ID.
-        :param group_ids: Filter out by a list of group ID.
-        :param application_ids: Filter out by a list of application ID.
-        :param no_principal: True when the policy do not belong to any principal.
-        :param policy_name: Name of policy to fetch.
+        :param page: Page number. Value must be greater than 1.
+        :param organization_id: ID of the Organization to filter.
+        :param editable: Defines whether or not filter out editable policies.
+        :param user_ids: Defines whether or not to filter by list of user IDs.
+        :param group_ids: Defines whether or not to filter by list of group IDs.
+        :param application_ids: Filter by a list of application IDs.
+        :param no_principal: Defines whether or not the policy is attributed to a principal.
+        :param policy_name: Name of the policy to fetch.
         :return: :class:`List[ListPoliciesResponse] <List[ListPoliciesResponse]>`
 
         Usage:
         ::
 
             result = await api.list_policies_all()
         """
@@ -1120,29 +1232,30 @@
         rules: Optional[List[RuleSpecs]] = None,
         user_id: Optional[str] = None,
         group_id: Optional[str] = None,
         application_id: Optional[str] = None,
         no_principal: Optional[bool] = None,
     ) -> Policy:
         """
-        Create a new policy
-        :param name: Name of policy to create (max length is 64 chars).
-        :param description: Description of policy to create (max length is 200 chars).
-        :param organization_id: ID of organization.
+        Create a new policy.
+        Create a new application. You must define the `name` parameter in the request. You can specify parameters such as `user_id`, `groups_id`, `application_id`, `no_principal`, `rules` and its child attributes.
+        :param name: Name of the policy to create (max length is 64 characters).
+        :param description: Description of the policy to create (max length is 200 characters).
+        :param organization_id: ID of the Organization.
         :param rules: Rules of the policy to create.
-        :param user_id: ID of user, owner of the policy.
+        :param user_id: ID of user attributed to the policy.
 
         One-of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
-        :param group_id: ID of group, owner of the policy.
+        :param group_id: ID of group attributed to the policy.
 
         One-of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
-        :param application_id: ID of application, owner of the policy.
+        :param application_id: ID of application attributed to the policy.
 
         One-of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
-        :param no_principal: True when the policy do not belong to any principal.
+        :param no_principal: Defines whether or not a policy is attributed to a principal.
 
         One-of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
         :return: :class:`Policy <Policy>`
 
         Usage:
         ::
 
@@ -1172,15 +1285,16 @@
 
     async def get_policy(
         self,
         *,
         policy_id: str,
     ) -> Policy:
         """
-        Get an existing policy
+        Get an existing policy.
+        Retrieve information about a policy, speficified by the `policy_id` parameter. The policy's full details, including `id`, `name`, `organization_id`, `nb_rules` and `nb_scopes`, `nb_permission_sets` are returned in the response.
         :param policy_id: Id of policy to search.
         :return: :class:`Policy <Policy>`
 
         Usage:
         ::
 
             result = await api.get_policy(policy_id="example")
@@ -1204,28 +1318,29 @@
         description: Optional[str] = None,
         user_id: Optional[str] = None,
         group_id: Optional[str] = None,
         application_id: Optional[str] = None,
         no_principal: Optional[bool] = None,
     ) -> Policy:
         """
-        Update an existing policy
+        Update an existing policy.
+        Update the parameters of a policy, including `name`, `description`, `user_id`, `group_id`, `application_id` and `no_principal`.
         :param policy_id: Id of policy to update.
-        :param name: New name of policy (max length is 64 chars).
-        :param description: New description of policy (max length is 200 chars).
-        :param user_id: New ID of user, owner of the policy.
+        :param name: New name for the policy (max length is 64 characters).
+        :param description: New description of policy (max length is 200 characters).
+        :param user_id: New ID of user attributed to the policy.
 
         One-of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
-        :param group_id: New ID of group, owner of the policy.
+        :param group_id: New ID of group attributed to the policy.
 
         One-of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
-        :param application_id: New ID of application, owner of the policy.
+        :param application_id: New ID of application attributed to the policy.
 
         One-of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
-        :param no_principal: True when the policy do not belong to any principal.
+        :param no_principal: Defines whether or not the policy is attributed to a principal.
 
         One-of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
         :return: :class:`Policy <Policy>`
 
         Usage:
         ::
 
@@ -1256,15 +1371,16 @@
 
     async def delete_policy(
         self,
         *,
         policy_id: str,
     ) -> Optional[None]:
         """
-        Delete a policy
+        Delete a policy.
+        Delete a policy. You must define specify the `policy_id` parameter in your request. Note that when deleting a policy, all permissions it gives to its principal (user, group or application) will be revoked.
         :param policy_id: Id of policy to delete.
 
         Usage:
         ::
 
             result = await api.delete_policy(policy_id="example")
         """
@@ -1281,14 +1397,18 @@
 
     async def clone_policy(
         self,
         *,
         policy_id: str,
     ) -> Policy:
         """
+        Clone a policy.
+        Clone a policy. You must define specify the `policy_id` parameter in your request.
+        :param policy_id:
+        :return: :class:`Policy <Policy>`
 
         Usage:
         ::
 
             result = await api.clone_policy(policy_id="example")
         """
 
@@ -1305,15 +1425,16 @@
     async def set_rules(
         self,
         *,
         policy_id: str,
         rules: List[RuleSpecs],
     ) -> SetRulesResponse:
         """
-        Set rules of an existing policy
+        Set rules of a given policy.
+        Overwrite the rules of a given policy. Any information that you add using this command will overwrite the previous configuration. If you include some of the rules you already had in your previous configuration in your new one, but you change their order, the new order of display will apply. While policy rules are ordered, they have no impact on the access logic of IAM because rules are allow-only.
         :param policy_id: Id of policy to update.
         :param rules: Rules of the policy to set.
         :return: :class:`SetRulesResponse <SetRulesResponse>`
 
         Usage:
         ::
 
@@ -1342,18 +1463,19 @@
         self,
         *,
         policy_id: str,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
     ) -> ListRulesResponse:
         """
-        List rules of an existing policy
+        List rules of a given policy.
+        List the rules of a given policy. By default, the rules listed are ordered by creation date in ascending order. This can be modified via the `order_by` field. You must define the `policy_id` in the query path of your request.
         :param policy_id: Id of policy to search.
         :param page_size: Number of results per page. Value must be between 1 and 100.
-        :param page: Number of page. Value must be greater to 1.
+        :param page: Page number. Value must be greater than 1.
         :return: :class:`ListRulesResponse <ListRulesResponse>`
 
         Usage:
         ::
 
             result = await api.list_rules(policy_id="example")
         """
@@ -1375,18 +1497,19 @@
         self,
         *,
         policy_id: str,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
     ) -> List[Rule]:
         """
-        List rules of an existing policy
+        List rules of a given policy.
+        List the rules of a given policy. By default, the rules listed are ordered by creation date in ascending order. This can be modified via the `order_by` field. You must define the `policy_id` in the query path of your request.
         :param policy_id: Id of policy to search.
         :param page_size: Number of results per page. Value must be between 1 and 100.
-        :param page: Number of page. Value must be greater to 1.
+        :param page: Page number. Value must be greater than 1.
         :return: :class:`List[ListRulesResponse] <List[ListRulesResponse]>`
 
         Usage:
         ::
 
             result = await api.list_rules_all(policy_id="example")
         """
@@ -1407,19 +1530,20 @@
         *,
         order_by: ListPermissionSetsRequestOrderBy = ListPermissionSetsRequestOrderBy.NAME_ASC,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         organization_id: Optional[str] = None,
     ) -> ListPermissionSetsResponse:
         """
-        List permission sets
+        List permission sets.
+        List permission sets available for given Organization. You must define the `organization_id` in the query path of your request.
         :param order_by: Criteria for sorting results.
         :param page_size: Number of results per page. Value must be between 1 and 100.
-        :param page: Number of page. Value must be greater to 1.
-        :param organization_id: Filter by organization ID.
+        :param page: Page number. Value must be greater than 1.
+        :param organization_id: Filter by Organization ID.
         :return: :class:`ListPermissionSetsResponse <ListPermissionSetsResponse>`
 
         Usage:
         ::
 
             result = await api.list_permission_sets()
         """
@@ -1444,19 +1568,20 @@
         *,
         order_by: Optional[ListPermissionSetsRequestOrderBy] = None,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         organization_id: Optional[str] = None,
     ) -> List[PermissionSet]:
         """
-        List permission sets
+        List permission sets.
+        List permission sets available for given Organization. You must define the `organization_id` in the query path of your request.
         :param order_by: Criteria for sorting results.
         :param page_size: Number of results per page. Value must be between 1 and 100.
-        :param page: Number of page. Value must be greater to 1.
-        :param organization_id: Filter by organization ID.
+        :param page: Page number. Value must be greater than 1.
+        :param organization_id: Filter by Organization ID.
         :return: :class:`List[ListPermissionSetsResponse] <List[ListPermissionSetsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_permission_sets_all()
         """
@@ -1486,31 +1611,32 @@
         expired: Optional[bool] = None,
         access_key: Optional[str] = None,
         description: Optional[str] = None,
         bearer_id: Optional[str] = None,
         bearer_type: BearerType = BearerType.UNKNOWN_BEARER_TYPE,
     ) -> ListAPIKeysResponse:
         """
-        List API keys
+        List API keys.
+        List API keys. By default, the API keys listed are ordered by creation date in ascending order. This can be modified via the `order_by` field. You can define additional parameters for your query such as `editable`, `expired`, `access_key` and `bearer_id`.
         :param order_by: Criteria for sorting results.
-        :param page: Number of page. Value must be greater or equals to 1.
+        :param page: Page number. Value must be greater or equal to 1.
         :param page_size: Number of results per page. Value must be between 1 and 100.
-        :param organization_id: ID of organization.
-        :param application_id: ID of an application bearer.
+        :param organization_id: ID of Organization.
+        :param application_id: ID of application that bears the API key.
 
         One-of ('bearer'): at most one of 'application_id', 'user_id' could be set.
-        :param user_id: ID of a user bearer.
+        :param user_id: ID of user that bears the API key.
 
         One-of ('bearer'): at most one of 'application_id', 'user_id' could be set.
-        :param editable: Filter out editable API keys or not.
-        :param expired: Filter out expired API keys or not.
-        :param access_key: Filter out by access key.
-        :param description: Filter out by description.
-        :param bearer_id: Filter out by bearer ID.
-        :param bearer_type: Filter out by type of bearer.
+        :param editable: Defines whether to filter out editable API keys or not.
+        :param expired: Defines whether to filter out expired API keys or not.
+        :param access_key: Filter by access key.
+        :param description: Filter by description.
+        :param bearer_id: Filter by bearer ID.
+        :param bearer_type: Filter by type of bearer.
         :return: :class:`ListAPIKeysResponse <ListAPIKeysResponse>`
 
         Usage:
         ::
 
             result = await api.list_api_keys()
         """
@@ -1555,31 +1681,32 @@
         expired: Optional[bool] = None,
         access_key: Optional[str] = None,
         description: Optional[str] = None,
         bearer_id: Optional[str] = None,
         bearer_type: Optional[BearerType] = None,
     ) -> List[APIKey]:
         """
-        List API keys
+        List API keys.
+        List API keys. By default, the API keys listed are ordered by creation date in ascending order. This can be modified via the `order_by` field. You can define additional parameters for your query such as `editable`, `expired`, `access_key` and `bearer_id`.
         :param order_by: Criteria for sorting results.
-        :param page: Number of page. Value must be greater or equals to 1.
+        :param page: Page number. Value must be greater or equal to 1.
         :param page_size: Number of results per page. Value must be between 1 and 100.
-        :param organization_id: ID of organization.
-        :param application_id: ID of an application bearer.
+        :param organization_id: ID of Organization.
+        :param application_id: ID of application that bears the API key.
 
         One-of ('bearer'): at most one of 'application_id', 'user_id' could be set.
-        :param user_id: ID of a user bearer.
+        :param user_id: ID of user that bears the API key.
 
         One-of ('bearer'): at most one of 'application_id', 'user_id' could be set.
-        :param editable: Filter out editable API keys or not.
-        :param expired: Filter out expired API keys or not.
-        :param access_key: Filter out by access key.
-        :param description: Filter out by description.
-        :param bearer_id: Filter out by bearer ID.
-        :param bearer_type: Filter out by type of bearer.
+        :param editable: Defines whether to filter out editable API keys or not.
+        :param expired: Defines whether to filter out expired API keys or not.
+        :param access_key: Filter by access key.
+        :param description: Filter by description.
+        :param bearer_id: Filter by bearer ID.
+        :param bearer_type: Filter by type of bearer.
         :return: :class:`List[ListAPIKeysResponse] <List[ListAPIKeysResponse]>`
 
         Usage:
         ::
 
             result = await api.list_api_keys_all()
         """
@@ -1610,24 +1737,25 @@
         description: str,
         application_id: Optional[str] = None,
         user_id: Optional[str] = None,
         expires_at: Optional[datetime] = None,
         default_project_id: Optional[str] = None,
     ) -> APIKey:
         """
-        Create an API key
-        :param application_id: ID of application principal.
+        Create an API key.
+        Create an API key. You must specify the `application_id` or the `user_id` and the description. You can also specify the `default_project_id` which is the Project ID of your preferred Project, to use with Object Storage. The `access_key` and `secret_key` values are returned in the response. Note that he secret key is only showed once. Make sure that you copy and store both keys somewhere safe.
+        :param application_id: ID of the application.
 
         One-of ('bearer'): at most one of 'application_id', 'user_id' could be set.
-        :param user_id: ID of user principal.
+        :param user_id: ID of the user.
 
         One-of ('bearer'): at most one of 'application_id', 'user_id' could be set.
         :param expires_at: Expiration date of the API key.
-        :param default_project_id: The default project ID to use with object storage.
-        :param description: The description of the API key (max length is 200 chars).
+        :param default_project_id: Default Project ID to use with Object Storage.
+        :param description: Description of the API key (max length is 200 characters).
         :return: :class:`APIKey <APIKey>`
 
         Usage:
         ::
 
             result = await api.create_api_key(description="example")
         """
@@ -1652,15 +1780,16 @@
 
     async def get_api_key(
         self,
         *,
         access_key: str,
     ) -> APIKey:
         """
-        Get an API key
+        Get an API key.
+        Retrive information about an API key, specified by the `access_key` parameter. The API key's details, including either the `user_id` or `application_id` of its bearer are returned in the response. Note that the string value for the `secret_key` is nullable, and therefore is not displayed in the response. The `secret_key` value is only displayed upon API key creation.
         :param access_key: Access key to search for.
         :return: :class:`APIKey <APIKey>`
 
         Usage:
         ::
 
             result = await api.get_api_key(access_key="example")
@@ -1680,18 +1809,19 @@
         self,
         *,
         access_key: str,
         default_project_id: Optional[str] = None,
         description: Optional[str] = None,
     ) -> APIKey:
         """
-        Update an API key
+        Update an API key.
+        Update the parameters of an API key, including `default_project_id` and `description`.
         :param access_key: Access key to update.
-        :param default_project_id: The new default project ID to set.
-        :param description: The new description to update.
+        :param default_project_id: New default Project ID to set.
+        :param description: New description to update.
         :return: :class:`APIKey <APIKey>`
 
         Usage:
         ::
 
             result = await api.update_api_key(access_key="example")
         """
@@ -1716,15 +1846,16 @@
 
     async def delete_api_key(
         self,
         *,
         access_key: str,
     ) -> Optional[None]:
         """
-        Delete an API key
+        Delete an API key.
+        Delete an API key. Note that this action is irreversible and cannot be undone. Make sure you update any configurations using the API keys you delete.
         :param access_key: Access key to delete.
 
         Usage:
         ::
 
             result = await api.delete_api_key(access_key="example")
         """
@@ -1744,19 +1875,20 @@
         *,
         order_by: ListQuotaRequestOrderBy = ListQuotaRequestOrderBy.NAME_ASC,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         organization_id: Optional[str] = None,
     ) -> ListQuotaResponse:
         """
-        List all quota in the organization with the associated limit
+        List all quotas in the Organization.
+        List all product and features quota for an Organization, with their associated limits. By default, the quota listed are ordered by creation date in ascending order. This can be modified via the `order_by` field. You must define the `organization_id` in the query path of your request.
         :param order_by: Criteria for sorting results.
         :param page_size: Number of results per page. Value must be between 1 and 100.
-        :param page: Number of page. Value must be greater to 1.
-        :param organization_id: Filter by organization ID.
+        :param page: Page number. Value must be greater than 1.
+        :param organization_id: Filter by Organization ID.
         :return: :class:`ListQuotaResponse <ListQuotaResponse>`
 
         Usage:
         ::
 
             result = await api.list_quota()
         """
@@ -1781,19 +1913,20 @@
         *,
         order_by: Optional[ListQuotaRequestOrderBy] = None,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         organization_id: Optional[str] = None,
     ) -> List[Quotum]:
         """
-        List all quota in the organization with the associated limit
+        List all quotas in the Organization.
+        List all product and features quota for an Organization, with their associated limits. By default, the quota listed are ordered by creation date in ascending order. This can be modified via the `order_by` field. You must define the `organization_id` in the query path of your request.
         :param order_by: Criteria for sorting results.
         :param page_size: Number of results per page. Value must be between 1 and 100.
-        :param page: Number of page. Value must be greater to 1.
-        :param organization_id: Filter by organization ID.
+        :param page: Page number. Value must be greater than 1.
+        :param organization_id: Filter by Organization ID.
         :return: :class:`List[ListQuotaResponse] <List[ListQuotaResponse]>`
 
         Usage:
         ::
 
             result = await api.list_quota_all()
         """
@@ -1813,17 +1946,18 @@
     async def get_quotum(
         self,
         *,
         quotum_name: str,
         organization_id: Optional[str] = None,
     ) -> Quotum:
         """
-        Get a quotum in the organization with the associated limit
-        :param quotum_name: Name of the quotum to get.
-        :param organization_id: ID of the organization.
+        Get a quota in the Organization.
+        Retrieve information about a resource quota, speficified by the `quotum_name` parameter. The quota's `limit`, or whether it is unlimited, is returned in the response.
+        :param quotum_name: Name of the quota to get.
+        :param organization_id: ID of the Organization.
         :return: :class:`Quotum <Quotum>`
 
         Usage:
         ::
 
             result = await api.get_quotum(quotum_name="example")
         """
@@ -1848,19 +1982,19 @@
         audience_id: str,
         order_by: ListJWTsRequestOrderBy = ListJWTsRequestOrderBy.CREATED_AT_ASC,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         expired: Optional[bool] = None,
     ) -> ListJWTsResponse:
         """
-        List JWTs
+        List JWTs.
         :param order_by: Criteria for sorting results.
         :param audience_id: ID of the user to search.
         :param page_size: Number of results per page. Value must be between 1 and 100.
-        :param page: Number of page. Value must be greater to 1.
+        :param page: Page number. Value must be greater to 1.
         :param expired: Filter out expired JWTs or not.
         :return: :class:`ListJWTsResponse <ListJWTsResponse>`
 
         Usage:
         ::
 
             result = await api.list_jw_ts(audience_id="example")
@@ -1887,19 +2021,19 @@
         audience_id: str,
         order_by: Optional[ListJWTsRequestOrderBy] = None,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         expired: Optional[bool] = None,
     ) -> List[JWT]:
         """
-        List JWTs
+        List JWTs.
         :param order_by: Criteria for sorting results.
         :param audience_id: ID of the user to search.
         :param page_size: Number of results per page. Value must be between 1 and 100.
-        :param page: Number of page. Value must be greater to 1.
+        :param page: Page number. Value must be greater to 1.
         :param expired: Filter out expired JWTs or not.
         :return: :class:`List[ListJWTsResponse] <List[ListJWTsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_jw_ts_all(audience_id="example")
@@ -1920,15 +2054,15 @@
 
     async def get_jwt(
         self,
         *,
         jti: str,
     ) -> JWT:
         """
-        Get a JWT
+        Get a JWT.
         :param jti: JWT ID of the JWT to get.
         :return: :class:`JWT <JWT>`
 
         Usage:
         ::
 
             result = await api.get_jwt(jti="example")
@@ -1946,15 +2080,15 @@
 
     async def delete_jwt(
         self,
         *,
         jti: str,
     ) -> Optional[None]:
         """
-        Delete a JWT
+        Delete a JWT.
         :param jti: JWT ID of the JWT to delete.
 
         Usage:
         ::
 
             result = await api.delete_jwt(jti="example")
         """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/iam/v1alpha1/marshalling.py` & `scaleway_async-1.0.0/scaleway_async/iam/v1alpha1/marshalling.py`

 * *Files 27% similar despite different names*

```diff
@@ -30,20 +30,22 @@
     Rule,
     RuleSpecs,
     SSHKey,
     SetRulesResponse,
     User,
     CreateSSHKeyRequest,
     UpdateSSHKeyRequest,
+    CreateUserRequest,
     CreateApplicationRequest,
     UpdateApplicationRequest,
     CreateGroupRequest,
     UpdateGroupRequest,
     SetGroupMembersRequest,
     AddGroupMemberRequest,
+    AddGroupMembersRequest,
     RemoveGroupMemberRequest,
     CreatePolicyRequest,
     UpdatePolicyRequest,
     SetRulesRequest,
     CreateAPIKeyRequest,
     UpdateAPIKeyRequest,
 )
@@ -53,736 +55,927 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'APIKey' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("access_key")
+    field = data.get("access_key", None)
     args["access_key"] = field
 
-    field = data.get("application_id")
+    field = data.get("application_id", None)
     args["application_id"] = field
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("creation_ip")
+    field = data.get("creation_ip", None)
     args["creation_ip"] = field
 
-    field = data.get("default_project_id")
+    field = data.get("default_project_id", None)
     args["default_project_id"] = field
 
-    field = data.get("description")
+    field = data.get("description", None)
     args["description"] = field
 
-    field = data.get("editable")
+    field = data.get("editable", None)
     args["editable"] = field
 
-    field = data.get("expires_at")
+    field = data.get("expires_at", None)
     args["expires_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("secret_key")
+    field = data.get("secret_key", None)
     args["secret_key"] = field
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("user_id")
+    field = data.get("user_id", None)
     args["user_id"] = field
 
     return APIKey(**args)
 
 
 def unmarshal_Application(data: Any) -> Application:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Application' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("description")
+    field = data.get("description", None)
     args["description"] = field
 
-    field = data.get("editable")
+    field = data.get("editable", None)
     args["editable"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("nb_api_keys")
+    field = data.get("nb_api_keys", None)
     args["nb_api_keys"] = field
 
-    field = data.get("organization_id")
+    field = data.get("organization_id", None)
     args["organization_id"] = field
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
     return Application(**args)
 
 
 def unmarshal_Group(data: Any) -> Group:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Group' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("application_ids")
+    field = data.get("application_ids", None)
     args["application_ids"] = field
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("description")
+    field = data.get("description", None)
     args["description"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("organization_id")
+    field = data.get("organization_id", None)
     args["organization_id"] = field
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("user_ids")
+    field = data.get("user_ids", None)
     args["user_ids"] = field
 
     return Group(**args)
 
 
 def unmarshal_JWT(data: Any) -> JWT:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'JWT' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("audience_id")
+    field = data.get("audience_id", None)
     args["audience_id"] = field
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("expires_at")
+    field = data.get("expires_at", None)
     args["expires_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("ip")
+    field = data.get("ip", None)
     args["ip"] = field
 
-    field = data.get("issuer_id")
+    field = data.get("issuer_id", None)
     args["issuer_id"] = field
 
-    field = data.get("jti")
+    field = data.get("jti", None)
     args["jti"] = field
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("user_agent")
+    field = data.get("user_agent", None)
     args["user_agent"] = field
 
     return JWT(**args)
 
 
 def unmarshal_PermissionSet(data: Any) -> PermissionSet:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'PermissionSet' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("categories")
+    field = data.get("categories", None)
     args["categories"] = field
 
-    field = data.get("description")
+    field = data.get("description", None)
     args["description"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("scope_type")
+    field = data.get("scope_type", None)
     args["scope_type"] = field
 
     return PermissionSet(**args)
 
 
 def unmarshal_Policy(data: Any) -> Policy:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Policy' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("application_id")
+    field = data.get("application_id", None)
     args["application_id"] = field
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("description")
+    field = data.get("description", None)
     args["description"] = field
 
-    field = data.get("editable")
+    field = data.get("editable", None)
     args["editable"] = field
 
-    field = data.get("group_id")
+    field = data.get("group_id", None)
     args["group_id"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("nb_permission_sets")
+    field = data.get("nb_permission_sets", None)
     args["nb_permission_sets"] = field
 
-    field = data.get("nb_rules")
+    field = data.get("nb_rules", None)
     args["nb_rules"] = field
 
-    field = data.get("nb_scopes")
+    field = data.get("nb_scopes", None)
     args["nb_scopes"] = field
 
-    field = data.get("no_principal")
+    field = data.get("no_principal", None)
     args["no_principal"] = field
 
-    field = data.get("organization_id")
+    field = data.get("organization_id", None)
     args["organization_id"] = field
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("user_id")
+    field = data.get("user_id", None)
     args["user_id"] = field
 
     return Policy(**args)
 
 
 def unmarshal_Quotum(data: Any) -> Quotum:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Quotum' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("limit")
+    field = data.get("limit", None)
     args["limit"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("unlimited")
+    field = data.get("unlimited", None)
     args["unlimited"] = field
 
     return Quotum(**args)
 
 
 def unmarshal_Rule(data: Any) -> Rule:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Rule' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("account_root_user_id")
+    field = data.get("account_root_user_id", None)
     args["account_root_user_id"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("organization_id")
+    field = data.get("organization_id", None)
     args["organization_id"] = field
 
-    field = data.get("permission_set_names")
+    field = data.get("permission_set_names", None)
     args["permission_set_names"] = field
 
-    field = data.get("permission_sets_scope_type")
+    field = data.get("permission_sets_scope_type", None)
     args["permission_sets_scope_type"] = field
 
-    field = data.get("project_ids")
+    field = data.get("project_ids", None)
     args["project_ids"] = field
 
     return Rule(**args)
 
 
 def unmarshal_SSHKey(data: Any) -> SSHKey:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'SSHKey' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("disabled")
+    field = data.get("disabled", None)
     args["disabled"] = field
 
-    field = data.get("fingerprint")
+    field = data.get("fingerprint", None)
     args["fingerprint"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("organization_id")
+    field = data.get("organization_id", None)
     args["organization_id"] = field
 
-    field = data.get("project_id")
+    field = data.get("project_id", None)
     args["project_id"] = field
 
-    field = data.get("public_key")
+    field = data.get("public_key", None)
     args["public_key"] = field
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
     return SSHKey(**args)
 
 
 def unmarshal_User(data: Any) -> User:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'User' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
+    field = data.get("account_root_user_id", None)
+    args["account_root_user_id"] = field
+
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("deletable")
+    field = data.get("deletable", None)
     args["deletable"] = field
 
-    field = data.get("email")
+    field = data.get("email", None)
     args["email"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("last_login_at")
+    field = data.get("last_login_at", None)
     args["last_login_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("organization_id")
+    field = data.get("mfa", None)
+    args["mfa"] = field
+
+    field = data.get("organization_id", None)
     args["organization_id"] = field
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("two_factor_enabled")
+    field = data.get("two_factor_enabled", None)
     args["two_factor_enabled"] = field
 
-    field = data.get("type_")
+    field = data.get("type", None)
     args["type_"] = field
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
     return User(**args)
 
 
 def unmarshal_ListAPIKeysResponse(data: Any) -> ListAPIKeysResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListAPIKeysResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("api_keys")
-    args["api_keys"] = [unmarshal_APIKey(v) for v in data["api_keys"]]
+    field = data.get("api_keys", None)
+    args["api_keys"] = (
+        [unmarshal_APIKey(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListAPIKeysResponse(**args)
 
 
 def unmarshal_ListApplicationsResponse(data: Any) -> ListApplicationsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListApplicationsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("applications")
-    args["applications"] = [unmarshal_Application(v) for v in data["applications"]]
+    field = data.get("applications", None)
+    args["applications"] = (
+        [unmarshal_Application(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListApplicationsResponse(**args)
 
 
 def unmarshal_ListGroupsResponse(data: Any) -> ListGroupsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListGroupsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("groups")
-    args["groups"] = [unmarshal_Group(v) for v in data["groups"]]
+    field = data.get("groups", None)
+    args["groups"] = [unmarshal_Group(v) for v in field] if field is not None else None
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListGroupsResponse(**args)
 
 
 def unmarshal_ListJWTsResponse(data: Any) -> ListJWTsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListJWTsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("jwts")
-    args["jwts"] = [unmarshal_JWT(v) for v in data["jwts"]]
+    field = data.get("jwts", None)
+    args["jwts"] = [unmarshal_JWT(v) for v in field] if field is not None else None
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListJWTsResponse(**args)
 
 
 def unmarshal_ListPermissionSetsResponse(data: Any) -> ListPermissionSetsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListPermissionSetsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("permission_sets")
-    args["permission_sets"] = [
-        unmarshal_PermissionSet(v) for v in data["permission_sets"]
-    ]
+    field = data.get("permission_sets", None)
+    args["permission_sets"] = (
+        [unmarshal_PermissionSet(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListPermissionSetsResponse(**args)
 
 
 def unmarshal_ListPoliciesResponse(data: Any) -> ListPoliciesResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListPoliciesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("policies")
-    args["policies"] = [unmarshal_Policy(v) for v in data["policies"]]
+    field = data.get("policies", None)
+    args["policies"] = (
+        [unmarshal_Policy(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListPoliciesResponse(**args)
 
 
 def unmarshal_ListQuotaResponse(data: Any) -> ListQuotaResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListQuotaResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("quota")
-    args["quota"] = [unmarshal_Quotum(v) for v in data["quota"]]
+    field = data.get("quota", None)
+    args["quota"] = [unmarshal_Quotum(v) for v in field] if field is not None else None
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListQuotaResponse(**args)
 
 
 def unmarshal_ListRulesResponse(data: Any) -> ListRulesResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListRulesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("rules")
-    args["rules"] = [unmarshal_Rule(v) for v in data["rules"]]
+    field = data.get("rules", None)
+    args["rules"] = [unmarshal_Rule(v) for v in field] if field is not None else None
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListRulesResponse(**args)
 
 
 def unmarshal_ListSSHKeysResponse(data: Any) -> ListSSHKeysResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListSSHKeysResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("ssh_keys")
-    args["ssh_keys"] = [unmarshal_SSHKey(v) for v in data["ssh_keys"]]
+    field = data.get("ssh_keys", None)
+    args["ssh_keys"] = (
+        [unmarshal_SSHKey(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListSSHKeysResponse(**args)
 
 
 def unmarshal_ListUsersResponse(data: Any) -> ListUsersResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListUsersResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    field = data.get("users")
-    args["users"] = [unmarshal_User(v) for v in data["users"]]
+    field = data.get("users", None)
+    args["users"] = [unmarshal_User(v) for v in field] if field is not None else None
 
     return ListUsersResponse(**args)
 
 
 def unmarshal_SetRulesResponse(data: Any) -> SetRulesResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'SetRulesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("rules")
-    args["rules"] = [unmarshal_Rule(v) for v in data["rules"]]
+    field = data.get("rules", None)
+    args["rules"] = [unmarshal_Rule(v) for v in field] if field is not None else None
 
     return SetRulesResponse(**args)
 
 
 def marshal_RuleSpecs(
     request: RuleSpecs,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("project_ids", request.project_ids),
+                OneOfPossibility(
+                    "project_ids",
+                    request.project_ids if request.project_ids is not None else None,
+                ),
                 OneOfPossibility(
                     "organization_id",
-                    request.organization_id,
+                    request.organization_id
+                    if request.organization_id is not None
+                    else None,
                     defaults.default_organization_id,
                 ),
             ]
         ),
-        "permission_set_names": request.permission_set_names,
-    }
+    )
+
+    if request.permission_set_names is not None:
+        output["permission_set_names"] = request.permission_set_names
+
+    return output
 
 
 def marshal_AddGroupMemberRequest(
     request: AddGroupMemberRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("user_id", request.user_id),
-                OneOfPossibility("application_id", request.application_id),
+                OneOfPossibility(
+                    "user_id", request.user_id if request.user_id is not None else None
+                ),
+                OneOfPossibility(
+                    "application_id",
+                    request.application_id
+                    if request.application_id is not None
+                    else None,
+                ),
             ]
         ),
-    }
+    )
+
+    return output
+
+
+def marshal_AddGroupMembersRequest(
+    request: AddGroupMembersRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.application_ids is not None:
+        output["application_ids"] = request.application_ids
+
+    if request.user_ids is not None:
+        output["user_ids"] = request.user_ids
+
+    return output
 
 
 def marshal_CreateAPIKeyRequest(
     request: CreateAPIKeyRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("application_id", request.application_id),
-                OneOfPossibility("user_id", request.user_id),
+                OneOfPossibility(
+                    "application_id",
+                    request.application_id
+                    if request.application_id is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "user_id", request.user_id if request.user_id is not None else None
+                ),
             ]
         ),
-        "default_project_id": request.default_project_id,
-        "description": request.description,
-        "expires_at": request.expires_at,
-    }
+    )
+
+    if request.default_project_id is not None:
+        output["default_project_id"] = request.default_project_id
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.expires_at is not None:
+        output["expires_at"] = request.expires_at
+
+    return output
 
 
 def marshal_CreateApplicationRequest(
     request: CreateApplicationRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "description": request.description,
-        "name": request.name,
-        "organization_id": request.organization_id or defaults.default_organization_id,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.organization_id is not None:
+        output["organization_id"] = (
+            request.organization_id or defaults.default_organization_id
+        )
+
+    return output
 
 
 def marshal_CreateGroupRequest(
     request: CreateGroupRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "description": request.description,
-        "name": request.name,
-        "organization_id": request.organization_id or defaults.default_organization_id,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.organization_id is not None:
+        output["organization_id"] = (
+            request.organization_id or defaults.default_organization_id
+        )
+
+    return output
 
 
 def marshal_CreatePolicyRequest(
     request: CreatePolicyRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("user_id", request.user_id),
-                OneOfPossibility("group_id", request.group_id),
-                OneOfPossibility("application_id", request.application_id),
-                OneOfPossibility("no_principal", request.no_principal),
+                OneOfPossibility(
+                    "user_id", request.user_id if request.user_id is not None else None
+                ),
+                OneOfPossibility(
+                    "group_id",
+                    request.group_id if request.group_id is not None else None,
+                ),
+                OneOfPossibility(
+                    "application_id",
+                    request.application_id
+                    if request.application_id is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "no_principal",
+                    request.no_principal if request.no_principal is not None else None,
+                ),
             ]
         ),
-        "description": request.description,
-        "name": request.name,
-        "organization_id": request.organization_id or defaults.default_organization_id,
-        "rules": [marshal_RuleSpecs(v, defaults) for v in request.rules]
-        if request.rules is not None
-        else None,
-    }
+    )
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.organization_id is not None:
+        output["organization_id"] = (
+            request.organization_id or defaults.default_organization_id
+        )
+
+    if request.rules is not None:
+        output["rules"] = [marshal_RuleSpecs(v, defaults) for v in request.rules]
+
+    return output
 
 
 def marshal_CreateSSHKeyRequest(
     request: CreateSSHKeyRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "name": request.name,
-        "project_id": request.project_id or defaults.default_project_id,
-        "public_key": request.public_key,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    if request.public_key is not None:
+        output["public_key"] = request.public_key
+
+    return output
+
+
+def marshal_CreateUserRequest(
+    request: CreateUserRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.email is not None:
+        output["email"] = request.email
+
+    if request.organization_id is not None:
+        output["organization_id"] = (
+            request.organization_id or defaults.default_organization_id
+        )
+
+    return output
 
 
 def marshal_RemoveGroupMemberRequest(
     request: RemoveGroupMemberRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("user_id", request.user_id),
-                OneOfPossibility("application_id", request.application_id),
+                OneOfPossibility(
+                    "user_id", request.user_id if request.user_id is not None else None
+                ),
+                OneOfPossibility(
+                    "application_id",
+                    request.application_id
+                    if request.application_id is not None
+                    else None,
+                ),
             ]
         ),
-    }
+    )
+
+    return output
 
 
 def marshal_SetGroupMembersRequest(
     request: SetGroupMembersRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "application_ids": request.application_ids,
-        "user_ids": request.user_ids,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.application_ids is not None:
+        output["application_ids"] = request.application_ids
+
+    if request.user_ids is not None:
+        output["user_ids"] = request.user_ids
+
+    return output
 
 
 def marshal_SetRulesRequest(
     request: SetRulesRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "policy_id": request.policy_id,
-        "rules": [marshal_RuleSpecs(v, defaults) for v in request.rules],
-    }
+    output: Dict[str, Any] = {}
+
+    if request.policy_id is not None:
+        output["policy_id"] = request.policy_id
+
+    if request.rules is not None:
+        output["rules"] = [marshal_RuleSpecs(v, defaults) for v in request.rules]
+
+    return output
 
 
 def marshal_UpdateAPIKeyRequest(
     request: UpdateAPIKeyRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "default_project_id": request.default_project_id,
-        "description": request.description,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.default_project_id is not None:
+        output["default_project_id"] = request.default_project_id
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    return output
 
 
 def marshal_UpdateApplicationRequest(
     request: UpdateApplicationRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "description": request.description,
-        "name": request.name,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
 
 
 def marshal_UpdateGroupRequest(
     request: UpdateGroupRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "description": request.description,
-        "name": request.name,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
 
 
 def marshal_UpdatePolicyRequest(
     request: UpdatePolicyRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("user_id", request.user_id),
-                OneOfPossibility("group_id", request.group_id),
-                OneOfPossibility("application_id", request.application_id),
-                OneOfPossibility("no_principal", request.no_principal),
+                OneOfPossibility(
+                    "user_id", request.user_id if request.user_id is not None else None
+                ),
+                OneOfPossibility(
+                    "group_id",
+                    request.group_id if request.group_id is not None else None,
+                ),
+                OneOfPossibility(
+                    "application_id",
+                    request.application_id
+                    if request.application_id is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "no_principal",
+                    request.no_principal if request.no_principal is not None else None,
+                ),
             ]
         ),
-        "description": request.description,
-        "name": request.name,
-    }
+    )
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
 
 
 def marshal_UpdateSSHKeyRequest(
     request: UpdateSSHKeyRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "disabled": request.disabled,
-        "name": request.name,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.disabled is not None:
+        output["disabled"] = request.disabled
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
```

### Comparing `scaleway_async-0.9.0/scaleway_async/iam/v1alpha1/types.py` & `scaleway_async-1.0.0/scaleway_async/iam/v1alpha1/types.py`

 * *Files 11% similar despite different names*

```diff
@@ -151,148 +151,148 @@
 class APIKey:
     """
     Api key.
     """
 
     access_key: str
     """
-    Access key of API key.
+    Access key of the API key.
     """
 
     secret_key: Optional[str]
     """
-    Secret key of API Key.
+    Secret key of the API Key.
     """
 
     application_id: Optional[str]
     """
-    ID of application bearer.
+    ID of application that bears the API key.
     
     One-of ('bearer'): at most one of 'application_id', 'user_id' could be set.
     """
 
     user_id: Optional[str]
     """
-    ID of user bearer.
+    ID of user that bears the API key.
     
     One-of ('bearer'): at most one of 'application_id', 'user_id' could be set.
     """
 
     description: str
     """
     Description of API key.
     """
 
     created_at: Optional[datetime]
     """
-    Creation date and time of API key.
+    Date and time of API key creation.
     """
 
     updated_at: Optional[datetime]
     """
-    Last update date and time of API key.
+    Date and time of last API key update.
     """
 
     expires_at: Optional[datetime]
     """
-    Expiration date and time of API key.
+    Date and time of API key expiration.
     """
 
     default_project_id: str
     """
-    The default project ID specified for this API key.
+    Default Project ID specified for this API key.
     """
 
     editable: bool
     """
-    Whether or not the API key is editable.
+    Defines whether or not the API key is editable.
     """
 
     creation_ip: str
     """
-    IP Address of the device which created the API key.
+    IP address of the device that created the API key.
     """
 
 
 @dataclass
 class Application:
     """
     Application.
     """
 
     id: str
     """
-    ID of application.
+    ID of the application.
     """
 
     name: str
     """
-    Name of application.
+    Name of the application.
     """
 
     description: str
     """
     Description of the application.
     """
 
     created_at: Optional[datetime]
     """
-    Creation date of application.
+    Date and time application was created.
     """
 
     updated_at: Optional[datetime]
     """
-    Last update date of application.
+    Date and time of last application update.
     """
 
     organization_id: str
     """
-    ID of organization.
+    ID of the Organization.
     """
 
     editable: bool
     """
-    Whether or not the application is editable.
+    Defines whether or not the application is editable.
     """
 
     nb_api_keys: int
     """
-    Number of API keys owned by the application.
+    Number of API keys attributed to the application.
     """
 
 
 @dataclass
 class Group:
     """
     Group.
     """
 
     id: str
     """
-    ID of group.
+    ID of the group.
     """
 
     created_at: Optional[datetime]
     """
-    Creation date and time of group.
+    Date and time of group creation.
     """
 
     updated_at: Optional[datetime]
     """
-    Last update date and time of group.
+    Date and time of last group update.
     """
 
     organization_id: str
     """
-    ID of organization linked to the group.
+    ID of Organization linked to the group.
     """
 
     name: str
     """
-    Name of group.
+    Name of the group.
     """
 
     description: str
     """
     Description of the group.
     """
 
@@ -518,144 +518,144 @@
 class PermissionSet:
     """
     Permission set.
     """
 
     id: str
     """
-    Id of permission set.
+    Id of the permission set.
     """
 
     name: str
     """
-    Name of permission set.
+    Name of the permission set.
     """
 
     scope_type: PermissionSetScopeType
     """
-    Scope of permission set.
+    Scope of the permission set.
     """
 
     description: str
     """
-    Description of permission set.
+    Description of the permission set.
     """
 
     categories: Optional[List[str]]
     """
-    Categories of permission set.
+    Categories of the permission set.
     """
 
 
 @dataclass
 class Policy:
     """
     Policy.
     """
 
     id: str
     """
-    Id of policy.
+    Id of the policy.
     """
 
     name: str
     """
-    Name of policy.
+    Name of the policy.
     """
 
     description: str
     """
-    Description of policy.
+    Description of the policy.
     """
 
     organization_id: str
     """
-    Organization ID of policy.
+    Organization ID of the policy.
     """
 
     created_at: Optional[datetime]
     """
-    Creation date and time of policy.
+    Date and time of policy creation.
     """
 
     updated_at: Optional[datetime]
     """
-    Last update date and time of policy.
+    Date and time of last policy update.
     """
 
     editable: bool
     """
-    Editable status of policy.
+    Defines whether or not a policy is editable.
     """
 
     nb_rules: int
     """
-    Number of rules of policy.
+    Number of rules of the policy.
     """
 
     nb_scopes: int
     """
-    Number of scopes of policy.
+    Number of policy scopes.
     """
 
     nb_permission_sets: int
     """
-    Number of permission sets of policy.
+    Number of permission sets of the policy.
     """
 
     user_id: Optional[str]
     """
-    ID of user, owner of the policy.
+    ID of the user attributed to the policy.
     
     One-of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
     """
 
     group_id: Optional[str]
     """
-    ID of group, owner of the policy.
+    ID of the group attributed to the policy.
     
     One-of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
     """
 
     application_id: Optional[str]
     """
-    ID of application, owner of the policy.
+    ID of the application attributed to the policy.
     
     One-of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
     """
 
     no_principal: Optional[bool]
     """
-    True when the policy do not belong to any principal.
+    Defines whether or not a policy is attributed to a principal.
     
     One-of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
     """
 
 
 @dataclass
 class Quotum:
     """
     Quotum.
     """
 
     name: str
     """
-    Name of the quotum.
+    Name of the quota.
     """
 
     limit: Optional[int]
     """
-    Max limit of the quotum.
+    Maximum limit of the quota.
     
     One-of ('value'): at most one of 'limit', 'unlimited' could be set.
     """
 
     unlimited: Optional[bool]
     """
-    Whether the quotum is unlimited or not.
+    Defines whether or not the quota is unlimited.
     
     One-of ('value'): at most one of 'limit', 'unlimited' could be set.
     """
 
 
 @dataclass
 class Rule:
@@ -676,29 +676,29 @@
     permission_sets_scope_type: PermissionSetScopeType
     """
     Permission_set_names have the same scope_type.
     """
 
     project_ids: Optional[List[str]]
     """
-    List of project IDs scoped to the rule.
+    List of Project IDs the rule is scoped to.
     
     One-of ('scope'): at most one of 'project_ids', 'organization_id', 'account_root_user_id' could be set.
     """
 
     organization_id: Optional[str]
     """
-    ID of organization scoped to the rule.
+    ID of Organization the rule is scoped to.
     
     One-of ('scope'): at most one of 'project_ids', 'organization_id', 'account_root_user_id' could be set.
     """
 
     account_root_user_id: Optional[str]
     """
-    ID of account root user scoped to the rule.
+    ID of account root user the rule is scoped to.
     
     One-of ('scope'): at most one of 'project_ids', 'organization_id', 'account_root_user_id' could be set.
     """
 
 
 @dataclass
 class RuleSpecs:
@@ -709,22 +709,22 @@
     permission_set_names: Optional[List[str]]
     """
     Names of permission sets bound to the rule.
     """
 
     project_ids: Optional[List[str]]
     """
-    List of project IDs scoped to the rule.
+    List of Project IDs the rule is scoped to.
     
     One-of ('scope'): at most one of 'project_ids', 'organization_id' could be set.
     """
 
     organization_id: Optional[str]
     """
-    ID of organization scoped to the rule.
+    ID of Organization the rule is scoped to.
     
     One-of ('scope'): at most one of 'project_ids', 'organization_id' could be set.
     """
 
 
 @dataclass
 class SSHKey:
@@ -745,35 +745,35 @@
     public_key: str
     """
     Public key of SSH key.
     """
 
     fingerprint: str
     """
-    Fingerprint of SSH key.
+    Fingerprint of the SSH key.
     """
 
     created_at: Optional[datetime]
     """
     Creation date of SSH key.
     """
 
     updated_at: Optional[datetime]
     """
     Last update date of SSH key.
     """
 
     organization_id: str
     """
-    ID of organization linked to the SSH key.
+    ID of Organization linked to the SSH key.
     """
 
     project_id: str
     """
-    ID of project linked to the SSH key.
+    ID of Project linked to the SSH key.
     """
 
     disabled: bool
     """
     SSH key status.
     """
 
@@ -782,15 +782,15 @@
 class SetRulesResponse:
     """
     Set rules response.
     """
 
     rules: List[Rule]
     """
-    Rules of policy.
+    Rules of the policy.
     """
 
 
 @dataclass
 class User:
     """
     User.
@@ -804,114 +804,125 @@
     email: str
     """
     Email of user.
     """
 
     created_at: Optional[datetime]
     """
-    Creation date of user.
+    Date user was created.
     """
 
     updated_at: Optional[datetime]
     """
-    Last update date of user.
+    Date of last user update.
     """
 
     organization_id: str
     """
-    ID of organization.
+    ID of the Organization.
     """
 
     deletable: bool
     """
-    Deletion status of user. Owner user cannot be deleted.
+    Deletion status of user. Owners cannot be deleted.
     """
 
     last_login_at: Optional[datetime]
     """
-    Last login date.
+    Date of the last login.
     """
 
     type_: UserType
     """
-    Type of the user.
+    Type of user.
     """
 
-    two_factor_enabled: bool
+    two_factor_enabled: Optional[bool]
     """
-    2FA enabled.
+    Deprecated, use "mfa" instead.
+    :deprecated
     """
 
     status: UserStatus
     """
-    Status of invitation for the user.
+    Status of user invitation.
+    """
+
+    mfa: bool
+    """
+    Defines whether MFA is enabled.
+    """
+
+    account_root_user_id: str
+    """
+    ID of the account root user associated with the user.
     """
 
 
 @dataclass
 class ListSSHKeysRequest:
     order_by: Optional[ListSSHKeysRequestOrderBy]
     """
-    Sort order of SSH keys.
+    Sort order of the SSH keys.
     """
 
     page: Optional[int]
     """
-    Requested page number. Value must be greater or equals to 1.
+    Requested page number. Value must be greater or equal to 1.
     """
 
     page_size: Optional[int]
     """
     Number of items per page. Value must be between 1 and 100.
     """
 
     organization_id: Optional[str]
     """
-    Filter by organization ID.
+    Filter by Organization ID.
     """
 
     name: Optional[str]
     """
     Name of group to find.
     """
 
     project_id: Optional[str]
     """
-    Filter by project ID.
+    Filter by Project ID.
     """
 
     disabled: Optional[bool]
     """
-    Filter out disabled SSH keys or not.
+    Defines whether to include disabled SSH keys or not.
     """
 
 
 @dataclass
 class CreateSSHKeyRequest:
     name: Optional[str]
     """
-    The name of the SSH key. Max length is 1000.
+    Name of the SSH key. Max length is 1000.
     """
 
     public_key: str
     """
-    SSH public key. Currently ssh-rsa, ssh-dss (DSA), ssh-ed25519 and ecdsa keys with NIST curves are supported. Max length is 65000.
+    SSH public key. Currently only the ssh-rsa, ssh-dss (DSA), ssh-ed25519 and ecdsa keys with NIST curves are supported. Max length is 65000.
     """
 
     project_id: Optional[str]
     """
-    Project owning the resource.
+    Project the resource is attributed to.
     """
 
 
 @dataclass
 class GetSSHKeyRequest:
     ssh_key_id: str
     """
-    The ID of the SSH key.
+    ID of the SSH key.
     """
 
 
 @dataclass
 class UpdateSSHKeyRequest:
     ssh_key_id: str
 
@@ -941,41 +952,59 @@
     page_size: Optional[int]
     """
     Number of results per page. Value must be between 1 and 100.
     """
 
     page: Optional[int]
     """
-    Number of page. Value must be greater or equals to 1.
+    Page number. Value must be greater or equal to 1.
     """
 
     organization_id: Optional[str]
     """
-    ID of organization to filter.
+    ID of the Organization to filter.
     """
 
     user_ids: Optional[List[str]]
     """
-    Filter out by a list of ID.
+    Filter by list of IDs.
+    """
+
+    mfa: Optional[bool]
+    """
+    Filter by MFA status.
     """
 
 
 @dataclass
 class GetUserRequest:
     user_id: str
     """
-    ID of user to find.
+    ID of the user to find.
     """
 
 
 @dataclass
 class DeleteUserRequest:
     user_id: str
     """
-    ID of user to delete.
+    ID of the user to delete.
+    """
+
+
+@dataclass
+class CreateUserRequest:
+    organization_id: Optional[str]
+    """
+    ID of the Organization.
+    """
+
+    email: str
+    """
+    Email of the user.
     """
 
 
 @dataclass
 class ListApplicationsRequest:
     order_by: Optional[ListApplicationsRequestOrderBy]
     """
@@ -985,169 +1014,169 @@
     page_size: Optional[int]
     """
     Number of results per page. Value must be between 1 and 100.
     """
 
     page: Optional[int]
     """
-    Number of page. Value must be greater to 1.
+    Page number. Value must be greater than 1.
     """
 
     name: Optional[str]
     """
-    Name of application to filter.
+    Name of the application to filter.
     """
 
     organization_id: Optional[str]
     """
-    ID of organization to filter.
+    ID of the Organization to filter.
     """
 
     editable: Optional[bool]
     """
-    Filter out editable applications or not.
+    Defines whether to filter out editable applications or not.
     """
 
     application_ids: Optional[List[str]]
     """
-    Filter out by a list of ID.
+    Filter by list of IDs.
     """
 
 
 @dataclass
 class CreateApplicationRequest:
     name: Optional[str]
     """
-    Name of application to create (max length is 64 chars).
+    Name of the application to create (max length is 64 characters).
     """
 
     organization_id: Optional[str]
     """
-    ID of organization.
+    ID of the Organization.
     """
 
     description: str
     """
-    Description of application (max length is 200 chars).
+    Description of the application (max length is 200 characters).
     """
 
 
 @dataclass
 class GetApplicationRequest:
     application_id: str
     """
-    ID of application to find.
+    ID of the application to find.
     """
 
 
 @dataclass
 class UpdateApplicationRequest:
     application_id: str
     """
-    ID of application to update.
+    ID of the application to update.
     """
 
     name: Optional[str]
     """
-    New name of application (max length is 64 chars).
+    New name for the application (max length is 64 chars).
     """
 
     description: Optional[str]
     """
-    New description of application (max length is 200 chars).
+    New description for the application (max length is 200 chars).
     """
 
 
 @dataclass
 class DeleteApplicationRequest:
     application_id: str
     """
-    ID of application to delete.
+    ID of the application to delete.
     """
 
 
 @dataclass
 class ListGroupsRequest:
     order_by: Optional[ListGroupsRequestOrderBy]
     """
     Sort order of groups.
     """
 
     page: Optional[int]
     """
-    Requested page number. Value must be greater or equals to 1.
+    Requested page number. Value must be greater or equal to 1.
     """
 
     page_size: Optional[int]
     """
     Number of items per page. Value must be between 1 and 100.
     """
 
     organization_id: Optional[str]
     """
-    Filter by organization ID.
+    Filter by Organization ID.
     """
 
     name: Optional[str]
     """
     Name of group to find.
     """
 
     application_ids: Optional[List[str]]
     """
-    Filter out by a list of application ID.
+    Filter by a list of application IDs.
     """
 
     user_ids: Optional[List[str]]
     """
-    Filter out by a list of user ID.
+    Filter by a list of user IDs.
     """
 
     group_ids: Optional[List[str]]
     """
-    Filter out by a list of group ID.
+    Filter by a list of group IDs.
     """
 
 
 @dataclass
 class CreateGroupRequest:
     organization_id: Optional[str]
     """
-    ID of organization linked to the group.
+    ID of Organization linked to the group.
     """
 
     name: Optional[str]
     """
-    Name of the group to create (max length is 64 chars). MUST be unique inside an organization.
+    Name of the group to create (max length is 64 chars). MUST be unique inside an Organization.
     """
 
     description: str
     """
     Description of the group to create (max length is 200 chars).
     """
 
 
 @dataclass
 class GetGroupRequest:
     group_id: str
     """
-    ID of group.
+    ID of the group.
     """
 
 
 @dataclass
 class UpdateGroupRequest:
     group_id: str
     """
-    ID of group to update.
+    ID of the group to update.
     """
 
     name: Optional[str]
     """
-    New name for the group (max length is 64 chars). MUST be unique inside an organization.
+    New name for the group (max length is 64 chars). MUST be unique inside an Organization.
     """
 
     description: Optional[str]
     """
     New description for the group (max length is 200 chars).
     """
 
@@ -1161,15 +1190,15 @@
     application_ids: List[str]
 
 
 @dataclass
 class AddGroupMemberRequest:
     group_id: str
     """
-    ID of group.
+    ID of the group.
     """
 
     user_id: Optional[str]
     """
     ID of the user to add.
     
     One-of ('member'): at most one of 'user_id', 'application_id' could be set.
@@ -1180,18 +1209,36 @@
     ID of the application to add.
     
     One-of ('member'): at most one of 'user_id', 'application_id' could be set.
     """
 
 
 @dataclass
+class AddGroupMembersRequest:
+    group_id: str
+    """
+    ID of the group.
+    """
+
+    user_ids: Optional[List[str]]
+    """
+    IDs of the users to add.
+    """
+
+    application_ids: Optional[List[str]]
+    """
+    IDs of the applications to add.
+    """
+
+
+@dataclass
 class RemoveGroupMemberRequest:
     group_id: str
     """
-    ID of group.
+    ID of the group.
     """
 
     user_id: Optional[str]
     """
     ID of the user to remove.
     
     One-of ('member'): at most one of 'user_id', 'application_id' could be set.
@@ -1205,15 +1252,15 @@
     """
 
 
 @dataclass
 class DeleteGroupRequest:
     group_id: str
     """
-    ID of group to delete.
+    ID of the group to delete.
     """
 
 
 @dataclass
 class ListPoliciesRequest:
     order_by: Optional[ListPoliciesRequestOrderBy]
     """
@@ -1223,99 +1270,99 @@
     page_size: Optional[int]
     """
     Number of results per page. Value must be between 1 and 100.
     """
 
     page: Optional[int]
     """
-    Number of page. Value must be greater to 1.
+    Page number. Value must be greater than 1.
     """
 
     organization_id: Optional[str]
     """
-    ID of organization to filter.
+    ID of the Organization to filter.
     """
 
     editable: Optional[bool]
     """
-    Filter out editable policies or not.
+    Defines whether or not filter out editable policies.
     """
 
     user_ids: Optional[List[str]]
     """
-    Filter out by a list of user ID.
+    Defines whether or not to filter by list of user IDs.
     """
 
     group_ids: Optional[List[str]]
     """
-    Filter out by a list of group ID.
+    Defines whether or not to filter by list of group IDs.
     """
 
     application_ids: Optional[List[str]]
     """
-    Filter out by a list of application ID.
+    Filter by a list of application IDs.
     """
 
     no_principal: Optional[bool]
     """
-    True when the policy do not belong to any principal.
+    Defines whether or not the policy is attributed to a principal.
     """
 
     policy_name: Optional[str]
     """
-    Name of policy to fetch.
+    Name of the policy to fetch.
     """
 
 
 @dataclass
 class CreatePolicyRequest:
     name: Optional[str]
     """
-    Name of policy to create (max length is 64 chars).
+    Name of the policy to create (max length is 64 characters).
     """
 
     description: str
     """
-    Description of policy to create (max length is 200 chars).
+    Description of the policy to create (max length is 200 characters).
     """
 
     organization_id: Optional[str]
     """
-    ID of organization.
+    ID of the Organization.
     """
 
     rules: Optional[List[RuleSpecs]]
     """
     Rules of the policy to create.
     """
 
     user_id: Optional[str]
     """
-    ID of user, owner of the policy.
+    ID of user attributed to the policy.
     
     One-of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
     """
 
     group_id: Optional[str]
     """
-    ID of group, owner of the policy.
+    ID of group attributed to the policy.
     
     One-of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
     """
 
     application_id: Optional[str]
     """
-    ID of application, owner of the policy.
+    ID of application attributed to the policy.
     
     One-of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
     """
 
     no_principal: Optional[bool]
     """
-    True when the policy do not belong to any principal.
+    Defines whether or not a policy is attributed to a principal.
     
     One-of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
     """
 
 
 @dataclass
 class GetPolicyRequest:
@@ -1330,46 +1377,46 @@
     policy_id: str
     """
     Id of policy to update.
     """
 
     name: Optional[str]
     """
-    New name of policy (max length is 64 chars).
+    New name for the policy (max length is 64 characters).
     """
 
     description: Optional[str]
     """
-    New description of policy (max length is 200 chars).
+    New description of policy (max length is 200 characters).
     """
 
     user_id: Optional[str]
     """
-    New ID of user, owner of the policy.
+    New ID of user attributed to the policy.
     
     One-of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
     """
 
     group_id: Optional[str]
     """
-    New ID of group, owner of the policy.
+    New ID of group attributed to the policy.
     
     One-of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
     """
 
     application_id: Optional[str]
     """
-    New ID of application, owner of the policy.
+    New ID of application attributed to the policy.
     
     One-of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
     """
 
     no_principal: Optional[bool]
     """
-    True when the policy do not belong to any principal.
+    Defines whether or not the policy is attributed to a principal.
     
     One-of ('principal'): at most one of 'user_id', 'group_id', 'application_id', 'no_principal' could be set.
     """
 
 
 @dataclass
 class DeletePolicyRequest:
@@ -1407,15 +1454,15 @@
     page_size: Optional[int]
     """
     Number of results per page. Value must be between 1 and 100.
     """
 
     page: Optional[int]
     """
-    Number of page. Value must be greater to 1.
+    Page number. Value must be greater than 1.
     """
 
 
 @dataclass
 class ListPermissionSetsRequest:
     order_by: Optional[ListPermissionSetsRequestOrderBy]
     """
@@ -1425,121 +1472,121 @@
     page_size: Optional[int]
     """
     Number of results per page. Value must be between 1 and 100.
     """
 
     page: Optional[int]
     """
-    Number of page. Value must be greater to 1.
+    Page number. Value must be greater than 1.
     """
 
     organization_id: Optional[str]
     """
-    Filter by organization ID.
+    Filter by Organization ID.
     """
 
 
 @dataclass
 class ListAPIKeysRequest:
     order_by: Optional[ListAPIKeysRequestOrderBy]
     """
     Criteria for sorting results.
     """
 
     page: Optional[int]
     """
-    Number of page. Value must be greater or equals to 1.
+    Page number. Value must be greater or equal to 1.
     """
 
     page_size: Optional[int]
     """
     Number of results per page. Value must be between 1 and 100.
     """
 
     organization_id: Optional[str]
     """
-    ID of organization.
+    ID of Organization.
     """
 
     application_id: Optional[str]
     """
-    ID of an application bearer.
+    ID of application that bears the API key.
     
     One-of ('bearer'): at most one of 'application_id', 'user_id' could be set.
     :deprecated
     """
 
     user_id: Optional[str]
     """
-    ID of a user bearer.
+    ID of user that bears the API key.
     
     One-of ('bearer'): at most one of 'application_id', 'user_id' could be set.
     :deprecated
     """
 
     editable: Optional[bool]
     """
-    Filter out editable API keys or not.
+    Defines whether to filter out editable API keys or not.
     """
 
     expired: Optional[bool]
     """
-    Filter out expired API keys or not.
+    Defines whether to filter out expired API keys or not.
     """
 
     access_key: Optional[str]
     """
-    Filter out by access key.
+    Filter by access key.
     """
 
     description: Optional[str]
     """
-    Filter out by description.
+    Filter by description.
     """
 
     bearer_id: Optional[str]
     """
-    Filter out by bearer ID.
+    Filter by bearer ID.
     """
 
     bearer_type: Optional[BearerType]
     """
-    Filter out by type of bearer.
+    Filter by type of bearer.
     """
 
 
 @dataclass
 class CreateAPIKeyRequest:
     application_id: Optional[str]
     """
-    ID of application principal.
+    ID of the application.
     
     One-of ('bearer'): at most one of 'application_id', 'user_id' could be set.
     """
 
     user_id: Optional[str]
     """
-    ID of user principal.
+    ID of the user.
     
     One-of ('bearer'): at most one of 'application_id', 'user_id' could be set.
     """
 
     expires_at: Optional[datetime]
     """
     Expiration date of the API key.
     """
 
     default_project_id: Optional[str]
     """
-    The default project ID to use with object storage.
+    Default Project ID to use with Object Storage.
     """
 
     description: str
     """
-    The description of the API key (max length is 200 chars).
+    Description of the API key (max length is 200 characters).
     """
 
 
 @dataclass
 class GetAPIKeyRequest:
     access_key: str
     """
@@ -1552,20 +1599,20 @@
     access_key: str
     """
     Access key to update.
     """
 
     default_project_id: Optional[str]
     """
-    The new default project ID to set.
+    New default Project ID to set.
     """
 
     description: Optional[str]
     """
-    The new description to update.
+    New description to update.
     """
 
 
 @dataclass
 class DeleteAPIKeyRequest:
     access_key: str
     """
@@ -1583,33 +1630,33 @@
     page_size: Optional[int]
     """
     Number of results per page. Value must be between 1 and 100.
     """
 
     page: Optional[int]
     """
-    Number of page. Value must be greater to 1.
+    Page number. Value must be greater than 1.
     """
 
     organization_id: Optional[str]
     """
-    Filter by organization ID.
+    Filter by Organization ID.
     """
 
 
 @dataclass
 class GetQuotumRequest:
     quotum_name: str
     """
-    Name of the quotum to get.
+    Name of the quota to get.
     """
 
     organization_id: Optional[str]
     """
-    ID of the organization.
+    ID of the Organization.
     """
 
 
 @dataclass
 class ListJWTsRequest:
     order_by: Optional[ListJWTsRequestOrderBy]
     """
@@ -1624,15 +1671,15 @@
     page_size: Optional[int]
     """
     Number of results per page. Value must be between 1 and 100.
     """
 
     page: Optional[int]
     """
-    Number of page. Value must be greater to 1.
+    Page number. Value must be greater to 1.
     """
 
     expired: Optional[bool]
     """
     Filter out expired JWTs or not.
     """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/instance/v1/__init__.py` & `scaleway_async-1.0.0/scaleway_async/instance/v1/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,22 +1,26 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 from .types import Arch
 from .types import BootType
 from .types import ImageState
+from .types import IpState
+from .types import IpType
 from .types import ListServersRequestOrder
 from .types import PlacementGroupPolicyMode
 from .types import PlacementGroupPolicyType
 from .types import PrivateNICState
 from .types import SecurityGroupPolicy
 from .types import SecurityGroupRuleAction
 from .types import SecurityGroupRuleDirection
 from .types import SecurityGroupRuleProtocol
 from .types import SecurityGroupState
 from .types import ServerAction
+from .types import ServerIpIpFamily
+from .types import ServerIpProvisioningMode
 from .types import ServerState
 from .types import ServerTypesAvailability
 from .types import SnapshotState
 from .types import SnapshotVolumeType
 from .types import TaskStatus
 from .types import VolumeServerState
 from .types import VolumeServerVolumeType
@@ -102,37 +106,42 @@
 from .types import VolumeServerTemplate
 from .types import VolumeSummary
 from .types import VolumeTemplate
 from .types import VolumeType
 from .types import VolumeTypeCapabilities
 from .types import VolumeTypeConstraints
 from .content import IMAGE_TRANSIENT_STATUSES
+from .content import IP_TRANSIENT_STATUSES
 from .content import PRIVATE_NIC_TRANSIENT_STATUSES
 from .content import SECURITY_GROUP_TRANSIENT_STATUSES
 from .content import SERVER_TRANSIENT_STATUSES
 from .content import SNAPSHOT_TRANSIENT_STATUSES
 from .content import TASK_TRANSIENT_STATUSES
 from .content import VOLUME_SERVER_TRANSIENT_STATUSES
 from .content import VOLUME_TRANSIENT_STATUSES
 from .api import InstanceV1API
 
 __all__ = [
     "Arch",
     "BootType",
     "ImageState",
+    "IpState",
+    "IpType",
     "ListServersRequestOrder",
     "PlacementGroupPolicyMode",
     "PlacementGroupPolicyType",
     "PrivateNICState",
     "SecurityGroupPolicy",
     "SecurityGroupRuleAction",
     "SecurityGroupRuleDirection",
     "SecurityGroupRuleProtocol",
     "SecurityGroupState",
     "ServerAction",
+    "ServerIpIpFamily",
+    "ServerIpProvisioningMode",
     "ServerState",
     "ServerTypesAvailability",
     "SnapshotState",
     "SnapshotVolumeType",
     "TaskStatus",
     "VolumeServerState",
     "VolumeServerVolumeType",
@@ -218,14 +227,15 @@
     "VolumeServerTemplate",
     "VolumeSummary",
     "VolumeTemplate",
     "VolumeType",
     "VolumeTypeCapabilities",
     "VolumeTypeConstraints",
     "IMAGE_TRANSIENT_STATUSES",
+    "IP_TRANSIENT_STATUSES",
     "PRIVATE_NIC_TRANSIENT_STATUSES",
     "SECURITY_GROUP_TRANSIENT_STATUSES",
     "SERVER_TRANSIENT_STATUSES",
     "SNAPSHOT_TRANSIENT_STATUSES",
     "TASK_TRANSIENT_STATUSES",
     "VOLUME_SERVER_TRANSIENT_STATUSES",
     "VOLUME_TRANSIENT_STATUSES",
```

### Comparing `scaleway_async-0.9.0/scaleway_async/instance/v1/api.py` & `scaleway_async-1.0.0/scaleway_async/instance/v1/api.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,14 +13,15 @@
     random_name,
     validate_path_param,
 )
 from .types import (
     Arch,
     BootType,
     ImageState,
+    IpType,
     ListServersRequestOrder,
     PlacementGroupPolicyMode,
     PlacementGroupPolicyType,
     SecurityGroupPolicy,
     SecurityGroupRuleAction,
     SecurityGroupRuleDirection,
     SecurityGroupRuleProtocol,
@@ -211,28 +212,31 @@
     unmarshal__SetSnapshotResponse,
 )
 
 
 class InstanceV1API(API):
     """
     Instance API.
+
+    Instance API.
     """
 
     async def get_server_types_availability(
         self,
         *,
         zone: Optional[Zone] = None,
         per_page: Optional[int] = None,
         page: Optional[int] = None,
     ) -> GetServerTypesAvailabilityResponse:
         """
-        Get availability for all server types.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param per_page:
-        :param page:
+        Get availability.
+        Get availability for all Instance types.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param per_page: A positive integer lower or equal to 100 to select the number of items to return.
+        :param page: A positive integer to choose the page to return.
         :return: :class:`GetServerTypesAvailabilityResponse <GetServerTypesAvailabilityResponse>`
 
         Usage:
         ::
 
             result = await api.get_server_types_availability()
         """
@@ -255,16 +259,17 @@
         self,
         *,
         zone: Optional[Zone] = None,
         per_page: Optional[int] = None,
         page: Optional[int] = None,
     ) -> ListServersTypesResponse:
         """
-        Get server types technical details.
-        :param zone: Zone to target. If none is passed will use default zone from the config
+        List Instance types.
+        List available Instance types and their technical details.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
         :param per_page:
         :param page:
         :return: :class:`ListServersTypesResponse <ListServersTypesResponse>`
 
         Usage:
         ::
 
@@ -289,16 +294,17 @@
         self,
         *,
         zone: Optional[Zone] = None,
         per_page: Optional[int] = None,
         page: Optional[int] = None,
     ) -> ListVolumesTypesResponse:
         """
-        Get volumes technical details.
-        :param zone: Zone to target. If none is passed will use default zone from the config
+        List volume types.
+        List all volume types and their technical details.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
         :param per_page:
         :param page:
         :return: :class:`ListVolumesTypesResponse <ListVolumesTypesResponse>`
 
         Usage:
         ::
 
@@ -331,30 +337,33 @@
         private_ip: Optional[str] = None,
         without_ip: Optional[bool] = None,
         commercial_type: Optional[str] = None,
         state: ServerState = ServerState.RUNNING,
         tags: Optional[List[str]] = None,
         private_network: Optional[str] = None,
         order: ListServersRequestOrder = ListServersRequestOrder.CREATION_DATE_DESC,
+        private_networks: Optional[List[str]] = None,
     ) -> ListServersResponse:
         """
-        List all servers
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param per_page: A positive integer lower or equal to 100 to select the number of items to return
-        :param page: A positive integer to choose the page to return
-        :param organization: List only servers of this organization ID
-        :param project: List only servers of this project ID
-        :param name: Filter servers by name (for eg. "server1" will return "server100" and "server1" but not "foo")
-        :param private_ip: List servers by private_ip
-        :param without_ip: List servers that are not attached to a public IP
-        :param commercial_type: List servers of this commercial type
-        :param state: List servers in this state
-        :param tags: List servers with these exact tags (to filter with several tags, use commas to separate them)
-        :param private_network: List servers in this Private Network
-        :param order: Define the order of the returned servers
+        List all Instances.
+        List all Instances in a specified Availability Zone, e.g. `fr-par-1`.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param per_page: A positive integer lower or equal to 100 to select the number of items to return.
+        :param page: A positive integer to choose the page to return.
+        :param organization: List only Instances of this Organization ID.
+        :param project: List only Instances of this Project ID.
+        :param name: Filter Instances by name (eg. "server1" will return "server100" and "server1" but not "foo").
+        :param private_ip: List Instances by private_ip.
+        :param without_ip: List Instances that are not attached to a public IP.
+        :param commercial_type: List Instances of this commercial type.
+        :param state: List Instances in this state.
+        :param tags: List Instances with these exact tags (to filter with several tags, use commas to separate them).
+        :param private_network: List Instances in this Private Network.
+        :param order: Define the order of the returned servers.
+        :param private_networks: List Instances from the given Private Networks (use commas to separate them).
         :return: :class:`ListServersResponse <ListServersResponse>`
 
         Usage:
         ::
 
             result = await api.list_servers()
         """
@@ -369,14 +378,17 @@
                 "name": name,
                 "order": order,
                 "organization": organization or self.client.default_organization_id,
                 "page": page,
                 "per_page": per_page or self.client.default_page_size,
                 "private_ip": private_ip,
                 "private_network": private_network,
+                "private_networks": ",".join(private_networks)
+                if private_networks and len(private_networks) > 0
+                else None,
                 "project": project or self.client.default_project_id,
                 "state": state,
                 "tags": ",".join(tags) if tags and len(tags) > 0 else None,
                 "without_ip": without_ip,
             },
         )
 
@@ -395,30 +407,33 @@
         private_ip: Optional[str] = None,
         without_ip: Optional[bool] = None,
         commercial_type: Optional[str] = None,
         state: Optional[ServerState] = None,
         tags: Optional[List[str]] = None,
         private_network: Optional[str] = None,
         order: Optional[ListServersRequestOrder] = None,
+        private_networks: Optional[List[str]] = None,
     ) -> List[Server]:
         """
-        List all servers
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param per_page: A positive integer lower or equal to 100 to select the number of items to return
-        :param page: A positive integer to choose the page to return
-        :param organization: List only servers of this organization ID
-        :param project: List only servers of this project ID
-        :param name: Filter servers by name (for eg. "server1" will return "server100" and "server1" but not "foo")
-        :param private_ip: List servers by private_ip
-        :param without_ip: List servers that are not attached to a public IP
-        :param commercial_type: List servers of this commercial type
-        :param state: List servers in this state
-        :param tags: List servers with these exact tags (to filter with several tags, use commas to separate them)
-        :param private_network: List servers in this Private Network
-        :param order: Define the order of the returned servers
+        List all Instances.
+        List all Instances in a specified Availability Zone, e.g. `fr-par-1`.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param per_page: A positive integer lower or equal to 100 to select the number of items to return.
+        :param page: A positive integer to choose the page to return.
+        :param organization: List only Instances of this Organization ID.
+        :param project: List only Instances of this Project ID.
+        :param name: Filter Instances by name (eg. "server1" will return "server100" and "server1" but not "foo").
+        :param private_ip: List Instances by private_ip.
+        :param without_ip: List Instances that are not attached to a public IP.
+        :param commercial_type: List Instances of this commercial type.
+        :param state: List Instances in this state.
+        :param tags: List Instances with these exact tags (to filter with several tags, use commas to separate them).
+        :param private_network: List Instances in this Private Network.
+        :param order: Define the order of the returned servers.
+        :param private_networks: List Instances from the given Private Networks (use commas to separate them).
         :return: :class:`List[ListServersResponse] <List[ListServersResponse]>`
 
         Usage:
         ::
 
             result = await api.list_servers_all()
         """
@@ -437,75 +452,64 @@
                 "private_ip": private_ip,
                 "without_ip": without_ip,
                 "commercial_type": commercial_type,
                 "state": state,
                 "tags": tags,
                 "private_network": private_network,
                 "order": order,
+                "private_networks": private_networks,
             },
         )
 
     async def _create_server(
         self,
         *,
         commercial_type: str,
         image: str,
         enable_ipv6: bool,
         zone: Optional[Zone] = None,
         name: Optional[str] = None,
         dynamic_ip_required: Optional[bool] = None,
+        routed_ip_enabled: Optional[bool] = None,
         volumes: Optional[Dict[str, VolumeServerTemplate]] = None,
         public_ip: Optional[str] = None,
+        public_ips: Optional[List[str]] = None,
         boot_type: Optional[BootType] = None,
         bootscript: Optional[str] = None,
         organization: Optional[str] = None,
         project: Optional[str] = None,
         tags: Optional[List[str]] = None,
         security_group: Optional[str] = None,
         placement_group: Optional[str] = None,
     ) -> CreateServerResponse:
         """
-        The `volumes` key is a dictionary composed of the volume position as key and the volume parameters as value.
-        Depending of the volume parameters, you can achieve different behaviours :
-
-        Create a volume from a snapshot of an image :
-        Optional : `volume_type`, `size`, `boot`.
-        If the `size` parameter is not set, the size of the volume will equal the size of the corresponding snapshot of the image.
-
-        Attach an existing volume :
-        Required : `id`, `name`.
-        Optional : `boot`.
-
-        Create an empty volume :
-        Required : `name`, `volume_type`, `size`.
-        Optional : `organization`, `project`, `boot`.
-
-        Create a volume from a snapshot :
-        Required : `base_snapshot`, `name`, `volume_type`.
-        Optional : `organization`, `project`, `boot`.
-
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param name: The server name
-        :param dynamic_ip_required: Define if a dynamic IP is required for the instance
-        :param commercial_type: Define the server commercial type (i.e. GP1-S)
-        :param image: The server image ID or label
-        :param volumes: The volumes attached to the server
-        :param enable_ipv6: True if IPv6 is enabled on the server
-        :param public_ip: The ID of the reserved IP to attach to the server
-        :param boot_type: The boot type to use
-        :param bootscript: The bootscript ID to use when `boot_type` is set to `bootscript`
-        :param organization: The server organization ID.
+        Create an Instance.
+        Create a new Instance of the specified commercial type in the specified zone. Pay attention to the volumes parameter, which takes an object which can be used in different ways to achieve different behaviors.
+        Get more information in the [Technical Information](#technical-information) section of the introduction.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param name: Instance name.
+        :param dynamic_ip_required: Define if a dynamic IPv4 is required for the Instance.
+        :param routed_ip_enabled: If true, configure the Instance so it uses the new routed IP mode.
+        :param commercial_type: Define the Instance commercial type (i.e. GP1-S).
+        :param image: Instance image ID or label.
+        :param volumes: Volumes attached to the server.
+        :param enable_ipv6: True if IPv6 is enabled on the server.
+        :param public_ip: ID of the reserved IP to attach to the Instance.
+        :param public_ips: A list of reserved IP IDs to attach to the Instance.
+        :param boot_type: Boot type to use.
+        :param bootscript: Bootscript ID to use when `boot_type` is set to `bootscript`.
+        :param organization: Instance Organization ID.
 
         One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
-        :param project: The server project ID.
+        :param project: Instance Project ID.
 
         One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
-        :param tags: The server tags
-        :param security_group: The security group ID
-        :param placement_group: Placement group ID if server must be part of a placement group
+        :param tags: Instance tags.
+        :param security_group: Security group ID.
+        :param placement_group: Placement group ID if Instance must be part of a placement group.
         :return: :class:`CreateServerResponse <CreateServerResponse>`
 
         Usage:
         ::
 
             result = await api._create_server(
                 commercial_type="example",
@@ -523,16 +527,18 @@
                 _CreateServerRequest(
                     commercial_type=commercial_type,
                     image=image,
                     enable_ipv6=enable_ipv6,
                     zone=zone,
                     name=name or random_name(prefix="srv"),
                     dynamic_ip_required=dynamic_ip_required,
+                    routed_ip_enabled=routed_ip_enabled,
                     volumes=volumes,
                     public_ip=public_ip,
+                    public_ips=public_ips,
                     boot_type=boot_type,
                     bootscript=bootscript,
                     organization=organization,
                     project=project,
                     tags=tags,
                     security_group=security_group,
                     placement_group=placement_group,
@@ -547,16 +553,17 @@
     async def delete_server(
         self,
         *,
         server_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete a server with the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
+        Delete an Instance.
+        Delete the Instance with the specified ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
         :param server_id:
 
         Usage:
         ::
 
             result = await api.delete_server(server_id="example")
         """
@@ -575,17 +582,18 @@
     async def get_server(
         self,
         *,
         server_id: str,
         zone: Optional[Zone] = None,
     ) -> GetServerResponse:
         """
-        Get the details of a specified Server.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: UUID of the server you want to get
+        Get an Instance.
+        Get the details of a specified Instance.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: UUID of the Instance you want to get.
         :return: :class:`GetServerResponse <GetServerResponse>`
 
         Usage:
         ::
 
             result = await api.get_server(server_id="example")
         """
@@ -617,17 +625,19 @@
         arch: Arch,
         zone: Optional[Zone] = None,
         organization: Optional[str] = None,
         project: Optional[str] = None,
         allowed_actions: Optional[List[ServerAction]] = None,
         tags: Optional[List[str]] = None,
         creation_date: Optional[datetime] = None,
+        routed_ip_enabled: Optional[bool] = None,
         image: Optional[Image] = None,
         private_ip: Optional[str] = None,
         public_ip: Optional[ServerIp] = None,
+        public_ips: Optional[List[ServerIp]] = None,
         modification_date: Optional[datetime] = None,
         location: Optional[ServerLocation] = None,
         ipv6: Optional[ServerIpv6] = None,
         bootscript: Optional[Bootscript] = None,
         volumes: Optional[Dict[str, Volume]] = None,
         security_group: Optional[SecurityGroupSummary] = None,
         maintenances: Optional[List[ServerMaintenance]] = None,
@@ -675,17 +685,19 @@
                     arch=arch,
                     zone=zone,
                     organization=organization,
                     project=project,
                     allowed_actions=allowed_actions,
                     tags=tags,
                     creation_date=creation_date,
+                    routed_ip_enabled=routed_ip_enabled,
                     image=image,
                     private_ip=private_ip,
                     public_ip=public_ip,
+                    public_ips=public_ips,
                     modification_date=modification_date,
                     location=location,
                     ipv6=ipv6,
                     bootscript=bootscript,
                     volumes=volumes,
                     security_group=security_group,
                     maintenances=maintenances,
@@ -706,35 +718,46 @@
         zone: Optional[Zone] = None,
         name: Optional[str] = None,
         boot_type: Optional[BootType] = None,
         tags: Optional[List[str]] = None,
         volumes: Optional[Dict[str, VolumeServerTemplate]] = None,
         bootscript: Optional[str] = None,
         dynamic_ip_required: Optional[bool] = None,
+        routed_ip_enabled: Optional[bool] = None,
+        public_ips: Optional[List[ServerIp]] = None,
         enable_ipv6: Optional[bool] = None,
         protected: Optional[bool] = None,
         security_group: Optional[SecurityGroupTemplate] = None,
         placement_group: Optional[str] = None,
         private_nics: Optional[List[PrivateNIC]] = None,
+        commercial_type: Optional[str] = None,
     ) -> UpdateServerResponse:
         """
-        Update a server
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: UUID of the server
-        :param name: Name of the server
+        Update an Instance.
+        Update the Instance information, such as name, boot mode, or tags.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: UUID of the Instance.
+        :param name: Name of the Instance.
         :param boot_type:
-        :param tags: Tags of the server
+        :param tags: Tags of the Instance.
         :param volumes:
         :param bootscript:
         :param dynamic_ip_required:
+        :param routed_ip_enabled: True to configure the instance so it uses the new routed IP mode (once this is set to True you cannot set it back to False).
+        :param public_ips:
         :param enable_ipv6:
         :param protected:
         :param security_group:
-        :param placement_group: Placement group ID if server must be part of a placement group
-        :param private_nics: The server private NICs
+        :param placement_group: Placement group ID if Instance must be part of a placement group.
+        :param private_nics: Instance private NICs.
+        :param commercial_type: Set the commercial_type for this Instance.
+        Warning: This field has some restrictions:
+        - Cannot be changed if the Instance is not in `stopped` state.
+        - Cannot be changed if the Instance is in a placement group.
+        - Local storage requirements of the target commercial_types must be fulfilled (i.e. if an Instance has 80GB of local storage, it can be changed into a GP1-XS, which has a maximum of 150GB, but it cannot be changed into a DEV1-S, which has only 20GB).
         :return: :class:`UpdateServerResponse <UpdateServerResponse>`
 
         Usage:
         ::
 
             result = await api._update_server(server_id="example")
         """
@@ -751,19 +774,22 @@
                     zone=zone,
                     name=name,
                     boot_type=boot_type,
                     tags=tags,
                     volumes=volumes,
                     bootscript=bootscript,
                     dynamic_ip_required=dynamic_ip_required,
+                    routed_ip_enabled=routed_ip_enabled,
+                    public_ips=public_ips,
                     enable_ipv6=enable_ipv6,
                     protected=protected,
                     security_group=security_group,
                     placement_group=placement_group,
                     private_nics=private_nics,
+                    commercial_type=commercial_type,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_UpdateServerResponse(res.json())
@@ -771,16 +797,17 @@
     async def list_server_actions(
         self,
         *,
         server_id: str,
         zone: Optional[Zone] = None,
     ) -> ListServerActionsResponse:
         """
-        List all actions that can currently be performed on a server.
-        :param zone: Zone to target. If none is passed will use default zone from the config
+        List Instance actions.
+        List all actions (e.g. power on, power off, reboot) that can currently be performed on an Instance.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
         :param server_id:
         :return: :class:`ListServerActionsResponse <ListServerActionsResponse>`
 
         Usage:
         ::
 
             result = await api.list_server_actions(server_id="example")
@@ -803,24 +830,37 @@
         server_id: str,
         action: ServerAction,
         zone: Optional[Zone] = None,
         name: Optional[str] = None,
         volumes: Optional[Dict[str, ServerActionRequestVolumeBackupTemplate]] = None,
     ) -> ServerActionResponse:
         """
-        Perform power related actions on a server. Be wary that when terminating a server, all the attached volumes (local *and* block storage) are deleted. So, if you want to keep your local volumes, you must use the `archive` action instead of `terminate`. And if you want to keep block-storage volumes, **you must** detach it beforehand you issue the `terminate` call.  For more information, read the [Volumes](#volumes-7e8a39) documentation.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: UUID of the server
-        :param action: The action to perform on the server
-        :param name: The name of the backup you want to create.
+        Perform action.
+        Perform an action on an Instance.
+        Available actions are:
+        * `poweron`: Start a stopped Instance.
+        * `poweroff`: Fully stop the Instance and release the hypervisor slot.
+        * `stop_in_place`: Stop the Instance, but keep the slot on the hypervisor.
+        * `reboot`: Stop the instance and restart it.
+        * `backup`:  Create an image with all the volumes of an Instance.
+        * `terminate`: Delete the Instance along with all attached volumes.
+        * `enable_routed_ip`: Migrate the Instance to the new network stack.
+
+        Keep in mind that terminating an Instance will result in the deletion of all attached volumes, including local and block storage.
+        If you want to preserve your local volumes, you should use the `archive` action instead of `terminate`. Similarly, if you want to keep your block storage volumes, you must first detach them before issuing the `terminate` command.
+        For more information, read the [Volumes](#path-volumes-list-volumes) documentation.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: UUID of the Instance.
+        :param action: Action to perform on the Instance.
+        :param name: Name of the backup you want to create.
+        Name of the backup you want to create.
         This field should only be specified when performing a backup action.
-
         :param volumes: For each volume UUID, the snapshot parameters of the volume.
+        For each volume UUID, the snapshot parameters of the volume.
         This field should only be specified when performing a backup action.
-
         :return: :class:`ServerActionResponse <ServerActionResponse>`
 
         Usage:
         ::
 
             result = await api.server_action(
                 server_id="example",
@@ -852,17 +892,18 @@
     async def list_server_user_data(
         self,
         *,
         server_id: str,
         zone: Optional[Zone] = None,
     ) -> ListServerUserDataResponse:
         """
-        List all user data keys registered on a given server.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: UUID of the server
+        List user data.
+        List all user data keys registered on a specified Instance.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: UUID of the Instance.
         :return: :class:`ListServerUserDataResponse <ListServerUserDataResponse>`
 
         Usage:
         ::
 
             result = await api.list_server_user_data(server_id="example")
         """
@@ -882,18 +923,19 @@
         self,
         *,
         server_id: str,
         key: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete the given key from a server user data.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: UUID of the server
-        :param key: Key of the user data to delete
+        Delete user data.
+        Delete the specified key from an Instance's user data.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: UUID of the Instance.
+        :param key: Key of the user data to delete.
 
         Usage:
         ::
 
             result = await api.delete_server_user_data(
                 server_id="example",
                 key="example",
@@ -922,16 +964,17 @@
         name: Optional[str] = None,
         public: Optional[bool] = None,
         arch: Optional[str] = None,
         project: Optional[str] = None,
         tags: Optional[str] = None,
     ) -> ListImagesResponse:
         """
-        List all images available in an account.
-        :param zone: Zone to target. If none is passed will use default zone from the config
+        List Instance images.
+        List all existing Instance images.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
         :param organization:
         :param per_page:
         :param page:
         :param name:
         :param public:
         :param arch:
         :param project:
@@ -974,16 +1017,17 @@
         name: Optional[str] = None,
         public: Optional[bool] = None,
         arch: Optional[str] = None,
         project: Optional[str] = None,
         tags: Optional[str] = None,
     ) -> List[Image]:
         """
-        List all images available in an account.
-        :param zone: Zone to target. If none is passed will use default zone from the config
+        List Instance images.
+        List all existing Instance images.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
         :param organization:
         :param per_page:
         :param page:
         :param name:
         :param public:
         :param arch:
         :param project:
@@ -1016,17 +1060,18 @@
     async def get_image(
         self,
         *,
         image_id: str,
         zone: Optional[Zone] = None,
     ) -> GetImageResponse:
         """
-        Get details of an image with the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param image_id: UUID of the image you want to get
+        Get an Instance image.
+        Get details of an image with the specified ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param image_id: UUID of the image you want to get.
         :return: :class:`GetImageResponse <GetImageResponse>`
 
         Usage:
         ::
 
             result = await api.get_image(image_id="example")
         """
@@ -1053,29 +1098,30 @@
         extra_volumes: Optional[Dict[str, VolumeTemplate]] = None,
         organization: Optional[str] = None,
         project: Optional[str] = None,
         tags: Optional[List[str]] = None,
         public: Optional[bool] = None,
     ) -> CreateImageResponse:
         """
-        Create an instance image
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param name: Name of the image
-        :param root_volume: UUID of the snapshot
-        :param arch: Architecture of the image
-        :param default_bootscript: Default bootscript of the image
-        :param extra_volumes: Additional volumes of the image
+        Create an Instance image.
+        Create an Instance image from the specified snapshot ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param name: Name of the image.
+        :param root_volume: UUID of the snapshot.
+        :param arch: Architecture of the image.
+        :param default_bootscript: Default bootscript of the image.
+        :param extra_volumes: Additional volumes of the image.
         :param organization: Organization ID of the image.
 
         One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
         :param project: Project ID of the image.
 
         One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
-        :param tags: The tags of the image
-        :param public: True to create a public image
+        :param tags: Tags of the image.
+        :param public: True to create a public image.
         :return: :class:`CreateImageResponse <CreateImageResponse>`
 
         Usage:
         ::
 
             result = await api.create_image(root_volume="example")
         """
@@ -1121,16 +1167,17 @@
         extra_volumes: Optional[Dict[str, Volume]] = None,
         organization: Optional[str] = None,
         root_volume: Optional[VolumeSummary] = None,
         project: Optional[str] = None,
         tags: Optional[List[str]] = None,
     ) -> _SetImageResponse:
         """
+        Update image.
         Replace all image properties with an image message.
-        :param zone: Zone to target. If none is passed will use default zone from the config
+        :param zone: Zone to target. If none is passed will use default zone from the config.
         :param id:
         :param name:
         :param arch:
         :param creation_date:
         :param modification_date:
         :param default_bootscript:
         :param extra_volumes:
@@ -1190,17 +1237,18 @@
     async def delete_image(
         self,
         *,
         image_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete the image with the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param image_id: UUID of the image you want to delete
+        Delete an Instance image.
+        Delete the image with the specified ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param image_id: UUID of the image you want to delete.
 
         Usage:
         ::
 
             result = await api.delete_image(image_id="example")
         """
 
@@ -1223,16 +1271,17 @@
         per_page: Optional[int] = None,
         page: Optional[int] = None,
         name: Optional[str] = None,
         project: Optional[str] = None,
         tags: Optional[str] = None,
     ) -> ListSnapshotsResponse:
         """
-        List snapshots
-        :param zone: Zone to target. If none is passed will use default zone from the config
+        List snapshots.
+        List all snapshots of an Organization in a specified Availability Zone.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
         :param organization:
         :param per_page:
         :param page:
         :param name:
         :param project:
         :param tags:
         :return: :class:`ListSnapshotsResponse <ListSnapshotsResponse>`
@@ -1269,16 +1318,17 @@
         per_page: Optional[int] = None,
         page: Optional[int] = None,
         name: Optional[str] = None,
         project: Optional[str] = None,
         tags: Optional[str] = None,
     ) -> List[Snapshot]:
         """
-        List snapshots
-        :param zone: Zone to target. If none is passed will use default zone from the config
+        List snapshots.
+        List all snapshots of an Organization in a specified Availability Zone.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
         :param organization:
         :param per_page:
         :param page:
         :param name:
         :param project:
         :param tags:
         :return: :class:`List[ListSnapshotsResponse] <List[ListSnapshotsResponse]>`
@@ -1315,31 +1365,32 @@
         organization: Optional[str] = None,
         project: Optional[str] = None,
         bucket: Optional[str] = None,
         key: Optional[str] = None,
         size: Optional[int] = None,
     ) -> CreateSnapshotResponse:
         """
-        Create a snapshot from a given volume or from a QCOW2 file
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param name: Name of the snapshot
-        :param volume_id: UUID of the volume
-        :param tags: The tags of the snapshot
+        Create a snapshot from a specified volume or from a QCOW2 file.
+        Create a snapshot from a specified volume or from a QCOW2 file in a specified Availability Zone.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param name: Name of the snapshot.
+        :param volume_id: UUID of the volume.
+        :param tags: Tags of the snapshot.
         :param organization: Organization ID of the snapshot.
 
         One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
         :param project: Project ID of the snapshot.
 
         One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
-        :param volume_type: Overrides the volume_type of the snapshot.
+        :param volume_type: Volume type of the snapshot.
+        Overrides the volume_type of the snapshot.
         If omitted, the volume type of the original volume will be used.
-
-        :param bucket: Bucket name for snapshot imports
-        :param key: Object key for snapshot imports
-        :param size: Imported snapshot size, must be a multiple of 512
+        :param bucket: Bucket name for snapshot imports.
+        :param key: Object key for snapshot imports.
+        :param size: Imported snapshot size, must be a multiple of 512.
         :return: :class:`CreateSnapshotResponse <CreateSnapshotResponse>`
 
         Usage:
         ::
 
             result = await api.create_snapshot(volume_type=unknown_volume_type)
         """
@@ -1372,17 +1423,18 @@
     async def get_snapshot(
         self,
         *,
         snapshot_id: str,
         zone: Optional[Zone] = None,
     ) -> GetSnapshotResponse:
         """
-        Get details of a snapshot with the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param snapshot_id: UUID of the snapshot you want to get
+        Get a snapshot.
+        Get details of a snapshot with the specified ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param snapshot_id: UUID of the snapshot you want to get.
         :return: :class:`GetSnapshotResponse <GetSnapshotResponse>`
 
         Usage:
         ::
 
             result = await api.get_snapshot(snapshot_id="example")
         """
@@ -1412,16 +1464,17 @@
         base_volume: Optional[SnapshotBaseVolume] = None,
         creation_date: Optional[datetime] = None,
         modification_date: Optional[datetime] = None,
         project: Optional[str] = None,
         tags: Optional[List[str]] = None,
     ) -> _SetSnapshotResponse:
         """
+        Update snapshot.
         Replace all snapshot properties with a snapshot message.
-        :param zone: Zone to target. If none is passed will use default zone from the config
+        :param zone: Zone to target. If none is passed will use default zone from the config.
         :param snapshot_id:
         :param id:
         :param name:
         :param organization:
         :param volume_type:
         :param size:
         :param state:
@@ -1477,17 +1530,18 @@
     async def delete_snapshot(
         self,
         *,
         snapshot_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete the snapshot with the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param snapshot_id: UUID of the snapshot you want to delete
+        Delete a snapshot.
+        Delete the snapshot with the specified ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param snapshot_id: UUID of the snapshot you want to delete.
 
         Usage:
         ::
 
             result = await api.delete_snapshot(snapshot_id="example")
         """
 
@@ -1507,19 +1561,20 @@
         *,
         snapshot_id: str,
         bucket: str,
         key: str,
         zone: Optional[Zone] = None,
     ) -> ExportSnapshotResponse:
         """
-        Export a snapshot to a given S3 bucket in the same region.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param snapshot_id: The snapshot ID
-        :param bucket: S3 bucket name
-        :param key: S3 object key
+        Export a snapshot.
+        Export a snapshot to a specified S3 bucket in the same region.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param snapshot_id: Snapshot ID.
+        :param bucket: S3 bucket name.
+        :param key: S3 object key.
         :return: :class:`ExportSnapshotResponse <ExportSnapshotResponse>`
 
         Usage:
         ::
 
             result = await api.export_snapshot(
                 snapshot_id="example",
@@ -1557,23 +1612,24 @@
         page: Optional[int] = None,
         organization: Optional[str] = None,
         project: Optional[str] = None,
         tags: Optional[List[str]] = None,
         name: Optional[str] = None,
     ) -> ListVolumesResponse:
         """
-        List volumes
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param volume_type: Filter by volume type
-        :param per_page: A positive integer lower or equal to 100 to select the number of items to return
-        :param page: A positive integer to choose the page to return
-        :param organization: Filter volume by organization ID
-        :param project: Filter volume by project ID
-        :param tags: Filter volumes with these exact tags (to filter with several tags, use commas to separate them)
-        :param name: Filter volume by name (for eg. "vol" will return "myvolume" but not "data")
+        List volumes.
+        List volumes in the specified Availability Zone. You can filter the output by volume type.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param volume_type: Filter by volume type.
+        :param per_page: A positive integer lower or equal to 100 to select the number of items to return.
+        :param page: A positive integer to choose the page to return.
+        :param organization: Filter volume by Organization ID.
+        :param project: Filter volume by Project ID.
+        :param tags: Filter volumes with these exact tags (to filter with several tags, use commas to separate them).
+        :param name: Filter volume by name (for eg. "vol" will return "myvolume" but not "data").
         :return: :class:`ListVolumesResponse <ListVolumesResponse>`
 
         Usage:
         ::
 
             result = await api.list_volumes()
         """
@@ -1606,23 +1662,24 @@
         page: Optional[int] = None,
         organization: Optional[str] = None,
         project: Optional[str] = None,
         tags: Optional[List[str]] = None,
         name: Optional[str] = None,
     ) -> List[Volume]:
         """
-        List volumes
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param volume_type: Filter by volume type
-        :param per_page: A positive integer lower or equal to 100 to select the number of items to return
-        :param page: A positive integer to choose the page to return
-        :param organization: Filter volume by organization ID
-        :param project: Filter volume by project ID
-        :param tags: Filter volumes with these exact tags (to filter with several tags, use commas to separate them)
-        :param name: Filter volume by name (for eg. "vol" will return "myvolume" but not "data")
+        List volumes.
+        List volumes in the specified Availability Zone. You can filter the output by volume type.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param volume_type: Filter by volume type.
+        :param per_page: A positive integer lower or equal to 100 to select the number of items to return.
+        :param page: A positive integer to choose the page to return.
+        :param organization: Filter volume by Organization ID.
+        :param project: Filter volume by Project ID.
+        :param tags: Filter volumes with these exact tags (to filter with several tags, use commas to separate them).
+        :param name: Filter volume by name (for eg. "vol" will return "myvolume" but not "data").
         :return: :class:`List[ListVolumesResponse] <List[ListVolumesResponse]>`
 
         Usage:
         ::
 
             result = await api.list_volumes_all()
         """
@@ -1653,32 +1710,33 @@
         project: Optional[str] = None,
         tags: Optional[List[str]] = None,
         size: Optional[int] = None,
         base_volume: Optional[str] = None,
         base_snapshot: Optional[str] = None,
     ) -> CreateVolumeResponse:
         """
-        Create a volume
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param name: The volume name
-        :param organization: The volume organization ID.
+        Create a volume.
+        Create a volume of a specified type in an Availability Zone.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param name: Volume name.
+        :param organization: Volume Organization ID.
 
         One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
-        :param project: The volume project ID.
+        :param project: Volume Project ID.
 
         One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
-        :param tags: The volume tags
-        :param volume_type: The volume type
-        :param size: The volume disk size, must be a multiple of 512.
+        :param tags: Volume tags.
+        :param volume_type: Volume type.
+        :param size: Volume disk size, must be a multiple of 512.
 
         One-of ('from_'): at most one of 'size', 'base_volume', 'base_snapshot' could be set.
-        :param base_volume: The ID of the volume on which this volume will be based.
+        :param base_volume: ID of the volume on which this volume will be based.
 
         One-of ('from_'): at most one of 'size', 'base_volume', 'base_snapshot' could be set.
-        :param base_snapshot: The ID of the snapshot on which this volume will be based.
+        :param base_snapshot: ID of the snapshot on which this volume will be based.
 
         One-of ('from_'): at most one of 'size', 'base_volume', 'base_snapshot' could be set.
         :return: :class:`CreateVolumeResponse <CreateVolumeResponse>`
 
         Usage:
         ::
 
@@ -1712,17 +1770,18 @@
     async def get_volume(
         self,
         *,
         volume_id: str,
         zone: Optional[Zone] = None,
     ) -> GetVolumeResponse:
         """
-        Get details of a volume with the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param volume_id: UUID of the volume you want to get
+        Get a volume.
+        Get details of a volume with the specified ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param volume_id: UUID of the volume you want to get.
         :return: :class:`GetVolumeResponse <GetVolumeResponse>`
 
         Usage:
         ::
 
             result = await api.get_volume(volume_id="example")
         """
@@ -1744,20 +1803,21 @@
         volume_id: str,
         zone: Optional[Zone] = None,
         name: Optional[str] = None,
         tags: Optional[List[str]] = None,
         size: Optional[int] = None,
     ) -> UpdateVolumeResponse:
         """
-        Replace name and/or size properties of given ID volume with the given value(s). Any volume name can be changed while, for now, only `b_ssd` volume growing is supported.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param volume_id: UUID of the volume
-        :param name: The volume name
-        :param tags: The tags of the volume
-        :param size: The volume disk size, must be a multiple of 512
+        Update a volume.
+        Replace the name and/or size properties of a volume specified by its ID, with the specified value(s). Any volume name can be changed, however only `b_ssd` volumes can currently be increased in size.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param volume_id: UUID of the volume.
+        :param name: Volume name.
+        :param tags: Tags of the volume.
+        :param size: Volume disk size, must be a multiple of 512.
         :return: :class:`UpdateVolumeResponse <UpdateVolumeResponse>`
 
         Usage:
         ::
 
             result = await api.update_volume(volume_id="example")
         """
@@ -1786,17 +1846,18 @@
     async def delete_volume(
         self,
         *,
         volume_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete the volume with the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param volume_id: UUID of the volume you want to delete
+        Delete a volume.
+        Delete the volume with the specified ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param volume_id: UUID of the volume you want to delete.
 
         Usage:
         ::
 
             result = await api.delete_volume(volume_id="example")
         """
 
@@ -1820,23 +1881,24 @@
         project: Optional[str] = None,
         tags: Optional[List[str]] = None,
         project_default: Optional[bool] = None,
         per_page: Optional[int] = None,
         page: Optional[int] = None,
     ) -> ListSecurityGroupsResponse:
         """
-        List all security groups available in an account.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param name: Name of the security group
-        :param organization: The security group organization ID
-        :param project: The security group project ID
-        :param tags: List security groups with these exact tags (to filter with several tags, use commas to separate them)
-        :param project_default: Filter security groups with this value for project_default
-        :param per_page: A positive integer lower or equal to 100 to select the number of items to return
-        :param page: A positive integer to choose the page to return
+        List security groups.
+        List all existing security groups.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param name: Name of the security group.
+        :param organization: Security group Organization ID.
+        :param project: Security group Project ID.
+        :param tags: List security groups with these exact tags (to filter with several tags, use commas to separate them).
+        :param project_default: Filter security groups with this value for project_default.
+        :param per_page: A positive integer lower or equal to 100 to select the number of items to return.
+        :param page: A positive integer to choose the page to return.
         :return: :class:`ListSecurityGroupsResponse <ListSecurityGroupsResponse>`
 
         Usage:
         ::
 
             result = await api.list_security_groups()
         """
@@ -1869,23 +1931,24 @@
         project: Optional[str] = None,
         tags: Optional[List[str]] = None,
         project_default: Optional[bool] = None,
         per_page: Optional[int] = None,
         page: Optional[int] = None,
     ) -> List[SecurityGroup]:
         """
-        List all security groups available in an account.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param name: Name of the security group
-        :param organization: The security group organization ID
-        :param project: The security group project ID
-        :param tags: List security groups with these exact tags (to filter with several tags, use commas to separate them)
-        :param project_default: Filter security groups with this value for project_default
-        :param per_page: A positive integer lower or equal to 100 to select the number of items to return
-        :param page: A positive integer to choose the page to return
+        List security groups.
+        List all existing security groups.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param name: Name of the security group.
+        :param organization: Security group Organization ID.
+        :param project: Security group Project ID.
+        :param tags: List security groups with these exact tags (to filter with several tags, use commas to separate them).
+        :param project_default: Filter security groups with this value for project_default.
+        :param per_page: A positive integer lower or equal to 100 to select the number of items to return.
+        :param page: A positive integer to choose the page to return.
         :return: :class:`List[ListSecurityGroupsResponse] <List[ListSecurityGroupsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_security_groups_all()
         """
@@ -1919,35 +1982,36 @@
         project: Optional[str] = None,
         tags: Optional[List[str]] = None,
         organization_default: Optional[bool] = None,
         project_default: Optional[bool] = None,
         enable_default_security: Optional[bool] = None,
     ) -> CreateSecurityGroupResponse:
         """
-        Create a security group
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param name: Name of the security group
-        :param description: Description of the security group
+        Create a security group.
+        Create a security group with a specified name and description.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param name: Name of the security group.
+        :param description: Description of the security group.
         :param organization: Organization ID the security group belongs to.
 
         One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
         :param project: Project ID the security group belong to.
 
         One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
-        :param tags: The tags of the security group
-        :param organization_default: Whether this security group becomes the default security group for new instances.
+        :param tags: Tags of the security group.
+        :param organization_default: Defines whether this security group becomes the default security group for new Instances.
 
         One-of ('default_identifier'): at most one of 'organization_default', 'project_default' could be set.
-        :param project_default: Whether this security group becomes the default security group for new instances.
+        :param project_default: Whether this security group becomes the default security group for new Instances.
 
         One-of ('default_identifier'): at most one of 'organization_default', 'project_default' could be set.
-        :param stateful: Whether the security group is stateful or not
-        :param inbound_default_policy: Default policy for inbound rules
-        :param outbound_default_policy: Default policy for outbound rules
-        :param enable_default_security: True to block SMTP on IPv4 and IPv6
+        :param stateful: Whether the security group is stateful or not.
+        :param inbound_default_policy: Default policy for inbound rules.
+        :param outbound_default_policy: Default policy for outbound rules.
+        :param enable_default_security: True to block SMTP on IPv4 and IPv6. This feature is read only, please open a support ticket if you need to make it configurable.
         :return: :class:`CreateSecurityGroupResponse <CreateSecurityGroupResponse>`
 
         Usage:
         ::
 
             result = await api.create_security_group(
                 description="example",
@@ -1987,17 +2051,18 @@
     async def get_security_group(
         self,
         *,
         security_group_id: str,
         zone: Optional[Zone] = None,
     ) -> GetSecurityGroupResponse:
         """
-        Get the details of a Security Group with the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param security_group_id: UUID of the security group you want to get
+        Get a security group.
+        Get the details of a security group with the specified ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param security_group_id: UUID of the security group you want to get.
         :return: :class:`GetSecurityGroupResponse <GetSecurityGroupResponse>`
 
         Usage:
         ::
 
             result = await api.get_security_group(security_group_id="example")
         """
@@ -2018,17 +2083,18 @@
     async def delete_security_group(
         self,
         *,
         security_group_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete a security group
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param security_group_id: UUID of the security group you want to delete
+        Delete a security group.
+        Delete a security group with the specified ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param security_group_id: UUID of the security group you want to delete.
 
         Usage:
         ::
 
             result = await api.delete_security_group(security_group_id="example")
         """
 
@@ -2062,31 +2128,32 @@
         modification_date: Optional[datetime] = None,
         organization: Optional[str] = None,
         project: Optional[str] = None,
         organization_default: Optional[bool] = None,
         servers: Optional[List[ServerSummary]] = None,
     ) -> _SetSecurityGroupResponse:
         """
+        Update a security group.
         Replace all security group properties with a security group message.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param id: The ID of the security group (will be ignored)
-        :param name: The name of the security group
-        :param tags: The tags of the security group
-        :param creation_date: The creation date of the security group (will be ignored)
-        :param modification_date: The modification date of the security group (will be ignored)
-        :param description: The description of the security group
-        :param enable_default_security: True to block SMTP on IPv4 and IPv6
-        :param inbound_default_policy: The default inbound policy
-        :param outbound_default_policy: The default outbound policy
-        :param organization: The security groups organization ID
-        :param project: The security group project ID
-        :param organization_default: Please use project_default instead
-        :param project_default: True use this security group for future instances created in this project
-        :param servers: The servers attached to this security group
-        :param stateful: True to set the security group as stateful
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param id: ID of the security group (will be ignored).
+        :param name: Name of the security group.
+        :param tags: Tags of the security group.
+        :param creation_date: Creation date of the security group (will be ignored).
+        :param modification_date: Modification date of the security group (will be ignored).
+        :param description: Description of the security group.
+        :param enable_default_security: True to block SMTP on IPv4 and IPv6. This feature is read only, please open a support ticket if you need to make it configurable.
+        :param inbound_default_policy: Default inbound policy.
+        :param outbound_default_policy: Default outbound policy.
+        :param organization: Security groups Organization ID.
+        :param project: Security group Project ID.
+        :param organization_default: Please use project_default instead.
+        :param project_default: True use this security group for future Instances created in this project.
+        :param servers: Instances attached to this security group.
+        :param stateful: True to set the security group as stateful.
         :return: :class:`_SetSecurityGroupResponse <_SetSecurityGroupResponse>`
 
         Usage:
         ::
 
             result = await api._set_security_group(
                 id="example",
@@ -2134,16 +2201,17 @@
 
     async def list_default_security_group_rules(
         self,
         *,
         zone: Optional[Zone] = None,
     ) -> ListSecurityGroupRulesResponse:
         """
+        Get default rules.
         Lists the default rules applied to all the security groups.
-        :param zone: Zone to target. If none is passed will use default zone from the config
+        :param zone: Zone to target. If none is passed will use default zone from the config.
         :return: :class:`ListSecurityGroupRulesResponse <ListSecurityGroupRulesResponse>`
 
         Usage:
         ::
 
             result = await api.list_default_security_group_rules()
         """
@@ -2163,19 +2231,20 @@
         *,
         security_group_id: str,
         zone: Optional[Zone] = None,
         per_page: Optional[int] = None,
         page: Optional[int] = None,
     ) -> ListSecurityGroupRulesResponse:
         """
-        List rules
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param security_group_id: UUID of the security group
-        :param per_page: A positive integer lower or equal to 100 to select the number of items to return
-        :param page: A positive integer to choose the page to return
+        List rules.
+        List the rules of the a specified security group ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param security_group_id: UUID of the security group.
+        :param per_page: A positive integer lower or equal to 100 to select the number of items to return.
+        :param page: A positive integer to choose the page to return.
         :return: :class:`ListSecurityGroupRulesResponse <ListSecurityGroupRulesResponse>`
 
         Usage:
         ::
 
             result = await api.list_security_group_rules(security_group_id="example")
         """
@@ -2202,19 +2271,20 @@
         *,
         security_group_id: str,
         zone: Optional[Zone] = None,
         per_page: Optional[int] = None,
         page: Optional[int] = None,
     ) -> List[SecurityGroupRule]:
         """
-        List rules
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param security_group_id: UUID of the security group
-        :param per_page: A positive integer lower or equal to 100 to select the number of items to return
-        :param page: A positive integer to choose the page to return
+        List rules.
+        List the rules of the a specified security group ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param security_group_id: UUID of the security group.
+        :param per_page: A positive integer lower or equal to 100 to select the number of items to return.
+        :param page: A positive integer to choose the page to return.
         :return: :class:`List[ListSecurityGroupRulesResponse] <List[ListSecurityGroupRulesResponse]>`
 
         Usage:
         ::
 
             result = await api.list_security_group_rules_all(security_group_id="example")
         """
@@ -2242,25 +2312,26 @@
         protocol: SecurityGroupRuleProtocol = SecurityGroupRuleProtocol.TCP,
         direction: SecurityGroupRuleDirection = SecurityGroupRuleDirection.INBOUND,
         action: SecurityGroupRuleAction = SecurityGroupRuleAction.ACCEPT,
         dest_port_from: Optional[int] = None,
         dest_port_to: Optional[int] = None,
     ) -> CreateSecurityGroupRuleResponse:
         """
-        Create rule
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param security_group_id: UUID of the security group
+        Create rule.
+        Create a rule in the specified security group ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param security_group_id: UUID of the security group.
         :param protocol:
         :param direction:
         :param action:
         :param ip_range:
-        :param dest_port_from: The beginning of the range of ports to apply this rule to (inclusive)
-        :param dest_port_to: The end of the range of ports to apply this rule to (inclusive)
-        :param position: The position of this rule in the security group rules list
-        :param editable: Indicates if this rule is editable (will be ignored)
+        :param dest_port_from: Beginning of the range of ports to apply this rule to (inclusive).
+        :param dest_port_to: End of the range of ports to apply this rule to (inclusive).
+        :param position: Position of this rule in the security group rules list.
+        :param editable: Indicates if this rule is editable (will be ignored).
         :return: :class:`CreateSecurityGroupRuleResponse <CreateSecurityGroupRuleResponse>`
 
         Usage:
         ::
 
             result = await api.create_security_group_rule(
                 security_group_id="example",
@@ -2302,18 +2373,19 @@
         self,
         *,
         security_group_id: str,
         zone: Optional[Zone] = None,
         rules: Optional[List[SetSecurityGroupRulesRequestRule]] = None,
     ) -> SetSecurityGroupRulesResponse:
         """
-        Replaces the rules of the security group with the rules provided. This endpoint supports the update of existing rules, creation of new rules and deletion of existing rules when they are not passed in the request.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param security_group_id: UUID of the security group to update the rules on
-        :param rules: List of rules to update in the security group
+        Update all the rules of a security group.
+        Replaces the existing rules of the security group with the rules provided. This endpoint supports the update of existing rules, creation of new rules and deletion of existing rules when they are not passed in the request.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param security_group_id: UUID of the security group to update the rules on.
+        :param rules: List of rules to update in the security group.
         :return: :class:`SetSecurityGroupRulesResponse <SetSecurityGroupRulesResponse>`
 
         Usage:
         ::
 
             result = await api.set_security_group_rules(security_group_id="example")
         """
@@ -2343,16 +2415,17 @@
         self,
         *,
         security_group_id: str,
         security_group_rule_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete a security group rule with the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
+        Delete rule.
+        Delete a security group rule with the specified ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
         :param security_group_id:
         :param security_group_rule_id:
 
         Usage:
         ::
 
             result = await api.delete_security_group_rule(
@@ -2381,16 +2454,17 @@
         self,
         *,
         security_group_id: str,
         security_group_rule_id: str,
         zone: Optional[Zone] = None,
     ) -> GetSecurityGroupRuleResponse:
         """
-        Get details of a security group rule with the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
+        Get rule.
+        Get details of a security group rule with the specified ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
         :param security_group_id:
         :param security_group_rule_id:
         :return: :class:`GetSecurityGroupRuleResponse <GetSecurityGroupRuleResponse>`
 
         Usage:
         ::
 
@@ -2429,16 +2503,17 @@
         position: int,
         editable: bool,
         zone: Optional[Zone] = None,
         dest_port_from: Optional[int] = None,
         dest_port_to: Optional[int] = None,
     ) -> _SetSecurityGroupRuleResponse:
         """
-        Update security group rule
-        :param zone: Zone to target. If none is passed will use default zone from the config
+        Update security group rule.
+        Update the rule of a specified security group ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
         :param security_group_id:
         :param security_group_rule_id:
         :param id:
         :param protocol:
         :param direction:
         :param action:
         :param ip_range:
@@ -2505,22 +2580,23 @@
         page: Optional[int] = None,
         organization: Optional[str] = None,
         project: Optional[str] = None,
         tags: Optional[List[str]] = None,
         name: Optional[str] = None,
     ) -> ListPlacementGroupsResponse:
         """
-        List all placement groups.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param per_page: A positive integer lower or equal to 100 to select the number of items to return
-        :param page: A positive integer to choose the page to return
-        :param organization: List only placement groups of this organization ID
-        :param project: List only placement groups of this project ID
-        :param tags: List placement groups with these exact tags (to filter with several tags, use commas to separate them)
-        :param name: Filter placement groups by name (for eg. "cluster1" will return "cluster100" and "cluster1" but not "foo")
+        List placement groups.
+        List all placement groups in a specified Availability Zone.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param per_page: A positive integer lower or equal to 100 to select the number of items to return.
+        :param page: A positive integer to choose the page to return.
+        :param organization: List only placement groups of this Organization ID.
+        :param project: List only placement groups of this Project ID.
+        :param tags: List placement groups with these exact tags (to filter with several tags, use commas to separate them).
+        :param name: Filter placement groups by name (for eg. "cluster1" will return "cluster100" and "cluster1" but not "foo").
         :return: :class:`ListPlacementGroupsResponse <ListPlacementGroupsResponse>`
 
         Usage:
         ::
 
             result = await api.list_placement_groups()
         """
@@ -2551,22 +2627,23 @@
         page: Optional[int] = None,
         organization: Optional[str] = None,
         project: Optional[str] = None,
         tags: Optional[List[str]] = None,
         name: Optional[str] = None,
     ) -> List[PlacementGroup]:
         """
-        List all placement groups.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param per_page: A positive integer lower or equal to 100 to select the number of items to return
-        :param page: A positive integer to choose the page to return
-        :param organization: List only placement groups of this organization ID
-        :param project: List only placement groups of this project ID
-        :param tags: List placement groups with these exact tags (to filter with several tags, use commas to separate them)
-        :param name: Filter placement groups by name (for eg. "cluster1" will return "cluster100" and "cluster1" but not "foo")
+        List placement groups.
+        List all placement groups in a specified Availability Zone.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param per_page: A positive integer lower or equal to 100 to select the number of items to return.
+        :param page: A positive integer to choose the page to return.
+        :param organization: List only placement groups of this Organization ID.
+        :param project: List only placement groups of this Project ID.
+        :param tags: List placement groups with these exact tags (to filter with several tags, use commas to separate them).
+        :param name: Filter placement groups by name (for eg. "cluster1" will return "cluster100" and "cluster1" but not "foo").
         :return: :class:`List[ListPlacementGroupsResponse] <List[ListPlacementGroupsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_placement_groups_all()
         """
@@ -2594,26 +2671,27 @@
         zone: Optional[Zone] = None,
         name: Optional[str] = None,
         organization: Optional[str] = None,
         project: Optional[str] = None,
         tags: Optional[List[str]] = None,
     ) -> CreatePlacementGroupResponse:
         """
-        Create a new placement group.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param name: Name of the placement group
+        Create a placement group.
+        Create a new placement group in a specified Availability Zone.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param name: Name of the placement group.
         :param organization: Organization ID of the placement group.
 
         One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
         :param project: Project ID of the placement group.
 
         One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
-        :param tags: The tags of the placement group
-        :param policy_mode: The operating mode of the placement group
-        :param policy_type: The policy type of the placement group
+        :param tags: Tags of the placement group.
+        :param policy_mode: Operating mode of the placement group.
+        :param policy_type: Policy type of the placement group.
         :return: :class:`CreatePlacementGroupResponse <CreatePlacementGroupResponse>`
 
         Usage:
         ::
 
             result = await api.create_placement_group(
                 policy_mode=optional,
@@ -2646,17 +2724,18 @@
     async def get_placement_group(
         self,
         *,
         placement_group_id: str,
         zone: Optional[Zone] = None,
     ) -> GetPlacementGroupResponse:
         """
-        Get the given placement group.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param placement_group_id: UUID of the placement group you want to get
+        Get a placement group.
+        Get the specified placement group.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param placement_group_id: UUID of the placement group you want to get.
         :return: :class:`GetPlacementGroupResponse <GetPlacementGroupResponse>`
 
         Usage:
         ::
 
             result = await api.get_placement_group(placement_group_id="example")
         """
@@ -2683,16 +2762,17 @@
         policy_type: PlacementGroupPolicyType,
         zone: Optional[Zone] = None,
         organization: Optional[str] = None,
         project: Optional[str] = None,
         tags: Optional[List[str]] = None,
     ) -> SetPlacementGroupResponse:
         """
-        Set all parameters of the given placement group.
-        :param zone: Zone to target. If none is passed will use default zone from the config
+        Set placement group.
+        Set all parameters of the specified placement group.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
         :param placement_group_id:
         :param name:
         :param organization:
         :param policy_mode:
         :param policy_type:
         :param project:
         :param tags:
@@ -2742,21 +2822,22 @@
         zone: Optional[Zone] = None,
         name: Optional[str] = None,
         tags: Optional[List[str]] = None,
         policy_mode: Optional[PlacementGroupPolicyMode] = None,
         policy_type: Optional[PlacementGroupPolicyType] = None,
     ) -> UpdatePlacementGroupResponse:
         """
-        Update one or more parameter of the given placement group.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param placement_group_id: UUID of the placement group
-        :param name: Name of the placement group
-        :param tags: The tags of the placement group
-        :param policy_mode: The operating mode of the placement group
-        :param policy_type: The policy type of the placement group
+        Update a placement group.
+        Update one or more parameter of the specified placement group.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param placement_group_id: UUID of the placement group.
+        :param name: Name of the placement group.
+        :param tags: Tags of the placement group.
+        :param policy_mode: Operating mode of the placement group.
+        :param policy_type: Policy type of the placement group.
         :return: :class:`UpdatePlacementGroupResponse <UpdatePlacementGroupResponse>`
 
         Usage:
         ::
 
             result = await api.update_placement_group(placement_group_id="example")
         """
@@ -2788,17 +2869,17 @@
     async def delete_placement_group(
         self,
         *,
         placement_group_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete the given placement group.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param placement_group_id: UUID of the placement group you want to delete
+        Delete the specified placement group.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param placement_group_id: UUID of the placement group you want to delete.
 
         Usage:
         ::
 
             result = await api.delete_placement_group(placement_group_id="example")
         """
 
@@ -2818,17 +2899,18 @@
     async def get_placement_group_servers(
         self,
         *,
         placement_group_id: str,
         zone: Optional[Zone] = None,
     ) -> GetPlacementGroupServersResponse:
         """
-        Get all servers belonging to the given placement group.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param placement_group_id:
+        Get placement group servers.
+        Get all Instances belonging to the specified placement group.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param placement_group_id: UUID of the placement group you want to get.
         :return: :class:`GetPlacementGroupServersResponse <GetPlacementGroupServersResponse>`
 
         Usage:
         ::
 
             result = await api.get_placement_group_servers(placement_group_id="example")
         """
@@ -2846,43 +2928,47 @@
         self._throw_on_error(res)
         return unmarshal_GetPlacementGroupServersResponse(res.json())
 
     async def set_placement_group_servers(
         self,
         *,
         placement_group_id: str,
+        servers: List[str],
         zone: Optional[Zone] = None,
-        servers: Optional[List[str]] = None,
     ) -> SetPlacementGroupServersResponse:
         """
-        Set all servers belonging to the given placement group.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param placement_group_id:
-        :param servers:
+        Set placement group servers.
+        Set all Instances belonging to the specified placement group.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param placement_group_id: UUID of the placement group you want to set.
+        :param servers: An array of the Instances' UUIDs you want to configure.
         :return: :class:`SetPlacementGroupServersResponse <SetPlacementGroupServersResponse>`
 
         Usage:
         ::
 
-            result = await api.set_placement_group_servers(placement_group_id="example")
+            result = await api.set_placement_group_servers(
+                placement_group_id="example",
+                servers=["example"],
+            )
         """
 
         param_zone = validate_path_param("zone", zone or self.client.default_zone)
         param_placement_group_id = validate_path_param(
             "placement_group_id", placement_group_id
         )
 
         res = self._request(
             "PUT",
             f"/instance/v1/zones/{param_zone}/placement_groups/{param_placement_group_id}/servers",
             body=marshal_SetPlacementGroupServersRequest(
                 SetPlacementGroupServersRequest(
                     placement_group_id=placement_group_id,
-                    zone=zone,
                     servers=servers,
+                    zone=zone,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_SetPlacementGroupServersResponse(res.json())
@@ -2891,18 +2977,19 @@
         self,
         *,
         placement_group_id: str,
         servers: List[str],
         zone: Optional[Zone] = None,
     ) -> UpdatePlacementGroupServersResponse:
         """
-        Update all servers belonging to the given placement group.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param placement_group_id: UUID of the placement group
-        :param servers:
+        Update placement group servers.
+        Update all Instances belonging to the specified placement group.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param placement_group_id: UUID of the placement group you want to update.
+        :param servers: An array of the Instances' UUIDs you want to configure.
         :return: :class:`UpdatePlacementGroupServersResponse <UpdatePlacementGroupServersResponse>`
 
         Usage:
         ::
 
             result = await api.update_placement_group_servers(
                 placement_group_id="example",
@@ -2939,22 +3026,23 @@
         organization: Optional[str] = None,
         tags: Optional[List[str]] = None,
         name: Optional[str] = None,
         per_page: Optional[int] = None,
         page: Optional[int] = None,
     ) -> ListIpsResponse:
         """
-        List all flexible IPs
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param project: The project ID the IPs are reserved in
-        :param organization: The organization ID the IPs are reserved in
-        :param tags: Filter IPs with these exact tags (to filter with several tags, use commas to separate them)
-        :param name: Filter on the IP address (Works as a LIKE operation on the IP address)
-        :param per_page: A positive integer lower or equal to 100 to select the number of items to return
-        :param page: A positive integer to choose the page to return
+        List all flexible IPs.
+        List all flexible IPs in a specified zone.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param project: Project ID in which the IPs are reserved.
+        :param organization: Organization ID in which the IPs are reserved.
+        :param tags: Filter IPs with these exact tags (to filter with several tags, use commas to separate them).
+        :param name: Filter on the IP address (Works as a LIKE operation on the IP address).
+        :param per_page: A positive integer lower or equal to 100 to select the number of items to return.
+        :param page: A positive integer to choose the page to return.
         :return: :class:`ListIpsResponse <ListIpsResponse>`
 
         Usage:
         ::
 
             result = await api.list_ips()
         """
@@ -2985,22 +3073,23 @@
         organization: Optional[str] = None,
         tags: Optional[List[str]] = None,
         name: Optional[str] = None,
         per_page: Optional[int] = None,
         page: Optional[int] = None,
     ) -> List[Ip]:
         """
-        List all flexible IPs
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param project: The project ID the IPs are reserved in
-        :param organization: The organization ID the IPs are reserved in
-        :param tags: Filter IPs with these exact tags (to filter with several tags, use commas to separate them)
-        :param name: Filter on the IP address (Works as a LIKE operation on the IP address)
-        :param per_page: A positive integer lower or equal to 100 to select the number of items to return
-        :param page: A positive integer to choose the page to return
+        List all flexible IPs.
+        List all flexible IPs in a specified zone.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param project: Project ID in which the IPs are reserved.
+        :param organization: Organization ID in which the IPs are reserved.
+        :param tags: Filter IPs with these exact tags (to filter with several tags, use commas to separate them).
+        :param name: Filter on the IP address (Works as a LIKE operation on the IP address).
+        :param per_page: A positive integer lower or equal to 100 to select the number of items to return.
+        :param page: A positive integer to choose the page to return.
         :return: :class:`List[ListIpsResponse] <List[ListIpsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_ips_all()
         """
@@ -3019,46 +3108,50 @@
                 "page": page,
             },
         )
 
     async def create_ip(
         self,
         *,
+        type_: IpType,
         zone: Optional[Zone] = None,
         organization: Optional[str] = None,
         project: Optional[str] = None,
         tags: Optional[List[str]] = None,
         server: Optional[str] = None,
     ) -> CreateIpResponse:
         """
-        Reserve a flexible IP
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param organization: The organization ID the IP is reserved in.
+        Reserve a flexible IP.
+        Reserve a flexible IP and attach it to the specified Instance.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param organization: Organization ID in which the IP is reserved.
 
         One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
-        :param project: The project ID the IP is reserved in.
+        :param project: Project ID in which the IP is reserved.
 
         One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
-        :param tags: The tags of the IP
-        :param server: UUID of the server you want to attach the IP to
+        :param tags: Tags of the IP.
+        :param server: UUID of the Instance you want to attach the IP to.
+        :param type_: IP type to reserve (either 'nat', 'routed_ipv4' or 'routed_ipv6').
         :return: :class:`CreateIpResponse <CreateIpResponse>`
 
         Usage:
         ::
 
-            result = await api.create_ip()
+            result = await api.create_ip(type_=unknown_iptype)
         """
 
         param_zone = validate_path_param("zone", zone or self.client.default_zone)
 
         res = self._request(
             "POST",
             f"/instance/v1/zones/{param_zone}/ips",
             body=marshal_CreateIpRequest(
                 CreateIpRequest(
+                    type_=type_,
                     zone=zone,
                     organization=organization,
                     project=project,
                     tags=tags,
                     server=server,
                 ),
                 self.client,
@@ -3071,17 +3164,18 @@
     async def get_ip(
         self,
         *,
         ip: str,
         zone: Optional[Zone] = None,
     ) -> GetIpResponse:
         """
-        Get details of an IP with the given ID or address.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param ip: The IP ID or address to get
+        Get a flexible IP.
+        Get details of an IP with the specified ID or address.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param ip: IP ID or address to get.
         :return: :class:`GetIpResponse <GetIpResponse>`
 
         Usage:
         ::
 
             result = await api.get_ip(ip="example")
         """
@@ -3097,43 +3191,50 @@
         self._throw_on_error(res)
         return unmarshal_GetIpResponse(res.json())
 
     async def update_ip(
         self,
         *,
         ip: str,
+        type_: IpType,
         zone: Optional[Zone] = None,
         reverse: Optional[str] = None,
         tags: Optional[List[str]] = None,
         server: Optional[str] = None,
     ) -> UpdateIpResponse:
         """
-        Update a flexible IP
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param ip: IP ID or IP address
-        :param reverse: Reverse domain name
-        :param tags: An array of keywords you want to tag this IP with
+        Update a flexible IP.
+        Update a flexible IP in the specified zone with the specified ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param ip: IP ID or IP address.
+        :param reverse: Reverse domain name.
+        :param type_: Convert a 'nat' IP to a 'routed_ipv4'.
+        :param tags: An array of keywords you want to tag this IP with.
         :param server:
         :return: :class:`UpdateIpResponse <UpdateIpResponse>`
 
         Usage:
         ::
 
-            result = await api.update_ip(ip="example")
+            result = await api.update_ip(
+                ip="example",
+                type_=unknown_iptype,
+            )
         """
 
         param_zone = validate_path_param("zone", zone or self.client.default_zone)
         param_ip = validate_path_param("ip", ip)
 
         res = self._request(
             "PATCH",
             f"/instance/v1/zones/{param_zone}/ips/{param_ip}",
             body=marshal_UpdateIpRequest(
                 UpdateIpRequest(
                     ip=ip,
+                    type_=type_,
                     zone=zone,
                     reverse=reverse,
                     tags=tags,
                     server=server,
                 ),
                 self.client,
             ),
@@ -3145,17 +3246,18 @@
     async def delete_ip(
         self,
         *,
         ip: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete the IP with the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param ip: The ID or the address of the IP to delete
+        Delete a flexible IP.
+        Delete the IP with the specified ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param ip: ID or address of the IP to delete.
 
         Usage:
         ::
 
             result = await api.delete_ip(ip="example")
         """
 
@@ -3176,20 +3278,21 @@
         server_id: str,
         zone: Optional[Zone] = None,
         tags: Optional[List[str]] = None,
         per_page: Optional[int] = None,
         page: Optional[int] = None,
     ) -> ListPrivateNICsResponse:
         """
-        List all private NICs of a given server.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: The server the private NIC is attached to
-        :param tags: The private NIC tags
-        :param per_page: A positive integer lower or equal to 100 to select the number of items to return
-        :param page: A positive integer to choose the page to return
+        List all private NICs.
+        List all private NICs of a specified Instance.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: Instance to which the private NIC is attached.
+        :param tags: Private NIC tags.
+        :param per_page: A positive integer lower or equal to 100 to select the number of items to return.
+        :param page: A positive integer to choose the page to return.
         :return: :class:`ListPrivateNICsResponse <ListPrivateNICsResponse>`
 
         Usage:
         ::
 
             result = await api.list_private_ni_cs(server_id="example")
         """
@@ -3216,20 +3319,21 @@
         server_id: str,
         zone: Optional[Zone] = None,
         tags: Optional[List[str]] = None,
         per_page: Optional[int] = None,
         page: Optional[int] = None,
     ) -> List[PrivateNIC]:
         """
-        List all private NICs of a given server.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: The server the private NIC is attached to
-        :param tags: The private NIC tags
-        :param per_page: A positive integer lower or equal to 100 to select the number of items to return
-        :param page: A positive integer to choose the page to return
+        List all private NICs.
+        List all private NICs of a specified Instance.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: Instance to which the private NIC is attached.
+        :param tags: Private NIC tags.
+        :param per_page: A positive integer lower or equal to 100 to select the number of items to return.
+        :param page: A positive integer to choose the page to return.
         :return: :class:`List[ListPrivateNICsResponse] <List[ListPrivateNICsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_private_ni_cs_all(server_id="example")
         """
@@ -3250,21 +3354,23 @@
     async def create_private_nic(
         self,
         *,
         server_id: str,
         private_network_id: str,
         zone: Optional[Zone] = None,
         tags: Optional[List[str]] = None,
+        ip_ids: Optional[List[str]] = None,
     ) -> CreatePrivateNICResponse:
         """
-        Create a private NIC connecting a server to a private network.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: UUID of the server the private NIC will be attached to
-        :param private_network_id: UUID of the private network where the private NIC will be attached
-        :param tags: The private NIC tags
+        Create a private NIC connecting an Instance to a Private Network.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: UUID of the Instance the private NIC will be attached to.
+        :param private_network_id: UUID of the private network where the private NIC will be attached.
+        :param tags: Private NIC tags.
+        :param ip_ids: Ip_ids defined from IPAM.
         :return: :class:`CreatePrivateNICResponse <CreatePrivateNICResponse>`
 
         Usage:
         ::
 
             result = await api.create_private_nic(
                 server_id="example",
@@ -3280,14 +3386,15 @@
             f"/instance/v1/zones/{param_zone}/servers/{param_server_id}/private_nics",
             body=marshal_CreatePrivateNICRequest(
                 CreatePrivateNICRequest(
                     server_id=server_id,
                     private_network_id=private_network_id,
                     zone=zone,
                     tags=tags,
+                    ip_ids=ip_ids,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_CreatePrivateNICResponse(res.json())
@@ -3296,18 +3403,19 @@
         self,
         *,
         server_id: str,
         private_nic_id: str,
         zone: Optional[Zone] = None,
     ) -> GetPrivateNICResponse:
         """
+        Get a private NIC.
         Get private NIC properties.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: The server the private NIC is attached to
-        :param private_nic_id: The private NIC unique ID
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: Instance to which the private NIC is attached.
+        :param private_nic_id: Private NIC unique ID.
         :return: :class:`GetPrivateNICResponse <GetPrivateNICResponse>`
 
         Usage:
         ::
 
             result = await api.get_private_nic(
                 server_id="example",
@@ -3332,19 +3440,20 @@
         *,
         server_id: str,
         private_nic_id: str,
         zone: Optional[Zone] = None,
         tags: Optional[List[str]] = None,
     ) -> PrivateNIC:
         """
-        Update one or more parameter/s to a given private NIC.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: UUID of the server the private NIC will be attached to
-        :param private_nic_id: The private NIC unique ID
-        :param tags: Tags used to select private NIC/s
+        Update a private NIC.
+        Update one or more parameter(s) of a specified private NIC.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: UUID of the Instance the private NIC will be attached to.
+        :param private_nic_id: Private NIC unique ID.
+        :param tags: Tags used to select private NIC/s.
         :return: :class:`PrivateNIC <PrivateNIC>`
 
         Usage:
         ::
 
             result = await api.update_private_nic(
                 server_id="example",
@@ -3378,17 +3487,17 @@
         *,
         server_id: str,
         private_nic_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
         Delete a private NIC.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param server_id: The server the private NIC is attached to
-        :param private_nic_id: The private NIC unique ID
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param server_id: Instance to which the private NIC is attached.
+        :param private_nic_id: Private NIC unique ID.
 
         Usage:
         ::
 
             result = await api.delete_private_nic(
                 server_id="example",
                 private_nic_id="example",
@@ -3415,16 +3524,16 @@
         title: Optional[str] = None,
         default: Optional[bool] = None,
         public: Optional[bool] = None,
         per_page: Optional[int] = None,
         page: Optional[int] = None,
     ) -> ListBootscriptsResponse:
         """
-        List bootscripts
-        :param zone: Zone to target. If none is passed will use default zone from the config
+        List bootscripts.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
         :param arch:
         :param title:
         :param default:
         :param public:
         :param per_page:
         :param page:
         :return: :class:`ListBootscriptsResponse <ListBootscriptsResponse>`
@@ -3462,16 +3571,16 @@
         title: Optional[str] = None,
         default: Optional[bool] = None,
         public: Optional[bool] = None,
         per_page: Optional[int] = None,
         page: Optional[int] = None,
     ) -> List[Bootscript]:
         """
-        List bootscripts
-        :param zone: Zone to target. If none is passed will use default zone from the config
+        List bootscripts.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
         :param arch:
         :param title:
         :param default:
         :param public:
         :param per_page:
         :param page:
         :return: :class:`List[ListBootscriptsResponse] <List[ListBootscriptsResponse]>`
@@ -3501,16 +3610,17 @@
     async def get_bootscript(
         self,
         *,
         bootscript_id: str,
         zone: Optional[Zone] = None,
     ) -> GetBootscriptResponse:
         """
-        Get details of a bootscript with the given ID.
-        :param zone: Zone to target. If none is passed will use default zone from the config
+        Get bootscripts.
+        Get details of a bootscript with the specified ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
         :param bootscript_id:
         :return: :class:`GetBootscriptResponse <GetBootscriptResponse>`
         :deprecated
 
         Usage:
         ::
```

### Comparing `scaleway_async-0.9.0/scaleway_async/instance/v1/content.py` & `scaleway_async-1.0.0/scaleway_async/instance/v1/content.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 from typing import List
 
 from .types import (
     ImageState,
+    IpState,
     PrivateNICState,
     SecurityGroupState,
     ServerState,
     SnapshotState,
     TaskStatus,
     VolumeServerState,
     VolumeState,
@@ -17,14 +18,21 @@
 IMAGE_TRANSIENT_STATUSES: List[ImageState] = [
     ImageState.CREATING,
 ]
 """
 Lists transient statutes of the enum :class:`ImageState <ImageState>`.
 """
 
+IP_TRANSIENT_STATUSES: List[IpState] = [
+    IpState.PENDING,
+]
+"""
+Lists transient statutes of the enum :class:`IpState <IpState>`.
+"""
+
 PRIVATE_NIC_TRANSIENT_STATUSES: List[PrivateNICState] = [
     PrivateNICState.SYNCING,
 ]
 """
 Lists transient statutes of the enum :class:`PrivateNICState <PrivateNICState>`.
 """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/instance/v1/marshalling.py` & `scaleway_async-1.0.0/scaleway_async/lb/v1/marshalling.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,2788 +6,2946 @@
 from scaleway_core.profile import ProfileDefaults
 from scaleway_core.utils import (
     OneOfPossibility,
     resolve_one_of,
 )
 from dateutil import parser
 from .types import (
-    Arch,
-    BootType,
-    ImageState,
-    PlacementGroupPolicyMode,
-    PlacementGroupPolicyType,
-    PrivateNICState,
-    SecurityGroupPolicy,
-    SecurityGroupRuleAction,
-    SecurityGroupRuleDirection,
-    SecurityGroupRuleProtocol,
-    ServerAction,
-    ServerState,
-    SnapshotState,
-    SnapshotVolumeType,
-    VolumeState,
-    VolumeVolumeType,
-    Bootscript,
-    CreateImageResponse,
-    CreateIpResponse,
-    CreatePlacementGroupResponse,
-    CreatePrivateNICResponse,
-    CreateSecurityGroupResponse,
-    CreateSecurityGroupRuleResponse,
-    CreateServerResponse,
-    CreateSnapshotResponse,
-    CreateVolumeResponse,
-    Dashboard,
-    ExportSnapshotResponse,
-    GetBootscriptResponse,
-    GetDashboardResponse,
-    GetImageResponse,
-    GetIpResponse,
-    GetPlacementGroupResponse,
-    GetPlacementGroupServersResponse,
-    GetPrivateNICResponse,
-    GetSecurityGroupResponse,
-    GetSecurityGroupRuleResponse,
-    GetServerResponse,
-    GetServerTypesAvailabilityResponse,
-    GetServerTypesAvailabilityResponseAvailability,
-    GetSnapshotResponse,
-    GetVolumeResponse,
-    Image,
+    AclActionRedirectRedirectType,
+    AclActionType,
+    AclHttpFilter,
+    ForwardPortAlgorithm,
+    OnMarkedDownAction,
+    Protocol,
+    ProxyProtocol,
+    SSLCompatibilityLevel,
+    StickySessionsType,
+    Acl,
+    AclAction,
+    AclActionRedirect,
+    AclMatch,
+    AclSpec,
+    Backend,
+    BackendServerStats,
+    Certificate,
+    CreateCertificateRequestCustomCertificate,
+    CreateCertificateRequestLetsencryptConfig,
+    Frontend,
+    HealthCheck,
+    HealthCheckHttpConfig,
+    HealthCheckHttpsConfig,
+    HealthCheckLdapConfig,
+    HealthCheckMysqlConfig,
+    HealthCheckPgsqlConfig,
+    HealthCheckRedisConfig,
+    HealthCheckTcpConfig,
+    Instance,
     Ip,
-    ListBootscriptsResponse,
-    ListImagesResponse,
+    Lb,
+    LbStats,
+    LbType,
+    ListAclResponse,
+    ListBackendStatsResponse,
+    ListBackendsResponse,
+    ListCertificatesResponse,
+    ListFrontendsResponse,
     ListIpsResponse,
-    ListPlacementGroupsResponse,
-    ListPrivateNICsResponse,
-    ListSecurityGroupRulesResponse,
-    ListSecurityGroupsResponse,
-    ListServerActionsResponse,
-    ListServerUserDataResponse,
-    ListServersResponse,
-    ListServersTypesResponse,
-    ListSnapshotsResponse,
-    ListVolumesResponse,
-    ListVolumesTypesResponse,
-    PlacementGroup,
-    PlacementGroupServer,
-    PrivateNIC,
-    SecurityGroup,
-    SecurityGroupRule,
-    SecurityGroupSummary,
-    SecurityGroupTemplate,
-    Server,
-    ServerActionRequestVolumeBackupTemplate,
-    ServerActionResponse,
-    ServerIp,
-    ServerIpv6,
-    ServerLocation,
-    ServerMaintenance,
-    ServerSummary,
-    ServerType,
-    ServerTypeCapabilities,
-    ServerTypeNetwork,
-    ServerTypeNetworkInterface,
-    ServerTypeVolumeConstraintSizes,
-    ServerTypeVolumeConstraintsByType,
-    SetPlacementGroupResponse,
-    SetPlacementGroupServersResponse,
-    SetSecurityGroupRulesRequestRule,
-    SetSecurityGroupRulesResponse,
-    Snapshot,
-    SnapshotBaseVolume,
-    Task,
-    UpdateIpResponse,
-    UpdatePlacementGroupResponse,
-    UpdatePlacementGroupServersResponse,
-    UpdateServerResponse,
-    UpdateVolumeResponse,
-    Volume,
-    VolumeServer,
-    VolumeServerTemplate,
-    VolumeSummary,
-    VolumeTemplate,
-    VolumeType,
-    VolumeTypeCapabilities,
-    VolumeTypeConstraints,
-    ServerActionRequest,
-    CreateImageRequest,
-    CreateSnapshotRequest,
-    ExportSnapshotRequest,
-    CreateVolumeRequest,
-    UpdateVolumeRequest,
-    CreateSecurityGroupRequest,
-    CreateSecurityGroupRuleRequest,
-    SetSecurityGroupRulesRequest,
-    CreatePlacementGroupRequest,
-    SetPlacementGroupRequest,
-    UpdatePlacementGroupRequest,
-    SetPlacementGroupServersRequest,
-    UpdatePlacementGroupServersRequest,
+    ListLbPrivateNetworksResponse,
+    ListLbTypesResponse,
+    ListLbsResponse,
+    ListRoutesResponse,
+    ListSubscriberResponse,
+    PrivateNetwork,
+    PrivateNetworkDHCPConfig,
+    PrivateNetworkIpamConfig,
+    PrivateNetworkStaticConfig,
+    Route,
+    RouteMatch,
+    SetAclsResponse,
+    Subscriber,
+    SubscriberEmailConfig,
+    SubscriberWebhookConfig,
+    CreateLbRequest,
+    UpdateLbRequest,
+    MigrateLbRequest,
     CreateIpRequest,
     UpdateIpRequest,
-    CreatePrivateNICRequest,
-    UpdatePrivateNICRequest,
-)
-from .types_private import (
-    _SetImageResponse,
-    _SetSecurityGroupResponse,
-    _SetSecurityGroupRuleResponse,
-    _SetServerResponse,
-    _SetSnapshotResponse,
-    _CreateServerRequest,
-    _SetServerRequest,
-    _UpdateServerRequest,
-    _SetImageRequest,
-    _SetSnapshotRequest,
-    _SetSecurityGroupRequest,
-    _SetSecurityGroupRuleRequest,
+    CreateBackendRequest,
+    UpdateBackendRequest,
+    AddBackendServersRequest,
+    RemoveBackendServersRequest,
+    SetBackendServersRequest,
+    UpdateHealthCheckRequest,
+    CreateFrontendRequest,
+    UpdateFrontendRequest,
+    CreateRouteRequest,
+    UpdateRouteRequest,
+    CreateAclRequest,
+    UpdateAclRequest,
+    CreateCertificateRequest,
+    UpdateCertificateRequest,
+    CreateSubscriberRequest,
+    UpdateSubscriberRequest,
+    SubscribeToLbRequest,
+    AttachPrivateNetworkRequest,
+    ZonedApiCreateLbRequest,
+    ZonedApiUpdateLbRequest,
+    ZonedApiMigrateLbRequest,
+    ZonedApiCreateIpRequest,
+    ZonedApiUpdateIpRequest,
+    ZonedApiCreateBackendRequest,
+    ZonedApiUpdateBackendRequest,
+    ZonedApiAddBackendServersRequest,
+    ZonedApiRemoveBackendServersRequest,
+    ZonedApiSetBackendServersRequest,
+    ZonedApiUpdateHealthCheckRequest,
+    ZonedApiCreateFrontendRequest,
+    ZonedApiUpdateFrontendRequest,
+    ZonedApiCreateRouteRequest,
+    ZonedApiUpdateRouteRequest,
+    ZonedApiCreateAclRequest,
+    ZonedApiUpdateAclRequest,
+    ZonedApiSetAclsRequest,
+    ZonedApiCreateCertificateRequest,
+    ZonedApiUpdateCertificateRequest,
+    ZonedApiCreateSubscriberRequest,
+    ZonedApiUpdateSubscriberRequest,
+    ZonedApiSubscribeToLbRequest,
+    ZonedApiAttachPrivateNetworkRequest,
 )
 
 
-def unmarshal_ServerSummary(data: Any) -> ServerSummary:
+def unmarshal_SubscriberEmailConfig(data: Any) -> SubscriberEmailConfig:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ServerSummary' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'SubscriberEmailConfig' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("id")
-    args["id"] = field
-
-    field = data.get("name")
-    args["name"] = field
+    field = data.get("email", None)
+    args["email"] = field
 
-    return ServerSummary(**args)
+    return SubscriberEmailConfig(**args)
 
 
-def unmarshal_Bootscript(data: Any) -> Bootscript:
+def unmarshal_SubscriberWebhookConfig(data: Any) -> SubscriberWebhookConfig:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Bootscript' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'SubscriberWebhookConfig' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("arch")
-    args["arch"] = field
-
-    field = data.get("bootcmdargs")
-    args["bootcmdargs"] = field
-
-    field = data.get("default")
-    args["default"] = field
-
-    field = data.get("dtb")
-    args["dtb"] = field
+    field = data.get("uri", None)
+    args["uri"] = field
 
-    field = data.get("id")
-    args["id"] = field
+    return SubscriberWebhookConfig(**args)
 
-    field = data.get("initrd")
-    args["initrd"] = field
 
-    field = data.get("kernel")
-    args["kernel"] = field
+def unmarshal_HealthCheckHttpConfig(data: Any) -> HealthCheckHttpConfig:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'HealthCheckHttpConfig' failed as data isn't a dictionary."
+        )
 
-    field = data.get("organization")
-    args["organization"] = field
+    args: Dict[str, Any] = {}
 
-    field = data.get("project")
-    args["project"] = field
+    field = data.get("code", None)
+    args["code"] = field
 
-    field = data.get("public")
-    args["public"] = field
+    field = data.get("host_header", None)
+    args["host_header"] = field
 
-    field = data.get("title")
-    args["title"] = field
+    field = data.get("method", None)
+    args["method"] = field
 
-    field = data.get("zone")
-    args["zone"] = field
+    field = data.get("uri", None)
+    args["uri"] = field
 
-    return Bootscript(**args)
+    return HealthCheckHttpConfig(**args)
 
 
-def unmarshal_ServerTypeNetworkInterface(data: Any) -> ServerTypeNetworkInterface:
+def unmarshal_HealthCheckHttpsConfig(data: Any) -> HealthCheckHttpsConfig:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ServerTypeNetworkInterface' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'HealthCheckHttpsConfig' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("internal_bandwidth")
-    args["internal_bandwidth"] = field
+    field = data.get("code", None)
+    args["code"] = field
+
+    field = data.get("host_header", None)
+    args["host_header"] = field
 
-    field = data.get("internet_bandwidth")
-    args["internet_bandwidth"] = field
+    field = data.get("method", None)
+    args["method"] = field
 
-    return ServerTypeNetworkInterface(**args)
+    field = data.get("sni", None)
+    args["sni"] = field
 
+    field = data.get("uri", None)
+    args["uri"] = field
 
-def unmarshal_ServerTypeVolumeConstraintSizes(
-    data: Any,
-) -> ServerTypeVolumeConstraintSizes:
+    return HealthCheckHttpsConfig(**args)
+
+
+def unmarshal_HealthCheckLdapConfig(data: Any) -> HealthCheckLdapConfig:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ServerTypeVolumeConstraintSizes' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'HealthCheckLdapConfig' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("max_size")
-    args["max_size"] = field
-
-    field = data.get("min_size")
-    args["min_size"] = field
-
-    return ServerTypeVolumeConstraintSizes(**args)
+    return HealthCheckLdapConfig(**args)
 
 
-def unmarshal_Volume(data: Any) -> Volume:
+def unmarshal_HealthCheckMysqlConfig(data: Any) -> HealthCheckMysqlConfig:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Volume' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'HealthCheckMysqlConfig' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("creation_date")
-    args["creation_date"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("user", None)
+    args["user"] = field
 
-    field = data.get("export_uri")
-    args["export_uri"] = field
+    return HealthCheckMysqlConfig(**args)
 
-    field = data.get("id")
-    args["id"] = field
 
-    field = data.get("modification_date")
-    args["modification_date"] = parser.isoparse(field) if type(field) is str else field
+def unmarshal_HealthCheckPgsqlConfig(data: Any) -> HealthCheckPgsqlConfig:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'HealthCheckPgsqlConfig' failed as data isn't a dictionary."
+        )
 
-    field = data.get("name")
-    args["name"] = field
+    args: Dict[str, Any] = {}
 
-    field = data.get("organization")
-    args["organization"] = field
+    field = data.get("user", None)
+    args["user"] = field
 
-    field = data.get("project")
-    args["project"] = field
+    return HealthCheckPgsqlConfig(**args)
 
-    field = data.get("server")
-    args["server"] = unmarshal_ServerSummary(field) if field is not None else None
 
-    field = data.get("size")
-    args["size"] = field
+def unmarshal_HealthCheckRedisConfig(data: Any) -> HealthCheckRedisConfig:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'HealthCheckRedisConfig' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
 
-    field = data.get("state")
-    args["state"] = field
+    return HealthCheckRedisConfig(**args)
 
-    field = data.get("tags")
-    args["tags"] = field
 
-    field = data.get("volume_type")
-    args["volume_type"] = field
+def unmarshal_HealthCheckTcpConfig(data: Any) -> HealthCheckTcpConfig:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'HealthCheckTcpConfig' failed as data isn't a dictionary."
+        )
 
-    field = data.get("zone")
-    args["zone"] = field
+    args: Dict[str, Any] = {}
 
-    return Volume(**args)
+    return HealthCheckTcpConfig(**args)
 
 
-def unmarshal_VolumeSummary(data: Any) -> VolumeSummary:
+def unmarshal_Instance(data: Any) -> Instance:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'VolumeSummary' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Instance' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("id")
+    field = data.get("created_at", None)
+    args["created_at"] = parser.isoparse(field) if type(field) is str else field
+
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("name")
-    args["name"] = field
+    field = data.get("ip_address", None)
+    args["ip_address"] = field
 
-    field = data.get("size")
-    args["size"] = field
+    field = data.get("region", None)
+    args["region"] = field
 
-    field = data.get("volume_type")
-    args["volume_type"] = field
+    field = data.get("status", None)
+    args["status"] = field
+
+    field = data.get("updated_at", None)
+    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
+
+    field = data.get("zone", None)
+    args["zone"] = field
 
-    return VolumeSummary(**args)
+    return Instance(**args)
 
 
-def unmarshal_Image(data: Any) -> Image:
+def unmarshal_Ip(data: Any) -> Ip:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Image' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Ip' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("arch")
-    args["arch"] = field
-
-    field = data.get("creation_date")
-    args["creation_date"] = parser.isoparse(field) if type(field) is str else field
-
-    field = data.get("default_bootscript")
-    args["default_bootscript"] = (
-        unmarshal_Bootscript(field) if field is not None else None
-    )
-
-    field = data.get("extra_volumes")
-    args["extra_volumes"] = {
-        k: unmarshal_Volume(v) for k, v in data["extra_volumes"].items()
-    }
-
-    field = data.get("from_server")
-    args["from_server"] = field
-
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("modification_date")
-    args["modification_date"] = parser.isoparse(field) if type(field) is str else field
-
-    field = data.get("name")
-    args["name"] = field
-
-    field = data.get("organization")
-    args["organization"] = field
+    field = data.get("ip_address", None)
+    args["ip_address"] = field
 
-    field = data.get("project")
-    args["project"] = field
+    field = data.get("lb_id", None)
+    args["lb_id"] = field
 
-    field = data.get("public")
-    args["public"] = field
+    field = data.get("organization_id", None)
+    args["organization_id"] = field
 
-    field = data.get("root_volume")
-    args["root_volume"] = unmarshal_VolumeSummary(field) if field is not None else None
+    field = data.get("project_id", None)
+    args["project_id"] = field
 
-    field = data.get("state")
-    args["state"] = field
+    field = data.get("region", None)
+    args["region"] = field
 
-    field = data.get("tags")
-    args["tags"] = field
+    field = data.get("reverse", None)
+    args["reverse"] = field
 
-    field = data.get("zone")
+    field = data.get("zone", None)
     args["zone"] = field
 
-    return Image(**args)
+    return Ip(**args)
 
 
-def unmarshal_PlacementGroup(data: Any) -> PlacementGroup:
+def unmarshal_Subscriber(data: Any) -> Subscriber:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'PlacementGroup' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Subscriber' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("id")
+    field = data.get("email_config", None)
+    args["email_config"] = (
+        unmarshal_SubscriberEmailConfig(field) if field is not None else None
+    )
+
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("organization")
-    args["organization"] = field
-
-    field = data.get("policy_mode")
-    args["policy_mode"] = field
-
-    field = data.get("policy_respected")
-    args["policy_respected"] = field
-
-    field = data.get("policy_type")
-    args["policy_type"] = field
-
-    field = data.get("project")
-    args["project"] = field
-
-    field = data.get("tags")
-    args["tags"] = field
-
-    field = data.get("zone")
-    args["zone"] = field
+    field = data.get("webhook_config", None)
+    args["webhook_config"] = (
+        unmarshal_SubscriberWebhookConfig(field) if field is not None else None
+    )
 
-    return PlacementGroup(**args)
+    return Subscriber(**args)
 
 
-def unmarshal_PrivateNIC(data: Any) -> PrivateNIC:
+def unmarshal_HealthCheck(data: Any) -> HealthCheck:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'PrivateNIC' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'HealthCheck' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("id")
-    args["id"] = field
+    field = data.get("check_delay", None)
+    args["check_delay"] = field
 
-    field = data.get("mac_address")
-    args["mac_address"] = field
+    field = data.get("check_max_retries", None)
+    args["check_max_retries"] = field
 
-    field = data.get("private_network_id")
-    args["private_network_id"] = field
+    field = data.get("check_send_proxy", None)
+    args["check_send_proxy"] = field
 
-    field = data.get("server_id")
-    args["server_id"] = field
+    field = data.get("check_timeout", None)
+    args["check_timeout"] = field
 
-    field = data.get("state")
-    args["state"] = field
+    field = data.get("http_config", None)
+    args["http_config"] = (
+        unmarshal_HealthCheckHttpConfig(field) if field is not None else None
+    )
 
-    field = data.get("tags")
-    args["tags"] = field
+    field = data.get("https_config", None)
+    args["https_config"] = (
+        unmarshal_HealthCheckHttpsConfig(field) if field is not None else None
+    )
 
-    return PrivateNIC(**args)
+    field = data.get("ldap_config", None)
+    args["ldap_config"] = (
+        unmarshal_HealthCheckLdapConfig(field) if field is not None else None
+    )
 
+    field = data.get("mysql_config", None)
+    args["mysql_config"] = (
+        unmarshal_HealthCheckMysqlConfig(field) if field is not None else None
+    )
 
-def unmarshal_SecurityGroupSummary(data: Any) -> SecurityGroupSummary:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'SecurityGroupSummary' failed as data isn't a dictionary."
-        )
+    field = data.get("pgsql_config", None)
+    args["pgsql_config"] = (
+        unmarshal_HealthCheckPgsqlConfig(field) if field is not None else None
+    )
 
-    args: Dict[str, Any] = {}
+    field = data.get("port", None)
+    args["port"] = field
 
-    field = data.get("id")
-    args["id"] = field
+    field = data.get("redis_config", None)
+    args["redis_config"] = (
+        unmarshal_HealthCheckRedisConfig(field) if field is not None else None
+    )
 
-    field = data.get("name")
-    args["name"] = field
+    field = data.get("tcp_config", None)
+    args["tcp_config"] = (
+        unmarshal_HealthCheckTcpConfig(field) if field is not None else None
+    )
+
+    field = data.get("transient_check_delay", None)
+    args["transient_check_delay"] = field
 
-    return SecurityGroupSummary(**args)
+    return HealthCheck(**args)
 
 
-def unmarshal_ServerIp(data: Any) -> ServerIp:
+def unmarshal_Lb(data: Any) -> Lb:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ServerIp' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Lb' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("address")
-    args["address"] = field
+    field = data.get("backend_count", None)
+    args["backend_count"] = field
 
-    field = data.get("dynamic")
-    args["dynamic"] = field
+    field = data.get("created_at", None)
+    args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("id")
-    args["id"] = field
+    field = data.get("description", None)
+    args["description"] = field
 
-    return ServerIp(**args)
+    field = data.get("frontend_count", None)
+    args["frontend_count"] = field
 
+    field = data.get("id", None)
+    args["id"] = field
 
-def unmarshal_ServerIpv6(data: Any) -> ServerIpv6:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ServerIpv6' failed as data isn't a dictionary."
-        )
+    field = data.get("instances", None)
+    args["instances"] = (
+        [unmarshal_Instance(v) for v in field] if field is not None else None
+    )
 
-    args: Dict[str, Any] = {}
+    field = data.get("ip", None)
+    args["ip"] = [unmarshal_Ip(v) for v in field] if field is not None else None
 
-    field = data.get("address")
-    args["address"] = field
+    field = data.get("name", None)
+    args["name"] = field
 
-    field = data.get("gateway")
-    args["gateway"] = field
+    field = data.get("organization_id", None)
+    args["organization_id"] = field
 
-    field = data.get("netmask")
-    args["netmask"] = field
+    field = data.get("private_network_count", None)
+    args["private_network_count"] = field
 
-    return ServerIpv6(**args)
+    field = data.get("project_id", None)
+    args["project_id"] = field
 
+    field = data.get("region", None)
+    args["region"] = field
 
-def unmarshal_ServerLocation(data: Any) -> ServerLocation:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ServerLocation' failed as data isn't a dictionary."
-        )
+    field = data.get("route_count", None)
+    args["route_count"] = field
 
-    args: Dict[str, Any] = {}
+    field = data.get("ssl_compatibility_level", None)
+    args["ssl_compatibility_level"] = field
 
-    field = data.get("cluster_id")
-    args["cluster_id"] = field
+    field = data.get("status", None)
+    args["status"] = field
 
-    field = data.get("hypervisor_id")
-    args["hypervisor_id"] = field
+    field = data.get("subscriber", None)
+    args["subscriber"] = unmarshal_Subscriber(field) if field is not None else None
 
-    field = data.get("node_id")
-    args["node_id"] = field
+    field = data.get("tags", None)
+    args["tags"] = field
 
-    field = data.get("platform_id")
-    args["platform_id"] = field
+    field = data.get("type", None)
+    args["type_"] = field
 
-    field = data.get("zone_id")
-    args["zone_id"] = field
+    field = data.get("updated_at", None)
+    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    return ServerLocation(**args)
+    field = data.get("zone", None)
+    args["zone"] = field
+
+    return Lb(**args)
 
 
-def unmarshal_ServerMaintenance(data: Any) -> ServerMaintenance:
+def unmarshal_AclActionRedirect(data: Any) -> AclActionRedirect:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ServerMaintenance' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'AclActionRedirect' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("reason")
-    args["reason"] = field
+    field = data.get("code", None)
+    args["code"] = field
+
+    field = data.get("target", None)
+    args["target"] = field
 
-    return ServerMaintenance(**args)
+    field = data.get("type", None)
+    args["type_"] = field
 
+    return AclActionRedirect(**args)
 
-def unmarshal_ServerTypeCapabilities(data: Any) -> ServerTypeCapabilities:
+
+def unmarshal_Backend(data: Any) -> Backend:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ServerTypeCapabilities' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Backend' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("block_storage")
-    args["block_storage"] = field
+    field = data.get("created_at", None)
+    args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("boot_types")
-    args["boot_types"] = field
+    field = data.get("failover_host", None)
+    args["failover_host"] = field
 
-    return ServerTypeCapabilities(**args)
+    field = data.get("forward_port", None)
+    args["forward_port"] = field
 
+    field = data.get("forward_port_algorithm", None)
+    args["forward_port_algorithm"] = field
 
-def unmarshal_ServerTypeNetwork(data: Any) -> ServerTypeNetwork:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ServerTypeNetwork' failed as data isn't a dictionary."
-        )
+    field = data.get("forward_protocol", None)
+    args["forward_protocol"] = field
 
-    args: Dict[str, Any] = {}
+    field = data.get("health_check", None)
+    args["health_check"] = unmarshal_HealthCheck(field) if field is not None else None
 
-    field = data.get("interfaces")
-    args["interfaces"] = [
-        unmarshal_ServerTypeNetworkInterface(v) for v in data["interfaces"]
-    ]
+    field = data.get("id", None)
+    args["id"] = field
 
-    field = data.get("ipv6_support")
-    args["ipv6_support"] = field
+    field = data.get("ignore_ssl_server_verify", None)
+    args["ignore_ssl_server_verify"] = field
 
-    field = data.get("sum_internal_bandwidth")
-    args["sum_internal_bandwidth"] = field
+    field = data.get("lb", None)
+    args["lb"] = unmarshal_Lb(field) if field is not None else None
 
-    field = data.get("sum_internet_bandwidth")
-    args["sum_internet_bandwidth"] = field
+    field = data.get("max_connections", None)
+    args["max_connections"] = field
 
-    return ServerTypeNetwork(**args)
+    field = data.get("max_retries", None)
+    args["max_retries"] = field
 
+    field = data.get("name", None)
+    args["name"] = field
 
-def unmarshal_ServerTypeVolumeConstraintsByType(
-    data: Any,
-) -> ServerTypeVolumeConstraintsByType:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ServerTypeVolumeConstraintsByType' failed as data isn't a dictionary."
-        )
+    field = data.get("on_marked_down_action", None)
+    args["on_marked_down_action"] = field
 
-    args: Dict[str, Any] = {}
+    field = data.get("pool", None)
+    args["pool"] = field
 
-    field = data.get("l_ssd")
-    args["l_ssd"] = (
-        unmarshal_ServerTypeVolumeConstraintSizes(field) if field is not None else None
-    )
+    field = data.get("proxy_protocol", None)
+    args["proxy_protocol"] = field
 
-    return ServerTypeVolumeConstraintsByType(**args)
+    field = data.get("redispatch_attempt_count", None)
+    args["redispatch_attempt_count"] = field
 
+    field = data.get("send_proxy_v2", None)
+    args["send_proxy_v2"] = field
 
-def unmarshal_SnapshotBaseVolume(data: Any) -> SnapshotBaseVolume:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'SnapshotBaseVolume' failed as data isn't a dictionary."
-        )
+    field = data.get("ssl_bridging", None)
+    args["ssl_bridging"] = field
 
-    args: Dict[str, Any] = {}
+    field = data.get("sticky_sessions", None)
+    args["sticky_sessions"] = field
 
-    field = data.get("id")
-    args["id"] = field
+    field = data.get("sticky_sessions_cookie_name", None)
+    args["sticky_sessions_cookie_name"] = field
 
-    field = data.get("name")
-    args["name"] = field
+    field = data.get("timeout_connect", None)
+    args["timeout_connect"] = field
+
+    field = data.get("timeout_queue", None)
+    args["timeout_queue"] = field
+
+    field = data.get("timeout_server", None)
+    args["timeout_server"] = field
 
-    return SnapshotBaseVolume(**args)
+    field = data.get("timeout_tunnel", None)
+    args["timeout_tunnel"] = field
 
+    field = data.get("updated_at", None)
+    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-def unmarshal_VolumeServer(data: Any) -> VolumeServer:
+    return Backend(**args)
+
+
+def unmarshal_Certificate(data: Any) -> Certificate:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'VolumeServer' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Certificate' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("boot")
-    args["boot"] = field
+    field = data.get("common_name", None)
+    args["common_name"] = field
 
-    field = data.get("creation_date")
-    args["creation_date"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("created_at", None)
+    args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("export_uri")
-    args["export_uri"] = field
+    field = data.get("fingerprint", None)
+    args["fingerprint"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("modification_date")
-    args["modification_date"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("lb", None)
+    args["lb"] = unmarshal_Lb(field) if field is not None else None
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("organization")
-    args["organization"] = field
+    field = data.get("not_valid_after", None)
+    args["not_valid_after"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("project")
-    args["project"] = field
+    field = data.get("not_valid_before", None)
+    args["not_valid_before"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("server")
-    args["server"] = unmarshal_ServerSummary(field) if field is not None else None
+    field = data.get("status", None)
+    args["status"] = field
 
-    field = data.get("size")
-    args["size"] = field
+    field = data.get("status_details", None)
+    args["status_details"] = field
 
-    field = data.get("state")
-    args["state"] = field
+    field = data.get("subject_alternative_name", None)
+    args["subject_alternative_name"] = field
 
-    field = data.get("volume_type")
-    args["volume_type"] = field
+    field = data.get("type", None)
+    args["type_"] = field
 
-    field = data.get("zone")
-    args["zone"] = field
+    field = data.get("updated_at", None)
+    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    return VolumeServer(**args)
+    return Certificate(**args)
 
 
-def unmarshal_VolumeTypeCapabilities(data: Any) -> VolumeTypeCapabilities:
+def unmarshal_AclAction(data: Any) -> AclAction:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'VolumeTypeCapabilities' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'AclAction' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("snapshot")
-    args["snapshot"] = field
+    field = data.get("redirect", None)
+    args["redirect"] = unmarshal_AclActionRedirect(field) if field is not None else None
 
-    return VolumeTypeCapabilities(**args)
+    field = data.get("type", None)
+    args["type_"] = field
 
+    return AclAction(**args)
 
-def unmarshal_VolumeTypeConstraints(data: Any) -> VolumeTypeConstraints:
+
+def unmarshal_AclMatch(data: Any) -> AclMatch:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'VolumeTypeConstraints' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'AclMatch' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("max")
-    args["max"] = field
+    field = data.get("http_filter", None)
+    args["http_filter"] = field
+
+    field = data.get("http_filter_option", None)
+    args["http_filter_option"] = field
+
+    field = data.get("http_filter_value", None)
+    args["http_filter_value"] = field
 
-    field = data.get("min")
-    args["min"] = field
+    field = data.get("invert", None)
+    args["invert"] = field
 
-    return VolumeTypeConstraints(**args)
+    field = data.get("ip_subnet", None)
+    args["ip_subnet"] = field
 
+    return AclMatch(**args)
 
-def unmarshal_Dashboard(data: Any) -> Dashboard:
+
+def unmarshal_Frontend(data: Any) -> Frontend:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Dashboard' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Frontend' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("images_count")
-    args["images_count"] = field
-
-    field = data.get("ips_count")
-    args["ips_count"] = field
-
-    field = data.get("ips_unused")
-    args["ips_unused"] = field
+    field = data.get("backend", None)
+    args["backend"] = unmarshal_Backend(field) if field is not None else None
 
-    field = data.get("placement_groups_count")
-    args["placement_groups_count"] = field
+    field = data.get("certificate", None)
+    args["certificate"] = unmarshal_Certificate(field) if field is not None else None
 
-    field = data.get("private_nics_count")
-    args["private_nics_count"] = field
+    field = data.get("certificate_ids", None)
+    args["certificate_ids"] = field
 
-    field = data.get("running_servers_count")
-    args["running_servers_count"] = field
+    field = data.get("created_at", None)
+    args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("security_groups_count")
-    args["security_groups_count"] = field
+    field = data.get("enable_http3", None)
+    args["enable_http3"] = field
 
-    field = data.get("servers_by_types")
-    args["servers_by_types"] = field
-
-    field = data.get("servers_count")
-    args["servers_count"] = field
-
-    field = data.get("snapshots_count")
-    args["snapshots_count"] = field
+    field = data.get("id", None)
+    args["id"] = field
 
-    field = data.get("volumes_b_ssd_count")
-    args["volumes_b_ssd_count"] = field
+    field = data.get("inbound_port", None)
+    args["inbound_port"] = field
 
-    field = data.get("volumes_b_ssd_total_size")
-    args["volumes_b_ssd_total_size"] = field
+    field = data.get("lb", None)
+    args["lb"] = unmarshal_Lb(field) if field is not None else None
 
-    field = data.get("volumes_count")
-    args["volumes_count"] = field
+    field = data.get("name", None)
+    args["name"] = field
 
-    field = data.get("volumes_l_ssd_count")
-    args["volumes_l_ssd_count"] = field
+    field = data.get("timeout_client", None)
+    args["timeout_client"] = field
 
-    field = data.get("volumes_l_ssd_total_size")
-    args["volumes_l_ssd_total_size"] = field
+    field = data.get("updated_at", None)
+    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    return Dashboard(**args)
+    return Frontend(**args)
 
 
-def unmarshal_GetServerTypesAvailabilityResponseAvailability(
-    data: Any,
-) -> GetServerTypesAvailabilityResponseAvailability:
+def unmarshal_PrivateNetworkDHCPConfig(data: Any) -> PrivateNetworkDHCPConfig:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'GetServerTypesAvailabilityResponseAvailability' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'PrivateNetworkDHCPConfig' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("availability")
-    args["availability"] = field
+    field = data.get("ip_id", None)
+    args["ip_id"] = field
 
-    return GetServerTypesAvailabilityResponseAvailability(**args)
+    return PrivateNetworkDHCPConfig(**args)
 
 
-def unmarshal_Ip(data: Any) -> Ip:
+def unmarshal_PrivateNetworkIpamConfig(data: Any) -> PrivateNetworkIpamConfig:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Ip' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'PrivateNetworkIpamConfig' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("address")
-    args["address"] = field
+    return PrivateNetworkIpamConfig(**args)
 
-    field = data.get("id")
-    args["id"] = field
 
-    field = data.get("organization")
-    args["organization"] = field
-
-    field = data.get("project")
-    args["project"] = field
-
-    field = data.get("reverse")
-    args["reverse"] = field
-
-    field = data.get("server")
-    args["server"] = unmarshal_ServerSummary(field) if field is not None else None
+def unmarshal_PrivateNetworkStaticConfig(data: Any) -> PrivateNetworkStaticConfig:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'PrivateNetworkStaticConfig' failed as data isn't a dictionary."
+        )
 
-    field = data.get("tags")
-    args["tags"] = field
+    args: Dict[str, Any] = {}
 
-    field = data.get("zone")
-    args["zone"] = field
+    field = data.get("ip_address", None)
+    args["ip_address"] = field
 
-    return Ip(**args)
+    return PrivateNetworkStaticConfig(**args)
 
 
-def unmarshal_PlacementGroupServer(data: Any) -> PlacementGroupServer:
+def unmarshal_RouteMatch(data: Any) -> RouteMatch:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'PlacementGroupServer' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'RouteMatch' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("id")
-    args["id"] = field
+    field = data.get("host_header", None)
+    args["host_header"] = field
 
-    field = data.get("name")
-    args["name"] = field
+    field = data.get("sni", None)
+    args["sni"] = field
 
-    field = data.get("policy_respected")
-    args["policy_respected"] = field
+    return RouteMatch(**args)
 
-    return PlacementGroupServer(**args)
 
-
-def unmarshal_SecurityGroup(data: Any) -> SecurityGroup:
+def unmarshal_Acl(data: Any) -> Acl:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'SecurityGroup' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Acl' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("creation_date")
-    args["creation_date"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("action", None)
+    args["action"] = unmarshal_AclAction(field) if field is not None else None
+
+    field = data.get("created_at", None)
+    args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("description")
+    field = data.get("description", None)
     args["description"] = field
 
-    field = data.get("enable_default_security")
-    args["enable_default_security"] = field
+    field = data.get("frontend", None)
+    args["frontend"] = unmarshal_Frontend(field) if field is not None else None
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("inbound_default_policy")
-    args["inbound_default_policy"] = field
+    field = data.get("index", None)
+    args["index"] = field
 
-    field = data.get("modification_date")
-    args["modification_date"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("match", None)
+    args["match"] = unmarshal_AclMatch(field) if field is not None else None
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("organization")
-    args["organization"] = field
-
-    field = data.get("organization_default")
-    args["organization_default"] = field
-
-    field = data.get("outbound_default_policy")
-    args["outbound_default_policy"] = field
-
-    field = data.get("project")
-    args["project"] = field
-
-    field = data.get("project_default")
-    args["project_default"] = field
-
-    field = data.get("servers")
-    args["servers"] = [unmarshal_ServerSummary(v) for v in data["servers"]]
-
-    field = data.get("state")
-    args["state"] = field
-
-    field = data.get("stateful")
-    args["stateful"] = field
+    field = data.get("updated_at", None)
+    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("tags")
-    args["tags"] = field
-
-    field = data.get("zone")
-    args["zone"] = field
-
-    return SecurityGroup(**args)
+    return Acl(**args)
 
 
-def unmarshal_SecurityGroupRule(data: Any) -> SecurityGroupRule:
+def unmarshal_BackendServerStats(data: Any) -> BackendServerStats:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'SecurityGroupRule' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'BackendServerStats' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("action")
-    args["action"] = field
-
-    field = data.get("dest_port_from")
-    args["dest_port_from"] = field
-
-    field = data.get("dest_port_to")
-    args["dest_port_to"] = field
-
-    field = data.get("direction")
-    args["direction"] = field
+    field = data.get("backend_id", None)
+    args["backend_id"] = field
 
-    field = data.get("editable")
-    args["editable"] = field
+    field = data.get("instance_id", None)
+    args["instance_id"] = field
 
-    field = data.get("id")
-    args["id"] = field
-
-    field = data.get("ip_range")
-    args["ip_range"] = field
+    field = data.get("ip", None)
+    args["ip"] = field
 
-    field = data.get("position")
-    args["position"] = field
+    field = data.get("last_health_check_status", None)
+    args["last_health_check_status"] = field
 
-    field = data.get("protocol")
-    args["protocol"] = field
+    field = data.get("server_state", None)
+    args["server_state"] = field
 
-    field = data.get("zone")
-    args["zone"] = field
+    field = data.get("server_state_changed_at", None)
+    args["server_state_changed_at"] = (
+        parser.isoparse(field) if type(field) is str else field
+    )
 
-    return SecurityGroupRule(**args)
+    return BackendServerStats(**args)
 
 
-def unmarshal_Server(data: Any) -> Server:
+def unmarshal_LbType(data: Any) -> LbType:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Server' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'LbType' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("allowed_actions")
-    args["allowed_actions"] = field
-
-    field = data.get("arch")
-    args["arch"] = field
-
-    field = data.get("boot_type")
-    args["boot_type"] = field
-
-    field = data.get("bootscript")
-    args["bootscript"] = unmarshal_Bootscript(field) if field is not None else None
-
-    field = data.get("commercial_type")
-    args["commercial_type"] = field
-
-    field = data.get("creation_date")
-    args["creation_date"] = parser.isoparse(field) if type(field) is str else field
-
-    field = data.get("dynamic_ip_required")
-    args["dynamic_ip_required"] = field
-
-    field = data.get("enable_ipv6")
-    args["enable_ipv6"] = field
-
-    field = data.get("hostname")
-    args["hostname"] = field
-
-    field = data.get("id")
-    args["id"] = field
-
-    field = data.get("image")
-    args["image"] = unmarshal_Image(field) if field is not None else None
-
-    field = data.get("ipv6")
-    args["ipv6"] = unmarshal_ServerIpv6(field) if field is not None else None
-
-    field = data.get("location")
-    args["location"] = unmarshal_ServerLocation(field) if field is not None else None
-
-    field = data.get("maintenances")
-    args["maintenances"] = [
-        unmarshal_ServerMaintenance(v) for v in data["maintenances"]
-    ]
-
-    field = data.get("modification_date")
-    args["modification_date"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("description", None)
+    args["description"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("organization")
-    args["organization"] = field
+    field = data.get("region", None)
+    args["region"] = field
 
-    field = data.get("placement_group")
-    args["placement_group"] = (
-        unmarshal_PlacementGroup(field) if field is not None else None
-    )
-
-    field = data.get("private_ip")
-    args["private_ip"] = field
-
-    field = data.get("private_nics")
-    args["private_nics"] = [unmarshal_PrivateNIC(v) for v in data["private_nics"]]
-
-    field = data.get("project")
-    args["project"] = field
-
-    field = data.get("protected")
-    args["protected"] = field
-
-    field = data.get("public_ip")
-    args["public_ip"] = unmarshal_ServerIp(field) if field is not None else None
-
-    field = data.get("security_group")
-    args["security_group"] = (
-        unmarshal_SecurityGroupSummary(field) if field is not None else None
-    )
-
-    field = data.get("state")
-    args["state"] = field
-
-    field = data.get("state_detail")
-    args["state_detail"] = field
-
-    field = data.get("tags")
-    args["tags"] = field
-
-    field = data.get("volumes")
-    args["volumes"] = {k: unmarshal_VolumeServer(v) for k, v in data["volumes"].items()}
+    field = data.get("stock_status", None)
+    args["stock_status"] = field
 
-    field = data.get("zone")
+    field = data.get("zone", None)
     args["zone"] = field
 
-    return Server(**args)
+    return LbType(**args)
 
 
-def unmarshal_ServerType(data: Any) -> ServerType:
+def unmarshal_PrivateNetwork(data: Any) -> PrivateNetwork:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ServerType' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'PrivateNetwork' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("alt_names")
-    args["alt_names"] = field
+    field = data.get("created_at", None)
+    args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("arch")
-    args["arch"] = field
-
-    field = data.get("baremetal")
-    args["baremetal"] = field
-
-    field = data.get("capabilities")
-    args["capabilities"] = (
-        unmarshal_ServerTypeCapabilities(field) if field is not None else None
+    field = data.get("dhcp_config", None)
+    args["dhcp_config"] = (
+        unmarshal_PrivateNetworkDHCPConfig(field) if field is not None else None
     )
 
-    field = data.get("gpu")
-    args["gpu"] = field
-
-    field = data.get("hourly_price")
-    args["hourly_price"] = field
-
-    field = data.get("monthly_price")
-    args["monthly_price"] = field
+    field = data.get("ipam_config", None)
+    args["ipam_config"] = (
+        unmarshal_PrivateNetworkIpamConfig(field) if field is not None else None
+    )
 
-    field = data.get("ncpus")
-    args["ncpus"] = field
+    field = data.get("lb", None)
+    args["lb"] = unmarshal_Lb(field) if field is not None else None
 
-    field = data.get("network")
-    args["network"] = unmarshal_ServerTypeNetwork(field) if field is not None else None
+    field = data.get("private_network_id", None)
+    args["private_network_id"] = field
 
-    field = data.get("per_volume_constraint")
-    args["per_volume_constraint"] = (
-        unmarshal_ServerTypeVolumeConstraintsByType(field)
-        if field is not None
-        else None
+    field = data.get("static_config", None)
+    args["static_config"] = (
+        unmarshal_PrivateNetworkStaticConfig(field) if field is not None else None
     )
 
-    field = data.get("ram")
-    args["ram"] = field
+    field = data.get("status", None)
+    args["status"] = field
 
-    field = data.get("volumes_constraint")
-    args["volumes_constraint"] = (
-        unmarshal_ServerTypeVolumeConstraintSizes(field) if field is not None else None
-    )
+    field = data.get("updated_at", None)
+    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    return ServerType(**args)
+    return PrivateNetwork(**args)
 
 
-def unmarshal_Snapshot(data: Any) -> Snapshot:
+def unmarshal_Route(data: Any) -> Route:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Snapshot' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Route' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("base_volume")
-    args["base_volume"] = (
-        unmarshal_SnapshotBaseVolume(field) if field is not None else None
-    )
+    field = data.get("backend_id", None)
+    args["backend_id"] = field
 
-    field = data.get("creation_date")
-    args["creation_date"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("created_at", None)
+    args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("error_reason")
-    args["error_reason"] = field
+    field = data.get("frontend_id", None)
+    args["frontend_id"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("modification_date")
-    args["modification_date"] = parser.isoparse(field) if type(field) is str else field
-
-    field = data.get("name")
-    args["name"] = field
-
-    field = data.get("organization")
-    args["organization"] = field
-
-    field = data.get("project")
-    args["project"] = field
+    field = data.get("match", None)
+    args["match"] = unmarshal_RouteMatch(field) if field is not None else None
 
-    field = data.get("size")
-    args["size"] = field
+    field = data.get("updated_at", None)
+    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("state")
-    args["state"] = field
+    return Route(**args)
 
-    field = data.get("tags")
-    args["tags"] = field
-
-    field = data.get("volume_type")
-    args["volume_type"] = field
-
-    field = data.get("zone")
-    args["zone"] = field
 
-    return Snapshot(**args)
-
-
-def unmarshal_Task(data: Any) -> Task:
+def unmarshal_LbStats(data: Any) -> LbStats:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Task' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'LbStats' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("description")
-    args["description"] = field
-
-    field = data.get("href_from")
-    args["href_from"] = field
-
-    field = data.get("href_result")
-    args["href_result"] = field
+    field = data.get("backend_servers_stats", None)
+    args["backend_servers_stats"] = (
+        [unmarshal_BackendServerStats(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("id")
-    args["id"] = field
+    return LbStats(**args)
 
-    field = data.get("progress")
-    args["progress"] = field
 
-    field = data.get("started_at")
-    args["started_at"] = parser.isoparse(field) if type(field) is str else field
+def unmarshal_ListAclResponse(data: Any) -> ListAclResponse:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'ListAclResponse' failed as data isn't a dictionary."
+        )
 
-    field = data.get("status")
-    args["status"] = field
+    args: Dict[str, Any] = {}
 
-    field = data.get("terminated_at")
-    args["terminated_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("acls", None)
+    args["acls"] = [unmarshal_Acl(v) for v in field] if field is not None else None
 
-    field = data.get("zone")
-    args["zone"] = field
+    field = data.get("total_count", None)
+    args["total_count"] = field
 
-    return Task(**args)
+    return ListAclResponse(**args)
 
 
-def unmarshal_VolumeType(data: Any) -> VolumeType:
+def unmarshal_ListBackendStatsResponse(data: Any) -> ListBackendStatsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'VolumeType' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListBackendStatsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("capabilities")
-    args["capabilities"] = (
-        unmarshal_VolumeTypeCapabilities(field) if field is not None else None
+    field = data.get("backend_servers_stats", None)
+    args["backend_servers_stats"] = (
+        [unmarshal_BackendServerStats(v) for v in field] if field is not None else None
     )
 
-    field = data.get("constraints")
-    args["constraints"] = (
-        unmarshal_VolumeTypeConstraints(field) if field is not None else None
-    )
-
-    field = data.get("display_name")
-    args["display_name"] = field
+    field = data.get("total_count", None)
+    args["total_count"] = field
 
-    return VolumeType(**args)
+    return ListBackendStatsResponse(**args)
 
 
-def unmarshal_CreateImageResponse(data: Any) -> CreateImageResponse:
+def unmarshal_ListBackendsResponse(data: Any) -> ListBackendsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'CreateImageResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListBackendsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("image")
-    args["image"] = unmarshal_Image(field) if field is not None else None
+    field = data.get("backends", None)
+    args["backends"] = (
+        [unmarshal_Backend(v) for v in field] if field is not None else None
+    )
+
+    field = data.get("total_count", None)
+    args["total_count"] = field
 
-    return CreateImageResponse(**args)
+    return ListBackendsResponse(**args)
 
 
-def unmarshal_CreateIpResponse(data: Any) -> CreateIpResponse:
+def unmarshal_ListCertificatesResponse(data: Any) -> ListCertificatesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'CreateIpResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListCertificatesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("ip")
-    args["ip"] = unmarshal_Ip(field) if field is not None else None
+    field = data.get("certificates", None)
+    args["certificates"] = (
+        [unmarshal_Certificate(v) for v in field] if field is not None else None
+    )
+
+    field = data.get("total_count", None)
+    args["total_count"] = field
 
-    return CreateIpResponse(**args)
+    return ListCertificatesResponse(**args)
 
 
-def unmarshal_CreatePlacementGroupResponse(data: Any) -> CreatePlacementGroupResponse:
+def unmarshal_ListFrontendsResponse(data: Any) -> ListFrontendsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'CreatePlacementGroupResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListFrontendsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("placement_group")
-    args["placement_group"] = (
-        unmarshal_PlacementGroup(field) if field is not None else None
+    field = data.get("frontends", None)
+    args["frontends"] = (
+        [unmarshal_Frontend(v) for v in field] if field is not None else None
     )
 
-    return CreatePlacementGroupResponse(**args)
+    field = data.get("total_count", None)
+    args["total_count"] = field
+
+    return ListFrontendsResponse(**args)
 
 
-def unmarshal_CreatePrivateNICResponse(data: Any) -> CreatePrivateNICResponse:
+def unmarshal_ListIpsResponse(data: Any) -> ListIpsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'CreatePrivateNICResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListIpsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("private_nic")
-    args["private_nic"] = unmarshal_PrivateNIC(field) if field is not None else None
+    field = data.get("ips", None)
+    args["ips"] = [unmarshal_Ip(v) for v in field] if field is not None else None
 
-    return CreatePrivateNICResponse(**args)
+    field = data.get("total_count", None)
+    args["total_count"] = field
+
+    return ListIpsResponse(**args)
 
 
-def unmarshal_CreateSecurityGroupResponse(data: Any) -> CreateSecurityGroupResponse:
+def unmarshal_ListLbPrivateNetworksResponse(data: Any) -> ListLbPrivateNetworksResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'CreateSecurityGroupResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListLbPrivateNetworksResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("security_group")
-    args["security_group"] = (
-        unmarshal_SecurityGroup(field) if field is not None else None
+    field = data.get("private_network", None)
+    args["private_network"] = (
+        [unmarshal_PrivateNetwork(v) for v in field] if field is not None else None
     )
 
-    return CreateSecurityGroupResponse(**args)
+    field = data.get("total_count", None)
+    args["total_count"] = field
+
+    return ListLbPrivateNetworksResponse(**args)
 
 
-def unmarshal_CreateSecurityGroupRuleResponse(
-    data: Any,
-) -> CreateSecurityGroupRuleResponse:
+def unmarshal_ListLbTypesResponse(data: Any) -> ListLbTypesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'CreateSecurityGroupRuleResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListLbTypesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("rule")
-    args["rule"] = unmarshal_SecurityGroupRule(field) if field is not None else None
+    field = data.get("lb_types", None)
+    args["lb_types"] = (
+        [unmarshal_LbType(v) for v in field] if field is not None else None
+    )
 
-    return CreateSecurityGroupRuleResponse(**args)
+    field = data.get("total_count", None)
+    args["total_count"] = field
 
+    return ListLbTypesResponse(**args)
 
-def unmarshal_CreateServerResponse(data: Any) -> CreateServerResponse:
+
+def unmarshal_ListLbsResponse(data: Any) -> ListLbsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'CreateServerResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListLbsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("server")
-    args["server"] = unmarshal_Server(field) if field is not None else None
+    field = data.get("lbs", None)
+    args["lbs"] = [unmarshal_Lb(v) for v in field] if field is not None else None
+
+    field = data.get("total_count", None)
+    args["total_count"] = field
 
-    return CreateServerResponse(**args)
+    return ListLbsResponse(**args)
 
 
-def unmarshal_CreateSnapshotResponse(data: Any) -> CreateSnapshotResponse:
+def unmarshal_ListRoutesResponse(data: Any) -> ListRoutesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'CreateSnapshotResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListRoutesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("snapshot")
-    args["snapshot"] = unmarshal_Snapshot(field) if field is not None else None
+    field = data.get("routes", None)
+    args["routes"] = [unmarshal_Route(v) for v in field] if field is not None else None
 
-    field = data.get("task")
-    args["task"] = unmarshal_Task(field) if field is not None else None
+    field = data.get("total_count", None)
+    args["total_count"] = field
 
-    return CreateSnapshotResponse(**args)
+    return ListRoutesResponse(**args)
 
 
-def unmarshal_CreateVolumeResponse(data: Any) -> CreateVolumeResponse:
+def unmarshal_ListSubscriberResponse(data: Any) -> ListSubscriberResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'CreateVolumeResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListSubscriberResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("volume")
-    args["volume"] = unmarshal_Volume(field) if field is not None else None
+    field = data.get("subscribers", None)
+    args["subscribers"] = (
+        [unmarshal_Subscriber(v) for v in field] if field is not None else None
+    )
+
+    field = data.get("total_count", None)
+    args["total_count"] = field
 
-    return CreateVolumeResponse(**args)
+    return ListSubscriberResponse(**args)
 
 
-def unmarshal_ExportSnapshotResponse(data: Any) -> ExportSnapshotResponse:
+def unmarshal_SetAclsResponse(data: Any) -> SetAclsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ExportSnapshotResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'SetAclsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("task")
-    args["task"] = unmarshal_Task(field) if field is not None else None
+    field = data.get("acls", None)
+    args["acls"] = [unmarshal_Acl(v) for v in field] if field is not None else None
 
-    return ExportSnapshotResponse(**args)
+    field = data.get("total_count", None)
+    args["total_count"] = field
 
+    return SetAclsResponse(**args)
 
-def unmarshal_GetBootscriptResponse(data: Any) -> GetBootscriptResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'GetBootscriptResponse' failed as data isn't a dictionary."
-        )
 
-    args: Dict[str, Any] = {}
+def marshal_AclActionRedirect(
+    request: AclActionRedirect,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    field = data.get("bootscript")
-    args["bootscript"] = unmarshal_Bootscript(field) if field is not None else None
+    if request.code is not None:
+        output["code"] = request.code
 
-    return GetBootscriptResponse(**args)
+    if request.target is not None:
+        output["target"] = request.target
 
+    if request.type_ is not None:
+        output["type"] = AclActionRedirectRedirectType(request.type_)
 
-def unmarshal_GetDashboardResponse(data: Any) -> GetDashboardResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'GetDashboardResponse' failed as data isn't a dictionary."
-        )
+    return output
 
-    args: Dict[str, Any] = {}
 
-    field = data.get("dashboard")
-    args["dashboard"] = unmarshal_Dashboard(field) if field is not None else None
+def marshal_AclAction(
+    request: AclAction,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    return GetDashboardResponse(**args)
+    if request.redirect is not None:
+        output["redirect"] = marshal_AclActionRedirect(request.redirect, defaults)
 
+    if request.type_ is not None:
+        output["type"] = AclActionType(request.type_)
 
-def unmarshal_GetImageResponse(data: Any) -> GetImageResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'GetImageResponse' failed as data isn't a dictionary."
-        )
+    return output
 
-    args: Dict[str, Any] = {}
 
-    field = data.get("image")
-    args["image"] = unmarshal_Image(field) if field is not None else None
+def marshal_AclMatch(
+    request: AclMatch,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    return GetImageResponse(**args)
+    if request.http_filter is not None:
+        output["http_filter"] = AclHttpFilter(request.http_filter)
 
+    if request.http_filter_option is not None:
+        output["http_filter_option"] = request.http_filter_option
 
-def unmarshal_GetIpResponse(data: Any) -> GetIpResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'GetIpResponse' failed as data isn't a dictionary."
-        )
+    if request.http_filter_value is not None:
+        output["http_filter_value"] = request.http_filter_value
 
-    args: Dict[str, Any] = {}
+    if request.invert is not None:
+        output["invert"] = request.invert
 
-    field = data.get("ip")
-    args["ip"] = unmarshal_Ip(field) if field is not None else None
+    if request.ip_subnet is not None:
+        output["ip_subnet"] = request.ip_subnet
 
-    return GetIpResponse(**args)
+    return output
 
 
-def unmarshal_GetPlacementGroupResponse(data: Any) -> GetPlacementGroupResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'GetPlacementGroupResponse' failed as data isn't a dictionary."
-        )
+def marshal_HealthCheckHttpConfig(
+    request: HealthCheckHttpConfig,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    args: Dict[str, Any] = {}
+    if request.code is not None:
+        output["code"] = request.code
 
-    field = data.get("placement_group")
-    args["placement_group"] = (
-        unmarshal_PlacementGroup(field) if field is not None else None
-    )
+    if request.host_header is not None:
+        output["host_header"] = request.host_header
 
-    return GetPlacementGroupResponse(**args)
+    if request.method is not None:
+        output["method"] = request.method
 
+    if request.uri is not None:
+        output["uri"] = request.uri
 
-def unmarshal_GetPlacementGroupServersResponse(
-    data: Any,
-) -> GetPlacementGroupServersResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'GetPlacementGroupServersResponse' failed as data isn't a dictionary."
-        )
+    return output
 
-    args: Dict[str, Any] = {}
 
-    field = data.get("servers")
-    args["servers"] = [unmarshal_PlacementGroupServer(v) for v in data["servers"]]
+def marshal_HealthCheckHttpsConfig(
+    request: HealthCheckHttpsConfig,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    return GetPlacementGroupServersResponse(**args)
+    if request.code is not None:
+        output["code"] = request.code
 
+    if request.host_header is not None:
+        output["host_header"] = request.host_header
 
-def unmarshal_GetPrivateNICResponse(data: Any) -> GetPrivateNICResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'GetPrivateNICResponse' failed as data isn't a dictionary."
-        )
+    if request.method is not None:
+        output["method"] = request.method
 
-    args: Dict[str, Any] = {}
+    if request.sni is not None:
+        output["sni"] = request.sni
 
-    field = data.get("private_nic")
-    args["private_nic"] = unmarshal_PrivateNIC(field) if field is not None else None
+    if request.uri is not None:
+        output["uri"] = request.uri
 
-    return GetPrivateNICResponse(**args)
+    return output
 
 
-def unmarshal_GetSecurityGroupResponse(data: Any) -> GetSecurityGroupResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'GetSecurityGroupResponse' failed as data isn't a dictionary."
-        )
+def marshal_HealthCheckLdapConfig(
+    request: HealthCheckLdapConfig,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    args: Dict[str, Any] = {}
+    return output
 
-    field = data.get("security_group")
-    args["security_group"] = (
-        unmarshal_SecurityGroup(field) if field is not None else None
-    )
 
-    return GetSecurityGroupResponse(**args)
+def marshal_HealthCheckMysqlConfig(
+    request: HealthCheckMysqlConfig,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
+    if request.user is not None:
+        output["user"] = request.user
 
-def unmarshal_GetSecurityGroupRuleResponse(data: Any) -> GetSecurityGroupRuleResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'GetSecurityGroupRuleResponse' failed as data isn't a dictionary."
-        )
+    return output
 
-    args: Dict[str, Any] = {}
 
-    field = data.get("rule")
-    args["rule"] = unmarshal_SecurityGroupRule(field) if field is not None else None
+def marshal_HealthCheckPgsqlConfig(
+    request: HealthCheckPgsqlConfig,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    return GetSecurityGroupRuleResponse(**args)
+    if request.user is not None:
+        output["user"] = request.user
 
+    return output
 
-def unmarshal_GetServerResponse(data: Any) -> GetServerResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'GetServerResponse' failed as data isn't a dictionary."
-        )
 
-    args: Dict[str, Any] = {}
+def marshal_HealthCheckRedisConfig(
+    request: HealthCheckRedisConfig,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    field = data.get("server")
-    args["server"] = unmarshal_Server(field) if field is not None else None
+    return output
 
-    return GetServerResponse(**args)
 
+def marshal_HealthCheckTcpConfig(
+    request: HealthCheckTcpConfig,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-def unmarshal_GetServerTypesAvailabilityResponse(
-    data: Any,
-) -> GetServerTypesAvailabilityResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'GetServerTypesAvailabilityResponse' failed as data isn't a dictionary."
-        )
+    return output
 
-    args: Dict[str, Any] = {}
 
-    field = data.get("servers")
-    args["servers"] = {
-        k: unmarshal_GetServerTypesAvailabilityResponseAvailability(v)
-        for k, v in data["servers"].items()
-    }
+def marshal_AclSpec(
+    request: AclSpec,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    return GetServerTypesAvailabilityResponse(**args)
+    if request.action is not None:
+        output["action"] = marshal_AclAction(request.action, defaults)
 
+    if request.description is not None:
+        output["description"] = request.description
 
-def unmarshal_GetSnapshotResponse(data: Any) -> GetSnapshotResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'GetSnapshotResponse' failed as data isn't a dictionary."
-        )
+    if request.index is not None:
+        output["index"] = request.index
 
-    args: Dict[str, Any] = {}
+    if request.match is not None:
+        output["match"] = marshal_AclMatch(request.match, defaults)
 
-    field = data.get("snapshot")
-    args["snapshot"] = unmarshal_Snapshot(field) if field is not None else None
+    if request.name is not None:
+        output["name"] = request.name
 
-    return GetSnapshotResponse(**args)
+    return output
 
 
-def unmarshal_GetVolumeResponse(data: Any) -> GetVolumeResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'GetVolumeResponse' failed as data isn't a dictionary."
-        )
+def marshal_CreateCertificateRequestCustomCertificate(
+    request: CreateCertificateRequestCustomCertificate,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    args: Dict[str, Any] = {}
+    if request.certificate_chain is not None:
+        output["certificate_chain"] = request.certificate_chain
 
-    field = data.get("volume")
-    args["volume"] = unmarshal_Volume(field) if field is not None else None
+    return output
 
-    return GetVolumeResponse(**args)
 
+def marshal_CreateCertificateRequestLetsencryptConfig(
+    request: CreateCertificateRequestLetsencryptConfig,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-def unmarshal_ListBootscriptsResponse(data: Any) -> ListBootscriptsResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ListBootscriptsResponse' failed as data isn't a dictionary."
-        )
+    if request.common_name is not None:
+        output["common_name"] = request.common_name
 
-    args: Dict[str, Any] = {}
+    if request.subject_alternative_name is not None:
+        output["subject_alternative_name"] = request.subject_alternative_name
 
-    field = data.get("bootscripts")
-    args["bootscripts"] = [unmarshal_Bootscript(v) for v in data["bootscripts"]]
+    return output
 
-    field = data.get("total_count")
-    args["total_count"] = field
 
-    return ListBootscriptsResponse(**args)
+def marshal_HealthCheck(
+    request: HealthCheck,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
+            [
+                OneOfPossibility(
+                    "tcp_config",
+                    marshal_HealthCheckTcpConfig(request.tcp_config, defaults)
+                    if request.tcp_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "mysql_config",
+                    marshal_HealthCheckMysqlConfig(request.mysql_config, defaults)
+                    if request.mysql_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "pgsql_config",
+                    marshal_HealthCheckPgsqlConfig(request.pgsql_config, defaults)
+                    if request.pgsql_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "ldap_config",
+                    marshal_HealthCheckLdapConfig(request.ldap_config, defaults)
+                    if request.ldap_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "redis_config",
+                    marshal_HealthCheckRedisConfig(request.redis_config, defaults)
+                    if request.redis_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "http_config",
+                    marshal_HealthCheckHttpConfig(request.http_config, defaults)
+                    if request.http_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "https_config",
+                    marshal_HealthCheckHttpsConfig(request.https_config, defaults)
+                    if request.https_config is not None
+                    else None,
+                ),
+            ]
+        ),
+    )
 
+    if request.check_delay is not None:
+        output["check_delay"] = request.check_delay
 
-def unmarshal_ListImagesResponse(data: Any) -> ListImagesResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ListImagesResponse' failed as data isn't a dictionary."
-        )
+    if request.check_max_retries is not None:
+        output["check_max_retries"] = request.check_max_retries
 
-    args: Dict[str, Any] = {}
+    if request.check_send_proxy is not None:
+        output["check_send_proxy"] = request.check_send_proxy
 
-    field = data.get("images")
-    args["images"] = [unmarshal_Image(v) for v in data["images"]]
+    if request.check_timeout is not None:
+        output["check_timeout"] = request.check_timeout
 
-    field = data.get("total_count")
-    args["total_count"] = field
+    if request.port is not None:
+        output["port"] = request.port
 
-    return ListImagesResponse(**args)
+    if request.transient_check_delay is not None:
+        output["transient_check_delay"] = request.transient_check_delay
 
+    return output
 
-def unmarshal_ListIpsResponse(data: Any) -> ListIpsResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ListIpsResponse' failed as data isn't a dictionary."
-        )
 
-    args: Dict[str, Any] = {}
+def marshal_PrivateNetworkDHCPConfig(
+    request: PrivateNetworkDHCPConfig,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    field = data.get("ips")
-    args["ips"] = [unmarshal_Ip(v) for v in data["ips"]]
+    if request.ip_id is not None:
+        output["ip_id"] = request.ip_id
 
-    field = data.get("total_count")
-    args["total_count"] = field
+    return output
 
-    return ListIpsResponse(**args)
 
+def marshal_PrivateNetworkIpamConfig(
+    request: PrivateNetworkIpamConfig,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-def unmarshal_ListPlacementGroupsResponse(data: Any) -> ListPlacementGroupsResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ListPlacementGroupsResponse' failed as data isn't a dictionary."
-        )
+    return output
 
-    args: Dict[str, Any] = {}
 
-    field = data.get("placement_groups")
-    args["placement_groups"] = [
-        unmarshal_PlacementGroup(v) for v in data["placement_groups"]
-    ]
+def marshal_PrivateNetworkStaticConfig(
+    request: PrivateNetworkStaticConfig,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    field = data.get("total_count")
-    args["total_count"] = field
+    if request.ip_address is not None:
+        output["ip_address"] = request.ip_address
 
-    return ListPlacementGroupsResponse(**args)
+    return output
 
 
-def unmarshal_ListPrivateNICsResponse(data: Any) -> ListPrivateNICsResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ListPrivateNICsResponse' failed as data isn't a dictionary."
-        )
+def marshal_RouteMatch(
+    request: RouteMatch,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
+            [
+                OneOfPossibility(
+                    "sni", request.sni if request.sni is not None else None
+                ),
+                OneOfPossibility(
+                    "host_header",
+                    request.host_header if request.host_header is not None else None,
+                ),
+            ]
+        ),
+    )
 
-    args: Dict[str, Any] = {}
+    return output
 
-    field = data.get("private_nics")
-    args["private_nics"] = [unmarshal_PrivateNIC(v) for v in data["private_nics"]]
 
-    field = data.get("total_count")
-    args["total_count"] = field
+def marshal_SubscriberEmailConfig(
+    request: SubscriberEmailConfig,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    return ListPrivateNICsResponse(**args)
+    if request.email is not None:
+        output["email"] = request.email
 
+    return output
 
-def unmarshal_ListSecurityGroupRulesResponse(
-    data: Any,
-) -> ListSecurityGroupRulesResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ListSecurityGroupRulesResponse' failed as data isn't a dictionary."
-        )
 
-    args: Dict[str, Any] = {}
+def marshal_SubscriberWebhookConfig(
+    request: SubscriberWebhookConfig,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    field = data.get("rules")
-    args["rules"] = [unmarshal_SecurityGroupRule(v) for v in data["rules"]]
+    if request.uri is not None:
+        output["uri"] = request.uri
 
-    field = data.get("total_count")
-    args["total_count"] = field
+    return output
 
-    return ListSecurityGroupRulesResponse(**args)
 
+def marshal_AddBackendServersRequest(
+    request: AddBackendServersRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-def unmarshal_ListSecurityGroupsResponse(data: Any) -> ListSecurityGroupsResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ListSecurityGroupsResponse' failed as data isn't a dictionary."
-        )
+    if request.server_ip is not None:
+        output["server_ip"] = request.server_ip
 
-    args: Dict[str, Any] = {}
+    return output
 
-    field = data.get("security_groups")
-    args["security_groups"] = [
-        unmarshal_SecurityGroup(v) for v in data["security_groups"]
-    ]
 
-    field = data.get("total_count")
-    args["total_count"] = field
+def marshal_AttachPrivateNetworkRequest(
+    request: AttachPrivateNetworkRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
+            [
+                OneOfPossibility(
+                    "static_config",
+                    marshal_PrivateNetworkStaticConfig(request.static_config, defaults)
+                    if request.static_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "dhcp_config",
+                    marshal_PrivateNetworkDHCPConfig(request.dhcp_config, defaults)
+                    if request.dhcp_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "ipam_config",
+                    marshal_PrivateNetworkIpamConfig(request.ipam_config, defaults)
+                    if request.ipam_config is not None
+                    else None,
+                ),
+            ]
+        ),
+    )
 
-    return ListSecurityGroupsResponse(**args)
+    return output
 
 
-def unmarshal_ListServerActionsResponse(data: Any) -> ListServerActionsResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ListServerActionsResponse' failed as data isn't a dictionary."
-        )
+def marshal_CreateAclRequest(
+    request: CreateAclRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    args: Dict[str, Any] = {}
+    if request.action is not None:
+        output["action"] = marshal_AclAction(request.action, defaults)
 
-    field = data.get("actions")
-    args["actions"] = field
+    if request.description is not None:
+        output["description"] = request.description
 
-    return ListServerActionsResponse(**args)
+    if request.index is not None:
+        output["index"] = request.index
 
+    if request.match is not None:
+        output["match"] = marshal_AclMatch(request.match, defaults)
 
-def unmarshal_ListServerUserDataResponse(data: Any) -> ListServerUserDataResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ListServerUserDataResponse' failed as data isn't a dictionary."
-        )
+    if request.name is not None:
+        output["name"] = request.name
 
-    args: Dict[str, Any] = {}
+    return output
 
-    field = data.get("user_data")
-    args["user_data"] = field
 
-    return ListServerUserDataResponse(**args)
+def marshal_CreateBackendRequest(
+    request: CreateBackendRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
+    if request.failover_host is not None:
+        output["failover_host"] = request.failover_host
 
-def unmarshal_ListServersResponse(data: Any) -> ListServersResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ListServersResponse' failed as data isn't a dictionary."
+    if request.forward_port is not None:
+        output["forward_port"] = request.forward_port
+
+    if request.forward_port_algorithm is not None:
+        output["forward_port_algorithm"] = ForwardPortAlgorithm(
+            request.forward_port_algorithm
         )
 
-    args: Dict[str, Any] = {}
+    if request.forward_protocol is not None:
+        output["forward_protocol"] = Protocol(request.forward_protocol)
 
-    field = data.get("servers")
-    args["servers"] = [unmarshal_Server(v) for v in data["servers"]]
+    if request.health_check is not None:
+        output["health_check"] = marshal_HealthCheck(request.health_check, defaults)
 
-    field = data.get("total_count")
-    args["total_count"] = field
+    if request.ignore_ssl_server_verify is not None:
+        output["ignore_ssl_server_verify"] = request.ignore_ssl_server_verify
 
-    return ListServersResponse(**args)
+    if request.max_connections is not None:
+        output["max_connections"] = request.max_connections
 
+    if request.max_retries is not None:
+        output["max_retries"] = request.max_retries
 
-def unmarshal_ListServersTypesResponse(data: Any) -> ListServersTypesResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ListServersTypesResponse' failed as data isn't a dictionary."
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.on_marked_down_action is not None:
+        output["on_marked_down_action"] = OnMarkedDownAction(
+            request.on_marked_down_action
         )
 
-    args: Dict[str, Any] = {}
+    if request.proxy_protocol is not None:
+        output["proxy_protocol"] = ProxyProtocol(request.proxy_protocol)
 
-    field = data.get("servers")
-    args["servers"] = {k: unmarshal_ServerType(v) for k, v in data["servers"].items()}
+    if request.redispatch_attempt_count is not None:
+        output["redispatch_attempt_count"] = request.redispatch_attempt_count
 
-    field = data.get("total_count")
-    args["total_count"] = field
+    if request.send_proxy_v2 is not None:
+        output["send_proxy_v2"] = request.send_proxy_v2
 
-    return ListServersTypesResponse(**args)
+    if request.server_ip is not None:
+        output["server_ip"] = request.server_ip
 
+    if request.ssl_bridging is not None:
+        output["ssl_bridging"] = request.ssl_bridging
 
-def unmarshal_ListSnapshotsResponse(data: Any) -> ListSnapshotsResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ListSnapshotsResponse' failed as data isn't a dictionary."
-        )
+    if request.sticky_sessions is not None:
+        output["sticky_sessions"] = StickySessionsType(request.sticky_sessions)
 
-    args: Dict[str, Any] = {}
+    if request.sticky_sessions_cookie_name is not None:
+        output["sticky_sessions_cookie_name"] = request.sticky_sessions_cookie_name
 
-    field = data.get("snapshots")
-    args["snapshots"] = [unmarshal_Snapshot(v) for v in data["snapshots"]]
+    if request.timeout_connect is not None:
+        output["timeout_connect"] = request.timeout_connect
 
-    field = data.get("total_count")
-    args["total_count"] = field
+    if request.timeout_queue is not None:
+        output["timeout_queue"] = request.timeout_queue
 
-    return ListSnapshotsResponse(**args)
+    if request.timeout_server is not None:
+        output["timeout_server"] = request.timeout_server
 
+    if request.timeout_tunnel is not None:
+        output["timeout_tunnel"] = request.timeout_tunnel
 
-def unmarshal_ListVolumesResponse(data: Any) -> ListVolumesResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ListVolumesResponse' failed as data isn't a dictionary."
-        )
+    return output
 
-    args: Dict[str, Any] = {}
 
-    field = data.get("total_count")
-    args["total_count"] = field
+def marshal_CreateCertificateRequest(
+    request: CreateCertificateRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
+            [
+                OneOfPossibility(
+                    "letsencrypt",
+                    marshal_CreateCertificateRequestLetsencryptConfig(
+                        request.letsencrypt, defaults
+                    )
+                    if request.letsencrypt is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "custom_certificate",
+                    marshal_CreateCertificateRequestCustomCertificate(
+                        request.custom_certificate, defaults
+                    )
+                    if request.custom_certificate is not None
+                    else None,
+                ),
+            ]
+        ),
+    )
 
-    field = data.get("volumes")
-    args["volumes"] = [unmarshal_Volume(v) for v in data["volumes"]]
+    if request.name is not None:
+        output["name"] = request.name
 
-    return ListVolumesResponse(**args)
+    return output
 
 
-def unmarshal_ListVolumesTypesResponse(data: Any) -> ListVolumesTypesResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ListVolumesTypesResponse' failed as data isn't a dictionary."
-        )
+def marshal_CreateFrontendRequest(
+    request: CreateFrontendRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    args: Dict[str, Any] = {}
+    if request.backend_id is not None:
+        output["backend_id"] = request.backend_id
 
-    field = data.get("total_count")
-    args["total_count"] = field
+    if request.certificate_id is not None:
+        output["certificate_id"] = request.certificate_id
 
-    field = data.get("volumes")
-    args["volumes"] = {k: unmarshal_VolumeType(v) for k, v in data["volumes"].items()}
+    if request.certificate_ids is not None:
+        output["certificate_ids"] = request.certificate_ids
 
-    return ListVolumesTypesResponse(**args)
+    if request.enable_http3 is not None:
+        output["enable_http3"] = request.enable_http3
 
+    if request.inbound_port is not None:
+        output["inbound_port"] = request.inbound_port
 
-def unmarshal_ServerActionResponse(data: Any) -> ServerActionResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ServerActionResponse' failed as data isn't a dictionary."
-        )
+    if request.name is not None:
+        output["name"] = request.name
 
-    args: Dict[str, Any] = {}
+    if request.timeout_client is not None:
+        output["timeout_client"] = request.timeout_client
 
-    field = data.get("task")
-    args["task"] = unmarshal_Task(field) if field is not None else None
+    return output
 
-    return ServerActionResponse(**args)
 
+def marshal_CreateIpRequest(
+    request: CreateIpRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
+            [
+                OneOfPossibility(
+                    "project_id",
+                    request.project_id or defaults.default_project_id
+                    if request.project_id is not None
+                    else None,
+                    defaults.default_project_id,
+                ),
+                OneOfPossibility(
+                    "organization_id",
+                    request.organization_id or defaults.default_organization_id
+                    if request.organization_id is not None
+                    else None,
+                    defaults.default_organization_id,
+                ),
+            ]
+        ),
+    )
 
-def unmarshal_SetPlacementGroupResponse(data: Any) -> SetPlacementGroupResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'SetPlacementGroupResponse' failed as data isn't a dictionary."
-        )
+    if request.reverse is not None:
+        output["reverse"] = request.reverse
 
-    args: Dict[str, Any] = {}
+    return output
 
-    field = data.get("placement_group")
-    args["placement_group"] = (
-        unmarshal_PlacementGroup(field) if field is not None else None
-    )
 
-    return SetPlacementGroupResponse(**args)
+def marshal_CreateLbRequest(
+    request: CreateLbRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
+            [
+                OneOfPossibility(
+                    "project_id",
+                    request.project_id or defaults.default_project_id
+                    if request.project_id is not None
+                    else None,
+                    defaults.default_project_id,
+                ),
+                OneOfPossibility(
+                    "organization_id",
+                    request.organization_id or defaults.default_organization_id
+                    if request.organization_id is not None
+                    else None,
+                    defaults.default_organization_id,
+                ),
+            ]
+        ),
+    )
 
+    if request.assign_flexible_ip is not None:
+        output["assign_flexible_ip"] = request.assign_flexible_ip
 
-def unmarshal_SetPlacementGroupServersResponse(
-    data: Any,
-) -> SetPlacementGroupServersResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'SetPlacementGroupServersResponse' failed as data isn't a dictionary."
-        )
+    if request.description is not None:
+        output["description"] = request.description
 
-    args: Dict[str, Any] = {}
+    if request.ip_id is not None:
+        output["ip_id"] = request.ip_id
 
-    field = data.get("servers")
-    args["servers"] = [unmarshal_PlacementGroupServer(v) for v in data["servers"]]
+    if request.name is not None:
+        output["name"] = request.name
 
-    return SetPlacementGroupServersResponse(**args)
+    if request.ssl_compatibility_level is not None:
+        output["ssl_compatibility_level"] = SSLCompatibilityLevel(
+            request.ssl_compatibility_level
+        )
 
+    if request.tags is not None:
+        output["tags"] = request.tags
 
-def unmarshal_SetSecurityGroupRulesResponse(data: Any) -> SetSecurityGroupRulesResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'SetSecurityGroupRulesResponse' failed as data isn't a dictionary."
-        )
+    if request.type_ is not None:
+        output["type"] = request.type_
 
-    args: Dict[str, Any] = {}
+    return output
 
-    field = data.get("rules")
-    args["rules"] = [unmarshal_SecurityGroupRule(v) for v in data["rules"]]
 
-    return SetSecurityGroupRulesResponse(**args)
+def marshal_CreateRouteRequest(
+    request: CreateRouteRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
+    if request.backend_id is not None:
+        output["backend_id"] = request.backend_id
 
-def unmarshal_UpdateIpResponse(data: Any) -> UpdateIpResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'UpdateIpResponse' failed as data isn't a dictionary."
-        )
+    if request.frontend_id is not None:
+        output["frontend_id"] = request.frontend_id
 
-    args: Dict[str, Any] = {}
+    if request.match is not None:
+        output["match"] = marshal_RouteMatch(request.match, defaults)
 
-    field = data.get("ip")
-    args["ip"] = unmarshal_Ip(field) if field is not None else None
+    return output
 
-    return UpdateIpResponse(**args)
 
+def marshal_CreateSubscriberRequest(
+    request: CreateSubscriberRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
+            [
+                OneOfPossibility(
+                    "project_id",
+                    request.project_id or defaults.default_project_id
+                    if request.project_id is not None
+                    else None,
+                    defaults.default_project_id,
+                ),
+                OneOfPossibility(
+                    "organization_id",
+                    request.organization_id or defaults.default_organization_id
+                    if request.organization_id is not None
+                    else None,
+                    defaults.default_organization_id,
+                ),
+            ]
+        ),
+    )
+    output.update(
+        resolve_one_of(
+            [
+                OneOfPossibility(
+                    "email_config",
+                    marshal_SubscriberEmailConfig(request.email_config, defaults)
+                    if request.email_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "webhook_config",
+                    marshal_SubscriberWebhookConfig(request.webhook_config, defaults)
+                    if request.webhook_config is not None
+                    else None,
+                ),
+            ]
+        ),
+    )
 
-def unmarshal_UpdatePlacementGroupResponse(data: Any) -> UpdatePlacementGroupResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'UpdatePlacementGroupResponse' failed as data isn't a dictionary."
-        )
+    if request.name is not None:
+        output["name"] = request.name
 
-    args: Dict[str, Any] = {}
+    return output
 
-    field = data.get("placement_group")
-    args["placement_group"] = (
-        unmarshal_PlacementGroup(field) if field is not None else None
-    )
 
-    return UpdatePlacementGroupResponse(**args)
+def marshal_MigrateLbRequest(
+    request: MigrateLbRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
+    if request.type_ is not None:
+        output["type"] = request.type_
 
-def unmarshal_UpdatePlacementGroupServersResponse(
-    data: Any,
-) -> UpdatePlacementGroupServersResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'UpdatePlacementGroupServersResponse' failed as data isn't a dictionary."
-        )
+    return output
 
-    args: Dict[str, Any] = {}
 
-    field = data.get("servers")
-    args["servers"] = [unmarshal_PlacementGroupServer(v) for v in data["servers"]]
+def marshal_RemoveBackendServersRequest(
+    request: RemoveBackendServersRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    return UpdatePlacementGroupServersResponse(**args)
+    if request.server_ip is not None:
+        output["server_ip"] = request.server_ip
 
+    return output
 
-def unmarshal_UpdateServerResponse(data: Any) -> UpdateServerResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'UpdateServerResponse' failed as data isn't a dictionary."
-        )
 
-    args: Dict[str, Any] = {}
+def marshal_SetBackendServersRequest(
+    request: SetBackendServersRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    field = data.get("server")
-    args["server"] = unmarshal_Server(field) if field is not None else None
+    if request.server_ip is not None:
+        output["server_ip"] = request.server_ip
 
-    return UpdateServerResponse(**args)
+    return output
 
 
-def unmarshal_UpdateVolumeResponse(data: Any) -> UpdateVolumeResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'UpdateVolumeResponse' failed as data isn't a dictionary."
-        )
+def marshal_SubscribeToLbRequest(
+    request: SubscribeToLbRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    args: Dict[str, Any] = {}
+    if request.subscriber_id is not None:
+        output["subscriber_id"] = request.subscriber_id
 
-    field = data.get("volume")
-    args["volume"] = unmarshal_Volume(field) if field is not None else None
+    return output
 
-    return UpdateVolumeResponse(**args)
 
+def marshal_UpdateAclRequest(
+    request: UpdateAclRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-def unmarshal__SetImageResponse(data: Any) -> _SetImageResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type '_SetImageResponse' failed as data isn't a dictionary."
-        )
+    if request.action is not None:
+        output["action"] = marshal_AclAction(request.action, defaults)
 
-    args: Dict[str, Any] = {}
+    if request.description is not None:
+        output["description"] = request.description
 
-    field = data.get("image")
-    args["image"] = unmarshal_Image(field) if field is not None else None
+    if request.index is not None:
+        output["index"] = request.index
 
-    return _SetImageResponse(**args)
+    if request.match is not None:
+        output["match"] = marshal_AclMatch(request.match, defaults)
 
+    if request.name is not None:
+        output["name"] = request.name
 
-def unmarshal__SetSecurityGroupResponse(data: Any) -> _SetSecurityGroupResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type '_SetSecurityGroupResponse' failed as data isn't a dictionary."
-        )
+    return output
 
-    args: Dict[str, Any] = {}
 
-    field = data.get("security_group")
-    args["security_group"] = (
-        unmarshal_SecurityGroup(field) if field is not None else None
-    )
+def marshal_UpdateBackendRequest(
+    request: UpdateBackendRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    return _SetSecurityGroupResponse(**args)
+    if request.failover_host is not None:
+        output["failover_host"] = request.failover_host
 
+    if request.forward_port is not None:
+        output["forward_port"] = request.forward_port
 
-def unmarshal__SetSecurityGroupRuleResponse(data: Any) -> _SetSecurityGroupRuleResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type '_SetSecurityGroupRuleResponse' failed as data isn't a dictionary."
+    if request.forward_port_algorithm is not None:
+        output["forward_port_algorithm"] = ForwardPortAlgorithm(
+            request.forward_port_algorithm
         )
 
-    args: Dict[str, Any] = {}
+    if request.forward_protocol is not None:
+        output["forward_protocol"] = Protocol(request.forward_protocol)
 
-    field = data.get("rule")
-    args["rule"] = unmarshal_SecurityGroupRule(field) if field is not None else None
+    if request.ignore_ssl_server_verify is not None:
+        output["ignore_ssl_server_verify"] = request.ignore_ssl_server_verify
 
-    return _SetSecurityGroupRuleResponse(**args)
+    if request.max_connections is not None:
+        output["max_connections"] = request.max_connections
 
+    if request.max_retries is not None:
+        output["max_retries"] = request.max_retries
 
-def unmarshal__SetServerResponse(data: Any) -> _SetServerResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type '_SetServerResponse' failed as data isn't a dictionary."
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.on_marked_down_action is not None:
+        output["on_marked_down_action"] = OnMarkedDownAction(
+            request.on_marked_down_action
         )
 
-    args: Dict[str, Any] = {}
+    if request.proxy_protocol is not None:
+        output["proxy_protocol"] = ProxyProtocol(request.proxy_protocol)
 
-    field = data.get("server")
-    args["server"] = unmarshal_Server(field) if field is not None else None
+    if request.redispatch_attempt_count is not None:
+        output["redispatch_attempt_count"] = request.redispatch_attempt_count
 
-    return _SetServerResponse(**args)
+    if request.send_proxy_v2 is not None:
+        output["send_proxy_v2"] = request.send_proxy_v2
 
+    if request.ssl_bridging is not None:
+        output["ssl_bridging"] = request.ssl_bridging
 
-def unmarshal__SetSnapshotResponse(data: Any) -> _SetSnapshotResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type '_SetSnapshotResponse' failed as data isn't a dictionary."
-        )
+    if request.sticky_sessions is not None:
+        output["sticky_sessions"] = StickySessionsType(request.sticky_sessions)
 
-    args: Dict[str, Any] = {}
+    if request.sticky_sessions_cookie_name is not None:
+        output["sticky_sessions_cookie_name"] = request.sticky_sessions_cookie_name
 
-    field = data.get("snapshot")
-    args["snapshot"] = unmarshal_Snapshot(field) if field is not None else None
+    if request.timeout_connect is not None:
+        output["timeout_connect"] = request.timeout_connect
 
-    return _SetSnapshotResponse(**args)
+    if request.timeout_queue is not None:
+        output["timeout_queue"] = request.timeout_queue
 
+    if request.timeout_server is not None:
+        output["timeout_server"] = request.timeout_server
 
-def marshal_ServerSummary(
-    request: ServerSummary,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "id": request.id,
-        "name": request.name,
-    }
+    if request.timeout_tunnel is not None:
+        output["timeout_tunnel"] = request.timeout_tunnel
+
+    return output
 
 
-def marshal_Bootscript(
-    request: Bootscript,
+def marshal_UpdateCertificateRequest(
+    request: UpdateCertificateRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "arch": Arch(request.arch),
-        "bootcmdargs": request.bootcmdargs,
-        "default": request.default,
-        "dtb": request.dtb,
-        "id": request.id,
-        "initrd": request.initrd,
-        "kernel": request.kernel,
-        "organization": request.organization,
-        "project": request.project,
-        "public": request.public,
-        "title": request.title,
-        "zone": request.zone,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.name is not None:
+        output["name"] = request.name
 
-def marshal_Volume(
-    request: Volume,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "creation_date": request.creation_date,
-        "export_uri": request.export_uri,
-        "id": request.id,
-        "modification_date": request.modification_date,
-        "name": request.name,
-        "organization": request.organization,
-        "project": request.project,
-        "server": marshal_ServerSummary(request.server, defaults)
-        if request.server is not None
-        else None,
-        "size": request.size,
-        "state": VolumeState(request.state),
-        "tags": request.tags,
-        "volume_type": VolumeVolumeType(request.volume_type),
-        "zone": request.zone,
-    }
+    return output
 
 
-def marshal_VolumeSummary(
-    request: VolumeSummary,
+def marshal_UpdateFrontendRequest(
+    request: UpdateFrontendRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "id": request.id,
-        "name": request.name,
-        "size": request.size,
-        "volume_type": VolumeVolumeType(request.volume_type),
-    }
+    output: Dict[str, Any] = {}
 
+    if request.backend_id is not None:
+        output["backend_id"] = request.backend_id
 
-def marshal_Image(
-    request: Image,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "arch": Arch(request.arch),
-        "creation_date": request.creation_date,
-        "default_bootscript": marshal_Bootscript(request.default_bootscript, defaults)
-        if request.default_bootscript is not None
-        else None,
-        "extra_volumes": {
-            k: marshal_Volume(v, defaults) for k, v in request.extra_volumes.items()
-        },
-        "from_server": request.from_server,
-        "id": request.id,
-        "modification_date": request.modification_date,
-        "name": request.name,
-        "organization": request.organization,
-        "project": request.project,
-        "public": request.public,
-        "root_volume": marshal_VolumeSummary(request.root_volume, defaults)
-        if request.root_volume is not None
-        else None,
-        "state": ImageState(request.state),
-        "tags": request.tags,
-        "zone": request.zone,
-    }
+    if request.certificate_id is not None:
+        output["certificate_id"] = request.certificate_id
 
+    if request.certificate_ids is not None:
+        output["certificate_ids"] = request.certificate_ids
 
-def marshal_PlacementGroup(
-    request: PlacementGroup,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "id": request.id,
-        "name": request.name,
-        "organization": request.organization,
-        "policy_mode": PlacementGroupPolicyMode(request.policy_mode),
-        "policy_respected": request.policy_respected,
-        "policy_type": PlacementGroupPolicyType(request.policy_type),
-        "project": request.project,
-        "tags": request.tags,
-        "zone": request.zone,
-    }
+    if request.enable_http3 is not None:
+        output["enable_http3"] = request.enable_http3
 
+    if request.inbound_port is not None:
+        output["inbound_port"] = request.inbound_port
 
-def marshal_PrivateNIC(
-    request: PrivateNIC,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "id": request.id,
-        "mac_address": request.mac_address,
-        "private_network_id": request.private_network_id,
-        "server_id": request.server_id,
-        "state": PrivateNICState(request.state),
-        "tags": request.tags,
-    }
+    if request.name is not None:
+        output["name"] = request.name
 
+    if request.timeout_client is not None:
+        output["timeout_client"] = request.timeout_client
 
-def marshal_SecurityGroupSummary(
-    request: SecurityGroupSummary,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "id": request.id,
-        "name": request.name,
-    }
+    return output
 
 
-def marshal_SecurityGroupTemplate(
-    request: SecurityGroupTemplate,
+def marshal_UpdateHealthCheckRequest(
+    request: UpdateHealthCheckRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "id": request.id,
-        "name": request.name,
-    }
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
+            [
+                OneOfPossibility(
+                    "tcp_config",
+                    marshal_HealthCheckTcpConfig(request.tcp_config, defaults)
+                    if request.tcp_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "mysql_config",
+                    marshal_HealthCheckMysqlConfig(request.mysql_config, defaults)
+                    if request.mysql_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "pgsql_config",
+                    marshal_HealthCheckPgsqlConfig(request.pgsql_config, defaults)
+                    if request.pgsql_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "ldap_config",
+                    marshal_HealthCheckLdapConfig(request.ldap_config, defaults)
+                    if request.ldap_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "redis_config",
+                    marshal_HealthCheckRedisConfig(request.redis_config, defaults)
+                    if request.redis_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "http_config",
+                    marshal_HealthCheckHttpConfig(request.http_config, defaults)
+                    if request.http_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "https_config",
+                    marshal_HealthCheckHttpsConfig(request.https_config, defaults)
+                    if request.https_config is not None
+                    else None,
+                ),
+            ]
+        ),
+    )
 
+    if request.check_delay is not None:
+        output["check_delay"] = request.check_delay
 
-def marshal_ServerActionRequestVolumeBackupTemplate(
-    request: ServerActionRequestVolumeBackupTemplate,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "volume_type": SnapshotVolumeType(request.volume_type),
-    }
+    if request.check_max_retries is not None:
+        output["check_max_retries"] = request.check_max_retries
 
+    if request.check_send_proxy is not None:
+        output["check_send_proxy"] = request.check_send_proxy
 
-def marshal_ServerIp(
-    request: ServerIp,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "address": request.address,
-        "dynamic": request.dynamic,
-        "id": request.id,
-    }
+    if request.check_timeout is not None:
+        output["check_timeout"] = request.check_timeout
 
+    if request.port is not None:
+        output["port"] = request.port
 
-def marshal_ServerIpv6(
-    request: ServerIpv6,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "address": request.address,
-        "gateway": request.gateway,
-        "netmask": request.netmask,
-    }
+    if request.transient_check_delay is not None:
+        output["transient_check_delay"] = request.transient_check_delay
 
+    return output
 
-def marshal_ServerLocation(
-    request: ServerLocation,
+
+def marshal_UpdateIpRequest(
+    request: UpdateIpRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "cluster_id": request.cluster_id,
-        "hypervisor_id": request.hypervisor_id,
-        "node_id": request.node_id,
-        "platform_id": request.platform_id,
-        "zone_id": request.zone_id,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.reverse is not None:
+        output["reverse"] = request.reverse
 
-def marshal_ServerMaintenance(
-    request: ServerMaintenance,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "reason": request.reason,
-    }
+    return output
 
 
-def marshal_SetSecurityGroupRulesRequestRule(
-    request: SetSecurityGroupRulesRequestRule,
+def marshal_UpdateLbRequest(
+    request: UpdateLbRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "action": SecurityGroupRuleAction(request.action),
-        "dest_port_from": request.dest_port_from,
-        "dest_port_to": request.dest_port_to,
-        "direction": SecurityGroupRuleDirection(request.direction),
-        "editable": request.editable,
-        "id": request.id,
-        "ip_range": request.ip_range,
-        "position": request.position,
-        "protocol": SecurityGroupRuleProtocol(request.protocol),
-        "zone": request.zone,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.description is not None:
+        output["description"] = request.description
 
-def marshal_SnapshotBaseVolume(
-    request: SnapshotBaseVolume,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "id": request.id,
-        "name": request.name,
-    }
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.ssl_compatibility_level is not None:
+        output["ssl_compatibility_level"] = SSLCompatibilityLevel(
+            request.ssl_compatibility_level
+        )
+
+    if request.tags is not None:
+        output["tags"] = request.tags
 
+    return output
 
-def marshal_VolumeServerTemplate(
-    request: VolumeServerTemplate,
+
+def marshal_UpdateRouteRequest(
+    request: UpdateRouteRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "base_snapshot": request.base_snapshot,
-        "boot": request.boot,
-        "id": request.id,
-        "name": request.name,
-        "organization": request.organization,
-        "project": request.project,
-        "size": request.size,
-        "volume_type": VolumeVolumeType(request.volume_type),
-    }
+    output: Dict[str, Any] = {}
+
+    if request.backend_id is not None:
+        output["backend_id"] = request.backend_id
+
+    if request.match is not None:
+        output["match"] = marshal_RouteMatch(request.match, defaults)
 
+    return output
 
-def marshal_VolumeTemplate(
-    request: VolumeTemplate,
+
+def marshal_UpdateSubscriberRequest(
+    request: UpdateSubscriberRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
                 OneOfPossibility(
-                    "project", request.project, defaults.default_project_id
+                    "email_config",
+                    marshal_SubscriberEmailConfig(request.email_config, defaults)
+                    if request.email_config is not None
+                    else None,
                 ),
                 OneOfPossibility(
-                    "organization",
-                    request.organization,
-                    defaults.default_organization_id,
+                    "webhook_config",
+                    marshal_SubscriberWebhookConfig(request.webhook_config, defaults)
+                    if request.webhook_config is not None
+                    else None,
                 ),
             ]
         ),
-        "id": request.id,
-        "name": request.name,
-        "size": request.size,
-        "volume_type": VolumeVolumeType(request.volume_type),
-    }
+    )
+
+    if request.name is not None:
+        output["name"] = request.name
 
+    return output
 
-def marshal_CreateImageRequest(
-    request: CreateImageRequest,
+
+def marshal_ZonedApiAddBackendServersRequest(
+    request: ZonedApiAddBackendServersRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
-            [
-                OneOfPossibility(
-                    "project", request.project, defaults.default_project_id
-                ),
-                OneOfPossibility(
-                    "organization",
-                    request.organization,
-                    defaults.default_organization_id,
-                ),
-            ]
-        ),
-        "arch": Arch(request.arch) if request.arch is not None else None,
-        "default_bootscript": request.default_bootscript,
-        "extra_volumes": {
-            k: marshal_VolumeTemplate(v, defaults)
-            for k, v in request.extra_volumes.items()
-        }
-        if request.extra_volumes is not None
-        else None,
-        "name": request.name,
-        "public": request.public,
-        "root_volume": request.root_volume,
-        "tags": request.tags,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.server_ip is not None:
+        output["server_ip"] = request.server_ip
 
-def marshal_CreateIpRequest(
-    request: CreateIpRequest,
+    return output
+
+
+def marshal_ZonedApiAttachPrivateNetworkRequest(
+    request: ZonedApiAttachPrivateNetworkRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
                 OneOfPossibility(
-                    "project", request.project, defaults.default_project_id
+                    "static_config",
+                    marshal_PrivateNetworkStaticConfig(request.static_config, defaults)
+                    if request.static_config is not None
+                    else None,
                 ),
                 OneOfPossibility(
-                    "organization",
-                    request.organization,
-                    defaults.default_organization_id,
+                    "dhcp_config",
+                    marshal_PrivateNetworkDHCPConfig(request.dhcp_config, defaults)
+                    if request.dhcp_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "ipam_config",
+                    marshal_PrivateNetworkIpamConfig(request.ipam_config, defaults)
+                    if request.ipam_config is not None
+                    else None,
                 ),
             ]
         ),
-        "server": request.server,
-        "tags": request.tags,
-    }
+    )
+
+    return output
+
+
+def marshal_ZonedApiCreateAclRequest(
+    request: ZonedApiCreateAclRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.action is not None:
+        output["action"] = marshal_AclAction(request.action, defaults)
 
+    if request.description is not None:
+        output["description"] = request.description
 
-def marshal_CreatePlacementGroupRequest(
-    request: CreatePlacementGroupRequest,
+    if request.index is not None:
+        output["index"] = request.index
+
+    if request.match is not None:
+        output["match"] = marshal_AclMatch(request.match, defaults)
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
+
+
+def marshal_ZonedApiCreateBackendRequest(
+    request: ZonedApiCreateBackendRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+
+    if request.failover_host is not None:
+        output["failover_host"] = request.failover_host
+
+    if request.forward_port is not None:
+        output["forward_port"] = request.forward_port
+
+    if request.forward_port_algorithm is not None:
+        output["forward_port_algorithm"] = ForwardPortAlgorithm(
+            request.forward_port_algorithm
+        )
+
+    if request.forward_protocol is not None:
+        output["forward_protocol"] = Protocol(request.forward_protocol)
+
+    if request.health_check is not None:
+        output["health_check"] = marshal_HealthCheck(request.health_check, defaults)
+
+    if request.ignore_ssl_server_verify is not None:
+        output["ignore_ssl_server_verify"] = request.ignore_ssl_server_verify
+
+    if request.max_connections is not None:
+        output["max_connections"] = request.max_connections
+
+    if request.max_retries is not None:
+        output["max_retries"] = request.max_retries
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.on_marked_down_action is not None:
+        output["on_marked_down_action"] = OnMarkedDownAction(
+            request.on_marked_down_action
+        )
+
+    if request.proxy_protocol is not None:
+        output["proxy_protocol"] = ProxyProtocol(request.proxy_protocol)
+
+    if request.redispatch_attempt_count is not None:
+        output["redispatch_attempt_count"] = request.redispatch_attempt_count
+
+    if request.send_proxy_v2 is not None:
+        output["send_proxy_v2"] = request.send_proxy_v2
+
+    if request.server_ip is not None:
+        output["server_ip"] = request.server_ip
+
+    if request.ssl_bridging is not None:
+        output["ssl_bridging"] = request.ssl_bridging
+
+    if request.sticky_sessions is not None:
+        output["sticky_sessions"] = StickySessionsType(request.sticky_sessions)
+
+    if request.sticky_sessions_cookie_name is not None:
+        output["sticky_sessions_cookie_name"] = request.sticky_sessions_cookie_name
+
+    if request.timeout_connect is not None:
+        output["timeout_connect"] = request.timeout_connect
+
+    if request.timeout_queue is not None:
+        output["timeout_queue"] = request.timeout_queue
+
+    if request.timeout_server is not None:
+        output["timeout_server"] = request.timeout_server
+
+    if request.timeout_tunnel is not None:
+        output["timeout_tunnel"] = request.timeout_tunnel
+
+    return output
+
+
+def marshal_ZonedApiCreateCertificateRequest(
+    request: ZonedApiCreateCertificateRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
                 OneOfPossibility(
-                    "project", request.project, defaults.default_project_id
+                    "letsencrypt",
+                    marshal_CreateCertificateRequestLetsencryptConfig(
+                        request.letsencrypt, defaults
+                    )
+                    if request.letsencrypt is not None
+                    else None,
                 ),
                 OneOfPossibility(
-                    "organization",
-                    request.organization,
-                    defaults.default_organization_id,
+                    "custom_certificate",
+                    marshal_CreateCertificateRequestCustomCertificate(
+                        request.custom_certificate, defaults
+                    )
+                    if request.custom_certificate is not None
+                    else None,
                 ),
             ]
         ),
-        "name": request.name,
-        "policy_mode": PlacementGroupPolicyMode(request.policy_mode),
-        "policy_type": PlacementGroupPolicyType(request.policy_type),
-        "tags": request.tags,
-    }
+    )
+
+    if request.name is not None:
+        output["name"] = request.name
 
+    return output
 
-def marshal_CreatePrivateNICRequest(
-    request: CreatePrivateNICRequest,
+
+def marshal_ZonedApiCreateFrontendRequest(
+    request: ZonedApiCreateFrontendRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "private_network_id": request.private_network_id,
-        "tags": request.tags,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.backend_id is not None:
+        output["backend_id"] = request.backend_id
+
+    if request.certificate_id is not None:
+        output["certificate_id"] = request.certificate_id
+
+    if request.certificate_ids is not None:
+        output["certificate_ids"] = request.certificate_ids
+
+    if request.enable_http3 is not None:
+        output["enable_http3"] = request.enable_http3
 
+    if request.inbound_port is not None:
+        output["inbound_port"] = request.inbound_port
 
-def marshal_CreateSecurityGroupRequest(
-    request: CreateSecurityGroupRequest,
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.timeout_client is not None:
+        output["timeout_client"] = request.timeout_client
+
+    return output
+
+
+def marshal_ZonedApiCreateIpRequest(
+    request: ZonedApiCreateIpRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
-            [
-                OneOfPossibility("organization_default", request.organization_default),
-                OneOfPossibility("project_default", request.project_default),
-            ]
-        ),
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
                 OneOfPossibility(
-                    "project", request.project, defaults.default_project_id
+                    "project_id",
+                    request.project_id or defaults.default_project_id
+                    if request.project_id is not None
+                    else None,
+                    defaults.default_project_id,
                 ),
                 OneOfPossibility(
-                    "organization",
-                    request.organization,
+                    "organization_id",
+                    request.organization_id or defaults.default_organization_id
+                    if request.organization_id is not None
+                    else None,
                     defaults.default_organization_id,
                 ),
             ]
         ),
-        "description": request.description,
-        "enable_default_security": request.enable_default_security,
-        "inbound_default_policy": SecurityGroupPolicy(request.inbound_default_policy),
-        "name": request.name,
-        "outbound_default_policy": SecurityGroupPolicy(request.outbound_default_policy),
-        "stateful": request.stateful,
-        "tags": request.tags,
-    }
-
-
-def marshal_CreateSecurityGroupRuleRequest(
-    request: CreateSecurityGroupRuleRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "action": SecurityGroupRuleAction(request.action)
-        if request.action is not None
-        else None,
-        "dest_port_from": request.dest_port_from,
-        "dest_port_to": request.dest_port_to,
-        "direction": SecurityGroupRuleDirection(request.direction)
-        if request.direction is not None
-        else None,
-        "editable": request.editable,
-        "ip_range": request.ip_range,
-        "position": request.position,
-        "protocol": SecurityGroupRuleProtocol(request.protocol)
-        if request.protocol is not None
-        else None,
-    }
+    )
+
+    if request.reverse is not None:
+        output["reverse"] = request.reverse
+
+    return output
 
 
-def marshal_CreateSnapshotRequest(
-    request: CreateSnapshotRequest,
+def marshal_ZonedApiCreateLbRequest(
+    request: ZonedApiCreateLbRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
                 OneOfPossibility(
-                    "project", request.project, defaults.default_project_id
+                    "project_id",
+                    request.project_id or defaults.default_project_id
+                    if request.project_id is not None
+                    else None,
+                    defaults.default_project_id,
                 ),
                 OneOfPossibility(
-                    "organization",
-                    request.organization,
+                    "organization_id",
+                    request.organization_id or defaults.default_organization_id
+                    if request.organization_id is not None
+                    else None,
                     defaults.default_organization_id,
                 ),
             ]
         ),
-        "bucket": request.bucket,
-        "key": request.key,
-        "name": request.name,
-        "size": request.size,
-        "tags": request.tags,
-        "volume_id": request.volume_id,
-        "volume_type": SnapshotVolumeType(request.volume_type),
-    }
+    )
+
+    if request.assign_flexible_ip is not None:
+        output["assign_flexible_ip"] = request.assign_flexible_ip
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.ip_id is not None:
+        output["ip_id"] = request.ip_id
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.ssl_compatibility_level is not None:
+        output["ssl_compatibility_level"] = SSLCompatibilityLevel(
+            request.ssl_compatibility_level
+        )
+
+    if request.tags is not None:
+        output["tags"] = request.tags
+
+    if request.type_ is not None:
+        output["type"] = request.type_
 
+    return output
 
-def marshal_CreateVolumeRequest(
-    request: CreateVolumeRequest,
+
+def marshal_ZonedApiCreateRouteRequest(
+    request: ZonedApiCreateRouteRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+
+    if request.backend_id is not None:
+        output["backend_id"] = request.backend_id
+
+    if request.frontend_id is not None:
+        output["frontend_id"] = request.frontend_id
+
+    if request.match is not None:
+        output["match"] = marshal_RouteMatch(request.match, defaults)
+
+    return output
+
+
+def marshal_ZonedApiCreateSubscriberRequest(
+    request: ZonedApiCreateSubscriberRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
                 OneOfPossibility(
-                    "project", request.project, defaults.default_project_id
+                    "project_id",
+                    request.project_id or defaults.default_project_id
+                    if request.project_id is not None
+                    else None,
+                    defaults.default_project_id,
                 ),
                 OneOfPossibility(
-                    "organization",
-                    request.organization,
+                    "organization_id",
+                    request.organization_id or defaults.default_organization_id
+                    if request.organization_id is not None
+                    else None,
                     defaults.default_organization_id,
                 ),
             ]
         ),
-        **resolve_one_of(
+    )
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("size", request.size),
-                OneOfPossibility("base_volume", request.base_volume),
-                OneOfPossibility("base_snapshot", request.base_snapshot),
+                OneOfPossibility(
+                    "email_config",
+                    marshal_SubscriberEmailConfig(request.email_config, defaults)
+                    if request.email_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "webhook_config",
+                    marshal_SubscriberWebhookConfig(request.webhook_config, defaults)
+                    if request.webhook_config is not None
+                    else None,
+                ),
             ]
         ),
-        "name": request.name,
-        "tags": request.tags,
-        "volume_type": VolumeVolumeType(request.volume_type),
-    }
+    )
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
 
 
-def marshal_ExportSnapshotRequest(
-    request: ExportSnapshotRequest,
+def marshal_ZonedApiMigrateLbRequest(
+    request: ZonedApiMigrateLbRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "bucket": request.bucket,
-        "key": request.key,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.type_ is not None:
+        output["type"] = request.type_
 
-def marshal_ServerActionRequest(
-    request: ServerActionRequest,
+    return output
+
+
+def marshal_ZonedApiRemoveBackendServersRequest(
+    request: ZonedApiRemoveBackendServersRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "action": ServerAction(request.action),
-        "name": request.name,
-        "volumes": {
-            k: marshal_ServerActionRequestVolumeBackupTemplate(v, defaults)
-            for k, v in request.volumes.items()
-        }
-        if request.volumes is not None
-        else None,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.server_ip is not None:
+        output["server_ip"] = request.server_ip
 
+    return output
 
-def marshal_SetPlacementGroupRequest(
-    request: SetPlacementGroupRequest,
+
+def marshal_ZonedApiSetAclsRequest(
+    request: ZonedApiSetAclsRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "name": request.name,
-        "organization": request.organization or defaults.default_organization_id,
-        "policy_mode": PlacementGroupPolicyMode(request.policy_mode),
-        "policy_type": PlacementGroupPolicyType(request.policy_type),
-        "project": request.project or defaults.default_project_id,
-        "tags": request.tags,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.acls is not None:
+        output["acls"] = [marshal_AclSpec(v, defaults) for v in request.acls]
 
+    return output
 
-def marshal_SetPlacementGroupServersRequest(
-    request: SetPlacementGroupServersRequest,
+
+def marshal_ZonedApiSetBackendServersRequest(
+    request: ZonedApiSetBackendServersRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "servers": request.servers,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.server_ip is not None:
+        output["server_ip"] = request.server_ip
 
+    return output
 
-def marshal_SetSecurityGroupRulesRequest(
-    request: SetSecurityGroupRulesRequest,
+
+def marshal_ZonedApiSubscribeToLbRequest(
+    request: ZonedApiSubscribeToLbRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "rules": [
-            marshal_SetSecurityGroupRulesRequestRule(v, defaults) for v in request.rules
-        ]
-        if request.rules is not None
-        else None,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.subscriber_id is not None:
+        output["subscriber_id"] = request.subscriber_id
 
-def marshal_UpdateIpRequest(
-    request: UpdateIpRequest,
+    return output
+
+
+def marshal_ZonedApiUpdateAclRequest(
+    request: ZonedApiUpdateAclRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.action is not None:
+        output["action"] = marshal_AclAction(request.action, defaults)
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.index is not None:
+        output["index"] = request.index
+
+    if request.match is not None:
+        output["match"] = marshal_AclMatch(request.match, defaults)
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
+
+
+def marshal_ZonedApiUpdateBackendRequest(
+    request: ZonedApiUpdateBackendRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.failover_host is not None:
+        output["failover_host"] = request.failover_host
+
+    if request.forward_port is not None:
+        output["forward_port"] = request.forward_port
+
+    if request.forward_port_algorithm is not None:
+        output["forward_port_algorithm"] = ForwardPortAlgorithm(
+            request.forward_port_algorithm
+        )
+
+    if request.forward_protocol is not None:
+        output["forward_protocol"] = Protocol(request.forward_protocol)
+
+    if request.ignore_ssl_server_verify is not None:
+        output["ignore_ssl_server_verify"] = request.ignore_ssl_server_verify
+
+    if request.max_connections is not None:
+        output["max_connections"] = request.max_connections
+
+    if request.max_retries is not None:
+        output["max_retries"] = request.max_retries
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.on_marked_down_action is not None:
+        output["on_marked_down_action"] = OnMarkedDownAction(
+            request.on_marked_down_action
+        )
+
+    if request.proxy_protocol is not None:
+        output["proxy_protocol"] = ProxyProtocol(request.proxy_protocol)
+
+    if request.redispatch_attempt_count is not None:
+        output["redispatch_attempt_count"] = request.redispatch_attempt_count
+
+    if request.send_proxy_v2 is not None:
+        output["send_proxy_v2"] = request.send_proxy_v2
+
+    if request.ssl_bridging is not None:
+        output["ssl_bridging"] = request.ssl_bridging
+
+    if request.sticky_sessions is not None:
+        output["sticky_sessions"] = StickySessionsType(request.sticky_sessions)
+
+    if request.sticky_sessions_cookie_name is not None:
+        output["sticky_sessions_cookie_name"] = request.sticky_sessions_cookie_name
+
+    if request.timeout_connect is not None:
+        output["timeout_connect"] = request.timeout_connect
+
+    if request.timeout_queue is not None:
+        output["timeout_queue"] = request.timeout_queue
+
+    if request.timeout_server is not None:
+        output["timeout_server"] = request.timeout_server
+
+    if request.timeout_tunnel is not None:
+        output["timeout_tunnel"] = request.timeout_tunnel
+
+    return output
+
+
+def marshal_ZonedApiUpdateCertificateRequest(
+    request: ZonedApiUpdateCertificateRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
+
+
+def marshal_ZonedApiUpdateFrontendRequest(
+    request: ZonedApiUpdateFrontendRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "reverse": request.reverse,
-        "server": request.server,
-        "tags": request.tags,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.backend_id is not None:
+        output["backend_id"] = request.backend_id
+
+    if request.certificate_id is not None:
+        output["certificate_id"] = request.certificate_id
 
+    if request.certificate_ids is not None:
+        output["certificate_ids"] = request.certificate_ids
 
-def marshal_UpdatePlacementGroupRequest(
-    request: UpdatePlacementGroupRequest,
+    if request.enable_http3 is not None:
+        output["enable_http3"] = request.enable_http3
+
+    if request.inbound_port is not None:
+        output["inbound_port"] = request.inbound_port
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.timeout_client is not None:
+        output["timeout_client"] = request.timeout_client
+
+    return output
+
+
+def marshal_ZonedApiUpdateHealthCheckRequest(
+    request: ZonedApiUpdateHealthCheckRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "name": request.name,
-        "policy_mode": PlacementGroupPolicyMode(request.policy_mode)
-        if request.policy_mode is not None
-        else None,
-        "policy_type": PlacementGroupPolicyType(request.policy_type)
-        if request.policy_type is not None
-        else None,
-        "tags": request.tags,
-    }
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
+            [
+                OneOfPossibility(
+                    "tcp_config",
+                    marshal_HealthCheckTcpConfig(request.tcp_config, defaults)
+                    if request.tcp_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "mysql_config",
+                    marshal_HealthCheckMysqlConfig(request.mysql_config, defaults)
+                    if request.mysql_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "pgsql_config",
+                    marshal_HealthCheckPgsqlConfig(request.pgsql_config, defaults)
+                    if request.pgsql_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "ldap_config",
+                    marshal_HealthCheckLdapConfig(request.ldap_config, defaults)
+                    if request.ldap_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "redis_config",
+                    marshal_HealthCheckRedisConfig(request.redis_config, defaults)
+                    if request.redis_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "http_config",
+                    marshal_HealthCheckHttpConfig(request.http_config, defaults)
+                    if request.http_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "https_config",
+                    marshal_HealthCheckHttpsConfig(request.https_config, defaults)
+                    if request.https_config is not None
+                    else None,
+                ),
+            ]
+        ),
+    )
+
+    if request.check_delay is not None:
+        output["check_delay"] = request.check_delay
+
+    if request.check_max_retries is not None:
+        output["check_max_retries"] = request.check_max_retries
+
+    if request.check_send_proxy is not None:
+        output["check_send_proxy"] = request.check_send_proxy
 
+    if request.check_timeout is not None:
+        output["check_timeout"] = request.check_timeout
 
-def marshal_UpdatePlacementGroupServersRequest(
-    request: UpdatePlacementGroupServersRequest,
+    if request.port is not None:
+        output["port"] = request.port
+
+    if request.transient_check_delay is not None:
+        output["transient_check_delay"] = request.transient_check_delay
+
+    return output
+
+
+def marshal_ZonedApiUpdateIpRequest(
+    request: ZonedApiUpdateIpRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "servers": request.servers,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.reverse is not None:
+        output["reverse"] = request.reverse
+
+    return output
 
 
-def marshal_UpdatePrivateNICRequest(
-    request: UpdatePrivateNICRequest,
+def marshal_ZonedApiUpdateLbRequest(
+    request: ZonedApiUpdateLbRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "tags": request.tags,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.description is not None:
+        output["description"] = request.description
 
-def marshal_UpdateVolumeRequest(
-    request: UpdateVolumeRequest,
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.ssl_compatibility_level is not None:
+        output["ssl_compatibility_level"] = SSLCompatibilityLevel(
+            request.ssl_compatibility_level
+        )
+
+    if request.tags is not None:
+        output["tags"] = request.tags
+
+    return output
+
+
+def marshal_ZonedApiUpdateRouteRequest(
+    request: ZonedApiUpdateRouteRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "name": request.name,
-        "size": request.size,
-        "tags": request.tags,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.backend_id is not None:
+        output["backend_id"] = request.backend_id
 
+    if request.match is not None:
+        output["match"] = marshal_RouteMatch(request.match, defaults)
 
-def marshal__CreateServerRequest(
-    request: _CreateServerRequest,
+    return output
+
+
+def marshal_ZonedApiUpdateSubscriberRequest(
+    request: ZonedApiUpdateSubscriberRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
                 OneOfPossibility(
-                    "project", request.project, defaults.default_project_id
+                    "email_config",
+                    marshal_SubscriberEmailConfig(request.email_config, defaults)
+                    if request.email_config is not None
+                    else None,
                 ),
                 OneOfPossibility(
-                    "organization",
-                    request.organization,
-                    defaults.default_organization_id,
+                    "webhook_config",
+                    marshal_SubscriberWebhookConfig(request.webhook_config, defaults)
+                    if request.webhook_config is not None
+                    else None,
                 ),
             ]
         ),
-        "boot_type": BootType(request.boot_type)
-        if request.boot_type is not None
-        else None,
-        "bootscript": request.bootscript,
-        "commercial_type": request.commercial_type,
-        "dynamic_ip_required": request.dynamic_ip_required,
-        "enable_ipv6": request.enable_ipv6,
-        "image": request.image,
-        "name": request.name,
-        "placement_group": request.placement_group,
-        "public_ip": request.public_ip,
-        "security_group": request.security_group,
-        "tags": request.tags,
-        "volumes": {
-            k: marshal_VolumeServerTemplate(v, defaults)
-            for k, v in request.volumes.items()
-        }
-        if request.volumes is not None
-        else None,
-    }
-
-
-def marshal__SetImageRequest(
-    request: _SetImageRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "arch": Arch(request.arch),
-        "creation_date": request.creation_date,
-        "default_bootscript": marshal_Bootscript(request.default_bootscript, defaults)
-        if request.default_bootscript is not None
-        else None,
-        "extra_volumes": {
-            k: marshal_Volume(v, defaults) for k, v in request.extra_volumes.items()
-        }
-        if request.extra_volumes is not None
-        else None,
-        "from_server": request.from_server,
-        "modification_date": request.modification_date,
-        "name": request.name,
-        "organization": request.organization or defaults.default_organization_id,
-        "project": request.project or defaults.default_project_id,
-        "public": request.public,
-        "root_volume": marshal_VolumeSummary(request.root_volume, defaults)
-        if request.root_volume is not None
-        else None,
-        "state": ImageState(request.state),
-        "tags": request.tags,
-    }
-
-
-def marshal__SetSecurityGroupRequest(
-    request: _SetSecurityGroupRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "creation_date": request.creation_date,
-        "description": request.description,
-        "enable_default_security": request.enable_default_security,
-        "inbound_default_policy": SecurityGroupPolicy(request.inbound_default_policy),
-        "modification_date": request.modification_date,
-        "name": request.name,
-        "organization": request.organization or defaults.default_organization_id,
-        "organization_default": request.organization_default,
-        "outbound_default_policy": SecurityGroupPolicy(request.outbound_default_policy),
-        "project": request.project or defaults.default_project_id,
-        "project_default": request.project_default,
-        "servers": [marshal_ServerSummary(v, defaults) for v in request.servers]
-        if request.servers is not None
-        else None,
-        "stateful": request.stateful,
-        "tags": request.tags,
-    }
-
-
-def marshal__SetSecurityGroupRuleRequest(
-    request: _SetSecurityGroupRuleRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "action": SecurityGroupRuleAction(request.action),
-        "dest_port_from": request.dest_port_from,
-        "dest_port_to": request.dest_port_to,
-        "direction": SecurityGroupRuleDirection(request.direction),
-        "editable": request.editable,
-        "id": request.id,
-        "ip_range": request.ip_range,
-        "position": request.position,
-        "protocol": SecurityGroupRuleProtocol(request.protocol),
-    }
-
-
-def marshal__SetServerRequest(
-    request: _SetServerRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "allowed_actions": [ServerAction(v) for v in request.allowed_actions]
-        if request.allowed_actions is not None
-        else None,
-        "arch": Arch(request.arch),
-        "boot_type": BootType(request.boot_type),
-        "bootscript": marshal_Bootscript(request.bootscript, defaults)
-        if request.bootscript is not None
-        else None,
-        "commercial_type": request.commercial_type,
-        "creation_date": request.creation_date,
-        "dynamic_ip_required": request.dynamic_ip_required,
-        "enable_ipv6": request.enable_ipv6,
-        "hostname": request.hostname,
-        "image": marshal_Image(request.image, defaults)
-        if request.image is not None
-        else None,
-        "ipv6": marshal_ServerIpv6(request.ipv6, defaults)
-        if request.ipv6 is not None
-        else None,
-        "location": marshal_ServerLocation(request.location, defaults)
-        if request.location is not None
-        else None,
-        "maintenances": [
-            marshal_ServerMaintenance(v, defaults) for v in request.maintenances
-        ]
-        if request.maintenances is not None
-        else None,
-        "modification_date": request.modification_date,
-        "name": request.name,
-        "organization": request.organization or defaults.default_organization_id,
-        "placement_group": marshal_PlacementGroup(request.placement_group, defaults)
-        if request.placement_group is not None
-        else None,
-        "private_ip": request.private_ip,
-        "private_nics": [marshal_PrivateNIC(v, defaults) for v in request.private_nics]
-        if request.private_nics is not None
-        else None,
-        "project": request.project or defaults.default_project_id,
-        "protected": request.protected,
-        "public_ip": marshal_ServerIp(request.public_ip, defaults)
-        if request.public_ip is not None
-        else None,
-        "security_group": marshal_SecurityGroupSummary(request.security_group, defaults)
-        if request.security_group is not None
-        else None,
-        "state": ServerState(request.state),
-        "state_detail": request.state_detail,
-        "tags": request.tags,
-        "volumes": {k: marshal_Volume(v, defaults) for k, v in request.volumes.items()}
-        if request.volumes is not None
-        else None,
-    }
-
-
-def marshal__SetSnapshotRequest(
-    request: _SetSnapshotRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "base_volume": marshal_SnapshotBaseVolume(request.base_volume, defaults)
-        if request.base_volume is not None
-        else None,
-        "creation_date": request.creation_date,
-        "id": request.id,
-        "modification_date": request.modification_date,
-        "name": request.name,
-        "organization": request.organization or defaults.default_organization_id,
-        "project": request.project or defaults.default_project_id,
-        "size": request.size,
-        "state": SnapshotState(request.state),
-        "tags": request.tags,
-        "volume_type": VolumeVolumeType(request.volume_type),
-    }
-
-
-def marshal__UpdateServerRequest(
-    request: _UpdateServerRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "boot_type": BootType(request.boot_type)
-        if request.boot_type is not None
-        else None,
-        "bootscript": request.bootscript,
-        "dynamic_ip_required": request.dynamic_ip_required,
-        "enable_ipv6": request.enable_ipv6,
-        "name": request.name,
-        "placement_group": request.placement_group,
-        "private_nics": [marshal_PrivateNIC(v, defaults) for v in request.private_nics]
-        if request.private_nics is not None
-        else None,
-        "protected": request.protected,
-        "security_group": marshal_SecurityGroupTemplate(
-            request.security_group, defaults
-        )
-        if request.security_group is not None
-        else None,
-        "tags": request.tags,
-        "volumes": {
-            k: marshal_VolumeServerTemplate(v, defaults)
-            for k, v in request.volumes.items()
-        }
-        if request.volumes is not None
-        else None,
-    }
+    )
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
```

### Comparing `scaleway_async-0.9.0/scaleway_async/instance/v1/types.py` & `scaleway_async-1.0.0/scaleway_async/rdb/v1/types.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,3111 +1,2781 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 from __future__ import annotations
 
 from dataclasses import dataclass
 from datetime import datetime
 from enum import Enum
-from typing import Dict, List, Optional
+from typing import List, Optional
 
 from scaleway_core.bridge import (
+    Region,
+    TimeSeries,
     Zone,
 )
 
 
-class Arch(str, Enum):
-    X86_64 = "x86_64"
-    ARM = "arm"
+class ACLRuleAction(str, Enum):
+    ALLOW = "allow"
+    DENY = "deny"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class BootType(str, Enum):
-    LOCAL = "local"
-    BOOTSCRIPT = "bootscript"
-    RESCUE = "rescue"
+class ACLRuleDirection(str, Enum):
+    INBOUND = "inbound"
+    OUTBOUND = "outbound"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ImageState(str, Enum):
-    AVAILABLE = "available"
+class ACLRuleProtocol(str, Enum):
+    TCP = "tcp"
+    UDP = "udp"
+    ICMP = "icmp"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
+class DatabaseBackupStatus(str, Enum):
+    UNKNOWN = "unknown"
     CREATING = "creating"
+    READY = "ready"
+    RESTORING = "restoring"
+    DELETING = "deleting"
     ERROR = "error"
+    EXPORTING = "exporting"
+    LOCKED = "locked"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ListServersRequestOrder(str, Enum):
-    CREATION_DATE_DESC = "creation_date_desc"
-    CREATION_DATE_ASC = "creation_date_asc"
-    MODIFICATION_DATE_DESC = "modification_date_desc"
-    MODIFICATION_DATE_ASC = "modification_date_asc"
+class EngineSettingPropertyType(str, Enum):
+    BOOLEAN = "BOOLEAN"
+    INT = "INT"
+    STRING = "STRING"
+    FLOAT = "FLOAT"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class PlacementGroupPolicyMode(str, Enum):
-    OPTIONAL = "optional"
-    ENFORCED = "enforced"
+class InstanceLogStatus(str, Enum):
+    UNKNOWN = "unknown"
+    READY = "ready"
+    CREATING = "creating"
+    ERROR = "error"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class PlacementGroupPolicyType(str, Enum):
-    MAX_AVAILABILITY = "max_availability"
-    LOW_LATENCY = "low_latency"
+class InstanceStatus(str, Enum):
+    UNKNOWN = "unknown"
+    READY = "ready"
+    PROVISIONING = "provisioning"
+    CONFIGURING = "configuring"
+    DELETING = "deleting"
+    ERROR = "error"
+    AUTOHEALING = "autohealing"
+    LOCKED = "locked"
+    INITIALIZING = "initializing"
+    DISK_FULL = "disk_full"
+    BACKUPING = "backuping"
+    SNAPSHOTTING = "snapshotting"
+    RESTARTING = "restarting"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class PrivateNICState(str, Enum):
-    AVAILABLE = "available"
-    SYNCING = "syncing"
-    SYNCING_ERROR = "syncing_error"
+class ListDatabaseBackupsRequestOrderBy(str, Enum):
+    CREATED_AT_ASC = "created_at_asc"
+    CREATED_AT_DESC = "created_at_desc"
+    NAME_ASC = "name_asc"
+    NAME_DESC = "name_desc"
+    STATUS_ASC = "status_asc"
+    STATUS_DESC = "status_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class SecurityGroupPolicy(str, Enum):
-    ACCEPT = "accept"
-    DROP = "drop"
+class ListDatabasesRequestOrderBy(str, Enum):
+    NAME_ASC = "name_asc"
+    NAME_DESC = "name_desc"
+    SIZE_ASC = "size_asc"
+    SIZE_DESC = "size_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class SecurityGroupRuleAction(str, Enum):
-    ACCEPT = "accept"
-    DROP = "drop"
+class ListInstanceLogsRequestOrderBy(str, Enum):
+    CREATED_AT_ASC = "created_at_asc"
+    CREATED_AT_DESC = "created_at_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class SecurityGroupRuleDirection(str, Enum):
-    INBOUND = "inbound"
-    OUTBOUND = "outbound"
+class ListInstancesRequestOrderBy(str, Enum):
+    CREATED_AT_ASC = "created_at_asc"
+    CREATED_AT_DESC = "created_at_desc"
+    NAME_ASC = "name_asc"
+    NAME_DESC = "name_desc"
+    REGION = "region"
+    STATUS_ASC = "status_asc"
+    STATUS_DESC = "status_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class SecurityGroupRuleProtocol(str, Enum):
-    TCP = "TCP"
-    UDP = "UDP"
-    ICMP = "ICMP"
-    ANY = "ANY"
+class ListPrivilegesRequestOrderBy(str, Enum):
+    USER_NAME_ASC = "user_name_asc"
+    USER_NAME_DESC = "user_name_desc"
+    DATABASE_NAME_ASC = "database_name_asc"
+    DATABASE_NAME_DESC = "database_name_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class SecurityGroupState(str, Enum):
-    AVAILABLE = "available"
-    SYNCING = "syncing"
-    SYNCING_ERROR = "syncing_error"
+class ListSnapshotsRequestOrderBy(str, Enum):
+    CREATED_AT_ASC = "created_at_asc"
+    CREATED_AT_DESC = "created_at_desc"
+    NAME_ASC = "name_asc"
+    NAME_DESC = "name_desc"
+    EXPIRES_AT_ASC = "expires_at_asc"
+    EXPIRES_AT_DESC = "expires_at_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ServerAction(str, Enum):
-    POWERON = "poweron"
-    BACKUP = "backup"
-    STOP_IN_PLACE = "stop_in_place"
-    POWEROFF = "poweroff"
-    TERMINATE = "terminate"
-    REBOOT = "reboot"
+class ListUsersRequestOrderBy(str, Enum):
+    NAME_ASC = "name_asc"
+    NAME_DESC = "name_desc"
+    IS_ADMIN_ASC = "is_admin_asc"
+    IS_ADMIN_DESC = "is_admin_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ServerState(str, Enum):
-    RUNNING = "running"
-    STOPPED = "stopped"
-    STOPPED_IN_PLACE = "stopped in place"
-    STARTING = "starting"
-    STOPPING = "stopping"
-    LOCKED = "locked"
+class MaintenanceStatus(str, Enum):
+    UNKNOWN = "unknown"
+    PENDING = "pending"
+    DONE = "done"
+    CANCELED = "canceled"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ServerTypesAvailability(str, Enum):
-    AVAILABLE = "available"
-    SCARCE = "scarce"
-    SHORTAGE = "shortage"
+class NodeTypeGeneration(str, Enum):
+    UNKNOWN_GENERATION = "unknown_generation"
+    GENERATION_V1 = "generation_v1"
+    GENERATION_V2 = "generation_v2"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class SnapshotState(str, Enum):
+class NodeTypeStock(str, Enum):
+    UNKNOWN = "unknown"
+    LOW_STOCK = "low_stock"
+    OUT_OF_STOCK = "out_of_stock"
     AVAILABLE = "available"
-    SNAPSHOTTING = "snapshotting"
-    ERROR = "error"
-    INVALID_DATA = "invalid_data"
-    IMPORTING = "importing"
-    EXPORTING = "exporting"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class SnapshotVolumeType(str, Enum):
-    UNKNOWN_VOLUME_TYPE = "unknown_volume_type"
-    L_SSD = "l_ssd"
-    B_SSD = "b_ssd"
-    UNIFIED = "unified"
+class Permission(str, Enum):
+    READONLY = "readonly"
+    READWRITE = "readwrite"
+    ALL = "all"
+    CUSTOM = "custom"
+    NONE = "none"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class TaskStatus(str, Enum):
-    PENDING = "pending"
-    STARTED = "started"
-    SUCCESS = "success"
-    FAILURE = "failure"
-    RETRY = "retry"
+class ReadReplicaStatus(str, Enum):
+    """
+    Read replica. status.
+    """
+
+    UNKNOWN = "unknown"
+    PROVISIONING = "provisioning"
+    INITIALIZING = "initializing"
+    READY = "ready"
+    DELETING = "deleting"
+    ERROR = "error"
+    LOCKED = "locked"
+    CONFIGURING = "configuring"
+    PROMOTING = "promoting"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class VolumeServerState(str, Enum):
-    AVAILABLE = "available"
-    SNAPSHOTTING = "snapshotting"
+class SnapshotStatus(str, Enum):
+    UNKNOWN = "unknown"
+    CREATING = "creating"
+    READY = "ready"
+    RESTORING = "restoring"
+    DELETING = "deleting"
     ERROR = "error"
-    FETCHING = "fetching"
-    RESIZING = "resizing"
-    SAVING = "saving"
-    HOTSYNCING = "hotsyncing"
+    LOCKED = "locked"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class VolumeServerVolumeType(str, Enum):
-    L_SSD = "l_ssd"
-    B_SSD = "b_ssd"
+class VolumeType(str, Enum):
+    LSSD = "lssd"
+    BSSD = "bssd"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class VolumeState(str, Enum):
-    AVAILABLE = "available"
-    SNAPSHOTTING = "snapshotting"
-    ERROR = "error"
-    FETCHING = "fetching"
-    RESIZING = "resizing"
-    SAVING = "saving"
-    HOTSYNCING = "hotsyncing"
+@dataclass
+class ACLRule:
+    ip: str
 
-    def __str__(self) -> str:
-        return str(self.value)
+    port: Optional[int]
+    """
+    :deprecated
+    """
 
+    protocol: ACLRuleProtocol
 
-class VolumeVolumeType(str, Enum):
-    L_SSD = "l_ssd"
-    B_SSD = "b_ssd"
-    UNIFIED = "unified"
+    direction: ACLRuleDirection
 
-    def __str__(self) -> str:
-        return str(self.value)
+    action: ACLRuleAction
+
+    description: str
 
 
 @dataclass
-class Bootscript:
-    """
-    Bootscript
-    """
+class ACLRuleRequest:
+    ip: str
 
-    bootcmdargs: str
-    """
-    The bootscript arguments
-    """
+    description: str
 
-    default: bool
-    """
-    Dispmay if the bootscript is the default bootscript if no other boot option is configured
-    """
 
-    dtb: str
+@dataclass
+class AddInstanceACLRulesResponse:
     """
-    Provide information regarding a Device Tree Binary (dtb) for use with C1 servers
+    Add instance acl rules response.
     """
 
-    id: str
+    rules: List[ACLRule]
     """
-    The bootscript ID
+    ACL Rules enabled for the Database Instance.
     """
 
-    initrd: str
-    """
-    The initrd (initial ramdisk) configuration
-    """
 
-    kernel: str
+@dataclass
+class AddInstanceSettingsResponse:
     """
-    The server kernel version
+    Add instance settings response.
     """
 
-    organization: str
+    settings: List[InstanceSetting]
     """
-    The bootscript organization ID
+    Settings available on the Database Instance.
     """
 
-    project: str
-    """
-    The bootscript project ID
-    """
 
-    public: bool
+@dataclass
+class BackupSchedule:
     """
-    Provide information if the bootscript is public
+    Backup schedule.
     """
 
-    title: str
+    frequency: int
     """
-    The bootscript title
+    Frequency of the backup schedule (in hours).
     """
 
-    arch: Arch
+    retention: int
     """
-    The bootscript arch
+    Default retention period of backups (in days).
     """
 
-    zone: Zone
+    disabled: bool
     """
-    The zone in which is the bootscript
+    Defines whether the backup schedule feature is disabled.
     """
 
-
-@dataclass
-class CreateImageResponse:
-    image: Optional[Image]
-
-
-@dataclass
-class CreateIpResponse:
-    ip: Optional[Ip]
-
-
-@dataclass
-class CreatePlacementGroupResponse:
-    placement_group: Optional[PlacementGroup]
-
-
-@dataclass
-class CreatePrivateNICResponse:
-    private_nic: Optional[PrivateNIC]
-
-
-@dataclass
-class CreateSecurityGroupResponse:
-    security_group: Optional[SecurityGroup]
-
-
-@dataclass
-class CreateSecurityGroupRuleResponse:
-    rule: Optional[SecurityGroupRule]
-
-
-@dataclass
-class CreateServerResponse:
-    server: Optional[Server]
-
-
-@dataclass
-class CreateSnapshotResponse:
-    snapshot: Optional[Snapshot]
-
-    task: Optional[Task]
-
-
-@dataclass
-class CreateVolumeResponse:
-    volume: Optional[Volume]
-
-
-@dataclass
-class Dashboard:
-    volumes_count: int
-
-    running_servers_count: int
-
-    servers_by_types: Dict[str, int]
-
-    images_count: int
-
-    snapshots_count: int
-
-    servers_count: int
-
-    ips_count: int
-
-    security_groups_count: int
-
-    ips_unused: int
-
-    volumes_l_ssd_count: int
-
-    volumes_b_ssd_count: int
-
-    volumes_l_ssd_total_size: int
-
-    volumes_b_ssd_total_size: int
-
-    private_nics_count: int
-
-    placement_groups_count: int
-
-
-@dataclass
-class ExportSnapshotResponse:
-    task: Optional[Task]
-
-
-@dataclass
-class GetBootscriptResponse:
-    bootscript: Optional[Bootscript]
-
-
-@dataclass
-class GetDashboardResponse:
-    dashboard: Optional[Dashboard]
-
-
-@dataclass
-class GetImageResponse:
-    image: Optional[Image]
-
-
-@dataclass
-class GetIpResponse:
-    ip: Optional[Ip]
-
-
-@dataclass
-class GetPlacementGroupResponse:
-    placement_group: Optional[PlacementGroup]
-
-
-@dataclass
-class GetPlacementGroupServersResponse:
-    servers: List[PlacementGroupServer]
-
-
-@dataclass
-class GetPrivateNICResponse:
-    private_nic: Optional[PrivateNIC]
-
-
-@dataclass
-class GetSecurityGroupResponse:
-    security_group: Optional[SecurityGroup]
-
-
-@dataclass
-class GetSecurityGroupRuleResponse:
-    rule: Optional[SecurityGroupRule]
-
-
-@dataclass
-class GetServerResponse:
-    server: Optional[Server]
-
-
-@dataclass
-class GetServerTypesAvailabilityResponse:
-    servers: Dict[str, GetServerTypesAvailabilityResponseAvailability]
-
-
-@dataclass
-class GetServerTypesAvailabilityResponseAvailability:
-    availability: ServerTypesAvailability
-
-
-@dataclass
-class GetSnapshotResponse:
-    snapshot: Optional[Snapshot]
-
-
-@dataclass
-class GetVolumeResponse:
-    volume: Optional[Volume]
-
-
-@dataclass
-class Image:
-    id: str
-
-    name: str
-
-    arch: Arch
-
-    creation_date: Optional[datetime]
-
-    modification_date: Optional[datetime]
-
-    default_bootscript: Optional[Bootscript]
+    next_run_at: Optional[datetime]
     """
-    :deprecated
+    Next run of the backup schedule (accurate to 10 minutes).
     """
 
-    extra_volumes: Dict[str, Volume]
-
-    from_server: str
-
-    organization: str
-
-    public: bool
-
-    root_volume: Optional[VolumeSummary]
-
-    state: ImageState
-
-    project: str
-
-    tags: List[str]
-
-    zone: Zone
-
-
-@dataclass
-class Ip:
-    id: str
-
-    address: str
-
-    reverse: Optional[str]
-
-    server: Optional[ServerSummary]
-
-    organization: str
-
-    tags: List[str]
-
-    project: str
-
-    zone: Zone
-
 
 @dataclass
-class ListBootscriptsResponse:
-    """
-    List bootscripts response
-    """
-
-    total_count: int
+class Database:
     """
-    Total number of bootscripts
+    Database.
     """
 
-    bootscripts: List[Bootscript]
+    name: str
     """
-    List of bootscripts
+    Name of the database.
     """
 
-
-@dataclass
-class ListImagesResponse:
+    owner: str
     """
-    List images response
+    Name of the database owner.
     """
 
-    total_count: int
+    managed: bool
     """
-    Total number of images
+    Defines whether the database is managed or not.
     """
 
-    images: List[Image]
+    size: int
     """
-    List of images
+    Size of the database.
     """
 
 
 @dataclass
-class ListIpsResponse:
+class DatabaseBackup:
     """
-    List ips response
+    Database backup.
     """
 
-    total_count: int
+    id: str
     """
-    Total number of ips
+    UUID of the database backup.
     """
 
-    ips: List[Ip]
+    instance_id: str
     """
-    List of ips
+    UUID of the Database Instance.
     """
 
-
-@dataclass
-class ListPlacementGroupsResponse:
+    database_name: str
     """
-    List placement groups response
+    Name of backed up database.
     """
 
-    total_count: int
+    name: str
     """
-    Total number of placement groups
+    Name of the backup.
     """
 
-    placement_groups: List[PlacementGroup]
+    status: DatabaseBackupStatus
     """
-    List of placement groups
+    Status of the backup.
     """
 
-
-@dataclass
-class ListPrivateNICsResponse:
-    private_nics: List[PrivateNIC]
-
-    total_count: int
-
-
-@dataclass
-class ListSecurityGroupRulesResponse:
+    size: Optional[int]
     """
-    List security group rules response
+    Size of the database backup.
     """
 
-    total_count: int
+    expires_at: Optional[datetime]
     """
-    Total number of security groups
+    Expiration date (must follow the ISO 8601 format).
     """
 
-    rules: List[SecurityGroupRule]
+    created_at: Optional[datetime]
     """
-    List of security rules
+    Creation date (must follow the ISO 8601 format).
     """
 
-
-@dataclass
-class ListSecurityGroupsResponse:
+    updated_at: Optional[datetime]
     """
-    List security groups response
+    Updated date (must follow the ISO 8601 format).
     """
 
-    total_count: int
+    instance_name: str
     """
-    Total number of security groups
+    Name of the Database Instance of the backup.
     """
 
-    security_groups: List[SecurityGroup]
+    download_url: Optional[str]
     """
-    List of security groups
+    URL you can download the backup from.
     """
 
-
-@dataclass
-class ListServerActionsResponse:
-    actions: List[ServerAction]
-
-
-@dataclass
-class ListServerUserDataResponse:
-    user_data: List[str]
-
-
-@dataclass
-class ListServersResponse:
+    download_url_expires_at: Optional[datetime]
     """
-    List servers response
+    Expiration date of the download link.
     """
 
-    total_count: int
+    region: Region
     """
-    Total number of servers
+    Region of the database backup.
     """
 
-    servers: List[Server]
+    same_region: bool
     """
-    List of servers
+    Store logical backups in the same region as the source Database Instance.
     """
 
 
 @dataclass
-class ListServersTypesResponse:
+class DatabaseEngine:
     """
-    List servers types response
+    Database engine.
     """
 
-    total_count: int
+    name: str
     """
-    Total number of server types
+    Engine name.
     """
 
-    servers: Dict[str, ServerType]
+    logo_url: str
     """
-    List of server types
+    Engine logo URL.
     """
 
-
-@dataclass
-class ListSnapshotsResponse:
+    versions: List[EngineVersion]
     """
-    List snapshots response
+    Available versions.
     """
 
-    total_count: int
+    region: Region
     """
-    Total number of snapshots
-    """
-
-    snapshots: List[Snapshot]
-    """
-    List of snapshots
+    Region of this Database Instance.
     """
 
 
 @dataclass
-class ListVolumesResponse:
-    """
-    List volumes response
-    """
-
-    total_count: int
+class DeleteInstanceACLRulesResponse:
     """
-    Total number of volumes
+    Delete instance acl rules response.
     """
 
-    volumes: List[Volume]
+    rules: List[ACLRule]
     """
-    List of volumes
+    IP addresses defined in the ACL rules of the Database Instance.
     """
 
 
 @dataclass
-class ListVolumesTypesResponse:
-    """
-    List volumes types response
-    """
-
-    total_count: int
+class DeleteInstanceSettingsResponse:
     """
-    Total number of volume types
+    Delete instance settings response.
     """
 
-    volumes: Dict[str, VolumeType]
+    settings: List[InstanceSetting]
     """
-    Map of volume types
+    Settings names to delete from the Database Instance.
     """
 
 
 @dataclass
-class PlacementGroup:
+class Endpoint:
     """
-    Placement group
+    Endpoint.
     """
 
     id: str
     """
-    The placement group unique ID
+    UUID of the endpoint.
     """
 
-    name: str
+    ip: Optional[str]
     """
-    The placement group name
-    """
-
-    organization: str
-    """
-    The placement group organization ID
+    IPv4 address of the endpoint.
+    
+    One-of ('address'): at most one of 'ip', 'hostname' could be set.
     """
 
-    project: str
+    port: int
     """
-    The placement group project ID
+    TCP port of the endpoint.
     """
 
-    tags: List[str]
+    name: Optional[str]
     """
-    The placement group tags
+    Name of the endpoint.
     """
 
-    policy_mode: PlacementGroupPolicyMode
+    private_network: Optional[EndpointPrivateNetworkDetails]
     """
-    Select the failling mode when the placement cannot be respected, either optional or enforced
+    Private Network details. One maximum per Database Instance or Read Replica (a Database Instance and its Read Replica can have different Private Networks). Cannot be updated (has to be deleted and recreated).
+    
+    One-of ('details'): at most one of 'private_network', 'load_balancer', 'direct_access' could be set.
     """
 
-    policy_type: PlacementGroupPolicyType
+    load_balancer: Optional[EndpointLoadBalancerDetails]
     """
-    Select the behavior of the placement group, either low_latency (group) or max_availability (spread)
+    Load balancer details. Public endpoint for Database Instance which is systematically present. One per Database Instance.
+    
+    One-of ('details'): at most one of 'private_network', 'load_balancer', 'direct_access' could be set.
     """
 
-    policy_respected: bool
+    direct_access: Optional[EndpointDirectAccessDetails]
     """
-    Returns true if the policy is respected, false otherwise
+    Direct access details. Public endpoint reserved for Read Replicas. One per Read Replica.
+    
+    One-of ('details'): at most one of 'private_network', 'load_balancer', 'direct_access' could be set.
     """
 
-    zone: Zone
+    hostname: Optional[str]
     """
-    The zone in which is the placement group
+    Hostname of the endpoint.
+    
+    One-of ('address'): at most one of 'ip', 'hostname' could be set.
     """
 
 
 @dataclass
-class PlacementGroupServer:
-    id: str
+class EndpointDirectAccessDetails:
+    pass
 
-    name: str
 
-    policy_respected: bool
+@dataclass
+class EndpointLoadBalancerDetails:
+    pass
 
 
 @dataclass
-class PrivateNIC:
+class EndpointPrivateNetworkDetails:
     """
-    Private nic
+    Endpoint. private network details.
     """
 
-    id: str
+    private_network_id: str
     """
-    The private NIC unique ID
+    UUID of the private network.
     """
 
-    server_id: str
+    service_ip: str
     """
-    The server the private NIC is attached to
+    CIDR notation of the endpoint IPv4 address.
     """
 
-    private_network_id: str
+    zone: Zone
     """
-    The private network where the private NIC is attached
+    Private network zone.
     """
 
-    mac_address: str
+
+@dataclass
+class EndpointSpec:
     """
-    The private NIC MAC address
+    Endpoint spec.
     """
 
-    state: PrivateNICState
+    load_balancer: Optional[EndpointSpecLoadBalancer]
     """
-    The private NIC state
+    Load balancer endpoint specifications. Public endpoint for Database Instance which is systematically present. One per RDB instance.
+    
+    One-of ('spec'): at most one of 'load_balancer', 'private_network' could be set.
     """
 
-    tags: List[str]
+    private_network: Optional[EndpointSpecPrivateNetwork]
     """
-    The private NIC tags
+    Private Network endpoint specifications. One maximum per Database Instance or Read Replica (a Database Instance and its Read Replica can have different Private Networks). Cannot be updated (has to be deleted and recreated).
+    
+    One-of ('spec'): at most one of 'load_balancer', 'private_network' could be set.
     """
 
 
 @dataclass
-class SecurityGroup:
-    """
-    Security group
-    """
+class EndpointSpecLoadBalancer:
+    pass
 
-    id: str
-    """
-    The security groups' unique ID
-    """
 
-    name: str
+@dataclass
+class EndpointSpecPrivateNetwork:
     """
-    The security groups name
+    Endpoint spec. private network.
     """
 
-    description: str
+    private_network_id: str
     """
-    The security groups description
+    UUID of the Private Network to be connected to the Database Instance.
     """
 
-    enable_default_security: bool
+    service_ip: Optional[str]
     """
-    True if SMTP is blocked on IPv4 and IPv6
+    Endpoint IPv4 address with a CIDR notation. Refer to the official Scaleway documentation to learn more about IP and subnet limitations.
+    
+    One-of ('config'): at most one of 'service_ip', 'ipam_config' could be set.
     """
 
-    inbound_default_policy: SecurityGroupPolicy
+    ipam_config: Optional[EndpointSpecPrivateNetworkIpamConfig]
     """
-    The default inbound policy
+    Automated configuration of your Private Network endpoint with Scaleway IPAM service. One at the most per Database Instance or Read Replica (a Database Instance and its Read Replica can have different Private Networks). Cannot be updated (has to be deleted and recreated).
+    
+    One-of ('config'): at most one of 'service_ip', 'ipam_config' could be set.
     """
 
-    outbound_default_policy: SecurityGroupPolicy
+
+@dataclass
+class EndpointSpecPrivateNetworkIpamConfig:
+    pass
+
+
+@dataclass
+class EngineSetting:
     """
-    The default outbound policy
+    Engine setting.
     """
 
-    organization: str
+    name: str
     """
-    The security groups organization ID
+    Setting name from the database engine.
     """
 
-    project: str
+    default_value: str
     """
-    The security group project ID
+    Value set when not specified.
     """
 
-    tags: List[str]
+    hot_configurable: bool
     """
-    The security group tags
+    Setting can be applied without restarting.
     """
 
-    organization_default: Optional[bool]
+    description: str
     """
-    True if it is your default security group for this organization ID
-    :deprecated
+    Setting description.
     """
 
-    project_default: bool
+    property_type: EngineSettingPropertyType
     """
-    True if it is your default security group for this project ID
+    Setting type.
     """
 
-    creation_date: Optional[datetime]
+    unit: Optional[str]
     """
-    The security group creation date
+    Setting base unit.
     """
 
-    modification_date: Optional[datetime]
+    string_constraint: Optional[str]
     """
-    The security group modification date
+    Validation regex for string type settings.
     """
 
-    servers: List[ServerSummary]
+    int_min: Optional[int]
     """
-    List of servers attached to this security group
+    Minimum value for int types.
     """
 
-    stateful: bool
+    int_max: Optional[int]
     """
-    True if the security group is stateful
+    Maximum value for int types.
     """
 
-    state: SecurityGroupState
+    float_min: Optional[float]
     """
-    Security group state
+    Minimum value for float types.
     """
 
-    zone: Zone
+    float_max: Optional[float]
     """
-    The zone in which is the security group
+    Maximum value for float types.
     """
 
 
 @dataclass
-class SecurityGroupRule:
-    id: str
-
-    protocol: SecurityGroupRuleProtocol
-
-    direction: SecurityGroupRuleDirection
-
-    action: SecurityGroupRuleAction
-
-    ip_range: str
-
-    dest_port_from: Optional[int]
-
-    dest_port_to: Optional[int]
-
-    position: int
-
-    editable: bool
-
-    zone: Zone
-
-
-@dataclass
-class SecurityGroupSummary:
-    id: str
-
-    name: str
-
-
-@dataclass
-class SecurityGroupTemplate:
-    id: str
-
-    name: str
-
-
-@dataclass
-class Server:
+class EngineVersion:
     """
-    Server
+    Engine version.
     """
 
-    id: str
+    version: str
     """
-    The server unique ID
+    Database engine version.
     """
 
     name: str
     """
-    The server name
+    Database engine name.
     """
 
-    organization: str
+    end_of_life: Optional[datetime]
     """
-    The server organization ID
+    End of life date.
     """
 
-    project: str
+    available_settings: List[EngineSetting]
     """
-    The server project ID
+    Engine settings available to be set.
     """
 
-    allowed_actions: List[ServerAction]
+    disabled: bool
     """
-    Provide as list of allowed actions on the server
+    Disabled versions cannot be created.
     """
 
-    tags: List[str]
+    beta: bool
     """
-    The server associated tags
+    Beta status of engine version.
     """
 
-    commercial_type: str
+    available_init_settings: List[EngineSetting]
     """
-    The server commercial type (eg. GP1-M)
+    Engine settings available to be set at database initialization.
     """
 
-    creation_date: Optional[datetime]
-    """
-    The server creation date
-    """
 
-    dynamic_ip_required: bool
+@dataclass
+class Instance:
     """
-    True if a dynamic IP is required
+    Instance.
     """
 
-    enable_ipv6: bool
+    created_at: Optional[datetime]
     """
-    True if IPv6 is enabled
+    Creation date (must follow the ISO 8601 format).
     """
 
-    hostname: str
+    volume: Optional[Volume]
     """
-    The server host name
+    Volumes of the Database Instance.
     """
 
-    image: Optional[Image]
+    region: Region
     """
-    Provide information on the server image
+    Region the Database Instance is in.
     """
 
-    protected: bool
+    id: str
     """
-    The server protection option is activated
+    UUID of the Database Instance.
     """
 
-    private_ip: Optional[str]
+    name: str
     """
-    The server private IP address
+    Name of the Database Instance.
     """
 
-    public_ip: Optional[ServerIp]
+    organization_id: str
     """
-    Information about the public IP
+    Organization ID the Database Instance belongs to.
     """
 
-    modification_date: Optional[datetime]
+    project_id: str
     """
-    The server modification date
+    Project ID the Database Instance belongs to.
     """
 
-    state: ServerState
+    status: InstanceStatus
     """
-    The server state
+    Status of the Database Instance.
     """
 
-    location: Optional[ServerLocation]
+    engine: str
     """
-    The server location
+    Database engine of the database (PostgreSQL, MySQL, ...).
     """
 
-    ipv6: Optional[ServerIpv6]
+    upgradable_version: List[UpgradableVersion]
     """
-    The server IPv6 address
+    Available database engine versions for upgrade.
     """
 
-    bootscript: Optional[Bootscript]
+    endpoint: Optional[Endpoint]
     """
-    The server bootscript
+    Endpoint of the Database Instance.
     :deprecated
     """
 
-    boot_type: BootType
+    tags: List[str]
     """
-    The server boot type
+    List of tags applied to the Database Instance.
     """
 
-    volumes: Dict[str, VolumeServer]
+    settings: List[InstanceSetting]
     """
-    The server volumes
+    Advanced settings of the Database Instance.
     """
 
-    security_group: Optional[SecurityGroupSummary]
+    backup_schedule: Optional[BackupSchedule]
     """
-    The server security group
+    Backup schedule of the Database Instance.
     """
 
-    maintenances: List[ServerMaintenance]
+    is_ha_cluster: bool
     """
-    The server planned maintenances
+    Defines whether or not High-Availability is enabled.
     """
 
-    state_detail: str
+    read_replicas: List[ReadReplica]
     """
-    The server state_detail
+    Read Replicas of the Database Instance.
     """
 
-    arch: Arch
+    node_type: str
     """
-    The server arch
+    Node type of the Database Instance.
     """
 
-    placement_group: Optional[PlacementGroup]
+    init_settings: List[InstanceSetting]
     """
-    The server placement group
+    List of engine settings to be set at database initialization.
     """
 
-    private_nics: List[PrivateNIC]
+    endpoints: List[Endpoint]
     """
-    The server private NICs
+    List of Database Instance endpoints.
     """
 
-    zone: Zone
+    logs_policy: Optional[LogsPolicy]
     """
-    The zone in which is the server
+    Logs policy of the Database Instance.
     """
 
-
-@dataclass
-class ServerActionRequestVolumeBackupTemplate:
+    backup_same_region: bool
     """
-    Server action request. volume backup template
+    Store logical backups in the same region as the Database Instance.
     """
 
-    volume_type: SnapshotVolumeType
+    maintenances: List[Maintenance]
     """
-    Overrides the volume_type of the snapshot for this volume.
-    If omitted, the volume type of the original volume will be used.
-    
+    List of Database Instance maintenance events.
     """
 
 
 @dataclass
-class ServerActionResponse:
-    task: Optional[Task]
-
-
-@dataclass
-class ServerIp:
+class InstanceLog:
     """
-    Server. ip
+    Instance log.
     """
 
-    id: str
+    download_url: Optional[str]
     """
-    The unique ID of the IP address
+    Presigned S3 URL to download your log file.
     """
 
-    address: str
+    id: str
     """
-    The server public IPv4 IP-Address
+    UUID of the Database Instance log.
     """
 
-    dynamic: bool
+    status: InstanceLogStatus
     """
-    True if the IP address is dynamic
+    Status of the logs in a Database Instance.
     """
 
-
-@dataclass
-class ServerIpv6:
+    node_name: str
     """
-    Server. ipv6
+    Name of the underlying node.
     """
 
-    address: str
+    expires_at: Optional[datetime]
     """
-    The server IPv6 IP-Address
+    Expiration date (must follow the ISO 8601 format).
     """
 
-    gateway: str
+    created_at: Optional[datetime]
     """
-    The IPv6 IP-addresses gateway
+    Creation date (must follow the ISO 8601 format).
     """
 
-    netmask: str
+    region: Region
     """
-    The IPv6 IP-addresses CIDR netmask
+    Region the Database Instance is in.
     """
 
 
 @dataclass
-class ServerLocation:
-    cluster_id: str
-
-    hypervisor_id: str
-
-    node_id: str
-
-    platform_id: str
-
-    zone_id: str
-
+class InstanceMetrics:
+    """
+    Instance metrics.
+    """
 
-@dataclass
-class ServerMaintenance:
-    reason: str
+    timeseries: List[TimeSeries]
+    """
+    Time series of metrics of a Database Instance.
+    """
 
 
 @dataclass
-class ServerSummary:
-    id: str
-
+class InstanceSetting:
     name: str
 
+    value: str
+
 
 @dataclass
-class ServerType:
+class ListDatabaseBackupsResponse:
     """
-    Server type
+    List database backups response.
     """
 
-    monthly_price: Optional[float]
+    database_backups: List[DatabaseBackup]
     """
-    Estimated monthly price, for a 30 days month, in Euro
-    :deprecated
+    List of database backups.
     """
 
-    hourly_price: float
+    total_count: int
     """
-    Hourly price in Euro
+    Total count of database backups available.
     """
 
-    alt_names: List[str]
-    """
-    Alternative instance name if any
-    """
 
-    per_volume_constraint: Optional[ServerTypeVolumeConstraintsByType]
+@dataclass
+class ListDatabaseEnginesResponse:
     """
-    Additional volume constraints
+    List database engines response.
     """
 
-    volumes_constraint: Optional[ServerTypeVolumeConstraintSizes]
+    engines: List[DatabaseEngine]
     """
-    Initial volume constraints
+    List of the available database engines.
     """
 
-    ncpus: int
+    total_count: int
     """
-    Number of CPU
+    Total count of database engines available.
     """
 
-    gpu: Optional[int]
+
+@dataclass
+class ListDatabasesResponse:
     """
-    Number of GPU
+    List databases response.
     """
 
-    ram: int
+    databases: List[Database]
     """
-    Available RAM in bytes
+    List of the databases.
     """
 
-    arch: Arch
+    total_count: int
     """
-    CPU architecture
+    Total count of databases present on a Database Instance.
     """
 
-    baremetal: bool
+
+@dataclass
+class ListInstanceACLRulesResponse:
     """
-    True if it is a baremetal instance
+    List instance acl rules response.
     """
 
-    network: Optional[ServerTypeNetwork]
+    rules: List[ACLRule]
     """
-    Network available for the instance
+    List of ACL rules present on a Database Instance.
     """
 
-    capabilities: Optional[ServerTypeCapabilities]
+    total_count: int
     """
-    Capabilities
+    Total count of ACL rules present on a Database Instance.
     """
 
 
 @dataclass
-class ServerTypeCapabilities:
+class ListInstanceLogsDetailsResponse:
     """
-    Server type. capabilities
+    List instance logs details response.
     """
 
-    block_storage: Optional[bool]
+    details: List[ListInstanceLogsDetailsResponseInstanceLogDetail]
     """
-    True if server supports block storage
+    Remote Database Instance logs details.
     """
 
-    boot_types: List[BootType]
-    """
-    List of supported boot types
-    """
+
+@dataclass
+class ListInstanceLogsDetailsResponseInstanceLogDetail:
+    log_name: str
+
+    size: int
 
 
 @dataclass
-class ServerTypeNetwork:
+class ListInstanceLogsResponse:
     """
-    Server type. network
+    List instance logs response.
     """
 
-    interfaces: List[ServerTypeNetworkInterface]
+    instance_logs: List[InstanceLog]
     """
-    List of available network interfaces
+    Available logs in a Database Instance.
     """
 
-    sum_internal_bandwidth: Optional[int]
+
+@dataclass
+class ListInstancesResponse:
     """
-    Total maximum internal bandwidth in bits per seconds
+    List instances response.
     """
 
-    sum_internet_bandwidth: Optional[int]
+    instances: List[Instance]
     """
-    Total maximum internet bandwidth in bits per seconds
+    List of all Database Instances available in an Organization or Project.
     """
 
-    ipv6_support: bool
+    total_count: int
     """
-    True if IPv6 is enabled
+    Total count of Database Instances available in a Organization or Project.
     """
 
 
 @dataclass
-class ServerTypeNetworkInterface:
+class ListNodeTypesResponse:
     """
-    Server type. network. interface
+    List node types response.
     """
 
-    internal_bandwidth: Optional[int]
+    node_types: List[NodeType]
     """
-    Maximum internal bandwidth in bits per seconds
+    Types of the node.
     """
 
-    internet_bandwidth: Optional[int]
+    total_count: int
     """
-    Maximum internet bandwidth in bits per seconds
+    Total count of node-types available.
     """
 
 
 @dataclass
-class ServerTypeVolumeConstraintSizes:
+class ListPrivilegesResponse:
     """
-    Server type. volume constraint sizes
+    List privileges response.
     """
 
-    min_size: int
+    privileges: List[Privilege]
     """
-    Minimum volume size in bytes
+    Privileges of a user in a database in a Database Instance.
     """
 
-    max_size: int
+    total_count: int
     """
-    Maximum volume size in bytes
+    Total count of privileges present on a database.
     """
 
 
 @dataclass
-class ServerTypeVolumeConstraintsByType:
+class ListSnapshotsResponse:
     """
-    Server type. volume constraints by type
+    List snapshots response.
     """
 
-    l_ssd: Optional[ServerTypeVolumeConstraintSizes]
+    snapshots: List[Snapshot]
     """
-    Local SSD volumes
+    List of snapshots.
     """
 
-
-@dataclass
-class SetPlacementGroupResponse:
-    placement_group: Optional[PlacementGroup]
+    total_count: int
+    """
+    Total count of snapshots available.
+    """
 
 
 @dataclass
-class SetPlacementGroupServersResponse:
-    servers: List[PlacementGroupServer]
-
+class ListUsersResponse:
+    """
+    List users response.
+    """
 
-@dataclass
-class SetSecurityGroupRulesRequestRule:
+    users: List[User]
     """
-    Set security group rules request. rule
+    List of users in a Database Instance.
     """
 
-    id: Optional[str]
+    total_count: int
     """
-    UUID of the security rule to update. If no value is provided, a new rule will be created
+    Total count of users present on a Database Instance.
     """
 
-    action: SecurityGroupRuleAction
+
+@dataclass
+class LogsPolicy:
     """
-    Action to apply when the rule matches a packet
+    Logs policy.
     """
 
-    protocol: SecurityGroupRuleProtocol
+    max_age_retention: Optional[int]
     """
-    Protocol family this rule applies to
+    Max age (in days) of remote logs to keep on the Database Instance.
     """
 
-    direction: SecurityGroupRuleDirection
+    total_disk_retention: Optional[int]
     """
-    Direction the rule applies to
+    Max disk size of remote logs to keep on the Database Instance.
     """
 
-    ip_range: str
+
+@dataclass
+class Maintenance:
     """
-    The range of IP address this rules applies to
+    Maintenance.
     """
 
-    dest_port_from: Optional[int]
+    starts_at: Optional[datetime]
     """
-    Beginning of the range of ports this rule applies to (inclusive). This value will be set to null if protocol is ICMP or ANY
+    Start date of the maintenance window.
     """
 
-    dest_port_to: Optional[int]
+    stops_at: Optional[datetime]
     """
-    End of the range of ports this rule applies to (inclusive). This value will be set to null if protocol is ICMP or ANY, or if it is equal to dest_port_from
+    End date of the maintenance window.
     """
 
-    position: int
+    closed_at: Optional[datetime]
     """
-    Position of this rule in the security group rules list. If several rules are passed with the same position, the resulting order is undefined
+    Closed maintenance date.
     """
 
-    editable: Optional[bool]
+    reason: str
     """
-    Indicates if this rule is editable. Rules with the value false will be ignored
+    Maintenance information message.
     """
 
-    zone: Zone
+    status: MaintenanceStatus
     """
-    Zone of the rule. This field is ignored
+    Status of the maintenance.
     """
 
 
 @dataclass
-class SetSecurityGroupRulesResponse:
-    rules: List[SecurityGroupRule]
-
+class NodeType:
+    """
+    Node type.
+    """
 
-@dataclass
-class Snapshot:
+    name: str
     """
-    Snapshot
+    Node Type name identifier.
     """
 
-    id: str
+    stock_status: NodeTypeStock
     """
-    The snapshot ID
+    Current stock status for the Node Type.
     """
 
-    name: str
+    description: str
     """
-    The snapshot name
+    Current specs of the offer.
     """
 
-    organization: str
+    vcpus: int
     """
-    The snapshot organization ID
+    Number of virtual CPUs.
     """
 
-    project: str
+    memory: int
     """
-    The snapshot project ID
+    Quantity of RAM.
     """
 
-    tags: List[str]
+    volume_constraint: Optional[NodeTypeVolumeConstraintSizes]
     """
-    The snapshot tags
+    [deprecated] Node Type volume constraints.
+    :deprecated
     """
 
-    volume_type: VolumeVolumeType
+    is_bssd_compatible: Optional[bool]
     """
-    The snapshot volume type
+    The Node Type is compliant with Block Storage.
+    :deprecated
     """
 
-    size: int
+    disabled: bool
     """
-    The snapshot size
+    The Node Type is currently disabled.
     """
 
-    state: SnapshotState
+    beta: bool
     """
-    The snapshot state
+    The Node Type is currently in beta.
     """
 
-    base_volume: Optional[SnapshotBaseVolume]
+    available_volume_types: List[NodeTypeVolumeType]
     """
-    The volume on which the snapshot is based on
+    Available storage options for the Node Type.
     """
 
-    creation_date: Optional[datetime]
+    is_ha_required: bool
     """
-    The snapshot creation date
+    The Node Type can be used only with high availability option.
     """
 
-    modification_date: Optional[datetime]
+    generation: NodeTypeGeneration
     """
-    The snapshot modification date
+    Generation associated with the NodeType offer.
     """
 
-    zone: Zone
+    instance_range: str
     """
-    The snapshot zone
+    Instance range associated with the NodeType offer.
     """
 
-    error_reason: Optional[str]
+    region: Region
     """
-    The reason for the failed snapshot import
+    Region the Node Type is in.
     """
 
 
 @dataclass
-class SnapshotBaseVolume:
+class NodeTypeVolumeConstraintSizes:
     """
-    Snapshot. base volume
+    Node type. volume constraint sizes.
     """
 
-    id: str
+    min_size: int
     """
-    The volume ID on which the snapshot is based on
+    [deprecated] Mimimum size required for the Volume.
     """
 
-    name: str
+    max_size: int
     """
-    The volume name on which the snapshot is based on
+    [deprecated] Maximum size required for the Volume.
     """
 
 
 @dataclass
-class Task:
+class NodeTypeVolumeType:
     """
-    Task
+    Node type. volume type.
     """
 
-    id: str
+    type_: VolumeType
     """
-    The unique ID of the task
+    Volume Type.
     """
 
     description: str
     """
-    The description of the task
+    The description of the Volume.
     """
 
-    progress: int
+    min_size: int
     """
-    The progress of the task in percent
+    Mimimum size required for the Volume.
     """
 
-    started_at: Optional[datetime]
+    max_size: int
     """
-    The task start date
+    Maximum size required for the Volume.
     """
 
-    terminated_at: Optional[datetime]
+    chunk_size: int
     """
-    The task end date
+    Minimum increment level for a Block Storage volume size.
     """
 
-    status: TaskStatus
+
+@dataclass
+class PrepareInstanceLogsResponse:
     """
-    The task status
+    Prepare instance logs response.
     """
 
-    href_from: str
-
-    href_result: str
-
-    zone: Zone
+    instance_logs: List[InstanceLog]
     """
-    The zone in which is the task
+    Instance logs for a Database Instance between a start and an end date.
     """
 
 
 @dataclass
-class UpdateIpResponse:
-    ip: Optional[Ip]
-
-
-@dataclass
-class UpdatePlacementGroupResponse:
-    placement_group: Optional[PlacementGroup]
-
-
-@dataclass
-class UpdatePlacementGroupServersResponse:
-    servers: List[PlacementGroupServer]
-
-
-@dataclass
-class UpdateServerResponse:
-    server: Optional[Server]
-
-
-@dataclass
-class UpdateVolumeResponse:
-    volume: Optional[Volume]
-
-
-@dataclass
-class Volume:
+class Privilege:
     """
-    Volume
+    Privilege.
     """
 
-    id: str
+    permission: Permission
     """
-    The volume unique ID
+    Permission (Read, Read/Write, All, Custom).
     """
 
-    name: str
+    database_name: str
     """
-    The volume name
+    Name of the database.
     """
 
-    export_uri: Optional[str]
+    user_name: str
     """
-    Show the volume NBD export URI
-    :deprecated
+    Name of the user.
     """
 
-    size: int
-    """
-    The volume disk size
-    """
 
-    volume_type: VolumeVolumeType
+@dataclass
+class ReadReplica:
     """
-    The volume type
+    Read replica.
     """
 
-    creation_date: Optional[datetime]
+    id: str
     """
-    The volume creation date
+    UUID of the Read Replica.
     """
 
-    modification_date: Optional[datetime]
+    endpoints: List[Endpoint]
     """
-    The volume modification date
+    Display Read Replica connection information.
     """
 
-    organization: str
+    status: ReadReplicaStatus
     """
-    The volume organization ID
+    Read replica status.
     """
 
-    project: str
+    region: Region
     """
-    The volume project ID
+    Region the Read Replica is in.
     """
 
-    tags: List[str]
+    same_zone: bool
     """
-    The volume tags
+    Whether the replica is in the same availability zone as the main instance nodes or not.
     """
 
-    server: Optional[ServerSummary]
+
+@dataclass
+class ReadReplicaEndpointSpec:
     """
-    The server attached to the volume
+    Read replica endpoint spec.
     """
 
-    state: VolumeState
+    direct_access: Optional[ReadReplicaEndpointSpecDirectAccess]
     """
-    The volume state
+    Direct access endpoint specifications. Public endpoint reserved for Read Replicas. One per Read Replica.
+    
+    One-of ('spec'): at most one of 'direct_access', 'private_network' could be set.
     """
 
-    zone: Zone
+    private_network: Optional[ReadReplicaEndpointSpecPrivateNetwork]
     """
-    The zone in which is the volume
+    Private Network endpoint specifications. One at the most per Read Replica. Cannot be updated (has to be deleted and recreated).
+    
+    One-of ('spec'): at most one of 'direct_access', 'private_network' could be set.
     """
 
 
 @dataclass
-class VolumeServer:
-    id: str
-
-    name: str
+class ReadReplicaEndpointSpecDirectAccess:
+    pass
 
-    export_uri: str
 
-    organization: str
-
-    server: Optional[ServerSummary]
-
-    size: int
-
-    volume_type: VolumeServerVolumeType
-
-    creation_date: Optional[datetime]
+@dataclass
+class ReadReplicaEndpointSpecPrivateNetwork:
+    """
+    Read replica endpoint spec. private network.
+    """
 
-    modification_date: Optional[datetime]
+    private_network_id: str
+    """
+    UUID of the Private Network to be connected to the Read Replica.
+    """
 
-    state: VolumeServerState
+    service_ip: Optional[str]
+    """
+    Endpoint IPv4 address with a CIDR notation. Refer to the official Scaleway documentation to learn more about IP and subnet limitations.
+    
+    One-of ('config'): at most one of 'service_ip', 'ipam_config' could be set.
+    """
 
-    project: str
+    ipam_config: Optional[ReadReplicaEndpointSpecPrivateNetworkIpamConfig]
+    """
+    Automated configuration of your Private Network endpoint with Scaleway IPAM service. One at the most per Database Instance or Read Replica (a Database Instance and its Read Replica can have different private networks). Cannot be updated (has to be deleted and recreated).
+    
+    One-of ('config'): at most one of 'service_ip', 'ipam_config' could be set.
+    """
 
-    boot: bool
 
-    zone: Zone
+@dataclass
+class ReadReplicaEndpointSpecPrivateNetworkIpamConfig:
+    pass
 
 
 @dataclass
-class VolumeServerTemplate:
+class SetInstanceACLRulesResponse:
     """
-    Volume server template
+    Set instance acl rules response.
     """
 
-    id: str
+    rules: List[ACLRule]
     """
-    UUID of the volume
+    ACLs rules configured for a Database Instance.
     """
 
-    boot: bool
+
+@dataclass
+class SetInstanceSettingsResponse:
     """
-    Force the server to boot on this volume
+    Set instance settings response.
     """
 
-    name: str
+    settings: List[InstanceSetting]
     """
-    Name of the volume
+    Settings configured for a Database Instance.
     """
 
-    size: int
+
+@dataclass
+class Snapshot:
     """
-    Disk size of the volume, must be a multiple of 512
+    Snapshot.
     """
 
-    volume_type: VolumeVolumeType
+    id: str
     """
-    Type of the volume
+    UUID of the snapshot.
     """
 
-    base_snapshot: str
+    instance_id: str
     """
-    The ID of the snapshot on which this volume will be based
+    UUID of the Database Instance.
     """
 
-    organization: str
+    name: str
     """
-    Organization ID of the volume
+    Name of the snapshot.
     """
 
-    project: str
+    status: SnapshotStatus
     """
-    Project ID of the volume
+    Status of the snapshot.
     """
 
-
-@dataclass
-class VolumeSummary:
-    id: str
-
-    name: str
-
-    size: int
-
-    volume_type: VolumeVolumeType
-
-
-@dataclass
-class VolumeTemplate:
+    size: Optional[int]
     """
-    Volume template
+    Size of the snapshot.
     """
 
-    id: str
+    expires_at: Optional[datetime]
     """
-    UUID of the volume
+    Expiration date (must follow the ISO 8601 format).
     """
 
-    name: str
+    created_at: Optional[datetime]
     """
-    Name of the volume
+    Creation date (must follow the ISO 8601 format).
     """
 
-    size: int
+    updated_at: Optional[datetime]
     """
-    Disk size of the volume, must be a multiple of 512
+    Updated date (must follow the ISO 8601 format).
     """
 
-    volume_type: VolumeVolumeType
+    instance_name: str
     """
-    Type of the volume
+    Name of the Database Instance of the snapshot.
     """
 
-    organization: Optional[str]
+    node_type: str
     """
-    Organization ID of the volume.
-    
-    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
-    :deprecated
+    Source node type.
     """
 
-    project: Optional[str]
+    region: Region
     """
-    Project ID of the volume.
-    
-    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
+    Region of this snapshot.
     """
 
 
 @dataclass
-class VolumeType:
-    display_name: str
-
-    capabilities: Optional[VolumeTypeCapabilities]
+class UpgradableVersion:
+    id: str
 
-    constraints: Optional[VolumeTypeConstraints]
+    name: str
 
+    version: str
 
-@dataclass
-class VolumeTypeCapabilities:
-    snapshot: bool
+    minor_version: str
 
 
 @dataclass
-class VolumeTypeConstraints:
-    min: int
-
-    max: int
+class User:
+    """
+    User.
+    """
 
+    name: str
+    """
+    Name of the user (Length must be between 1 and 63 characters for PostgreSQL and between 1 and 32 characters for MySQL. First character must be an alphabet character (a-zA-Z). Your username cannot start with '_rdb' or in PostgreSQL, 'pg_'. Only a-zA-Z0-9_$- characters are accepted).
+    """
 
-@dataclass
-class GetServerTypesAvailabilityRequest:
-    zone: Optional[Zone]
+    is_admin: bool
     """
-    Zone to target. If none is passed will use default zone from the config
+    Defines whether or not a user got administrative privileges on the Database Instance.
     """
 
-    per_page: Optional[int]
 
-    page: Optional[int]
+@dataclass
+class Volume:
+    type_: VolumeType
+
+    size: int
 
 
 @dataclass
-class ListServersTypesRequest:
-    zone: Optional[Zone]
+class ListDatabaseEnginesRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    per_page: Optional[int]
-
-    page: Optional[int]
-
-
-@dataclass
-class ListVolumesTypesRequest:
-    zone: Optional[Zone]
+    name: Optional[str]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Name of the database engine.
     """
 
-    per_page: Optional[int]
+    version: Optional[str]
+    """
+    Version of the database engine.
+    """
 
     page: Optional[int]
 
+    page_size: Optional[int]
+
 
 @dataclass
-class ListServersRequest:
-    zone: Optional[Zone]
+class ListNodeTypesRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    per_page: Optional[int]
+    include_disabled_types: bool
     """
-    A positive integer lower or equal to 100 to select the number of items to return
+    Defines whether or not to include disabled types.
     """
 
     page: Optional[int]
-    """
-    A positive integer to choose the page to return
-    """
 
-    organization: Optional[str]
-    """
-    List only servers of this organization ID
-    """
+    page_size: Optional[int]
 
-    project: Optional[str]
+
+@dataclass
+class ListDatabaseBackupsRequest:
+    region: Optional[Region]
     """
-    List only servers of this project ID
+    Region to target. If none is passed will use default region from the config.
     """
 
     name: Optional[str]
     """
-    Filter servers by name (for eg. "server1" will return "server100" and "server1" but not "foo")
+    Name of the database backups.
     """
 
-    private_ip: Optional[str]
+    order_by: Optional[ListDatabaseBackupsRequestOrderBy]
     """
-    List servers by private_ip
+    Criteria to use when ordering database backups listing.
     """
 
-    without_ip: Optional[bool]
+    instance_id: Optional[str]
     """
-    List servers that are not attached to a public IP
+    UUID of the Database Instance.
     """
 
-    commercial_type: Optional[str]
+    organization_id: Optional[str]
     """
-    List servers of this commercial type
+    Organization ID of the Organization the database backups belong to.
     """
 
-    state: Optional[ServerState]
+    project_id: Optional[str]
     """
-    List servers in this state
+    Project ID of the Project the database backups belong to.
     """
 
-    tags: Optional[List[str]]
-    """
-    List servers with these exact tags (to filter with several tags, use commas to separate them)
-    """
+    page: Optional[int]
 
-    private_network: Optional[str]
+    page_size: Optional[int]
+
+
+@dataclass
+class CreateDatabaseBackupRequest:
+    region: Optional[Region]
     """
-    List servers in this Private Network
+    Region to target. If none is passed will use default region from the config.
     """
 
-    order: Optional[ListServersRequestOrder]
+    instance_id: str
     """
-    Define the order of the returned servers
+    UUID of the Database Instance.
     """
 
-
-@dataclass
-class DeleteServerRequest:
-    zone: Optional[Zone]
+    database_name: str
     """
-    Zone to target. If none is passed will use default zone from the config
+    Name of the database you want to back up.
     """
 
-    server_id: str
-
-
-@dataclass
-class GetServerRequest:
-    zone: Optional[Zone]
+    name: Optional[str]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Name of the backup.
     """
 
-    server_id: str
+    expires_at: Optional[datetime]
     """
-    UUID of the server you want to get
+    Expiration date (must follow the ISO 8601 format).
     """
 
 
 @dataclass
-class ListServerActionsRequest:
-    zone: Optional[Zone]
+class GetDatabaseBackupRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    server_id: str
-
-
-@dataclass
-class ServerActionRequest:
-    zone: Optional[Zone]
+    database_backup_id: str
     """
-    Zone to target. If none is passed will use default zone from the config
+    UUID of the database backup.
     """
 
-    server_id: str
+
+@dataclass
+class UpdateDatabaseBackupRequest:
+    region: Optional[Region]
     """
-    UUID of the server
+    Region to target. If none is passed will use default region from the config.
     """
 
-    action: ServerAction
+    database_backup_id: str
     """
-    The action to perform on the server
+    UUID of the database backup to update.
     """
 
     name: Optional[str]
     """
-    The name of the backup you want to create.
-    This field should only be specified when performing a backup action.
-    
+    Name of the Database Backup.
     """
 
-    volumes: Optional[Dict[str, ServerActionRequestVolumeBackupTemplate]]
+    expires_at: Optional[datetime]
     """
-    For each volume UUID, the snapshot parameters of the volume.
-    This field should only be specified when performing a backup action.
-    
+    Expiration date (must follow the ISO 8601 format).
     """
 
 
 @dataclass
-class ListServerUserDataRequest:
-    zone: Optional[Zone]
+class DeleteDatabaseBackupRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    server_id: str
+    database_backup_id: str
     """
-    UUID of the server
+    UUID of the database backup to delete.
     """
 
 
 @dataclass
-class DeleteServerUserDataRequest:
-    zone: Optional[Zone]
+class RestoreDatabaseBackupRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    server_id: str
+    database_backup_id: str
     """
-    UUID of the server
+    Backup of a logical database.
     """
 
-    key: str
+    database_name: Optional[str]
     """
-    Key of the user data to delete
+    Defines the destination database to restore into a specified database (the default destination is set to the origin database of the backup).
     """
 
-
-@dataclass
-class ListImagesRequest:
-    zone: Optional[Zone]
+    instance_id: str
     """
-    Zone to target. If none is passed will use default zone from the config
+    Defines the Database Instance where the backup has to be restored.
     """
 
-    organization: Optional[str]
-
-    per_page: Optional[int]
-
-    page: Optional[int]
-
-    name: Optional[str]
-
-    public: Optional[bool]
-
-    arch: Optional[str]
-
-    project: Optional[str]
-
-    tags: Optional[str]
-
 
 @dataclass
-class GetImageRequest:
-    zone: Optional[Zone]
+class ExportDatabaseBackupRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    image_id: str
+    database_backup_id: str
     """
-    UUID of the image you want to get
+    UUID of the database backup you want to export.
     """
 
 
 @dataclass
-class CreateImageRequest:
-    zone: Optional[Zone]
+class UpgradeInstanceRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    name: Optional[str]
+    instance_id: str
     """
-    Name of the image
+    UUID of the Database Instance you want to upgrade.
     """
 
-    root_volume: str
+    node_type: Optional[str]
     """
-    UUID of the snapshot
+    Node type of the Database Instance you want to upgrade to.
+    
+    One-of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id' could be set.
     """
 
-    arch: Optional[Arch]
+    enable_ha: Optional[bool]
     """
-    Architecture of the image
+    Defines whether or not high availability should be enabled on the Database Instance.
+    
+    One-of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id' could be set.
     """
 
-    default_bootscript: Optional[str]
+    volume_size: Optional[int]
     """
-    Default bootscript of the image
-    :deprecated
+    Increase your block storage volume size.
+    
+    One-of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id' could be set.
     """
 
-    extra_volumes: Optional[Dict[str, VolumeTemplate]]
+    volume_type: Optional[VolumeType]
     """
-    Additional volumes of the image
+    Change your Database Instance storage type.
+    
+    One-of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id' could be set.
     """
 
-    organization: Optional[str]
+    upgradable_version_id: Optional[str]
     """
-    Organization ID of the image.
+    Update your database engine to a newer version.
+    This will create a new Database Instance with same specifications as the current one and perform a Database Engine upgrade.
     
-    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
-    :deprecated
+    One-of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id' could be set.
     """
 
-    project: Optional[str]
+
+@dataclass
+class ListInstancesRequest:
+    region: Optional[Region]
     """
-    Project ID of the image.
-    
-    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
+    Region to target. If none is passed will use default region from the config.
     """
 
     tags: Optional[List[str]]
     """
-    The tags of the image
+    List Database Instances that have a given tag.
     """
 
-    public: Optional[bool]
+    name: Optional[str]
     """
-    True to create a public image
+    Lists Database Instances that match a name pattern.
     """
 
-
-@dataclass
-class DeleteImageRequest:
-    zone: Optional[Zone]
+    order_by: Optional[ListInstancesRequestOrderBy]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Criteria to use when ordering Database Instance listings.
     """
 
-    image_id: str
+    organization_id: Optional[str]
     """
-    UUID of the image you want to delete
+    Please use project_id instead.
     """
 
-
-@dataclass
-class ListSnapshotsRequest:
-    zone: Optional[Zone]
+    project_id: Optional[str]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Project ID to list the Database Instance of.
     """
 
-    organization: Optional[str]
-
-    per_page: Optional[int]
-
     page: Optional[int]
 
-    name: Optional[str]
-
-    project: Optional[str]
-
-    tags: Optional[str]
+    page_size: Optional[int]
 
 
 @dataclass
-class CreateSnapshotRequest:
-    zone: Optional[Zone]
+class GetInstanceRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    name: Optional[str]
+    instance_id: str
     """
-    Name of the snapshot
+    UUID of the Database Instance.
     """
 
-    volume_id: Optional[str]
-    """
-    UUID of the volume
-    """
 
-    tags: Optional[List[str]]
+@dataclass
+class CreateInstanceRequest:
+    region: Optional[Region]
     """
-    The tags of the snapshot
+    Region to target. If none is passed will use default region from the config.
     """
 
-    organization: Optional[str]
+    organization_id: Optional[str]
     """
-    Organization ID of the snapshot.
+    Please use project_id instead.
     
-    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
+    One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
     :deprecated
     """
 
-    project: Optional[str]
+    project_id: Optional[str]
     """
-    Project ID of the snapshot.
+    The Project ID on which the Database Instance will be created.
     
-    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
+    One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
     """
 
-    volume_type: SnapshotVolumeType
+    name: Optional[str]
     """
-    Overrides the volume_type of the snapshot.
-    If omitted, the volume type of the original volume will be used.
-    
+    Name of the Database Instance.
     """
 
-    bucket: Optional[str]
+    engine: str
     """
-    Bucket name for snapshot imports
+    Database engine of the Database Instance (PostgreSQL, MySQL, ...).
     """
 
-    key: Optional[str]
+    user_name: str
     """
-    Object key for snapshot imports
+    Username created when the Database Instance is created.
     """
 
-    size: Optional[int]
+    password: str
     """
-    Imported snapshot size, must be a multiple of 512
+    Password of the user.
     """
 
-
-@dataclass
-class GetSnapshotRequest:
-    zone: Optional[Zone]
+    node_type: str
     """
-    Zone to target. If none is passed will use default zone from the config
+    Type of node to use for the Database Instance.
     """
 
-    snapshot_id: str
+    is_ha_cluster: bool
     """
-    UUID of the snapshot you want to get
+    Defines whether or not High-Availability is enabled.
     """
 
-
-@dataclass
-class DeleteSnapshotRequest:
-    zone: Optional[Zone]
+    disable_backup: bool
     """
-    Zone to target. If none is passed will use default zone from the config
+    Defines whether or not backups are disabled.
     """
 
-    snapshot_id: str
+    tags: Optional[List[str]]
     """
-    UUID of the snapshot you want to delete
+    Tags to apply to the Database Instance.
     """
 
+    init_settings: Optional[List[InstanceSetting]]
+    """
+    List of engine settings to be set upon Database Instance initialization.
+    """
 
-@dataclass
-class ExportSnapshotRequest:
-    zone: Optional[Zone]
+    volume_type: VolumeType
     """
-    Zone to target. If none is passed will use default zone from the config
+    Type of volume where data is stored (lssd, bssd, ...).
     """
 
-    snapshot_id: str
+    volume_size: int
     """
-    The snapshot ID
+    Volume size when volume_type is not lssd.
     """
 
-    bucket: str
+    init_endpoints: Optional[List[EndpointSpec]]
     """
-    S3 bucket name
+    One or multiple EndpointSpec used to expose your Database Instance. A load_balancer public endpoint is systematically created.
     """
 
-    key: str
+    backup_same_region: bool
     """
-    S3 object key
+    Defines whether to or not to store logical backups in the same region as the Database Instance.
     """
 
 
 @dataclass
-class ListVolumesRequest:
-    zone: Optional[Zone]
+class UpdateInstanceRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    volume_type: Optional[VolumeVolumeType]
+    instance_id: str
     """
-    Filter by volume type
+    UUID of the Database Instance to update.
     """
 
-    per_page: Optional[int]
+    backup_schedule_frequency: Optional[int]
     """
-    A positive integer lower or equal to 100 to select the number of items to return
+    In hours.
     """
 
-    page: Optional[int]
+    backup_schedule_retention: Optional[int]
     """
-    A positive integer to choose the page to return
+    In days.
     """
 
-    organization: Optional[str]
+    is_backup_schedule_disabled: Optional[bool]
     """
-    Filter volume by organization ID
+    Defines whether or not the backup schedule is disabled.
     """
 
-    project: Optional[str]
+    name: Optional[str]
     """
-    Filter volume by project ID
+    Name of the Database Instance.
     """
 
     tags: Optional[List[str]]
     """
-    Filter volumes with these exact tags (to filter with several tags, use commas to separate them)
+    Tags of a Database Instance.
     """
 
-    name: Optional[str]
+    logs_policy: Optional[LogsPolicy]
     """
-    Filter volume by name (for eg. "vol" will return "myvolume" but not "data")
+    Logs policy of the Database Instance.
     """
 
+    backup_same_region: Optional[bool]
+    """
+    Store logical backups in the same region as the Database Instance.
+    """
 
-@dataclass
-class CreateVolumeRequest:
-    zone: Optional[Zone]
+    backup_schedule_start_hour: Optional[int]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Defines the start time of the autobackup.
     """
 
-    name: Optional[str]
+
+@dataclass
+class DeleteInstanceRequest:
+    region: Optional[Region]
     """
-    The volume name
+    Region to target. If none is passed will use default region from the config.
     """
 
-    organization: Optional[str]
+    instance_id: str
     """
-    The volume organization ID.
-    
-    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
-    :deprecated
+    UUID of the Database Instance to delete.
     """
 
-    project: Optional[str]
+
+@dataclass
+class CloneInstanceRequest:
+    region: Optional[Region]
     """
-    The volume project ID.
-    
-    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    tags: Optional[List[str]]
+    instance_id: str
     """
-    The volume tags
+    UUID of the Database Instance you want to clone.
     """
 
-    volume_type: VolumeVolumeType
+    name: str
     """
-    The volume type
+    Name of the Database Instance clone.
     """
 
-    size: Optional[int]
+    node_type: Optional[str]
     """
-    The volume disk size, must be a multiple of 512.
-    
-    One-of ('from_'): at most one of 'size', 'base_volume', 'base_snapshot' could be set.
+    Node type of the clone.
     """
 
-    base_volume: Optional[str]
+
+@dataclass
+class RestartInstanceRequest:
+    region: Optional[Region]
     """
-    The ID of the volume on which this volume will be based.
-    
-    One-of ('from_'): at most one of 'size', 'base_volume', 'base_snapshot' could be set.
+    Region to target. If none is passed will use default region from the config.
     """
 
-    base_snapshot: Optional[str]
+    instance_id: str
     """
-    The ID of the snapshot on which this volume will be based.
-    
-    One-of ('from_'): at most one of 'size', 'base_volume', 'base_snapshot' could be set.
+    UUID of the Database Instance you want to restart.
     """
 
 
 @dataclass
-class GetVolumeRequest:
-    zone: Optional[Zone]
+class GetInstanceCertificateRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    volume_id: str
+    instance_id: str
     """
-    UUID of the volume you want to get
+    UUID of the Database Instance.
     """
 
 
 @dataclass
-class UpdateVolumeRequest:
-    zone: Optional[Zone]
+class RenewInstanceCertificateRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    volume_id: str
+    instance_id: str
     """
-    UUID of the volume
+    UUID of the Database Instance you want logs of.
     """
 
-    name: Optional[str]
+
+@dataclass
+class GetInstanceMetricsRequest:
+    region: Optional[Region]
     """
-    The volume name
+    Region to target. If none is passed will use default region from the config.
     """
 
-    tags: Optional[List[str]]
+    instance_id: str
     """
-    The tags of the volume
+    UUID of the Database Instance.
     """
 
-    size: Optional[int]
+    start_date: Optional[datetime]
     """
-    The volume disk size, must be a multiple of 512
+    Start date to gather metrics from.
     """
 
-
-@dataclass
-class DeleteVolumeRequest:
-    zone: Optional[Zone]
+    end_date: Optional[datetime]
     """
-    Zone to target. If none is passed will use default zone from the config
+    End date to gather metrics from.
     """
 
-    volume_id: str
+    metric_name: Optional[str]
     """
-    UUID of the volume you want to delete
+    Name of the metric to gather.
     """
 
 
 @dataclass
-class ListSecurityGroupsRequest:
-    zone: Optional[Zone]
+class CreateReadReplicaRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    name: Optional[str]
+    instance_id: str
     """
-    Name of the security group
+    UUID of the Database Instance you want to create a Read Replica from.
     """
 
-    organization: Optional[str]
+    endpoint_spec: Optional[List[ReadReplicaEndpointSpec]]
     """
-    The security group organization ID
+    Specification of the endpoint you want to create.
     """
 
-    project: Optional[str]
+    same_zone: Optional[bool]
     """
-    The security group project ID
+    Defines whether to create the replica in the same availability zone as the main instance nodes or not.
     """
 
-    tags: Optional[List[str]]
+
+@dataclass
+class GetReadReplicaRequest:
+    region: Optional[Region]
     """
-    List security groups with these exact tags (to filter with several tags, use commas to separate them)
+    Region to target. If none is passed will use default region from the config.
     """
 
-    project_default: Optional[bool]
+    read_replica_id: str
     """
-    Filter security groups with this value for project_default
+    UUID of the Read Replica.
     """
 
-    per_page: Optional[int]
+
+@dataclass
+class DeleteReadReplicaRequest:
+    region: Optional[Region]
     """
-    A positive integer lower or equal to 100 to select the number of items to return
+    Region to target. If none is passed will use default region from the config.
     """
 
-    page: Optional[int]
+    read_replica_id: str
     """
-    A positive integer to choose the page to return
+    UUID of the Read Replica.
     """
 
 
 @dataclass
-class CreateSecurityGroupRequest:
-    zone: Optional[Zone]
+class ResetReadReplicaRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    name: Optional[str]
+    read_replica_id: str
     """
-    Name of the security group
+    UUID of the Read Replica.
     """
 
-    description: str
-    """
-    Description of the security group
-    """
 
-    organization: Optional[str]
+@dataclass
+class PromoteReadReplicaRequest:
+    region: Optional[Region]
     """
-    Organization ID the security group belongs to.
-    
-    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
-    :deprecated
+    Region to target. If none is passed will use default region from the config.
     """
 
-    project: Optional[str]
+    read_replica_id: str
     """
-    Project ID the security group belong to.
-    
-    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
+    UUID of the Read Replica.
     """
 
-    tags: Optional[List[str]]
+
+@dataclass
+class CreateReadReplicaEndpointRequest:
+    region: Optional[Region]
     """
-    The tags of the security group
+    Region to target. If none is passed will use default region from the config.
     """
 
-    organization_default: Optional[bool]
+    read_replica_id: str
     """
-    Whether this security group becomes the default security group for new instances.
-    
-    One-of ('default_identifier'): at most one of 'organization_default', 'project_default' could be set.
-    :deprecated
+    UUID of the Read Replica.
     """
 
-    project_default: Optional[bool]
+    endpoint_spec: List[ReadReplicaEndpointSpec]
     """
-    Whether this security group becomes the default security group for new instances.
-    
-    One-of ('default_identifier'): at most one of 'organization_default', 'project_default' could be set.
+    Specification of the endpoint you want to create.
     """
 
-    stateful: bool
+
+@dataclass
+class PrepareInstanceLogsRequest:
+    region: Optional[Region]
     """
-    Whether the security group is stateful or not
+    Region to target. If none is passed will use default region from the config.
     """
 
-    inbound_default_policy: SecurityGroupPolicy
+    instance_id: str
     """
-    Default policy for inbound rules
+    UUID of the Database Instance you want logs of.
     """
 
-    outbound_default_policy: SecurityGroupPolicy
+    start_date: Optional[datetime]
     """
-    Default policy for outbound rules
+    Start datetime of your log. (RFC 3339 format).
     """
 
-    enable_default_security: Optional[bool]
+    end_date: Optional[datetime]
     """
-    True to block SMTP on IPv4 and IPv6
+    End datetime of your log. (RFC 3339 format).
     """
 
 
 @dataclass
-class GetSecurityGroupRequest:
-    zone: Optional[Zone]
+class ListInstanceLogsRequest:
+    region: Optional[Region]
+    """
+    Region to target. If none is passed will use default region from the config.
     """
-    Zone to target. If none is passed will use default zone from the config
+
+    instance_id: str
+    """
+    UUID of the Database Instance you want logs of.
     """
 
-    security_group_id: str
+    order_by: ListInstanceLogsRequestOrderBy
     """
-    UUID of the security group you want to get
+    Criteria to use when ordering Database Instance logs listing.
     """
 
 
 @dataclass
-class DeleteSecurityGroupRequest:
-    zone: Optional[Zone]
+class GetInstanceLogRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    security_group_id: str
+    instance_log_id: str
     """
-    UUID of the security group you want to delete
+    UUID of the instance_log you want.
     """
 
 
 @dataclass
-class ListDefaultSecurityGroupRulesRequest:
-    zone: Optional[Zone]
+class PurgeInstanceLogsRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-
-@dataclass
-class ListSecurityGroupRulesRequest:
-    zone: Optional[Zone]
+    instance_id: str
     """
-    Zone to target. If none is passed will use default zone from the config
+    UUID of the Database Instance you want logs of.
     """
 
-    security_group_id: str
+    log_name: Optional[str]
     """
-    UUID of the security group
+    Given log name to purge.
     """
 
-    per_page: Optional[int]
+
+@dataclass
+class ListInstanceLogsDetailsRequest:
+    region: Optional[Region]
     """
-    A positive integer lower or equal to 100 to select the number of items to return
+    Region to target. If none is passed will use default region from the config.
     """
 
-    page: Optional[int]
+    instance_id: str
     """
-    A positive integer to choose the page to return
+    UUID of the Database Instance you want logs of.
     """
 
 
 @dataclass
-class CreateSecurityGroupRuleRequest:
-    zone: Optional[Zone]
+class AddInstanceSettingsRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    security_group_id: str
+    instance_id: str
     """
-    UUID of the security group
+    UUID of the Database Instance you want to add settings to.
     """
 
-    protocol: Optional[SecurityGroupRuleProtocol]
-
-    direction: Optional[SecurityGroupRuleDirection]
-
-    action: Optional[SecurityGroupRuleAction]
-
-    ip_range: str
-
-    dest_port_from: Optional[int]
+    settings: List[InstanceSetting]
     """
-    The beginning of the range of ports to apply this rule to (inclusive)
+    Settings to add to the Database Instance.
     """
 
-    dest_port_to: Optional[int]
+
+@dataclass
+class DeleteInstanceSettingsRequest:
+    region: Optional[Region]
     """
-    The end of the range of ports to apply this rule to (inclusive)
+    Region to target. If none is passed will use default region from the config.
     """
 
-    position: int
+    instance_id: str
     """
-    The position of this rule in the security group rules list
+    UUID of the Database Instance to delete settings from.
     """
 
-    editable: bool
+    setting_names: List[str]
     """
-    Indicates if this rule is editable (will be ignored)
+    Settings names to delete.
     """
 
 
 @dataclass
-class SetSecurityGroupRulesRequest:
-    zone: Optional[Zone]
+class SetInstanceSettingsRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    security_group_id: str
+    instance_id: str
     """
-    UUID of the security group to update the rules on
+    UUID of the Database Instance where the settings must be set.
     """
 
-    rules: Optional[List[SetSecurityGroupRulesRequestRule]]
+    settings: List[InstanceSetting]
     """
-    List of rules to update in the security group
+    Settings to define for the Database Instance.
     """
 
 
 @dataclass
-class DeleteSecurityGroupRuleRequest:
-    zone: Optional[Zone]
+class ListInstanceACLRulesRequest:
+    region: Optional[Region]
+    """
+    Region to target. If none is passed will use default region from the config.
+    """
+
+    instance_id: str
     """
-    Zone to target. If none is passed will use default zone from the config
+    UUID of the Database Instance.
     """
 
-    security_group_id: str
+    page: Optional[int]
 
-    security_group_rule_id: str
+    page_size: Optional[int]
 
 
 @dataclass
-class GetSecurityGroupRuleRequest:
-    zone: Optional[Zone]
+class AddInstanceACLRulesRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    security_group_id: str
+    instance_id: str
+    """
+    UUID of the Database Instance you want to add ACL rules to.
+    """
 
-    security_group_rule_id: str
+    rules: List[ACLRuleRequest]
+    """
+    ACL rules to add to the Database Instance.
+    """
 
 
 @dataclass
-class ListPlacementGroupsRequest:
-    zone: Optional[Zone]
+class SetInstanceACLRulesRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    per_page: Optional[int]
+    instance_id: str
     """
-    A positive integer lower or equal to 100 to select the number of items to return
+    UUID of the Database Instance where the ACL rules must be set.
     """
 
-    page: Optional[int]
+    rules: List[ACLRuleRequest]
     """
-    A positive integer to choose the page to return
+    ACL rules to define for the Database Instance.
     """
 
-    organization: Optional[str]
-    """
-    List only placement groups of this organization ID
-    """
 
-    project: Optional[str]
+@dataclass
+class DeleteInstanceACLRulesRequest:
+    region: Optional[Region]
     """
-    List only placement groups of this project ID
+    Region to target. If none is passed will use default region from the config.
     """
 
-    tags: Optional[List[str]]
+    instance_id: str
     """
-    List placement groups with these exact tags (to filter with several tags, use commas to separate them)
+    UUID of the Database Instance you want to delete an ACL rule from.
     """
 
-    name: Optional[str]
+    acl_rule_ips: List[str]
     """
-    Filter placement groups by name (for eg. "cluster1" will return "cluster100" and "cluster1" but not "foo")
+    IP addresses defined in the ACL rules of the Database Instance.
     """
 
 
 @dataclass
-class CreatePlacementGroupRequest:
-    zone: Optional[Zone]
+class ListUsersRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    name: Optional[str]
+    instance_id: str
     """
-    Name of the placement group
+    UUID of the Database Instance.
     """
 
-    organization: Optional[str]
+    name: Optional[str]
     """
-    Organization ID of the placement group.
-    
-    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
-    :deprecated
+    Name of the user.
     """
 
-    project: Optional[str]
+    order_by: Optional[ListUsersRequestOrderBy]
     """
-    Project ID of the placement group.
-    
-    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
+    Criteria to use when requesting user listing.
     """
 
-    tags: Optional[List[str]]
+    page: Optional[int]
+
+    page_size: Optional[int]
+
+
+@dataclass
+class CreateUserRequest:
+    region: Optional[Region]
     """
-    The tags of the placement group
+    Region to target. If none is passed will use default region from the config.
     """
 
-    policy_mode: PlacementGroupPolicyMode
+    instance_id: str
     """
-    The operating mode of the placement group
+    UUID of the Database Instance in which you want to create a user.
     """
 
-    policy_type: PlacementGroupPolicyType
+    name: str
     """
-    The policy type of the placement group
+    Name of the user you want to create.
     """
 
-
-@dataclass
-class GetPlacementGroupRequest:
-    zone: Optional[Zone]
+    password: str
     """
-    Zone to target. If none is passed will use default zone from the config
+    Password of the user you want to create.
     """
 
-    placement_group_id: str
+    is_admin: bool
     """
-    UUID of the placement group you want to get
+    Defines whether the user will have administrative privileges.
     """
 
 
 @dataclass
-class SetPlacementGroupRequest:
-    zone: Optional[Zone]
+class UpdateUserRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    placement_group_id: str
+    instance_id: str
+    """
+    UUID of the Database Instance the user belongs to.
+    """
 
     name: str
-
-    organization: Optional[str]
-
-    policy_mode: PlacementGroupPolicyMode
-
-    policy_type: PlacementGroupPolicyType
-
-    project: Optional[str]
-
-    tags: Optional[List[str]]
-
-
-@dataclass
-class UpdatePlacementGroupRequest:
-    zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Name of the database user.
     """
 
-    placement_group_id: str
+    password: Optional[str]
     """
-    UUID of the placement group
+    Password of the database user.
     """
 
-    name: Optional[str]
+    is_admin: Optional[bool]
     """
-    Name of the placement group
+    Defines whether or not this user got administrative privileges.
     """
 
-    tags: Optional[List[str]]
+
+@dataclass
+class DeleteUserRequest:
+    region: Optional[Region]
     """
-    The tags of the placement group
+    Region to target. If none is passed will use default region from the config.
     """
 
-    policy_mode: Optional[PlacementGroupPolicyMode]
+    instance_id: str
     """
-    The operating mode of the placement group
+    UUID of the Database Instance to delete the user from.
     """
 
-    policy_type: Optional[PlacementGroupPolicyType]
+    name: str
     """
-    The policy type of the placement group
+    Name of the user.
     """
 
 
 @dataclass
-class DeletePlacementGroupRequest:
-    zone: Optional[Zone]
+class ListDatabasesRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    placement_group_id: str
+    instance_id: str
     """
-    UUID of the placement group you want to delete
+    UUID of the Database Instance to list the databases of.
     """
 
-
-@dataclass
-class GetPlacementGroupServersRequest:
-    zone: Optional[Zone]
+    name: Optional[str]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Name of the database.
     """
 
-    placement_group_id: str
+    managed: Optional[bool]
+    """
+    Defines whether or not the database is managed.
+    """
 
+    owner: Optional[str]
+    """
+    User that owns this database.
+    """
 
-@dataclass
-class SetPlacementGroupServersRequest:
-    zone: Optional[Zone]
+    order_by: Optional[ListDatabasesRequestOrderBy]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Criteria to use when ordering database listing.
     """
 
-    placement_group_id: str
+    page: Optional[int]
 
-    servers: Optional[List[str]]
+    page_size: Optional[int]
 
 
 @dataclass
-class UpdatePlacementGroupServersRequest:
-    zone: Optional[Zone]
+class CreateDatabaseRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    placement_group_id: str
+    instance_id: str
     """
-    UUID of the placement group
+    UUID of the Database Instance where to create the database.
     """
 
-    servers: List[str]
+    name: str
+    """
+    Name of the database.
+    """
 
 
 @dataclass
-class ListIpsRequest:
-    zone: Optional[Zone]
+class DeleteDatabaseRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    project: Optional[str]
+    instance_id: str
     """
-    The project ID the IPs are reserved in
+    UUID of the Database Instance where to delete the database.
     """
 
-    organization: Optional[str]
+    name: str
     """
-    The organization ID the IPs are reserved in
+    Name of the database to delete.
     """
 
-    tags: Optional[List[str]]
+
+@dataclass
+class ListPrivilegesRequest:
+    region: Optional[Region]
     """
-    Filter IPs with these exact tags (to filter with several tags, use commas to separate them)
+    Region to target. If none is passed will use default region from the config.
     """
 
-    name: Optional[str]
+    instance_id: str
     """
-    Filter on the IP address (Works as a LIKE operation on the IP address)
+    UUID of the Database Instance.
     """
 
-    per_page: Optional[int]
+    order_by: Optional[ListPrivilegesRequestOrderBy]
     """
-    A positive integer lower or equal to 100 to select the number of items to return
+    Criteria to use when ordering privileges listing.
     """
 
     page: Optional[int]
+
+    page_size: Optional[int]
+
+    database_name: Optional[str]
+    """
+    Name of the database.
+    """
+
+    user_name: Optional[str]
     """
-    A positive integer to choose the page to return
+    Name of the user.
     """
 
 
 @dataclass
-class CreateIpRequest:
-    zone: Optional[Zone]
+class SetPrivilegeRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    organization: Optional[str]
+    instance_id: str
     """
-    The organization ID the IP is reserved in.
-    
-    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
-    :deprecated
+    UUID of the Database Instance.
     """
 
-    project: Optional[str]
+    database_name: str
     """
-    The project ID the IP is reserved in.
-    
-    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
+    Name of the database.
     """
 
-    tags: Optional[List[str]]
+    user_name: str
     """
-    The tags of the IP
+    Name of the user.
     """
 
-    server: Optional[str]
+    permission: Permission
     """
-    UUID of the server you want to attach the IP to
+    Permission to set (Read, Read/Write, All, Custom).
     """
 
 
 @dataclass
-class GetIpRequest:
-    zone: Optional[Zone]
+class ListSnapshotsRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    ip: str
+    name: Optional[str]
     """
-    The IP ID or address to get
+    Name of the snapshot.
     """
 
-
-@dataclass
-class UpdateIpRequest:
-    zone: Optional[Zone]
+    order_by: Optional[ListSnapshotsRequestOrderBy]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Criteria to use when ordering snapshot listing.
     """
 
-    ip: str
+    instance_id: Optional[str]
     """
-    IP ID or IP address
+    UUID of the Database Instance.
     """
 
-    reverse: Optional[str]
+    organization_id: Optional[str]
     """
-    Reverse domain name
+    Organization ID the snapshots belongs to.
     """
 
-    tags: Optional[List[str]]
+    project_id: Optional[str]
     """
-    An array of keywords you want to tag this IP with
+    Project ID the snapshots belongs to.
     """
 
-    server: Optional[str]
+    page: Optional[int]
+
+    page_size: Optional[int]
 
 
 @dataclass
-class DeleteIpRequest:
-    zone: Optional[Zone]
+class GetSnapshotRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    ip: str
+    snapshot_id: str
     """
-    The ID or the address of the IP to delete
+    UUID of the snapshot.
     """
 
 
 @dataclass
-class ListPrivateNICsRequest:
-    zone: Optional[Zone]
-    """
-    Zone to target. If none is passed will use default zone from the config
-    """
-
-    server_id: str
+class CreateSnapshotRequest:
+    region: Optional[Region]
     """
-    The server the private NIC is attached to
+    Region to target. If none is passed will use default region from the config.
     """
 
-    tags: Optional[List[str]]
+    instance_id: str
     """
-    The private NIC tags
+    UUID of the Database Instance.
     """
 
-    per_page: Optional[int]
+    name: Optional[str]
     """
-    A positive integer lower or equal to 100 to select the number of items to return
+    Name of the snapshot.
     """
 
-    page: Optional[int]
+    expires_at: Optional[datetime]
     """
-    A positive integer to choose the page to return
+    Expiration date (must follow the ISO 8601 format).
     """
 
 
 @dataclass
-class CreatePrivateNICRequest:
-    zone: Optional[Zone]
+class UpdateSnapshotRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    server_id: str
+    snapshot_id: str
     """
-    UUID of the server the private NIC will be attached to
+    UUID of the snapshot to update.
     """
 
-    private_network_id: str
+    name: Optional[str]
     """
-    UUID of the private network where the private NIC will be attached
+    Name of the snapshot.
     """
 
-    tags: Optional[List[str]]
+    expires_at: Optional[datetime]
     """
-    The private NIC tags
+    Expiration date (must follow the ISO 8601 format).
     """
 
 
 @dataclass
-class GetPrivateNICRequest:
-    zone: Optional[Zone]
+class DeleteSnapshotRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    server_id: str
+    snapshot_id: str
     """
-    The server the private NIC is attached to
+    UUID of the snapshot to delete.
     """
 
-    private_nic_id: str
+
+@dataclass
+class CreateInstanceFromSnapshotRequest:
+    region: Optional[Region]
     """
-    The private NIC unique ID
+    Region to target. If none is passed will use default region from the config.
     """
 
-
-@dataclass
-class UpdatePrivateNICRequest:
-    zone: Optional[Zone]
+    snapshot_id: str
     """
-    Zone to target. If none is passed will use default zone from the config
+    Block snapshot of the Database Instance.
     """
 
-    server_id: str
+    instance_name: str
     """
-    UUID of the server the private NIC will be attached to
+    Name of the Database Instance created with the snapshot.
     """
 
-    private_nic_id: str
+    is_ha_cluster: Optional[bool]
     """
-    The private NIC unique ID
+    Defines whether or not High-Availability is enabled on the new Database Instance.
     """
 
-    tags: Optional[List[str]]
+    node_type: Optional[str]
     """
-    Tags used to select private NIC/s
+    The node type used to restore the snapshot.
     """
 
 
 @dataclass
-class DeletePrivateNICRequest:
-    zone: Optional[Zone]
+class CreateEndpointRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    server_id: str
+    instance_id: str
     """
-    The server the private NIC is attached to
+    UUID of the Database Instance you to which you want to add an endpoint.
     """
 
-    private_nic_id: str
+    endpoint_spec: Optional[EndpointSpec]
     """
-    The private NIC unique ID
+    Specification of the endpoint you want to create.
     """
 
 
 @dataclass
-class ListBootscriptsRequest:
-    zone: Optional[Zone]
+class DeleteEndpointRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    arch: Optional[str]
-
-    title: Optional[str]
-
-    default: Optional[bool]
-
-    public: Optional[bool]
-
-    per_page: Optional[int]
-
-    page: Optional[int]
+    endpoint_id: str
+    """
+    UUID of the endpoint you want to delete.
+    This endpoint can also be used to delete a Read Replica endpoint.
+    """
 
 
 @dataclass
-class GetBootscriptRequest:
-    zone: Optional[Zone]
+class GetEndpointRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    bootscript_id: str
+    endpoint_id: str
+    """
+    UUID of the endpoint you want to get.
+    """
 
 
 @dataclass
-class GetDashboardRequest:
-    zone: Optional[Zone]
+class MigrateEndpointRequest:
+    region: Optional[Region]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    organization: Optional[str]
+    endpoint_id: str
+    """
+    UUID of the endpoint you want to migrate.
+    """
 
-    project: Optional[str]
+    instance_id: str
+    """
+    UUID of the instance you want to attach the endpoint to.
+    """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/instance/v1/types_private.py` & `scaleway_async-1.0.0/scaleway_async/instance/v1/types_private.py`

 * *Files 18% similar despite different names*

```diff
@@ -42,344 +42,380 @@
     VolumeVolumeType,
 )
 
 
 @dataclass
 class _SetImageResponse:
     """
-    Set image response
+    Set image response.
     """
 
     image: Optional[Image]
 
 
 @dataclass
 class _SetSecurityGroupResponse:
     """
-    Set security group response
+    Set security group response.
     """
 
     security_group: Optional[SecurityGroup]
 
 
 @dataclass
 class _SetSecurityGroupRuleResponse:
     """
-    Set security group rule response
+    Set security group rule response.
     """
 
     rule: Optional[SecurityGroupRule]
 
 
 @dataclass
 class _SetServerResponse:
     """
-    Set server response
+    Set server response.
     """
 
     server: Optional[Server]
 
 
 @dataclass
 class _SetSnapshotResponse:
     """
-    Set snapshot response
+    Set snapshot response.
     """
 
     snapshot: Optional[Snapshot]
 
 
 @dataclass
 class _CreateServerRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     name: Optional[str]
     """
-    The server name
+    Instance name.
     """
 
     dynamic_ip_required: Optional[bool]
     """
-    Define if a dynamic IP is required for the instance
+    Define if a dynamic IPv4 is required for the Instance.
+    """
+
+    routed_ip_enabled: Optional[bool]
+    """
+    If true, configure the Instance so it uses the new routed IP mode.
     """
 
     commercial_type: str
     """
-    Define the server commercial type (i.e. GP1-S)
+    Define the Instance commercial type (i.e. GP1-S).
     """
 
     image: str
     """
-    The server image ID or label
+    Instance image ID or label.
     """
 
     volumes: Optional[Dict[str, VolumeServerTemplate]]
     """
-    The volumes attached to the server
+    Volumes attached to the server.
     """
 
     enable_ipv6: bool
     """
-    True if IPv6 is enabled on the server
+    True if IPv6 is enabled on the server.
     """
 
     public_ip: Optional[str]
     """
-    The ID of the reserved IP to attach to the server
+    ID of the reserved IP to attach to the Instance.
+    """
+
+    public_ips: Optional[List[str]]
+    """
+    A list of reserved IP IDs to attach to the Instance.
     """
 
     boot_type: Optional[BootType]
     """
-    The boot type to use
+    Boot type to use.
     """
 
     bootscript: Optional[str]
     """
-    The bootscript ID to use when `boot_type` is set to `bootscript`
+    Bootscript ID to use when `boot_type` is set to `bootscript`.
     :deprecated
     """
 
     organization: Optional[str]
     """
-    The server organization ID.
+    Instance Organization ID.
     
     One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
     :deprecated
     """
 
     project: Optional[str]
     """
-    The server project ID.
+    Instance Project ID.
     
     One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
     """
 
     tags: Optional[List[str]]
     """
-    The server tags
+    Instance tags.
     """
 
     security_group: Optional[str]
     """
-    The security group ID
+    Security group ID.
     """
 
     placement_group: Optional[str]
     """
-    Placement group ID if server must be part of a placement group
+    Placement group ID if Instance must be part of a placement group.
     """
 
 
 @dataclass
 class _SetServerRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     id: str
     """
-    The server unique ID
+    Instance unique ID.
     """
 
     name: str
     """
-    The server name
+    Instance name.
     """
 
     organization: Optional[str]
     """
-    The server organization ID
+    Instance Organization ID.
     """
 
     project: Optional[str]
     """
-    The server project ID
+    Instance Project ID.
     """
 
     allowed_actions: Optional[List[ServerAction]]
     """
-    Provide as list of allowed actions on the server
+    Provide a list of allowed actions on the server.
     """
 
     tags: Optional[List[str]]
     """
-    The server associated tags
+    Tags associated with the Instance.
     """
 
     commercial_type: str
     """
-    The server commercial type (eg. GP1-M)
+    Instance commercial type (eg. GP1-M).
     """
 
     creation_date: Optional[datetime]
     """
-    The server creation date
+    Instance creation date.
     """
 
     dynamic_ip_required: bool
     """
-    True if a dynamic IP is required
+    True if a dynamic IPv4 is required.
+    """
+
+    routed_ip_enabled: Optional[bool]
+    """
+    True to configure the instance so it uses the new routed IP mode (once this is set to True you cannot set it back to False).
     """
 
     enable_ipv6: bool
     """
-    True if IPv6 is enabled
+    True if IPv6 is enabled.
     """
 
     hostname: str
     """
-    The server host name
+    Instance host name.
     """
 
     image: Optional[Image]
     """
-    Provide information on the server image
+    Provide information on the Instance image.
     """
 
     protected: bool
     """
-    The server protection option is activated
+    Instance protection option is activated.
     """
 
     private_ip: Optional[str]
     """
-    The server private IP address
+    Instance private IP address.
     """
 
     public_ip: Optional[ServerIp]
     """
-    Information about the public IP
+    Information about the public IP.
+    """
+
+    public_ips: Optional[List[ServerIp]]
+    """
+    Information about all the public IPs attached to the server.
     """
 
     modification_date: Optional[datetime]
     """
-    The server modification date
+    Instance modification date.
     """
 
     state: ServerState
     """
-    The server state
+    Instance state.
     """
 
     location: Optional[ServerLocation]
     """
-    The server location
+    Instance location.
     """
 
     ipv6: Optional[ServerIpv6]
     """
-    The server IPv6 address
+    Instance IPv6 address.
     """
 
     bootscript: Optional[Bootscript]
     """
-    The server bootscript
+    Instance bootscript.
     :deprecated
     """
 
     boot_type: BootType
     """
-    The server boot type
+    Instance boot type.
     """
 
     volumes: Optional[Dict[str, Volume]]
     """
-    The server volumes
+    Instance volumes.
     """
 
     security_group: Optional[SecurityGroupSummary]
     """
-    The server security group
+    Instance security group.
     """
 
     maintenances: Optional[List[ServerMaintenance]]
     """
-    The server planned maintenances
+    Instance planned maintenances.
     """
 
     state_detail: str
     """
-    The server state_detail
+    Instance state_detail.
     """
 
     arch: Arch
     """
-    The server arch
+    Instance architecture (refers to the CPU architecture used for the Instance, e.g. x86_64, arm64).
     """
 
     placement_group: Optional[PlacementGroup]
     """
-    The server placement group
+    Instance placement group.
     """
 
     private_nics: Optional[List[PrivateNIC]]
     """
-    The server private NICs
+    Instance private NICs.
     """
 
 
 @dataclass
 class _UpdateServerRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     server_id: str
     """
-    UUID of the server
+    UUID of the Instance.
     """
 
     name: Optional[str]
     """
-    Name of the server
+    Name of the Instance.
     """
 
     boot_type: Optional[BootType]
 
     tags: Optional[List[str]]
     """
-    Tags of the server
+    Tags of the Instance.
     """
 
     volumes: Optional[Dict[str, VolumeServerTemplate]]
 
     bootscript: Optional[str]
     """
     :deprecated
     """
 
     dynamic_ip_required: Optional[bool]
 
+    routed_ip_enabled: Optional[bool]
+    """
+    True to configure the instance so it uses the new routed IP mode (once this is set to True you cannot set it back to False).
+    """
+
+    public_ips: Optional[List[ServerIp]]
+
     enable_ipv6: Optional[bool]
 
     protected: Optional[bool]
 
     security_group: Optional[SecurityGroupTemplate]
 
     placement_group: Optional[str]
     """
-    Placement group ID if server must be part of a placement group
+    Placement group ID if Instance must be part of a placement group.
     """
 
     private_nics: Optional[List[PrivateNIC]]
     """
-    The server private NICs
+    Instance private NICs.
+    """
+
+    commercial_type: Optional[str]
+    """
+    Set the commercial_type for this Instance.
+    Warning: This field has some restrictions:
+    - Cannot be changed if the Instance is not in `stopped` state.
+    - Cannot be changed if the Instance is in a placement group.
+    - Local storage requirements of the target commercial_types must be fulfilled (i.e. if an Instance has 80GB of local storage, it can be changed into a GP1-XS, which has a maximum of 150GB, but it cannot be changed into a DEV1-S, which has only 20GB).
     """
 
 
 @dataclass
 class _SetImageRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     id: str
 
     name: str
 
     arch: Arch
@@ -410,15 +446,15 @@
     tags: Optional[List[str]]
 
 
 @dataclass
 class _SetSnapshotRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     snapshot_id: str
 
     id: str
 
     name: str
@@ -442,99 +478,99 @@
     tags: Optional[List[str]]
 
 
 @dataclass
 class _SetSecurityGroupRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     id: str
     """
-    The ID of the security group (will be ignored)
+    ID of the security group (will be ignored).
     """
 
     name: str
     """
-    The name of the security group
+    Name of the security group.
     """
 
     tags: Optional[List[str]]
     """
-    The tags of the security group
+    Tags of the security group.
     """
 
     creation_date: Optional[datetime]
     """
-    The creation date of the security group (will be ignored)
+    Creation date of the security group (will be ignored).
     """
 
     modification_date: Optional[datetime]
     """
-    The modification date of the security group (will be ignored)
+    Modification date of the security group (will be ignored).
     """
 
     description: str
     """
-    The description of the security group
+    Description of the security group.
     """
 
     enable_default_security: bool
     """
-    True to block SMTP on IPv4 and IPv6
+    True to block SMTP on IPv4 and IPv6. This feature is read only, please open a support ticket if you need to make it configurable.
     """
 
     inbound_default_policy: SecurityGroupPolicy
     """
-    The default inbound policy
+    Default inbound policy.
     """
 
     outbound_default_policy: SecurityGroupPolicy
     """
-    The default outbound policy
+    Default outbound policy.
     """
 
     organization: Optional[str]
     """
-    The security groups organization ID
+    Security groups Organization ID.
     """
 
     project: Optional[str]
     """
-    The security group project ID
+    Security group Project ID.
     """
 
     organization_default: Optional[bool]
     """
-    Please use project_default instead
+    Please use project_default instead.
     :deprecated
     """
 
     project_default: bool
     """
-    True use this security group for future instances created in this project
+    True use this security group for future Instances created in this project.
     """
 
     servers: Optional[List[ServerSummary]]
     """
-    The servers attached to this security group
+    Instances attached to this security group.
     """
 
     stateful: bool
     """
-    True to set the security group as stateful
+    True to set the security group as stateful.
     """
 
 
 @dataclass
 class _SetSecurityGroupRuleRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     security_group_id: str
 
     security_group_rule_id: str
 
     id: str
```

### Comparing `scaleway_async-0.9.0/scaleway_async/iot/v1/__init__.py` & `scaleway_async-1.0.0/scaleway_async/iot/v1/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-0.9.0/scaleway_async/iot/v1/api.py` & `scaleway_async-1.0.0/scaleway_async/iot/v1/api.py`

 * *Files 6% similar despite different names*

```diff
@@ -96,39 +96,41 @@
     unmarshal_SetDeviceCertificateResponse,
     unmarshal_TwinDocument,
 )
 
 
 class IotV1API(API):
     """
-    IoT API.
+    IoT Hub API.
 
     This API allows you to manage IoT hubs and devices.
+    IoT Hub API.
     """
 
     async def list_hubs(
         self,
         *,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListHubsRequestOrderBy = ListHubsRequestOrderBy.NAME_ASC,
         project_id: Optional[str] = None,
         organization_id: Optional[str] = None,
         name: Optional[str] = None,
     ) -> ListHubsResponse:
         """
-        List hubs
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page: Page number
-        :param page_size: Page size. The maximum value is 100
-        :param order_by: Ordering of requested hub
-        :param project_id: Filter on project
-        :param organization_id: Filter on the organization
-        :param name: Filter on the name
+        List hubs.
+        List all Hubs in the specified zone. By default, returned Hubs are ordered by creation date in ascending order, though this can be modified via the `order_by` field.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number to return, from the paginated results.
+        :param page_size: Number of Hubs to return within a page. Maximum value is 100.
+        :param order_by: Sort order of Hubs in the response.
+        :param project_id: Only list Hubs of this Project ID.
+        :param organization_id: Only list Hubs of this Organization ID.
+        :param name: Hub name.
         :return: :class:`ListHubsResponse <ListHubsResponse>`
 
         Usage:
         ::
 
             result = await api.list_hubs()
         """
@@ -162,22 +164,23 @@
         page_size: Optional[int] = None,
         order_by: Optional[ListHubsRequestOrderBy] = None,
         project_id: Optional[str] = None,
         organization_id: Optional[str] = None,
         name: Optional[str] = None,
     ) -> List[Hub]:
         """
-        List hubs
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page: Page number
-        :param page_size: Page size. The maximum value is 100
-        :param order_by: Ordering of requested hub
-        :param project_id: Filter on project
-        :param organization_id: Filter on the organization
-        :param name: Filter on the name
+        List hubs.
+        List all Hubs in the specified zone. By default, returned Hubs are ordered by creation date in ascending order, though this can be modified via the `order_by` field.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number to return, from the paginated results.
+        :param page_size: Number of Hubs to return within a page. Maximum value is 100.
+        :param order_by: Sort order of Hubs in the response.
+        :param project_id: Only list Hubs of this Project ID.
+        :param organization_id: Only list Hubs of this Organization ID.
+        :param name: Hub name.
         :return: :class:`List[ListHubsResponse] <List[ListHubsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_hubs_all()
         """
@@ -205,21 +208,22 @@
         project_id: Optional[str] = None,
         product_plan: HubProductPlan = HubProductPlan.PLAN_UNKNOWN,
         disable_events: Optional[bool] = None,
         events_topic_prefix: Optional[str] = None,
         twins_graphite_config: Optional[HubTwinsGraphiteConfig] = None,
     ) -> Hub:
         """
-        Create a hub
-        :param region: Region to target. If none is passed will use default region from the config
-        :param name: Hub name (up to 255 characters)
-        :param project_id: Organization/project owning the resource
-        :param product_plan: Hub feature set
-        :param disable_events: Disable Hub events
-        :param events_topic_prefix: Hub events topic prefix (default '$SCW/events')
+        Create a hub.
+        Create a new Hub in the targeted region, specifying its configuration including name and product plan.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param name: Hub name (up to 255 characters).
+        :param project_id: Project/Organization ID to filter for, only Hubs from this Project/Organization will be returned.
+        :param product_plan: Hub product plan.
+        :param disable_events: Disable Hub events.
+        :param events_topic_prefix: Topic prefix (default '$SCW/events') of Hub events.
         :param twins_graphite_config: BETA - not implemented yet.
 
         One-of ('twins_db_config'): at most one of 'twins_graphite_config' could be set.
         :return: :class:`Hub <Hub>`
 
         Usage:
         ::
@@ -254,17 +258,18 @@
     async def get_hub(
         self,
         *,
         hub_id: str,
         region: Optional[Region] = None,
     ) -> Hub:
         """
-        Get a hub
-        :param region: Region to target. If none is passed will use default region from the config
-        :param hub_id: Hub ID
+        Get a hub.
+        Retrieve information about an existing IoT Hub, specified by its Hub ID. Its full details, including name, status and endpoint, are returned in the response object.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param hub_id: Hub ID.
         :return: :class:`Hub <Hub>`
 
         Usage:
         ::
 
             result = await api.get_hub(hub_id="example")
         """
@@ -287,16 +292,16 @@
         *,
         hub_id: str,
         region: Optional[Region] = None,
         options: Optional[WaitForOptions[Hub, Union[bool, Awaitable[bool]]]] = None,
     ) -> Hub:
         """
         Waits for :class:`Hub <Hub>` to be in a final state.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param hub_id: Hub ID
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param hub_id: Hub ID.
         :param options: The options for the waiter
         :return: :class:`Hub <Hub>`
 
         Usage:
         ::
 
             result = api.wait_for_hub(hub_id="example")
@@ -326,22 +331,23 @@
         name: Optional[str] = None,
         disable_events: Optional[bool] = None,
         events_topic_prefix: Optional[str] = None,
         enable_device_auto_provisioning: Optional[bool] = None,
         twins_graphite_config: Optional[HubTwinsGraphiteConfig] = None,
     ) -> Hub:
         """
-        Update a hub
-        :param region: Region to target. If none is passed will use default region from the config
-        :param hub_id: Hub ID
-        :param name: Hub name (up to 255 characters)
-        :param product_plan: Hub feature set
-        :param disable_events: Disable Hub events
-        :param events_topic_prefix: Hub events topic prefix
-        :param enable_device_auto_provisioning: Enable device auto provisioning
+        Update a hub.
+        Update the parameters of an existing IoT Hub, specified by its Hub ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param hub_id: ID of the Hub you want to update.
+        :param name: Hub name (up to 255 characters).
+        :param product_plan: Hub product plan.
+        :param disable_events: Disable Hub events.
+        :param events_topic_prefix: Topic prefix of Hub events.
+        :param enable_device_auto_provisioning: Enable device auto provisioning.
         :param twins_graphite_config: BETA - not implemented yet.
 
         One-of ('twins_db_config'): at most one of 'twins_graphite_config' could be set.
         :return: :class:`Hub <Hub>`
 
         Usage:
         ::
@@ -381,17 +387,18 @@
     async def enable_hub(
         self,
         *,
         hub_id: str,
         region: Optional[Region] = None,
     ) -> Hub:
         """
-        Enable a hub
-        :param region: Region to target. If none is passed will use default region from the config
-        :param hub_id: Hub ID
+        Enable a hub.
+        Enable an existing IoT Hub, specified by its Hub ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param hub_id: Hub ID.
         :return: :class:`Hub <Hub>`
 
         Usage:
         ::
 
             result = await api.enable_hub(hub_id="example")
         """
@@ -412,17 +419,18 @@
     async def disable_hub(
         self,
         *,
         hub_id: str,
         region: Optional[Region] = None,
     ) -> Hub:
         """
-        Disable a hub
-        :param region: Region to target. If none is passed will use default region from the config
-        :param hub_id: Hub ID
+        Disable a hub.
+        Disable an existing IoT Hub, specified by its Hub ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param hub_id: Hub ID.
         :return: :class:`Hub <Hub>`
 
         Usage:
         ::
 
             result = await api.disable_hub(hub_id="example")
         """
@@ -444,18 +452,19 @@
         self,
         *,
         hub_id: str,
         region: Optional[Region] = None,
         delete_devices: Optional[bool] = None,
     ) -> Optional[None]:
         """
-        Delete a hub
-        :param region: Region to target. If none is passed will use default region from the config
-        :param hub_id: Hub ID
-        :param delete_devices: Force deletion of devices added to this hub instead of rejecting operation
+        Delete a hub.
+        Delete an existing IoT Hub, specified by its Hub ID. Deleting a Hub is permanent, and cannot be undone.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param hub_id: Hub ID.
+        :param delete_devices: Defines whether to force the deletion of devices added to this Hub or reject the operation.
 
         Usage:
         ::
 
             result = await api.delete_hub(hub_id="example")
         """
 
@@ -479,18 +488,19 @@
         self,
         *,
         hub_id: str,
         start_date: datetime,
         region: Optional[Region] = None,
     ) -> GetHubMetricsResponse:
         """
-        Get a hub's metrics
-        :param region: Region to target. If none is passed will use default region from the config
-        :param hub_id: Hub ID
-        :param start_date: Start date used to compute the best scale for the returned metrics
+        Get a hub's metrics.
+        Get the metrics of an existing IoT Hub, specified by its Hub ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param hub_id: Hub ID.
+        :param start_date: Start date used to compute the best scale for returned metrics.
         :return: :class:`GetHubMetricsResponse <GetHubMetricsResponse>`
         :deprecated
 
         Usage:
         ::
 
             result = await api.get_hub_metrics(
@@ -520,19 +530,21 @@
         *,
         hub_id: str,
         ca_cert_pem: str,
         challenge_cert_pem: str,
         region: Optional[Region] = None,
     ) -> Hub:
         """
-        Set the certificate authority of a hub
-        :param region: Region to target. If none is passed will use default region from the config
-        :param hub_id: Hub ID
-        :param ca_cert_pem: The CA's PEM-encoded certificate
-        :param challenge_cert_pem: The challenge is a PEM-encoded certificate to prove the possession of the CA. It must be signed by the CA, and have a Common Name equal to the Hub ID.
+        Set the certificate authority of a hub.
+        Set a particular PEM-encoded certificate, specified by the Hub ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param hub_id: Hub ID.
+        :param ca_cert_pem: CA's PEM-encoded certificate.
+        :param challenge_cert_pem: Proof of possession of PEM-encoded certificate.
+        Challenge is a PEM-encoded certificate that acts as proof of possession of the CA. It must be signed by the CA, and have a Common Name equal to the Hub ID.
         :return: :class:`Hub <Hub>`
 
         Usage:
         ::
 
             result = await api.set_hub_ca(
                 hub_id="example",
@@ -566,16 +578,17 @@
     async def get_hub_ca(
         self,
         *,
         hub_id: str,
         region: Optional[Region] = None,
     ) -> GetHubCAResponse:
         """
-        Get the certificate authority of a hub
-        :param region: Region to target. If none is passed will use default region from the config
+        Get the certificate authority of a hub.
+        Get information for a particular PEM-encoded certificate, specified by the Hub ID.
+        :param region: Region to target. If none is passed will use default region from the config.
         :param hub_id:
         :return: :class:`GetHubCAResponse <GetHubCAResponse>`
 
         Usage:
         ::
 
             result = await api.get_hub_ca(hub_id="example")
@@ -603,23 +616,24 @@
         order_by: ListDevicesRequestOrderBy = ListDevicesRequestOrderBy.NAME_ASC,
         name: Optional[str] = None,
         hub_id: Optional[str] = None,
         allow_insecure: Optional[bool] = None,
         status: DeviceStatus = DeviceStatus.UNKNOWN,
     ) -> ListDevicesResponse:
         """
-        List devices
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page: Page number
-        :param page_size: Page size. The maximum value is 100
-        :param order_by: Ordering of requested devices
-        :param name: Filter on the name
-        :param hub_id: Filter on the hub
-        :param allow_insecure: Filter on the allow_insecure flag
-        :param status: Device status (enabled, disabled, etc.)
+        List devices.
+        List all devices in the specified region. By default, returned devices are ordered by creation date in ascending order, though this can be modified via the `order_by` field.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number to return, from the paginated results.
+        :param page_size: Number of devices to return within a page. Maximum value is 100.
+        :param order_by: Ordering of requested devices.
+        :param name: Name to filter for, only devices with this name will be returned.
+        :param hub_id: Hub ID to filter for, only devices attached to this Hub will be returned.
+        :param allow_insecure: Defines wheter to filter the allow_insecure flag.
+        :param status: Device status (enabled, disabled, etc.).
         :return: :class:`ListDevicesResponse <ListDevicesResponse>`
 
         Usage:
         ::
 
             result = await api.list_devices()
         """
@@ -654,23 +668,24 @@
         order_by: Optional[ListDevicesRequestOrderBy] = None,
         name: Optional[str] = None,
         hub_id: Optional[str] = None,
         allow_insecure: Optional[bool] = None,
         status: Optional[DeviceStatus] = None,
     ) -> List[Device]:
         """
-        List devices
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page: Page number
-        :param page_size: Page size. The maximum value is 100
-        :param order_by: Ordering of requested devices
-        :param name: Filter on the name
-        :param hub_id: Filter on the hub
-        :param allow_insecure: Filter on the allow_insecure flag
-        :param status: Device status (enabled, disabled, etc.)
+        List devices.
+        List all devices in the specified region. By default, returned devices are ordered by creation date in ascending order, though this can be modified via the `order_by` field.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number to return, from the paginated results.
+        :param page_size: Number of devices to return within a page. Maximum value is 100.
+        :param order_by: Ordering of requested devices.
+        :param name: Name to filter for, only devices with this name will be returned.
+        :param hub_id: Hub ID to filter for, only devices attached to this Hub will be returned.
+        :param allow_insecure: Defines wheter to filter the allow_insecure flag.
+        :param status: Device status (enabled, disabled, etc.).
         :return: :class:`List[ListDevicesResponse] <List[ListDevicesResponse]>`
 
         Usage:
         ::
 
             result = await api.list_devices_all()
         """
@@ -699,22 +714,23 @@
         allow_multiple_connections: bool,
         region: Optional[Region] = None,
         name: Optional[str] = None,
         message_filters: Optional[DeviceMessageFilters] = None,
         description: Optional[str] = None,
     ) -> CreateDeviceResponse:
         """
-        Add a device
-        :param region: Region to target. If none is passed will use default region from the config
-        :param name: Device name
-        :param hub_id: ID of the device's hub
-        :param allow_insecure: Allow plain and server-authenticated SSL connections in addition to mutually-authenticated ones
-        :param allow_multiple_connections: Allow multiple physical devices to connect with this device's credentials
-        :param message_filters: Filter-sets to authorize or deny the device to publish/subscribe to specific topics
-        :param description: Device description
+        Add a device.
+        Attach a device to a given Hub.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param name: Device name.
+        :param hub_id: Hub ID of the device.
+        :param allow_insecure: Defines whether to allow plain and server-authenticated SSL connections in addition to mutually-authenticated ones.
+        :param allow_multiple_connections: Defines whether to allow multiple physical devices to connect with this device's credentials.
+        :param message_filters: Filter-sets to authorize or deny the device to publish/subscribe to specific topics.
+        :param description: Device description.
         :return: :class:`CreateDeviceResponse <CreateDeviceResponse>`
 
         Usage:
         ::
 
             result = await api.create_device(
                 hub_id="example",
@@ -750,17 +766,18 @@
     async def get_device(
         self,
         *,
         device_id: str,
         region: Optional[Region] = None,
     ) -> Device:
         """
-        Get a device
-        :param region: Region to target. If none is passed will use default region from the config
-        :param device_id: Device ID
+        Get a device.
+        Retrieve information about an existing device, specified by its device ID. Its full details, including name, status and ID, are returned in the response object.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param device_id: Device ID.
         :return: :class:`Device <Device>`
 
         Usage:
         ::
 
             result = await api.get_device(device_id="example")
         """
@@ -786,22 +803,23 @@
         description: Optional[str] = None,
         allow_insecure: Optional[bool] = None,
         allow_multiple_connections: Optional[bool] = None,
         message_filters: Optional[DeviceMessageFilters] = None,
         hub_id: Optional[str] = None,
     ) -> Device:
         """
-        Update a device
-        :param region: Region to target. If none is passed will use default region from the config
-        :param device_id: Device ID
-        :param description: Device description
-        :param allow_insecure: Allow plain and server-authenticated SSL connections in addition to mutually-authenticated ones
-        :param allow_multiple_connections: Allow multiple physical devices to connect with this device's credentials
-        :param message_filters: Filter-sets to restrict the topics the device can publish/subscribe to
-        :param hub_id: Change Hub for this device, additional fees may apply, see IoT Hub pricing
+        Update a device.
+        Update the parameters of an existing device, specified by its device ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param device_id: Device ID.
+        :param description: Description for the device.
+        :param allow_insecure: Defines whether to allow plain and server-authenticated SSL connections in addition to mutually-authenticated ones.
+        :param allow_multiple_connections: Defines whether to allow multiple physical devices to connect with this device's credentials.
+        :param message_filters: Filter-sets to restrict the topics the device can publish/subscribe to.
+        :param hub_id: Change Hub for this device, additional fees may apply, see IoT Hub pricing.
         :return: :class:`Device <Device>`
 
         Usage:
         ::
 
             result = await api.update_device(device_id="example")
         """
@@ -834,17 +852,18 @@
     async def enable_device(
         self,
         *,
         device_id: str,
         region: Optional[Region] = None,
     ) -> Device:
         """
-        Enable a device
-        :param region: Region to target. If none is passed will use default region from the config
-        :param device_id: Device ID
+        Enable a device.
+        Enable a specific device, specified by its device ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param device_id: Device ID.
         :return: :class:`Device <Device>`
 
         Usage:
         ::
 
             result = await api.enable_device(device_id="example")
         """
@@ -865,17 +884,18 @@
     async def disable_device(
         self,
         *,
         device_id: str,
         region: Optional[Region] = None,
     ) -> Device:
         """
-        Disable a device
-        :param region: Region to target. If none is passed will use default region from the config
-        :param device_id: Device ID
+        Disable a device.
+        Disable an existing device, specified by its device ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param device_id: Device ID.
         :return: :class:`Device <Device>`
 
         Usage:
         ::
 
             result = await api.disable_device(device_id="example")
         """
@@ -896,17 +916,18 @@
     async def renew_device_certificate(
         self,
         *,
         device_id: str,
         region: Optional[Region] = None,
     ) -> RenewDeviceCertificateResponse:
         """
-        Renew a device certificate
-        :param region: Region to target. If none is passed will use default region from the config
-        :param device_id: Device ID
+        Renew a device certificate.
+        Renew the certificate of an existing device, specified by its device ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param device_id: Device ID.
         :return: :class:`RenewDeviceCertificateResponse <RenewDeviceCertificateResponse>`
 
         Usage:
         ::
 
             result = await api.renew_device_certificate(device_id="example")
         """
@@ -928,18 +949,19 @@
         self,
         *,
         device_id: str,
         certificate_pem: str,
         region: Optional[Region] = None,
     ) -> SetDeviceCertificateResponse:
         """
-        Set a custom certificate on a device
-        :param region: Region to target. If none is passed will use default region from the config
-        :param device_id: Device ID
-        :param certificate_pem: The PEM-encoded custom certificate
+        Set a custom certificate on a device.
+        Switch the existing certificate of a given device with an EM-encoded custom certificate.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param device_id: Device ID.
+        :param certificate_pem: PEM-encoded custom certificate.
         :return: :class:`SetDeviceCertificateResponse <SetDeviceCertificateResponse>`
 
         Usage:
         ::
 
             result = await api.set_device_certificate(
                 device_id="example",
@@ -971,17 +993,18 @@
     async def get_device_certificate(
         self,
         *,
         device_id: str,
         region: Optional[Region] = None,
     ) -> GetDeviceCertificateResponse:
         """
-        Get a device's certificate
-        :param region: Region to target. If none is passed will use default region from the config
-        :param device_id: Device ID
+        Get a device's certificate.
+        Get information for a particular PEM-encoded certificate, specified by the device ID. The response returns full details of the device, including its type of certificate.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param device_id: Device ID.
         :return: :class:`GetDeviceCertificateResponse <GetDeviceCertificateResponse>`
 
         Usage:
         ::
 
             result = await api.get_device_certificate(device_id="example")
         """
@@ -1002,17 +1025,18 @@
     async def delete_device(
         self,
         *,
         device_id: str,
         region: Optional[Region] = None,
     ) -> Optional[None]:
         """
-        Remove a device
-        :param region: Region to target. If none is passed will use default region from the config
-        :param device_id: Device ID
+        Remove a device.
+        Remove a specific device from the specific Hub it is attached to.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param device_id: Device ID.
 
         Usage:
         ::
 
             result = await api.delete_device(device_id="example")
         """
 
@@ -1033,18 +1057,19 @@
         self,
         *,
         device_id: str,
         start_date: datetime,
         region: Optional[Region] = None,
     ) -> GetDeviceMetricsResponse:
         """
-        Get a device's metrics
-        :param region: Region to target. If none is passed will use default region from the config
-        :param device_id: Device ID
-        :param start_date: Start date used to compute the best scale for the returned metrics
+        Get a device's metrics.
+        Get the metrics of an existing device, specified by its device ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param device_id: Device ID.
+        :param start_date: Start date used to compute the best scale for the returned metrics.
         :return: :class:`GetDeviceMetricsResponse <GetDeviceMetricsResponse>`
         :deprecated
 
         Usage:
         ::
 
             result = await api.get_device_metrics(
@@ -1076,21 +1101,22 @@
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListRoutesRequestOrderBy = ListRoutesRequestOrderBy.NAME_ASC,
         hub_id: Optional[str] = None,
         name: Optional[str] = None,
     ) -> ListRoutesResponse:
         """
-        List routes
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page: Page number
-        :param page_size: Page size. The maximum value is 100
-        :param order_by: Ordering of requested routes
-        :param hub_id: Filter on the hub
-        :param name: Filter on route's name
+        List routes.
+        List all routes in the specified region. By default, returned routes are ordered by creation date in ascending order, though this can be modified via the `order_by` field.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number to return, from the paginated results.
+        :param page_size: Number of routes to return within a page. Maximum value is 100.
+        :param order_by: Ordering of requested routes.
+        :param hub_id: Hub ID to filter for.
+        :param name: Route name to filter for.
         :return: :class:`ListRoutesResponse <ListRoutesResponse>`
 
         Usage:
         ::
 
             result = await api.list_routes()
         """
@@ -1121,21 +1147,22 @@
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListRoutesRequestOrderBy] = None,
         hub_id: Optional[str] = None,
         name: Optional[str] = None,
     ) -> List[RouteSummary]:
         """
-        List routes
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page: Page number
-        :param page_size: Page size. The maximum value is 100
-        :param order_by: Ordering of requested routes
-        :param hub_id: Filter on the hub
-        :param name: Filter on route's name
+        List routes.
+        List all routes in the specified region. By default, returned routes are ordered by creation date in ascending order, though this can be modified via the `order_by` field.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number to return, from the paginated results.
+        :param page_size: Number of routes to return within a page. Maximum value is 100.
+        :param order_by: Ordering of requested routes.
+        :param hub_id: Hub ID to filter for.
+        :param name: Route name to filter for.
         :return: :class:`List[ListRoutesResponse] <List[ListRoutesResponse]>`
 
         Usage:
         ::
 
             result = await api.list_routes_all()
         """
@@ -1162,29 +1189,29 @@
         region: Optional[Region] = None,
         name: Optional[str] = None,
         s3_config: Optional[CreateRouteRequestS3Config] = None,
         db_config: Optional[CreateRouteRequestDatabaseConfig] = None,
         rest_config: Optional[CreateRouteRequestRestConfig] = None,
     ) -> Route:
         """
-        Multiple route kinds can be created:
-        - Database Route.
+        Create a route.
+        Multiple kinds of routes can be created, such as:
+        - Database Route
           Create a route that will record subscribed MQTT messages into your database.
           <b>You need to manage the database by yourself</b>.
         - REST Route.
           Create a route that will call a REST API on received subscribed MQTT messages.
         - S3 Routes.
           Create a route that will put subscribed MQTT messages into an S3 bucket.
-          You need to create the bucket yourself and grant us write access.
-          The grant can be done with s3cmd (`s3cmd setacl s3://<my-bucket> --acl-grant=write:555c69c3-87d0-4bf8-80f1-99a2f757d031:555c69c3-87d0-4bf8-80f1-99a2f757d031`).
-
-        :param region: Region to target. If none is passed will use default region from the config
-        :param name: Route name
-        :param hub_id: ID of the route's hub
-        :param topic: Topic the route subscribes to. It must be a valid MQTT topic and up to 65535 characters
+          You need to create the bucket yourself and grant write access.
+          Granting can be done with s3cmd (`s3cmd setacl s3://<my-bucket> --acl-grant=write:555c69c3-87d0-4bf8-80f1-99a2f757d031:555c69c3-87d0-4bf8-80f1-99a2f757d031`).
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param name: Route name.
+        :param hub_id: Hub ID of the route.
+        :param topic: Topic the route subscribes to. It must be a valid MQTT topic and up to 65535 characters.
         :param s3_config: If creating S3 Route, S3-specific configuration fields.
 
         One-of ('config'): at most one of 's3_config', 'db_config', 'rest_config' could be set.
         :param db_config: If creating Database Route, DB-specific configuration fields.
 
         One-of ('config'): at most one of 's3_config', 'db_config', 'rest_config' could be set.
         :param rest_config: If creating Rest Route, Rest-specific configuration fields.
@@ -1233,19 +1260,20 @@
         name: Optional[str] = None,
         topic: Optional[str] = None,
         s3_config: Optional[UpdateRouteRequestS3Config] = None,
         db_config: Optional[UpdateRouteRequestDatabaseConfig] = None,
         rest_config: Optional[UpdateRouteRequestRestConfig] = None,
     ) -> Route:
         """
-        Update a route
-        :param region: Region to target. If none is passed will use default region from the config
-        :param route_id: Route id
-        :param name: Route name
-        :param topic: Topic the route subscribes to. It must be a valid MQTT topic and up to 65535 characters
+        Update a route.
+        Update the parameters of an existing route, specified by its route ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param route_id: Route id.
+        :param name: Route name.
+        :param topic: Topic the route subscribes to. It must be a valid MQTT topic and up to 65535 characters.
         :param s3_config: When updating S3 Route, S3-specific configuration fields.
 
         One-of ('config'): at most one of 's3_config', 'db_config', 'rest_config' could be set.
         :param db_config: When updating Database Route, DB-specific configuration fields.
 
         One-of ('config'): at most one of 's3_config', 'db_config', 'rest_config' could be set.
         :param rest_config: When updating Rest Route, Rest-specific configuration fields.
@@ -1287,17 +1315,18 @@
     async def get_route(
         self,
         *,
         route_id: str,
         region: Optional[Region] = None,
     ) -> Route:
         """
-        Get a route
-        :param region: Region to target. If none is passed will use default region from the config
-        :param route_id: Route ID
+        Get a route.
+        Get information for a particular route, specified by the route ID. The response returns full details of the route, including its type, the topic it subscribes to and its configuration.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param route_id: Route ID.
         :return: :class:`Route <Route>`
 
         Usage:
         ::
 
             result = await api.get_route(route_id="example")
         """
@@ -1318,17 +1347,18 @@
     async def delete_route(
         self,
         *,
         route_id: str,
         region: Optional[Region] = None,
     ) -> Optional[None]:
         """
-        Delete a route
-        :param region: Region to target. If none is passed will use default region from the config
-        :param route_id: Route ID
+        Delete a route.
+        Delete an existing route, specified by its route ID. Deleting a route is permanent, and cannot be undone.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param route_id: Route ID.
 
         Usage:
         ::
 
             result = await api.delete_route(route_id="example")
         """
 
@@ -1353,22 +1383,22 @@
         page_size: Optional[int] = None,
         order_by: ListNetworksRequestOrderBy = ListNetworksRequestOrderBy.NAME_ASC,
         name: Optional[str] = None,
         hub_id: Optional[str] = None,
         topic_prefix: Optional[str] = None,
     ) -> ListNetworksResponse:
         """
-        List the Networks
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page: Page number
-        :param page_size: Page size. The maximum value is 100
-        :param order_by: Ordering of requested routes
-        :param name: Filter on Network name
-        :param hub_id: Filter on the hub
-        :param topic_prefix: Filter on the topic prefix
+        List the networks.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number to return, from the paginated results.
+        :param page_size: Number of networks to return. The maximum value is 100.
+        :param order_by: Ordering of requested routes.
+        :param name: Network name to filter for.
+        :param hub_id: Hub ID to filter for.
+        :param topic_prefix: Topic prefix to filter for.
         :return: :class:`ListNetworksResponse <ListNetworksResponse>`
 
         Usage:
         ::
 
             result = await api.list_networks()
         """
@@ -1401,22 +1431,22 @@
         page_size: Optional[int] = None,
         order_by: Optional[ListNetworksRequestOrderBy] = None,
         name: Optional[str] = None,
         hub_id: Optional[str] = None,
         topic_prefix: Optional[str] = None,
     ) -> List[Network]:
         """
-        List the Networks
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page: Page number
-        :param page_size: Page size. The maximum value is 100
-        :param order_by: Ordering of requested routes
-        :param name: Filter on Network name
-        :param hub_id: Filter on the hub
-        :param topic_prefix: Filter on the topic prefix
+        List the networks.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number to return, from the paginated results.
+        :param page_size: Number of networks to return. The maximum value is 100.
+        :param order_by: Ordering of requested routes.
+        :param name: Network name to filter for.
+        :param hub_id: Hub ID to filter for.
+        :param topic_prefix: Topic prefix to filter for.
         :return: :class:`List[ListNetworksResponse] <List[ListNetworksResponse]>`
 
         Usage:
         ::
 
             result = await api.list_networks_all()
         """
@@ -1442,20 +1472,21 @@
         hub_id: str,
         topic_prefix: str,
         region: Optional[Region] = None,
         name: Optional[str] = None,
         type_: NetworkNetworkType = NetworkNetworkType.UNKNOWN,
     ) -> CreateNetworkResponse:
         """
-        Create a new Network
-        :param region: Region to target. If none is passed will use default region from the config
-        :param name: Network name
-        :param type_: Type of network to connect with
-        :param hub_id: Hub ID to connect the Network to
-        :param topic_prefix: Topic prefix for the Network
+        Create a new network.
+        Create a new network for an existing hub.  Beside the default network, you can add networks for different data providers. Possible network types are Sigfox and REST.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param name: Network name.
+        :param type_: Type of network to connect with.
+        :param hub_id: Hub ID to connect the Network to.
+        :param topic_prefix: Topic prefix for the Network.
         :return: :class:`CreateNetworkResponse <CreateNetworkResponse>`
 
         Usage:
         ::
 
             result = await api.create_network(
                 hub_id="example",
@@ -1488,17 +1519,18 @@
     async def get_network(
         self,
         *,
         network_id: str,
         region: Optional[Region] = None,
     ) -> Network:
         """
-        Retrieve a specific Network
-        :param region: Region to target. If none is passed will use default region from the config
-        :param network_id: Network ID
+        Retrieve a specific network.
+        Retrieve an existing network, specified by its network ID.  The response returns full details of the network, including its type, the topic prefix and its endpoint.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param network_id: Network ID.
         :return: :class:`Network <Network>`
 
         Usage:
         ::
 
             result = await api.get_network(network_id="example")
         """
@@ -1519,17 +1551,18 @@
     async def delete_network(
         self,
         *,
         network_id: str,
         region: Optional[Region] = None,
     ) -> Optional[None]:
         """
-        Delete a Network
-        :param region: Region to target. If none is passed will use default region from the config
-        :param network_id: Network ID
+        Delete a Network.
+        Delete an existing network, specified by its network ID. Deleting a network is permanent, and cannot be undone.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param network_id: Network ID.
 
         Usage:
         ::
 
             result = await api.delete_network(network_id="example")
         """
 
@@ -1550,18 +1583,18 @@
         self,
         *,
         twin_id: str,
         document_name: str,
         region: Optional[Region] = None,
     ) -> TwinDocument:
         """
-        BETA - Get a Cloud Twin Document
-        :param region: Region to target. If none is passed will use default region from the config
-        :param twin_id: Twin ID
-        :param document_name: Document name
+        BETA - Get a Cloud Twin Document.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param twin_id: Twin ID.
+        :param document_name: Name of the document.
         :return: :class:`TwinDocument <TwinDocument>`
 
         Usage:
         ::
 
             result = await api.get_twin_document(
                 twin_id="example",
@@ -1589,20 +1622,22 @@
         twin_id: str,
         document_name: str,
         region: Optional[Region] = None,
         version: Optional[int] = None,
         data: Optional[Dict[str, Any]] = None,
     ) -> TwinDocument:
         """
-        BETA - Update a Cloud Twin Document
-        :param region: Region to target. If none is passed will use default region from the config
-        :param twin_id: Twin ID
-        :param document_name: Document name
-        :param version: If set, ensures that the document's current version matches before persisting the update.
-        :param data: The new data that will replace the contents of the document.
+        BETA - Update a Cloud Twin Document.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param twin_id: Twin ID.
+        :param document_name: Name of the document.
+        :param version: Version of the document to update.
+        If set, ensures that the current version of the document matches before persisting the update.
+        :param data: Data of the new document.
+        New data that will replace the contents of the document.
         :return: :class:`TwinDocument <TwinDocument>`
 
         Usage:
         ::
 
             result = await api.put_twin_document(
                 twin_id="example",
@@ -1640,26 +1675,27 @@
         twin_id: str,
         document_name: str,
         region: Optional[Region] = None,
         version: Optional[int] = None,
         data: Optional[Dict[str, Any]] = None,
     ) -> TwinDocument:
         """
-        BETA - Patch a Cloud Twin Document
-        :param region: Region to target. If none is passed will use default region from the config
-        :param twin_id: Twin ID
-        :param document_name: Document name
-        :param version: If set, ensures that the document's current version matches before persisting the update.
-        :param data: A json data that will be applied on the document's current data.
+        BETA - Patch a Cloud Twin Document.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param twin_id: Twin ID.
+        :param document_name: Name of the document.
+        :param version: The version of the document to update.
+        If set, ensures that the current version of the document matches before persisting the update.
+        :param data: Patch data.
+        A json data that will be applied on the document's current data.
         Patching rules:
         * The patch goes recursively through the patch objects.
-        * If the patch object property is null, then it is removed from the final object.
+        * If the patch object property is null, it is removed from the final object.
         * If the patch object property is a value (number, strings, bool, arrays), it is replaced.
         * If the patch object property is an object, the previous rules will be applied recursively on it.
-
         :return: :class:`TwinDocument <TwinDocument>`
 
         Usage:
         ::
 
             result = await api.patch_twin_document(
                 twin_id="example",
@@ -1695,18 +1731,18 @@
         self,
         *,
         twin_id: str,
         document_name: str,
         region: Optional[Region] = None,
     ) -> Optional[None]:
         """
-        BETA - Delete a Cloud Twin Document
-        :param region: Region to target. If none is passed will use default region from the config
-        :param twin_id: Twin ID
-        :param document_name: Document name
+        BETA - Delete a Cloud Twin Document.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param twin_id: Twin ID.
+        :param document_name: Name of the document.
 
         Usage:
         ::
 
             result = await api.delete_twin_document(
                 twin_id="example",
                 document_name="example",
@@ -1730,17 +1766,17 @@
     async def list_twin_documents(
         self,
         *,
         twin_id: str,
         region: Optional[Region] = None,
     ) -> ListTwinDocumentsResponse:
         """
-        BETA - List the documents of a Cloud Twin
-        :param region: Region to target. If none is passed will use default region from the config
-        :param twin_id: Twin ID
+        BETA - List the documents of a Cloud Twin.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param twin_id: Twin ID.
         :return: :class:`ListTwinDocumentsResponse <ListTwinDocumentsResponse>`
 
         Usage:
         ::
 
             result = await api.list_twin_documents(twin_id="example")
         """
@@ -1761,17 +1797,17 @@
     async def delete_twin_documents(
         self,
         *,
         twin_id: str,
         region: Optional[Region] = None,
     ) -> Optional[None]:
         """
-        BETA - Delete all the documents of a Cloud Twin
-        :param region: Region to target. If none is passed will use default region from the config
-        :param twin_id: Twin ID
+        BETA - Delete all the documents of a Cloud Twin.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param twin_id: Twin ID.
 
         Usage:
         ::
 
             result = await api.delete_twin_documents(twin_id="example")
         """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/iot/v1/marshalling.py` & `scaleway_async-1.0.0/scaleway_async/container/v1beta1/marshalling.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,964 +1,979 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 
 from typing import Any, Dict
 
 from scaleway_core.profile import ProfileDefaults
-from scaleway_core.bridge import (
-    unmarshal_TimeSeries,
-)
 from scaleway_core.utils import (
     OneOfPossibility,
     resolve_one_of,
 )
 from dateutil import parser
 from .types import (
-    DeviceMessageFiltersRulePolicy,
-    HubProductPlan,
-    NetworkNetworkType,
-    RouteDatabaseConfigEngine,
-    RouteRestConfigHttpVerb,
-    RouteS3ConfigS3Strategy,
-    Certificate,
-    CreateDeviceResponse,
-    CreateNetworkResponse,
-    CreateRouteRequestDatabaseConfig,
-    CreateRouteRequestRestConfig,
-    CreateRouteRequestS3Config,
-    Device,
-    DeviceMessageFilters,
-    DeviceMessageFiltersRule,
-    GetDeviceCertificateResponse,
-    GetDeviceMetricsResponse,
-    GetHubCAResponse,
-    GetHubMetricsResponse,
-    Hub,
-    HubTwinsGraphiteConfig,
-    ListDevicesResponse,
-    ListHubsResponse,
-    ListNetworksResponse,
-    ListRoutesResponse,
-    ListTwinDocumentsResponse,
-    ListTwinDocumentsResponseDocumentSummary,
-    Network,
-    RenewDeviceCertificateResponse,
-    Route,
-    RouteDatabaseConfig,
-    RouteRestConfig,
-    RouteS3Config,
-    RouteSummary,
-    SetDeviceCertificateResponse,
-    TwinDocument,
-    UpdateRouteRequestDatabaseConfig,
-    UpdateRouteRequestRestConfig,
-    UpdateRouteRequestS3Config,
-    CreateHubRequest,
-    UpdateHubRequest,
-    SetHubCARequest,
-    CreateDeviceRequest,
-    UpdateDeviceRequest,
-    SetDeviceCertificateRequest,
-    CreateRouteRequest,
-    UpdateRouteRequest,
-    CreateNetworkRequest,
-    PutTwinDocumentRequest,
-    PatchTwinDocumentRequest,
+    ContainerHttpOption,
+    ContainerPrivacy,
+    ContainerProtocol,
+    Container,
+    CreateTriggerRequestMnqNatsClientConfig,
+    CreateTriggerRequestMnqSqsClientConfig,
+    CreateTriggerRequestSqsClientConfig,
+    Cron,
+    Domain,
+    ListContainersResponse,
+    ListCronsResponse,
+    ListDomainsResponse,
+    ListLogsResponse,
+    ListNamespacesResponse,
+    ListTokensResponse,
+    ListTriggersResponse,
+    Log,
+    Namespace,
+    Secret,
+    SecretHashedValue,
+    Token,
+    Trigger,
+    TriggerMnqNatsClientConfig,
+    TriggerMnqSqsClientConfig,
+    TriggerSqsClientConfig,
+    UpdateTriggerRequestSqsClientConfig,
+    CreateNamespaceRequest,
+    UpdateNamespaceRequest,
+    CreateContainerRequest,
+    UpdateContainerRequest,
+    CreateCronRequest,
+    UpdateCronRequest,
+    CreateDomainRequest,
+    CreateTokenRequest,
+    CreateTriggerRequest,
+    UpdateTriggerRequest,
 )
 
 
-def unmarshal_DeviceMessageFiltersRule(data: Any) -> DeviceMessageFiltersRule:
+def unmarshal_SecretHashedValue(data: Any) -> SecretHashedValue:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'DeviceMessageFiltersRule' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'SecretHashedValue' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("policy")
-    args["policy"] = field
+    field = data.get("hashed_value", None)
+    args["hashed_value"] = field
 
-    field = data.get("topics")
-    args["topics"] = field
+    field = data.get("key", None)
+    args["key"] = field
 
-    return DeviceMessageFiltersRule(**args)
+    return SecretHashedValue(**args)
 
 
-def unmarshal_DeviceMessageFilters(data: Any) -> DeviceMessageFilters:
+def unmarshal_TriggerMnqNatsClientConfig(data: Any) -> TriggerMnqNatsClientConfig:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'DeviceMessageFilters' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'TriggerMnqNatsClientConfig' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("publish")
-    args["publish"] = (
-        unmarshal_DeviceMessageFiltersRule(field) if field is not None else None
-    )
+    field = data.get("mnq_credential_id", None)
+    args["mnq_credential_id"] = field
 
-    field = data.get("subscribe")
-    args["subscribe"] = (
-        unmarshal_DeviceMessageFiltersRule(field) if field is not None else None
-    )
+    field = data.get("mnq_namespace_id", None)
+    args["mnq_namespace_id"] = field
 
-    return DeviceMessageFilters(**args)
-
-
-def unmarshal_HubTwinsGraphiteConfig(data: Any) -> HubTwinsGraphiteConfig:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'HubTwinsGraphiteConfig' failed as data isn't a dictionary."
-        )
+    field = data.get("mnq_project_id", None)
+    args["mnq_project_id"] = field
 
-    args: Dict[str, Any] = {}
+    field = data.get("mnq_region", None)
+    args["mnq_region"] = field
 
-    field = data.get("push_uri")
-    args["push_uri"] = field
+    field = data.get("subject", None)
+    args["subject"] = field
 
-    return HubTwinsGraphiteConfig(**args)
+    return TriggerMnqNatsClientConfig(**args)
 
 
-def unmarshal_Certificate(data: Any) -> Certificate:
+def unmarshal_TriggerMnqSqsClientConfig(data: Any) -> TriggerMnqSqsClientConfig:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Certificate' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'TriggerMnqSqsClientConfig' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("crt")
-    args["crt"] = field
+    field = data.get("mnq_credential_id", None)
+    args["mnq_credential_id"] = field
 
-    field = data.get("key")
-    args["key"] = field
+    field = data.get("mnq_namespace_id", None)
+    args["mnq_namespace_id"] = field
+
+    field = data.get("mnq_project_id", None)
+    args["mnq_project_id"] = field
+
+    field = data.get("mnq_region", None)
+    args["mnq_region"] = field
+
+    field = data.get("queue", None)
+    args["queue"] = field
 
-    return Certificate(**args)
+    return TriggerMnqSqsClientConfig(**args)
 
 
-def unmarshal_Device(data: Any) -> Device:
+def unmarshal_TriggerSqsClientConfig(data: Any) -> TriggerSqsClientConfig:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Device' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'TriggerSqsClientConfig' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("allow_insecure")
-    args["allow_insecure"] = field
+    field = data.get("access_key", None)
+    args["access_key"] = field
 
-    field = data.get("allow_multiple_connections")
-    args["allow_multiple_connections"] = field
-
-    field = data.get("created_at")
-    args["created_at"] = parser.isoparse(field) if type(field) is str else field
-
-    field = data.get("description")
-    args["description"] = field
-
-    field = data.get("has_custom_certificate")
-    args["has_custom_certificate"] = field
-
-    field = data.get("hub_id")
-    args["hub_id"] = field
-
-    field = data.get("id")
-    args["id"] = field
-
-    field = data.get("is_connected")
-    args["is_connected"] = field
-
-    field = data.get("last_activity_at")
-    args["last_activity_at"] = parser.isoparse(field) if type(field) is str else field
-
-    field = data.get("message_filters")
-    args["message_filters"] = (
-        unmarshal_DeviceMessageFilters(field) if field is not None else None
-    )
-
-    field = data.get("name")
-    args["name"] = field
+    field = data.get("endpoint", None)
+    args["endpoint"] = field
 
-    field = data.get("status")
-    args["status"] = field
+    field = data.get("queue_url", None)
+    args["queue_url"] = field
 
-    field = data.get("updated_at")
-    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("secret_key", None)
+    args["secret_key"] = field
 
-    return Device(**args)
+    return TriggerSqsClientConfig(**args)
 
 
-def unmarshal_Hub(data: Any) -> Hub:
+def unmarshal_Container(data: Any) -> Container:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Hub' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Container' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("connected_device_count")
-    args["connected_device_count"] = field
+    field = data.get("cpu_limit", None)
+    args["cpu_limit"] = field
 
-    field = data.get("created_at")
-    args["created_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("description", None)
+    args["description"] = field
 
-    field = data.get("device_count")
-    args["device_count"] = field
+    field = data.get("domain_name", None)
+    args["domain_name"] = field
 
-    field = data.get("disable_events")
-    args["disable_events"] = field
+    field = data.get("environment_variables", None)
+    args["environment_variables"] = field
 
-    field = data.get("enable_device_auto_provisioning")
-    args["enable_device_auto_provisioning"] = field
+    field = data.get("error_message", None)
+    args["error_message"] = field
 
-    field = data.get("enabled")
-    args["enabled"] = field
+    field = data.get("http_option", None)
+    args["http_option"] = field
 
-    field = data.get("endpoint")
-    args["endpoint"] = field
+    field = data.get("id", None)
+    args["id"] = field
 
-    field = data.get("events_topic_prefix")
-    args["events_topic_prefix"] = field
+    field = data.get("max_concurrency", None)
+    args["max_concurrency"] = field
 
-    field = data.get("has_custom_ca")
-    args["has_custom_ca"] = field
+    field = data.get("max_scale", None)
+    args["max_scale"] = field
 
-    field = data.get("id")
-    args["id"] = field
+    field = data.get("memory_limit", None)
+    args["memory_limit"] = field
+
+    field = data.get("min_scale", None)
+    args["min_scale"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("organization_id")
-    args["organization_id"] = field
+    field = data.get("namespace_id", None)
+    args["namespace_id"] = field
 
-    field = data.get("product_plan")
-    args["product_plan"] = field
+    field = data.get("port", None)
+    args["port"] = field
 
-    field = data.get("project_id")
-    args["project_id"] = field
+    field = data.get("privacy", None)
+    args["privacy"] = field
 
-    field = data.get("region")
+    field = data.get("protocol", None)
+    args["protocol"] = field
+
+    field = data.get("region", None)
     args["region"] = field
 
-    field = data.get("status")
-    args["status"] = field
+    field = data.get("registry_image", None)
+    args["registry_image"] = field
 
-    field = data.get("twins_graphite_config")
-    args["twins_graphite_config"] = (
-        unmarshal_HubTwinsGraphiteConfig(field) if field is not None else None
+    field = data.get("secret_environment_variables", None)
+    args["secret_environment_variables"] = (
+        [unmarshal_SecretHashedValue(v) for v in field] if field is not None else None
     )
 
-    field = data.get("updated_at")
-    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("status", None)
+    args["status"] = field
+
+    field = data.get("timeout", None)
+    args["timeout"] = field
 
-    return Hub(**args)
+    return Container(**args)
 
 
-def unmarshal_ListTwinDocumentsResponseDocumentSummary(
-    data: Any,
-) -> ListTwinDocumentsResponseDocumentSummary:
+def unmarshal_Cron(data: Any) -> Cron:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListTwinDocumentsResponseDocumentSummary' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Cron' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("document_name")
-    args["document_name"] = field
+    field = data.get("args", None)
+    args["args"] = field
+
+    field = data.get("container_id", None)
+    args["container_id"] = field
 
-    return ListTwinDocumentsResponseDocumentSummary(**args)
+    field = data.get("id", None)
+    args["id"] = field
 
+    field = data.get("name", None)
+    args["name"] = field
+
+    field = data.get("schedule", None)
+    args["schedule"] = field
+
+    field = data.get("status", None)
+    args["status"] = field
 
-def unmarshal_Network(data: Any) -> Network:
+    return Cron(**args)
+
+
+def unmarshal_Domain(data: Any) -> Domain:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Network' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Domain' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
-    args["created_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("container_id", None)
+    args["container_id"] = field
 
-    field = data.get("endpoint")
-    args["endpoint"] = field
+    field = data.get("error_message", None)
+    args["error_message"] = field
 
-    field = data.get("hub_id")
-    args["hub_id"] = field
+    field = data.get("hostname", None)
+    args["hostname"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("name")
-    args["name"] = field
-
-    field = data.get("topic_prefix")
-    args["topic_prefix"] = field
+    field = data.get("status", None)
+    args["status"] = field
 
-    field = data.get("type_")
-    args["type_"] = field
+    field = data.get("url", None)
+    args["url"] = field
 
-    return Network(**args)
+    return Domain(**args)
 
 
-def unmarshal_RouteDatabaseConfig(data: Any) -> RouteDatabaseConfig:
+def unmarshal_Log(data: Any) -> Log:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'RouteDatabaseConfig' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Log' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("dbname")
-    args["dbname"] = field
-
-    field = data.get("engine")
-    args["engine"] = field
+    field = data.get("id", None)
+    args["id"] = field
 
-    field = data.get("host")
-    args["host"] = field
+    field = data.get("level", None)
+    args["level"] = field
 
-    field = data.get("password")
-    args["password"] = field
+    field = data.get("message", None)
+    args["message"] = field
 
-    field = data.get("port")
-    args["port"] = field
+    field = data.get("source", None)
+    args["source"] = field
 
-    field = data.get("query")
-    args["query"] = field
+    field = data.get("stream", None)
+    args["stream"] = field
 
-    field = data.get("username")
-    args["username"] = field
+    field = data.get("timestamp", None)
+    args["timestamp"] = parser.isoparse(field) if type(field) is str else field
 
-    return RouteDatabaseConfig(**args)
+    return Log(**args)
 
 
-def unmarshal_RouteRestConfig(data: Any) -> RouteRestConfig:
+def unmarshal_Namespace(data: Any) -> Namespace:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'RouteRestConfig' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Namespace' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("headers")
-    args["headers"] = field
+    field = data.get("description", None)
+    args["description"] = field
 
-    field = data.get("uri")
-    args["uri"] = field
+    field = data.get("environment_variables", None)
+    args["environment_variables"] = field
 
-    field = data.get("verb")
-    args["verb"] = field
+    field = data.get("error_message", None)
+    args["error_message"] = field
 
-    return RouteRestConfig(**args)
+    field = data.get("id", None)
+    args["id"] = field
 
+    field = data.get("name", None)
+    args["name"] = field
 
-def unmarshal_RouteS3Config(data: Any) -> RouteS3Config:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'RouteS3Config' failed as data isn't a dictionary."
-        )
+    field = data.get("organization_id", None)
+    args["organization_id"] = field
 
-    args: Dict[str, Any] = {}
+    field = data.get("project_id", None)
+    args["project_id"] = field
+
+    field = data.get("region", None)
+    args["region"] = field
 
-    field = data.get("bucket_name")
-    args["bucket_name"] = field
+    field = data.get("registry_endpoint", None)
+    args["registry_endpoint"] = field
 
-    field = data.get("bucket_region")
-    args["bucket_region"] = field
+    field = data.get("registry_namespace_id", None)
+    args["registry_namespace_id"] = field
 
-    field = data.get("object_prefix")
-    args["object_prefix"] = field
+    field = data.get("secret_environment_variables", None)
+    args["secret_environment_variables"] = (
+        [unmarshal_SecretHashedValue(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("strategy")
-    args["strategy"] = field
+    field = data.get("status", None)
+    args["status"] = field
 
-    return RouteS3Config(**args)
+    return Namespace(**args)
 
 
-def unmarshal_RouteSummary(data: Any) -> RouteSummary:
+def unmarshal_Token(data: Any) -> Token:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'RouteSummary' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Token' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
-    args["created_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("container_id", None)
+    args["container_id"] = field
 
-    field = data.get("hub_id")
-    args["hub_id"] = field
+    field = data.get("description", None)
+    args["description"] = field
 
-    field = data.get("id")
+    field = data.get("expires_at", None)
+    args["expires_at"] = parser.isoparse(field) if type(field) is str else field
+
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("name")
-    args["name"] = field
+    field = data.get("namespace_id", None)
+    args["namespace_id"] = field
 
-    field = data.get("topic")
-    args["topic"] = field
+    field = data.get("public_key", None)
+    args["public_key"] = field
 
-    field = data.get("type_")
-    args["type_"] = field
+    field = data.get("status", None)
+    args["status"] = field
 
-    field = data.get("updated_at")
-    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("token", None)
+    args["token"] = field
 
-    return RouteSummary(**args)
+    return Token(**args)
 
 
-def unmarshal_CreateDeviceResponse(data: Any) -> CreateDeviceResponse:
+def unmarshal_Trigger(data: Any) -> Trigger:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'CreateDeviceResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Trigger' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("certificate")
-    args["certificate"] = unmarshal_Certificate(field) if field is not None else None
+    field = data.get("container_id", None)
+    args["container_id"] = field
 
-    field = data.get("device")
-    args["device"] = unmarshal_Device(field) if field is not None else None
+    field = data.get("description", None)
+    args["description"] = field
 
-    return CreateDeviceResponse(**args)
+    field = data.get("error_message", None)
+    args["error_message"] = field
 
+    field = data.get("id", None)
+    args["id"] = field
 
-def unmarshal_CreateNetworkResponse(data: Any) -> CreateNetworkResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'CreateNetworkResponse' failed as data isn't a dictionary."
-        )
+    field = data.get("input_type", None)
+    args["input_type"] = field
 
-    args: Dict[str, Any] = {}
+    field = data.get("name", None)
+    args["name"] = field
+
+    field = data.get("scw_nats_config", None)
+    args["scw_nats_config"] = (
+        unmarshal_TriggerMnqNatsClientConfig(field) if field is not None else None
+    )
 
-    field = data.get("network")
-    args["network"] = unmarshal_Network(field) if field is not None else None
+    field = data.get("scw_sqs_config", None)
+    args["scw_sqs_config"] = (
+        unmarshal_TriggerMnqSqsClientConfig(field) if field is not None else None
+    )
 
-    field = data.get("secret")
-    args["secret"] = field
+    field = data.get("sqs_config", None)
+    args["sqs_config"] = (
+        unmarshal_TriggerSqsClientConfig(field) if field is not None else None
+    )
+
+    field = data.get("status", None)
+    args["status"] = field
 
-    return CreateNetworkResponse(**args)
+    return Trigger(**args)
 
 
-def unmarshal_GetDeviceCertificateResponse(data: Any) -> GetDeviceCertificateResponse:
+def unmarshal_ListContainersResponse(data: Any) -> ListContainersResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'GetDeviceCertificateResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListContainersResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("certificate_pem")
-    args["certificate_pem"] = field
+    field = data.get("containers", None)
+    args["containers"] = (
+        [unmarshal_Container(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("device")
-    args["device"] = unmarshal_Device(field) if field is not None else None
+    field = data.get("total_count", None)
+    args["total_count"] = field
 
-    return GetDeviceCertificateResponse(**args)
+    return ListContainersResponse(**args)
 
 
-def unmarshal_GetDeviceMetricsResponse(data: Any) -> GetDeviceMetricsResponse:
+def unmarshal_ListCronsResponse(data: Any) -> ListCronsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'GetDeviceMetricsResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListCronsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("metrics")
-    args["metrics"] = [unmarshal_TimeSeries(v) for v in data["metrics"]]
+    field = data.get("crons", None)
+    args["crons"] = [unmarshal_Cron(v) for v in field] if field is not None else None
+
+    field = data.get("total_count", None)
+    args["total_count"] = field
 
-    return GetDeviceMetricsResponse(**args)
+    return ListCronsResponse(**args)
 
 
-def unmarshal_GetHubCAResponse(data: Any) -> GetHubCAResponse:
+def unmarshal_ListDomainsResponse(data: Any) -> ListDomainsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'GetHubCAResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListDomainsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("ca_cert_pem")
-    args["ca_cert_pem"] = field
+    field = data.get("domains", None)
+    args["domains"] = (
+        [unmarshal_Domain(v) for v in field] if field is not None else None
+    )
+
+    field = data.get("total_count", None)
+    args["total_count"] = field
 
-    return GetHubCAResponse(**args)
+    return ListDomainsResponse(**args)
 
 
-def unmarshal_GetHubMetricsResponse(data: Any) -> GetHubMetricsResponse:
+def unmarshal_ListLogsResponse(data: Any) -> ListLogsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'GetHubMetricsResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListLogsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("metrics")
-    args["metrics"] = [unmarshal_TimeSeries(v) for v in data["metrics"]]
+    field = data.get("logs", None)
+    args["logs"] = [unmarshal_Log(v) for v in field] if field is not None else None
+
+    field = data.get("total_count", None)
+    args["total_count"] = field
 
-    return GetHubMetricsResponse(**args)
+    return ListLogsResponse(**args)
 
 
-def unmarshal_ListDevicesResponse(data: Any) -> ListDevicesResponse:
+def unmarshal_ListNamespacesResponse(data: Any) -> ListNamespacesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListDevicesResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListNamespacesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("devices")
-    args["devices"] = [unmarshal_Device(v) for v in data["devices"]]
+    field = data.get("namespaces", None)
+    args["namespaces"] = (
+        [unmarshal_Namespace(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListDevicesResponse(**args)
+    return ListNamespacesResponse(**args)
 
 
-def unmarshal_ListHubsResponse(data: Any) -> ListHubsResponse:
+def unmarshal_ListTokensResponse(data: Any) -> ListTokensResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListHubsResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListTokensResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("hubs")
-    args["hubs"] = [unmarshal_Hub(v) for v in data["hubs"]]
+    field = data.get("tokens", None)
+    args["tokens"] = [unmarshal_Token(v) for v in field] if field is not None else None
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListHubsResponse(**args)
+    return ListTokensResponse(**args)
 
 
-def unmarshal_ListNetworksResponse(data: Any) -> ListNetworksResponse:
+def unmarshal_ListTriggersResponse(data: Any) -> ListTriggersResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListNetworksResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListTriggersResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("networks")
-    args["networks"] = [unmarshal_Network(v) for v in data["networks"]]
-
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListNetworksResponse(**args)
+    field = data.get("triggers", None)
+    args["triggers"] = (
+        [unmarshal_Trigger(v) for v in field] if field is not None else None
+    )
 
+    return ListTriggersResponse(**args)
 
-def unmarshal_ListRoutesResponse(data: Any) -> ListRoutesResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ListRoutesResponse' failed as data isn't a dictionary."
-        )
 
-    args: Dict[str, Any] = {}
+def marshal_CreateTriggerRequestMnqNatsClientConfig(
+    request: CreateTriggerRequestMnqNatsClientConfig,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    field = data.get("routes")
-    args["routes"] = [unmarshal_RouteSummary(v) for v in data["routes"]]
+    if request.mnq_namespace_id is not None:
+        output["mnq_namespace_id"] = request.mnq_namespace_id
 
-    field = data.get("total_count")
-    args["total_count"] = field
+    if request.mnq_project_id is not None:
+        output["mnq_project_id"] = request.mnq_project_id
 
-    return ListRoutesResponse(**args)
+    if request.mnq_region is not None:
+        output["mnq_region"] = request.mnq_region
 
+    if request.subject is not None:
+        output["subject"] = request.subject
 
-def unmarshal_ListTwinDocumentsResponse(data: Any) -> ListTwinDocumentsResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ListTwinDocumentsResponse' failed as data isn't a dictionary."
-        )
+    return output
 
-    args: Dict[str, Any] = {}
 
-    field = data.get("documents")
-    args["documents"] = [
-        unmarshal_ListTwinDocumentsResponseDocumentSummary(v) for v in data["documents"]
-    ]
+def marshal_CreateTriggerRequestMnqSqsClientConfig(
+    request: CreateTriggerRequestMnqSqsClientConfig,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    return ListTwinDocumentsResponse(**args)
+    if request.mnq_namespace_id is not None:
+        output["mnq_namespace_id"] = request.mnq_namespace_id
 
+    if request.mnq_project_id is not None:
+        output["mnq_project_id"] = request.mnq_project_id
 
-def unmarshal_RenewDeviceCertificateResponse(
-    data: Any,
-) -> RenewDeviceCertificateResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'RenewDeviceCertificateResponse' failed as data isn't a dictionary."
-        )
+    if request.mnq_region is not None:
+        output["mnq_region"] = request.mnq_region
 
-    args: Dict[str, Any] = {}
+    if request.queue is not None:
+        output["queue"] = request.queue
 
-    field = data.get("certificate")
-    args["certificate"] = unmarshal_Certificate(field) if field is not None else None
+    return output
 
-    field = data.get("device")
-    args["device"] = unmarshal_Device(field) if field is not None else None
 
-    return RenewDeviceCertificateResponse(**args)
+def marshal_CreateTriggerRequestSqsClientConfig(
+    request: CreateTriggerRequestSqsClientConfig,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
+    if request.access_key is not None:
+        output["access_key"] = request.access_key
 
-def unmarshal_Route(data: Any) -> Route:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'Route' failed as data isn't a dictionary."
-        )
+    if request.endpoint is not None:
+        output["endpoint"] = request.endpoint
 
-    args: Dict[str, Any] = {}
+    if request.queue_url is not None:
+        output["queue_url"] = request.queue_url
 
-    field = data.get("created_at")
-    args["created_at"] = parser.isoparse(field) if type(field) is str else field
+    if request.secret_key is not None:
+        output["secret_key"] = request.secret_key
 
-    field = data.get("db_config")
-    args["db_config"] = (
-        unmarshal_RouteDatabaseConfig(field) if field is not None else None
-    )
+    return output
 
-    field = data.get("hub_id")
-    args["hub_id"] = field
 
-    field = data.get("id")
-    args["id"] = field
+def marshal_Secret(
+    request: Secret,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    field = data.get("name")
-    args["name"] = field
+    if request.key is not None:
+        output["key"] = request.key
 
-    field = data.get("rest_config")
-    args["rest_config"] = (
-        unmarshal_RouteRestConfig(field) if field is not None else None
-    )
+    if request.value is not None:
+        output["value"] = request.value
 
-    field = data.get("s3_config")
-    args["s3_config"] = unmarshal_RouteS3Config(field) if field is not None else None
+    return output
 
-    field = data.get("topic")
-    args["topic"] = field
 
-    field = data.get("type_")
-    args["type_"] = field
+def marshal_UpdateTriggerRequestSqsClientConfig(
+    request: UpdateTriggerRequestSqsClientConfig,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    field = data.get("updated_at")
-    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
+    if request.access_key is not None:
+        output["access_key"] = request.access_key
 
-    return Route(**args)
+    if request.secret_key is not None:
+        output["secret_key"] = request.secret_key
 
+    return output
 
-def unmarshal_SetDeviceCertificateResponse(data: Any) -> SetDeviceCertificateResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'SetDeviceCertificateResponse' failed as data isn't a dictionary."
-        )
 
-    args: Dict[str, Any] = {}
+def marshal_CreateContainerRequest(
+    request: CreateContainerRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
 
-    field = data.get("certificate_pem")
-    args["certificate_pem"] = field
+    if request.cpu_limit is not None:
+        output["cpu_limit"] = request.cpu_limit
 
-    field = data.get("device")
-    args["device"] = unmarshal_Device(field) if field is not None else None
+    if request.description is not None:
+        output["description"] = request.description
 
-    return SetDeviceCertificateResponse(**args)
+    if request.environment_variables is not None:
+        output["environment_variables"] = request.environment_variables
 
+    if request.http_option is not None:
+        output["http_option"] = ContainerHttpOption(request.http_option)
 
-def unmarshal_TwinDocument(data: Any) -> TwinDocument:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'TwinDocument' failed as data isn't a dictionary."
-        )
+    if request.max_concurrency is not None:
+        output["max_concurrency"] = request.max_concurrency
 
-    args: Dict[str, Any] = {}
+    if request.max_scale is not None:
+        output["max_scale"] = request.max_scale
 
-    field = data.get("data")
-    args["data"] = field
+    if request.memory_limit is not None:
+        output["memory_limit"] = request.memory_limit
 
-    field = data.get("document_name")
-    args["document_name"] = field
+    if request.min_scale is not None:
+        output["min_scale"] = request.min_scale
 
-    field = data.get("twin_id")
-    args["twin_id"] = field
+    if request.name is not None:
+        output["name"] = request.name
 
-    field = data.get("version")
-    args["version"] = field
+    if request.namespace_id is not None:
+        output["namespace_id"] = request.namespace_id
 
-    return TwinDocument(**args)
+    if request.port is not None:
+        output["port"] = request.port
 
+    if request.privacy is not None:
+        output["privacy"] = ContainerPrivacy(request.privacy)
 
-def marshal_DeviceMessageFiltersRule(
-    request: DeviceMessageFiltersRule,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "policy": DeviceMessageFiltersRulePolicy(request.policy),
-        "topics": request.topics,
-    }
+    if request.protocol is not None:
+        output["protocol"] = ContainerProtocol(request.protocol)
 
+    if request.registry_image is not None:
+        output["registry_image"] = request.registry_image
 
-def marshal_CreateRouteRequestDatabaseConfig(
-    request: CreateRouteRequestDatabaseConfig,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "dbname": request.dbname,
-        "engine": RouteDatabaseConfigEngine(request.engine),
-        "host": request.host,
-        "password": request.password,
-        "port": request.port,
-        "query": request.query,
-        "username": request.username,
-    }
+    if request.secret_environment_variables is not None:
+        output["secret_environment_variables"] = [
+            marshal_Secret(v, defaults) for v in request.secret_environment_variables
+        ]
 
+    if request.timeout is not None:
+        output["timeout"] = request.timeout
 
-def marshal_CreateRouteRequestRestConfig(
-    request: CreateRouteRequestRestConfig,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "headers": request.headers,
-        "uri": request.uri,
-        "verb": RouteRestConfigHttpVerb(request.verb),
-    }
+    return output
 
 
-def marshal_CreateRouteRequestS3Config(
-    request: CreateRouteRequestS3Config,
+def marshal_CreateCronRequest(
+    request: CreateCronRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "bucket_name": request.bucket_name,
-        "bucket_region": request.bucket_region,
-        "object_prefix": request.object_prefix,
-        "strategy": RouteS3ConfigS3Strategy(request.strategy),
-    }
+    output: Dict[str, Any] = {}
 
+    if request.args is not None:
+        output["args"] = request.args
 
-def marshal_DeviceMessageFilters(
-    request: DeviceMessageFilters,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "publish": marshal_DeviceMessageFiltersRule(request.publish, defaults)
-        if request.publish is not None
-        else None,
-        "subscribe": marshal_DeviceMessageFiltersRule(request.subscribe, defaults)
-        if request.subscribe is not None
-        else None,
-    }
+    if request.container_id is not None:
+        output["container_id"] = request.container_id
 
+    if request.name is not None:
+        output["name"] = request.name
 
-def marshal_HubTwinsGraphiteConfig(
-    request: HubTwinsGraphiteConfig,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "push_uri": request.push_uri,
-    }
+    if request.schedule is not None:
+        output["schedule"] = request.schedule
 
+    return output
 
-def marshal_UpdateRouteRequestDatabaseConfig(
-    request: UpdateRouteRequestDatabaseConfig,
+
+def marshal_CreateDomainRequest(
+    request: CreateDomainRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "dbname": request.dbname,
-        "engine": RouteDatabaseConfigEngine(request.engine),
-        "host": request.host,
-        "password": request.password,
-        "port": request.port,
-        "query": request.query,
-        "username": request.username,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.container_id is not None:
+        output["container_id"] = request.container_id
 
-def marshal_UpdateRouteRequestRestConfig(
-    request: UpdateRouteRequestRestConfig,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "headers": request.headers,
-        "uri": request.uri,
-        "verb": RouteRestConfigHttpVerb(request.verb),
-    }
+    if request.hostname is not None:
+        output["hostname"] = request.hostname
 
+    return output
 
-def marshal_UpdateRouteRequestS3Config(
-    request: UpdateRouteRequestS3Config,
+
+def marshal_CreateNamespaceRequest(
+    request: CreateNamespaceRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "bucket_name": request.bucket_name,
-        "bucket_region": request.bucket_region,
-        "object_prefix": request.object_prefix,
-        "strategy": RouteS3ConfigS3Strategy(request.strategy),
-    }
+    output: Dict[str, Any] = {}
 
+    if request.description is not None:
+        output["description"] = request.description
 
-def marshal_CreateDeviceRequest(
-    request: CreateDeviceRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "allow_insecure": request.allow_insecure,
-        "allow_multiple_connections": request.allow_multiple_connections,
-        "description": request.description,
-        "hub_id": request.hub_id,
-        "message_filters": marshal_DeviceMessageFilters(
-            request.message_filters, defaults
-        )
-        if request.message_filters is not None
-        else None,
-        "name": request.name,
-    }
+    if request.environment_variables is not None:
+        output["environment_variables"] = request.environment_variables
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
 
+    if request.secret_environment_variables is not None:
+        output["secret_environment_variables"] = [
+            marshal_Secret(v, defaults) for v in request.secret_environment_variables
+        ]
 
-def marshal_CreateHubRequest(
-    request: CreateHubRequest,
+    return output
+
+
+def marshal_CreateTokenRequest(
+    request: CreateTokenRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
                 OneOfPossibility(
-                    "twins_graphite_config", request.twins_graphite_config
+                    "container_id",
+                    request.container_id if request.container_id is not None else None,
+                ),
+                OneOfPossibility(
+                    "namespace_id",
+                    request.namespace_id if request.namespace_id is not None else None,
                 ),
             ]
         ),
-        "disable_events": request.disable_events,
-        "events_topic_prefix": request.events_topic_prefix,
-        "name": request.name,
-        "product_plan": HubProductPlan(request.product_plan)
-        if request.product_plan is not None
-        else None,
-        "project_id": request.project_id or defaults.default_project_id,
-    }
+    )
 
+    if request.description is not None:
+        output["description"] = request.description
 
-def marshal_CreateNetworkRequest(
-    request: CreateNetworkRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "hub_id": request.hub_id,
-        "name": request.name,
-        "topic_prefix": request.topic_prefix,
-        "type": NetworkNetworkType(request.type_)
-        if request.type_ is not None
-        else None,
-    }
+    if request.expires_at is not None:
+        output["expires_at"] = request.expires_at
 
+    return output
 
-def marshal_CreateRouteRequest(
-    request: CreateRouteRequest,
+
+def marshal_CreateTriggerRequest(
+    request: CreateTriggerRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("s3_config", request.s3_config),
-                OneOfPossibility("db_config", request.db_config),
-                OneOfPossibility("rest_config", request.rest_config),
+                OneOfPossibility(
+                    "scw_sqs_config",
+                    marshal_CreateTriggerRequestMnqSqsClientConfig(
+                        request.scw_sqs_config, defaults
+                    )
+                    if request.scw_sqs_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "sqs_config",
+                    marshal_CreateTriggerRequestSqsClientConfig(
+                        request.sqs_config, defaults
+                    )
+                    if request.sqs_config is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "scw_nats_config",
+                    marshal_CreateTriggerRequestMnqNatsClientConfig(
+                        request.scw_nats_config, defaults
+                    )
+                    if request.scw_nats_config is not None
+                    else None,
+                ),
             ]
         ),
-        "hub_id": request.hub_id,
-        "name": request.name,
-        "topic": request.topic,
-    }
+    )
 
+    if request.container_id is not None:
+        output["container_id"] = request.container_id
 
-def marshal_PatchTwinDocumentRequest(
-    request: PatchTwinDocumentRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "data": request.data,
-        "version": request.version,
-    }
+    if request.description is not None:
+        output["description"] = request.description
 
+    if request.name is not None:
+        output["name"] = request.name
 
-def marshal_PutTwinDocumentRequest(
-    request: PutTwinDocumentRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "data": request.data,
-        "version": request.version,
-    }
+    return output
 
 
-def marshal_SetDeviceCertificateRequest(
-    request: SetDeviceCertificateRequest,
+def marshal_UpdateContainerRequest(
+    request: UpdateContainerRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "certificate_pem": request.certificate_pem,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.cpu_limit is not None:
+        output["cpu_limit"] = request.cpu_limit
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.environment_variables is not None:
+        output["environment_variables"] = request.environment_variables
+
+    if request.http_option is not None:
+        output["http_option"] = ContainerHttpOption(request.http_option)
+
+    if request.max_concurrency is not None:
+        output["max_concurrency"] = request.max_concurrency
+
+    if request.max_scale is not None:
+        output["max_scale"] = request.max_scale
+
+    if request.memory_limit is not None:
+        output["memory_limit"] = request.memory_limit
 
+    if request.min_scale is not None:
+        output["min_scale"] = request.min_scale
 
-def marshal_SetHubCARequest(
-    request: SetHubCARequest,
+    if request.port is not None:
+        output["port"] = request.port
+
+    if request.privacy is not None:
+        output["privacy"] = ContainerPrivacy(request.privacy)
+
+    if request.protocol is not None:
+        output["protocol"] = ContainerProtocol(request.protocol)
+
+    if request.redeploy is not None:
+        output["redeploy"] = request.redeploy
+
+    if request.registry_image is not None:
+        output["registry_image"] = request.registry_image
+
+    if request.secret_environment_variables is not None:
+        output["secret_environment_variables"] = [
+            marshal_Secret(v, defaults) for v in request.secret_environment_variables
+        ]
+
+    if request.timeout is not None:
+        output["timeout"] = request.timeout
+
+    return output
+
+
+def marshal_UpdateCronRequest(
+    request: UpdateCronRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "ca_cert_pem": request.ca_cert_pem,
-        "challenge_cert_pem": request.challenge_cert_pem,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.args is not None:
+        output["args"] = request.args
+
+    if request.container_id is not None:
+        output["container_id"] = request.container_id
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.schedule is not None:
+        output["schedule"] = request.schedule
 
+    return output
 
-def marshal_UpdateDeviceRequest(
-    request: UpdateDeviceRequest,
+
+def marshal_UpdateNamespaceRequest(
+    request: UpdateNamespaceRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "allow_insecure": request.allow_insecure,
-        "allow_multiple_connections": request.allow_multiple_connections,
-        "description": request.description,
-        "hub_id": request.hub_id,
-        "message_filters": marshal_DeviceMessageFilters(
-            request.message_filters, defaults
-        )
-        if request.message_filters is not None
-        else None,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.environment_variables is not None:
+        output["environment_variables"] = request.environment_variables
 
+    if request.secret_environment_variables is not None:
+        output["secret_environment_variables"] = [
+            marshal_Secret(v, defaults) for v in request.secret_environment_variables
+        ]
 
-def marshal_UpdateHubRequest(
-    request: UpdateHubRequest,
+    return output
+
+
+def marshal_UpdateTriggerRequest(
+    request: UpdateTriggerRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
                 OneOfPossibility(
-                    "twins_graphite_config", request.twins_graphite_config
+                    "sqs_config",
+                    marshal_UpdateTriggerRequestSqsClientConfig(
+                        request.sqs_config, defaults
+                    )
+                    if request.sqs_config is not None
+                    else None,
                 ),
             ]
         ),
-        "disable_events": request.disable_events,
-        "enable_device_auto_provisioning": request.enable_device_auto_provisioning,
-        "events_topic_prefix": request.events_topic_prefix,
-        "name": request.name,
-        "product_plan": HubProductPlan(request.product_plan),
-    }
+    )
 
+    if request.description is not None:
+        output["description"] = request.description
 
-def marshal_UpdateRouteRequest(
-    request: UpdateRouteRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
-            [
-                OneOfPossibility("s3_config", request.s3_config),
-                OneOfPossibility("db_config", request.db_config),
-                OneOfPossibility("rest_config", request.rest_config),
-            ]
-        ),
-        "name": request.name,
-        "topic": request.topic,
-    }
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
```

### Comparing `scaleway_async-0.9.0/scaleway_async/iot/v1/types.py` & `scaleway_async-1.0.0/scaleway_async/iot/v1/types.py`

 * *Files 15% similar despite different names*

```diff
@@ -176,42 +176,42 @@
 
     key: str
 
 
 @dataclass
 class CreateDeviceResponse:
     """
-    Create device response
+    Create device response.
     """
 
     device: Optional[Device]
     """
-    Created device information
+    Information related to the created device.
     """
 
     certificate: Optional[Certificate]
     """
-    Device certificate
+    Device certificate.
     """
 
 
 @dataclass
 class CreateNetworkResponse:
     """
-    Create network response
+    Create network response.
     """
 
     network: Optional[Network]
     """
-    Created network
+    Information related to the created network.
     """
 
     secret: str
     """
-    Endpoint Key to keep secret. This cannot be retrieved later
+    Endpoint Key to keep secret. This cannot be retrieved later.
     """
 
 
 @dataclass
 class CreateRouteRequestDatabaseConfig:
     host: str
 
@@ -247,254 +247,258 @@
 
     strategy: RouteS3ConfigS3Strategy
 
 
 @dataclass
 class Device:
     """
-    Device
+    Device.
     """
 
     id: str
     """
-    Device ID, also used as MQTT Client ID or Username
+    Device ID, also used as MQTT Client ID or username.
     """
 
     name: str
     """
-    Device name
+    Device name.
     """
 
     description: str
     """
-    Device description
+    Device description.
     """
 
     status: DeviceStatus
     """
-    Device status
+    Device status.
     """
 
     hub_id: str
     """
-    Hub ID
+    Hub ID.
     """
 
     last_activity_at: Optional[datetime]
     """
-    Device last connection/activity date
+    Last connection/activity date of a device.
     """
 
     is_connected: bool
     """
-    Whether the device is connected to the Hub or not
+    Defines whether the device is connected to the Hub.
     """
 
     allow_insecure: bool
     """
-    Whether to allow device to connect without TLS mutual authentication
+    Defines whether to allow the device to connect to the Hub without TLS mutual authentication.
     """
 
     allow_multiple_connections: bool
     """
-    Whether to allow multiple physical devices to connect with this device's credentials
+    Defines whether to allow multiple physical devices to connect to the Hub with this device's credentials.
     """
 
     message_filters: Optional[DeviceMessageFilters]
     """
-    Filter-sets to restrict the topics the device can publish/subscribe to
+    Filter-sets to restrict the topics the device can publish/subscribe to.
     """
 
     has_custom_certificate: bool
     """
-    Assigning a custom certificate allows a device to authenticate using that specific certificate without checking the hub's CA certificate.
+    Defines whether the device was assigned a custom certificate.
+    Assigning a custom certificate allows a device to authenticate using that specific certificate without checking the Hub's CA certificate.
     """
 
     created_at: Optional[datetime]
     """
-    Device add date
+    Date at which the device was added.
     """
 
     updated_at: Optional[datetime]
     """
-    Device last modification date
+    Date at which the device was last modified.
     """
 
 
 @dataclass
 class DeviceMessageFilters:
     """
-    Device. message filters
+    Device. message filters.
     """
 
     publish: Optional[DeviceMessageFiltersRule]
     """
-    Filtering rule to restrict topics the device can publish to
+    Filtering rule to restrict topics the device can publish to.
     """
 
     subscribe: Optional[DeviceMessageFiltersRule]
     """
-    Filtering rule to restrict topics the device can subscribe to
+    Filtering rule to restrict topics the device can subscribe to.
     """
 
 
 @dataclass
 class DeviceMessageFiltersRule:
     """
-    Device. message filters. rule
+    Device. message filters. rule.
     """
 
     policy: DeviceMessageFiltersRulePolicy
     """
-    If accept, the set will accept all topics in the topics list, but no other.
-    If reject, the set will deny all topics in the topics list, but all others will be allowed.
-    
+    How to use the topic list.
+    If set to `accept`, all topics in the topics list will be allowed, with all other topics being denied.
+    If set to `reject`, all topics in the topics list will be denied, with all other topics being allowed.
     """
 
     topics: Optional[List[str]]
     """
-    List of topics to accept or reject. It must be valid MQTT topics and up to 65535 characters
+    List of topics to accept or reject. It must be valid MQTT topics and up to 65535 characters.
     """
 
 
 @dataclass
 class GetDeviceCertificateResponse:
     """
-    Get device certificate response
+    Get device certificate response.
     """
 
     device: Optional[Device]
     """
-    Created device information
+    Information related to the created device.
     """
 
     certificate_pem: str
     """
-    Device certificate
+    Device certificate.
     """
 
 
 @dataclass
 class GetDeviceMetricsResponse:
     """
-    Get device metrics response
+    Get device metrics response.
     """
 
     metrics: List[TimeSeries]
     """
-    Metrics for a device over the requested period
+    Metrics for a device over the requested period.
     """
 
 
 @dataclass
 class GetHubCAResponse:
     ca_cert_pem: str
 
 
 @dataclass
 class GetHubMetricsResponse:
     """
-    Get hub metrics response
+    Get hub metrics response.
     """
 
     metrics: List[TimeSeries]
     """
-    Metrics for a hub over the requested period
+    Metrics for a Hub over the requested period.
     """
 
 
 @dataclass
 class Hub:
     """
-    Hub
+    Hub.
     """
 
     id: str
     """
-    Hub ID
+    Hub ID.
     """
 
     name: str
     """
-    Hub name
+    Hub name.
     """
 
     status: HubStatus
     """
-    Current status of the Hub
+    Current status of the Hub.
     """
 
     product_plan: HubProductPlan
     """
-    Hub feature set
+    Hub feature set.
     """
 
     enabled: bool
     """
-    Whether the hub has been enabled
+    Defines whether the hub has been enabled.
     """
 
     device_count: int
     """
-    Number of registered devices
+    Number of registered devices.
     """
 
     connected_device_count: int
     """
-    Number of currently connected devices
+    Number of currently connected devices.
     """
 
     endpoint: str
     """
-    Devices should be connected to this host, port may be 1883 (MQTT), 8883 (MQTT over TLS), 80 (MQTT over Websocket) or 443 (MQTT over Websocket over TLS).
+    Host to connect your devices to.
+    Devices should be connected to this host. Port may be 1883 (MQTT), 8883 (MQTT over TLS), 80 (MQTT over Websocket) or 443 (MQTT over Websocket over TLS).
     """
 
     disable_events: bool
     """
-    Disable Hub events
+    Defines whether to disable Hub events.
     """
 
     events_topic_prefix: str
     """
-    Hub events topic prefix
+    Hub events topic prefix.
     """
 
     region: Region
     """
-    Region of the Hub
+    Region of the Hub.
     """
 
     created_at: Optional[datetime]
     """
-    Hub creation date
+    Hub creation date.
     """
 
     updated_at: Optional[datetime]
     """
-    Hub last modification date
+    Hub last modification date.
     """
 
     project_id: str
     """
-    Project owning the resource
+    Project owning the resource.
     """
 
     organization_id: str
     """
-    Organization owning the resource
+    Organization owning the resource.
     """
 
     enable_device_auto_provisioning: bool
     """
-    When an unknown device connects to your hub using a valid certificate chain, it will be automatically provisioned inside your hub. The hub uses the common name of the device certifcate to find out if a device with the same name already exists. This setting can only be enabled on a hub with a custom certificate authority.
+    Defines whether to enable device auto provisioning.
+    When an unknown device connects to your hub using a valid certificate chain, it will be automatically provisioned inside your Hub. The Hub uses the common name of the device certifcate to find out if a device with the same name already exists. This setting can only be enabled on a hub with a custom certificate authority.
     """
 
     has_custom_ca: bool
     """
-    After creating a hub, this flag is set to False as the hub certificates are managed by Scaleway. Once a custom certificate authority is installed, this flag will be set to true.
+    Defines whether the hub is using a custom certificate authority.
+    Flag is automatically set to `false` after Hub creation, as Hub certificates are managed by Scaleway. Once a custom certificate authority is set, the flag will be set to `true`.
     """
 
     twins_graphite_config: Optional[HubTwinsGraphiteConfig]
     """
     BETA - not implemented yet.
     
     One-of ('twins_db_config'): at most one of 'twins_graphite_config' could be set.
@@ -505,196 +509,197 @@
 class HubTwinsGraphiteConfig:
     push_uri: str
 
 
 @dataclass
 class ListDevicesResponse:
     """
-    List devices response
+    List devices response.
     """
 
     total_count: int
     """
-    Total number of devices
+    Total number of devices.
     """
 
     devices: List[Device]
     """
-    A page of devices
+    Page of devices.
     """
 
 
 @dataclass
 class ListHubsResponse:
     """
-    List hubs response
+    List hubs response.
     """
 
     total_count: int
     """
-    Total number of hubs
+    Total number of Hubs.
     """
 
     hubs: List[Hub]
     """
-    A page of hubs
+    A page of hubs.
     """
 
 
 @dataclass
 class ListNetworksResponse:
     """
-    List networks response
+    List networks response.
     """
 
     total_count: int
     """
-    Total number of Networks
+    Total number of Networks.
     """
 
     networks: List[Network]
     """
-    A page of networks
+    Page of networks.
     """
 
 
 @dataclass
 class ListRoutesResponse:
     """
-    List routes response
+    List routes response.
     """
 
     total_count: int
     """
-    Total number of routes
+    Total number of routes.
     """
 
     routes: List[RouteSummary]
     """
-    A page of routes
+    Page of routes.
     """
 
 
 @dataclass
 class ListTwinDocumentsResponse:
     """
-    List twin documents response
+    List twin documents response.
     """
 
     documents: List[ListTwinDocumentsResponseDocumentSummary]
     """
-    Twin's document list
+    List of the twin document.
     """
 
 
 @dataclass
 class ListTwinDocumentsResponseDocumentSummary:
     """
-    List twin documents response. document summary
+    List twin documents response. document summary.
     """
 
     document_name: str
     """
-    Document's name
+    Name of the document.
     """
 
 
 @dataclass
 class Network:
     """
-    Network
+    Network.
     """
 
     id: str
     """
-    Network ID
+    Network ID.
     """
 
     name: str
     """
-    Network name
+    Network name.
     """
 
     type_: NetworkNetworkType
     """
-    Type of network to connect with
+    Type of network to connect with.
     """
 
     endpoint: str
     """
-    Endpoint to use for interacting with the network
+    Endpoint to use for interacting with the network.
     """
 
     hub_id: str
     """
-    Hub ID to connect the Network to
+    Hub ID to connect the Network to.
     """
 
     created_at: Optional[datetime]
     """
-    Network creation date
+    Date at which the network was created.
     """
 
     topic_prefix: str
     """
+    Topic prefix for the Network.
     This prefix will be prepended to all topics for this Network.
     """
 
 
 @dataclass
 class RenewDeviceCertificateResponse:
     """
-    Renew device certificate response
+    Renew device certificate response.
     """
 
     device: Optional[Device]
     """
-    Created device information
+    Information related to the created device.
     """
 
     certificate: Optional[Certificate]
     """
-    Device certificate
+    Device certificate.
     """
 
 
 @dataclass
 class Route:
     """
-    Route
+    Route.
     """
 
     id: str
     """
-    Route ID
+    Route ID.
     """
 
     name: str
     """
-    Route name
+    Route name.
     """
 
     hub_id: str
     """
-    ID of the route's hub
+    Hub ID of the route.
     """
 
     topic: str
     """
-    Topic the route subscribes to. It must be a valid MQTT topic and up to 65535 characters
+    Topic the route subscribes to. It must be a valid MQTT topic and up to 65535 characters.
     """
 
     type_: RouteRouteType
     """
-    Route type
+    Route type.
     """
 
     created_at: Optional[datetime]
     """
-    Route creation date
+    Date at which the route was created.
     """
 
     s3_config: Optional[RouteS3Config]
     """
     When using S3 Route, S3-specific configuration fields.
     
     One-of ('config'): at most one of 's3_config', 'db_config', 'rest_config' could be set.
@@ -712,182 +717,182 @@
     When using Rest Route, Rest-specific configuration fields.
     
     One-of ('config'): at most one of 's3_config', 'db_config', 'rest_config' could be set.
     """
 
     updated_at: Optional[datetime]
     """
-    Route last update date
+    Date at which the route was last updated.
     """
 
 
 @dataclass
 class RouteDatabaseConfig:
     """
-    Route. database config
+    Route. database config.
     """
 
     engine: RouteDatabaseConfigEngine
     """
-    Database engine the route will connect to. If not specified, will default to 'PostgreSQL'
+    Database engine the route will connect to. If not specified, the default database will be 'PostgreSQL'.
     """
 
     host: str
     """
-    Database host
+    Database host.
     """
 
     port: int
     """
-    Database port
+    Database port.
     """
 
     dbname: str
     """
-    Database name
+    Database name.
     """
 
     username: str
     """
-    Database username. Make sure this account can execute the provided query
+    Database username. Make sure this account can execute the provided query.
     """
 
     password: str
     """
-    Database password
+    Database password.
     """
 
     query: str
     """
-    SQL query to be executed ($TOPIC and $PAYLOAD variables are available, see documentation)
+    SQL query to be executed ($TOPIC and $PAYLOAD variables are available, see documentation).
     """
 
 
 @dataclass
 class RouteRestConfig:
     """
-    Route. rest config
+    Route. rest config.
     """
 
     verb: RouteRestConfigHttpVerb
     """
-    HTTP Verb used to call REST URI
+    HTTP verb used to call REST URI.
     """
 
     uri: str
     """
-    URI of the REST endpoint
+    URI of the REST endpoint.
     """
 
     headers: Dict[str, str]
     """
-    HTTP call extra headers
+    HTTP call extra headers.
     """
 
 
 @dataclass
 class RouteS3Config:
     """
-    Route.s3 config
+    Route.s3 config.
     """
 
     bucket_region: str
     """
-    Region of the S3 route's destination bucket (eg 'fr-par')
+    Region of the S3 route's destination bucket (e.g., 'fr-par').
     """
 
     bucket_name: str
     """
-    Name of the S3 route's destination bucket
+    Destination bucket name of the S3 route.
     """
 
     object_prefix: str
     """
-    Optional string to prefix object names with
+    Optional string to prefix object names with.
     """
 
     strategy: RouteS3ConfigS3Strategy
     """
-    How the S3 route's objects will be created: one per topic or one per message
+    How the S3 route's objects will be created: one per topic or one per message.
     """
 
 
 @dataclass
 class RouteSummary:
     """
-    Route summary
+    Route summary.
     """
 
     id: str
     """
-    Route ID
+    Route ID.
     """
 
     name: str
     """
-    Route name
+    Route name.
     """
 
     hub_id: str
     """
-    ID of the route's hub
+    Hub ID of the route.
     """
 
     topic: str
     """
-    Topic the route subscribes to. It must be a valid MQTT topic and up to 65535 characters
+    Topic the route subscribes to. It must be a valid MQTT topic and up to 65535 characters.
     """
 
     type_: RouteRouteType
     """
-    Route type
+    Route type.
     """
 
     created_at: Optional[datetime]
     """
-    Route creation date
+    Date at which the route was created.
     """
 
     updated_at: Optional[datetime]
     """
-    Route last update date
+    Date at which the route was last updated.
     """
 
 
 @dataclass
 class SetDeviceCertificateResponse:
     device: Optional[Device]
 
     certificate_pem: str
 
 
 @dataclass
 class TwinDocument:
     """
-    Twin document
+    Twin document.
     """
 
     twin_id: str
     """
-    Document's parent twin ID
+    Parent twin ID of the document.
     """
 
     document_name: str
     """
-    Document's name
+    Name of the document.
     """
 
     version: int
     """
-    Document's new version
+    New version of the document.
     """
 
     data: Optional[Dict[str, Any]]
     """
-    Document's new data
+    New data related to the document.
     """
 
 
 @dataclass
 class UpdateRouteRequestDatabaseConfig:
     host: Optional[str]
 
@@ -924,527 +929,528 @@
     strategy: RouteS3ConfigS3Strategy
 
 
 @dataclass
 class ListHubsRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     page: Optional[int]
     """
-    Page number
+    Page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    Page size. The maximum value is 100
+    Number of Hubs to return within a page. Maximum value is 100.
     """
 
     order_by: Optional[ListHubsRequestOrderBy]
     """
-    Ordering of requested hub
+    Sort order of Hubs in the response.
     """
 
     project_id: Optional[str]
     """
-    Filter on project
+    Only list Hubs of this Project ID.
     """
 
     organization_id: Optional[str]
     """
-    Filter on the organization
+    Only list Hubs of this Organization ID.
     """
 
     name: Optional[str]
     """
-    Filter on the name
+    Hub name.
     """
 
 
 @dataclass
 class CreateHubRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     name: Optional[str]
     """
-    Hub name (up to 255 characters)
+    Hub name (up to 255 characters).
     """
 
     project_id: Optional[str]
     """
-    Organization/project owning the resource
+    Project/Organization ID to filter for, only Hubs from this Project/Organization will be returned.
     """
 
     product_plan: Optional[HubProductPlan]
     """
-    Hub feature set
+    Hub product plan.
     """
 
     disable_events: Optional[bool]
     """
-    Disable Hub events
+    Disable Hub events.
     """
 
     events_topic_prefix: Optional[str]
     """
-    Hub events topic prefix (default '$SCW/events')
+    Topic prefix (default '$SCW/events') of Hub events.
     """
 
     twins_graphite_config: Optional[HubTwinsGraphiteConfig]
     """
     BETA - not implemented yet.
     
     One-of ('twins_db_config'): at most one of 'twins_graphite_config' could be set.
     """
 
 
 @dataclass
 class GetHubRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     hub_id: str
     """
-    Hub ID
+    Hub ID.
     """
 
 
 @dataclass
 class UpdateHubRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     hub_id: str
     """
-    Hub ID
+    ID of the Hub you want to update.
     """
 
     name: Optional[str]
     """
-    Hub name (up to 255 characters)
+    Hub name (up to 255 characters).
     """
 
     product_plan: HubProductPlan
     """
-    Hub feature set
+    Hub product plan.
     """
 
     disable_events: Optional[bool]
     """
-    Disable Hub events
+    Disable Hub events.
     """
 
     events_topic_prefix: Optional[str]
     """
-    Hub events topic prefix
+    Topic prefix of Hub events.
     """
 
     enable_device_auto_provisioning: Optional[bool]
     """
-    Enable device auto provisioning
+    Enable device auto provisioning.
     """
 
     twins_graphite_config: Optional[HubTwinsGraphiteConfig]
     """
     BETA - not implemented yet.
     
     One-of ('twins_db_config'): at most one of 'twins_graphite_config' could be set.
     """
 
 
 @dataclass
 class EnableHubRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     hub_id: str
     """
-    Hub ID
+    Hub ID.
     """
 
 
 @dataclass
 class DisableHubRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     hub_id: str
     """
-    Hub ID
+    Hub ID.
     """
 
 
 @dataclass
 class DeleteHubRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     hub_id: str
     """
-    Hub ID
+    Hub ID.
     """
 
     delete_devices: Optional[bool]
     """
-    Force deletion of devices added to this hub instead of rejecting operation
+    Defines whether to force the deletion of devices added to this Hub or reject the operation.
     """
 
 
 @dataclass
 class GetHubMetricsRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     hub_id: str
     """
-    Hub ID
+    Hub ID.
     """
 
     start_date: datetime
     """
-    Start date used to compute the best scale for the returned metrics
+    Start date used to compute the best scale for returned metrics.
     """
 
 
 @dataclass
 class SetHubCARequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     hub_id: str
     """
-    Hub ID
+    Hub ID.
     """
 
     ca_cert_pem: str
     """
-    The CA's PEM-encoded certificate
+    CA's PEM-encoded certificate.
     """
 
     challenge_cert_pem: str
     """
-    The challenge is a PEM-encoded certificate to prove the possession of the CA. It must be signed by the CA, and have a Common Name equal to the Hub ID.
+    Proof of possession of PEM-encoded certificate.
+    Challenge is a PEM-encoded certificate that acts as proof of possession of the CA. It must be signed by the CA, and have a Common Name equal to the Hub ID.
     """
 
 
 @dataclass
 class GetHubCARequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     hub_id: str
 
 
 @dataclass
 class ListDevicesRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     page: Optional[int]
     """
-    Page number
+    Page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    Page size. The maximum value is 100
+    Number of devices to return within a page. Maximum value is 100.
     """
 
     order_by: Optional[ListDevicesRequestOrderBy]
     """
-    Ordering of requested devices
+    Ordering of requested devices.
     """
 
     name: Optional[str]
     """
-    Filter on the name
+    Name to filter for, only devices with this name will be returned.
     """
 
     hub_id: Optional[str]
     """
-    Filter on the hub
+    Hub ID to filter for, only devices attached to this Hub will be returned.
     """
 
     allow_insecure: Optional[bool]
     """
-    Filter on the allow_insecure flag
+    Defines wheter to filter the allow_insecure flag.
     """
 
     status: Optional[DeviceStatus]
     """
-    Device status (enabled, disabled, etc.)
+    Device status (enabled, disabled, etc.).
     """
 
 
 @dataclass
 class CreateDeviceRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     name: Optional[str]
     """
-    Device name
+    Device name.
     """
 
     hub_id: str
     """
-    ID of the device's hub
+    Hub ID of the device.
     """
 
     allow_insecure: bool
     """
-    Allow plain and server-authenticated SSL connections in addition to mutually-authenticated ones
+    Defines whether to allow plain and server-authenticated SSL connections in addition to mutually-authenticated ones.
     """
 
     allow_multiple_connections: bool
     """
-    Allow multiple physical devices to connect with this device's credentials
+    Defines whether to allow multiple physical devices to connect with this device's credentials.
     """
 
     message_filters: Optional[DeviceMessageFilters]
     """
-    Filter-sets to authorize or deny the device to publish/subscribe to specific topics
+    Filter-sets to authorize or deny the device to publish/subscribe to specific topics.
     """
 
     description: Optional[str]
     """
-    Device description
+    Device description.
     """
 
 
 @dataclass
 class GetDeviceRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     device_id: str
     """
-    Device ID
+    Device ID.
     """
 
 
 @dataclass
 class UpdateDeviceRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     device_id: str
     """
-    Device ID
+    Device ID.
     """
 
     description: Optional[str]
     """
-    Device description
+    Description for the device.
     """
 
     allow_insecure: Optional[bool]
     """
-    Allow plain and server-authenticated SSL connections in addition to mutually-authenticated ones
+    Defines whether to allow plain and server-authenticated SSL connections in addition to mutually-authenticated ones.
     """
 
     allow_multiple_connections: Optional[bool]
     """
-    Allow multiple physical devices to connect with this device's credentials
+    Defines whether to allow multiple physical devices to connect with this device's credentials.
     """
 
     message_filters: Optional[DeviceMessageFilters]
     """
-    Filter-sets to restrict the topics the device can publish/subscribe to
+    Filter-sets to restrict the topics the device can publish/subscribe to.
     """
 
     hub_id: Optional[str]
     """
-    Change Hub for this device, additional fees may apply, see IoT Hub pricing
+    Change Hub for this device, additional fees may apply, see IoT Hub pricing.
     """
 
 
 @dataclass
 class EnableDeviceRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     device_id: str
     """
-    Device ID
+    Device ID.
     """
 
 
 @dataclass
 class DisableDeviceRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     device_id: str
     """
-    Device ID
+    Device ID.
     """
 
 
 @dataclass
 class RenewDeviceCertificateRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     device_id: str
     """
-    Device ID
+    Device ID.
     """
 
 
 @dataclass
 class SetDeviceCertificateRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     device_id: str
     """
-    Device ID
+    Device ID.
     """
 
     certificate_pem: str
     """
-    The PEM-encoded custom certificate
+    PEM-encoded custom certificate.
     """
 
 
 @dataclass
 class GetDeviceCertificateRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     device_id: str
     """
-    Device ID
+    Device ID.
     """
 
 
 @dataclass
 class DeleteDeviceRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     device_id: str
     """
-    Device ID
+    Device ID.
     """
 
 
 @dataclass
 class GetDeviceMetricsRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     device_id: str
     """
-    Device ID
+    Device ID.
     """
 
     start_date: datetime
     """
-    Start date used to compute the best scale for the returned metrics
+    Start date used to compute the best scale for the returned metrics.
     """
 
 
 @dataclass
 class ListRoutesRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     page: Optional[int]
     """
-    Page number
+    Page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    Page size. The maximum value is 100
+    Number of routes to return within a page. Maximum value is 100.
     """
 
     order_by: Optional[ListRoutesRequestOrderBy]
     """
-    Ordering of requested routes
+    Ordering of requested routes.
     """
 
     hub_id: Optional[str]
     """
-    Filter on the hub
+    Hub ID to filter for.
     """
 
     name: Optional[str]
     """
-    Filter on route's name
+    Route name to filter for.
     """
 
 
 @dataclass
 class CreateRouteRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     name: Optional[str]
     """
-    Route name
+    Route name.
     """
 
     hub_id: str
     """
-    ID of the route's hub
+    Hub ID of the route.
     """
 
     topic: str
     """
-    Topic the route subscribes to. It must be a valid MQTT topic and up to 65535 characters
+    Topic the route subscribes to. It must be a valid MQTT topic and up to 65535 characters.
     """
 
     s3_config: Optional[CreateRouteRequestS3Config]
     """
     If creating S3 Route, S3-specific configuration fields.
     
     One-of ('config'): at most one of 's3_config', 'db_config', 'rest_config' could be set.
@@ -1465,30 +1471,30 @@
     """
 
 
 @dataclass
 class UpdateRouteRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     route_id: str
     """
-    Route id
+    Route id.
     """
 
     name: Optional[str]
     """
-    Route name
+    Route name.
     """
 
     topic: Optional[str]
     """
-    Topic the route subscribes to. It must be a valid MQTT topic and up to 65535 characters
+    Topic the route subscribes to. It must be a valid MQTT topic and up to 65535 characters.
     """
 
     s3_config: Optional[UpdateRouteRequestS3Config]
     """
     When updating S3 Route, S3-specific configuration fields.
     
     One-of ('config'): at most one of 's3_config', 'db_config', 'rest_config' could be set.
@@ -1509,243 +1515,246 @@
     """
 
 
 @dataclass
 class GetRouteRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     route_id: str
     """
-    Route ID
+    Route ID.
     """
 
 
 @dataclass
 class DeleteRouteRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     route_id: str
     """
-    Route ID
+    Route ID.
     """
 
 
 @dataclass
 class ListNetworksRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     page: Optional[int]
     """
-    Page number
+    Page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    Page size. The maximum value is 100
+    Number of networks to return. The maximum value is 100.
     """
 
     order_by: Optional[ListNetworksRequestOrderBy]
     """
-    Ordering of requested routes
+    Ordering of requested routes.
     """
 
     name: Optional[str]
     """
-    Filter on Network name
+    Network name to filter for.
     """
 
     hub_id: Optional[str]
     """
-    Filter on the hub
+    Hub ID to filter for.
     """
 
     topic_prefix: Optional[str]
     """
-    Filter on the topic prefix
+    Topic prefix to filter for.
     """
 
 
 @dataclass
 class CreateNetworkRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     name: Optional[str]
     """
-    Network name
+    Network name.
     """
 
     type_: Optional[NetworkNetworkType]
     """
-    Type of network to connect with
+    Type of network to connect with.
     """
 
     hub_id: str
     """
-    Hub ID to connect the Network to
+    Hub ID to connect the Network to.
     """
 
     topic_prefix: str
     """
-    Topic prefix for the Network
+    Topic prefix for the Network.
     """
 
 
 @dataclass
 class GetNetworkRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     network_id: str
     """
-    Network ID
+    Network ID.
     """
 
 
 @dataclass
 class DeleteNetworkRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     network_id: str
     """
-    Network ID
+    Network ID.
     """
 
 
 @dataclass
 class GetTwinDocumentRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     twin_id: str
     """
-    Twin ID
+    Twin ID.
     """
 
     document_name: str
     """
-    Document name
+    Name of the document.
     """
 
 
 @dataclass
 class PutTwinDocumentRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     twin_id: str
     """
-    Twin ID
+    Twin ID.
     """
 
     document_name: str
     """
-    Document name
+    Name of the document.
     """
 
     version: Optional[int]
     """
-    If set, ensures that the document's current version matches before persisting the update.
+    Version of the document to update.
+    If set, ensures that the current version of the document matches before persisting the update.
     """
 
     data: Optional[Dict[str, Any]]
     """
-    The new data that will replace the contents of the document.
+    Data of the new document.
+    New data that will replace the contents of the document.
     """
 
 
 @dataclass
 class PatchTwinDocumentRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     twin_id: str
     """
-    Twin ID
+    Twin ID.
     """
 
     document_name: str
     """
-    Document name
+    Name of the document.
     """
 
     version: Optional[int]
     """
-    If set, ensures that the document's current version matches before persisting the update.
+    The version of the document to update.
+    If set, ensures that the current version of the document matches before persisting the update.
     """
 
     data: Optional[Dict[str, Any]]
     """
+    Patch data.
     A json data that will be applied on the document's current data.
     Patching rules:
     * The patch goes recursively through the patch objects.
-    * If the patch object property is null, then it is removed from the final object.
+    * If the patch object property is null, it is removed from the final object.
     * If the patch object property is a value (number, strings, bool, arrays), it is replaced.
     * If the patch object property is an object, the previous rules will be applied recursively on it.
-    
     """
 
 
 @dataclass
 class DeleteTwinDocumentRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     twin_id: str
     """
-    Twin ID
+    Twin ID.
     """
 
     document_name: str
     """
-    Document name
+    Name of the document.
     """
 
 
 @dataclass
 class ListTwinDocumentsRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     twin_id: str
     """
-    Twin ID
+    Twin ID.
     """
 
 
 @dataclass
 class DeleteTwinDocumentsRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     twin_id: str
     """
-    Twin ID
+    Twin ID.
     """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/k8s/v1/__init__.py` & `scaleway_async-1.0.0/scaleway_async/k8s/v1/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,34 +1,39 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 from .types import AutoscalerEstimator
 from .types import AutoscalerExpander
 from .types import CNI
 from .types import ClusterStatus
+from .types import ClusterTypeAvailability
+from .types import ClusterTypeResiliency
 from .types import Ingress
 from .types import ListClustersRequestOrderBy
 from .types import ListNodesRequestOrderBy
 from .types import ListPoolsRequestOrderBy
 from .types import MaintenanceWindowDayOfTheWeek
 from .types import NodeStatus
 from .types import PoolStatus
 from .types import PoolVolumeType
 from .types import Runtime
 from .types import Cluster
 from .types import ClusterAutoUpgrade
 from .types import ClusterAutoscalerConfig
 from .types import ClusterOpenIDConnectConfig
+from .types import ClusterType
 from .types import CreateClusterRequestAutoUpgrade
 from .types import CreateClusterRequestAutoscalerConfig
 from .types import CreateClusterRequestOpenIDConnectConfig
 from .types import CreateClusterRequestPoolConfig
 from .types import CreateClusterRequestPoolConfigUpgradePolicy
 from .types import CreatePoolRequestUpgradePolicy
 from .types import ExternalNode
+from .types import ListClusterAvailableTypesResponse
 from .types import ListClusterAvailableVersionsResponse
+from .types import ListClusterTypesResponse
 from .types import ListClustersResponse
 from .types import ListNodesResponse
 from .types import ListPoolsResponse
 from .types import ListVersionsResponse
 from .types import MaintenanceWindow
 from .types import Node
 from .types import Pool
@@ -44,35 +49,40 @@
 from .api import K8SV1API
 
 __all__ = [
     "AutoscalerEstimator",
     "AutoscalerExpander",
     "CNI",
     "ClusterStatus",
+    "ClusterTypeAvailability",
+    "ClusterTypeResiliency",
     "Ingress",
     "ListClustersRequestOrderBy",
     "ListNodesRequestOrderBy",
     "ListPoolsRequestOrderBy",
     "MaintenanceWindowDayOfTheWeek",
     "NodeStatus",
     "PoolStatus",
     "PoolVolumeType",
     "Runtime",
     "Cluster",
     "ClusterAutoUpgrade",
     "ClusterAutoscalerConfig",
     "ClusterOpenIDConnectConfig",
+    "ClusterType",
     "CreateClusterRequestAutoUpgrade",
     "CreateClusterRequestAutoscalerConfig",
     "CreateClusterRequestOpenIDConnectConfig",
     "CreateClusterRequestPoolConfig",
     "CreateClusterRequestPoolConfigUpgradePolicy",
     "CreatePoolRequestUpgradePolicy",
     "ExternalNode",
+    "ListClusterAvailableTypesResponse",
     "ListClusterAvailableVersionsResponse",
+    "ListClusterTypesResponse",
     "ListClustersResponse",
     "ListNodesResponse",
     "ListPoolsResponse",
     "ListVersionsResponse",
     "MaintenanceWindow",
     "Node",
     "Pool",
```

### Comparing `scaleway_async-0.9.0/scaleway_async/k8s/v1/api.py` & `scaleway_async-1.0.0/scaleway_async/k8s/v1/api.py`

 * *Files 6% similar despite different names*

```diff
@@ -25,67 +25,78 @@
     ListNodesRequestOrderBy,
     ListPoolsRequestOrderBy,
     NodeStatus,
     PoolStatus,
     PoolVolumeType,
     Runtime,
     Cluster,
+    ClusterType,
     CreateClusterRequestAutoUpgrade,
     CreateClusterRequestAutoscalerConfig,
     CreateClusterRequestOpenIDConnectConfig,
     CreateClusterRequestPoolConfig,
     CreatePoolRequestUpgradePolicy,
     ExternalNode,
+    ListClusterAvailableTypesResponse,
     ListClusterAvailableVersionsResponse,
+    ListClusterTypesResponse,
     ListClustersResponse,
     ListNodesResponse,
     ListPoolsResponse,
     ListVersionsResponse,
     Node,
     Pool,
     UpdateClusterRequestAutoUpgrade,
     UpdateClusterRequestAutoscalerConfig,
     UpdateClusterRequestOpenIDConnectConfig,
     UpdatePoolRequestUpgradePolicy,
     Version,
     CreateClusterRequest,
     UpdateClusterRequest,
     UpgradeClusterRequest,
+    SetClusterTypeRequest,
+    MigrateToPrivateNetworkClusterRequest,
     CreatePoolRequest,
     UpgradePoolRequest,
     UpdatePoolRequest,
 )
 from .content import (
     CLUSTER_TRANSIENT_STATUSES,
     NODE_TRANSIENT_STATUSES,
     POOL_TRANSIENT_STATUSES,
 )
 from .marshalling import (
     marshal_CreateClusterRequest,
     marshal_CreatePoolRequest,
+    marshal_MigrateToPrivateNetworkClusterRequest,
+    marshal_SetClusterTypeRequest,
     marshal_UpdateClusterRequest,
     marshal_UpdatePoolRequest,
     marshal_UpgradeClusterRequest,
     marshal_UpgradePoolRequest,
     unmarshal_Cluster,
     unmarshal_Node,
     unmarshal_Pool,
     unmarshal_Version,
     unmarshal_ExternalNode,
+    unmarshal_ListClusterAvailableTypesResponse,
     unmarshal_ListClusterAvailableVersionsResponse,
+    unmarshal_ListClusterTypesResponse,
     unmarshal_ListClustersResponse,
     unmarshal_ListNodesResponse,
     unmarshal_ListPoolsResponse,
     unmarshal_ListVersionsResponse,
 )
 
 
 class K8SV1API(API):
     """
-    Kapsule API.
+    Kubernetes API.
+
+    Kubernetes API.
     """
 
     async def list_clusters(
         self,
         *,
         region: Optional[Region] = None,
         organization_id: Optional[str] = None,
@@ -94,24 +105,25 @@
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         name: Optional[str] = None,
         status: ClusterStatus = ClusterStatus.UNKNOWN,
         type_: Optional[str] = None,
     ) -> ListClustersResponse:
         """
-        This method allows to list all the existing Kubernetes clusters in an account.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param organization_id: The organization ID on which to filter the returned clusters
-        :param project_id: The project ID on which to filter the returned clusters
-        :param order_by: The sort order of the returned clusters
-        :param page: The page number for the returned clusters
-        :param page_size: The maximum number of clusters per page
-        :param name: The name on which to filter the returned clusters
-        :param status: The status on which to filter the returned clusters
-        :param type_: The type on which to filter the returned clusters
+        List Clusters.
+        List all existing Kubernetes clusters in a specific region.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param organization_id: Organization ID on which to filter the returned clusters.
+        :param project_id: Project ID on which to filter the returned clusters.
+        :param order_by: Sort order of returned clusters.
+        :param page: Page number to return for clusters, from the paginated results.
+        :param page_size: Maximum number of clusters per page.
+        :param name: Name to filter on, only clusters containing this substring in their name will be returned.
+        :param status: Status to filter on, only clusters with this status will be returned.
+        :param type_: Type to filter on, only clusters with this type will be returned.
         :return: :class:`ListClustersResponse <ListClustersResponse>`
 
         Usage:
         ::
 
             result = await api.list_clusters()
         """
@@ -149,24 +161,25 @@
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         name: Optional[str] = None,
         status: Optional[ClusterStatus] = None,
         type_: Optional[str] = None,
     ) -> List[Cluster]:
         """
-        This method allows to list all the existing Kubernetes clusters in an account.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param organization_id: The organization ID on which to filter the returned clusters
-        :param project_id: The project ID on which to filter the returned clusters
-        :param order_by: The sort order of the returned clusters
-        :param page: The page number for the returned clusters
-        :param page_size: The maximum number of clusters per page
-        :param name: The name on which to filter the returned clusters
-        :param status: The status on which to filter the returned clusters
-        :param type_: The type on which to filter the returned clusters
+        List Clusters.
+        List all existing Kubernetes clusters in a specific region.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param organization_id: Organization ID on which to filter the returned clusters.
+        :param project_id: Project ID on which to filter the returned clusters.
+        :param order_by: Sort order of returned clusters.
+        :param page: Page number to return for clusters, from the paginated results.
+        :param page_size: Maximum number of clusters per page.
+        :param name: Name to filter on, only clusters containing this substring in their name will be returned.
+        :param status: Status to filter on, only clusters with this status will be returned.
+        :param type_: Type to filter on, only clusters with this type will be returned.
         :return: :class:`List[ListClustersResponse] <List[ListClustersResponse]>`
 
         Usage:
         ::
 
             result = await api.list_clusters_all()
         """
@@ -207,39 +220,42 @@
         auto_upgrade: Optional[CreateClusterRequestAutoUpgrade] = None,
         feature_gates: Optional[List[str]] = None,
         admission_plugins: Optional[List[str]] = None,
         open_id_connect_config: Optional[
             CreateClusterRequestOpenIDConnectConfig
         ] = None,
         apiserver_cert_sans: Optional[List[str]] = None,
+        private_network_id: Optional[str] = None,
     ) -> Cluster:
         """
-        This method allows to create a new Kubernetes cluster on an account.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param organization_id: The organization ID where the cluster will be created.
+        Create a new Cluster.
+        Create a new Kubernetes cluster in a Scaleway region.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param organization_id: Organization ID in which the cluster will be created.
 
         One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
-        :param project_id: The project ID where the cluster will be created.
+        :param project_id: Project ID in which the cluster will be created.
 
         One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
-        :param type_: The type of the cluster (possible values are kapsule, multicloud).
-        :param name: The name of the cluster
-        :param description: The description of the cluster
-        :param tags: The tags associated with the cluster
-        :param version: The Kubernetes version of the cluster
-        :param cni: The Container Network Interface (CNI) plugin that will run in the cluster
-        :param enable_dashboard: The enablement of the Kubernetes Dashboard in the cluster
-        :param ingress: The Ingress Controller that will run in the cluster
-        :param pools: The pools to be created along with the cluster
-        :param autoscaler_config: This field allows to specify some configuration for the autoscaler, which is an implementation of the [cluster-autoscaler](https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler/).
-        :param auto_upgrade: This configuration enables to set a specific 2-hour time window in which the cluster can be automatically updated to the latest patch version in the current minor one.
-        :param feature_gates: List of feature gates to enable
-        :param admission_plugins: List of admission plugins to enable
-        :param open_id_connect_config: This feature is in ALPHA state, it may be deleted or modified. This configuration enables to set the [OpenID Connect configuration](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens) of the Kubernetes API server.
-        :param apiserver_cert_sans: Additional Subject Alternative Names for the Kubernetes API server certificate
+        :param type_: Type of the cluster (possible values are kapsule, multicloud, kapsule-dedicated-8, kapsule-dedicated-16).
+        :param name: Cluster name.
+        :param description: Cluster description.
+        :param tags: Tags associated with the cluster.
+        :param version: Kubernetes version of the cluster.
+        :param cni: Container Network Interface (CNI) plugin running in the cluster.
+        :param enable_dashboard: Defines whether the Kubernetes Dashboard is enabled in the cluster.
+        :param ingress: Ingress Controller running in the cluster (deprecated feature).
+        :param pools: Pools created along with the cluster.
+        :param autoscaler_config: Autoscaler configuration for the cluster. It allows you to set (to an extent) your preferred autoscaler configuration, which is an implementation of the cluster-autoscaler (https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler/).
+        :param auto_upgrade: Auto upgrade configuration of the cluster. This configuration enables to set a specific 2-hour time window in which the cluster can be automatically updated to the latest patch version.
+        :param feature_gates: List of feature gates to enable.
+        :param admission_plugins: List of admission plugins to enable.
+        :param open_id_connect_config: OpenID Connect configuration of the cluster. This configuration enables to update the OpenID Connect configuration of the Kubernetes API server.
+        :param apiserver_cert_sans: Additional Subject Alternative Names for the Kubernetes API server certificate.
+        :param private_network_id: Private network ID for internal cluster communication (cannot be changed later).
         :return: :class:`Cluster <Cluster>`
 
         Usage:
         ::
 
             result = await api.create_cluster(
                 type_="example",
@@ -271,14 +287,15 @@
                     pools=pools,
                     autoscaler_config=autoscaler_config,
                     auto_upgrade=auto_upgrade,
                     feature_gates=feature_gates,
                     admission_plugins=admission_plugins,
                     open_id_connect_config=open_id_connect_config,
                     apiserver_cert_sans=apiserver_cert_sans,
+                    private_network_id=private_network_id,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_Cluster(res.json())
@@ -286,17 +303,18 @@
     async def get_cluster(
         self,
         *,
         cluster_id: str,
         region: Optional[Region] = None,
     ) -> Cluster:
         """
-        This method allows to get details about a specific Kubernetes cluster.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param cluster_id: The ID of the requested cluster
+        Get a Cluster.
+        Retrieve information about a specific Kubernetes cluster.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cluster_id: ID of the requested cluster.
         :return: :class:`Cluster <Cluster>`
 
         Usage:
         ::
 
             result = await api.get_cluster(cluster_id="example")
         """
@@ -319,16 +337,16 @@
         *,
         cluster_id: str,
         region: Optional[Region] = None,
         options: Optional[WaitForOptions[Cluster, Union[bool, Awaitable[bool]]]] = None,
     ) -> Cluster:
         """
         Waits for :class:`Cluster <Cluster>` to be in a final state.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param cluster_id: The ID of the requested cluster
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cluster_id: ID of the requested cluster.
         :param options: The options for the waiter
         :return: :class:`Cluster <Cluster>`
 
         Usage:
         ::
 
             result = api.wait_for_cluster(cluster_id="example")
@@ -365,28 +383,29 @@
         admission_plugins: Optional[List[str]] = None,
         open_id_connect_config: Optional[
             UpdateClusterRequestOpenIDConnectConfig
         ] = None,
         apiserver_cert_sans: Optional[List[str]] = None,
     ) -> Cluster:
         """
-        This method allows to update a specific Kubernetes cluster. Note that this method is not made to upgrade a Kubernetes cluster.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param cluster_id: The ID of the cluster to update
-        :param name: This field allows to update the external name of the cluster. The internal name (used for instance in hostname) won't change.
-        :param description: The new description of the cluster
-        :param tags: The new tags associated with the cluster
-        :param autoscaler_config: This field allows to update some configuration for the autoscaler, which is an implementation of the [cluster-autoscaler](https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler/).
-        :param enable_dashboard: The new value of the Kubernetes Dashboard enablement
-        :param ingress: The new Ingress Controller for the cluster
-        :param auto_upgrade: The new auto upgrade configuration of the cluster. Note that all fields need to be set.
-        :param feature_gates: List of feature gates to enable
-        :param admission_plugins: List of admission plugins to enable
-        :param open_id_connect_config: This feature is in ALPHA state, it may be deleted or modified. This configuration enables to update the [OpenID Connect configuration](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens) of the Kubernetes API server.
-        :param apiserver_cert_sans: Additional Subject Alternative Names for the Kubernetes API server certificate
+        Update a Cluster.
+        Update information on a specific Kubernetes cluster. You can update details such as its name, description, tags and configuration. To upgrade a cluster, you will need to use the dedicated endpoint.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cluster_id: ID of the cluster to update.
+        :param name: New external name for the cluster.
+        :param description: New description for the cluster.
+        :param tags: New tags associated with the cluster.
+        :param autoscaler_config: New autoscaler config for the cluster.
+        :param enable_dashboard: New value for the Kubernetes Dashboard enablement.
+        :param ingress: New Ingress Controller for the cluster (deprecated feature).
+        :param auto_upgrade: New auto upgrade configuration for the cluster. Note that all fields need to be set.
+        :param feature_gates: List of feature gates to enable.
+        :param admission_plugins: List of admission plugins to enable.
+        :param open_id_connect_config: OpenID Connect configuration of the cluster. This configuration enables to update the OpenID Connect configuration of the Kubernetes API server.
+        :param apiserver_cert_sans: Additional Subject Alternative Names for the Kubernetes API server certificate.
         :return: :class:`Cluster <Cluster>`
 
         Usage:
         ::
 
             result = await api.update_cluster(cluster_id="example")
         """
@@ -426,18 +445,19 @@
         self,
         *,
         cluster_id: str,
         with_additional_resources: bool,
         region: Optional[Region] = None,
     ) -> Cluster:
         """
-        This method allows to delete a specific cluster and all its associated pools and nodes. Note that this method will not delete any Load Balancers or Block Volumes that are associated with the cluster.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param cluster_id: The ID of the cluster to delete
-        :param with_additional_resources: Set true if you want to delete all volumes (including retain volume type) and loadbalancers whose name start with cluster ID
+        Delete a Cluster.
+        Delete a specific Kubernetes cluster and all its associated pools and nodes. Note that this method will not delete any Load Balancer or Block Volume that are associated with the cluster.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cluster_id: ID of the cluster to delete.
+        :param with_additional_resources: Defines whether all volumes (including retain volume type), empty Private Networks and Load Balancers with a name starting with the cluster ID will also be deleted.
         :return: :class:`Cluster <Cluster>`
 
         Usage:
         ::
 
             result = await api.delete_cluster(
                 cluster_id="example",
@@ -466,19 +486,20 @@
         *,
         cluster_id: str,
         version: str,
         upgrade_pools: bool,
         region: Optional[Region] = None,
     ) -> Cluster:
         """
-        This method allows to upgrade a specific Kubernetes cluster and/or its associated pools to a specific and supported Kubernetes version.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param cluster_id: The ID of the cluster to upgrade
-        :param version: The new Kubernetes version of the cluster. Note that the version shoud either be a higher patch version of the same minor version or the direct minor version after the current one.
-        :param upgrade_pools: This field makes the upgrade upgrades the pool once the Kubernetes master in upgrade.
+        Upgrade a Cluster.
+        Upgrade a specific Kubernetes cluster and possibly its associated pools to a specific and supported Kubernetes version.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cluster_id: ID of the cluster to upgrade.
+        :param version: New Kubernetes version of the cluster. Note that the version should either be a higher patch version of the same minor version or the direct minor version after the current one.
+        :param upgrade_pools: Defines whether pools will also be upgraded once the control plane is upgraded.
         :return: :class:`Cluster <Cluster>`
 
         Usage:
         ::
 
             result = await api.upgrade_cluster(
                 cluster_id="example",
@@ -505,24 +526,70 @@
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_Cluster(res.json())
 
+    async def set_cluster_type(
+        self,
+        *,
+        cluster_id: str,
+        type_: str,
+        region: Optional[Region] = None,
+    ) -> Cluster:
+        """
+        Change the Cluster type.
+        Change the type of a specific Kubernetes cluster.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cluster_id: ID of the cluster to migrate from one type to another.
+        :param type_: Type of the cluster. Note that some migrations are not possible (please refer to product documentation).
+        :return: :class:`Cluster <Cluster>`
+
+        Usage:
+        ::
+
+            result = await api.set_cluster_type(
+                cluster_id="example",
+                type_="example",
+            )
+        """
+
+        param_region = validate_path_param(
+            "region", region or self.client.default_region
+        )
+        param_cluster_id = validate_path_param("cluster_id", cluster_id)
+
+        res = self._request(
+            "POST",
+            f"/k8s/v1/regions/{param_region}/clusters/{param_cluster_id}/set-type",
+            body=marshal_SetClusterTypeRequest(
+                SetClusterTypeRequest(
+                    cluster_id=cluster_id,
+                    type_=type_,
+                    region=region,
+                ),
+                self.client,
+            ),
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_Cluster(res.json())
+
     async def list_cluster_available_versions(
         self,
         *,
         cluster_id: str,
         region: Optional[Region] = None,
     ) -> ListClusterAvailableVersionsResponse:
         """
-        This method allows to list the versions that a specific Kubernetes cluster is allowed to upgrade to. Note that it will be every patch version greater than the actual one as well a one minor version ahead of the actual one. Upgrades skipping a minor version will not work.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param cluster_id: The ID of the cluster which the available Kuberentes versions will be listed from
+        List available versions for a Cluster.
+        List the versions that a specific Kubernetes cluster is allowed to upgrade to. Results will include every patch version greater than the current patch, as well as one minor version ahead of the current version. Any upgrade skipping a minor version will not work.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cluster_id: Cluster ID for which the available Kubernetes versions will be listed.
         :return: :class:`ListClusterAvailableVersionsResponse <ListClusterAvailableVersionsResponse>`
 
         Usage:
         ::
 
             result = await api.list_cluster_available_versions(cluster_id="example")
         """
@@ -536,25 +603,58 @@
             "GET",
             f"/k8s/v1/regions/{param_region}/clusters/{param_cluster_id}/available-versions",
         )
 
         self._throw_on_error(res)
         return unmarshal_ListClusterAvailableVersionsResponse(res.json())
 
+    async def list_cluster_available_types(
+        self,
+        *,
+        cluster_id: str,
+        region: Optional[Region] = None,
+    ) -> ListClusterAvailableTypesResponse:
+        """
+        List available cluster types for a cluster.
+        List the cluster types that a specific Kubernetes cluster is allowed to switch to.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cluster_id: Cluster ID for which the available Kubernetes types will be listed.
+        :return: :class:`ListClusterAvailableTypesResponse <ListClusterAvailableTypesResponse>`
+
+        Usage:
+        ::
+
+            result = await api.list_cluster_available_types(cluster_id="example")
+        """
+
+        param_region = validate_path_param(
+            "region", region or self.client.default_region
+        )
+        param_cluster_id = validate_path_param("cluster_id", cluster_id)
+
+        res = self._request(
+            "GET",
+            f"/k8s/v1/regions/{param_region}/clusters/{param_cluster_id}/available-types",
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_ListClusterAvailableTypesResponse(res.json())
+
     async def _get_cluster_kube_config(
         self,
         *,
         cluster_id: str,
         region: Optional[Region] = None,
     ) -> Optional[ScwFile]:
         """
-        This method allows to download the Kubernetes cluster config file (AKA kubeconfig) for a specific cluster in order to use it with, for instance, `kubectl`. Tips: add `?dl=1` at the end of the URL to directly get the base64 decoded kubeconfig. If not, the kubeconfig will be base64 encoded.
-
-        :param region: Region to target. If none is passed will use default region from the config
-        :param cluster_id: The ID of the cluster to download the kubeconfig from
+        Download the kubeconfig for a Cluster.
+        Download the Kubernetes cluster config file (also known as `kubeconfig`) for a specific cluster to use it with `kubectl`.
+        Tip: add `?dl=1` at the end of the URL to directly retrieve the base64 decoded kubeconfig. If you choose not to, the kubeconfig will be base64 encoded.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cluster_id: Cluster ID for which to download the kubeconfig.
         :return: :class:`Optional[ScwFile] <Optional[ScwFile]>`
 
         Usage:
         ::
 
             result = await api._get_cluster_kube_config(cluster_id="example")
         """
@@ -576,17 +676,18 @@
     async def reset_cluster_admin_token(
         self,
         *,
         cluster_id: str,
         region: Optional[Region] = None,
     ) -> Optional[None]:
         """
-        This method allows to reset the admin token for a specific Kubernetes cluster. This will invalidate the old admin token (which will not be usable after) and create a new one. Note that the redownload of the kubeconfig will be necessary to keep interacting with the cluster (if the old admin token was used).
-        :param region: Region to target. If none is passed will use default region from the config
-        :param cluster_id: The ID of the cluster of which the admin token will be renewed
+        Reset the admin token of a Cluster.
+        Reset the admin token for a specific Kubernetes cluster. This will revoke the old admin token (which will not be usable afterwards) and create a new one. Note that you will need to download kubeconfig again to keep interacting with the cluster.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cluster_id: Cluster ID on which the admin token will be renewed.
 
         Usage:
         ::
 
             result = await api.reset_cluster_admin_token(cluster_id="example")
         """
 
@@ -599,34 +700,80 @@
             "POST",
             f"/k8s/v1/regions/{param_region}/clusters/{param_cluster_id}/reset-admin-token",
         )
 
         self._throw_on_error(res)
         return None
 
+    async def migrate_to_private_network_cluster(
+        self,
+        *,
+        cluster_id: str,
+        private_network_id: str,
+        region: Optional[Region] = None,
+    ) -> Cluster:
+        """
+        Migrate an existing cluster to a Private Network cluster.
+        Migrate a cluster that was created before the release of Private Network clusters to a new one with a Private Network.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cluster_id: ID of the cluster to migrate.
+        :param private_network_id: ID of the Private Network to link to the cluster.
+        :return: :class:`Cluster <Cluster>`
+
+        Usage:
+        ::
+
+            result = await api.migrate_to_private_network_cluster(
+                cluster_id="example",
+                private_network_id="example",
+            )
+        """
+
+        param_region = validate_path_param(
+            "region", region or self.client.default_region
+        )
+        param_cluster_id = validate_path_param("cluster_id", cluster_id)
+
+        res = self._request(
+            "POST",
+            f"/k8s/v1/regions/{param_region}/clusters/{param_cluster_id}/migrate-to-private-network",
+            body=marshal_MigrateToPrivateNetworkClusterRequest(
+                MigrateToPrivateNetworkClusterRequest(
+                    cluster_id=cluster_id,
+                    private_network_id=private_network_id,
+                    region=region,
+                ),
+                self.client,
+            ),
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_Cluster(res.json())
+
     async def list_pools(
         self,
         *,
         cluster_id: str,
         region: Optional[Region] = None,
         order_by: ListPoolsRequestOrderBy = ListPoolsRequestOrderBy.CREATED_AT_ASC,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         name: Optional[str] = None,
         status: PoolStatus = PoolStatus.UNKNOWN,
     ) -> ListPoolsResponse:
         """
-        This method allows to list all the existing pools for a specific Kubernetes cluster.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param cluster_id: The ID of the cluster from which the pools will be listed from
-        :param order_by: The sort order of the returned pools
-        :param page: The page number for the returned pools
-        :param page_size: The maximum number of pools per page
-        :param name: The name on which to filter the returned pools
-        :param status: The status on which to filter the returned pools
+        List Pools in a Cluster.
+        List all the existing pools for a specific Kubernetes cluster.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cluster_id: ID of the cluster whose pools will be listed.
+        :param order_by: Sort order of returned pools.
+        :param page: Page number for the returned pools.
+        :param page_size: Maximum number of pools per page.
+        :param name: Name to filter on, only pools containing this substring in their name will be returned.
+        :param status: Status to filter on, only pools with this status will be returned.
         :return: :class:`ListPoolsResponse <ListPoolsResponse>`
 
         Usage:
         ::
 
             result = await api.list_pools(cluster_id="example")
         """
@@ -659,22 +806,23 @@
         order_by: Optional[ListPoolsRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         name: Optional[str] = None,
         status: Optional[PoolStatus] = None,
     ) -> List[Pool]:
         """
-        This method allows to list all the existing pools for a specific Kubernetes cluster.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param cluster_id: The ID of the cluster from which the pools will be listed from
-        :param order_by: The sort order of the returned pools
-        :param page: The page number for the returned pools
-        :param page_size: The maximum number of pools per page
-        :param name: The name on which to filter the returned pools
-        :param status: The status on which to filter the returned pools
+        List Pools in a Cluster.
+        List all the existing pools for a specific Kubernetes cluster.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cluster_id: ID of the cluster whose pools will be listed.
+        :param order_by: Sort order of returned pools.
+        :param page: Page number for the returned pools.
+        :param page_size: Maximum number of pools per page.
+        :param name: Name to filter on, only pools containing this substring in their name will be returned.
+        :param status: Status to filter on, only pools with this status will be returned.
         :return: :class:`List[ListPoolsResponse] <List[ListPoolsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_pools_all(cluster_id="example")
         """
@@ -712,38 +860,33 @@
         tags: Optional[List[str]] = None,
         kubelet_args: Optional[Dict[str, str]] = None,
         upgrade_policy: Optional[CreatePoolRequestUpgradePolicy] = None,
         zone: Optional[Zone] = None,
         root_volume_size: Optional[int] = None,
     ) -> Pool:
         """
-        This method allows to create a new pool in a specific Kubernetes cluster.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param cluster_id: The ID of the cluster in which the pool will be created
-        :param name: The name of the pool
-        :param node_type: The node type is the type of Scaleway Instance wanted for the pool. Nodes with insufficient memory are not eligible (DEV1-S, PLAY2-PICO, STARDUST). 'external' is a special node type used to provision instances from other cloud providers.
-        :param placement_group_id: The placement group ID in which all the nodes of the pool will be created
-        :param autoscaling: The enablement of the autoscaling feature for the pool
-        :param size: The size (number of nodes) of the pool
-        :param min_size: The minimum size of the pool. Note that this field will be used only when autoscaling is enabled.
-        :param max_size: The maximum size of the pool. Note that this field will be used only when autoscaling is enabled.
-        :param container_runtime: The customization of the container runtime is available for each pool. Note that `docker` is deprecated since 1.20 and will be removed in 1.24.
-
-        :param autohealing: The enablement of the autohealing feature for the pool
-        :param tags: The tags associated with the pool
-        :param kubelet_args: The Kubelet arguments to be used by this pool. Note that this feature is to be considered as experimental
-        :param upgrade_policy: The Pool upgrade policy
-        :param zone: The Zone in which the Pool's node will be spawn in
-        :param root_volume_type: The system volume disk type, we provide two different types of volume (`volume_type`):
-          - `l_ssd` is a local block storage: your system is stored locally on
-            the hypervisor of your node.
-          - `b_ssd` is a remote block storage: your system is stored on a
-            centralised and resilient cluster.
-
-        :param root_volume_size: The system volume disk size
+        Create a new Pool in a Cluster.
+        Create a new pool in a specific Kubernetes cluster.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cluster_id: Cluster ID to which the pool will be attached.
+        :param name: Pool name.
+        :param node_type: Node type is the type of Scaleway Instance wanted for the pool. Nodes with insufficient memory are not eligible (DEV1-S, PLAY2-PICO, STARDUST). 'external' is a special node type used to provision instances from other cloud providers in a Kosmos Cluster.
+        :param placement_group_id: Placement group ID in which all the nodes of the pool will be created.
+        :param autoscaling: Defines whether the autoscaling feature is enabled for the pool.
+        :param size: Size (number of nodes) of the pool.
+        :param min_size: Defines the minimum size of the pool. Note that this field is only used when autoscaling is enabled on the pool.
+        :param max_size: Defines the maximum size of the pool. Note that this field is only used when autoscaling is enabled on the pool.
+        :param container_runtime: Customization of the container runtime is available for each pool. Note that `docker` has been deprecated since version 1.20 and will be removed by version 1.24.
+        :param autohealing: Defines whether the autohealing feature is enabled for the pool.
+        :param tags: Tags associated with the pool.
+        :param kubelet_args: Kubelet arguments to be used by this pool. Note that this feature is experimental.
+        :param upgrade_policy: Pool upgrade policy.
+        :param zone: Zone in which the pool's nodes will be spawned.
+        :param root_volume_type: Defines the system volume disk type. Two different types of volume (`volume_type`) are provided: `l_ssd` is a local block storage which means your system is stored locally on your node's hypervisor. `b_ssd` is a remote block storage which means your system is stored on a centralized and resilient cluster.
+        :param root_volume_size: System volume disk size.
         :return: :class:`Pool <Pool>`
 
         Usage:
         ::
 
             result = await api.create_pool(
                 cluster_id="example",
@@ -794,17 +937,18 @@
     async def get_pool(
         self,
         *,
         pool_id: str,
         region: Optional[Region] = None,
     ) -> Pool:
         """
-        This method allows to get details about a specific pool.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param pool_id: The ID of the requested pool
+        Get a Pool in a Cluster.
+        Retrieve details about a specific pool in a Kubernetes cluster.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param pool_id: ID of the requested pool.
         :return: :class:`Pool <Pool>`
 
         Usage:
         ::
 
             result = await api.get_pool(pool_id="example")
         """
@@ -827,16 +971,16 @@
         *,
         pool_id: str,
         region: Optional[Region] = None,
         options: Optional[WaitForOptions[Pool, Union[bool, Awaitable[bool]]]] = None,
     ) -> Pool:
         """
         Waits for :class:`Pool <Pool>` to be in a final state.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param pool_id: The ID of the requested pool
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param pool_id: ID of the requested pool.
         :param options: The options for the waiter
         :return: :class:`Pool <Pool>`
 
         Usage:
         ::
 
             result = api.wait_for_pool(pool_id="example")
@@ -861,18 +1005,19 @@
         self,
         *,
         pool_id: str,
         version: str,
         region: Optional[Region] = None,
     ) -> Pool:
         """
-        This method allows to upgrade the Kubernetes version of a specific pool. Note that this will work when the targeted version is the same than the version of the cluster.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param pool_id: The ID of the pool to upgrade
-        :param version: The new Kubernetes version for the pool
+        Upgrade a Pool in a Cluster.
+        Upgrade the Kubernetes version of a specific pool. Note that it only works if the targeted version matches the cluster's version.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param pool_id: ID of the pool to upgrade.
+        :param version: New Kubernetes version for the pool.
         :return: :class:`Pool <Pool>`
 
         Usage:
         ::
 
             result = await api.upgrade_pool(
                 pool_id="example",
@@ -912,25 +1057,26 @@
         max_size: Optional[int] = None,
         autohealing: Optional[bool] = None,
         tags: Optional[List[str]] = None,
         kubelet_args: Optional[Dict[str, str]] = None,
         upgrade_policy: Optional[UpdatePoolRequestUpgradePolicy] = None,
     ) -> Pool:
         """
-        This method allows to update some attributes of a specific pool such as the size, the autoscaling enablement, the tags, ...
-        :param region: Region to target. If none is passed will use default region from the config
-        :param pool_id: The ID of the pool to update
-        :param autoscaling: The new value for the enablement of autoscaling for the pool
-        :param size: The new size for the pool
-        :param min_size: The new minimun size for the pool
-        :param max_size: The new maximum size for the pool
-        :param autohealing: The new value for the enablement of autohealing for the pool
-        :param tags: The new tags associated with the pool
-        :param kubelet_args: The new Kubelet arguments to be used by this pool. Note that this feature is to be considered as experimental
-        :param upgrade_policy: The Pool upgrade policy
+        Update a Pool in a Cluster.
+        Update the attributes of a specific pool, such as its desired size, autoscaling settings, and tags.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param pool_id: ID of the pool to update.
+        :param autoscaling: New value for the pool autoscaling enablement.
+        :param size: New desired pool size.
+        :param min_size: New minimum size for the pool.
+        :param max_size: New maximum size for the pool.
+        :param autohealing: New value for the pool autohealing enablement.
+        :param tags: New tags associated with the pool.
+        :param kubelet_args: New Kubelet arguments to be used by this pool. Note that this feature is experimental.
+        :param upgrade_policy: New upgrade policy for the pool.
         :return: :class:`Pool <Pool>`
 
         Usage:
         ::
 
             result = await api.update_pool(pool_id="example")
         """
@@ -966,17 +1112,18 @@
     async def delete_pool(
         self,
         *,
         pool_id: str,
         region: Optional[Region] = None,
     ) -> Pool:
         """
-        This method allows to delete a specific pool from a cluster, deleting all the nodes associated with it.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param pool_id: The ID of the pool to delete
+        Delete a Pool in a Cluster.
+        Delete a specific pool from a cluster. Note that all the pool's nodes will also be deleted.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param pool_id: ID of the pool to delete.
         :return: :class:`Pool <Pool>`
 
         Usage:
         ::
 
             result = await api.delete_pool(pool_id="example")
         """
@@ -997,16 +1144,17 @@
     async def create_external_node(
         self,
         *,
         pool_id: str,
         region: Optional[Region] = None,
     ) -> ExternalNode:
         """
-        This method returns metadata about a Kosmos node, it is not intended to be directly called by end users, rather by kapsule-node-agent.
-        :param region: Region to target. If none is passed will use default region from the config
+        Create a Kosmos node.
+        Retrieve metadata for a Kosmos node. This method is not intended to be called by end users but rather programmatically by the kapsule-node-agent.
+        :param region: Region to target. If none is passed will use default region from the config.
         :param pool_id:
         :return: :class:`ExternalNode <ExternalNode>`
 
         Usage:
         ::
 
             result = await api.create_external_node(pool_id="example")
@@ -1034,23 +1182,24 @@
         order_by: ListNodesRequestOrderBy = ListNodesRequestOrderBy.CREATED_AT_ASC,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         name: Optional[str] = None,
         status: NodeStatus = NodeStatus.UNKNOWN,
     ) -> ListNodesResponse:
         """
-        This method allows to list all the existing nodes for a specific Kubernetes cluster.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param cluster_id: The cluster ID from which the nodes will be listed from
-        :param pool_id: The pool ID on which to filter the returned nodes
-        :param order_by: The sort order of the returned nodes
-        :param page: The page number for the returned nodes
-        :param page_size: The maximum number of nodes per page
-        :param name: The name on which to filter the returned nodes
-        :param status: The status on which to filter the returned nodes
+        List Nodes in a Cluster.
+        List all the existing nodes for a specific Kubernetes cluster.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cluster_id: Cluster ID from which the nodes will be listed from.
+        :param pool_id: Pool ID on which to filter the returned nodes.
+        :param order_by: Sort order of the returned nodes.
+        :param page: Page number for the returned nodes.
+        :param page_size: Maximum number of nodes per page.
+        :param name: Name to filter on, only nodes containing this substring in their name will be returned.
+        :param status: Status to filter on, only nodes with this status will be returned.
         :return: :class:`ListNodesResponse <ListNodesResponse>`
 
         Usage:
         ::
 
             result = await api.list_nodes(cluster_id="example")
         """
@@ -1085,23 +1234,24 @@
         order_by: Optional[ListNodesRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         name: Optional[str] = None,
         status: Optional[NodeStatus] = None,
     ) -> List[Node]:
         """
-        This method allows to list all the existing nodes for a specific Kubernetes cluster.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param cluster_id: The cluster ID from which the nodes will be listed from
-        :param pool_id: The pool ID on which to filter the returned nodes
-        :param order_by: The sort order of the returned nodes
-        :param page: The page number for the returned nodes
-        :param page_size: The maximum number of nodes per page
-        :param name: The name on which to filter the returned nodes
-        :param status: The status on which to filter the returned nodes
+        List Nodes in a Cluster.
+        List all the existing nodes for a specific Kubernetes cluster.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param cluster_id: Cluster ID from which the nodes will be listed from.
+        :param pool_id: Pool ID on which to filter the returned nodes.
+        :param order_by: Sort order of the returned nodes.
+        :param page: Page number for the returned nodes.
+        :param page_size: Maximum number of nodes per page.
+        :param name: Name to filter on, only nodes containing this substring in their name will be returned.
+        :param status: Status to filter on, only nodes with this status will be returned.
         :return: :class:`List[ListNodesResponse] <List[ListNodesResponse]>`
 
         Usage:
         ::
 
             result = await api.list_nodes_all(cluster_id="example")
         """
@@ -1125,17 +1275,18 @@
     async def get_node(
         self,
         *,
         node_id: str,
         region: Optional[Region] = None,
     ) -> Node:
         """
-        This method allows to get details about a specific Kubernetes node.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param node_id: The ID of the requested node
+        Get a Node in a Cluster.
+        Retrieve details about a specific Kubernetes Node.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param node_id: ID of the requested node.
         :return: :class:`Node <Node>`
 
         Usage:
         ::
 
             result = await api.get_node(node_id="example")
         """
@@ -1158,16 +1309,16 @@
         *,
         node_id: str,
         region: Optional[Region] = None,
         options: Optional[WaitForOptions[Node, Union[bool, Awaitable[bool]]]] = None,
     ) -> Node:
         """
         Waits for :class:`Node <Node>` to be in a final state.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param node_id: The ID of the requested node
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param node_id: ID of the requested node.
         :param options: The options for the waiter
         :return: :class:`Node <Node>`
 
         Usage:
         ::
 
             result = api.wait_for_node(node_id="example")
@@ -1191,17 +1342,18 @@
     async def replace_node(
         self,
         *,
         node_id: str,
         region: Optional[Region] = None,
     ) -> Node:
         """
-        This method allows to replace a specific node. The node will be set cordoned, meaning that scheduling will be disabled. Then the existing pods on the node will be drained and reschedule onto another schedulable node. Then the node will be deleted, and a new one will be created after the deletion. Note that when there is not enough space to reschedule all the pods (in a one node cluster for instance), you may experience some disruption of your applications.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param node_id: The ID of the node to replace
+        Replace a Node in a Cluster.
+        Replace a specific Node. The node will first be cordoned (scheduling will be disabled on it). The existing pods on the node will then be drained and rescheduled onto another schedulable node. Note that when there is not enough space to reschedule all the pods (such as in a one-node cluster), disruption of your applications can be expected.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param node_id: ID of the node to replace.
         :return: :class:`Node <Node>`
         :deprecated
 
         Usage:
         ::
 
             result = await api.replace_node(node_id="example")
@@ -1223,17 +1375,18 @@
     async def reboot_node(
         self,
         *,
         node_id: str,
         region: Optional[Region] = None,
     ) -> Node:
         """
-        This method allows to reboot a specific node. This node will frist be cordoned, meaning that scheduling will be disabled. Then the existing pods on the node will be drained and reschedule onto another schedulable node. Note that when there is not enough space to reschedule all the pods (in a one node cluster for instance), you may experience some disruption of your applications.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param node_id: The ID of the node to reboot
+        Reboot a Node in a Cluster.
+        Reboot a specific Node. The node will first be cordoned (scheduling will be disabled on it). The existing pods on the node will then be drained and rescheduled onto another schedulable node. Note that when there is not enough space to reschedule all the pods (such as in a one-node cluster), disruption of your applications can be expected.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param node_id: ID of the node to reboot.
         :return: :class:`Node <Node>`
 
         Usage:
         ::
 
             result = await api.reboot_node(node_id="example")
         """
@@ -1256,19 +1409,20 @@
         *,
         node_id: str,
         skip_drain: bool,
         replace: bool,
         region: Optional[Region] = None,
     ) -> Node:
         """
-        This method allows to delete a specific node. Note that when there is not enough space to reschedule all the pods (in a one node cluster for instance), you may experience some disruption of your applications.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param node_id: The ID of the node to replace
-        :param skip_drain: Skip draining node from its workload
-        :param replace: Add a new node after the deletion of this node
+        Delete a Node in a Cluster.
+        Delete a specific Node. Note that when there is not enough space to reschedule all the pods (such as in a one-node cluster), disruption of your applications can be expected.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param node_id: ID of the node to replace.
+        :param skip_drain: Skip draining node from its workload.
+        :param replace: Add a new node after the deletion of this node.
         :return: :class:`Node <Node>`
 
         Usage:
         ::
 
             result = await api.delete_node(
                 node_id="example",
@@ -1296,16 +1450,17 @@
 
     async def list_versions(
         self,
         *,
         region: Optional[Region] = None,
     ) -> ListVersionsResponse:
         """
-        This method allows to list all available versions for the creation of a new Kubernetes cluster.
-        :param region: Region to target. If none is passed will use default region from the config
+        List all available Versions.
+        List all available versions for the creation of a new Kubernetes cluster.
+        :param region: Region to target. If none is passed will use default region from the config.
         :return: :class:`ListVersionsResponse <ListVersionsResponse>`
 
         Usage:
         ::
 
             result = await api.list_versions()
         """
@@ -1325,17 +1480,18 @@
     async def get_version(
         self,
         *,
         version_name: str,
         region: Optional[Region] = None,
     ) -> Version:
         """
-        This method allows to get a specific Kubernetes version and the details about the version.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param version_name: The requested version name
+        Get a Version.
+        Retrieve a specific Kubernetes version and its details.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param version_name: Requested version name.
         :return: :class:`Version <Version>`
 
         Usage:
         ::
 
             result = await api.get_version(version_name="example")
         """
@@ -1348,7 +1504,76 @@
         res = self._request(
             "GET",
             f"/k8s/v1/regions/{param_region}/versions/{param_version_name}",
         )
 
         self._throw_on_error(res)
         return unmarshal_Version(res.json())
+
+    async def list_cluster_types(
+        self,
+        *,
+        region: Optional[Region] = None,
+        page: Optional[int] = None,
+        page_size: Optional[int] = None,
+    ) -> ListClusterTypesResponse:
+        """
+        List cluster types.
+        List available cluster types and their technical details.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number, from the paginated results, to return for cluster-types.
+        :param page_size: Maximum number of clusters per page.
+        :return: :class:`ListClusterTypesResponse <ListClusterTypesResponse>`
+
+        Usage:
+        ::
+
+            result = await api.list_cluster_types()
+        """
+
+        param_region = validate_path_param(
+            "region", region or self.client.default_region
+        )
+
+        res = self._request(
+            "GET",
+            f"/k8s/v1/regions/{param_region}/cluster-types",
+            params={
+                "page": page,
+                "page_size": page_size or self.client.default_page_size,
+            },
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_ListClusterTypesResponse(res.json())
+
+    async def list_cluster_types_all(
+        self,
+        *,
+        region: Optional[Region] = None,
+        page: Optional[int] = None,
+        page_size: Optional[int] = None,
+    ) -> List[ClusterType]:
+        """
+        List cluster types.
+        List available cluster types and their technical details.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: Page number, from the paginated results, to return for cluster-types.
+        :param page_size: Maximum number of clusters per page.
+        :return: :class:`List[ListClusterTypesResponse] <List[ListClusterTypesResponse]>`
+
+        Usage:
+        ::
+
+            result = await api.list_cluster_types_all()
+        """
+
+        return await fetch_all_pages_async(
+            type=ListClusterTypesResponse,
+            key="cluster_types",
+            fetcher=self.list_cluster_types,
+            args={
+                "region": region,
+                "page": page,
+                "page_size": page_size,
+            },
+        )
```

### Comparing `scaleway_async-0.9.0/scaleway_async/k8s/v1/content.py` & `scaleway_async-1.0.0/scaleway_async/k8s/v1/content.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-0.9.0/scaleway_async/k8s/v1/marshalling.py` & `scaleway_async-1.0.0/scaleway_async/vpcgw/v1/marshalling.py`

 * *Files 24% similar despite different names*

```diff
@@ -6,850 +6,925 @@
 from scaleway_core.profile import ProfileDefaults
 from scaleway_core.utils import (
     OneOfPossibility,
     resolve_one_of,
 )
 from dateutil import parser
 from .types import (
-    AutoscalerEstimator,
-    AutoscalerExpander,
-    CNI,
-    Ingress,
-    MaintenanceWindowDayOfTheWeek,
-    PoolVolumeType,
-    Runtime,
-    Cluster,
-    ClusterAutoUpgrade,
-    ClusterAutoscalerConfig,
-    ClusterOpenIDConnectConfig,
-    CreateClusterRequestAutoUpgrade,
-    CreateClusterRequestAutoscalerConfig,
-    CreateClusterRequestOpenIDConnectConfig,
-    CreateClusterRequestPoolConfig,
-    CreateClusterRequestPoolConfigUpgradePolicy,
-    CreatePoolRequestUpgradePolicy,
-    ExternalNode,
-    ListClusterAvailableVersionsResponse,
-    ListClustersResponse,
-    ListNodesResponse,
-    ListPoolsResponse,
-    ListVersionsResponse,
-    MaintenanceWindow,
-    Node,
-    Pool,
-    PoolUpgradePolicy,
-    UpdateClusterRequestAutoUpgrade,
-    UpdateClusterRequestAutoscalerConfig,
-    UpdateClusterRequestOpenIDConnectConfig,
-    UpdatePoolRequestUpgradePolicy,
-    Version,
-    CreateClusterRequest,
-    UpdateClusterRequest,
-    UpgradeClusterRequest,
-    CreatePoolRequest,
-    UpgradePoolRequest,
-    UpdatePoolRequest,
+    PATRuleProtocol,
+    DHCP,
+    DHCPEntry,
+    Gateway,
+    GatewayNetwork,
+    GatewayType,
+    IP,
+    ListDHCPEntriesResponse,
+    ListDHCPsResponse,
+    ListGatewayNetworksResponse,
+    ListGatewayTypesResponse,
+    ListGatewaysResponse,
+    ListIPsResponse,
+    ListPATRulesResponse,
+    PATRule,
+    SetDHCPEntriesRequestEntry,
+    SetDHCPEntriesResponse,
+    SetPATRulesRequestRule,
+    SetPATRulesResponse,
+    CreateGatewayRequest,
+    UpdateGatewayRequest,
+    CreateGatewayNetworkRequest,
+    UpdateGatewayNetworkRequest,
+    CreateDHCPRequest,
+    UpdateDHCPRequest,
+    CreateDHCPEntryRequest,
+    UpdateDHCPEntryRequest,
+    SetDHCPEntriesRequest,
+    CreatePATRuleRequest,
+    UpdatePATRuleRequest,
+    SetPATRulesRequest,
+    CreateIPRequest,
+    UpdateIPRequest,
 )
 
 
-def unmarshal_MaintenanceWindow(data: Any) -> MaintenanceWindow:
+def unmarshal_DHCP(data: Any) -> DHCP:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'MaintenanceWindow' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'DHCP' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("day")
-    args["day"] = field
+    field = data.get("address", None)
+    args["address"] = field
 
-    field = data.get("start_hour")
-    args["start_hour"] = field
-
-    return MaintenanceWindow(**args)
-
-
-def unmarshal_ClusterAutoUpgrade(data: Any) -> ClusterAutoUpgrade:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ClusterAutoUpgrade' failed as data isn't a dictionary."
-        )
+    field = data.get("created_at", None)
+    args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    args: Dict[str, Any] = {}
+    field = data.get("dns_local_name", None)
+    args["dns_local_name"] = field
 
-    field = data.get("enabled")
-    args["enabled"] = field
+    field = data.get("dns_search", None)
+    args["dns_search"] = field
 
-    field = data.get("maintenance_window")
-    args["maintenance_window"] = (
-        unmarshal_MaintenanceWindow(field) if field is not None else None
-    )
+    field = data.get("dns_servers_override", None)
+    args["dns_servers_override"] = field
 
-    return ClusterAutoUpgrade(**args)
+    field = data.get("enable_dynamic", None)
+    args["enable_dynamic"] = field
 
+    field = data.get("id", None)
+    args["id"] = field
 
-def unmarshal_ClusterAutoscalerConfig(data: Any) -> ClusterAutoscalerConfig:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ClusterAutoscalerConfig' failed as data isn't a dictionary."
-        )
+    field = data.get("organization_id", None)
+    args["organization_id"] = field
 
-    args: Dict[str, Any] = {}
+    field = data.get("pool_high", None)
+    args["pool_high"] = field
 
-    field = data.get("balance_similar_node_groups")
-    args["balance_similar_node_groups"] = field
+    field = data.get("pool_low", None)
+    args["pool_low"] = field
 
-    field = data.get("estimator")
-    args["estimator"] = field
+    field = data.get("project_id", None)
+    args["project_id"] = field
 
-    field = data.get("expander")
-    args["expander"] = field
+    field = data.get("push_default_route", None)
+    args["push_default_route"] = field
 
-    field = data.get("expendable_pods_priority_cutoff")
-    args["expendable_pods_priority_cutoff"] = field
+    field = data.get("push_dns_server", None)
+    args["push_dns_server"] = field
 
-    field = data.get("ignore_daemonsets_utilization")
-    args["ignore_daemonsets_utilization"] = field
+    field = data.get("rebind_timer", None)
+    args["rebind_timer"] = field
 
-    field = data.get("max_graceful_termination_sec")
-    args["max_graceful_termination_sec"] = field
+    field = data.get("renew_timer", None)
+    args["renew_timer"] = field
 
-    field = data.get("scale_down_delay_after_add")
-    args["scale_down_delay_after_add"] = field
+    field = data.get("subnet", None)
+    args["subnet"] = field
 
-    field = data.get("scale_down_disabled")
-    args["scale_down_disabled"] = field
+    field = data.get("updated_at", None)
+    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("scale_down_unneeded_time")
-    args["scale_down_unneeded_time"] = field
+    field = data.get("valid_lifetime", None)
+    args["valid_lifetime"] = field
 
-    field = data.get("scale_down_utilization_threshold")
-    args["scale_down_utilization_threshold"] = field
+    field = data.get("zone", None)
+    args["zone"] = field
 
-    return ClusterAutoscalerConfig(**args)
+    return DHCP(**args)
 
 
-def unmarshal_ClusterOpenIDConnectConfig(data: Any) -> ClusterOpenIDConnectConfig:
+def unmarshal_GatewayNetwork(data: Any) -> GatewayNetwork:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ClusterOpenIDConnectConfig' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'GatewayNetwork' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("client_id")
-    args["client_id"] = field
+    field = data.get("address", None)
+    args["address"] = field
 
-    field = data.get("groups_claim")
-    args["groups_claim"] = field
-
-    field = data.get("groups_prefix")
-    args["groups_prefix"] = field
+    field = data.get("created_at", None)
+    args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("issuer_url")
-    args["issuer_url"] = field
+    field = data.get("dhcp", None)
+    args["dhcp"] = unmarshal_DHCP(field) if field is not None else None
 
-    field = data.get("required_claim")
-    args["required_claim"] = field
+    field = data.get("enable_dhcp", None)
+    args["enable_dhcp"] = field
 
-    field = data.get("username_claim")
-    args["username_claim"] = field
+    field = data.get("enable_masquerade", None)
+    args["enable_masquerade"] = field
 
-    field = data.get("username_prefix")
-    args["username_prefix"] = field
+    field = data.get("gateway_id", None)
+    args["gateway_id"] = field
 
-    return ClusterOpenIDConnectConfig(**args)
+    field = data.get("id", None)
+    args["id"] = field
 
+    field = data.get("mac_address", None)
+    args["mac_address"] = field
 
-def unmarshal_PoolUpgradePolicy(data: Any) -> PoolUpgradePolicy:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'PoolUpgradePolicy' failed as data isn't a dictionary."
-        )
+    field = data.get("private_network_id", None)
+    args["private_network_id"] = field
 
-    args: Dict[str, Any] = {}
+    field = data.get("status", None)
+    args["status"] = field
 
-    field = data.get("max_surge")
-    args["max_surge"] = field
+    field = data.get("updated_at", None)
+    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("max_unavailable")
-    args["max_unavailable"] = field
+    field = data.get("zone", None)
+    args["zone"] = field
 
-    return PoolUpgradePolicy(**args)
+    return GatewayNetwork(**args)
 
 
-def unmarshal_Cluster(data: Any) -> Cluster:
+def unmarshal_GatewayType(data: Any) -> GatewayType:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Cluster' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'GatewayType' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("admission_plugins")
-    args["admission_plugins"] = field
+    field = data.get("bandwidth", None)
+    args["bandwidth"] = field
 
-    field = data.get("apiserver_cert_sans")
-    args["apiserver_cert_sans"] = field
-
-    field = data.get("auto_upgrade")
-    args["auto_upgrade"] = (
-        unmarshal_ClusterAutoUpgrade(field) if field is not None else None
-    )
+    field = data.get("name", None)
+    args["name"] = field
 
-    field = data.get("autoscaler_config")
-    args["autoscaler_config"] = (
-        unmarshal_ClusterAutoscalerConfig(field) if field is not None else None
-    )
+    field = data.get("zone", None)
+    args["zone"] = field
 
-    field = data.get("cluster_url")
-    args["cluster_url"] = field
+    return GatewayType(**args)
 
-    field = data.get("cni")
-    args["cni"] = field
 
-    field = data.get("created_at")
-    args["created_at"] = parser.isoparse(field) if type(field) is str else field
+def unmarshal_IP(data: Any) -> IP:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'IP' failed as data isn't a dictionary."
+        )
 
-    field = data.get("dashboard_enabled")
-    args["dashboard_enabled"] = field
+    args: Dict[str, Any] = {}
 
-    field = data.get("description")
-    args["description"] = field
+    field = data.get("address", None)
+    args["address"] = field
 
-    field = data.get("dns_wildcard")
-    args["dns_wildcard"] = field
+    field = data.get("created_at", None)
+    args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("feature_gates")
-    args["feature_gates"] = field
+    field = data.get("gateway_id", None)
+    args["gateway_id"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("ingress")
-    args["ingress"] = field
-
-    field = data.get("name")
-    args["name"] = field
-
-    field = data.get("open_id_connect_config")
-    args["open_id_connect_config"] = (
-        unmarshal_ClusterOpenIDConnectConfig(field) if field is not None else None
-    )
-
-    field = data.get("organization_id")
+    field = data.get("organization_id", None)
     args["organization_id"] = field
 
-    field = data.get("project_id")
+    field = data.get("project_id", None)
     args["project_id"] = field
 
-    field = data.get("region")
-    args["region"] = field
-
-    field = data.get("status")
-    args["status"] = field
+    field = data.get("reverse", None)
+    args["reverse"] = field
 
-    field = data.get("tags")
+    field = data.get("tags", None)
     args["tags"] = field
 
-    field = data.get("type_")
-    args["type_"] = field
-
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("upgrade_available")
-    args["upgrade_available"] = field
-
-    field = data.get("version")
-    args["version"] = field
+    field = data.get("zone", None)
+    args["zone"] = field
 
-    return Cluster(**args)
+    return IP(**args)
 
 
-def unmarshal_Node(data: Any) -> Node:
+def unmarshal_DHCPEntry(data: Any) -> DHCPEntry:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Node' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'DHCPEntry' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("cluster_id")
-    args["cluster_id"] = field
-
-    field = data.get("conditions")
-    args["conditions"] = field
-
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("error_message")
-    args["error_message"] = field
+    field = data.get("gateway_network_id", None)
+    args["gateway_network_id"] = field
 
-    field = data.get("id")
-    args["id"] = field
+    field = data.get("hostname", None)
+    args["hostname"] = field
 
-    field = data.get("name")
-    args["name"] = field
-
-    field = data.get("pool_id")
-    args["pool_id"] = field
-
-    field = data.get("provider_id")
-    args["provider_id"] = field
-
-    field = data.get("public_ip_v4")
-    args["public_ip_v4"] = field
+    field = data.get("id", None)
+    args["id"] = field
 
-    field = data.get("public_ip_v6")
-    args["public_ip_v6"] = field
+    field = data.get("ip_address", None)
+    args["ip_address"] = field
 
-    field = data.get("region")
-    args["region"] = field
+    field = data.get("mac_address", None)
+    args["mac_address"] = field
 
-    field = data.get("status")
-    args["status"] = field
+    field = data.get("type", None)
+    args["type_"] = field
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    return Node(**args)
+    field = data.get("zone", None)
+    args["zone"] = field
+
+    return DHCPEntry(**args)
 
 
-def unmarshal_Pool(data: Any) -> Pool:
+def unmarshal_Gateway(data: Any) -> Gateway:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Pool' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Gateway' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("autohealing")
-    args["autohealing"] = field
+    field = data.get("bastion_enabled", None)
+    args["bastion_enabled"] = field
 
-    field = data.get("autoscaling")
-    args["autoscaling"] = field
+    field = data.get("bastion_port", None)
+    args["bastion_port"] = field
 
-    field = data.get("cluster_id")
-    args["cluster_id"] = field
+    field = data.get("can_upgrade_to", None)
+    args["can_upgrade_to"] = field
 
-    field = data.get("container_runtime")
-    args["container_runtime"] = field
-
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("id")
-    args["id"] = field
-
-    field = data.get("kubelet_args")
-    args["kubelet_args"] = field
+    field = data.get("gateway_networks", None)
+    args["gateway_networks"] = (
+        [unmarshal_GatewayNetwork(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("max_size")
-    args["max_size"] = field
+    field = data.get("id", None)
+    args["id"] = field
 
-    field = data.get("min_size")
-    args["min_size"] = field
+    field = data.get("ip", None)
+    args["ip"] = unmarshal_IP(field) if field is not None else None
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("node_type")
-    args["node_type"] = field
-
-    field = data.get("placement_group_id")
-    args["placement_group_id"] = field
-
-    field = data.get("region")
-    args["region"] = field
-
-    field = data.get("root_volume_size")
-    args["root_volume_size"] = field
+    field = data.get("organization_id", None)
+    args["organization_id"] = field
 
-    field = data.get("root_volume_type")
-    args["root_volume_type"] = field
+    field = data.get("project_id", None)
+    args["project_id"] = field
 
-    field = data.get("size")
-    args["size"] = field
+    field = data.get("smtp_enabled", None)
+    args["smtp_enabled"] = field
 
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("tags")
+    field = data.get("tags", None)
     args["tags"] = field
 
-    field = data.get("updated_at")
+    field = data.get("type", None)
+    args["type_"] = unmarshal_GatewayType(field) if field is not None else None
+
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("upgrade_policy")
-    args["upgrade_policy"] = (
-        unmarshal_PoolUpgradePolicy(field) if field is not None else None
-    )
+    field = data.get("upstream_dns_servers", None)
+    args["upstream_dns_servers"] = field
 
-    field = data.get("version")
+    field = data.get("version", None)
     args["version"] = field
 
-    field = data.get("zone")
+    field = data.get("zone", None)
     args["zone"] = field
 
-    return Pool(**args)
+    return Gateway(**args)
 
 
-def unmarshal_Version(data: Any) -> Version:
+def unmarshal_PATRule(data: Any) -> PATRule:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Version' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'PATRule' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("available_admission_plugins")
-    args["available_admission_plugins"] = field
+    field = data.get("created_at", None)
+    args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("available_cnis")
-    args["available_cnis"] = field
+    field = data.get("gateway_id", None)
+    args["gateway_id"] = field
 
-    field = data.get("available_container_runtimes")
-    args["available_container_runtimes"] = field
+    field = data.get("id", None)
+    args["id"] = field
 
-    field = data.get("available_feature_gates")
-    args["available_feature_gates"] = field
+    field = data.get("private_ip", None)
+    args["private_ip"] = field
 
-    field = data.get("available_ingresses")
-    args["available_ingresses"] = field
+    field = data.get("private_port", None)
+    args["private_port"] = field
 
-    field = data.get("available_kubelet_args")
-    args["available_kubelet_args"] = field
+    field = data.get("protocol", None)
+    args["protocol"] = field
 
-    field = data.get("label")
-    args["label"] = field
+    field = data.get("public_port", None)
+    args["public_port"] = field
 
-    field = data.get("name")
-    args["name"] = field
+    field = data.get("updated_at", None)
+    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("region")
-    args["region"] = field
+    field = data.get("zone", None)
+    args["zone"] = field
 
-    return Version(**args)
+    return PATRule(**args)
 
 
-def unmarshal_ExternalNode(data: Any) -> ExternalNode:
+def unmarshal_ListDHCPEntriesResponse(data: Any) -> ListDHCPEntriesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ExternalNode' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListDHCPEntriesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("cluster_ca")
-    args["cluster_ca"] = field
+    field = data.get("dhcp_entries", None)
+    args["dhcp_entries"] = (
+        [unmarshal_DHCPEntry(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("cluster_url")
-    args["cluster_url"] = field
+    field = data.get("total_count", None)
+    args["total_count"] = field
 
-    field = data.get("cluster_version")
-    args["cluster_version"] = field
+    return ListDHCPEntriesResponse(**args)
 
-    field = data.get("id")
-    args["id"] = field
 
-    field = data.get("kube_token")
-    args["kube_token"] = field
+def unmarshal_ListDHCPsResponse(data: Any) -> ListDHCPsResponse:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'ListDHCPsResponse' failed as data isn't a dictionary."
+        )
 
-    field = data.get("kubelet_config")
-    args["kubelet_config"] = field
+    args: Dict[str, Any] = {}
 
-    field = data.get("name")
-    args["name"] = field
+    field = data.get("dhcps", None)
+    args["dhcps"] = [unmarshal_DHCP(v) for v in field] if field is not None else None
+
+    field = data.get("total_count", None)
+    args["total_count"] = field
+
+    return ListDHCPsResponse(**args)
 
-    return ExternalNode(**args)
 
+def unmarshal_ListGatewayNetworksResponse(data: Any) -> ListGatewayNetworksResponse:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'ListGatewayNetworksResponse' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("gateway_networks", None)
+    args["gateway_networks"] = (
+        [unmarshal_GatewayNetwork(v) for v in field] if field is not None else None
+    )
 
-def unmarshal_ListClusterAvailableVersionsResponse(
-    data: Any,
-) -> ListClusterAvailableVersionsResponse:
+    field = data.get("total_count", None)
+    args["total_count"] = field
+
+    return ListGatewayNetworksResponse(**args)
+
+
+def unmarshal_ListGatewayTypesResponse(data: Any) -> ListGatewayTypesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListClusterAvailableVersionsResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListGatewayTypesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("versions")
-    args["versions"] = [unmarshal_Version(v) for v in data["versions"]]
+    field = data.get("types", None)
+    args["types"] = (
+        [unmarshal_GatewayType(v) for v in field] if field is not None else None
+    )
 
-    return ListClusterAvailableVersionsResponse(**args)
+    return ListGatewayTypesResponse(**args)
 
 
-def unmarshal_ListClustersResponse(data: Any) -> ListClustersResponse:
+def unmarshal_ListGatewaysResponse(data: Any) -> ListGatewaysResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListClustersResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListGatewaysResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("clusters")
-    args["clusters"] = [unmarshal_Cluster(v) for v in data["clusters"]]
+    field = data.get("gateways", None)
+    args["gateways"] = (
+        [unmarshal_Gateway(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListClustersResponse(**args)
+    return ListGatewaysResponse(**args)
 
 
-def unmarshal_ListNodesResponse(data: Any) -> ListNodesResponse:
+def unmarshal_ListIPsResponse(data: Any) -> ListIPsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListNodesResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListIPsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("nodes")
-    args["nodes"] = [unmarshal_Node(v) for v in data["nodes"]]
+    field = data.get("ips", None)
+    args["ips"] = [unmarshal_IP(v) for v in field] if field is not None else None
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListNodesResponse(**args)
+    return ListIPsResponse(**args)
 
 
-def unmarshal_ListPoolsResponse(data: Any) -> ListPoolsResponse:
+def unmarshal_ListPATRulesResponse(data: Any) -> ListPATRulesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListPoolsResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListPATRulesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("pools")
-    args["pools"] = [unmarshal_Pool(v) for v in data["pools"]]
+    field = data.get("pat_rules", None)
+    args["pat_rules"] = (
+        [unmarshal_PATRule(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListPoolsResponse(**args)
+    return ListPATRulesResponse(**args)
+
 
+def unmarshal_SetDHCPEntriesResponse(data: Any) -> SetDHCPEntriesResponse:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'SetDHCPEntriesResponse' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("dhcp_entries", None)
+    args["dhcp_entries"] = (
+        [unmarshal_DHCPEntry(v) for v in field] if field is not None else None
+    )
+
+    return SetDHCPEntriesResponse(**args)
 
-def unmarshal_ListVersionsResponse(data: Any) -> ListVersionsResponse:
+
+def unmarshal_SetPATRulesResponse(data: Any) -> SetPATRulesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListVersionsResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'SetPATRulesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("versions")
-    args["versions"] = [unmarshal_Version(v) for v in data["versions"]]
+    field = data.get("pat_rules", None)
+    args["pat_rules"] = (
+        [unmarshal_PATRule(v) for v in field] if field is not None else None
+    )
 
-    return ListVersionsResponse(**args)
+    return SetPATRulesResponse(**args)
 
 
-def marshal_CreateClusterRequestPoolConfigUpgradePolicy(
-    request: CreateClusterRequestPoolConfigUpgradePolicy,
+def marshal_CreateDHCPRequest(
+    request: CreateDHCPRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "max_surge": request.max_surge,
-        "max_unavailable": request.max_unavailable,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.address is not None:
+        output["address"] = request.address
+
+    if request.dns_local_name is not None:
+        output["dns_local_name"] = request.dns_local_name
+
+    if request.dns_search is not None:
+        output["dns_search"] = request.dns_search
+
+    if request.dns_servers_override is not None:
+        output["dns_servers_override"] = request.dns_servers_override
+
+    if request.enable_dynamic is not None:
+        output["enable_dynamic"] = request.enable_dynamic
 
+    if request.pool_high is not None:
+        output["pool_high"] = request.pool_high
 
-def marshal_MaintenanceWindow(
-    request: MaintenanceWindow,
+    if request.pool_low is not None:
+        output["pool_low"] = request.pool_low
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    if request.push_default_route is not None:
+        output["push_default_route"] = request.push_default_route
+
+    if request.push_dns_server is not None:
+        output["push_dns_server"] = request.push_dns_server
+
+    if request.rebind_timer is not None:
+        output["rebind_timer"] = request.rebind_timer
+
+    if request.renew_timer is not None:
+        output["renew_timer"] = request.renew_timer
+
+    if request.subnet is not None:
+        output["subnet"] = request.subnet
+
+    if request.valid_lifetime is not None:
+        output["valid_lifetime"] = request.valid_lifetime
+
+    return output
+
+
+def marshal_SetDHCPEntriesRequestEntry(
+    request: SetDHCPEntriesRequestEntry,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "day": MaintenanceWindowDayOfTheWeek(request.day),
-        "start_hour": request.start_hour,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.ip_address is not None:
+        output["ip_address"] = request.ip_address
+
+    if request.mac_address is not None:
+        output["mac_address"] = request.mac_address
 
+    return output
 
-def marshal_CreateClusterRequestAutoUpgrade(
-    request: CreateClusterRequestAutoUpgrade,
+
+def marshal_SetPATRulesRequestRule(
+    request: SetPATRulesRequestRule,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "enable": request.enable,
-        "maintenance_window": marshal_MaintenanceWindow(
-            request.maintenance_window, defaults
-        )
-        if request.maintenance_window is not None
-        else None,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.private_ip is not None:
+        output["private_ip"] = request.private_ip
 
+    if request.private_port is not None:
+        output["private_port"] = request.private_port
 
-def marshal_CreateClusterRequestAutoscalerConfig(
-    request: CreateClusterRequestAutoscalerConfig,
+    if request.protocol is not None:
+        output["protocol"] = PATRuleProtocol(request.protocol)
+
+    if request.public_port is not None:
+        output["public_port"] = request.public_port
+
+    return output
+
+
+def marshal_CreateDHCPEntryRequest(
+    request: CreateDHCPEntryRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "balance_similar_node_groups": request.balance_similar_node_groups,
-        "estimator": AutoscalerEstimator(request.estimator),
-        "expander": AutoscalerExpander(request.expander),
-        "expendable_pods_priority_cutoff": request.expendable_pods_priority_cutoff,
-        "ignore_daemonsets_utilization": request.ignore_daemonsets_utilization,
-        "max_graceful_termination_sec": request.max_graceful_termination_sec,
-        "scale_down_delay_after_add": request.scale_down_delay_after_add,
-        "scale_down_disabled": request.scale_down_disabled,
-        "scale_down_unneeded_time": request.scale_down_unneeded_time,
-        "scale_down_utilization_threshold": request.scale_down_utilization_threshold,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.gateway_network_id is not None:
+        output["gateway_network_id"] = request.gateway_network_id
+
+    if request.ip_address is not None:
+        output["ip_address"] = request.ip_address
+
+    if request.mac_address is not None:
+        output["mac_address"] = request.mac_address
+
+    return output
 
 
-def marshal_CreateClusterRequestOpenIDConnectConfig(
-    request: CreateClusterRequestOpenIDConnectConfig,
+def marshal_CreateGatewayNetworkRequest(
+    request: CreateGatewayNetworkRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "client_id": request.client_id,
-        "groups_claim": request.groups_claim,
-        "groups_prefix": request.groups_prefix,
-        "issuer_url": request.issuer_url,
-        "required_claim": request.required_claim,
-        "username_claim": request.username_claim,
-        "username_prefix": request.username_prefix,
-    }
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
+            [
+                OneOfPossibility(
+                    "dhcp_id", request.dhcp_id if request.dhcp_id is not None else None
+                ),
+                OneOfPossibility(
+                    "dhcp",
+                    marshal_CreateDHCPRequest(request.dhcp, defaults)
+                    if request.dhcp is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "address", request.address if request.address is not None else None
+                ),
+            ]
+        ),
+    )
+
+    if request.enable_dhcp is not None:
+        output["enable_dhcp"] = request.enable_dhcp
+
+    if request.enable_masquerade is not None:
+        output["enable_masquerade"] = request.enable_masquerade
+
+    if request.gateway_id is not None:
+        output["gateway_id"] = request.gateway_id
+
+    if request.private_network_id is not None:
+        output["private_network_id"] = request.private_network_id
+
+    return output
 
 
-def marshal_CreateClusterRequestPoolConfig(
-    request: CreateClusterRequestPoolConfig,
+def marshal_CreateGatewayRequest(
+    request: CreateGatewayRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "autohealing": request.autohealing,
-        "autoscaling": request.autoscaling,
-        "container_runtime": Runtime(request.container_runtime),
-        "kubelet_args": request.kubelet_args,
-        "max_size": request.max_size,
-        "min_size": request.min_size,
-        "name": request.name,
-        "node_type": request.node_type,
-        "placement_group_id": request.placement_group_id,
-        "root_volume_size": request.root_volume_size,
-        "root_volume_type": PoolVolumeType(request.root_volume_type),
-        "size": request.size,
-        "tags": request.tags,
-        "upgrade_policy": marshal_CreateClusterRequestPoolConfigUpgradePolicy(
-            request.upgrade_policy, defaults
-        )
-        if request.upgrade_policy is not None
-        else None,
-        "zone": request.zone,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.bastion_port is not None:
+        output["bastion_port"] = request.bastion_port
+
+    if request.enable_bastion is not None:
+        output["enable_bastion"] = request.enable_bastion
+
+    if request.enable_smtp is not None:
+        output["enable_smtp"] = request.enable_smtp
+
+    if request.ip_id is not None:
+        output["ip_id"] = request.ip_id
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
 
+    if request.tags is not None:
+        output["tags"] = request.tags
 
-def marshal_CreatePoolRequestUpgradePolicy(
-    request: CreatePoolRequestUpgradePolicy,
+    if request.type_ is not None:
+        output["type"] = request.type_
+
+    if request.upstream_dns_servers is not None:
+        output["upstream_dns_servers"] = request.upstream_dns_servers
+
+    return output
+
+
+def marshal_CreateIPRequest(
+    request: CreateIPRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "max_surge": request.max_surge,
-        "max_unavailable": request.max_unavailable,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
 
-def marshal_UpdateClusterRequestAutoUpgrade(
-    request: UpdateClusterRequestAutoUpgrade,
+    if request.tags is not None:
+        output["tags"] = request.tags
+
+    return output
+
+
+def marshal_CreatePATRuleRequest(
+    request: CreatePATRuleRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "enable": request.enable,
-        "maintenance_window": marshal_MaintenanceWindow(
-            request.maintenance_window, defaults
-        )
-        if request.maintenance_window is not None
-        else None,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.gateway_id is not None:
+        output["gateway_id"] = request.gateway_id
+
+    if request.private_ip is not None:
+        output["private_ip"] = request.private_ip
+
+    if request.private_port is not None:
+        output["private_port"] = request.private_port
+
+    if request.protocol is not None:
+        output["protocol"] = PATRuleProtocol(request.protocol)
+
+    if request.public_port is not None:
+        output["public_port"] = request.public_port
+
+    return output
+
 
+def marshal_SetDHCPEntriesRequest(
+    request: SetDHCPEntriesRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.dhcp_entries is not None:
+        output["dhcp_entries"] = [
+            marshal_SetDHCPEntriesRequestEntry(v, defaults)
+            for v in request.dhcp_entries
+        ]
 
-def marshal_UpdateClusterRequestAutoscalerConfig(
-    request: UpdateClusterRequestAutoscalerConfig,
+    if request.gateway_network_id is not None:
+        output["gateway_network_id"] = request.gateway_network_id
+
+    return output
+
+
+def marshal_SetPATRulesRequest(
+    request: SetPATRulesRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "balance_similar_node_groups": request.balance_similar_node_groups,
-        "estimator": AutoscalerEstimator(request.estimator),
-        "expander": AutoscalerExpander(request.expander),
-        "expendable_pods_priority_cutoff": request.expendable_pods_priority_cutoff,
-        "ignore_daemonsets_utilization": request.ignore_daemonsets_utilization,
-        "max_graceful_termination_sec": request.max_graceful_termination_sec,
-        "scale_down_delay_after_add": request.scale_down_delay_after_add,
-        "scale_down_disabled": request.scale_down_disabled,
-        "scale_down_unneeded_time": request.scale_down_unneeded_time,
-        "scale_down_utilization_threshold": request.scale_down_utilization_threshold,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.gateway_id is not None:
+        output["gateway_id"] = request.gateway_id
 
-def marshal_UpdateClusterRequestOpenIDConnectConfig(
-    request: UpdateClusterRequestOpenIDConnectConfig,
+    if request.pat_rules is not None:
+        output["pat_rules"] = [
+            marshal_SetPATRulesRequestRule(v, defaults) for v in request.pat_rules
+        ]
+
+    return output
+
+
+def marshal_UpdateDHCPEntryRequest(
+    request: UpdateDHCPEntryRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "client_id": request.client_id,
-        "groups_claim": request.groups_claim,
-        "groups_prefix": request.groups_prefix,
-        "issuer_url": request.issuer_url,
-        "required_claim": request.required_claim,
-        "username_claim": request.username_claim,
-        "username_prefix": request.username_prefix,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.ip_address is not None:
+        output["ip_address"] = request.ip_address
 
+    return output
 
-def marshal_UpdatePoolRequestUpgradePolicy(
-    request: UpdatePoolRequestUpgradePolicy,
+
+def marshal_UpdateDHCPRequest(
+    request: UpdateDHCPRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "max_surge": request.max_surge,
-        "max_unavailable": request.max_unavailable,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.address is not None:
+        output["address"] = request.address
+
+    if request.dns_local_name is not None:
+        output["dns_local_name"] = request.dns_local_name
 
+    if request.dns_search is not None:
+        output["dns_search"] = request.dns_search
 
-def marshal_CreateClusterRequest(
-    request: CreateClusterRequest,
+    if request.dns_servers_override is not None:
+        output["dns_servers_override"] = request.dns_servers_override
+
+    if request.enable_dynamic is not None:
+        output["enable_dynamic"] = request.enable_dynamic
+
+    if request.pool_high is not None:
+        output["pool_high"] = request.pool_high
+
+    if request.pool_low is not None:
+        output["pool_low"] = request.pool_low
+
+    if request.push_default_route is not None:
+        output["push_default_route"] = request.push_default_route
+
+    if request.push_dns_server is not None:
+        output["push_dns_server"] = request.push_dns_server
+
+    if request.rebind_timer is not None:
+        output["rebind_timer"] = request.rebind_timer
+
+    if request.renew_timer is not None:
+        output["renew_timer"] = request.renew_timer
+
+    if request.subnet is not None:
+        output["subnet"] = request.subnet
+
+    if request.valid_lifetime is not None:
+        output["valid_lifetime"] = request.valid_lifetime
+
+    return output
+
+
+def marshal_UpdateGatewayNetworkRequest(
+    request: UpdateGatewayNetworkRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
                 OneOfPossibility(
-                    "project_id", request.project_id, defaults.default_project_id
+                    "dhcp_id", request.dhcp_id if request.dhcp_id is not None else None
                 ),
                 OneOfPossibility(
-                    "organization_id",
-                    request.organization_id,
-                    defaults.default_organization_id,
+                    "address", request.address if request.address is not None else None
                 ),
             ]
         ),
-        "admission_plugins": request.admission_plugins,
-        "apiserver_cert_sans": request.apiserver_cert_sans,
-        "auto_upgrade": marshal_CreateClusterRequestAutoUpgrade(
-            request.auto_upgrade, defaults
-        )
-        if request.auto_upgrade is not None
-        else None,
-        "autoscaler_config": marshal_CreateClusterRequestAutoscalerConfig(
-            request.autoscaler_config, defaults
-        )
-        if request.autoscaler_config is not None
-        else None,
-        "cni": CNI(request.cni) if request.cni is not None else None,
-        "description": request.description,
-        "enable_dashboard": request.enable_dashboard,
-        "feature_gates": request.feature_gates,
-        "ingress": Ingress(request.ingress) if request.ingress is not None else None,
-        "name": request.name,
-        "open_id_connect_config": marshal_CreateClusterRequestOpenIDConnectConfig(
-            request.open_id_connect_config, defaults
-        )
-        if request.open_id_connect_config is not None
-        else None,
-        "pools": [
-            marshal_CreateClusterRequestPoolConfig(v, defaults) for v in request.pools
-        ]
-        if request.pools is not None
-        else None,
-        "tags": request.tags,
-        "type": request.type_,
-        "version": request.version,
-    }
-
-
-def marshal_CreatePoolRequest(
-    request: CreatePoolRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "autohealing": request.autohealing,
-        "autoscaling": request.autoscaling,
-        "container_runtime": Runtime(request.container_runtime),
-        "kubelet_args": request.kubelet_args,
-        "max_size": request.max_size,
-        "min_size": request.min_size,
-        "name": request.name,
-        "node_type": request.node_type,
-        "placement_group_id": request.placement_group_id,
-        "root_volume_size": request.root_volume_size,
-        "root_volume_type": PoolVolumeType(request.root_volume_type),
-        "size": request.size,
-        "tags": request.tags,
-        "upgrade_policy": marshal_CreatePoolRequestUpgradePolicy(
-            request.upgrade_policy, defaults
-        )
-        if request.upgrade_policy is not None
-        else None,
-        "zone": request.zone or defaults.default_zone,
-    }
-
-
-def marshal_UpdateClusterRequest(
-    request: UpdateClusterRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "admission_plugins": request.admission_plugins,
-        "apiserver_cert_sans": request.apiserver_cert_sans,
-        "auto_upgrade": marshal_UpdateClusterRequestAutoUpgrade(
-            request.auto_upgrade, defaults
-        )
-        if request.auto_upgrade is not None
-        else None,
-        "autoscaler_config": marshal_UpdateClusterRequestAutoscalerConfig(
-            request.autoscaler_config, defaults
-        )
-        if request.autoscaler_config is not None
-        else None,
-        "description": request.description,
-        "enable_dashboard": request.enable_dashboard,
-        "feature_gates": request.feature_gates,
-        "ingress": Ingress(request.ingress) if request.ingress is not None else None,
-        "name": request.name,
-        "open_id_connect_config": marshal_UpdateClusterRequestOpenIDConnectConfig(
-            request.open_id_connect_config, defaults
-        )
-        if request.open_id_connect_config is not None
-        else None,
-        "tags": request.tags,
-    }
-
-
-def marshal_UpdatePoolRequest(
-    request: UpdatePoolRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "autohealing": request.autohealing,
-        "autoscaling": request.autoscaling,
-        "kubelet_args": request.kubelet_args,
-        "max_size": request.max_size,
-        "min_size": request.min_size,
-        "size": request.size,
-        "tags": request.tags,
-        "upgrade_policy": marshal_UpdatePoolRequestUpgradePolicy(
-            request.upgrade_policy, defaults
-        )
-        if request.upgrade_policy is not None
-        else None,
-    }
-
-
-def marshal_UpgradeClusterRequest(
-    request: UpgradeClusterRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "upgrade_pools": request.upgrade_pools,
-        "version": request.version,
-    }
-
-
-def marshal_UpgradePoolRequest(
-    request: UpgradePoolRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "version": request.version,
-    }
+    )
+
+    if request.enable_dhcp is not None:
+        output["enable_dhcp"] = request.enable_dhcp
+
+    if request.enable_masquerade is not None:
+        output["enable_masquerade"] = request.enable_masquerade
+
+    return output
+
+
+def marshal_UpdateGatewayRequest(
+    request: UpdateGatewayRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.bastion_port is not None:
+        output["bastion_port"] = request.bastion_port
+
+    if request.enable_bastion is not None:
+        output["enable_bastion"] = request.enable_bastion
+
+    if request.enable_smtp is not None:
+        output["enable_smtp"] = request.enable_smtp
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.tags is not None:
+        output["tags"] = request.tags
+
+    if request.upstream_dns_servers is not None:
+        output["upstream_dns_servers"] = request.upstream_dns_servers
+
+    return output
+
+
+def marshal_UpdateIPRequest(
+    request: UpdateIPRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.gateway_id is not None:
+        output["gateway_id"] = request.gateway_id
+
+    if request.reverse is not None:
+        output["reverse"] = request.reverse
+
+    if request.tags is not None:
+        output["tags"] = request.tags
+
+    return output
+
+
+def marshal_UpdatePATRuleRequest(
+    request: UpdatePATRuleRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+
+    if request.private_ip is not None:
+        output["private_ip"] = request.private_ip
+
+    if request.private_port is not None:
+        output["private_port"] = request.private_port
+
+    if request.protocol is not None:
+        output["protocol"] = PATRuleProtocol(request.protocol)
+
+    if request.public_port is not None:
+        output["public_port"] = request.public_port
+
+    return output
```

### Comparing `scaleway_async-0.9.0/scaleway_async/k8s/v1/types.py` & `scaleway_async-1.0.0/scaleway_async/k8s/v1/types.py`

 * *Files 11% similar despite different names*

```diff
@@ -55,14 +55,32 @@
     LOCKED = "locked"
     POOL_REQUIRED = "pool_required"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
+class ClusterTypeAvailability(str, Enum):
+    AVAILABLE = "available"
+    SCARCE = "scarce"
+    SHORTAGE = "shortage"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
+class ClusterTypeResiliency(str, Enum):
+    UNKNOWN_RESILIENCY = "unknown_resiliency"
+    STANDARD = "standard"
+    HIGH_AVAILABILITY = "high_availability"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
 class Ingress(str, Enum):
     UNKNOWN_INGRESS = "unknown_ingress"
     NONE = "none"
     NGINX = "nginx"
     TRAEFIK = "traefik"
     TRAEFIK2 = "traefik2"
 
@@ -174,484 +192,525 @@
     def __str__(self) -> str:
         return str(self.value)
 
 
 @dataclass
 class Cluster:
     """
-    Cluster
+    Cluster.
     """
 
     id: str
     """
-    The ID of the cluster
+    Cluster ID.
     """
 
     type_: str
     """
-    The type of the cluster
+    Cluster type.
     """
 
     name: str
     """
-    The name of the cluster
+    Cluster name.
     """
 
     status: ClusterStatus
     """
-    The status of the cluster
+    Status of the cluster.
     """
 
     version: str
     """
-    The Kubernetes version of the cluster
+    Kubernetes version of the cluster.
     """
 
     region: Region
     """
-    The region in which the cluster is
+    Region in which the cluster is deployed.
     """
 
     organization_id: str
     """
-    The ID of the organization owning the cluster
+    ID of the Organization owning the cluster.
     """
 
     project_id: str
     """
-    The ID of the project owning the cluster
+    ID of the Project owning the cluster.
     """
 
     tags: List[str]
     """
-    The tags associated with the cluster
+    Tags associated with the cluster.
     """
 
     cni: CNI
     """
-    The Container Network Interface (CNI) plugin running in the cluster
+    Container Network Interface (CNI) plugin running in the cluster.
     """
 
     description: str
     """
-    The description of the cluster
+    Cluster description.
     """
 
     cluster_url: str
     """
-    The Kubernetes API server URL of the cluster
+    Kubernetes API server URL of the cluster.
     """
 
     dns_wildcard: str
     """
-    The DNS wildcard resovling all the ready nodes of the cluster
+    Wildcard DNS resolving all the ready cluster nodes.
     """
 
     created_at: Optional[datetime]
     """
-    The date at which the cluster was created
+    Date on which the cluster was created.
     """
 
     updated_at: Optional[datetime]
     """
-    The date at which the cluster was last updated
+    Date on which the cluster was last updated.
     """
 
     autoscaler_config: Optional[ClusterAutoscalerConfig]
     """
-    The autoscaler config for the cluster
+    Autoscaler config for the cluster.
     """
 
     dashboard_enabled: Optional[bool]
     """
-    The enablement of the Kubernetes Dashboard in the cluster
+    Defines whether the Kubernetes dashboard is enabled for the cluster.
     :deprecated
     """
 
     ingress: Optional[Ingress]
     """
-    The ingress controller used in the cluster
+    Managed Ingress controller used in the cluster (deprecated feature).
     :deprecated
     """
 
     auto_upgrade: Optional[ClusterAutoUpgrade]
     """
-    The auto upgrade configuration of the cluster
+    Auto upgrade configuration of the cluster.
     """
 
     upgrade_available: bool
     """
-    True if a new Kubernetes version is available
+    Defines whether a new Kubernetes version is available.
     """
 
     feature_gates: List[str]
     """
-    List of enabled feature gates
+    List of enabled feature gates.
     """
 
     admission_plugins: List[str]
     """
-    List of enabled admission plugins
+    List of enabled admission plugins.
     """
 
     open_id_connect_config: Optional[ClusterOpenIDConnectConfig]
     """
-    This feature is in ALPHA state, it may be deleted or modified. This configuration is the [OpenID Connect configuration](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens) of the Kubernetes API server.
+    This configuration enables to update the OpenID Connect configuration of the Kubernetes API server.
     """
 
     apiserver_cert_sans: List[str]
     """
-    Additional Subject Alternative Names for the Kubernetes API server certificate
+    Additional Subject Alternative Names for the Kubernetes API server certificate.
+    """
+
+    private_network_id: Optional[str]
+    """
+    Private network ID for internal cluster communication.
+    """
+
+    commitment_ends_at: Optional[datetime]
+    """
+    Date on which it will be possible to switch to a smaller offer.
     """
 
 
 @dataclass
 class ClusterAutoUpgrade:
     """
-    Cluster. auto upgrade
+    Cluster. auto upgrade.
     """
 
     enabled: bool
     """
-    Whether or not auto upgrade is enabled for the cluster
+    Defines whether auto upgrade is enabled for the cluster.
     """
 
     maintenance_window: Optional[MaintenanceWindow]
     """
-    The maintenance window of the cluster auto upgrades
+    Maintenance window of the cluster auto upgrades.
     """
 
 
 @dataclass
 class ClusterAutoscalerConfig:
     """
-    Cluster. autoscaler config
+    Cluster. autoscaler config.
     """
 
     scale_down_disabled: bool
     """
-    Disable the cluster autoscaler
+    Disable the cluster autoscaler.
     """
 
     scale_down_delay_after_add: str
     """
-    How long after scale up that scale down evaluation resumes
+    How long after scale up that scale down evaluation resumes.
     """
 
     estimator: AutoscalerEstimator
     """
-    Type of resource estimator to be used in scale up
+    Type of resource estimator to be used in scale up.
     """
 
     expander: AutoscalerExpander
     """
-    Type of node group expander to be used in scale up
+    Type of node group expander to be used in scale up.
     """
 
     ignore_daemonsets_utilization: bool
     """
-    Ignore DaemonSet pods when calculating resource utilization for scaling down
+    Ignore DaemonSet pods when calculating resource utilization for scaling down.
     """
 
     balance_similar_node_groups: bool
     """
-    Detect similar node groups and balance the number of nodes between them
+    Detect similar node groups and balance the number of nodes between them.
     """
 
     expendable_pods_priority_cutoff: int
     """
-    Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
+    Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they won't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
     """
 
     scale_down_unneeded_time: str
     """
-    How long a node should be unneeded before it is eligible for scale down
+    How long a node should be unneeded before it is eligible to be scaled down.
     """
 
     scale_down_utilization_threshold: float
     """
-    Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
+    Node utilization level, defined as a sum of requested resources divided by capacity, below which a node can be considered for scale down.
     """
 
     max_graceful_termination_sec: int
     """
-    Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
+    Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node.
     """
 
 
 @dataclass
 class ClusterOpenIDConnectConfig:
     """
-    Cluster. open id connect config
+    Cluster. open id connect config.
     """
 
     issuer_url: str
     """
-    URL of the provider which allows the API server to discover public signing keys. Only URLs which use the `https://` scheme are accepted. This is typically the provider's discovery URL without a path, for example "https://accounts.google.com" or "https://login.salesforce.com". This URL should point to the level below .well-known/openid-configuration.
-    
+    URL of the provider which allows the API server to discover public signing keys. Only URLs using the `https://` scheme are accepted. This is typically the provider's discovery URL without a path, for example "https://accounts.google.com" or "https://login.salesforce.com".
     """
 
     client_id: str
     """
-    A client id that all tokens must be issued for
+    A client ID that all tokens must be issued for.
     """
 
     username_claim: str
     """
-    JWT claim to use as the user name. By default `sub`, which is expected to be a unique identifier of the end user. Admins can choose other claims, such as `email` or `name`, depending on their provider. However, claims other than `email` will be prefixed with the issuer URL to prevent naming clashes with other plugins.
-    
+    JWT claim to use as the user name. The default is `sub`, which is expected to be the end user's unique identifier. Admins can choose other claims, such as `email` or `name`, depending on their provider. However, claims other than `email` will be prefixed with the issuer URL to prevent name collision.
     """
 
     username_prefix: str
     """
-    Prefix prepended to username claims to prevent clashes with existing names (such as `system:` users). For example, the value `oidc:` will create usernames like `oidc:jane.doe`. If this flag isn't provided and `username_claim` is a value other than `email` the prefix defaults to `( Issuer URL )#` where `( Issuer URL )` is the value of `issuer_url`. The value `-` can be used to disable all prefixing.
-    
+    Prefix prepended to username claims to prevent name collision (such as `system:` users). For example, the value `oidc:` will create usernames like `oidc:jane.doe`. If this flag is not provided and `username_claim` is a value other than `email`, the prefix defaults to `( Issuer URL )#` where `( Issuer URL )` is the value of `issuer_url`. The value `-` can be used to disable all prefixing.
     """
 
     groups_claim: List[str]
     """
-    JWT claim to use as the user's group
+    JWT claim to use as the user's group.
     """
 
     groups_prefix: str
     """
-    Prefix prepended to group claims to prevent clashes with existing names (such as `system:` groups). For example, the value `oidc:` will create group names like `oidc:engineering` and `oidc:infra`.
-    
+    Prefix prepended to group claims to prevent name collision (such as `system:` groups). For example, the value `oidc:` will create group names like `oidc:engineering` and `oidc:infra`.
     """
 
     required_claim: List[str]
     """
-    Multiple key=value pairs that describes a required claim in the ID Token. If set, the claims are verified to be present in the ID Token with a matching value.
-    
+    Multiple key=value pairs describing a required claim in the ID token. If set, the claims are verified to be present in the ID token with a matching value.
+    """
+
+
+@dataclass
+class ClusterType:
+    """
+    Cluster type.
+    """
+
+    name: str
+    """
+    Cluster type name.
+    """
+
+    availability: ClusterTypeAvailability
+    """
+    Cluster type availability.
+    """
+
+    max_nodes: int
+    """
+    Maximum number of nodes supported by the offer.
+    """
+
+    commitment_delay: Optional[str]
+    """
+    Time period during which you can no longer switch to a lower offer.
+    """
+
+    sla: float
+    """
+    Value of the Service Level Agreement of the offer.
+    """
+
+    resiliency: ClusterTypeResiliency
+    """
+    Resiliency offered by the offer.
+    """
+
+    memory: int
+    """
+    Max RAM allowed for the control plane.
+    """
+
+    dedicated: bool
+    """
+    Returns information if this offer uses dedicated resources.
     """
 
 
 @dataclass
 class CreateClusterRequestAutoUpgrade:
     """
-    Create cluster request. auto upgrade
+    Create cluster request. auto upgrade.
     """
 
     enable: bool
     """
-    Whether or not auto upgrade is enabled for the cluster
+    Defines whether auto upgrade is enabled for the cluster.
     """
 
     maintenance_window: Optional[MaintenanceWindow]
     """
-    The maintenance window of the cluster auto upgrades
+    Maintenance window of the cluster auto upgrades.
     """
 
 
 @dataclass
 class CreateClusterRequestAutoscalerConfig:
     """
-    Create cluster request. autoscaler config
+    Create cluster request. autoscaler config.
     """
 
     scale_down_disabled: Optional[bool]
     """
-    Disable the cluster autoscaler
+    Disable the cluster autoscaler.
     """
 
     scale_down_delay_after_add: Optional[str]
     """
-    How long after scale up that scale down evaluation resumes
+    How long after scale up that scale down evaluation resumes.
     """
 
     estimator: AutoscalerEstimator
     """
-    Type of resource estimator to be used in scale up
+    Type of resource estimator to be used in scale up.
     """
 
     expander: AutoscalerExpander
     """
-    Type of node group expander to be used in scale up
+    Type of node group expander to be used in scale up.
     """
 
     ignore_daemonsets_utilization: Optional[bool]
     """
-    Ignore DaemonSet pods when calculating resource utilization for scaling down
+    Ignore DaemonSet pods when calculating resource utilization for scaling down.
     """
 
     balance_similar_node_groups: Optional[bool]
     """
-    Detect similar node groups and balance the number of nodes between them
+    Detect similar node groups and balance the number of nodes between them.
     """
 
     expendable_pods_priority_cutoff: Optional[int]
     """
-    Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
+    Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they won't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
     """
 
     scale_down_unneeded_time: Optional[str]
     """
-    How long a node should be unneeded before it is eligible for scale down
+    How long a node should be unneeded before it is eligible to be scaled down.
     """
 
     scale_down_utilization_threshold: Optional[float]
     """
-    Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
+    Node utilization level, defined as a sum of requested resources divided by capacity, below which a node can be considered for scale down.
     """
 
     max_graceful_termination_sec: Optional[int]
     """
-    Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
+    Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node.
     """
 
 
 @dataclass
 class CreateClusterRequestOpenIDConnectConfig:
     """
-    Create cluster request. open id connect config
+    Create cluster request. open id connect config.
     """
 
     issuer_url: str
     """
-    URL of the provider which allows the API server to discover public signing keys. Only URLs which use the `https://` scheme are accepted. This is typically the provider's discovery URL without a path, for example "https://accounts.google.com" or "https://login.salesforce.com". This URL should point to the level below .well-known/openid-configuration.
-    
+    URL of the provider which allows the API server to discover public signing keys. Only URLs using the `https://` scheme are accepted. This is typically the provider's discovery URL without a path, for example "https://accounts.google.com" or "https://login.salesforce.com".
     """
 
     client_id: str
     """
-    A client id that all tokens must be issued for
+    A client ID that all tokens must be issued for.
     """
 
     username_claim: Optional[str]
     """
-    JWT claim to use as the user name. By default `sub`, which is expected to be a unique identifier of the end user. Admins can choose other claims, such as `email` or `name`, depending on their provider. However, claims other than `email` will be prefixed with the issuer URL to prevent naming clashes with other plugins.
-    
+    JWT claim to use as the user name. The default is `sub`, which is expected to be the end user's unique identifier. Admins can choose other claims, such as `email` or `name`, depending on their provider. However, claims other than `email` will be prefixed with the issuer URL to prevent name collision.
     """
 
     username_prefix: Optional[str]
     """
-    Prefix prepended to username claims to prevent clashes with existing names (such as `system:` users). For example, the value `oidc:` will create usernames like `oidc:jane.doe`. If this flag isn't provided and `username_claim` is a value other than `email` the prefix defaults to `( Issuer URL )#` where `( Issuer URL )` is the value of `issuer_url`. The value `-` can be used to disable all prefixing.
-    
+    Prefix prepended to username claims to prevent name collision (such as `system:` users). For example, the value `oidc:` will create usernames like `oidc:jane.doe`. If this flag is not provided and `username_claim` is a value other than `email`, the prefix defaults to `( Issuer URL )#` where `( Issuer URL )` is the value of `issuer_url`. The value `-` can be used to disable all prefixing.
     """
 
     groups_claim: Optional[List[str]]
     """
-    JWT claim to use as the user's group
+    JWT claim to use as the user's group.
     """
 
     groups_prefix: Optional[str]
     """
-    Prefix prepended to group claims to prevent clashes with existing names (such as `system:` groups). For example, the value `oidc:` will create group names like `oidc:engineering` and `oidc:infra`.
-    
+    Prefix prepended to group claims to prevent name collision (such as `system:` groups). For example, the value `oidc:` will create group names like `oidc:engineering` and `oidc:infra`.
     """
 
     required_claim: Optional[List[str]]
     """
-    Multiple key=value pairs that describes a required claim in the ID Token. If set, the claims are verified to be present in the ID Token with a matching value.
-    
+    Multiple key=value pairs describing a required claim in the ID token. If set, the claims are verified to be present in the ID token with a matching value.
     """
 
 
 @dataclass
 class CreateClusterRequestPoolConfig:
     """
-    Create cluster request. pool config
+    Create cluster request. pool config.
     """
 
     name: str
     """
-    The name of the pool
+    Name of the pool.
     """
 
     node_type: str
     """
-    The node type is the type of Scaleway Instance wanted for the pool. Nodes with insufficient memory are not eligible (DEV1-S, PLAY2-PICO, STARDUST). 'external' is a special node type used to provision instances from other cloud providers.
+    Node type is the type of Scaleway Instance wanted for the pool. Nodes with insufficient memory are not eligible (DEV1-S, PLAY2-PICO, STARDUST). 'external' is a special node type used to provision instances from other cloud providers in a Kosmos Cluster.
     """
 
     placement_group_id: Optional[str]
     """
-    The placement group ID in which all the nodes of the pool will be created
+    Placement group ID in which all the nodes of the pool will be created.
     """
 
     autoscaling: bool
     """
-    The enablement of the autoscaling feature for the pool
+    Defines whether the autoscaling feature is enabled for the pool.
     """
 
     size: int
     """
-    The size (number of nodes) of the pool
+    Size (number of nodes) of the pool.
     """
 
     min_size: Optional[int]
     """
-    The minimum size of the pool. Note that this field will be used only when autoscaling is enabled.
+    Defines the minimum size of the pool. Note that this field is only used when autoscaling is enabled on the pool.
     """
 
     max_size: Optional[int]
     """
-    The maximum size of the pool. Note that this field will be used only when autoscaling is enabled.
+    Defines the maximum size of the pool. Note that this field is only used when autoscaling is enabled on the pool.
     """
 
     container_runtime: Runtime
     """
-    The customization of the container runtime is available for each pool. Note that `docker` is deprecated since 1.20 and will be removed in 1.24.
-    
+    Customization of the container runtime is available for each pool. Note that `docker` has been deprecated since version 1.20 and will be removed by version 1.24.
     """
 
     autohealing: bool
     """
-    The enablement of the autohealing feature for the pool
+    Defines whether the autohealing feature is enabled for the pool.
     """
 
     tags: List[str]
     """
-    The tags associated with the pool
+    Tags associated with the pool.
     """
 
     kubelet_args: Dict[str, str]
     """
-    The Kubelet arguments to be used by this pool. Note that this feature is to be considered as experimental
+    Kubelet arguments to be used by this pool. Note that this feature is experimental.
     """
 
     upgrade_policy: Optional[CreateClusterRequestPoolConfigUpgradePolicy]
     """
-    The Pool upgrade policy
+    Pool upgrade policy.
     """
 
     zone: Zone
     """
-    The Zone in which the Pool's node will be spawn in
+    Zone in which the pool's nodes will be spawned.
     """
 
     root_volume_type: PoolVolumeType
     """
-    The system volume disk type, we provide two different types of volume (`volume_type`):
-      - `l_ssd` is a local block storage: your system is stored locally on
-        the hypervisor of your node.
-      - `b_ssd` is a remote block storage: your system is stored on a
-        centralised and resilient cluster.
-    
+    Defines the system volume disk type. Two different types of volume (`volume_type`) are provided: `l_ssd` is a local block storage which means your system is stored locally on your node's hypervisor. `b_ssd` is a remote block storage which means your system is stored on a centralized and resilient cluster.
     """
 
     root_volume_size: Optional[int]
     """
-    The system volume disk size
+    System volume disk size.
     """
 
 
 @dataclass
 class CreateClusterRequestPoolConfigUpgradePolicy:
     """
-    Create cluster request. pool config. upgrade policy
+    Create cluster request. pool config. upgrade policy.
     """
 
     max_unavailable: Optional[int]
     """
-    The maximum number of nodes that can be not ready at the same time
+    The maximum number of nodes that can be not ready at the same time.
     """
 
     max_surge: Optional[int]
     """
-    The maximum number of nodes to be created during the upgrade
+    The maximum number of nodes to be created during the upgrade.
     """
 
 
 @dataclass
 class CreatePoolRequestUpgradePolicy:
     max_unavailable: Optional[int]
 
@@ -662,1155 +721,1246 @@
 class ExternalNode:
     id: str
 
     name: str
 
     cluster_url: str
 
-    cluster_version: str
+    pool_version: str
 
     cluster_ca: str
 
     kube_token: str
 
     kubelet_config: str
 
+    external_ip: str
+
+
+@dataclass
+class ListClusterAvailableTypesResponse:
+    """
+    List cluster available types response.
+    """
+
+    cluster_types: List[ClusterType]
+    """
+    Available cluster types for the cluster.
+    """
+
+    total_count: int
+    """
+    Total number of types.
+    """
+
 
 @dataclass
 class ListClusterAvailableVersionsResponse:
     """
-    List cluster available versions response
+    List cluster available versions response.
     """
 
     versions: List[Version]
     """
-    The available Kubernetes version for the cluster
+    Available Kubernetes versions for the cluster.
+    """
+
+
+@dataclass
+class ListClusterTypesResponse:
+    """
+    List cluster types response.
+    """
+
+    total_count: int
+    """
+    Total number of cluster-types.
+    """
+
+    cluster_types: List[ClusterType]
+    """
+    Paginated returned cluster-types.
     """
 
 
 @dataclass
 class ListClustersResponse:
     """
-    List clusters response
+    List clusters response.
     """
 
     total_count: int
     """
-    The total number of clusters
+    Total number of clusters.
     """
 
     clusters: List[Cluster]
     """
-    The paginated returned clusters
+    Paginated returned clusters.
     """
 
 
 @dataclass
 class ListNodesResponse:
     """
-    List nodes response
+    List nodes response.
     """
 
     total_count: int
     """
-    The total number of nodes
+    Total number of nodes.
     """
 
     nodes: List[Node]
     """
-    The paginated returned nodes
+    Paginated returned nodes.
     """
 
 
 @dataclass
 class ListPoolsResponse:
     """
-    List pools response
+    List pools response.
     """
 
     total_count: int
     """
-    The total number of pools that exists for the cluster
+    Total number of pools that exists for the cluster.
     """
 
     pools: List[Pool]
     """
-    The paginated returned pools
+    Paginated returned pools.
     """
 
 
 @dataclass
 class ListVersionsResponse:
     """
-    List versions response
+    List versions response.
     """
 
     versions: List[Version]
     """
-    The available Kubernetes versions
+    Available Kubernetes versions.
     """
 
 
 @dataclass
 class MaintenanceWindow:
     """
-    Maintenance window
+    Maintenance window.
     """
 
     start_hour: int
     """
-    The start hour of the 2-hour maintenance window
+    Start time of the two-hour maintenance window.
     """
 
     day: MaintenanceWindowDayOfTheWeek
     """
-    The day of the week for the maintenance window
+    Day of the week for the maintenance window.
     """
 
 
 @dataclass
 class Node:
     """
-    Node
+    Node.
     """
 
     id: str
     """
-    The ID of the node
+    Node ID.
     """
 
     pool_id: str
     """
-    The pool ID of the node
+    Pool ID of the node.
     """
 
     cluster_id: str
     """
-    The cluster ID of the node
+    Cluster ID of the node.
     """
 
     provider_id: str
     """
-    It is prefixed by instance type and location information (see https://pkg.go.dev/k8s.io/api/core/v1#NodeSpec.ProviderID).
+    Underlying instance ID. It is prefixed by instance type and location information (see https://pkg.go.dev/k8s.io/api/core/v1#NodeSpec.ProviderID).
     """
 
     region: Region
     """
-    The cluster region of the node
+    Cluster region of the node.
     """
 
     name: str
     """
-    The name of the node
+    Name of the node.
     """
 
     public_ip_v4: Optional[str]
     """
-    The public IPv4 address of the node
+    Public IPv4 address of the node.
     :deprecated
     """
 
     public_ip_v6: Optional[str]
     """
-    The public IPv6 address of the node
+    Public IPv6 address of the node.
     :deprecated
     """
 
     conditions: Optional[Dict[str, str]]
     """
-    These conditions contains the Node Problem Detector conditions, as well as some in house conditions.
+    Conditions of the node. These conditions contain the Node Problem Detector conditions, as well as some in house conditions.
     :deprecated
     """
 
     status: NodeStatus
     """
-    The status of the node
+    Status of the node.
     """
 
     error_message: Optional[str]
     """
-    Details of the error, if any occured when managing the node
+    Details of the error, if any occurred when managing the node.
     """
 
     created_at: Optional[datetime]
     """
-    The date at which the node was created
+    Date on which the node was created.
     """
 
     updated_at: Optional[datetime]
     """
-    The date at which the node was last updated
+    Date on which the node was last updated.
     """
 
 
 @dataclass
 class Pool:
     """
-    Pool
+    Pool.
     """
 
     id: str
     """
-    The ID of the pool
+    Pool ID.
     """
 
     cluster_id: str
     """
-    The cluster ID of the pool
+    Cluster ID of the pool.
     """
 
     created_at: Optional[datetime]
     """
-    The date at which the pool was created
+    Date on which the pool was created.
     """
 
     updated_at: Optional[datetime]
     """
-    The date at which the pool was last updated
+    Date on which the pool was last updated.
     """
 
     name: str
     """
-    The name of the pool
+    Pool name.
     """
 
     status: PoolStatus
     """
-    The status of the pool
+    Pool status.
     """
 
     version: str
     """
-    The version of the pool
+    Pool version.
     """
 
     node_type: str
     """
-    The node type is the type of Scaleway Instance wanted for the pool. Nodes with insufficient memory are not eligible (DEV1-S, PLAY2-PICO, STARDUST). 'external' is a special node type used to provision instances from other cloud providers.
+    Node type is the type of Scaleway Instance wanted for the pool. Nodes with insufficient memory are not eligible (DEV1-S, PLAY2-PICO, STARDUST). 'external' is a special node type used to provision instances from other cloud providers in a Kosmos Cluster.
     """
 
     autoscaling: bool
     """
-    The enablement of the autoscaling feature for the pool
+    Defines whether the autoscaling feature is enabled for the pool.
     """
 
     size: int
     """
-    The size (number of nodes) of the pool
+    Size (number of nodes) of the pool.
     """
 
     min_size: int
     """
-    The minimum size of the pool. Note that this field will be used only when autoscaling is enabled.
+    Defines the minimum size of the pool. Note that this field is only used when autoscaling is enabled on the pool.
     """
 
     max_size: int
     """
-    The maximum size of the pool. Note that this field will be used only when autoscaling is enabled.
+    Defines the maximum size of the pool. Note that this field is only used when autoscaling is enabled on the pool.
     """
 
     container_runtime: Runtime
     """
-    The customization of the container runtime is available for each pool. Note that `docker` is deprecated since 1.20 and will be removed in 1.24.
-    
+    Customization of the container runtime is available for each pool. Note that `docker` has been deprecated since version 1.20 and will be removed by version 1.24.
     """
 
     autohealing: bool
     """
-    The enablement of the autohealing feature for the pool
+    Defines whether the autohealing feature is enabled for the pool.
     """
 
     tags: List[str]
     """
-    The tags associated with the pool
+    Tags associated with the pool.
     """
 
     placement_group_id: Optional[str]
     """
-    The placement group ID in which all the nodes of the pool will be created
+    Placement group ID in which all the nodes of the pool will be created.
     """
 
     kubelet_args: Dict[str, str]
     """
-    The Kubelet arguments to be used by this pool. Note that this feature is to be considered as experimental
+    Kubelet arguments to be used by this pool. Note that this feature is experimental.
     """
 
     upgrade_policy: Optional[PoolUpgradePolicy]
     """
-    The Pool upgrade policy
+    Pool upgrade policy.
     """
 
     zone: Zone
     """
-    The Zone in which the Pool's node will be spawn in
+    Zone in which the pool's nodes will be spawned.
     """
 
     root_volume_type: PoolVolumeType
     """
-    The system volume disk type, we provide two different types of volume (`volume_type`):
-      - `l_ssd` is a local block storage: your system is stored locally on
-        the hypervisor of your node.
-      - `b_ssd` is a remote block storage: your system is stored on a
-        centralised and resilient cluster.
-    
+    Defines the system volume disk type. Two different types of volume (`volume_type`) are provided: `l_ssd` is a local block storage which means your system is stored locally on your node's hypervisor. `b_ssd` is a remote block storage which means your system is stored on a centralized and resilient cluster.
     """
 
     root_volume_size: Optional[int]
     """
-    The system volume disk size
+    System volume disk size.
     """
 
     region: Region
     """
-    The cluster region of the pool
+    Cluster region of the pool.
     """
 
 
 @dataclass
 class PoolUpgradePolicy:
     max_unavailable: int
 
     max_surge: int
 
 
 @dataclass
 class UpdateClusterRequestAutoUpgrade:
     """
-    Update cluster request. auto upgrade
+    Update cluster request. auto upgrade.
     """
 
     enable: Optional[bool]
     """
-    Whether or not auto upgrade is enabled for the cluster
+    Defines whether auto upgrade is enabled for the cluster.
     """
 
     maintenance_window: Optional[MaintenanceWindow]
     """
-    The maintenance window of the cluster auto upgrades
+    Maintenance window of the cluster auto upgrades.
     """
 
 
 @dataclass
 class UpdateClusterRequestAutoscalerConfig:
     """
-    Update cluster request. autoscaler config
+    Update cluster request. autoscaler config.
     """
 
     scale_down_disabled: Optional[bool]
     """
-    Disable the cluster autoscaler
+    Disable the cluster autoscaler.
     """
 
     scale_down_delay_after_add: Optional[str]
     """
-    How long after scale up that scale down evaluation resumes
+    How long after scale up that scale down evaluation resumes.
     """
 
     estimator: AutoscalerEstimator
     """
-    Type of resource estimator to be used in scale up
+    Type of resource estimator to be used in scale up.
     """
 
     expander: AutoscalerExpander
     """
-    Type of node group expander to be used in scale up
+    Type of node group expander to be used in scale up.
     """
 
     ignore_daemonsets_utilization: Optional[bool]
     """
-    Ignore DaemonSet pods when calculating resource utilization for scaling down
+    Ignore DaemonSet pods when calculating resource utilization for scaling down.
     """
 
     balance_similar_node_groups: Optional[bool]
     """
-    Detect similar node groups and balance the number of nodes between them
+    Detect similar node groups and balance the number of nodes between them.
     """
 
     expendable_pods_priority_cutoff: Optional[int]
     """
-    Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
+    Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they won't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
     """
 
     scale_down_unneeded_time: Optional[str]
     """
-    How long a node should be unneeded before it is eligible for scale down
+    How long a node should be unneeded before it is eligible to be scaled down.
     """
 
     scale_down_utilization_threshold: Optional[float]
     """
-    Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
+    Node utilization level, defined as a sum of requested resources divided by capacity, below which a node can be considered for scale down.
     """
 
     max_graceful_termination_sec: Optional[int]
     """
-    Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
+    Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node.
     """
 
 
 @dataclass
 class UpdateClusterRequestOpenIDConnectConfig:
     """
-    Update cluster request. open id connect config
+    Update cluster request. open id connect config.
     """
 
     issuer_url: Optional[str]
     """
-    URL of the provider which allows the API server to discover public signing keys. Only URLs which use the `https://` scheme are accepted. This is typically the provider's discovery URL without a path, for example "https://accounts.google.com" or "https://login.salesforce.com". This URL should point to the level below .well-known/openid-configuration.
-    
+    URL of the provider which allows the API server to discover public signing keys. Only URLs using the `https://` scheme are accepted. This is typically the provider's discovery URL without a path, for example "https://accounts.google.com" or "https://login.salesforce.com".
     """
 
     client_id: Optional[str]
     """
-    A client id that all tokens must be issued for
+    A client ID that all tokens must be issued for.
     """
 
     username_claim: Optional[str]
     """
-    JWT claim to use as the user name. By default `sub`, which is expected to be a unique identifier of the end user. Admins can choose other claims, such as `email` or `name`, depending on their provider. However, claims other than `email` will be prefixed with the issuer URL to prevent naming clashes with other plugins.
-    
+    JWT claim to use as the user name. The default is `sub`, which is expected to be the end user's unique identifier. Admins can choose other claims, such as `email` or `name`, depending on their provider. However, claims other than `email` will be prefixed with the issuer URL to prevent name collision.
     """
 
     username_prefix: Optional[str]
     """
-    Prefix prepended to username claims to prevent clashes with existing names (such as `system:` users). For example, the value `oidc:` will create usernames like `oidc:jane.doe`. If this flag isn't provided and `username_claim` is a value other than `email` the prefix defaults to `( Issuer URL )#` where `( Issuer URL )` is the value of `issuer_url`. The value `-` can be used to disable all prefixing.
-    
+    Prefix prepended to username claims to prevent name collision (such as `system:` users). For example, the value `oidc:` will create usernames like `oidc:jane.doe`. If this flag is not provided and `username_claim` is a value other than `email`, the prefix defaults to `( Issuer URL )#` where `( Issuer URL )` is the value of `issuer_url`. The value `-` can be used to disable all prefixing.
     """
 
     groups_claim: Optional[List[str]]
     """
-    JWT claim to use as the user's group
+    JWT claim to use as the user's group.
     """
 
     groups_prefix: Optional[str]
     """
-    Prefix prepended to group claims to prevent clashes with existing names (such as `system:` groups). For example, the value `oidc:` will create group names like `oidc:engineering` and `oidc:infra`.
-    
+    Prefix prepended to group claims to prevent name collision (such as `system:` groups). For example, the value `oidc:` will create group names like `oidc:engineering` and `oidc:infra`.
     """
 
     required_claim: Optional[List[str]]
     """
-    Multiple key=value pairs that describes a required claim in the ID Token. If set, the claims are verified to be present in the ID Token with a matching value.
-    
+    Multiple key=value pairs describing a required claim in the ID token. If set, the claims are verified to be present in the ID token with a matching value.
     """
 
 
 @dataclass
 class UpdatePoolRequestUpgradePolicy:
     max_unavailable: Optional[int]
 
     max_surge: Optional[int]
 
 
 @dataclass
 class Version:
     """
-    Version
+    Version.
     """
 
     name: str
     """
-    The name of the Kubernetes version
+    Name of the Kubernetes version.
     """
 
     label: str
     """
-    The label of the Kubernetes version
+    Label of the Kubernetes version.
     """
 
     region: Region
     """
-    The region in which this version is available
+    Region in which this version is available.
     """
 
     available_cnis: List[CNI]
     """
-    The supported Container Network Interface (CNI) plugins for this version
+    Supported Container Network Interface (CNI) plugins for this version.
     """
 
     available_ingresses: Optional[List[Ingress]]
     """
-    The supported Ingress Controllers for this version
+    Supported Ingress Controllers for this version.
     :deprecated
     """
 
     available_container_runtimes: List[Runtime]
     """
-    The supported container runtimes for this version
+    Supported container runtimes for this version.
     """
 
     available_feature_gates: List[str]
     """
-    The supported feature gates for this version
+    Supported feature gates for this version.
     """
 
     available_admission_plugins: List[str]
     """
-    The supported admission plugins for this version
+    Supported admission plugins for this version.
     """
 
     available_kubelet_args: Dict[str, str]
     """
-    The supported kubelet arguments for this version
+    Supported kubelet arguments for this version.
     """
 
 
 @dataclass
 class ListClustersRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     organization_id: Optional[str]
     """
-    The organization ID on which to filter the returned clusters
+    Organization ID on which to filter the returned clusters.
     """
 
     project_id: Optional[str]
     """
-    The project ID on which to filter the returned clusters
+    Project ID on which to filter the returned clusters.
     """
 
     order_by: Optional[ListClustersRequestOrderBy]
     """
-    The sort order of the returned clusters
+    Sort order of returned clusters.
     """
 
     page: Optional[int]
     """
-    The page number for the returned clusters
+    Page number to return for clusters, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    The maximum number of clusters per page
+    Maximum number of clusters per page.
     """
 
     name: Optional[str]
     """
-    The name on which to filter the returned clusters
+    Name to filter on, only clusters containing this substring in their name will be returned.
     """
 
     status: Optional[ClusterStatus]
     """
-    The status on which to filter the returned clusters
+    Status to filter on, only clusters with this status will be returned.
     """
 
     type_: Optional[str]
     """
-    The type on which to filter the returned clusters
+    Type to filter on, only clusters with this type will be returned.
     """
 
 
 @dataclass
 class CreateClusterRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     organization_id: Optional[str]
     """
-    The organization ID where the cluster will be created.
+    Organization ID in which the cluster will be created.
     
     One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
     :deprecated
     """
 
     project_id: Optional[str]
     """
-    The project ID where the cluster will be created.
+    Project ID in which the cluster will be created.
     
     One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
     """
 
     type_: str
     """
-    The type of the cluster (possible values are kapsule, multicloud).
+    Type of the cluster (possible values are kapsule, multicloud, kapsule-dedicated-8, kapsule-dedicated-16).
     """
 
     name: Optional[str]
     """
-    The name of the cluster
+    Cluster name.
     """
 
     description: str
     """
-    The description of the cluster
+    Cluster description.
     """
 
     tags: Optional[List[str]]
     """
-    The tags associated with the cluster
+    Tags associated with the cluster.
     """
 
     version: str
     """
-    The Kubernetes version of the cluster
+    Kubernetes version of the cluster.
     """
 
     cni: Optional[CNI]
     """
-    The Container Network Interface (CNI) plugin that will run in the cluster
+    Container Network Interface (CNI) plugin running in the cluster.
     """
 
     enable_dashboard: Optional[bool]
     """
-    The enablement of the Kubernetes Dashboard in the cluster
+    Defines whether the Kubernetes Dashboard is enabled in the cluster.
     :deprecated
     """
 
     ingress: Optional[Ingress]
     """
-    The Ingress Controller that will run in the cluster
+    Ingress Controller running in the cluster (deprecated feature).
     :deprecated
     """
 
     pools: Optional[List[CreateClusterRequestPoolConfig]]
     """
-    The pools to be created along with the cluster
+    Pools created along with the cluster.
     """
 
     autoscaler_config: Optional[CreateClusterRequestAutoscalerConfig]
     """
-    This field allows to specify some configuration for the autoscaler, which is an implementation of the [cluster-autoscaler](https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler/).
+    Autoscaler configuration for the cluster. It allows you to set (to an extent) your preferred autoscaler configuration, which is an implementation of the cluster-autoscaler (https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler/).
     """
 
     auto_upgrade: Optional[CreateClusterRequestAutoUpgrade]
     """
-    This configuration enables to set a specific 2-hour time window in which the cluster can be automatically updated to the latest patch version in the current minor one.
+    Auto upgrade configuration of the cluster. This configuration enables to set a specific 2-hour time window in which the cluster can be automatically updated to the latest patch version.
     """
 
     feature_gates: Optional[List[str]]
     """
-    List of feature gates to enable
+    List of feature gates to enable.
     """
 
     admission_plugins: Optional[List[str]]
     """
-    List of admission plugins to enable
+    List of admission plugins to enable.
     """
 
     open_id_connect_config: Optional[CreateClusterRequestOpenIDConnectConfig]
     """
-    This feature is in ALPHA state, it may be deleted or modified. This configuration enables to set the [OpenID Connect configuration](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens) of the Kubernetes API server.
+    OpenID Connect configuration of the cluster. This configuration enables to update the OpenID Connect configuration of the Kubernetes API server.
     """
 
     apiserver_cert_sans: Optional[List[str]]
     """
-    Additional Subject Alternative Names for the Kubernetes API server certificate
+    Additional Subject Alternative Names for the Kubernetes API server certificate.
+    """
+
+    private_network_id: Optional[str]
+    """
+    Private network ID for internal cluster communication (cannot be changed later).
     """
 
 
 @dataclass
 class GetClusterRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     cluster_id: str
     """
-    The ID of the requested cluster
+    ID of the requested cluster.
     """
 
 
 @dataclass
 class UpdateClusterRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     cluster_id: str
     """
-    The ID of the cluster to update
+    ID of the cluster to update.
     """
 
     name: Optional[str]
     """
-    This field allows to update the external name of the cluster. The internal name (used for instance in hostname) won't change.
+    New external name for the cluster.
     """
 
     description: Optional[str]
     """
-    The new description of the cluster
+    New description for the cluster.
     """
 
     tags: Optional[List[str]]
     """
-    The new tags associated with the cluster
+    New tags associated with the cluster.
     """
 
     autoscaler_config: Optional[UpdateClusterRequestAutoscalerConfig]
     """
-    This field allows to update some configuration for the autoscaler, which is an implementation of the [cluster-autoscaler](https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler/).
+    New autoscaler config for the cluster.
     """
 
     enable_dashboard: Optional[bool]
     """
-    The new value of the Kubernetes Dashboard enablement
+    New value for the Kubernetes Dashboard enablement.
     :deprecated
     """
 
     ingress: Optional[Ingress]
     """
-    The new Ingress Controller for the cluster
+    New Ingress Controller for the cluster (deprecated feature).
     :deprecated
     """
 
     auto_upgrade: Optional[UpdateClusterRequestAutoUpgrade]
     """
-    The new auto upgrade configuration of the cluster. Note that all fields need to be set.
+    New auto upgrade configuration for the cluster. Note that all fields need to be set.
     """
 
     feature_gates: Optional[List[str]]
     """
-    List of feature gates to enable
+    List of feature gates to enable.
     """
 
     admission_plugins: Optional[List[str]]
     """
-    List of admission plugins to enable
+    List of admission plugins to enable.
     """
 
     open_id_connect_config: Optional[UpdateClusterRequestOpenIDConnectConfig]
     """
-    This feature is in ALPHA state, it may be deleted or modified. This configuration enables to update the [OpenID Connect configuration](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens) of the Kubernetes API server.
+    OpenID Connect configuration of the cluster. This configuration enables to update the OpenID Connect configuration of the Kubernetes API server.
     """
 
     apiserver_cert_sans: Optional[List[str]]
     """
-    Additional Subject Alternative Names for the Kubernetes API server certificate
+    Additional Subject Alternative Names for the Kubernetes API server certificate.
     """
 
 
 @dataclass
 class DeleteClusterRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     cluster_id: str
     """
-    The ID of the cluster to delete
+    ID of the cluster to delete.
     """
 
     with_additional_resources: bool
     """
-    Set true if you want to delete all volumes (including retain volume type) and loadbalancers whose name start with cluster ID
+    Defines whether all volumes (including retain volume type), empty Private Networks and Load Balancers with a name starting with the cluster ID will also be deleted.
     """
 
 
 @dataclass
 class UpgradeClusterRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     cluster_id: str
     """
-    The ID of the cluster to upgrade
+    ID of the cluster to upgrade.
     """
 
     version: str
     """
-    The new Kubernetes version of the cluster. Note that the version shoud either be a higher patch version of the same minor version or the direct minor version after the current one.
+    New Kubernetes version of the cluster. Note that the version should either be a higher patch version of the same minor version or the direct minor version after the current one.
     """
 
     upgrade_pools: bool
     """
-    This field makes the upgrade upgrades the pool once the Kubernetes master in upgrade.
+    Defines whether pools will also be upgraded once the control plane is upgraded.
+    """
+
+
+@dataclass
+class SetClusterTypeRequest:
+    region: Optional[Region]
+    """
+    Region to target. If none is passed will use default region from the config.
+    """
+
+    cluster_id: str
+    """
+    ID of the cluster to migrate from one type to another.
+    """
+
+    type_: str
+    """
+    Type of the cluster. Note that some migrations are not possible (please refer to product documentation).
     """
 
 
 @dataclass
 class ListClusterAvailableVersionsRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     cluster_id: str
     """
-    The ID of the cluster which the available Kuberentes versions will be listed from
+    Cluster ID for which the available Kubernetes versions will be listed.
+    """
+
+
+@dataclass
+class ListClusterAvailableTypesRequest:
+    region: Optional[Region]
+    """
+    Region to target. If none is passed will use default region from the config.
+    """
+
+    cluster_id: str
+    """
+    Cluster ID for which the available Kubernetes types will be listed.
     """
 
 
 @dataclass
 class ResetClusterAdminTokenRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
+    """
+
+    cluster_id: str
+    """
+    Cluster ID on which the admin token will be renewed.
+    """
+
+
+@dataclass
+class MigrateToPrivateNetworkClusterRequest:
+    region: Optional[Region]
+    """
+    Region to target. If none is passed will use default region from the config.
     """
 
     cluster_id: str
     """
-    The ID of the cluster of which the admin token will be renewed
+    ID of the cluster to migrate.
+    """
+
+    private_network_id: str
+    """
+    ID of the Private Network to link to the cluster.
     """
 
 
 @dataclass
 class ListPoolsRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     cluster_id: str
     """
-    The ID of the cluster from which the pools will be listed from
+    ID of the cluster whose pools will be listed.
     """
 
     order_by: Optional[ListPoolsRequestOrderBy]
     """
-    The sort order of the returned pools
+    Sort order of returned pools.
     """
 
     page: Optional[int]
     """
-    The page number for the returned pools
+    Page number for the returned pools.
     """
 
     page_size: Optional[int]
     """
-    The maximum number of pools per page
+    Maximum number of pools per page.
     """
 
     name: Optional[str]
     """
-    The name on which to filter the returned pools
+    Name to filter on, only pools containing this substring in their name will be returned.
     """
 
     status: Optional[PoolStatus]
     """
-    The status on which to filter the returned pools
+    Status to filter on, only pools with this status will be returned.
     """
 
 
 @dataclass
 class CreatePoolRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     cluster_id: str
     """
-    The ID of the cluster in which the pool will be created
+    Cluster ID to which the pool will be attached.
     """
 
     name: Optional[str]
     """
-    The name of the pool
+    Pool name.
     """
 
     node_type: str
     """
-    The node type is the type of Scaleway Instance wanted for the pool. Nodes with insufficient memory are not eligible (DEV1-S, PLAY2-PICO, STARDUST). 'external' is a special node type used to provision instances from other cloud providers.
+    Node type is the type of Scaleway Instance wanted for the pool. Nodes with insufficient memory are not eligible (DEV1-S, PLAY2-PICO, STARDUST). 'external' is a special node type used to provision instances from other cloud providers in a Kosmos Cluster.
     """
 
     placement_group_id: Optional[str]
     """
-    The placement group ID in which all the nodes of the pool will be created
+    Placement group ID in which all the nodes of the pool will be created.
     """
 
     autoscaling: bool
     """
-    The enablement of the autoscaling feature for the pool
+    Defines whether the autoscaling feature is enabled for the pool.
     """
 
     size: int
     """
-    The size (number of nodes) of the pool
+    Size (number of nodes) of the pool.
     """
 
     min_size: Optional[int]
     """
-    The minimum size of the pool. Note that this field will be used only when autoscaling is enabled.
+    Defines the minimum size of the pool. Note that this field is only used when autoscaling is enabled on the pool.
     """
 
     max_size: Optional[int]
     """
-    The maximum size of the pool. Note that this field will be used only when autoscaling is enabled.
+    Defines the maximum size of the pool. Note that this field is only used when autoscaling is enabled on the pool.
     """
 
     container_runtime: Runtime
     """
-    The customization of the container runtime is available for each pool. Note that `docker` is deprecated since 1.20 and will be removed in 1.24.
-    
+    Customization of the container runtime is available for each pool. Note that `docker` has been deprecated since version 1.20 and will be removed by version 1.24.
     """
 
     autohealing: bool
     """
-    The enablement of the autohealing feature for the pool
+    Defines whether the autohealing feature is enabled for the pool.
     """
 
     tags: Optional[List[str]]
     """
-    The tags associated with the pool
+    Tags associated with the pool.
     """
 
     kubelet_args: Optional[Dict[str, str]]
     """
-    The Kubelet arguments to be used by this pool. Note that this feature is to be considered as experimental
+    Kubelet arguments to be used by this pool. Note that this feature is experimental.
     """
 
     upgrade_policy: Optional[CreatePoolRequestUpgradePolicy]
     """
-    The Pool upgrade policy
+    Pool upgrade policy.
     """
 
     zone: Optional[Zone]
     """
-    The Zone in which the Pool's node will be spawn in
+    Zone in which the pool's nodes will be spawned.
     """
 
     root_volume_type: PoolVolumeType
     """
-    The system volume disk type, we provide two different types of volume (`volume_type`):
-      - `l_ssd` is a local block storage: your system is stored locally on
-        the hypervisor of your node.
-      - `b_ssd` is a remote block storage: your system is stored on a
-        centralised and resilient cluster.
-    
+    Defines the system volume disk type. Two different types of volume (`volume_type`) are provided: `l_ssd` is a local block storage which means your system is stored locally on your node's hypervisor. `b_ssd` is a remote block storage which means your system is stored on a centralized and resilient cluster.
     """
 
     root_volume_size: Optional[int]
     """
-    The system volume disk size
+    System volume disk size.
     """
 
 
 @dataclass
 class GetPoolRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     pool_id: str
     """
-    The ID of the requested pool
+    ID of the requested pool.
     """
 
 
 @dataclass
 class UpgradePoolRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     pool_id: str
     """
-    The ID of the pool to upgrade
+    ID of the pool to upgrade.
     """
 
     version: str
     """
-    The new Kubernetes version for the pool
+    New Kubernetes version for the pool.
     """
 
 
 @dataclass
 class UpdatePoolRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     pool_id: str
     """
-    The ID of the pool to update
+    ID of the pool to update.
     """
 
     autoscaling: Optional[bool]
     """
-    The new value for the enablement of autoscaling for the pool
+    New value for the pool autoscaling enablement.
     """
 
     size: Optional[int]
     """
-    The new size for the pool
+    New desired pool size.
     """
 
     min_size: Optional[int]
     """
-    The new minimun size for the pool
+    New minimum size for the pool.
     """
 
     max_size: Optional[int]
     """
-    The new maximum size for the pool
+    New maximum size for the pool.
     """
 
     autohealing: Optional[bool]
     """
-    The new value for the enablement of autohealing for the pool
+    New value for the pool autohealing enablement.
     """
 
     tags: Optional[List[str]]
     """
-    The new tags associated with the pool
+    New tags associated with the pool.
     """
 
     kubelet_args: Optional[Dict[str, str]]
     """
-    The new Kubelet arguments to be used by this pool. Note that this feature is to be considered as experimental
+    New Kubelet arguments to be used by this pool. Note that this feature is experimental.
     """
 
     upgrade_policy: Optional[UpdatePoolRequestUpgradePolicy]
     """
-    The Pool upgrade policy
+    New upgrade policy for the pool.
     """
 
 
 @dataclass
 class DeletePoolRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     pool_id: str
     """
-    The ID of the pool to delete
+    ID of the pool to delete.
     """
 
 
 @dataclass
 class CreateExternalNodeRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     pool_id: str
 
 
 @dataclass
 class ListNodesRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     cluster_id: str
     """
-    The cluster ID from which the nodes will be listed from
+    Cluster ID from which the nodes will be listed from.
     """
 
     pool_id: Optional[str]
     """
-    The pool ID on which to filter the returned nodes
+    Pool ID on which to filter the returned nodes.
     """
 
     order_by: Optional[ListNodesRequestOrderBy]
     """
-    The sort order of the returned nodes
+    Sort order of the returned nodes.
     """
 
     page: Optional[int]
     """
-    The page number for the returned nodes
+    Page number for the returned nodes.
     """
 
     page_size: Optional[int]
     """
-    The maximum number of nodes per page
+    Maximum number of nodes per page.
     """
 
     name: Optional[str]
     """
-    The name on which to filter the returned nodes
+    Name to filter on, only nodes containing this substring in their name will be returned.
     """
 
     status: Optional[NodeStatus]
     """
-    The status on which to filter the returned nodes
+    Status to filter on, only nodes with this status will be returned.
     """
 
 
 @dataclass
 class GetNodeRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     node_id: str
     """
-    The ID of the requested node
+    ID of the requested node.
     """
 
 
 @dataclass
 class ReplaceNodeRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     node_id: str
     """
-    The ID of the node to replace
+    ID of the node to replace.
     """
 
 
 @dataclass
 class RebootNodeRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     node_id: str
     """
-    The ID of the node to reboot
+    ID of the node to reboot.
     """
 
 
 @dataclass
 class DeleteNodeRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     node_id: str
     """
-    The ID of the node to replace
+    ID of the node to replace.
     """
 
     skip_drain: bool
     """
-    Skip draining node from its workload
+    Skip draining node from its workload.
     """
 
     replace: bool
     """
-    Add a new node after the deletion of this node
+    Add a new node after the deletion of this node.
     """
 
 
 @dataclass
 class ListVersionsRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
 
 @dataclass
 class GetVersionRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     version_name: str
     """
-    The requested version name
+    Requested version name.
+    """
+
+
+@dataclass
+class ListClusterTypesRequest:
+    region: Optional[Region]
+    """
+    Region to target. If none is passed will use default region from the config.
+    """
+
+    page: Optional[int]
+    """
+    Page number, from the paginated results, to return for cluster-types.
+    """
+
+    page_size: Optional[int]
+    """
+    Maximum number of clusters per page.
     """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/k8s/v1/types_private.py` & `scaleway_async-1.0.0/scaleway_async/k8s/v1/types_private.py`

 * *Files 26% similar despite different names*

```diff
@@ -10,14 +10,14 @@
 )
 
 
 @dataclass
 class _GetClusterKubeConfigRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     cluster_id: str
     """
-    The ID of the cluster to download the kubeconfig from
+    Cluster ID for which to download the kubeconfig.
     """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/lb/v1/__init__.py` & `scaleway_async-1.0.0/scaleway_async/lb/v1/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-0.9.0/scaleway_async/lb/v1/api.py` & `scaleway_async-1.0.0/scaleway_async/lb/v1/api.py`

 * *Files 17% similar despite different names*

```diff
@@ -200,36 +200,37 @@
 
 
 class LbV1API(API):
     """
     Load balancer API.
 
     This API allows you to manage your load balancer service.
+    Load balancer API.
     """
 
     async def list_lbs(
         self,
         *,
         region: Optional[Region] = None,
         name: Optional[str] = None,
         order_by: ListLbsRequestOrderBy = ListLbsRequestOrderBy.CREATED_AT_ASC,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> ListLbsResponse:
         """
-        List load balancers
-        :param region: Region to target. If none is passed will use default region from the config
-        :param name: Use this to search by name
-        :param order_by: Response order
-        :param page_size: The number of items to return
-        :param page: Page number
-        :param organization_id: Filter LBs by organization ID
-        :param project_id: Filter LBs by project ID
+        List load balancers.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param name: Load Balancer name to filter for.
+        :param order_by: Sort order of Load Balancers in the response.
+        :param page_size: Number of Load Balancers to return.
+        :param page: Page number to return, from the paginated results.
+        :param organization_id: Organization ID to filter for, only Load Balancers from this Organization will be returned.
+        :param project_id: Project ID to filter for, only Load Balancers from this Project will be returned.
         :return: :class:`ListLbsResponse <ListLbsResponse>`
 
         Usage:
         ::
 
             result = await api.list_lbs()
         """
@@ -263,22 +264,22 @@
         order_by: Optional[ListLbsRequestOrderBy] = None,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> List[Lb]:
         """
-        List load balancers
-        :param region: Region to target. If none is passed will use default region from the config
-        :param name: Use this to search by name
-        :param order_by: Response order
-        :param page_size: The number of items to return
-        :param page: Page number
-        :param organization_id: Filter LBs by organization ID
-        :param project_id: Filter LBs by project ID
+        List load balancers.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param name: Load Balancer name to filter for.
+        :param order_by: Sort order of Load Balancers in the response.
+        :param page_size: Number of Load Balancers to return.
+        :param page: Page number to return, from the paginated results.
+        :param organization_id: Organization ID to filter for, only Load Balancers from this Organization will be returned.
+        :param project_id: Project ID to filter for, only Load Balancers from this Project will be returned.
         :return: :class:`List[ListLbsResponse] <List[ListLbsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_lbs_all()
         """
@@ -305,35 +306,33 @@
         type_: str,
         ssl_compatibility_level: SSLCompatibilityLevel,
         region: Optional[Region] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         name: Optional[str] = None,
         ip_id: Optional[str] = None,
+        assign_flexible_ip: Optional[bool] = None,
         tags: Optional[List[str]] = None,
     ) -> Lb:
         """
-        Create a load balancer
-        :param region: Region to target. If none is passed will use default region from the config
-        :param organization_id: Owner of resources.
+        Create a load balancer.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param organization_id: Scaleway Organization to create the Load Balancer in.
 
         One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
-        :param project_id: Assign the resource to a project ID.
+        :param project_id: Scaleway Project to create the Load Balancer in.
 
         One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
-        :param name: Resource names
-        :param description: Resource description
-        :param ip_id: Just like for compute instances, when you destroy a load balancer, you can keep its highly available IP address and reuse it for another load balancer later
-        :param tags: List of keyword
-        :param type_: Load balancer offer type
-        :param ssl_compatibility_level: Enforces minimal SSL version (in SSL/TLS offloading context).
-        - `intermediate` General-purpose servers with a variety of clients, recommended for almost all systems (Supports Firefox 27, Android 4.4.2, Chrome 31, Edge, IE 11 on Windows 7, Java 8u31, OpenSSL 1.0.1, Opera 20, and Safari 9).
-        - `modern` Services with clients that support TLS 1.3 and don't need backward compatibility (Firefox 63, Android 10.0, Chrome 70, Edge 75, Java 11, OpenSSL 1.1.1, Opera 57, and Safari 12.1).
-        - `old` Compatible with a number of very old clients, and should be used only as a last resort (Firefox 1, Android 2.3, Chrome 1, Edge 12, IE8 on Windows XP, Java 6, OpenSSL 0.9.8, Opera 5, and Safari 1).
-
+        :param name: Name for the Load Balancer.
+        :param description: Description for the Load Balancer.
+        :param ip_id: ID of an existing flexible IP address to attach to the Load Balancer.
+        :param assign_flexible_ip: Defines whether to automatically assign a flexible public IP to lb. Default value is `false` (do not assign).
+        :param tags: List of tags for the Load Balancer.
+        :param type_: Load Balancer commercial offer type. Use the Load Balancer types endpoint to retrieve a list of available offer types.
+        :param ssl_compatibility_level: Determines the minimal SSL version which needs to be supported on the client side, in an SSL/TLS offloading context. Intermediate is suitable for general-purpose servers with a variety of clients, recommended for almost all systems. Modern is suitable for services with clients that support TLS 1.3 and do not need backward compatibility. Old is compatible with a small number of very old clients and should be used only as a last resort.
         :return: :class:`Lb <Lb>`
 
         Usage:
         ::
 
             result = await api.create_lb(
                 description="example",
@@ -355,14 +354,15 @@
                     type_=type_,
                     ssl_compatibility_level=ssl_compatibility_level,
                     region=region,
                     organization_id=organization_id,
                     project_id=project_id,
                     name=name or random_name(prefix="lb"),
                     ip_id=ip_id,
+                    assign_flexible_ip=assign_flexible_ip,
                     tags=tags,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
@@ -371,17 +371,17 @@
     async def get_lb(
         self,
         *,
         lb_id: str,
         region: Optional[Region] = None,
     ) -> Lb:
         """
-        Get a load balancer
-        :param region: Region to target. If none is passed will use default region from the config
-        :param lb_id: Load balancer ID
+        Get a load balancer.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: Load Balancer ID.
         :return: :class:`Lb <Lb>`
 
         Usage:
         ::
 
             result = await api.get_lb(lb_id="example")
         """
@@ -404,16 +404,16 @@
         *,
         lb_id: str,
         region: Optional[Region] = None,
         options: Optional[WaitForOptions[Lb, Union[bool, Awaitable[bool]]]] = None,
     ) -> Lb:
         """
         Waits for :class:`Lb <Lb>` to be in a final state.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param lb_id: Load balancer ID
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: Load Balancer ID.
         :param options: The options for the waiter
         :return: :class:`Lb <Lb>`
 
         Usage:
         ::
 
             result = api.wait_for_lb(lb_id="example")
@@ -441,25 +441,21 @@
         name: str,
         description: str,
         ssl_compatibility_level: SSLCompatibilityLevel,
         region: Optional[Region] = None,
         tags: Optional[List[str]] = None,
     ) -> Lb:
         """
-        Update a load balancer
-        :param region: Region to target. If none is passed will use default region from the config
-        :param lb_id: Load balancer ID
-        :param name: Resource name
-        :param description: Resource description
-        :param tags: List of keywords
-        :param ssl_compatibility_level: Enforces minimal SSL version (in SSL/TLS offloading context).
-        - `intermediate` General-purpose servers with a variety of clients, recommended for almost all systems (Supports Firefox 27, Android 4.4.2, Chrome 31, Edge, IE 11 on Windows 7, Java 8u31, OpenSSL 1.0.1, Opera 20, and Safari 9).
-        - `modern` Services with clients that support TLS 1.3 and don't need backward compatibility (Firefox 63, Android 10.0, Chrome 70, Edge 75, Java 11, OpenSSL 1.1.1, Opera 57, and Safari 12.1).
-        - `old` Compatible with a number of very old clients, and should be used only as a last resort (Firefox 1, Android 2.3, Chrome 1, Edge 12, IE8 on Windows XP, Java 6, OpenSSL 0.9.8, Opera 5, and Safari 1).
-
+        Update a load balancer.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: Load Balancer ID.
+        :param name: Load Balancer name.
+        :param description: Load Balancer description.
+        :param tags: List of tags for the Load Balancer.
+        :param ssl_compatibility_level: Determines the minimal SSL version which needs to be supported on the client side, in an SSL/TLS offloading context. Intermediate is suitable for general-purpose servers with a variety of clients, recommended for almost all systems. Modern is suitable for services with clients that support TLS 1.3 and don't need backward compatibility. Old is compatible with a small number of very old clients and should be used only as a last resort.
         :return: :class:`Lb <Lb>`
 
         Usage:
         ::
 
             result = await api.update_lb(
                 lb_id="example",
@@ -497,18 +493,18 @@
         self,
         *,
         lb_id: str,
         release_ip: bool,
         region: Optional[Region] = None,
     ) -> Optional[None]:
         """
-        Delete a load balancer
-        :param region: Region to target. If none is passed will use default region from the config
-        :param lb_id: Load balancer ID
-        :param release_ip: Set true if you don't want to keep this IP address
+        Delete a load balancer.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: ID of the Load Balancer to delete.
+        :param release_ip: Defines whether the Load Balancer's flexible IP should be deleted. Set to true to release the flexible IP, or false to keep it available in your account for future Load Balancers.
 
         Usage:
         ::
 
             result = await api.delete_lb(
                 lb_id="example",
                 release_ip=True,
@@ -535,18 +531,18 @@
         self,
         *,
         lb_id: str,
         type_: str,
         region: Optional[Region] = None,
     ) -> Lb:
         """
-        Migrate a load balancer
-        :param region: Region to target. If none is passed will use default region from the config
-        :param lb_id: Load balancer ID
-        :param type_: Load balancer type (check /lb-types to list all type)
+        Migrate a load balancer.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: Load Balancer ID.
+        :param type_: Load Balancer type to migrate to (use the List all Load Balancer offer types endpoint to get a list of available offer types).
         :return: :class:`Lb <Lb>`
 
         Usage:
         ::
 
             result = await api.migrate_lb(
                 lb_id="example",
@@ -582,21 +578,21 @@
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         ip_address: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> ListIpsResponse:
         """
-        List IPs
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page: Page number
-        :param page_size: The number of items to return
-        :param ip_address: Use this to search by IP address
-        :param organization_id: Filter IPs by organization id
-        :param project_id: Filter IPs by project ID
+        List IPs.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: Number of IP addresses to return.
+        :param ip_address: IP address to filter for.
+        :param organization_id: Organization ID to filter for, only Load Balancer IP addresses from this Organization will be returned.
+        :param project_id: Project ID to filter for, only Load Balancer IP addresses from this Project will be returned.
         :return: :class:`ListIpsResponse <ListIpsResponse>`
 
         Usage:
         ::
 
             result = await api.list_i_ps()
         """
@@ -628,21 +624,21 @@
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         ip_address: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> List[Ip]:
         """
-        List IPs
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page: Page number
-        :param page_size: The number of items to return
-        :param ip_address: Use this to search by IP address
-        :param organization_id: Filter IPs by organization id
-        :param project_id: Filter IPs by project ID
+        List IPs.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: Number of IP addresses to return.
+        :param ip_address: IP address to filter for.
+        :param organization_id: Organization ID to filter for, only Load Balancer IP addresses from this Organization will be returned.
+        :param project_id: Project ID to filter for, only Load Balancer IP addresses from this Project will be returned.
         :return: :class:`List[ListIpsResponse] <List[ListIpsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_i_ps_all()
         """
@@ -666,23 +662,23 @@
         *,
         region: Optional[Region] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         reverse: Optional[str] = None,
     ) -> Ip:
         """
-        Create an IP
-        :param region: Region to target. If none is passed will use default region from the config
-        :param organization_id: Owner of resources.
+        Create an IP.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param organization_id: Organization ID of the Organization where the IP address should be created.
 
         One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
-        :param project_id: Assign the resource to a project ID.
+        :param project_id: Project ID of the Project where the IP address should be created.
 
         One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
-        :param reverse: Reverse domain name
+        :param reverse: Reverse DNS (domain name) for the IP address.
         :return: :class:`Ip <Ip>`
 
         Usage:
         ::
 
             result = await api.create_ip()
         """
@@ -711,17 +707,17 @@
     async def get_ip(
         self,
         *,
         ip_id: str,
         region: Optional[Region] = None,
     ) -> Ip:
         """
-        Get an IP
-        :param region: Region to target. If none is passed will use default region from the config
-        :param ip_id: IP address ID
+        Get an IP.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param ip_id: IP address ID.
         :return: :class:`Ip <Ip>`
 
         Usage:
         ::
 
             result = await api.get_ip(ip_id="example")
         """
@@ -742,17 +738,17 @@
     async def release_ip(
         self,
         *,
         ip_id: str,
         region: Optional[Region] = None,
     ) -> Optional[None]:
         """
-        Delete an IP
-        :param region: Region to target. If none is passed will use default region from the config
-        :param ip_id: IP address ID
+        Delete an IP.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param ip_id: IP address ID.
 
         Usage:
         ::
 
             result = await api.release_ip(ip_id="example")
         """
 
@@ -773,18 +769,18 @@
         self,
         *,
         ip_id: str,
         region: Optional[Region] = None,
         reverse: Optional[str] = None,
     ) -> Ip:
         """
-        Update an IP
-        :param region: Region to target. If none is passed will use default region from the config
-        :param ip_id: IP address ID
-        :param reverse: Reverse DNS
+        Update an IP.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param ip_id: IP address ID.
+        :param reverse: Reverse DNS (domain name) for the IP address.
         :return: :class:`Ip <Ip>`
 
         Usage:
         ::
 
             result = await api.update_ip(ip_id="example")
         """
@@ -817,21 +813,21 @@
         region: Optional[Region] = None,
         name: Optional[str] = None,
         order_by: ListBackendsRequestOrderBy = ListBackendsRequestOrderBy.CREATED_AT_ASC,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListBackendsResponse:
         """
-        List backends in a given load balancer
-        :param region: Region to target. If none is passed will use default region from the config
-        :param lb_id: Load balancer ID
-        :param name: Use this to search by name
-        :param order_by: Response order
-        :param page: Page number
-        :param page_size: The number of items to return
+        List backends in a given load balancer.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: Load Balancer ID.
+        :param name: Name of the backend to filter for.
+        :param order_by: Sort order of backends in the response.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: Number of backends to return.
         :return: :class:`ListBackendsResponse <ListBackendsResponse>`
 
         Usage:
         ::
 
             result = await api.list_backends(lb_id="example")
         """
@@ -862,21 +858,21 @@
         region: Optional[Region] = None,
         name: Optional[str] = None,
         order_by: Optional[ListBackendsRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[Backend]:
         """
-        List backends in a given load balancer
-        :param region: Region to target. If none is passed will use default region from the config
-        :param lb_id: Load balancer ID
-        :param name: Use this to search by name
-        :param order_by: Response order
-        :param page: Page number
-        :param page_size: The number of items to return
+        List backends in a given load balancer.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: Load Balancer ID.
+        :param name: Name of the backend to filter for.
+        :param order_by: Sort order of backends in the response.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: Number of backends to return.
         :return: :class:`List[ListBackendsResponse] <List[ListBackendsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_backends_all(lb_id="example")
         """
@@ -913,45 +909,44 @@
         send_proxy_v2: Optional[bool] = None,
         timeout_server: Optional[str] = None,
         timeout_connect: Optional[str] = None,
         timeout_tunnel: Optional[str] = None,
         failover_host: Optional[str] = None,
         ssl_bridging: Optional[bool] = None,
         ignore_ssl_server_verify: Optional[bool] = None,
+        redispatch_attempt_count: Optional[int] = None,
+        max_retries: Optional[int] = None,
+        max_connections: Optional[int] = None,
+        timeout_queue: Optional[str] = None,
     ) -> Backend:
         """
-        Create a backend in a given load balancer
-        :param region: Region to target. If none is passed will use default region from the config
-        :param lb_id: Load balancer ID
-        :param name: Resource name
-        :param forward_protocol: Backend protocol. TCP or HTTP
-        :param forward_port: User sessions will be forwarded to this port of backend servers
-        :param forward_port_algorithm: Load balancing algorithm
-        :param sticky_sessions: Enables cookie-based session persistence
-        :param sticky_sessions_cookie_name: Cookie name for sticky sessions
-        :param health_check: See the Healthcheck object description
-        :param server_ip: Backend server IP addresses list (IPv4 or IPv6)
-        :param send_proxy_v2: Deprecated in favor of proxy_protocol field !
-        :param timeout_server: Maximum server connection inactivity time (allowed time the server has to process the request)
-        :param timeout_connect: Maximum initial server connection establishment time
-        :param timeout_tunnel: Maximum tunnel inactivity time after Websocket is established (take precedence over client and server timeout)
-        :param on_marked_down_action: Modify what occurs when a backend server is marked down
-        :param proxy_protocol: The PROXY protocol informs the other end about the incoming connection, so that it can know the client's address or the public address it accessed to, whatever the upper layer protocol.
-
-        * `proxy_protocol_none` Disable proxy protocol.
-        * `proxy_protocol_v1` Version one (text format).
-        * `proxy_protocol_v2` Version two (binary format).
-        * `proxy_protocol_v2_ssl` Version two with SSL connection.
-        * `proxy_protocol_v2_ssl_cn` Version two with SSL connection and common name information.
-
-        :param failover_host: Only the host part of the Scaleway S3 bucket website is expected.
-        E.g. `failover-website.s3-website.fr-par.scw.cloud` if your bucket website URL is `https://failover-website.s3-website.fr-par.scw.cloud/`.
-
-        :param ssl_bridging: Enable SSL between load balancer and backend servers
-        :param ignore_ssl_server_verify: Set to true to ignore server certificate verification
+        Create a backend in a given load balancer.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: Load Balancer ID.
+        :param name: Name for the backend.
+        :param forward_protocol: Protocol to be used by the backend when forwarding traffic to backend servers.
+        :param forward_port: Port to be used by the backend when forwarding traffic to backend servers.
+        :param forward_port_algorithm: Load balancing algorithm to be used when determining which backend server to forward new traffic to.
+        :param sticky_sessions: Defines whether to activate sticky sessions (binding a particular session to a particular backend server) and the method to use if so. None disables sticky sessions. Cookie-based uses an HTTP cookie TO stick a session to a backend server. Table-based uses the source (client) IP address to stick a session to a backend server.
+        :param sticky_sessions_cookie_name: Cookie name for cookie-based sticky sessions.
+        :param health_check: Object defining the health check to be carried out by the backend when checking the status and health of backend servers.
+        :param server_ip: List of backend server IP addresses (IPv4 or IPv6) the backend should forward traffic to.
+        :param send_proxy_v2: Deprecated in favor of proxy_protocol field.
+        :param timeout_server: Maximum allowed time for a backend server to process a request.
+        :param timeout_connect: Maximum allowed time for establishing a connection to a backend server.
+        :param timeout_tunnel: Maximum allowed tunnel inactivity time after Websocket is established (takes precedence over client and server timeout).
+        :param on_marked_down_action: Action to take when a backend server is marked as down.
+        :param proxy_protocol: Protocol to use between the Load Balancer and backend servers. Allows the backend servers to be informed of the client's real IP address. The PROXY protocol must be supported by the backend servers' software.
+        :param failover_host: Scaleway S3 bucket website to be served as failover if all backend servers are down, e.g. failover-website.s3-website.fr-par.scw.cloud.
+        :param ssl_bridging: Defines whether to enable SSL bridging between the Load Balancer and backend servers.
+        :param ignore_ssl_server_verify: Defines whether the server certificate verification should be ignored.
+        :param redispatch_attempt_count: Whether to use another backend server on each attempt.
+        :param max_retries: Number of retries when a backend server connection failed.
+        :param max_connections: Maximum number of connections allowed per backend server.
+        :param timeout_queue: Maximum time for a request to be left pending in queue when `max_connections` is reached.
         :return: :class:`Backend <Backend>`
 
         Usage:
         ::
 
             result = await api.create_backend(
                 lb_id="example",
@@ -989,14 +984,18 @@
                     send_proxy_v2=send_proxy_v2,
                     timeout_server=timeout_server,
                     timeout_connect=timeout_connect,
                     timeout_tunnel=timeout_tunnel,
                     failover_host=failover_host,
                     ssl_bridging=ssl_bridging,
                     ignore_ssl_server_verify=ignore_ssl_server_verify,
+                    redispatch_attempt_count=redispatch_attempt_count,
+                    max_retries=max_retries,
+                    max_connections=max_connections,
+                    timeout_queue=timeout_queue,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_Backend(res.json())
@@ -1004,17 +1003,17 @@
     async def get_backend(
         self,
         *,
         backend_id: str,
         region: Optional[Region] = None,
     ) -> Backend:
         """
-        Get a backend in a given load balancer
-        :param region: Region to target. If none is passed will use default region from the config
-        :param backend_id: Backend ID
+        Get a backend in a given load balancer.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param backend_id: Backend ID.
         :return: :class:`Backend <Backend>`
 
         Usage:
         ::
 
             result = await api.get_backend(backend_id="example")
         """
@@ -1048,43 +1047,42 @@
         send_proxy_v2: Optional[bool] = None,
         timeout_server: Optional[str] = None,
         timeout_connect: Optional[str] = None,
         timeout_tunnel: Optional[str] = None,
         failover_host: Optional[str] = None,
         ssl_bridging: Optional[bool] = None,
         ignore_ssl_server_verify: Optional[bool] = None,
+        redispatch_attempt_count: Optional[int] = None,
+        max_retries: Optional[int] = None,
+        max_connections: Optional[int] = None,
+        timeout_queue: Optional[str] = None,
     ) -> Backend:
         """
-        Update a backend in a given load balancer
-        :param region: Region to target. If none is passed will use default region from the config
-        :param backend_id: Backend ID to update
-        :param name: Resource name
-        :param forward_protocol: Backend protocol. TCP or HTTP
-        :param forward_port: User sessions will be forwarded to this port of backend servers
-        :param forward_port_algorithm: Load balancing algorithm
-        :param sticky_sessions: Enable cookie-based session persistence
-        :param sticky_sessions_cookie_name: Cookie name for sticky sessions
-        :param send_proxy_v2: Deprecated in favor of proxy_protocol field!
-        :param timeout_server: Maximum server connection inactivity time (allowed time the server has to process the request)
-        :param timeout_connect: Maximum initial server connection establishment time
-        :param timeout_tunnel: Maximum tunnel inactivity time after Websocket is established (take precedence over client and server timeout)
-        :param on_marked_down_action: Modify what occurs when a backend server is marked down
-        :param proxy_protocol: The PROXY protocol informs the other end about the incoming connection, so that it can know the client's address or the public address it accessed to, whatever the upper layer protocol is.
-
-        * `proxy_protocol_none` Disable proxy protocol.
-        * `proxy_protocol_v1` Version one (text format).
-        * `proxy_protocol_v2` Version two (binary format).
-        * `proxy_protocol_v2_ssl` Version two with SSL connection.
-        * `proxy_protocol_v2_ssl_cn` Version two with SSL connection and common name information.
-
-        :param failover_host: Only the host part of the Scaleway S3 bucket website is expected.
-        Example: `failover-website.s3-website.fr-par.scw.cloud` if your bucket website URL is `https://failover-website.s3-website.fr-par.scw.cloud/`.
-
-        :param ssl_bridging: Enable SSL between load balancer and backend servers
-        :param ignore_ssl_server_verify: Set to true to ignore server certificate verification
+        Update a backend in a given load balancer.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param backend_id: Backend ID.
+        :param name: Backend name.
+        :param forward_protocol: Protocol to be used by the backend when forwarding traffic to backend servers.
+        :param forward_port: Port to be used by the backend when forwarding traffic to backend servers.
+        :param forward_port_algorithm: Load balancing algorithm to be used when determining which backend server to forward new traffic to.
+        :param sticky_sessions: Defines whether to activate sticky sessions (binding a particular session to a particular backend server) and the method to use if so. None disables sticky sessions. Cookie-based uses an HTTP cookie to stick a session to a backend server. Table-based uses the source (client) IP address to stick a session to a backend server.
+        :param sticky_sessions_cookie_name: Cookie name for cookie-based sticky sessions.
+        :param send_proxy_v2: Deprecated in favor of proxy_protocol field.
+        :param timeout_server: Maximum allowed time for a backend server to process a request.
+        :param timeout_connect: Maximum allowed time for establishing a connection to a backend server.
+        :param timeout_tunnel: Maximum allowed tunnel inactivity time after Websocket is established (takes precedence over client and server timeout).
+        :param on_marked_down_action: Action to take when a backend server is marked as down.
+        :param proxy_protocol: Protocol to use between the Load Balancer and backend servers. Allows the backend servers to be informed of the client's real IP address. The PROXY protocol must be supported by the backend servers' software.
+        :param failover_host: Scaleway S3 bucket website to be served as failover if all backend servers are down, e.g. failover-website.s3-website.fr-par.scw.cloud.
+        :param ssl_bridging: Defines whether to enable SSL bridging between the Load Balancer and backend servers.
+        :param ignore_ssl_server_verify: Defines whether the server certificate verification should be ignored.
+        :param redispatch_attempt_count: Whether to use another backend server on each attempt.
+        :param max_retries: Number of retries when a backend server connection failed.
+        :param max_connections: Maximum number of connections allowed per backend server.
+        :param timeout_queue: Maximum time for a request to be left pending in queue when `max_connections` is reached.
         :return: :class:`Backend <Backend>`
 
         Usage:
         ::
 
             result = await api.update_backend(
                 backend_id="example",
@@ -1119,14 +1117,18 @@
                     send_proxy_v2=send_proxy_v2,
                     timeout_server=timeout_server,
                     timeout_connect=timeout_connect,
                     timeout_tunnel=timeout_tunnel,
                     failover_host=failover_host,
                     ssl_bridging=ssl_bridging,
                     ignore_ssl_server_verify=ignore_ssl_server_verify,
+                    redispatch_attempt_count=redispatch_attempt_count,
+                    max_retries=max_retries,
+                    max_connections=max_connections,
+                    timeout_queue=timeout_queue,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_Backend(res.json())
@@ -1134,17 +1136,17 @@
     async def delete_backend(
         self,
         *,
         backend_id: str,
         region: Optional[Region] = None,
     ) -> Optional[None]:
         """
-        Delete a backend in a given load balancer
-        :param region: Region to target. If none is passed will use default region from the config
-        :param backend_id: ID of the backend to delete
+        Delete a backend in a given load balancer.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param backend_id: ID of the backend to delete.
 
         Usage:
         ::
 
             result = await api.delete_backend(backend_id="example")
         """
 
@@ -1165,18 +1167,18 @@
         self,
         *,
         backend_id: str,
         server_ip: List[str],
         region: Optional[Region] = None,
     ) -> Backend:
         """
-        Add a set of servers in a given backend
-        :param region: Region to target. If none is passed will use default region from the config
-        :param backend_id: Backend ID
-        :param server_ip: Set all IPs to add on your backend
+        Add a set of servers in a given backend.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param backend_id: Backend ID.
+        :param server_ip: List of IP addresses to add to backend servers.
         :return: :class:`Backend <Backend>`
 
         Usage:
         ::
 
             result = await api.add_backend_servers(
                 backend_id="example",
@@ -1209,18 +1211,18 @@
         self,
         *,
         backend_id: str,
         server_ip: List[str],
         region: Optional[Region] = None,
     ) -> Backend:
         """
-        Remove a set of servers for a given backend
-        :param region: Region to target. If none is passed will use default region from the config
-        :param backend_id: Backend ID
-        :param server_ip: Set all IPs to remove of your backend
+        Remove a set of servers for a given backend.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param backend_id: Backend ID.
+        :param server_ip: List of IP addresses to remove from backend servers.
         :return: :class:`Backend <Backend>`
 
         Usage:
         ::
 
             result = await api.remove_backend_servers(
                 backend_id="example",
@@ -1253,18 +1255,18 @@
         self,
         *,
         backend_id: str,
         server_ip: List[str],
         region: Optional[Region] = None,
     ) -> Backend:
         """
-        Define all servers in a given backend
-        :param region: Region to target. If none is passed will use default region from the config
-        :param backend_id: Backend ID
-        :param server_ip: Set all IPs to add on your backend and remove all other
+        Define all servers in a given backend.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param backend_id: Backend ID.
+        :param server_ip: List of IP addresses for backend servers. Any other existing backend servers will be removed.
         :return: :class:`Backend <Backend>`
 
         Usage:
         ::
 
             result = await api.set_backend_servers(
                 backend_id="example",
@@ -1299,52 +1301,54 @@
         backend_id: str,
         port: int,
         check_delay: str,
         check_timeout: str,
         check_max_retries: int,
         check_send_proxy: bool,
         region: Optional[Region] = None,
+        tcp_config: Optional[HealthCheckTcpConfig] = None,
         mysql_config: Optional[HealthCheckMysqlConfig] = None,
+        pgsql_config: Optional[HealthCheckPgsqlConfig] = None,
         ldap_config: Optional[HealthCheckLdapConfig] = None,
         redis_config: Optional[HealthCheckRedisConfig] = None,
-        pgsql_config: Optional[HealthCheckPgsqlConfig] = None,
-        tcp_config: Optional[HealthCheckTcpConfig] = None,
         http_config: Optional[HealthCheckHttpConfig] = None,
         https_config: Optional[HealthCheckHttpsConfig] = None,
+        transient_check_delay: Optional[str] = None,
     ) -> HealthCheck:
         """
-        Update an health check for a given backend
-        :param region: Region to target. If none is passed will use default region from the config
-        :param backend_id: Backend ID
-        :param port: Specify the port used to health check
-        :param check_delay: Time between two consecutive health checks
-        :param check_timeout: Maximum time a backend server has to reply to the health check
-        :param check_max_retries: Number of consecutive unsuccessful health checks, after which the server will be considered dead
-        :param mysql_config: The check requires MySQL >=3.22, for older version, please use TCP check.
-
-        One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
-        :param ldap_config: The response is analyzed to find an LDAPv3 response message.
-
-        One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
-        :param redis_config: The response is analyzed to find the +PONG response message.
-
-        One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
-        :param pgsql_config: PostgreSQL health check.
-
-        One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
-        :param tcp_config: Basic TCP health check.
+        Update an health check for a given backend.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param backend_id: Backend ID.
+        :param port: Port to use for the backend server health check.
+        :param check_delay: Time to wait between two consecutive health checks.
+        :param check_timeout: Maximum time a backend server has to reply to the health check.
+        :param check_max_retries: Number of consecutive unsuccessful health checks after which the server will be considered dead.
+        :param check_send_proxy: Defines whether proxy protocol should be activated for the health check.
+        :param tcp_config: Object to configure a basic TCP health check.
+
+        One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
+        :param mysql_config: Object to configure a MySQL health check. The check requires MySQL >=3.22, for older versions, use a TCP health check.
+
+        One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
+        :param pgsql_config: Object to configure a PostgreSQL health check.
+
+        One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
+        :param ldap_config: Object to configure an LDAP health check. The response is analyzed to find the LDAPv3 response message.
+
+        One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
+        :param redis_config: Object to configure a Redis health check. The response is analyzed to find the +PONG response message.
 
-        One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
-        :param http_config: HTTP health check.
+        One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
+        :param http_config: Object to configure an HTTP health check.
 
-        One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
-        :param https_config: HTTPS health check.
+        One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
+        :param https_config: Object to configure an HTTPS health check.
 
-        One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
-        :param check_send_proxy: It defines whether the health check should be done considering the proxy protocol
+        One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
+        :param transient_check_delay: Time to wait between two consecutive health checks when a backend server is in a transient state (going UP or DOWN).
         :return: :class:`HealthCheck <HealthCheck>`
 
         Usage:
         ::
 
             result = await api.update_health_check(
                 backend_id="example",
@@ -1369,21 +1373,22 @@
                     backend_id=backend_id,
                     port=port,
                     check_delay=check_delay,
                     check_timeout=check_timeout,
                     check_max_retries=check_max_retries,
                     check_send_proxy=check_send_proxy,
                     region=region,
+                    tcp_config=tcp_config,
                     mysql_config=mysql_config,
+                    pgsql_config=pgsql_config,
                     ldap_config=ldap_config,
                     redis_config=redis_config,
-                    pgsql_config=pgsql_config,
-                    tcp_config=tcp_config,
                     http_config=http_config,
                     https_config=https_config,
+                    transient_check_delay=transient_check_delay,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_HealthCheck(res.json())
@@ -1395,21 +1400,21 @@
         region: Optional[Region] = None,
         name: Optional[str] = None,
         order_by: ListFrontendsRequestOrderBy = ListFrontendsRequestOrderBy.CREATED_AT_ASC,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListFrontendsResponse:
         """
-        List frontends in a given load balancer
-        :param region: Region to target. If none is passed will use default region from the config
-        :param lb_id: Load balancer ID
-        :param name: Use this to search by name
-        :param order_by: Response order
-        :param page: Page number
-        :param page_size: The number of items to return
+        List frontends in a given load balancer.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: Load Balancer ID.
+        :param name: Name of the frontend to filter for.
+        :param order_by: Sort order of frontends in the response.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: Number of frontends to return.
         :return: :class:`ListFrontendsResponse <ListFrontendsResponse>`
 
         Usage:
         ::
 
             result = await api.list_frontends(lb_id="example")
         """
@@ -1440,21 +1445,21 @@
         region: Optional[Region] = None,
         name: Optional[str] = None,
         order_by: Optional[ListFrontendsRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[Frontend]:
         """
-        List frontends in a given load balancer
-        :param region: Region to target. If none is passed will use default region from the config
-        :param lb_id: Load balancer ID
-        :param name: Use this to search by name
-        :param order_by: Response order
-        :param page: Page number
-        :param page_size: The number of items to return
+        List frontends in a given load balancer.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: Load Balancer ID.
+        :param name: Name of the frontend to filter for.
+        :param order_by: Sort order of frontends in the response.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: Number of frontends to return.
         :return: :class:`List[ListFrontendsResponse] <List[ListFrontendsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_frontends_all(lb_id="example")
         """
@@ -1483,24 +1488,24 @@
         region: Optional[Region] = None,
         name: Optional[str] = None,
         timeout_client: Optional[str] = None,
         certificate_id: Optional[str] = None,
         certificate_ids: Optional[List[str]] = None,
     ) -> Frontend:
         """
-        Create a frontend in a given load balancer
-        :param region: Region to target. If none is passed will use default region from the config
-        :param lb_id: Load balancer ID
-        :param name: Resource name
-        :param inbound_port: TCP port to listen on the front side
-        :param backend_id: Backend ID
-        :param timeout_client: Set the maximum inactivity time on the client side
-        :param certificate_id: Certificate ID, deprecated in favor of certificate_ids array !
-        :param certificate_ids: List of certificate IDs to bind on the frontend
-        :param enable_http3: Activate HTTP 3 protocol (beta)
+        Create a frontend in a given load balancer.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: Load Balancer ID (ID of the Load Balancer to attach the frontend to).
+        :param name: Name for the frontend.
+        :param inbound_port: Port the frontend should listen on.
+        :param backend_id: Backend ID (ID of the backend the frontend should pass traffic to).
+        :param timeout_client: Maximum allowed inactivity time on the client side.
+        :param certificate_id: Certificate ID, deprecated in favor of certificate_ids array.
+        :param certificate_ids: List of SSL/TLS certificate IDs to bind to the frontend.
+        :param enable_http3: Defines whether to enable HTTP/3 protocol on the frontend.
         :return: :class:`Frontend <Frontend>`
 
         Usage:
         ::
 
             result = await api.create_frontend(
                 lb_id="example",
@@ -1540,17 +1545,17 @@
     async def get_frontend(
         self,
         *,
         frontend_id: str,
         region: Optional[Region] = None,
     ) -> Frontend:
         """
-        Get a frontend
-        :param region: Region to target. If none is passed will use default region from the config
-        :param frontend_id: Frontend ID
+        Get a frontend.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param frontend_id: Frontend ID.
         :return: :class:`Frontend <Frontend>`
 
         Usage:
         ::
 
             result = await api.get_frontend(frontend_id="example")
         """
@@ -1578,24 +1583,24 @@
         enable_http3: bool,
         region: Optional[Region] = None,
         timeout_client: Optional[str] = None,
         certificate_id: Optional[str] = None,
         certificate_ids: Optional[List[str]] = None,
     ) -> Frontend:
         """
-        Update a frontend
-        :param region: Region to target. If none is passed will use default region from the config
-        :param frontend_id: Frontend ID
-        :param name: Resource name
-        :param inbound_port: TCP port to listen on the front side
-        :param backend_id: Backend ID
-        :param timeout_client: Client session maximum inactivity time
-        :param certificate_id: Certificate ID, deprecated in favor of `certificate_ids` array!
-        :param certificate_ids: List of certificate IDs to bind on the frontend
-        :param enable_http3: Activate HTTP 3 protocol (beta)
+        Update a frontend.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param frontend_id: Frontend ID.
+        :param name: Frontend name.
+        :param inbound_port: Port the frontend should listen on.
+        :param backend_id: Backend ID (ID of the backend the frontend should pass traffic to).
+        :param timeout_client: Maximum allowed inactivity time on the client side.
+        :param certificate_id: Certificate ID, deprecated in favor of certificate_ids array.
+        :param certificate_ids: List of SSL/TLS certificate IDs to bind to the frontend.
+        :param enable_http3: Defines whether to enable HTTP/3 protocol on the frontend.
         :return: :class:`Frontend <Frontend>`
 
         Usage:
         ::
 
             result = await api.update_frontend(
                 frontend_id="example",
@@ -1636,17 +1641,17 @@
     async def delete_frontend(
         self,
         *,
         frontend_id: str,
         region: Optional[Region] = None,
     ) -> Optional[None]:
         """
-        Delete a frontend
-        :param region: Region to target. If none is passed will use default region from the config
-        :param frontend_id: Frontend ID to delete
+        Delete a frontend.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param frontend_id: ID of the frontend to delete.
 
         Usage:
         ::
 
             result = await api.delete_frontend(frontend_id="example")
         """
 
@@ -1669,20 +1674,20 @@
         region: Optional[Region] = None,
         order_by: ListRoutesRequestOrderBy = ListRoutesRequestOrderBy.CREATED_AT_ASC,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         frontend_id: Optional[str] = None,
     ) -> ListRoutesResponse:
         """
-        List all backend redirections
-        :param region: Region to target. If none is passed will use default region from the config
-        :param order_by: Response order
-        :param page_size: The number of items to return
-        :param page: Page number
-        :param frontend_id:
+        List all backend redirections.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param order_by: Sort order of routes in the response.
+        :param page_size: The number of route objects to return.
+        :param page: The page number to return, from the paginated results.
+        :param frontend_id: Frontend ID to filter for, only Routes from this Frontend will be returned.
         :return: :class:`ListRoutesResponse <ListRoutesResponse>`
 
         Usage:
         ::
 
             result = await api.list_routes()
         """
@@ -1711,20 +1716,20 @@
         region: Optional[Region] = None,
         order_by: Optional[ListRoutesRequestOrderBy] = None,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         frontend_id: Optional[str] = None,
     ) -> List[Route]:
         """
-        List all backend redirections
-        :param region: Region to target. If none is passed will use default region from the config
-        :param order_by: Response order
-        :param page_size: The number of items to return
-        :param page: Page number
-        :param frontend_id:
+        List all backend redirections.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param order_by: Sort order of routes in the response.
+        :param page_size: The number of route objects to return.
+        :param page: The page number to return, from the paginated results.
+        :param frontend_id: Frontend ID to filter for, only Routes from this Frontend will be returned.
         :return: :class:`List[ListRoutesResponse] <List[ListRoutesResponse]>`
 
         Usage:
         ::
 
             result = await api.list_routes_all()
         """
@@ -1747,19 +1752,19 @@
         *,
         frontend_id: str,
         backend_id: str,
         region: Optional[Region] = None,
         match: Optional[RouteMatch] = None,
     ) -> Route:
         """
-        Create a backend redirection
-        :param region: Region to target. If none is passed will use default region from the config
-        :param frontend_id: Origin of redirection
-        :param backend_id: Destination of destination
-        :param match: Value to match a redirection
+        Create a backend redirection.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param frontend_id: ID of the source frontend to create the route on.
+        :param backend_id: ID of the target backend for the route.
+        :param match: Object defining the match condition for a route to be applied. If an incoming client session matches the specified condition (i.e. it has a matching SNI value or HTTP Host header value), it will be passed to the target backend.
         :return: :class:`Route <Route>`
 
         Usage:
         ::
 
             result = await api.create_route(
                 frontend_id="example",
@@ -1791,17 +1796,17 @@
     async def get_route(
         self,
         *,
         route_id: str,
         region: Optional[Region] = None,
     ) -> Route:
         """
-        Get single backend redirection
-        :param region: Region to target. If none is passed will use default region from the config
-        :param route_id: Id of route to get
+        Get single backend redirection.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param route_id: Route ID.
         :return: :class:`Route <Route>`
 
         Usage:
         ::
 
             result = await api.get_route(route_id="example")
         """
@@ -1824,19 +1829,19 @@
         *,
         route_id: str,
         backend_id: str,
         region: Optional[Region] = None,
         match: Optional[RouteMatch] = None,
     ) -> Route:
         """
-        Edit a backend redirection
-        :param region: Region to target. If none is passed will use default region from the config
-        :param route_id: Route id to update
-        :param backend_id: Backend id of redirection
-        :param match: Value to match a redirection
+        Edit a backend redirection.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param route_id: Route ID.
+        :param backend_id: ID of the target backend for the route.
+        :param match: Object defining the match condition for a route to be applied. If an incoming client session matches the specified condition (i.e. it has a matching SNI value or HTTP Host header value), it will be passed to the target backend.
         :return: :class:`Route <Route>`
 
         Usage:
         ::
 
             result = await api.update_route(
                 route_id="example",
@@ -1869,17 +1874,17 @@
     async def delete_route(
         self,
         *,
         route_id: str,
         region: Optional[Region] = None,
     ) -> Optional[None]:
         """
-        Delete a backend redirection
-        :param region: Region to target. If none is passed will use default region from the config
-        :param route_id: Route id to delete
+        Delete a backend redirection.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param route_id: Route ID.
 
         Usage:
         ::
 
             result = await api.delete_route(route_id="example")
         """
 
@@ -1897,19 +1902,21 @@
         return None
 
     async def get_lb_stats(
         self,
         *,
         lb_id: str,
         region: Optional[Region] = None,
+        backend_id: Optional[str] = None,
     ) -> LbStats:
         """
-        Get usage statistics of a given load balancer
-        :param region: Region to target. If none is passed will use default region from the config
-        :param lb_id: Load balancer ID
+        Get usage statistics of a given load balancer.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: Load Balancer ID.
+        :param backend_id: ID of the backend.
         :return: :class:`LbStats <LbStats>`
         :deprecated
 
         Usage:
         ::
 
             result = await api.get_lb_stats(lb_id="example")
@@ -1919,28 +1926,39 @@
             "region", region or self.client.default_region
         )
         param_lb_id = validate_path_param("lb_id", lb_id)
 
         res = self._request(
             "GET",
             f"/lb/v1/regions/{param_region}/lbs/{param_lb_id}/stats",
+            params={
+                "backend_id": backend_id,
+            },
         )
 
         self._throw_on_error(res)
         return unmarshal_LbStats(res.json())
 
     async def list_backend_stats(
         self,
         *,
         lb_id: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
+        backend_id: Optional[str] = None,
     ) -> ListBackendStatsResponse:
         """
+        List backend server statistics.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: Load Balancer ID.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: Number of items to return.
+        :param backend_id: ID of the backend.
+        :return: :class:`ListBackendStatsResponse <ListBackendStatsResponse>`
 
         Usage:
         ::
 
             result = await api.list_backend_stats(lb_id="example")
         """
 
@@ -1949,14 +1967,15 @@
         )
         param_lb_id = validate_path_param("lb_id", lb_id)
 
         res = self._request(
             "GET",
             f"/lb/v1/regions/{param_region}/lbs/{param_lb_id}/backend-stats",
             params={
+                "backend_id": backend_id,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
             },
         )
 
         self._throw_on_error(res)
         return unmarshal_ListBackendStatsResponse(res.json())
@@ -1964,16 +1983,23 @@
     async def list_backend_stats_all(
         self,
         *,
         lb_id: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
+        backend_id: Optional[str] = None,
     ) -> List[BackendServerStats]:
         """
+        List backend server statistics.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: Load Balancer ID.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: Number of items to return.
+        :param backend_id: ID of the backend.
         :return: :class:`List[ListBackendStatsResponse] <List[ListBackendStatsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_backend_stats_all(lb_id="example")
         """
@@ -1983,35 +2009,36 @@
             key="backend_servers_stats",
             fetcher=self.list_backend_stats,
             args={
                 "lb_id": lb_id,
                 "region": region,
                 "page": page,
                 "page_size": page_size,
+                "backend_id": backend_id,
             },
         )
 
     async def list_acls(
         self,
         *,
         frontend_id: str,
         region: Optional[Region] = None,
         order_by: ListAclRequestOrderBy = ListAclRequestOrderBy.CREATED_AT_ASC,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         name: Optional[str] = None,
     ) -> ListAclResponse:
         """
-        List ACL for a given frontend
-        :param region: Region to target. If none is passed will use default region from the config
-        :param frontend_id: ID of your frontend
-        :param order_by: Response order
-        :param page: Page number
-        :param page_size: The number of items to return
-        :param name: Filter acl per name
+        List ACL for a given frontend.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param frontend_id: Frontend ID (ACLs attached to this frontend will be returned in the response).
+        :param order_by: Sort order of ACLs in the response.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: The number of ACLs to return.
+        :param name: ACL name to filter for.
         :return: :class:`ListAclResponse <ListAclResponse>`
 
         Usage:
         ::
 
             result = await api.list_acls(frontend_id="example")
         """
@@ -2042,21 +2069,21 @@
         region: Optional[Region] = None,
         order_by: Optional[ListAclRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         name: Optional[str] = None,
     ) -> List[Acl]:
         """
-        List ACL for a given frontend
-        :param region: Region to target. If none is passed will use default region from the config
-        :param frontend_id: ID of your frontend
-        :param order_by: Response order
-        :param page: Page number
-        :param page_size: The number of items to return
-        :param name: Filter acl per name
+        List ACL for a given frontend.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param frontend_id: Frontend ID (ACLs attached to this frontend will be returned in the response).
+        :param order_by: Sort order of ACLs in the response.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: The number of ACLs to return.
+        :param name: ACL name to filter for.
         :return: :class:`List[ListAclResponse] <List[ListAclResponse]>`
 
         Usage:
         ::
 
             result = await api.list_acls_all(frontend_id="example")
         """
@@ -2083,27 +2110,22 @@
         index: int,
         description: str,
         region: Optional[Region] = None,
         name: Optional[str] = None,
         match: Optional[AclMatch] = None,
     ) -> Acl:
         """
-        Create an ACL for a given frontend
-        :param region: Region to target. If none is passed will use default region from the config
-        :param frontend_id: ID of your frontend
-        :param name: Name of your ACL ressource
-        :param action: Action to undertake when an ACL filter matches
-        :param match: The ACL match rule. You can have one of those three cases:
-
-          - `ip_subnet` is defined
-          - `http_filter` and `http_filter_value` are defined
-          - `ip_subnet`, `http_filter` and `http_filter_value` are defined
-
-        :param index: Order between your Acls (ascending order, 0 is first acl executed)
-        :param description: Description of your ACL ressource
+        Create an ACL for a given frontend.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param frontend_id: Frontend ID to attach the ACL to.
+        :param name: ACL name.
+        :param action: Action to take when incoming traffic matches an ACL filter.
+        :param match: ACL match filter object. One of `ip_subnet` or `http_filter` & `http_filter_value` are required.
+        :param index: Priority of this ACL (ACLs are applied in ascending order, 0 is the first ACL executed).
+        :param description: ACL description.
         :return: :class:`Acl <Acl>`
 
         Usage:
         ::
 
             result = await api.create_acl(
                 frontend_id="example",
@@ -2141,17 +2163,17 @@
     async def get_acl(
         self,
         *,
         acl_id: str,
         region: Optional[Region] = None,
     ) -> Acl:
         """
-        Get an ACL
-        :param region: Region to target. If none is passed will use default region from the config
-        :param acl_id: ID of your ACL ressource
+        Get an ACL.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param acl_id: ACL ID.
         :return: :class:`Acl <Acl>`
 
         Usage:
         ::
 
             result = await api.get_acl(acl_id="example")
         """
@@ -2177,22 +2199,22 @@
         action: AclAction,
         index: int,
         region: Optional[Region] = None,
         match: Optional[AclMatch] = None,
         description: Optional[str] = None,
     ) -> Acl:
         """
-        Update an ACL
-        :param region: Region to target. If none is passed will use default region from the config
-        :param acl_id: ID of your ACL ressource
-        :param name: Name of your ACL ressource
-        :param action: Action to undertake when an ACL filter matches
-        :param match: The ACL match rule. At least `ip_subnet` or `http_filter` and `http_filter_value` are required
-        :param index: Order between your Acls (ascending order, 0 is first acl executed)
-        :param description: Description of your ACL ressource
+        Update an ACL.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param acl_id: ACL ID.
+        :param name: ACL name.
+        :param action: Action to take when incoming traffic matches an ACL filter.
+        :param match: ACL match filter object. One of `ip_subnet` or `http_filter` & `http_filter_value` are required.
+        :param index: Priority of this ACL (ACLs are applied in ascending order, 0 is the first ACL executed).
+        :param description: ACL description.
         :return: :class:`Acl <Acl>`
 
         Usage:
         ::
 
             result = await api.update_acl(
                 acl_id="example",
@@ -2230,17 +2252,17 @@
     async def delete_acl(
         self,
         *,
         acl_id: str,
         region: Optional[Region] = None,
     ) -> Optional[None]:
         """
-        Delete an ACL
-        :param region: Region to target. If none is passed will use default region from the config
-        :param acl_id: ID of your ACL ressource
+        Delete an ACL.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param acl_id: ACL ID.
 
         Usage:
         ::
 
             result = await api.delete_acl(acl_id="example")
         """
 
@@ -2263,22 +2285,23 @@
         lb_id: str,
         region: Optional[Region] = None,
         name: Optional[str] = None,
         letsencrypt: Optional[CreateCertificateRequestLetsencryptConfig] = None,
         custom_certificate: Optional[CreateCertificateRequestCustomCertificate] = None,
     ) -> Certificate:
         """
+        Create a TLS certificate.
         Generate a new TLS certificate using Let's Encrypt or import your certificate.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param lb_id: Load balancer ID
-        :param name: Certificate name
-        :param letsencrypt: Let's Encrypt type.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: Load Balancer ID.
+        :param name: Name for the certificate.
+        :param letsencrypt: Object to define a new Let's Encrypt certificate to be generated.
 
         One-of ('type_'): at most one of 'letsencrypt', 'custom_certificate' could be set.
-        :param custom_certificate: Custom import certificate.
+        :param custom_certificate: Object to define an existing custom certificate to be imported.
 
         One-of ('type_'): at most one of 'letsencrypt', 'custom_certificate' could be set.
         :return: :class:`Certificate <Certificate>`
 
         Usage:
         ::
 
@@ -2293,15 +2316,15 @@
         res = self._request(
             "POST",
             f"/lb/v1/regions/{param_region}/lbs/{param_lb_id}/certificates",
             body=marshal_CreateCertificateRequest(
                 CreateCertificateRequest(
                     lb_id=lb_id,
                     region=region,
-                    name=name or random_name(prefix="certiticate"),
+                    name=name or random_name(prefix="certificate"),
                     letsencrypt=letsencrypt,
                     custom_certificate=custom_certificate,
                 ),
                 self.client,
             ),
         )
 
@@ -2315,21 +2338,21 @@
         region: Optional[Region] = None,
         order_by: ListCertificatesRequestOrderBy = ListCertificatesRequestOrderBy.CREATED_AT_ASC,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         name: Optional[str] = None,
     ) -> ListCertificatesResponse:
         """
-        List all TLS certificates on a given load balancer
-        :param region: Region to target. If none is passed will use default region from the config
-        :param lb_id: Load balancer ID
-        :param order_by: Response order
-        :param page: Page number
-        :param page_size: The number of items to return
-        :param name: Use this to search by name
+        List all TLS certificates on a given load balancer.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: Load Balancer ID.
+        :param order_by: Sort order of certificates in the response.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: Number of certificates to return.
+        :param name: Certificate name to filter for, only certificates of this name will be returned.
         :return: :class:`ListCertificatesResponse <ListCertificatesResponse>`
 
         Usage:
         ::
 
             result = await api.list_certificates(lb_id="example")
         """
@@ -2360,21 +2383,21 @@
         region: Optional[Region] = None,
         order_by: Optional[ListCertificatesRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         name: Optional[str] = None,
     ) -> List[Certificate]:
         """
-        List all TLS certificates on a given load balancer
-        :param region: Region to target. If none is passed will use default region from the config
-        :param lb_id: Load balancer ID
-        :param order_by: Response order
-        :param page: Page number
-        :param page_size: The number of items to return
-        :param name: Use this to search by name
+        List all TLS certificates on a given load balancer.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: Load Balancer ID.
+        :param order_by: Sort order of certificates in the response.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: Number of certificates to return.
+        :param name: Certificate name to filter for, only certificates of this name will be returned.
         :return: :class:`List[ListCertificatesResponse] <List[ListCertificatesResponse]>`
 
         Usage:
         ::
 
             result = await api.list_certificates_all(lb_id="example")
         """
@@ -2396,17 +2419,17 @@
     async def get_certificate(
         self,
         *,
         certificate_id: str,
         region: Optional[Region] = None,
     ) -> Certificate:
         """
-        Get a TLS certificate
-        :param region: Region to target. If none is passed will use default region from the config
-        :param certificate_id: Certificate ID
+        Get a TLS certificate.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param certificate_id: Certificate ID.
         :return: :class:`Certificate <Certificate>`
 
         Usage:
         ::
 
             result = await api.get_certificate(certificate_id="example")
         """
@@ -2431,16 +2454,16 @@
         region: Optional[Region] = None,
         options: Optional[
             WaitForOptions[Certificate, Union[bool, Awaitable[bool]]]
         ] = None,
     ) -> Certificate:
         """
         Waits for :class:`Certificate <Certificate>` to be in a final state.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param certificate_id: Certificate ID
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param certificate_id: Certificate ID.
         :param options: The options for the waiter
         :return: :class:`Certificate <Certificate>`
 
         Usage:
         ::
 
             result = api.wait_for_certificate(certificate_id="example")
@@ -2465,18 +2488,18 @@
         self,
         *,
         certificate_id: str,
         name: str,
         region: Optional[Region] = None,
     ) -> Certificate:
         """
-        Update a TLS certificate
-        :param region: Region to target. If none is passed will use default region from the config
-        :param certificate_id: Certificate ID
-        :param name: Certificate name
+        Update a TLS certificate.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param certificate_id: Certificate ID.
+        :param name: Certificate name.
         :return: :class:`Certificate <Certificate>`
 
         Usage:
         ::
 
             result = await api.update_certificate(
                 certificate_id="example",
@@ -2508,17 +2531,17 @@
     async def delete_certificate(
         self,
         *,
         certificate_id: str,
         region: Optional[Region] = None,
     ) -> Optional[None]:
         """
-        Delete a TLS certificate
-        :param region: Region to target. If none is passed will use default region from the config
-        :param certificate_id: Certificate ID
+        Delete a TLS certificate.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param certificate_id: Certificate ID.
 
         Usage:
         ::
 
             result = await api.delete_certificate(certificate_id="example")
         """
 
@@ -2539,18 +2562,18 @@
         self,
         *,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListLbTypesResponse:
         """
-        List all load balancer offer type
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page: Page number
-        :param page_size: The number of items to return
+        List all load balancer offer type.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: The number of items to return.
         :return: :class:`ListLbTypesResponse <ListLbTypesResponse>`
 
         Usage:
         ::
 
             result = await api.list_lb_types()
         """
@@ -2575,18 +2598,18 @@
         self,
         *,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[LbType]:
         """
-        List all load balancer offer type
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page: Page number
-        :param page_size: The number of items to return
+        List all load balancer offer type.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: The number of items to return.
         :return: :class:`List[ListLbTypesResponse] <List[ListLbTypesResponse]>`
 
         Usage:
         ::
 
             result = await api.list_lb_types_all()
         """
@@ -2609,27 +2632,27 @@
         region: Optional[Region] = None,
         email_config: Optional[SubscriberEmailConfig] = None,
         webhook_config: Optional[SubscriberWebhookConfig] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> Subscriber:
         """
-        Create a subscriber, webhook or email
-        :param region: Region to target. If none is passed will use default region from the config
-        :param name: Subscriber name
+        Create a subscriber, webhook or email.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param name: Subscriber name.
         :param email_config: Email address configuration.
 
         One-of ('config'): at most one of 'email_config', 'webhook_config' could be set.
         :param webhook_config: WebHook URI configuration.
 
         One-of ('config'): at most one of 'email_config', 'webhook_config' could be set.
-        :param organization_id: Owner of resources.
+        :param organization_id: Organization ID to create the subscriber in.
 
         One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
-        :param project_id: Assign the resource to a project ID.
+        :param project_id: Project ID to create the subscriber in.
 
         One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
         :return: :class:`Subscriber <Subscriber>`
 
         Usage:
         ::
 
@@ -2662,17 +2685,17 @@
     async def get_subscriber(
         self,
         *,
         subscriber_id: str,
         region: Optional[Region] = None,
     ) -> Subscriber:
         """
-        Get a subscriber
-        :param region: Region to target. If none is passed will use default region from the config
-        :param subscriber_id: Subscriber ID
+        Get a subscriber.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param subscriber_id: Subscriber ID.
         :return: :class:`Subscriber <Subscriber>`
 
         Usage:
         ::
 
             result = await api.get_subscriber(subscriber_id="example")
         """
@@ -2698,22 +2721,22 @@
         order_by: ListSubscriberRequestOrderBy = ListSubscriberRequestOrderBy.CREATED_AT_ASC,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> ListSubscriberResponse:
         """
-        List all subscriber
-        :param region: Region to target. If none is passed will use default region from the config
-        :param order_by: Response order
-        :param page: Page number
-        :param page_size: The number of items to return
-        :param name: Use this to search by name
-        :param organization_id: Filter Subscribers by organization ID
-        :param project_id: Filter Subscribers by project ID
+        List all subscriber.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param order_by: Sort order of subscribers in the response.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: The number of items to return.
+        :param name: Subscriber name to search for.
+        :param organization_id: Filter subscribers by Organization ID.
+        :param project_id: Filter subscribers by Project ID.
         :return: :class:`ListSubscriberResponse <ListSubscriberResponse>`
 
         Usage:
         ::
 
             result = await api.list_subscriber(name="example")
         """
@@ -2747,22 +2770,22 @@
         order_by: Optional[ListSubscriberRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> List[Subscriber]:
         """
-        List all subscriber
-        :param region: Region to target. If none is passed will use default region from the config
-        :param order_by: Response order
-        :param page: Page number
-        :param page_size: The number of items to return
-        :param name: Use this to search by name
-        :param organization_id: Filter Subscribers by organization ID
-        :param project_id: Filter Subscribers by project ID
+        List all subscriber.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param order_by: Sort order of subscribers in the response.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: The number of items to return.
+        :param name: Subscriber name to search for.
+        :param organization_id: Filter subscribers by Organization ID.
+        :param project_id: Filter subscribers by Project ID.
         :return: :class:`List[ListSubscriberResponse] <List[ListSubscriberResponse]>`
 
         Usage:
         ::
 
             result = await api.list_subscriber_all(name="example")
         """
@@ -2788,22 +2811,22 @@
         subscriber_id: str,
         name: str,
         region: Optional[Region] = None,
         email_config: Optional[SubscriberEmailConfig] = None,
         webhook_config: Optional[SubscriberWebhookConfig] = None,
     ) -> Subscriber:
         """
-        Update a subscriber
-        :param region: Region to target. If none is passed will use default region from the config
-        :param subscriber_id: Assign the resource to a project IDs
-        :param name: Subscriber name
+        Update a subscriber.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param subscriber_id: Subscriber ID.
+        :param name: Subscriber name.
         :param email_config: Email address configuration.
 
         One-of ('config'): at most one of 'email_config', 'webhook_config' could be set.
-        :param webhook_config: WebHook URI configuration.
+        :param webhook_config: Webhook URI configuration.
 
         One-of ('config'): at most one of 'email_config', 'webhook_config' could be set.
         :return: :class:`Subscriber <Subscriber>`
 
         Usage:
         ::
 
@@ -2839,17 +2862,17 @@
     async def delete_subscriber(
         self,
         *,
         subscriber_id: str,
         region: Optional[Region] = None,
     ) -> Optional[None]:
         """
-        Delete a subscriber
-        :param region: Region to target. If none is passed will use default region from the config
-        :param subscriber_id: Subscriber ID
+        Delete a subscriber.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param subscriber_id: Subscriber ID.
 
         Usage:
         ::
 
             result = await api.delete_subscriber(subscriber_id="example")
         """
 
@@ -2870,18 +2893,18 @@
         self,
         *,
         lb_id: str,
         subscriber_id: str,
         region: Optional[Region] = None,
     ) -> Lb:
         """
-        Subscribe a subscriber to a given load balancer
-        :param region: Region to target. If none is passed will use default region from the config
-        :param lb_id: Load balancer ID
-        :param subscriber_id: Subscriber ID
+        Subscribe a subscriber to a given load balancer.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: Load Balancer ID.
+        :param subscriber_id: Subscriber ID.
         :return: :class:`Lb <Lb>`
 
         Usage:
         ::
 
             result = await api.subscribe_to_lb(
                 lb_id="example",
@@ -2913,17 +2936,17 @@
     async def unsubscribe_from_lb(
         self,
         *,
         lb_id: str,
         region: Optional[Region] = None,
     ) -> Lb:
         """
-        Unsubscribe a subscriber from a given load balancer
-        :param region: Region to target. If none is passed will use default region from the config
-        :param lb_id: Load balancer ID
+        Unsubscribe a subscriber from a given load balancer.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: Load Balancer ID.
         :return: :class:`Lb <Lb>`
 
         Usage:
         ::
 
             result = await api.unsubscribe_from_lb(lb_id="example")
         """
@@ -2947,20 +2970,20 @@
         lb_id: str,
         region: Optional[Region] = None,
         order_by: ListPrivateNetworksRequestOrderBy = ListPrivateNetworksRequestOrderBy.CREATED_AT_ASC,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
     ) -> ListLbPrivateNetworksResponse:
         """
-        List attached private network of load balancer
-        :param region: Region to target. If none is passed will use default region from the config
-        :param lb_id: Load balancer ID
-        :param order_by: Response order
-        :param page_size: The number of items to return
-        :param page: Page number
+        List attached private network of load balancer.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: Load Balancer ID.
+        :param order_by: Sort order of Private Network objects in the response.
+        :param page_size: Number of objects to return.
+        :param page: The page number to return, from the paginated results.
         :return: :class:`ListLbPrivateNetworksResponse <ListLbPrivateNetworksResponse>`
 
         Usage:
         ::
 
             result = await api.list_lb_private_networks(lb_id="example")
         """
@@ -2989,20 +3012,20 @@
         lb_id: str,
         region: Optional[Region] = None,
         order_by: Optional[ListPrivateNetworksRequestOrderBy] = None,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
     ) -> List[PrivateNetwork]:
         """
-        List attached private network of load balancer
-        :param region: Region to target. If none is passed will use default region from the config
-        :param lb_id: Load balancer ID
-        :param order_by: Response order
-        :param page_size: The number of items to return
-        :param page: Page number
+        List attached private network of load balancer.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: Load Balancer ID.
+        :param order_by: Sort order of Private Network objects in the response.
+        :param page_size: Number of objects to return.
+        :param page: The page number to return, from the paginated results.
         :return: :class:`List[ListLbPrivateNetworksResponse] <List[ListLbPrivateNetworksResponse]>`
 
         Usage:
         ::
 
             result = await api.list_lb_private_networks_all(lb_id="example")
         """
@@ -3027,22 +3050,22 @@
         private_network_id: str,
         region: Optional[Region] = None,
         static_config: Optional[PrivateNetworkStaticConfig] = None,
         dhcp_config: Optional[PrivateNetworkDHCPConfig] = None,
         ipam_config: Optional[PrivateNetworkIpamConfig] = None,
     ) -> PrivateNetwork:
         """
-        Add load balancer on instance private network
-        :param region: Region to target. If none is passed will use default region from the config
-        :param lb_id: Load balancer ID
-        :param private_network_id: Set your instance private network id
-        :param static_config: Define two local ip address of your choice for each load balancer instance.
+        Add load balancer on instance private network.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: Load Balancer ID.
+        :param private_network_id: Private Network ID.
+        :param static_config: Object containing an array of a local IP address for the Load Balancer on this Private Network.
 
         One-of ('config'): at most one of 'static_config', 'dhcp_config', 'ipam_config' could be set.
-        :param dhcp_config: Set to true if you want to let DHCP assign IP addresses.
+        :param dhcp_config: Defines whether to let DHCP assign IP addresses.
 
         One-of ('config'): at most one of 'static_config', 'dhcp_config', 'ipam_config' could be set.
         :param ipam_config: For internal use only.
 
         One-of ('config'): at most one of 'static_config', 'dhcp_config', 'ipam_config' could be set.
         :return: :class:`PrivateNetwork <PrivateNetwork>`
 
@@ -3086,18 +3109,18 @@
         self,
         *,
         lb_id: str,
         private_network_id: str,
         region: Optional[Region] = None,
     ) -> Optional[None]:
         """
-        Remove load balancer of private network
-        :param region: Region to target. If none is passed will use default region from the config
-        :param lb_id: Load balancer ID
-        :param private_network_id: Set your instance private network id
+        Remove load balancer of private network.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param lb_id: Load balancer ID.
+        :param private_network_id: Set your instance private network id.
 
         Usage:
         ::
 
             result = await api.detach_private_network(
                 lb_id="example",
                 private_network_id="example",
@@ -3119,39 +3142,41 @@
 
         self._throw_on_error(res)
         return None
 
 
 class LbZonedV1API(API):
     """
-    Load balancer API.
+    Load Balancer API.
 
-    This API allows you to manage your load balancer service.
+    This API allows you to manage your Scaleway Load Balancer services.
+    Load Balancer API.
     """
 
     async def list_lbs(
         self,
         *,
         zone: Optional[Zone] = None,
         name: Optional[str] = None,
         order_by: ListLbsRequestOrderBy = ListLbsRequestOrderBy.CREATED_AT_ASC,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> ListLbsResponse:
         """
-        List load balancers
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param name: Use this to search by name
-        :param order_by: Response order
-        :param page_size: The number of items to return
-        :param page: Page number
-        :param organization_id: Filter LBs by organization ID
-        :param project_id: Filter LBs by project ID
+        List Load Balancers.
+        List all Load Balancers in the specified zone, for a Scaleway Organization or Scaleway Project. By default, the Load Balancers returned in the list are ordered by creation date in ascending order, though this can be modified via the `order_by` field.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param name: Load Balancer name to filter for.
+        :param order_by: Sort order of Load Balancers in the response.
+        :param page_size: Number of Load Balancers to return.
+        :param page: Page number to return, from the paginated results.
+        :param organization_id: Organization ID to filter for, only Load Balancers from this Organization will be returned.
+        :param project_id: Project ID to filter for, only Load Balancers from this Project will be returned.
         :return: :class:`ListLbsResponse <ListLbsResponse>`
 
         Usage:
         ::
 
             result = await api.list_lbs()
         """
@@ -3183,22 +3208,23 @@
         order_by: Optional[ListLbsRequestOrderBy] = None,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> List[Lb]:
         """
-        List load balancers
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param name: Use this to search by name
-        :param order_by: Response order
-        :param page_size: The number of items to return
-        :param page: Page number
-        :param organization_id: Filter LBs by organization ID
-        :param project_id: Filter LBs by project ID
+        List Load Balancers.
+        List all Load Balancers in the specified zone, for a Scaleway Organization or Scaleway Project. By default, the Load Balancers returned in the list are ordered by creation date in ascending order, though this can be modified via the `order_by` field.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param name: Load Balancer name to filter for.
+        :param order_by: Sort order of Load Balancers in the response.
+        :param page_size: Number of Load Balancers to return.
+        :param page: Page number to return, from the paginated results.
+        :param organization_id: Organization ID to filter for, only Load Balancers from this Organization will be returned.
+        :param project_id: Project ID to filter for, only Load Balancers from this Project will be returned.
         :return: :class:`List[ListLbsResponse] <List[ListLbsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_lbs_all()
         """
@@ -3225,35 +3251,34 @@
         type_: str,
         ssl_compatibility_level: SSLCompatibilityLevel,
         zone: Optional[Zone] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         name: Optional[str] = None,
         ip_id: Optional[str] = None,
+        assign_flexible_ip: Optional[bool] = None,
         tags: Optional[List[str]] = None,
     ) -> Lb:
         """
-        Create a load balancer
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param organization_id: Owner of resources.
+        Create a Load Balancer.
+        Create a new Load Balancer. Note that the Load Balancer will be created without frontends or backends; these must be created separately via the dedicated endpoints.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param organization_id: Scaleway Organization to create the Load Balancer in.
 
         One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
-        :param project_id: Assign the resource to a project ID.
+        :param project_id: Scaleway Project to create the Load Balancer in.
 
         One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
-        :param name: Resource names
-        :param description: Resource description
-        :param ip_id: Just like for compute instances, when you destroy a load balancer, you can keep its highly available IP address and reuse it for another load balancer later
-        :param tags: List of keyword
-        :param type_: Load balancer offer type
-        :param ssl_compatibility_level: Enforces minimal SSL version (in SSL/TLS offloading context).
-        - `intermediate` General-purpose servers with a variety of clients, recommended for almost all systems (Supports Firefox 27, Android 4.4.2, Chrome 31, Edge, IE 11 on Windows 7, Java 8u31, OpenSSL 1.0.1, Opera 20, and Safari 9).
-        - `modern` Services with clients that support TLS 1.3 and don't need backward compatibility (Firefox 63, Android 10.0, Chrome 70, Edge 75, Java 11, OpenSSL 1.1.1, Opera 57, and Safari 12.1).
-        - `old` Compatible with a number of very old clients, and should be used only as a last resort (Firefox 1, Android 2.3, Chrome 1, Edge 12, IE8 on Windows XP, Java 6, OpenSSL 0.9.8, Opera 5, and Safari 1).
-
+        :param name: Name for the Load Balancer.
+        :param description: Description for the Load Balancer.
+        :param ip_id: ID of an existing flexible IP address to attach to the Load Balancer.
+        :param assign_flexible_ip: Defines whether to automatically assign a flexible public IP to lb. Default value is `false` (do not assign).
+        :param tags: List of tags for the Load Balancer.
+        :param type_: Load Balancer commercial offer type. Use the Load Balancer types endpoint to retrieve a list of available offer types.
+        :param ssl_compatibility_level: Determines the minimal SSL version which needs to be supported on the client side, in an SSL/TLS offloading context. Intermediate is suitable for general-purpose servers with a variety of clients, recommended for almost all systems. Modern is suitable for services with clients that support TLS 1.3 and do not need backward compatibility. Old is compatible with a small number of very old clients and should be used only as a last resort.
         :return: :class:`Lb <Lb>`
 
         Usage:
         ::
 
             result = await api.create_lb(
                 description="example",
@@ -3273,14 +3298,15 @@
                     type_=type_,
                     ssl_compatibility_level=ssl_compatibility_level,
                     zone=zone,
                     organization_id=organization_id,
                     project_id=project_id,
                     name=name or random_name(prefix="lb"),
                     ip_id=ip_id,
+                    assign_flexible_ip=assign_flexible_ip,
                     tags=tags,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
@@ -3289,17 +3315,18 @@
     async def get_lb(
         self,
         *,
         lb_id: str,
         zone: Optional[Zone] = None,
     ) -> Lb:
         """
-        Get a load balancer
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param lb_id: Load balancer ID
+        Get a Load Balancer.
+        Retrieve information about an existing Load Balancer, specified by its Load Balancer ID. Its full details, including name, status and IP address, are returned in the response object.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: Load Balancer ID.
         :return: :class:`Lb <Lb>`
 
         Usage:
         ::
 
             result = await api.get_lb(lb_id="example")
         """
@@ -3320,16 +3347,16 @@
         *,
         lb_id: str,
         zone: Optional[Zone] = None,
         options: Optional[WaitForOptions[Lb, Union[bool, Awaitable[bool]]]] = None,
     ) -> Lb:
         """
         Waits for :class:`Lb <Lb>` to be in a final state.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param lb_id: Load balancer ID
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: Load Balancer ID.
         :param options: The options for the waiter
         :return: :class:`Lb <Lb>`
 
         Usage:
         ::
 
             result = api.wait_for_lb(lb_id="example")
@@ -3357,25 +3384,22 @@
         name: str,
         description: str,
         ssl_compatibility_level: SSLCompatibilityLevel,
         zone: Optional[Zone] = None,
         tags: Optional[List[str]] = None,
     ) -> Lb:
         """
-        Update a load balancer
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param lb_id: Load balancer ID
-        :param name: Resource name
-        :param description: Resource description
-        :param tags: List of keywords
-        :param ssl_compatibility_level: Enforces minimal SSL version (in SSL/TLS offloading context).
-        - `intermediate` General-purpose servers with a variety of clients, recommended for almost all systems (Supports Firefox 27, Android 4.4.2, Chrome 31, Edge, IE 11 on Windows 7, Java 8u31, OpenSSL 1.0.1, Opera 20, and Safari 9).
-        - `modern` Services with clients that support TLS 1.3 and don't need backward compatibility (Firefox 63, Android 10.0, Chrome 70, Edge 75, Java 11, OpenSSL 1.1.1, Opera 57, and Safari 12.1).
-        - `old` Compatible with a number of very old clients, and should be used only as a last resort (Firefox 1, Android 2.3, Chrome 1, Edge 12, IE8 on Windows XP, Java 6, OpenSSL 0.9.8, Opera 5, and Safari 1).
-
+        Update a Load Balancer.
+        Update the parameters of an existing Load Balancer, specified by its Load Balancer ID. Note that the request type is PUT and not PATCH. You must set all parameters.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: Load Balancer ID.
+        :param name: Load Balancer name.
+        :param description: Load Balancer description.
+        :param tags: List of tags for the Load Balancer.
+        :param ssl_compatibility_level: Determines the minimal SSL version which needs to be supported on the client side, in an SSL/TLS offloading context. Intermediate is suitable for general-purpose servers with a variety of clients, recommended for almost all systems. Modern is suitable for services with clients that support TLS 1.3 and don't need backward compatibility. Old is compatible with a small number of very old clients and should be used only as a last resort.
         :return: :class:`Lb <Lb>`
 
         Usage:
         ::
 
             result = await api.update_lb(
                 lb_id="example",
@@ -3411,18 +3435,19 @@
         self,
         *,
         lb_id: str,
         release_ip: bool,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete a load balancer
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param lb_id: Load balancer ID
-        :param release_ip: Set true if you don't want to keep this IP address
+        Delete a Load Balancer.
+        Delete an existing Load Balancer, specified by its Load Balancer ID. Deleting a Load Balancer is permanent, and cannot be undone. The Load Balancer's flexible IP address can either be deleted with the Load Balancer, or kept in your account for future use.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: ID of the Load Balancer to delete.
+        :param release_ip: Defines whether the Load Balancer's flexible IP should be deleted. Set to true to release the flexible IP, or false to keep it available in your account for future Load Balancers.
 
         Usage:
         ::
 
             result = await api.delete_lb(
                 lb_id="example",
                 release_ip=True,
@@ -3447,18 +3472,19 @@
         self,
         *,
         lb_id: str,
         type_: str,
         zone: Optional[Zone] = None,
     ) -> Lb:
         """
-        Migrate a load balancer
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param lb_id: Load balancer ID
-        :param type_: Load balancer type (check /lb-types to list all type)
+        Migrate a Load Balancer.
+        Migrate an existing Load Balancer from one commercial type to another. Allows you to scale your Load Balancer up or down in terms of bandwidth or multi-cloud provision.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: Load Balancer ID.
+        :param type_: Load Balancer type to migrate to (use the List all Load Balancer offer types endpoint to get a list of available offer types).
         :return: :class:`Lb <Lb>`
 
         Usage:
         ::
 
             result = await api.migrate_lb(
                 lb_id="example",
@@ -3492,21 +3518,22 @@
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         ip_address: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> ListIpsResponse:
         """
-        List IPs
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param page: Page number
-        :param page_size: The number of items to return
-        :param ip_address: Use this to search by IP address
-        :param organization_id: Filter IPs by organization id
-        :param project_id: Filter IPs by project ID
+        List IP addresses.
+        List the Load Balancer flexible IP addresses held in the account (filtered by Organization ID or Project ID). It is also possible to search for a specific IP address.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: Number of IP addresses to return.
+        :param ip_address: IP address to filter for.
+        :param organization_id: Organization ID to filter for, only Load Balancer IP addresses from this Organization will be returned.
+        :param project_id: Project ID to filter for, only Load Balancer IP addresses from this Project will be returned.
         :return: :class:`ListIpsResponse <ListIpsResponse>`
 
         Usage:
         ::
 
             result = await api.list_i_ps()
         """
@@ -3536,21 +3563,22 @@
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         ip_address: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> List[Ip]:
         """
-        List IPs
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param page: Page number
-        :param page_size: The number of items to return
-        :param ip_address: Use this to search by IP address
-        :param organization_id: Filter IPs by organization id
-        :param project_id: Filter IPs by project ID
+        List IP addresses.
+        List the Load Balancer flexible IP addresses held in the account (filtered by Organization ID or Project ID). It is also possible to search for a specific IP address.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: Number of IP addresses to return.
+        :param ip_address: IP address to filter for.
+        :param organization_id: Organization ID to filter for, only Load Balancer IP addresses from this Organization will be returned.
+        :param project_id: Project ID to filter for, only Load Balancer IP addresses from this Project will be returned.
         :return: :class:`List[ListIpsResponse] <List[ListIpsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_i_ps_all()
         """
@@ -3574,23 +3602,24 @@
         *,
         zone: Optional[Zone] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         reverse: Optional[str] = None,
     ) -> Ip:
         """
-        Create an IP
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param organization_id: Owner of resources.
+        Create an IP address.
+        Create a new Load Balancer flexible IP address, in the specified Scaleway Project. This can be attached to new Load Balancers created in the future.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param organization_id: Organization ID of the Organization where the IP address should be created.
 
         One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
-        :param project_id: Assign the resource to a project ID.
+        :param project_id: Project ID of the Project where the IP address should be created.
 
         One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
-        :param reverse: Reverse domain name
+        :param reverse: Reverse DNS (domain name) for the IP address.
         :return: :class:`Ip <Ip>`
 
         Usage:
         ::
 
             result = await api.create_ip()
         """
@@ -3617,17 +3646,18 @@
     async def get_ip(
         self,
         *,
         ip_id: str,
         zone: Optional[Zone] = None,
     ) -> Ip:
         """
-        Get an IP
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param ip_id: IP address ID
+        Get an IP address.
+        Retrieve the full details of a Load Balancer flexible IP address.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param ip_id: IP address ID.
         :return: :class:`Ip <Ip>`
 
         Usage:
         ::
 
             result = await api.get_ip(ip_id="example")
         """
@@ -3646,17 +3676,18 @@
     async def release_ip(
         self,
         *,
         ip_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete an IP
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param ip_id: IP address ID
+        Delete an IP address.
+        Delete a Load Balancer flexible IP address. This action is irreversible, and cannot be undone.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param ip_id: IP address ID.
 
         Usage:
         ::
 
             result = await api.release_ip(ip_id="example")
         """
 
@@ -3675,18 +3706,19 @@
         self,
         *,
         ip_id: str,
         zone: Optional[Zone] = None,
         reverse: Optional[str] = None,
     ) -> Ip:
         """
-        Update an IP
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param ip_id: IP address ID
-        :param reverse: Reverse DNS
+        Update an IP address.
+        Update the reverse DNS of a Load Balancer flexible IP address.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param ip_id: IP address ID.
+        :param reverse: Reverse DNS (domain name) for the IP address.
         :return: :class:`Ip <Ip>`
 
         Usage:
         ::
 
             result = await api.update_ip(ip_id="example")
         """
@@ -3717,21 +3749,22 @@
         zone: Optional[Zone] = None,
         name: Optional[str] = None,
         order_by: ListBackendsRequestOrderBy = ListBackendsRequestOrderBy.CREATED_AT_ASC,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListBackendsResponse:
         """
-        List backends in a given load balancer
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param lb_id: Load balancer ID
-        :param name: Use this to search by name
-        :param order_by: Response order
-        :param page: Page number
-        :param page_size: The number of items to return
+        List the backends of a given Load Balancer.
+        List all the backends of a Load Balancer, specified by its Load Balancer ID. By default, results are returned in ascending order by the creation date of each backend. The response is an array of backend objects, containing full details of each one including their configuration parameters such as protocol, port and forwarding algorithm.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: Load Balancer ID.
+        :param name: Name of the backend to filter for.
+        :param order_by: Sort order of backends in the response.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: Number of backends to return.
         :return: :class:`ListBackendsResponse <ListBackendsResponse>`
 
         Usage:
         ::
 
             result = await api.list_backends(lb_id="example")
         """
@@ -3760,21 +3793,22 @@
         zone: Optional[Zone] = None,
         name: Optional[str] = None,
         order_by: Optional[ListBackendsRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[Backend]:
         """
-        List backends in a given load balancer
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param lb_id: Load balancer ID
-        :param name: Use this to search by name
-        :param order_by: Response order
-        :param page: Page number
-        :param page_size: The number of items to return
+        List the backends of a given Load Balancer.
+        List all the backends of a Load Balancer, specified by its Load Balancer ID. By default, results are returned in ascending order by the creation date of each backend. The response is an array of backend objects, containing full details of each one including their configuration parameters such as protocol, port and forwarding algorithm.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: Load Balancer ID.
+        :param name: Name of the backend to filter for.
+        :param order_by: Sort order of backends in the response.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: Number of backends to return.
         :return: :class:`List[ListBackendsResponse] <List[ListBackendsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_backends_all(lb_id="example")
         """
@@ -3811,45 +3845,45 @@
         send_proxy_v2: Optional[bool] = None,
         timeout_server: Optional[str] = None,
         timeout_connect: Optional[str] = None,
         timeout_tunnel: Optional[str] = None,
         failover_host: Optional[str] = None,
         ssl_bridging: Optional[bool] = None,
         ignore_ssl_server_verify: Optional[bool] = None,
+        redispatch_attempt_count: Optional[int] = None,
+        max_retries: Optional[int] = None,
+        max_connections: Optional[int] = None,
+        timeout_queue: Optional[str] = None,
     ) -> Backend:
         """
-        Create a backend in a given load balancer
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param lb_id: Load balancer ID
-        :param name: Resource name
-        :param forward_protocol: Backend protocol. TCP or HTTP
-        :param forward_port: User sessions will be forwarded to this port of backend servers
-        :param forward_port_algorithm: Load balancing algorithm
-        :param sticky_sessions: Enables cookie-based session persistence
-        :param sticky_sessions_cookie_name: Cookie name for sticky sessions
-        :param health_check: See the Healthcheck object description
-        :param server_ip: Backend server IP addresses list (IPv4 or IPv6)
-        :param send_proxy_v2: Deprecated in favor of proxy_protocol field !
-        :param timeout_server: Maximum server connection inactivity time (allowed time the server has to process the request)
-        :param timeout_connect: Maximum initial server connection establishment time
-        :param timeout_tunnel: Maximum tunnel inactivity time after Websocket is established (take precedence over client and server timeout)
-        :param on_marked_down_action: Modify what occurs when a backend server is marked down
-        :param proxy_protocol: The PROXY protocol informs the other end about the incoming connection, so that it can know the client's address or the public address it accessed to, whatever the upper layer protocol.
-
-        * `proxy_protocol_none` Disable proxy protocol.
-        * `proxy_protocol_v1` Version one (text format).
-        * `proxy_protocol_v2` Version two (binary format).
-        * `proxy_protocol_v2_ssl` Version two with SSL connection.
-        * `proxy_protocol_v2_ssl_cn` Version two with SSL connection and common name information.
-
-        :param failover_host: Only the host part of the Scaleway S3 bucket website is expected.
-        E.g. `failover-website.s3-website.fr-par.scw.cloud` if your bucket website URL is `https://failover-website.s3-website.fr-par.scw.cloud/`.
-
-        :param ssl_bridging: Enable SSL between load balancer and backend servers
-        :param ignore_ssl_server_verify: Set to true to ignore server certificate verification
+        Create a backend for a given Load Balancer.
+        Create a new backend for a given Load Balancer, specifying its full configuration including protocol, port and forwarding algorithm.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: Load Balancer ID.
+        :param name: Name for the backend.
+        :param forward_protocol: Protocol to be used by the backend when forwarding traffic to backend servers.
+        :param forward_port: Port to be used by the backend when forwarding traffic to backend servers.
+        :param forward_port_algorithm: Load balancing algorithm to be used when determining which backend server to forward new traffic to.
+        :param sticky_sessions: Defines whether to activate sticky sessions (binding a particular session to a particular backend server) and the method to use if so. None disables sticky sessions. Cookie-based uses an HTTP cookie TO stick a session to a backend server. Table-based uses the source (client) IP address to stick a session to a backend server.
+        :param sticky_sessions_cookie_name: Cookie name for cookie-based sticky sessions.
+        :param health_check: Object defining the health check to be carried out by the backend when checking the status and health of backend servers.
+        :param server_ip: List of backend server IP addresses (IPv4 or IPv6) the backend should forward traffic to.
+        :param send_proxy_v2: Deprecated in favor of proxy_protocol field.
+        :param timeout_server: Maximum allowed time for a backend server to process a request.
+        :param timeout_connect: Maximum allowed time for establishing a connection to a backend server.
+        :param timeout_tunnel: Maximum allowed tunnel inactivity time after Websocket is established (takes precedence over client and server timeout).
+        :param on_marked_down_action: Action to take when a backend server is marked as down.
+        :param proxy_protocol: Protocol to use between the Load Balancer and backend servers. Allows the backend servers to be informed of the client's real IP address. The PROXY protocol must be supported by the backend servers' software.
+        :param failover_host: Scaleway S3 bucket website to be served as failover if all backend servers are down, e.g. failover-website.s3-website.fr-par.scw.cloud.
+        :param ssl_bridging: Defines whether to enable SSL bridging between the Load Balancer and backend servers.
+        :param ignore_ssl_server_verify: Defines whether the server certificate verification should be ignored.
+        :param redispatch_attempt_count: Whether to use another backend server on each attempt.
+        :param max_retries: Number of retries when a backend server connection failed.
+        :param max_connections: Maximum number of connections allowed per backend server.
+        :param timeout_queue: Maximum time for a request to be left pending in queue when `max_connections` is reached.
         :return: :class:`Backend <Backend>`
 
         Usage:
         ::
 
             result = await api.create_backend(
                 lb_id="example",
@@ -3885,14 +3919,18 @@
                     send_proxy_v2=send_proxy_v2,
                     timeout_server=timeout_server,
                     timeout_connect=timeout_connect,
                     timeout_tunnel=timeout_tunnel,
                     failover_host=failover_host,
                     ssl_bridging=ssl_bridging,
                     ignore_ssl_server_verify=ignore_ssl_server_verify,
+                    redispatch_attempt_count=redispatch_attempt_count,
+                    max_retries=max_retries,
+                    max_connections=max_connections,
+                    timeout_queue=timeout_queue,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_Backend(res.json())
@@ -3900,17 +3938,18 @@
     async def get_backend(
         self,
         *,
         backend_id: str,
         zone: Optional[Zone] = None,
     ) -> Backend:
         """
-        Get a backend in a given load balancer
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param backend_id: Backend ID
+        Get a backend of a given Load Balancer.
+        Get the full details of a given backend, specified by its backend ID. The response contains the backend's full configuration parameters including protocol, port and forwarding algorithm.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param backend_id: Backend ID.
         :return: :class:`Backend <Backend>`
 
         Usage:
         ::
 
             result = await api.get_backend(backend_id="example")
         """
@@ -3942,43 +3981,43 @@
         send_proxy_v2: Optional[bool] = None,
         timeout_server: Optional[str] = None,
         timeout_connect: Optional[str] = None,
         timeout_tunnel: Optional[str] = None,
         failover_host: Optional[str] = None,
         ssl_bridging: Optional[bool] = None,
         ignore_ssl_server_verify: Optional[bool] = None,
+        redispatch_attempt_count: Optional[int] = None,
+        max_retries: Optional[int] = None,
+        max_connections: Optional[int] = None,
+        timeout_queue: Optional[str] = None,
     ) -> Backend:
         """
-        Update a backend in a given load balancer
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param backend_id: Backend ID to update
-        :param name: Resource name
-        :param forward_protocol: Backend protocol. TCP or HTTP
-        :param forward_port: User sessions will be forwarded to this port of backend servers
-        :param forward_port_algorithm: Load balancing algorithm
-        :param sticky_sessions: Enable cookie-based session persistence
-        :param sticky_sessions_cookie_name: Cookie name for sticky sessions
-        :param send_proxy_v2: Deprecated in favor of proxy_protocol field!
-        :param timeout_server: Maximum server connection inactivity time (allowed time the server has to process the request)
-        :param timeout_connect: Maximum initial server connection establishment time
-        :param timeout_tunnel: Maximum tunnel inactivity time after Websocket is established (take precedence over client and server timeout)
-        :param on_marked_down_action: Modify what occurs when a backend server is marked down
-        :param proxy_protocol: The PROXY protocol informs the other end about the incoming connection, so that it can know the client's address or the public address it accessed to, whatever the upper layer protocol is.
-
-        * `proxy_protocol_none` Disable proxy protocol.
-        * `proxy_protocol_v1` Version one (text format).
-        * `proxy_protocol_v2` Version two (binary format).
-        * `proxy_protocol_v2_ssl` Version two with SSL connection.
-        * `proxy_protocol_v2_ssl_cn` Version two with SSL connection and common name information.
-
-        :param failover_host: Only the host part of the Scaleway S3 bucket website is expected.
-        Example: `failover-website.s3-website.fr-par.scw.cloud` if your bucket website URL is `https://failover-website.s3-website.fr-par.scw.cloud/`.
-
-        :param ssl_bridging: Enable SSL between load balancer and backend servers
-        :param ignore_ssl_server_verify: Set to true to ignore server certificate verification
+        Update a backend of a given Load Balancer.
+        Update a backend of a given Load Balancer, specified by its backend ID. Note that the request type is PUT and not PATCH. You must set all parameters.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param backend_id: Backend ID.
+        :param name: Backend name.
+        :param forward_protocol: Protocol to be used by the backend when forwarding traffic to backend servers.
+        :param forward_port: Port to be used by the backend when forwarding traffic to backend servers.
+        :param forward_port_algorithm: Load balancing algorithm to be used when determining which backend server to forward new traffic to.
+        :param sticky_sessions: Defines whether to activate sticky sessions (binding a particular session to a particular backend server) and the method to use if so. None disables sticky sessions. Cookie-based uses an HTTP cookie to stick a session to a backend server. Table-based uses the source (client) IP address to stick a session to a backend server.
+        :param sticky_sessions_cookie_name: Cookie name for cookie-based sticky sessions.
+        :param send_proxy_v2: Deprecated in favor of proxy_protocol field.
+        :param timeout_server: Maximum allowed time for a backend server to process a request.
+        :param timeout_connect: Maximum allowed time for establishing a connection to a backend server.
+        :param timeout_tunnel: Maximum allowed tunnel inactivity time after Websocket is established (takes precedence over client and server timeout).
+        :param on_marked_down_action: Action to take when a backend server is marked as down.
+        :param proxy_protocol: Protocol to use between the Load Balancer and backend servers. Allows the backend servers to be informed of the client's real IP address. The PROXY protocol must be supported by the backend servers' software.
+        :param failover_host: Scaleway S3 bucket website to be served as failover if all backend servers are down, e.g. failover-website.s3-website.fr-par.scw.cloud.
+        :param ssl_bridging: Defines whether to enable SSL bridging between the Load Balancer and backend servers.
+        :param ignore_ssl_server_verify: Defines whether the server certificate verification should be ignored.
+        :param redispatch_attempt_count: Whether to use another backend server on each attempt.
+        :param max_retries: Number of retries when a backend server connection failed.
+        :param max_connections: Maximum number of connections allowed per backend server.
+        :param timeout_queue: Maximum time for a request to be left pending in queue when `max_connections` is reached.
         :return: :class:`Backend <Backend>`
 
         Usage:
         ::
 
             result = await api.update_backend(
                 backend_id="example",
@@ -4011,14 +4050,18 @@
                     send_proxy_v2=send_proxy_v2,
                     timeout_server=timeout_server,
                     timeout_connect=timeout_connect,
                     timeout_tunnel=timeout_tunnel,
                     failover_host=failover_host,
                     ssl_bridging=ssl_bridging,
                     ignore_ssl_server_verify=ignore_ssl_server_verify,
+                    redispatch_attempt_count=redispatch_attempt_count,
+                    max_retries=max_retries,
+                    max_connections=max_connections,
+                    timeout_queue=timeout_queue,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_Backend(res.json())
@@ -4026,17 +4069,18 @@
     async def delete_backend(
         self,
         *,
         backend_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete a backend in a given load balancer
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param backend_id: ID of the backend to delete
+        Delete a backend of a given Load Balancer.
+        Delete a backend of a given Load Balancer, specified by its backend ID. This action is irreversible and cannot be undone.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param backend_id: ID of the backend to delete.
 
         Usage:
         ::
 
             result = await api.delete_backend(backend_id="example")
         """
 
@@ -4055,18 +4099,19 @@
         self,
         *,
         backend_id: str,
         server_ip: List[str],
         zone: Optional[Zone] = None,
     ) -> Backend:
         """
-        Add a set of servers in a given backend
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param backend_id: Backend ID
-        :param server_ip: Set all IPs to add on your backend
+        Add a set of backend servers to a given backend.
+        For a given backend specified by its backend ID, add a set of backend servers (identified by their IP addresses) it should forward traffic to. These will be appended to any existing set of backend servers for this backend.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param backend_id: Backend ID.
+        :param server_ip: List of IP addresses to add to backend servers.
         :return: :class:`Backend <Backend>`
 
         Usage:
         ::
 
             result = await api.add_backend_servers(
                 backend_id="example",
@@ -4097,18 +4142,19 @@
         self,
         *,
         backend_id: str,
         server_ip: List[str],
         zone: Optional[Zone] = None,
     ) -> Backend:
         """
-        Remove a set of servers for a given backend
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param backend_id: Backend ID
-        :param server_ip: Set all IPs to remove of your backend
+        Remove a set of servers for a given backend.
+        For a given backend specified by its backend ID, remove the specified backend servers (identified by their IP addresses) so that it no longer forwards traffic to them.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param backend_id: Backend ID.
+        :param server_ip: List of IP addresses to remove from backend servers.
         :return: :class:`Backend <Backend>`
 
         Usage:
         ::
 
             result = await api.remove_backend_servers(
                 backend_id="example",
@@ -4139,18 +4185,19 @@
         self,
         *,
         backend_id: str,
         server_ip: List[str],
         zone: Optional[Zone] = None,
     ) -> Backend:
         """
-        Define all servers in a given backend
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param backend_id: Backend ID
-        :param server_ip: Set all IPs to add on your backend and remove all other
+        Define all backend servers for a given backend.
+        For a given backend specified by its backend ID, define the set of backend servers (identified by their IP addresses) that it should forward traffic to. Any existing backend servers configured for this backend will be removed.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param backend_id: Backend ID.
+        :param server_ip: List of IP addresses for backend servers. Any other existing backend servers will be removed.
         :return: :class:`Backend <Backend>`
 
         Usage:
         ::
 
             result = await api.set_backend_servers(
                 backend_id="example",
@@ -4183,52 +4230,55 @@
         backend_id: str,
         port: int,
         check_delay: str,
         check_timeout: str,
         check_max_retries: int,
         check_send_proxy: bool,
         zone: Optional[Zone] = None,
+        tcp_config: Optional[HealthCheckTcpConfig] = None,
         mysql_config: Optional[HealthCheckMysqlConfig] = None,
+        pgsql_config: Optional[HealthCheckPgsqlConfig] = None,
         ldap_config: Optional[HealthCheckLdapConfig] = None,
         redis_config: Optional[HealthCheckRedisConfig] = None,
-        pgsql_config: Optional[HealthCheckPgsqlConfig] = None,
-        tcp_config: Optional[HealthCheckTcpConfig] = None,
         http_config: Optional[HealthCheckHttpConfig] = None,
         https_config: Optional[HealthCheckHttpsConfig] = None,
+        transient_check_delay: Optional[str] = None,
     ) -> HealthCheck:
         """
-        Update an healthcheck for a given backend
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param backend_id: Backend ID
-        :param port: Specify the port used to health check
-        :param check_delay: Time between two consecutive health checks
-        :param check_timeout: Maximum time a backend server has to reply to the health check
-        :param check_max_retries: Number of consecutive unsuccessful health checks, after which the server will be considered dead
-        :param mysql_config: The check requires MySQL >=3.22, for older version, please use TCP check.
-
-        One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
-        :param ldap_config: The response is analyzed to find an LDAPv3 response message.
-
-        One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
-        :param redis_config: The response is analyzed to find the +PONG response message.
-
-        One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
-        :param pgsql_config: PostgreSQL health check.
-
-        One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
-        :param tcp_config: Basic TCP health check.
+        Update a health check for a given backend.
+        Update the configuration of the health check performed by a given backend to verify the health of its backend servers, identified by its backend ID. Note that the request type is PUT and not PATCH. You must set all parameters.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param backend_id: Backend ID.
+        :param port: Port to use for the backend server health check.
+        :param check_delay: Time to wait between two consecutive health checks.
+        :param check_timeout: Maximum time a backend server has to reply to the health check.
+        :param check_max_retries: Number of consecutive unsuccessful health checks after which the server will be considered dead.
+        :param check_send_proxy: Defines whether proxy protocol should be activated for the health check.
+        :param tcp_config: Object to configure a basic TCP health check.
+
+        One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
+        :param mysql_config: Object to configure a MySQL health check. The check requires MySQL >=3.22, for older versions, use a TCP health check.
+
+        One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
+        :param pgsql_config: Object to configure a PostgreSQL health check.
+
+        One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
+        :param ldap_config: Object to configure an LDAP health check. The response is analyzed to find the LDAPv3 response message.
+
+        One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
+        :param redis_config: Object to configure a Redis health check. The response is analyzed to find the +PONG response message.
 
-        One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
-        :param http_config: HTTP health check.
+        One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
+        :param http_config: Object to configure an HTTP health check.
 
-        One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
-        :param https_config: HTTPS health check.
+        One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
+        :param https_config: Object to configure an HTTPS health check.
 
-        One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
-        :param check_send_proxy: It defines whether the health check should be done considering the proxy protocol
+        One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
+        :param transient_check_delay: Time to wait between two consecutive health checks when a backend server is in a transient state (going UP or DOWN).
         :return: :class:`HealthCheck <HealthCheck>`
 
         Usage:
         ::
 
             result = await api.update_health_check(
                 backend_id="example",
@@ -4251,21 +4301,22 @@
                     backend_id=backend_id,
                     port=port,
                     check_delay=check_delay,
                     check_timeout=check_timeout,
                     check_max_retries=check_max_retries,
                     check_send_proxy=check_send_proxy,
                     zone=zone,
+                    tcp_config=tcp_config,
                     mysql_config=mysql_config,
+                    pgsql_config=pgsql_config,
                     ldap_config=ldap_config,
                     redis_config=redis_config,
-                    pgsql_config=pgsql_config,
-                    tcp_config=tcp_config,
                     http_config=http_config,
                     https_config=https_config,
+                    transient_check_delay=transient_check_delay,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_HealthCheck(res.json())
@@ -4277,21 +4328,22 @@
         zone: Optional[Zone] = None,
         name: Optional[str] = None,
         order_by: ListFrontendsRequestOrderBy = ListFrontendsRequestOrderBy.CREATED_AT_ASC,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListFrontendsResponse:
         """
-        List frontends in a given load balancer
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param lb_id: Load balancer ID
-        :param name: Use this to search by name
-        :param order_by: Response order
-        :param page: Page number
-        :param page_size: The number of items to return
+        List frontends of a given Load Balancer.
+        List all the frontends of a Load Balancer, specified by its Load Balancer ID. By default, results are returned in ascending order by the creation date of each frontend. The response is an array of frontend objects, containing full details of each one including the port they listen on and the backend they are attached to.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: Load Balancer ID.
+        :param name: Name of the frontend to filter for.
+        :param order_by: Sort order of frontends in the response.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: Number of frontends to return.
         :return: :class:`ListFrontendsResponse <ListFrontendsResponse>`
 
         Usage:
         ::
 
             result = await api.list_frontends(lb_id="example")
         """
@@ -4320,21 +4372,22 @@
         zone: Optional[Zone] = None,
         name: Optional[str] = None,
         order_by: Optional[ListFrontendsRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[Frontend]:
         """
-        List frontends in a given load balancer
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param lb_id: Load balancer ID
-        :param name: Use this to search by name
-        :param order_by: Response order
-        :param page: Page number
-        :param page_size: The number of items to return
+        List frontends of a given Load Balancer.
+        List all the frontends of a Load Balancer, specified by its Load Balancer ID. By default, results are returned in ascending order by the creation date of each frontend. The response is an array of frontend objects, containing full details of each one including the port they listen on and the backend they are attached to.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: Load Balancer ID.
+        :param name: Name of the frontend to filter for.
+        :param order_by: Sort order of frontends in the response.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: Number of frontends to return.
         :return: :class:`List[ListFrontendsResponse] <List[ListFrontendsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_frontends_all(lb_id="example")
         """
@@ -4363,24 +4416,25 @@
         zone: Optional[Zone] = None,
         name: Optional[str] = None,
         timeout_client: Optional[str] = None,
         certificate_id: Optional[str] = None,
         certificate_ids: Optional[List[str]] = None,
     ) -> Frontend:
         """
-        Create a frontend in a given load balancer
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param lb_id: Load balancer ID
-        :param name: Resource name
-        :param inbound_port: TCP port to listen on the front side
-        :param backend_id: Backend ID
-        :param timeout_client: Set the maximum inactivity time on the client side
-        :param certificate_id: Certificate ID, deprecated in favor of certificate_ids array !
-        :param certificate_ids: List of certificate IDs to bind on the frontend
-        :param enable_http3: Activate HTTP 3 protocol (beta)
+        Create a frontend in a given Load Balancer.
+        Create a new frontend for a given Load Balancer, specifying its configuration including the port it should listen on and the backend to attach it to.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: Load Balancer ID (ID of the Load Balancer to attach the frontend to).
+        :param name: Name for the frontend.
+        :param inbound_port: Port the frontend should listen on.
+        :param backend_id: Backend ID (ID of the backend the frontend should pass traffic to).
+        :param timeout_client: Maximum allowed inactivity time on the client side.
+        :param certificate_id: Certificate ID, deprecated in favor of certificate_ids array.
+        :param certificate_ids: List of SSL/TLS certificate IDs to bind to the frontend.
+        :param enable_http3: Defines whether to enable HTTP/3 protocol on the frontend.
         :return: :class:`Frontend <Frontend>`
 
         Usage:
         ::
 
             result = await api.create_frontend(
                 lb_id="example",
@@ -4418,17 +4472,18 @@
     async def get_frontend(
         self,
         *,
         frontend_id: str,
         zone: Optional[Zone] = None,
     ) -> Frontend:
         """
-        Get a frontend
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param frontend_id: Frontend ID
+        Get a frontend.
+        Get the full details of a given frontend, specified by its frontend ID. The response contains the frontend's full configuration parameters including the backend it is attached to, the port it listens on, and any certificates it has.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param frontend_id: Frontend ID.
         :return: :class:`Frontend <Frontend>`
 
         Usage:
         ::
 
             result = await api.get_frontend(frontend_id="example")
         """
@@ -4454,24 +4509,25 @@
         enable_http3: bool,
         zone: Optional[Zone] = None,
         timeout_client: Optional[str] = None,
         certificate_id: Optional[str] = None,
         certificate_ids: Optional[List[str]] = None,
     ) -> Frontend:
         """
-        Update a frontend
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param frontend_id: Frontend ID
-        :param name: Resource name
-        :param inbound_port: TCP port to listen on the front side
-        :param backend_id: Backend ID
-        :param timeout_client: Client session maximum inactivity time
-        :param certificate_id: Certificate ID, deprecated in favor of `certificate_ids` array!
-        :param certificate_ids: List of certificate IDs to bind on the frontend
-        :param enable_http3: Activate HTTP 3 protocol (beta)
+        Update a frontend.
+        Update a given frontend, specified by its frontend ID. You can update configuration parameters including its name and the port it listens on. Note that the request type is PUT and not PATCH. You must set all parameters.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param frontend_id: Frontend ID.
+        :param name: Frontend name.
+        :param inbound_port: Port the frontend should listen on.
+        :param backend_id: Backend ID (ID of the backend the frontend should pass traffic to).
+        :param timeout_client: Maximum allowed inactivity time on the client side.
+        :param certificate_id: Certificate ID, deprecated in favor of certificate_ids array.
+        :param certificate_ids: List of SSL/TLS certificate IDs to bind to the frontend.
+        :param enable_http3: Defines whether to enable HTTP/3 protocol on the frontend.
         :return: :class:`Frontend <Frontend>`
 
         Usage:
         ::
 
             result = await api.update_frontend(
                 frontend_id="example",
@@ -4510,17 +4566,18 @@
     async def delete_frontend(
         self,
         *,
         frontend_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete a frontend
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param frontend_id: Frontend ID to delete
+        Delete a frontend.
+        Delete a given frontend, specified by its frontend ID. This action is irreversible and cannot be undone.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param frontend_id: ID of the frontend to delete.
 
         Usage:
         ::
 
             result = await api.delete_frontend(frontend_id="example")
         """
 
@@ -4541,20 +4598,21 @@
         zone: Optional[Zone] = None,
         order_by: ListRoutesRequestOrderBy = ListRoutesRequestOrderBy.CREATED_AT_ASC,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         frontend_id: Optional[str] = None,
     ) -> ListRoutesResponse:
         """
-        List all backend redirections
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param order_by: Response order
-        :param page_size: The number of items to return
-        :param page: Page number
-        :param frontend_id:
+        List all routes.
+        List all routes for a given frontend. The response is an array of routes, each one  with a specified backend to direct to if a certain condition is matched (based on the value of the SNI field or HTTP Host header).
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param order_by: Sort order of routes in the response.
+        :param page_size: The number of route objects to return.
+        :param page: The page number to return, from the paginated results.
+        :param frontend_id: Frontend ID to filter for, only Routes from this Frontend will be returned.
         :return: :class:`ListRoutesResponse <ListRoutesResponse>`
 
         Usage:
         ::
 
             result = await api.list_routes()
         """
@@ -4581,20 +4639,21 @@
         zone: Optional[Zone] = None,
         order_by: Optional[ListRoutesRequestOrderBy] = None,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
         frontend_id: Optional[str] = None,
     ) -> List[Route]:
         """
-        List all backend redirections
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param order_by: Response order
-        :param page_size: The number of items to return
-        :param page: Page number
-        :param frontend_id:
+        List all routes.
+        List all routes for a given frontend. The response is an array of routes, each one  with a specified backend to direct to if a certain condition is matched (based on the value of the SNI field or HTTP Host header).
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param order_by: Sort order of routes in the response.
+        :param page_size: The number of route objects to return.
+        :param page: The page number to return, from the paginated results.
+        :param frontend_id: Frontend ID to filter for, only Routes from this Frontend will be returned.
         :return: :class:`List[ListRoutesResponse] <List[ListRoutesResponse]>`
 
         Usage:
         ::
 
             result = await api.list_routes_all()
         """
@@ -4617,19 +4676,20 @@
         *,
         frontend_id: str,
         backend_id: str,
         zone: Optional[Zone] = None,
         match: Optional[RouteMatch] = None,
     ) -> Route:
         """
-        Create a backend redirection
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param frontend_id: Origin of redirection
-        :param backend_id: Destination of destination
-        :param match: Value to match a redirection
+        Create a route.
+        Create a new route on a given frontend. To configure a route, specify the backend to direct to if a certain condition is matched (based on the value of the SNI field or HTTP Host header).
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param frontend_id: ID of the source frontend to create the route on.
+        :param backend_id: ID of the target backend for the route.
+        :param match: Object defining the match condition for a route to be applied. If an incoming client session matches the specified condition (i.e. it has a matching SNI value or HTTP Host header value), it will be passed to the target backend.
         :return: :class:`Route <Route>`
 
         Usage:
         ::
 
             result = await api.create_route(
                 frontend_id="example",
@@ -4659,17 +4719,18 @@
     async def get_route(
         self,
         *,
         route_id: str,
         zone: Optional[Zone] = None,
     ) -> Route:
         """
-        Get single backend redirection
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param route_id: Id of route to get
+        Get a route.
+        Retrieve information about an existing route, specified by its route ID. Its full details, origin frontend, target backend and match condition, are returned in the response object.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param route_id: Route ID.
         :return: :class:`Route <Route>`
 
         Usage:
         ::
 
             result = await api.get_route(route_id="example")
         """
@@ -4690,19 +4751,20 @@
         *,
         route_id: str,
         backend_id: str,
         zone: Optional[Zone] = None,
         match: Optional[RouteMatch] = None,
     ) -> Route:
         """
-        Edit a backend redirection
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param route_id: Route id to update
-        :param backend_id: Backend id of redirection
-        :param match: Value to match a redirection
+        Update a route.
+        Update the configuration of an existing route, specified by its route ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param route_id: Route ID.
+        :param backend_id: ID of the target backend for the route.
+        :param match: Object defining the match condition for a route to be applied. If an incoming client session matches the specified condition (i.e. it has a matching SNI value or HTTP Host header value), it will be passed to the target backend.
         :return: :class:`Route <Route>`
 
         Usage:
         ::
 
             result = await api.update_route(
                 route_id="example",
@@ -4733,17 +4795,18 @@
     async def delete_route(
         self,
         *,
         route_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete a backend redirection
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param route_id: Route id to delete
+        Delete a route.
+        Delete an existing route, specified by its route ID. Deleting a route is permanent, and cannot be undone.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param route_id: Route ID.
 
         Usage:
         ::
 
             result = await api.delete_route(route_id="example")
         """
 
@@ -4759,19 +4822,21 @@
         return None
 
     async def get_lb_stats(
         self,
         *,
         lb_id: str,
         zone: Optional[Zone] = None,
+        backend_id: Optional[str] = None,
     ) -> LbStats:
         """
-        Get usage statistics of a given load balancer
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param lb_id: Load balancer ID
+        Get usage statistics of a given Load Balancer.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: Load Balancer ID.
+        :param backend_id: ID of the backend.
         :return: :class:`LbStats <LbStats>`
         :deprecated
 
         Usage:
         ::
 
             result = await api.get_lb_stats(lb_id="example")
@@ -4779,42 +4844,55 @@
 
         param_zone = validate_path_param("zone", zone or self.client.default_zone)
         param_lb_id = validate_path_param("lb_id", lb_id)
 
         res = self._request(
             "GET",
             f"/lb/v1/zones/{param_zone}/lbs/{param_lb_id}/stats",
+            params={
+                "backend_id": backend_id,
+            },
         )
 
         self._throw_on_error(res)
         return unmarshal_LbStats(res.json())
 
     async def list_backend_stats(
         self,
         *,
         lb_id: str,
         zone: Optional[Zone] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
+        backend_id: Optional[str] = None,
     ) -> ListBackendStatsResponse:
         """
+        List backend server statistics.
+        List information about your backend servers, including their state and the result of their last health check.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: Load Balancer ID.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: Number of items to return.
+        :param backend_id: ID of the backend.
+        :return: :class:`ListBackendStatsResponse <ListBackendStatsResponse>`
 
         Usage:
         ::
 
             result = await api.list_backend_stats(lb_id="example")
         """
 
         param_zone = validate_path_param("zone", zone or self.client.default_zone)
         param_lb_id = validate_path_param("lb_id", lb_id)
 
         res = self._request(
             "GET",
             f"/lb/v1/zones/{param_zone}/lbs/{param_lb_id}/backend-stats",
             params={
+                "backend_id": backend_id,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
             },
         )
 
         self._throw_on_error(res)
         return unmarshal_ListBackendStatsResponse(res.json())
@@ -4822,16 +4900,24 @@
     async def list_backend_stats_all(
         self,
         *,
         lb_id: str,
         zone: Optional[Zone] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
+        backend_id: Optional[str] = None,
     ) -> List[BackendServerStats]:
         """
+        List backend server statistics.
+        List information about your backend servers, including their state and the result of their last health check.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: Load Balancer ID.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: Number of items to return.
+        :param backend_id: ID of the backend.
         :return: :class:`List[ListBackendStatsResponse] <List[ListBackendStatsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_backend_stats_all(lb_id="example")
         """
@@ -4841,35 +4927,37 @@
             key="backend_servers_stats",
             fetcher=self.list_backend_stats,
             args={
                 "lb_id": lb_id,
                 "zone": zone,
                 "page": page,
                 "page_size": page_size,
+                "backend_id": backend_id,
             },
         )
 
     async def list_acls(
         self,
         *,
         frontend_id: str,
         zone: Optional[Zone] = None,
         order_by: ListAclRequestOrderBy = ListAclRequestOrderBy.CREATED_AT_ASC,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         name: Optional[str] = None,
     ) -> ListAclResponse:
         """
-        List ACL for a given frontend
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param frontend_id: ID of your frontend
-        :param order_by: Response order
-        :param page: Page number
-        :param page_size: The number of items to return
-        :param name: Filter acl per name
+        List ACLs for a given frontend.
+        List the ACLs for a given frontend, specified by its frontend ID. The response is an array of ACL objects, each one representing an ACL that denies or allows traffic based on certain conditions.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param frontend_id: Frontend ID (ACLs attached to this frontend will be returned in the response).
+        :param order_by: Sort order of ACLs in the response.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: The number of ACLs to return.
+        :param name: ACL name to filter for.
         :return: :class:`ListAclResponse <ListAclResponse>`
 
         Usage:
         ::
 
             result = await api.list_acls(frontend_id="example")
         """
@@ -4898,21 +4986,22 @@
         zone: Optional[Zone] = None,
         order_by: Optional[ListAclRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         name: Optional[str] = None,
     ) -> List[Acl]:
         """
-        List ACL for a given frontend
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param frontend_id: ID of your frontend
-        :param order_by: Response order
-        :param page: Page number
-        :param page_size: The number of items to return
-        :param name: Filter acl per name
+        List ACLs for a given frontend.
+        List the ACLs for a given frontend, specified by its frontend ID. The response is an array of ACL objects, each one representing an ACL that denies or allows traffic based on certain conditions.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param frontend_id: Frontend ID (ACLs attached to this frontend will be returned in the response).
+        :param order_by: Sort order of ACLs in the response.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: The number of ACLs to return.
+        :param name: ACL name to filter for.
         :return: :class:`List[ListAclResponse] <List[ListAclResponse]>`
 
         Usage:
         ::
 
             result = await api.list_acls_all(frontend_id="example")
         """
@@ -4939,27 +5028,23 @@
         index: int,
         description: str,
         zone: Optional[Zone] = None,
         name: Optional[str] = None,
         match: Optional[AclMatch] = None,
     ) -> Acl:
         """
-        Create an ACL for a given frontend
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param frontend_id: ID of your frontend
-        :param name: Name of your ACL ressource
-        :param action: Action to undertake when an ACL filter matches
-        :param match: The ACL match rule. You can have one of those three cases:
-
-          - `ip_subnet` is defined
-          - `http_filter` and `http_filter_value` are defined
-          - `ip_subnet`, `http_filter` and `http_filter_value` are defined
-
-        :param index: Order between your Acls (ascending order, 0 is first acl executed)
-        :param description: Description of your ACL ressource
+        Create an ACL for a given frontend.
+        Create a new ACL for a given frontend. Each ACL must have a name, an action to perform (allow or deny), and a match rule (the action is carried out when the incoming traffic matches the rule).
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param frontend_id: Frontend ID to attach the ACL to.
+        :param name: ACL name.
+        :param action: Action to take when incoming traffic matches an ACL filter.
+        :param match: ACL match filter object. One of `ip_subnet` or `http_filter` & `http_filter_value` are required.
+        :param index: Priority of this ACL (ACLs are applied in ascending order, 0 is the first ACL executed).
+        :param description: ACL description.
         :return: :class:`Acl <Acl>`
 
         Usage:
         ::
 
             result = await api.create_acl(
                 frontend_id="example",
@@ -4995,17 +5080,18 @@
     async def get_acl(
         self,
         *,
         acl_id: str,
         zone: Optional[Zone] = None,
     ) -> Acl:
         """
-        Get an ACL
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param acl_id: ID of your ACL ressource
+        Get an ACL.
+        Get information for a particular ACL, specified by its ACL ID. The response returns full details of the ACL, including its name, action, match rule and frontend.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param acl_id: ACL ID.
         :return: :class:`Acl <Acl>`
 
         Usage:
         ::
 
             result = await api.get_acl(acl_id="example")
         """
@@ -5029,22 +5115,23 @@
         action: AclAction,
         index: int,
         zone: Optional[Zone] = None,
         match: Optional[AclMatch] = None,
         description: Optional[str] = None,
     ) -> Acl:
         """
-        Update an ACL
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param acl_id: ID of your ACL ressource
-        :param name: Name of your ACL ressource
-        :param action: Action to undertake when an ACL filter matches
-        :param match: The ACL match rule. At least `ip_subnet` or `http_filter` and `http_filter_value` are required
-        :param index: Order between your Acls (ascending order, 0 is first acl executed)
-        :param description: Description of your ACL ressource
+        Update an ACL.
+        Update a particular ACL, specified by its ACL ID. You can update details including its name, action and match rule.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param acl_id: ACL ID.
+        :param name: ACL name.
+        :param action: Action to take when incoming traffic matches an ACL filter.
+        :param match: ACL match filter object. One of `ip_subnet` or `http_filter` & `http_filter_value` are required.
+        :param index: Priority of this ACL (ACLs are applied in ascending order, 0 is the first ACL executed).
+        :param description: ACL description.
         :return: :class:`Acl <Acl>`
 
         Usage:
         ::
 
             result = await api.update_acl(
                 acl_id="example",
@@ -5080,17 +5167,18 @@
     async def delete_acl(
         self,
         *,
         acl_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete an ACL
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param acl_id: ID of your ACL ressource
+        Delete an ACL.
+        Delete an ACL, specified by its ACL ID. Deleting an ACL is irreversible and cannot be undone.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param acl_id: ACL ID.
 
         Usage:
         ::
 
             result = await api.delete_acl(acl_id="example")
         """
 
@@ -5109,18 +5197,19 @@
         self,
         *,
         frontend_id: str,
         acls: List[AclSpec],
         zone: Optional[Zone] = None,
     ) -> SetAclsResponse:
         """
-        Set all ACLs for a given frontend
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param frontend_id: The Frontend to change ACL to
-        :param acls: Array of ACLs to erease the existing ACLs
+        Define all ACLs for a given frontend.
+        For a given frontend specified by its frontend ID, define and add the complete set of ACLS for that frontend. Any existing ACLs on this frontend will be removed.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param frontend_id: Frontend ID.
+        :param acls: List of ACLs for this frontend. Any other existing ACLs on this frontend will be removed.
         :return: :class:`SetAclsResponse <SetAclsResponse>`
 
         Usage:
         ::
 
             result = await api.set_acls(
                 frontend_id="example",
@@ -5153,22 +5242,23 @@
         lb_id: str,
         zone: Optional[Zone] = None,
         name: Optional[str] = None,
         letsencrypt: Optional[CreateCertificateRequestLetsencryptConfig] = None,
         custom_certificate: Optional[CreateCertificateRequestCustomCertificate] = None,
     ) -> Certificate:
         """
-        Generate a new TLS certificate using Let's Encrypt or import your certificate.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param lb_id: Load balancer ID
-        :param name: Certificate name
-        :param letsencrypt: Let's Encrypt type.
+        Create an SSL/TLS certificate.
+        Generate a new SSL/TLS certificate for a given Load Balancer. You can choose to create a Let's Encrypt certificate, or import a custom certificate.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: Load Balancer ID.
+        :param name: Name for the certificate.
+        :param letsencrypt: Object to define a new Let's Encrypt certificate to be generated.
 
         One-of ('type_'): at most one of 'letsencrypt', 'custom_certificate' could be set.
-        :param custom_certificate: Custom import certificate.
+        :param custom_certificate: Object to define an existing custom certificate to be imported.
 
         One-of ('type_'): at most one of 'letsencrypt', 'custom_certificate' could be set.
         :return: :class:`Certificate <Certificate>`
 
         Usage:
         ::
 
@@ -5181,15 +5271,15 @@
         res = self._request(
             "POST",
             f"/lb/v1/zones/{param_zone}/lbs/{param_lb_id}/certificates",
             body=marshal_ZonedApiCreateCertificateRequest(
                 ZonedApiCreateCertificateRequest(
                     lb_id=lb_id,
                     zone=zone,
-                    name=name or random_name(prefix="certiticate"),
+                    name=name or random_name(prefix="certificate"),
                     letsencrypt=letsencrypt,
                     custom_certificate=custom_certificate,
                 ),
                 self.client,
             ),
         )
 
@@ -5203,21 +5293,22 @@
         zone: Optional[Zone] = None,
         order_by: ListCertificatesRequestOrderBy = ListCertificatesRequestOrderBy.CREATED_AT_ASC,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         name: Optional[str] = None,
     ) -> ListCertificatesResponse:
         """
-        List all TLS certificates on a given load balancer
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param lb_id: Load balancer ID
-        :param order_by: Response order
-        :param page: Page number
-        :param page_size: The number of items to return
-        :param name: Use this to search by name
+        List all SSL/TLS certificates on a given Load Balancer.
+        List all the SSL/TLS certificates on a given Load Balancer. The response is an array of certificate objects, which are by default listed in ascending order of creation date.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: Load Balancer ID.
+        :param order_by: Sort order of certificates in the response.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: Number of certificates to return.
+        :param name: Certificate name to filter for, only certificates of this name will be returned.
         :return: :class:`ListCertificatesResponse <ListCertificatesResponse>`
 
         Usage:
         ::
 
             result = await api.list_certificates(lb_id="example")
         """
@@ -5246,21 +5337,22 @@
         zone: Optional[Zone] = None,
         order_by: Optional[ListCertificatesRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         name: Optional[str] = None,
     ) -> List[Certificate]:
         """
-        List all TLS certificates on a given load balancer
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param lb_id: Load balancer ID
-        :param order_by: Response order
-        :param page: Page number
-        :param page_size: The number of items to return
-        :param name: Use this to search by name
+        List all SSL/TLS certificates on a given Load Balancer.
+        List all the SSL/TLS certificates on a given Load Balancer. The response is an array of certificate objects, which are by default listed in ascending order of creation date.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: Load Balancer ID.
+        :param order_by: Sort order of certificates in the response.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: Number of certificates to return.
+        :param name: Certificate name to filter for, only certificates of this name will be returned.
         :return: :class:`List[ListCertificatesResponse] <List[ListCertificatesResponse]>`
 
         Usage:
         ::
 
             result = await api.list_certificates_all(lb_id="example")
         """
@@ -5282,17 +5374,18 @@
     async def get_certificate(
         self,
         *,
         certificate_id: str,
         zone: Optional[Zone] = None,
     ) -> Certificate:
         """
-        Get a TLS certificate
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param certificate_id: Certificate ID
+        Get an SSL/TLS certificate.
+        Get information for a particular SSL/TLS certificate, specified by its certificate ID. The response returns full details of the certificate, including its type, main domain name, and alternative domain names.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param certificate_id: Certificate ID.
         :return: :class:`Certificate <Certificate>`
 
         Usage:
         ::
 
             result = await api.get_certificate(certificate_id="example")
         """
@@ -5315,16 +5408,16 @@
         zone: Optional[Zone] = None,
         options: Optional[
             WaitForOptions[Certificate, Union[bool, Awaitable[bool]]]
         ] = None,
     ) -> Certificate:
         """
         Waits for :class:`Certificate <Certificate>` to be in a final state.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param certificate_id: Certificate ID
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param certificate_id: Certificate ID.
         :param options: The options for the waiter
         :return: :class:`Certificate <Certificate>`
 
         Usage:
         ::
 
             result = api.wait_for_certificate(certificate_id="example")
@@ -5349,18 +5442,19 @@
         self,
         *,
         certificate_id: str,
         name: str,
         zone: Optional[Zone] = None,
     ) -> Certificate:
         """
-        Update a TLS certificate
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param certificate_id: Certificate ID
-        :param name: Certificate name
+        Update an SSL/TLS certificate.
+        Update the name of a particular SSL/TLS certificate, specified by its certificate ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param certificate_id: Certificate ID.
+        :param name: Certificate name.
         :return: :class:`Certificate <Certificate>`
 
         Usage:
         ::
 
             result = await api.update_certificate(
                 certificate_id="example",
@@ -5390,17 +5484,18 @@
     async def delete_certificate(
         self,
         *,
         certificate_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete a TLS certificate
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param certificate_id: Certificate ID
+        Delete an SSL/TLS certificate.
+        Delete an SSL/TLS certificate, specified by its certificate ID. Deleting a certificate is irreversible and cannot be undone.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param certificate_id: Certificate ID.
 
         Usage:
         ::
 
             result = await api.delete_certificate(certificate_id="example")
         """
 
@@ -5419,18 +5514,19 @@
         self,
         *,
         zone: Optional[Zone] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListLbTypesResponse:
         """
-        List all load balancer offer type
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param page: Page number
-        :param page_size: The number of items to return
+        List all Load Balancer offer types.
+        List all the different commercial Load Balancer types. The response includes an array of offer types, each with a name, description, and information about its stock availability.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: The number of items to return.
         :return: :class:`ListLbTypesResponse <ListLbTypesResponse>`
 
         Usage:
         ::
 
             result = await api.list_lb_types()
         """
@@ -5453,18 +5549,19 @@
         self,
         *,
         zone: Optional[Zone] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[LbType]:
         """
-        List all load balancer offer type
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param page: Page number
-        :param page_size: The number of items to return
+        List all Load Balancer offer types.
+        List all the different commercial Load Balancer types. The response includes an array of offer types, each with a name, description, and information about its stock availability.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: The number of items to return.
         :return: :class:`List[ListLbTypesResponse] <List[ListLbTypesResponse]>`
 
         Usage:
         ::
 
             result = await api.list_lb_types_all()
         """
@@ -5487,27 +5584,28 @@
         zone: Optional[Zone] = None,
         email_config: Optional[SubscriberEmailConfig] = None,
         webhook_config: Optional[SubscriberWebhookConfig] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> Subscriber:
         """
-        Create a subscriber, webhook or email
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param name: Subscriber name
+        Create a subscriber.
+        Create a new subscriber, either with an email configuration or a webhook configuration, for a specified Scaleway Project.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param name: Subscriber name.
         :param email_config: Email address configuration.
 
         One-of ('config'): at most one of 'email_config', 'webhook_config' could be set.
         :param webhook_config: WebHook URI configuration.
 
         One-of ('config'): at most one of 'email_config', 'webhook_config' could be set.
-        :param organization_id: Owner of resources.
+        :param organization_id: Organization ID to create the subscriber in.
 
         One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
-        :param project_id: Assign the resource to a project ID.
+        :param project_id: Project ID to create the subscriber in.
 
         One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
         :return: :class:`Subscriber <Subscriber>`
 
         Usage:
         ::
 
@@ -5538,17 +5636,18 @@
     async def get_subscriber(
         self,
         *,
         subscriber_id: str,
         zone: Optional[Zone] = None,
     ) -> Subscriber:
         """
-        Get a subscriber
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param subscriber_id: Subscriber ID
+        Get a subscriber.
+        Retrieve information about an existing subscriber, specified by its subscriber ID. Its full details, including name and email/webhook configuration, are returned in the response object.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param subscriber_id: Subscriber ID.
         :return: :class:`Subscriber <Subscriber>`
 
         Usage:
         ::
 
             result = await api.get_subscriber(subscriber_id="example")
         """
@@ -5572,22 +5671,23 @@
         order_by: ListSubscriberRequestOrderBy = ListSubscriberRequestOrderBy.CREATED_AT_ASC,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> ListSubscriberResponse:
         """
-        List all subscriber
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param order_by: Response order
-        :param page: Page number
-        :param page_size: The number of items to return
-        :param name: Use this to search by name
-        :param organization_id: Filter Subscribers by organization ID
-        :param project_id: Filter Subscribers by project ID
+        List all subscribers.
+        List all subscribers to Load Balancer alerts. By default, returns all subscribers to Load Balancer alerts for the Organization associated with the authentication token used for the request.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param order_by: Sort order of subscribers in the response.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: The number of items to return.
+        :param name: Subscriber name to search for.
+        :param organization_id: Filter subscribers by Organization ID.
+        :param project_id: Filter subscribers by Project ID.
         :return: :class:`ListSubscriberResponse <ListSubscriberResponse>`
 
         Usage:
         ::
 
             result = await api.list_subscriber(name="example")
         """
@@ -5619,22 +5719,23 @@
         order_by: Optional[ListSubscriberRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> List[Subscriber]:
         """
-        List all subscriber
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param order_by: Response order
-        :param page: Page number
-        :param page_size: The number of items to return
-        :param name: Use this to search by name
-        :param organization_id: Filter Subscribers by organization ID
-        :param project_id: Filter Subscribers by project ID
+        List all subscribers.
+        List all subscribers to Load Balancer alerts. By default, returns all subscribers to Load Balancer alerts for the Organization associated with the authentication token used for the request.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param order_by: Sort order of subscribers in the response.
+        :param page: The page number to return, from the paginated results.
+        :param page_size: The number of items to return.
+        :param name: Subscriber name to search for.
+        :param organization_id: Filter subscribers by Organization ID.
+        :param project_id: Filter subscribers by Project ID.
         :return: :class:`List[ListSubscriberResponse] <List[ListSubscriberResponse]>`
 
         Usage:
         ::
 
             result = await api.list_subscriber_all(name="example")
         """
@@ -5660,22 +5761,23 @@
         subscriber_id: str,
         name: str,
         zone: Optional[Zone] = None,
         email_config: Optional[SubscriberEmailConfig] = None,
         webhook_config: Optional[SubscriberWebhookConfig] = None,
     ) -> Subscriber:
         """
-        Update a subscriber
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param subscriber_id: Assign the resource to a project IDs
-        :param name: Subscriber name
+        Update a subscriber.
+        Update the parameters of a given subscriber (e.g. name, webhook configuration, email configuration), specified by its subscriber ID.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param subscriber_id: Subscriber ID.
+        :param name: Subscriber name.
         :param email_config: Email address configuration.
 
         One-of ('config'): at most one of 'email_config', 'webhook_config' could be set.
-        :param webhook_config: WebHook URI configuration.
+        :param webhook_config: Webhook URI configuration.
 
         One-of ('config'): at most one of 'email_config', 'webhook_config' could be set.
         :return: :class:`Subscriber <Subscriber>`
 
         Usage:
         ::
 
@@ -5709,17 +5811,18 @@
     async def delete_subscriber(
         self,
         *,
         subscriber_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete a subscriber
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param subscriber_id: Subscriber ID
+        Delete a subscriber.
+        Delete an existing subscriber, specified by its subscriber ID. Deleting a subscriber is permanent, and cannot be undone.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param subscriber_id: Subscriber ID.
 
         Usage:
         ::
 
             result = await api.delete_subscriber(subscriber_id="example")
         """
 
@@ -5738,18 +5841,19 @@
         self,
         *,
         lb_id: str,
         subscriber_id: str,
         zone: Optional[Zone] = None,
     ) -> Lb:
         """
-        Subscribe a subscriber to a given load balancer
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param lb_id: Load balancer ID
-        :param subscriber_id: Subscriber ID
+        Subscribe a subscriber to alerts for a given Load Balancer.
+        Subscribe an existing subscriber to alerts for a given Load Balancer.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: Load Balancer ID.
+        :param subscriber_id: Subscriber ID.
         :return: :class:`Lb <Lb>`
 
         Usage:
         ::
 
             result = await api.subscribe_to_lb(
                 lb_id="example",
@@ -5779,17 +5883,18 @@
     async def unsubscribe_from_lb(
         self,
         *,
         lb_id: str,
         zone: Optional[Zone] = None,
     ) -> Lb:
         """
-        Unsubscribe a subscriber from a given load balancer
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param lb_id: Load balancer ID
+        Unsubscribe a subscriber from alerts for a given Load Balancer.
+        Unsubscribe a subscriber from alerts for a given Load Balancer. The subscriber is not deleted, and can be resubscribed in the future if necessary.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: Load Balancer ID.
         :return: :class:`Lb <Lb>`
 
         Usage:
         ::
 
             result = await api.unsubscribe_from_lb(lb_id="example")
         """
@@ -5811,20 +5916,21 @@
         lb_id: str,
         zone: Optional[Zone] = None,
         order_by: ListPrivateNetworksRequestOrderBy = ListPrivateNetworksRequestOrderBy.CREATED_AT_ASC,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
     ) -> ListLbPrivateNetworksResponse:
         """
-        List attached private network of load balancer
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param lb_id: Load balancer ID
-        :param order_by: Response order
-        :param page_size: The number of items to return
-        :param page: Page number
+        List Private Networks attached to a Load Balancer.
+        List the Private Networks attached to a given Load Balancer, specified by its Load Balancer ID. The response is an array of Private Network objects, giving information including the status, configuration, name and creation date of each Private Network.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: Load Balancer ID.
+        :param order_by: Sort order of Private Network objects in the response.
+        :param page_size: Number of objects to return.
+        :param page: The page number to return, from the paginated results.
         :return: :class:`ListLbPrivateNetworksResponse <ListLbPrivateNetworksResponse>`
 
         Usage:
         ::
 
             result = await api.list_lb_private_networks(lb_id="example")
         """
@@ -5851,20 +5957,21 @@
         lb_id: str,
         zone: Optional[Zone] = None,
         order_by: Optional[ListPrivateNetworksRequestOrderBy] = None,
         page_size: Optional[int] = None,
         page: Optional[int] = None,
     ) -> List[PrivateNetwork]:
         """
-        List attached private network of load balancer
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param lb_id: Load balancer ID
-        :param order_by: Response order
-        :param page_size: The number of items to return
-        :param page: Page number
+        List Private Networks attached to a Load Balancer.
+        List the Private Networks attached to a given Load Balancer, specified by its Load Balancer ID. The response is an array of Private Network objects, giving information including the status, configuration, name and creation date of each Private Network.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: Load Balancer ID.
+        :param order_by: Sort order of Private Network objects in the response.
+        :param page_size: Number of objects to return.
+        :param page: The page number to return, from the paginated results.
         :return: :class:`List[ListLbPrivateNetworksResponse] <List[ListLbPrivateNetworksResponse]>`
 
         Usage:
         ::
 
             result = await api.list_lb_private_networks_all(lb_id="example")
         """
@@ -5889,22 +5996,23 @@
         private_network_id: str,
         zone: Optional[Zone] = None,
         static_config: Optional[PrivateNetworkStaticConfig] = None,
         dhcp_config: Optional[PrivateNetworkDHCPConfig] = None,
         ipam_config: Optional[PrivateNetworkIpamConfig] = None,
     ) -> PrivateNetwork:
         """
-        Add load balancer on instance private network
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param lb_id: Load balancer ID
-        :param private_network_id: Set your instance private network id
-        :param static_config: Define two local ip address of your choice for each load balancer instance.
+        Attach a Load Balancer to a Private Network.
+        Attach a specified Load Balancer to a specified Private Network, defining a static or DHCP configuration for the Load Balancer on the network.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: Load Balancer ID.
+        :param private_network_id: Private Network ID.
+        :param static_config: Object containing an array of a local IP address for the Load Balancer on this Private Network.
 
         One-of ('config'): at most one of 'static_config', 'dhcp_config', 'ipam_config' could be set.
-        :param dhcp_config: Set to true if you want to let DHCP assign IP addresses.
+        :param dhcp_config: Defines whether to let DHCP assign IP addresses.
 
         One-of ('config'): at most one of 'static_config', 'dhcp_config', 'ipam_config' could be set.
         :param ipam_config: For internal use only.
 
         One-of ('config'): at most one of 'static_config', 'dhcp_config', 'ipam_config' could be set.
         :return: :class:`PrivateNetwork <PrivateNetwork>`
 
@@ -5946,18 +6054,19 @@
         self,
         *,
         lb_id: str,
         private_network_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Remove load balancer of private network
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param lb_id: Load balancer ID
-        :param private_network_id: Set your instance private network id
+        Detach Load Balancer from Private Network.
+        Detach a specified Load Balancer from a specified Private Network.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param lb_id: Load balancer ID.
+        :param private_network_id: Set your instance private network id.
 
         Usage:
         ::
 
             result = await api.detach_private_network(
                 lb_id="example",
                 private_network_id="example",
```

### Comparing `scaleway_async-0.9.0/scaleway_async/lb/v1/content.py` & `scaleway_async-1.0.0/scaleway_async/lb/v1/content.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-0.9.0/scaleway_async/lb/v1/marshalling.py` & `scaleway_async-1.0.0/scaleway_async/rdb/v1/marshalling.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,2107 +1,1879 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 
 from typing import Any, Dict
 
 from scaleway_core.profile import ProfileDefaults
+from scaleway_core.bridge import (
+    unmarshal_TimeSeries,
+)
 from scaleway_core.utils import (
     OneOfPossibility,
     resolve_one_of,
 )
 from dateutil import parser
 from .types import (
-    AclActionRedirectRedirectType,
-    AclActionType,
-    AclHttpFilter,
-    ForwardPortAlgorithm,
-    OnMarkedDownAction,
-    Protocol,
-    ProxyProtocol,
-    SSLCompatibilityLevel,
-    StickySessionsType,
-    Acl,
-    AclAction,
-    AclActionRedirect,
-    AclMatch,
-    AclSpec,
-    Backend,
-    BackendServerStats,
-    Certificate,
-    CreateCertificateRequestCustomCertificate,
-    CreateCertificateRequestLetsencryptConfig,
-    Frontend,
-    HealthCheck,
-    HealthCheckHttpConfig,
-    HealthCheckHttpsConfig,
-    HealthCheckLdapConfig,
-    HealthCheckMysqlConfig,
-    HealthCheckPgsqlConfig,
-    HealthCheckRedisConfig,
-    HealthCheckTcpConfig,
+    Permission,
+    VolumeType,
+    ACLRule,
+    ACLRuleRequest,
+    AddInstanceACLRulesResponse,
+    AddInstanceSettingsResponse,
+    BackupSchedule,
+    Database,
+    DatabaseBackup,
+    DatabaseEngine,
+    DeleteInstanceACLRulesResponse,
+    DeleteInstanceSettingsResponse,
+    Endpoint,
+    EndpointDirectAccessDetails,
+    EndpointLoadBalancerDetails,
+    EndpointPrivateNetworkDetails,
+    EndpointSpec,
+    EndpointSpecLoadBalancer,
+    EndpointSpecPrivateNetwork,
+    EndpointSpecPrivateNetworkIpamConfig,
+    EngineSetting,
+    EngineVersion,
     Instance,
-    Ip,
-    Lb,
-    LbStats,
-    LbType,
-    ListAclResponse,
-    ListBackendStatsResponse,
-    ListBackendsResponse,
-    ListCertificatesResponse,
-    ListFrontendsResponse,
-    ListIpsResponse,
-    ListLbPrivateNetworksResponse,
-    ListLbTypesResponse,
-    ListLbsResponse,
-    ListRoutesResponse,
-    ListSubscriberResponse,
-    PrivateNetwork,
-    PrivateNetworkDHCPConfig,
-    PrivateNetworkIpamConfig,
-    PrivateNetworkStaticConfig,
-    Route,
-    RouteMatch,
-    SetAclsResponse,
-    Subscriber,
-    SubscriberEmailConfig,
-    SubscriberWebhookConfig,
-    CreateLbRequest,
-    UpdateLbRequest,
-    MigrateLbRequest,
-    CreateIpRequest,
-    UpdateIpRequest,
-    CreateBackendRequest,
-    UpdateBackendRequest,
-    AddBackendServersRequest,
-    RemoveBackendServersRequest,
-    SetBackendServersRequest,
-    UpdateHealthCheckRequest,
-    CreateFrontendRequest,
-    UpdateFrontendRequest,
-    CreateRouteRequest,
-    UpdateRouteRequest,
-    CreateAclRequest,
-    UpdateAclRequest,
-    CreateCertificateRequest,
-    UpdateCertificateRequest,
-    CreateSubscriberRequest,
-    UpdateSubscriberRequest,
-    SubscribeToLbRequest,
-    AttachPrivateNetworkRequest,
-    ZonedApiCreateLbRequest,
-    ZonedApiUpdateLbRequest,
-    ZonedApiMigrateLbRequest,
-    ZonedApiCreateIpRequest,
-    ZonedApiUpdateIpRequest,
-    ZonedApiCreateBackendRequest,
-    ZonedApiUpdateBackendRequest,
-    ZonedApiAddBackendServersRequest,
-    ZonedApiRemoveBackendServersRequest,
-    ZonedApiSetBackendServersRequest,
-    ZonedApiUpdateHealthCheckRequest,
-    ZonedApiCreateFrontendRequest,
-    ZonedApiUpdateFrontendRequest,
-    ZonedApiCreateRouteRequest,
-    ZonedApiUpdateRouteRequest,
-    ZonedApiCreateAclRequest,
-    ZonedApiUpdateAclRequest,
-    ZonedApiSetAclsRequest,
-    ZonedApiCreateCertificateRequest,
-    ZonedApiUpdateCertificateRequest,
-    ZonedApiCreateSubscriberRequest,
-    ZonedApiUpdateSubscriberRequest,
-    ZonedApiSubscribeToLbRequest,
-    ZonedApiAttachPrivateNetworkRequest,
+    InstanceLog,
+    InstanceMetrics,
+    InstanceSetting,
+    ListDatabaseBackupsResponse,
+    ListDatabaseEnginesResponse,
+    ListDatabasesResponse,
+    ListInstanceACLRulesResponse,
+    ListInstanceLogsDetailsResponse,
+    ListInstanceLogsDetailsResponseInstanceLogDetail,
+    ListInstanceLogsResponse,
+    ListInstancesResponse,
+    ListNodeTypesResponse,
+    ListPrivilegesResponse,
+    ListSnapshotsResponse,
+    ListUsersResponse,
+    LogsPolicy,
+    Maintenance,
+    NodeType,
+    NodeTypeVolumeConstraintSizes,
+    NodeTypeVolumeType,
+    PrepareInstanceLogsResponse,
+    Privilege,
+    ReadReplica,
+    ReadReplicaEndpointSpec,
+    ReadReplicaEndpointSpecDirectAccess,
+    ReadReplicaEndpointSpecPrivateNetwork,
+    ReadReplicaEndpointSpecPrivateNetworkIpamConfig,
+    SetInstanceACLRulesResponse,
+    SetInstanceSettingsResponse,
+    Snapshot,
+    UpgradableVersion,
+    User,
+    Volume,
+    CreateDatabaseBackupRequest,
+    UpdateDatabaseBackupRequest,
+    RestoreDatabaseBackupRequest,
+    UpgradeInstanceRequest,
+    CreateInstanceRequest,
+    UpdateInstanceRequest,
+    CloneInstanceRequest,
+    CreateReadReplicaRequest,
+    CreateReadReplicaEndpointRequest,
+    PrepareInstanceLogsRequest,
+    PurgeInstanceLogsRequest,
+    AddInstanceSettingsRequest,
+    DeleteInstanceSettingsRequest,
+    SetInstanceSettingsRequest,
+    AddInstanceACLRulesRequest,
+    SetInstanceACLRulesRequest,
+    DeleteInstanceACLRulesRequest,
+    CreateUserRequest,
+    UpdateUserRequest,
+    CreateDatabaseRequest,
+    SetPrivilegeRequest,
+    CreateSnapshotRequest,
+    UpdateSnapshotRequest,
+    CreateInstanceFromSnapshotRequest,
+    CreateEndpointRequest,
+    MigrateEndpointRequest,
 )
 
 
-def unmarshal_SubscriberEmailConfig(data: Any) -> SubscriberEmailConfig:
+def unmarshal_EndpointDirectAccessDetails(data: Any) -> EndpointDirectAccessDetails:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'SubscriberEmailConfig' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'EndpointDirectAccessDetails' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("email")
-    args["email"] = field
-
-    return SubscriberEmailConfig(**args)
+    return EndpointDirectAccessDetails(**args)
 
 
-def unmarshal_SubscriberWebhookConfig(data: Any) -> SubscriberWebhookConfig:
+def unmarshal_EndpointLoadBalancerDetails(data: Any) -> EndpointLoadBalancerDetails:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'SubscriberWebhookConfig' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'EndpointLoadBalancerDetails' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("uri")
-    args["uri"] = field
+    return EndpointLoadBalancerDetails(**args)
 
-    return SubscriberWebhookConfig(**args)
 
-
-def unmarshal_HealthCheckHttpConfig(data: Any) -> HealthCheckHttpConfig:
+def unmarshal_EndpointPrivateNetworkDetails(data: Any) -> EndpointPrivateNetworkDetails:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'HealthCheckHttpConfig' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'EndpointPrivateNetworkDetails' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("code")
-    args["code"] = field
-
-    field = data.get("host_header")
-    args["host_header"] = field
+    field = data.get("private_network_id", None)
+    args["private_network_id"] = field
 
-    field = data.get("method")
-    args["method"] = field
+    field = data.get("service_ip", None)
+    args["service_ip"] = field
 
-    field = data.get("uri")
-    args["uri"] = field
+    field = data.get("zone", None)
+    args["zone"] = field
 
-    return HealthCheckHttpConfig(**args)
+    return EndpointPrivateNetworkDetails(**args)
 
 
-def unmarshal_HealthCheckHttpsConfig(data: Any) -> HealthCheckHttpsConfig:
+def unmarshal_Endpoint(data: Any) -> Endpoint:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'HealthCheckHttpsConfig' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Endpoint' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("code")
-    args["code"] = field
+    field = data.get("direct_access", None)
+    args["direct_access"] = (
+        unmarshal_EndpointDirectAccessDetails(field) if field is not None else None
+    )
+
+    field = data.get("hostname", None)
+    args["hostname"] = field
 
-    field = data.get("host_header")
-    args["host_header"] = field
+    field = data.get("id", None)
+    args["id"] = field
+
+    field = data.get("ip", None)
+    args["ip"] = field
+
+    field = data.get("load_balancer", None)
+    args["load_balancer"] = (
+        unmarshal_EndpointLoadBalancerDetails(field) if field is not None else None
+    )
 
-    field = data.get("method")
-    args["method"] = field
+    field = data.get("name", None)
+    args["name"] = field
 
-    field = data.get("sni")
-    args["sni"] = field
+    field = data.get("port", None)
+    args["port"] = field
 
-    field = data.get("uri")
-    args["uri"] = field
+    field = data.get("private_network", None)
+    args["private_network"] = (
+        unmarshal_EndpointPrivateNetworkDetails(field) if field is not None else None
+    )
 
-    return HealthCheckHttpsConfig(**args)
+    return Endpoint(**args)
 
 
-def unmarshal_HealthCheckLdapConfig(data: Any) -> HealthCheckLdapConfig:
+def unmarshal_EngineSetting(data: Any) -> EngineSetting:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'HealthCheckLdapConfig' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'EngineSetting' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    return HealthCheckLdapConfig(**args)
+    field = data.get("default_value", None)
+    args["default_value"] = field
 
+    field = data.get("description", None)
+    args["description"] = field
 
-def unmarshal_HealthCheckMysqlConfig(data: Any) -> HealthCheckMysqlConfig:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'HealthCheckMysqlConfig' failed as data isn't a dictionary."
-        )
+    field = data.get("float_max", None)
+    args["float_max"] = field
 
-    args: Dict[str, Any] = {}
+    field = data.get("float_min", None)
+    args["float_min"] = field
 
-    field = data.get("user")
-    args["user"] = field
+    field = data.get("hot_configurable", None)
+    args["hot_configurable"] = field
 
-    return HealthCheckMysqlConfig(**args)
+    field = data.get("int_max", None)
+    args["int_max"] = field
 
+    field = data.get("int_min", None)
+    args["int_min"] = field
 
-def unmarshal_HealthCheckPgsqlConfig(data: Any) -> HealthCheckPgsqlConfig:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'HealthCheckPgsqlConfig' failed as data isn't a dictionary."
-        )
+    field = data.get("name", None)
+    args["name"] = field
 
-    args: Dict[str, Any] = {}
+    field = data.get("property_type", None)
+    args["property_type"] = field
 
-    field = data.get("user")
-    args["user"] = field
+    field = data.get("string_constraint", None)
+    args["string_constraint"] = field
 
-    return HealthCheckPgsqlConfig(**args)
+    field = data.get("unit", None)
+    args["unit"] = field
 
+    return EngineSetting(**args)
 
-def unmarshal_HealthCheckRedisConfig(data: Any) -> HealthCheckRedisConfig:
+
+def unmarshal_BackupSchedule(data: Any) -> BackupSchedule:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'HealthCheckRedisConfig' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'BackupSchedule' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    return HealthCheckRedisConfig(**args)
+    field = data.get("disabled", None)
+    args["disabled"] = field
 
+    field = data.get("frequency", None)
+    args["frequency"] = field
 
-def unmarshal_HealthCheckTcpConfig(data: Any) -> HealthCheckTcpConfig:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'HealthCheckTcpConfig' failed as data isn't a dictionary."
-        )
+    field = data.get("next_run_at", None)
+    args["next_run_at"] = parser.isoparse(field) if type(field) is str else field
 
-    args: Dict[str, Any] = {}
+    field = data.get("retention", None)
+    args["retention"] = field
 
-    return HealthCheckTcpConfig(**args)
+    return BackupSchedule(**args)
 
 
-def unmarshal_Instance(data: Any) -> Instance:
+def unmarshal_EngineVersion(data: Any) -> EngineVersion:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Instance' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'EngineVersion' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
-    args["created_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("available_init_settings", None)
+    args["available_init_settings"] = (
+        [unmarshal_EngineSetting(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("id")
-    args["id"] = field
+    field = data.get("available_settings", None)
+    args["available_settings"] = (
+        [unmarshal_EngineSetting(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("ip_address")
-    args["ip_address"] = field
+    field = data.get("beta", None)
+    args["beta"] = field
 
-    field = data.get("region")
-    args["region"] = field
+    field = data.get("disabled", None)
+    args["disabled"] = field
 
-    field = data.get("status")
-    args["status"] = field
+    field = data.get("end_of_life", None)
+    args["end_of_life"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("updated_at")
-    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("name", None)
+    args["name"] = field
 
-    field = data.get("zone")
-    args["zone"] = field
+    field = data.get("version", None)
+    args["version"] = field
 
-    return Instance(**args)
+    return EngineVersion(**args)
 
 
-def unmarshal_Ip(data: Any) -> Ip:
+def unmarshal_InstanceSetting(data: Any) -> InstanceSetting:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Ip' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'InstanceSetting' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("id")
-    args["id"] = field
+    field = data.get("name", None)
+    args["name"] = field
 
-    field = data.get("ip_address")
-    args["ip_address"] = field
+    field = data.get("value", None)
+    args["value"] = field
 
-    field = data.get("lb_id")
-    args["lb_id"] = field
+    return InstanceSetting(**args)
 
-    field = data.get("organization_id")
-    args["organization_id"] = field
 
-    field = data.get("project_id")
-    args["project_id"] = field
+def unmarshal_LogsPolicy(data: Any) -> LogsPolicy:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'LogsPolicy' failed as data isn't a dictionary."
+        )
 
-    field = data.get("region")
-    args["region"] = field
+    args: Dict[str, Any] = {}
 
-    field = data.get("reverse")
-    args["reverse"] = field
+    field = data.get("max_age_retention", None)
+    args["max_age_retention"] = field
 
-    field = data.get("zone")
-    args["zone"] = field
+    field = data.get("total_disk_retention", None)
+    args["total_disk_retention"] = field
 
-    return Ip(**args)
+    return LogsPolicy(**args)
 
 
-def unmarshal_Subscriber(data: Any) -> Subscriber:
+def unmarshal_Maintenance(data: Any) -> Maintenance:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Subscriber' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Maintenance' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("email_config")
-    args["email_config"] = (
-        unmarshal_SubscriberEmailConfig(field) if field is not None else None
-    )
+    field = data.get("closed_at", None)
+    args["closed_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("id")
-    args["id"] = field
+    field = data.get("reason", None)
+    args["reason"] = field
 
-    field = data.get("name")
-    args["name"] = field
+    field = data.get("starts_at", None)
+    args["starts_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("webhook_config")
-    args["webhook_config"] = (
-        unmarshal_SubscriberWebhookConfig(field) if field is not None else None
-    )
+    field = data.get("status", None)
+    args["status"] = field
 
-    return Subscriber(**args)
+    field = data.get("stops_at", None)
+    args["stops_at"] = parser.isoparse(field) if type(field) is str else field
 
+    return Maintenance(**args)
 
-def unmarshal_HealthCheck(data: Any) -> HealthCheck:
+
+def unmarshal_NodeTypeVolumeConstraintSizes(data: Any) -> NodeTypeVolumeConstraintSizes:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'HealthCheck' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'NodeTypeVolumeConstraintSizes' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("check_delay")
-    args["check_delay"] = field
+    field = data.get("max_size", None)
+    args["max_size"] = field
 
-    field = data.get("check_max_retries")
-    args["check_max_retries"] = field
+    field = data.get("min_size", None)
+    args["min_size"] = field
 
-    field = data.get("check_send_proxy")
-    args["check_send_proxy"] = field
+    return NodeTypeVolumeConstraintSizes(**args)
 
-    field = data.get("check_timeout")
-    args["check_timeout"] = field
 
-    field = data.get("http_config")
-    args["http_config"] = (
-        unmarshal_HealthCheckHttpConfig(field) if field is not None else None
-    )
+def unmarshal_NodeTypeVolumeType(data: Any) -> NodeTypeVolumeType:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'NodeTypeVolumeType' failed as data isn't a dictionary."
+        )
 
-    field = data.get("https_config")
-    args["https_config"] = (
-        unmarshal_HealthCheckHttpsConfig(field) if field is not None else None
-    )
+    args: Dict[str, Any] = {}
 
-    field = data.get("ldap_config")
-    args["ldap_config"] = (
-        unmarshal_HealthCheckLdapConfig(field) if field is not None else None
-    )
+    field = data.get("chunk_size", None)
+    args["chunk_size"] = field
 
-    field = data.get("mysql_config")
-    args["mysql_config"] = (
-        unmarshal_HealthCheckMysqlConfig(field) if field is not None else None
-    )
+    field = data.get("description", None)
+    args["description"] = field
 
-    field = data.get("pgsql_config")
-    args["pgsql_config"] = (
-        unmarshal_HealthCheckPgsqlConfig(field) if field is not None else None
-    )
+    field = data.get("max_size", None)
+    args["max_size"] = field
 
-    field = data.get("port")
-    args["port"] = field
+    field = data.get("min_size", None)
+    args["min_size"] = field
 
-    field = data.get("redis_config")
-    args["redis_config"] = (
-        unmarshal_HealthCheckRedisConfig(field) if field is not None else None
-    )
+    field = data.get("type", None)
+    args["type_"] = field
+
+    return NodeTypeVolumeType(**args)
+
+
+def unmarshal_ReadReplica(data: Any) -> ReadReplica:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'ReadReplica' failed as data isn't a dictionary."
+        )
 
-    field = data.get("tcp_config")
-    args["tcp_config"] = (
-        unmarshal_HealthCheckTcpConfig(field) if field is not None else None
+    args: Dict[str, Any] = {}
+
+    field = data.get("endpoints", None)
+    args["endpoints"] = (
+        [unmarshal_Endpoint(v) for v in field] if field is not None else None
     )
 
-    return HealthCheck(**args)
+    field = data.get("id", None)
+    args["id"] = field
+
+    field = data.get("region", None)
+    args["region"] = field
+
+    field = data.get("same_zone", None)
+    args["same_zone"] = field
+
+    field = data.get("status", None)
+    args["status"] = field
+
+    return ReadReplica(**args)
 
 
-def unmarshal_Lb(data: Any) -> Lb:
+def unmarshal_UpgradableVersion(data: Any) -> UpgradableVersion:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Lb' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'UpgradableVersion' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("backend_count")
-    args["backend_count"] = field
+    field = data.get("id", None)
+    args["id"] = field
 
-    field = data.get("created_at")
-    args["created_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("minor_version", None)
+    args["minor_version"] = field
 
-    field = data.get("description")
-    args["description"] = field
+    field = data.get("name", None)
+    args["name"] = field
 
-    field = data.get("frontend_count")
-    args["frontend_count"] = field
+    field = data.get("version", None)
+    args["version"] = field
 
-    field = data.get("id")
-    args["id"] = field
+    return UpgradableVersion(**args)
 
-    field = data.get("instances")
-    args["instances"] = [unmarshal_Instance(v) for v in data["instances"]]
 
-    field = data.get("ip")
-    args["ip"] = [unmarshal_Ip(v) for v in data["ip"]]
+def unmarshal_Volume(data: Any) -> Volume:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'Volume' failed as data isn't a dictionary."
+        )
 
-    field = data.get("name")
-    args["name"] = field
+    args: Dict[str, Any] = {}
 
-    field = data.get("organization_id")
-    args["organization_id"] = field
+    field = data.get("size", None)
+    args["size"] = field
 
-    field = data.get("private_network_count")
-    args["private_network_count"] = field
+    field = data.get("type", None)
+    args["type_"] = field
 
-    field = data.get("project_id")
-    args["project_id"] = field
+    return Volume(**args)
 
-    field = data.get("region")
-    args["region"] = field
 
-    field = data.get("route_count")
-    args["route_count"] = field
+def unmarshal_ACLRule(data: Any) -> ACLRule:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'ACLRule' failed as data isn't a dictionary."
+        )
 
-    field = data.get("ssl_compatibility_level")
-    args["ssl_compatibility_level"] = field
+    args: Dict[str, Any] = {}
 
-    field = data.get("status")
-    args["status"] = field
+    field = data.get("action", None)
+    args["action"] = field
 
-    field = data.get("subscriber")
-    args["subscriber"] = unmarshal_Subscriber(field) if field is not None else None
+    field = data.get("description", None)
+    args["description"] = field
 
-    field = data.get("tags")
-    args["tags"] = field
+    field = data.get("direction", None)
+    args["direction"] = field
 
-    field = data.get("type_")
-    args["type_"] = field
+    field = data.get("ip", None)
+    args["ip"] = field
 
-    field = data.get("updated_at")
-    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("port", None)
+    args["port"] = field
 
-    field = data.get("zone")
-    args["zone"] = field
+    field = data.get("protocol", None)
+    args["protocol"] = field
 
-    return Lb(**args)
+    return ACLRule(**args)
 
 
-def unmarshal_AclActionRedirect(data: Any) -> AclActionRedirect:
+def unmarshal_Database(data: Any) -> Database:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'AclActionRedirect' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Database' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("code")
-    args["code"] = field
+    field = data.get("managed", None)
+    args["managed"] = field
+
+    field = data.get("name", None)
+    args["name"] = field
 
-    field = data.get("target")
-    args["target"] = field
+    field = data.get("owner", None)
+    args["owner"] = field
 
-    field = data.get("type_")
-    args["type_"] = field
+    field = data.get("size", None)
+    args["size"] = field
 
-    return AclActionRedirect(**args)
+    return Database(**args)
 
 
-def unmarshal_Backend(data: Any) -> Backend:
+def unmarshal_DatabaseBackup(data: Any) -> DatabaseBackup:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Backend' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'DatabaseBackup' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("failover_host")
-    args["failover_host"] = field
+    field = data.get("database_name", None)
+    args["database_name"] = field
 
-    field = data.get("forward_port")
-    args["forward_port"] = field
+    field = data.get("download_url", None)
+    args["download_url"] = field
 
-    field = data.get("forward_port_algorithm")
-    args["forward_port_algorithm"] = field
-
-    field = data.get("forward_protocol")
-    args["forward_protocol"] = field
+    field = data.get("download_url_expires_at", None)
+    args["download_url_expires_at"] = (
+        parser.isoparse(field) if type(field) is str else field
+    )
 
-    field = data.get("health_check")
-    args["health_check"] = unmarshal_HealthCheck(field) if field is not None else None
+    field = data.get("expires_at", None)
+    args["expires_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("ignore_ssl_server_verify")
-    args["ignore_ssl_server_verify"] = field
+    field = data.get("instance_id", None)
+    args["instance_id"] = field
 
-    field = data.get("lb")
-    args["lb"] = unmarshal_Lb(field) if field is not None else None
+    field = data.get("instance_name", None)
+    args["instance_name"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("on_marked_down_action")
-    args["on_marked_down_action"] = field
+    field = data.get("region", None)
+    args["region"] = field
+
+    field = data.get("same_region", None)
+    args["same_region"] = field
 
-    field = data.get("pool")
-    args["pool"] = field
+    field = data.get("size", None)
+    args["size"] = field
 
-    field = data.get("proxy_protocol")
-    args["proxy_protocol"] = field
+    field = data.get("status", None)
+    args["status"] = field
+
+    field = data.get("updated_at", None)
+    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("send_proxy_v2")
-    args["send_proxy_v2"] = field
+    return DatabaseBackup(**args)
 
-    field = data.get("ssl_bridging")
-    args["ssl_bridging"] = field
 
-    field = data.get("sticky_sessions")
-    args["sticky_sessions"] = field
+def unmarshal_DatabaseEngine(data: Any) -> DatabaseEngine:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'DatabaseEngine' failed as data isn't a dictionary."
+        )
 
-    field = data.get("sticky_sessions_cookie_name")
-    args["sticky_sessions_cookie_name"] = field
+    args: Dict[str, Any] = {}
 
-    field = data.get("timeout_connect")
-    args["timeout_connect"] = field
+    field = data.get("logo_url", None)
+    args["logo_url"] = field
 
-    field = data.get("timeout_server")
-    args["timeout_server"] = field
+    field = data.get("name", None)
+    args["name"] = field
 
-    field = data.get("timeout_tunnel")
-    args["timeout_tunnel"] = field
+    field = data.get("region", None)
+    args["region"] = field
 
-    field = data.get("updated_at")
-    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("versions", None)
+    args["versions"] = (
+        [unmarshal_EngineVersion(v) for v in field] if field is not None else None
+    )
 
-    return Backend(**args)
+    return DatabaseEngine(**args)
 
 
-def unmarshal_Certificate(data: Any) -> Certificate:
+def unmarshal_Instance(data: Any) -> Instance:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Certificate' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Instance' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("common_name")
-    args["common_name"] = field
+    field = data.get("backup_same_region", None)
+    args["backup_same_region"] = field
+
+    field = data.get("backup_schedule", None)
+    args["backup_schedule"] = (
+        unmarshal_BackupSchedule(field) if field is not None else None
+    )
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("fingerprint")
-    args["fingerprint"] = field
+    field = data.get("endpoint", None)
+    args["endpoint"] = unmarshal_Endpoint(field) if field is not None else None
 
-    field = data.get("id")
+    field = data.get("endpoints", None)
+    args["endpoints"] = (
+        [unmarshal_Endpoint(v) for v in field] if field is not None else None
+    )
+
+    field = data.get("engine", None)
+    args["engine"] = field
+
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("lb")
-    args["lb"] = unmarshal_Lb(field) if field is not None else None
+    field = data.get("init_settings", None)
+    args["init_settings"] = (
+        [unmarshal_InstanceSetting(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("name")
-    args["name"] = field
+    field = data.get("is_ha_cluster", None)
+    args["is_ha_cluster"] = field
 
-    field = data.get("not_valid_after")
-    args["not_valid_after"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("logs_policy", None)
+    args["logs_policy"] = unmarshal_LogsPolicy(field) if field is not None else None
 
-    field = data.get("not_valid_before")
-    args["not_valid_before"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("maintenances", None)
+    args["maintenances"] = (
+        [unmarshal_Maintenance(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("status")
-    args["status"] = field
+    field = data.get("name", None)
+    args["name"] = field
 
-    field = data.get("status_details")
-    args["status_details"] = field
+    field = data.get("node_type", None)
+    args["node_type"] = field
 
-    field = data.get("subject_alternative_name")
-    args["subject_alternative_name"] = field
+    field = data.get("organization_id", None)
+    args["organization_id"] = field
 
-    field = data.get("type_")
-    args["type_"] = field
+    field = data.get("project_id", None)
+    args["project_id"] = field
 
-    field = data.get("updated_at")
-    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("read_replicas", None)
+    args["read_replicas"] = (
+        [unmarshal_ReadReplica(v) for v in field] if field is not None else None
+    )
 
-    return Certificate(**args)
+    field = data.get("region", None)
+    args["region"] = field
 
+    field = data.get("settings", None)
+    args["settings"] = (
+        [unmarshal_InstanceSetting(v) for v in field] if field is not None else None
+    )
 
-def unmarshal_AclAction(data: Any) -> AclAction:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'AclAction' failed as data isn't a dictionary."
-        )
+    field = data.get("status", None)
+    args["status"] = field
 
-    args: Dict[str, Any] = {}
+    field = data.get("tags", None)
+    args["tags"] = field
 
-    field = data.get("redirect")
-    args["redirect"] = unmarshal_AclActionRedirect(field) if field is not None else None
+    field = data.get("upgradable_version", None)
+    args["upgradable_version"] = (
+        [unmarshal_UpgradableVersion(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("type_")
-    args["type_"] = field
+    field = data.get("volume", None)
+    args["volume"] = unmarshal_Volume(field) if field is not None else None
 
-    return AclAction(**args)
+    return Instance(**args)
 
 
-def unmarshal_AclMatch(data: Any) -> AclMatch:
+def unmarshal_InstanceLog(data: Any) -> InstanceLog:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'AclMatch' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'InstanceLog' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("http_filter")
-    args["http_filter"] = field
+    field = data.get("created_at", None)
+    args["created_at"] = parser.isoparse(field) if type(field) is str else field
+
+    field = data.get("download_url", None)
+    args["download_url"] = field
 
-    field = data.get("http_filter_option")
-    args["http_filter_option"] = field
+    field = data.get("expires_at", None)
+    args["expires_at"] = parser.isoparse(field) if type(field) is str else field
+
+    field = data.get("id", None)
+    args["id"] = field
 
-    field = data.get("http_filter_value")
-    args["http_filter_value"] = field
+    field = data.get("node_name", None)
+    args["node_name"] = field
 
-    field = data.get("invert")
-    args["invert"] = field
+    field = data.get("region", None)
+    args["region"] = field
 
-    field = data.get("ip_subnet")
-    args["ip_subnet"] = field
+    field = data.get("status", None)
+    args["status"] = field
 
-    return AclMatch(**args)
+    return InstanceLog(**args)
 
 
-def unmarshal_Frontend(data: Any) -> Frontend:
+def unmarshal_ListInstanceLogsDetailsResponseInstanceLogDetail(
+    data: Any,
+) -> ListInstanceLogsDetailsResponseInstanceLogDetail:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Frontend' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListInstanceLogsDetailsResponseInstanceLogDetail' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("backend")
-    args["backend"] = unmarshal_Backend(field) if field is not None else None
-
-    field = data.get("certificate")
-    args["certificate"] = unmarshal_Certificate(field) if field is not None else None
-
-    field = data.get("certificate_ids")
-    args["certificate_ids"] = field
+    field = data.get("log_name", None)
+    args["log_name"] = field
 
-    field = data.get("created_at")
-    args["created_at"] = parser.isoparse(field) if type(field) is str else field
-
-    field = data.get("enable_http3")
-    args["enable_http3"] = field
+    field = data.get("size", None)
+    args["size"] = field
 
-    field = data.get("id")
-    args["id"] = field
+    return ListInstanceLogsDetailsResponseInstanceLogDetail(**args)
 
-    field = data.get("inbound_port")
-    args["inbound_port"] = field
 
-    field = data.get("lb")
-    args["lb"] = unmarshal_Lb(field) if field is not None else None
+def unmarshal_NodeType(data: Any) -> NodeType:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'NodeType' failed as data isn't a dictionary."
+        )
 
-    field = data.get("name")
-    args["name"] = field
+    args: Dict[str, Any] = {}
 
-    field = data.get("timeout_client")
-    args["timeout_client"] = field
+    field = data.get("available_volume_types", None)
+    args["available_volume_types"] = (
+        [unmarshal_NodeTypeVolumeType(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("updated_at")
-    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("beta", None)
+    args["beta"] = field
 
-    return Frontend(**args)
+    field = data.get("description", None)
+    args["description"] = field
 
+    field = data.get("disabled", None)
+    args["disabled"] = field
 
-def unmarshal_PrivateNetworkDHCPConfig(data: Any) -> PrivateNetworkDHCPConfig:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'PrivateNetworkDHCPConfig' failed as data isn't a dictionary."
-        )
+    field = data.get("generation", None)
+    args["generation"] = field
 
-    args: Dict[str, Any] = {}
+    field = data.get("instance_range", None)
+    args["instance_range"] = field
 
-    return PrivateNetworkDHCPConfig(**args)
+    field = data.get("is_bssd_compatible", None)
+    args["is_bssd_compatible"] = field
 
+    field = data.get("is_ha_required", None)
+    args["is_ha_required"] = field
 
-def unmarshal_PrivateNetworkIpamConfig(data: Any) -> PrivateNetworkIpamConfig:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'PrivateNetworkIpamConfig' failed as data isn't a dictionary."
-        )
+    field = data.get("memory", None)
+    args["memory"] = field
 
-    args: Dict[str, Any] = {}
-
-    return PrivateNetworkIpamConfig(**args)
+    field = data.get("name", None)
+    args["name"] = field
 
+    field = data.get("region", None)
+    args["region"] = field
 
-def unmarshal_PrivateNetworkStaticConfig(data: Any) -> PrivateNetworkStaticConfig:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'PrivateNetworkStaticConfig' failed as data isn't a dictionary."
-        )
+    field = data.get("stock_status", None)
+    args["stock_status"] = field
 
-    args: Dict[str, Any] = {}
+    field = data.get("vcpus", None)
+    args["vcpus"] = field
 
-    field = data.get("ip_address")
-    args["ip_address"] = field
+    field = data.get("volume_constraint", None)
+    args["volume_constraint"] = (
+        unmarshal_NodeTypeVolumeConstraintSizes(field) if field is not None else None
+    )
 
-    return PrivateNetworkStaticConfig(**args)
+    return NodeType(**args)
 
 
-def unmarshal_RouteMatch(data: Any) -> RouteMatch:
+def unmarshal_Privilege(data: Any) -> Privilege:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'RouteMatch' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Privilege' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("host_header")
-    args["host_header"] = field
+    field = data.get("database_name", None)
+    args["database_name"] = field
+
+    field = data.get("permission", None)
+    args["permission"] = field
 
-    field = data.get("sni")
-    args["sni"] = field
+    field = data.get("user_name", None)
+    args["user_name"] = field
 
-    return RouteMatch(**args)
+    return Privilege(**args)
 
 
-def unmarshal_Acl(data: Any) -> Acl:
+def unmarshal_Snapshot(data: Any) -> Snapshot:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Acl' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Snapshot' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("action")
-    args["action"] = unmarshal_AclAction(field) if field is not None else None
-
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("description")
-    args["description"] = field
-
-    field = data.get("frontend")
-    args["frontend"] = unmarshal_Frontend(field) if field is not None else None
+    field = data.get("expires_at", None)
+    args["expires_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("index")
-    args["index"] = field
+    field = data.get("instance_id", None)
+    args["instance_id"] = field
 
-    field = data.get("match")
-    args["match"] = unmarshal_AclMatch(field) if field is not None else None
+    field = data.get("instance_name", None)
+    args["instance_name"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("updated_at")
+    field = data.get("node_type", None)
+    args["node_type"] = field
+
+    field = data.get("region", None)
+    args["region"] = field
+
+    field = data.get("size", None)
+    args["size"] = field
+
+    field = data.get("status", None)
+    args["status"] = field
+
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    return Acl(**args)
+    return Snapshot(**args)
 
 
-def unmarshal_BackendServerStats(data: Any) -> BackendServerStats:
+def unmarshal_User(data: Any) -> User:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'BackendServerStats' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'User' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("backend_id")
-    args["backend_id"] = field
-
-    field = data.get("instance_id")
-    args["instance_id"] = field
-
-    field = data.get("ip")
-    args["ip"] = field
+    field = data.get("is_admin", None)
+    args["is_admin"] = field
 
-    field = data.get("last_health_check_status")
-    args["last_health_check_status"] = field
-
-    field = data.get("server_state")
-    args["server_state"] = field
-
-    field = data.get("server_state_changed_at")
-    args["server_state_changed_at"] = (
-        parser.isoparse(field) if type(field) is str else field
-    )
+    field = data.get("name", None)
+    args["name"] = field
 
-    return BackendServerStats(**args)
+    return User(**args)
 
 
-def unmarshal_LbType(data: Any) -> LbType:
+def unmarshal_AddInstanceACLRulesResponse(data: Any) -> AddInstanceACLRulesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'LbType' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'AddInstanceACLRulesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("description")
-    args["description"] = field
-
-    field = data.get("name")
-    args["name"] = field
-
-    field = data.get("region")
-    args["region"] = field
-
-    field = data.get("stock_status")
-    args["stock_status"] = field
-
-    field = data.get("zone")
-    args["zone"] = field
+    field = data.get("rules", None)
+    args["rules"] = [unmarshal_ACLRule(v) for v in field] if field is not None else None
 
-    return LbType(**args)
+    return AddInstanceACLRulesResponse(**args)
 
 
-def unmarshal_PrivateNetwork(data: Any) -> PrivateNetwork:
+def unmarshal_AddInstanceSettingsResponse(data: Any) -> AddInstanceSettingsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'PrivateNetwork' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'AddInstanceSettingsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
-    args["created_at"] = parser.isoparse(field) if type(field) is str else field
-
-    field = data.get("dhcp_config")
-    args["dhcp_config"] = (
-        unmarshal_PrivateNetworkDHCPConfig(field) if field is not None else None
-    )
-
-    field = data.get("ipam_config")
-    args["ipam_config"] = (
-        unmarshal_PrivateNetworkIpamConfig(field) if field is not None else None
+    field = data.get("settings", None)
+    args["settings"] = (
+        [unmarshal_InstanceSetting(v) for v in field] if field is not None else None
     )
 
-    field = data.get("lb")
-    args["lb"] = unmarshal_Lb(field) if field is not None else None
+    return AddInstanceSettingsResponse(**args)
 
-    field = data.get("private_network_id")
-    args["private_network_id"] = field
 
-    field = data.get("static_config")
-    args["static_config"] = (
-        unmarshal_PrivateNetworkStaticConfig(field) if field is not None else None
-    )
+def unmarshal_DeleteInstanceACLRulesResponse(
+    data: Any,
+) -> DeleteInstanceACLRulesResponse:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'DeleteInstanceACLRulesResponse' failed as data isn't a dictionary."
+        )
 
-    field = data.get("status")
-    args["status"] = field
+    args: Dict[str, Any] = {}
 
-    field = data.get("updated_at")
-    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("rules", None)
+    args["rules"] = [unmarshal_ACLRule(v) for v in field] if field is not None else None
 
-    return PrivateNetwork(**args)
+    return DeleteInstanceACLRulesResponse(**args)
 
 
-def unmarshal_Route(data: Any) -> Route:
+def unmarshal_DeleteInstanceSettingsResponse(
+    data: Any,
+) -> DeleteInstanceSettingsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Route' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'DeleteInstanceSettingsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("backend_id")
-    args["backend_id"] = field
+    field = data.get("settings", None)
+    args["settings"] = (
+        [unmarshal_InstanceSetting(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("created_at")
-    args["created_at"] = parser.isoparse(field) if type(field) is str else field
+    return DeleteInstanceSettingsResponse(**args)
 
-    field = data.get("frontend_id")
-    args["frontend_id"] = field
 
-    field = data.get("id")
-    args["id"] = field
+def unmarshal_InstanceMetrics(data: Any) -> InstanceMetrics:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'InstanceMetrics' failed as data isn't a dictionary."
+        )
 
-    field = data.get("match")
-    args["match"] = unmarshal_RouteMatch(field) if field is not None else None
+    args: Dict[str, Any] = {}
 
-    field = data.get("updated_at")
-    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("timeseries", None)
+    args["timeseries"] = (
+        [unmarshal_TimeSeries(v) for v in field] if field is not None else None
+    )
 
-    return Route(**args)
+    return InstanceMetrics(**args)
 
 
-def unmarshal_LbStats(data: Any) -> LbStats:
+def unmarshal_ListDatabaseBackupsResponse(data: Any) -> ListDatabaseBackupsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'LbStats' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListDatabaseBackupsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("backend_servers_stats")
-    args["backend_servers_stats"] = [
-        unmarshal_BackendServerStats(v) for v in data["backend_servers_stats"]
-    ]
+    field = data.get("database_backups", None)
+    args["database_backups"] = (
+        [unmarshal_DatabaseBackup(v) for v in field] if field is not None else None
+    )
+
+    field = data.get("total_count", None)
+    args["total_count"] = field
 
-    return LbStats(**args)
+    return ListDatabaseBackupsResponse(**args)
 
 
-def unmarshal_ListAclResponse(data: Any) -> ListAclResponse:
+def unmarshal_ListDatabaseEnginesResponse(data: Any) -> ListDatabaseEnginesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListAclResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListDatabaseEnginesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("acls")
-    args["acls"] = [unmarshal_Acl(v) for v in data["acls"]]
+    field = data.get("engines", None)
+    args["engines"] = (
+        [unmarshal_DatabaseEngine(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListAclResponse(**args)
+    return ListDatabaseEnginesResponse(**args)
 
 
-def unmarshal_ListBackendStatsResponse(data: Any) -> ListBackendStatsResponse:
+def unmarshal_ListDatabasesResponse(data: Any) -> ListDatabasesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListBackendStatsResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListDatabasesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("backend_servers_stats")
-    args["backend_servers_stats"] = [
-        unmarshal_BackendServerStats(v) for v in data["backend_servers_stats"]
-    ]
+    field = data.get("databases", None)
+    args["databases"] = (
+        [unmarshal_Database(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListBackendStatsResponse(**args)
+    return ListDatabasesResponse(**args)
 
 
-def unmarshal_ListBackendsResponse(data: Any) -> ListBackendsResponse:
+def unmarshal_ListInstanceACLRulesResponse(data: Any) -> ListInstanceACLRulesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListBackendsResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListInstanceACLRulesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("backends")
-    args["backends"] = [unmarshal_Backend(v) for v in data["backends"]]
+    field = data.get("rules", None)
+    args["rules"] = [unmarshal_ACLRule(v) for v in field] if field is not None else None
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListBackendsResponse(**args)
+    return ListInstanceACLRulesResponse(**args)
 
 
-def unmarshal_ListCertificatesResponse(data: Any) -> ListCertificatesResponse:
+def unmarshal_ListInstanceLogsDetailsResponse(
+    data: Any,
+) -> ListInstanceLogsDetailsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListCertificatesResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListInstanceLogsDetailsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("certificates")
-    args["certificates"] = [unmarshal_Certificate(v) for v in data["certificates"]]
-
-    field = data.get("total_count")
-    args["total_count"] = field
+    field = data.get("details", None)
+    args["details"] = (
+        [unmarshal_ListInstanceLogsDetailsResponseInstanceLogDetail(v) for v in field]
+        if field is not None
+        else None
+    )
 
-    return ListCertificatesResponse(**args)
+    return ListInstanceLogsDetailsResponse(**args)
 
 
-def unmarshal_ListFrontendsResponse(data: Any) -> ListFrontendsResponse:
+def unmarshal_ListInstanceLogsResponse(data: Any) -> ListInstanceLogsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListFrontendsResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListInstanceLogsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("frontends")
-    args["frontends"] = [unmarshal_Frontend(v) for v in data["frontends"]]
-
-    field = data.get("total_count")
-    args["total_count"] = field
+    field = data.get("instance_logs", None)
+    args["instance_logs"] = (
+        [unmarshal_InstanceLog(v) for v in field] if field is not None else None
+    )
 
-    return ListFrontendsResponse(**args)
+    return ListInstanceLogsResponse(**args)
 
 
-def unmarshal_ListIpsResponse(data: Any) -> ListIpsResponse:
+def unmarshal_ListInstancesResponse(data: Any) -> ListInstancesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListIpsResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListInstancesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("ips")
-    args["ips"] = [unmarshal_Ip(v) for v in data["ips"]]
+    field = data.get("instances", None)
+    args["instances"] = (
+        [unmarshal_Instance(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListIpsResponse(**args)
+    return ListInstancesResponse(**args)
 
 
-def unmarshal_ListLbPrivateNetworksResponse(data: Any) -> ListLbPrivateNetworksResponse:
+def unmarshal_ListNodeTypesResponse(data: Any) -> ListNodeTypesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListLbPrivateNetworksResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListNodeTypesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("private_network")
-    args["private_network"] = [
-        unmarshal_PrivateNetwork(v) for v in data["private_network"]
-    ]
+    field = data.get("node_types", None)
+    args["node_types"] = (
+        [unmarshal_NodeType(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListLbPrivateNetworksResponse(**args)
+    return ListNodeTypesResponse(**args)
 
 
-def unmarshal_ListLbTypesResponse(data: Any) -> ListLbTypesResponse:
+def unmarshal_ListPrivilegesResponse(data: Any) -> ListPrivilegesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListLbTypesResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListPrivilegesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("lb_types")
-    args["lb_types"] = [unmarshal_LbType(v) for v in data["lb_types"]]
+    field = data.get("privileges", None)
+    args["privileges"] = (
+        [unmarshal_Privilege(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListLbTypesResponse(**args)
+    return ListPrivilegesResponse(**args)
 
 
-def unmarshal_ListLbsResponse(data: Any) -> ListLbsResponse:
+def unmarshal_ListSnapshotsResponse(data: Any) -> ListSnapshotsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListLbsResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListSnapshotsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("lbs")
-    args["lbs"] = [unmarshal_Lb(v) for v in data["lbs"]]
+    field = data.get("snapshots", None)
+    args["snapshots"] = (
+        [unmarshal_Snapshot(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListLbsResponse(**args)
+    return ListSnapshotsResponse(**args)
 
 
-def unmarshal_ListRoutesResponse(data: Any) -> ListRoutesResponse:
+def unmarshal_ListUsersResponse(data: Any) -> ListUsersResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListRoutesResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListUsersResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("routes")
-    args["routes"] = [unmarshal_Route(v) for v in data["routes"]]
-
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListRoutesResponse(**args)
+    field = data.get("users", None)
+    args["users"] = [unmarshal_User(v) for v in field] if field is not None else None
+
+    return ListUsersResponse(**args)
 
 
-def unmarshal_ListSubscriberResponse(data: Any) -> ListSubscriberResponse:
+def unmarshal_PrepareInstanceLogsResponse(data: Any) -> PrepareInstanceLogsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListSubscriberResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'PrepareInstanceLogsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("subscribers")
-    args["subscribers"] = [unmarshal_Subscriber(v) for v in data["subscribers"]]
-
-    field = data.get("total_count")
-    args["total_count"] = field
+    field = data.get("instance_logs", None)
+    args["instance_logs"] = (
+        [unmarshal_InstanceLog(v) for v in field] if field is not None else None
+    )
 
-    return ListSubscriberResponse(**args)
+    return PrepareInstanceLogsResponse(**args)
 
 
-def unmarshal_SetAclsResponse(data: Any) -> SetAclsResponse:
+def unmarshal_SetInstanceACLRulesResponse(data: Any) -> SetInstanceACLRulesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'SetAclsResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'SetInstanceACLRulesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("acls")
-    args["acls"] = [unmarshal_Acl(v) for v in data["acls"]]
+    field = data.get("rules", None)
+    args["rules"] = [unmarshal_ACLRule(v) for v in field] if field is not None else None
 
-    field = data.get("total_count")
-    args["total_count"] = field
+    return SetInstanceACLRulesResponse(**args)
 
-    return SetAclsResponse(**args)
 
+def unmarshal_SetInstanceSettingsResponse(data: Any) -> SetInstanceSettingsResponse:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'SetInstanceSettingsResponse' failed as data isn't a dictionary."
+        )
 
-def marshal_AclActionRedirect(
-    request: AclActionRedirect,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "code": request.code,
-        "target": request.target,
-        "type": AclActionRedirectRedirectType(request.type_),
-    }
+    args: Dict[str, Any] = {}
 
+    field = data.get("settings", None)
+    args["settings"] = (
+        [unmarshal_InstanceSetting(v) for v in field] if field is not None else None
+    )
 
-def marshal_AclAction(
-    request: AclAction,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "redirect": marshal_AclActionRedirect(request.redirect, defaults)
-        if request.redirect is not None
-        else None,
-        "type": AclActionType(request.type_),
-    }
+    return SetInstanceSettingsResponse(**args)
 
 
-def marshal_AclMatch(
-    request: AclMatch,
+def marshal_EndpointSpecPrivateNetworkIpamConfig(
+    request: EndpointSpecPrivateNetworkIpamConfig,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "http_filter": AclHttpFilter(request.http_filter),
-        "http_filter_option": request.http_filter_option,
-        "http_filter_value": request.http_filter_value,
-        "invert": request.invert,
-        "ip_subnet": request.ip_subnet,
-    }
-
+    output: Dict[str, Any] = {}
 
-def marshal_HealthCheckHttpConfig(
-    request: HealthCheckHttpConfig,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "code": request.code,
-        "host_header": request.host_header,
-        "method": request.method,
-        "uri": request.uri,
-    }
+    return output
 
 
-def marshal_HealthCheckHttpsConfig(
-    request: HealthCheckHttpsConfig,
+def marshal_ReadReplicaEndpointSpecPrivateNetworkIpamConfig(
+    request: ReadReplicaEndpointSpecPrivateNetworkIpamConfig,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "code": request.code,
-        "host_header": request.host_header,
-        "method": request.method,
-        "sni": request.sni,
-        "uri": request.uri,
-    }
+    output: Dict[str, Any] = {}
 
+    return output
 
-def marshal_HealthCheckLdapConfig(
-    request: HealthCheckLdapConfig,
+
+def marshal_EndpointSpecLoadBalancer(
+    request: EndpointSpecLoadBalancer,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {}
+    output: Dict[str, Any] = {}
+
+    return output
 
 
-def marshal_HealthCheckMysqlConfig(
-    request: HealthCheckMysqlConfig,
+def marshal_EndpointSpecPrivateNetwork(
+    request: EndpointSpecPrivateNetwork,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "user": request.user,
-    }
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
+            [
+                OneOfPossibility(
+                    "service_ip",
+                    request.service_ip if request.service_ip is not None else None,
+                ),
+                OneOfPossibility(
+                    "ipam_config",
+                    marshal_EndpointSpecPrivateNetworkIpamConfig(
+                        request.ipam_config, defaults
+                    )
+                    if request.ipam_config is not None
+                    else None,
+                ),
+            ]
+        ),
+    )
 
+    if request.private_network_id is not None:
+        output["private_network_id"] = request.private_network_id
 
-def marshal_HealthCheckPgsqlConfig(
-    request: HealthCheckPgsqlConfig,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "user": request.user,
-    }
+    return output
 
 
-def marshal_HealthCheckRedisConfig(
-    request: HealthCheckRedisConfig,
+def marshal_ReadReplicaEndpointSpecDirectAccess(
+    request: ReadReplicaEndpointSpecDirectAccess,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {}
+    output: Dict[str, Any] = {}
 
+    return output
 
-def marshal_HealthCheckTcpConfig(
-    request: HealthCheckTcpConfig,
+
+def marshal_ReadReplicaEndpointSpecPrivateNetwork(
+    request: ReadReplicaEndpointSpecPrivateNetwork,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {}
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
+            [
+                OneOfPossibility(
+                    "service_ip",
+                    request.service_ip if request.service_ip is not None else None,
+                ),
+                OneOfPossibility(
+                    "ipam_config",
+                    marshal_ReadReplicaEndpointSpecPrivateNetworkIpamConfig(
+                        request.ipam_config, defaults
+                    )
+                    if request.ipam_config is not None
+                    else None,
+                ),
+            ]
+        ),
+    )
 
+    if request.private_network_id is not None:
+        output["private_network_id"] = request.private_network_id
 
-def marshal_AclSpec(
-    request: AclSpec,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "action": marshal_AclAction(request.action, defaults),
-        "description": request.description,
-        "index": request.index,
-        "match": marshal_AclMatch(request.match, defaults)
-        if request.match is not None
-        else None,
-        "name": request.name,
-    }
+    return output
 
 
-def marshal_CreateCertificateRequestCustomCertificate(
-    request: CreateCertificateRequestCustomCertificate,
+def marshal_ACLRuleRequest(
+    request: ACLRuleRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "certificate_chain": request.certificate_chain,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.description is not None:
+        output["description"] = request.description
 
-def marshal_CreateCertificateRequestLetsencryptConfig(
-    request: CreateCertificateRequestLetsencryptConfig,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "common_name": request.common_name,
-        "subject_alternative_name": request.subject_alternative_name,
-    }
+    if request.ip is not None:
+        output["ip"] = request.ip
+
+    return output
 
 
-def marshal_HealthCheck(
-    request: HealthCheck,
+def marshal_EndpointSpec(
+    request: EndpointSpec,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("mysql_config", request.mysql_config),
-                OneOfPossibility("ldap_config", request.ldap_config),
-                OneOfPossibility("redis_config", request.redis_config),
-                OneOfPossibility("tcp_config", request.tcp_config),
-                OneOfPossibility("pgsql_config", request.pgsql_config),
-                OneOfPossibility("http_config", request.http_config),
-                OneOfPossibility("https_config", request.https_config),
+                OneOfPossibility(
+                    "load_balancer",
+                    marshal_EndpointSpecLoadBalancer(request.load_balancer, defaults)
+                    if request.load_balancer is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "private_network",
+                    marshal_EndpointSpecPrivateNetwork(
+                        request.private_network, defaults
+                    )
+                    if request.private_network is not None
+                    else None,
+                ),
             ]
         ),
-        "check_delay": request.check_delay,
-        "check_max_retries": request.check_max_retries,
-        "check_send_proxy": request.check_send_proxy,
-        "check_timeout": request.check_timeout,
-        "port": request.port,
-    }
+    )
+
+    return output
 
 
-def marshal_PrivateNetworkDHCPConfig(
-    request: PrivateNetworkDHCPConfig,
+def marshal_InstanceSetting(
+    request: InstanceSetting,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {}
+    output: Dict[str, Any] = {}
 
+    if request.name is not None:
+        output["name"] = request.name
 
-def marshal_PrivateNetworkIpamConfig(
-    request: PrivateNetworkIpamConfig,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {}
+    if request.value is not None:
+        output["value"] = request.value
+
+    return output
 
 
-def marshal_PrivateNetworkStaticConfig(
-    request: PrivateNetworkStaticConfig,
+def marshal_LogsPolicy(
+    request: LogsPolicy,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "ip_address": request.ip_address,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.max_age_retention is not None:
+        output["max_age_retention"] = request.max_age_retention
+
+    if request.total_disk_retention is not None:
+        output["total_disk_retention"] = request.total_disk_retention
 
+    return output
 
-def marshal_RouteMatch(
-    request: RouteMatch,
+
+def marshal_ReadReplicaEndpointSpec(
+    request: ReadReplicaEndpointSpec,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("sni", request.sni),
-                OneOfPossibility("host_header", request.host_header),
+                OneOfPossibility(
+                    "direct_access",
+                    marshal_ReadReplicaEndpointSpecDirectAccess(
+                        request.direct_access, defaults
+                    )
+                    if request.direct_access is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "private_network",
+                    marshal_ReadReplicaEndpointSpecPrivateNetwork(
+                        request.private_network, defaults
+                    )
+                    if request.private_network is not None
+                    else None,
+                ),
             ]
         ),
-    }
+    )
 
+    return output
 
-def marshal_SubscriberEmailConfig(
-    request: SubscriberEmailConfig,
+
+def marshal_AddInstanceACLRulesRequest(
+    request: AddInstanceACLRulesRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "email": request.email,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.rules is not None:
+        output["rules"] = [marshal_ACLRuleRequest(v, defaults) for v in request.rules]
 
-def marshal_SubscriberWebhookConfig(
-    request: SubscriberWebhookConfig,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "uri": request.uri,
-    }
+    return output
 
 
-def marshal_AddBackendServersRequest(
-    request: AddBackendServersRequest,
+def marshal_AddInstanceSettingsRequest(
+    request: AddInstanceSettingsRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "server_ip": request.server_ip,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.settings is not None:
+        output["settings"] = [
+            marshal_InstanceSetting(v, defaults) for v in request.settings
+        ]
 
-def marshal_AttachPrivateNetworkRequest(
-    request: AttachPrivateNetworkRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
-            [
-                OneOfPossibility("static_config", request.static_config),
-                OneOfPossibility("dhcp_config", request.dhcp_config),
-                OneOfPossibility("ipam_config", request.ipam_config),
-            ]
-        ),
-    }
+    return output
 
 
-def marshal_CreateAclRequest(
-    request: CreateAclRequest,
+def marshal_CloneInstanceRequest(
+    request: CloneInstanceRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "action": marshal_AclAction(request.action, defaults),
-        "description": request.description,
-        "index": request.index,
-        "match": marshal_AclMatch(request.match, defaults)
-        if request.match is not None
-        else None,
-        "name": request.name,
-    }
-
-
-def marshal_CreateBackendRequest(
-    request: CreateBackendRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "failover_host": request.failover_host,
-        "forward_port": request.forward_port,
-        "forward_port_algorithm": ForwardPortAlgorithm(request.forward_port_algorithm)
-        if request.forward_port_algorithm is not None
-        else None,
-        "forward_protocol": Protocol(request.forward_protocol)
-        if request.forward_protocol is not None
-        else None,
-        "health_check": marshal_HealthCheck(request.health_check, defaults),
-        "ignore_ssl_server_verify": request.ignore_ssl_server_verify,
-        "name": request.name,
-        "on_marked_down_action": OnMarkedDownAction(request.on_marked_down_action),
-        "proxy_protocol": ProxyProtocol(request.proxy_protocol),
-        "send_proxy_v2": request.send_proxy_v2,
-        "server_ip": request.server_ip,
-        "ssl_bridging": request.ssl_bridging,
-        "sticky_sessions": StickySessionsType(request.sticky_sessions)
-        if request.sticky_sessions is not None
-        else None,
-        "sticky_sessions_cookie_name": request.sticky_sessions_cookie_name,
-        "timeout_connect": request.timeout_connect,
-        "timeout_server": request.timeout_server,
-        "timeout_tunnel": request.timeout_tunnel,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.name is not None:
+        output["name"] = request.name
 
-def marshal_CreateCertificateRequest(
-    request: CreateCertificateRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
-            [
-                OneOfPossibility("letsencrypt", request.letsencrypt),
-                OneOfPossibility("custom_certificate", request.custom_certificate),
-            ]
-        ),
-        "name": request.name,
-    }
+    if request.node_type is not None:
+        output["node_type"] = request.node_type
+
+    return output
 
 
-def marshal_CreateFrontendRequest(
-    request: CreateFrontendRequest,
+def marshal_CreateDatabaseBackupRequest(
+    request: CreateDatabaseBackupRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "backend_id": request.backend_id,
-        "certificate_id": request.certificate_id,
-        "certificate_ids": request.certificate_ids,
-        "enable_http3": request.enable_http3,
-        "inbound_port": request.inbound_port,
-        "name": request.name,
-        "timeout_client": request.timeout_client,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.database_name is not None:
+        output["database_name"] = request.database_name
 
-def marshal_CreateIpRequest(
-    request: CreateIpRequest,
+    if request.expires_at is not None:
+        output["expires_at"] = request.expires_at
+
+    if request.instance_id is not None:
+        output["instance_id"] = request.instance_id
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
+
+
+def marshal_CreateDatabaseRequest(
+    request: CreateDatabaseRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
-            [
-                OneOfPossibility(
-                    "project_id", request.project_id, defaults.default_project_id
-                ),
-                OneOfPossibility(
-                    "organization_id",
-                    request.organization_id,
-                    defaults.default_organization_id,
-                ),
-            ]
-        ),
-        "reverse": request.reverse,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.name is not None:
+        output["name"] = request.name
 
+    return output
 
-def marshal_CreateLbRequest(
-    request: CreateLbRequest,
+
+def marshal_CreateEndpointRequest(
+    request: CreateEndpointRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
-            [
-                OneOfPossibility(
-                    "project_id", request.project_id, defaults.default_project_id
-                ),
-                OneOfPossibility(
-                    "organization_id",
-                    request.organization_id,
-                    defaults.default_organization_id,
-                ),
-            ]
-        ),
-        "description": request.description,
-        "ip_id": request.ip_id,
-        "name": request.name,
-        "ssl_compatibility_level": SSLCompatibilityLevel(
-            request.ssl_compatibility_level
-        ),
-        "tags": request.tags,
-        "type": request.type_,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.endpoint_spec is not None:
+        output["endpoint_spec"] = marshal_EndpointSpec(request.endpoint_spec, defaults)
 
+    return output
 
-def marshal_CreateRouteRequest(
-    request: CreateRouteRequest,
+
+def marshal_CreateInstanceFromSnapshotRequest(
+    request: CreateInstanceFromSnapshotRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "backend_id": request.backend_id,
-        "frontend_id": request.frontend_id,
-        "match": marshal_RouteMatch(request.match, defaults)
-        if request.match is not None
-        else None,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.instance_name is not None:
+        output["instance_name"] = request.instance_name
+
+    if request.is_ha_cluster is not None:
+        output["is_ha_cluster"] = request.is_ha_cluster
+
+    if request.node_type is not None:
+        output["node_type"] = request.node_type
 
+    return output
 
-def marshal_CreateSubscriberRequest(
-    request: CreateSubscriberRequest,
+
+def marshal_CreateInstanceRequest(
+    request: CreateInstanceRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
                 OneOfPossibility(
-                    "project_id", request.project_id, defaults.default_project_id
+                    "project_id",
+                    request.project_id or defaults.default_project_id
+                    if request.project_id is not None
+                    else None,
+                    defaults.default_project_id,
                 ),
                 OneOfPossibility(
                     "organization_id",
-                    request.organization_id,
+                    request.organization_id or defaults.default_organization_id
+                    if request.organization_id is not None
+                    else None,
                     defaults.default_organization_id,
                 ),
             ]
         ),
-        **resolve_one_of(
-            [
-                OneOfPossibility("email_config", request.email_config),
-                OneOfPossibility("webhook_config", request.webhook_config),
-            ]
-        ),
-        "name": request.name,
-    }
+    )
 
+    if request.backup_same_region is not None:
+        output["backup_same_region"] = request.backup_same_region
 
-def marshal_MigrateLbRequest(
-    request: MigrateLbRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "type": request.type_,
-    }
+    if request.disable_backup is not None:
+        output["disable_backup"] = request.disable_backup
 
+    if request.engine is not None:
+        output["engine"] = request.engine
 
-def marshal_RemoveBackendServersRequest(
-    request: RemoveBackendServersRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "server_ip": request.server_ip,
-    }
+    if request.init_endpoints is not None:
+        output["init_endpoints"] = [
+            marshal_EndpointSpec(v, defaults) for v in request.init_endpoints
+        ]
 
+    if request.init_settings is not None:
+        output["init_settings"] = [
+            marshal_InstanceSetting(v, defaults) for v in request.init_settings
+        ]
 
-def marshal_SetBackendServersRequest(
-    request: SetBackendServersRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "server_ip": request.server_ip,
-    }
+    if request.is_ha_cluster is not None:
+        output["is_ha_cluster"] = request.is_ha_cluster
 
+    if request.name is not None:
+        output["name"] = request.name
 
-def marshal_SubscribeToLbRequest(
-    request: SubscribeToLbRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "subscriber_id": request.subscriber_id,
-    }
+    if request.node_type is not None:
+        output["node_type"] = request.node_type
 
+    if request.password is not None:
+        output["password"] = request.password
 
-def marshal_UpdateAclRequest(
-    request: UpdateAclRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "action": marshal_AclAction(request.action, defaults),
-        "description": request.description,
-        "index": request.index,
-        "match": marshal_AclMatch(request.match, defaults)
-        if request.match is not None
-        else None,
-        "name": request.name,
-    }
+    if request.tags is not None:
+        output["tags"] = request.tags
 
+    if request.user_name is not None:
+        output["user_name"] = request.user_name
 
-def marshal_UpdateBackendRequest(
-    request: UpdateBackendRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "failover_host": request.failover_host,
-        "forward_port": request.forward_port,
-        "forward_port_algorithm": ForwardPortAlgorithm(request.forward_port_algorithm)
-        if request.forward_port_algorithm is not None
-        else None,
-        "forward_protocol": Protocol(request.forward_protocol)
-        if request.forward_protocol is not None
-        else None,
-        "ignore_ssl_server_verify": request.ignore_ssl_server_verify,
-        "name": request.name,
-        "on_marked_down_action": OnMarkedDownAction(request.on_marked_down_action),
-        "proxy_protocol": ProxyProtocol(request.proxy_protocol),
-        "send_proxy_v2": request.send_proxy_v2,
-        "ssl_bridging": request.ssl_bridging,
-        "sticky_sessions": StickySessionsType(request.sticky_sessions)
-        if request.sticky_sessions is not None
-        else None,
-        "sticky_sessions_cookie_name": request.sticky_sessions_cookie_name,
-        "timeout_connect": request.timeout_connect,
-        "timeout_server": request.timeout_server,
-        "timeout_tunnel": request.timeout_tunnel,
-    }
+    if request.volume_size is not None:
+        output["volume_size"] = request.volume_size
 
+    if request.volume_type is not None:
+        output["volume_type"] = VolumeType(request.volume_type)
 
-def marshal_UpdateCertificateRequest(
-    request: UpdateCertificateRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "name": request.name,
-    }
+    return output
 
 
-def marshal_UpdateFrontendRequest(
-    request: UpdateFrontendRequest,
+def marshal_CreateReadReplicaEndpointRequest(
+    request: CreateReadReplicaEndpointRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "backend_id": request.backend_id,
-        "certificate_id": request.certificate_id,
-        "certificate_ids": request.certificate_ids,
-        "enable_http3": request.enable_http3,
-        "inbound_port": request.inbound_port,
-        "name": request.name,
-        "timeout_client": request.timeout_client,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.endpoint_spec is not None:
+        output["endpoint_spec"] = [
+            marshal_ReadReplicaEndpointSpec(v, defaults) for v in request.endpoint_spec
+        ]
 
-def marshal_UpdateHealthCheckRequest(
-    request: UpdateHealthCheckRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
-            [
-                OneOfPossibility("mysql_config", request.mysql_config),
-                OneOfPossibility("ldap_config", request.ldap_config),
-                OneOfPossibility("redis_config", request.redis_config),
-                OneOfPossibility("pgsql_config", request.pgsql_config),
-                OneOfPossibility("tcp_config", request.tcp_config),
-                OneOfPossibility("http_config", request.http_config),
-                OneOfPossibility("https_config", request.https_config),
-            ]
-        ),
-        "check_delay": request.check_delay,
-        "check_max_retries": request.check_max_retries,
-        "check_send_proxy": request.check_send_proxy,
-        "check_timeout": request.check_timeout,
-        "port": request.port,
-    }
+    return output
 
 
-def marshal_UpdateIpRequest(
-    request: UpdateIpRequest,
+def marshal_CreateReadReplicaRequest(
+    request: CreateReadReplicaRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "reverse": request.reverse,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.endpoint_spec is not None:
+        output["endpoint_spec"] = [
+            marshal_ReadReplicaEndpointSpec(v, defaults) for v in request.endpoint_spec
+        ]
 
-def marshal_UpdateLbRequest(
-    request: UpdateLbRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "description": request.description,
-        "name": request.name,
-        "ssl_compatibility_level": SSLCompatibilityLevel(
-            request.ssl_compatibility_level
-        ),
-        "tags": request.tags,
-    }
+    if request.instance_id is not None:
+        output["instance_id"] = request.instance_id
 
+    if request.same_zone is not None:
+        output["same_zone"] = request.same_zone
 
-def marshal_UpdateRouteRequest(
-    request: UpdateRouteRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "backend_id": request.backend_id,
-        "match": marshal_RouteMatch(request.match, defaults)
-        if request.match is not None
-        else None,
-    }
+    return output
 
 
-def marshal_UpdateSubscriberRequest(
-    request: UpdateSubscriberRequest,
+def marshal_CreateSnapshotRequest(
+    request: CreateSnapshotRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
-            [
-                OneOfPossibility("email_config", request.email_config),
-                OneOfPossibility("webhook_config", request.webhook_config),
-            ]
-        ),
-        "name": request.name,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.expires_at is not None:
+        output["expires_at"] = request.expires_at
 
-def marshal_ZonedApiAddBackendServersRequest(
-    request: ZonedApiAddBackendServersRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "server_ip": request.server_ip,
-    }
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
 
 
-def marshal_ZonedApiAttachPrivateNetworkRequest(
-    request: ZonedApiAttachPrivateNetworkRequest,
+def marshal_CreateUserRequest(
+    request: CreateUserRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
-            [
-                OneOfPossibility("static_config", request.static_config),
-                OneOfPossibility("dhcp_config", request.dhcp_config),
-                OneOfPossibility("ipam_config", request.ipam_config),
-            ]
-        ),
-    }
+    output: Dict[str, Any] = {}
 
+    if request.is_admin is not None:
+        output["is_admin"] = request.is_admin
 
-def marshal_ZonedApiCreateAclRequest(
-    request: ZonedApiCreateAclRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "action": marshal_AclAction(request.action, defaults),
-        "description": request.description,
-        "index": request.index,
-        "match": marshal_AclMatch(request.match, defaults)
-        if request.match is not None
-        else None,
-        "name": request.name,
-    }
-
-
-def marshal_ZonedApiCreateBackendRequest(
-    request: ZonedApiCreateBackendRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "failover_host": request.failover_host,
-        "forward_port": request.forward_port,
-        "forward_port_algorithm": ForwardPortAlgorithm(request.forward_port_algorithm)
-        if request.forward_port_algorithm is not None
-        else None,
-        "forward_protocol": Protocol(request.forward_protocol)
-        if request.forward_protocol is not None
-        else None,
-        "health_check": marshal_HealthCheck(request.health_check, defaults),
-        "ignore_ssl_server_verify": request.ignore_ssl_server_verify,
-        "name": request.name,
-        "on_marked_down_action": OnMarkedDownAction(request.on_marked_down_action),
-        "proxy_protocol": ProxyProtocol(request.proxy_protocol),
-        "send_proxy_v2": request.send_proxy_v2,
-        "server_ip": request.server_ip,
-        "ssl_bridging": request.ssl_bridging,
-        "sticky_sessions": StickySessionsType(request.sticky_sessions)
-        if request.sticky_sessions is not None
-        else None,
-        "sticky_sessions_cookie_name": request.sticky_sessions_cookie_name,
-        "timeout_connect": request.timeout_connect,
-        "timeout_server": request.timeout_server,
-        "timeout_tunnel": request.timeout_tunnel,
-    }
+    if request.name is not None:
+        output["name"] = request.name
 
+    if request.password is not None:
+        output["password"] = request.password
 
-def marshal_ZonedApiCreateCertificateRequest(
-    request: ZonedApiCreateCertificateRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
-            [
-                OneOfPossibility("letsencrypt", request.letsencrypt),
-                OneOfPossibility("custom_certificate", request.custom_certificate),
-            ]
-        ),
-        "name": request.name,
-    }
+    return output
 
 
-def marshal_ZonedApiCreateFrontendRequest(
-    request: ZonedApiCreateFrontendRequest,
+def marshal_DeleteInstanceACLRulesRequest(
+    request: DeleteInstanceACLRulesRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "backend_id": request.backend_id,
-        "certificate_id": request.certificate_id,
-        "certificate_ids": request.certificate_ids,
-        "enable_http3": request.enable_http3,
-        "inbound_port": request.inbound_port,
-        "name": request.name,
-        "timeout_client": request.timeout_client,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.acl_rule_ips is not None:
+        output["acl_rule_ips"] = request.acl_rule_ips
 
-def marshal_ZonedApiCreateIpRequest(
-    request: ZonedApiCreateIpRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
-            [
-                OneOfPossibility(
-                    "project_id", request.project_id, defaults.default_project_id
-                ),
-                OneOfPossibility(
-                    "organization_id",
-                    request.organization_id,
-                    defaults.default_organization_id,
-                ),
-            ]
-        ),
-        "reverse": request.reverse,
-    }
+    return output
 
 
-def marshal_ZonedApiCreateLbRequest(
-    request: ZonedApiCreateLbRequest,
+def marshal_DeleteInstanceSettingsRequest(
+    request: DeleteInstanceSettingsRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
-            [
-                OneOfPossibility(
-                    "project_id", request.project_id, defaults.default_project_id
-                ),
-                OneOfPossibility(
-                    "organization_id",
-                    request.organization_id,
-                    defaults.default_organization_id,
-                ),
-            ]
-        ),
-        "description": request.description,
-        "ip_id": request.ip_id,
-        "name": request.name,
-        "ssl_compatibility_level": SSLCompatibilityLevel(
-            request.ssl_compatibility_level
-        ),
-        "tags": request.tags,
-        "type": request.type_,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.setting_names is not None:
+        output["setting_names"] = request.setting_names
 
-def marshal_ZonedApiCreateRouteRequest(
-    request: ZonedApiCreateRouteRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "backend_id": request.backend_id,
-        "frontend_id": request.frontend_id,
-        "match": marshal_RouteMatch(request.match, defaults)
-        if request.match is not None
-        else None,
-    }
+    return output
 
 
-def marshal_ZonedApiCreateSubscriberRequest(
-    request: ZonedApiCreateSubscriberRequest,
+def marshal_MigrateEndpointRequest(
+    request: MigrateEndpointRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
-            [
-                OneOfPossibility(
-                    "project_id", request.project_id, defaults.default_project_id
-                ),
-                OneOfPossibility(
-                    "organization_id",
-                    request.organization_id,
-                    defaults.default_organization_id,
-                ),
-            ]
-        ),
-        **resolve_one_of(
-            [
-                OneOfPossibility("email_config", request.email_config),
-                OneOfPossibility("webhook_config", request.webhook_config),
-            ]
-        ),
-        "name": request.name,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.instance_id is not None:
+        output["instance_id"] = request.instance_id
 
-def marshal_ZonedApiMigrateLbRequest(
-    request: ZonedApiMigrateLbRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "type": request.type_,
-    }
+    return output
 
 
-def marshal_ZonedApiRemoveBackendServersRequest(
-    request: ZonedApiRemoveBackendServersRequest,
+def marshal_PrepareInstanceLogsRequest(
+    request: PrepareInstanceLogsRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "server_ip": request.server_ip,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.end_date is not None:
+        output["end_date"] = request.end_date
 
-def marshal_ZonedApiSetAclsRequest(
-    request: ZonedApiSetAclsRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "acls": [marshal_AclSpec(v, defaults) for v in request.acls],
-    }
+    if request.start_date is not None:
+        output["start_date"] = request.start_date
 
+    return output
 
-def marshal_ZonedApiSetBackendServersRequest(
-    request: ZonedApiSetBackendServersRequest,
+
+def marshal_PurgeInstanceLogsRequest(
+    request: PurgeInstanceLogsRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "server_ip": request.server_ip,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.log_name is not None:
+        output["log_name"] = request.log_name
 
-def marshal_ZonedApiSubscribeToLbRequest(
-    request: ZonedApiSubscribeToLbRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "subscriber_id": request.subscriber_id,
-    }
+    return output
 
 
-def marshal_ZonedApiUpdateAclRequest(
-    request: ZonedApiUpdateAclRequest,
+def marshal_RestoreDatabaseBackupRequest(
+    request: RestoreDatabaseBackupRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "action": marshal_AclAction(request.action, defaults),
-        "description": request.description,
-        "index": request.index,
-        "match": marshal_AclMatch(request.match, defaults)
-        if request.match is not None
-        else None,
-        "name": request.name,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.database_name is not None:
+        output["database_name"] = request.database_name
+
+    if request.instance_id is not None:
+        output["instance_id"] = request.instance_id
+
+    return output
 
 
-def marshal_ZonedApiUpdateBackendRequest(
-    request: ZonedApiUpdateBackendRequest,
+def marshal_SetInstanceACLRulesRequest(
+    request: SetInstanceACLRulesRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "failover_host": request.failover_host,
-        "forward_port": request.forward_port,
-        "forward_port_algorithm": ForwardPortAlgorithm(request.forward_port_algorithm)
-        if request.forward_port_algorithm is not None
-        else None,
-        "forward_protocol": Protocol(request.forward_protocol)
-        if request.forward_protocol is not None
-        else None,
-        "ignore_ssl_server_verify": request.ignore_ssl_server_verify,
-        "name": request.name,
-        "on_marked_down_action": OnMarkedDownAction(request.on_marked_down_action),
-        "proxy_protocol": ProxyProtocol(request.proxy_protocol),
-        "send_proxy_v2": request.send_proxy_v2,
-        "ssl_bridging": request.ssl_bridging,
-        "sticky_sessions": StickySessionsType(request.sticky_sessions)
-        if request.sticky_sessions is not None
-        else None,
-        "sticky_sessions_cookie_name": request.sticky_sessions_cookie_name,
-        "timeout_connect": request.timeout_connect,
-        "timeout_server": request.timeout_server,
-        "timeout_tunnel": request.timeout_tunnel,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.rules is not None:
+        output["rules"] = [marshal_ACLRuleRequest(v, defaults) for v in request.rules]
 
-def marshal_ZonedApiUpdateCertificateRequest(
-    request: ZonedApiUpdateCertificateRequest,
+    return output
+
+
+def marshal_SetInstanceSettingsRequest(
+    request: SetInstanceSettingsRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "name": request.name,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.settings is not None:
+        output["settings"] = [
+            marshal_InstanceSetting(v, defaults) for v in request.settings
+        ]
+
+    return output
 
 
-def marshal_ZonedApiUpdateFrontendRequest(
-    request: ZonedApiUpdateFrontendRequest,
+def marshal_SetPrivilegeRequest(
+    request: SetPrivilegeRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "backend_id": request.backend_id,
-        "certificate_id": request.certificate_id,
-        "certificate_ids": request.certificate_ids,
-        "enable_http3": request.enable_http3,
-        "inbound_port": request.inbound_port,
-        "name": request.name,
-        "timeout_client": request.timeout_client,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.database_name is not None:
+        output["database_name"] = request.database_name
 
-def marshal_ZonedApiUpdateHealthCheckRequest(
-    request: ZonedApiUpdateHealthCheckRequest,
+    if request.permission is not None:
+        output["permission"] = Permission(request.permission)
+
+    if request.user_name is not None:
+        output["user_name"] = request.user_name
+
+    return output
+
+
+def marshal_UpdateDatabaseBackupRequest(
+    request: UpdateDatabaseBackupRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
-            [
-                OneOfPossibility("mysql_config", request.mysql_config),
-                OneOfPossibility("ldap_config", request.ldap_config),
-                OneOfPossibility("redis_config", request.redis_config),
-                OneOfPossibility("pgsql_config", request.pgsql_config),
-                OneOfPossibility("tcp_config", request.tcp_config),
-                OneOfPossibility("http_config", request.http_config),
-                OneOfPossibility("https_config", request.https_config),
-            ]
-        ),
-        "check_delay": request.check_delay,
-        "check_max_retries": request.check_max_retries,
-        "check_send_proxy": request.check_send_proxy,
-        "check_timeout": request.check_timeout,
-        "port": request.port,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.expires_at is not None:
+        output["expires_at"] = request.expires_at
 
-def marshal_ZonedApiUpdateIpRequest(
-    request: ZonedApiUpdateIpRequest,
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
+
+
+def marshal_UpdateInstanceRequest(
+    request: UpdateInstanceRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "reverse": request.reverse,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.backup_same_region is not None:
+        output["backup_same_region"] = request.backup_same_region
+
+    if request.backup_schedule_frequency is not None:
+        output["backup_schedule_frequency"] = request.backup_schedule_frequency
+
+    if request.backup_schedule_retention is not None:
+        output["backup_schedule_retention"] = request.backup_schedule_retention
+
+    if request.backup_schedule_start_hour is not None:
+        output["backup_schedule_start_hour"] = request.backup_schedule_start_hour
+
+    if request.is_backup_schedule_disabled is not None:
+        output["is_backup_schedule_disabled"] = request.is_backup_schedule_disabled
 
+    if request.logs_policy is not None:
+        output["logs_policy"] = marshal_LogsPolicy(request.logs_policy, defaults)
 
-def marshal_ZonedApiUpdateLbRequest(
-    request: ZonedApiUpdateLbRequest,
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.tags is not None:
+        output["tags"] = request.tags
+
+    return output
+
+
+def marshal_UpdateSnapshotRequest(
+    request: UpdateSnapshotRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "description": request.description,
-        "name": request.name,
-        "ssl_compatibility_level": SSLCompatibilityLevel(
-            request.ssl_compatibility_level
-        ),
-        "tags": request.tags,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.expires_at is not None:
+        output["expires_at"] = request.expires_at
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    return output
 
 
-def marshal_ZonedApiUpdateRouteRequest(
-    request: ZonedApiUpdateRouteRequest,
+def marshal_UpdateUserRequest(
+    request: UpdateUserRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "backend_id": request.backend_id,
-        "match": marshal_RouteMatch(request.match, defaults)
-        if request.match is not None
-        else None,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.is_admin is not None:
+        output["is_admin"] = request.is_admin
 
-def marshal_ZonedApiUpdateSubscriberRequest(
-    request: ZonedApiUpdateSubscriberRequest,
+    if request.password is not None:
+        output["password"] = request.password
+
+    return output
+
+
+def marshal_UpgradeInstanceRequest(
+    request: UpgradeInstanceRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("email_config", request.email_config),
-                OneOfPossibility("webhook_config", request.webhook_config),
+                OneOfPossibility(
+                    "node_type",
+                    request.node_type if request.node_type is not None else None,
+                ),
+                OneOfPossibility(
+                    "enable_ha",
+                    request.enable_ha if request.enable_ha is not None else None,
+                ),
+                OneOfPossibility(
+                    "volume_size",
+                    request.volume_size if request.volume_size is not None else None,
+                ),
+                OneOfPossibility(
+                    "volume_type",
+                    VolumeType(request.volume_type)
+                    if request.volume_type is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "upgradable_version_id",
+                    request.upgradable_version_id
+                    if request.upgradable_version_id is not None
+                    else None,
+                ),
             ]
         ),
-        "name": request.name,
-    }
+    )
+
+    return output
```

### Comparing `scaleway_async-0.9.0/scaleway_async/lb/v1/types.py` & `scaleway_async-1.0.0/scaleway_async/lb/v1/types.py`

 * *Files 14% similar despite different names*

```diff
@@ -228,22 +228,16 @@
 
     def __str__(self) -> str:
         return str(self.value)
 
 
 class ProxyProtocol(str, Enum):
     """
-    The PROXY protocol informs the other end about the incoming connection, so that it can know the client's address or the public address it accessed to, whatever the upper layer protocol.
-
-    * `proxy_protocol_none` Disable proxy protocol.
-    * `proxy_protocol_v1` Version one (text format).
-    * `proxy_protocol_v2` Version two (binary format).
-    * `proxy_protocol_v2_ssl` Version two with SSL connection.
-    * `proxy_protocol_v2_ssl_cn` Version two with SSL connection and common name information.
-
+    PROXY protocol to use between the Load Balancer and backend servers. Allows the backend servers to be informed of the client's real IP address. PROXY protocol must be supported by the backend servers' software. For more information on the different protocols available, see the [dedicated documentation](https://www.scaleway.com/en/docs/network/load-balancer/reference-content/configuring-load-balancer/#choosing-a-proxy-protocol).
+    Proxy protocol.
     """
 
     PROXY_PROTOCOL_UNKNOWN = "proxy_protocol_unknown"
     PROXY_PROTOCOL_NONE = "proxy_protocol_none"
     PROXY_PROTOCOL_V1 = "proxy_protocol_v1"
     PROXY_PROTOCOL_V2 = "proxy_protocol_v2"
     PROXY_PROTOCOL_V2_SSL = "proxy_protocol_v2_ssl"
@@ -271,642 +265,681 @@
     def __str__(self) -> str:
         return str(self.value)
 
 
 @dataclass
 class Acl:
     """
-    The use of Access Control Lists (ACL) provide a flexible solution to perform a action generally consist in blocking or allow a request based on ip (and URL on HTTP)
+    Acl.
     """
 
     id: str
     """
-    ID of your ACL ressource
+    ACL ID.
     """
 
     name: str
     """
-    Name of you ACL ressource
+    ACL name.
     """
 
     match: Optional[AclMatch]
     """
-    The ACL match rule. At least `ip_subnet` or `http_filter` and `http_filter_value` are required
+    ACL match filter object. One of `ip_subnet` or `http_filter` & `http_filter_value` are required.
     """
 
     action: Optional[AclAction]
     """
-    Action to undertake when an ACL filter matches
+    Action to take when incoming traffic matches an ACL filter.
     """
 
     frontend: Optional[Frontend]
     """
-    See the Frontend object description
+    ACL is attached to this frontend object.
     """
 
     index: int
     """
-    Order between your Acls (ascending order, 0 is first acl executed)
+    Priority of this ACL (ACLs are applied in ascending order, 0 is the first ACL executed).
     """
 
     created_at: Optional[datetime]
     """
-    Date at which the ACL was created
+    Date on which the ACL was created.
     """
 
     updated_at: Optional[datetime]
     """
-    Date at which the ACL was last updated
+    Date on which the ACL was last updated.
     """
 
     description: str
     """
-    Description of your ACL ressource
+    ACL description.
     """
 
 
 @dataclass
 class AclAction:
     """
-    Acl action
+    Acl action.
     """
 
     type_: AclActionType
     """
-    The action type
+    Action to take when incoming traffic matches an ACL filter.
     """
 
     redirect: Optional[AclActionRedirect]
     """
-    Redirect parameters when using an ACL with `redirect` action
+    Redirection parameters when using an ACL with a `redirect` action.
     """
 
 
 @dataclass
 class AclActionRedirect:
     """
-    Acl action redirect
+    Acl action redirect.
     """
 
     type_: AclActionRedirectRedirectType
     """
-    Redirect type
+    Redirect type.
     """
 
     target: str
     """
-    An URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL).
-    A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme. This can be useful to implement HTTP to HTTPS redirects.
-    Placeholders can be used when using a `location` redirect in order to insert original request's parts, these are:
-    - `{{ host }}` for the current request's Host header
-    - `{{ query }}` for the current request's query string
-    - `{{ path }}` for the current request's URL path
-    - `{{ scheme }}` for the current request's scheme
-    
+    Redirect target. For a location redirect, you can use a URL e.g. `https://scaleway.com`. Using a scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme. This can be useful to implement HTTP to HTTPS redirects. Valid placeholders that can be used in a `location` redirect to preserve parts of the original request in the redirection URL are \{\{host\}\}, \{\{query\}\}, \{\{path\}\} and \{\{scheme\}\}.
     """
 
     code: Optional[int]
     """
-    HTTP redirect code to use. Valid values are 301, 302, 303, 307 and 308. Default value is 302
+    HTTP redirect code to use. Valid values are 301, 302, 303, 307 and 308. Default value is 302.
     """
 
 
 @dataclass
 class AclMatch:
     """
-    Acl match
+    Acl match.
     """
 
     ip_subnet: List[str]
     """
-    A list of IPs or CIDR v4/v6 addresses of the client of the session to match
+    List of IPs or CIDR v4/v6 addresses to filter for from the client side.
     """
 
     http_filter: AclHttpFilter
     """
-    The HTTP filter to match. This filter is supported only if your backend supports HTTP forwarding.
-    It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
-    
+    Type of HTTP filter to match. Extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part). Defines where to filter for the http_filter_value. Only supported for HTTP backends.
     """
 
     http_filter_value: List[str]
     """
-    A list of possible values to match for the given HTTP filter
+    List of values to filter for.
     """
 
     http_filter_option: Optional[str]
     """
-    A exra parameter. You can use this field with http_header_match acl type to set the header name to filter
+    Name of the HTTP header to filter on if `http_header_match` was selected in `http_filter`.
     """
 
     invert: bool
     """
-    If set to `true`, the ACL matching condition will be of type "UNLESS"
+    Defines whether to invert the match condition. If set to `true`, the ACL carries out its action when the condition DOES NOT match.
     """
 
 
 @dataclass
 class AclSpec:
     """
-    Acl spec
+    Acl spec.
     """
 
     name: str
     """
-    Name of your ACL resource
+    ACL name.
     """
 
     action: AclAction
     """
-    Action to undertake when an ACL filter matches
+    Action to take when incoming traffic matches an ACL filter.
     """
 
     match: Optional[AclMatch]
     """
-    The ACL match rule. At least `ip_subnet` or `http_filter` and `http_filter_value` are required
+    ACL match filter object. One of `ip_subnet` or `http_filter` and `http_filter_value` are required.
     """
 
     index: int
     """
-    Order between your Acls (ascending order, 0 is first acl executed)
+    Priority of this ACL (ACLs are applied in ascending order, 0 is the first ACL executed).
     """
 
     description: str
     """
-    Description of your ACL ressource
+    ACL description.
     """
 
 
 @dataclass
 class Backend:
     """
-    Backend
+    Backend.
     """
 
     id: str
     """
-    Load balancer Backend ID
+    Backend ID.
     """
 
     name: str
     """
-    Load balancer Backend name
+    Name of the backend.
     """
 
     forward_protocol: Protocol
     """
-    Type of backend protocol
+    Protocol used by the backend when forwarding traffic to backend servers.
     """
 
     forward_port: int
     """
-    User sessions will be forwarded to this port of backend servers
+    Port used by the backend when forwarding traffic to backend servers.
     """
 
     forward_port_algorithm: ForwardPortAlgorithm
     """
-    Load balancer algorithm used to select the backend server
+    Load balancing algorithm to use when determining which backend server to forward new traffic to.
     """
 
     sticky_sessions: StickySessionsType
     """
-    Enables cookie-based session persistence
+    Defines whether sticky sessions (binding a particular session to a particular backend server) are activated and the method to use if so. None disables sticky sessions. Cookie-based uses an HTTP cookie to stick a session to a backend server. Table-based uses the source (client) IP address to stick a session to a backend server.
     """
 
     sticky_sessions_cookie_name: str
     """
-    Cookie name for sticky sessions
+    Cookie name for cookie-based sticky sessions.
     """
 
     health_check: Optional[HealthCheck]
     """
-    Health Check used to verify backend servers status
+    Object defining the health check to be carried out by the backend when checking the status and health of backend servers.
     """
 
     pool: List[str]
     """
-    Servers IP addresses attached to the backend
+    List of IP addresses of backend servers attached to this backend.
     """
 
     lb: Optional[Lb]
     """
-    Load balancer the backend is attached to
+    Load Balancer the backend is attached to.
     """
 
     send_proxy_v2: Optional[bool]
     """
-    Deprecated in favor of proxy_protocol field
+    Deprecated in favor of proxy_protocol field.
     :deprecated
     """
 
     timeout_server: Optional[str]
     """
-    Maximum server connection inactivity time (allowed time the server has to process the request)
+    Maximum allowed time for a backend server to process a request.
     """
 
     timeout_connect: Optional[str]
     """
-    Maximum initial server connection establishment time
+    Maximum allowed time for establishing a connection to a backend server.
     """
 
     timeout_tunnel: Optional[str]
     """
-    Maximum tunnel inactivity time after Websocket is established (take precedence over client and server timeout)
+    Maximum allowed tunnel inactivity time after Websocket is established (takes precedence over client and server timeout).
     """
 
     on_marked_down_action: OnMarkedDownAction
     """
-    Defines what occurs when a backend server is marked down
+    Action to take when a backend server is marked as down.
     """
 
     proxy_protocol: ProxyProtocol
     """
-    PROXY protocol, forward client's address (must be supported by backend servers software)
+    Protocol to use between the Load Balancer and backend servers. Allows the backend servers to be informed of the client's real IP address. The PROXY protocol must be supported by the backend servers' software.
     """
 
     created_at: Optional[datetime]
     """
-    Date at which the backend was created
+    Date at which the backend was created.
     """
 
     updated_at: Optional[datetime]
     """
-    Date at which the backend was updated
+    Date at which the backend was updated.
     """
 
     failover_host: Optional[str]
     """
-    Scaleway S3 bucket website to be served in case all backend servers are down
+    Scaleway S3 bucket website to be served as failover if all backend servers are down, e.g. failover-website.s3-website.fr-par.scw.cloud.
     """
 
     ssl_bridging: Optional[bool]
     """
-    Enable SSL between load balancer and backend servers
+    Defines whether to enable SSL bridging between the Load Balancer and backend servers.
     """
 
     ignore_ssl_server_verify: Optional[bool]
     """
-    Whether or not the server certificate should be verified
+    Defines whether the server certificate verification should be ignored.
+    """
+
+    redispatch_attempt_count: Optional[int]
+    """
+    Whether to use another backend server on each attempt.
+    """
+
+    max_retries: Optional[int]
+    """
+    Number of retries when a backend server connection failed.
+    """
+
+    max_connections: Optional[int]
+    """
+    Maximum number of connections allowed per backend server.
+    """
+
+    timeout_queue: Optional[str]
+    """
+    Maximum time for a request to be left pending in queue when `max_connections` is reached.
     """
 
 
 @dataclass
 class BackendServerStats:
     """
-    State and statistics of your backend server like last health check status, server uptime, result state of your backend server
+    Backend server stats.
     """
 
     instance_id: str
     """
-    ID of your Load balancer cluster server
+    ID of your Load Balancer's underlying Instance.
     """
 
     backend_id: str
     """
-    ID of your Backend
+    Backend ID.
     """
 
     ip: str
     """
-    IPv4 or IPv6 address of the server backend
+    IPv4 or IPv6 address of the backend server.
     """
 
     server_state: BackendServerStatsServerState
     """
-    Server operational state (stopped/starting/running/stopping)
+    Server operational state (stopped/starting/running/stopping).
     """
 
     server_state_changed_at: Optional[datetime]
     """
-    Time since last operational change
+    Time since last operational change.
     """
 
     last_health_check_status: BackendServerStatsHealthCheckStatus
     """
-    Last health check status (unknown/neutral/failed/passed/condpass)
+    Last health check status (unknown/neutral/failed/passed/condpass).
     """
 
 
 @dataclass
 class Certificate:
     """
-    SSL certificate
+    Certificate.
     """
 
     type_: CertificateType
     """
-    Type of certificate (Let's encrypt or custom)
+    Certificate type (Let's Encrypt or custom).
     """
 
     id: str
     """
-    Certificate ID
+    Certificate ID.
     """
 
     common_name: str
     """
-    Main domain name of certificate
+    Main domain name of certificate.
     """
 
     subject_alternative_name: List[str]
     """
-    Alternative domain names
+    Alternative domain names.
     """
 
     fingerprint: str
     """
-    Identifier (SHA-1) of the certificate
+    Identifier (SHA-1) of the certificate.
     """
 
     not_valid_before: Optional[datetime]
     """
-    Validity bounds
+    Lower validity bound.
     """
 
     not_valid_after: Optional[datetime]
     """
-    Validity bounds
+    Upper validity bound.
     """
 
     status: CertificateStatus
     """
-    Status of certificate
+    Certificate status.
     """
 
     lb: Optional[Lb]
     """
-    Load balancer object
+    Load Balancer object the certificate is attached to.
     """
 
     name: str
     """
-    Certificate name
+    Certificate name.
     """
 
     created_at: Optional[datetime]
     """
-    Date at which the certificate was created
+    Date on which the certificate was created.
     """
 
     updated_at: Optional[datetime]
     """
-    Date at which the certificate was last updated
+    Date on which the certificate was last updated.
     """
 
     status_details: Optional[str]
     """
-    Additional information on the status (e.g. in case of certificate generation failure)
+    Additional information about the certificate status (useful in case of certificate generation failure, for example).
     """
 
 
 @dataclass
 class CreateCertificateRequestCustomCertificate:
     """
-    Import a custom SSL certificate
+    Create certificate request. custom certificate.
     """
 
     certificate_chain: str
     """
-    The full PEM-formatted include an entire certificate chain including public key, private key, and optionally certificate authorities.
+    Full PEM-formatted certificate, consisting of the entire certificate chain including public key, private key, and (optionally) Certificate Authorities.
     """
 
 
 @dataclass
 class CreateCertificateRequestLetsencryptConfig:
     """
-    Generate a new SSL certificate using Let's Encrypt.
+    Create certificate request. letsencrypt config.
     """
 
     common_name: str
     """
-    Main domain name of certificate (make sure this domain exists and resolves to your load balancer HA IP)
+    Main domain name of certificate (this domain must exist and resolve to your Load Balancer IP address).
     """
 
     subject_alternative_name: List[str]
     """
-    Alternative domain names (make sure all domain names exists and resolves to your load balancer HA IP)
+    Alternative domain names (all domain names must exist and resolve to your Load Balancer IP address).
     """
 
 
 @dataclass
 class Frontend:
     """
-    Frontend
+    Frontend.
     """
 
     id: str
     """
-    Load balancer Frontend ID
+    Frontend ID.
     """
 
     name: str
     """
-    Load balancer Frontend name
+    Name of the frontend.
     """
 
     inbound_port: int
     """
-    TCP port to listen on the front side
+    Port the frontend listens on.
     """
 
     backend: Optional[Backend]
     """
-    Backend resource the Frontend is attached to
+    Backend object the frontend is attached to.
     """
 
     lb: Optional[Lb]
     """
-    Load balancer the frontend is attached to
+    Load Balancer object the frontend is attached to.
     """
 
     timeout_client: Optional[str]
     """
-    Maximum inactivity time on the client side
+    Maximum allowed inactivity time on the client side.
     """
 
     certificate: Optional[Certificate]
     """
-    Certificate, deprecated in favor of certificate_ids array
+    Certificate, deprecated in favor of certificate_ids array.
     :deprecated
     """
 
     certificate_ids: List[str]
     """
-    List of certificate IDs to bind on the frontend
+    List of SSL/TLS certificate IDs to bind to the frontend.
     """
 
     created_at: Optional[datetime]
     """
-    Date at which the frontend was created
+    Date on which the frontend was created.
     """
 
     updated_at: Optional[datetime]
     """
-    Date at which the frontend was updated
+    Date on which the frontend was last updated.
     """
 
     enable_http3: bool
     """
-    Whether or not HTTP3 protocol is enabled
+    Defines whether to enable HTTP/3 protocol on the frontend.
     """
 
 
 @dataclass
 class HealthCheck:
     """
-    Health check
+    Health check.
     """
 
-    mysql_config: Optional[HealthCheckMysqlConfig]
+    port: int
     """
-    The check requires MySQL >=3.22, for older versions, use TCP check.
-    
-    One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'tcp_config', 'pgsql_config', 'http_config', 'https_config' could be set.
+    Port to use for the backend server health check.
     """
 
-    ldap_config: Optional[HealthCheckLdapConfig]
+    check_delay: Optional[str]
     """
-    The response is analyzed to find an LDAPv3 response message.
-    
-    One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'tcp_config', 'pgsql_config', 'http_config', 'https_config' could be set.
+    Time to wait between two consecutive health checks.
     """
 
-    redis_config: Optional[HealthCheckRedisConfig]
+    check_timeout: Optional[str]
     """
-    The response is analyzed to find the +PONG response message.
-    
-    One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'tcp_config', 'pgsql_config', 'http_config', 'https_config' could be set.
+    Maximum time a backend server has to reply to the health check.
     """
 
     check_max_retries: int
     """
-    Number of consecutive unsuccessful health checks, after which the server will be considered dead
+    Number of consecutive unsuccessful health checks after which the server will be considered dead.
     """
 
     tcp_config: Optional[HealthCheckTcpConfig]
     """
-    Basic TCP health check.
+    Object to configure a basic TCP health check.
     
-    One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'tcp_config', 'pgsql_config', 'http_config', 'https_config' could be set.
+    One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
     """
 
-    pgsql_config: Optional[HealthCheckPgsqlConfig]
+    mysql_config: Optional[HealthCheckMysqlConfig]
     """
-    PostgreSQL health check.
+    Object to configure a MySQL health check. The check requires MySQL >=3.22, for older versions, use a TCP health check.
     
-    One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'tcp_config', 'pgsql_config', 'http_config', 'https_config' could be set.
+    One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
     """
 
-    http_config: Optional[HealthCheckHttpConfig]
+    pgsql_config: Optional[HealthCheckPgsqlConfig]
     """
-    HTTP health check.
+    Object to configure a PostgreSQL health check.
     
-    One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'tcp_config', 'pgsql_config', 'http_config', 'https_config' could be set.
+    One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
     """
 
-    https_config: Optional[HealthCheckHttpsConfig]
+    ldap_config: Optional[HealthCheckLdapConfig]
     """
-    HTTPS health check.
+    Object to configure an LDAP health check. The response is analyzed to find the LDAPv3 response message.
     
-    One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'tcp_config', 'pgsql_config', 'http_config', 'https_config' could be set.
+    One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
     """
 
-    port: int
+    redis_config: Optional[HealthCheckRedisConfig]
     """
-    TCP port to use for the backend server health check
+    Object to configure a Redis health check. The response is analyzed to find the +PONG response message.
+    
+    One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
     """
 
-    check_timeout: Optional[str]
+    http_config: Optional[HealthCheckHttpConfig]
     """
-    Maximum time a backend server has to reply to the health check
+    Object to configure an HTTP health check.
+    
+    One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
     """
 
-    check_delay: Optional[str]
+    https_config: Optional[HealthCheckHttpsConfig]
     """
-    Time between two consecutive health checks
+    Object to configure an HTTPS health check.
+    
+    One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
     """
 
     check_send_proxy: bool
     """
-    It defines whether the health check should be done considering the proxy protocol
+    Defines whether proxy protocol should be activated for the health check.
+    """
+
+    transient_check_delay: Optional[str]
+    """
+    Time to wait between two consecutive health checks when a backend server is in a transient state (going UP or DOWN).
     """
 
 
 @dataclass
 class HealthCheckHttpConfig:
     """
-    Health check. http config
+    Health check. http config.
     """
 
     uri: str
     """
-    HTTP uri used for Healthcheck to the backend servers
+    HTTP URI used for the health check.
+    The HTTP URI to use when performing a health check on backend servers.
     """
 
     method: str
     """
-    HTTP method used for Healthcheck to the backend servers
+    HTTP method used for the health check.
+    The HTTP method used when performing a health check on backend servers.
     """
 
     code: Optional[int]
     """
-    A health check response will be considered as valid if the response's status code match
+    HTTP response code expected for a successful health check.
+    The HTTP response code that should be returned for a health check to be considered successful.
     """
 
     host_header: str
     """
-    HTTP host header used with the request
+    HTTP host header used for the health check.
+    The HTTP host header used when performing a health check on backend servers.
     """
 
 
 @dataclass
 class HealthCheckHttpsConfig:
     """
-    Health check. https config
+    Health check. https config.
     """
 
     uri: str
     """
-    HTTP uri used for Healthcheck to the backend servers
+    HTTP URI used for the health check.
+    The HTTP URI to use when performing a health check on backend servers.
     """
 
     method: str
     """
-    HTTP method used for Healthcheck to the backend servers
+    HTTP method used for the health check.
+    The HTTP method used when performing a health check on backend servers.
     """
 
     code: Optional[int]
     """
-    A health check response will be considered as valid if the response's status code match
+    HTTP response code expected for a successful health check.
+    The HTTP response code that should be returned for a health check to be considered successful.
     """
 
     host_header: str
     """
-    HTTP host header used with the request
+    HTTP host header used for the health check.
+    The HTTP host header used when performing a health check on backend servers.
     """
 
     sni: str
     """
-    Specifies the SNI to use to do health checks over SSL
+    SNI used for SSL health checks.
+    The SNI value used when performing a health check on backend servers over SSL.
     """
 
 
 @dataclass
 class HealthCheckLdapConfig:
     pass
 
 
 @dataclass
 class HealthCheckMysqlConfig:
+    """
+    Health check. mysql config.
+    """
+
     user: str
+    """
+    MySQL user to use for the health check.
+    """
 
 
 @dataclass
 class HealthCheckPgsqlConfig:
+    """
+    Health check. pgsql config.
+    """
+
     user: str
+    """
+    PostgreSQL user to use for the health check.
+    """
 
 
 @dataclass
 class HealthCheckRedisConfig:
     pass
 
 
@@ -914,1882 +947,1945 @@
 class HealthCheckTcpConfig:
     pass
 
 
 @dataclass
 class Instance:
     """
-    Instance
+    Instance.
     """
 
     id: str
     """
-    Underlying Instance ID
+    Underlying Instance ID.
     """
 
     status: InstanceStatus
     """
-    Instance status
+    Instance status.
     """
 
     ip_address: str
     """
-    Instance IP address
+    Instance IP address.
     """
 
     created_at: Optional[datetime]
     """
-    Date at which the Instance was created
+    Date on which the Instance was created.
     """
 
     updated_at: Optional[datetime]
     """
-    Date at which the Instance was updated
+    Date on which the Instance was last updated.
     """
 
     region: Optional[Region]
     """
-    The region the instance is in
+    The region the Instance is in.
     :deprecated
     """
 
     zone: Zone
     """
-    The zone the instance is in
+    The zone the Instance is in.
     """
 
 
 @dataclass
 class Ip:
     """
-    Ip
+    Ip.
     """
 
     id: str
     """
-    Flexible IP ID
+    IP address ID.
     """
 
     ip_address: str
     """
-    IP address
+    IP address.
     """
 
     organization_id: str
     """
-    Organization ID
+    Organization ID of the Scaleway Organization the IP address is in.
     """
 
     project_id: str
     """
-    Project ID
+    Project ID of the Scaleway Project the IP address is in.
     """
 
     lb_id: Optional[str]
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     reverse: str
     """
-    Reverse FQDN
+    Reverse DNS (domain name) of the IP address.
     """
 
     region: Optional[Region]
     """
-    The region the Flexible IP is in
+    The region the IP address is in.
     :deprecated
     """
 
     zone: Zone
     """
-    The zone the Flexible IP is in
+    The zone the IP address is in.
     """
 
 
 @dataclass
 class Lb:
     """
-    Lb
+    Lb.
     """
 
     id: str
     """
-    Underlying Instance ID
+    Underlying Instance ID.
     """
 
     name: str
     """
-    Load balancer name
+    Load Balancer name.
     """
 
     description: str
     """
-    Load balancer description
+    Load Balancer description.
     """
 
     status: LbStatus
     """
-    Load balancer status
+    Load Balancer status.
     """
 
     instances: List[Instance]
     """
-    List of underlying instances
+    List of underlying Instances.
     """
 
     organization_id: str
     """
-    Organization ID
+    Scaleway Organization ID.
     """
 
     project_id: str
     """
-    Project ID
+    Scaleway Project ID.
     """
 
     ip: List[Ip]
     """
-    List of IPs attached to the Load balancer
+    List of IP addresses attached to the Load Balancer.
     """
 
     tags: List[str]
     """
-    Load balancer tags
+    Load Balancer tags.
     """
 
     frontend_count: int
     """
-    Number of frontends the Load balancer has
+    Number of frontends the Load Balancer has.
     """
 
     backend_count: int
     """
-    Number of backends the Load balancer has
+    Number of backends the Load Balancer has.
     """
 
     type_: str
     """
-    Load balancer offer type
+    Load Balancer offer type.
     """
 
     subscriber: Optional[Subscriber]
     """
-    Subscriber information
+    Subscriber information.
     """
 
     ssl_compatibility_level: SSLCompatibilityLevel
     """
-    Determines the minimal SSL version which needs to be supported on client side
+    Determines the minimal SSL version which needs to be supported on client side.
     """
 
     created_at: Optional[datetime]
     """
-    Date at which the Load balancer was created
+    Date on which the Load Balancer was created.
     """
 
     updated_at: Optional[datetime]
     """
-    Date at which the Load balancer was updated
+    Date on which the Load Balancer was last updated.
     """
 
     private_network_count: int
     """
-    Number of private networks attached to the Load balancer
+    Number of Private Networks attached to the Load Balancer.
     """
 
     route_count: int
     """
-    Number of routes the Load balancer has
+    Number of routes configured on the Load Balancer.
     """
 
     region: Optional[Region]
     """
-    The region the Load balancer is in
+    The region the Load Balancer is in.
     :deprecated
     """
 
     zone: Zone
     """
-    The zone the Load balancer is in
+    The zone the Load Balancer is in.
     """
 
 
 @dataclass
 class LbStats:
     """
-    Lb stats
+    Lb stats.
     """
 
     backend_servers_stats: List[BackendServerStats]
     """
-    List stats object of your Load balancer
+    List of objects containing Load Balancer statistics.
     """
 
 
 @dataclass
 class LbType:
+    """
+    Lb type.
+    """
+
     name: str
+    """
+    Load Balancer commercial offer type name.
+    """
 
     stock_status: LbTypeStock
+    """
+    Current stock status for a given Load Balancer type.
+    """
 
     description: str
+    """
+    Load Balancer commercial offer type description.
+    """
 
     region: Optional[Region]
     """
+    The region the Load Balancer stock is in.
     :deprecated
     """
 
     zone: Zone
+    """
+    The zone the Load Balancer stock is in.
+    """
 
 
 @dataclass
 class ListAclResponse:
     """
-    List acl response
+    List acl response.
     """
 
     acls: List[Acl]
     """
-    List of Acl object (see Acl object description)
+    List of ACL objects.
     """
 
     total_count: int
     """
-    The total number of items
+    The total number of objects.
     """
 
 
 @dataclass
 class ListBackendStatsResponse:
     """
-    List backend stats response
+    List backend stats response.
     """
 
     backend_servers_stats: List[BackendServerStats]
     """
-    List backend stats object of your Load balancer
+    List of objects containing backend server statistics.
     """
 
     total_count: int
     """
-    The total number of items
+    The total number of objects.
     """
 
 
 @dataclass
 class ListBackendsResponse:
     """
-    List backends response
+    List backends response.
     """
 
     backends: List[Backend]
     """
-    List Backend objects of a load balancer
+    List of backend objects of a given Load Balancer.
     """
 
     total_count: int
     """
-    Total count, wihtout pagination
+    Total count of backend objects, without pagination.
     """
 
 
 @dataclass
 class ListCertificatesResponse:
     """
-    List certificates response
+    List certificates response.
     """
 
     certificates: List[Certificate]
     """
-    List of certificates
+    List of certificate objects.
     """
 
     total_count: int
     """
-    The total number of items
+    The total number of objects.
     """
 
 
 @dataclass
 class ListFrontendsResponse:
     """
-    List frontends response
+    List frontends response.
     """
 
     frontends: List[Frontend]
     """
-    List frontends object of your Load balancer
+    List of frontend objects of a given Load Balancer.
     """
 
     total_count: int
     """
-    Total count, wihtout pagination
+    Total count of frontend objects, without pagination.
     """
 
 
 @dataclass
 class ListIpsResponse:
     """
-    List ips response
+    List ips response.
     """
 
     ips: List[Ip]
     """
-    List IP address object
+    List of IP address objects.
     """
 
     total_count: int
     """
-    Total count, wihtout pagination
+    Total count of IP address objects, without pagination.
     """
 
 
 @dataclass
 class ListLbPrivateNetworksResponse:
     """
-    List lb private networks response
+    List lb private networks response.
     """
 
     private_network: List[PrivateNetwork]
     """
-    Private networks of a given load balancer
+    List of Private Network objects attached to the Load Balancer.
     """
 
     total_count: int
     """
-    The total number of items
+    Total number of objects in the response.
     """
 
 
 @dataclass
 class ListLbTypesResponse:
     """
-    List lb types response
+    List lb types response.
     """
 
     lb_types: List[LbType]
     """
-    Different types of LB
+    List of Load Balancer commercial offer type objects.
     """
 
     total_count: int
     """
-    The total number of items
+    Total number of Load Balancer offer type objects.
     """
 
 
 @dataclass
 class ListLbsResponse:
     """
-    Get list of Load balancers
+    List lbs response.
     """
 
     lbs: List[Lb]
     """
-    List of Load balancer
+    List of Load Balancer objects.
     """
 
     total_count: int
     """
-    The total number of items
+    The total number of Load Balancer objects.
     """
 
 
 @dataclass
 class ListRoutesResponse:
     """
-    List routes response
+    List routes response.
     """
 
     routes: List[Route]
     """
-    List of Routes object
+    List of route objects.
     """
 
     total_count: int
     """
-    The total number of items
+    The total number of route objects.
     """
 
 
 @dataclass
 class ListSubscriberResponse:
     """
-    List subscriber response
+    List subscriber response.
     """
 
     subscribers: List[Subscriber]
     """
-    List of Subscribers object
+    List of subscriber objects.
     """
 
     total_count: int
     """
-    The total number of items
+    The total number of objects.
     """
 
 
 @dataclass
 class PrivateNetwork:
     """
-    Private network
+    Private network.
     """
 
     lb: Optional[Lb]
     """
-    LoadBalancer object
+    Load Balancer object which is attached to the Private Network.
     """
 
     static_config: Optional[PrivateNetworkStaticConfig]
     """
-    Local ip address of load balancer instance.
+    Object containing an array of a local IP address for the Load Balancer on this Private Network.
     
     One-of ('config'): at most one of 'static_config', 'dhcp_config', 'ipam_config' could be set.
+    :deprecated
     """
 
     dhcp_config: Optional[PrivateNetworkDHCPConfig]
     """
-    Value set to true if load balancer instance use a DHCP.
+    Object containing DHCP-assigned IP addresses.
     
     One-of ('config'): at most one of 'static_config', 'dhcp_config', 'ipam_config' could be set.
     """
 
     ipam_config: Optional[PrivateNetworkIpamConfig]
     """
-    Value set to true if load balancer instance use a DHCP.
+    For internal use only.
     
     One-of ('config'): at most one of 'static_config', 'dhcp_config', 'ipam_config' could be set.
+    :deprecated
     """
 
     private_network_id: str
     """
-    Instance private network id
+    Private Network ID.
     """
 
     status: PrivateNetworkStatus
     """
-    Status (running, to create...) of private network connection
+    Status of Private Network connection.
     """
 
     created_at: Optional[datetime]
     """
-    Date at which the PN was created
+    Date on which the Private Network was created.
     """
 
     updated_at: Optional[datetime]
     """
-    Date at which the PN was last updated
+    Date on which the PN was last updated.
     """
 
 
 @dataclass
 class PrivateNetworkDHCPConfig:
-    pass
+    ip_id: Optional[str]
 
 
 @dataclass
 class PrivateNetworkIpamConfig:
     pass
 
 
 @dataclass
 class PrivateNetworkStaticConfig:
-    ip_address: List[str]
+    """
+    Private network. static config.
+    """
+
+    ip_address: Optional[List[str]]
+    """
+    Array of a local IP address for the Load Balancer on this Private Network.
+    :deprecated
+    """
 
 
 @dataclass
 class Route:
     """
-    Route
+    Route.
     """
 
     id: str
     """
-    Id of match ressource
+    Route ID.
     """
 
     frontend_id: str
     """
-    Id of frontend
+    ID of the source frontend.
     """
 
     backend_id: str
     """
-    Id of backend
+    ID of the target backend.
     """
 
     match: Optional[RouteMatch]
     """
-    Value to match a redirection
+    Object defining the match condition for a route to be applied. If an incoming client session matches the specified condition (i.e. it has a matching SNI value or HTTP Host header value), it will be passed to the target backend.
     """
 
     created_at: Optional[datetime]
     """
-    Date at which the route was created
+    Date on which the route was created.
     """
 
     updated_at: Optional[datetime]
     """
-    Date at which the route was last updated
+    Date on which the route was last updated.
     """
 
 
 @dataclass
 class RouteMatch:
     """
-    Route. match
+    Route. match.
     """
 
     sni: Optional[str]
     """
-    Server Name Indication TLS extension (SNI) field from an incoming connection made via an SSL/TLS transport layer.
+    Server Name Indication (SNI) value to match.
+    Value to match in the Server Name Indication TLS extension (SNI) field from an incoming connection made via an SSL/TLS transport layer. This field should be set for routes on TCP Load Balancers.
     
     One-of ('match_type'): at most one of 'sni', 'host_header' could be set.
     """
 
     host_header: Optional[str]
     """
-    The Host request header specifies the host of the server to which the request is being sent.
+    HTTP host header to match.
+    Value to match in the HTTP Host request header from an incoming connection. This field should be set for routes on HTTP Load Balancers.
     
     One-of ('match_type'): at most one of 'sni', 'host_header' could be set.
     """
 
 
 @dataclass
 class SetAclsResponse:
     """
-    Set acls response
+    Set acls response.
     """
 
     acls: List[Acl]
     """
-    List of ACLs object (see ACL object description)
+    List of ACL objects.
     """
 
     total_count: int
     """
-    The total number of items
+    The total number of ACL objects.
     """
 
 
 @dataclass
 class Subscriber:
     """
-    Subscriber
+    Subscriber.
     """
 
     id: str
     """
-    Subscriber ID
+    Subscriber ID.
     """
 
     name: str
     """
-    Subscriber name
+    Subscriber name.
     """
 
     email_config: Optional[SubscriberEmailConfig]
     """
     Email address of subscriber.
     
     One-of ('config'): at most one of 'email_config', 'webhook_config' could be set.
     """
 
     webhook_config: Optional[SubscriberWebhookConfig]
     """
-    WebHook URI of subscriber.
+    Webhook URI of subscriber.
     
     One-of ('config'): at most one of 'email_config', 'webhook_config' could be set.
     """
 
 
 @dataclass
 class SubscriberEmailConfig:
     """
-    Email alert of subscriber
+    Subscriber. email config.
     """
 
     email: str
     """
-    Email who receive alert
+    Email address to send alerts to.
     """
 
 
 @dataclass
 class SubscriberWebhookConfig:
     """
-    Webhook alert of subscriber
+    Webhook alert of subscriber.
+    Subscriber. webhook config.
     """
 
     uri: str
     """
-    URI who receive POST request
+    URI to receive POST requests.
     """
 
 
 @dataclass
 class ListLbsRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     name: Optional[str]
     """
-    Use this to search by name
+    Load Balancer name to filter for.
     """
 
     order_by: Optional[ListLbsRequestOrderBy]
     """
-    Response order
+    Sort order of Load Balancers in the response.
     """
 
     page_size: Optional[int]
     """
-    The number of items to return
+    Number of Load Balancers to return.
     """
 
     page: Optional[int]
     """
-    Page number
+    Page number to return, from the paginated results.
     """
 
     organization_id: Optional[str]
     """
-    Filter LBs by organization ID
+    Organization ID to filter for, only Load Balancers from this Organization will be returned.
     """
 
     project_id: Optional[str]
     """
-    Filter LBs by project ID
+    Project ID to filter for, only Load Balancers from this Project will be returned.
     """
 
 
 @dataclass
 class CreateLbRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     organization_id: Optional[str]
     """
-    Owner of resources.
+    Scaleway Organization to create the Load Balancer in.
     
     One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
     :deprecated
     """
 
     project_id: Optional[str]
     """
-    Assign the resource to a project ID.
+    Scaleway Project to create the Load Balancer in.
     
     One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
     """
 
     name: Optional[str]
     """
-    Resource names
+    Name for the Load Balancer.
     """
 
     description: str
     """
-    Resource description
+    Description for the Load Balancer.
     """
 
     ip_id: Optional[str]
     """
-    Just like for compute instances, when you destroy a load balancer, you can keep its highly available IP address and reuse it for another load balancer later
+    ID of an existing flexible IP address to attach to the Load Balancer.
+    :deprecated
+    """
+
+    assign_flexible_ip: Optional[bool]
+    """
+    Defines whether to automatically assign a flexible public IP to lb. Default value is `false` (do not assign).
     """
 
     tags: Optional[List[str]]
     """
-    List of keyword
+    List of tags for the Load Balancer.
     """
 
     type_: str
     """
-    Load balancer offer type
+    Load Balancer commercial offer type. Use the Load Balancer types endpoint to retrieve a list of available offer types.
     """
 
     ssl_compatibility_level: SSLCompatibilityLevel
     """
-    Enforces minimal SSL version (in SSL/TLS offloading context).
-    - `intermediate` General-purpose servers with a variety of clients, recommended for almost all systems (Supports Firefox 27, Android 4.4.2, Chrome 31, Edge, IE 11 on Windows 7, Java 8u31, OpenSSL 1.0.1, Opera 20, and Safari 9).
-    - `modern` Services with clients that support TLS 1.3 and don't need backward compatibility (Firefox 63, Android 10.0, Chrome 70, Edge 75, Java 11, OpenSSL 1.1.1, Opera 57, and Safari 12.1).
-    - `old` Compatible with a number of very old clients, and should be used only as a last resort (Firefox 1, Android 2.3, Chrome 1, Edge 12, IE8 on Windows XP, Java 6, OpenSSL 0.9.8, Opera 5, and Safari 1).
-    
+    Determines the minimal SSL version which needs to be supported on the client side, in an SSL/TLS offloading context. Intermediate is suitable for general-purpose servers with a variety of clients, recommended for almost all systems. Modern is suitable for services with clients that support TLS 1.3 and do not need backward compatibility. Old is compatible with a small number of very old clients and should be used only as a last resort.
     """
 
 
 @dataclass
 class GetLbRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
 
 @dataclass
 class UpdateLbRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     name: str
     """
-    Resource name
+    Load Balancer name.
     """
 
     description: str
     """
-    Resource description
+    Load Balancer description.
     """
 
     tags: Optional[List[str]]
     """
-    List of keywords
+    List of tags for the Load Balancer.
     """
 
     ssl_compatibility_level: SSLCompatibilityLevel
     """
-    Enforces minimal SSL version (in SSL/TLS offloading context).
-    - `intermediate` General-purpose servers with a variety of clients, recommended for almost all systems (Supports Firefox 27, Android 4.4.2, Chrome 31, Edge, IE 11 on Windows 7, Java 8u31, OpenSSL 1.0.1, Opera 20, and Safari 9).
-    - `modern` Services with clients that support TLS 1.3 and don't need backward compatibility (Firefox 63, Android 10.0, Chrome 70, Edge 75, Java 11, OpenSSL 1.1.1, Opera 57, and Safari 12.1).
-    - `old` Compatible with a number of very old clients, and should be used only as a last resort (Firefox 1, Android 2.3, Chrome 1, Edge 12, IE8 on Windows XP, Java 6, OpenSSL 0.9.8, Opera 5, and Safari 1).
-    
+    Determines the minimal SSL version which needs to be supported on the client side, in an SSL/TLS offloading context. Intermediate is suitable for general-purpose servers with a variety of clients, recommended for almost all systems. Modern is suitable for services with clients that support TLS 1.3 and don't need backward compatibility. Old is compatible with a small number of very old clients and should be used only as a last resort.
     """
 
 
 @dataclass
 class DeleteLbRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    ID of the Load Balancer to delete.
     """
 
     release_ip: bool
     """
-    Set true if you don't want to keep this IP address
+    Defines whether the Load Balancer's flexible IP should be deleted. Set to true to release the flexible IP, or false to keep it available in your account for future Load Balancers.
     """
 
 
 @dataclass
 class MigrateLbRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     type_: str
     """
-    Load balancer type (check /lb-types to list all type)
+    Load Balancer type to migrate to (use the List all Load Balancer offer types endpoint to get a list of available offer types).
     """
 
 
 @dataclass
 class ListIPsRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     page: Optional[int]
     """
-    Page number
+    The page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    The number of items to return
+    Number of IP addresses to return.
     """
 
     ip_address: Optional[str]
     """
-    Use this to search by IP address
+    IP address to filter for.
     """
 
     organization_id: Optional[str]
     """
-    Filter IPs by organization id
+    Organization ID to filter for, only Load Balancer IP addresses from this Organization will be returned.
     """
 
     project_id: Optional[str]
     """
-    Filter IPs by project ID
+    Project ID to filter for, only Load Balancer IP addresses from this Project will be returned.
     """
 
 
 @dataclass
 class CreateIpRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     organization_id: Optional[str]
     """
-    Owner of resources.
+    Organization ID of the Organization where the IP address should be created.
     
     One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
     :deprecated
     """
 
     project_id: Optional[str]
     """
-    Assign the resource to a project ID.
+    Project ID of the Project where the IP address should be created.
     
     One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
     """
 
     reverse: Optional[str]
     """
-    Reverse domain name
+    Reverse DNS (domain name) for the IP address.
     """
 
 
 @dataclass
 class GetIpRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     ip_id: str
     """
-    IP address ID
+    IP address ID.
     """
 
 
 @dataclass
 class ReleaseIpRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     ip_id: str
     """
-    IP address ID
+    IP address ID.
     """
 
 
 @dataclass
 class UpdateIpRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     ip_id: str
     """
-    IP address ID
+    IP address ID.
     """
 
     reverse: Optional[str]
     """
-    Reverse DNS
+    Reverse DNS (domain name) for the IP address.
     """
 
 
 @dataclass
 class ListBackendsRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     name: Optional[str]
     """
-    Use this to search by name
+    Name of the backend to filter for.
     """
 
     order_by: Optional[ListBackendsRequestOrderBy]
     """
-    Response order
+    Sort order of backends in the response.
     """
 
     page: Optional[int]
     """
-    Page number
+    The page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    The number of items to return
+    Number of backends to return.
     """
 
 
 @dataclass
 class CreateBackendRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     name: Optional[str]
     """
-    Resource name
+    Name for the backend.
     """
 
     forward_protocol: Optional[Protocol]
     """
-    Backend protocol. TCP or HTTP
+    Protocol to be used by the backend when forwarding traffic to backend servers.
     """
 
     forward_port: int
     """
-    User sessions will be forwarded to this port of backend servers
+    Port to be used by the backend when forwarding traffic to backend servers.
     """
 
     forward_port_algorithm: Optional[ForwardPortAlgorithm]
     """
-    Load balancing algorithm
+    Load balancing algorithm to be used when determining which backend server to forward new traffic to.
     """
 
     sticky_sessions: Optional[StickySessionsType]
     """
-    Enables cookie-based session persistence
+    Defines whether to activate sticky sessions (binding a particular session to a particular backend server) and the method to use if so. None disables sticky sessions. Cookie-based uses an HTTP cookie TO stick a session to a backend server. Table-based uses the source (client) IP address to stick a session to a backend server.
     """
 
     sticky_sessions_cookie_name: str
     """
-    Cookie name for sticky sessions
+    Cookie name for cookie-based sticky sessions.
     """
 
     health_check: HealthCheck
     """
-    See the Healthcheck object description
+    Object defining the health check to be carried out by the backend when checking the status and health of backend servers.
     """
 
     server_ip: List[str]
     """
-    Backend server IP addresses list (IPv4 or IPv6)
+    List of backend server IP addresses (IPv4 or IPv6) the backend should forward traffic to.
     """
 
     send_proxy_v2: Optional[bool]
     """
-    Deprecated in favor of proxy_protocol field !
+    Deprecated in favor of proxy_protocol field.
     :deprecated
     """
 
     timeout_server: Optional[str]
     """
-    Maximum server connection inactivity time (allowed time the server has to process the request)
+    Maximum allowed time for a backend server to process a request.
     """
 
     timeout_connect: Optional[str]
     """
-    Maximum initial server connection establishment time
+    Maximum allowed time for establishing a connection to a backend server.
     """
 
     timeout_tunnel: Optional[str]
     """
-    Maximum tunnel inactivity time after Websocket is established (take precedence over client and server timeout)
+    Maximum allowed tunnel inactivity time after Websocket is established (takes precedence over client and server timeout).
     """
 
     on_marked_down_action: OnMarkedDownAction
     """
-    Modify what occurs when a backend server is marked down
+    Action to take when a backend server is marked as down.
     """
 
     proxy_protocol: ProxyProtocol
     """
-    The PROXY protocol informs the other end about the incoming connection, so that it can know the client's address or the public address it accessed to, whatever the upper layer protocol.
-    
-    * `proxy_protocol_none` Disable proxy protocol.
-    * `proxy_protocol_v1` Version one (text format).
-    * `proxy_protocol_v2` Version two (binary format).
-    * `proxy_protocol_v2_ssl` Version two with SSL connection.
-    * `proxy_protocol_v2_ssl_cn` Version two with SSL connection and common name information.
-    
+    Protocol to use between the Load Balancer and backend servers. Allows the backend servers to be informed of the client's real IP address. The PROXY protocol must be supported by the backend servers' software.
     """
 
     failover_host: Optional[str]
     """
-    Only the host part of the Scaleway S3 bucket website is expected.
-    E.g. `failover-website.s3-website.fr-par.scw.cloud` if your bucket website URL is `https://failover-website.s3-website.fr-par.scw.cloud/`.
-    
+    Scaleway S3 bucket website to be served as failover if all backend servers are down, e.g. failover-website.s3-website.fr-par.scw.cloud.
     """
 
     ssl_bridging: Optional[bool]
     """
-    Enable SSL between load balancer and backend servers
+    Defines whether to enable SSL bridging between the Load Balancer and backend servers.
     """
 
     ignore_ssl_server_verify: Optional[bool]
     """
-    Set to true to ignore server certificate verification
+    Defines whether the server certificate verification should be ignored.
+    """
+
+    redispatch_attempt_count: Optional[int]
+    """
+    Whether to use another backend server on each attempt.
+    """
+
+    max_retries: Optional[int]
+    """
+    Number of retries when a backend server connection failed.
+    """
+
+    max_connections: Optional[int]
+    """
+    Maximum number of connections allowed per backend server.
+    """
+
+    timeout_queue: Optional[str]
+    """
+    Maximum time for a request to be left pending in queue when `max_connections` is reached.
     """
 
 
 @dataclass
 class GetBackendRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     backend_id: str
     """
-    Backend ID
+    Backend ID.
     """
 
 
 @dataclass
 class UpdateBackendRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     backend_id: str
     """
-    Backend ID to update
+    Backend ID.
     """
 
     name: str
     """
-    Resource name
+    Backend name.
     """
 
     forward_protocol: Optional[Protocol]
     """
-    Backend protocol. TCP or HTTP
+    Protocol to be used by the backend when forwarding traffic to backend servers.
     """
 
     forward_port: int
     """
-    User sessions will be forwarded to this port of backend servers
+    Port to be used by the backend when forwarding traffic to backend servers.
     """
 
     forward_port_algorithm: Optional[ForwardPortAlgorithm]
     """
-    Load balancing algorithm
+    Load balancing algorithm to be used when determining which backend server to forward new traffic to.
     """
 
     sticky_sessions: Optional[StickySessionsType]
     """
-    Enable cookie-based session persistence
+    Defines whether to activate sticky sessions (binding a particular session to a particular backend server) and the method to use if so. None disables sticky sessions. Cookie-based uses an HTTP cookie to stick a session to a backend server. Table-based uses the source (client) IP address to stick a session to a backend server.
     """
 
     sticky_sessions_cookie_name: str
     """
-    Cookie name for sticky sessions
+    Cookie name for cookie-based sticky sessions.
     """
 
     send_proxy_v2: Optional[bool]
     """
-    Deprecated in favor of proxy_protocol field!
+    Deprecated in favor of proxy_protocol field.
     :deprecated
     """
 
     timeout_server: Optional[str]
     """
-    Maximum server connection inactivity time (allowed time the server has to process the request)
+    Maximum allowed time for a backend server to process a request.
     """
 
     timeout_connect: Optional[str]
     """
-    Maximum initial server connection establishment time
+    Maximum allowed time for establishing a connection to a backend server.
     """
 
     timeout_tunnel: Optional[str]
     """
-    Maximum tunnel inactivity time after Websocket is established (take precedence over client and server timeout)
+    Maximum allowed tunnel inactivity time after Websocket is established (takes precedence over client and server timeout).
     """
 
     on_marked_down_action: OnMarkedDownAction
     """
-    Modify what occurs when a backend server is marked down
+    Action to take when a backend server is marked as down.
     """
 
     proxy_protocol: ProxyProtocol
     """
-    The PROXY protocol informs the other end about the incoming connection, so that it can know the client's address or the public address it accessed to, whatever the upper layer protocol is.
-    
-    * `proxy_protocol_none` Disable proxy protocol.
-    * `proxy_protocol_v1` Version one (text format).
-    * `proxy_protocol_v2` Version two (binary format).
-    * `proxy_protocol_v2_ssl` Version two with SSL connection.
-    * `proxy_protocol_v2_ssl_cn` Version two with SSL connection and common name information.
-    
+    Protocol to use between the Load Balancer and backend servers. Allows the backend servers to be informed of the client's real IP address. The PROXY protocol must be supported by the backend servers' software.
     """
 
     failover_host: Optional[str]
     """
-    Only the host part of the Scaleway S3 bucket website is expected.
-    Example: `failover-website.s3-website.fr-par.scw.cloud` if your bucket website URL is `https://failover-website.s3-website.fr-par.scw.cloud/`.
-    
+    Scaleway S3 bucket website to be served as failover if all backend servers are down, e.g. failover-website.s3-website.fr-par.scw.cloud.
     """
 
     ssl_bridging: Optional[bool]
     """
-    Enable SSL between load balancer and backend servers
+    Defines whether to enable SSL bridging between the Load Balancer and backend servers.
     """
 
     ignore_ssl_server_verify: Optional[bool]
     """
-    Set to true to ignore server certificate verification
+    Defines whether the server certificate verification should be ignored.
+    """
+
+    redispatch_attempt_count: Optional[int]
+    """
+    Whether to use another backend server on each attempt.
+    """
+
+    max_retries: Optional[int]
+    """
+    Number of retries when a backend server connection failed.
+    """
+
+    max_connections: Optional[int]
+    """
+    Maximum number of connections allowed per backend server.
+    """
+
+    timeout_queue: Optional[str]
+    """
+    Maximum time for a request to be left pending in queue when `max_connections` is reached.
     """
 
 
 @dataclass
 class DeleteBackendRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     backend_id: str
     """
-    ID of the backend to delete
+    ID of the backend to delete.
     """
 
 
 @dataclass
 class AddBackendServersRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     backend_id: str
     """
-    Backend ID
+    Backend ID.
     """
 
     server_ip: List[str]
     """
-    Set all IPs to add on your backend
+    List of IP addresses to add to backend servers.
     """
 
 
 @dataclass
 class RemoveBackendServersRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     backend_id: str
     """
-    Backend ID
+    Backend ID.
     """
 
     server_ip: List[str]
     """
-    Set all IPs to remove of your backend
+    List of IP addresses to remove from backend servers.
     """
 
 
 @dataclass
 class SetBackendServersRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     backend_id: str
     """
-    Backend ID
+    Backend ID.
     """
 
     server_ip: List[str]
     """
-    Set all IPs to add on your backend and remove all other
+    List of IP addresses for backend servers. Any other existing backend servers will be removed.
     """
 
 
 @dataclass
 class UpdateHealthCheckRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     backend_id: str
     """
-    Backend ID
+    Backend ID.
     """
 
     port: int
     """
-    Specify the port used to health check
+    Port to use for the backend server health check.
     """
 
     check_delay: str
     """
-    Time between two consecutive health checks
+    Time to wait between two consecutive health checks.
     """
 
     check_timeout: str
     """
-    Maximum time a backend server has to reply to the health check
+    Maximum time a backend server has to reply to the health check.
     """
 
     check_max_retries: int
     """
-    Number of consecutive unsuccessful health checks, after which the server will be considered dead
+    Number of consecutive unsuccessful health checks after which the server will be considered dead.
     """
 
-    mysql_config: Optional[HealthCheckMysqlConfig]
+    check_send_proxy: bool
     """
-    The check requires MySQL >=3.22, for older version, please use TCP check.
-    
-    One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
+    Defines whether proxy protocol should be activated for the health check.
     """
 
-    ldap_config: Optional[HealthCheckLdapConfig]
+    tcp_config: Optional[HealthCheckTcpConfig]
     """
-    The response is analyzed to find an LDAPv3 response message.
+    Object to configure a basic TCP health check.
     
-    One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
+    One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
     """
 
-    redis_config: Optional[HealthCheckRedisConfig]
+    mysql_config: Optional[HealthCheckMysqlConfig]
     """
-    The response is analyzed to find the +PONG response message.
+    Object to configure a MySQL health check. The check requires MySQL >=3.22, for older versions, use a TCP health check.
     
-    One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
+    One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
     """
 
     pgsql_config: Optional[HealthCheckPgsqlConfig]
     """
-    PostgreSQL health check.
+    Object to configure a PostgreSQL health check.
     
-    One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
+    One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
     """
 
-    tcp_config: Optional[HealthCheckTcpConfig]
+    ldap_config: Optional[HealthCheckLdapConfig]
     """
-    Basic TCP health check.
+    Object to configure an LDAP health check. The response is analyzed to find the LDAPv3 response message.
     
-    One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
+    One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
+    """
+
+    redis_config: Optional[HealthCheckRedisConfig]
+    """
+    Object to configure a Redis health check. The response is analyzed to find the +PONG response message.
+    
+    One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
     """
 
     http_config: Optional[HealthCheckHttpConfig]
     """
-    HTTP health check.
+    Object to configure an HTTP health check.
     
-    One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
+    One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
     """
 
     https_config: Optional[HealthCheckHttpsConfig]
     """
-    HTTPS health check.
+    Object to configure an HTTPS health check.
     
-    One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
+    One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
     """
 
-    check_send_proxy: bool
+    transient_check_delay: Optional[str]
     """
-    It defines whether the health check should be done considering the proxy protocol
+    Time to wait between two consecutive health checks when a backend server is in a transient state (going UP or DOWN).
     """
 
 
 @dataclass
 class ListFrontendsRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     name: Optional[str]
     """
-    Use this to search by name
+    Name of the frontend to filter for.
     """
 
     order_by: Optional[ListFrontendsRequestOrderBy]
     """
-    Response order
+    Sort order of frontends in the response.
     """
 
     page: Optional[int]
     """
-    Page number
+    The page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    The number of items to return
+    Number of frontends to return.
     """
 
 
 @dataclass
 class CreateFrontendRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID (ID of the Load Balancer to attach the frontend to).
     """
 
     name: Optional[str]
     """
-    Resource name
+    Name for the frontend.
     """
 
     inbound_port: int
     """
-    TCP port to listen on the front side
+    Port the frontend should listen on.
     """
 
     backend_id: str
     """
-    Backend ID
+    Backend ID (ID of the backend the frontend should pass traffic to).
     """
 
     timeout_client: Optional[str]
     """
-    Set the maximum inactivity time on the client side
+    Maximum allowed inactivity time on the client side.
     """
 
     certificate_id: Optional[str]
     """
-    Certificate ID, deprecated in favor of certificate_ids array !
+    Certificate ID, deprecated in favor of certificate_ids array.
     :deprecated
     """
 
     certificate_ids: Optional[List[str]]
     """
-    List of certificate IDs to bind on the frontend
+    List of SSL/TLS certificate IDs to bind to the frontend.
     """
 
     enable_http3: bool
     """
-    Activate HTTP 3 protocol (beta)
+    Defines whether to enable HTTP/3 protocol on the frontend.
     """
 
 
 @dataclass
 class GetFrontendRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     frontend_id: str
     """
-    Frontend ID
+    Frontend ID.
     """
 
 
 @dataclass
 class UpdateFrontendRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     frontend_id: str
     """
-    Frontend ID
+    Frontend ID.
     """
 
     name: str
     """
-    Resource name
+    Frontend name.
     """
 
     inbound_port: int
     """
-    TCP port to listen on the front side
+    Port the frontend should listen on.
     """
 
     backend_id: str
     """
-    Backend ID
+    Backend ID (ID of the backend the frontend should pass traffic to).
     """
 
     timeout_client: Optional[str]
     """
-    Client session maximum inactivity time
+    Maximum allowed inactivity time on the client side.
     """
 
     certificate_id: Optional[str]
     """
-    Certificate ID, deprecated in favor of `certificate_ids` array!
+    Certificate ID, deprecated in favor of certificate_ids array.
     :deprecated
     """
 
     certificate_ids: Optional[List[str]]
     """
-    List of certificate IDs to bind on the frontend
+    List of SSL/TLS certificate IDs to bind to the frontend.
     """
 
     enable_http3: bool
     """
-    Activate HTTP 3 protocol (beta)
+    Defines whether to enable HTTP/3 protocol on the frontend.
     """
 
 
 @dataclass
 class DeleteFrontendRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     frontend_id: str
     """
-    Frontend ID to delete
+    ID of the frontend to delete.
     """
 
 
 @dataclass
 class ListRoutesRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     order_by: Optional[ListRoutesRequestOrderBy]
     """
-    Response order
+    Sort order of routes in the response.
     """
 
     page_size: Optional[int]
     """
-    The number of items to return
+    The number of route objects to return.
     """
 
     page: Optional[int]
     """
-    Page number
+    The page number to return, from the paginated results.
     """
 
     frontend_id: Optional[str]
+    """
+    Frontend ID to filter for, only Routes from this Frontend will be returned.
+    """
 
 
 @dataclass
 class CreateRouteRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     frontend_id: str
     """
-    Origin of redirection
+    ID of the source frontend to create the route on.
     """
 
     backend_id: str
     """
-    Destination of destination
+    ID of the target backend for the route.
     """
 
     match: Optional[RouteMatch]
     """
-    Value to match a redirection
+    Object defining the match condition for a route to be applied. If an incoming client session matches the specified condition (i.e. it has a matching SNI value or HTTP Host header value), it will be passed to the target backend.
     """
 
 
 @dataclass
 class GetRouteRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     route_id: str
     """
-    Id of route to get
+    Route ID.
     """
 
 
 @dataclass
 class UpdateRouteRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     route_id: str
     """
-    Route id to update
+    Route ID.
     """
 
     backend_id: str
     """
-    Backend id of redirection
+    ID of the target backend for the route.
     """
 
     match: Optional[RouteMatch]
     """
-    Value to match a redirection
+    Object defining the match condition for a route to be applied. If an incoming client session matches the specified condition (i.e. it has a matching SNI value or HTTP Host header value), it will be passed to the target backend.
     """
 
 
 @dataclass
 class DeleteRouteRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     route_id: str
     """
-    Route id to delete
+    Route ID.
     """
 
 
 @dataclass
 class GetLbStatsRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
+    """
+
+    backend_id: Optional[str]
+    """
+    ID of the backend.
     """
 
 
 @dataclass
 class ListBackendStatsRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     page: Optional[int]
     """
-    Page number
+    The page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    The number of items to return
+    Number of items to return.
+    """
+
+    backend_id: Optional[str]
+    """
+    ID of the backend.
     """
 
 
 @dataclass
 class ListAclsRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     frontend_id: str
     """
-    ID of your frontend
+    Frontend ID (ACLs attached to this frontend will be returned in the response).
     """
 
     order_by: Optional[ListAclRequestOrderBy]
     """
-    Response order
+    Sort order of ACLs in the response.
     """
 
     page: Optional[int]
     """
-    Page number
+    The page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    The number of items to return
+    The number of ACLs to return.
     """
 
     name: Optional[str]
     """
-    Filter acl per name
+    ACL name to filter for.
     """
 
 
 @dataclass
 class CreateAclRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     frontend_id: str
     """
-    ID of your frontend
+    Frontend ID to attach the ACL to.
     """
 
     name: Optional[str]
     """
-    Name of your ACL ressource
+    ACL name.
     """
 
     action: AclAction
     """
-    Action to undertake when an ACL filter matches
+    Action to take when incoming traffic matches an ACL filter.
     """
 
     match: Optional[AclMatch]
     """
-    The ACL match rule. You can have one of those three cases:
-    
-      - `ip_subnet` is defined
-      - `http_filter` and `http_filter_value` are defined
-      - `ip_subnet`, `http_filter` and `http_filter_value` are defined
-    
+    ACL match filter object. One of `ip_subnet` or `http_filter` & `http_filter_value` are required.
     """
 
     index: int
     """
-    Order between your Acls (ascending order, 0 is first acl executed)
+    Priority of this ACL (ACLs are applied in ascending order, 0 is the first ACL executed).
     """
 
     description: str
     """
-    Description of your ACL ressource
+    ACL description.
     """
 
 
 @dataclass
 class GetAclRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     acl_id: str
     """
-    ID of your ACL ressource
+    ACL ID.
     """
 
 
 @dataclass
 class UpdateAclRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     acl_id: str
     """
-    ID of your ACL ressource
+    ACL ID.
     """
 
     name: str
     """
-    Name of your ACL ressource
+    ACL name.
     """
 
     action: AclAction
     """
-    Action to undertake when an ACL filter matches
+    Action to take when incoming traffic matches an ACL filter.
     """
 
     match: Optional[AclMatch]
     """
-    The ACL match rule. At least `ip_subnet` or `http_filter` and `http_filter_value` are required
+    ACL match filter object. One of `ip_subnet` or `http_filter` & `http_filter_value` are required.
     """
 
     index: int
     """
-    Order between your Acls (ascending order, 0 is first acl executed)
+    Priority of this ACL (ACLs are applied in ascending order, 0 is the first ACL executed).
     """
 
     description: Optional[str]
     """
-    Description of your ACL ressource
+    ACL description.
     """
 
 
 @dataclass
 class DeleteAclRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     acl_id: str
     """
-    ID of your ACL ressource
+    ACL ID.
     """
 
 
 @dataclass
 class CreateCertificateRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     name: Optional[str]
     """
-    Certificate name
+    Name for the certificate.
     """
 
     letsencrypt: Optional[CreateCertificateRequestLetsencryptConfig]
     """
-    Let's Encrypt type.
+    Object to define a new Let's Encrypt certificate to be generated.
     
     One-of ('type_'): at most one of 'letsencrypt', 'custom_certificate' could be set.
     """
 
     custom_certificate: Optional[CreateCertificateRequestCustomCertificate]
     """
-    Custom import certificate.
+    Object to define an existing custom certificate to be imported.
     
     One-of ('type_'): at most one of 'letsencrypt', 'custom_certificate' could be set.
     """
 
 
 @dataclass
 class ListCertificatesRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     order_by: Optional[ListCertificatesRequestOrderBy]
     """
-    Response order
+    Sort order of certificates in the response.
     """
 
     page: Optional[int]
     """
-    Page number
+    The page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    The number of items to return
+    Number of certificates to return.
     """
 
     name: Optional[str]
     """
-    Use this to search by name
+    Certificate name to filter for, only certificates of this name will be returned.
     """
 
 
 @dataclass
 class GetCertificateRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     certificate_id: str
     """
-    Certificate ID
+    Certificate ID.
     """
 
 
 @dataclass
 class UpdateCertificateRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     certificate_id: str
     """
-    Certificate ID
+    Certificate ID.
     """
 
     name: str
     """
-    Certificate name
+    Certificate name.
     """
 
 
 @dataclass
 class DeleteCertificateRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     certificate_id: str
     """
-    Certificate ID
+    Certificate ID.
     """
 
 
 @dataclass
 class ListLbTypesRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     page: Optional[int]
     """
-    Page number
+    The page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    The number of items to return
+    The number of items to return.
     """
 
 
 @dataclass
 class CreateSubscriberRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     name: str
     """
-    Subscriber name
+    Subscriber name.
     """
 
     email_config: Optional[SubscriberEmailConfig]
     """
     Email address configuration.
     
     One-of ('config'): at most one of 'email_config', 'webhook_config' could be set.
@@ -2800,1517 +2896,1552 @@
     WebHook URI configuration.
     
     One-of ('config'): at most one of 'email_config', 'webhook_config' could be set.
     """
 
     organization_id: Optional[str]
     """
-    Owner of resources.
+    Organization ID to create the subscriber in.
     
     One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
     :deprecated
     """
 
     project_id: Optional[str]
     """
-    Assign the resource to a project ID.
+    Project ID to create the subscriber in.
     
     One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
     """
 
 
 @dataclass
 class GetSubscriberRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     subscriber_id: str
     """
-    Subscriber ID
+    Subscriber ID.
     """
 
 
 @dataclass
 class ListSubscriberRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     order_by: Optional[ListSubscriberRequestOrderBy]
     """
-    Response order
+    Sort order of subscribers in the response.
     """
 
     page: Optional[int]
     """
-    Page number
+    The page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    The number of items to return
+    The number of items to return.
     """
 
     name: str
     """
-    Use this to search by name
+    Subscriber name to search for.
     """
 
     organization_id: Optional[str]
     """
-    Filter Subscribers by organization ID
+    Filter subscribers by Organization ID.
     """
 
     project_id: Optional[str]
     """
-    Filter Subscribers by project ID
+    Filter subscribers by Project ID.
     """
 
 
 @dataclass
 class UpdateSubscriberRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     subscriber_id: str
     """
-    Assign the resource to a project IDs
+    Subscriber ID.
     """
 
     name: str
     """
-    Subscriber name
+    Subscriber name.
     """
 
     email_config: Optional[SubscriberEmailConfig]
     """
     Email address configuration.
     
     One-of ('config'): at most one of 'email_config', 'webhook_config' could be set.
     """
 
     webhook_config: Optional[SubscriberWebhookConfig]
     """
-    WebHook URI configuration.
+    Webhook URI configuration.
     
     One-of ('config'): at most one of 'email_config', 'webhook_config' could be set.
     """
 
 
 @dataclass
 class DeleteSubscriberRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     subscriber_id: str
     """
-    Subscriber ID
+    Subscriber ID.
     """
 
 
 @dataclass
 class SubscribeToLbRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     subscriber_id: str
     """
-    Subscriber ID
+    Subscriber ID.
     """
 
 
 @dataclass
 class UnsubscribeFromLbRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
 
 @dataclass
 class ListLbPrivateNetworksRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     order_by: Optional[ListPrivateNetworksRequestOrderBy]
     """
-    Response order
+    Sort order of Private Network objects in the response.
     """
 
     page_size: Optional[int]
     """
-    The number of items to return
+    Number of objects to return.
     """
 
     page: Optional[int]
     """
-    Page number
+    The page number to return, from the paginated results.
     """
 
 
 @dataclass
 class AttachPrivateNetworkRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     private_network_id: str
     """
-    Set your instance private network id
+    Private Network ID.
     """
 
     static_config: Optional[PrivateNetworkStaticConfig]
     """
-    Define two local ip address of your choice for each load balancer instance.
+    Object containing an array of a local IP address for the Load Balancer on this Private Network.
     
     One-of ('config'): at most one of 'static_config', 'dhcp_config', 'ipam_config' could be set.
+    :deprecated
     """
 
     dhcp_config: Optional[PrivateNetworkDHCPConfig]
     """
-    Set to true if you want to let DHCP assign IP addresses.
+    Defines whether to let DHCP assign IP addresses.
     
     One-of ('config'): at most one of 'static_config', 'dhcp_config', 'ipam_config' could be set.
     """
 
     ipam_config: Optional[PrivateNetworkIpamConfig]
     """
     For internal use only.
     
     One-of ('config'): at most one of 'static_config', 'dhcp_config', 'ipam_config' could be set.
+    :deprecated
     """
 
 
 @dataclass
 class DetachPrivateNetworkRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load balancer ID.
     """
 
     private_network_id: str
     """
-    Set your instance private network id
+    Set your instance private network id.
     """
 
 
 @dataclass
 class ZonedApiListLbsRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     name: Optional[str]
     """
-    Use this to search by name
+    Load Balancer name to filter for.
     """
 
     order_by: Optional[ListLbsRequestOrderBy]
     """
-    Response order
+    Sort order of Load Balancers in the response.
     """
 
     page_size: Optional[int]
     """
-    The number of items to return
+    Number of Load Balancers to return.
     """
 
     page: Optional[int]
     """
-    Page number
+    Page number to return, from the paginated results.
     """
 
     organization_id: Optional[str]
     """
-    Filter LBs by organization ID
+    Organization ID to filter for, only Load Balancers from this Organization will be returned.
     """
 
     project_id: Optional[str]
     """
-    Filter LBs by project ID
+    Project ID to filter for, only Load Balancers from this Project will be returned.
     """
 
 
 @dataclass
 class ZonedApiCreateLbRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     organization_id: Optional[str]
     """
-    Owner of resources.
+    Scaleway Organization to create the Load Balancer in.
     
     One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
     :deprecated
     """
 
     project_id: Optional[str]
     """
-    Assign the resource to a project ID.
+    Scaleway Project to create the Load Balancer in.
     
     One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
     """
 
     name: Optional[str]
     """
-    Resource names
+    Name for the Load Balancer.
     """
 
     description: str
     """
-    Resource description
+    Description for the Load Balancer.
     """
 
     ip_id: Optional[str]
     """
-    Just like for compute instances, when you destroy a load balancer, you can keep its highly available IP address and reuse it for another load balancer later
+    ID of an existing flexible IP address to attach to the Load Balancer.
+    :deprecated
+    """
+
+    assign_flexible_ip: Optional[bool]
+    """
+    Defines whether to automatically assign a flexible public IP to lb. Default value is `false` (do not assign).
     """
 
     tags: Optional[List[str]]
     """
-    List of keyword
+    List of tags for the Load Balancer.
     """
 
     type_: str
     """
-    Load balancer offer type
+    Load Balancer commercial offer type. Use the Load Balancer types endpoint to retrieve a list of available offer types.
     """
 
     ssl_compatibility_level: SSLCompatibilityLevel
     """
-    Enforces minimal SSL version (in SSL/TLS offloading context).
-    - `intermediate` General-purpose servers with a variety of clients, recommended for almost all systems (Supports Firefox 27, Android 4.4.2, Chrome 31, Edge, IE 11 on Windows 7, Java 8u31, OpenSSL 1.0.1, Opera 20, and Safari 9).
-    - `modern` Services with clients that support TLS 1.3 and don't need backward compatibility (Firefox 63, Android 10.0, Chrome 70, Edge 75, Java 11, OpenSSL 1.1.1, Opera 57, and Safari 12.1).
-    - `old` Compatible with a number of very old clients, and should be used only as a last resort (Firefox 1, Android 2.3, Chrome 1, Edge 12, IE8 on Windows XP, Java 6, OpenSSL 0.9.8, Opera 5, and Safari 1).
-    
+    Determines the minimal SSL version which needs to be supported on the client side, in an SSL/TLS offloading context. Intermediate is suitable for general-purpose servers with a variety of clients, recommended for almost all systems. Modern is suitable for services with clients that support TLS 1.3 and do not need backward compatibility. Old is compatible with a small number of very old clients and should be used only as a last resort.
     """
 
 
 @dataclass
 class ZonedApiGetLbRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
 
 @dataclass
 class ZonedApiUpdateLbRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     name: str
     """
-    Resource name
+    Load Balancer name.
     """
 
     description: str
     """
-    Resource description
+    Load Balancer description.
     """
 
     tags: Optional[List[str]]
     """
-    List of keywords
+    List of tags for the Load Balancer.
     """
 
     ssl_compatibility_level: SSLCompatibilityLevel
     """
-    Enforces minimal SSL version (in SSL/TLS offloading context).
-    - `intermediate` General-purpose servers with a variety of clients, recommended for almost all systems (Supports Firefox 27, Android 4.4.2, Chrome 31, Edge, IE 11 on Windows 7, Java 8u31, OpenSSL 1.0.1, Opera 20, and Safari 9).
-    - `modern` Services with clients that support TLS 1.3 and don't need backward compatibility (Firefox 63, Android 10.0, Chrome 70, Edge 75, Java 11, OpenSSL 1.1.1, Opera 57, and Safari 12.1).
-    - `old` Compatible with a number of very old clients, and should be used only as a last resort (Firefox 1, Android 2.3, Chrome 1, Edge 12, IE8 on Windows XP, Java 6, OpenSSL 0.9.8, Opera 5, and Safari 1).
-    
+    Determines the minimal SSL version which needs to be supported on the client side, in an SSL/TLS offloading context. Intermediate is suitable for general-purpose servers with a variety of clients, recommended for almost all systems. Modern is suitable for services with clients that support TLS 1.3 and don't need backward compatibility. Old is compatible with a small number of very old clients and should be used only as a last resort.
     """
 
 
 @dataclass
 class ZonedApiDeleteLbRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    ID of the Load Balancer to delete.
     """
 
     release_ip: bool
     """
-    Set true if you don't want to keep this IP address
+    Defines whether the Load Balancer's flexible IP should be deleted. Set to true to release the flexible IP, or false to keep it available in your account for future Load Balancers.
     """
 
 
 @dataclass
 class ZonedApiMigrateLbRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     type_: str
     """
-    Load balancer type (check /lb-types to list all type)
+    Load Balancer type to migrate to (use the List all Load Balancer offer types endpoint to get a list of available offer types).
     """
 
 
 @dataclass
 class ZonedApiListIPsRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     page: Optional[int]
     """
-    Page number
+    The page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    The number of items to return
+    Number of IP addresses to return.
     """
 
     ip_address: Optional[str]
     """
-    Use this to search by IP address
+    IP address to filter for.
     """
 
     organization_id: Optional[str]
     """
-    Filter IPs by organization id
+    Organization ID to filter for, only Load Balancer IP addresses from this Organization will be returned.
     """
 
     project_id: Optional[str]
     """
-    Filter IPs by project ID
+    Project ID to filter for, only Load Balancer IP addresses from this Project will be returned.
     """
 
 
 @dataclass
 class ZonedApiCreateIpRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     organization_id: Optional[str]
     """
-    Owner of resources.
+    Organization ID of the Organization where the IP address should be created.
     
     One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
     :deprecated
     """
 
     project_id: Optional[str]
     """
-    Assign the resource to a project ID.
+    Project ID of the Project where the IP address should be created.
     
     One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
     """
 
     reverse: Optional[str]
     """
-    Reverse domain name
+    Reverse DNS (domain name) for the IP address.
     """
 
 
 @dataclass
 class ZonedApiGetIpRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     ip_id: str
     """
-    IP address ID
+    IP address ID.
     """
 
 
 @dataclass
 class ZonedApiReleaseIpRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     ip_id: str
     """
-    IP address ID
+    IP address ID.
     """
 
 
 @dataclass
 class ZonedApiUpdateIpRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     ip_id: str
     """
-    IP address ID
+    IP address ID.
     """
 
     reverse: Optional[str]
     """
-    Reverse DNS
+    Reverse DNS (domain name) for the IP address.
     """
 
 
 @dataclass
 class ZonedApiListBackendsRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     name: Optional[str]
     """
-    Use this to search by name
+    Name of the backend to filter for.
     """
 
     order_by: Optional[ListBackendsRequestOrderBy]
     """
-    Response order
+    Sort order of backends in the response.
     """
 
     page: Optional[int]
     """
-    Page number
+    The page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    The number of items to return
+    Number of backends to return.
     """
 
 
 @dataclass
 class ZonedApiCreateBackendRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     name: Optional[str]
     """
-    Resource name
+    Name for the backend.
     """
 
     forward_protocol: Optional[Protocol]
     """
-    Backend protocol. TCP or HTTP
+    Protocol to be used by the backend when forwarding traffic to backend servers.
     """
 
     forward_port: int
     """
-    User sessions will be forwarded to this port of backend servers
+    Port to be used by the backend when forwarding traffic to backend servers.
     """
 
     forward_port_algorithm: Optional[ForwardPortAlgorithm]
     """
-    Load balancing algorithm
+    Load balancing algorithm to be used when determining which backend server to forward new traffic to.
     """
 
     sticky_sessions: Optional[StickySessionsType]
     """
-    Enables cookie-based session persistence
+    Defines whether to activate sticky sessions (binding a particular session to a particular backend server) and the method to use if so. None disables sticky sessions. Cookie-based uses an HTTP cookie TO stick a session to a backend server. Table-based uses the source (client) IP address to stick a session to a backend server.
     """
 
     sticky_sessions_cookie_name: str
     """
-    Cookie name for sticky sessions
+    Cookie name for cookie-based sticky sessions.
     """
 
     health_check: HealthCheck
     """
-    See the Healthcheck object description
+    Object defining the health check to be carried out by the backend when checking the status and health of backend servers.
     """
 
     server_ip: List[str]
     """
-    Backend server IP addresses list (IPv4 or IPv6)
+    List of backend server IP addresses (IPv4 or IPv6) the backend should forward traffic to.
     """
 
     send_proxy_v2: Optional[bool]
     """
-    Deprecated in favor of proxy_protocol field !
+    Deprecated in favor of proxy_protocol field.
     :deprecated
     """
 
     timeout_server: Optional[str]
     """
-    Maximum server connection inactivity time (allowed time the server has to process the request)
+    Maximum allowed time for a backend server to process a request.
     """
 
     timeout_connect: Optional[str]
     """
-    Maximum initial server connection establishment time
+    Maximum allowed time for establishing a connection to a backend server.
     """
 
     timeout_tunnel: Optional[str]
     """
-    Maximum tunnel inactivity time after Websocket is established (take precedence over client and server timeout)
+    Maximum allowed tunnel inactivity time after Websocket is established (takes precedence over client and server timeout).
     """
 
     on_marked_down_action: OnMarkedDownAction
     """
-    Modify what occurs when a backend server is marked down
+    Action to take when a backend server is marked as down.
     """
 
     proxy_protocol: ProxyProtocol
     """
-    The PROXY protocol informs the other end about the incoming connection, so that it can know the client's address or the public address it accessed to, whatever the upper layer protocol.
-    
-    * `proxy_protocol_none` Disable proxy protocol.
-    * `proxy_protocol_v1` Version one (text format).
-    * `proxy_protocol_v2` Version two (binary format).
-    * `proxy_protocol_v2_ssl` Version two with SSL connection.
-    * `proxy_protocol_v2_ssl_cn` Version two with SSL connection and common name information.
-    
+    Protocol to use between the Load Balancer and backend servers. Allows the backend servers to be informed of the client's real IP address. The PROXY protocol must be supported by the backend servers' software.
     """
 
     failover_host: Optional[str]
     """
-    Only the host part of the Scaleway S3 bucket website is expected.
-    E.g. `failover-website.s3-website.fr-par.scw.cloud` if your bucket website URL is `https://failover-website.s3-website.fr-par.scw.cloud/`.
-    
+    Scaleway S3 bucket website to be served as failover if all backend servers are down, e.g. failover-website.s3-website.fr-par.scw.cloud.
     """
 
     ssl_bridging: Optional[bool]
     """
-    Enable SSL between load balancer and backend servers
+    Defines whether to enable SSL bridging between the Load Balancer and backend servers.
     """
 
     ignore_ssl_server_verify: Optional[bool]
     """
-    Set to true to ignore server certificate verification
+    Defines whether the server certificate verification should be ignored.
+    """
+
+    redispatch_attempt_count: Optional[int]
+    """
+    Whether to use another backend server on each attempt.
+    """
+
+    max_retries: Optional[int]
+    """
+    Number of retries when a backend server connection failed.
+    """
+
+    max_connections: Optional[int]
+    """
+    Maximum number of connections allowed per backend server.
+    """
+
+    timeout_queue: Optional[str]
+    """
+    Maximum time for a request to be left pending in queue when `max_connections` is reached.
     """
 
 
 @dataclass
 class ZonedApiGetBackendRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     backend_id: str
     """
-    Backend ID
+    Backend ID.
     """
 
 
 @dataclass
 class ZonedApiUpdateBackendRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     backend_id: str
     """
-    Backend ID to update
+    Backend ID.
     """
 
     name: str
     """
-    Resource name
+    Backend name.
     """
 
     forward_protocol: Optional[Protocol]
     """
-    Backend protocol. TCP or HTTP
+    Protocol to be used by the backend when forwarding traffic to backend servers.
     """
 
     forward_port: int
     """
-    User sessions will be forwarded to this port of backend servers
+    Port to be used by the backend when forwarding traffic to backend servers.
     """
 
     forward_port_algorithm: Optional[ForwardPortAlgorithm]
     """
-    Load balancing algorithm
+    Load balancing algorithm to be used when determining which backend server to forward new traffic to.
     """
 
     sticky_sessions: Optional[StickySessionsType]
     """
-    Enable cookie-based session persistence
+    Defines whether to activate sticky sessions (binding a particular session to a particular backend server) and the method to use if so. None disables sticky sessions. Cookie-based uses an HTTP cookie to stick a session to a backend server. Table-based uses the source (client) IP address to stick a session to a backend server.
     """
 
     sticky_sessions_cookie_name: str
     """
-    Cookie name for sticky sessions
+    Cookie name for cookie-based sticky sessions.
     """
 
     send_proxy_v2: Optional[bool]
     """
-    Deprecated in favor of proxy_protocol field!
+    Deprecated in favor of proxy_protocol field.
     :deprecated
     """
 
     timeout_server: Optional[str]
     """
-    Maximum server connection inactivity time (allowed time the server has to process the request)
+    Maximum allowed time for a backend server to process a request.
     """
 
     timeout_connect: Optional[str]
     """
-    Maximum initial server connection establishment time
+    Maximum allowed time for establishing a connection to a backend server.
     """
 
     timeout_tunnel: Optional[str]
     """
-    Maximum tunnel inactivity time after Websocket is established (take precedence over client and server timeout)
+    Maximum allowed tunnel inactivity time after Websocket is established (takes precedence over client and server timeout).
     """
 
     on_marked_down_action: OnMarkedDownAction
     """
-    Modify what occurs when a backend server is marked down
+    Action to take when a backend server is marked as down.
     """
 
     proxy_protocol: ProxyProtocol
     """
-    The PROXY protocol informs the other end about the incoming connection, so that it can know the client's address or the public address it accessed to, whatever the upper layer protocol is.
-    
-    * `proxy_protocol_none` Disable proxy protocol.
-    * `proxy_protocol_v1` Version one (text format).
-    * `proxy_protocol_v2` Version two (binary format).
-    * `proxy_protocol_v2_ssl` Version two with SSL connection.
-    * `proxy_protocol_v2_ssl_cn` Version two with SSL connection and common name information.
-    
+    Protocol to use between the Load Balancer and backend servers. Allows the backend servers to be informed of the client's real IP address. The PROXY protocol must be supported by the backend servers' software.
     """
 
     failover_host: Optional[str]
     """
-    Only the host part of the Scaleway S3 bucket website is expected.
-    Example: `failover-website.s3-website.fr-par.scw.cloud` if your bucket website URL is `https://failover-website.s3-website.fr-par.scw.cloud/`.
-    
+    Scaleway S3 bucket website to be served as failover if all backend servers are down, e.g. failover-website.s3-website.fr-par.scw.cloud.
     """
 
     ssl_bridging: Optional[bool]
     """
-    Enable SSL between load balancer and backend servers
+    Defines whether to enable SSL bridging between the Load Balancer and backend servers.
     """
 
     ignore_ssl_server_verify: Optional[bool]
     """
-    Set to true to ignore server certificate verification
+    Defines whether the server certificate verification should be ignored.
+    """
+
+    redispatch_attempt_count: Optional[int]
+    """
+    Whether to use another backend server on each attempt.
+    """
+
+    max_retries: Optional[int]
+    """
+    Number of retries when a backend server connection failed.
+    """
+
+    max_connections: Optional[int]
+    """
+    Maximum number of connections allowed per backend server.
+    """
+
+    timeout_queue: Optional[str]
+    """
+    Maximum time for a request to be left pending in queue when `max_connections` is reached.
     """
 
 
 @dataclass
 class ZonedApiDeleteBackendRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     backend_id: str
     """
-    ID of the backend to delete
+    ID of the backend to delete.
     """
 
 
 @dataclass
 class ZonedApiAddBackendServersRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     backend_id: str
     """
-    Backend ID
+    Backend ID.
     """
 
     server_ip: List[str]
     """
-    Set all IPs to add on your backend
+    List of IP addresses to add to backend servers.
     """
 
 
 @dataclass
 class ZonedApiRemoveBackendServersRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     backend_id: str
     """
-    Backend ID
+    Backend ID.
     """
 
     server_ip: List[str]
     """
-    Set all IPs to remove of your backend
+    List of IP addresses to remove from backend servers.
     """
 
 
 @dataclass
 class ZonedApiSetBackendServersRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     backend_id: str
     """
-    Backend ID
+    Backend ID.
     """
 
     server_ip: List[str]
     """
-    Set all IPs to add on your backend and remove all other
+    List of IP addresses for backend servers. Any other existing backend servers will be removed.
     """
 
 
 @dataclass
 class ZonedApiUpdateHealthCheckRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     backend_id: str
     """
-    Backend ID
+    Backend ID.
     """
 
     port: int
     """
-    Specify the port used to health check
+    Port to use for the backend server health check.
     """
 
     check_delay: str
     """
-    Time between two consecutive health checks
+    Time to wait between two consecutive health checks.
     """
 
     check_timeout: str
     """
-    Maximum time a backend server has to reply to the health check
+    Maximum time a backend server has to reply to the health check.
     """
 
     check_max_retries: int
     """
-    Number of consecutive unsuccessful health checks, after which the server will be considered dead
+    Number of consecutive unsuccessful health checks after which the server will be considered dead.
     """
 
-    mysql_config: Optional[HealthCheckMysqlConfig]
+    check_send_proxy: bool
     """
-    The check requires MySQL >=3.22, for older version, please use TCP check.
-    
-    One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
+    Defines whether proxy protocol should be activated for the health check.
     """
 
-    ldap_config: Optional[HealthCheckLdapConfig]
+    tcp_config: Optional[HealthCheckTcpConfig]
     """
-    The response is analyzed to find an LDAPv3 response message.
+    Object to configure a basic TCP health check.
     
-    One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
+    One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
     """
 
-    redis_config: Optional[HealthCheckRedisConfig]
+    mysql_config: Optional[HealthCheckMysqlConfig]
     """
-    The response is analyzed to find the +PONG response message.
+    Object to configure a MySQL health check. The check requires MySQL >=3.22, for older versions, use a TCP health check.
     
-    One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
+    One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
     """
 
     pgsql_config: Optional[HealthCheckPgsqlConfig]
     """
-    PostgreSQL health check.
+    Object to configure a PostgreSQL health check.
     
-    One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
+    One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
     """
 
-    tcp_config: Optional[HealthCheckTcpConfig]
+    ldap_config: Optional[HealthCheckLdapConfig]
     """
-    Basic TCP health check.
+    Object to configure an LDAP health check. The response is analyzed to find the LDAPv3 response message.
     
-    One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
+    One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
+    """
+
+    redis_config: Optional[HealthCheckRedisConfig]
+    """
+    Object to configure a Redis health check. The response is analyzed to find the +PONG response message.
+    
+    One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
     """
 
     http_config: Optional[HealthCheckHttpConfig]
     """
-    HTTP health check.
+    Object to configure an HTTP health check.
     
-    One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
+    One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
     """
 
     https_config: Optional[HealthCheckHttpsConfig]
     """
-    HTTPS health check.
+    Object to configure an HTTPS health check.
     
-    One-of ('config'): at most one of 'mysql_config', 'ldap_config', 'redis_config', 'pgsql_config', 'tcp_config', 'http_config', 'https_config' could be set.
+    One-of ('config'): at most one of 'tcp_config', 'mysql_config', 'pgsql_config', 'ldap_config', 'redis_config', 'http_config', 'https_config' could be set.
     """
 
-    check_send_proxy: bool
+    transient_check_delay: Optional[str]
     """
-    It defines whether the health check should be done considering the proxy protocol
+    Time to wait between two consecutive health checks when a backend server is in a transient state (going UP or DOWN).
     """
 
 
 @dataclass
 class ZonedApiListFrontendsRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     name: Optional[str]
     """
-    Use this to search by name
+    Name of the frontend to filter for.
     """
 
     order_by: Optional[ListFrontendsRequestOrderBy]
     """
-    Response order
+    Sort order of frontends in the response.
     """
 
     page: Optional[int]
     """
-    Page number
+    The page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    The number of items to return
+    Number of frontends to return.
     """
 
 
 @dataclass
 class ZonedApiCreateFrontendRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID (ID of the Load Balancer to attach the frontend to).
     """
 
     name: Optional[str]
     """
-    Resource name
+    Name for the frontend.
     """
 
     inbound_port: int
     """
-    TCP port to listen on the front side
+    Port the frontend should listen on.
     """
 
     backend_id: str
     """
-    Backend ID
+    Backend ID (ID of the backend the frontend should pass traffic to).
     """
 
     timeout_client: Optional[str]
     """
-    Set the maximum inactivity time on the client side
+    Maximum allowed inactivity time on the client side.
     """
 
     certificate_id: Optional[str]
     """
-    Certificate ID, deprecated in favor of certificate_ids array !
+    Certificate ID, deprecated in favor of certificate_ids array.
     :deprecated
     """
 
     certificate_ids: Optional[List[str]]
     """
-    List of certificate IDs to bind on the frontend
+    List of SSL/TLS certificate IDs to bind to the frontend.
     """
 
     enable_http3: bool
     """
-    Activate HTTP 3 protocol (beta)
+    Defines whether to enable HTTP/3 protocol on the frontend.
     """
 
 
 @dataclass
 class ZonedApiGetFrontendRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     frontend_id: str
     """
-    Frontend ID
+    Frontend ID.
     """
 
 
 @dataclass
 class ZonedApiUpdateFrontendRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     frontend_id: str
     """
-    Frontend ID
+    Frontend ID.
     """
 
     name: str
     """
-    Resource name
+    Frontend name.
     """
 
     inbound_port: int
     """
-    TCP port to listen on the front side
+    Port the frontend should listen on.
     """
 
     backend_id: str
     """
-    Backend ID
+    Backend ID (ID of the backend the frontend should pass traffic to).
     """
 
     timeout_client: Optional[str]
     """
-    Client session maximum inactivity time
+    Maximum allowed inactivity time on the client side.
     """
 
     certificate_id: Optional[str]
     """
-    Certificate ID, deprecated in favor of `certificate_ids` array!
+    Certificate ID, deprecated in favor of certificate_ids array.
     :deprecated
     """
 
     certificate_ids: Optional[List[str]]
     """
-    List of certificate IDs to bind on the frontend
+    List of SSL/TLS certificate IDs to bind to the frontend.
     """
 
     enable_http3: bool
     """
-    Activate HTTP 3 protocol (beta)
+    Defines whether to enable HTTP/3 protocol on the frontend.
     """
 
 
 @dataclass
 class ZonedApiDeleteFrontendRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     frontend_id: str
     """
-    Frontend ID to delete
+    ID of the frontend to delete.
     """
 
 
 @dataclass
 class ZonedApiListRoutesRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     order_by: Optional[ListRoutesRequestOrderBy]
     """
-    Response order
+    Sort order of routes in the response.
     """
 
     page_size: Optional[int]
     """
-    The number of items to return
+    The number of route objects to return.
     """
 
     page: Optional[int]
     """
-    Page number
+    The page number to return, from the paginated results.
     """
 
     frontend_id: Optional[str]
+    """
+    Frontend ID to filter for, only Routes from this Frontend will be returned.
+    """
 
 
 @dataclass
 class ZonedApiCreateRouteRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     frontend_id: str
     """
-    Origin of redirection
+    ID of the source frontend to create the route on.
     """
 
     backend_id: str
     """
-    Destination of destination
+    ID of the target backend for the route.
     """
 
     match: Optional[RouteMatch]
     """
-    Value to match a redirection
+    Object defining the match condition for a route to be applied. If an incoming client session matches the specified condition (i.e. it has a matching SNI value or HTTP Host header value), it will be passed to the target backend.
     """
 
 
 @dataclass
 class ZonedApiGetRouteRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     route_id: str
     """
-    Id of route to get
+    Route ID.
     """
 
 
 @dataclass
 class ZonedApiUpdateRouteRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     route_id: str
     """
-    Route id to update
+    Route ID.
     """
 
     backend_id: str
     """
-    Backend id of redirection
+    ID of the target backend for the route.
     """
 
     match: Optional[RouteMatch]
     """
-    Value to match a redirection
+    Object defining the match condition for a route to be applied. If an incoming client session matches the specified condition (i.e. it has a matching SNI value or HTTP Host header value), it will be passed to the target backend.
     """
 
 
 @dataclass
 class ZonedApiDeleteRouteRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     route_id: str
     """
-    Route id to delete
+    Route ID.
     """
 
 
 @dataclass
 class ZonedApiGetLbStatsRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
+    """
+
+    backend_id: Optional[str]
+    """
+    ID of the backend.
     """
 
 
 @dataclass
 class ZonedApiListBackendStatsRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     page: Optional[int]
     """
-    Page number
+    The page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    The number of items to return
+    Number of items to return.
+    """
+
+    backend_id: Optional[str]
+    """
+    ID of the backend.
     """
 
 
 @dataclass
 class ZonedApiListAclsRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     frontend_id: str
     """
-    ID of your frontend
+    Frontend ID (ACLs attached to this frontend will be returned in the response).
     """
 
     order_by: Optional[ListAclRequestOrderBy]
     """
-    Response order
+    Sort order of ACLs in the response.
     """
 
     page: Optional[int]
     """
-    Page number
+    The page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    The number of items to return
+    The number of ACLs to return.
     """
 
     name: Optional[str]
     """
-    Filter acl per name
+    ACL name to filter for.
     """
 
 
 @dataclass
 class ZonedApiCreateAclRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     frontend_id: str
     """
-    ID of your frontend
+    Frontend ID to attach the ACL to.
     """
 
     name: Optional[str]
     """
-    Name of your ACL ressource
+    ACL name.
     """
 
     action: AclAction
     """
-    Action to undertake when an ACL filter matches
+    Action to take when incoming traffic matches an ACL filter.
     """
 
     match: Optional[AclMatch]
     """
-    The ACL match rule. You can have one of those three cases:
-    
-      - `ip_subnet` is defined
-      - `http_filter` and `http_filter_value` are defined
-      - `ip_subnet`, `http_filter` and `http_filter_value` are defined
-    
+    ACL match filter object. One of `ip_subnet` or `http_filter` & `http_filter_value` are required.
     """
 
     index: int
     """
-    Order between your Acls (ascending order, 0 is first acl executed)
+    Priority of this ACL (ACLs are applied in ascending order, 0 is the first ACL executed).
     """
 
     description: str
     """
-    Description of your ACL ressource
+    ACL description.
     """
 
 
 @dataclass
 class ZonedApiGetAclRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     acl_id: str
     """
-    ID of your ACL ressource
+    ACL ID.
     """
 
 
 @dataclass
 class ZonedApiUpdateAclRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     acl_id: str
     """
-    ID of your ACL ressource
+    ACL ID.
     """
 
     name: str
     """
-    Name of your ACL ressource
+    ACL name.
     """
 
     action: AclAction
     """
-    Action to undertake when an ACL filter matches
+    Action to take when incoming traffic matches an ACL filter.
     """
 
     match: Optional[AclMatch]
     """
-    The ACL match rule. At least `ip_subnet` or `http_filter` and `http_filter_value` are required
+    ACL match filter object. One of `ip_subnet` or `http_filter` & `http_filter_value` are required.
     """
 
     index: int
     """
-    Order between your Acls (ascending order, 0 is first acl executed)
+    Priority of this ACL (ACLs are applied in ascending order, 0 is the first ACL executed).
     """
 
     description: Optional[str]
     """
-    Description of your ACL ressource
+    ACL description.
     """
 
 
 @dataclass
 class ZonedApiDeleteAclRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     acl_id: str
     """
-    ID of your ACL ressource
+    ACL ID.
     """
 
 
 @dataclass
 class ZonedApiSetAclsRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     frontend_id: str
     """
-    The Frontend to change ACL to
+    Frontend ID.
     """
 
     acls: List[AclSpec]
     """
-    Array of ACLs to erease the existing ACLs
+    List of ACLs for this frontend. Any other existing ACLs on this frontend will be removed.
     """
 
 
 @dataclass
 class ZonedApiCreateCertificateRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     name: Optional[str]
     """
-    Certificate name
+    Name for the certificate.
     """
 
     letsencrypt: Optional[CreateCertificateRequestLetsencryptConfig]
     """
-    Let's Encrypt type.
+    Object to define a new Let's Encrypt certificate to be generated.
     
     One-of ('type_'): at most one of 'letsencrypt', 'custom_certificate' could be set.
     """
 
     custom_certificate: Optional[CreateCertificateRequestCustomCertificate]
     """
-    Custom import certificate.
+    Object to define an existing custom certificate to be imported.
     
     One-of ('type_'): at most one of 'letsencrypt', 'custom_certificate' could be set.
     """
 
 
 @dataclass
 class ZonedApiListCertificatesRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     order_by: Optional[ListCertificatesRequestOrderBy]
     """
-    Response order
+    Sort order of certificates in the response.
     """
 
     page: Optional[int]
     """
-    Page number
+    The page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    The number of items to return
+    Number of certificates to return.
     """
 
     name: Optional[str]
     """
-    Use this to search by name
+    Certificate name to filter for, only certificates of this name will be returned.
     """
 
 
 @dataclass
 class ZonedApiGetCertificateRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     certificate_id: str
     """
-    Certificate ID
+    Certificate ID.
     """
 
 
 @dataclass
 class ZonedApiUpdateCertificateRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     certificate_id: str
     """
-    Certificate ID
+    Certificate ID.
     """
 
     name: str
     """
-    Certificate name
+    Certificate name.
     """
 
 
 @dataclass
 class ZonedApiDeleteCertificateRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     certificate_id: str
     """
-    Certificate ID
+    Certificate ID.
     """
 
 
 @dataclass
 class ZonedApiListLbTypesRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     page: Optional[int]
     """
-    Page number
+    The page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    The number of items to return
+    The number of items to return.
     """
 
 
 @dataclass
 class ZonedApiCreateSubscriberRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     name: str
     """
-    Subscriber name
+    Subscriber name.
     """
 
     email_config: Optional[SubscriberEmailConfig]
     """
     Email address configuration.
     
     One-of ('config'): at most one of 'email_config', 'webhook_config' could be set.
@@ -4321,231 +4452,233 @@
     WebHook URI configuration.
     
     One-of ('config'): at most one of 'email_config', 'webhook_config' could be set.
     """
 
     organization_id: Optional[str]
     """
-    Owner of resources.
+    Organization ID to create the subscriber in.
     
     One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
     :deprecated
     """
 
     project_id: Optional[str]
     """
-    Assign the resource to a project ID.
+    Project ID to create the subscriber in.
     
     One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
     """
 
 
 @dataclass
 class ZonedApiGetSubscriberRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     subscriber_id: str
     """
-    Subscriber ID
+    Subscriber ID.
     """
 
 
 @dataclass
 class ZonedApiListSubscriberRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     order_by: Optional[ListSubscriberRequestOrderBy]
     """
-    Response order
+    Sort order of subscribers in the response.
     """
 
     page: Optional[int]
     """
-    Page number
+    The page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    The number of items to return
+    The number of items to return.
     """
 
     name: str
     """
-    Use this to search by name
+    Subscriber name to search for.
     """
 
     organization_id: Optional[str]
     """
-    Filter Subscribers by organization ID
+    Filter subscribers by Organization ID.
     """
 
     project_id: Optional[str]
     """
-    Filter Subscribers by project ID
+    Filter subscribers by Project ID.
     """
 
 
 @dataclass
 class ZonedApiUpdateSubscriberRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     subscriber_id: str
     """
-    Assign the resource to a project IDs
+    Subscriber ID.
     """
 
     name: str
     """
-    Subscriber name
+    Subscriber name.
     """
 
     email_config: Optional[SubscriberEmailConfig]
     """
     Email address configuration.
     
     One-of ('config'): at most one of 'email_config', 'webhook_config' could be set.
     """
 
     webhook_config: Optional[SubscriberWebhookConfig]
     """
-    WebHook URI configuration.
+    Webhook URI configuration.
     
     One-of ('config'): at most one of 'email_config', 'webhook_config' could be set.
     """
 
 
 @dataclass
 class ZonedApiDeleteSubscriberRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     subscriber_id: str
     """
-    Subscriber ID
+    Subscriber ID.
     """
 
 
 @dataclass
 class ZonedApiSubscribeToLbRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     subscriber_id: str
     """
-    Subscriber ID
+    Subscriber ID.
     """
 
 
 @dataclass
 class ZonedApiUnsubscribeFromLbRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
 
 @dataclass
 class ZonedApiListLbPrivateNetworksRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     order_by: Optional[ListPrivateNetworksRequestOrderBy]
     """
-    Response order
+    Sort order of Private Network objects in the response.
     """
 
     page_size: Optional[int]
     """
-    The number of items to return
+    Number of objects to return.
     """
 
     page: Optional[int]
     """
-    Page number
+    The page number to return, from the paginated results.
     """
 
 
 @dataclass
 class ZonedApiAttachPrivateNetworkRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load Balancer ID.
     """
 
     private_network_id: str
     """
-    Set your instance private network id
+    Private Network ID.
     """
 
     static_config: Optional[PrivateNetworkStaticConfig]
     """
-    Define two local ip address of your choice for each load balancer instance.
+    Object containing an array of a local IP address for the Load Balancer on this Private Network.
     
     One-of ('config'): at most one of 'static_config', 'dhcp_config', 'ipam_config' could be set.
+    :deprecated
     """
 
     dhcp_config: Optional[PrivateNetworkDHCPConfig]
     """
-    Set to true if you want to let DHCP assign IP addresses.
+    Defines whether to let DHCP assign IP addresses.
     
     One-of ('config'): at most one of 'static_config', 'dhcp_config', 'ipam_config' could be set.
     """
 
     ipam_config: Optional[PrivateNetworkIpamConfig]
     """
     For internal use only.
     
     One-of ('config'): at most one of 'static_config', 'dhcp_config', 'ipam_config' could be set.
+    :deprecated
     """
 
 
 @dataclass
 class ZonedApiDetachPrivateNetworkRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     lb_id: str
     """
-    Load balancer ID
+    Load balancer ID.
     """
 
     private_network_id: str
     """
-    Set your instance private network id
+    Set your instance private network id.
     """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/marketplace/v1/__init__.py` & `scaleway_async-1.0.0/scaleway_async/marketplace/v1/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-0.9.0/scaleway_async/marketplace/v1/api.py` & `scaleway_async-1.0.0/scaleway_async/marketplace/v1/api.py`

 * *Files 3% similar despite different names*

```diff
@@ -22,26 +22,28 @@
     unmarshal_ListVersionsResponse,
 )
 
 
 class MarketplaceV1API(API):
     """
     Marketplace API.
+
+    Marketplace API.
     """
 
     async def list_images(
         self,
         *,
         per_page: Optional[int] = None,
         page: Optional[int] = None,
     ) -> ListImagesResponse:
         """
-        List marketplace images
-        :param per_page: A positive integer lower or equal to 100 to select the number of items to display
-        :param page: A positive integer to choose the page to display
+        List marketplace images.
+        :param per_page: A positive integer lower or equal to 100 to select the number of items to display.
+        :param page: A positive integer to choose the page to display.
         :return: :class:`ListImagesResponse <ListImagesResponse>`
 
         Usage:
         ::
 
             result = await api.list_images()
         """
@@ -61,17 +63,17 @@
     async def list_images_all(
         self,
         *,
         per_page: Optional[int] = None,
         page: Optional[int] = None,
     ) -> List[Image]:
         """
-        List marketplace images
-        :param per_page: A positive integer lower or equal to 100 to select the number of items to display
-        :param page: A positive integer to choose the page to display
+        List marketplace images.
+        :param per_page: A positive integer lower or equal to 100 to select the number of items to display.
+        :param page: A positive integer to choose the page to display.
         :return: :class:`List[ListImagesResponse] <List[ListImagesResponse]>`
 
         Usage:
         ::
 
             result = await api.list_images_all()
         """
@@ -88,16 +90,16 @@
 
     async def get_image(
         self,
         *,
         image_id: str,
     ) -> GetImageResponse:
         """
-        Get a specific marketplace image
-        :param image_id: Display the image name
+        Get a specific marketplace image.
+        :param image_id: Display the image name.
         :return: :class:`GetImageResponse <GetImageResponse>`
 
         Usage:
         ::
 
             result = await api.get_image(image_id="example")
         """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/marketplace/v1/marshalling.py` & `scaleway_async-1.0.0/scaleway_async/marketplace/v2/marshalling.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,191 +1,203 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 
 from typing import Any, Dict
 
 from dateutil import parser
 from .types import (
-    GetImageResponse,
-    GetVersionResponse,
+    Category,
     Image,
+    ListCategoriesResponse,
     ListImagesResponse,
+    ListLocalImagesResponse,
     ListVersionsResponse,
     LocalImage,
-    Organization,
     Version,
 )
 
 
-def unmarshal_LocalImage(data: Any) -> LocalImage:
+def unmarshal_Category(data: Any) -> Category:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'LocalImage' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Category' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("arch")
-    args["arch"] = field
-
-    field = data.get("compatible_commercial_types")
-    args["compatible_commercial_types"] = field
+    field = data.get("description", None)
+    args["description"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("zone")
-    args["zone"] = field
+    field = data.get("name", None)
+    args["name"] = field
 
-    return LocalImage(**args)
+    return Category(**args)
 
 
-def unmarshal_Organization(data: Any) -> Organization:
+def unmarshal_Image(data: Any) -> Image:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Organization' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Image' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("id")
+    field = data.get("categories", None)
+    args["categories"] = field
+
+    field = data.get("created_at", None)
+    args["created_at"] = parser.isoparse(field) if type(field) is str else field
+
+    field = data.get("description", None)
+    args["description"] = field
+
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("name")
+    field = data.get("label", None)
+    args["label"] = field
+
+    field = data.get("logo", None)
+    args["logo"] = field
+
+    field = data.get("name", None)
     args["name"] = field
 
-    return Organization(**args)
+    field = data.get("updated_at", None)
+    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
+    field = data.get("valid_until", None)
+    args["valid_until"] = parser.isoparse(field) if type(field) is str else field
 
-def unmarshal_Version(data: Any) -> Version:
+    return Image(**args)
+
+
+def unmarshal_LocalImage(data: Any) -> LocalImage:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Version' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'LocalImage' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("creation_date")
-    args["creation_date"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("arch", None)
+    args["arch"] = field
+
+    field = data.get("compatible_commercial_types", None)
+    args["compatible_commercial_types"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("local_images")
-    args["local_images"] = [unmarshal_LocalImage(v) for v in data["local_images"]]
+    field = data.get("label", None)
+    args["label"] = field
 
-    field = data.get("modification_date")
-    args["modification_date"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("type", None)
+    args["type_"] = field
 
-    field = data.get("name")
-    args["name"] = field
+    field = data.get("zone", None)
+    args["zone"] = field
 
-    return Version(**args)
+    return LocalImage(**args)
 
 
-def unmarshal_Image(data: Any) -> Image:
+def unmarshal_Version(data: Any) -> Version:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Image' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Version' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("categories")
-    args["categories"] = field
-
-    field = data.get("creation_date")
-    args["creation_date"] = parser.isoparse(field) if type(field) is str else field
-
-    field = data.get("current_public_version")
-    args["current_public_version"] = field
-
-    field = data.get("description")
-    args["description"] = field
+    field = data.get("created_at", None)
+    args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("label")
-    args["label"] = field
-
-    field = data.get("logo")
-    args["logo"] = field
-
-    field = data.get("modification_date")
-    args["modification_date"] = parser.isoparse(field) if type(field) is str else field
-
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("organization")
-    args["organization"] = unmarshal_Organization(field) if field is not None else None
-
-    field = data.get("valid_until")
-    args["valid_until"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("published_at", None)
+    args["published_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("versions")
-    args["versions"] = [unmarshal_Version(v) for v in data["versions"]]
+    field = data.get("updated_at", None)
+    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    return Image(**args)
+    return Version(**args)
 
 
-def unmarshal_GetImageResponse(data: Any) -> GetImageResponse:
+def unmarshal_ListCategoriesResponse(data: Any) -> ListCategoriesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'GetImageResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListCategoriesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("image")
-    args["image"] = unmarshal_Image(field) if field is not None else None
+    field = data.get("categories", None)
+    args["categories"] = (
+        [unmarshal_Category(v) for v in field] if field is not None else None
+    )
+
+    field = data.get("total_count", None)
+    args["total_count"] = field
 
-    return GetImageResponse(**args)
+    return ListCategoriesResponse(**args)
 
 
-def unmarshal_GetVersionResponse(data: Any) -> GetVersionResponse:
+def unmarshal_ListImagesResponse(data: Any) -> ListImagesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'GetVersionResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListImagesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("version")
-    args["version"] = unmarshal_Version(field) if field is not None else None
+    field = data.get("images", None)
+    args["images"] = [unmarshal_Image(v) for v in field] if field is not None else None
+
+    field = data.get("total_count", None)
+    args["total_count"] = field
 
-    return GetVersionResponse(**args)
+    return ListImagesResponse(**args)
 
 
-def unmarshal_ListImagesResponse(data: Any) -> ListImagesResponse:
+def unmarshal_ListLocalImagesResponse(data: Any) -> ListLocalImagesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListImagesResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListLocalImagesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("images")
-    args["images"] = [unmarshal_Image(v) for v in data["images"]]
+    field = data.get("local_images", None)
+    args["local_images"] = (
+        [unmarshal_LocalImage(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListImagesResponse(**args)
+    return ListLocalImagesResponse(**args)
 
 
 def unmarshal_ListVersionsResponse(data: Any) -> ListVersionsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListVersionsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    field = data.get("versions")
-    args["versions"] = [unmarshal_Version(v) for v in data["versions"]]
+    field = data.get("versions", None)
+    args["versions"] = (
+        [unmarshal_Version(v) for v in field] if field is not None else None
+    )
 
     return ListVersionsResponse(**args)
```

### Comparing `scaleway_async-0.9.0/scaleway_async/marketplace/v1/types.py` & `scaleway_async-1.0.0/scaleway_async/marketplace/v1/types.py`

 * *Files 20% similar despite different names*

```diff
@@ -20,70 +20,71 @@
 class GetVersionResponse:
     version: Optional[Version]
 
 
 @dataclass
 class Image:
     """
-    Image
+    Image.
     """
 
     id: str
     """
-    UUID of this image
+    UUID of this image.
     """
 
     name: str
     """
-    Name of the image
+    Name of the image.
     """
 
     description: str
     """
-    Text description of this image
+    Text description of this image.
     """
 
     logo: str
     """
-    URL of this image's logo
+    URL of this image's logo.
     """
 
     categories: List[str]
     """
-    List of categories this image belongs to
+    List of categories this image belongs to.
     """
 
     creation_date: Optional[datetime]
     """
-    Creation date of this image
+    Creation date of this image.
     """
 
     modification_date: Optional[datetime]
     """
-    Date of the last modification of this image
+    Date of the last modification of this image.
     """
 
     valid_until: Optional[datetime]
     """
-    Expiration date of this image
+    Expiration date of this image.
     """
 
     label: str
     """
+    Label of this image.
     Typically an identifier for a distribution (ex. "ubuntu_focal").
     """
 
     versions: List[Version]
     """
-    List of versions of this image
+    List of versions of this image.
     """
 
     organization: Optional[Organization]
     """
-    Organization this image belongs to
+    Organization this image belongs to.
     """
 
     current_public_version: str
 
 
 @dataclass
 class ListImagesResponse:
@@ -98,95 +99,96 @@
 
     total_count: int
 
 
 @dataclass
 class LocalImage:
     """
-    Local image
+    Local image.
     """
 
     id: str
     """
+    UUID of this local image.
     Version you will typically use to define an image in an API call.
     """
 
     compatible_commercial_types: List[str]
     """
-    List of all commercial types that are compatible with this local image
+    List of all commercial types that are compatible with this local image.
     """
 
     arch: str
     """
-    Supported architecture for this local image
+    Supported architecture for this local image.
     """
 
     zone: Zone
     """
-    Availability Zone where this local image is available
+    Availability Zone where this local image is available.
     """
 
 
 @dataclass
 class Organization:
     id: str
 
     name: str
 
 
 @dataclass
 class Version:
     """
-    Version
+    Version.
     """
 
     id: str
     """
-    UUID of this version
+    UUID of this version.
     """
 
     name: str
     """
-    Name of this version
+    Name of this version.
     """
 
     creation_date: Optional[datetime]
     """
-    Creation date of this image version
+    Creation date of this image version.
     """
 
     modification_date: Optional[datetime]
     """
-    Date of the last modification of this version
+    Date of the last modification of this version.
     """
 
     local_images: List[LocalImage]
     """
-    List of local images available in this version
+    List of local images available in this version.
     """
 
 
 @dataclass
 class ListImagesRequest:
     per_page: Optional[int]
     """
-    A positive integer lower or equal to 100 to select the number of items to display
+    A positive integer lower or equal to 100 to select the number of items to display.
     """
 
     page: Optional[int]
     """
-    A positive integer to choose the page to display
+    A positive integer to choose the page to display.
     """
 
 
 @dataclass
 class GetImageRequest:
     image_id: str
     """
-    Display the image name
+    Display the image name.
     """
 
 
 @dataclass
 class ListVersionsRequest:
     image_id: str
```

### Comparing `scaleway_async-0.9.0/scaleway_async/marketplace/v2/__init__.py` & `scaleway_async-1.0.0/scaleway_async/marketplace/v2/__init__.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,26 +1,28 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 from .types import ListImagesRequestOrderBy
 from .types import ListLocalImagesRequestOrderBy
 from .types import ListVersionsRequestOrderBy
+from .types import LocalImageType
 from .types import Category
 from .types import Image
 from .types import ListCategoriesResponse
 from .types import ListImagesResponse
 from .types import ListLocalImagesResponse
 from .types import ListVersionsResponse
 from .types import LocalImage
 from .types import Version
 from .api import MarketplaceV2API
 
 __all__ = [
     "ListImagesRequestOrderBy",
     "ListLocalImagesRequestOrderBy",
     "ListVersionsRequestOrderBy",
+    "LocalImageType",
     "Category",
     "Image",
     "ListCategoriesResponse",
     "ListImagesResponse",
     "ListLocalImagesResponse",
     "ListVersionsResponse",
     "LocalImage",
```

### Comparing `scaleway_async-0.9.0/scaleway_async/marketplace/v2/api.py` & `scaleway_async-1.0.0/scaleway_async/test/v1/api.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,423 +1,431 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 
-from typing import List, Optional
+from typing import Awaitable, List, Optional, Union
 
 from scaleway_core.api import API
-from scaleway_core.bridge import (
-    Zone,
-)
 from scaleway_core.utils import (
-    OneOfPossibility,
+    WaitForOptions,
     fetch_all_pages_async,
-    resolve_one_of,
     validate_path_param,
+    wait_for_resource_async,
 )
 from .types import (
-    ListImagesRequestOrderBy,
-    ListLocalImagesRequestOrderBy,
-    ListVersionsRequestOrderBy,
-    Category,
-    Image,
-    ListCategoriesResponse,
-    ListImagesResponse,
-    ListLocalImagesResponse,
-    ListVersionsResponse,
-    LocalImage,
-    Version,
+    EyeColors,
+    ListHumansRequestOrderBy,
+    Human,
+    ListHumansResponse,
+    RegisterResponse,
+    RegisterRequest,
+    CreateHumanRequest,
+    UpdateHumanRequest,
+)
+from .content import (
+    HUMAN_TRANSIENT_STATUSES,
 )
 from .marshalling import (
-    unmarshal_Category,
-    unmarshal_Image,
-    unmarshal_LocalImage,
-    unmarshal_Version,
-    unmarshal_ListCategoriesResponse,
-    unmarshal_ListImagesResponse,
-    unmarshal_ListLocalImagesResponse,
-    unmarshal_ListVersionsResponse,
+    marshal_CreateHumanRequest,
+    marshal_RegisterRequest,
+    marshal_UpdateHumanRequest,
+    unmarshal_Human,
+    unmarshal_ListHumansResponse,
+    unmarshal_RegisterResponse,
 )
 
 
-class MarketplaceV2API(API):
+class TestV1API(API):
     """
-    Marketplace API.
-    """
-
-    async def list_images(
-        self,
-        *,
-        include_eol: bool,
-        page_size: Optional[int] = None,
-        page: Optional[int] = None,
-        order_by: ListImagesRequestOrderBy = ListImagesRequestOrderBy.NAME_ASC,
-        arch: Optional[str] = None,
-        category: Optional[str] = None,
-    ) -> ListImagesResponse:
-        """
-        List marketplace images
-        :param page_size: A positive integer lower or equal to 100 to select the number of items to display
-        :param page: A positive integer to choose the page to display
-        :param order_by: Ordering to use
-        :param arch: Choose for which machine architecture to return images
-        :param category: Choose the category of images to get
-        :param include_eol: Choose to include end-of-life images
-        :return: :class:`ListImagesResponse <ListImagesResponse>`
+    Fake API.
 
-        Usage:
-        ::
+    No Auth Service for end-to-end testing.
+    Test is a fake service that aim to manage fake humans. It is used for internal and public end-to-end tests.
 
-            result = await api.list_images(include_eol=True)
-        """
-
-        res = self._request(
-            "GET",
-            f"/marketplace/v2/images",
-            params={
-                "arch": arch,
-                "category": category,
-                "include_eol": include_eol,
-                "order_by": order_by,
-                "page": page,
-                "page_size": page_size or self.client.default_page_size,
-            },
-        )
+    This service don't use the Scaleway authentication service but a fake one.
+    It allows to use this test service publicly without requiring a Scaleway account.
 
-        self._throw_on_error(res)
-        return unmarshal_ListImagesResponse(res.json())
+    First, you need to register a user with `scw test human register` to get an access-key.
+    Then, you can use other test commands by setting the SCW_SECRET_KEY env variable.
+    """
 
-    async def list_images_all(
+    async def register(
         self,
         *,
-        include_eol: bool,
-        page_size: Optional[int] = None,
-        page: Optional[int] = None,
-        order_by: Optional[ListImagesRequestOrderBy] = None,
-        arch: Optional[str] = None,
-        category: Optional[str] = None,
-    ) -> List[Image]:
-        """
-        List marketplace images
-        :param page_size: A positive integer lower or equal to 100 to select the number of items to display
-        :param page: A positive integer to choose the page to display
-        :param order_by: Ordering to use
-        :param arch: Choose for which machine architecture to return images
-        :param category: Choose the category of images to get
-        :param include_eol: Choose to include end-of-life images
-        :return: :class:`List[ListImagesResponse] <List[ListImagesResponse]>`
-
-        Usage:
-        ::
-
-            result = await api.list_images_all(include_eol=True)
+        username: str,
+    ) -> RegisterResponse:
         """
+        Register a user.
+        Register a human and return a access-key and a secret-key that must be used in all other commands.
 
-        return await fetch_all_pages_async(
-            type=ListImagesResponse,
-            key="images",
-            fetcher=self.list_images,
-            args={
-                "include_eol": include_eol,
-                "page_size": page_size,
-                "page": page,
-                "order_by": order_by,
-                "arch": arch,
-                "category": category,
-            },
-        )
-
-    async def get_image(
-        self,
-        *,
-        image_id: str,
-    ) -> Image:
-        """
-        Get a specific marketplace image
-        :param image_id: Display the image name
-        :return: :class:`Image <Image>`
+        Hint: you can use other test commands by setting the SCW_SECRET_KEY env variable.
+        :param username:
+        :return: :class:`RegisterResponse <RegisterResponse>`
 
         Usage:
         ::
 
-            result = await api.get_image(image_id="example")
+            result = await api.register(username="example")
         """
 
-        param_image_id = validate_path_param("image_id", image_id)
-
         res = self._request(
-            "GET",
-            f"/marketplace/v2/images/{param_image_id}",
+            "POST",
+            f"/test/v1/register",
+            body=marshal_RegisterRequest(
+                RegisterRequest(
+                    username=username,
+                ),
+                self.client,
+            ),
         )
 
         self._throw_on_error(res)
-        return unmarshal_Image(res.json())
+        return unmarshal_RegisterResponse(res.json())
 
-    async def list_versions(
+    async def list_humans(
         self,
         *,
-        image_id: str,
-        page_size: Optional[int] = None,
         page: Optional[int] = None,
-        order_by: ListVersionsRequestOrderBy = ListVersionsRequestOrderBy.CREATED_AT_ASC,
-    ) -> ListVersionsResponse:
+        page_size: Optional[int] = None,
+        order_by: ListHumansRequestOrderBy = ListHumansRequestOrderBy.CREATED_AT_ASC,
+        organization_id: Optional[str] = None,
+        project_id: Optional[str] = None,
+    ) -> ListHumansResponse:
         """
+        List all your humans.
+        :param page:
+        :param page_size:
+        :param order_by:
+        :param organization_id:
+        :param project_id:
+        :return: :class:`ListHumansResponse <ListHumansResponse>`
 
         Usage:
         ::
 
-            result = await api.list_versions(image_id="example")
+            result = await api.list_humans()
         """
 
         res = self._request(
             "GET",
-            f"/marketplace/v2/versions",
+            f"/test/v1/humans",
             params={
-                "image_id": image_id,
                 "order_by": order_by,
+                "organization_id": organization_id
+                or self.client.default_organization_id,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
+                "project_id": project_id or self.client.default_project_id,
             },
         )
 
         self._throw_on_error(res)
-        return unmarshal_ListVersionsResponse(res.json())
+        return unmarshal_ListHumansResponse(res.json())
 
-    async def list_versions_all(
+    async def list_humans_all(
         self,
         *,
-        image_id: str,
-        page_size: Optional[int] = None,
         page: Optional[int] = None,
-        order_by: Optional[ListVersionsRequestOrderBy] = None,
-    ) -> List[Version]:
+        page_size: Optional[int] = None,
+        order_by: Optional[ListHumansRequestOrderBy] = None,
+        organization_id: Optional[str] = None,
+        project_id: Optional[str] = None,
+    ) -> List[Human]:
         """
-        :return: :class:`List[ListVersionsResponse] <List[ListVersionsResponse]>`
+        List all your humans.
+        :param page:
+        :param page_size:
+        :param order_by:
+        :param organization_id:
+        :param project_id:
+        :return: :class:`List[ListHumansResponse] <List[ListHumansResponse]>`
 
         Usage:
         ::
 
-            result = await api.list_versions_all(image_id="example")
+            result = await api.list_humans_all()
         """
 
         return await fetch_all_pages_async(
-            type=ListVersionsResponse,
-            key="versions",
-            fetcher=self.list_versions,
+            type=ListHumansResponse,
+            key="humans",
+            fetcher=self.list_humans,
             args={
-                "image_id": image_id,
-                "page_size": page_size,
                 "page": page,
+                "page_size": page_size,
                 "order_by": order_by,
+                "organization_id": organization_id,
+                "project_id": project_id,
             },
         )
 
-    async def get_version(
+    async def get_human(
         self,
         *,
-        version_id: str,
-    ) -> Version:
+        human_id: str,
+    ) -> Human:
         """
+        Get human details.
+        Get the human details associated with the given id.
+        :param human_id: UUID of the human you want to get.
+        :return: :class:`Human <Human>`
 
         Usage:
         ::
 
-            result = await api.get_version(version_id="example")
+            result = await api.get_human(human_id="example")
         """
 
-        param_version_id = validate_path_param("version_id", version_id)
+        param_human_id = validate_path_param("human_id", human_id)
 
         res = self._request(
             "GET",
-            f"/marketplace/v2/versions/{param_version_id}",
+            f"/test/v1/humans/{param_human_id}",
         )
 
         self._throw_on_error(res)
-        return unmarshal_Version(res.json())
+        return unmarshal_Human(res.json())
 
-    async def list_local_images(
+    async def wait_for_human(
         self,
         *,
-        image_id: Optional[str] = None,
-        version_id: Optional[str] = None,
-        page_size: Optional[int] = None,
-        page: Optional[int] = None,
-        order_by: ListLocalImagesRequestOrderBy = ListLocalImagesRequestOrderBy.CREATED_AT_ASC,
-        image_label: Optional[str] = None,
-        zone: Optional[Zone] = None,
-    ) -> ListLocalImagesResponse:
-        """
-        List local images from a specific image or version
-        :param image_id: One-of ('scope'): at most one of 'image_id', 'version_id', 'image_label' could be set.
-        :param version_id: One-of ('scope'): at most one of 'image_id', 'version_id', 'image_label' could be set.
-        :param page_size:
-        :param page:
-        :param order_by:
-        :param image_label: One-of ('scope'): at most one of 'image_id', 'version_id', 'image_label' could be set.
-        :param zone:
-        :return: :class:`ListLocalImagesResponse <ListLocalImagesResponse>`
+        human_id: str,
+        options: Optional[WaitForOptions[Human, Union[bool, Awaitable[bool]]]] = None,
+    ) -> Human:
+        """
+        Waits for :class:`Human <Human>` to be in a final state.
+        :param human_id: UUID of the human you want to get.
+        :param options: The options for the waiter
+        :return: :class:`Human <Human>`
 
         Usage:
         ::
 
-            result = await api.list_local_images()
+            result = api.wait_for_human(human_id="example")
         """
 
-        res = self._request(
-            "GET",
-            f"/marketplace/v2/local-images",
-            params={
-                "order_by": order_by,
-                "page": page,
-                "page_size": page_size or self.client.default_page_size,
-                "zone": zone or self.client.default_zone,
-                **resolve_one_of(
-                    [
-                        OneOfPossibility("image_id", image_id),
-                        OneOfPossibility("version_id", version_id),
-                        OneOfPossibility("image_label", image_label),
-                    ]
-                ),
+        if not options:
+            options = WaitForOptions()
+
+        if not options.stop:
+            options.stop = lambda res: res.status not in HUMAN_TRANSIENT_STATUSES
+
+        return await wait_for_resource_async(
+            fetcher=self.get_human,
+            options=options,
+            args={
+                "human_id": human_id,
             },
         )
 
-        self._throw_on_error(res)
-        return unmarshal_ListLocalImagesResponse(res.json())
-
-    async def list_local_images_all(
+    async def create_human(
         self,
         *,
-        image_id: Optional[str] = None,
-        version_id: Optional[str] = None,
-        page_size: Optional[int] = None,
-        page: Optional[int] = None,
-        order_by: Optional[ListLocalImagesRequestOrderBy] = None,
-        image_label: Optional[str] = None,
-        zone: Optional[Zone] = None,
-    ) -> List[LocalImage]:
-        """
-        List local images from a specific image or version
-        :param image_id: One-of ('scope'): at most one of 'image_id', 'version_id', 'image_label' could be set.
-        :param version_id: One-of ('scope'): at most one of 'image_id', 'version_id', 'image_label' could be set.
-        :param page_size:
-        :param page:
-        :param order_by:
-        :param image_label: One-of ('scope'): at most one of 'image_id', 'version_id', 'image_label' could be set.
-        :param zone:
-        :return: :class:`List[ListLocalImagesResponse] <List[ListLocalImagesResponse]>`
+        height: float,
+        shoe_size: float,
+        altitude_in_meter: int,
+        altitude_in_millimeter: int,
+        fingers_count: int,
+        hair_count: int,
+        is_happy: bool,
+        eyes_color: EyeColors,
+        name: str,
+        organization_id: Optional[str] = None,
+        project_id: Optional[str] = None,
+    ) -> Human:
+        """
+        Create a new human.
+        :param height:
+        :param shoe_size:
+        :param altitude_in_meter:
+        :param altitude_in_millimeter:
+        :param fingers_count:
+        :param hair_count:
+        :param is_happy:
+        :param eyes_color:
+        :param organization_id: One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
+        :param name:
+        :param project_id: One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
+        :return: :class:`Human <Human>`
 
         Usage:
         ::
 
-            result = await api.list_local_images_all()
+            result = await api.create_human(
+                height=1.0,
+                shoe_size=1.0,
+                altitude_in_meter=1,
+                altitude_in_millimeter=1,
+                fingers_count=1,
+                hair_count=1,
+                is_happy=True,
+                eyes_color=unknown,
+                name="example",
+            )
         """
 
-        return await fetch_all_pages_async(
-            type=ListLocalImagesResponse,
-            key="local_images",
-            fetcher=self.list_local_images,
-            args={
-                "image_id": image_id,
-                "version_id": version_id,
-                "page_size": page_size,
-                "page": page,
-                "order_by": order_by,
-                "image_label": image_label,
-                "zone": zone,
-            },
+        res = self._request(
+            "POST",
+            f"/test/v1/humans",
+            body=marshal_CreateHumanRequest(
+                CreateHumanRequest(
+                    height=height,
+                    shoe_size=shoe_size,
+                    altitude_in_meter=altitude_in_meter,
+                    altitude_in_millimeter=altitude_in_millimeter,
+                    fingers_count=fingers_count,
+                    hair_count=hair_count,
+                    is_happy=is_happy,
+                    eyes_color=eyes_color,
+                    name=name,
+                    organization_id=organization_id,
+                    project_id=project_id,
+                ),
+                self.client,
+            ),
         )
 
-    async def get_local_image(
+        self._throw_on_error(res)
+        return unmarshal_Human(res.json())
+
+    async def update_human(
         self,
         *,
-        local_image_id: str,
-    ) -> LocalImage:
-        """
+        human_id: str,
+        eyes_color: EyeColors,
+        height: Optional[float] = None,
+        shoe_size: Optional[float] = None,
+        altitude_in_meter: Optional[int] = None,
+        altitude_in_millimeter: Optional[int] = None,
+        fingers_count: Optional[int] = None,
+        hair_count: Optional[int] = None,
+        is_happy: Optional[bool] = None,
+        name: Optional[str] = None,
+    ) -> Human:
+        """
+        Update an existing human.
+        Update the human associated with the given id.
+        :param human_id: UUID of the human you want to update.
+        :param height:
+        :param shoe_size:
+        :param altitude_in_meter:
+        :param altitude_in_millimeter:
+        :param fingers_count:
+        :param hair_count:
+        :param is_happy:
+        :param eyes_color:
+        :param name:
+        :return: :class:`Human <Human>`
 
         Usage:
         ::
 
-            result = await api.get_local_image(local_image_id="example")
+            result = await api.update_human(
+                human_id="example",
+                eyes_color=unknown,
+            )
         """
 
-        param_local_image_id = validate_path_param("local_image_id", local_image_id)
+        param_human_id = validate_path_param("human_id", human_id)
 
         res = self._request(
-            "GET",
-            f"/marketplace/v2/local-images/{param_local_image_id}",
+            "PATCH",
+            f"/test/v1/humans/{param_human_id}",
+            body=marshal_UpdateHumanRequest(
+                UpdateHumanRequest(
+                    human_id=human_id,
+                    eyes_color=eyes_color,
+                    height=height,
+                    shoe_size=shoe_size,
+                    altitude_in_meter=altitude_in_meter,
+                    altitude_in_millimeter=altitude_in_millimeter,
+                    fingers_count=fingers_count,
+                    hair_count=hair_count,
+                    is_happy=is_happy,
+                    name=name,
+                ),
+                self.client,
+            ),
         )
 
         self._throw_on_error(res)
-        return unmarshal_LocalImage(res.json())
+        return unmarshal_Human(res.json())
 
-    async def list_categories(
+    async def delete_human(
         self,
         *,
-        page_size: Optional[int] = None,
-        page: Optional[int] = None,
-    ) -> ListCategoriesResponse:
+        human_id: str,
+    ) -> Human:
         """
+        Delete an existing human.
+        Delete the human associated with the given id.
+        :param human_id: UUID of the human you want to delete.
+        :return: :class:`Human <Human>`
 
         Usage:
         ::
 
-            result = await api.list_categories()
+            result = await api.delete_human(human_id="example")
         """
 
+        param_human_id = validate_path_param("human_id", human_id)
+
         res = self._request(
-            "GET",
-            f"/marketplace/v2/categories",
-            params={
-                "page": page,
-                "page_size": page_size or self.client.default_page_size,
-            },
+            "DELETE",
+            f"/test/v1/humans/{param_human_id}",
         )
 
         self._throw_on_error(res)
-        return unmarshal_ListCategoriesResponse(res.json())
+        return unmarshal_Human(res.json())
 
-    async def list_categories_all(
+    async def run_human(
         self,
         *,
-        page_size: Optional[int] = None,
-        page: Optional[int] = None,
-    ) -> List[Category]:
+        human_id: str,
+    ) -> Human:
         """
-        :return: :class:`List[ListCategoriesResponse] <List[ListCategoriesResponse]>`
+        Start a 1h running for the given human.
+        Start a one hour running for the given human.
+        :param human_id: UUID of the human you want to make run.
+        :return: :class:`Human <Human>`
 
         Usage:
         ::
 
-            result = await api.list_categories_all()
+            result = await api.run_human(human_id="example")
         """
 
-        return await fetch_all_pages_async(
-            type=ListCategoriesResponse,
-            key="categories",
-            fetcher=self.list_categories,
-            args={
-                "page_size": page_size,
-                "page": page,
-            },
+        param_human_id = validate_path_param("human_id", human_id)
+
+        res = self._request(
+            "POST",
+            f"/test/v1/humans/{param_human_id}/run",
         )
 
-    async def get_category(
+        self._throw_on_error(res)
+        return unmarshal_Human(res.json())
+
+    async def smoke_human(
         self,
         *,
-        category_id: str,
-    ) -> Category:
+        human_id: Optional[str] = None,
+    ) -> Human:
         """
+        Make a human smoke.
+        :param human_id: UUID of the human you want to make smoking.
+        :return: :class:`Human <Human>`
+        :deprecated
 
         Usage:
         ::
 
-            result = await api.get_category(category_id="example")
+            result = await api.smoke_human()
         """
 
-        param_category_id = validate_path_param("category_id", category_id)
+        param_human_id = validate_path_param("human_id", human_id)
 
         res = self._request(
-            "GET",
-            f"/marketplace/v2/categories/{param_category_id}",
+            "POST",
+            f"/test/v1/humans/{param_human_id}/smoke",
         )
 
         self._throw_on_error(res)
-        return unmarshal_Category(res.json())
+        return unmarshal_Human(res.json())
```

### Comparing `scaleway_async-0.9.0/scaleway_async/marketplace/v2/marshalling.py` & `scaleway_async-1.0.0/scaleway_async/marketplace/v1/marshalling.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,194 +1,197 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 
 from typing import Any, Dict
 
 from dateutil import parser
 from .types import (
-    Category,
+    GetImageResponse,
+    GetVersionResponse,
     Image,
-    ListCategoriesResponse,
     ListImagesResponse,
-    ListLocalImagesResponse,
     ListVersionsResponse,
     LocalImage,
+    Organization,
     Version,
 )
 
 
-def unmarshal_Category(data: Any) -> Category:
+def unmarshal_LocalImage(data: Any) -> LocalImage:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Category' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'LocalImage' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("description")
-    args["description"] = field
+    field = data.get("arch", None)
+    args["arch"] = field
 
-    field = data.get("id")
+    field = data.get("compatible_commercial_types", None)
+    args["compatible_commercial_types"] = field
+
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("name")
-    args["name"] = field
+    field = data.get("zone", None)
+    args["zone"] = field
 
-    return Category(**args)
+    return LocalImage(**args)
 
 
-def unmarshal_Image(data: Any) -> Image:
+def unmarshal_Organization(data: Any) -> Organization:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Image' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Organization' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("categories")
-    args["categories"] = field
-
-    field = data.get("created_at")
-    args["created_at"] = parser.isoparse(field) if type(field) is str else field
-
-    field = data.get("description")
-    args["description"] = field
-
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("label")
-    args["label"] = field
-
-    field = data.get("logo")
-    args["logo"] = field
-
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("updated_at")
-    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
-
-    field = data.get("valid_until")
-    args["valid_until"] = parser.isoparse(field) if type(field) is str else field
-
-    return Image(**args)
+    return Organization(**args)
 
 
-def unmarshal_LocalImage(data: Any) -> LocalImage:
+def unmarshal_Version(data: Any) -> Version:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'LocalImage' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Version' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("arch")
-    args["arch"] = field
-
-    field = data.get("compatible_commercial_types")
-    args["compatible_commercial_types"] = field
+    field = data.get("creation_date", None)
+    args["creation_date"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("label")
-    args["label"] = field
+    field = data.get("local_images", None)
+    args["local_images"] = (
+        [unmarshal_LocalImage(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("zone")
-    args["zone"] = field
+    field = data.get("modification_date", None)
+    args["modification_date"] = parser.isoparse(field) if type(field) is str else field
 
-    return LocalImage(**args)
+    field = data.get("name", None)
+    args["name"] = field
 
+    return Version(**args)
 
-def unmarshal_Version(data: Any) -> Version:
+
+def unmarshal_Image(data: Any) -> Image:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Version' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Image' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
-    args["created_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("categories", None)
+    args["categories"] = field
+
+    field = data.get("creation_date", None)
+    args["creation_date"] = parser.isoparse(field) if type(field) is str else field
+
+    field = data.get("current_public_version", None)
+    args["current_public_version"] = field
+
+    field = data.get("description", None)
+    args["description"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("name")
+    field = data.get("label", None)
+    args["label"] = field
+
+    field = data.get("logo", None)
+    args["logo"] = field
+
+    field = data.get("modification_date", None)
+    args["modification_date"] = parser.isoparse(field) if type(field) is str else field
+
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("published_at")
-    args["published_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("organization", None)
+    args["organization"] = unmarshal_Organization(field) if field is not None else None
 
-    field = data.get("updated_at")
-    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("valid_until", None)
+    args["valid_until"] = parser.isoparse(field) if type(field) is str else field
 
-    return Version(**args)
+    field = data.get("versions", None)
+    args["versions"] = (
+        [unmarshal_Version(v) for v in field] if field is not None else None
+    )
+
+    return Image(**args)
 
 
-def unmarshal_ListCategoriesResponse(data: Any) -> ListCategoriesResponse:
+def unmarshal_GetImageResponse(data: Any) -> GetImageResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListCategoriesResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'GetImageResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("categories")
-    args["categories"] = [unmarshal_Category(v) for v in data["categories"]]
-
-    field = data.get("total_count")
-    args["total_count"] = field
+    field = data.get("image", None)
+    args["image"] = unmarshal_Image(field) if field is not None else None
 
-    return ListCategoriesResponse(**args)
+    return GetImageResponse(**args)
 
 
-def unmarshal_ListImagesResponse(data: Any) -> ListImagesResponse:
+def unmarshal_GetVersionResponse(data: Any) -> GetVersionResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListImagesResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'GetVersionResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("images")
-    args["images"] = [unmarshal_Image(v) for v in data["images"]]
-
-    field = data.get("total_count")
-    args["total_count"] = field
+    field = data.get("version", None)
+    args["version"] = unmarshal_Version(field) if field is not None else None
 
-    return ListImagesResponse(**args)
+    return GetVersionResponse(**args)
 
 
-def unmarshal_ListLocalImagesResponse(data: Any) -> ListLocalImagesResponse:
+def unmarshal_ListImagesResponse(data: Any) -> ListImagesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListLocalImagesResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListImagesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("local_images")
-    args["local_images"] = [unmarshal_LocalImage(v) for v in data["local_images"]]
+    field = data.get("images", None)
+    args["images"] = [unmarshal_Image(v) for v in field] if field is not None else None
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListLocalImagesResponse(**args)
+    return ListImagesResponse(**args)
 
 
 def unmarshal_ListVersionsResponse(data: Any) -> ListVersionsResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListVersionsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    field = data.get("versions")
-    args["versions"] = [unmarshal_Version(v) for v in data["versions"]]
+    field = data.get("versions", None)
+    args["versions"] = (
+        [unmarshal_Version(v) for v in field] if field is not None else None
+    )
 
     return ListVersionsResponse(**args)
```

### Comparing `scaleway_async-0.9.0/scaleway_async/marketplace/v2/types.py` & `scaleway_async-1.0.0/scaleway_async/marketplace/v2/types.py`

 * *Files 6% similar despite different names*

```diff
@@ -36,73 +36,82 @@
     CREATED_AT_ASC = "created_at_asc"
     CREATED_AT_DESC = "created_at_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
+class LocalImageType(str, Enum):
+    UNKNOWN_TYPE = "unknown_type"
+    INSTANCE_LOCAL = "instance_local"
+    INSTANCE_SBS = "instance_sbs"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
 @dataclass
 class Category:
     id: str
 
     name: str
 
     description: str
 
 
 @dataclass
 class Image:
     """
-    Image
+    Image.
     """
 
     id: str
     """
-    UUID of this image
+    UUID of this image.
     """
 
     name: str
     """
-    Name of the image
+    Name of the image.
     """
 
     description: str
     """
-    Text description of this image
+    Text description of this image.
     """
 
     logo: str
     """
-    URL of this image's logo
+    URL of this image's logo.
     """
 
     categories: List[str]
     """
-    List of categories this image belongs to
+    List of categories this image belongs to.
     """
 
     created_at: Optional[datetime]
     """
-    Creation date of this image
+    Creation date of this image.
     """
 
     updated_at: Optional[datetime]
     """
-    Date of the last modification of this image
+    Date of the last modification of this image.
     """
 
     valid_until: Optional[datetime]
     """
-    Expiration date of this image
+    Expiration date of this image.
     """
 
     label: str
     """
+    Label of this image.
     Typically an identifier for a distribution (ex. "ubuntu_focal").
-    
     """
 
 
 @dataclass
 class ListCategoriesResponse:
     categories: List[Category]
 
@@ -129,114 +138,119 @@
 
     total_count: int
 
 
 @dataclass
 class LocalImage:
     """
-    Local image
+    Local image.
     """
 
     id: str
     """
+    UUID of this local image.
     Version you will typically use to define an image in an API call.
-    
     """
 
     compatible_commercial_types: List[str]
     """
-    List of all commercial types that are compatible with this local image
+    List of all commercial types that are compatible with this local image.
     """
 
     arch: str
     """
-    Supported architecture for this local image
+    Supported architecture for this local image.
     """
 
     zone: Zone
     """
-    Availability Zone where this local image is available
+    Availability Zone where this local image is available.
     """
 
     label: str
     """
-    Image label this image belongs to
+    Image label this image belongs to.
+    """
+
+    type_: LocalImageType
+    """
+    Type of this local image.
     """
 
 
 @dataclass
 class Version:
     """
-    Version
+    Version.
     """
 
     id: str
     """
-    UUID of this version
+    UUID of this version.
     """
 
     name: str
     """
-    Name of this version
+    Name of this version.
     """
 
     created_at: Optional[datetime]
     """
-    Creation date of this image version
+    Creation date of this image version.
     """
 
     updated_at: Optional[datetime]
     """
-    Date of the last modification of this version
+    Date of the last modification of this version.
     """
 
     published_at: Optional[datetime]
     """
-    Date this version was officially published
+    Date this version was officially published.
     """
 
 
 @dataclass
 class ListImagesRequest:
     page_size: Optional[int]
     """
-    A positive integer lower or equal to 100 to select the number of items to display
+    A positive integer lower or equal to 100 to select the number of items to display.
     """
 
     page: Optional[int]
     """
-    A positive integer to choose the page to display
+    A positive integer to choose the page to display.
     """
 
     order_by: Optional[ListImagesRequestOrderBy]
     """
-    Ordering to use
+    Ordering to use.
     """
 
     arch: Optional[str]
     """
-    Choose for which machine architecture to return images
+    Choose for which machine architecture to return images.
     """
 
     category: Optional[str]
     """
-    Choose the category of images to get
+    Choose the category of images to get.
     """
 
     include_eol: bool
     """
-    Choose to include end-of-life images
+    Choose to include end-of-life images.
     """
 
 
 @dataclass
 class GetImageRequest:
     image_id: str
     """
-    Display the image name
+    Display the image name.
     """
 
 
 @dataclass
 class ListVersionsRequest:
     image_id: str
 
@@ -273,14 +287,16 @@
     image_label: Optional[str]
     """
     One-of ('scope'): at most one of 'image_id', 'version_id', 'image_label' could be set.
     """
 
     zone: Optional[Zone]
 
+    type_: Optional[LocalImageType]
+
 
 @dataclass
 class GetLocalImageRequest:
     local_image_id: str
 
 
 @dataclass
```

### Comparing `scaleway_async-0.9.0/scaleway_async/mnq/v1alpha1/__init__.py` & `scaleway_async-1.0.0/scaleway_async/mnq/v1alpha1/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-0.9.0/scaleway_async/mnq/v1alpha1/api.py` & `scaleway_async-1.0.0/scaleway_async/mnq/v1alpha1/api.py`

 * *Files 27% similar despite different names*

```diff
@@ -37,37 +37,39 @@
     unmarshal_ListCredentialsResponse,
     unmarshal_ListNamespacesResponse,
 )
 
 
 class MnqV1Alpha1API(API):
     """
-    MnQ API (beta).
+    Messaging and Queuing API.
 
-    This API allows you to manage Messaging or Queueing brokers.
+    This API allows you to manage Scaleway Messaging and Queueing brokers.
+    Messaging and Queuing API.
     """
 
     async def list_namespaces(
         self,
         *,
         region: Optional[Region] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListNamespacesRequestOrderBy = ListNamespacesRequestOrderBy.CREATED_AT_ASC,
     ) -> ListNamespacesResponse:
         """
-        List namespaces
-        :param region: Region to target. If none is passed will use default region from the config
-        :param organization_id: Will list only the Namespaces owned by the specified organization
-        :param project_id: Will list only the Namespaces contained into the specified project
-        :param page: Indicate the page number of results to be returned
-        :param page_size: Maximum number of results returned by page
-        :param order_by: Field used for sorting results
+        List namespaces.
+        List all Messaging and Queuing namespaces in the specified region, for a Scaleway Organization or Project. By default, the namespaces returned in the list are ordered by creation date in ascending order, though this can be modified via the `order_by` field.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param organization_id: Include only namespaces in this Organization.
+        :param project_id: Include only namespaces in this Project.
+        :param page: Page number to return.
+        :param page_size: Maximum number of namespaces to return per page.
+        :param order_by: Order in which to return results.
         :return: :class:`ListNamespacesResponse <ListNamespacesResponse>`
 
         Usage:
         ::
 
             result = await api.list_namespaces()
         """
@@ -99,21 +101,22 @@
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListNamespacesRequestOrderBy] = None,
     ) -> List[Namespace]:
         """
-        List namespaces
-        :param region: Region to target. If none is passed will use default region from the config
-        :param organization_id: Will list only the Namespaces owned by the specified organization
-        :param project_id: Will list only the Namespaces contained into the specified project
-        :param page: Indicate the page number of results to be returned
-        :param page_size: Maximum number of results returned by page
-        :param order_by: Field used for sorting results
+        List namespaces.
+        List all Messaging and Queuing namespaces in the specified region, for a Scaleway Organization or Project. By default, the namespaces returned in the list are ordered by creation date in ascending order, though this can be modified via the `order_by` field.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param organization_id: Include only namespaces in this Organization.
+        :param project_id: Include only namespaces in this Project.
+        :param page: Page number to return.
+        :param page_size: Maximum number of namespaces to return per page.
+        :param order_by: Order in which to return results.
         :return: :class:`List[ListNamespacesResponse] <List[ListNamespacesResponse]>`
 
         Usage:
         ::
 
             result = await api.list_namespaces_all()
         """
@@ -137,19 +140,20 @@
         *,
         region: Optional[Region] = None,
         name: Optional[str] = None,
         protocol: NamespaceProtocol = NamespaceProtocol.UNKNOWN,
         project_id: Optional[str] = None,
     ) -> Namespace:
         """
-        Create a namespace
-        :param region: Region to target. If none is passed will use default region from the config
-        :param name: Namespace name
-        :param protocol: Namespace protocol
-        :param project_id: Project containing the Namespace
+        Create a namespace.
+        Create a Messaging and Queuing namespace, set to the desired protocol.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param name: Namespace name.
+        :param protocol: Namespace protocol. You must specify a valid protocol (and not `unknown`) to avoid an error.
+        :param project_id: Project containing the Namespace.
         :return: :class:`Namespace <Namespace>`
 
         Usage:
         ::
 
             result = await api.create_namespace()
         """
@@ -179,18 +183,19 @@
         self,
         *,
         namespace_id: str,
         region: Optional[Region] = None,
         name: Optional[str] = None,
     ) -> Namespace:
         """
-        Update the name of a namespace
-        :param region: Region to target. If none is passed will use default region from the config
-        :param namespace_id: ID of the Namespace to update
-        :param name: Namespace name
+        Update the name of a namespace.
+        Update the name of a Messaging and Queuing namespace, specified by its namespace ID.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param namespace_id: ID of the Namespace to update.
+        :param name: Namespace name.
         :return: :class:`Namespace <Namespace>`
 
         Usage:
         ::
 
             result = await api.update_namespace(namespace_id="example")
         """
@@ -218,17 +223,18 @@
     async def get_namespace(
         self,
         *,
         namespace_id: str,
         region: Optional[Region] = None,
     ) -> Namespace:
         """
-        Get a namespace
-        :param region: Region to target. If none is passed will use default region from the config
-        :param namespace_id: ID of the Namespace to get
+        Get a namespace.
+        Retrieve information about an existing Messaging and Queuing namespace, identified by its namespace ID. Its full details, including name, endpoint and protocol, are returned in the response.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param namespace_id: ID of the Namespace to get.
         :return: :class:`Namespace <Namespace>`
 
         Usage:
         ::
 
             result = await api.get_namespace(namespace_id="example")
         """
@@ -249,17 +255,18 @@
     async def delete_namespace(
         self,
         *,
         namespace_id: str,
         region: Optional[Region] = None,
     ) -> Optional[None]:
         """
-        Delete a namespace
-        :param region: Region to target. If none is passed will use default region from the config
-        :param namespace_id: ID of the Namespace to delete
+        Delete a namespace.
+        Delete a Messaging and Queuing namespace, specified by its namespace ID. Note that deleting a namespace is irreversible, and any URLs, credentials and queued messages belonging to this namespace will also be deleted.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param namespace_id: ID of the namespace to delete.
 
         Usage:
         ::
 
             result = await api.delete_namespace(namespace_id="example")
         """
 
@@ -281,21 +288,20 @@
         *,
         namespace_id: str,
         region: Optional[Region] = None,
         name: Optional[str] = None,
         permissions: Optional[Permissions] = None,
     ) -> Credential:
         """
-        Create a set of credentials for a specific namespace.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param namespace_id: Namespace containing the Credential
-        :param name: Credential name
-        :param permissions: List of permissions associated to this Credential.
-
-        One-of ('optional_permissions'): at most one of 'permissions' could be set.
+        Create credentials.
+        Create a set of credentials for a Messaging and Queuing namespace, specified by its namespace ID. If creating credentials for a NATS namespace, the `permissions` object must not be included in the request. If creating credentials for an SQS/SNS namespace, the `permissions` object is required, with all three of its child attributes.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param namespace_id: Namespace containing the credentials.
+        :param name: Name of the credentials.
+        :param permissions: Permissions associated with these credentials.
         :return: :class:`Credential <Credential>`
 
         Usage:
         ::
 
             result = await api.create_credential(namespace_id="example")
         """
@@ -324,17 +330,18 @@
     async def delete_credential(
         self,
         *,
         credential_id: str,
         region: Optional[Region] = None,
     ) -> Optional[None]:
         """
-        Delete credentials
-        :param region: Region to target. If none is passed will use default region from the config
-        :param credential_id: ID of the Credential to delete
+        Delete credentials.
+        Delete a set of credentials, specified by their credential ID. Deleting credentials is irreversible and cannot be undone. The credentials can no longer be used to access the namespace.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param credential_id: ID of the credentials to delete.
 
         Usage:
         ::
 
             result = await api.delete_credential(credential_id="example")
         """
 
@@ -357,20 +364,21 @@
         region: Optional[Region] = None,
         namespace_id: Optional[str] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListCredentialsRequestOrderBy = ListCredentialsRequestOrderBy.ID_ASC,
     ) -> ListCredentialsResponse:
         """
-        List credentials
-        :param region: Region to target. If none is passed will use default region from the config
-        :param namespace_id: Namespace containing the Credential
-        :param page: Indicate the page number of results to be returned
-        :param page_size: Maximum number of results returned by page
-        :param order_by: Field used for sorting results
+        List credentials.
+        List existing credentials in the specified region. The response contains only the metadata for the credentials, not the credentials themselves (for this, use **Get Credentials**).
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param namespace_id: Namespace containing the credentials.
+        :param page: Page number to return.
+        :param page_size: Maximum number of credentials to return per page.
+        :param order_by: Order in which to return results.
         :return: :class:`ListCredentialsResponse <ListCredentialsResponse>`
 
         Usage:
         ::
 
             result = await api.list_credentials()
         """
@@ -399,20 +407,21 @@
         region: Optional[Region] = None,
         namespace_id: Optional[str] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListCredentialsRequestOrderBy] = None,
     ) -> List[CredentialSummary]:
         """
-        List credentials
-        :param region: Region to target. If none is passed will use default region from the config
-        :param namespace_id: Namespace containing the Credential
-        :param page: Indicate the page number of results to be returned
-        :param page_size: Maximum number of results returned by page
-        :param order_by: Field used for sorting results
+        List credentials.
+        List existing credentials in the specified region. The response contains only the metadata for the credentials, not the credentials themselves (for this, use **Get Credentials**).
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param namespace_id: Namespace containing the credentials.
+        :param page: Page number to return.
+        :param page_size: Maximum number of credentials to return per page.
+        :param order_by: Order in which to return results.
         :return: :class:`List[ListCredentialsResponse] <List[ListCredentialsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_credentials_all()
         """
@@ -435,21 +444,20 @@
         *,
         credential_id: str,
         region: Optional[Region] = None,
         name: Optional[str] = None,
         permissions: Optional[Permissions] = None,
     ) -> Credential:
         """
-        Update a set of credentials.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param credential_id: ID of the Credential to update
-        :param name: Credential name
-        :param permissions: List of permissions associated to this Credential.
-
-        One-of ('optional_permissions'): at most one of 'permissions' could be set.
+        Update credentials.
+        Update a set of credentials. You can update the credentials' name, or (in the case of SQS/SNS credentials only) their permissions. To update the name of NATS credentials, do not include the `permissions` object in your request.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param credential_id: ID of the credentials to update.
+        :param name: Name of the credentials.
+        :param permissions: Permissions associated with these credentials.
         :return: :class:`Credential <Credential>`
 
         Usage:
         ::
 
             result = await api.update_credential(credential_id="example")
         """
@@ -479,17 +487,18 @@
     async def get_credential(
         self,
         *,
         credential_id: str,
         region: Optional[Region] = None,
     ) -> Credential:
         """
-        Get a set of credentials
-        :param region: Region to target. If none is passed will use default region from the config
-        :param credential_id: ID of the Credential to get
+        Get credentials.
+        Retrieve an existing set of credentials, identified by the `credential_id`. The credentials themselves, as well as their metadata (protocol, namespace ID etc), are returned in the response.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param credential_id: ID of the credentials to get.
         :return: :class:`Credential <Credential>`
 
         Usage:
         ::
 
             result = await api.get_credential(credential_id="example")
         """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/mnq/v1alpha1/marshalling.py` & `scaleway_async-1.0.0/scaleway_async/mnq/v1alpha1/marshalling.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,17 +1,13 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 
 from typing import Any, Dict
 
 from scaleway_core.profile import ProfileDefaults
-from scaleway_core.utils import (
-    OneOfPossibility,
-    resolve_one_of,
-)
 from dateutil import parser
 from .types import (
     NamespaceProtocol,
     Credential,
     CredentialNATSCredsFile,
     CredentialSQSSNSCreds,
     CredentialSummary,
@@ -31,98 +27,98 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Permissions' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("can_manage")
+    field = data.get("can_manage", None)
     args["can_manage"] = field
 
-    field = data.get("can_publish")
+    field = data.get("can_publish", None)
     args["can_publish"] = field
 
-    field = data.get("can_receive")
+    field = data.get("can_receive", None)
     args["can_receive"] = field
 
     return Permissions(**args)
 
 
 def unmarshal_CredentialSummarySQSSNSCreds(data: Any) -> CredentialSummarySQSSNSCreds:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'CredentialSummarySQSSNSCreds' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("access_key")
+    field = data.get("access_key", None)
     args["access_key"] = field
 
-    field = data.get("permissions")
+    field = data.get("permissions", None)
     args["permissions"] = unmarshal_Permissions(field) if field is not None else None
 
     return CredentialSummarySQSSNSCreds(**args)
 
 
 def unmarshal_CredentialNATSCredsFile(data: Any) -> CredentialNATSCredsFile:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'CredentialNATSCredsFile' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("content")
+    field = data.get("content", None)
     args["content"] = field
 
     return CredentialNATSCredsFile(**args)
 
 
 def unmarshal_CredentialSQSSNSCreds(data: Any) -> CredentialSQSSNSCreds:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'CredentialSQSSNSCreds' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("access_key")
+    field = data.get("access_key", None)
     args["access_key"] = field
 
-    field = data.get("permissions")
+    field = data.get("permissions", None)
     args["permissions"] = unmarshal_Permissions(field) if field is not None else None
 
-    field = data.get("secret_key")
+    field = data.get("secret_key", None)
     args["secret_key"] = field
 
     return CredentialSQSSNSCreds(**args)
 
 
 def unmarshal_CredentialSummary(data: Any) -> CredentialSummary:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'CredentialSummary' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("namespace_id")
+    field = data.get("namespace_id", None)
     args["namespace_id"] = field
 
-    field = data.get("protocol")
+    field = data.get("protocol", None)
     args["protocol"] = field
 
-    field = data.get("sqs_sns_credentials")
+    field = data.get("sqs_sns_credentials", None)
     args["sqs_sns_credentials"] = (
         unmarshal_CredentialSummarySQSSNSCreds(field) if field is not None else None
     )
 
     return CredentialSummary(**args)
 
 
@@ -130,67 +126,67 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Namespace' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("endpoint")
+    field = data.get("endpoint", None)
     args["endpoint"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("project_id")
+    field = data.get("project_id", None)
     args["project_id"] = field
 
-    field = data.get("protocol")
+    field = data.get("protocol", None)
     args["protocol"] = field
 
-    field = data.get("region")
+    field = data.get("region", None)
     args["region"] = field
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
     return Namespace(**args)
 
 
 def unmarshal_Credential(data: Any) -> Credential:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'Credential' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("namespace_id")
+    field = data.get("namespace_id", None)
     args["namespace_id"] = field
 
-    field = data.get("nats_credentials")
+    field = data.get("nats_credentials", None)
     args["nats_credentials"] = (
         unmarshal_CredentialNATSCredsFile(field) if field is not None else None
     )
 
-    field = data.get("protocol")
+    field = data.get("protocol", None)
     args["protocol"] = field
 
-    field = data.get("sqs_sns_credentials")
+    field = data.get("sqs_sns_credentials", None)
     args["sqs_sns_credentials"] = (
         unmarshal_CredentialSQSSNSCreds(field) if field is not None else None
     )
 
     return Credential(**args)
 
 
@@ -198,94 +194,119 @@
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListCredentialsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("credentials")
-    args["credentials"] = [unmarshal_CredentialSummary(v) for v in data["credentials"]]
+    field = data.get("credentials", None)
+    args["credentials"] = (
+        [unmarshal_CredentialSummary(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListCredentialsResponse(**args)
 
 
 def unmarshal_ListNamespacesResponse(data: Any) -> ListNamespacesResponse:
     if type(data) is not dict:
         raise TypeError(
             f"Unmarshalling the type 'ListNamespacesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("namespaces")
-    args["namespaces"] = [unmarshal_Namespace(v) for v in data["namespaces"]]
+    field = data.get("namespaces", None)
+    args["namespaces"] = (
+        [unmarshal_Namespace(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
     return ListNamespacesResponse(**args)
 
 
 def marshal_Permissions(
     request: Permissions,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "can_manage": request.can_manage,
-        "can_publish": request.can_publish,
-        "can_receive": request.can_receive,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.can_manage is not None:
+        output["can_manage"] = request.can_manage
+
+    if request.can_publish is not None:
+        output["can_publish"] = request.can_publish
+
+    if request.can_receive is not None:
+        output["can_receive"] = request.can_receive
+
+    return output
 
 
 def marshal_CreateCredentialRequest(
     request: CreateCredentialRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
-            [
-                OneOfPossibility("permissions", request.permissions),
-            ]
-        ),
-        "name": request.name,
-        "namespace_id": request.namespace_id,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.namespace_id is not None:
+        output["namespace_id"] = request.namespace_id
+
+    if request.permissions is not None:
+        output["permissions"] = marshal_Permissions(request.permissions, defaults)
+
+    return output
 
 
 def marshal_CreateNamespaceRequest(
     request: CreateNamespaceRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "name": request.name,
-        "project_id": request.project_id or defaults.default_project_id,
-        "protocol": NamespaceProtocol(request.protocol)
-        if request.protocol is not None
-        else None,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    if request.protocol is not None:
+        output["protocol"] = NamespaceProtocol(request.protocol)
+
+    return output
 
 
 def marshal_UpdateCredentialRequest(
     request: UpdateCredentialRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
-            [
-                OneOfPossibility("permissions", request.permissions),
-            ]
-        ),
-        "name": request.name,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.permissions is not None:
+        output["permissions"] = marshal_Permissions(request.permissions, defaults)
+
+    return output
 
 
 def marshal_UpdateNamespaceRequest(
     request: UpdateNamespaceRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "name": request.name,
-        "namespace_id": request.namespace_id,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.namespace_id is not None:
+        output["namespace_id"] = request.namespace_id
+
+    return output
```

### Comparing `scaleway_async-0.9.0/scaleway_async/mnq/v1alpha1/types.py` & `scaleway_async-1.0.0/scaleway_async/mnq/v1alpha1/types.py`

 * *Files 12% similar despite different names*

```diff
@@ -46,435 +46,431 @@
     def __str__(self) -> str:
         return str(self.value)
 
 
 @dataclass
 class Credential:
     """
-    Credential
+    Credential.
     """
 
     id: str
     """
-    Credential ID
+    ID of the credentials.
     """
 
     name: str
     """
-    Credential name
+    Name of the credentials.
     """
 
     namespace_id: str
     """
-    Namespace containing the Credential
+    Namespace containing the credentials.
     """
 
     protocol: NamespaceProtocol
     """
-    Protocol associated to the Credential
+    Protocol associated with the credentials.
     """
 
     nats_credentials: Optional[CredentialNATSCredsFile]
     """
-    Credentials file used to connect to the NATS service.
+    Object containing the credentials, if the credentials are for a NATS namespace.
     
     One-of ('credential_type'): at most one of 'nats_credentials', 'sqs_sns_credentials' could be set.
     """
 
     sqs_sns_credentials: Optional[CredentialSQSSNSCreds]
     """
-    Credential used to connect to the SQS/SNS service.
+    Object containing the credentials and their metadata, if the credentials are for an SQS/SNS namespace.
     
     One-of ('credential_type'): at most one of 'nats_credentials', 'sqs_sns_credentials' could be set.
     """
 
 
 @dataclass
 class CredentialNATSCredsFile:
     """
-    Credential.nats creds file
+    Credential.nats creds file.
     """
 
     content: str
     """
-    Raw content of the NATS credentials file
+    Raw content of the NATS credentials file.
     """
 
 
 @dataclass
 class CredentialSQSSNSCreds:
     """
-    Credential.sqssns creds
+    Credential.sqssns creds.
     """
 
     access_key: str
     """
-    ID of the key
+    Access key ID.
     """
 
     secret_key: Optional[str]
     """
-    Secret value of the key
+    Secret key ID.
     """
 
     permissions: Optional[Permissions]
     """
-    List of permissions associated to this Credential
+    Permissions associated with these credentials.
     """
 
 
 @dataclass
 class CredentialSummary:
     """
-    Credential summary
+    Credential summary.
     """
 
     id: str
     """
-    Credential ID
+    ID of the credentials.
     """
 
     name: str
     """
-    Credential name
+    Name of the credentials.
     """
 
     namespace_id: str
     """
-    Namespace containing the Credential
+    Namespace containing the credentials.
     """
 
     protocol: NamespaceProtocol
     """
-    Protocol associated to the Credential
+    Protocol associated with the credentials.
     """
 
     sqs_sns_credentials: Optional[CredentialSummarySQSSNSCreds]
     """
-    Credential used to connect to the SQS/SNS service.
+    Object containing the credentials and their metadata, if the credentials are for an SQS/SNS namespace.
     
     One-of ('credential_type'): at most one of 'sqs_sns_credentials' could be set.
     """
 
 
 @dataclass
 class CredentialSummarySQSSNSCreds:
     """
-    Credential summary.sqssns creds
+    Credential summary.sqssns creds.
     """
 
     access_key: str
     """
-    ID of the key
+    Access key ID.
     """
 
     permissions: Optional[Permissions]
     """
-    List of permissions associated to this Credential
+    Permissions associated with these credentials.
     """
 
 
 @dataclass
 class ListCredentialsResponse:
     """
-    List credentials response
+    List credentials response.
     """
 
     total_count: int
     """
-    Total number of existing Credentials
+    Total count of existing credentials (matching any filters specified).
     """
 
     credentials: List[CredentialSummary]
     """
-    A page of Credentials
+    Credentials on this page.
     """
 
 
 @dataclass
 class ListNamespacesResponse:
     """
-    List namespaces response
+    List namespaces response.
     """
 
     total_count: int
     """
-    Total number of existing Namespaces
+    Total count of existing namespaces (matching any filters specified).
     """
 
     namespaces: List[Namespace]
     """
-    A page of Namespaces
+    Namespaces on this page.
     """
 
 
 @dataclass
 class Namespace:
     """
-    Namespace
+    Namespace.
     """
 
     id: str
     """
-    Namespace ID
+    Namespace ID.
     """
 
     name: str
     """
-    Namespace name
+    Namespace name.
     """
 
     endpoint: str
     """
-    Endpoint of the service matching the Namespace protocol
+    Endpoint of the service matching the namespace's protocol.
     """
 
     protocol: NamespaceProtocol
     """
-    Namespace protocol
+    Namespace protocol.
     """
 
     project_id: str
     """
-    Project containing the Namespace
+    Project ID of the Project containing the namespace.
     """
 
     region: Region
     """
-    Region where the Namespace is deployed
+    Region where the namespace is deployed.
     """
 
     created_at: Optional[datetime]
     """
-    Namespace creation date
+    Namespace creation date.
     """
 
     updated_at: Optional[datetime]
     """
-    Namespace last modification date
+    Namespace last modification date.
     """
 
 
 @dataclass
 class Permissions:
     """
-    Permissions
+    Permissions.
     """
 
     can_publish: Optional[bool]
     """
-    Defines if user can publish messages to the service
+    Defines whether the credentials bearer can publish messages to the service (send messages to SQS queues or publish to SNS topics).
     """
 
     can_receive: Optional[bool]
     """
-    Defines if user can receive messages from the service
+    Defines whether the credentials bearer can receive messages from the service.
     """
 
     can_manage: Optional[bool]
     """
-    Defines if user can manage the associated resource(s)
+    Defines whether the credentials bearer can manage the associated resources (SQS queues or SNS topics or subscriptions).
     """
 
 
 @dataclass
 class ListNamespacesRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     organization_id: Optional[str]
     """
-    Will list only the Namespaces owned by the specified organization
+    Include only namespaces in this Organization.
     """
 
     project_id: Optional[str]
     """
-    Will list only the Namespaces contained into the specified project
+    Include only namespaces in this Project.
     """
 
     page: Optional[int]
     """
-    Indicate the page number of results to be returned
+    Page number to return.
     """
 
     page_size: Optional[int]
     """
-    Maximum number of results returned by page
+    Maximum number of namespaces to return per page.
     """
 
     order_by: Optional[ListNamespacesRequestOrderBy]
     """
-    Field used for sorting results
+    Order in which to return results.
     """
 
 
 @dataclass
 class CreateNamespaceRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     name: Optional[str]
     """
-    Namespace name
+    Namespace name.
     """
 
     protocol: Optional[NamespaceProtocol]
     """
-    Namespace protocol
+    Namespace protocol. You must specify a valid protocol (and not `unknown`) to avoid an error.
     """
 
     project_id: Optional[str]
     """
-    Project containing the Namespace
+    Project containing the Namespace.
     """
 
 
 @dataclass
 class UpdateNamespaceRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     namespace_id: str
     """
-    ID of the Namespace to update
+    ID of the Namespace to update.
     """
 
     name: Optional[str]
     """
-    Namespace name
+    Namespace name.
     """
 
 
 @dataclass
 class GetNamespaceRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     namespace_id: str
     """
-    ID of the Namespace to get
+    ID of the Namespace to get.
     """
 
 
 @dataclass
 class DeleteNamespaceRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     namespace_id: str
     """
-    ID of the Namespace to delete
+    ID of the namespace to delete.
     """
 
 
 @dataclass
 class CreateCredentialRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     namespace_id: str
     """
-    Namespace containing the Credential
+    Namespace containing the credentials.
     """
 
     name: Optional[str]
     """
-    Credential name
+    Name of the credentials.
     """
 
     permissions: Optional[Permissions]
     """
-    List of permissions associated to this Credential.
-    
-    One-of ('optional_permissions'): at most one of 'permissions' could be set.
+    Permissions associated with these credentials.
     """
 
 
 @dataclass
 class DeleteCredentialRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     credential_id: str
     """
-    ID of the Credential to delete
+    ID of the credentials to delete.
     """
 
 
 @dataclass
 class ListCredentialsRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     namespace_id: Optional[str]
     """
-    Namespace containing the Credential
+    Namespace containing the credentials.
     """
 
     page: Optional[int]
     """
-    Indicate the page number of results to be returned
+    Page number to return.
     """
 
     page_size: Optional[int]
     """
-    Maximum number of results returned by page
+    Maximum number of credentials to return per page.
     """
 
     order_by: Optional[ListCredentialsRequestOrderBy]
     """
-    Field used for sorting results
+    Order in which to return results.
     """
 
 
 @dataclass
 class UpdateCredentialRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     credential_id: str
     """
-    ID of the Credential to update
+    ID of the credentials to update.
     """
 
     name: Optional[str]
     """
-    Credential name
+    Name of the credentials.
     """
 
     permissions: Optional[Permissions]
     """
-    List of permissions associated to this Credential.
-    
-    One-of ('optional_permissions'): at most one of 'permissions' could be set.
+    Permissions associated with these credentials.
     """
 
 
 @dataclass
 class GetCredentialRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     credential_id: str
     """
-    ID of the Credential to get
+    ID of the credentials to get.
     """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/rdb/v1/__init__.py` & `scaleway_async-1.0.0/scaleway_async/rdb/v1/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-0.9.0/scaleway_async/rdb/v1/api.py` & `scaleway_async-1.0.0/scaleway_async/rdb/v1/api.py`

 * *Files 13% similar despite different names*

```diff
@@ -153,31 +153,34 @@
     unmarshal_SetInstanceACLRulesResponse,
     unmarshal_SetInstanceSettingsResponse,
 )
 
 
 class RdbV1API(API):
     """
-    Database RDB API.
+    Managed Database for PostgreSQL and MySQL API.
+
+    Managed Database for PostgreSQL and MySQL API.
     """
 
     async def list_database_engines(
         self,
         *,
         region: Optional[Region] = None,
         name: Optional[str] = None,
         version: Optional[str] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListDatabaseEnginesResponse:
         """
-        List available database engines
+        List available database engines.
+        List the PostgreSQL and MySQL database engines available at Scaleway.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param name: Name of the Database Engine.
-        :param version: Version of the Database Engine.
+        :param name: Name of the database engine.
+        :param version: Version of the database engine.
         :param page:
         :param page_size:
         :return: :class:`ListDatabaseEnginesResponse <ListDatabaseEnginesResponse>`
 
         Usage:
         ::
 
@@ -208,18 +211,19 @@
         region: Optional[Region] = None,
         name: Optional[str] = None,
         version: Optional[str] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[DatabaseEngine]:
         """
-        List available database engines
+        List available database engines.
+        List the PostgreSQL and MySQL database engines available at Scaleway.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param name: Name of the Database Engine.
-        :param version: Version of the Database Engine.
+        :param name: Name of the database engine.
+        :param version: Version of the database engine.
         :param page:
         :param page_size:
         :return: :class:`List[ListDatabaseEnginesResponse] <List[ListDatabaseEnginesResponse]>`
 
         Usage:
         ::
 
@@ -244,17 +248,18 @@
         *,
         include_disabled_types: bool,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListNodeTypesResponse:
         """
-        List available node types
+        List available node types.
+        List all available node types. By default, the node types returned in the list are ordered by creation date in ascending order, though this can be modified via the `order_by` field.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param include_disabled_types: Whether or not to include disabled types.
+        :param include_disabled_types: Defines whether or not to include disabled types.
         :param page:
         :param page_size:
         :return: :class:`ListNodeTypesResponse <ListNodeTypesResponse>`
 
         Usage:
         ::
 
@@ -283,17 +288,18 @@
         *,
         include_disabled_types: bool,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[NodeType]:
         """
-        List available node types
+        List available node types.
+        List all available node types. By default, the node types returned in the list are ordered by creation date in ascending order, though this can be modified via the `order_by` field.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param include_disabled_types: Whether or not to include disabled types.
+        :param include_disabled_types: Defines whether or not to include disabled types.
         :param page:
         :param page_size:
         :return: :class:`List[ListNodeTypesResponse] <List[ListNodeTypesResponse]>`
 
         Usage:
         ::
 
@@ -321,21 +327,22 @@
         instance_id: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListDatabaseBackupsResponse:
         """
-        List database backups
+        List database backups.
+        List all backups in a specified region, for a given Scaleway Organization or Scaleway Project. By default, the backups listed are ordered by creation date in ascending order. This can be modified via the `order_by` field.
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: Name of the database backups.
         :param order_by: Criteria to use when ordering database backups listing.
-        :param instance_id: UUID of the instance.
-        :param organization_id: Organization ID the database backups belongs to.
-        :param project_id: Project ID the database backups belongs to.
+        :param instance_id: UUID of the Database Instance.
+        :param organization_id: Organization ID of the Organization the database backups belong to.
+        :param project_id: Project ID of the Project the database backups belong to.
         :param page:
         :param page_size:
         :return: :class:`ListDatabaseBackupsResponse <ListDatabaseBackupsResponse>`
 
         Usage:
         ::
 
@@ -373,21 +380,22 @@
         instance_id: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[DatabaseBackup]:
         """
-        List database backups
+        List database backups.
+        List all backups in a specified region, for a given Scaleway Organization or Scaleway Project. By default, the backups listed are ordered by creation date in ascending order. This can be modified via the `order_by` field.
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: Name of the database backups.
         :param order_by: Criteria to use when ordering database backups listing.
-        :param instance_id: UUID of the instance.
-        :param organization_id: Organization ID the database backups belongs to.
-        :param project_id: Project ID the database backups belongs to.
+        :param instance_id: UUID of the Database Instance.
+        :param organization_id: Organization ID of the Organization the database backups belong to.
+        :param project_id: Project ID of the Project the database backups belong to.
         :param page:
         :param page_size:
         :return: :class:`List[ListDatabaseBackupsResponse] <List[ListDatabaseBackupsResponse]>`
 
         Usage:
         ::
 
@@ -416,20 +424,21 @@
         instance_id: str,
         database_name: str,
         region: Optional[Region] = None,
         name: Optional[str] = None,
         expires_at: Optional[datetime] = None,
     ) -> DatabaseBackup:
         """
-        Create a database backup
+        Create a database backup.
+        Create a new backup. You must set the `instance_id`, `database_name`, `name` and `expires_at` parameters.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance.
-        :param database_name: Name of the database you want to make a backup of.
+        :param instance_id: UUID of the Database Instance.
+        :param database_name: Name of the database you want to back up.
         :param name: Name of the backup.
-        :param expires_at: Expiration date (Format ISO 8601).
+        :param expires_at: Expiration date (must follow the ISO 8601 format).
         :return: :class:`DatabaseBackup <DatabaseBackup>`
 
         Usage:
         ::
 
             result = await api.create_database_backup(
                 instance_id="example",
@@ -462,15 +471,16 @@
     async def get_database_backup(
         self,
         *,
         database_backup_id: str,
         region: Optional[Region] = None,
     ) -> DatabaseBackup:
         """
-        Get a database backup
+        Get a database backup.
+        Retrieve information about a given backup, specified by its database backup ID and region. Full details about the backup, like size, URL and expiration date, are returned in the response.
         :param region: Region to target. If none is passed will use default region from the config.
         :param database_backup_id: UUID of the database backup.
         :return: :class:`DatabaseBackup <DatabaseBackup>`
 
         Usage:
         ::
 
@@ -536,19 +546,20 @@
         *,
         database_backup_id: str,
         region: Optional[Region] = None,
         name: Optional[str] = None,
         expires_at: Optional[datetime] = None,
     ) -> DatabaseBackup:
         """
-        Update a database backup
+        Update a database backup.
+        Update the parameters of a backup, including name and expiration date.
         :param region: Region to target. If none is passed will use default region from the config.
         :param database_backup_id: UUID of the database backup to update.
         :param name: Name of the Database Backup.
-        :param expires_at: Expiration date (Format ISO 8601).
+        :param expires_at: Expiration date (must follow the ISO 8601 format).
         :return: :class:`DatabaseBackup <DatabaseBackup>`
 
         Usage:
         ::
 
             result = await api.update_database_backup(database_backup_id="example")
         """
@@ -580,15 +591,16 @@
     async def delete_database_backup(
         self,
         *,
         database_backup_id: str,
         region: Optional[Region] = None,
     ) -> DatabaseBackup:
         """
-        Delete a database backup
+        Delete a database backup.
+        Delete a backup, specified by its database backup ID and region. Deleting a backup is permanent, and cannot be undone.
         :param region: Region to target. If none is passed will use default region from the config.
         :param database_backup_id: UUID of the database backup to delete.
         :return: :class:`DatabaseBackup <DatabaseBackup>`
 
         Usage:
         ::
 
@@ -615,19 +627,20 @@
         *,
         database_backup_id: str,
         instance_id: str,
         region: Optional[Region] = None,
         database_name: Optional[str] = None,
     ) -> DatabaseBackup:
         """
-        Restore a database backup
+        Restore a database backup.
+        Launch the process of restoring database backup. You must specify the `instance_id` of the Database Instance of destination, where the backup will be restored. Note that large database backups can take up to several hours to restore.
         :param region: Region to target. If none is passed will use default region from the config.
         :param database_backup_id: Backup of a logical database.
-        :param database_name: Defines the destination database in order to restore into a specified database, the default destination is set to the origin database of the backup.
-        :param instance_id: Defines the rdb instance where the backup has to be restored.
+        :param database_name: Defines the destination database to restore into a specified database (the default destination is set to the origin database of the backup).
+        :param instance_id: Defines the Database Instance where the backup has to be restored.
         :return: :class:`DatabaseBackup <DatabaseBackup>`
 
         Usage:
         ::
 
             result = await api.restore_database_backup(
                 database_backup_id="example",
@@ -662,15 +675,16 @@
     async def export_database_backup(
         self,
         *,
         database_backup_id: str,
         region: Optional[Region] = None,
     ) -> DatabaseBackup:
         """
-        Export a database backup
+        Export a database backup.
+        Export a backup, specified by the `database_backup_id` and the `region` parameters. The download URL is returned in the response.
         :param region: Region to target. If none is passed will use default region from the config.
         :param database_backup_id: UUID of the database backup you want to export.
         :return: :class:`DatabaseBackup <DatabaseBackup>`
 
         Usage:
         ::
 
@@ -700,30 +714,32 @@
         node_type: Optional[str] = None,
         enable_ha: Optional[bool] = None,
         volume_size: Optional[int] = None,
         volume_type: Optional[VolumeType] = None,
         upgradable_version_id: Optional[str] = None,
     ) -> Instance:
         """
-        Upgrade your current instance specifications like node type, high availability, volume, or db engine version.
+        Upgrade a Database Instance.
+        Upgrade your current Database Instance specifications like node type, high availability, volume, or the database engine version. Note that upon upgrade the `enable_ha` parameter can only be set to `true`.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance you want to upgrade.
-        :param node_type: Node type of the instance you want to upgrade to.
+        :param instance_id: UUID of the Database Instance you want to upgrade.
+        :param node_type: Node type of the Database Instance you want to upgrade to.
 
         One-of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id' could be set.
-        :param enable_ha: Set to true to enable high availability on your instance.
+        :param enable_ha: Defines whether or not high availability should be enabled on the Database Instance.
 
         One-of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id' could be set.
         :param volume_size: Increase your block storage volume size.
 
         One-of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id' could be set.
-        :param volume_type: Change your instance storage type.
+        :param volume_type: Change your Database Instance storage type.
 
         One-of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id' could be set.
-        :param upgradable_version_id: This will create a new Database Instance with same instance specification as the current one and perform a Database Engine upgrade.
+        :param upgradable_version_id: Update your database engine to a newer version.
+        This will create a new Database Instance with same specifications as the current one and perform a Database Engine upgrade.
 
         One-of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id' could be set.
         :return: :class:`Instance <Instance>`
 
         Usage:
         ::
 
@@ -764,21 +780,22 @@
         order_by: ListInstancesRequestOrderBy = ListInstancesRequestOrderBy.CREATED_AT_ASC,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListInstancesResponse:
         """
-        List instances
+        List Database Instances.
+        List all Database Instances in the specified region, for a given Scaleway Organization or Scaleway Project. By default, the Database Instances returned in the list are ordered by creation date in ascending order, though this can be modified via the order_by field. You can define additional parameters for your query, such as `tags` and `name`. For the `name` parameter, the value you include will be checked against the whole name string to see if it includes the string you put in the parameter.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param tags: List instance that have a given tags.
-        :param name: List instance that match a given name pattern.
-        :param order_by: Criteria to use when ordering instance listing.
-        :param organization_id: Please use `project_id` instead.
-        :param project_id: Project ID to list the instance of.
+        :param tags: List Database Instances that have a given tag.
+        :param name: Lists Database Instances that match a name pattern.
+        :param order_by: Criteria to use when ordering Database Instance listings.
+        :param organization_id: Please use project_id instead.
+        :param project_id: Project ID to list the Database Instance of.
         :param page:
         :param page_size:
         :return: :class:`ListInstancesResponse <ListInstancesResponse>`
 
         Usage:
         ::
 
@@ -816,21 +833,22 @@
         order_by: Optional[ListInstancesRequestOrderBy] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[Instance]:
         """
-        List instances
+        List Database Instances.
+        List all Database Instances in the specified region, for a given Scaleway Organization or Scaleway Project. By default, the Database Instances returned in the list are ordered by creation date in ascending order, though this can be modified via the order_by field. You can define additional parameters for your query, such as `tags` and `name`. For the `name` parameter, the value you include will be checked against the whole name string to see if it includes the string you put in the parameter.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param tags: List instance that have a given tags.
-        :param name: List instance that match a given name pattern.
-        :param order_by: Criteria to use when ordering instance listing.
-        :param organization_id: Please use `project_id` instead.
-        :param project_id: Project ID to list the instance of.
+        :param tags: List Database Instances that have a given tag.
+        :param name: Lists Database Instances that match a name pattern.
+        :param order_by: Criteria to use when ordering Database Instance listings.
+        :param organization_id: Please use project_id instead.
+        :param project_id: Project ID to list the Database Instance of.
         :param page:
         :param page_size:
         :return: :class:`List[ListInstancesResponse] <List[ListInstancesResponse]>`
 
         Usage:
         ::
 
@@ -856,17 +874,18 @@
     async def get_instance(
         self,
         *,
         instance_id: str,
         region: Optional[Region] = None,
     ) -> Instance:
         """
-        Get an instance
+        Get a Database Instance.
+        Retrieve information about a given Database Instance, specified by the `region` and `instance_id` parameters. Its full details, including name, status, IP address and port, are returned in the response object.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance.
+        :param instance_id: UUID of the Database Instance.
         :return: :class:`Instance <Instance>`
 
         Usage:
         ::
 
             result = await api.get_instance(instance_id="example")
         """
@@ -892,15 +911,15 @@
         options: Optional[
             WaitForOptions[Instance, Union[bool, Awaitable[bool]]]
         ] = None,
     ) -> Instance:
         """
         Waits for :class:`Instance <Instance>` to be in a final state.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance.
+        :param instance_id: UUID of the Database Instance.
         :param options: The options for the waiter
         :return: :class:`Instance <Instance>`
 
         Usage:
         ::
 
             result = api.wait_for_instance(instance_id="example")
@@ -938,35 +957,36 @@
         project_id: Optional[str] = None,
         name: Optional[str] = None,
         tags: Optional[List[str]] = None,
         init_settings: Optional[List[InstanceSetting]] = None,
         init_endpoints: Optional[List[EndpointSpec]] = None,
     ) -> Instance:
         """
-        Create an instance
+        Create a Database Instance.
+        Create a new Database Instance. You must set the `engine`, `user_name`, `password` and `node_type` parameters. Optionally, you can specify the volume type and size.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param organization_id: Please use `project_id` instead.
+        :param organization_id: Please use project_id instead.
 
         One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
-        :param project_id: The project ID on which to create the instance.
+        :param project_id: The Project ID on which the Database Instance will be created.
 
         One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
-        :param name: Name of the instance.
-        :param engine: Database engine of the database (PostgreSQL, MySQL, ...).
-        :param user_name: Name of the user created when the instance is created.
+        :param name: Name of the Database Instance.
+        :param engine: Database engine of the Database Instance (PostgreSQL, MySQL, ...).
+        :param user_name: Username created when the Database Instance is created.
         :param password: Password of the user.
-        :param node_type: Type of node to use for the instance.
-        :param is_ha_cluster: Whether or not High-Availability is enabled.
-        :param disable_backup: Whether or not backups are disabled.
-        :param tags: Tags to apply to the instance.
-        :param init_settings: List of engine settings to be set at database initialisation.
-        :param volume_type: Type of volume where data are stored (lssd, bssd, ...).
+        :param node_type: Type of node to use for the Database Instance.
+        :param is_ha_cluster: Defines whether or not High-Availability is enabled.
+        :param disable_backup: Defines whether or not backups are disabled.
+        :param tags: Tags to apply to the Database Instance.
+        :param init_settings: List of engine settings to be set upon Database Instance initialization.
+        :param volume_type: Type of volume where data is stored (lssd, bssd, ...).
         :param volume_size: Volume size when volume_type is not lssd.
-        :param init_endpoints: One or multiple EndpointSpec used to expose your database instance. A load_balancer public endpoint is systematically created.
-        :param backup_same_region: Store logical backups in the same region as the database instance.
+        :param init_endpoints: One or multiple EndpointSpec used to expose your Database Instance. A load_balancer public endpoint is systematically created.
+        :param backup_same_region: Defines whether to or not to store logical backups in the same region as the Database Instance.
         :return: :class:`Instance <Instance>`
 
         Usage:
         ::
 
             result = await api.create_instance(
                 engine="example",
@@ -1022,26 +1042,29 @@
         backup_schedule_frequency: Optional[int] = None,
         backup_schedule_retention: Optional[int] = None,
         is_backup_schedule_disabled: Optional[bool] = None,
         name: Optional[str] = None,
         tags: Optional[List[str]] = None,
         logs_policy: Optional[LogsPolicy] = None,
         backup_same_region: Optional[bool] = None,
+        backup_schedule_start_hour: Optional[int] = None,
     ) -> Instance:
         """
-        Update an instance
+        Update a Database Instance.
+        Update the parameters of a Database Instance, including name, tags and backup schedule details.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance to update.
+        :param instance_id: UUID of the Database Instance to update.
         :param backup_schedule_frequency: In hours.
         :param backup_schedule_retention: In days.
-        :param is_backup_schedule_disabled: Whether or not the backup schedule is disabled.
-        :param name: Name of the instance.
-        :param tags: Tags of a given instance.
-        :param logs_policy: Logs policy of the instance.
-        :param backup_same_region: Store logical backups in the same region as the database instance.
+        :param is_backup_schedule_disabled: Defines whether or not the backup schedule is disabled.
+        :param name: Name of the Database Instance.
+        :param tags: Tags of a Database Instance.
+        :param logs_policy: Logs policy of the Database Instance.
+        :param backup_same_region: Store logical backups in the same region as the Database Instance.
+        :param backup_schedule_start_hour: Defines the start time of the autobackup.
         :return: :class:`Instance <Instance>`
 
         Usage:
         ::
 
             result = await api.update_instance(instance_id="example")
         """
@@ -1061,14 +1084,15 @@
                     backup_schedule_frequency=backup_schedule_frequency,
                     backup_schedule_retention=backup_schedule_retention,
                     is_backup_schedule_disabled=is_backup_schedule_disabled,
                     name=name,
                     tags=tags,
                     logs_policy=logs_policy,
                     backup_same_region=backup_same_region,
+                    backup_schedule_start_hour=backup_schedule_start_hour,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_Instance(res.json())
@@ -1076,17 +1100,18 @@
     async def delete_instance(
         self,
         *,
         instance_id: str,
         region: Optional[Region] = None,
     ) -> Instance:
         """
-        Delete an instance
+        Delete a Database Instance.
+        Delete a given Database Instance, specified by the `region` and `instance_id` parameters. Deleting a Database Instance is permanent, and cannot be undone. Note that upon deletion all your data will be lost.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance to delete.
+        :param instance_id: UUID of the Database Instance to delete.
         :return: :class:`Instance <Instance>`
 
         Usage:
         ::
 
             result = await api.delete_instance(instance_id="example")
         """
@@ -1109,18 +1134,19 @@
         *,
         instance_id: str,
         name: str,
         region: Optional[Region] = None,
         node_type: Optional[str] = None,
     ) -> Instance:
         """
-        Clone an instance
+        Clone a Database Instance.
+        Clone a given Database Instance, specified by the `region` and `instance_id` parameters. The clone feature allows you to create a new Database Instance from an existing one. The clone includes all existing databases, users and permissions. You can create a clone on a Database Instance bigger than your current one.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance you want to clone.
-        :param name: Name of the clone instance.
+        :param instance_id: UUID of the Database Instance you want to clone.
+        :param name: Name of the Database Instance clone.
         :param node_type: Node type of the clone.
         :return: :class:`Instance <Instance>`
 
         Usage:
         ::
 
             result = await api.clone_instance(
@@ -1154,17 +1180,18 @@
     async def restart_instance(
         self,
         *,
         instance_id: str,
         region: Optional[Region] = None,
     ) -> Instance:
         """
-        Restart an instance
+        Restart Database Instance.
+        Restart a given Database Instance, specified by the `region` and `instance_id` parameters. The status of the Database Instance returned in the response.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance you want to restart.
+        :param instance_id: UUID of the Database Instance you want to restart.
         :return: :class:`Instance <Instance>`
 
         Usage:
         ::
 
             result = await api.restart_instance(instance_id="example")
         """
@@ -1185,17 +1212,18 @@
     async def get_instance_certificate(
         self,
         *,
         instance_id: str,
         region: Optional[Region] = None,
     ) -> Optional[ScwFile]:
         """
-        Get the TLS certificate of an instance
+        Get the TLS certificate of a Database Instance.
+        Retrieve information about the TLS certificate of a given Database Instance. Details like name and content are returned in the response.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance.
+        :param instance_id: UUID of the Database Instance.
         :return: :class:`Optional[ScwFile] <Optional[ScwFile]>`
 
         Usage:
         ::
 
             result = await api.get_instance_certificate(instance_id="example")
         """
@@ -1217,17 +1245,18 @@
     async def renew_instance_certificate(
         self,
         *,
         instance_id: str,
         region: Optional[Region] = None,
     ) -> Optional[None]:
         """
-        Renew the TLS certificate of an instance
+        Renew the TLS certificate of a Database Instance.
+        Renew a TLS for a Database Instance. Renewing a certificate means that you will not be able to connect to your Database Instance using the previous certificate. You will also need to download and update the new certificate for all database clients.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance you want logs of.
+        :param instance_id: UUID of the Database Instance you want logs of.
 
         Usage:
         ::
 
             result = await api.renew_instance_certificate(instance_id="example")
         """
 
@@ -1250,17 +1279,18 @@
         instance_id: str,
         region: Optional[Region] = None,
         start_date: Optional[datetime] = None,
         end_date: Optional[datetime] = None,
         metric_name: Optional[str] = None,
     ) -> InstanceMetrics:
         """
-        Get database instance metrics.
+        Get Database Instance metrics.
+        Retrieve the time series metrics of a given Database Instance. You can define the period from which to retrieve metrics by specifying the `start_date` and `end_date`.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance.
+        :param instance_id: UUID of the Database Instance.
         :param start_date: Start date to gather metrics from.
         :param end_date: End date to gather metrics from.
         :param metric_name: Name of the metric to gather.
         :return: :class:`InstanceMetrics <InstanceMetrics>`
 
         Usage:
         ::
@@ -1288,20 +1318,23 @@
 
     async def create_read_replica(
         self,
         *,
         instance_id: str,
         region: Optional[Region] = None,
         endpoint_spec: Optional[List[ReadReplicaEndpointSpec]] = None,
+        same_zone: Optional[bool] = None,
     ) -> ReadReplica:
         """
-        You can only create a maximum of 3 read replicas for one instance.
+        Create a Read Replica.
+        Create a new Read Replica of a Database Instance. You must specify the `region` and the `instance_id`. You can only create a maximum of 3 Read Replicas per Database Instance.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance you want a read replica of.
+        :param instance_id: UUID of the Database Instance you want to create a Read Replica from.
         :param endpoint_spec: Specification of the endpoint you want to create.
+        :param same_zone: Defines whether to create the replica in the same availability zone as the main instance nodes or not.
         :return: :class:`ReadReplica <ReadReplica>`
 
         Usage:
         ::
 
             result = await api.create_read_replica(instance_id="example")
         """
@@ -1314,14 +1347,15 @@
             "POST",
             f"/rdb/v1/regions/{param_region}/read-replicas",
             body=marshal_CreateReadReplicaRequest(
                 CreateReadReplicaRequest(
                     instance_id=instance_id,
                     region=region,
                     endpoint_spec=endpoint_spec,
+                    same_zone=same_zone,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
         return unmarshal_ReadReplica(res.json())
@@ -1329,17 +1363,18 @@
     async def get_read_replica(
         self,
         *,
         read_replica_id: str,
         region: Optional[Region] = None,
     ) -> ReadReplica:
         """
-        Get a read replica
+        Get a Read Replica.
+        Retrieve information about a Database Instance Read Replica. Full details about the Read Replica, like `endpoints`, `status`  and `region` are returned in the response.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param read_replica_id: UUID of the read replica.
+        :param read_replica_id: UUID of the Read Replica.
         :return: :class:`ReadReplica <ReadReplica>`
 
         Usage:
         ::
 
             result = await api.get_read_replica(read_replica_id="example")
         """
@@ -1365,15 +1400,15 @@
         options: Optional[
             WaitForOptions[ReadReplica, Union[bool, Awaitable[bool]]]
         ] = None,
     ) -> ReadReplica:
         """
         Waits for :class:`ReadReplica <ReadReplica>` to be in a final state.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param read_replica_id: UUID of the read replica.
+        :param read_replica_id: UUID of the Read Replica.
         :param options: The options for the waiter
         :return: :class:`ReadReplica <ReadReplica>`
 
         Usage:
         ::
 
             result = api.wait_for_read_replica(read_replica_id="example")
@@ -1397,17 +1432,18 @@
     async def delete_read_replica(
         self,
         *,
         read_replica_id: str,
         region: Optional[Region] = None,
     ) -> ReadReplica:
         """
-        Delete a read replica
+        Delete a Read Replica.
+        Delete a Read Replica of a Database Instance. You must specify the `region` and `read_replica_id` parameters of the Read Replica you want to delete.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param read_replica_id: UUID of the read replica.
+        :param read_replica_id: UUID of the Read Replica.
         :return: :class:`ReadReplica <ReadReplica>`
 
         Usage:
         ::
 
             result = await api.delete_read_replica(read_replica_id="example")
         """
@@ -1428,20 +1464,19 @@
     async def reset_read_replica(
         self,
         *,
         read_replica_id: str,
         region: Optional[Region] = None,
     ) -> ReadReplica:
         """
-        When you resync a read replica, first it is reset, and then its data is resynchronized from the primary node.
-        Your read replica will be unavailable during the resync process. The duration of this process is proportional to your Database Instance size.
-        The configured endpoints will not change.
-
+        Resync a Read Replica.
+        When you resync a Read Replica, first it is reset, then its data is resynchronized from the primary node. Your Read Replica remains unavailable during the resync process. The duration of this process is proportional to the size of your Database Instance.
+        The configured endpoints do not change.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param read_replica_id: UUID of the read replica.
+        :param read_replica_id: UUID of the Read Replica.
         :return: :class:`ReadReplica <ReadReplica>`
 
         Usage:
         ::
 
             result = await api.reset_read_replica(read_replica_id="example")
         """
@@ -1455,25 +1490,58 @@
             "POST",
             f"/rdb/v1/regions/{param_region}/read-replicas/{param_read_replica_id}/reset",
         )
 
         self._throw_on_error(res)
         return unmarshal_ReadReplica(res.json())
 
+    async def promote_read_replica(
+        self,
+        *,
+        read_replica_id: str,
+        region: Optional[Region] = None,
+    ) -> Instance:
+        """
+        Promote a Read Replica.
+        Promote a Read Replica to Database Instance automatically.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param read_replica_id: UUID of the Read Replica.
+        :return: :class:`Instance <Instance>`
+
+        Usage:
+        ::
+
+            result = await api.promote_read_replica(read_replica_id="example")
+        """
+
+        param_region = validate_path_param(
+            "region", region or self.client.default_region
+        )
+        param_read_replica_id = validate_path_param("read_replica_id", read_replica_id)
+
+        res = self._request(
+            "POST",
+            f"/rdb/v1/regions/{param_region}/read-replicas/{param_read_replica_id}/promote",
+        )
+
+        self._throw_on_error(res)
+        return unmarshal_Instance(res.json())
+
     async def create_read_replica_endpoint(
         self,
         *,
         read_replica_id: str,
         endpoint_spec: List[ReadReplicaEndpointSpec],
         region: Optional[Region] = None,
     ) -> ReadReplica:
         """
-        A read replica can have at most one direct access and one private network endpoint.
+        Create an endpoint for a Read Replica.
+        Create a new endpoint for a Read Replica. Read Replicas can have at most one direct access and one Private Network endpoint.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param read_replica_id: UUID of the read replica.
+        :param read_replica_id: UUID of the Read Replica.
         :param endpoint_spec: Specification of the endpoint you want to create.
         :return: :class:`ReadReplica <ReadReplica>`
 
         Usage:
         ::
 
             result = await api.create_read_replica_endpoint(
@@ -1508,19 +1576,20 @@
         *,
         instance_id: str,
         region: Optional[Region] = None,
         start_date: Optional[datetime] = None,
         end_date: Optional[datetime] = None,
     ) -> PrepareInstanceLogsResponse:
         """
-        Prepare your instance logs. Logs will be grouped on a minimum interval of a day.
+        Prepare logs of a Database Instance.
+        Prepare your Database Instance logs. You can define the `start_date` and `end_date` parameters for your query. The download URL is returned in the response. Logs are recorded from 00h00 to 23h59 and then aggregated in a `.log` file once a day. Therefore, even if you specify a timeframe from which you want to get the logs, you will receive logs from the full 24 hours.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance you want logs of.
-        :param start_date: Start datetime of your log. Format: `{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z`.
-        :param end_date: End datetime of your log. Format: `{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z`.
+        :param instance_id: UUID of the Database Instance you want logs of.
+        :param start_date: Start datetime of your log. (RFC 3339 format).
+        :param end_date: End datetime of your log. (RFC 3339 format).
         :return: :class:`PrepareInstanceLogsResponse <PrepareInstanceLogsResponse>`
 
         Usage:
         ::
 
             result = await api.prepare_instance_logs(instance_id="example")
         """
@@ -1551,18 +1620,19 @@
         self,
         *,
         instance_id: str,
         order_by: ListInstanceLogsRequestOrderBy,
         region: Optional[Region] = None,
     ) -> ListInstanceLogsResponse:
         """
-        List available logs of a given instance
+        List available logs of a Database Instance.
+        List the available logs of a Database Instance. By default, the logs returned in the list are ordered by creation date in ascending order, though this can be modified via the order_by field.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance you want logs of.
-        :param order_by: Criteria to use when ordering instance logs listing.
+        :param instance_id: UUID of the Database Instance you want logs of.
+        :param order_by: Criteria to use when ordering Database Instance logs listing.
         :return: :class:`ListInstanceLogsResponse <ListInstanceLogsResponse>`
 
         Usage:
         ::
 
             result = await api.list_instance_logs(
                 instance_id="example",
@@ -1589,15 +1659,16 @@
     async def get_instance_log(
         self,
         *,
         instance_log_id: str,
         region: Optional[Region] = None,
     ) -> InstanceLog:
         """
-        Get specific logs of a given instance
+        Get given logs of a Database Instance.
+        Retrieve information about the logs of a Database Instance. Specify the `instance_log_id` and `region` in your request to get information such as `download_url`, `status`, `expires_at` and `created_at` about your logs in the response.
         :param region: Region to target. If none is passed will use default region from the config.
         :param instance_log_id: UUID of the instance_log you want.
         :return: :class:`InstanceLog <InstanceLog>`
 
         Usage:
         ::
 
@@ -1658,18 +1729,19 @@
         self,
         *,
         instance_id: str,
         region: Optional[Region] = None,
         log_name: Optional[str] = None,
     ) -> Optional[None]:
         """
-        purge remote instances logs
+        Purge remote Database Instance logs.
+        Purge a given remote log from a Database Instance. You can specify the `log_name` of the log you wish to clean from your Database Instance.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance you want logs of.
-        :param log_name: Specific log name to purge.
+        :param instance_id: UUID of the Database Instance you want logs of.
+        :param log_name: Given log name to purge.
 
         Usage:
         ::
 
             result = await api.purge_instance_logs(instance_id="example")
         """
 
@@ -1697,17 +1769,18 @@
     async def list_instance_logs_details(
         self,
         *,
         instance_id: str,
         region: Optional[Region] = None,
     ) -> ListInstanceLogsDetailsResponse:
         """
-        List remote instances logs details
+        List remote Database Instance logs details.
+        List remote log details. By default, the details returned in the list are ordered by creation date in ascending order, though this can be modified via the order_by field.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance you want logs of.
+        :param instance_id: UUID of the Database Instance you want logs of.
         :return: :class:`ListInstanceLogsDetailsResponse <ListInstanceLogsDetailsResponse>`
 
         Usage:
         ::
 
             result = await api.list_instance_logs_details(instance_id="example")
         """
@@ -1729,18 +1802,19 @@
         self,
         *,
         instance_id: str,
         settings: List[InstanceSetting],
         region: Optional[Region] = None,
     ) -> AddInstanceSettingsResponse:
         """
-        Add an instance setting
+        Add Database Instance advanced settings.
+        Add an advanced setting to a Database Instance. You must set the `name` and the `value` of each setting.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance you want to add settings to.
-        :param settings: Settings to add on the instance.
+        :param instance_id: UUID of the Database Instance you want to add settings to.
+        :param settings: Settings to add to the Database Instance.
         :return: :class:`AddInstanceSettingsResponse <AddInstanceSettingsResponse>`
 
         Usage:
         ::
 
             result = await api.add_instance_settings(
                 instance_id="example",
@@ -1773,17 +1847,18 @@
         self,
         *,
         instance_id: str,
         setting_names: List[str],
         region: Optional[Region] = None,
     ) -> DeleteInstanceSettingsResponse:
         """
-        Delete an instance setting
+        Delete Database Instance advanced settings.
+        Delete an advanced setting in a Database Instance. You must specify the names of the settings you want to delete in the request.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance to delete settings from.
+        :param instance_id: UUID of the Database Instance to delete settings from.
         :param setting_names: Settings names to delete.
         :return: :class:`DeleteInstanceSettingsResponse <DeleteInstanceSettingsResponse>`
 
         Usage:
         ::
 
             result = await api.delete_instance_settings(
@@ -1817,18 +1892,19 @@
         self,
         *,
         instance_id: str,
         settings: List[InstanceSetting],
         region: Optional[Region] = None,
     ) -> SetInstanceSettingsResponse:
         """
-        Set a given instance setting
+        Set Database Instance advanced settings.
+        Update an advanced setting for a Database Instance. Settings added upon database engine initalization can only be defined once, and cannot, therefore, be updated.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance where the settings has to be set.
-        :param settings: Settings to define for the instance.
+        :param instance_id: UUID of the Database Instance where the settings must be set.
+        :param settings: Settings to define for the Database Instance.
         :return: :class:`SetInstanceSettingsResponse <SetInstanceSettingsResponse>`
 
         Usage:
         ::
 
             result = await api.set_instance_settings(
                 instance_id="example",
@@ -1862,17 +1938,18 @@
         *,
         instance_id: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListInstanceACLRulesResponse:
         """
-        List ACL rules of a given instance
+        List ACL rules of a Database Instance.
+        List the ACL rules for a given Database Instance. The response is an array of ACL objects, each one representing an ACL that denies, allows or redirects traffic based on certain conditions.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance.
+        :param instance_id: UUID of the Database Instance.
         :param page:
         :param page_size:
         :return: :class:`ListInstanceACLRulesResponse <ListInstanceACLRulesResponse>`
 
         Usage:
         ::
 
@@ -1901,17 +1978,18 @@
         *,
         instance_id: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[ACLRule]:
         """
-        List ACL rules of a given instance
+        List ACL rules of a Database Instance.
+        List the ACL rules for a given Database Instance. The response is an array of ACL objects, each one representing an ACL that denies, allows or redirects traffic based on certain conditions.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance.
+        :param instance_id: UUID of the Database Instance.
         :param page:
         :param page_size:
         :return: :class:`List[ListInstanceACLRulesResponse] <List[ListInstanceACLRulesResponse]>`
 
         Usage:
         ::
 
@@ -1934,18 +2012,19 @@
         self,
         *,
         instance_id: str,
         rules: List[ACLRuleRequest],
         region: Optional[Region] = None,
     ) -> AddInstanceACLRulesResponse:
         """
-        Add an additional ACL rule to a database instance.
+        Add an ACL rule to a Database Instance.
+        Add an additional ACL rule to a Database Instance.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance you want to add acl rules to.
-        :param rules: ACLs rules to add to the instance.
+        :param instance_id: UUID of the Database Instance you want to add ACL rules to.
+        :param rules: ACL rules to add to the Database Instance.
         :return: :class:`AddInstanceACLRulesResponse <AddInstanceACLRulesResponse>`
 
         Usage:
         ::
 
             result = await api.add_instance_acl_rules(
                 instance_id="example",
@@ -1978,18 +2057,19 @@
         self,
         *,
         instance_id: str,
         rules: List[ACLRuleRequest],
         region: Optional[Region] = None,
     ) -> SetInstanceACLRulesResponse:
         """
-        Replace all the ACL rules of a database instance.
+        Set ACL rules for a Database Instance.
+        Replace all the ACL rules of a Database Instance.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance where the ACL rules has to be set.
-        :param rules: ACL rules to define for the instance.
+        :param instance_id: UUID of the Database Instance where the ACL rules must be set.
+        :param rules: ACL rules to define for the Database Instance.
         :return: :class:`SetInstanceACLRulesResponse <SetInstanceACLRulesResponse>`
 
         Usage:
         ::
 
             result = await api.set_instance_acl_rules(
                 instance_id="example",
@@ -2022,18 +2102,19 @@
         self,
         *,
         instance_id: str,
         acl_rule_ips: List[str],
         region: Optional[Region] = None,
     ) -> DeleteInstanceACLRulesResponse:
         """
-        Delete ACL rules of a given instance
+        Delete ACL rules of a Database Instance.
+        Delete one or more ACL rules of a Database Instance.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance you want to delete an ACL rules from.
-        :param acl_rule_ips: ACL rules IP present on the instance.
+        :param instance_id: UUID of the Database Instance you want to delete an ACL rule from.
+        :param acl_rule_ips: IP addresses defined in the ACL rules of the Database Instance.
         :return: :class:`DeleteInstanceACLRulesResponse <DeleteInstanceACLRulesResponse>`
 
         Usage:
         ::
 
             result = await api.delete_instance_acl_rules(
                 instance_id="example",
@@ -2069,19 +2150,20 @@
         region: Optional[Region] = None,
         name: Optional[str] = None,
         order_by: ListUsersRequestOrderBy = ListUsersRequestOrderBy.NAME_ASC,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListUsersResponse:
         """
-        List users of a given instance
+        List users of a Database Instance.
+        List all users of a given Database Instance. By default, the users returned in the list are ordered by creation date in ascending order, though this can be modified via the order_by field.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance.
+        :param instance_id: UUID of the Database Instance.
         :param name: Name of the user.
-        :param order_by: Criteria to use when ordering users listing.
+        :param order_by: Criteria to use when requesting user listing.
         :param page:
         :param page_size:
         :return: :class:`ListUsersResponse <ListUsersResponse>`
 
         Usage:
         ::
 
@@ -2114,19 +2196,20 @@
         region: Optional[Region] = None,
         name: Optional[str] = None,
         order_by: Optional[ListUsersRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[User]:
         """
-        List users of a given instance
+        List users of a Database Instance.
+        List all users of a given Database Instance. By default, the users returned in the list are ordered by creation date in ascending order, though this can be modified via the order_by field.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance.
+        :param instance_id: UUID of the Database Instance.
         :param name: Name of the user.
-        :param order_by: Criteria to use when ordering users listing.
+        :param order_by: Criteria to use when requesting user listing.
         :param page:
         :param page_size:
         :return: :class:`List[ListUsersResponse] <List[ListUsersResponse]>`
 
         Usage:
         ::
 
@@ -2153,20 +2236,21 @@
         instance_id: str,
         name: str,
         password: str,
         is_admin: bool,
         region: Optional[Region] = None,
     ) -> User:
         """
-        Create a user on a given instance
+        Create a user for a Database Instance.
+        Create a new user for a Database Instance. You must define the `name`, `password` and `is_admin` parameters.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance you want to create a user in.
+        :param instance_id: UUID of the Database Instance in which you want to create a user.
         :param name: Name of the user you want to create.
         :param password: Password of the user you want to create.
-        :param is_admin: Whether the user you want to create will have administrative privileges.
+        :param is_admin: Defines whether the user will have administrative privileges.
         :return: :class:`User <User>`
 
         Usage:
         ::
 
             result = await api.create_user(
                 instance_id="example",
@@ -2205,20 +2289,21 @@
         instance_id: str,
         name: str,
         region: Optional[Region] = None,
         password: Optional[str] = None,
         is_admin: Optional[bool] = None,
     ) -> User:
         """
-        Update a user on a given instance
+        Update a user on a Database Instance.
+        Update the parameters of a user on a Database Instance. You can update the `password` and `is_admin` parameters, but you cannot change the name of the user.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance the user belongs to.
+        :param instance_id: UUID of the Database Instance the user belongs to.
         :param name: Name of the database user.
         :param password: Password of the database user.
-        :param is_admin: Whether or not this user got administrative privileges.
+        :param is_admin: Defines whether or not this user got administrative privileges.
         :return: :class:`User <User>`
 
         Usage:
         ::
 
             result = await api.update_user(
                 instance_id="example",
@@ -2254,17 +2339,18 @@
         self,
         *,
         instance_id: str,
         name: str,
         region: Optional[Region] = None,
     ) -> Optional[None]:
         """
-        Delete a user on a given instance
+        Delete a user on a Database Instance.
+        Delete a given user on a Database Instance. You must specify, in the endpoint,  the `region`, `instance_id` and `name` parameters of the user you want to delete.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance to delete a user from.
+        :param instance_id: UUID of the Database Instance to delete the user from.
         :param name: Name of the user.
 
         Usage:
         ::
 
             result = await api.delete_user(
                 instance_id="example",
@@ -2295,19 +2381,20 @@
         managed: Optional[bool] = None,
         owner: Optional[str] = None,
         order_by: ListDatabasesRequestOrderBy = ListDatabasesRequestOrderBy.NAME_ASC,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListDatabasesResponse:
         """
-        List all database in a given instance
+        List databases in a Database Instance.
+        List all databases of a given Database Instance. By default, the databases returned in the list are ordered by creation date in ascending order, though this can be modified via the order_by field. You can define additional parameters for your query, such as `name`, `managed` and `owner`.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance to list database of.
+        :param instance_id: UUID of the Database Instance to list the databases of.
         :param name: Name of the database.
-        :param managed: Whether or not the database is managed.
+        :param managed: Defines whether or not the database is managed.
         :param owner: User that owns this database.
         :param order_by: Criteria to use when ordering database listing.
         :param page:
         :param page_size:
         :return: :class:`ListDatabasesResponse <ListDatabasesResponse>`
 
         Usage:
@@ -2346,19 +2433,20 @@
         managed: Optional[bool] = None,
         owner: Optional[str] = None,
         order_by: Optional[ListDatabasesRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[Database]:
         """
-        List all database in a given instance
+        List databases in a Database Instance.
+        List all databases of a given Database Instance. By default, the databases returned in the list are ordered by creation date in ascending order, though this can be modified via the order_by field. You can define additional parameters for your query, such as `name`, `managed` and `owner`.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance to list database of.
+        :param instance_id: UUID of the Database Instance to list the databases of.
         :param name: Name of the database.
-        :param managed: Whether or not the database is managed.
+        :param managed: Defines whether or not the database is managed.
         :param owner: User that owns this database.
         :param order_by: Criteria to use when ordering database listing.
         :param page:
         :param page_size:
         :return: :class:`List[ListDatabasesResponse] <List[ListDatabasesResponse]>`
 
         Usage:
@@ -2387,17 +2475,18 @@
         self,
         *,
         instance_id: str,
         name: str,
         region: Optional[Region] = None,
     ) -> Database:
         """
-        Create a database in a given instance
+        Create a database in a Database Instance.
+        Create a new database. You must define the `name` parameter in the request.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance where to create the database.
+        :param instance_id: UUID of the Database Instance where to create the database.
         :param name: Name of the database.
         :return: :class:`Database <Database>`
 
         Usage:
         ::
 
             result = await api.create_database(
@@ -2431,17 +2520,18 @@
         self,
         *,
         instance_id: str,
         name: str,
         region: Optional[Region] = None,
     ) -> Optional[None]:
         """
-        Delete a database in a given instance
+        Delete a database in a Database Instance.
+        Delete a given database on a Database Instance. You must specify, in the endpoint, the `region`, `instance_id` and `name` parameters of the database you want to delete.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance where to delete the database.
+        :param instance_id: UUID of the Database Instance where to delete the database.
         :param name: Name of the database to delete.
 
         Usage:
         ::
 
             result = await api.delete_database(
                 instance_id="example",
@@ -2471,17 +2561,18 @@
         order_by: ListPrivilegesRequestOrderBy = ListPrivilegesRequestOrderBy.USER_NAME_ASC,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         database_name: Optional[str] = None,
         user_name: Optional[str] = None,
     ) -> ListPrivilegesResponse:
         """
-        List privileges of a given user for a given database on a given instance
+        List user privileges for a database.
+        List privileges of a user on a database. By default, the details returned in the list are ordered by creation date in ascending order, though this can be modified via the order_by field. You can define additional parameters for your query, such as `database_name` and `user_name`.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance.
+        :param instance_id: UUID of the Database Instance.
         :param order_by: Criteria to use when ordering privileges listing.
         :param page:
         :param page_size:
         :param database_name: Name of the database.
         :param user_name: Name of the user.
         :return: :class:`ListPrivilegesResponse <ListPrivilegesResponse>`
 
@@ -2519,17 +2610,18 @@
         order_by: Optional[ListPrivilegesRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         database_name: Optional[str] = None,
         user_name: Optional[str] = None,
     ) -> List[Privilege]:
         """
-        List privileges of a given user for a given database on a given instance
+        List user privileges for a database.
+        List privileges of a user on a database. By default, the details returned in the list are ordered by creation date in ascending order, though this can be modified via the order_by field. You can define additional parameters for your query, such as `database_name` and `user_name`.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance.
+        :param instance_id: UUID of the Database Instance.
         :param order_by: Criteria to use when ordering privileges listing.
         :param page:
         :param page_size:
         :param database_name: Name of the database.
         :param user_name: Name of the user.
         :return: :class:`List[ListPrivilegesResponse] <List[ListPrivilegesResponse]>`
 
@@ -2560,17 +2652,18 @@
         instance_id: str,
         database_name: str,
         user_name: str,
         permission: Permission,
         region: Optional[Region] = None,
     ) -> Privilege:
         """
-        Set privileges of a given user for a given database on a given instance
+        Set user privileges for a database.
+        Set the privileges of a user on a database. You must define `database_name`, `user_name` and `permission` in the request body.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance.
+        :param instance_id: UUID of the Database Instance.
         :param database_name: Name of the database.
         :param user_name: Name of the user.
         :param permission: Permission to set (Read, Read/Write, All, Custom).
         :return: :class:`Privilege <Privilege>`
 
         Usage:
         ::
@@ -2615,19 +2708,20 @@
         instance_id: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListSnapshotsResponse:
         """
-        List instance snapshots
+        List snapshots.
+        List snapshots. You can include the `instance_id` or `project_id` in your query to get the list of snapshots for specific Database Instances and/or Projects. By default, the details returned in the list are ordered by creation date in ascending order, though this can be modified via the `order_by` field.
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: Name of the snapshot.
         :param order_by: Criteria to use when ordering snapshot listing.
-        :param instance_id: UUID of the instance.
+        :param instance_id: UUID of the Database Instance.
         :param organization_id: Organization ID the snapshots belongs to.
         :param project_id: Project ID the snapshots belongs to.
         :param page:
         :param page_size:
         :return: :class:`ListSnapshotsResponse <ListSnapshotsResponse>`
 
         Usage:
@@ -2667,19 +2761,20 @@
         instance_id: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[Snapshot]:
         """
-        List instance snapshots
+        List snapshots.
+        List snapshots. You can include the `instance_id` or `project_id` in your query to get the list of snapshots for specific Database Instances and/or Projects. By default, the details returned in the list are ordered by creation date in ascending order, though this can be modified via the `order_by` field.
         :param region: Region to target. If none is passed will use default region from the config.
         :param name: Name of the snapshot.
         :param order_by: Criteria to use when ordering snapshot listing.
-        :param instance_id: UUID of the instance.
+        :param instance_id: UUID of the Database Instance.
         :param organization_id: Organization ID the snapshots belongs to.
         :param project_id: Project ID the snapshots belongs to.
         :param page:
         :param page_size:
         :return: :class:`List[ListSnapshotsResponse] <List[ListSnapshotsResponse]>`
 
         Usage:
@@ -2707,15 +2802,16 @@
     async def get_snapshot(
         self,
         *,
         snapshot_id: str,
         region: Optional[Region] = None,
     ) -> Snapshot:
         """
-        Get an instance snapshot
+        Get a Database Instance snapshot.
+        Retrieve information about a given snapshot, specified by its `snapshot_id` and `region`. Full details about the snapshot, like size and expiration date, are returned in the response.
         :param region: Region to target. If none is passed will use default region from the config.
         :param snapshot_id: UUID of the snapshot.
         :return: :class:`Snapshot <Snapshot>`
 
         Usage:
         ::
 
@@ -2777,19 +2873,20 @@
         *,
         instance_id: str,
         region: Optional[Region] = None,
         name: Optional[str] = None,
         expires_at: Optional[datetime] = None,
     ) -> Snapshot:
         """
-        Create an instance snapshot
+        Create a Database Instance snapshot.
+        Create a new snapshot of a Database Instance. You must define the `name` parameter in the request.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance.
+        :param instance_id: UUID of the Database Instance.
         :param name: Name of the snapshot.
-        :param expires_at: Expiration date (Format ISO 8601).
+        :param expires_at: Expiration date (must follow the ISO 8601 format).
         :return: :class:`Snapshot <Snapshot>`
 
         Usage:
         ::
 
             result = await api.create_snapshot(instance_id="example")
         """
@@ -2821,19 +2918,20 @@
         *,
         snapshot_id: str,
         region: Optional[Region] = None,
         name: Optional[str] = None,
         expires_at: Optional[datetime] = None,
     ) -> Snapshot:
         """
-        Update an instance snapshot
+        Update a Database Instance snapshot.
+        Update the parameters of a snapshot of a Database Instance. You can update the `name` and `expires_at` parameters.
         :param region: Region to target. If none is passed will use default region from the config.
         :param snapshot_id: UUID of the snapshot to update.
         :param name: Name of the snapshot.
-        :param expires_at: Expiration date (Format ISO 8601).
+        :param expires_at: Expiration date (must follow the ISO 8601 format).
         :return: :class:`Snapshot <Snapshot>`
 
         Usage:
         ::
 
             result = await api.update_snapshot(snapshot_id="example")
         """
@@ -2863,15 +2961,16 @@
     async def delete_snapshot(
         self,
         *,
         snapshot_id: str,
         region: Optional[Region] = None,
     ) -> Snapshot:
         """
-        Delete an instance snapshot
+        Delete a Database Instance snapshot.
+        Delete a given snapshot of a Database Instance. You must specify, in the endpoint,  the `region` and `snapshot_id` parameters of the snapshot you want to delete.
         :param region: Region to target. If none is passed will use default region from the config.
         :param snapshot_id: UUID of the snapshot to delete.
         :return: :class:`Snapshot <Snapshot>`
 
         Usage:
         ::
 
@@ -2897,19 +2996,20 @@
         snapshot_id: str,
         instance_name: str,
         region: Optional[Region] = None,
         is_ha_cluster: Optional[bool] = None,
         node_type: Optional[str] = None,
     ) -> Instance:
         """
-        Create a new instance from a given snapshot
+        Create a new Database Instance from a snapshot.
+        Restore a snapshot. When you restore a snapshot, a new Instance is created and billed to your account. Note that is possible to select a larger node type for your new Database Instance. However, the Block volume size will be the same as the size of the restored snapshot. All Instance settings will be restored if you chose a node type with the same or more memory size than the initial Instance. Settings will be reset to the default if your node type has less memory.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param snapshot_id: Block snapshot of the instance.
-        :param instance_name: Name of the instance created with the snapshot.
-        :param is_ha_cluster: Whether or not High-Availability is enabled on the new instance.
+        :param snapshot_id: Block snapshot of the Database Instance.
+        :param instance_name: Name of the Database Instance created with the snapshot.
+        :param is_ha_cluster: Defines whether or not High-Availability is enabled on the new Database Instance.
         :param node_type: The node type used to restore the snapshot.
         :return: :class:`Instance <Instance>`
 
         Usage:
         ::
 
             result = await api.create_instance_from_snapshot(
@@ -2945,17 +3045,18 @@
         self,
         *,
         instance_id: str,
         region: Optional[Region] = None,
         endpoint_spec: Optional[EndpointSpec] = None,
     ) -> Endpoint:
         """
-        Create a new instance endpoint
+        Create a new Database Instance endpoint.
+        Create a new endpoint for a Database Instance. You can add `load_balancer` and `private_network` specifications to the body of the request.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param instance_id: UUID of the instance you want to add endpoint to.
+        :param instance_id: UUID of the Database Instance you to which you want to add an endpoint.
         :param endpoint_spec: Specification of the endpoint you want to create.
         :return: :class:`Endpoint <Endpoint>`
 
         Usage:
         ::
 
             result = await api.create_endpoint(instance_id="example")
@@ -2985,17 +3086,19 @@
     async def delete_endpoint(
         self,
         *,
         endpoint_id: str,
         region: Optional[Region] = None,
     ) -> Optional[None]:
         """
-        Delete an instance endpoint
+        Delete a Database Instance endpoint.
+        Delete the endpoint of a Database Instance. You must specify the `region` and `endpoint_id` parameters of the endpoint you want to delete. Note that might need to update any environment configurations that point to the deleted endpoint.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param endpoint_id: This endpoint can also be used to delete a read replica endpoint.
+        :param endpoint_id: UUID of the endpoint you want to delete.
+        This endpoint can also be used to delete a Read Replica endpoint.
 
         Usage:
         ::
 
             result = await api.delete_endpoint(endpoint_id="example")
         """
 
@@ -3015,15 +3118,16 @@
     async def get_endpoint(
         self,
         *,
         endpoint_id: str,
         region: Optional[Region] = None,
     ) -> Endpoint:
         """
-        Get an instance endpoint
+        Get a Database Instance endpoint.
+        Retrieve information about a Database Instance endpoint. Full details about the endpoint, like `ip`, `port`, `private_network` and `load_balancer` specifications are returned in the response.
         :param region: Region to target. If none is passed will use default region from the config.
         :param endpoint_id: UUID of the endpoint you want to get.
         :return: :class:`Endpoint <Endpoint>`
 
         Usage:
         ::
 
@@ -3047,15 +3151,15 @@
         self,
         *,
         endpoint_id: str,
         instance_id: str,
         region: Optional[Region] = None,
     ) -> Endpoint:
         """
-        Migrate an existing instance endpoint to another instance
+        Migrate an existing instance endpoint to another instance.
         :param region: Region to target. If none is passed will use default region from the config.
         :param endpoint_id: UUID of the endpoint you want to migrate.
         :param instance_id: UUID of the instance you want to attach the endpoint to.
         :return: :class:`Endpoint <Endpoint>`
 
         Usage:
         ::
```

### Comparing `scaleway_async-0.9.0/scaleway_async/rdb/v1/content.py` & `scaleway_async-1.0.0/scaleway_async/rdb/v1/content.py`

 * *Files 1% similar despite different names*

```diff
@@ -51,14 +51,15 @@
 """
 
 READ_REPLICA_TRANSIENT_STATUSES: List[ReadReplicaStatus] = [
     ReadReplicaStatus.PROVISIONING,
     ReadReplicaStatus.INITIALIZING,
     ReadReplicaStatus.DELETING,
     ReadReplicaStatus.CONFIGURING,
+    ReadReplicaStatus.PROMOTING,
 ]
 """
 Lists transient statutes of the enum :class:`ReadReplicaStatus <ReadReplicaStatus>`.
 """
 
 SNAPSHOT_TRANSIENT_STATUSES: List[SnapshotStatus] = [
     SnapshotStatus.CREATING,
```

### Comparing `scaleway_async-0.9.0/scaleway_async/rdb/v1/types.py` & `scaleway_async-1.0.0/scaleway_async/instance/v1/types.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,2727 +1,3271 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 from __future__ import annotations
 
 from dataclasses import dataclass
 from datetime import datetime
 from enum import Enum
-from typing import List, Optional
+from typing import Dict, List, Optional
 
 from scaleway_core.bridge import (
-    Region,
-    TimeSeries,
     Zone,
 )
 
 
-class ACLRuleAction(str, Enum):
-    ALLOW = "allow"
-    DENY = "deny"
+class Arch(str, Enum):
+    X86_64 = "x86_64"
+    ARM = "arm"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ACLRuleDirection(str, Enum):
-    INBOUND = "inbound"
-    OUTBOUND = "outbound"
+class BootType(str, Enum):
+    LOCAL = "local"
+    BOOTSCRIPT = "bootscript"
+    RESCUE = "rescue"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ACLRuleProtocol(str, Enum):
-    TCP = "tcp"
-    UDP = "udp"
-    ICMP = "icmp"
+class ImageState(str, Enum):
+    AVAILABLE = "available"
+    CREATING = "creating"
+    ERROR = "error"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class DatabaseBackupStatus(str, Enum):
-    UNKNOWN = "unknown"
-    CREATING = "creating"
-    READY = "ready"
-    RESTORING = "restoring"
-    DELETING = "deleting"
+class IpState(str, Enum):
+    UNKNOWN_STATE = "unknown_state"
+    DETACHED = "detached"
+    ATTACHED = "attached"
+    PENDING = "pending"
     ERROR = "error"
-    EXPORTING = "exporting"
-    LOCKED = "locked"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class EngineSettingPropertyType(str, Enum):
-    BOOLEAN = "BOOLEAN"
-    INT = "INT"
-    STRING = "STRING"
-    FLOAT = "FLOAT"
+class IpType(str, Enum):
+    UNKNOWN_IPTYPE = "unknown_iptype"
+    NAT = "nat"
+    ROUTED_IPV4 = "routed_ipv4"
+    ROUTED_IPV6 = "routed_ipv6"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class InstanceLogStatus(str, Enum):
-    UNKNOWN = "unknown"
-    READY = "ready"
-    CREATING = "creating"
-    ERROR = "error"
+class ListServersRequestOrder(str, Enum):
+    CREATION_DATE_DESC = "creation_date_desc"
+    CREATION_DATE_ASC = "creation_date_asc"
+    MODIFICATION_DATE_DESC = "modification_date_desc"
+    MODIFICATION_DATE_ASC = "modification_date_asc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class InstanceStatus(str, Enum):
-    UNKNOWN = "unknown"
-    READY = "ready"
-    PROVISIONING = "provisioning"
-    CONFIGURING = "configuring"
-    DELETING = "deleting"
-    ERROR = "error"
-    AUTOHEALING = "autohealing"
-    LOCKED = "locked"
-    INITIALIZING = "initializing"
-    DISK_FULL = "disk_full"
-    BACKUPING = "backuping"
-    SNAPSHOTTING = "snapshotting"
-    RESTARTING = "restarting"
+class PlacementGroupPolicyMode(str, Enum):
+    OPTIONAL = "optional"
+    ENFORCED = "enforced"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ListDatabaseBackupsRequestOrderBy(str, Enum):
-    CREATED_AT_ASC = "created_at_asc"
-    CREATED_AT_DESC = "created_at_desc"
-    NAME_ASC = "name_asc"
-    NAME_DESC = "name_desc"
-    STATUS_ASC = "status_asc"
-    STATUS_DESC = "status_desc"
+class PlacementGroupPolicyType(str, Enum):
+    MAX_AVAILABILITY = "max_availability"
+    LOW_LATENCY = "low_latency"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ListDatabasesRequestOrderBy(str, Enum):
-    NAME_ASC = "name_asc"
-    NAME_DESC = "name_desc"
-    SIZE_ASC = "size_asc"
-    SIZE_DESC = "size_desc"
+class PrivateNICState(str, Enum):
+    AVAILABLE = "available"
+    SYNCING = "syncing"
+    SYNCING_ERROR = "syncing_error"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ListInstanceLogsRequestOrderBy(str, Enum):
-    CREATED_AT_ASC = "created_at_asc"
-    CREATED_AT_DESC = "created_at_desc"
+class SecurityGroupPolicy(str, Enum):
+    ACCEPT = "accept"
+    DROP = "drop"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ListInstancesRequestOrderBy(str, Enum):
-    CREATED_AT_ASC = "created_at_asc"
-    CREATED_AT_DESC = "created_at_desc"
-    NAME_ASC = "name_asc"
-    NAME_DESC = "name_desc"
-    REGION = "region"
-    STATUS_ASC = "status_asc"
-    STATUS_DESC = "status_desc"
+class SecurityGroupRuleAction(str, Enum):
+    ACCEPT = "accept"
+    DROP = "drop"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ListPrivilegesRequestOrderBy(str, Enum):
-    USER_NAME_ASC = "user_name_asc"
-    USER_NAME_DESC = "user_name_desc"
-    DATABASE_NAME_ASC = "database_name_asc"
-    DATABASE_NAME_DESC = "database_name_desc"
+class SecurityGroupRuleDirection(str, Enum):
+    INBOUND = "inbound"
+    OUTBOUND = "outbound"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ListSnapshotsRequestOrderBy(str, Enum):
-    CREATED_AT_ASC = "created_at_asc"
-    CREATED_AT_DESC = "created_at_desc"
-    NAME_ASC = "name_asc"
-    NAME_DESC = "name_desc"
-    EXPIRES_AT_ASC = "expires_at_asc"
-    EXPIRES_AT_DESC = "expires_at_desc"
+class SecurityGroupRuleProtocol(str, Enum):
+    TCP = "TCP"
+    UDP = "UDP"
+    ICMP = "ICMP"
+    ANY = "ANY"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ListUsersRequestOrderBy(str, Enum):
-    NAME_ASC = "name_asc"
-    NAME_DESC = "name_desc"
-    IS_ADMIN_ASC = "is_admin_asc"
-    IS_ADMIN_DESC = "is_admin_desc"
+class SecurityGroupState(str, Enum):
+    AVAILABLE = "available"
+    SYNCING = "syncing"
+    SYNCING_ERROR = "syncing_error"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class MaintenanceStatus(str, Enum):
-    UNKNOWN = "unknown"
-    PENDING = "pending"
-    DONE = "done"
-    CANCELED = "canceled"
+class ServerAction(str, Enum):
+    POWERON = "poweron"
+    BACKUP = "backup"
+    STOP_IN_PLACE = "stop_in_place"
+    POWEROFF = "poweroff"
+    TERMINATE = "terminate"
+    REBOOT = "reboot"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class NodeTypeGeneration(str, Enum):
-    UNKNOWN_GENERATION = "unknown_generation"
-    GENERATION_V1 = "generation_v1"
-    GENERATION_V2 = "generation_v2"
+class ServerIpIpFamily(str, Enum):
+    INET = "inet"
+    INET6 = "inet6"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class NodeTypeStock(str, Enum):
-    UNKNOWN = "unknown"
-    LOW_STOCK = "low_stock"
-    OUT_OF_STOCK = "out_of_stock"
+class ServerIpProvisioningMode(str, Enum):
+    MANUAL = "manual"
+    DHCP = "dhcp"
+    SLAAC = "slaac"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
+class ServerState(str, Enum):
+    RUNNING = "running"
+    STOPPED = "stopped"
+    STOPPED_IN_PLACE = "stopped in place"
+    STARTING = "starting"
+    STOPPING = "stopping"
+    LOCKED = "locked"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
+class ServerTypesAvailability(str, Enum):
     AVAILABLE = "available"
+    SCARCE = "scarce"
+    SHORTAGE = "shortage"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class Permission(str, Enum):
-    READONLY = "readonly"
-    READWRITE = "readwrite"
-    ALL = "all"
-    CUSTOM = "custom"
-    NONE = "none"
+class SnapshotState(str, Enum):
+    AVAILABLE = "available"
+    SNAPSHOTTING = "snapshotting"
+    ERROR = "error"
+    INVALID_DATA = "invalid_data"
+    IMPORTING = "importing"
+    EXPORTING = "exporting"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class ReadReplicaStatus(str, Enum):
-    """
-    Read replica. status.
-    """
+class SnapshotVolumeType(str, Enum):
+    UNKNOWN_VOLUME_TYPE = "unknown_volume_type"
+    L_SSD = "l_ssd"
+    B_SSD = "b_ssd"
+    UNIFIED = "unified"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
 
-    UNKNOWN = "unknown"
-    PROVISIONING = "provisioning"
-    INITIALIZING = "initializing"
-    READY = "ready"
-    DELETING = "deleting"
+class TaskStatus(str, Enum):
+    PENDING = "pending"
+    STARTED = "started"
+    SUCCESS = "success"
+    FAILURE = "failure"
+    RETRY = "retry"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
+class VolumeServerState(str, Enum):
+    AVAILABLE = "available"
+    SNAPSHOTTING = "snapshotting"
     ERROR = "error"
-    LOCKED = "locked"
-    CONFIGURING = "configuring"
+    FETCHING = "fetching"
+    RESIZING = "resizing"
+    SAVING = "saving"
+    HOTSYNCING = "hotsyncing"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class SnapshotStatus(str, Enum):
-    UNKNOWN = "unknown"
-    CREATING = "creating"
-    READY = "ready"
-    RESTORING = "restoring"
-    DELETING = "deleting"
+class VolumeServerVolumeType(str, Enum):
+    L_SSD = "l_ssd"
+    B_SSD = "b_ssd"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
+class VolumeState(str, Enum):
+    AVAILABLE = "available"
+    SNAPSHOTTING = "snapshotting"
     ERROR = "error"
-    LOCKED = "locked"
+    FETCHING = "fetching"
+    RESIZING = "resizing"
+    SAVING = "saving"
+    HOTSYNCING = "hotsyncing"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class VolumeType(str, Enum):
-    LSSD = "lssd"
-    BSSD = "bssd"
+class VolumeVolumeType(str, Enum):
+    L_SSD = "l_ssd"
+    B_SSD = "b_ssd"
+    UNIFIED = "unified"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
 @dataclass
-class ACLRule:
-    ip: str
+class Bootscript:
+    """
+    Bootscript.
+    """
 
-    port: Optional[int]
+    bootcmdargs: str
     """
-    :deprecated
+    Bootscript arguments.
     """
 
-    protocol: ACLRuleProtocol
+    default: bool
+    """
+    Display if the bootscript is the default bootscript (if no other boot option is configured).
+    """
 
-    direction: ACLRuleDirection
+    dtb: str
+    """
+    Provide information regarding a Device Tree Binary (DTB) for use with C1 servers.
+    """
 
-    action: ACLRuleAction
+    id: str
+    """
+    Bootscript ID.
+    """
 
-    description: str
+    initrd: str
+    """
+    Initrd (initial ramdisk) configuration.
+    """
 
+    kernel: str
+    """
+    Instance kernel version.
+    """
 
-@dataclass
-class ACLRuleRequest:
-    ip: str
+    organization: str
+    """
+    Bootscript Organization ID.
+    """
 
-    description: str
+    project: str
+    """
+    Bootscript Project ID.
+    """
 
+    public: bool
+    """
+    Provide information if the bootscript is public.
+    """
 
-@dataclass
-class AddInstanceACLRulesResponse:
+    title: str
     """
-    Add instance acl rules response.
+    Bootscript title.
     """
 
-    rules: List[ACLRule]
+    arch: Arch
     """
-    Rules enabled on the instance.
+    Bootscript architecture.
     """
 
+    zone: Zone
+    """
+    Zone in which the bootscript is located.
+    """
+
+
+@dataclass
+class CreateImageResponse:
+    image: Optional[Image]
+
+
+@dataclass
+class CreateIpResponse:
+    ip: Optional[Ip]
+
 
 @dataclass
-class AddInstanceSettingsResponse:
+class CreatePlacementGroupResponse:
+    placement_group: Optional[PlacementGroup]
+
+
+@dataclass
+class CreatePrivateNICResponse:
+    private_nic: Optional[PrivateNIC]
+
+
+@dataclass
+class CreateSecurityGroupResponse:
+    security_group: Optional[SecurityGroup]
+
+
+@dataclass
+class CreateSecurityGroupRuleResponse:
+    rule: Optional[SecurityGroupRule]
+
+
+@dataclass
+class CreateServerResponse:
+    server: Optional[Server]
+
+
+@dataclass
+class CreateSnapshotResponse:
+    snapshot: Optional[Snapshot]
+
+    task: Optional[Task]
+
+
+@dataclass
+class CreateVolumeResponse:
+    volume: Optional[Volume]
+
+
+@dataclass
+class Dashboard:
+    volumes_count: int
+
+    running_servers_count: int
+
+    servers_by_types: Dict[str, int]
+
+    images_count: int
+
+    snapshots_count: int
+
+    servers_count: int
+
+    ips_count: int
+
+    security_groups_count: int
+
+    ips_unused: int
+
+    volumes_l_ssd_count: int
+
+    volumes_b_ssd_count: int
+
+    volumes_l_ssd_total_size: int
+
+    volumes_b_ssd_total_size: int
+
+    private_nics_count: int
+
+    placement_groups_count: int
+
+
+@dataclass
+class ExportSnapshotResponse:
+    task: Optional[Task]
+
+
+@dataclass
+class GetBootscriptResponse:
+    bootscript: Optional[Bootscript]
+
+
+@dataclass
+class GetDashboardResponse:
+    dashboard: Optional[Dashboard]
+
+
+@dataclass
+class GetImageResponse:
+    image: Optional[Image]
+
+
+@dataclass
+class GetIpResponse:
+    ip: Optional[Ip]
+
+
+@dataclass
+class GetPlacementGroupResponse:
+    placement_group: Optional[PlacementGroup]
+
+
+@dataclass
+class GetPlacementGroupServersResponse:
     """
-    Add instance settings response.
+    Get placement group servers response.
     """
 
-    settings: List[InstanceSetting]
+    servers: List[PlacementGroupServer]
     """
-    Settings available on the instance.
+    Instances attached to the placement group.
     """
 
 
 @dataclass
-class BackupSchedule:
-    frequency: int
+class GetPrivateNICResponse:
+    private_nic: Optional[PrivateNIC]
+
+
+@dataclass
+class GetSecurityGroupResponse:
+    security_group: Optional[SecurityGroup]
+
+
+@dataclass
+class GetSecurityGroupRuleResponse:
+    rule: Optional[SecurityGroupRule]
 
-    retention: int
 
-    disabled: bool
+@dataclass
+class GetServerResponse:
+    server: Optional[Server]
 
 
 @dataclass
-class Database:
+class GetServerTypesAvailabilityResponse:
     """
-    Database.
+    Get server types availability response.
+    """
+
+    servers: Dict[str, GetServerTypesAvailabilityResponseAvailability]
     """
+    Map of server types.
+    """
+
+    total_count: int
+
+
+@dataclass
+class GetServerTypesAvailabilityResponseAvailability:
+    availability: ServerTypesAvailability
+
+
+@dataclass
+class GetSnapshotResponse:
+    snapshot: Optional[Snapshot]
+
+
+@dataclass
+class GetVolumeResponse:
+    volume: Optional[Volume]
+
+
+@dataclass
+class Image:
+    id: str
 
     name: str
+
+    arch: Arch
+
+    creation_date: Optional[datetime]
+
+    modification_date: Optional[datetime]
+
+    default_bootscript: Optional[Bootscript]
     """
-    Name of the database.
+    :deprecated
     """
 
-    owner: str
+    extra_volumes: Dict[str, Volume]
+
+    from_server: str
+
+    organization: str
+
+    public: bool
+
+    root_volume: Optional[VolumeSummary]
+
+    state: ImageState
+
+    project: str
+
+    tags: List[str]
+
+    zone: Zone
+
+
+@dataclass
+class Ip:
+    id: str
+
+    address: str
+
+    reverse: Optional[str]
+
+    server: Optional[ServerSummary]
+
+    organization: str
+
+    tags: List[str]
+
+    project: str
+
+    type_: IpType
+
+    state: IpState
+
+    prefix: str
+
+    zone: Zone
+
+
+@dataclass
+class ListBootscriptsResponse:
     """
-    Name of the owner of the database.
+    List bootscripts response.
     """
 
-    managed: bool
+    total_count: int
     """
-    Whether or not the database is managed or not.
+    Total number of bootscripts.
     """
 
-    size: int
+    bootscripts: List[Bootscript]
     """
-    Size of the database.
+    List of bootscripts.
     """
 
 
 @dataclass
-class DatabaseBackup:
+class ListImagesResponse:
     """
-    Database backup.
+    List images response.
     """
 
-    id: str
+    total_count: int
     """
-    UUID of the database backup.
+    Total number of images.
     """
 
-    instance_id: str
+    images: List[Image]
     """
-    UUID of the instance.
+    List of images.
     """
 
-    database_name: str
+
+@dataclass
+class ListIpsResponse:
     """
-    Name of the database of this backup.
+    List ips response.
     """
 
-    name: str
+    total_count: int
     """
-    Name of the backup.
+    Total number of ips.
     """
 
-    status: DatabaseBackupStatus
+    ips: List[Ip]
     """
-    Status of the backup.
+    List of ips.
     """
 
-    size: Optional[int]
+
+@dataclass
+class ListPlacementGroupsResponse:
     """
-    Size of the database backup.
+    List placement groups response.
     """
 
-    expires_at: Optional[datetime]
+    total_count: int
     """
-    Expiration date (Format ISO 8601).
+    Total number of placement groups.
     """
 
-    created_at: Optional[datetime]
+    placement_groups: List[PlacementGroup]
     """
-    Creation date (Format ISO 8601).
+    List of placement groups.
     """
 
-    updated_at: Optional[datetime]
+
+@dataclass
+class ListPrivateNICsResponse:
+    private_nics: List[PrivateNIC]
+
+    total_count: int
+
+
+@dataclass
+class ListSecurityGroupRulesResponse:
     """
-    Updated date (Format ISO 8601).
+    List security group rules response.
     """
 
-    instance_name: str
+    total_count: int
     """
-    Name of the instance of the backup.
+    Total number of security groups.
     """
 
-    download_url: Optional[str]
+    rules: List[SecurityGroupRule]
     """
-    URL you can download the backup from.
+    List of security rules.
     """
 
-    download_url_expires_at: Optional[datetime]
+
+@dataclass
+class ListSecurityGroupsResponse:
     """
-    Expiration date of the download link.
+    List security groups response.
     """
 
-    region: Region
+    total_count: int
     """
-    Region of this database backup.
+    Total number of security groups.
     """
 
-    same_region: bool
+    security_groups: List[SecurityGroup]
     """
-    Store logical backups in the same region as the source database instance.
+    List of security groups.
     """
 
 
 @dataclass
-class DatabaseEngine:
+class ListServerActionsResponse:
+    actions: List[ServerAction]
+
+
+@dataclass
+class ListServerUserDataResponse:
+    user_data: List[str]
+
+
+@dataclass
+class ListServersResponse:
     """
-    Database engine.
+    List servers response.
     """
 
-    name: str
+    total_count: int
     """
-    Engine name.
+    Total number of Instances.
     """
 
-    logo_url: str
+    servers: List[Server]
     """
-    Engine logo URL.
+    List of Instances.
     """
 
-    versions: List[EngineVersion]
+
+@dataclass
+class ListServersTypesResponse:
+    """
+    List servers types response.
+    """
+
+    total_count: int
     """
-    Available versions.
+    Total number of Instance types.
     """
 
-    region: Region
+    servers: Dict[str, ServerType]
     """
-    Region of this database engine.
+    List of Instance types.
     """
 
 
 @dataclass
-class DeleteInstanceACLRulesResponse:
+class ListSnapshotsResponse:
     """
-    Delete instance acl rules response.
+    List snapshots response.
     """
 
-    rules: List[ACLRule]
+    total_count: int
     """
-    ACL rules present on the instance.
+    Total number of snapshots.
+    """
+
+    snapshots: List[Snapshot]
+    """
+    List of snapshots.
     """
 
 
 @dataclass
-class DeleteInstanceSettingsResponse:
+class ListVolumesResponse:
+    """
+    List volumes response.
+    """
+
+    total_count: int
     """
-    Delete instance settings response.
+    Total number of volumes.
     """
 
-    settings: List[InstanceSetting]
+    volumes: List[Volume]
     """
-    Settings names to delete from the instance.
+    List of volumes.
     """
 
 
 @dataclass
-class Endpoint:
+class ListVolumesTypesResponse:
     """
-    Endpoint.
+    List volumes types response.
     """
 
-    id: str
+    total_count: int
     """
-    UUID of the endpoint.
+    Total number of volume types.
     """
 
-    ip: Optional[str]
+    volumes: Dict[str, VolumeType]
     """
-    IPv4 address of the endpoint.
-    
-    One-of ('address'): at most one of 'ip', 'hostname' could be set.
+    Map of volume types.
     """
 
-    port: int
+
+@dataclass
+class PlacementGroup:
     """
-    TCP port of the endpoint.
+    Placement group.
     """
 
-    name: Optional[str]
+    id: str
     """
-    Name of the endpoint.
+    Placement group unique ID.
     """
 
-    private_network: Optional[EndpointPrivateNetworkDetails]
+    name: str
     """
-    Private network details. One at the most per RDB instance or read replica (an RDB instance and its read replica can have different private networks). Cannot be updated (has to be deleted and recreated).
-    
-    One-of ('details'): at most one of 'private_network', 'load_balancer', 'direct_access' could be set.
+    Placement group name.
     """
 
-    load_balancer: Optional[EndpointLoadBalancerDetails]
+    organization: str
     """
-    Load balancer details. Public endpoint for RDB instances which is systematically present. One per RDB instance.
-    
-    One-of ('details'): at most one of 'private_network', 'load_balancer', 'direct_access' could be set.
+    Placement group Organization ID.
     """
 
-    direct_access: Optional[EndpointDirectAccessDetails]
+    project: str
     """
-    Direct access details. Public endpoint reserved for read replicas. One per read replica.
-    
-    One-of ('details'): at most one of 'private_network', 'load_balancer', 'direct_access' could be set.
+    Placement group Project ID.
     """
 
-    hostname: Optional[str]
+    tags: List[str]
     """
-    Hostname of the endpoint.
-    
-    One-of ('address'): at most one of 'ip', 'hostname' could be set.
+    Placement group tags.
     """
 
-
-@dataclass
-class EndpointDirectAccessDetails:
-    pass
-
-
-@dataclass
-class EndpointLoadBalancerDetails:
-    pass
-
-
-@dataclass
-class EndpointPrivateNetworkDetails:
+    policy_mode: PlacementGroupPolicyMode
     """
-    Endpoint. private network details.
+    Select the failure mode when the placement cannot be respected, either optional or enforced.
     """
 
-    private_network_id: str
+    policy_type: PlacementGroupPolicyType
     """
-    UUID of the private network.
+    Select the behavior of the placement group, either low_latency (group) or max_availability (spread).
     """
 
-    service_ip: str
+    policy_respected: bool
     """
-    CIDR notation of the endpoint IPv4 address.
+    Returns true if the policy is respected, false otherwise.
     """
 
     zone: Zone
     """
-    Private network zone.
+    Zone in which the placement group is located.
     """
 
 
 @dataclass
-class EndpointSpec:
+class PlacementGroupServer:
     """
-    Endpoint spec.
+    Placement group server.
     """
 
-    load_balancer: Optional[EndpointSpecLoadBalancer]
+    id: str
     """
-    Load balancer endpoint specifications. Public endpoint for RDB instances which is systematically present. One per RDB instance.
-    
-    One-of ('spec'): at most one of 'load_balancer', 'private_network' could be set.
+    Instance UUID.
     """
 
-    private_network: Optional[EndpointSpecPrivateNetwork]
+    name: str
     """
-    Private network endpoint specifications. One at the most per RDB instance or read replica (an RDB instance and its read replica can have different private networks). Cannot be updated (has to be deleted and recreated).
-    
-    One-of ('spec'): at most one of 'load_balancer', 'private_network' could be set.
+    Instance name.
+    """
+
+    policy_respected: bool
+    """
+    Defines whether the placement group policy is respected (either 1 or 0).
     """
 
 
 @dataclass
-class EndpointSpecLoadBalancer:
-    pass
+class PrivateNIC:
+    """
+    Private nic.
+    """
 
+    id: str
+    """
+    Private NIC unique ID.
+    """
 
-@dataclass
-class EndpointSpecPrivateNetwork:
+    server_id: str
     """
-    Endpoint spec. private network.
+    Instance to which the private NIC is attached.
     """
 
     private_network_id: str
     """
-    UUID of the private network to be connected to the database instance.
+    Private Network the private NIC is attached to.
     """
 
-    service_ip: Optional[str]
+    mac_address: str
     """
-    Endpoint IPv4 adress with a CIDR notation. Check documentation about IP and subnet limitation.
-    
-    One-of ('config'): at most one of 'service_ip', 'ipam_config' could be set.
+    Private NIC MAC address.
     """
 
-    ipam_config: Optional[EndpointSpecPrivateNetworkIpamConfig]
+    state: PrivateNICState
     """
-    Automated configuration of your private network endpoint with Scaleway IPAM service. One at the most per RDB instance or read replica (an RDB instance and its read replica can have different private networks). Cannot be updated (has to be deleted and recreated).
-    
-    One-of ('config'): at most one of 'service_ip', 'ipam_config' could be set.
+    Private NIC state.
     """
 
-
-@dataclass
-class EndpointSpecPrivateNetworkIpamConfig:
-    pass
+    tags: List[str]
+    """
+    Private NIC tags.
+    """
 
 
 @dataclass
-class EngineSetting:
+class SecurityGroup:
     """
-    Engine setting.
+    Security group.
     """
 
-    name: str
+    id: str
     """
-    Setting name from database engine.
+    Security group unique ID.
     """
 
-    default_value: str
+    name: str
     """
-    Value set when not specified.
+    Security group name.
     """
 
-    hot_configurable: bool
+    description: str
     """
-    Setting can be applied without restarting.
+    Security group description.
     """
 
-    description: str
+    enable_default_security: bool
     """
-    Setting description.
+    True if SMTP is blocked on IPv4 and IPv6. This feature is read only, please open a support ticket if you need to make it configurable.
     """
 
-    property_type: EngineSettingPropertyType
+    inbound_default_policy: SecurityGroupPolicy
     """
-    Setting type.
+    Default inbound policy.
     """
 
-    unit: Optional[str]
+    outbound_default_policy: SecurityGroupPolicy
     """
-    Setting base unit.
+    Default outbound policy.
     """
 
-    string_constraint: Optional[str]
+    organization: str
     """
-    Validation regex for string type settings.
+    Security group Organization ID.
     """
 
-    int_min: Optional[int]
+    project: str
     """
-    Minimum value for int types.
+    Security group Project ID.
     """
 
-    int_max: Optional[int]
+    tags: List[str]
     """
-    Maximum value for int types.
+    Security group tags.
     """
 
-    float_min: Optional[float]
+    organization_default: Optional[bool]
     """
-    Minimum value for float types.
+    True if it is your default security group for this Organization ID.
+    :deprecated
     """
 
-    float_max: Optional[float]
+    project_default: bool
     """
-    Maximum value for float types.
+    True if it is your default security group for this Project ID.
     """
 
-
-@dataclass
-class EngineVersion:
+    creation_date: Optional[datetime]
     """
-    Engine version.
+    Security group creation date.
     """
 
-    version: str
+    modification_date: Optional[datetime]
     """
-    Database engine version.
+    Security group modification date.
     """
 
-    name: str
+    servers: List[ServerSummary]
     """
-    Database engine name.
+    List of Instances attached to this security group.
     """
 
-    end_of_life: Optional[datetime]
+    stateful: bool
     """
-    End of life date.
+    Defines whether the security group is stateful.
     """
 
-    available_settings: List[EngineSetting]
+    state: SecurityGroupState
     """
-    Engine settings available to be set.
+    Security group state.
     """
 
-    disabled: bool
+    zone: Zone
     """
-    Disabled versions cannot be created.
+    Zone in which the security group is located.
     """
 
-    beta: bool
+
+@dataclass
+class SecurityGroupRule:
+    id: str
+
+    protocol: SecurityGroupRuleProtocol
+
+    direction: SecurityGroupRuleDirection
+
+    action: SecurityGroupRuleAction
+
+    ip_range: str
+
+    dest_port_from: Optional[int]
+
+    dest_port_to: Optional[int]
+
+    position: int
+
+    editable: bool
+
+    zone: Zone
+
+
+@dataclass
+class SecurityGroupSummary:
+    id: str
+
+    name: str
+
+
+@dataclass
+class SecurityGroupTemplate:
+    id: str
+
+    name: str
+
+
+@dataclass
+class Server:
     """
-    Beta status of engine version.
+    Server.
     """
 
-    available_init_settings: List[EngineSetting]
+    id: str
     """
-    Engine settings available to be set at database initialisation.
+    Instance unique ID.
     """
 
-
-@dataclass
-class Instance:
+    name: str
     """
-    Instance.
+    Instance name.
     """
 
-    created_at: Optional[datetime]
+    organization: str
     """
-    Creation date (Format ISO 8601).
+    Instance Organization ID.
     """
 
-    volume: Optional[Volume]
+    project: str
     """
-    Volumes of the instance.
+    Instance Project ID.
     """
 
-    region: Region
+    allowed_actions: List[ServerAction]
     """
-    Region the instance is in.
+    List of allowed actions on the Instance.
     """
 
-    id: str
+    tags: List[str]
     """
-    UUID of the instance.
+    Tags associated with the Instance.
     """
 
-    name: str
+    commercial_type: str
     """
-    Name of the instance.
+    Instance commercial type (eg. GP1-M).
     """
 
-    organization_id: str
+    creation_date: Optional[datetime]
     """
-    Organization ID the instance belongs to.
+    Instance creation date.
     """
 
-    project_id: str
+    dynamic_ip_required: bool
     """
-    Project ID the instance belongs to.
+    True if a dynamic IPv4 is required.
     """
 
-    status: InstanceStatus
+    routed_ip_enabled: bool
     """
-    Status of the instance.
+    True to configure the instance so it uses the new routed IP mode.
     """
 
-    engine: str
+    enable_ipv6: bool
     """
-    Database engine of the database (PostgreSQL, MySQL, ...).
+    True if IPv6 is enabled.
     """
 
-    upgradable_version: List[UpgradableVersion]
+    hostname: str
     """
-    Available database engine versions for upgrade.
+    Instance host name.
     """
 
-    endpoint: Optional[Endpoint]
+    image: Optional[Image]
     """
-    Endpoint of the instance.
-    :deprecated
+    Information about the Instance image.
     """
 
-    tags: List[str]
+    protected: bool
     """
-    List of tags applied to the instance.
+    Defines whether the Instance protection option is activated.
     """
 
-    settings: List[InstanceSetting]
+    private_ip: Optional[str]
     """
-    Advanced settings of the instance.
+    Private IP address of the Instance.
     """
 
-    backup_schedule: Optional[BackupSchedule]
+    public_ip: Optional[ServerIp]
     """
-    Backup schedule of the instance.
+    Information about the public IP.
     """
 
-    is_ha_cluster: bool
+    public_ips: List[ServerIp]
     """
-    Whether or not High-Availability is enabled.
+    Information about all the public IPs attached to the server.
     """
 
-    read_replicas: List[ReadReplica]
+    mac_address: str
     """
-    Read replicas of the instance.
+    The server's MAC address.
     """
 
-    node_type: str
+    modification_date: Optional[datetime]
     """
-    Node type of the instance.
+    Instance modification date.
     """
 
-    init_settings: List[InstanceSetting]
+    state: ServerState
     """
-    List of engine settings to be set at database initialisation.
+    Instance state.
     """
 
-    endpoints: List[Endpoint]
+    location: Optional[ServerLocation]
     """
-    List of instance endpoints.
+    Instance location.
     """
 
-    logs_policy: Optional[LogsPolicy]
+    ipv6: Optional[ServerIpv6]
     """
-    Logs policy of the instance.
+    Instance IPv6 address.
     """
 
-    backup_same_region: bool
+    bootscript: Optional[Bootscript]
     """
-    Store logical backups in the same region as the database instance.
+    Instance bootscript.
+    :deprecated
     """
 
-    maintenances: List[Maintenance]
+    boot_type: BootType
     """
-    List of instance maintenances.
+    Instance boot type.
     """
 
-
-@dataclass
-class InstanceLog:
+    volumes: Dict[str, VolumeServer]
     """
-    Instance log.
+    Instance volumes.
     """
 
-    download_url: Optional[str]
+    security_group: Optional[SecurityGroupSummary]
     """
-    Presigned S3 URL to download your log file.
+    Instance security group.
     """
 
-    id: str
+    maintenances: List[ServerMaintenance]
     """
-    UUID of the instance log.
+    Instance planned maintenance.
     """
 
-    status: InstanceLogStatus
+    state_detail: str
     """
-    Status of the logs in a given instance.
+    Detailed information about the Instance state.
     """
 
-    node_name: str
+    arch: Arch
     """
-    Name of the undelying node.
+    Instance architecture.
     """
 
-    expires_at: Optional[datetime]
+    placement_group: Optional[PlacementGroup]
     """
-    Expiration date (Format ISO 8601).
+    Instance placement group.
     """
 
-    created_at: Optional[datetime]
+    private_nics: List[PrivateNIC]
     """
-    Creation date (Format ISO 8601).
+    Instance private NICs.
     """
 
-    region: Region
+    zone: Zone
     """
-    Region the instance is in.
+    Zone in which the Instance is located.
     """
 
 
 @dataclass
-class InstanceMetrics:
+class ServerActionRequestVolumeBackupTemplate:
     """
-    Instance metrics.
+    Server action request. volume backup template.
     """
 
-    timeseries: List[TimeSeries]
+    volume_type: SnapshotVolumeType
     """
-    Time series of metrics of a given instance.
+    Snapshot's volume type.
+    Overrides the `volume_type` of the snapshot for this volume.
+    If omitted, the volume type of the original volume will be used.
     """
 
 
 @dataclass
-class InstanceSetting:
-    name: str
-
-    value: str
+class ServerActionResponse:
+    task: Optional[Task]
 
 
 @dataclass
-class ListDatabaseBackupsResponse:
+class ServerIp:
     """
-    List database backups response.
+    Server. ip.
     """
 
-    database_backups: List[DatabaseBackup]
+    id: str
     """
-    List of database backups.
+    Unique ID of the IP address.
     """
 
-    total_count: int
+    address: str
     """
-    Total count of database backups available.
+    Instance's public IP-Address.
     """
 
-
-@dataclass
-class ListDatabaseEnginesResponse:
+    gateway: str
     """
-    List database engines response.
+    Gateway's IP address.
     """
 
-    engines: List[DatabaseEngine]
+    netmask: str
     """
-    List of the available database engines.
+    CIDR netmask.
     """
 
-    total_count: int
+    family: ServerIpIpFamily
     """
-    Total count of database engines available.
+    IP address family (inet or inet6).
     """
 
-
-@dataclass
-class ListDatabasesResponse:
+    dynamic: bool
     """
-    List databases response.
+    True if the IP address is dynamic.
     """
 
-    databases: List[Database]
+    provisioning_mode: ServerIpProvisioningMode
     """
-    List of the databases.
+    Information about this address provisioning mode.
     """
 
-    total_count: int
+
+@dataclass
+class ServerIpv6:
     """
-    Total count of databases present on a given instance.
+    Server. ipv6.
     """
 
-
-@dataclass
-class ListInstanceACLRulesResponse:
+    address: str
     """
-    List instance acl rules response.
+    Instance IPv6 IP-Address.
     """
 
-    rules: List[ACLRule]
+    gateway: str
     """
-    List of the ACL rules present on a given instance.
+    IPv6 IP-addresses gateway.
     """
 
-    total_count: int
+    netmask: str
     """
-    Total count of ACL rules present on a given instance.
+    IPv6 IP-addresses CIDR netmask.
     """
 
 
 @dataclass
-class ListInstanceLogsDetailsResponse:
-    """
-    List instance logs details response.
-    """
+class ServerLocation:
+    cluster_id: str
 
-    details: List[ListInstanceLogsDetailsResponseInstanceLogDetail]
-    """
-    Remote instance logs details.
-    """
+    hypervisor_id: str
+
+    node_id: str
+
+    platform_id: str
+
+    zone_id: str
 
 
 @dataclass
-class ListInstanceLogsDetailsResponseInstanceLogDetail:
-    log_name: str
+class ServerMaintenance:
+    reason: str
 
-    size: int
+
+@dataclass
+class ServerSummary:
+    id: str
+
+    name: str
 
 
 @dataclass
-class ListInstanceLogsResponse:
+class ServerType:
     """
-    List instance logs response.
+    Server type.
     """
 
-    instance_logs: List[InstanceLog]
+    monthly_price: Optional[float]
     """
-    Available logs in a given instance.
+    Estimated monthly price, for a 30 days month, in Euro.
+    :deprecated
     """
 
-
-@dataclass
-class ListInstancesResponse:
+    hourly_price: float
     """
-    List instances response.
+    Hourly price in Euro.
     """
 
-    instances: List[Instance]
+    alt_names: List[str]
     """
-    List all instances available in a given organization/project.
+    Alternative Instance name, if any.
     """
 
-    total_count: int
+    per_volume_constraint: Optional[ServerTypeVolumeConstraintsByType]
     """
-    Total count of instances available in a given organization/project.
+    Additional volume constraints.
     """
 
+    volumes_constraint: Optional[ServerTypeVolumeConstraintSizes]
+    """
+    Initial volume constraints.
+    """
 
-@dataclass
-class ListNodeTypesResponse:
+    ncpus: int
     """
-    List node types response.
+    Number of CPU.
     """
 
-    node_types: List[NodeType]
+    gpu: Optional[int]
     """
-    Types of the node.
+    Number of GPU.
     """
 
-    total_count: int
+    ram: int
     """
-    Total count of node-types available.
+    Available RAM in bytes.
     """
 
+    arch: Arch
+    """
+    CPU architecture.
+    """
 
-@dataclass
-class ListPrivilegesResponse:
+    baremetal: bool
     """
-    List privileges response.
+    True if it is a baremetal Instance.
     """
 
-    privileges: List[Privilege]
+    network: Optional[ServerTypeNetwork]
     """
-    Privileges of a given user in a given database in a given instance.
+    Network available for the Instance.
     """
 
-    total_count: int
+    capabilities: Optional[ServerTypeCapabilities]
     """
-    Total count of privileges present on a given database.
+    Capabilities.
     """
 
 
 @dataclass
-class ListSnapshotsResponse:
+class ServerTypeCapabilities:
     """
-    List snapshots response.
+    Server type. capabilities.
     """
 
-    snapshots: List[Snapshot]
+    block_storage: Optional[bool]
     """
-    List of snapshots.
+    Defines whether the Instance supports block storage.
     """
 
-    total_count: int
+    boot_types: List[BootType]
     """
-    Total count of snapshots available.
+    List of supported boot types.
     """
 
 
 @dataclass
-class ListUsersResponse:
+class ServerTypeNetwork:
     """
-    List users response.
+    Server type. network.
     """
 
-    users: List[User]
+    interfaces: List[ServerTypeNetworkInterface]
     """
-    List of users in a given instance.
+    List of available network interfaces.
     """
 
-    total_count: int
+    sum_internal_bandwidth: Optional[int]
+    """
+    Total maximum internal bandwidth in bits per seconds.
     """
-    Total count of users present on a given instance.
+
+    sum_internet_bandwidth: Optional[int]
+    """
+    Total maximum internet bandwidth in bits per seconds.
+    """
+
+    ipv6_support: bool
+    """
+    True if IPv6 is enabled.
     """
 
 
 @dataclass
-class LogsPolicy:
+class ServerTypeNetworkInterface:
     """
-    Logs policy.
+    Server type. network. interface.
     """
 
-    max_age_retention: Optional[int]
+    internal_bandwidth: Optional[int]
     """
-    Max age (in day) of remote logs to keep on the database instance.
+    Maximum internal bandwidth in bits per seconds.
     """
 
-    total_disk_retention: Optional[int]
+    internet_bandwidth: Optional[int]
     """
-    Max disk size of remote logs to keep on the database instance.
+    Maximum internet bandwidth in bits per seconds.
     """
 
 
 @dataclass
-class Maintenance:
+class ServerTypeVolumeConstraintSizes:
     """
-    Maintenance.
+    Server type. volume constraint sizes.
     """
 
-    starts_at: Optional[datetime]
+    min_size: int
     """
-    Start date of the maintenance window.
+    Minimum volume size in bytes.
     """
 
-    stops_at: Optional[datetime]
+    max_size: int
     """
-    End date of the maintenance window.
+    Maximum volume size in bytes.
     """
 
-    closed_at: Optional[datetime]
-    """
-    Closed maintenance date.
-    """
 
-    reason: str
+@dataclass
+class ServerTypeVolumeConstraintsByType:
     """
-    Maintenance information message.
+    Server type. volume constraints by type.
     """
 
-    status: MaintenanceStatus
+    l_ssd: Optional[ServerTypeVolumeConstraintSizes]
     """
-    Status of the maintenance.
+    Local SSD volumes.
     """
 
 
 @dataclass
-class NodeType:
-    """
-    Node type.
-    """
+class SetPlacementGroupResponse:
+    placement_group: Optional[PlacementGroup]
 
-    name: str
+
+@dataclass
+class SetPlacementGroupServersResponse:
     """
-    Node Type name identifier.
+    Set placement group servers response.
     """
 
-    stock_status: NodeTypeStock
+    servers: List[PlacementGroupServer]
     """
-    Current stock status for the Node Type.
+    Instances attached to the placement group.
     """
 
-    description: str
+
+@dataclass
+class SetSecurityGroupRulesRequestRule:
     """
-    Current specs of the offer.
+    Set security group rules request. rule.
     """
 
-    vcpus: int
+    id: Optional[str]
     """
-    Number of virtual CPUs.
+    UUID of the security rule to update. If no value is provided, a new rule will be created.
     """
 
-    memory: int
+    action: SecurityGroupRuleAction
     """
-    Quantity of RAM.
+    Action to apply when the rule matches a packet.
     """
 
-    volume_constraint: Optional[NodeTypeVolumeConstraintSizes]
+    protocol: SecurityGroupRuleProtocol
     """
-    [deprecated] Node Type volume constraints.
-    :deprecated
+    Protocol family this rule applies to.
     """
 
-    is_bssd_compatible: Optional[bool]
+    direction: SecurityGroupRuleDirection
     """
-    The Node Type is compliant with Block Storage.
-    :deprecated
+    Direction the rule applies to.
     """
 
-    disabled: bool
+    ip_range: str
     """
-    The Node Type is currently disabled.
+    Range of IP addresses these rules apply to.
     """
 
-    beta: bool
+    dest_port_from: Optional[int]
     """
-    The Node Type is currently in beta.
+    Beginning of the range of ports this rule applies to (inclusive). This value will be set to null if protocol is ICMP or ANY.
     """
 
-    available_volume_types: List[NodeTypeVolumeType]
+    dest_port_to: Optional[int]
     """
-    Available storage options for the Node Type.
+    End of the range of ports this rule applies to (inclusive). This value will be set to null if protocol is ICMP or ANY, or if it is equal to dest_port_from.
     """
 
-    is_ha_required: bool
+    position: int
     """
-    The Node Type can be used only with high availability option.
+    Position of this rule in the security group rules list. If several rules are passed with the same position, the resulting order is undefined.
     """
 
-    generation: NodeTypeGeneration
+    editable: Optional[bool]
     """
-    Generation associated the NodeType offer.
+    Indicates if this rule is editable. Rules with the value false will be ignored.
     """
 
-    region: Region
+    zone: Zone
     """
-    Region the Node Type is in.
+    Zone of the rule. This field is ignored.
     """
 
 
 @dataclass
-class NodeTypeVolumeConstraintSizes:
+class SetSecurityGroupRulesResponse:
+    rules: List[SecurityGroupRule]
+
+
+@dataclass
+class Snapshot:
     """
-    Node type. volume constraint sizes.
+    Snapshot.
     """
 
-    min_size: int
+    id: str
     """
-    [deprecated] Mimimum size required for the Volume.
+    Snapshot ID.
     """
 
-    max_size: int
+    name: str
     """
-    [deprecated] Maximum size required for the Volume.
+    Snapshot name.
     """
 
-
-@dataclass
-class NodeTypeVolumeType:
+    organization: str
     """
-    Node type. volume type.
+    Snapshot Organization ID.
     """
 
-    type_: VolumeType
+    project: str
     """
-    Volume Type.
+    Snapshot Project ID.
     """
 
-    description: str
+    tags: List[str]
     """
-    The description of the Volume.
+    Snapshot tags.
     """
 
-    min_size: int
+    volume_type: VolumeVolumeType
     """
-    Mimimum size required for the Volume.
+    Snapshot volume type.
     """
 
-    max_size: int
+    size: int
     """
-    Maximum size required for the Volume.
+    Snapshot size.
     """
 
-    chunk_size: int
+    state: SnapshotState
     """
-    Minimum increment level for a Block Storage volume size.
+    Snapshot state.
     """
 
+    base_volume: Optional[SnapshotBaseVolume]
+    """
+    Volume on which the snapshot is based on.
+    """
 
-@dataclass
-class PrepareInstanceLogsResponse:
+    creation_date: Optional[datetime]
     """
-    Prepare instance logs response.
+    Snapshot creation date.
     """
 
-    instance_logs: List[InstanceLog]
+    modification_date: Optional[datetime]
     """
-    Instance logs for a given instance between a start and an end date.
+    Snapshot modification date.
     """
 
+    zone: Zone
+    """
+    Snapshot zone.
+    """
 
-@dataclass
-class Privilege:
+    error_reason: Optional[str]
     """
-    Privilege.
+    Reason for the failed snapshot import.
     """
 
-    permission: Permission
+
+@dataclass
+class SnapshotBaseVolume:
     """
-    Permission (Read, Read/Write, All, Custom).
+    Snapshot. base volume.
     """
 
-    database_name: str
+    id: str
     """
-    Name of the database.
+    Volume ID on which the snapshot is based.
     """
 
-    user_name: str
+    name: str
     """
-    Name of the user.
+    Volume name on which the snapshot is based on.
     """
 
 
 @dataclass
-class ReadReplica:
+class Task:
     """
-    Read replica.
+    Task.
     """
 
     id: str
     """
-    UUID of the read replica.
+    Unique ID of the task.
     """
 
-    endpoints: List[Endpoint]
+    description: str
     """
-    Display read replica connection information.
+    Description of the task.
     """
 
-    status: ReadReplicaStatus
+    progress: int
     """
-    Read replica status.
+    Progress of the task in percent.
     """
 
-    region: Region
+    started_at: Optional[datetime]
     """
-    Region the read replica is in.
+    Task start date.
     """
 
-
-@dataclass
-class ReadReplicaEndpointSpec:
+    terminated_at: Optional[datetime]
     """
-    Read replica endpoint spec.
+    Task end date.
     """
 
-    direct_access: Optional[ReadReplicaEndpointSpecDirectAccess]
+    status: TaskStatus
     """
-    Direct access endpoint specifications. Public endpoint reserved for read replicas. One per read replica.
-    
-    One-of ('spec'): at most one of 'direct_access', 'private_network' could be set.
+    Task status.
     """
 
-    private_network: Optional[ReadReplicaEndpointSpecPrivateNetwork]
+    href_from: str
+
+    href_result: str
+
+    zone: Zone
     """
-    Private network endpoint specifications. One at the most per read replica. Cannot be updated (has to be deleted and recreated).
-    
-    One-of ('spec'): at most one of 'direct_access', 'private_network' could be set.
+    Zone in which the task is excecuted.
     """
 
 
 @dataclass
-class ReadReplicaEndpointSpecDirectAccess:
-    pass
+class UpdateIpResponse:
+    ip: Optional[Ip]
+
+
+@dataclass
+class UpdatePlacementGroupResponse:
+    placement_group: Optional[PlacementGroup]
 
 
 @dataclass
-class ReadReplicaEndpointSpecPrivateNetwork:
+class UpdatePlacementGroupServersResponse:
     """
-    Read replica endpoint spec. private network.
+    Update placement group servers response.
     """
 
-    private_network_id: str
+    servers: List[PlacementGroupServer]
     """
-    UUID of the private network to be connected to the read replica.
+    Instances attached to the placement group.
     """
 
-    service_ip: Optional[str]
+
+@dataclass
+class UpdateServerResponse:
+    server: Optional[Server]
+
+
+@dataclass
+class UpdateVolumeResponse:
+    volume: Optional[Volume]
+
+
+@dataclass
+class Volume:
     """
-    Endpoint IPv4 adress with a CIDR notation. Check documentation about IP and subnet limitations.
-    
-    One-of ('config'): at most one of 'service_ip', 'ipam_config' could be set.
+    Volume.
     """
 
-    ipam_config: Optional[ReadReplicaEndpointSpecPrivateNetworkIpamConfig]
+    id: str
     """
-    Automated configuration of your private network endpoint with Scaleway IPAM service. One at the most per RDB instance or read replica (an RDB instance and its read replica can have different private networks). Cannot be updated (has to be deleted and recreated).
-    
-    One-of ('config'): at most one of 'service_ip', 'ipam_config' could be set.
+    Volume unique ID.
     """
 
+    name: str
+    """
+    Volume name.
+    """
 
-@dataclass
-class ReadReplicaEndpointSpecPrivateNetworkIpamConfig:
-    pass
+    export_uri: Optional[str]
+    """
+    Show the volume NBD export URI.
+    :deprecated
+    """
 
+    size: int
+    """
+    Volume disk size.
+    """
 
-@dataclass
-class SetInstanceACLRulesResponse:
+    volume_type: VolumeVolumeType
     """
-    Set instance acl rules response.
+    Volume type.
     """
 
-    rules: List[ACLRule]
+    creation_date: Optional[datetime]
     """
-    ACLs rules configured for an instance.
+    Volume creation date.
     """
 
+    modification_date: Optional[datetime]
+    """
+    Volume modification date.
+    """
 
-@dataclass
-class SetInstanceSettingsResponse:
+    organization: str
     """
-    Set instance settings response.
+    Volume Organization ID.
     """
 
-    settings: List[InstanceSetting]
+    project: str
     """
-    Settings configured for a given instance.
+    Volume Project ID.
     """
 
+    tags: List[str]
+    """
+    Volume tags.
+    """
 
-@dataclass
-class Snapshot:
+    server: Optional[ServerSummary]
     """
-    Snapshot.
+    Instance attached to the volume.
     """
 
-    id: str
+    state: VolumeState
     """
-    UUID of the snapshot.
+    Volume state.
     """
 
-    instance_id: str
+    zone: Zone
     """
-    UUID of the instance.
+    Zone in which the volume is located.
     """
 
+
+@dataclass
+class VolumeServer:
+    id: str
+
     name: str
+
+    export_uri: str
+
+    organization: str
+
+    server: Optional[ServerSummary]
+
+    size: int
+
+    volume_type: VolumeServerVolumeType
+
+    creation_date: Optional[datetime]
+
+    modification_date: Optional[datetime]
+
+    state: VolumeServerState
+
+    project: str
+
+    boot: bool
+
+    zone: Zone
+
+
+@dataclass
+class VolumeServerTemplate:
     """
-    Name of the snapshot.
+    Volume server template.
     """
 
-    status: SnapshotStatus
+    id: Optional[str]
     """
-    Status of the snapshot.
+    UUID of the volume.
     """
 
-    size: Optional[int]
+    boot: Optional[bool]
     """
-    Size of the snapshot.
+    Force the Instance to boot on this volume.
     """
 
-    expires_at: Optional[datetime]
+    name: Optional[str]
     """
-    Expiration date (Format ISO 8601).
+    Name of the volume.
     """
 
-    created_at: Optional[datetime]
+    size: Optional[int]
     """
-    Creation date (Format ISO 8601).
+    Disk size of the volume, must be a multiple of 512.
     """
 
-    updated_at: Optional[datetime]
+    volume_type: VolumeVolumeType
     """
-    Updated date (Format ISO 8601).
+    Type of the volume.
     """
 
-    instance_name: str
+    base_snapshot: Optional[str]
     """
-    Name of the instance of the snapshot.
+    ID of the snapshot on which this volume will be based.
     """
 
-    node_type: str
+    organization: Optional[str]
     """
-    Source node type.
+    Organization ID of the volume.
     """
 
-    region: Region
+    project: Optional[str]
     """
-    Region of this snapshot.
+    Project ID of the volume.
     """
 
 
 @dataclass
-class UpgradableVersion:
+class VolumeSummary:
     id: str
 
     name: str
 
-    version: str
+    size: int
 
-    minor_version: str
+    volume_type: VolumeVolumeType
 
 
 @dataclass
-class User:
+class VolumeTemplate:
     """
-    User.
+    Volume template.
+    """
+
+    id: str
+    """
+    UUID of the volume.
     """
 
     name: str
     """
-    Name of the user (Length must be between 1 and 63 characters, The max Length is 32 for MySQL engines, First character must be an alphabet character (a-zA-Z), Your Username cannot start with '_rdb', Only a-zA-Z0-9_$- characters are accepted).
+    Name of the volume.
+    """
+
+    size: int
+    """
+    Disk size of the volume, must be a multiple of 512.
+    """
+
+    volume_type: VolumeVolumeType
+    """
+    Type of the volume.
     """
 
-    is_admin: bool
+    organization: Optional[str]
     """
-    Whether or not a user got administrative privileges on the database instance.
+    Organization ID of the volume.
+    
+    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
+    :deprecated
+    """
+
+    project: Optional[str]
+    """
+    Project ID of the volume.
+    
+    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
     """
 
 
 @dataclass
-class Volume:
-    type_: VolumeType
+class VolumeType:
+    display_name: str
 
-    size: int
+    capabilities: Optional[VolumeTypeCapabilities]
+
+    constraints: Optional[VolumeTypeConstraints]
 
 
 @dataclass
-class ListDatabaseEnginesRequest:
-    region: Optional[Region]
-    """
-    Region to target. If none is passed will use default region from the config.
-    """
+class VolumeTypeCapabilities:
+    snapshot: bool
 
-    name: Optional[str]
+
+@dataclass
+class VolumeTypeConstraints:
+    min: int
+
+    max: int
+
+
+@dataclass
+class GetServerTypesAvailabilityRequest:
+    zone: Optional[Zone]
     """
-    Name of the Database Engine.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    version: Optional[str]
+    per_page: Optional[int]
     """
-    Version of the Database Engine.
+    A positive integer lower or equal to 100 to select the number of items to return.
     """
 
     page: Optional[int]
-
-    page_size: Optional[int]
+    """
+    A positive integer to choose the page to return.
+    """
 
 
 @dataclass
-class ListNodeTypesRequest:
-    region: Optional[Region]
+class ListServersTypesRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    include_disabled_types: bool
+    per_page: Optional[int]
+
+    page: Optional[int]
+
+
+@dataclass
+class ListVolumesTypesRequest:
+    zone: Optional[Zone]
     """
-    Whether or not to include disabled types.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    page: Optional[int]
+    per_page: Optional[int]
 
-    page_size: Optional[int]
+    page: Optional[int]
 
 
 @dataclass
-class ListDatabaseBackupsRequest:
-    region: Optional[Region]
+class ListServersRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    name: Optional[str]
+    per_page: Optional[int]
     """
-    Name of the database backups.
+    A positive integer lower or equal to 100 to select the number of items to return.
     """
 
-    order_by: Optional[ListDatabaseBackupsRequestOrderBy]
+    page: Optional[int]
     """
-    Criteria to use when ordering database backups listing.
+    A positive integer to choose the page to return.
     """
 
-    instance_id: Optional[str]
+    organization: Optional[str]
     """
-    UUID of the instance.
+    List only Instances of this Organization ID.
     """
 
-    organization_id: Optional[str]
+    project: Optional[str]
     """
-    Organization ID the database backups belongs to.
+    List only Instances of this Project ID.
     """
 
-    project_id: Optional[str]
+    name: Optional[str]
     """
-    Project ID the database backups belongs to.
+    Filter Instances by name (eg. "server1" will return "server100" and "server1" but not "foo").
     """
 
-    page: Optional[int]
+    private_ip: Optional[str]
+    """
+    List Instances by private_ip.
+    """
+
+    without_ip: Optional[bool]
+    """
+    List Instances that are not attached to a public IP.
+    """
 
-    page_size: Optional[int]
+    commercial_type: Optional[str]
+    """
+    List Instances of this commercial type.
+    """
 
+    state: Optional[ServerState]
+    """
+    List Instances in this state.
+    """
 
-@dataclass
-class CreateDatabaseBackupRequest:
-    region: Optional[Region]
+    tags: Optional[List[str]]
     """
-    Region to target. If none is passed will use default region from the config.
+    List Instances with these exact tags (to filter with several tags, use commas to separate them).
     """
 
-    instance_id: str
+    private_network: Optional[str]
     """
-    UUID of the instance.
+    List Instances in this Private Network.
     """
 
-    database_name: str
+    order: Optional[ListServersRequestOrder]
     """
-    Name of the database you want to make a backup of.
+    Define the order of the returned servers.
     """
 
-    name: Optional[str]
+    private_networks: Optional[List[str]]
     """
-    Name of the backup.
+    List Instances from the given Private Networks (use commas to separate them).
     """
 
-    expires_at: Optional[datetime]
+
+@dataclass
+class DeleteServerRequest:
+    zone: Optional[Zone]
     """
-    Expiration date (Format ISO 8601).
+    Zone to target. If none is passed will use default zone from the config.
     """
 
+    server_id: str
+
 
 @dataclass
-class GetDatabaseBackupRequest:
-    region: Optional[Region]
+class GetServerRequest:
+    zone: Optional[Zone]
+    """
+    Zone to target. If none is passed will use default zone from the config.
+    """
+
+    server_id: str
     """
-    Region to target. If none is passed will use default region from the config.
+    UUID of the Instance you want to get.
     """
 
-    database_backup_id: str
+
+@dataclass
+class ListServerActionsRequest:
+    zone: Optional[Zone]
     """
-    UUID of the database backup.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
+    server_id: str
+
 
 @dataclass
-class UpdateDatabaseBackupRequest:
-    region: Optional[Region]
+class ServerActionRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    database_backup_id: str
+    server_id: str
     """
-    UUID of the database backup to update.
+    UUID of the Instance.
+    """
+
+    action: ServerAction
+    """
+    Action to perform on the Instance.
     """
 
     name: Optional[str]
     """
-    Name of the Database Backup.
+    Name of the backup you want to create.
+    Name of the backup you want to create.
+    This field should only be specified when performing a backup action.
     """
 
-    expires_at: Optional[datetime]
+    volumes: Optional[Dict[str, ServerActionRequestVolumeBackupTemplate]]
     """
-    Expiration date (Format ISO 8601).
+    For each volume UUID, the snapshot parameters of the volume.
+    For each volume UUID, the snapshot parameters of the volume.
+    This field should only be specified when performing a backup action.
     """
 
 
 @dataclass
-class DeleteDatabaseBackupRequest:
-    region: Optional[Region]
+class ListServerUserDataRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    database_backup_id: str
+    server_id: str
     """
-    UUID of the database backup to delete.
+    UUID of the Instance.
     """
 
 
 @dataclass
-class RestoreDatabaseBackupRequest:
-    region: Optional[Region]
+class DeleteServerUserDataRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    database_backup_id: str
+    server_id: str
     """
-    Backup of a logical database.
+    UUID of the Instance.
     """
 
-    database_name: Optional[str]
+    key: str
     """
-    Defines the destination database in order to restore into a specified database, the default destination is set to the origin database of the backup.
+    Key of the user data to delete.
     """
 
-    instance_id: str
+
+@dataclass
+class ListImagesRequest:
+    zone: Optional[Zone]
     """
-    Defines the rdb instance where the backup has to be restored.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
+    organization: Optional[str]
+
+    per_page: Optional[int]
+
+    page: Optional[int]
+
+    name: Optional[str]
+
+    public: Optional[bool]
+
+    arch: Optional[str]
+
+    project: Optional[str]
+
+    tags: Optional[str]
+
 
 @dataclass
-class ExportDatabaseBackupRequest:
-    region: Optional[Region]
+class GetImageRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    database_backup_id: str
+    image_id: str
     """
-    UUID of the database backup you want to export.
+    UUID of the image you want to get.
     """
 
 
 @dataclass
-class UpgradeInstanceRequest:
-    region: Optional[Region]
+class CreateImageRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_id: str
+    name: Optional[str]
     """
-    UUID of the instance you want to upgrade.
+    Name of the image.
     """
 
-    node_type: Optional[str]
+    root_volume: str
     """
-    Node type of the instance you want to upgrade to.
-    
-    One-of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id' could be set.
+    UUID of the snapshot.
     """
 
-    enable_ha: Optional[bool]
+    arch: Optional[Arch]
     """
-    Set to true to enable high availability on your instance.
-    
-    One-of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id' could be set.
+    Architecture of the image.
     """
 
-    volume_size: Optional[int]
+    default_bootscript: Optional[str]
     """
-    Increase your block storage volume size.
-    
-    One-of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id' could be set.
+    Default bootscript of the image.
+    :deprecated
     """
 
-    volume_type: Optional[VolumeType]
+    extra_volumes: Optional[Dict[str, VolumeTemplate]]
     """
-    Change your instance storage type.
-    
-    One-of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id' could be set.
+    Additional volumes of the image.
     """
 
-    upgradable_version_id: Optional[str]
+    organization: Optional[str]
     """
-    This will create a new Database Instance with same instance specification as the current one and perform a Database Engine upgrade.
+    Organization ID of the image.
     
-    One-of ('upgrade_target'): at most one of 'node_type', 'enable_ha', 'volume_size', 'volume_type', 'upgradable_version_id' could be set.
+    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
+    :deprecated
     """
 
-
-@dataclass
-class ListInstancesRequest:
-    region: Optional[Region]
+    project: Optional[str]
     """
-    Region to target. If none is passed will use default region from the config.
+    Project ID of the image.
+    
+    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
     """
 
     tags: Optional[List[str]]
     """
-    List instance that have a given tags.
+    Tags of the image.
     """
 
-    name: Optional[str]
+    public: Optional[bool]
     """
-    List instance that match a given name pattern.
+    True to create a public image.
     """
 
-    order_by: Optional[ListInstancesRequestOrderBy]
+
+@dataclass
+class DeleteImageRequest:
+    zone: Optional[Zone]
     """
-    Criteria to use when ordering instance listing.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    organization_id: Optional[str]
+    image_id: str
     """
-    Please use `project_id` instead.
+    UUID of the image you want to delete.
     """
 
-    project_id: Optional[str]
+
+@dataclass
+class ListSnapshotsRequest:
+    zone: Optional[Zone]
     """
-    Project ID to list the instance of.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
+    organization: Optional[str]
+
+    per_page: Optional[int]
+
     page: Optional[int]
 
-    page_size: Optional[int]
+    name: Optional[str]
+
+    project: Optional[str]
+
+    tags: Optional[str]
 
 
 @dataclass
-class GetInstanceRequest:
-    region: Optional[Region]
+class CreateSnapshotRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_id: str
+    name: Optional[str]
     """
-    UUID of the instance.
+    Name of the snapshot.
     """
 
+    volume_id: Optional[str]
+    """
+    UUID of the volume.
+    """
 
-@dataclass
-class CreateInstanceRequest:
-    region: Optional[Region]
+    tags: Optional[List[str]]
     """
-    Region to target. If none is passed will use default region from the config.
+    Tags of the snapshot.
     """
 
-    organization_id: Optional[str]
+    organization: Optional[str]
     """
-    Please use `project_id` instead.
+    Organization ID of the snapshot.
     
-    One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
+    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
     :deprecated
     """
 
-    project_id: Optional[str]
+    project: Optional[str]
     """
-    The project ID on which to create the instance.
+    Project ID of the snapshot.
     
-    One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
+    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
     """
 
-    name: Optional[str]
+    volume_type: SnapshotVolumeType
     """
-    Name of the instance.
+    Volume type of the snapshot.
+    Overrides the volume_type of the snapshot.
+    If omitted, the volume type of the original volume will be used.
     """
 
-    engine: str
+    bucket: Optional[str]
     """
-    Database engine of the database (PostgreSQL, MySQL, ...).
+    Bucket name for snapshot imports.
     """
 
-    user_name: str
+    key: Optional[str]
     """
-    Name of the user created when the instance is created.
+    Object key for snapshot imports.
     """
 
-    password: str
+    size: Optional[int]
     """
-    Password of the user.
+    Imported snapshot size, must be a multiple of 512.
     """
 
-    node_type: str
-    """
-    Type of node to use for the instance.
-    """
 
-    is_ha_cluster: bool
+@dataclass
+class GetSnapshotRequest:
+    zone: Optional[Zone]
     """
-    Whether or not High-Availability is enabled.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    disable_backup: bool
+    snapshot_id: str
     """
-    Whether or not backups are disabled.
+    UUID of the snapshot you want to get.
     """
 
-    tags: Optional[List[str]]
+
+@dataclass
+class DeleteSnapshotRequest:
+    zone: Optional[Zone]
     """
-    Tags to apply to the instance.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    init_settings: Optional[List[InstanceSetting]]
+    snapshot_id: str
     """
-    List of engine settings to be set at database initialisation.
+    UUID of the snapshot you want to delete.
     """
 
-    volume_type: VolumeType
+
+@dataclass
+class ExportSnapshotRequest:
+    zone: Optional[Zone]
     """
-    Type of volume where data are stored (lssd, bssd, ...).
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    volume_size: int
+    snapshot_id: str
     """
-    Volume size when volume_type is not lssd.
+    Snapshot ID.
     """
 
-    init_endpoints: Optional[List[EndpointSpec]]
+    bucket: str
     """
-    One or multiple EndpointSpec used to expose your database instance. A load_balancer public endpoint is systematically created.
+    S3 bucket name.
     """
 
-    backup_same_region: bool
+    key: str
     """
-    Store logical backups in the same region as the database instance.
+    S3 object key.
     """
 
 
 @dataclass
-class UpdateInstanceRequest:
-    region: Optional[Region]
+class ListVolumesRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_id: str
+    volume_type: Optional[VolumeVolumeType]
     """
-    UUID of the instance to update.
+    Filter by volume type.
     """
 
-    backup_schedule_frequency: Optional[int]
+    per_page: Optional[int]
     """
-    In hours.
+    A positive integer lower or equal to 100 to select the number of items to return.
     """
 
-    backup_schedule_retention: Optional[int]
+    page: Optional[int]
     """
-    In days.
+    A positive integer to choose the page to return.
     """
 
-    is_backup_schedule_disabled: Optional[bool]
+    organization: Optional[str]
     """
-    Whether or not the backup schedule is disabled.
+    Filter volume by Organization ID.
     """
 
-    name: Optional[str]
+    project: Optional[str]
     """
-    Name of the instance.
+    Filter volume by Project ID.
     """
 
     tags: Optional[List[str]]
     """
-    Tags of a given instance.
+    Filter volumes with these exact tags (to filter with several tags, use commas to separate them).
     """
 
-    logs_policy: Optional[LogsPolicy]
-    """
-    Logs policy of the instance.
-    """
-
-    backup_same_region: Optional[bool]
+    name: Optional[str]
     """
-    Store logical backups in the same region as the database instance.
+    Filter volume by name (for eg. "vol" will return "myvolume" but not "data").
     """
 
 
 @dataclass
-class DeleteInstanceRequest:
-    region: Optional[Region]
+class CreateVolumeRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_id: str
+    name: Optional[str]
     """
-    UUID of the instance to delete.
+    Volume name.
     """
 
-
-@dataclass
-class CloneInstanceRequest:
-    region: Optional[Region]
+    organization: Optional[str]
     """
-    Region to target. If none is passed will use default region from the config.
+    Volume Organization ID.
+    
+    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
+    :deprecated
     """
 
-    instance_id: str
+    project: Optional[str]
     """
-    UUID of the instance you want to clone.
+    Volume Project ID.
+    
+    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
     """
 
-    name: str
+    tags: Optional[List[str]]
     """
-    Name of the clone instance.
+    Volume tags.
     """
 
-    node_type: Optional[str]
+    volume_type: VolumeVolumeType
     """
-    Node type of the clone.
+    Volume type.
     """
 
+    size: Optional[int]
+    """
+    Volume disk size, must be a multiple of 512.
+    
+    One-of ('from_'): at most one of 'size', 'base_volume', 'base_snapshot' could be set.
+    """
 
-@dataclass
-class RestartInstanceRequest:
-    region: Optional[Region]
+    base_volume: Optional[str]
     """
-    Region to target. If none is passed will use default region from the config.
+    ID of the volume on which this volume will be based.
+    
+    One-of ('from_'): at most one of 'size', 'base_volume', 'base_snapshot' could be set.
     """
 
-    instance_id: str
+    base_snapshot: Optional[str]
     """
-    UUID of the instance you want to restart.
+    ID of the snapshot on which this volume will be based.
+    
+    One-of ('from_'): at most one of 'size', 'base_volume', 'base_snapshot' could be set.
     """
 
 
 @dataclass
-class GetInstanceCertificateRequest:
-    region: Optional[Region]
+class GetVolumeRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_id: str
+    volume_id: str
     """
-    UUID of the instance.
+    UUID of the volume you want to get.
     """
 
 
 @dataclass
-class RenewInstanceCertificateRequest:
-    region: Optional[Region]
+class UpdateVolumeRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_id: str
+    volume_id: str
     """
-    UUID of the instance you want logs of.
+    UUID of the volume.
     """
 
-
-@dataclass
-class GetInstanceMetricsRequest:
-    region: Optional[Region]
+    name: Optional[str]
     """
-    Region to target. If none is passed will use default region from the config.
+    Volume name.
     """
 
-    instance_id: str
+    tags: Optional[List[str]]
     """
-    UUID of the instance.
+    Tags of the volume.
     """
 
-    start_date: Optional[datetime]
+    size: Optional[int]
     """
-    Start date to gather metrics from.
+    Volume disk size, must be a multiple of 512.
     """
 
-    end_date: Optional[datetime]
+
+@dataclass
+class DeleteVolumeRequest:
+    zone: Optional[Zone]
     """
-    End date to gather metrics from.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    metric_name: Optional[str]
+    volume_id: str
     """
-    Name of the metric to gather.
+    UUID of the volume you want to delete.
     """
 
 
 @dataclass
-class CreateReadReplicaRequest:
-    region: Optional[Region]
+class ListSecurityGroupsRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_id: str
+    name: Optional[str]
     """
-    UUID of the instance you want a read replica of.
+    Name of the security group.
     """
 
-    endpoint_spec: Optional[List[ReadReplicaEndpointSpec]]
+    organization: Optional[str]
     """
-    Specification of the endpoint you want to create.
+    Security group Organization ID.
     """
 
-
-@dataclass
-class GetReadReplicaRequest:
-    region: Optional[Region]
+    project: Optional[str]
     """
-    Region to target. If none is passed will use default region from the config.
+    Security group Project ID.
     """
 
-    read_replica_id: str
+    tags: Optional[List[str]]
     """
-    UUID of the read replica.
+    List security groups with these exact tags (to filter with several tags, use commas to separate them).
     """
 
+    project_default: Optional[bool]
+    """
+    Filter security groups with this value for project_default.
+    """
 
-@dataclass
-class DeleteReadReplicaRequest:
-    region: Optional[Region]
+    per_page: Optional[int]
     """
-    Region to target. If none is passed will use default region from the config.
+    A positive integer lower or equal to 100 to select the number of items to return.
     """
 
-    read_replica_id: str
+    page: Optional[int]
     """
-    UUID of the read replica.
+    A positive integer to choose the page to return.
     """
 
 
 @dataclass
-class ResetReadReplicaRequest:
-    region: Optional[Region]
+class CreateSecurityGroupRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    read_replica_id: str
+    name: Optional[str]
     """
-    UUID of the read replica.
+    Name of the security group.
     """
 
-
-@dataclass
-class CreateReadReplicaEndpointRequest:
-    region: Optional[Region]
+    description: str
     """
-    Region to target. If none is passed will use default region from the config.
+    Description of the security group.
     """
 
-    read_replica_id: str
+    organization: Optional[str]
     """
-    UUID of the read replica.
+    Organization ID the security group belongs to.
+    
+    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
+    :deprecated
     """
 
-    endpoint_spec: List[ReadReplicaEndpointSpec]
+    project: Optional[str]
     """
-    Specification of the endpoint you want to create.
+    Project ID the security group belong to.
+    
+    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
     """
 
-
-@dataclass
-class PrepareInstanceLogsRequest:
-    region: Optional[Region]
+    tags: Optional[List[str]]
     """
-    Region to target. If none is passed will use default region from the config.
+    Tags of the security group.
     """
 
-    instance_id: str
+    organization_default: Optional[bool]
     """
-    UUID of the instance you want logs of.
+    Defines whether this security group becomes the default security group for new Instances.
+    
+    One-of ('default_identifier'): at most one of 'organization_default', 'project_default' could be set.
+    :deprecated
     """
 
-    start_date: Optional[datetime]
+    project_default: Optional[bool]
     """
-    Start datetime of your log. Format: `{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z`.
+    Whether this security group becomes the default security group for new Instances.
+    
+    One-of ('default_identifier'): at most one of 'organization_default', 'project_default' could be set.
     """
 
-    end_date: Optional[datetime]
+    stateful: bool
     """
-    End datetime of your log. Format: `{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z`.
+    Whether the security group is stateful or not.
     """
 
-
-@dataclass
-class ListInstanceLogsRequest:
-    region: Optional[Region]
+    inbound_default_policy: SecurityGroupPolicy
     """
-    Region to target. If none is passed will use default region from the config.
+    Default policy for inbound rules.
     """
 
-    instance_id: str
+    outbound_default_policy: SecurityGroupPolicy
     """
-    UUID of the instance you want logs of.
+    Default policy for outbound rules.
     """
 
-    order_by: ListInstanceLogsRequestOrderBy
+    enable_default_security: Optional[bool]
     """
-    Criteria to use when ordering instance logs listing.
+    True to block SMTP on IPv4 and IPv6. This feature is read only, please open a support ticket if you need to make it configurable.
     """
 
 
 @dataclass
-class GetInstanceLogRequest:
-    region: Optional[Region]
+class GetSecurityGroupRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_log_id: str
+    security_group_id: str
     """
-    UUID of the instance_log you want.
+    UUID of the security group you want to get.
     """
 
 
 @dataclass
-class PurgeInstanceLogsRequest:
-    region: Optional[Region]
+class DeleteSecurityGroupRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_id: str
+    security_group_id: str
     """
-    UUID of the instance you want logs of.
+    UUID of the security group you want to delete.
     """
 
-    log_name: Optional[str]
+
+@dataclass
+class ListDefaultSecurityGroupRulesRequest:
+    zone: Optional[Zone]
     """
-    Specific log name to purge.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
 
 @dataclass
-class ListInstanceLogsDetailsRequest:
-    region: Optional[Region]
+class ListSecurityGroupRulesRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_id: str
+    security_group_id: str
     """
-    UUID of the instance you want logs of.
+    UUID of the security group.
     """
 
+    per_page: Optional[int]
+    """
+    A positive integer lower or equal to 100 to select the number of items to return.
+    """
 
-@dataclass
-class AddInstanceSettingsRequest:
-    region: Optional[Region]
+    page: Optional[int]
     """
-    Region to target. If none is passed will use default region from the config.
+    A positive integer to choose the page to return.
     """
 
-    instance_id: str
+
+@dataclass
+class CreateSecurityGroupRuleRequest:
+    zone: Optional[Zone]
     """
-    UUID of the instance you want to add settings to.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    settings: List[InstanceSetting]
+    security_group_id: str
     """
-    Settings to add on the instance.
+    UUID of the security group.
     """
 
+    protocol: Optional[SecurityGroupRuleProtocol]
 
-@dataclass
-class DeleteInstanceSettingsRequest:
-    region: Optional[Region]
+    direction: Optional[SecurityGroupRuleDirection]
+
+    action: Optional[SecurityGroupRuleAction]
+
+    ip_range: str
+
+    dest_port_from: Optional[int]
     """
-    Region to target. If none is passed will use default region from the config.
+    Beginning of the range of ports to apply this rule to (inclusive).
     """
 
-    instance_id: str
+    dest_port_to: Optional[int]
     """
-    UUID of the instance to delete settings from.
+    End of the range of ports to apply this rule to (inclusive).
     """
 
-    setting_names: List[str]
+    position: int
     """
-    Settings names to delete.
+    Position of this rule in the security group rules list.
+    """
+
+    editable: bool
+    """
+    Indicates if this rule is editable (will be ignored).
     """
 
 
 @dataclass
-class SetInstanceSettingsRequest:
-    region: Optional[Region]
+class SetSecurityGroupRulesRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_id: str
+    security_group_id: str
     """
-    UUID of the instance where the settings has to be set.
+    UUID of the security group to update the rules on.
     """
 
-    settings: List[InstanceSetting]
+    rules: Optional[List[SetSecurityGroupRulesRequestRule]]
     """
-    Settings to define for the instance.
+    List of rules to update in the security group.
     """
 
 
 @dataclass
-class ListInstanceACLRulesRequest:
-    region: Optional[Region]
+class DeleteSecurityGroupRuleRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_id: str
+    security_group_id: str
+
+    security_group_rule_id: str
+
+
+@dataclass
+class GetSecurityGroupRuleRequest:
+    zone: Optional[Zone]
     """
-    UUID of the instance.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    page: Optional[int]
+    security_group_id: str
 
-    page_size: Optional[int]
+    security_group_rule_id: str
 
 
 @dataclass
-class AddInstanceACLRulesRequest:
-    region: Optional[Region]
+class ListPlacementGroupsRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_id: str
+    per_page: Optional[int]
     """
-    UUID of the instance you want to add acl rules to.
+    A positive integer lower or equal to 100 to select the number of items to return.
     """
 
-    rules: List[ACLRuleRequest]
+    page: Optional[int]
     """
-    ACLs rules to add to the instance.
+    A positive integer to choose the page to return.
     """
 
+    organization: Optional[str]
+    """
+    List only placement groups of this Organization ID.
+    """
 
-@dataclass
-class SetInstanceACLRulesRequest:
-    region: Optional[Region]
+    project: Optional[str]
     """
-    Region to target. If none is passed will use default region from the config.
+    List only placement groups of this Project ID.
     """
 
-    instance_id: str
+    tags: Optional[List[str]]
     """
-    UUID of the instance where the ACL rules has to be set.
+    List placement groups with these exact tags (to filter with several tags, use commas to separate them).
     """
 
-    rules: List[ACLRuleRequest]
+    name: Optional[str]
     """
-    ACL rules to define for the instance.
+    Filter placement groups by name (for eg. "cluster1" will return "cluster100" and "cluster1" but not "foo").
     """
 
 
 @dataclass
-class DeleteInstanceACLRulesRequest:
-    region: Optional[Region]
+class CreatePlacementGroupRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_id: str
+    name: Optional[str]
     """
-    UUID of the instance you want to delete an ACL rules from.
+    Name of the placement group.
     """
 
-    acl_rule_ips: List[str]
+    organization: Optional[str]
     """
-    ACL rules IP present on the instance.
+    Organization ID of the placement group.
+    
+    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
+    :deprecated
     """
 
-
-@dataclass
-class ListUsersRequest:
-    region: Optional[Region]
+    project: Optional[str]
     """
-    Region to target. If none is passed will use default region from the config.
+    Project ID of the placement group.
+    
+    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
     """
 
-    instance_id: str
+    tags: Optional[List[str]]
     """
-    UUID of the instance.
+    Tags of the placement group.
     """
 
-    name: Optional[str]
+    policy_mode: PlacementGroupPolicyMode
     """
-    Name of the user.
+    Operating mode of the placement group.
     """
 
-    order_by: Optional[ListUsersRequestOrderBy]
+    policy_type: PlacementGroupPolicyType
     """
-    Criteria to use when ordering users listing.
+    Policy type of the placement group.
     """
 
-    page: Optional[int]
-
-    page_size: Optional[int]
-
 
 @dataclass
-class CreateUserRequest:
-    region: Optional[Region]
+class GetPlacementGroupRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_id: str
+    placement_group_id: str
     """
-    UUID of the instance you want to create a user in.
+    UUID of the placement group you want to get.
     """
 
-    name: str
-    """
-    Name of the user you want to create.
-    """
 
-    password: str
+@dataclass
+class SetPlacementGroupRequest:
+    zone: Optional[Zone]
     """
-    Password of the user you want to create.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    is_admin: bool
-    """
-    Whether the user you want to create will have administrative privileges.
-    """
+    placement_group_id: str
+
+    name: str
+
+    organization: Optional[str]
+
+    policy_mode: PlacementGroupPolicyMode
+
+    policy_type: PlacementGroupPolicyType
+
+    project: Optional[str]
+
+    tags: Optional[List[str]]
 
 
 @dataclass
-class UpdateUserRequest:
-    region: Optional[Region]
+class UpdatePlacementGroupRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_id: str
+    placement_group_id: str
     """
-    UUID of the instance the user belongs to.
+    UUID of the placement group.
     """
 
-    name: str
+    name: Optional[str]
     """
-    Name of the database user.
+    Name of the placement group.
     """
 
-    password: Optional[str]
+    tags: Optional[List[str]]
     """
-    Password of the database user.
+    Tags of the placement group.
     """
 
-    is_admin: Optional[bool]
+    policy_mode: Optional[PlacementGroupPolicyMode]
     """
-    Whether or not this user got administrative privileges.
+    Operating mode of the placement group.
     """
 
-
-@dataclass
-class DeleteUserRequest:
-    region: Optional[Region]
+    policy_type: Optional[PlacementGroupPolicyType]
     """
-    Region to target. If none is passed will use default region from the config.
+    Policy type of the placement group.
     """
 
-    instance_id: str
+
+@dataclass
+class DeletePlacementGroupRequest:
+    zone: Optional[Zone]
     """
-    UUID of the instance to delete a user from.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    name: str
+    placement_group_id: str
     """
-    Name of the user.
+    UUID of the placement group you want to delete.
     """
 
 
 @dataclass
-class ListDatabasesRequest:
-    region: Optional[Region]
+class GetPlacementGroupServersRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_id: str
+    placement_group_id: str
     """
-    UUID of the instance to list database of.
+    UUID of the placement group you want to get.
     """
 
-    name: Optional[str]
-    """
-    Name of the database.
-    """
 
-    managed: Optional[bool]
+@dataclass
+class SetPlacementGroupServersRequest:
+    zone: Optional[Zone]
     """
-    Whether or not the database is managed.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    owner: Optional[str]
+    placement_group_id: str
     """
-    User that owns this database.
+    UUID of the placement group you want to set.
     """
 
-    order_by: Optional[ListDatabasesRequestOrderBy]
+    servers: List[str]
     """
-    Criteria to use when ordering database listing.
+    An array of the Instances' UUIDs you want to configure.
     """
 
-    page: Optional[int]
-
-    page_size: Optional[int]
-
 
 @dataclass
-class CreateDatabaseRequest:
-    region: Optional[Region]
+class UpdatePlacementGroupServersRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_id: str
+    placement_group_id: str
     """
-    UUID of the instance where to create the database.
+    UUID of the placement group you want to update.
     """
 
-    name: str
+    servers: List[str]
     """
-    Name of the database.
+    An array of the Instances' UUIDs you want to configure.
     """
 
 
 @dataclass
-class DeleteDatabaseRequest:
-    region: Optional[Region]
+class ListIpsRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_id: str
+    project: Optional[str]
     """
-    UUID of the instance where to delete the database.
+    Project ID in which the IPs are reserved.
     """
 
-    name: str
+    organization: Optional[str]
     """
-    Name of the database to delete.
+    Organization ID in which the IPs are reserved.
     """
 
-
-@dataclass
-class ListPrivilegesRequest:
-    region: Optional[Region]
+    tags: Optional[List[str]]
     """
-    Region to target. If none is passed will use default region from the config.
+    Filter IPs with these exact tags (to filter with several tags, use commas to separate them).
     """
 
-    instance_id: str
+    name: Optional[str]
     """
-    UUID of the instance.
+    Filter on the IP address (Works as a LIKE operation on the IP address).
     """
 
-    order_by: Optional[ListPrivilegesRequestOrderBy]
+    per_page: Optional[int]
     """
-    Criteria to use when ordering privileges listing.
+    A positive integer lower or equal to 100 to select the number of items to return.
     """
 
     page: Optional[int]
-
-    page_size: Optional[int]
-
-    database_name: Optional[str]
     """
-    Name of the database.
+    A positive integer to choose the page to return.
     """
 
-    user_name: Optional[str]
+
+@dataclass
+class CreateIpRequest:
+    zone: Optional[Zone]
     """
-    Name of the user.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-
-@dataclass
-class SetPrivilegeRequest:
-    region: Optional[Region]
+    organization: Optional[str]
     """
-    Region to target. If none is passed will use default region from the config.
+    Organization ID in which the IP is reserved.
+    
+    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
+    :deprecated
     """
 
-    instance_id: str
+    project: Optional[str]
     """
-    UUID of the instance.
+    Project ID in which the IP is reserved.
+    
+    One-of ('project_identifier'): at most one of 'organization', 'project' could be set.
     """
 
-    database_name: str
+    tags: Optional[List[str]]
     """
-    Name of the database.
+    Tags of the IP.
     """
 
-    user_name: str
+    server: Optional[str]
     """
-    Name of the user.
+    UUID of the Instance you want to attach the IP to.
     """
 
-    permission: Permission
+    type_: IpType
     """
-    Permission to set (Read, Read/Write, All, Custom).
+    IP type to reserve (either 'nat', 'routed_ipv4' or 'routed_ipv6').
     """
 
 
 @dataclass
-class ListSnapshotsRequest:
-    region: Optional[Region]
+class GetIpRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    name: Optional[str]
+    ip: str
     """
-    Name of the snapshot.
+    IP ID or address to get.
     """
 
-    order_by: Optional[ListSnapshotsRequestOrderBy]
+
+@dataclass
+class UpdateIpRequest:
+    zone: Optional[Zone]
     """
-    Criteria to use when ordering snapshot listing.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_id: Optional[str]
+    ip: str
     """
-    UUID of the instance.
+    IP ID or IP address.
     """
 
-    organization_id: Optional[str]
+    reverse: Optional[str]
     """
-    Organization ID the snapshots belongs to.
+    Reverse domain name.
     """
 
-    project_id: Optional[str]
+    type_: IpType
     """
-    Project ID the snapshots belongs to.
+    Convert a 'nat' IP to a 'routed_ipv4'.
     """
 
-    page: Optional[int]
+    tags: Optional[List[str]]
+    """
+    An array of keywords you want to tag this IP with.
+    """
 
-    page_size: Optional[int]
+    server: Optional[str]
 
 
 @dataclass
-class GetSnapshotRequest:
-    region: Optional[Region]
+class DeleteIpRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    snapshot_id: str
+    ip: str
     """
-    UUID of the snapshot.
+    ID or address of the IP to delete.
     """
 
 
 @dataclass
-class CreateSnapshotRequest:
-    region: Optional[Region]
+class ListPrivateNICsRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_id: str
+    server_id: str
     """
-    UUID of the instance.
+    Instance to which the private NIC is attached.
     """
 
-    name: Optional[str]
+    tags: Optional[List[str]]
     """
-    Name of the snapshot.
+    Private NIC tags.
     """
 
-    expires_at: Optional[datetime]
+    per_page: Optional[int]
     """
-    Expiration date (Format ISO 8601).
+    A positive integer lower or equal to 100 to select the number of items to return.
+    """
+
+    page: Optional[int]
+    """
+    A positive integer to choose the page to return.
     """
 
 
 @dataclass
-class UpdateSnapshotRequest:
-    region: Optional[Region]
+class CreatePrivateNICRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    snapshot_id: str
+    server_id: str
     """
-    UUID of the snapshot to update.
+    UUID of the Instance the private NIC will be attached to.
     """
 
-    name: Optional[str]
+    private_network_id: str
     """
-    Name of the snapshot.
+    UUID of the private network where the private NIC will be attached.
     """
 
-    expires_at: Optional[datetime]
+    tags: Optional[List[str]]
+    """
+    Private NIC tags.
+    """
+
+    ip_ids: Optional[List[str]]
     """
-    Expiration date (Format ISO 8601).
+    Ip_ids defined from IPAM.
     """
 
 
 @dataclass
-class DeleteSnapshotRequest:
-    region: Optional[Region]
+class GetPrivateNICRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    snapshot_id: str
+    server_id: str
     """
-    UUID of the snapshot to delete.
+    Instance to which the private NIC is attached.
     """
 
-
-@dataclass
-class CreateInstanceFromSnapshotRequest:
-    region: Optional[Region]
+    private_nic_id: str
     """
-    Region to target. If none is passed will use default region from the config.
+    Private NIC unique ID.
     """
 
-    snapshot_id: str
+
+@dataclass
+class UpdatePrivateNICRequest:
+    zone: Optional[Zone]
     """
-    Block snapshot of the instance.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_name: str
+    server_id: str
     """
-    Name of the instance created with the snapshot.
+    UUID of the Instance the private NIC will be attached to.
     """
 
-    is_ha_cluster: Optional[bool]
+    private_nic_id: str
     """
-    Whether or not High-Availability is enabled on the new instance.
+    Private NIC unique ID.
     """
 
-    node_type: Optional[str]
+    tags: Optional[List[str]]
     """
-    The node type used to restore the snapshot.
+    Tags used to select private NIC/s.
     """
 
 
 @dataclass
-class CreateEndpointRequest:
-    region: Optional[Region]
+class DeletePrivateNICRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    instance_id: str
+    server_id: str
     """
-    UUID of the instance you want to add endpoint to.
+    Instance to which the private NIC is attached.
     """
 
-    endpoint_spec: Optional[EndpointSpec]
+    private_nic_id: str
     """
-    Specification of the endpoint you want to create.
+    Private NIC unique ID.
     """
 
 
 @dataclass
-class DeleteEndpointRequest:
-    region: Optional[Region]
+class ListBootscriptsRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    endpoint_id: str
-    """
-    This endpoint can also be used to delete a read replica endpoint.
-    """
+    arch: Optional[str]
+
+    title: Optional[str]
+
+    default: Optional[bool]
+
+    public: Optional[bool]
+
+    per_page: Optional[int]
+
+    page: Optional[int]
 
 
 @dataclass
-class GetEndpointRequest:
-    region: Optional[Region]
+class GetBootscriptRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    endpoint_id: str
-    """
-    UUID of the endpoint you want to get.
-    """
+    bootscript_id: str
 
 
 @dataclass
-class MigrateEndpointRequest:
-    region: Optional[Region]
+class GetDashboardRequest:
+    zone: Optional[Zone]
     """
-    Region to target. If none is passed will use default region from the config.
+    Zone to target. If none is passed will use default zone from the config.
     """
 
-    endpoint_id: str
-    """
-    UUID of the endpoint you want to migrate.
-    """
+    organization: Optional[str]
 
-    instance_id: str
-    """
-    UUID of the instance you want to attach the endpoint to.
-    """
+    project: Optional[str]
```

### Comparing `scaleway_async-0.9.0/scaleway_async/redis/v1/__init__.py` & `scaleway_async-1.0.0/scaleway_async/redis/v1/__init__.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,26 +1,28 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 from .types import AvailableClusterSettingPropertyType
 from .types import ClusterStatus
 from .types import ListClustersRequestOrderBy
 from .types import NodeTypeStock
+from .types import PrivateNetworkProvisioningMode
 from .types import ACLRule
 from .types import ACLRuleSpec
 from .types import AddAclRulesResponse
 from .types import AddEndpointsResponse
 from .types import AvailableClusterSetting
 from .types import Cluster
 from .types import ClusterMetricsResponse
 from .types import ClusterSetting
 from .types import ClusterSettingsResponse
 from .types import ClusterVersion
 from .types import Endpoint
 from .types import EndpointSpec
 from .types import EndpointSpecPrivateNetworkSpec
+from .types import EndpointSpecPrivateNetworkSpecIpamConfig
 from .types import EndpointSpecPublicNetworkSpec
 from .types import ListClusterVersionsResponse
 from .types import ListClustersResponse
 from .types import ListNodeTypesResponse
 from .types import NodeType
 from .types import PrivateNetwork
 from .types import PublicNetwork
@@ -30,27 +32,29 @@
 from .api import RedisV1API
 
 __all__ = [
     "AvailableClusterSettingPropertyType",
     "ClusterStatus",
     "ListClustersRequestOrderBy",
     "NodeTypeStock",
+    "PrivateNetworkProvisioningMode",
     "ACLRule",
     "ACLRuleSpec",
     "AddAclRulesResponse",
     "AddEndpointsResponse",
     "AvailableClusterSetting",
     "Cluster",
     "ClusterMetricsResponse",
     "ClusterSetting",
     "ClusterSettingsResponse",
     "ClusterVersion",
     "Endpoint",
     "EndpointSpec",
     "EndpointSpecPrivateNetworkSpec",
+    "EndpointSpecPrivateNetworkSpecIpamConfig",
     "EndpointSpecPublicNetworkSpec",
     "ListClusterVersionsResponse",
     "ListClustersResponse",
     "ListNodeTypesResponse",
     "NodeType",
     "PrivateNetwork",
     "PublicNetwork",
```

### Comparing `scaleway_async-0.9.0/scaleway_async/redis/v1/api.py` & `scaleway_async-1.0.0/scaleway_async/redis/v1/api.py`

 * *Files 18% similar despite different names*

```diff
@@ -77,14 +77,16 @@
     unmarshal_SetEndpointsResponse,
 )
 
 
 class RedisV1API(API):
     """
     Managed Database for Redis API.
+
+    Managed Database for Redis API.
     """
 
     async def create_cluster(
         self,
         *,
         version: str,
         node_type: str,
@@ -97,28 +99,30 @@
         tags: Optional[List[str]] = None,
         cluster_size: Optional[int] = None,
         acl_rules: Optional[List[ACLRuleSpec]] = None,
         endpoints: Optional[List[EndpointSpec]] = None,
         cluster_settings: Optional[List[ClusterSetting]] = None,
     ) -> Cluster:
         """
-        Create a cluster
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param project_id: The project ID on which to create the cluster
-        :param name: Name of the cluster
-        :param version: Redis engine version of the cluster
-        :param tags: Tags to apply to the cluster
-        :param node_type: Type of node to use for the cluster
-        :param user_name: Name of the user created when the cluster is created
-        :param password: Password of the user
-        :param cluster_size: Number of nodes for the cluster
-        :param acl_rules: List of ACLRuleSpec used to secure your publicly exposed cluster
-        :param endpoints: Zero or multiple EndpointSpec used to expose your cluster publicly and inside private networks. If no EndpoindSpec is given the cluster will be publicly exposed by default.
-        :param tls_enabled: Whether or not TLS is enabled
-        :param cluster_settings: List of cluster settings to be set at cluster initialisation
+        Create a Redis Database Instance.
+        Create a new Redis Database Instance (Redis cluster). You must set the `zone`, `project_id`, `version`, `node_type`, `user_name` and `password` parameters. Optionally you can define `acl_rules`, `endpoints`, `tls_enabled` and `cluster_settings`.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param project_id: Project ID in which to create the Database Instance.
+        :param name: Name of the Database Instance.
+        :param version: Redis engine version of the Database Instance.
+        :param tags: Tags to apply to the Database Instance.
+        :param node_type: Type of node to use for the Database Instance.
+        :param user_name: Name of the user created upon Database Instance creation.
+        :param password: Password of the user.
+        :param cluster_size: Number of nodes in the Redis cluster.
+        :param acl_rules: List of ACLRuleSpec used to secure your publicly exposed cluster.
+        :param endpoints: Zero or multiple EndpointSpec used to expose your cluster publicly and inside Private Networks.
+        Zero or multiple EndpointSpec used to expose your cluster publicly and inside private networks. If no EndpoindSpec is given the cluster will be publicly exposed by default.
+        :param tls_enabled: Defines whether or not TLS is enabled.
+        :param cluster_settings: List of advanced settings to be set upon Database Instance initialization.
         :return: :class:`Cluster <Cluster>`
 
         Usage:
         ::
 
             result = await api.create_cluster(
                 version="example",
@@ -164,21 +168,22 @@
         zone: Optional[Zone] = None,
         name: Optional[str] = None,
         tags: Optional[List[str]] = None,
         user_name: Optional[str] = None,
         password: Optional[str] = None,
     ) -> Cluster:
         """
-        Update a cluster
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param cluster_id: UUID of the cluster to update
-        :param name: Name of the cluster
-        :param tags: Tags of a given cluster
-        :param user_name: Name of the cluster user
-        :param password: Password of the cluster user
+        Update a Redis Database Instance.
+        Update the parameters of a Redis Database Instance (Redis cluster), including `name`, `tags`, `user_name` and `password`.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param cluster_id: UUID of the Database Instance to update.
+        :param name: Name of the Database Instance.
+        :param tags: Database Instance tags.
+        :param user_name: Name of the Database Instance user.
+        :param password: Password of the Database Instance user.
         :return: :class:`Cluster <Cluster>`
 
         Usage:
         ::
 
             result = await api.update_cluster(cluster_id="example")
         """
@@ -208,17 +213,18 @@
     async def get_cluster(
         self,
         *,
         cluster_id: str,
         zone: Optional[Zone] = None,
     ) -> Cluster:
         """
-        Get a cluster
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param cluster_id: UUID of the cluster
+        Get a Redis Database Instance.
+        Retrieve information about a Redis Database Instance (Redis cluster). Specify the `cluster_id` and `region` in your request to get information such as `id`, `status`, `version`, `tls_enabled`, `cluster_settings`, `upgradable_versions` and `endpoints` about your cluster in the response.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param cluster_id: UUID of the cluster.
         :return: :class:`Cluster <Cluster>`
 
         Usage:
         ::
 
             result = await api.get_cluster(cluster_id="example")
         """
@@ -239,16 +245,16 @@
         *,
         cluster_id: str,
         zone: Optional[Zone] = None,
         options: Optional[WaitForOptions[Cluster, Union[bool, Awaitable[bool]]]] = None,
     ) -> Cluster:
         """
         Waits for :class:`Cluster <Cluster>` to be in a final state.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param cluster_id: UUID of the cluster
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param cluster_id: UUID of the cluster.
         :param options: The options for the waiter
         :return: :class:`Cluster <Cluster>`
 
         Usage:
         ::
 
             result = api.wait_for_cluster(cluster_id="example")
@@ -279,22 +285,23 @@
         project_id: Optional[str] = None,
         organization_id: Optional[str] = None,
         version: Optional[str] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListClustersResponse:
         """
-        List clusters
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param tags: Tags of the clusters to filter upon
-        :param name: Name of the clusters to filter upon
-        :param order_by: Criteria to use when ordering cluster listing
-        :param project_id: Project ID to list the cluster of
-        :param organization_id: Organization ID to list the cluster of
-        :param version: Version of the clusters to filter upon
+        List Redis Database Instances.
+        List all Redis Database Instances (Redis cluster) in the specified zone. By default, the Database Instances returned in the list are ordered by creation date in ascending order, though this can be modified via the order_by field. You can define additional parameters for your query, such as `tags`, `name`, `organization_id` and `version`.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param tags: Filter by Database Instance tags.
+        :param name: Filter by Database Instance names.
+        :param order_by: Criteria to use when ordering the list.
+        :param project_id: Filter by Project ID.
+        :param organization_id: Filter by Organization ID.
+        :param version: Filter by Redis engine version.
         :param page:
         :param page_size:
         :return: :class:`ListClustersResponse <ListClustersResponse>`
 
         Usage:
         ::
 
@@ -332,22 +339,23 @@
         project_id: Optional[str] = None,
         organization_id: Optional[str] = None,
         version: Optional[str] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[Cluster]:
         """
-        List clusters
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param tags: Tags of the clusters to filter upon
-        :param name: Name of the clusters to filter upon
-        :param order_by: Criteria to use when ordering cluster listing
-        :param project_id: Project ID to list the cluster of
-        :param organization_id: Organization ID to list the cluster of
-        :param version: Version of the clusters to filter upon
+        List Redis Database Instances.
+        List all Redis Database Instances (Redis cluster) in the specified zone. By default, the Database Instances returned in the list are ordered by creation date in ascending order, though this can be modified via the order_by field. You can define additional parameters for your query, such as `tags`, `name`, `organization_id` and `version`.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param tags: Filter by Database Instance tags.
+        :param name: Filter by Database Instance names.
+        :param order_by: Criteria to use when ordering the list.
+        :param project_id: Filter by Project ID.
+        :param organization_id: Filter by Organization ID.
+        :param version: Filter by Redis engine version.
         :param page:
         :param page_size:
         :return: :class:`List[ListClustersResponse] <List[ListClustersResponse]>`
 
         Usage:
         ::
 
@@ -377,24 +385,25 @@
         cluster_id: str,
         zone: Optional[Zone] = None,
         version: Optional[str] = None,
         node_type: Optional[str] = None,
         cluster_size: Optional[int] = None,
     ) -> Cluster:
         """
-        Upgrade your Database for Redis cluster to a new version or scale it vertically / horizontally. Please note: scaling horizontally your Database for Redis cluster won't renew its TLS certificate. In order to refresh the SSL certificate, you have to use the dedicated api route.
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param cluster_id: UUID of the cluster to update
-        :param version: Redis engine version of the cluster.
+        Scale up a Redis Database Instance.
+        Upgrade your standalone Redis Database Instance node, either by upgrading to a bigger node type (vertical scaling) or by adding more nodes to your Database Instance to increase your number of endpoints and distribute cache (horizontal scaling). Note that scaling horizontally your Redis Database Instance will not renew its TLS certificate. In order to refresh the TLS certificate, you must use the Renew TLS certificate endpoint.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param cluster_id: UUID of the Database Instance to update.
+        :param version: Redis engine version of the Database Instance.
 
         One-of ('action'): at most one of 'version', 'node_type', 'cluster_size' could be set.
-        :param node_type: Type of node to use for the cluster.
+        :param node_type: Type of node to use for the Database Instance.
 
         One-of ('action'): at most one of 'version', 'node_type', 'cluster_size' could be set.
-        :param cluster_size: Number of nodes for the cluster.
+        :param cluster_size: Number of nodes for the Database Instance.
 
         One-of ('action'): at most one of 'version', 'node_type', 'cluster_size' could be set.
         :return: :class:`Cluster <Cluster>`
 
         Usage:
         ::
 
@@ -425,17 +434,18 @@
     async def delete_cluster(
         self,
         *,
         cluster_id: str,
         zone: Optional[Zone] = None,
     ) -> Cluster:
         """
-        Delete a cluster
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param cluster_id: UUID of the cluster to delete
+        Delete a Redis Database Instance.
+        Delete a Redis Database Instance (Redis cluster), specified by the `region` and `cluster_id` parameters. Deleting a Database Instance is permanent, and cannot be undone. Note that upon deletion all your data will be lost.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param cluster_id: UUID of the Database Instance to delete.
         :return: :class:`Cluster <Cluster>`
 
         Usage:
         ::
 
             result = await api.delete_cluster(cluster_id="example")
         """
@@ -457,20 +467,21 @@
         cluster_id: str,
         zone: Optional[Zone] = None,
         start_at: Optional[datetime] = None,
         end_at: Optional[datetime] = None,
         metric_name: Optional[str] = None,
     ) -> ClusterMetricsResponse:
         """
-        Get metrics of a cluster
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param cluster_id: UUID of the cluster
-        :param start_at: Start date to gather metrics from
-        :param end_at: End date to gather metrics from
-        :param metric_name: Name of the metric to gather
+        Get metrics of a Redis Database Instance.
+        Retrieve the metrics of a Redis Database Instance (Redis cluster). You can define the period from which to retrieve metrics by specifying the `start_date` and `end_date`.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param cluster_id: UUID of the cluster.
+        :param start_at: Start date.
+        :param end_at: End date.
+        :param metric_name: Name of the metric to gather.
         :return: :class:`ClusterMetricsResponse <ClusterMetricsResponse>`
 
         Usage:
         ::
 
             result = await api.get_cluster_metrics(cluster_id="example")
         """
@@ -496,17 +507,18 @@
         *,
         include_disabled_types: bool,
         zone: Optional[Zone] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListNodeTypesResponse:
         """
-        List available node types
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param include_disabled_types: Whether or not to include disabled types
+        List available node types.
+        List all available node types. By default, the node types returned in the list are ordered by creation date in ascending order, though this can be modified via the `order_by` field.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param include_disabled_types: Defines whether or not to include disabled types.
         :param page:
         :param page_size:
         :return: :class:`ListNodeTypesResponse <ListNodeTypesResponse>`
 
         Usage:
         ::
 
@@ -533,17 +545,18 @@
         *,
         include_disabled_types: bool,
         zone: Optional[Zone] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[NodeType]:
         """
-        List available node types
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param include_disabled_types: Whether or not to include disabled types
+        List available node types.
+        List all available node types. By default, the node types returned in the list are ordered by creation date in ascending order, though this can be modified via the `order_by` field.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param include_disabled_types: Defines whether or not to include disabled types.
         :param page:
         :param page_size:
         :return: :class:`List[ListNodeTypesResponse] <List[ListNodeTypesResponse]>`
 
         Usage:
         ::
 
@@ -570,20 +583,21 @@
         include_deprecated: bool,
         zone: Optional[Zone] = None,
         version: Optional[str] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> ListClusterVersionsResponse:
         """
-        List available Redis versions
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param include_disabled: Whether or not to include disabled Redis engine versions
-        :param include_beta: Whether or not to include beta Redis engine versions
-        :param include_deprecated: Whether or not to include deprecated Redis engine versions
-        :param version: List Redis engine versions that match a given name pattern
+        List available Redis versions.
+        List the Redis database engine versions available. You can define additional parameters for your query, such as `include_disabled`, `include_beta`, `include_deprecated` and `version`.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param include_disabled: Defines whether or not to include disabled Redis engine versions.
+        :param include_beta: Defines whether or not to include beta Redis engine versions.
+        :param include_deprecated: Defines whether or not to include deprecated Redis engine versions.
+        :param version: List Redis engine versions that match a given name pattern.
         :param page:
         :param page_size:
         :return: :class:`ListClusterVersionsResponse <ListClusterVersionsResponse>`
 
         Usage:
         ::
 
@@ -620,20 +634,21 @@
         include_deprecated: bool,
         zone: Optional[Zone] = None,
         version: Optional[str] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
     ) -> List[ClusterVersion]:
         """
-        List available Redis versions
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param include_disabled: Whether or not to include disabled Redis engine versions
-        :param include_beta: Whether or not to include beta Redis engine versions
-        :param include_deprecated: Whether or not to include deprecated Redis engine versions
-        :param version: List Redis engine versions that match a given name pattern
+        List available Redis versions.
+        List the Redis database engine versions available. You can define additional parameters for your query, such as `include_disabled`, `include_beta`, `include_deprecated` and `version`.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param include_disabled: Defines whether or not to include disabled Redis engine versions.
+        :param include_beta: Defines whether or not to include beta Redis engine versions.
+        :param include_deprecated: Defines whether or not to include deprecated Redis engine versions.
+        :param version: List Redis engine versions that match a given name pattern.
         :param page:
         :param page_size:
         :return: :class:`List[ListClusterVersionsResponse] <List[ListClusterVersionsResponse]>`
 
         Usage:
         ::
 
@@ -662,17 +677,18 @@
     async def get_cluster_certificate(
         self,
         *,
         cluster_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[ScwFile]:
         """
-        Get the TLS certificate of a cluster
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param cluster_id: UUID of the cluster
+        Get the TLS certificate of a cluster.
+        Retrieve information about the TLS certificate of a Redis Database Instance (Redis cluster). Details like name and content are returned in the response.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param cluster_id: UUID of the cluster.
         :return: :class:`Optional[ScwFile] <Optional[ScwFile]>`
 
         Usage:
         ::
 
             result = await api.get_cluster_certificate(cluster_id="example")
         """
@@ -692,17 +708,18 @@
     async def renew_cluster_certificate(
         self,
         *,
         cluster_id: str,
         zone: Optional[Zone] = None,
     ) -> Cluster:
         """
-        Renew the TLS certificate of a cluster
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param cluster_id: UUID of the cluster
+        Renew the TLS certificate of a cluster.
+        Renew a TLS certificate for a Redis Database Instance (Redis cluster). Renewing a certificate means that you will not be able to connect to your Database Instance using the previous certificate. You will also need to download and update the new certificate for all database clients.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param cluster_id: UUID of the cluster.
         :return: :class:`Cluster <Cluster>`
 
         Usage:
         ::
 
             result = await api.renew_cluster_certificate(cluster_id="example")
         """
@@ -722,18 +739,19 @@
         self,
         *,
         cluster_id: str,
         settings: List[ClusterSetting],
         zone: Optional[Zone] = None,
     ) -> ClusterSettingsResponse:
         """
-        Add cluster settings
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param cluster_id: UUID of the cluster you want to add settings to
-        :param settings: Settings to add on the cluster
+        Add advanced settings.
+        Add an advanced setting to a Redis Database Instance (Redis cluster). You must set the `name` and the `value` of each setting.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param cluster_id: UUID of the Database Instance you want to add settings to.
+        :param settings: Settings to add to the cluster.
         :return: :class:`ClusterSettingsResponse <ClusterSettingsResponse>`
 
         Usage:
         ::
 
             result = await api.add_cluster_settings(
                 cluster_id="example",
@@ -764,18 +782,19 @@
         self,
         *,
         cluster_id: str,
         setting_name: str,
         zone: Optional[Zone] = None,
     ) -> Cluster:
         """
-        Delete a cluster setting
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param cluster_id: UUID of the cluster where the settings has to be set
-        :param setting_name: Setting name to delete
+        Delete advanced setting.
+        Delete an advanced setting in a Redis Database Instance (Redis cluster). You must specify the names of the settings you want to delete in the request body.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param cluster_id: UUID of the Database Instance where the settings must be set.
+        :param setting_name: Setting name to delete.
         :return: :class:`Cluster <Cluster>`
 
         Usage:
         ::
 
             result = await api.delete_cluster_setting(
                 cluster_id="example",
@@ -799,18 +818,19 @@
         self,
         *,
         cluster_id: str,
         settings: List[ClusterSetting],
         zone: Optional[Zone] = None,
     ) -> ClusterSettingsResponse:
         """
-        Set cluster settings
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param cluster_id: UUID of the cluster where the settings has to be set
-        :param settings: Settings to define for the cluster
+        Set advanced settings.
+        Update an advanced setting for a Redis Database Instance (Redis cluster). Settings added upon database engine initalization can only be defined once, and cannot, therefore, be updated.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param cluster_id: UUID of the Database Instance where the settings must be set.
+        :param settings: Settings to define for the Database Instance.
         :return: :class:`ClusterSettingsResponse <ClusterSettingsResponse>`
 
         Usage:
         ::
 
             result = await api.set_cluster_settings(
                 cluster_id="example",
@@ -841,18 +861,19 @@
         self,
         *,
         cluster_id: str,
         acl_rules: List[ACLRuleSpec],
         zone: Optional[Zone] = None,
     ) -> SetAclRulesResponse:
         """
-        Set ACL rules for a given cluster
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param cluster_id: UUID of the cluster where the ACL rules has to be set
-        :param acl_rules: ACLs rules to define for the cluster
+        Set ACL rules for a cluster.
+        Replace all the ACL rules of a Redis Database Instance (Redis cluster).
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param cluster_id: UUID of the Database Instance where the ACL rules have to be set.
+        :param acl_rules: ACLs rules to define for the cluster.
         :return: :class:`SetAclRulesResponse <SetAclRulesResponse>`
 
         Usage:
         ::
 
             result = await api.set_acl_rules(
                 cluster_id="example",
@@ -883,18 +904,19 @@
         self,
         *,
         cluster_id: str,
         acl_rules: List[ACLRuleSpec],
         zone: Optional[Zone] = None,
     ) -> AddAclRulesResponse:
         """
-        Add ACL rules for a given cluster
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param cluster_id: UUID of the cluster you want to add acl rules to
-        :param acl_rules: ACLs rules to add to the cluster
+        Add ACL rules for a cluster.
+        Add an additional ACL rule to a Redis Database Instance (Redis cluster).
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param cluster_id: UUID of the Database Instance you want to add ACL rules to.
+        :param acl_rules: ACLs rules to add to the cluster.
         :return: :class:`AddAclRulesResponse <AddAclRulesResponse>`
 
         Usage:
         ::
 
             result = await api.add_acl_rules(
                 cluster_id="example",
@@ -924,17 +946,18 @@
     async def delete_acl_rule(
         self,
         *,
         acl_id: str,
         zone: Optional[Zone] = None,
     ) -> Cluster:
         """
-        Delete an ACL rule for a given cluster
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param acl_id: UUID of the acl rule you want to delete
+        Delete an ACL rule for a cluster.
+        Delete an ACL rule of a Redis Database Instance (Redis cluster). You must specify the `acl_id` of the rule you want to delete in your request.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param acl_id: UUID of the ACL rule you want to delete.
         :return: :class:`Cluster <Cluster>`
 
         Usage:
         ::
 
             result = await api.delete_acl_rule(acl_id="example")
         """
@@ -953,17 +976,18 @@
     async def get_acl_rule(
         self,
         *,
         acl_id: str,
         zone: Optional[Zone] = None,
     ) -> ACLRule:
         """
-        Get an ACL rule
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param acl_id: UUID of the acl rule you want to get
+        Get an ACL rule.
+        Retrieve information about an ACL rule of a Redis Database Instance (Redis cluster). You must specify the `acl_id` of the rule in your request.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param acl_id: UUID of the ACL rule you want to get.
         :return: :class:`ACLRule <ACLRule>`
 
         Usage:
         ::
 
             result = await api.get_acl_rule(acl_id="example")
         """
@@ -983,18 +1007,19 @@
         self,
         *,
         cluster_id: str,
         endpoints: List[EndpointSpec],
         zone: Optional[Zone] = None,
     ) -> SetEndpointsResponse:
         """
-        Set endpoints for a given cluster
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param cluster_id: UUID of the cluster where the endpoints has to be set
-        :param endpoints: Endpoints to define for the cluster
+        Set endpoints for a cluster.
+        Update an endpoint for a Redis Database Instance (Redis cluster). You must specify the `cluster_id` and the `endpoints` parameters in your request.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param cluster_id: UUID of the Database Instance where the endpoints have to be set.
+        :param endpoints: Endpoints to define for the Database Instance.
         :return: :class:`SetEndpointsResponse <SetEndpointsResponse>`
 
         Usage:
         ::
 
             result = await api.set_endpoints(
                 cluster_id="example",
@@ -1025,18 +1050,19 @@
         self,
         *,
         cluster_id: str,
         endpoints: List[EndpointSpec],
         zone: Optional[Zone] = None,
     ) -> AddEndpointsResponse:
         """
-        Add endpoints for a given cluster
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param cluster_id: UUID of the cluster you want to add endpoints to
-        :param endpoints: Endpoints to add to the cluster
+        Add endpoints for a cluster.
+        Add a new endpoint for a Redis Database Instance (Redis cluster). You can add `private_network` or `public_network` specifications to the body of the request.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param cluster_id: UUID of the Database Instance you want to add endpoints to.
+        :param endpoints: Endpoints to add to the Database Instance.
         :return: :class:`AddEndpointsResponse <AddEndpointsResponse>`
 
         Usage:
         ::
 
             result = await api.add_endpoints(
                 cluster_id="example",
@@ -1066,17 +1092,18 @@
     async def delete_endpoint(
         self,
         *,
         endpoint_id: str,
         zone: Optional[Zone] = None,
     ) -> Cluster:
         """
-        Delete an endpoint for a given cluster
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param endpoint_id: UUID of the endpoint you want to delete
+        Delete an endpoint for a cluster.
+        Delete the endpoint of a Redis Database Instance (Redis cluster). You must specify the `region` and `endpoint_id` parameters of the endpoint you want to delete. Note that might need to update any environment configurations that point to the deleted endpoint.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param endpoint_id: UUID of the endpoint you want to delete.
         :return: :class:`Cluster <Cluster>`
 
         Usage:
         ::
 
             result = await api.delete_endpoint(endpoint_id="example")
         """
@@ -1095,17 +1122,18 @@
     async def get_endpoint(
         self,
         *,
         endpoint_id: str,
         zone: Optional[Zone] = None,
     ) -> Endpoint:
         """
-        Get an endpoint
-        :param zone: Zone to target. If none is passed will use default zone from the config
-        :param endpoint_id: UUID of the endpoint you want to get
+        Get an endpoint.
+        Retrieve information about a Redis Database Instance (Redis cluster) endpoint. Full details about the endpoint, like `ips`, `port`, `private_network` and `public_network` specifications are returned in the response.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param endpoint_id: UUID of the endpoint you want to get.
         :return: :class:`Endpoint <Endpoint>`
 
         Usage:
         ::
 
             result = await api.get_endpoint(endpoint_id="example")
         """
@@ -1126,14 +1154,21 @@
         *,
         endpoint_id: str,
         zone: Optional[Zone] = None,
         private_network: Optional[EndpointSpecPrivateNetworkSpec] = None,
         public_network: Optional[EndpointSpecPublicNetworkSpec] = None,
     ) -> Endpoint:
         """
+        Update an endpoint.
+        Update information about a Redis Database Instance (Redis cluster) endpoint. Full details about the endpoint, like `ips`, `port`, `private_network` and `public_network` specifications are returned in the response.
+        :param zone: Zone to target. If none is passed will use default zone from the config.
+        :param endpoint_id:
+        :param private_network: One-of ('endpoint_type'): at most one of 'private_network', 'public_network' could be set.
+        :param public_network: One-of ('endpoint_type'): at most one of 'private_network', 'public_network' could be set.
+        :return: :class:`Endpoint <Endpoint>`
 
         Usage:
         ::
 
             result = await api.update_endpoint(endpoint_id="example")
         """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/redis/v1/types.py` & `scaleway_async-1.0.0/scaleway_async/redis/v1/types.py`

 * *Files 19% similar despite different names*

```diff
@@ -55,1018 +55,1042 @@
     OUT_OF_STOCK = "out_of_stock"
     AVAILABLE = "available"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
+class PrivateNetworkProvisioningMode(str, Enum):
+    STATIC = "static"
+    IPAM = "ipam"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
 @dataclass
 class ACLRule:
     """
-    Acl rule
+    Acl rule.
     """
 
     id: str
     """
-    ID of the rule
+    ID of the rule.
     """
 
     ip_cidr: Optional[str]
     """
-    IPv4 network address of the rule
+    IPv4 network address of the rule.
     """
 
     description: Optional[str]
     """
-    Description of the rule
+    Description of the rule.
     """
 
 
 @dataclass
 class ACLRuleSpec:
     """
-    Acl rule spec
+    Acl rule spec.
     """
 
     ip_cidr: str
     """
-    IPv4 network address of the rule
+    IPv4 network address of the rule.
     """
 
     description: str
     """
-    Description of the rule
+    Description of the rule.
     """
 
 
 @dataclass
 class AddAclRulesResponse:
     """
-    Add acl rules response
+    Add acl rules response.
     """
 
     acl_rules: List[ACLRule]
     """
-    ACL Rules enabled on the cluster
+    ACL Rules enabled for the Database Instance.
     """
 
     total_count: int
     """
-    Total count of acl rules of the cluster
+    Total count of ACL rules of the Database Instance.
     """
 
 
 @dataclass
 class AddEndpointsResponse:
     """
-    Add endpoints response
+    Add endpoints response.
     """
 
     endpoints: List[Endpoint]
     """
-    Endpoints defined on the cluster
+    Endpoints defined on the Database Instance.
     """
 
     total_count: int
     """
-    Total count of endpoints of the cluster
+    Total count of endpoints of the Database Instance.
     """
 
 
 @dataclass
 class AvailableClusterSetting:
     """
-    Available cluster setting
+    Available cluster setting.
     """
 
     name: str
     """
-    Name of the setting
+    Name of the setting.
     """
 
     default_value: Optional[str]
     """
-    Default value of the setting
+    Default value of the setting.
     """
 
     type_: AvailableClusterSettingPropertyType
     """
-    Type of the setting
+    Type of setting.
     """
 
     description: str
     """
-    Description of the setting
+    Description of the setting.
     """
 
     max_value: Optional[int]
     """
-    Optional maximum value of the setting
+    Optional maximum value of the setting.
     """
 
     min_value: Optional[int]
     """
-    Optional minimum value of the setting
+    Optional minimum value of the setting.
     """
 
     regex: Optional[str]
     """
-    Optional validation rule of the setting
+    Optional validation rule of the setting.
     """
 
     deprecated: bool
     """
-    Whether the setting is deprecated
+    Defines whether or not the setting is deprecated.
     """
 
 
 @dataclass
 class Cluster:
     """
-    Cluster
+    Cluster.
     """
 
     id: str
     """
-    UUID of the cluster
+    UUID of the Database Instance.
     """
 
     name: str
     """
-    Name of the cluster
+    Name of the Database Instance.
     """
 
     project_id: str
     """
-    Project ID the cluster belongs to
+    Project ID the Database Instance belongs to.
     """
 
     status: ClusterStatus
     """
-    Status of the cluster
+    Status of the Database Instance.
     """
 
     version: str
     """
-    Redis engine version of the cluster
+    Redis engine version of the Database Instance.
     """
 
     endpoints: List[Endpoint]
     """
-    List of cluster endpoints
+    List of Database Instance endpoints.
     """
 
     tags: List[str]
     """
-    List of tags applied to the cluster
+    List of tags applied to the Database Instance.
     """
 
     node_type: str
     """
-    Node type of the cluster
+    Node type of the Database Instance.
     """
 
     created_at: Optional[datetime]
     """
-    Creation date (Format ISO 8601)
+    Creation date (Format ISO 8601).
     """
 
     updated_at: Optional[datetime]
     """
-    Update date (Format ISO 8601)
+    Update date (Format ISO 8601).
     """
 
     tls_enabled: bool
     """
-    Whether or not TLS is enabled
+    Defines whether or not TLS is enabled.
     """
 
     cluster_settings: List[ClusterSetting]
     """
-    List of cluster settings
+    List of Database Instance settings.
     """
 
     acl_rules: List[ACLRule]
     """
-    List of acl rules
+    List of ACL rules.
     """
 
     cluster_size: int
     """
-    Number of nodes of the cluster
+    Number of nodes of the Database Instance cluster.
     """
 
     zone: Zone
     """
-    Zone of the cluster
+    Zone of the Database Instance.
     """
 
     user_name: str
     """
-    Name of the user associated to the cluster
+    Name of the user associated to the cluster.
     """
 
     upgradable_versions: List[str]
     """
-    List of versions the cluster can be migrated to
+    List of engine versions the Database Instance can upgrade to.
     """
 
 
 @dataclass
 class ClusterMetricsResponse:
     """
-    Cluster metrics response
+    Cluster metrics response.
     """
 
     timeseries: List[TimeSeries]
     """
-    Time series of metrics of a given cluster
+    Time series of metrics of a given cluster.
     """
 
 
 @dataclass
 class ClusterSetting:
     """
-    Cluster setting
+    Cluster setting.
     """
 
     value: str
     """
-    Value of the setting
+    Value of the setting.
     """
 
     name: str
     """
-    Name of the setting
+    Name of the setting.
     """
 
 
 @dataclass
 class ClusterSettingsResponse:
     """
-    Cluster settings response
+    Cluster settings response.
     """
 
     settings: List[ClusterSetting]
     """
-    Settings configured for a given cluster
+    Settings configured for a given Database Instance.
     """
 
 
 @dataclass
 class ClusterVersion:
     """
-    Cluster version
+    Cluster version.
     """
 
     version: str
     """
-    Redis engine version
+    Redis engine version.
     """
 
     end_of_life_at: Optional[datetime]
     """
-    End of life date
+    Date of End of Life.
     """
 
     available_settings: List[AvailableClusterSetting]
     """
-    Cluster settings available to be set
+    Cluster settings available to be updated.
     """
 
     logo_url: str
     """
-    Redis logo url
+    Redis logo url.
     """
 
     zone: Zone
     """
-    Zone of the Managed Database for Redis
+    Zone of the Redis Database Instance.
     """
 
 
 @dataclass
 class Endpoint:
     """
-    Endpoint
+    Endpoint.
     """
 
     port: int
     """
-    TCP port of the endpoint
+    TCP port of the endpoint.
     """
 
     private_network: Optional[PrivateNetwork]
     """
-    Private network details.
+    Private Network details.
     
     One-of ('details'): at most one of 'private_network', 'public_network' could be set.
     """
 
     public_network: Optional[PublicNetwork]
     """
     Public network details.
     
     One-of ('details'): at most one of 'private_network', 'public_network' could be set.
     """
 
     ips: List[str]
     """
-    Lis of IPv4 address of the endpoint
+    List of IPv4 addresses of the endpoint.
     """
 
     id: str
     """
-    UUID of the endpoint
+    UUID of the endpoint.
     """
 
 
 @dataclass
 class EndpointSpec:
     """
-    Endpoint spec
+    Endpoint spec.
     """
 
     private_network: Optional[EndpointSpecPrivateNetworkSpec]
     """
-    Private network spec details.
+    Private Network specification details.
     
     One-of ('endpoint_type'): at most one of 'private_network', 'public_network' could be set.
     """
 
     public_network: Optional[EndpointSpecPublicNetworkSpec]
     """
-    Public network spec details.
+    Public network specification details.
     
     One-of ('endpoint_type'): at most one of 'private_network', 'public_network' could be set.
     """
 
 
 @dataclass
 class EndpointSpecPrivateNetworkSpec:
     """
-    Endpoint spec. private network spec
+    Endpoint spec. private network spec.
     """
 
     id: str
     """
-    UUID of the private network to be connected to the cluster
+    UUID of the Private Network to connect to the Database Instance.
     """
 
     service_ips: List[str]
     """
-    Endpoint IPv4 adress with a CIDR notation. You must provide at least one IPv4 per node. Check documentation about IP and subnet limitation.
+    Endpoint IPv4 address with a CIDR notation. You must provide at least one IPv4 per node.
+    """
+
+    ipam_config: Optional[EndpointSpecPrivateNetworkSpecIpamConfig]
+    """
+    Automated configuration of your Private Network endpoint with Scaleway IPAM service.
     """
 
 
 @dataclass
+class EndpointSpecPrivateNetworkSpecIpamConfig:
+    pass
+
+
+@dataclass
 class EndpointSpecPublicNetworkSpec:
     """
-    Endpoint spec. public network spec
+    Endpoint spec. public network spec.
     """
 
 
 @dataclass
 class ListClusterVersionsResponse:
     """
-    List cluster versions response
+    List cluster versions response.
     """
 
     versions: List[ClusterVersion]
     """
-    List of the available Redis engine versions
+    List of available Redis engine versions.
     """
 
     total_count: int
     """
-    Total count of available Redis engine versions
+    Total count of available Redis engine versions.
     """
 
 
 @dataclass
 class ListClustersResponse:
     """
-    List clusters response
+    List clusters response.
     """
 
     clusters: List[Cluster]
     """
-    List all clusters
+    List all Database Instances.
     """
 
     total_count: int
     """
-    Total count of clusters
+    Total count of Database Instances.
     """
 
 
 @dataclass
 class ListNodeTypesResponse:
     """
-    List node types response
+    List node types response.
     """
 
     node_types: List[NodeType]
     """
-    Types of the node
+    Types of node.
     """
 
     total_count: int
     """
-    Total count of node-types available
+    Total count of node types available.
     """
 
 
 @dataclass
 class NodeType:
     """
-    Node type
+    Node type.
     """
 
     name: str
     """
-    Node Type name identifier
+    Node type name.
     """
 
     stock_status: NodeTypeStock
     """
-    Current stock status for the Node Type
+    Current stock status of the node type.
     """
 
     description: str
     """
-    Current specs of the offer
+    Current specifications of the offer.
     """
 
     vcpus: int
     """
-    Number of virtual CPUs
+    Number of virtual CPUs.
     """
 
     memory: int
     """
-    Quantity of RAM
+    Quantity of RAM.
     """
 
     disabled: bool
     """
-    The Node Type is currently disabled
+    Defines whether node type is currently disabled or not.
     """
 
     beta: bool
     """
-    The Node Type is currently in beta
+    Defines whether node type is currently in beta.
     """
 
     zone: Zone
     """
-    Zone the Node Type is in
+    Zone of the node type.
     """
 
 
 @dataclass
 class PrivateNetwork:
     """
-    Private network
+    Private network.
     """
 
     id: str
     """
-    UUID of the private network
+    UUID of the Private Network.
     """
 
     service_ips: List[str]
     """
-    List of IPv4 CIDR notation addresses of the endpoint
+    List of IPv4 CIDR notation addresses of the endpoint.
     """
 
     zone: Zone
     """
-    Private network zone
+    Zone of the Private Network.
+    """
+
+    provisioning_mode: PrivateNetworkProvisioningMode
+    """
+    How your endpoint ips are provisioned.
     """
 
 
 @dataclass
 class PublicNetwork:
     pass
 
 
 @dataclass
 class SetAclRulesResponse:
     """
-    Set acl rules response
+    Set acl rules response.
     """
 
     acl_rules: List[ACLRule]
     """
-    ACL Rules enabled on the cluster
+    ACL Rules enabled for the Database Instance.
     """
 
 
 @dataclass
 class SetEndpointsResponse:
     """
-    Set endpoints response
+    Set endpoints response.
     """
 
     endpoints: List[Endpoint]
     """
-    Endpoints defined on the cluster
+    Endpoints defined on the Database Instance.
     """
 
 
 @dataclass
 class CreateClusterRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     project_id: Optional[str]
     """
-    The project ID on which to create the cluster
+    Project ID in which to create the Database Instance.
     """
 
     name: Optional[str]
     """
-    Name of the cluster
+    Name of the Database Instance.
     """
 
     version: str
     """
-    Redis engine version of the cluster
+    Redis engine version of the Database Instance.
     """
 
     tags: Optional[List[str]]
     """
-    Tags to apply to the cluster
+    Tags to apply to the Database Instance.
     """
 
     node_type: str
     """
-    Type of node to use for the cluster
+    Type of node to use for the Database Instance.
     """
 
     user_name: str
     """
-    Name of the user created when the cluster is created
+    Name of the user created upon Database Instance creation.
     """
 
     password: str
     """
-    Password of the user
+    Password of the user.
     """
 
     cluster_size: Optional[int]
     """
-    Number of nodes for the cluster
+    Number of nodes in the Redis cluster.
     """
 
     acl_rules: Optional[List[ACLRuleSpec]]
     """
-    List of ACLRuleSpec used to secure your publicly exposed cluster
+    List of ACLRuleSpec used to secure your publicly exposed cluster.
     """
 
     endpoints: Optional[List[EndpointSpec]]
     """
+    Zero or multiple EndpointSpec used to expose your cluster publicly and inside Private Networks.
     Zero or multiple EndpointSpec used to expose your cluster publicly and inside private networks. If no EndpoindSpec is given the cluster will be publicly exposed by default.
     """
 
     tls_enabled: bool
     """
-    Whether or not TLS is enabled
+    Defines whether or not TLS is enabled.
     """
 
     cluster_settings: Optional[List[ClusterSetting]]
     """
-    List of cluster settings to be set at cluster initialisation
+    List of advanced settings to be set upon Database Instance initialization.
     """
 
 
 @dataclass
 class UpdateClusterRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     cluster_id: str
     """
-    UUID of the cluster to update
+    UUID of the Database Instance to update.
     """
 
     name: Optional[str]
     """
-    Name of the cluster
+    Name of the Database Instance.
     """
 
     tags: Optional[List[str]]
     """
-    Tags of a given cluster
+    Database Instance tags.
     """
 
     user_name: Optional[str]
     """
-    Name of the cluster user
+    Name of the Database Instance user.
     """
 
     password: Optional[str]
     """
-    Password of the cluster user
+    Password of the Database Instance user.
     """
 
 
 @dataclass
 class GetClusterRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     cluster_id: str
     """
-    UUID of the cluster
+    UUID of the cluster.
     """
 
 
 @dataclass
 class ListClustersRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     tags: Optional[List[str]]
     """
-    Tags of the clusters to filter upon
+    Filter by Database Instance tags.
     """
 
     name: Optional[str]
     """
-    Name of the clusters to filter upon
+    Filter by Database Instance names.
     """
 
     order_by: Optional[ListClustersRequestOrderBy]
     """
-    Criteria to use when ordering cluster listing
+    Criteria to use when ordering the list.
     """
 
     project_id: Optional[str]
     """
-    Project ID to list the cluster of
+    Filter by Project ID.
     """
 
     organization_id: Optional[str]
     """
-    Organization ID to list the cluster of
+    Filter by Organization ID.
     """
 
     version: Optional[str]
     """
-    Version of the clusters to filter upon
+    Filter by Redis engine version.
     """
 
     page: Optional[int]
 
     page_size: Optional[int]
 
 
 @dataclass
 class MigrateClusterRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     cluster_id: str
     """
-    UUID of the cluster to update
+    UUID of the Database Instance to update.
     """
 
     version: Optional[str]
     """
-    Redis engine version of the cluster.
+    Redis engine version of the Database Instance.
     
     One-of ('action'): at most one of 'version', 'node_type', 'cluster_size' could be set.
     """
 
     node_type: Optional[str]
     """
-    Type of node to use for the cluster.
+    Type of node to use for the Database Instance.
     
     One-of ('action'): at most one of 'version', 'node_type', 'cluster_size' could be set.
     """
 
     cluster_size: Optional[int]
     """
-    Number of nodes for the cluster.
+    Number of nodes for the Database Instance.
     
     One-of ('action'): at most one of 'version', 'node_type', 'cluster_size' could be set.
     """
 
 
 @dataclass
 class DeleteClusterRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     cluster_id: str
     """
-    UUID of the cluster to delete
+    UUID of the Database Instance to delete.
     """
 
 
 @dataclass
 class GetClusterMetricsRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     cluster_id: str
     """
-    UUID of the cluster
+    UUID of the cluster.
     """
 
     start_at: Optional[datetime]
     """
-    Start date to gather metrics from
+    Start date.
     """
 
     end_at: Optional[datetime]
     """
-    End date to gather metrics from
+    End date.
     """
 
     metric_name: Optional[str]
     """
-    Name of the metric to gather
+    Name of the metric to gather.
     """
 
 
 @dataclass
 class ListNodeTypesRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     include_disabled_types: bool
     """
-    Whether or not to include disabled types
+    Defines whether or not to include disabled types.
     """
 
     page: Optional[int]
 
     page_size: Optional[int]
 
 
 @dataclass
 class ListClusterVersionsRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     include_disabled: bool
     """
-    Whether or not to include disabled Redis engine versions
+    Defines whether or not to include disabled Redis engine versions.
     """
 
     include_beta: bool
     """
-    Whether or not to include beta Redis engine versions
+    Defines whether or not to include beta Redis engine versions.
     """
 
     include_deprecated: bool
     """
-    Whether or not to include deprecated Redis engine versions
+    Defines whether or not to include deprecated Redis engine versions.
     """
 
     version: Optional[str]
     """
-    List Redis engine versions that match a given name pattern
+    List Redis engine versions that match a given name pattern.
     """
 
     page: Optional[int]
 
     page_size: Optional[int]
 
 
 @dataclass
 class GetClusterCertificateRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     cluster_id: str
     """
-    UUID of the cluster
+    UUID of the cluster.
     """
 
 
 @dataclass
 class RenewClusterCertificateRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     cluster_id: str
     """
-    UUID of the cluster
+    UUID of the cluster.
     """
 
 
 @dataclass
 class AddClusterSettingsRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     cluster_id: str
     """
-    UUID of the cluster you want to add settings to
+    UUID of the Database Instance you want to add settings to.
     """
 
     settings: List[ClusterSetting]
     """
-    Settings to add on the cluster
+    Settings to add to the cluster.
     """
 
 
 @dataclass
 class DeleteClusterSettingRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     cluster_id: str
     """
-    UUID of the cluster where the settings has to be set
+    UUID of the Database Instance where the settings must be set.
     """
 
     setting_name: str
     """
-    Setting name to delete
+    Setting name to delete.
     """
 
 
 @dataclass
 class SetClusterSettingsRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     cluster_id: str
     """
-    UUID of the cluster where the settings has to be set
+    UUID of the Database Instance where the settings must be set.
     """
 
     settings: List[ClusterSetting]
     """
-    Settings to define for the cluster
+    Settings to define for the Database Instance.
     """
 
 
 @dataclass
 class SetAclRulesRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     cluster_id: str
     """
-    UUID of the cluster where the ACL rules has to be set
+    UUID of the Database Instance where the ACL rules have to be set.
     """
 
     acl_rules: List[ACLRuleSpec]
     """
-    ACLs rules to define for the cluster
+    ACLs rules to define for the cluster.
     """
 
 
 @dataclass
 class AddAclRulesRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     cluster_id: str
     """
-    UUID of the cluster you want to add acl rules to
+    UUID of the Database Instance you want to add ACL rules to.
     """
 
     acl_rules: List[ACLRuleSpec]
     """
-    ACLs rules to add to the cluster
+    ACLs rules to add to the cluster.
     """
 
 
 @dataclass
 class DeleteAclRuleRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     acl_id: str
     """
-    UUID of the acl rule you want to delete
+    UUID of the ACL rule you want to delete.
     """
 
 
 @dataclass
 class GetAclRuleRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     acl_id: str
     """
-    UUID of the acl rule you want to get
+    UUID of the ACL rule you want to get.
     """
 
 
 @dataclass
 class SetEndpointsRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     cluster_id: str
     """
-    UUID of the cluster where the endpoints has to be set
+    UUID of the Database Instance where the endpoints have to be set.
     """
 
     endpoints: List[EndpointSpec]
     """
-    Endpoints to define for the cluster
+    Endpoints to define for the Database Instance.
     """
 
 
 @dataclass
 class AddEndpointsRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     cluster_id: str
     """
-    UUID of the cluster you want to add endpoints to
+    UUID of the Database Instance you want to add endpoints to.
     """
 
     endpoints: List[EndpointSpec]
     """
-    Endpoints to add to the cluster
+    Endpoints to add to the Database Instance.
     """
 
 
 @dataclass
 class DeleteEndpointRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     endpoint_id: str
     """
-    UUID of the endpoint you want to delete
+    UUID of the endpoint you want to delete.
     """
 
 
 @dataclass
 class GetEndpointRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     endpoint_id: str
     """
-    UUID of the endpoint you want to get
+    UUID of the endpoint you want to get.
     """
 
 
 @dataclass
 class UpdateEndpointRequest:
     zone: Optional[Zone]
     """
-    Zone to target. If none is passed will use default zone from the config
+    Zone to target. If none is passed will use default zone from the config.
     """
 
     endpoint_id: str
 
     private_network: Optional[EndpointSpecPrivateNetworkSpec]
     """
     One-of ('endpoint_type'): at most one of 'private_network', 'public_network' could be set.
```

### Comparing `scaleway_async-0.9.0/scaleway_async/registry/v1/__init__.py` & `scaleway_async-1.0.0/scaleway_async/registry/v1/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-0.9.0/scaleway_async/registry/v1/api.py` & `scaleway_async-1.0.0/scaleway_async/registry/v1/api.py`

 * *Files 17% similar despite different names*

```diff
@@ -45,39 +45,40 @@
     unmarshal_ListNamespacesResponse,
     unmarshal_ListTagsResponse,
 )
 
 
 class RegistryV1API(API):
     """
-    Registry API.
+    Container Registry API.
 
-    Container registry API.
+    Container Registry API.
     """
 
     async def list_namespaces(
         self,
         *,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListNamespacesRequestOrderBy = ListNamespacesRequestOrderBy.CREATED_AT_ASC,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         name: Optional[str] = None,
     ) -> ListNamespacesResponse:
         """
-        List all your namespaces
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page: A positive integer to choose the page to display
-        :param page_size: A positive integer lower or equal to 100 to select the number of items to display
-        :param order_by: Field by which to order the display of Images
-        :param organization_id: Filter by Organization ID
-        :param project_id: Filter by Project ID
-        :param name: Filter by the namespace name (exact match)
+        List namespaces.
+        List all namespaces in a specified region. By default, the namespaces listed are ordered by creation date in ascending order. This can be modified via the order_by field. You can also define additional parameters for your query, such as the `instance_id` and `project_id` parameters.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: A positive integer to choose the page to display.
+        :param page_size: A positive integer lower or equal to 100 to select the number of items to display.
+        :param order_by: Criteria to use when ordering namespace listings. Possible values are `created_at_asc`, `created_at_desc`, `name_asc`, `name_desc`, `region`, `status_asc` and `status_desc`. The default value is `created_at_asc`.
+        :param organization_id: Filter by Organization ID.
+        :param project_id: Filter by Project ID.
+        :param name: Filter by the namespace name (exact match).
         :return: :class:`ListNamespacesResponse <ListNamespacesResponse>`
 
         Usage:
         ::
 
             result = await api.list_namespaces()
         """
@@ -111,22 +112,23 @@
         page_size: Optional[int] = None,
         order_by: Optional[ListNamespacesRequestOrderBy] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         name: Optional[str] = None,
     ) -> List[Namespace]:
         """
-        List all your namespaces
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page: A positive integer to choose the page to display
-        :param page_size: A positive integer lower or equal to 100 to select the number of items to display
-        :param order_by: Field by which to order the display of Images
-        :param organization_id: Filter by Organization ID
-        :param project_id: Filter by Project ID
-        :param name: Filter by the namespace name (exact match)
+        List namespaces.
+        List all namespaces in a specified region. By default, the namespaces listed are ordered by creation date in ascending order. This can be modified via the order_by field. You can also define additional parameters for your query, such as the `instance_id` and `project_id` parameters.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: A positive integer to choose the page to display.
+        :param page_size: A positive integer lower or equal to 100 to select the number of items to display.
+        :param order_by: Criteria to use when ordering namespace listings. Possible values are `created_at_asc`, `created_at_desc`, `name_asc`, `name_desc`, `region`, `status_asc` and `status_desc`. The default value is `created_at_asc`.
+        :param organization_id: Filter by Organization ID.
+        :param project_id: Filter by Project ID.
+        :param name: Filter by the namespace name (exact match).
         :return: :class:`List[ListNamespacesResponse] <List[ListNamespacesResponse]>`
 
         Usage:
         ::
 
             result = await api.list_namespaces_all()
         """
@@ -149,17 +151,18 @@
     async def get_namespace(
         self,
         *,
         namespace_id: str,
         region: Optional[Region] = None,
     ) -> Namespace:
         """
-        Get the namespace associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param namespace_id: The unique ID of the Namespace
+        Get a namespace.
+        Retrieve information about a given namespace, specified by its `namespace_id` and region. Full details about the namespace, such as `description`, `project_id`, `status`, `endpoint`, `is_public`, `size`, and `image_count` are returned in the response.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param namespace_id: UUID of the namespace.
         :return: :class:`Namespace <Namespace>`
 
         Usage:
         ::
 
             result = await api.get_namespace(namespace_id="example")
         """
@@ -184,16 +187,16 @@
         region: Optional[Region] = None,
         options: Optional[
             WaitForOptions[Namespace, Union[bool, Awaitable[bool]]]
         ] = None,
     ) -> Namespace:
         """
         Waits for :class:`Namespace <Namespace>` to be in a final state.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param namespace_id: The unique ID of the Namespace
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param namespace_id: UUID of the namespace.
         :param options: The options for the waiter
         :return: :class:`Namespace <Namespace>`
 
         Usage:
         ::
 
             result = api.wait_for_namespace(namespace_id="example")
@@ -221,25 +224,26 @@
         is_public: bool,
         region: Optional[Region] = None,
         name: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> Namespace:
         """
-        Create a new namespace
-        :param region: Region to target. If none is passed will use default region from the config
-        :param name: Define a namespace name
-        :param description: Define a description
-        :param organization_id: Assign the namespace owner (deprecated).
+        Create a namespace.
+        Create a new Container Registry namespace. You must specify the namespace name and region in which you want it to be created. Optionally, you can specify the `project_id` and `is_public` in the request payload.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param name: Name of the namespace.
+        :param description: Description of the namespace.
+        :param organization_id: Namespace owner (deprecated).
 
         One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
-        :param project_id: Assign the namespace to a project ID.
+        :param project_id: Project ID on which the namespace will be created.
 
         One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
-        :param is_public: Define the default visibility policy
+        :param is_public: Defines whether or not namespace is public.
         :return: :class:`Namespace <Namespace>`
 
         Usage:
         ::
 
             result = await api.create_namespace(
                 description="example",
@@ -275,19 +279,20 @@
         *,
         namespace_id: str,
         region: Optional[Region] = None,
         description: Optional[str] = None,
         is_public: Optional[bool] = None,
     ) -> Namespace:
         """
-        Update the namespace associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param namespace_id: Namespace ID to update
-        :param description: Define a description
-        :param is_public: Define the default visibility policy
+        Update a namespace.
+        Update the parameters of a given namespace, specified by its `namespace_id` and `region`. You can update the `description` and `is_public` parameters.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param namespace_id: ID of the namespace to update.
+        :param description: Namespace description.
+        :param is_public: Defines whether or not the namespace is public.
         :return: :class:`Namespace <Namespace>`
 
         Usage:
         ::
 
             result = await api.update_namespace(namespace_id="example")
         """
@@ -317,17 +322,18 @@
     async def delete_namespace(
         self,
         *,
         namespace_id: str,
         region: Optional[Region] = None,
     ) -> Namespace:
         """
-        Delete the namespace associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param namespace_id: The unique ID of the Namespace
+        Delete a namespace.
+        Delete a given namespace. You must specify, in the endpoint, the `region` and `namespace_id` parameters of the namespace you want to delete.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param namespace_id: UUID of the namespace.
         :return: :class:`Namespace <Namespace>`
 
         Usage:
         ::
 
             result = await api.delete_namespace(namespace_id="example")
         """
@@ -354,23 +360,24 @@
         order_by: ListImagesRequestOrderBy = ListImagesRequestOrderBy.CREATED_AT_ASC,
         namespace_id: Optional[str] = None,
         name: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> ListImagesResponse:
         """
-        List all your images
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page: A positive integer to choose the page to display
-        :param page_size: A positive integer lower or equal to 100 to select the number of items to display
-        :param order_by: Field by which to order the display of Images
-        :param namespace_id: Filter by the Namespace ID
-        :param name: Filter by the Image name (exact match)
-        :param organization_id: Filter by Organization ID
-        :param project_id: Filter by Project ID
+        List images.
+        List all images in a specified region. By default, the images listed are ordered by creation date in ascending order. This can be modified via the order_by field. You can also define additional parameters for your query, such as the `namespace_id` and `project_id` parameters.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: A positive integer to choose the page to display.
+        :param page_size: A positive integer lower or equal to 100 to select the number of items to display.
+        :param order_by: Criteria to use when ordering image listings. Possible values are `created_at_asc`, `created_at_desc`, `name_asc`, `name_desc`, `region`, `status_asc` and `status_desc`. The default value is `created_at_asc`.
+        :param namespace_id: Filter by the namespace ID.
+        :param name: Filter by the image name (exact match).
+        :param organization_id: Filter by Organization ID.
+        :param project_id: Filter by Project ID.
         :return: :class:`ListImagesResponse <ListImagesResponse>`
 
         Usage:
         ::
 
             result = await api.list_images()
         """
@@ -406,23 +413,24 @@
         order_by: Optional[ListImagesRequestOrderBy] = None,
         namespace_id: Optional[str] = None,
         name: Optional[str] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
     ) -> List[Image]:
         """
-        List all your images
-        :param region: Region to target. If none is passed will use default region from the config
-        :param page: A positive integer to choose the page to display
-        :param page_size: A positive integer lower or equal to 100 to select the number of items to display
-        :param order_by: Field by which to order the display of Images
-        :param namespace_id: Filter by the Namespace ID
-        :param name: Filter by the Image name (exact match)
-        :param organization_id: Filter by Organization ID
-        :param project_id: Filter by Project ID
+        List images.
+        List all images in a specified region. By default, the images listed are ordered by creation date in ascending order. This can be modified via the order_by field. You can also define additional parameters for your query, such as the `namespace_id` and `project_id` parameters.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param page: A positive integer to choose the page to display.
+        :param page_size: A positive integer lower or equal to 100 to select the number of items to display.
+        :param order_by: Criteria to use when ordering image listings. Possible values are `created_at_asc`, `created_at_desc`, `name_asc`, `name_desc`, `region`, `status_asc` and `status_desc`. The default value is `created_at_asc`.
+        :param namespace_id: Filter by the namespace ID.
+        :param name: Filter by the image name (exact match).
+        :param organization_id: Filter by Organization ID.
+        :param project_id: Filter by Project ID.
         :return: :class:`List[ListImagesResponse] <List[ListImagesResponse]>`
 
         Usage:
         ::
 
             result = await api.list_images_all()
         """
@@ -446,17 +454,18 @@
     async def get_image(
         self,
         *,
         image_id: str,
         region: Optional[Region] = None,
     ) -> Image:
         """
-        Get the image associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param image_id: The unique ID of the Image
+        Get an image.
+        Retrieve information about a given container image, specified by its `image_id` and region. Full details about the image, such as `name`, `namespace_id`, `status`, `visibility`, and `size` are returned in the response.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param image_id: UUID of the image.
         :return: :class:`Image <Image>`
 
         Usage:
         ::
 
             result = await api.get_image(image_id="example")
         """
@@ -479,16 +488,16 @@
         *,
         image_id: str,
         region: Optional[Region] = None,
         options: Optional[WaitForOptions[Image, Union[bool, Awaitable[bool]]]] = None,
     ) -> Image:
         """
         Waits for :class:`Image <Image>` to be in a final state.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param image_id: The unique ID of the Image
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param image_id: UUID of the image.
         :param options: The options for the waiter
         :return: :class:`Image <Image>`
 
         Usage:
         ::
 
             result = api.wait_for_image(image_id="example")
@@ -513,18 +522,19 @@
         self,
         *,
         image_id: str,
         visibility: ImageVisibility,
         region: Optional[Region] = None,
     ) -> Image:
         """
-        Update the image associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param image_id: Image ID to update
-        :param visibility: A `public` image is pullable from internet without authentication, opposed to a `private` image. `inherit` will use the namespace `is_public` parameter
+        Update an image.
+        Update the parameters of a given image, specified by its `image_id` and `region`. You can update the `visibility` parameter.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param image_id: ID of the image to update.
+        :param visibility: Set to `public` to allow the image to be pulled without authentication. Else, set to  `private`. Set to `inherit` to keep the same visibility configuration as the namespace.
         :return: :class:`Image <Image>`
 
         Usage:
         ::
 
             result = await api.update_image(
                 image_id="example",
@@ -556,17 +566,18 @@
     async def delete_image(
         self,
         *,
         image_id: str,
         region: Optional[Region] = None,
     ) -> Image:
         """
-        Delete the image associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param image_id: The unique ID of the Image
+        Delete an image.
+        Delete a given image. You must specify, in the endpoint, the `region` and `image_id` parameters of the image you want to delete.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param image_id: UUID of the image.
         :return: :class:`Image <Image>`
 
         Usage:
         ::
 
             result = await api.delete_image(image_id="example")
         """
@@ -591,21 +602,22 @@
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: ListTagsRequestOrderBy = ListTagsRequestOrderBy.CREATED_AT_ASC,
         name: Optional[str] = None,
     ) -> ListTagsResponse:
         """
-        List all your tags
-        :param region: Region to target. If none is passed will use default region from the config
-        :param image_id: The unique ID of the image
-        :param page: A positive integer to choose the page to display
-        :param page_size: A positive integer lower or equal to 100 to select the number of items to display
-        :param order_by: Field by which to order the display of Images
-        :param name: Filter by the tag name (exact match)
+        List tags.
+        List all tags for a given image, specified by region. By default, the tags listed are ordered by creation date in ascending order. This can be modified via the order_by field. You can also define additional parameters for your query, such as the `name`.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param image_id: UUID of the image.
+        :param page: A positive integer to choose the page to display.
+        :param page_size: A positive integer lower or equal to 100 to select the number of items to display.
+        :param order_by: Criteria to use when ordering tag listings. Possible values are `created_at_asc`, `created_at_desc`, `name_asc`, `name_desc`, `region`, `status_asc` and `status_desc`. The default value is `created_at_asc`.
+        :param name: Filter by the tag name (exact match).
         :return: :class:`ListTagsResponse <ListTagsResponse>`
 
         Usage:
         ::
 
             result = await api.list_tags(image_id="example")
         """
@@ -636,21 +648,22 @@
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         order_by: Optional[ListTagsRequestOrderBy] = None,
         name: Optional[str] = None,
     ) -> List[Tag]:
         """
-        List all your tags
-        :param region: Region to target. If none is passed will use default region from the config
-        :param image_id: The unique ID of the image
-        :param page: A positive integer to choose the page to display
-        :param page_size: A positive integer lower or equal to 100 to select the number of items to display
-        :param order_by: Field by which to order the display of Images
-        :param name: Filter by the tag name (exact match)
+        List tags.
+        List all tags for a given image, specified by region. By default, the tags listed are ordered by creation date in ascending order. This can be modified via the order_by field. You can also define additional parameters for your query, such as the `name`.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param image_id: UUID of the image.
+        :param page: A positive integer to choose the page to display.
+        :param page_size: A positive integer lower or equal to 100 to select the number of items to display.
+        :param order_by: Criteria to use when ordering tag listings. Possible values are `created_at_asc`, `created_at_desc`, `name_asc`, `name_desc`, `region`, `status_asc` and `status_desc`. The default value is `created_at_asc`.
+        :param name: Filter by the tag name (exact match).
         :return: :class:`List[ListTagsResponse] <List[ListTagsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_tags_all(image_id="example")
         """
@@ -672,17 +685,18 @@
     async def get_tag(
         self,
         *,
         tag_id: str,
         region: Optional[Region] = None,
     ) -> Tag:
         """
-        Get the tag associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param tag_id: The unique ID of the Tag
+        Get a tag.
+        Retrieve information about a given image tag, specified by its `tag_id` and region. Full details about the tag, such as `name`, `image_id`, `status`, and `digest` are returned in the response.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param tag_id: UUID of the tag.
         :return: :class:`Tag <Tag>`
 
         Usage:
         ::
 
             result = await api.get_tag(tag_id="example")
         """
@@ -705,16 +719,16 @@
         *,
         tag_id: str,
         region: Optional[Region] = None,
         options: Optional[WaitForOptions[Tag, Union[bool, Awaitable[bool]]]] = None,
     ) -> Tag:
         """
         Waits for :class:`Tag <Tag>` to be in a final state.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param tag_id: The unique ID of the Tag
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param tag_id: UUID of the tag.
         :param options: The options for the waiter
         :return: :class:`Tag <Tag>`
 
         Usage:
         ::
 
             result = api.wait_for_tag(tag_id="example")
@@ -735,31 +749,29 @@
             },
         )
 
     async def delete_tag(
         self,
         *,
         tag_id: str,
-        force: bool,
         region: Optional[Region] = None,
+        force: Optional[bool] = None,
     ) -> Tag:
         """
-        Delete the tag associated with the given id.
-        :param region: Region to target. If none is passed will use default region from the config
-        :param tag_id: The unique ID of the tag
-        :param force: If two tags share the same digest the deletion will fail unless this parameter is set to true
+        Delete a tag.
+        Delete a given image tag. You must specify, in the endpoint, the `region` and `tag_id` parameters of the tag you want to delete.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param tag_id: UUID of the tag.
+        :param force: If two tags share the same digest the deletion will fail unless this parameter is set to true (deprecated).
         :return: :class:`Tag <Tag>`
 
         Usage:
         ::
 
-            result = await api.delete_tag(
-                tag_id="example",
-                force=True,
-            )
+            result = await api.delete_tag(tag_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
         param_tag_id = validate_path_param("tag_id", tag_id)
```

### Comparing `scaleway_async-0.9.0/scaleway_async/registry/v1/content.py` & `scaleway_async-1.0.0/scaleway_async/registry/v1/content.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-0.9.0/scaleway_async/registry/v1/types.py` & `scaleway_async-1.0.0/scaleway_async/registry/v1/types.py`

 * *Files 12% similar despite different names*

```diff
@@ -86,505 +86,507 @@
     def __str__(self) -> str:
         return str(self.value)
 
 
 @dataclass
 class Image:
     """
-    Image
+    Image.
     """
 
     id: str
     """
-    The unique ID of the Image
+    UUID of the image.
     """
 
     name: str
     """
-    The Image name, unique in a namespace
+    Name of the image, it must be unique within the namespace.
     """
 
     namespace_id: str
     """
-    The unique ID of the Namespace the image belongs to
+    UUID of the namespace the image belongs to.
     """
 
     status: ImageStatus
     """
-    The status of the image
+    Status of the image.
     """
 
     status_message: Optional[str]
     """
-    Details of the image status
+    Details of the image status.
     """
 
     visibility: ImageVisibility
     """
-    A `public` image is pullable from internet without authentication, opposed to a `private` image. `inherit` will use the namespace `is_public` parameter
+    Set to `public` to allow the image to be pulled without authentication. Else, set to  `private`. Set to `inherit` to keep the same visibility configuration as the namespace.
     """
 
     size: int
     """
+    Image size in bytes, calculated from the size of image layers.
     Image size in bytes, calculated from the size of image layers. One layer used in two tags of the same image is counted once but one layer used in two images is counted twice.
     """
 
     created_at: Optional[datetime]
     """
-    Creation date
+    Date and time of image creation.
     """
 
     updated_at: Optional[datetime]
     """
-    Last modification date, from the user or the service
+    Date and time of last update.
     """
 
     tags: List[str]
     """
-    List of docker tags of the image
+    List of docker tags of the image.
     """
 
 
 @dataclass
 class ListImagesResponse:
     """
-    List images response
+    List images response.
     """
 
     images: List[Image]
     """
-    Paginated list of images matching filters
+    Paginated list of images that match the selected filters.
     """
 
     total_count: int
     """
-    Total number of images matching filters
+    Total number of images that match the selected filters.
     """
 
 
 @dataclass
 class ListNamespacesResponse:
     """
-    List namespaces response
+    List namespaces response.
     """
 
     namespaces: List[Namespace]
     """
-    Paginated list of namespaces matching filters
+    Paginated list of namespaces that match the selected filters.
     """
 
     total_count: int
     """
-    Total number of namespaces matching filters
+    Total number of namespaces that match the selected filters.
     """
 
 
 @dataclass
 class ListTagsResponse:
     """
-    List tags response
+    List tags response.
     """
 
     tags: List[Tag]
     """
-    Paginated list of tags matching filters
+    Paginated list of tags that match the selected filters.
     """
 
     total_count: int
     """
-    Total number of tags matching filters
+    Total number of tags that match the selected filters.
     """
 
 
 @dataclass
 class Namespace:
     """
-    Namespace
+    Namespace.
     """
 
     id: str
     """
-    The unique ID of the namespace
+    UUID of the namespace.
     """
 
     name: str
     """
-    The name of the namespace, unique in a region accross all organizations
+    Name of the namespace, unique in a region accross all organizations.
     """
 
     description: str
     """
-    Description of the namespace
+    Description of the namespace.
     """
 
     organization_id: str
     """
-    Owner of the namespace
+    Owner of the namespace.
     """
 
     project_id: str
     """
-    Project of the namespace
+    Project of the namespace.
     """
 
     status: NamespaceStatus
     """
-    Namespace status
+    Namespace status.
     """
 
     status_message: str
     """
-    Namespace status details
+    Namespace status details.
     """
 
     endpoint: str
     """
-    Endpoint reachable by docker
+    Endpoint reachable by docker.
     """
 
     is_public: bool
     """
-    Namespace visibility policy
+    Defines whether or not namespace is public.
     """
 
     size: int
     """
-    Total size of the namespace, calculated as the sum of the size of all images in the namespace
+    Total size of the namespace, calculated as the sum of the size of all images in the namespace.
     """
 
     created_at: Optional[datetime]
     """
-    Creation date
+    Date and time of creation.
     """
 
     updated_at: Optional[datetime]
     """
-    Last modification date, from the user or the service
+    Date and time of last update.
     """
 
     image_count: int
     """
-    Number of images in the namespace
+    Number of images in the namespace.
     """
 
     region: Region
     """
-    Region the namespace belongs to
+    Region the namespace belongs to.
     """
 
 
 @dataclass
 class Tag:
     """
-    Tag
+    Tag.
     """
 
     id: str
     """
-    The unique ID of the tag
+    UUID of the tag.
     """
 
     name: str
     """
-    Tag name, unique for an image
+    Tag name, unique to an image.
     """
 
     image_id: str
     """
-    Image ID this tag belongs to
+    Image ID the of the image the tag belongs to.
     """
 
     status: TagStatus
     """
-    Tag status
+    Tag status.
     """
 
     digest: str
     """
-    Hash of the tag actual content. Several tags of a same image may have the same digest
+    Hash of the tag content. Several tags of a same image may have the same digest.
     """
 
     created_at: Optional[datetime]
     """
-    Creation date
+    Date and time of creation.
     """
 
     updated_at: Optional[datetime]
     """
-    Last modification date, from the user or the service
+    Date and time of last update.
     """
 
 
 @dataclass
 class ListNamespacesRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     page: Optional[int]
     """
-    A positive integer to choose the page to display
+    A positive integer to choose the page to display.
     """
 
     page_size: Optional[int]
     """
-    A positive integer lower or equal to 100 to select the number of items to display
+    A positive integer lower or equal to 100 to select the number of items to display.
     """
 
     order_by: Optional[ListNamespacesRequestOrderBy]
     """
-    Field by which to order the display of Images
+    Criteria to use when ordering namespace listings. Possible values are `created_at_asc`, `created_at_desc`, `name_asc`, `name_desc`, `region`, `status_asc` and `status_desc`. The default value is `created_at_asc`.
     """
 
     organization_id: Optional[str]
     """
-    Filter by Organization ID
+    Filter by Organization ID.
     """
 
     project_id: Optional[str]
     """
-    Filter by Project ID
+    Filter by Project ID.
     """
 
     name: Optional[str]
     """
-    Filter by the namespace name (exact match)
+    Filter by the namespace name (exact match).
     """
 
 
 @dataclass
 class GetNamespaceRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     namespace_id: str
     """
-    The unique ID of the Namespace
+    UUID of the namespace.
     """
 
 
 @dataclass
 class CreateNamespaceRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     name: Optional[str]
     """
-    Define a namespace name
+    Name of the namespace.
     """
 
     description: str
     """
-    Define a description
+    Description of the namespace.
     """
 
     organization_id: Optional[str]
     """
-    Assign the namespace owner (deprecated).
+    Namespace owner (deprecated).
     
     One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
     :deprecated
     """
 
     project_id: Optional[str]
     """
-    Assign the namespace to a project ID.
+    Project ID on which the namespace will be created.
     
     One-of ('project_identifier'): at most one of 'organization_id', 'project_id' could be set.
     """
 
     is_public: bool
     """
-    Define the default visibility policy
+    Defines whether or not namespace is public.
     """
 
 
 @dataclass
 class UpdateNamespaceRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     namespace_id: str
     """
-    Namespace ID to update
+    ID of the namespace to update.
     """
 
     description: Optional[str]
     """
-    Define a description
+    Namespace description.
     """
 
     is_public: Optional[bool]
     """
-    Define the default visibility policy
+    Defines whether or not the namespace is public.
     """
 
 
 @dataclass
 class DeleteNamespaceRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     namespace_id: str
     """
-    The unique ID of the Namespace
+    UUID of the namespace.
     """
 
 
 @dataclass
 class ListImagesRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     page: Optional[int]
     """
-    A positive integer to choose the page to display
+    A positive integer to choose the page to display.
     """
 
     page_size: Optional[int]
     """
-    A positive integer lower or equal to 100 to select the number of items to display
+    A positive integer lower or equal to 100 to select the number of items to display.
     """
 
     order_by: Optional[ListImagesRequestOrderBy]
     """
-    Field by which to order the display of Images
+    Criteria to use when ordering image listings. Possible values are `created_at_asc`, `created_at_desc`, `name_asc`, `name_desc`, `region`, `status_asc` and `status_desc`. The default value is `created_at_asc`.
     """
 
     namespace_id: Optional[str]
     """
-    Filter by the Namespace ID
+    Filter by the namespace ID.
     """
 
     name: Optional[str]
     """
-    Filter by the Image name (exact match)
+    Filter by the image name (exact match).
     """
 
     organization_id: Optional[str]
     """
-    Filter by Organization ID
+    Filter by Organization ID.
     """
 
     project_id: Optional[str]
     """
-    Filter by Project ID
+    Filter by Project ID.
     """
 
 
 @dataclass
 class GetImageRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     image_id: str
     """
-    The unique ID of the Image
+    UUID of the image.
     """
 
 
 @dataclass
 class UpdateImageRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     image_id: str
     """
-    Image ID to update
+    ID of the image to update.
     """
 
     visibility: ImageVisibility
     """
-    A `public` image is pullable from internet without authentication, opposed to a `private` image. `inherit` will use the namespace `is_public` parameter
+    Set to `public` to allow the image to be pulled without authentication. Else, set to  `private`. Set to `inherit` to keep the same visibility configuration as the namespace.
     """
 
 
 @dataclass
 class DeleteImageRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     image_id: str
     """
-    The unique ID of the Image
+    UUID of the image.
     """
 
 
 @dataclass
 class ListTagsRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     image_id: str
     """
-    The unique ID of the image
+    UUID of the image.
     """
 
     page: Optional[int]
     """
-    A positive integer to choose the page to display
+    A positive integer to choose the page to display.
     """
 
     page_size: Optional[int]
     """
-    A positive integer lower or equal to 100 to select the number of items to display
+    A positive integer lower or equal to 100 to select the number of items to display.
     """
 
     order_by: Optional[ListTagsRequestOrderBy]
     """
-    Field by which to order the display of Images
+    Criteria to use when ordering tag listings. Possible values are `created_at_asc`, `created_at_desc`, `name_asc`, `name_desc`, `region`, `status_asc` and `status_desc`. The default value is `created_at_asc`.
     """
 
     name: Optional[str]
     """
-    Filter by the tag name (exact match)
+    Filter by the tag name (exact match).
     """
 
 
 @dataclass
 class GetTagRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     tag_id: str
     """
-    The unique ID of the Tag
+    UUID of the tag.
     """
 
 
 @dataclass
 class DeleteTagRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     tag_id: str
     """
-    The unique ID of the tag
+    UUID of the tag.
     """
 
-    force: bool
+    force: Optional[bool]
     """
-    If two tags share the same digest the deletion will fail unless this parameter is set to true
+    If two tags share the same digest the deletion will fail unless this parameter is set to true (deprecated).
+    :deprecated
     """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/secret/v1alpha1/__init__.py` & `scaleway_async-1.0.0/scaleway_async/secret/v1alpha1/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,23 +1,31 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 from .types import ListSecretsRequestOrderBy
+from .types import Product
 from .types import SecretStatus
+from .types import SecretType
 from .types import SecretVersionStatus
 from .types import AccessSecretVersionResponse
 from .types import ListSecretVersionsResponse
 from .types import ListSecretsResponse
+from .types import ListTagsResponse
+from .types import PasswordGenerationParams
 from .types import Secret
 from .types import SecretVersion
 from .api import SecretV1Alpha1API
 
 __all__ = [
     "ListSecretsRequestOrderBy",
+    "Product",
     "SecretStatus",
+    "SecretType",
     "SecretVersionStatus",
     "AccessSecretVersionResponse",
     "ListSecretVersionsResponse",
     "ListSecretsResponse",
+    "ListTagsResponse",
+    "PasswordGenerationParams",
     "Secret",
     "SecretVersion",
     "SecretV1Alpha1API",
 ]
```

### Comparing `scaleway_async-0.9.0/scaleway_async/secret/v1alpha1/api.py` & `scaleway_async-1.0.0/scaleway_async/tem/v1alpha1/api.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,840 +1,721 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 
-from typing import List, Optional
+from datetime import datetime
+from typing import Awaitable, List, Optional, Union
 
 from scaleway_core.api import API
 from scaleway_core.bridge import (
     Region,
 )
 from scaleway_core.utils import (
+    WaitForOptions,
     fetch_all_pages_async,
     validate_path_param,
+    wait_for_resource_async,
 )
 from .types import (
-    ListSecretsRequestOrderBy,
-    SecretVersionStatus,
-    AccessSecretVersionResponse,
-    ListSecretVersionsResponse,
-    ListSecretsResponse,
-    Secret,
-    SecretVersion,
-    CreateSecretRequest,
-    UpdateSecretRequest,
-    CreateSecretVersionRequest,
-    UpdateSecretVersionRequest,
+    DomainStatus,
+    EmailFlag,
+    EmailStatus,
+    ListEmailsRequestOrderBy,
+    CreateEmailRequestAddress,
+    CreateEmailRequestAttachment,
+    CreateEmailResponse,
+    Domain,
+    DomainLastStatus,
+    Email,
+    ListDomainsResponse,
+    ListEmailsResponse,
+    Statistics,
+    CreateEmailRequest,
+    CreateDomainRequest,
+)
+from .content import (
+    DOMAIN_TRANSIENT_STATUSES,
+    EMAIL_TRANSIENT_STATUSES,
 )
 from .marshalling import (
-    marshal_CreateSecretRequest,
-    marshal_CreateSecretVersionRequest,
-    marshal_UpdateSecretRequest,
-    marshal_UpdateSecretVersionRequest,
-    unmarshal_Secret,
-    unmarshal_SecretVersion,
-    unmarshal_AccessSecretVersionResponse,
-    unmarshal_ListSecretVersionsResponse,
-    unmarshal_ListSecretsResponse,
+    marshal_CreateDomainRequest,
+    marshal_CreateEmailRequest,
+    unmarshal_Domain,
+    unmarshal_Email,
+    unmarshal_CreateEmailResponse,
+    unmarshal_DomainLastStatus,
+    unmarshal_ListDomainsResponse,
+    unmarshal_ListEmailsResponse,
+    unmarshal_Statistics,
 )
 
 
-class SecretV1Alpha1API(API):
+class TemV1Alpha1API(API):
     """
-    Secret API (beta).
+    Transactional Email API.
 
-    This API allows you to conveniently store, access and share sensitive data.
+    Transactional Email API.
     """
 
-    async def create_secret(
+    async def create_email(
         self,
         *,
-        name: str,
+        subject: str,
+        text: str,
+        html: str,
         region: Optional[Region] = None,
+        from_: Optional[CreateEmailRequestAddress] = None,
+        to: Optional[List[CreateEmailRequestAddress]] = None,
+        cc: Optional[List[CreateEmailRequestAddress]] = None,
+        bcc: Optional[List[CreateEmailRequestAddress]] = None,
         project_id: Optional[str] = None,
-        tags: Optional[List[str]] = None,
-        description: Optional[str] = None,
-    ) -> Secret:
-        """
-        Create a Secret containing no versions
-        :param region: Region to target. If none is passed will use default region from the config.
-        :param project_id: ID of the project containing the Secret.
-        :param name: Name of the Secret.
-        :param tags: List of tags associated to this Secret.
-        :param description: Description of the Secret.
-        :return: :class:`Secret <Secret>`
+        attachments: Optional[List[CreateEmailRequestAttachment]] = None,
+        send_before: Optional[datetime] = None,
+    ) -> CreateEmailResponse:
+        """
+        Send an email.
+        You must specify the `region`, the sender and the recipient's information and the `project_id` to send an email from a checked domain. The subject of the email must contain at least 6 characters.
+        :param region: Region to target. If none is passed will use default region from the config.
+        :param from_: Sender information. Must be from a checked domain declared in the Project.
+        :param to: An array of the primary recipient's information.
+        :param cc: An array of the carbon copy recipient's information.
+        :param bcc: An array of the blind carbon copy recipient's information.
+        :param subject: Subject of the email.
+        :param text: Text content.
+        :param html: HTML content.
+        :param project_id: ID of the Project in which to create the email.
+        :param attachments: Array of attachments.
+        :param send_before: Maximum date to deliver the email.
+        :return: :class:`CreateEmailResponse <CreateEmailResponse>`
 
         Usage:
         ::
 
-            result = await api.create_secret(name="example")
+            result = await api.create_email(
+                subject="example",
+                text="example",
+                html="example",
+            )
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "POST",
-            f"/secret-manager/v1alpha1/regions/{param_region}/secrets",
-            body=marshal_CreateSecretRequest(
-                CreateSecretRequest(
-                    name=name,
+            f"/transactional-email/v1alpha1/regions/{param_region}/emails",
+            body=marshal_CreateEmailRequest(
+                CreateEmailRequest(
+                    subject=subject,
+                    text=text,
+                    html=html,
                     region=region,
+                    from_=from_,
+                    to=to,
+                    cc=cc,
+                    bcc=bcc,
                     project_id=project_id,
-                    tags=tags,
-                    description=description,
+                    attachments=attachments,
+                    send_before=send_before,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
-        return unmarshal_Secret(res.json())
+        return unmarshal_CreateEmailResponse(res.json())
 
-    async def get_secret(
+    async def get_email(
         self,
         *,
-        secret_id: str,
+        email_id: str,
         region: Optional[Region] = None,
-    ) -> Secret:
+    ) -> Email:
         """
-        Get metadata of a Secret
+        Get an email.
+        Retrieve information about a specific email using the `email_id` and `region` parameters.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param secret_id: ID of the Secret.
-        :return: :class:`Secret <Secret>`
+        :param email_id: ID of the email to retrieve.
+        :return: :class:`Email <Email>`
 
         Usage:
         ::
 
-            result = await api.get_secret(secret_id="example")
+            result = await api.get_email(email_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_secret_id = validate_path_param("secret_id", secret_id)
+        param_email_id = validate_path_param("email_id", email_id)
 
         res = self._request(
             "GET",
-            f"/secret-manager/v1alpha1/regions/{param_region}/secrets/{param_secret_id}",
+            f"/transactional-email/v1alpha1/regions/{param_region}/emails/{param_email_id}",
         )
 
         self._throw_on_error(res)
-        return unmarshal_Secret(res.json())
+        return unmarshal_Email(res.json())
 
-    async def get_secret_by_name(
+    async def wait_for_email(
         self,
         *,
-        secret_name: str,
+        email_id: str,
         region: Optional[Region] = None,
-    ) -> Secret:
+        options: Optional[WaitForOptions[Email, Union[bool, Awaitable[bool]]]] = None,
+    ) -> Email:
         """
-        Get metadata of a Secret
+        Waits for :class:`Email <Email>` to be in a final state.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param secret_name: Name of the Secret.
-        :return: :class:`Secret <Secret>`
+        :param email_id: ID of the email to retrieve.
+        :param options: The options for the waiter
+        :return: :class:`Email <Email>`
 
         Usage:
         ::
 
-            result = await api.get_secret_by_name(secret_name="example")
+            result = api.wait_for_email(email_id="example")
         """
 
-        param_region = validate_path_param(
-            "region", region or self.client.default_region
-        )
-        param_secret_name = validate_path_param("secret_name", secret_name)
+        if not options:
+            options = WaitForOptions()
 
-        res = self._request(
-            "GET",
-            f"/secret-manager/v1alpha1/regions/{param_region}/secrets-by-name/{param_secret_name}",
-        )
+        if not options.stop:
+            options.stop = lambda res: res.status not in EMAIL_TRANSIENT_STATUSES
 
-        self._throw_on_error(res)
-        return unmarshal_Secret(res.json())
-
-    async def update_secret(
-        self,
-        *,
-        secret_id: str,
-        region: Optional[Region] = None,
-        name: Optional[str] = None,
-        tags: Optional[List[str]] = None,
-        description: Optional[str] = None,
-    ) -> Secret:
-        """
-        Update metadata of a Secret
-        :param region: Region to target. If none is passed will use default region from the config.
-        :param secret_id: ID of the Secret.
-        :param name: New name of the Secret (optional).
-        :param tags: New list of tags associated to this Secret (optional).
-        :param description: Description of the Secret.
-        :return: :class:`Secret <Secret>`
-
-        Usage:
-        ::
-
-            result = await api.update_secret(secret_id="example")
-        """
-
-        param_region = validate_path_param(
-            "region", region or self.client.default_region
-        )
-        param_secret_id = validate_path_param("secret_id", secret_id)
-
-        res = self._request(
-            "PATCH",
-            f"/secret-manager/v1alpha1/regions/{param_region}/secrets/{param_secret_id}",
-            body=marshal_UpdateSecretRequest(
-                UpdateSecretRequest(
-                    secret_id=secret_id,
-                    region=region,
-                    name=name,
-                    tags=tags,
-                    description=description,
-                ),
-                self.client,
-            ),
+        return await wait_for_resource_async(
+            fetcher=self.get_email,
+            options=options,
+            args={
+                "email_id": email_id,
+                "region": region,
+            },
         )
 
-        self._throw_on_error(res)
-        return unmarshal_Secret(res.json())
-
-    async def list_secrets(
+    async def list_emails(
         self,
         *,
         region: Optional[Region] = None,
-        organization_id: Optional[str] = None,
-        project_id: Optional[str] = None,
-        name: Optional[str] = None,
-        tags: Optional[List[str]] = None,
-        order_by: ListSecretsRequestOrderBy = ListSecretsRequestOrderBy.NAME_ASC,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
-    ) -> ListSecretsResponse:
+        project_id: Optional[str] = None,
+        domain_id: Optional[str] = None,
+        message_id: Optional[str] = None,
+        since: Optional[datetime] = None,
+        until: Optional[datetime] = None,
+        mail_from: Optional[str] = None,
+        mail_to: Optional[str] = None,
+        mail_rcpt: Optional[str] = None,
+        statuses: Optional[List[EmailStatus]] = None,
+        subject: Optional[str] = None,
+        search: Optional[str] = None,
+        order_by: ListEmailsRequestOrderBy = ListEmailsRequestOrderBy.CREATED_AT_DESC,
+        flags: Optional[List[EmailFlag]] = None,
+    ) -> ListEmailsResponse:
         """
-        List Secrets
+        List emails.
+        Retrieve the list of emails sent from a specific domain or for a specific Project or Organization. You must specify the `region`.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param organization_id: ID of an organization to filter on (optional).
-        :param project_id: ID of a project to filter on (optional).
-        :param name: Secret name to filter on (optional).
-        :param tags: List of tags to filter on (optional).
-        :param order_by:
         :param page:
         :param page_size:
-        :return: :class:`ListSecretsResponse <ListSecretsResponse>`
+        :param project_id: (Optional) ID of the Project in which to list the emails.
+        :param domain_id: (Optional) ID of the domain for which to list the emails.
+        :param message_id: (Optional) ID of the message for which to list the emails.
+        :param since: (Optional) List emails created after this date.
+        :param until: (Optional) List emails created before this date.
+        :param mail_from: (Optional) List emails sent with this sender's email address.
+        :param mail_to: List emails sent to this recipient's email address.
+        :param mail_rcpt: (Optional) List emails sent to this recipient's email address.
+        :param statuses: (Optional) List emails with any of these statuses.
+        :param subject: (Optional) List emails with this subject.
+        :param search: (Optional) List emails by searching to all fields.
+        :param order_by: (Optional) List emails corresponding to specific criteria.
+        :param flags: (Optional) List emails containing only specific flags.
+        :return: :class:`ListEmailsResponse <ListEmailsResponse>`
 
         Usage:
         ::
 
-            result = await api.list_secrets()
+            result = await api.list_emails()
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "GET",
-            f"/secret-manager/v1alpha1/regions/{param_region}/secrets",
+            f"/transactional-email/v1alpha1/regions/{param_region}/emails",
             params={
-                "name": name,
+                "domain_id": domain_id,
+                "flags": flags,
+                "mail_from": mail_from,
+                "mail_rcpt": mail_rcpt,
+                "mail_to": mail_to,
+                "message_id": message_id,
                 "order_by": order_by,
-                "organization_id": organization_id
-                or self.client.default_organization_id,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
                 "project_id": project_id or self.client.default_project_id,
-                "tags": tags,
+                "search": search,
+                "since": since,
+                "statuses": statuses,
+                "subject": subject,
+                "until": until,
             },
         )
 
         self._throw_on_error(res)
-        return unmarshal_ListSecretsResponse(res.json())
+        return unmarshal_ListEmailsResponse(res.json())
 
-    async def list_secrets_all(
+    async def list_emails_all(
         self,
         *,
         region: Optional[Region] = None,
-        organization_id: Optional[str] = None,
-        project_id: Optional[str] = None,
-        name: Optional[str] = None,
-        tags: Optional[List[str]] = None,
-        order_by: Optional[ListSecretsRequestOrderBy] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
-    ) -> List[Secret]:
+        project_id: Optional[str] = None,
+        domain_id: Optional[str] = None,
+        message_id: Optional[str] = None,
+        since: Optional[datetime] = None,
+        until: Optional[datetime] = None,
+        mail_from: Optional[str] = None,
+        mail_to: Optional[str] = None,
+        mail_rcpt: Optional[str] = None,
+        statuses: Optional[List[EmailStatus]] = None,
+        subject: Optional[str] = None,
+        search: Optional[str] = None,
+        order_by: Optional[ListEmailsRequestOrderBy] = None,
+        flags: Optional[List[EmailFlag]] = None,
+    ) -> List[Email]:
         """
-        List Secrets
+        List emails.
+        Retrieve the list of emails sent from a specific domain or for a specific Project or Organization. You must specify the `region`.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param organization_id: ID of an organization to filter on (optional).
-        :param project_id: ID of a project to filter on (optional).
-        :param name: Secret name to filter on (optional).
-        :param tags: List of tags to filter on (optional).
-        :param order_by:
         :param page:
         :param page_size:
-        :return: :class:`List[ListSecretsResponse] <List[ListSecretsResponse]>`
+        :param project_id: (Optional) ID of the Project in which to list the emails.
+        :param domain_id: (Optional) ID of the domain for which to list the emails.
+        :param message_id: (Optional) ID of the message for which to list the emails.
+        :param since: (Optional) List emails created after this date.
+        :param until: (Optional) List emails created before this date.
+        :param mail_from: (Optional) List emails sent with this sender's email address.
+        :param mail_to: List emails sent to this recipient's email address.
+        :param mail_rcpt: (Optional) List emails sent to this recipient's email address.
+        :param statuses: (Optional) List emails with any of these statuses.
+        :param subject: (Optional) List emails with this subject.
+        :param search: (Optional) List emails by searching to all fields.
+        :param order_by: (Optional) List emails corresponding to specific criteria.
+        :param flags: (Optional) List emails containing only specific flags.
+        :return: :class:`List[ListEmailsResponse] <List[ListEmailsResponse]>`
 
         Usage:
         ::
 
-            result = await api.list_secrets_all()
+            result = await api.list_emails_all()
         """
 
         return await fetch_all_pages_async(
-            type=ListSecretsResponse,
-            key="secrets",
-            fetcher=self.list_secrets,
+            type=ListEmailsResponse,
+            key="emails",
+            fetcher=self.list_emails,
             args={
                 "region": region,
-                "organization_id": organization_id,
-                "project_id": project_id,
-                "name": name,
-                "tags": tags,
-                "order_by": order_by,
                 "page": page,
                 "page_size": page_size,
+                "project_id": project_id,
+                "domain_id": domain_id,
+                "message_id": message_id,
+                "since": since,
+                "until": until,
+                "mail_from": mail_from,
+                "mail_to": mail_to,
+                "mail_rcpt": mail_rcpt,
+                "statuses": statuses,
+                "subject": subject,
+                "search": search,
+                "order_by": order_by,
+                "flags": flags,
             },
         )
 
-    async def delete_secret(
+    async def get_statistics(
         self,
         *,
-        secret_id: str,
         region: Optional[Region] = None,
-    ) -> Optional[None]:
-        """
-        Delete a secret
-        :param region: Region to target. If none is passed will use default region from the config.
-        :param secret_id: ID of the Secret.
-
-        Usage:
-        ::
-
-            result = await api.delete_secret(secret_id="example")
-        """
-
-        param_region = validate_path_param(
-            "region", region or self.client.default_region
-        )
-        param_secret_id = validate_path_param("secret_id", secret_id)
-
-        res = self._request(
-            "DELETE",
-            f"/secret-manager/v1alpha1/regions/{param_region}/secrets/{param_secret_id}",
-        )
-
-        self._throw_on_error(res)
-        return None
-
-    async def create_secret_version(
-        self,
-        *,
-        secret_id: str,
-        data: str,
-        region: Optional[Region] = None,
-        description: Optional[str] = None,
-    ) -> SecretVersion:
-        """
-        Create a SecretVersion
-        :param region: Region to target. If none is passed will use default region from the config.
-        :param secret_id: ID of the Secret.
-        :param data: The base64-encoded secret payload of the SecretVersion.
-        :param description: Description of the SecretVersion.
-        :return: :class:`SecretVersion <SecretVersion>`
-
-        Usage:
-        ::
-
-            result = await api.create_secret_version(
-                secret_id="example",
-                data="example",
-            )
-        """
-
-        param_region = validate_path_param(
-            "region", region or self.client.default_region
-        )
-        param_secret_id = validate_path_param("secret_id", secret_id)
-
-        res = self._request(
-            "POST",
-            f"/secret-manager/v1alpha1/regions/{param_region}/secrets/{param_secret_id}/versions",
-            body=marshal_CreateSecretVersionRequest(
-                CreateSecretVersionRequest(
-                    secret_id=secret_id,
-                    data=data,
-                    region=region,
-                    description=description,
-                ),
-                self.client,
-            ),
-        )
-
-        self._throw_on_error(res)
-        return unmarshal_SecretVersion(res.json())
-
-    async def get_secret_version(
-        self,
-        *,
-        secret_id: str,
-        revision: str,
-        region: Optional[Region] = None,
-    ) -> SecretVersion:
+        project_id: Optional[str] = None,
+        domain_id: Optional[str] = None,
+        since: Optional[datetime] = None,
+        until: Optional[datetime] = None,
+        mail_from: Optional[str] = None,
+    ) -> Statistics:
         """
-        Get metadata of a SecretVersion
+        Email statuses.
+        Get information on your emails' statuses.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param secret_id: ID of the Secret.
-        :param revision: Revision of the SecretVersion (may be a number or "latest").
-        :return: :class:`SecretVersion <SecretVersion>`
+        :param project_id: (Optional) Number of emails for this Project.
+        :param domain_id: (Optional) Number of emails sent from this domain (must be coherent with the `project_id` and the `organization_id`).
+        :param since: (Optional) Number of emails created after this date.
+        :param until: (Optional) Number of emails created before this date.
+        :param mail_from: (Optional) Number of emails sent with this sender's email address.
+        :return: :class:`Statistics <Statistics>`
 
         Usage:
         ::
 
-            result = await api.get_secret_version(
-                secret_id="example",
-                revision="example",
-            )
+            result = await api.get_statistics()
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_secret_id = validate_path_param("secret_id", secret_id)
-        param_revision = validate_path_param("revision", revision)
 
         res = self._request(
             "GET",
-            f"/secret-manager/v1alpha1/regions/{param_region}/secrets/{param_secret_id}/versions/{param_revision}",
+            f"/transactional-email/v1alpha1/regions/{param_region}/statistics",
+            params={
+                "domain_id": domain_id,
+                "mail_from": mail_from,
+                "project_id": project_id or self.client.default_project_id,
+                "since": since,
+                "until": until,
+            },
         )
 
         self._throw_on_error(res)
-        return unmarshal_SecretVersion(res.json())
+        return unmarshal_Statistics(res.json())
 
-    async def get_secret_version_by_name(
+    async def cancel_email(
         self,
         *,
-        secret_name: str,
-        revision: str,
+        email_id: str,
         region: Optional[Region] = None,
-    ) -> SecretVersion:
+    ) -> Email:
         """
-        Get metadata of a SecretVersion
+        Cancel an email.
+        You can cancel the sending of an email if it has not been sent yet. You must specify the `region` and the `email_id` of the email you want to cancel.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param secret_name: Name of the Secret.
-        :param revision: Revision of the SecretVersion (may be a number or "latest").
-        :return: :class:`SecretVersion <SecretVersion>`
+        :param email_id: ID of the email to cancel.
+        :return: :class:`Email <Email>`
 
         Usage:
         ::
 
-            result = await api.get_secret_version_by_name(
-                secret_name="example",
-                revision="example",
-            )
+            result = await api.cancel_email(email_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_secret_name = validate_path_param("secret_name", secret_name)
-        param_revision = validate_path_param("revision", revision)
+        param_email_id = validate_path_param("email_id", email_id)
 
         res = self._request(
-            "GET",
-            f"/secret-manager/v1alpha1/regions/{param_region}/secrets-by-name/{param_secret_name}/versions/{param_revision}",
+            "POST",
+            f"/transactional-email/v1alpha1/regions/{param_region}/emails/{param_email_id}/cancel",
         )
 
         self._throw_on_error(res)
-        return unmarshal_SecretVersion(res.json())
+        return unmarshal_Email(res.json())
 
-    async def update_secret_version(
+    async def create_domain(
         self,
         *,
-        secret_id: str,
-        revision: str,
+        domain_name: str,
+        accept_tos: bool,
         region: Optional[Region] = None,
-        description: Optional[str] = None,
-    ) -> SecretVersion:
+        project_id: Optional[str] = None,
+    ) -> Domain:
         """
-        Update metadata of a SecretVersion
+        Register a domain in a project.
+        You must specify the `region`, `project_id` and `domain_name` to register a domain in a specific Project.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param secret_id: ID of the Secret.
-        :param revision: Revision of the SecretVersion (may be a number or "latest").
-        :param description: Description of the SecretVersion.
-        :return: :class:`SecretVersion <SecretVersion>`
+        :param project_id: ID of the project to which the domain belongs.
+        :param domain_name: Fully qualified domain dame.
+        :param accept_tos: Accept Scaleway's Terms of Service.
+        :return: :class:`Domain <Domain>`
 
         Usage:
         ::
 
-            result = await api.update_secret_version(
-                secret_id="example",
-                revision="example",
+            result = await api.create_domain(
+                domain_name="example",
+                accept_tos=True,
             )
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_secret_id = validate_path_param("secret_id", secret_id)
-        param_revision = validate_path_param("revision", revision)
 
         res = self._request(
-            "PATCH",
-            f"/secret-manager/v1alpha1/regions/{param_region}/secrets/{param_secret_id}/versions/{param_revision}",
-            body=marshal_UpdateSecretVersionRequest(
-                UpdateSecretVersionRequest(
-                    secret_id=secret_id,
-                    revision=revision,
+            "POST",
+            f"/transactional-email/v1alpha1/regions/{param_region}/domains",
+            body=marshal_CreateDomainRequest(
+                CreateDomainRequest(
+                    domain_name=domain_name,
+                    accept_tos=accept_tos,
                     region=region,
-                    description=description,
+                    project_id=project_id,
                 ),
                 self.client,
             ),
         )
 
         self._throw_on_error(res)
-        return unmarshal_SecretVersion(res.json())
+        return unmarshal_Domain(res.json())
 
-    async def list_secret_versions(
+    async def get_domain(
         self,
         *,
-        secret_id: str,
+        domain_id: str,
         region: Optional[Region] = None,
-        page: Optional[int] = None,
-        page_size: Optional[int] = None,
-        status: Optional[List[SecretVersionStatus]] = None,
-    ) -> ListSecretVersionsResponse:
+    ) -> Domain:
         """
-        List versions of a secret, not returning any sensitive data
+        Get information about a domain.
+        Retrieve information about a specific domain using the `region` and `domain_id` parameters.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param secret_id: ID of the Secret.
-        :param page:
-        :param page_size:
-        :param status: Filter results by status.
-        :return: :class:`ListSecretVersionsResponse <ListSecretVersionsResponse>`
+        :param domain_id: ID of the domain.
+        :return: :class:`Domain <Domain>`
 
         Usage:
         ::
 
-            result = await api.list_secret_versions(secret_id="example")
+            result = await api.get_domain(domain_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_secret_id = validate_path_param("secret_id", secret_id)
+        param_domain_id = validate_path_param("domain_id", domain_id)
 
         res = self._request(
             "GET",
-            f"/secret-manager/v1alpha1/regions/{param_region}/secrets/{param_secret_id}/versions",
-            params={
-                "page": page,
-                "page_size": page_size or self.client.default_page_size,
-                "status": status,
-            },
+            f"/transactional-email/v1alpha1/regions/{param_region}/domains/{param_domain_id}",
         )
 
         self._throw_on_error(res)
-        return unmarshal_ListSecretVersionsResponse(res.json())
+        return unmarshal_Domain(res.json())
 
-    async def list_secret_versions_all(
+    async def wait_for_domain(
         self,
         *,
-        secret_id: str,
+        domain_id: str,
         region: Optional[Region] = None,
-        page: Optional[int] = None,
-        page_size: Optional[int] = None,
-        status: Optional[List[SecretVersionStatus]] = None,
-    ) -> List[SecretVersion]:
+        options: Optional[WaitForOptions[Domain, Union[bool, Awaitable[bool]]]] = None,
+    ) -> Domain:
         """
-        List versions of a secret, not returning any sensitive data
+        Waits for :class:`Domain <Domain>` to be in a final state.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param secret_id: ID of the Secret.
-        :param page:
-        :param page_size:
-        :param status: Filter results by status.
-        :return: :class:`List[ListSecretVersionsResponse] <List[ListSecretVersionsResponse]>`
+        :param domain_id: ID of the domain.
+        :param options: The options for the waiter
+        :return: :class:`Domain <Domain>`
 
         Usage:
         ::
 
-            result = await api.list_secret_versions_all(secret_id="example")
+            result = api.wait_for_domain(domain_id="example")
         """
 
-        return await fetch_all_pages_async(
-            type=ListSecretVersionsResponse,
-            key="versions",
-            fetcher=self.list_secret_versions,
+        if not options:
+            options = WaitForOptions()
+
+        if not options.stop:
+            options.stop = lambda res: res.status not in DOMAIN_TRANSIENT_STATUSES
+
+        return await wait_for_resource_async(
+            fetcher=self.get_domain,
+            options=options,
             args={
-                "secret_id": secret_id,
+                "domain_id": domain_id,
                 "region": region,
-                "page": page,
-                "page_size": page_size,
-                "status": status,
             },
         )
 
-    async def list_secret_versions_by_name(
+    async def list_domains(
         self,
         *,
-        secret_name: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
-        status: Optional[List[SecretVersionStatus]] = None,
-    ) -> ListSecretVersionsResponse:
+        project_id: Optional[str] = None,
+        status: Optional[List[DomainStatus]] = None,
+        organization_id: Optional[str] = None,
+        name: Optional[str] = None,
+    ) -> ListDomainsResponse:
         """
-        List versions of a secret, not returning any sensitive data
+        List domains.
+        Retrieve domains in a specific project or in a specific Organization using the `region` parameter.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param secret_name: Name of the Secret.
-        :param page:
-        :param page_size:
-        :param status: Filter results by status.
-        :return: :class:`ListSecretVersionsResponse <ListSecretVersionsResponse>`
+        :param page: Requested page number. Value must be greater or equal to 1.
+        :param page_size: Page size.
+        :param project_id:
+        :param status:
+        :param organization_id:
+        :param name:
+        :return: :class:`ListDomainsResponse <ListDomainsResponse>`
 
         Usage:
         ::
 
-            result = await api.list_secret_versions_by_name(secret_name="example")
+            result = await api.list_domains()
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_secret_name = validate_path_param("secret_name", secret_name)
 
         res = self._request(
             "GET",
-            f"/secret-manager/v1alpha1/regions/{param_region}/secrets-by-name/{param_secret_name}/versions",
+            f"/transactional-email/v1alpha1/regions/{param_region}/domains",
             params={
+                "name": name,
+                "organization_id": organization_id
+                or self.client.default_organization_id,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
+                "project_id": project_id or self.client.default_project_id,
                 "status": status,
             },
         )
 
         self._throw_on_error(res)
-        return unmarshal_ListSecretVersionsResponse(res.json())
+        return unmarshal_ListDomainsResponse(res.json())
 
-    async def list_secret_versions_by_name_all(
+    async def list_domains_all(
         self,
         *,
-        secret_name: str,
         region: Optional[Region] = None,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
-        status: Optional[List[SecretVersionStatus]] = None,
-    ) -> List[SecretVersion]:
+        project_id: Optional[str] = None,
+        status: Optional[List[DomainStatus]] = None,
+        organization_id: Optional[str] = None,
+        name: Optional[str] = None,
+    ) -> List[Domain]:
         """
-        List versions of a secret, not returning any sensitive data
+        List domains.
+        Retrieve domains in a specific project or in a specific Organization using the `region` parameter.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param secret_name: Name of the Secret.
-        :param page:
-        :param page_size:
-        :param status: Filter results by status.
-        :return: :class:`List[ListSecretVersionsResponse] <List[ListSecretVersionsResponse]>`
+        :param page: Requested page number. Value must be greater or equal to 1.
+        :param page_size: Page size.
+        :param project_id:
+        :param status:
+        :param organization_id:
+        :param name:
+        :return: :class:`List[ListDomainsResponse] <List[ListDomainsResponse]>`
 
         Usage:
         ::
 
-            result = await api.list_secret_versions_by_name_all(secret_name="example")
+            result = await api.list_domains_all()
         """
 
         return await fetch_all_pages_async(
-            type=ListSecretVersionsResponse,
-            key="versions",
-            fetcher=self.list_secret_versions_by_name,
+            type=ListDomainsResponse,
+            key="domains",
+            fetcher=self.list_domains,
             args={
-                "secret_name": secret_name,
                 "region": region,
                 "page": page,
                 "page_size": page_size,
+                "project_id": project_id,
                 "status": status,
+                "organization_id": organization_id,
+                "name": name,
             },
         )
 
-    async def destroy_secret_version(
-        self,
-        *,
-        secret_id: str,
-        revision: str,
-        region: Optional[Region] = None,
-    ) -> SecretVersion:
-        """
-        Destroy a SecretVersion, permanently destroying the sensitive data
-        :param region: Region to target. If none is passed will use default region from the config.
-        :param secret_id: ID of the Secret.
-        :param revision: Revision of the SecretVersion (may be a number or "latest").
-        :return: :class:`SecretVersion <SecretVersion>`
-
-        Usage:
-        ::
-
-            result = await api.destroy_secret_version(
-                secret_id="example",
-                revision="example",
-            )
-        """
-
-        param_region = validate_path_param(
-            "region", region or self.client.default_region
-        )
-        param_secret_id = validate_path_param("secret_id", secret_id)
-        param_revision = validate_path_param("revision", revision)
-
-        res = self._request(
-            "POST",
-            f"/secret-manager/v1alpha1/regions/{param_region}/secrets/{param_secret_id}/versions/{param_revision}/destroy",
-        )
-
-        self._throw_on_error(res)
-        return unmarshal_SecretVersion(res.json())
-
-    async def enable_secret_version(
+    async def revoke_domain(
         self,
         *,
-        secret_id: str,
-        revision: str,
+        domain_id: str,
         region: Optional[Region] = None,
-    ) -> SecretVersion:
+    ) -> Domain:
         """
-        Enable a SecretVersion
+        Delete a domain.
+        You must specify the domain you want to delete by the `region` and `domain_id`. Deleting a domain is permanent and cannot be undone.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param secret_id: ID of the Secret.
-        :param revision: Revision of the SecretVersion (may be a number or "latest").
-        :return: :class:`SecretVersion <SecretVersion>`
+        :param domain_id: ID of the domain to delete.
+        :return: :class:`Domain <Domain>`
 
         Usage:
         ::
 
-            result = await api.enable_secret_version(
-                secret_id="example",
-                revision="example",
-            )
+            result = await api.revoke_domain(domain_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_secret_id = validate_path_param("secret_id", secret_id)
-        param_revision = validate_path_param("revision", revision)
+        param_domain_id = validate_path_param("domain_id", domain_id)
 
         res = self._request(
             "POST",
-            f"/secret-manager/v1alpha1/regions/{param_region}/secrets/{param_secret_id}/versions/{param_revision}/enable",
+            f"/transactional-email/v1alpha1/regions/{param_region}/domains/{param_domain_id}/revoke",
         )
 
         self._throw_on_error(res)
-        return unmarshal_SecretVersion(res.json())
+        return unmarshal_Domain(res.json())
 
-    async def disable_secret_version(
+    async def check_domain(
         self,
         *,
-        secret_id: str,
-        revision: str,
+        domain_id: str,
         region: Optional[Region] = None,
-    ) -> SecretVersion:
+    ) -> Domain:
         """
-        Disable a SecretVersion
+        Domain DNS check.
+        Perform an immediate DNS check of a domain using the `region` and `domain_id` parameters.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param secret_id: ID of the Secret.
-        :param revision: Revision of the SecretVersion (may be a number or "latest").
-        :return: :class:`SecretVersion <SecretVersion>`
+        :param domain_id: ID of the domain to check.
+        :return: :class:`Domain <Domain>`
 
         Usage:
         ::
 
-            result = await api.disable_secret_version(
-                secret_id="example",
-                revision="example",
-            )
+            result = await api.check_domain(domain_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_secret_id = validate_path_param("secret_id", secret_id)
-        param_revision = validate_path_param("revision", revision)
+        param_domain_id = validate_path_param("domain_id", domain_id)
 
         res = self._request(
             "POST",
-            f"/secret-manager/v1alpha1/regions/{param_region}/secrets/{param_secret_id}/versions/{param_revision}/disable",
-        )
-
-        self._throw_on_error(res)
-        return unmarshal_SecretVersion(res.json())
-
-    async def access_secret_version(
-        self,
-        *,
-        secret_id: str,
-        revision: str,
-        region: Optional[Region] = None,
-    ) -> AccessSecretVersionResponse:
-        """
-        Access a SecretVersion, returning the sensitive data
-        :param region: Region to target. If none is passed will use default region from the config.
-        :param secret_id: ID of the Secret.
-        :param revision: Revision of the SecretVersion (may be a number or "latest").
-        :return: :class:`AccessSecretVersionResponse <AccessSecretVersionResponse>`
-
-        Usage:
-        ::
-
-            result = await api.access_secret_version(
-                secret_id="example",
-                revision="example",
-            )
-        """
-
-        param_region = validate_path_param(
-            "region", region or self.client.default_region
-        )
-        param_secret_id = validate_path_param("secret_id", secret_id)
-        param_revision = validate_path_param("revision", revision)
-
-        res = self._request(
-            "GET",
-            f"/secret-manager/v1alpha1/regions/{param_region}/secrets/{param_secret_id}/versions/{param_revision}/access",
+            f"/transactional-email/v1alpha1/regions/{param_region}/domains/{param_domain_id}/check",
         )
 
         self._throw_on_error(res)
-        return unmarshal_AccessSecretVersionResponse(res.json())
+        return unmarshal_Domain(res.json())
 
-    async def access_secret_version_by_name(
+    async def get_domain_last_status(
         self,
         *,
-        secret_name: str,
-        revision: str,
+        domain_id: str,
         region: Optional[Region] = None,
-    ) -> AccessSecretVersionResponse:
+    ) -> DomainLastStatus:
         """
-        Access a SecretVersion, returning the sensitive data
+        Display SPF and DKIM records status and potential errors.
+        Display SPF and DKIM records status and potential errors, including the found records to make debugging easier.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param secret_name: Name of the Secret.
-        :param revision: Revision of the SecretVersion (may be a number or "latest").
-        :return: :class:`AccessSecretVersionResponse <AccessSecretVersionResponse>`
+        :param domain_id: ID of the domain to delete.
+        :return: :class:`DomainLastStatus <DomainLastStatus>`
 
         Usage:
         ::
 
-            result = await api.access_secret_version_by_name(
-                secret_name="example",
-                revision="example",
-            )
+            result = await api.get_domain_last_status(domain_id="example")
         """
 
         param_region = validate_path_param(
             "region", region or self.client.default_region
         )
-        param_secret_name = validate_path_param("secret_name", secret_name)
-        param_revision = validate_path_param("revision", revision)
+        param_domain_id = validate_path_param("domain_id", domain_id)
 
         res = self._request(
             "GET",
-            f"/secret-manager/v1alpha1/regions/{param_region}/secrets-by-name/{param_secret_name}/versions/{param_revision}/access",
+            f"/transactional-email/v1alpha1/regions/{param_region}/domains/{param_domain_id}/verification",
         )
 
         self._throw_on_error(res)
-        return unmarshal_AccessSecretVersionResponse(res.json())
+        return unmarshal_DomainLastStatus(res.json())
```

### Comparing `scaleway_async-0.9.0/scaleway_async/secret/v1alpha1/types.py` & `scaleway_async-1.0.0/scaleway_async/cockpit/v1beta1/types.py`

 * *Files 25% similar despite different names*

```diff
@@ -4,538 +4,676 @@
 
 from dataclasses import dataclass
 from datetime import datetime
 from enum import Enum
 from typing import List, Optional
 
 from scaleway_core.bridge import (
-    Region,
+    TimeSeries,
 )
 
 
-class ListSecretsRequestOrderBy(str, Enum):
+class CockpitStatus(str, Enum):
+    UNKNOWN_STATUS = "unknown_status"
+    CREATING = "creating"
+    READY = "ready"
+    DELETING = "deleting"
+    UPDATING = "updating"
+    ERROR = "error"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
+class GrafanaUserRole(str, Enum):
+    UNKNOWN_ROLE = "unknown_role"
+    EDITOR = "editor"
+    VIEWER = "viewer"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
+class ListGrafanaUsersRequestOrderBy(str, Enum):
+    LOGIN_ASC = "login_asc"
+    LOGIN_DESC = "login_desc"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
+class ListPlansRequestOrderBy(str, Enum):
     NAME_ASC = "name_asc"
     NAME_DESC = "name_desc"
-    CREATED_AT_ASC = "created_at_asc"
-    CREATED_AT_DESC = "created_at_desc"
-    UPDATED_AT_ASC = "updated_at_asc"
-    UPDATED_AT_DESC = "updated_at_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class SecretStatus(str, Enum):
-    READY = "ready"
-    LOCKED = "locked"
+class ListTokensRequestOrderBy(str, Enum):
+    CREATED_AT_ASC = "created_at_asc"
+    CREATED_AT_DESC = "created_at_desc"
+    NAME_ASC = "name_asc"
+    NAME_DESC = "name_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class SecretVersionStatus(str, Enum):
-    UNKNOWN = "unknown"
-    ENABLED = "enabled"
-    DISABLED = "disabled"
-    DESTROYED = "destroyed"
+class PlanName(str, Enum):
+    UNKNOWN_NAME = "unknown_name"
+    FREE = "free"
+    PREMIUM = "premium"
+    CUSTOM = "custom"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
 @dataclass
-class AccessSecretVersionResponse:
+class Cockpit:
     """
-    Access secret version response.
+    Cockpit.
     """
 
-    secret_id: str
+    project_id: str
     """
-    ID of the Secret.
+    ID of the Project the Cockpit belongs to.
     """
 
-    revision: int
+    created_at: Optional[datetime]
     """
-    Revision of the SecretVersion.
+    Date and time of the Cockpit's creation.
     """
 
-    data: str
+    updated_at: Optional[datetime]
     """
-    The base64-encoded secret payload of the SecretVersion.
+    Date and time of the Cockpit's last update.
     """
 
+    endpoints: Optional[CockpitEndpoints]
+    """
+    Endpoints of the Cockpit.
+    """
 
-@dataclass
-class ListSecretVersionsResponse:
+    status: CockpitStatus
     """
-    List secret versions response.
+    Status of the Cockpit.
     """
 
-    total_count: int
+    managed_alerts_enabled: bool
     """
-    Count of all SecretVersions.
+    Specifies whether managed alerts are enabled or disabled.
     """
 
-    versions: List[SecretVersion]
+    plan: Optional[Plan]
     """
-    Single page of SecretVersions.
+    Pricing plan information.
     """
 
 
 @dataclass
-class ListSecretsResponse:
+class CockpitEndpoints:
     """
-    List secrets response.
+    Cockpit. endpoints.
     """
 
-    total_count: int
+    metrics_url: str
     """
-    Count of all Secrets matching the requested criteria.
+    URL for metrics.
     """
 
-    secrets: List[Secret]
+    logs_url: str
     """
-    Single page of Secrets matching the requested criteria.
+    URL for logs.
     """
 
-
-@dataclass
-class Secret:
+    alertmanager_url: str
     """
-    Secret.
+    URL for the alert manager.
     """
 
-    id: str
+    grafana_url: str
     """
-    ID of the Secret.
+    URL for the Grafana dashboard.
     """
 
-    project_id: str
+
+@dataclass
+class CockpitMetrics:
     """
-    ID of the project containing the Secret.
+    Metrics for a given Cockpit.
+    Cockpit metrics.
     """
 
-    name: str
+    timeseries: List[TimeSeries]
     """
-    Name of the Secret.
+    Time series array.
     """
 
-    status: SecretStatus
+
+@dataclass
+class ContactPoint:
     """
-    * `ready`: the Secret is ready.
-    * `locked`: the Secret is locked.
+    Contact point.
     """
 
-    created_at: Optional[datetime]
+    email: Optional[ContactPointEmail]
     """
-    The time at which the Secret was created.
+    Contact point configuration.
+    
+    One-of ('configuration'): at most one of 'email' could be set.
     """
 
-    updated_at: Optional[datetime]
+
+@dataclass
+class ContactPointEmail:
+    to: str
+
+
+@dataclass
+class GrafanaUser:
     """
-    The time at which the Secret was updated.
+    Grafana user.
     """
 
-    tags: List[str]
+    id: int
     """
-    List of tags associated to this Secret.
+    ID of the Grafana user.
     """
 
-    region: Region
+    login: str
     """
-    Region of the Secret.
+    Username of the Grafana user.
     """
 
-    version_count: int
+    role: GrafanaUserRole
     """
-    The number of versions for this Secret.
+    Role assigned to the Grafana user.
     """
 
-    description: Optional[str]
+    password: Optional[str]
     """
-    Description of the Secret.
+    The Grafana user's password.
     """
 
 
 @dataclass
-class SecretVersion:
+class ListContactPointsResponse:
     """
-    Secret version.
+    Response returned when listing contact points.
+    List contact points response.
     """
 
-    secret_id: str
+    total_count: int
     """
-    ID of the Secret.
+    Count of all contact points created.
     """
 
-    revision: int
+    contact_points: List[ContactPoint]
     """
-    Revision of the SecretVersion.
+    Array of contact points.
     """
 
-    status: SecretVersionStatus
+    has_additional_receivers: bool
     """
-    * `unknown`: the SecretVersion is in an invalid state.
-    * `enabled`: the SecretVersion is accessible.
-    * `disabled`: the SecretVersion is not accessible but can be enabled.
-    * `destroyed`: the SecretVersion is permanently destroyed.
+    Specifies whether the contact point has other receivers than the default receiver.
     """
 
-    created_at: Optional[datetime]
+    has_additional_contact_points: bool
     """
-    The time at which the SecretVersion was created.
+    Specifies whether there are unmanaged contact points.
     """
 
-    updated_at: Optional[datetime]
+
+@dataclass
+class ListGrafanaUsersResponse:
     """
-    The time at which the SecretVersion was updated.
+    Response returned when listing Grafana users.
+    List grafana users response.
     """
 
-    description: Optional[str]
+    total_count: int
     """
-    Description of the SecretVersion.
+    Count of all Grafana users.
+    """
+
+    grafana_users: List[GrafanaUser]
+    """
+    Information on all Grafana users.
     """
 
 
 @dataclass
-class CreateSecretRequest:
-    region: Optional[Region]
+class ListPlansResponse:
     """
-    Region to target. If none is passed will use default region from the config.
+    Response returned when listing all pricing plans.
+    List plans response.
     """
 
-    project_id: Optional[str]
+    total_count: int
     """
-    ID of the project containing the Secret.
+    Count of all pricing plans.
     """
 
-    name: str
+    plans: List[Plan]
+    """
+    Information on plans.
+    """
+
+
+@dataclass
+class ListTokensResponse:
     """
-    Name of the Secret.
+    List tokens response.
     """
 
-    tags: Optional[List[str]]
+    total_count: int
     """
-    List of tags associated to this Secret.
+    Count of all tokens created.
     """
 
-    description: Optional[str]
+    tokens: List[Token]
     """
-    Description of the Secret.
+    List of all tokens created.
     """
 
 
 @dataclass
-class GetSecretRequest:
-    region: Optional[Region]
+class Plan:
     """
-    Region to target. If none is passed will use default region from the config.
+    Pricing plan.
+    Plan.
     """
 
-    secret_id: str
+    id: str
     """
-    ID of the Secret.
+    ID of a given pricing plan.
     """
 
-
-@dataclass
-class GetSecretByNameRequest:
-    region: Optional[Region]
+    name: PlanName
     """
-    Region to target. If none is passed will use default region from the config.
+    Name of a given pricing plan.
     """
 
-    secret_name: str
+    retention_metrics_interval: Optional[str]
     """
-    Name of the Secret.
+    Retention for metrics.
     """
 
-
-@dataclass
-class UpdateSecretRequest:
-    region: Optional[Region]
+    retention_logs_interval: Optional[str]
     """
-    Region to target. If none is passed will use default region from the config.
+    Retention for logs.
     """
 
-    secret_id: str
+    sample_ingestion_price: int
     """
-    ID of the Secret.
+    Ingestion price for 1 million samples in cents.
     """
 
-    name: Optional[str]
+    logs_ingestion_price: int
     """
-    New name of the Secret (optional).
+    Ingestion price for 1 GB of logs in cents.
     """
 
-    tags: Optional[List[str]]
+    retention_price: int
     """
-    New list of tags associated to this Secret (optional).
+    Retention price in euros per month.
     """
 
-    description: Optional[str]
+
+@dataclass
+class SelectPlanResponse:
     """
-    Description of the Secret.
+    Response returned when selecting a pricing plan.
+    Select plan response.
     """
 
 
 @dataclass
-class ListSecretsRequest:
-    region: Optional[Region]
+class Token:
     """
-    Region to target. If none is passed will use default region from the config.
+    Token.
     """
 
-    organization_id: Optional[str]
+    id: str
     """
-    ID of an organization to filter on (optional).
+    ID of the token.
     """
 
-    project_id: Optional[str]
+    project_id: str
     """
-    ID of a project to filter on (optional).
+    ID of the Project.
     """
 
-    name: Optional[str]
+    name: str
     """
-    Secret name to filter on (optional).
+    Name of the token.
     """
 
-    tags: Optional[List[str]]
+    created_at: Optional[datetime]
     """
-    List of tags to filter on (optional).
+    Date and time of the token's creation.
     """
 
-    order_by: Optional[ListSecretsRequestOrderBy]
+    updated_at: Optional[datetime]
+    """
+    Date and time of the token's last update.
+    """
 
-    page: Optional[int]
+    scopes: Optional[TokenScopes]
+    """
+    Token's permissions.
+    """
 
-    page_size: Optional[int]
+    secret_key: Optional[str]
+    """
+    Token's secret key.
+    """
 
 
 @dataclass
-class DeleteSecretRequest:
-    region: Optional[Region]
+class TokenScopes:
     """
-    Region to target. If none is passed will use default region from the config.
+    Token scopes.
     """
 
-    secret_id: str
+    query_metrics: bool
     """
-    ID of the Secret.
+    Permission to fetch metrics.
     """
 
+    write_metrics: bool
+    """
+    Permission to write metrics.
+    """
 
-@dataclass
-class CreateSecretVersionRequest:
-    region: Optional[Region]
+    setup_metrics_rules: bool
     """
-    Region to target. If none is passed will use default region from the config.
+    Permission to setup metrics rules.
     """
 
-    secret_id: str
+    query_logs: bool
     """
-    ID of the Secret.
+    Permission to fetch logs.
     """
 
-    data: str
+    write_logs: bool
     """
-    The base64-encoded secret payload of the SecretVersion.
+    Permission to write logs.
     """
 
-    description: Optional[str]
+    setup_logs_rules: bool
     """
-    Description of the SecretVersion.
+    Permission to setup logs rules.
+    """
+
+    setup_alerts: bool
+    """
+    Permission to setup alerts.
     """
 
 
 @dataclass
-class GetSecretVersionRequest:
-    region: Optional[Region]
+class ActivateCockpitRequest:
+    project_id: Optional[str]
     """
-    Region to target. If none is passed will use default region from the config.
+    ID of the Project the Cockpit belongs to.
     """
 
-    secret_id: str
+
+@dataclass
+class GetCockpitRequest:
+    project_id: Optional[str]
     """
-    ID of the Secret.
+    ID of the Project the Cockpit belongs to.
     """
 
-    revision: str
+
+@dataclass
+class GetCockpitMetricsRequest:
+    project_id: Optional[str]
     """
-    Revision of the SecretVersion (may be a number or "latest").
+    ID of the Project the Cockpit belongs to.
     """
 
+    start_date: Optional[datetime]
+    """
+    Desired time range's start date for the metrics.
+    """
 
-@dataclass
-class GetSecretVersionByNameRequest:
-    region: Optional[Region]
+    end_date: Optional[datetime]
     """
-    Region to target. If none is passed will use default region from the config.
+    Desired time range's end date for the metrics.
     """
 
-    secret_name: str
+    metric_name: Optional[str]
     """
-    Name of the Secret.
+    Name of the metric requested.
     """
 
-    revision: str
+
+@dataclass
+class DeactivateCockpitRequest:
+    project_id: Optional[str]
     """
-    Revision of the SecretVersion (may be a number or "latest").
+    ID of the Project the Cockpit belongs to.
     """
 
 
 @dataclass
-class UpdateSecretVersionRequest:
-    region: Optional[Region]
+class ResetCockpitGrafanaRequest:
+    project_id: Optional[str]
     """
-    Region to target. If none is passed will use default region from the config.
+    ID of the Project the Cockpit belongs to.
     """
 
-    secret_id: str
+
+@dataclass
+class CreateTokenRequest:
+    project_id: Optional[str]
     """
-    ID of the Secret.
+    ID of the Project.
     """
 
-    revision: str
+    name: Optional[str]
     """
-    Revision of the SecretVersion (may be a number or "latest").
+    Name of the token.
     """
 
-    description: Optional[str]
+    scopes: Optional[TokenScopes]
     """
-    Description of the SecretVersion.
+    Token's permissions.
     """
 
 
 @dataclass
-class ListSecretVersionsRequest:
-    region: Optional[Region]
+class ListTokensRequest:
+    page: Optional[int]
     """
-    Region to target. If none is passed will use default region from the config.
+    Page number.
     """
 
-    secret_id: str
+    page_size: Optional[int]
     """
-    ID of the Secret.
+    Page size.
     """
 
-    page: Optional[int]
+    order_by: Optional[ListTokensRequestOrderBy]
+
+    project_id: Optional[str]
+    """
+    ID of the Project.
+    """
+
+
+@dataclass
+class GetTokenRequest:
+    token_id: str
+    """
+    ID of the token.
+    """
 
-    page_size: Optional[int]
 
-    status: Optional[List[SecretVersionStatus]]
+@dataclass
+class DeleteTokenRequest:
+    token_id: str
     """
-    Filter results by status.
+    ID of the token.
     """
 
 
 @dataclass
-class ListSecretVersionsByNameRequest:
-    region: Optional[Region]
+class CreateContactPointRequest:
+    project_id: Optional[str]
     """
-    Region to target. If none is passed will use default region from the config.
+    ID of the Project in which to create the contact point.
     """
 
-    secret_name: str
+    contact_point: Optional[ContactPoint]
     """
-    Name of the Secret.
+    Contact point to create.
     """
 
+
+@dataclass
+class ListContactPointsRequest:
     page: Optional[int]
+    """
+    Page number.
+    """
 
     page_size: Optional[int]
+    """
+    Page size.
+    """
 
-    status: Optional[List[SecretVersionStatus]]
+    project_id: Optional[str]
     """
-    Filter results by status.
+    ID of the Project from which to list the contact points.
     """
 
 
 @dataclass
-class DestroySecretVersionRequest:
-    region: Optional[Region]
+class DeleteContactPointRequest:
+    project_id: Optional[str]
     """
-    Region to target. If none is passed will use default region from the config.
+    ID of the Project.
     """
 
-    secret_id: str
+    contact_point: Optional[ContactPoint]
     """
-    ID of the Secret.
+    Contact point to delete.
     """
 
-    revision: str
+
+@dataclass
+class EnableManagedAlertsRequest:
+    project_id: Optional[str]
     """
-    Revision of the SecretVersion (may be a number or "latest").
+    ID of the Project.
     """
 
 
 @dataclass
-class EnableSecretVersionRequest:
-    region: Optional[Region]
+class DisableManagedAlertsRequest:
+    project_id: Optional[str]
+    """
+    ID of the Project.
+    """
+
+
+@dataclass
+class TriggerTestAlertRequest:
+    project_id: Optional[str]
+
+
+@dataclass
+class CreateGrafanaUserRequest:
+    project_id: Optional[str]
     """
-    Region to target. If none is passed will use default region from the config.
+    ID of the Project.
     """
 
-    secret_id: str
+    login: str
     """
-    ID of the Secret.
+    Username of the Grafana user.
     """
 
-    revision: str
+    role: GrafanaUserRole
     """
-    Revision of the SecretVersion (may be a number or "latest").
+    Role assigned to the Grafana user.
     """
 
 
 @dataclass
-class DisableSecretVersionRequest:
-    region: Optional[Region]
+class ListGrafanaUsersRequest:
+    page: Optional[int]
     """
-    Region to target. If none is passed will use default region from the config.
+    Page number.
     """
 
-    secret_id: str
+    page_size: Optional[int]
     """
-    ID of the Secret.
+    Page size.
     """
 
-    revision: str
+    order_by: Optional[ListGrafanaUsersRequestOrderBy]
+
+    project_id: Optional[str]
     """
-    Revision of the SecretVersion (may be a number or "latest").
+    ID of the Project.
     """
 
 
 @dataclass
-class AccessSecretVersionRequest:
-    region: Optional[Region]
+class DeleteGrafanaUserRequest:
+    grafana_user_id: int
     """
-    Region to target. If none is passed will use default region from the config.
+    ID of the Grafana user.
     """
 
-    secret_id: str
+    project_id: Optional[str]
     """
-    ID of the Secret.
+    ID of the Project.
     """
 
-    revision: str
+
+@dataclass
+class ResetGrafanaUserPasswordRequest:
+    grafana_user_id: int
     """
-    Revision of the SecretVersion (may be a number or "latest").
+    ID of the Grafana user.
+    """
+
+    project_id: Optional[str]
+    """
+    ID of the Project.
     """
 
 
 @dataclass
-class AccessSecretVersionByNameRequest:
-    region: Optional[Region]
+class ListPlansRequest:
+    page: Optional[int]
+    """
+    Page number.
+    """
+
+    page_size: Optional[int]
     """
-    Region to target. If none is passed will use default region from the config.
+    Page size.
     """
 
-    secret_name: str
+    order_by: Optional[ListPlansRequestOrderBy]
+
+
+@dataclass
+class SelectPlanRequest:
+    project_id: Optional[str]
     """
-    Name of the Secret.
+    ID of the Project.
     """
 
-    revision: str
+    plan_id: str
     """
-    Revision of the SecretVersion (may be a number or "latest").
+    ID of the pricing plan.
     """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/tem/v1alpha1/__init__.py` & `scaleway_async-1.0.0/scaleway_async/tem/v1alpha1/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,34 +1,46 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
+from .types import DomainLastStatusRecordStatus
 from .types import DomainStatus
+from .types import EmailFlag
 from .types import EmailRcptType
 from .types import EmailStatus
+from .types import ListEmailsRequestOrderBy
 from .types import CreateEmailRequestAddress
 from .types import CreateEmailRequestAttachment
 from .types import CreateEmailResponse
 from .types import Domain
+from .types import DomainLastStatus
+from .types import DomainLastStatusDkimRecord
+from .types import DomainLastStatusSpfRecord
 from .types import DomainStatistics
 from .types import Email
 from .types import EmailTry
 from .types import ListDomainsResponse
 from .types import ListEmailsResponse
 from .types import Statistics
 from .content import DOMAIN_TRANSIENT_STATUSES
 from .content import EMAIL_TRANSIENT_STATUSES
 from .api import TemV1Alpha1API
 
 __all__ = [
+    "DomainLastStatusRecordStatus",
     "DomainStatus",
+    "EmailFlag",
     "EmailRcptType",
     "EmailStatus",
+    "ListEmailsRequestOrderBy",
     "CreateEmailRequestAddress",
     "CreateEmailRequestAttachment",
     "CreateEmailResponse",
     "Domain",
+    "DomainLastStatus",
+    "DomainLastStatusDkimRecord",
+    "DomainLastStatusSpfRecord",
     "DomainStatistics",
     "Email",
     "EmailTry",
     "ListDomainsResponse",
     "ListEmailsResponse",
     "Statistics",
     "DOMAIN_TRANSIENT_STATUSES",
```

### Comparing `scaleway_async-0.9.0/scaleway_async/tem/v1alpha1/content.py` & `scaleway_async-1.0.0/scaleway_async/tem/v1alpha1/content.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-0.9.0/scaleway_async/tem/v1alpha1/marshalling.py` & `scaleway_async-1.0.0/scaleway_async/webhosting/v1alpha1/marshalling.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,308 +1,351 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 
 from typing import Any, Dict
 
 from scaleway_core.profile import ProfileDefaults
+from scaleway_core.bridge import (
+    unmarshal_Money,
+)
 from dateutil import parser
 from .types import (
-    CreateEmailRequestAddress,
-    CreateEmailRequestAttachment,
-    CreateEmailResponse,
-    Domain,
-    DomainStatistics,
-    Email,
-    EmailTry,
-    ListDomainsResponse,
-    ListEmailsResponse,
-    Statistics,
-    CreateEmailRequest,
-    CreateDomainRequest,
+    DnsRecord,
+    DnsRecords,
+    Hosting,
+    HostingCpanelUrls,
+    HostingOption,
+    ListHostingsResponse,
+    ListOffersResponse,
+    Nameserver,
+    Offer,
+    OfferProduct,
+    CreateHostingRequest,
+    UpdateHostingRequest,
 )
 
 
-def unmarshal_DomainStatistics(data: Any) -> DomainStatistics:
+def unmarshal_HostingCpanelUrls(data: Any) -> HostingCpanelUrls:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'DomainStatistics' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'HostingCpanelUrls' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("canceled_count")
-    args["canceled_count"] = field
-
-    field = data.get("failed_count")
-    args["failed_count"] = field
+    field = data.get("dashboard", None)
+    args["dashboard"] = field
 
-    field = data.get("sent_count")
-    args["sent_count"] = field
+    field = data.get("webmail", None)
+    args["webmail"] = field
 
-    field = data.get("total_count")
-    args["total_count"] = field
+    return HostingCpanelUrls(**args)
 
-    return DomainStatistics(**args)
 
-
-def unmarshal_EmailTry(data: Any) -> EmailTry:
+def unmarshal_HostingOption(data: Any) -> HostingOption:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'EmailTry' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'HostingOption' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("code")
-    args["code"] = field
-
-    field = data.get("message")
-    args["message"] = field
-
-    field = data.get("rank")
-    args["rank"] = field
+    field = data.get("id", None)
+    args["id"] = field
 
-    field = data.get("tried_at")
-    args["tried_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("name", None)
+    args["name"] = field
 
-    return EmailTry(**args)
+    return HostingOption(**args)
 
 
-def unmarshal_Domain(data: Any) -> Domain:
+def unmarshal_OfferProduct(data: Any) -> OfferProduct:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Domain' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'OfferProduct' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
-    args["created_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("databases_quota", None)
+    args["databases_quota"] = field
 
-    field = data.get("dkim_config")
-    args["dkim_config"] = field
+    field = data.get("email_accounts_quota", None)
+    args["email_accounts_quota"] = field
 
-    field = data.get("id")
-    args["id"] = field
+    field = data.get("email_storage_quota", None)
+    args["email_storage_quota"] = field
 
-    field = data.get("last_error")
-    args["last_error"] = field
+    field = data.get("hosting_storage_quota", None)
+    args["hosting_storage_quota"] = field
 
-    field = data.get("last_valid_at")
-    args["last_valid_at"] = parser.isoparse(field) if type(field) is str else field
-
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("next_check_at")
-    args["next_check_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("option", None)
+    args["option"] = field
 
-    field = data.get("organization_id")
-    args["organization_id"] = field
+    field = data.get("ram", None)
+    args["ram"] = field
 
-    field = data.get("project_id")
-    args["project_id"] = field
+    field = data.get("support_included", None)
+    args["support_included"] = field
 
-    field = data.get("region")
-    args["region"] = field
+    field = data.get("v_cpu", None)
+    args["v_cpu"] = field
 
-    field = data.get("revoked_at")
-    args["revoked_at"] = parser.isoparse(field) if type(field) is str else field
+    return OfferProduct(**args)
 
-    field = data.get("spf_config")
-    args["spf_config"] = field
 
-    field = data.get("statistics")
-    args["statistics"] = (
-        unmarshal_DomainStatistics(field) if field is not None else None
-    )
+def unmarshal_DnsRecord(data: Any) -> DnsRecord:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'DnsRecord' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("name", None)
+    args["name"] = field
 
-    field = data.get("status")
+    field = data.get("priority", None)
+    args["priority"] = field
+
+    field = data.get("status", None)
     args["status"] = field
 
-    return Domain(**args)
+    field = data.get("ttl", None)
+    args["ttl"] = field
+
+    field = data.get("type", None)
+    args["type_"] = field
 
+    field = data.get("value", None)
+    args["value"] = field
 
-def unmarshal_Email(data: Any) -> Email:
+    return DnsRecord(**args)
+
+
+def unmarshal_Hosting(data: Any) -> Hosting:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Email' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Hosting' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
+    field = data.get("cpanel_urls", None)
+    args["cpanel_urls"] = (
+        unmarshal_HostingCpanelUrls(field) if field is not None else None
+    )
+
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("id")
+    field = data.get("dns_status", None)
+    args["dns_status"] = field
+
+    field = data.get("domain", None)
+    args["domain"] = field
+
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("last_tries")
-    args["last_tries"] = [unmarshal_EmailTry(v) for v in data["last_tries"]]
+    field = data.get("offer_end_of_life", None)
+    args["offer_end_of_life"] = field
 
-    field = data.get("mail_from")
-    args["mail_from"] = field
+    field = data.get("offer_id", None)
+    args["offer_id"] = field
 
-    field = data.get("message_id")
-    args["message_id"] = field
+    field = data.get("offer_name", None)
+    args["offer_name"] = field
 
-    field = data.get("project_id")
-    args["project_id"] = field
+    field = data.get("options", None)
+    args["options"] = (
+        [unmarshal_HostingOption(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("rcpt_to")
-    args["rcpt_to"] = field
+    field = data.get("organization_id", None)
+    args["organization_id"] = field
 
-    field = data.get("rcpt_type")
-    args["rcpt_type"] = field
+    field = data.get("platform_hostname", None)
+    args["platform_hostname"] = field
 
-    field = data.get("status")
-    args["status"] = field
+    field = data.get("platform_number", None)
+    args["platform_number"] = field
 
-    field = data.get("status_details")
-    args["status_details"] = field
+    field = data.get("project_id", None)
+    args["project_id"] = field
+
+    field = data.get("region", None)
+    args["region"] = field
 
-    field = data.get("try_count")
-    args["try_count"] = field
+    field = data.get("status", None)
+    args["status"] = field
 
-    field = data.get("updated_at")
+    field = data.get("tags", None)
+    args["tags"] = field
+
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    return Email(**args)
+    field = data.get("username", None)
+    args["username"] = field
+
+    return Hosting(**args)
 
 
-def unmarshal_CreateEmailResponse(data: Any) -> CreateEmailResponse:
+def unmarshal_Nameserver(data: Any) -> Nameserver:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'CreateEmailResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Nameserver' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("emails")
-    args["emails"] = [unmarshal_Email(v) for v in data["emails"]]
+    field = data.get("hostname", None)
+    args["hostname"] = field
+
+    field = data.get("is_default", None)
+    args["is_default"] = field
+
+    field = data.get("status", None)
+    args["status"] = field
 
-    return CreateEmailResponse(**args)
+    return Nameserver(**args)
 
 
-def unmarshal_ListDomainsResponse(data: Any) -> ListDomainsResponse:
+def unmarshal_Offer(data: Any) -> Offer:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListDomainsResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Offer' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("domains")
-    args["domains"] = [unmarshal_Domain(v) for v in data["domains"]]
+    field = data.get("available", None)
+    args["available"] = field
 
-    field = data.get("total_count")
-    args["total_count"] = field
+    field = data.get("billing_operation_path", None)
+    args["billing_operation_path"] = field
+
+    field = data.get("end_of_life", None)
+    args["end_of_life"] = field
+
+    field = data.get("id", None)
+    args["id"] = field
+
+    field = data.get("price", None)
+    args["price"] = unmarshal_Money(field) if field is not None else None
 
-    return ListDomainsResponse(**args)
+    field = data.get("product", None)
+    args["product"] = unmarshal_OfferProduct(field) if field is not None else None
 
+    field = data.get("quota_warnings", None)
+    args["quota_warnings"] = field
 
-def unmarshal_ListEmailsResponse(data: Any) -> ListEmailsResponse:
+    return Offer(**args)
+
+
+def unmarshal_DnsRecords(data: Any) -> DnsRecords:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListEmailsResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'DnsRecords' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("emails")
-    args["emails"] = [unmarshal_Email(v) for v in data["emails"]]
+    field = data.get("name_servers", None)
+    args["name_servers"] = (
+        [unmarshal_Nameserver(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
-    args["total_count"] = field
+    field = data.get("records", None)
+    args["records"] = (
+        [unmarshal_DnsRecord(v) for v in field] if field is not None else None
+    )
 
-    return ListEmailsResponse(**args)
+    field = data.get("status", None)
+    args["status"] = field
+
+    return DnsRecords(**args)
 
 
-def unmarshal_Statistics(data: Any) -> Statistics:
+def unmarshal_ListHostingsResponse(data: Any) -> ListHostingsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Statistics' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListHostingsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("canceled_count")
-    args["canceled_count"] = field
+    field = data.get("hostings", None)
+    args["hostings"] = (
+        [unmarshal_Hosting(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("failed_count")
-    args["failed_count"] = field
+    field = data.get("total_count", None)
+    args["total_count"] = field
 
-    field = data.get("new_count")
-    args["new_count"] = field
+    return ListHostingsResponse(**args)
 
-    field = data.get("sending_count")
-    args["sending_count"] = field
 
-    field = data.get("sent_count")
-    args["sent_count"] = field
+def unmarshal_ListOffersResponse(data: Any) -> ListOffersResponse:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'ListOffersResponse' failed as data isn't a dictionary."
+        )
 
-    field = data.get("total_count")
-    args["total_count"] = field
+    args: Dict[str, Any] = {}
 
-    return Statistics(**args)
+    field = data.get("offers", None)
+    args["offers"] = [unmarshal_Offer(v) for v in field] if field is not None else None
 
+    return ListOffersResponse(**args)
 
-def marshal_CreateEmailRequestAddress(
-    request: CreateEmailRequestAddress,
+
+def marshal_CreateHostingRequest(
+    request: CreateHostingRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "email": request.email,
-        "name": request.name,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.domain is not None:
+        output["domain"] = request.domain
 
-def marshal_CreateEmailRequestAttachment(
-    request: CreateEmailRequestAttachment,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "content": request.content,
-        "name": request.name,
-        "type": request.type_,
-    }
+    if request.email is not None:
+        output["email"] = request.email
 
+    if request.offer_id is not None:
+        output["offer_id"] = request.offer_id
 
-def marshal_CreateDomainRequest(
-    request: CreateDomainRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "domain_name": request.domain_name,
-        "project_id": request.project_id or defaults.default_project_id,
-    }
+    if request.option_ids is not None:
+        output["option_ids"] = request.option_ids
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    if request.tags is not None:
+        output["tags"] = request.tags
 
+    return output
 
-def marshal_CreateEmailRequest(
-    request: CreateEmailRequest,
+
+def marshal_UpdateHostingRequest(
+    request: UpdateHostingRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "attachments": [
-            marshal_CreateEmailRequestAttachment(v, defaults)
-            for v in request.attachments
-        ]
-        if request.attachments is not None
-        else None,
-        "bcc": [marshal_CreateEmailRequestAddress(v, defaults) for v in request.bcc]
-        if request.bcc is not None
-        else None,
-        "cc": [marshal_CreateEmailRequestAddress(v, defaults) for v in request.cc]
-        if request.cc is not None
-        else None,
-        "from": marshal_CreateEmailRequestAddress(request.from_, defaults)
-        if request.from_ is not None
-        else None,
-        "html": request.html,
-        "project_id": request.project_id or defaults.default_project_id,
-        "send_before": request.send_before,
-        "subject": request.subject,
-        "text": request.text,
-        "to": [marshal_CreateEmailRequestAddress(v, defaults) for v in request.to]
-        if request.to is not None
-        else None,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.email is not None:
+        output["email"] = request.email
+
+    if request.offer_id is not None:
+        output["offer_id"] = request.offer_id
+
+    if request.option_ids is not None:
+        output["option_ids"] = request.option_ids
+
+    if request.tags is not None:
+        output["tags"] = request.tags
+
+    return output
```

### Comparing `scaleway_async-0.9.0/scaleway_async/tem/v1alpha1/types.py` & `scaleway_async-1.0.0/scaleway_async/webhosting/v1alpha1/types.py`

 * *Files 22% similar despite different names*

```diff
@@ -4,588 +4,600 @@
 
 from dataclasses import dataclass
 from datetime import datetime
 from enum import Enum
 from typing import List, Optional
 
 from scaleway_core.bridge import (
+    Money,
     Region,
 )
 
 
-class DomainStatus(str, Enum):
+class DnsRecordStatus(str, Enum):
+    UNKNOWN_STATUS = "unknown_status"
+    VALID = "valid"
+    INVALID = "invalid"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
+class DnsRecordType(str, Enum):
+    UNKNOWN_TYPE = "unknown_type"
+    A = "a"
+    CNAME = "cname"
+    MX = "mx"
+    TXT = "txt"
+    NS = "ns"
+    AAAA = "aaaa"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
+class DnsRecordsStatus(str, Enum):
     UNKNOWN = "unknown"
-    CHECKED = "checked"
-    UNCHECKED = "unchecked"
+    VALID = "valid"
     INVALID = "invalid"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
+class HostingDnsStatus(str, Enum):
+    UNKNOWN_DNS_STATUS = "unknown_dns_status"
+    VALID = "valid"
+    INVALID = "invalid"
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
+class HostingStatus(str, Enum):
+    UNKNOWN_STATUS = "unknown_status"
+    DELIVERING = "delivering"
+    READY = "ready"
+    DELETING = "deleting"
+    ERROR = "error"
     LOCKED = "locked"
-    REVOKED = "revoked"
-    PENDING = "pending"
+    MIGRATING = "migrating"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class EmailRcptType(str, Enum):
-    UNKNOWN_RCPT_TYPE = "unknown_rcpt_type"
-    TO = "to"
-    CC = "cc"
-    BCC = "bcc"
+class ListHostingsRequestOrderBy(str, Enum):
+    CREATED_AT_ASC = "created_at_asc"
+    CREATED_AT_DESC = "created_at_desc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-class EmailStatus(str, Enum):
-    UNKNOWN = "unknown"
-    NEW = "new"
-    SENDING = "sending"
-    SENT = "sent"
-    FAILED = "failed"
-    CANCELED = "canceled"
+class ListOffersRequestOrderBy(str, Enum):
+    PRICE_ASC = "price_asc"
 
     def __str__(self) -> str:
         return str(self.value)
 
 
-@dataclass
-class CreateEmailRequestAddress:
-    """
-    Create email request. address
-    """
+class NameserverStatus(str, Enum):
+    UNKNOWN_STATUS = "unknown_status"
+    VALID = "valid"
+    INVALID = "invalid"
 
-    email: str
-    """
-    Email address
-    """
+    def __str__(self) -> str:
+        return str(self.value)
 
-    name: Optional[str]
-    """
-    Optional display name
-    """
+
+class OfferQuotaWarning(str, Enum):
+    UNKNOWN_QUOTA_WARNING = "unknown_quota_warning"
+    EMAIL_COUNT_EXCEEDED = "email_count_exceeded"
+    DATABASE_COUNT_EXCEEDED = "database_count_exceeded"
+    DISK_USAGE_EXCEEDED = "disk_usage_exceeded"
+
+    def __str__(self) -> str:
+        return str(self.value)
 
 
 @dataclass
-class CreateEmailRequestAttachment:
+class DnsRecord:
     """
-    Create email request. attachment
+    Dns record.
     """
 
     name: str
     """
-    Filename of the attachment
+    Record name.
     """
 
-    type_: str
+    type_: DnsRecordType
     """
-    MIME type of the attachment (Currently only allow, text files, pdf and html files)
+    Record type.
     """
 
-    content: str
+    ttl: int
     """
-    Content of the attachment, encoded in base64
+    Record time-to-live.
     """
 
+    value: str
+    """
+    Record value.
+    """
 
-@dataclass
-class CreateEmailResponse:
+    priority: Optional[int]
     """
-    Create email response
+    Record priority level.
     """
 
-    emails: List[Email]
+    status: DnsRecordStatus
     """
-    Single page of emails matching the requested criteria
+    Record status.
     """
 
 
 @dataclass
-class Domain:
+class DnsRecords:
     """
-    Domain
+    Dns records.
     """
 
-    id: str
+    records: List[DnsRecord]
     """
-    ID of the domain
+    List of DNS records.
     """
 
-    organization_id: str
+    name_servers: List[Nameserver]
     """
-    ID of the organization to which the domain belongs
+    List of nameservers.
     """
 
-    project_id: str
+    status: DnsRecordsStatus
     """
-    ID of the project
+    Status of the records.
     """
 
-    name: str
-    """
-    Domain name (example.com)
-    """
 
-    status: DomainStatus
+@dataclass
+class Hosting:
     """
-    Status of the domain
+    Hosting.
     """
 
-    created_at: Optional[datetime]
+    id: str
     """
-    Date and time of domain's creation
+    ID of the Web Hosting plan.
     """
 
-    next_check_at: Optional[datetime]
+    organization_id: str
     """
-    Date and time of the next scheduled check
+    ID of the Scaleway Organization the Web Hosting plan belongs to.
     """
 
-    last_valid_at: Optional[datetime]
+    project_id: str
     """
-    Date and time the domain was last found to be valid
+    ID of the Scaleway Project the Web Hosting plan belongs to.
     """
 
-    revoked_at: Optional[datetime]
+    updated_at: Optional[datetime]
     """
-    Date and time of the revocation of the domain
+    Date on which the Web Hosting plan was last updated.
     """
 
-    last_error: Optional[str]
+    created_at: Optional[datetime]
     """
-    Error message if the last check failed
+    Date on which the Web Hosting plan was created.
     """
 
-    spf_config: str
+    status: HostingStatus
     """
-    Snippet of the SPF record that should be registered in the DNS zone
+    Status of the Web Hosting plan.
     """
 
-    dkim_config: str
+    platform_hostname: str
     """
-    DKIM public key, as should be recorded in the DNS zone
+    Hostname of the host platform.
     """
 
-    statistics: Optional[DomainStatistics]
+    platform_number: Optional[int]
     """
-    Domain's statistics
+    Number of the host platform.
     """
 
-    region: Region
-
-
-@dataclass
-class DomainStatistics:
-    total_count: int
-
-    sent_count: int
-
-    failed_count: int
-
-    canceled_count: int
-
-
-@dataclass
-class Email:
+    offer_id: str
     """
-    Email
+    ID of the active offer for the Web Hosting plan.
     """
 
-    id: str
+    offer_name: str
     """
-    Technical ID of the email
+    Name of the active offer for the Web Hosting plan.
     """
 
-    message_id: str
+    domain: str
     """
-    MessageID of the email
+    Main domain associated with the Web Hosting plan.
     """
 
-    project_id: str
+    tags: List[str]
     """
-    ID of the project to which the email belongs
+    List of tags associated with the Web Hosting plan.
     """
 
-    mail_from: str
+    options: List[HostingOption]
     """
-    Email address of the sender
+    Array of any options activated for the Web Hosting plan.
     """
 
-    rcpt_to: str
+    dns_status: HostingDnsStatus
     """
-    Email address of the recipient
+    DNS status of the Web Hosting plan.
     """
 
-    rcpt_type: EmailRcptType
+    cpanel_urls: Optional[HostingCpanelUrls]
     """
-    Type of the recipient
+    URL to connect to cPanel dashboard and to Webmail interface.
     """
 
-    created_at: Optional[datetime]
+    username: str
     """
-    Creation date of the email object
+    Main Web Hosting cPanel username.
     """
 
-    updated_at: Optional[datetime]
+    offer_end_of_life: bool
     """
-    Last update time of the email object
+    Indicates if the hosting offer has reached its end of life.
     """
 
-    status: EmailStatus
+    region: Region
     """
-    Status of the email
+    Region where the Web Hosting plan is hosted.
     """
 
-    status_details: Optional[str]
+
+@dataclass
+class HostingCpanelUrls:
+    dashboard: str
+
+    webmail: str
+
+
+@dataclass
+class HostingOption:
     """
-    Additional information on the status
+    Hosting. option.
     """
 
-    try_count: int
+    id: str
     """
-    Total number of attempts to send the email
+    Option ID.
     """
 
-    last_tries: List[EmailTry]
+    name: str
     """
-    Informations about the latest three attempts to send the email
+    Option name.
     """
 
 
 @dataclass
-class EmailTry:
+class ListHostingsResponse:
     """
-    Email. try
+    List hostings response.
     """
 
-    rank: int
+    total_count: int
     """
-    Rank number of this attempt to send the email
+    Number of Web Hosting plans returned.
     """
 
-    tried_at: Optional[datetime]
+    hostings: List[Hosting]
     """
-    Date of the attempt
+    List of Web Hosting plans.
     """
 
-    code: int
+
+@dataclass
+class ListOffersResponse:
     """
-    The SMTP status code received after the attempt. 0 if the attempt did not reach an SMTP server.
+    List offers response.
     """
 
-    message: str
+    offers: List[Offer]
     """
-    The SMTP message received, if any. If the attempt did not reach an SMTP server, the message says why.
+    List of offers.
     """
 
 
 @dataclass
-class ListDomainsResponse:
+class Nameserver:
     """
-    List domains response
+    Nameserver.
     """
 
-    total_count: int
+    hostname: str
     """
-    Total number of domains matching the request (without pagination)
+    Hostname of the nameserver.
     """
 
-    domains: List[Domain]
-
-
-@dataclass
-class ListEmailsResponse:
+    status: NameserverStatus
     """
-    List emails response
+    Status of the nameserver.
     """
 
-    total_count: int
+    is_default: bool
     """
-    Count of all emails matching the requested criteria
+    Defines whether the nameserver is the default one.
     """
 
-    emails: List[Email]
+
+@dataclass
+class Offer:
     """
-    Single page of emails matching the requested criteria
+    Offer.
     """
 
-
-@dataclass
-class Statistics:
+    id: str
     """
-    Statistics
+    Offer ID.
     """
 
-    total_count: int
+    billing_operation_path: str
     """
-    Total number of emails matching the request criteria
+    Unique identifier used for billing.
     """
 
-    new_count: int
+    product: Optional[OfferProduct]
     """
-    Number of emails still in the `new` transient state (received from the API, not yet processed)
+    Product constituting this offer.
     """
 
-    sending_count: int
+    price: Optional[Money]
     """
-    Number of emails still in the `sending` transient state (received from the API, not yet in their final status)
+    Price of this offer.
     """
 
-    sent_count: int
+    available: bool
     """
-    Number of emails in the final `sent` state (have been delivered to the target mail system)
+    If a hosting_id was specified in the call, defines whether this offer is available for that Web Hosting plan to migrate (update) to.
     """
 
-    failed_count: int
+    quota_warnings: List[OfferQuotaWarning]
     """
-    Number of emails in the final `failed` state (refused by the target mail system with a final error status)
+    Quota warnings, if the offer is not available for the specified hosting_id.
     """
 
-    canceled_count: int
+    end_of_life: bool
     """
-    Number of emails in the final `canceled` state (canceled by customer's request)
+    Indicates if the offer has reached its end of life.
     """
 
 
 @dataclass
-class CreateEmailRequest:
-    region: Optional[Region]
+class OfferProduct:
     """
-    Region to target. If none is passed will use default region from the config
+    Offer. product.
     """
 
-    from_: Optional[CreateEmailRequestAddress]
+    name: str
     """
-    Sender information (must be from a checked domain declared in the project)
+    Product name.
     """
 
-    to: Optional[List[CreateEmailRequestAddress]]
+    option: bool
     """
-    Array of recipient information (limited to 1 recipient)
+    Product option.
     """
 
-    cc: Optional[List[CreateEmailRequestAddress]]
-    """
-    Array of recipient information (unimplemented)
-    """
+    email_accounts_quota: int
 
-    bcc: Optional[List[CreateEmailRequestAddress]]
-    """
-    Array of recipient information (unimplemented)
-    """
+    email_storage_quota: int
 
-    subject: str
-    """
-    Message subject
-    """
+    databases_quota: int
+
+    hosting_storage_quota: int
+
+    support_included: bool
+
+    v_cpu: int
+
+    ram: int
 
-    text: str
+
+@dataclass
+class CreateHostingRequest:
+    region: Optional[Region]
     """
-    Text content
+    Region to target. If none is passed will use default region from the config.
     """
 
-    html: str
+    offer_id: str
     """
-    HTML content
+    ID of the selected offer for the Web Hosting plan.
     """
 
     project_id: Optional[str]
     """
-    ID of the project in which to create the email
+    ID of the Scaleway Project in which to create the Web Hosting plan.
     """
 
-    attachments: Optional[List[CreateEmailRequestAttachment]]
+    email: Optional[str]
     """
-    Array of attachments
+    Contact email for the Web Hosting client.
     """
 
-    send_before: Optional[datetime]
+    tags: Optional[List[str]]
     """
-    Maximum date to deliver mail
+    List of tags for the Web Hosting plan.
     """
 
-
-@dataclass
-class GetEmailRequest:
-    region: Optional[Region]
+    domain: str
     """
-    Region to target. If none is passed will use default region from the config
+    Domain name to link to the Web Hosting plan. You must already own this domain name, and have completed the DNS validation process beforehand.
     """
 
-    email_id: str
+    option_ids: Optional[List[str]]
     """
-    ID of the email to retrieve
+    IDs of any selected additional options for the Web Hosting plan.
     """
 
 
 @dataclass
-class ListEmailsRequest:
+class ListHostingsRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
     page: Optional[int]
-
-    page_size: Optional[int]
-
-    project_id: Optional[str]
     """
-    Optional ID of the project in which to list the emails
+    Page number to return, from the paginated results (must be a positive integer).
     """
 
-    domain_id: Optional[str]
+    page_size: Optional[int]
     """
-    Optional ID of the domain for which to list the emails
+    Number of Web Hosting plans to return (must be a positive integer lower or equal to 100).
     """
 
-    message_id: Optional[str]
+    order_by: Optional[ListHostingsRequestOrderBy]
     """
-    Optional ID of the message for which to list the emails
+    Sort order for Web Hosting plans in the response.
     """
 
-    since: Optional[datetime]
+    tags: Optional[List[str]]
     """
-    Optional, list emails created after this date
+    Tags to filter for, only Web Hosting plans with matching tags will be returned.
     """
 
-    until: Optional[datetime]
+    statuses: Optional[List[HostingStatus]]
     """
-    Optional, list emails created before this date
+    Statuses to filter for, only Web Hosting plans with matching statuses will be returned.
     """
 
-    mail_from: Optional[str]
+    domain: Optional[str]
     """
-    Optional, list emails sent with this `mail_from` sender's address
+    Domain to filter for, only Web Hosting plans associated with this domain will be returned.
     """
 
-    mail_to: Optional[str]
+    project_id: Optional[str]
     """
-    Optional, list emails sent with this `mail_to` recipient's address
+    Project ID to filter for, only Web Hosting plans from this Project will be returned.
     """
 
-    statuses: Optional[List[EmailStatus]]
+    organization_id: Optional[str]
     """
-    Optional, list emails having any of this status
+    Organization ID to filter for, only Web Hosting plans from this Organization will be returned.
     """
 
 
 @dataclass
-class GetStatisticsRequest:
+class GetHostingRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    project_id: Optional[str]
+    hosting_id: str
     """
-    Optional, count emails for this project
+    Hosting ID.
     """
 
-    domain_id: Optional[str]
+
+@dataclass
+class UpdateHostingRequest:
+    region: Optional[Region]
     """
-    Optional, count emails send from this domain (must be coherent with the `project_id` and the `organization_id`)
+    Region to target. If none is passed will use default region from the config.
     """
 
-    since: Optional[datetime]
+    hosting_id: str
     """
-    Optional, count emails created after this date
+    Hosting ID.
     """
 
-    until: Optional[datetime]
+    email: Optional[str]
     """
-    Optional, count emails created before this date
+    New contact email for the Web Hosting plan.
     """
 
-    mail_from: Optional[str]
+    tags: Optional[List[str]]
     """
-    Optional, count emails sent with this `mail_from` sender's address
+    New tags for the Web Hosting plan.
     """
 
-
-@dataclass
-class CancelEmailRequest:
-    region: Optional[Region]
+    option_ids: Optional[List[str]]
     """
-    Region to target. If none is passed will use default region from the config
+    IDs of the new options for the Web Hosting plan.
     """
 
-    email_id: str
+    offer_id: Optional[str]
     """
-    ID of the email to cancel
+    ID of the new offer for the Web Hosting plan.
     """
 
 
 @dataclass
-class CreateDomainRequest:
+class DeleteHostingRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    project_id: Optional[str]
-
-    domain_name: str
+    hosting_id: str
+    """
+    Hosting ID.
+    """
 
 
 @dataclass
-class GetDomainRequest:
+class RestoreHostingRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    domain_id: str
+    hosting_id: str
     """
-    ID of the domain
+    Hosting ID.
     """
 
 
 @dataclass
-class ListDomainsRequest:
+class GetDomainDnsRecordsRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    page: Optional[int]
+    domain: str
     """
-    Page number (1 for the first page)
+    Domain associated with the DNS records.
     """
 
-    page_size: Optional[int]
-    """
-    Page size
-    """
-
-    project_id: Optional[str]
-
-    status: Optional[List[DomainStatus]]
-
-    organization_id: Optional[str]
-
-    name: Optional[str]
-
 
 @dataclass
-class RevokeDomainRequest:
+class ListOffersRequest:
     region: Optional[Region]
     """
-    Region to target. If none is passed will use default region from the config
+    Region to target. If none is passed will use default region from the config.
     """
 
-    domain_id: str
+    order_by: ListOffersRequestOrderBy
     """
-    ID of the domain to revoke
+    Sort order of offers in the response.
     """
 
+    without_options: bool
+    """
+    Defines whether the response should consist of offers only, without options.
+    """
 
-@dataclass
-class CheckDomainRequest:
-    region: Optional[Region]
+    only_options: bool
     """
-    Region to target. If none is passed will use default region from the config
+    Defines whether the response should consist of options only, without offers.
     """
 
-    domain_id: str
+    hosting_id: Optional[str]
     """
-    ID of the domain to check
+    ID of a Web Hosting plan, to check compatibility with returned offers (in case of wanting to update the plan).
     """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/test/v1/__init__.py` & `scaleway_async-1.0.0/scaleway_async/test/v1/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-0.9.0/scaleway_async/test/v1/types.py` & `scaleway_async-1.0.0/scaleway_async/test/v1/types.py`

 * *Files 1% similar despite different names*

```diff
@@ -109,15 +109,15 @@
     project_id: Optional[str]
 
 
 @dataclass
 class GetHumanRequest:
     human_id: str
     """
-    UUID of the human you want to get
+    UUID of the human you want to get.
     """
 
 
 @dataclass
 class CreateHumanRequest:
     height: float
 
@@ -149,15 +149,15 @@
     """
 
 
 @dataclass
 class UpdateHumanRequest:
     human_id: str
     """
-    UUID of the human you want to update
+    UUID of the human you want to update.
     """
 
     height: Optional[float]
 
     shoe_size: Optional[float]
 
     altitude_in_meter: Optional[int]
@@ -175,26 +175,26 @@
     name: Optional[str]
 
 
 @dataclass
 class DeleteHumanRequest:
     human_id: str
     """
-    UUID of the human you want to delete
+    UUID of the human you want to delete.
     """
 
 
 @dataclass
 class RunHumanRequest:
     human_id: str
     """
-    UUID of the human you want to make run
+    UUID of the human you want to make run.
     """
 
 
 @dataclass
 class SmokeHumanRequest:
     human_id: Optional[str]
     """
-    UUID of the human you want to make smoking
+    UUID of the human you want to make smoking.
     :deprecated
     """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/vpc/v1/api.py` & `scaleway_async-1.0.0/scaleway_async/vpc/v1/api.py`

 * *Files 12% similar despite different names*

```diff
@@ -26,54 +26,60 @@
     unmarshal_ListPrivateNetworksResponse,
 )
 
 
 class VpcV1API(API):
     """
     VPC API.
+
+    VPC API.
     """
 
     async def list_private_networks(
         self,
         *,
         zone: Optional[Zone] = None,
         order_by: ListPrivateNetworksRequestOrderBy = ListPrivateNetworksRequestOrderBy.CREATED_AT_ASC,
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         name: Optional[str] = None,
         tags: Optional[List[str]] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         private_network_ids: Optional[List[str]] = None,
+        include_regional: Optional[bool] = None,
     ) -> ListPrivateNetworksResponse:
         """
-        List private networks
+        List Private Networks.
+        List existing Private Networks in a specified Availability Zone. By default, the Private Networks returned in the list are ordered by creation date in ascending order, though this can be modified via the order_by field.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param order_by: The sort order of the returned private networks.
-        :param page: The page number for the returned private networks.
-        :param page_size: The maximum number of private networks per page.
-        :param name: Filter private networks with names containing this string.
-        :param tags: Filter private networks with one or more matching tags.
-        :param organization_id: The organization ID on which to filter the returned private networks.
-        :param project_id: The project ID on which to filter the returned private networks.
-        :param private_network_ids: The PrivateNetwork IDs on which to filter the returned private networks.
+        :param order_by: Sort order of the returned Private Networks.
+        :param page: Page number to return, from the paginated results.
+        :param page_size: Maximum number of Private Networks to return per page.
+        :param name: Name to filter for. Only Private Networks with names containing this string will be returned.
+        :param tags: Tags to filter for. Only Private Networks with one or more matching tags will be returned.
+        :param organization_id: Organization ID to filter for. Only Private Networks belonging to this Organization will be returned.
+        :param project_id: Project ID to filter for. Only Private Networks belonging to this Project will be returned.
+        :param private_network_ids: Private Network IDs to filter for. Only Private Networks with one of these IDs will be returned.
+        :param include_regional: Defines whether to include regional Private Networks in the response.
         :return: :class:`ListPrivateNetworksResponse <ListPrivateNetworksResponse>`
 
         Usage:
         ::
 
             result = await api.list_private_networks()
         """
 
         param_zone = validate_path_param("zone", zone or self.client.default_zone)
 
         res = self._request(
             "GET",
             f"/vpc/v1/zones/{param_zone}/private-networks",
             params={
+                "include_regional": include_regional,
                 "name": name,
                 "order_by": order_by,
                 "organization_id": organization_id
                 or self.client.default_organization_id,
                 "page": page,
                 "page_size": page_size or self.client.default_page_size,
                 "private_network_ids": private_network_ids,
@@ -93,26 +99,29 @@
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         name: Optional[str] = None,
         tags: Optional[List[str]] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         private_network_ids: Optional[List[str]] = None,
+        include_regional: Optional[bool] = None,
     ) -> List[PrivateNetwork]:
         """
-        List private networks
+        List Private Networks.
+        List existing Private Networks in a specified Availability Zone. By default, the Private Networks returned in the list are ordered by creation date in ascending order, though this can be modified via the order_by field.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param order_by: The sort order of the returned private networks.
-        :param page: The page number for the returned private networks.
-        :param page_size: The maximum number of private networks per page.
-        :param name: Filter private networks with names containing this string.
-        :param tags: Filter private networks with one or more matching tags.
-        :param organization_id: The organization ID on which to filter the returned private networks.
-        :param project_id: The project ID on which to filter the returned private networks.
-        :param private_network_ids: The PrivateNetwork IDs on which to filter the returned private networks.
+        :param order_by: Sort order of the returned Private Networks.
+        :param page: Page number to return, from the paginated results.
+        :param page_size: Maximum number of Private Networks to return per page.
+        :param name: Name to filter for. Only Private Networks with names containing this string will be returned.
+        :param tags: Tags to filter for. Only Private Networks with one or more matching tags will be returned.
+        :param organization_id: Organization ID to filter for. Only Private Networks belonging to this Organization will be returned.
+        :param project_id: Project ID to filter for. Only Private Networks belonging to this Project will be returned.
+        :param private_network_ids: Private Network IDs to filter for. Only Private Networks with one of these IDs will be returned.
+        :param include_regional: Defines whether to include regional Private Networks in the response.
         :return: :class:`List[ListPrivateNetworksResponse] <List[ListPrivateNetworksResponse]>`
 
         Usage:
         ::
 
             result = await api.list_private_networks_all()
         """
@@ -127,33 +136,35 @@
                 "page": page,
                 "page_size": page_size,
                 "name": name,
                 "tags": tags,
                 "organization_id": organization_id,
                 "project_id": project_id,
                 "private_network_ids": private_network_ids,
+                "include_regional": include_regional,
             },
         )
 
     async def create_private_network(
         self,
         *,
         zone: Optional[Zone] = None,
         name: Optional[str] = None,
         project_id: Optional[str] = None,
         tags: Optional[List[str]] = None,
         subnets: Optional[List[str]] = None,
     ) -> PrivateNetwork:
         """
-        Create a private network
+        Create a Private Network.
+        Create a new Private Network. Once created, you can attach Scaleway resources in the same Availability Zone.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param name: The name of the private network.
-        :param project_id: The project ID of the private network.
-        :param tags: The private networks tags.
-        :param subnets: Private network subnets CIDR.
+        :param name: Name for the Private Network.
+        :param project_id: Scaleway Project in which to create the Private Network.
+        :param tags: Tags for the Private Network.
+        :param subnets: Private Network subnets CIDR.
         :return: :class:`PrivateNetwork <PrivateNetwork>`
 
         Usage:
         ::
 
             result = await api.create_private_network()
         """
@@ -181,17 +192,18 @@
     async def get_private_network(
         self,
         *,
         private_network_id: str,
         zone: Optional[Zone] = None,
     ) -> PrivateNetwork:
         """
-        Get a private network
+        Get a Private Network.
+        Retrieve information about an existing Private Network, specified by its Private Network ID. Its full details are returned in the response object.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param private_network_id: The private network id.
+        :param private_network_id: Private Network ID.
         :return: :class:`PrivateNetwork <PrivateNetwork>`
 
         Usage:
         ::
 
             result = await api.get_private_network(private_network_id="example")
         """
@@ -215,20 +227,21 @@
         private_network_id: str,
         zone: Optional[Zone] = None,
         name: Optional[str] = None,
         tags: Optional[List[str]] = None,
         subnets: Optional[List[str]] = None,
     ) -> PrivateNetwork:
         """
-        Update private network
+        Update Private Network.
+        Update parameters (such as name or tags) of an existing Private Network, specified by its Private Network ID.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param private_network_id: The private network ID.
-        :param name: The name of the private network.
-        :param tags: The private networks tags.
-        :param subnets: Private network subnets CIDR (deprecated).
+        :param private_network_id: Private Network ID.
+        :param name: Name of the private network.
+        :param tags: Tags for the Private Network.
+        :param subnets: Private Network subnets CIDR (deprecated).
         :return: :class:`PrivateNetwork <PrivateNetwork>`
 
         Usage:
         ::
 
             result = await api.update_private_network(private_network_id="example")
         """
@@ -259,17 +272,18 @@
     async def delete_private_network(
         self,
         *,
         private_network_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete a private network
+        Delete a Private Network.
+        Delete an existing Private Network. Note that you must first detach all resources from the network, in order to delete it.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param private_network_id: The private network ID.
+        :param private_network_id: Private Network ID.
 
         Usage:
         ::
 
             result = await api.delete_private_network(private_network_id="example")
         """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/vpc/v1/types.py` & `scaleway_async-1.0.0/scaleway_async/vpc/v1/types.py`

 * *Files 15% similar despite different names*

```diff
@@ -33,180 +33,185 @@
 class PrivateNetwork:
     """
     Private network.
     """
 
     id: str
     """
-    The private network ID.
+    Private Network ID.
     """
 
     name: str
     """
-    The private network name.
+    Private Network name.
     """
 
     organization_id: str
     """
-    The private network organization.
+    Scaleway Organization the Private Network belongs to.
     """
 
     project_id: str
     """
-    The private network project ID.
+    Scaleway Project the Private Network belongs to.
     """
 
     zone: Zone
     """
-    The zone in which the private network is available.
+    Availability Zone in which the Private Network is available.
     """
 
     tags: List[str]
     """
-    The private network tags.
+    Tags of the Private Network.
     """
 
     created_at: Optional[datetime]
     """
-    The private network creation date.
+    Date the Private Network was created.
     """
 
     updated_at: Optional[datetime]
     """
-    The last private network modification date.
+    Date the Private Network was last modified.
     """
 
     subnets: List[str]
     """
-    Private network subnets CIDR.
+    Private Network subnets CIDR.
     """
 
 
 @dataclass
 class ListPrivateNetworksRequest:
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     order_by: Optional[ListPrivateNetworksRequestOrderBy]
     """
-    The sort order of the returned private networks.
+    Sort order of the returned Private Networks.
     """
 
     page: Optional[int]
     """
-    The page number for the returned private networks.
+    Page number to return, from the paginated results.
     """
 
     page_size: Optional[int]
     """
-    The maximum number of private networks per page.
+    Maximum number of Private Networks to return per page.
     """
 
     name: Optional[str]
     """
-    Filter private networks with names containing this string.
+    Name to filter for. Only Private Networks with names containing this string will be returned.
     """
 
     tags: Optional[List[str]]
     """
-    Filter private networks with one or more matching tags.
+    Tags to filter for. Only Private Networks with one or more matching tags will be returned.
     """
 
     organization_id: Optional[str]
     """
-    The organization ID on which to filter the returned private networks.
+    Organization ID to filter for. Only Private Networks belonging to this Organization will be returned.
     """
 
     project_id: Optional[str]
     """
-    The project ID on which to filter the returned private networks.
+    Project ID to filter for. Only Private Networks belonging to this Project will be returned.
     """
 
     private_network_ids: Optional[List[str]]
     """
-    The PrivateNetwork IDs on which to filter the returned private networks.
+    Private Network IDs to filter for. Only Private Networks with one of these IDs will be returned.
+    """
+
+    include_regional: Optional[bool]
+    """
+    Defines whether to include regional Private Networks in the response.
     """
 
 
 @dataclass
 class CreatePrivateNetworkRequest:
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     name: Optional[str]
     """
-    The name of the private network.
+    Name for the Private Network.
     """
 
     project_id: Optional[str]
     """
-    The project ID of the private network.
+    Scaleway Project in which to create the Private Network.
     """
 
     tags: Optional[List[str]]
     """
-    The private networks tags.
+    Tags for the Private Network.
     """
 
     subnets: Optional[List[str]]
     """
-    Private network subnets CIDR.
+    Private Network subnets CIDR.
     """
 
 
 @dataclass
 class GetPrivateNetworkRequest:
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     private_network_id: str
     """
-    The private network id.
+    Private Network ID.
     """
 
 
 @dataclass
 class UpdatePrivateNetworkRequest:
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     private_network_id: str
     """
-    The private network ID.
+    Private Network ID.
     """
 
     name: Optional[str]
     """
-    The name of the private network.
+    Name of the private network.
     """
 
     tags: Optional[List[str]]
     """
-    The private networks tags.
+    Tags for the Private Network.
     """
 
     subnets: Optional[List[str]]
     """
-    Private network subnets CIDR (deprecated).
+    Private Network subnets CIDR (deprecated).
     :deprecated
     """
 
 
 @dataclass
 class DeletePrivateNetworkRequest:
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     private_network_id: str
     """
-    The private network ID.
+    Private Network ID.
     """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/vpcgw/v1/__init__.py` & `scaleway_async-1.0.0/scaleway_async/vpcgw/v1/__init__.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-0.9.0/scaleway_async/vpcgw/v1/api.py` & `scaleway_async-1.0.0/scaleway_async/vpcgw/v1/api.py`

 * *Files 16% similar despite different names*

```diff
@@ -92,15 +92,17 @@
     unmarshal_SetDHCPEntriesResponse,
     unmarshal_SetPATRulesResponse,
 )
 
 
 class VpcgwV1API(API):
     """
-    VPC Public Gateway API.
+    Public Gateways API.
+
+    Public Gateways API.
     """
 
     async def list_gateways(
         self,
         *,
         zone: Optional[Zone] = None,
         order_by: ListGatewaysRequestOrderBy = ListGatewaysRequestOrderBy.CREATED_AT_ASC,
@@ -111,26 +113,27 @@
         name: Optional[str] = None,
         tags: Optional[List[str]] = None,
         type_: Optional[str] = None,
         status: GatewayStatus = GatewayStatus.UNKNOWN,
         private_network_id: Optional[str] = None,
     ) -> ListGatewaysResponse:
         """
-        List VPC Public Gateways
+        List Public Gateways.
+        List Public Gateways in a given Scaleway Organization or Project. By default, results are displayed in ascending order of creation date.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param order_by: Order in which to return results.
-        :param page: Page number.
+        :param page: Page number to return.
         :param page_size: Gateways per page.
-        :param organization_id: Include only gateways in this organization.
-        :param project_id: Include only gateways in this project.
-        :param name: Filter gateways including this name.
-        :param tags: Filter gateways with these tags.
-        :param type_: Filter gateways of this type.
-        :param status: Filter gateways in this status (unknown for any).
-        :param private_network_id: Filter gateways attached to this private network.
+        :param organization_id: Include only gateways in this Organization.
+        :param project_id: Include only gateways in this Project.
+        :param name: Filter for gateways which have this search term in their name.
+        :param tags: Filter for gateways with these tags.
+        :param type_: Filter for gateways of this type.
+        :param status: Filter for gateways with this current status. Use `unknown` to include all statuses.
+        :param private_network_id: Filter for gateways attached to this Private nNetwork.
         :return: :class:`ListGatewaysResponse <ListGatewaysResponse>`
 
         Usage:
         ::
 
             result = await api.list_gateways()
         """
@@ -170,26 +173,27 @@
         name: Optional[str] = None,
         tags: Optional[List[str]] = None,
         type_: Optional[str] = None,
         status: Optional[GatewayStatus] = None,
         private_network_id: Optional[str] = None,
     ) -> List[Gateway]:
         """
-        List VPC Public Gateways
+        List Public Gateways.
+        List Public Gateways in a given Scaleway Organization or Project. By default, results are displayed in ascending order of creation date.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param order_by: Order in which to return results.
-        :param page: Page number.
+        :param page: Page number to return.
         :param page_size: Gateways per page.
-        :param organization_id: Include only gateways in this organization.
-        :param project_id: Include only gateways in this project.
-        :param name: Filter gateways including this name.
-        :param tags: Filter gateways with these tags.
-        :param type_: Filter gateways of this type.
-        :param status: Filter gateways in this status (unknown for any).
-        :param private_network_id: Filter gateways attached to this private network.
+        :param organization_id: Include only gateways in this Organization.
+        :param project_id: Include only gateways in this Project.
+        :param name: Filter for gateways which have this search term in their name.
+        :param tags: Filter for gateways with these tags.
+        :param type_: Filter for gateways of this type.
+        :param status: Filter for gateways with this current status. Use `unknown` to include all statuses.
+        :param private_network_id: Filter for gateways attached to this Private nNetwork.
         :return: :class:`List[ListGatewaysResponse] <List[ListGatewaysResponse]>`
 
         Usage:
         ::
 
             result = await api.list_gateways_all()
         """
@@ -216,15 +220,16 @@
     async def get_gateway(
         self,
         *,
         gateway_id: str,
         zone: Optional[Zone] = None,
     ) -> Gateway:
         """
-        Get a VPC Public Gateway
+        Get a Public Gateway.
+        Get details of a Public Gateway, specified by its gateway ID. The response object contains full details of the gateway, including its **name**, **type**, **status** and more.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param gateway_id: ID of the gateway to fetch.
         :return: :class:`Gateway <Gateway>`
 
         Usage:
         ::
 
@@ -288,24 +293,25 @@
         name: Optional[str] = None,
         tags: Optional[List[str]] = None,
         upstream_dns_servers: Optional[List[str]] = None,
         ip_id: Optional[str] = None,
         bastion_port: Optional[int] = None,
     ) -> Gateway:
         """
-        Create a VPC Public Gateway
+        Create a Public Gateway.
+        Create a new Public Gateway in the specified Scaleway Project, defining its **name**, **type** and other configuration details such as whether to enable SSH bastion.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param project_id: Project to create the gateway into.
-        :param name: Name of the gateway.
+        :param project_id: Scaleway Project to create the gateway in.
+        :param name: Name for the gateway.
         :param tags: Tags for the gateway.
-        :param type_: Gateway type.
-        :param upstream_dns_servers: Override the gateway's default recursive DNS servers, if DNS features are enabled.
-        :param ip_id: Attach an existing IP to the gateway.
-        :param enable_smtp: Allow SMTP traffic to pass through the gateway.
-        :param enable_bastion: Enable SSH bastion on the gateway.
+        :param type_: Gateway type (commercial offer type).
+        :param upstream_dns_servers: Array of DNS server IP addresses to override the gateway's default recursive DNS servers.
+        :param ip_id: Existing IP address to attach to the gateway.
+        :param enable_smtp: Defines whether SMTP traffic should be allowed pass through the gateway.
+        :param enable_bastion: Defines whether SSH bastion should be enabled the gateway.
         :param bastion_port: Port of the SSH bastion.
         :return: :class:`Gateway <Gateway>`
 
         Usage:
         ::
 
             result = await api.create_gateway(
@@ -349,23 +355,24 @@
         tags: Optional[List[str]] = None,
         upstream_dns_servers: Optional[List[str]] = None,
         enable_bastion: Optional[bool] = None,
         bastion_port: Optional[int] = None,
         enable_smtp: Optional[bool] = None,
     ) -> Gateway:
         """
-        Update a VPC Public Gateway
+        Update a Public Gateway.
+        Update the parameters of an existing Public Gateway, for example, its **name**, **tags**, **SSH bastion configuration**, and **DNS servers**.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param gateway_id: ID of the gateway to update.
-        :param name: Name fo the gateway.
+        :param name: Name for the gateway.
         :param tags: Tags for the gateway.
-        :param upstream_dns_servers: Override the gateway's default recursive DNS servers, if DNS features are enabled.
-        :param enable_bastion: Enable SSH bastion on the gateway.
+        :param upstream_dns_servers: Array of DNS server IP addresses to override the gateway's default recursive DNS servers.
+        :param enable_bastion: Defines whether SSH bastion should be enabled the gateway.
         :param bastion_port: Port of the SSH bastion.
-        :param enable_smtp: Allow SMTP traffic to pass through the gateway.
+        :param enable_smtp: Defines whether SMTP traffic should be allowed to pass through the gateway.
         :return: :class:`Gateway <Gateway>`
 
         Usage:
         ::
 
             result = await api.update_gateway(gateway_id="example")
         """
@@ -398,18 +405,19 @@
         self,
         *,
         gateway_id: str,
         cleanup_dhcp: bool,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete a VPC Public Gateway
+        Delete a Public Gateway.
+        Delete an existing Public Gateway, specified by its gateway ID. This action is irreversible.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param gateway_id: ID of the gateway to delete.
-        :param cleanup_dhcp: Whether to cleanup attached DHCP configurations (if any, and if not attached to another Gateway Network).
+        :param cleanup_dhcp: Defines whether to clean up attached DHCP configurations (if any, and if not attached to another Gateway Network).
 
         Usage:
         ::
 
             result = await api.delete_gateway(
                 gateway_id="example",
                 cleanup_dhcp=True,
@@ -433,15 +441,16 @@
     async def upgrade_gateway(
         self,
         *,
         gateway_id: str,
         zone: Optional[Zone] = None,
     ) -> Gateway:
         """
-        Upgrade a VPC Public Gateway to the latest version
+        Upgrade a Public Gateway to the latest version.
+        Upgrade a given Public Gateway to the newest software version. This applies the latest bugfixes and features to your Public Gateway, but its service will be interrupted during the update.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param gateway_id: ID of the gateway to upgrade.
         :return: :class:`Gateway <Gateway>`
 
         Usage:
         ::
 
@@ -469,24 +478,25 @@
         gateway_id: Optional[str] = None,
         private_network_id: Optional[str] = None,
         enable_masquerade: Optional[bool] = None,
         dhcp_id: Optional[str] = None,
         status: GatewayNetworkStatus = GatewayNetworkStatus.UNKNOWN,
     ) -> ListGatewayNetworksResponse:
         """
-        List gateway connections to Private Networks
+        List Public Gateway connections to Private Networks.
+        List the connections between Public Gateways and Private Networks (a connection = a GatewayNetwork). You can choose to filter by `gateway-id` to list all Private Networks attached to the specified Public Gateway, or by `private_network_id` to list all Public Gateways attached to the specified Private Network. Other query parameters are also available. The result is an array of GatewayNetwork objects, each giving details of the connection between a given Public Gateway and a given Private Network.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param order_by: Order in which to return results.
         :param page: Page number.
         :param page_size: GatewayNetworks per page.
-        :param gateway_id: Filter by gateway.
-        :param private_network_id: Filter by private network.
-        :param enable_masquerade: Filter by masquerade enablement.
-        :param dhcp_id: Filter by DHCP configuration.
-        :param status: Filter GatewayNetworks by this status (unknown for any).
+        :param gateway_id: Filter for GatewayNetworks connected to this gateway.
+        :param private_network_id: Filter for GatewayNetworks connected to this Private Network.
+        :param enable_masquerade: Filter for GatewayNetworks with this `enable_masquerade` setting.
+        :param dhcp_id: Filter for GatewayNetworks using this DHCP configuration.
+        :param status: Filter for GatewayNetworks with this current status this status. Use `unknown` to include all statuses.
         :return: :class:`ListGatewayNetworksResponse <ListGatewayNetworksResponse>`
 
         Usage:
         ::
 
             result = await api.list_gateway_networks()
         """
@@ -521,24 +531,25 @@
         gateway_id: Optional[str] = None,
         private_network_id: Optional[str] = None,
         enable_masquerade: Optional[bool] = None,
         dhcp_id: Optional[str] = None,
         status: Optional[GatewayNetworkStatus] = None,
     ) -> List[GatewayNetwork]:
         """
-        List gateway connections to Private Networks
+        List Public Gateway connections to Private Networks.
+        List the connections between Public Gateways and Private Networks (a connection = a GatewayNetwork). You can choose to filter by `gateway-id` to list all Private Networks attached to the specified Public Gateway, or by `private_network_id` to list all Public Gateways attached to the specified Private Network. Other query parameters are also available. The result is an array of GatewayNetwork objects, each giving details of the connection between a given Public Gateway and a given Private Network.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param order_by: Order in which to return results.
         :param page: Page number.
         :param page_size: GatewayNetworks per page.
-        :param gateway_id: Filter by gateway.
-        :param private_network_id: Filter by private network.
-        :param enable_masquerade: Filter by masquerade enablement.
-        :param dhcp_id: Filter by DHCP configuration.
-        :param status: Filter GatewayNetworks by this status (unknown for any).
+        :param gateway_id: Filter for GatewayNetworks connected to this gateway.
+        :param private_network_id: Filter for GatewayNetworks connected to this Private Network.
+        :param enable_masquerade: Filter for GatewayNetworks with this `enable_masquerade` setting.
+        :param dhcp_id: Filter for GatewayNetworks using this DHCP configuration.
+        :param status: Filter for GatewayNetworks with this current status this status. Use `unknown` to include all statuses.
         :return: :class:`List[ListGatewayNetworksResponse] <List[ListGatewayNetworksResponse]>`
 
         Usage:
         ::
 
             result = await api.list_gateway_networks_all()
         """
@@ -563,15 +574,16 @@
     async def get_gateway_network(
         self,
         *,
         gateway_network_id: str,
         zone: Optional[Zone] = None,
     ) -> GatewayNetwork:
         """
-        Get a gateway connection to a Private Network
+        Get a Public Gateway connection to a Private Network.
+        Get details of a given connection between a Public Gateway and a Private Network (this connection = a GatewayNetwork), specified by its `gateway_network_id`. The response object contains details of the connection including the IDs of the Public Gateway and Private Network, the dates the connection was created/updated and its configuration settings.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param gateway_network_id: ID of the GatewayNetwork to fetch.
         :return: :class:`GatewayNetwork <GatewayNetwork>`
 
         Usage:
         ::
 
@@ -639,29 +651,30 @@
         zone: Optional[Zone] = None,
         dhcp_id: Optional[str] = None,
         dhcp: Optional[CreateDHCPRequest] = None,
         address: Optional[str] = None,
         enable_dhcp: Optional[bool] = None,
     ) -> GatewayNetwork:
         """
-        Attach a gateway to a Private Network
+        Attach a Public Gateway to a Private Network.
+        Attach a specific Public Gateway to a specific Private Network (create a GatewayNetwork). You can configure parameters for the connection including DHCP settings, whether to enable masquerade (dynamic NAT), and more.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param gateway_id: Gateway to connect.
+        :param gateway_id: Public Gateway to connect.
         :param private_network_id: Private Network to connect.
-        :param enable_masquerade: Whether to enable masquerade on this network.
-        :param dhcp_id: Existing configuration.
+        :param enable_masquerade: Defines whether to enable masquerade (dynamic NAT) on this network.
+        :param dhcp_id: ID of an existing DHCP configuration object to use for this GatewayNetwork.
 
         One-of ('ip_config'): at most one of 'dhcp_id', 'dhcp', 'address' could be set.
-        :param dhcp: New DHCP configuration.
+        :param dhcp: New DHCP configuration object to use for this GatewayNetwork.
 
         One-of ('ip_config'): at most one of 'dhcp_id', 'dhcp', 'address' could be set.
         :param address: Static IP address in CIDR format to to use without DHCP.
 
         One-of ('ip_config'): at most one of 'dhcp_id', 'dhcp', 'address' could be set.
-        :param enable_dhcp: Whether to enable DHCP on this Private Network. Defaults to `true` if either `dhcp_id` or `dhcp` short: are present. If set to `true`, requires that either `dhcp_id` or `dhcp` to be present.
+        :param enable_dhcp: Defines whether to enable DHCP on this Private Network. Defaults to `true` if either `dhcp_id` or `dhcp` are present. If set to `true`, either `dhcp_id` or `dhcp` must be present.
         :return: :class:`GatewayNetwork <GatewayNetwork>`
 
         Usage:
         ::
 
             result = await api.create_gateway_network(
                 gateway_id="example",
@@ -700,22 +713,23 @@
         zone: Optional[Zone] = None,
         enable_masquerade: Optional[bool] = None,
         dhcp_id: Optional[str] = None,
         enable_dhcp: Optional[bool] = None,
         address: Optional[str] = None,
     ) -> GatewayNetwork:
         """
-        Update a gateway connection to a Private Network
+        Update a Public Gateway's connection to a Private Network.
+        Update the configuration parameters of a connection between a given Public Gateway and Private Network (the connection = a GatewayNetwork). Updatable parameters include DHCP settings and whether to enable traffic masquerade (dynamic NAT).
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param gateway_network_id: ID of the GatewayNetwork to update.
-        :param enable_masquerade: New masquerade enablement.
-        :param dhcp_id: New DHCP configuration.
+        :param enable_masquerade: Defines whether to enable masquerade (dynamic NAT) on the GatewayNetwork.
+        :param dhcp_id: ID of the new DHCP configuration object to use with this GatewayNetwork.
 
         One-of ('ip_config'): at most one of 'dhcp_id', 'address' could be set.
-        :param enable_dhcp: Whether to enable DHCP on the connected Private Network.
+        :param enable_dhcp: Defines whether to enable DHCP on the connected Private Network.
         :param address: New static IP address.
 
         One-of ('ip_config'): at most one of 'dhcp_id', 'address' could be set.
         :return: :class:`GatewayNetwork <GatewayNetwork>`
 
         Usage:
         ::
@@ -751,18 +765,19 @@
         self,
         *,
         gateway_network_id: str,
         cleanup_dhcp: bool,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Detach a gateway from a Private Network
+        Detach a Public Gateway from a Private Network.
+        Detach a given Public Gateway from a given Private Network, i.e. delete a GatewayNetwork specified by a gateway_network_id.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param gateway_network_id: GatewayNetwork to delete.
-        :param cleanup_dhcp: Whether to cleanup the attached DHCP configuration (if any, and if not attached to another gateway_network).
+        :param gateway_network_id: ID of the GatewayNetwork to delete.
+        :param cleanup_dhcp: Defines whether to clean up attached DHCP configurations (if any, and if not attached to another Gateway Network).
 
         Usage:
         ::
 
             result = await api.delete_gateway_network(
                 gateway_network_id="example",
                 cleanup_dhcp=True,
@@ -794,23 +809,24 @@
         page_size: Optional[int] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         address: Optional[str] = None,
         has_address: Optional[str] = None,
     ) -> ListDHCPsResponse:
         """
-        List DHCP configurations
+        List DHCP configurations.
+        List DHCP configurations, optionally filtering by Organization, Project, Public Gateway IP address or more. The response is an array of DHCP configuration objects, each identified by a DHCP ID and containing configuration settings for the assignment of IP addresses to devices on a Private Network attached to a Public Gateway. Note that the response does not contain the IDs of any Private Network / Public Gateway the configuration is attached to. Use the `List Public Gateway connections to Private Networks` method for that purpose, filtering on DHCP ID.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param order_by: Order in which to return results.
         :param page: Page number.
         :param page_size: DHCP configurations per page.
-        :param organization_id: Include only DHCPs in this organization.
-        :param project_id: Include only DHCPs in this project.
-        :param address: Filter on gateway address.
-        :param has_address: Filter on subnets containing address.
+        :param organization_id: Include only DHCP configuration objects in this Organization.
+        :param project_id: Include only DHCP configuration objects in this Project.
+        :param address: Filter for DHCP configuration objects with this DHCP server IP address (the gateway's address in the Private Network).
+        :param has_address: Filter for DHCP configuration objects with subnets containing this IP address.
         :return: :class:`ListDHCPsResponse <ListDHCPsResponse>`
 
         Usage:
         ::
 
             result = await api.list_dhc_ps()
         """
@@ -844,23 +860,24 @@
         page_size: Optional[int] = None,
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         address: Optional[str] = None,
         has_address: Optional[str] = None,
     ) -> List[DHCP]:
         """
-        List DHCP configurations
+        List DHCP configurations.
+        List DHCP configurations, optionally filtering by Organization, Project, Public Gateway IP address or more. The response is an array of DHCP configuration objects, each identified by a DHCP ID and containing configuration settings for the assignment of IP addresses to devices on a Private Network attached to a Public Gateway. Note that the response does not contain the IDs of any Private Network / Public Gateway the configuration is attached to. Use the `List Public Gateway connections to Private Networks` method for that purpose, filtering on DHCP ID.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param order_by: Order in which to return results.
         :param page: Page number.
         :param page_size: DHCP configurations per page.
-        :param organization_id: Include only DHCPs in this organization.
-        :param project_id: Include only DHCPs in this project.
-        :param address: Filter on gateway address.
-        :param has_address: Filter on subnets containing address.
+        :param organization_id: Include only DHCP configuration objects in this Organization.
+        :param project_id: Include only DHCP configuration objects in this Project.
+        :param address: Filter for DHCP configuration objects with this DHCP server IP address (the gateway's address in the Private Network).
+        :param has_address: Filter for DHCP configuration objects with subnets containing this IP address.
         :return: :class:`List[ListDHCPsResponse] <List[ListDHCPsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_dhc_ps_all()
         """
@@ -884,17 +901,18 @@
     async def get_dhcp(
         self,
         *,
         dhcp_id: str,
         zone: Optional[Zone] = None,
     ) -> DHCP:
         """
-        Get a DHCP configuration
+        Get a DHCP configuration.
+        Get a DHCP configuration object, identified by its DHCP ID. The response object contains configuration settings for the assignment of IP addresses to devices on a Private Network attached to a Public Gateway. Note that the response does not contain the IDs of any Private Network / Public Gateway the configuration is attached to. Use the `List Public Gateway connections to Private Networks` method for that purpose, filtering on DHCP ID.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param dhcp_id: ID of the DHCP config to fetch.
+        :param dhcp_id: ID of the DHCP configuration to fetch.
         :return: :class:`DHCP <DHCP>`
 
         Usage:
         ::
 
             result = await api.get_dhcp(dhcp_id="example")
         """
@@ -926,29 +944,30 @@
         push_default_route: Optional[bool] = None,
         push_dns_server: Optional[bool] = None,
         dns_servers_override: Optional[List[str]] = None,
         dns_search: Optional[List[str]] = None,
         dns_local_name: Optional[str] = None,
     ) -> DHCP:
         """
-        Create a DHCP configuration
+        Create a DHCP configuration.
+        Create a new DHCP configuration object, containing settings for the assignment of IP addresses to devices on a Private Network attached to a Public Gateway. The response object includes the ID of the DHCP configuration object. You can use this ID as part of a call to `Create a Public Gateway connection to a Private Network` or `Update a Public Gateway connection to a Private Network` to directly apply this DHCP configuration.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param project_id: Project to create the DHCP configuration in.
         :param subnet: Subnet for the DHCP server.
-        :param address: Address of the DHCP server. This will be the gateway's address in the private network. Defaults to the first address of the subnet.
-        :param pool_low: Low IP (included) of the dynamic address pool. Defaults to the second address of the subnet.
-        :param pool_high: High IP (included) of the dynamic address pool. Defaults to the last address of the subnet.
-        :param enable_dynamic: Whether to enable dynamic pooling of IPs. By turning the dynamic pool off, only pre-existing DHCP reservations will be handed out. Defaults to true.
-        :param valid_lifetime: For how long, in seconds, will DHCP entries will be valid. Defaults to 1h (3600s).
-        :param renew_timer: After how long, in seconds, a renew will be attempted. Must be 30s lower than `rebind_timer`. Defaults to 50m (3000s).
-        :param rebind_timer: After how long, in seconds, a DHCP client will query for a new lease if previous renews fail. Must be 30s lower than `valid_lifetime`. Defaults to 51m (3060s).
-        :param push_default_route: Whether the gateway should push a default route to DHCP clients or only hand out IPs. Defaults to true.
-        :param push_dns_server: Whether the gateway should push custom DNS servers to clients. This allows for instance hostname -> IP resolution. Defaults to true.
-        :param dns_servers_override: Override the DNS server list pushed to DHCP clients, instead of the gateway itself.
-        :param dns_search: Additional DNS search paths.
+        :param address: IP address of the DHCP server. This will be the gateway's address in the Private Network. Defaults to the first address of the subnet.
+        :param pool_low: Low IP (inclusive) of the dynamic address pool. Must be in the config's subnet. Defaults to the second address of the subnet.
+        :param pool_high: High IP (inclusive) of the dynamic address pool. Must be in the config's subnet. Defaults to the last address of the subnet.
+        :param enable_dynamic: Defines whether to enable dynamic pooling of IPs. When false, only pre-existing DHCP reservations will be handed out. Defaults to true.
+        :param valid_lifetime: How long DHCP entries will be valid for. Defaults to 1h (3600s).
+        :param renew_timer: After how long a renew will be attempted. Must be 30s lower than `rebind_timer`. Defaults to 50m (3000s).
+        :param rebind_timer: After how long a DHCP client will query for a new lease if previous renews fail. Must be 30s lower than `valid_lifetime`. Defaults to 51m (3060s).
+        :param push_default_route: Defines whether the gateway should push a default route to DHCP clients or only hand out IPs. Defaults to true.
+        :param push_dns_server: Defines whether the gateway should push custom DNS servers to clients. This allows for Instance hostname -> IP resolution. Defaults to true.
+        :param dns_servers_override: Array of DNS server IP addresses used to override the DNS server list pushed to DHCP clients, instead of the gateway itself.
+        :param dns_search: Array of search paths in addition to the pushed DNS configuration.
         :param dns_local_name: TLD given to hostnames in the Private Network. Allowed characters are `a-z0-9-.`. Defaults to the slugified Private Network name if created along a GatewayNetwork, or else to `priv`.
         :return: :class:`DHCP <DHCP>`
 
         Usage:
         ::
 
             result = await api.create_dhcp(subnet="example")
@@ -1000,30 +1019,31 @@
         push_default_route: Optional[bool] = None,
         push_dns_server: Optional[bool] = None,
         dns_servers_override: Optional[List[str]] = None,
         dns_search: Optional[List[str]] = None,
         dns_local_name: Optional[str] = None,
     ) -> DHCP:
         """
-        Update a DHCP configuration
+        Update a DHCP configuration.
+        Update a DHCP configuration object, identified by its DHCP ID.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param dhcp_id: DHCP config to update.
+        :param dhcp_id: DHCP configuration to update.
         :param subnet: Subnet for the DHCP server.
-        :param address: Address of the DHCP server. This will be the gateway's address in the private network.
-        :param pool_low: Low IP (included) of the dynamic address pool.
-        :param pool_high: High IP (included) of the dynamic address pool.
-        :param enable_dynamic: Whether to enable dynamic pooling of IPs. By turning the dynamic pool off, only pre-existing DHCP reservations will be handed out. Defaults to true.
-        :param valid_lifetime: How long, in seconds, DHCP entries will be valid for.
-        :param renew_timer: After how long, in seconds, a renew will be attempted. Must be 30s lower than `rebind_timer`.
-        :param rebind_timer: After how long, in seconds, a DHCP client will query for a new lease if previous renews fail. Must be 30s lower than `valid_lifetime`.
-        :param push_default_route: Whether the gateway should push a default route to DHCP clients or only hand out IPs.
-        :param push_dns_server: Whether the gateway should push custom DNS servers to clients. This allows for instance hostname -> IP resolution.
-        :param dns_servers_override: Override the DNS server list pushed to DHCP clients, instead of the gateway itself.
-        :param dns_search: Additional DNS search paths.
-        :param dns_local_name: TLD given to hostnames in the Private Network. Allowed characters are `a-z0-9-.`.
+        :param address: IP address of the DHCP server. This will be the Public Gateway's address in the Private Network. It must be part of config's subnet.
+        :param pool_low: Low IP (inclusive) of the dynamic address pool. Must be in the config's subnet.
+        :param pool_high: High IP (inclusive) of the dynamic address pool. Must be in the config's subnet.
+        :param enable_dynamic: Defines whether to enable dynamic pooling of IPs. When false, only pre-existing DHCP reservations will be handed out. Defaults to true.
+        :param valid_lifetime: How long DHCP entries will be valid for.
+        :param renew_timer: After how long a renew will be attempted. Must be 30s lower than `rebind_timer`.
+        :param rebind_timer: After how long a DHCP client will query for a new lease if previous renews fail. Must be 30s lower than `valid_lifetime`.
+        :param push_default_route: Defines whether the gateway should push a default route to DHCP clients, or only hand out IPs.
+        :param push_dns_server: Defines whether the gateway should push custom DNS servers to clients. This allows for instance hostname -> IP resolution.
+        :param dns_servers_override: Array of DNS server IP addresses used to override the DNS server list pushed to DHCP clients, instead of the gateway itself.
+        :param dns_search: Array of search paths in addition to the pushed DNS configuration.
+        :param dns_local_name: TLD given to hostnames in the Private Networks. If an instance with hostname `foo` gets a lease, and this is set to `bar`, `foo.bar` will resolve. Allowed characters are `a-z0-9-.`.
         :return: :class:`DHCP <DHCP>`
 
         Usage:
         ::
 
             result = await api.update_dhcp(dhcp_id="example")
         """
@@ -1062,17 +1082,18 @@
     async def delete_dhcp(
         self,
         *,
         dhcp_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete a DHCP configuration
+        Delete a DHCP configuration.
+        Delete a DHCP configuration object, identified by its DHCP ID. Note that you cannot delete a DHCP configuration object that is currently being used by a Gateway Network.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param dhcp_id: DHCP config id to delete.
+        :param dhcp_id: DHCP configuration ID to delete.
 
         Usage:
         ::
 
             result = await api.delete_dhcp(dhcp_id="example")
         """
 
@@ -1097,24 +1118,25 @@
         gateway_network_id: Optional[str] = None,
         mac_address: Optional[str] = None,
         ip_address: Optional[str] = None,
         hostname: Optional[str] = None,
         type_: DHCPEntryType = DHCPEntryType.UNKNOWN,
     ) -> ListDHCPEntriesResponse:
         """
-        List DHCP entries
+        List DHCP entries.
+        List DHCP entries, whether dynamically assigned and/or statically reserved. DHCP entries can be filtered by the Gateway Network they are on, their MAC address, IP address, type or hostname.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param order_by: Order in which to return results.
         :param page: Page number.
         :param page_size: DHCP entries per page.
-        :param gateway_network_id: Filter entries based on the gateway network they are on.
-        :param mac_address: Filter entries on their MAC address.
-        :param ip_address: Filter entries on their IP address.
-        :param hostname: Filter entries on their hostname substring.
-        :param type_: Filter entries on their type.
+        :param gateway_network_id: Filter for entries on this GatewayNetwork.
+        :param mac_address: Filter for entries with this MAC address.
+        :param ip_address: Filter for entries with this IP address.
+        :param hostname: Filter for entries with this hostname substring.
+        :param type_: Filter for entries of this type.
         :return: :class:`ListDHCPEntriesResponse <ListDHCPEntriesResponse>`
 
         Usage:
         ::
 
             result = await api.list_dhcp_entries()
         """
@@ -1149,24 +1171,25 @@
         gateway_network_id: Optional[str] = None,
         mac_address: Optional[str] = None,
         ip_address: Optional[str] = None,
         hostname: Optional[str] = None,
         type_: Optional[DHCPEntryType] = None,
     ) -> List[DHCPEntry]:
         """
-        List DHCP entries
+        List DHCP entries.
+        List DHCP entries, whether dynamically assigned and/or statically reserved. DHCP entries can be filtered by the Gateway Network they are on, their MAC address, IP address, type or hostname.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param order_by: Order in which to return results.
         :param page: Page number.
         :param page_size: DHCP entries per page.
-        :param gateway_network_id: Filter entries based on the gateway network they are on.
-        :param mac_address: Filter entries on their MAC address.
-        :param ip_address: Filter entries on their IP address.
-        :param hostname: Filter entries on their hostname substring.
-        :param type_: Filter entries on their type.
+        :param gateway_network_id: Filter for entries on this GatewayNetwork.
+        :param mac_address: Filter for entries with this MAC address.
+        :param ip_address: Filter for entries with this IP address.
+        :param hostname: Filter for entries with this hostname substring.
+        :param type_: Filter for entries of this type.
         :return: :class:`List[ListDHCPEntriesResponse] <List[ListDHCPEntriesResponse]>`
 
         Usage:
         ::
 
             result = await api.list_dhcp_entries_all()
         """
@@ -1191,15 +1214,16 @@
     async def get_dhcp_entry(
         self,
         *,
         dhcp_entry_id: str,
         zone: Optional[Zone] = None,
     ) -> DHCPEntry:
         """
-        Get DHCP entries
+        Get a DHCP entry.
+        Get a DHCP entry, specified by its DHCP entry ID.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param dhcp_entry_id: ID of the DHCP entry to fetch.
         :return: :class:`DHCPEntry <DHCPEntry>`
 
         Usage:
         ::
 
@@ -1222,19 +1246,20 @@
         *,
         gateway_network_id: str,
         mac_address: str,
         ip_address: str,
         zone: Optional[Zone] = None,
     ) -> DHCPEntry:
         """
-        Create a static DHCP reservation
+        Create a DHCP entry.
+        Create a static DHCP reservation, specifying the Gateway Network for the reservation, the MAC address of the target device and the IP address to assign this device. The response is a DHCP entry object, confirming the ID and configuration details of the static DHCP reservation.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param gateway_network_id: GatewayNetwork on which to create a DHCP reservation.
         :param mac_address: MAC address to give a static entry to.
-        :param ip_address: IP address to give to the machine.
+        :param ip_address: IP address to give to the device.
         :return: :class:`DHCPEntry <DHCPEntry>`
 
         Usage:
         ::
 
             result = await api.create_dhcp_entry(
                 gateway_network_id="example",
@@ -1266,18 +1291,19 @@
         self,
         *,
         dhcp_entry_id: str,
         zone: Optional[Zone] = None,
         ip_address: Optional[str] = None,
     ) -> DHCPEntry:
         """
-        Update a DHCP entry
+        Update a DHCP entry.
+        Update the IP address for a DHCP entry, specified by its DHCP entry ID. You can update an existing DHCP entry of any type (`reservation` (static), `lease` (dynamic) or `unknown`), but in manually updating the IP address the entry will necessarily be of type `reservation` after the update.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param dhcp_entry_id: DHCP entry ID to update.
-        :param ip_address: New IP address to give to the machine.
+        :param dhcp_entry_id: ID of the DHCP entry to update.
+        :param ip_address: New IP address to give to the device.
         :return: :class:`DHCPEntry <DHCPEntry>`
 
         Usage:
         ::
 
             result = await api.update_dhcp_entry(dhcp_entry_id="example")
         """
@@ -1305,18 +1331,18 @@
         self,
         *,
         gateway_network_id: str,
         zone: Optional[Zone] = None,
         dhcp_entries: Optional[List[SetDHCPEntriesRequestEntry]] = None,
     ) -> SetDHCPEntriesResponse:
         """
-        Set the list of DHCP reservations attached to a Gateway Network. Reservations are identified by their MAC address, and will sync the current DHCP entry list to the given list, creating, updating or deleting DHCP entries.
-
+        Set all DHCP reservations on a Gateway Network.
+        Set the list of DHCP reservations attached to a Gateway Network. Reservations are identified by their MAC address, and will sync the current DHCP entry list to the given list, creating, updating or deleting DHCP entries accordingly.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param gateway_network_id: Gateway Network on which to set DHCP reservation list.
+        :param gateway_network_id: ID of the Gateway Network on which to set DHCP reservation list.
         :param dhcp_entries: New list of DHCP reservations.
         :return: :class:`SetDHCPEntriesResponse <SetDHCPEntriesResponse>`
 
         Usage:
         ::
 
             result = await api.set_dhcp_entries(gateway_network_id="example")
@@ -1343,17 +1369,18 @@
     async def delete_dhcp_entry(
         self,
         *,
         dhcp_entry_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete a DHCP reservation
+        Delete a DHCP entry.
+        Delete a static DHCP reservation, identified by its DHCP entry ID. Note that you cannot delete DHCP entries of type `lease`, these are deleted automatically when their time-to-live expires.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param dhcp_entry_id: DHCP entry ID to delete.
+        :param dhcp_entry_id: ID of the DHCP entry to delete.
 
         Usage:
         ::
 
             result = await api.delete_dhcp_entry(dhcp_entry_id="example")
         """
 
@@ -1376,22 +1403,23 @@
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         gateway_id: Optional[str] = None,
         private_ip: Optional[str] = None,
         protocol: PATRuleProtocol = PATRuleProtocol.UNKNOWN,
     ) -> ListPATRulesResponse:
         """
-        List PAT rules
+        List PAT rules.
+        List PAT rules. You can filter by gateway ID to list all PAT rules for a particular gateway, or filter for PAT rules targeting a specific IP address or using a specific protocol.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param order_by: Order in which to return results.
         :param page: Page number.
         :param page_size: PAT rules per page.
-        :param gateway_id: Fetch rules for this gateway.
-        :param private_ip: Fetch rules targeting this private ip.
-        :param protocol: Fetch rules for this protocol.
+        :param gateway_id: Filter for PAT rules on this Gateway.
+        :param private_ip: Filter for PAT rules targeting this private ip.
+        :param protocol: Filter for PAT rules with this protocol.
         :return: :class:`ListPATRulesResponse <ListPATRulesResponse>`
 
         Usage:
         ::
 
             result = await api.list_pat_rules()
         """
@@ -1422,22 +1450,23 @@
         page: Optional[int] = None,
         page_size: Optional[int] = None,
         gateway_id: Optional[str] = None,
         private_ip: Optional[str] = None,
         protocol: Optional[PATRuleProtocol] = None,
     ) -> List[PATRule]:
         """
-        List PAT rules
+        List PAT rules.
+        List PAT rules. You can filter by gateway ID to list all PAT rules for a particular gateway, or filter for PAT rules targeting a specific IP address or using a specific protocol.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param order_by: Order in which to return results.
         :param page: Page number.
         :param page_size: PAT rules per page.
-        :param gateway_id: Fetch rules for this gateway.
-        :param private_ip: Fetch rules targeting this private ip.
-        :param protocol: Fetch rules for this protocol.
+        :param gateway_id: Filter for PAT rules on this Gateway.
+        :param private_ip: Filter for PAT rules targeting this private ip.
+        :param protocol: Filter for PAT rules with this protocol.
         :return: :class:`List[ListPATRulesResponse] <List[ListPATRulesResponse]>`
 
         Usage:
         ::
 
             result = await api.list_pat_rules_all()
         """
@@ -1460,17 +1489,18 @@
     async def get_pat_rule(
         self,
         *,
         pat_rule_id: str,
         zone: Optional[Zone] = None,
     ) -> PATRule:
         """
-        Get a PAT rule
+        Get a PAT rule.
+        Get a PAT rule, specified by its PAT rule ID. The response object gives full details of the PAT rule, including the Public Gateway it belongs to and the configuration settings in terms of public / private ports, private IP and protocol.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param pat_rule_id: PAT rule to get.
+        :param pat_rule_id: ID of the PAT rule to get.
         :return: :class:`PATRule <PATRule>`
 
         Usage:
         ::
 
             result = await api.get_pat_rule(pat_rule_id="example")
         """
@@ -1493,17 +1523,18 @@
         public_port: int,
         private_ip: str,
         private_port: int,
         protocol: PATRuleProtocol,
         zone: Optional[Zone] = None,
     ) -> PATRule:
         """
-        Create a PAT rule
+        Create a PAT rule.
+        Create a new PAT rule on a specified Public Gateway, defining the protocol to use, public port to listen on, and private port / IP address to map to.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param gateway_id: Gateway on which to attach the rule to.
+        :param gateway_id: ID of the Gateway on which to create the rule.
         :param public_port: Public port to listen on.
         :param private_ip: Private IP to forward data to.
         :param private_port: Private port to translate to.
         :param protocol: Protocol the rule should apply to.
         :return: :class:`PATRule <PATRule>`
 
         Usage:
@@ -1546,17 +1577,18 @@
         protocol: PATRuleProtocol,
         zone: Optional[Zone] = None,
         public_port: Optional[int] = None,
         private_ip: Optional[str] = None,
         private_port: Optional[int] = None,
     ) -> PATRule:
         """
-        Update a PAT rule
+        Update a PAT rule.
+        Update a PAT rule, specified by its PAT rule ID. Configuration settings including private/public port, private IP address and protocol can all be updated.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param pat_rule_id: PAT rule to update.
+        :param pat_rule_id: ID of the PAT rule to update.
         :param public_port: Public port to listen on.
         :param private_ip: Private IP to forward data to.
         :param private_port: Private port to translate to.
         :param protocol: Protocol the rule should apply to.
         :return: :class:`PATRule <PATRule>`
 
         Usage:
@@ -1594,18 +1626,18 @@
         self,
         *,
         gateway_id: str,
         pat_rules: List[SetPATRulesRequestRule],
         zone: Optional[Zone] = None,
     ) -> SetPATRulesResponse:
         """
-        Set the list of PAT rules attached to a Gateway. Rules are identified by their public port and protocol. This will sync the current PAT rule list with the givent list, creating, updating or deleting PAT rules.
-
+        Set all PAT rules.
+        Set a definitive list of PAT rules attached to a Public Gateway. Each rule is identified by its public port and protocol. This will sync the current PAT rule list on the gateway with the new list, creating, updating or deleting PAT rules accordingly.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param gateway_id: Gateway on which to set the PAT rules.
+        :param gateway_id: ID of the gateway on which to set the PAT rules.
         :param pat_rules: New list of PAT rules.
         :return: :class:`SetPATRulesResponse <SetPATRulesResponse>`
 
         Usage:
         ::
 
             result = await api.set_pat_rules(
@@ -1635,17 +1667,18 @@
     async def delete_pat_rule(
         self,
         *,
         pat_rule_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete a PAT rule
+        Delete a PAT rule.
+        Delete a PAT rule, identified by its PAT rule ID. This action is irreversible.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param pat_rule_id: PAT rule to delete.
+        :param pat_rule_id: ID of the PAT rule to delete.
 
         Usage:
         ::
 
             result = await api.delete_pat_rule(pat_rule_id="example")
         """
 
@@ -1662,15 +1695,16 @@
 
     async def list_gateway_types(
         self,
         *,
         zone: Optional[Zone] = None,
     ) -> ListGatewayTypesResponse:
         """
-        List VPC Public Gateway types
+        List Public Gateway types.
+        List the different Public Gateway commercial offer types available at Scaleway. The response is an array of objects describing the name and technical details of each available gateway type.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :return: :class:`ListGatewayTypesResponse <ListGatewayTypesResponse>`
 
         Usage:
         ::
 
             result = await api.list_gateway_types()
@@ -1696,24 +1730,25 @@
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         tags: Optional[List[str]] = None,
         reverse: Optional[str] = None,
         is_free: Optional[bool] = None,
     ) -> ListIPsResponse:
         """
-        List IPs
+        List IPs.
+        List Public Gateway flexible IP addresses. A number of filter options are available for limiting results in the response.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param order_by: Order in which to return results.
         :param page: Page number.
-        :param page_size: IPs per page.
-        :param organization_id: Include only IPs in this organization.
-        :param project_id: Include only IPs in this project.
-        :param tags: Filter IPs with these tags.
-        :param reverse: Filter by reverse containing this string.
-        :param is_free: Filter whether the IP is attached to a gateway or not.
+        :param page_size: IP addresses per page.
+        :param organization_id: Filter for IP addresses in this Organization.
+        :param project_id: Filter for IP addresses in this Project.
+        :param tags: Filter for IP addresses with these tags.
+        :param reverse: Filter for IP addresses that have a reverse containing this string.
+        :param is_free: Filter based on whether the IP is attached to a gateway or not.
         :return: :class:`ListIPsResponse <ListIPsResponse>`
 
         Usage:
         ::
 
             result = await api.list_i_ps()
         """
@@ -1749,24 +1784,25 @@
         organization_id: Optional[str] = None,
         project_id: Optional[str] = None,
         tags: Optional[List[str]] = None,
         reverse: Optional[str] = None,
         is_free: Optional[bool] = None,
     ) -> List[IP]:
         """
-        List IPs
+        List IPs.
+        List Public Gateway flexible IP addresses. A number of filter options are available for limiting results in the response.
         :param zone: Zone to target. If none is passed will use default zone from the config.
         :param order_by: Order in which to return results.
         :param page: Page number.
-        :param page_size: IPs per page.
-        :param organization_id: Include only IPs in this organization.
-        :param project_id: Include only IPs in this project.
-        :param tags: Filter IPs with these tags.
-        :param reverse: Filter by reverse containing this string.
-        :param is_free: Filter whether the IP is attached to a gateway or not.
+        :param page_size: IP addresses per page.
+        :param organization_id: Filter for IP addresses in this Organization.
+        :param project_id: Filter for IP addresses in this Project.
+        :param tags: Filter for IP addresses with these tags.
+        :param reverse: Filter for IP addresses that have a reverse containing this string.
+        :param is_free: Filter based on whether the IP is attached to a gateway or not.
         :return: :class:`List[ListIPsResponse] <List[ListIPsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_i_ps_all()
         """
@@ -1791,17 +1827,18 @@
     async def get_ip(
         self,
         *,
         ip_id: str,
         zone: Optional[Zone] = None,
     ) -> IP:
         """
-        Get an IP
+        Get an IP.
+        Get details of a Public Gateway flexible IP address, identified by its IP ID. The response object contains information including which (if any) Public Gateway using this IP address, the reverse and various other metadata.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param ip_id: ID of the IP to get.
+        :param ip_id: ID of the IP address to get.
         :return: :class:`IP <IP>`
 
         Usage:
         ::
 
             result = await api.get_ip(ip_id="example")
         """
@@ -1821,18 +1858,19 @@
         self,
         *,
         zone: Optional[Zone] = None,
         project_id: Optional[str] = None,
         tags: Optional[List[str]] = None,
     ) -> IP:
         """
-        Reserve an IP
+        Reserve an IP.
+        Create (reserve) a new flexible IP address that can be used for a Public Gateway in a specified Scaleway Project.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param project_id: Project to create the IP into.
-        :param tags: Tags to give to the IP.
+        :param project_id: Project to create the IP address in.
+        :param tags: Tags to give to the IP address.
         :return: :class:`IP <IP>`
 
         Usage:
         ::
 
             result = await api.create_ip()
         """
@@ -1861,20 +1899,21 @@
         ip_id: str,
         zone: Optional[Zone] = None,
         tags: Optional[List[str]] = None,
         reverse: Optional[str] = None,
         gateway_id: Optional[str] = None,
     ) -> IP:
         """
-        Update an IP
+        Update an IP.
+        Update details of an existing flexible IP address, including its tags, reverse and the Public Gateway it is assigned to.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param ip_id: ID of the IP to update.
-        :param tags: Tags to give to the IP.
-        :param reverse: Reverse to set on the IP. Empty string to unset.
-        :param gateway_id: Gateway to attach the IP to. Empty string to detach.
+        :param ip_id: ID of the IP address to update.
+        :param tags: Tags to give to the IP address.
+        :param reverse: Reverse to set on the address. Empty string to unset.
+        :param gateway_id: Gateway to attach the IP address to. Empty string to detach.
         :return: :class:`IP <IP>`
 
         Usage:
         ::
 
             result = await api.update_ip(ip_id="example")
         """
@@ -1903,17 +1942,18 @@
     async def delete_ip(
         self,
         *,
         ip_id: str,
         zone: Optional[Zone] = None,
     ) -> Optional[None]:
         """
-        Delete an IP
+        Delete an IP.
+        Delete a flexible IP address from your account. This action is irreversible.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param ip_id: ID of the IP to delete.
+        :param ip_id: ID of the IP address to delete.
 
         Usage:
         ::
 
             result = await api.delete_ip(ip_id="example")
         """
 
@@ -1931,17 +1971,18 @@
     async def refresh_ssh_keys(
         self,
         *,
         gateway_id: str,
         zone: Optional[Zone] = None,
     ) -> Gateway:
         """
-        Refresh SSH keys of a VPC Public Gateway
+        Refresh a Public Gateway's SSH keys.
+        Refresh the SSH keys of a given Public Gateway, specified by its gateway ID. This adds any new SSH keys in the gateway's Scaleway Project to the gateway itself.
         :param zone: Zone to target. If none is passed will use default zone from the config.
-        :param gateway_id: ID of the gateway that needs fresh ssh keys.
+        :param gateway_id: ID of the gateway to refresh SSH keys on.
         :return: :class:`Gateway <Gateway>`
 
         Usage:
         ::
 
             result = await api.refresh_ssh_keys(gateway_id="example")
         """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/vpcgw/v1/content.py` & `scaleway_async-1.0.0/scaleway_async/vpcgw/v1/content.py`

 * *Files identical despite different names*

### Comparing `scaleway_async-0.9.0/scaleway_async/vpcgw/v1/marshalling.py` & `scaleway_async-1.0.0/scaleway_async/redis/v1/marshalling.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,735 +1,789 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 
 from typing import Any, Dict
 
 from scaleway_core.profile import ProfileDefaults
+from scaleway_core.bridge import (
+    unmarshal_TimeSeries,
+)
 from scaleway_core.utils import (
     OneOfPossibility,
     resolve_one_of,
 )
 from dateutil import parser
 from .types import (
-    PATRuleProtocol,
-    DHCP,
-    DHCPEntry,
-    Gateway,
-    GatewayNetwork,
-    GatewayType,
-    IP,
-    ListDHCPEntriesResponse,
-    ListDHCPsResponse,
-    ListGatewayNetworksResponse,
-    ListGatewayTypesResponse,
-    ListGatewaysResponse,
-    ListIPsResponse,
-    ListPATRulesResponse,
-    PATRule,
-    SetDHCPEntriesRequestEntry,
-    SetDHCPEntriesResponse,
-    SetPATRulesRequestRule,
-    SetPATRulesResponse,
-    CreateGatewayRequest,
-    UpdateGatewayRequest,
-    CreateGatewayNetworkRequest,
-    UpdateGatewayNetworkRequest,
-    CreateDHCPRequest,
-    UpdateDHCPRequest,
-    CreateDHCPEntryRequest,
-    UpdateDHCPEntryRequest,
-    SetDHCPEntriesRequest,
-    CreatePATRuleRequest,
-    UpdatePATRuleRequest,
-    SetPATRulesRequest,
-    CreateIPRequest,
-    UpdateIPRequest,
+    ACLRule,
+    ACLRuleSpec,
+    AddAclRulesResponse,
+    AddEndpointsResponse,
+    AvailableClusterSetting,
+    Cluster,
+    ClusterMetricsResponse,
+    ClusterSetting,
+    ClusterSettingsResponse,
+    ClusterVersion,
+    Endpoint,
+    EndpointSpec,
+    EndpointSpecPrivateNetworkSpec,
+    EndpointSpecPrivateNetworkSpecIpamConfig,
+    EndpointSpecPublicNetworkSpec,
+    ListClusterVersionsResponse,
+    ListClustersResponse,
+    ListNodeTypesResponse,
+    NodeType,
+    PrivateNetwork,
+    PublicNetwork,
+    SetAclRulesResponse,
+    SetEndpointsResponse,
+    CreateClusterRequest,
+    UpdateClusterRequest,
+    MigrateClusterRequest,
+    AddClusterSettingsRequest,
+    SetClusterSettingsRequest,
+    SetAclRulesRequest,
+    AddAclRulesRequest,
+    SetEndpointsRequest,
+    AddEndpointsRequest,
+    UpdateEndpointRequest,
 )
 
 
-def unmarshal_DHCP(data: Any) -> DHCP:
+def unmarshal_PrivateNetwork(data: Any) -> PrivateNetwork:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'DHCP' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'PrivateNetwork' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("address")
-    args["address"] = field
-
-    field = data.get("created_at")
-    args["created_at"] = parser.isoparse(field) if type(field) is str else field
-
-    field = data.get("dns_local_name")
-    args["dns_local_name"] = field
-
-    field = data.get("dns_search")
-    args["dns_search"] = field
-
-    field = data.get("dns_servers_override")
-    args["dns_servers_override"] = field
-
-    field = data.get("enable_dynamic")
-    args["enable_dynamic"] = field
-
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("organization_id")
-    args["organization_id"] = field
-
-    field = data.get("pool_high")
-    args["pool_high"] = field
-
-    field = data.get("pool_low")
-    args["pool_low"] = field
+    field = data.get("provisioning_mode", None)
+    args["provisioning_mode"] = field
 
-    field = data.get("project_id")
-    args["project_id"] = field
-
-    field = data.get("push_default_route")
-    args["push_default_route"] = field
-
-    field = data.get("push_dns_server")
-    args["push_dns_server"] = field
-
-    field = data.get("rebind_timer")
-    args["rebind_timer"] = field
-
-    field = data.get("renew_timer")
-    args["renew_timer"] = field
+    field = data.get("service_ips", None)
+    args["service_ips"] = field
 
-    field = data.get("subnet")
-    args["subnet"] = field
-
-    field = data.get("updated_at")
-    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
-
-    field = data.get("valid_lifetime")
-    args["valid_lifetime"] = field
-
-    field = data.get("zone")
+    field = data.get("zone", None)
     args["zone"] = field
 
-    return DHCP(**args)
+    return PrivateNetwork(**args)
 
 
-def unmarshal_GatewayNetwork(data: Any) -> GatewayNetwork:
+def unmarshal_PublicNetwork(data: Any) -> PublicNetwork:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'GatewayNetwork' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'PublicNetwork' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("address")
-    args["address"] = field
+    return PublicNetwork(**args)
 
-    field = data.get("created_at")
-    args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("dhcp")
-    args["dhcp"] = unmarshal_DHCP(field) if field is not None else None
-
-    field = data.get("enable_dhcp")
-    args["enable_dhcp"] = field
-
-    field = data.get("enable_masquerade")
-    args["enable_masquerade"] = field
-
-    field = data.get("gateway_id")
-    args["gateway_id"] = field
-
-    field = data.get("id")
-    args["id"] = field
-
-    field = data.get("mac_address")
-    args["mac_address"] = field
-
-    field = data.get("private_network_id")
-    args["private_network_id"] = field
-
-    field = data.get("status")
-    args["status"] = field
-
-    field = data.get("updated_at")
-    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
-
-    field = data.get("zone")
-    args["zone"] = field
-
-    return GatewayNetwork(**args)
-
-
-def unmarshal_GatewayType(data: Any) -> GatewayType:
+def unmarshal_ACLRule(data: Any) -> ACLRule:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'GatewayType' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ACLRule' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("bandwidth")
-    args["bandwidth"] = field
+    field = data.get("description", None)
+    args["description"] = field
 
-    field = data.get("name")
-    args["name"] = field
+    field = data.get("id", None)
+    args["id"] = field
 
-    field = data.get("zone")
-    args["zone"] = field
+    field = data.get("ip_cidr", None)
+    args["ip_cidr"] = field
 
-    return GatewayType(**args)
+    return ACLRule(**args)
 
 
-def unmarshal_IP(data: Any) -> IP:
+def unmarshal_AvailableClusterSetting(data: Any) -> AvailableClusterSetting:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'IP' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'AvailableClusterSetting' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("address")
-    args["address"] = field
+    field = data.get("default_value", None)
+    args["default_value"] = field
 
-    field = data.get("created_at")
-    args["created_at"] = parser.isoparse(field) if type(field) is str else field
-
-    field = data.get("gateway_id")
-    args["gateway_id"] = field
+    field = data.get("deprecated", None)
+    args["deprecated"] = field
 
-    field = data.get("id")
-    args["id"] = field
+    field = data.get("description", None)
+    args["description"] = field
 
-    field = data.get("organization_id")
-    args["organization_id"] = field
-
-    field = data.get("project_id")
-    args["project_id"] = field
+    field = data.get("max_value", None)
+    args["max_value"] = field
 
-    field = data.get("reverse")
-    args["reverse"] = field
+    field = data.get("min_value", None)
+    args["min_value"] = field
 
-    field = data.get("tags")
-    args["tags"] = field
+    field = data.get("name", None)
+    args["name"] = field
 
-    field = data.get("updated_at")
-    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("regex", None)
+    args["regex"] = field
 
-    field = data.get("zone")
-    args["zone"] = field
+    field = data.get("type", None)
+    args["type_"] = field
 
-    return IP(**args)
+    return AvailableClusterSetting(**args)
 
 
-def unmarshal_DHCPEntry(data: Any) -> DHCPEntry:
+def unmarshal_ClusterSetting(data: Any) -> ClusterSetting:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'DHCPEntry' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ClusterSetting' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
-    args["created_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("name", None)
+    args["name"] = field
 
-    field = data.get("gateway_network_id")
-    args["gateway_network_id"] = field
+    field = data.get("value", None)
+    args["value"] = field
 
-    field = data.get("hostname")
-    args["hostname"] = field
+    return ClusterSetting(**args)
 
-    field = data.get("id")
-    args["id"] = field
 
-    field = data.get("ip_address")
-    args["ip_address"] = field
+def unmarshal_Endpoint(data: Any) -> Endpoint:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'Endpoint' failed as data isn't a dictionary."
+        )
 
-    field = data.get("mac_address")
-    args["mac_address"] = field
+    args: Dict[str, Any] = {}
 
-    field = data.get("type_")
-    args["type_"] = field
+    field = data.get("id", None)
+    args["id"] = field
 
-    field = data.get("updated_at")
-    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("ips", None)
+    args["ips"] = field
 
-    field = data.get("zone")
-    args["zone"] = field
+    field = data.get("port", None)
+    args["port"] = field
+
+    field = data.get("private_network", None)
+    args["private_network"] = (
+        unmarshal_PrivateNetwork(field) if field is not None else None
+    )
 
-    return DHCPEntry(**args)
+    field = data.get("public_network", None)
+    args["public_network"] = (
+        unmarshal_PublicNetwork(field) if field is not None else None
+    )
 
+    return Endpoint(**args)
 
-def unmarshal_Gateway(data: Any) -> Gateway:
+
+def unmarshal_Cluster(data: Any) -> Cluster:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Gateway' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Cluster' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("bastion_enabled")
-    args["bastion_enabled"] = field
+    field = data.get("acl_rules", None)
+    args["acl_rules"] = (
+        [unmarshal_ACLRule(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("bastion_port")
-    args["bastion_port"] = field
+    field = data.get("cluster_settings", None)
+    args["cluster_settings"] = (
+        [unmarshal_ClusterSetting(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("can_upgrade_to")
-    args["can_upgrade_to"] = field
+    field = data.get("cluster_size", None)
+    args["cluster_size"] = field
 
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("gateway_networks")
-    args["gateway_networks"] = [
-        unmarshal_GatewayNetwork(v) for v in data["gateway_networks"]
-    ]
+    field = data.get("endpoints", None)
+    args["endpoints"] = (
+        [unmarshal_Endpoint(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("ip")
-    args["ip"] = unmarshal_IP(field) if field is not None else None
-
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    field = data.get("organization_id")
-    args["organization_id"] = field
+    field = data.get("node_type", None)
+    args["node_type"] = field
 
-    field = data.get("project_id")
+    field = data.get("project_id", None)
     args["project_id"] = field
 
-    field = data.get("smtp_enabled")
-    args["smtp_enabled"] = field
-
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("tags")
+    field = data.get("tags", None)
     args["tags"] = field
 
-    field = data.get("type_")
-    args["type_"] = unmarshal_GatewayType(field) if field is not None else None
+    field = data.get("tls_enabled", None)
+    args["tls_enabled"] = field
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("upstream_dns_servers")
-    args["upstream_dns_servers"] = field
+    field = data.get("upgradable_versions", None)
+    args["upgradable_versions"] = field
+
+    field = data.get("user_name", None)
+    args["user_name"] = field
 
-    field = data.get("version")
+    field = data.get("version", None)
     args["version"] = field
 
-    field = data.get("zone")
+    field = data.get("zone", None)
     args["zone"] = field
 
-    return Gateway(**args)
+    return Cluster(**args)
 
 
-def unmarshal_PATRule(data: Any) -> PATRule:
+def unmarshal_ClusterVersion(data: Any) -> ClusterVersion:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'PATRule' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ClusterVersion' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("created_at")
-    args["created_at"] = parser.isoparse(field) if type(field) is str else field
+    field = data.get("available_settings", None)
+    args["available_settings"] = (
+        [unmarshal_AvailableClusterSetting(v) for v in field]
+        if field is not None
+        else None
+    )
 
-    field = data.get("gateway_id")
-    args["gateway_id"] = field
+    field = data.get("end_of_life_at", None)
+    args["end_of_life_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("id")
-    args["id"] = field
+    field = data.get("logo_url", None)
+    args["logo_url"] = field
 
-    field = data.get("private_ip")
-    args["private_ip"] = field
+    field = data.get("version", None)
+    args["version"] = field
 
-    field = data.get("private_port")
-    args["private_port"] = field
+    field = data.get("zone", None)
+    args["zone"] = field
 
-    field = data.get("protocol")
-    args["protocol"] = field
+    return ClusterVersion(**args)
 
-    field = data.get("public_port")
-    args["public_port"] = field
 
-    field = data.get("updated_at")
-    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
+def unmarshal_NodeType(data: Any) -> NodeType:
+    if type(data) is not dict:
+        raise TypeError(
+            f"Unmarshalling the type 'NodeType' failed as data isn't a dictionary."
+        )
+
+    args: Dict[str, Any] = {}
+
+    field = data.get("beta", None)
+    args["beta"] = field
+
+    field = data.get("description", None)
+    args["description"] = field
 
-    field = data.get("zone")
+    field = data.get("disabled", None)
+    args["disabled"] = field
+
+    field = data.get("memory", None)
+    args["memory"] = field
+
+    field = data.get("name", None)
+    args["name"] = field
+
+    field = data.get("stock_status", None)
+    args["stock_status"] = field
+
+    field = data.get("vcpus", None)
+    args["vcpus"] = field
+
+    field = data.get("zone", None)
     args["zone"] = field
 
-    return PATRule(**args)
+    return NodeType(**args)
 
 
-def unmarshal_ListDHCPEntriesResponse(data: Any) -> ListDHCPEntriesResponse:
+def unmarshal_AddAclRulesResponse(data: Any) -> AddAclRulesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListDHCPEntriesResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'AddAclRulesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("dhcp_entries")
-    args["dhcp_entries"] = [unmarshal_DHCPEntry(v) for v in data["dhcp_entries"]]
+    field = data.get("acl_rules", None)
+    args["acl_rules"] = (
+        [unmarshal_ACLRule(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListDHCPEntriesResponse(**args)
+    return AddAclRulesResponse(**args)
 
 
-def unmarshal_ListDHCPsResponse(data: Any) -> ListDHCPsResponse:
+def unmarshal_AddEndpointsResponse(data: Any) -> AddEndpointsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListDHCPsResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'AddEndpointsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("dhcps")
-    args["dhcps"] = [unmarshal_DHCP(v) for v in data["dhcps"]]
+    field = data.get("endpoints", None)
+    args["endpoints"] = (
+        [unmarshal_Endpoint(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListDHCPsResponse(**args)
+    return AddEndpointsResponse(**args)
 
 
-def unmarshal_ListGatewayNetworksResponse(data: Any) -> ListGatewayNetworksResponse:
+def unmarshal_ClusterMetricsResponse(data: Any) -> ClusterMetricsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListGatewayNetworksResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ClusterMetricsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("gateway_networks")
-    args["gateway_networks"] = [
-        unmarshal_GatewayNetwork(v) for v in data["gateway_networks"]
-    ]
-
-    field = data.get("total_count")
-    args["total_count"] = field
+    field = data.get("timeseries", None)
+    args["timeseries"] = (
+        [unmarshal_TimeSeries(v) for v in field] if field is not None else None
+    )
 
-    return ListGatewayNetworksResponse(**args)
+    return ClusterMetricsResponse(**args)
 
 
-def unmarshal_ListGatewayTypesResponse(data: Any) -> ListGatewayTypesResponse:
+def unmarshal_ClusterSettingsResponse(data: Any) -> ClusterSettingsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListGatewayTypesResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ClusterSettingsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("types")
-    args["types"] = [unmarshal_GatewayType(v) for v in data["types"]]
+    field = data.get("settings", None)
+    args["settings"] = (
+        [unmarshal_ClusterSetting(v) for v in field] if field is not None else None
+    )
 
-    return ListGatewayTypesResponse(**args)
+    return ClusterSettingsResponse(**args)
 
 
-def unmarshal_ListGatewaysResponse(data: Any) -> ListGatewaysResponse:
+def unmarshal_ListClusterVersionsResponse(data: Any) -> ListClusterVersionsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListGatewaysResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListClusterVersionsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("gateways")
-    args["gateways"] = [unmarshal_Gateway(v) for v in data["gateways"]]
-
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListGatewaysResponse(**args)
+    field = data.get("versions", None)
+    args["versions"] = (
+        [unmarshal_ClusterVersion(v) for v in field] if field is not None else None
+    )
+
+    return ListClusterVersionsResponse(**args)
 
 
-def unmarshal_ListIPsResponse(data: Any) -> ListIPsResponse:
+def unmarshal_ListClustersResponse(data: Any) -> ListClustersResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListIPsResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListClustersResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("ips")
-    args["ips"] = [unmarshal_IP(v) for v in data["ips"]]
+    field = data.get("clusters", None)
+    args["clusters"] = (
+        [unmarshal_Cluster(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListIPsResponse(**args)
+    return ListClustersResponse(**args)
 
 
-def unmarshal_ListPATRulesResponse(data: Any) -> ListPATRulesResponse:
+def unmarshal_ListNodeTypesResponse(data: Any) -> ListNodeTypesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListPATRulesResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListNodeTypesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("pat_rules")
-    args["pat_rules"] = [unmarshal_PATRule(v) for v in data["pat_rules"]]
+    field = data.get("node_types", None)
+    args["node_types"] = (
+        [unmarshal_NodeType(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListPATRulesResponse(**args)
+    return ListNodeTypesResponse(**args)
 
 
-def unmarshal_SetDHCPEntriesResponse(data: Any) -> SetDHCPEntriesResponse:
+def unmarshal_SetAclRulesResponse(data: Any) -> SetAclRulesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'SetDHCPEntriesResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'SetAclRulesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("dhcp_entries")
-    args["dhcp_entries"] = [unmarshal_DHCPEntry(v) for v in data["dhcp_entries"]]
+    field = data.get("acl_rules", None)
+    args["acl_rules"] = (
+        [unmarshal_ACLRule(v) for v in field] if field is not None else None
+    )
 
-    return SetDHCPEntriesResponse(**args)
+    return SetAclRulesResponse(**args)
 
 
-def unmarshal_SetPATRulesResponse(data: Any) -> SetPATRulesResponse:
+def unmarshal_SetEndpointsResponse(data: Any) -> SetEndpointsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'SetPATRulesResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'SetEndpointsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("pat_rules")
-    args["pat_rules"] = [unmarshal_PATRule(v) for v in data["pat_rules"]]
+    field = data.get("endpoints", None)
+    args["endpoints"] = (
+        [unmarshal_Endpoint(v) for v in field] if field is not None else None
+    )
 
-    return SetPATRulesResponse(**args)
+    return SetEndpointsResponse(**args)
 
 
-def marshal_CreateDHCPRequest(
-    request: CreateDHCPRequest,
+def marshal_EndpointSpecPrivateNetworkSpecIpamConfig(
+    request: EndpointSpecPrivateNetworkSpecIpamConfig,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "address": request.address,
-        "dns_local_name": request.dns_local_name,
-        "dns_search": request.dns_search,
-        "dns_servers_override": request.dns_servers_override,
-        "enable_dynamic": request.enable_dynamic,
-        "pool_high": request.pool_high,
-        "pool_low": request.pool_low,
-        "project_id": request.project_id or defaults.default_project_id,
-        "push_default_route": request.push_default_route,
-        "push_dns_server": request.push_dns_server,
-        "rebind_timer": request.rebind_timer,
-        "renew_timer": request.renew_timer,
-        "subnet": request.subnet,
-        "valid_lifetime": request.valid_lifetime,
-    }
+    output: Dict[str, Any] = {}
 
+    return output
 
-def marshal_SetDHCPEntriesRequestEntry(
-    request: SetDHCPEntriesRequestEntry,
+
+def marshal_EndpointSpecPrivateNetworkSpec(
+    request: EndpointSpecPrivateNetworkSpec,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "ip_address": request.ip_address,
-        "mac_address": request.mac_address,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.id is not None:
+        output["id"] = request.id
+
+    if request.ipam_config is not None:
+        output["ipam_config"] = marshal_EndpointSpecPrivateNetworkSpecIpamConfig(
+            request.ipam_config, defaults
+        )
+
+    if request.service_ips is not None:
+        output["service_ips"] = request.service_ips
 
+    return output
 
-def marshal_SetPATRulesRequestRule(
-    request: SetPATRulesRequestRule,
+
+def marshal_EndpointSpecPublicNetworkSpec(
+    request: EndpointSpecPublicNetworkSpec,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "private_ip": request.private_ip,
-        "private_port": request.private_port,
-        "protocol": PATRuleProtocol(request.protocol),
-        "public_port": request.public_port,
-    }
+    output: Dict[str, Any] = {}
+
+    return output
 
 
-def marshal_CreateDHCPEntryRequest(
-    request: CreateDHCPEntryRequest,
+def marshal_ACLRuleSpec(
+    request: ACLRuleSpec,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "gateway_network_id": request.gateway_network_id,
-        "ip_address": request.ip_address,
-        "mac_address": request.mac_address,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.ip_cidr is not None:
+        output["ip_cidr"] = request.ip_cidr
+
+    return output
 
 
-def marshal_CreateGatewayNetworkRequest(
-    request: CreateGatewayNetworkRequest,
+def marshal_ClusterSetting(
+    request: ClusterSetting,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
+    output: Dict[str, Any] = {}
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.value is not None:
+        output["value"] = request.value
+
+    return output
+
+
+def marshal_EndpointSpec(
+    request: EndpointSpec,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
             [
-                OneOfPossibility("dhcp_id", request.dhcp_id),
-                OneOfPossibility("dhcp", request.dhcp),
-                OneOfPossibility("address", request.address),
+                OneOfPossibility(
+                    "private_network",
+                    marshal_EndpointSpecPrivateNetworkSpec(
+                        request.private_network, defaults
+                    )
+                    if request.private_network is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "public_network",
+                    marshal_EndpointSpecPublicNetworkSpec(
+                        request.public_network, defaults
+                    )
+                    if request.public_network is not None
+                    else None,
+                ),
             ]
         ),
-        "enable_dhcp": request.enable_dhcp,
-        "enable_masquerade": request.enable_masquerade,
-        "gateway_id": request.gateway_id,
-        "private_network_id": request.private_network_id,
-    }
+    )
+
+    return output
 
 
-def marshal_CreateGatewayRequest(
-    request: CreateGatewayRequest,
+def marshal_AddAclRulesRequest(
+    request: AddAclRulesRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "bastion_port": request.bastion_port,
-        "enable_bastion": request.enable_bastion,
-        "enable_smtp": request.enable_smtp,
-        "ip_id": request.ip_id,
-        "name": request.name,
-        "project_id": request.project_id or defaults.default_project_id,
-        "tags": request.tags,
-        "type": request.type_,
-        "upstream_dns_servers": request.upstream_dns_servers,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.acl_rules is not None:
+        output["acl_rules"] = [
+            marshal_ACLRuleSpec(v, defaults) for v in request.acl_rules
+        ]
 
-def marshal_CreateIPRequest(
-    request: CreateIPRequest,
-    defaults: ProfileDefaults,
-) -> Dict[str, Any]:
-    return {
-        "project_id": request.project_id or defaults.default_project_id,
-        "tags": request.tags,
-    }
+    return output
 
 
-def marshal_CreatePATRuleRequest(
-    request: CreatePATRuleRequest,
+def marshal_AddClusterSettingsRequest(
+    request: AddClusterSettingsRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "gateway_id": request.gateway_id,
-        "private_ip": request.private_ip,
-        "private_port": request.private_port,
-        "protocol": PATRuleProtocol(request.protocol),
-        "public_port": request.public_port,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.settings is not None:
+        output["settings"] = [
+            marshal_ClusterSetting(v, defaults) for v in request.settings
+        ]
 
+    return output
 
-def marshal_SetDHCPEntriesRequest(
-    request: SetDHCPEntriesRequest,
+
+def marshal_AddEndpointsRequest(
+    request: AddEndpointsRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "dhcp_entries": [
-            marshal_SetDHCPEntriesRequestEntry(v, defaults)
-            for v in request.dhcp_entries
+    output: Dict[str, Any] = {}
+
+    if request.endpoints is not None:
+        output["endpoints"] = [
+            marshal_EndpointSpec(v, defaults) for v in request.endpoints
         ]
-        if request.dhcp_entries is not None
-        else None,
-        "gateway_network_id": request.gateway_network_id,
-    }
 
+    return output
 
-def marshal_SetPATRulesRequest(
-    request: SetPATRulesRequest,
+
+def marshal_CreateClusterRequest(
+    request: CreateClusterRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "gateway_id": request.gateway_id,
-        "pat_rules": [
-            marshal_SetPATRulesRequestRule(v, defaults) for v in request.pat_rules
-        ],
-    }
+    output: Dict[str, Any] = {}
+
+    if request.acl_rules is not None:
+        output["acl_rules"] = [
+            marshal_ACLRuleSpec(v, defaults) for v in request.acl_rules
+        ]
 
+    if request.cluster_settings is not None:
+        output["cluster_settings"] = [
+            marshal_ClusterSetting(v, defaults) for v in request.cluster_settings
+        ]
 
-def marshal_UpdateDHCPEntryRequest(
-    request: UpdateDHCPEntryRequest,
+    if request.cluster_size is not None:
+        output["cluster_size"] = request.cluster_size
+
+    if request.endpoints is not None:
+        output["endpoints"] = [
+            marshal_EndpointSpec(v, defaults) for v in request.endpoints
+        ]
+
+    if request.name is not None:
+        output["name"] = request.name
+
+    if request.node_type is not None:
+        output["node_type"] = request.node_type
+
+    if request.password is not None:
+        output["password"] = request.password
+
+    if request.project_id is not None:
+        output["project_id"] = request.project_id or defaults.default_project_id
+
+    if request.tags is not None:
+        output["tags"] = request.tags
+
+    if request.tls_enabled is not None:
+        output["tls_enabled"] = request.tls_enabled
+
+    if request.user_name is not None:
+        output["user_name"] = request.user_name
+
+    if request.version is not None:
+        output["version"] = request.version
+
+    return output
+
+
+def marshal_MigrateClusterRequest(
+    request: MigrateClusterRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "ip_address": request.ip_address,
-    }
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
+            [
+                OneOfPossibility(
+                    "version", request.version if request.version is not None else None
+                ),
+                OneOfPossibility(
+                    "node_type",
+                    request.node_type if request.node_type is not None else None,
+                ),
+                OneOfPossibility(
+                    "cluster_size",
+                    request.cluster_size if request.cluster_size is not None else None,
+                ),
+            ]
+        ),
+    )
+
+    return output
 
 
-def marshal_UpdateDHCPRequest(
-    request: UpdateDHCPRequest,
+def marshal_SetAclRulesRequest(
+    request: SetAclRulesRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "address": request.address,
-        "dns_local_name": request.dns_local_name,
-        "dns_search": request.dns_search,
-        "dns_servers_override": request.dns_servers_override,
-        "enable_dynamic": request.enable_dynamic,
-        "pool_high": request.pool_high,
-        "pool_low": request.pool_low,
-        "push_default_route": request.push_default_route,
-        "push_dns_server": request.push_dns_server,
-        "rebind_timer": request.rebind_timer,
-        "renew_timer": request.renew_timer,
-        "subnet": request.subnet,
-        "valid_lifetime": request.valid_lifetime,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.acl_rules is not None:
+        output["acl_rules"] = [
+            marshal_ACLRuleSpec(v, defaults) for v in request.acl_rules
+        ]
 
+    return output
 
-def marshal_UpdateGatewayNetworkRequest(
-    request: UpdateGatewayNetworkRequest,
+
+def marshal_SetClusterSettingsRequest(
+    request: SetClusterSettingsRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        **resolve_one_of(
-            [
-                OneOfPossibility("dhcp_id", request.dhcp_id),
-                OneOfPossibility("address", request.address),
-            ]
-        ),
-        "enable_dhcp": request.enable_dhcp,
-        "enable_masquerade": request.enable_masquerade,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.settings is not None:
+        output["settings"] = [
+            marshal_ClusterSetting(v, defaults) for v in request.settings
+        ]
+
+    return output
 
 
-def marshal_UpdateGatewayRequest(
-    request: UpdateGatewayRequest,
+def marshal_SetEndpointsRequest(
+    request: SetEndpointsRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "bastion_port": request.bastion_port,
-        "enable_bastion": request.enable_bastion,
-        "enable_smtp": request.enable_smtp,
-        "name": request.name,
-        "tags": request.tags,
-        "upstream_dns_servers": request.upstream_dns_servers,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.endpoints is not None:
+        output["endpoints"] = [
+            marshal_EndpointSpec(v, defaults) for v in request.endpoints
+        ]
+
+    return output
 
 
-def marshal_UpdateIPRequest(
-    request: UpdateIPRequest,
+def marshal_UpdateClusterRequest(
+    request: UpdateClusterRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "gateway_id": request.gateway_id,
-        "reverse": request.reverse,
-        "tags": request.tags,
-    }
+    output: Dict[str, Any] = {}
 
+    if request.name is not None:
+        output["name"] = request.name
 
-def marshal_UpdatePATRuleRequest(
-    request: UpdatePATRuleRequest,
+    if request.password is not None:
+        output["password"] = request.password
+
+    if request.tags is not None:
+        output["tags"] = request.tags
+
+    if request.user_name is not None:
+        output["user_name"] = request.user_name
+
+    return output
+
+
+def marshal_UpdateEndpointRequest(
+    request: UpdateEndpointRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "private_ip": request.private_ip,
-        "private_port": request.private_port,
-        "protocol": PATRuleProtocol(request.protocol),
-        "public_port": request.public_port,
-    }
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
+            [
+                OneOfPossibility(
+                    "private_network",
+                    marshal_EndpointSpecPrivateNetworkSpec(
+                        request.private_network, defaults
+                    )
+                    if request.private_network is not None
+                    else None,
+                ),
+                OneOfPossibility(
+                    "public_network",
+                    marshal_EndpointSpecPublicNetworkSpec(
+                        request.public_network, defaults
+                    )
+                    if request.public_network is not None
+                    else None,
+                ),
+            ]
+        ),
+    )
+
+    return output
```

### Comparing `scaleway_async-0.9.0/scaleway_async/vpcgw/v1/types.py` & `scaleway_async-1.0.0/scaleway_async/vpcgw/v1/types.py`

 * *Files 10% similar despite different names*

```diff
@@ -137,152 +137,152 @@
     id: str
     """
     ID of the DHCP config.
     """
 
     organization_id: str
     """
-    Owning organization.
+    Owning Organization.
     """
 
     project_id: str
     """
-    Owning project.
+    Owning Project.
     """
 
     created_at: Optional[datetime]
     """
-    Configuration creation date.
+    Date the DHCP configuration was created.
     """
 
     updated_at: Optional[datetime]
     """
     Configuration last modification date.
     """
 
     subnet: str
     """
     Subnet for the DHCP server.
     """
 
     address: str
     """
-    Address of the DHCP server. This will be the gateway's address in the private network. It must be part of config's subnet.
+    IP address of the DHCP server. This will be the Public Gateway's address in the Private Network. It must be part of config's subnet.
     """
 
     pool_low: str
     """
-    Low IP (included) of the dynamic address pool. Must be in the config's subnet.
+    Low IP (inclusive) of the dynamic address pool. Must be in the config's subnet.
     """
 
     pool_high: str
     """
-    High IP (included) of the dynamic address pool. Must be in the config's subnet.
+    High IP (inclusive) of the dynamic address pool. Must be in the config's subnet.
     """
 
     enable_dynamic: bool
     """
-    Whether to enable dynamic pooling of IPs. By turning the dynamic pool off, only pre-existing DHCP reservations will be handed out.
+    Defines whether to enable dynamic pooling of IPs. When false, only pre-existing DHCP reservations will be handed out.
     """
 
     valid_lifetime: Optional[str]
     """
-    How long, in seconds, DHCP entries will be valid for.
+    How long DHCP entries will be valid for.
     """
 
     renew_timer: Optional[str]
     """
-    After how long, in seconds, a renew will be attempted. Must be 30s lower than `rebind_timer`.
+    After how long a renew will be attempted. Must be 30s lower than `rebind_timer`.
     """
 
     rebind_timer: Optional[str]
     """
-    After how long, in seconds, a DHCP client will query for a new lease if previous renews fail. Must be 30s lower than `valid_lifetime`.
+    After how long a DHCP client will query for a new lease if previous renews fail. Must be 30s lower than `valid_lifetime`.
     """
 
     push_default_route: bool
     """
-    Whether the gateway should push a default route to DHCP clients or only hand out IPs.
+    Defines whether the gateway should push a default route to DHCP clients, or only hand out IPs.
     """
 
     push_dns_server: bool
     """
-    Whether the gateway should push custom DNS servers to clients. This allows for instance hostname -> IP resolution.
+    Defines whether the gateway should push custom DNS servers to clients. This allows for instance hostname -> IP resolution.
     """
 
     dns_servers_override: List[str]
     """
-    Override the DNS server list pushed to DHCP clients, instead of the gateway itself.
+    Array of DNS server IP addresses used to override the DNS server list pushed to DHCP clients, instead of the gateway itself.
     """
 
     dns_search: List[str]
     """
-    Add search paths to the pushed DNS configuration.
+    Array of search paths in addition to the pushed DNS configuration.
     """
 
     dns_local_name: str
     """
-    TLD given to hostnames in the Private Network. If an instance with hostname `foo` gets a lease, and this is set to `bar`, `foo.bar` will resolve.
+    TLD given to hostnames in the Private Networks. If an Instance with hostname `foo` gets a lease, and this is set to `bar`, `foo.bar` will resolve.
     """
 
     zone: Zone
     """
-    Zone this configuration is available in.
+    Zone of this DHCP configuration.
     """
 
 
 @dataclass
 class DHCPEntry:
     """
     Dhcp entry.
     """
 
     id: str
     """
-    Entry ID.
+    DHCP entry ID.
     """
 
     created_at: Optional[datetime]
     """
-    Configuration creation date.
+    DHCP entry creation date.
     """
 
     updated_at: Optional[datetime]
     """
-    Configuration last modification date.
+    DHCP entry last modification date.
     """
 
     gateway_network_id: str
     """
     Owning GatewayNetwork.
     """
 
     mac_address: str
     """
-    MAC address of the client machine.
+    MAC address of the client device.
     """
 
     ip_address: str
     """
     Assigned IP address.
     """
 
     hostname: str
     """
-    Hostname of the client machine.
+    Hostname of the client device.
     """
 
     type_: DHCPEntryType
     """
     Entry type, either static (DHCP reservation) or dynamic (DHCP lease).
     """
 
     zone: Zone
     """
-    Zone this entry is available in.
+    Zone of this DHCP entry.
     """
 
 
 @dataclass
 class Gateway:
     """
     Gateway.
@@ -291,241 +291,241 @@
     id: str
     """
     ID of the gateway.
     """
 
     organization_id: str
     """
-    Owning organization.
+    Owning Organization.
     """
 
     project_id: str
     """
-    Owning project.
+    Owning Project.
     """
 
     created_at: Optional[datetime]
     """
     Gateway creation date.
     """
 
     updated_at: Optional[datetime]
     """
     Gateway last modification date.
     """
 
     type_: Optional[GatewayType]
     """
-    Gateway type.
+    Gateway type (commercial offer).
     """
 
     status: GatewayStatus
     """
-    Gateway's current status.
+    Current status of the gateway.
     """
 
     name: str
     """
     Name of the gateway.
     """
 
     tags: List[str]
     """
-    Tags of the gateway.
+    Tags associated with the gateway.
     """
 
     ip: Optional[IP]
     """
-    Public IP of the gateway.
+    Public IP address of the gateway.
     """
 
     gateway_networks: List[GatewayNetwork]
     """
-    GatewayNetworks attached to the gateway.
+    GatewayNetwork objects attached to the gateway (each one represents a connection to a Private Network).
     """
 
     upstream_dns_servers: List[str]
     """
-    Override the gateway's default recursive DNS servers.
+    Array of DNS server IP addresses to override the gateway's default recursive DNS servers.
     """
 
     version: Optional[str]
     """
     Version of the running gateway software.
     """
 
     can_upgrade_to: Optional[str]
     """
     Newly available gateway software version that can be updated to.
     """
 
     bastion_enabled: bool
     """
-    Whether SSH bastion is enabled on the gateway.
+    Defines whether SSH bastion is enabled on the gateway.
     """
 
     bastion_port: int
     """
     Port of the SSH bastion.
     """
 
     smtp_enabled: bool
     """
-    Whether SMTP traffic is allowed to pass through the gateway.
+    Defines whether SMTP traffic is allowed to pass through the gateway.
     """
 
     zone: Zone
     """
-    Zone the gateway is available in.
+    Zone of the gateway.
     """
 
 
 @dataclass
 class GatewayNetwork:
     """
     Gateway network.
     """
 
     id: str
     """
-    ID of the connection.
+    ID of the Public Gateway-Private Network connection.
     """
 
     created_at: Optional[datetime]
     """
     Connection creation date.
     """
 
     updated_at: Optional[datetime]
     """
     Connection last modification date.
     """
 
     gateway_id: str
     """
-    ID of the connected gateway.
+    ID of the connected Public Gateway.
     """
 
     private_network_id: str
     """
-    ID of the connected private network.
+    ID of the connected Private Network.
     """
 
     mac_address: Optional[str]
     """
-    MAC address of the gateway in the network (if the gateway is up and running).
+    MAC address of the gateway in the Private Network (if the gateway is up and running).
     """
 
     enable_masquerade: bool
     """
-    Whether the gateway masquerades traffic for this network.
+    Defines whether the gateway masquerades traffic for this Private Network (Dynamic NAT).
     """
 
     status: GatewayNetworkStatus
     """
-    Current status of the gateway network connection.
+    Current status of the Public Gateway's connection to the Private Network.
     """
 
     dhcp: Optional[DHCP]
     """
-    DHCP configuration for the connected private network.
+    DHCP configuration for the connected Private Network.
     """
 
     enable_dhcp: bool
     """
-    Whether DHCP is enabled on the connected Private Network.
+    Defines whether DHCP is enabled on the connected Private Network.
     """
 
     address: Optional[str]
     """
-    Address of the Gateway in CIDR form to use when DHCP is not used.
+    Address of the Gateway (in CIDR form) to use when DHCP is not used.
     """
 
     zone: Zone
     """
-    Zone the connection lives in.
+    Zone of the GatewayNetwork connection.
     """
 
 
 @dataclass
 class GatewayType:
     """
     Gateway type.
     """
 
     name: str
     """
-    Type name.
+    Public Gateway type name.
     """
 
     bandwidth: int
     """
-    Bandwidth, in bps, the gateway has. This is the public bandwidth to the outer internet, and the internal bandwidth to each connected Private Networks.
+    Bandwidth, in bps, of the Public Gateway. This is the public bandwidth to the outer Internet, and the internal bandwidth to each connected Private Networks.
     """
 
     zone: Zone
     """
-    Zone the type is available in.
+    Zone the Public Gateway type is available in.
     """
 
 
 @dataclass
 class IP:
     """
     Ip.
     """
 
     id: str
     """
-    IP ID.
+    IP address ID.
     """
 
     organization_id: str
     """
-    Owning organization.
+    Owning Organization.
     """
 
     project_id: str
     """
-    Owning project.
+    Owning Project.
     """
 
     created_at: Optional[datetime]
     """
-    Configuration creation date.
+    IP address creation date.
     """
 
     updated_at: Optional[datetime]
     """
-    Configuration last modification date.
+    IP address last modification date.
     """
 
     tags: List[str]
     """
-    Tags associated with the IP.
+    Tags associated with the IP address.
     """
 
     address: str
     """
-    The IP itself.
+    The IP address itself.
     """
 
     reverse: Optional[str]
     """
     Reverse domain name for the IP address.
     """
 
     gateway_id: Optional[str]
     """
-    Gateway associated to the IP.
+    Public Gateway associated with the IP address.
     """
 
     zone: Zone
     """
-    Zone this IP is available in.
+    Zone of the IP address.
     """
 
 
 @dataclass
 class ListDHCPEntriesResponse:
     """
     List dhcp entries response.
@@ -534,44 +534,44 @@
     dhcp_entries: List[DHCPEntry]
     """
     DHCP entries in this page.
     """
 
     total_count: int
     """
-    Total DHCP entries matching the filter.
+    Total count of DHCP entries matching the filter.
     """
 
 
 @dataclass
 class ListDHCPsResponse:
     """
     List dhc ps response.
     """
 
     dhcps: List[DHCP]
     """
-    First page of DHCP configs.
+    First page of DHCP configuration objects.
     """
 
     total_count: int
     """
-    Total DHCP configs matching the filter.
+    Total count of DHCP configuration objects matching the filter.
     """
 
 
 @dataclass
 class ListGatewayNetworksResponse:
     """
     List gateway networks response.
     """
 
     gateway_networks: List[GatewayNetwork]
     """
-    GatewayNetworks in this page.
+    GatewayNetworks on this page.
     """
 
     total_count: int
     """
     Total GatewayNetworks count matching the filter.
     """
 
@@ -580,27 +580,27 @@
 class ListGatewayTypesResponse:
     """
     List gateway types response.
     """
 
     types: List[GatewayType]
     """
-    Available types of gateway.
+    Available types of Public Gateway.
     """
 
 
 @dataclass
 class ListGatewaysResponse:
     """
     List gateways response.
     """
 
     gateways: List[Gateway]
     """
-    Gateways in this page.
+    Gateways on this page.
     """
 
     total_count: int
     """
     Total count of gateways matching the filter.
     """
 
@@ -609,106 +609,107 @@
 class ListIPsResponse:
     """
     List i ps response.
     """
 
     ips: List[IP]
     """
-    IPs in this page.
+    IP addresses on this page.
     """
 
     total_count: int
     """
-    Total IP count matching the filter.
+    Total count of IP addresses matching the filter.
     """
 
 
 @dataclass
 class ListPATRulesResponse:
     """
     List pat rules response.
     """
 
     pat_rules: List[PATRule]
     """
-    This page of PAT rules matching the filter.
+    Array of PAT rules matching the filter.
     """
 
     total_count: int
     """
-    Total PAT rules matching the filter.
+    Total count of PAT rules matching the filter.
     """
 
 
 @dataclass
 class PATRule:
     """
     Pat rule.
     """
 
     id: str
     """
-    Rule ID.
+    PAT rule ID.
     """
 
     gateway_id: str
     """
     Gateway the PAT rule applies to.
     """
 
     created_at: Optional[datetime]
     """
-    Rule creation date.
+    PAT rule creation date.
     """
 
     updated_at: Optional[datetime]
     """
-    Rule last modification date.
+    PAT rule last modification date.
     """
 
     public_port: int
     """
     Public port to listen on.
     """
 
     private_ip: str
     """
-    Private IP to forward data to.
+    Private IP address to forward data to.
     """
 
     private_port: int
     """
     Private port to translate to.
     """
 
     protocol: PATRuleProtocol
     """
     Protocol the rule applies to.
     """
 
     zone: Zone
     """
-    Zone this rule is available in.
+    Zone of the PAT rule.
     """
 
 
 @dataclass
 class SetDHCPEntriesRequestEntry:
     """
     Set dhcp entries request. entry.
     """
 
     mac_address: str
     """
+    MAC address to give a static entry to.
     MAC address to give a static entry to. A matching entry will be upgraded to a reservation, and a matching reservation will be updated.
     """
 
     ip_address: str
     """
-    IP address to give to the machine.
+    IP address to give to the device.
     """
 
 
 @dataclass
 class SetDHCPEntriesResponse:
     """
     Set dhcp entries response.
@@ -724,14 +725,15 @@
 class SetPATRulesRequestRule:
     """
     Set pat rules request. rule.
     """
 
     public_port: int
     """
+    Public port to listen on.
     Public port to listen on. Uniquely identifies the rule, and a matching rule will be updated with the new parameters.
     """
 
     private_ip: str
     """
     Private IP to forward data to.
     """
@@ -769,55 +771,55 @@
     order_by: Optional[ListGatewaysRequestOrderBy]
     """
     Order in which to return results.
     """
 
     page: Optional[int]
     """
-    Page number.
+    Page number to return.
     """
 
     page_size: Optional[int]
     """
     Gateways per page.
     """
 
     organization_id: Optional[str]
     """
-    Include only gateways in this organization.
+    Include only gateways in this Organization.
     """
 
     project_id: Optional[str]
     """
-    Include only gateways in this project.
+    Include only gateways in this Project.
     """
 
     name: Optional[str]
     """
-    Filter gateways including this name.
+    Filter for gateways which have this search term in their name.
     """
 
     tags: Optional[List[str]]
     """
-    Filter gateways with these tags.
+    Filter for gateways with these tags.
     """
 
     type_: Optional[str]
     """
-    Filter gateways of this type.
+    Filter for gateways of this type.
     """
 
     status: Optional[GatewayStatus]
     """
-    Filter gateways in this status (unknown for any).
+    Filter for gateways with this current status. Use `unknown` to include all statuses.
     """
 
     private_network_id: Optional[str]
     """
-    Filter gateways attached to this private network.
+    Filter for gateways attached to this Private nNetwork.
     """
 
 
 @dataclass
 class GetGatewayRequest:
     zone: Optional[Zone]
     """
@@ -835,50 +837,50 @@
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     project_id: Optional[str]
     """
-    Project to create the gateway into.
+    Scaleway Project to create the gateway in.
     """
 
     name: Optional[str]
     """
-    Name of the gateway.
+    Name for the gateway.
     """
 
     tags: Optional[List[str]]
     """
     Tags for the gateway.
     """
 
     type_: str
     """
-    Gateway type.
+    Gateway type (commercial offer type).
     """
 
     upstream_dns_servers: Optional[List[str]]
     """
-    Override the gateway's default recursive DNS servers, if DNS features are enabled.
+    Array of DNS server IP addresses to override the gateway's default recursive DNS servers.
     """
 
     ip_id: Optional[str]
     """
-    Attach an existing IP to the gateway.
+    Existing IP address to attach to the gateway.
     """
 
     enable_smtp: bool
     """
-    Allow SMTP traffic to pass through the gateway.
+    Defines whether SMTP traffic should be allowed pass through the gateway.
     """
 
     enable_bastion: bool
     """
-    Enable SSH bastion on the gateway.
+    Defines whether SSH bastion should be enabled the gateway.
     """
 
     bastion_port: Optional[int]
     """
     Port of the SSH bastion.
     """
 
@@ -893,40 +895,40 @@
     gateway_id: str
     """
     ID of the gateway to update.
     """
 
     name: Optional[str]
     """
-    Name fo the gateway.
+    Name for the gateway.
     """
 
     tags: Optional[List[str]]
     """
     Tags for the gateway.
     """
 
     upstream_dns_servers: Optional[List[str]]
     """
-    Override the gateway's default recursive DNS servers, if DNS features are enabled.
+    Array of DNS server IP addresses to override the gateway's default recursive DNS servers.
     """
 
     enable_bastion: Optional[bool]
     """
-    Enable SSH bastion on the gateway.
+    Defines whether SSH bastion should be enabled the gateway.
     """
 
     bastion_port: Optional[int]
     """
     Port of the SSH bastion.
     """
 
     enable_smtp: Optional[bool]
     """
-    Allow SMTP traffic to pass through the gateway.
+    Defines whether SMTP traffic should be allowed to pass through the gateway.
     """
 
 
 @dataclass
 class DeleteGatewayRequest:
     zone: Optional[Zone]
     """
@@ -936,15 +938,15 @@
     gateway_id: str
     """
     ID of the gateway to delete.
     """
 
     cleanup_dhcp: bool
     """
-    Whether to cleanup attached DHCP configurations (if any, and if not attached to another Gateway Network).
+    Defines whether to clean up attached DHCP configurations (if any, and if not attached to another Gateway Network).
     """
 
 
 @dataclass
 class UpgradeGatewayRequest:
     zone: Optional[Zone]
     """
@@ -977,35 +979,35 @@
     page_size: Optional[int]
     """
     GatewayNetworks per page.
     """
 
     gateway_id: Optional[str]
     """
-    Filter by gateway.
+    Filter for GatewayNetworks connected to this gateway.
     """
 
     private_network_id: Optional[str]
     """
-    Filter by private network.
+    Filter for GatewayNetworks connected to this Private Network.
     """
 
     enable_masquerade: Optional[bool]
     """
-    Filter by masquerade enablement.
+    Filter for GatewayNetworks with this `enable_masquerade` setting.
     """
 
     dhcp_id: Optional[str]
     """
-    Filter by DHCP configuration.
+    Filter for GatewayNetworks using this DHCP configuration.
     """
 
     status: Optional[GatewayNetworkStatus]
     """
-    Filter GatewayNetworks by this status (unknown for any).
+    Filter for GatewayNetworks with this current status this status. Use `unknown` to include all statuses.
     """
 
 
 @dataclass
 class GetGatewayNetworkRequest:
     zone: Optional[Zone]
     """
@@ -1023,51 +1025,51 @@
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     gateway_id: str
     """
-    Gateway to connect.
+    Public Gateway to connect.
     """
 
     private_network_id: str
     """
     Private Network to connect.
     """
 
     enable_masquerade: bool
     """
-    Whether to enable masquerade on this network.
+    Defines whether to enable masquerade (dynamic NAT) on this network.
     """
 
     dhcp_id: Optional[str]
     """
-    Existing configuration.
+    ID of an existing DHCP configuration object to use for this GatewayNetwork.
     
     One-of ('ip_config'): at most one of 'dhcp_id', 'dhcp', 'address' could be set.
     """
 
     dhcp: Optional[CreateDHCPRequest]
     """
-    New DHCP configuration.
+    New DHCP configuration object to use for this GatewayNetwork.
     
     One-of ('ip_config'): at most one of 'dhcp_id', 'dhcp', 'address' could be set.
     """
 
     address: Optional[str]
     """
     Static IP address in CIDR format to to use without DHCP.
     
     One-of ('ip_config'): at most one of 'dhcp_id', 'dhcp', 'address' could be set.
     """
 
     enable_dhcp: Optional[bool]
     """
-    Whether to enable DHCP on this Private Network. Defaults to `true` if either `dhcp_id` or `dhcp` short: are present. If set to `true`, requires that either `dhcp_id` or `dhcp` to be present.
+    Defines whether to enable DHCP on this Private Network. Defaults to `true` if either `dhcp_id` or `dhcp` are present. If set to `true`, either `dhcp_id` or `dhcp` must be present.
     """
 
 
 @dataclass
 class UpdateGatewayNetworkRequest:
     zone: Optional[Zone]
     """
@@ -1077,27 +1079,27 @@
     gateway_network_id: str
     """
     ID of the GatewayNetwork to update.
     """
 
     enable_masquerade: Optional[bool]
     """
-    New masquerade enablement.
+    Defines whether to enable masquerade (dynamic NAT) on the GatewayNetwork.
     """
 
     dhcp_id: Optional[str]
     """
-    New DHCP configuration.
+    ID of the new DHCP configuration object to use with this GatewayNetwork.
     
     One-of ('ip_config'): at most one of 'dhcp_id', 'address' could be set.
     """
 
     enable_dhcp: Optional[bool]
     """
-    Whether to enable DHCP on the connected Private Network.
+    Defines whether to enable DHCP on the connected Private Network.
     """
 
     address: Optional[str]
     """
     New static IP address.
     
     One-of ('ip_config'): at most one of 'dhcp_id', 'address' could be set.
@@ -1109,20 +1111,20 @@
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     gateway_network_id: str
     """
-    GatewayNetwork to delete.
+    ID of the GatewayNetwork to delete.
     """
 
     cleanup_dhcp: bool
     """
-    Whether to cleanup the attached DHCP configuration (if any, and if not attached to another gateway_network).
+    Defines whether to clean up attached DHCP configurations (if any, and if not attached to another Gateway Network).
     """
 
 
 @dataclass
 class ListDHCPsRequest:
     zone: Optional[Zone]
     """
@@ -1142,43 +1144,43 @@
     page_size: Optional[int]
     """
     DHCP configurations per page.
     """
 
     organization_id: Optional[str]
     """
-    Include only DHCPs in this organization.
+    Include only DHCP configuration objects in this Organization.
     """
 
     project_id: Optional[str]
     """
-    Include only DHCPs in this project.
+    Include only DHCP configuration objects in this Project.
     """
 
     address: Optional[str]
     """
-    Filter on gateway address.
+    Filter for DHCP configuration objects with this DHCP server IP address (the gateway's address in the Private Network).
     """
 
     has_address: Optional[str]
     """
-    Filter on subnets containing address.
+    Filter for DHCP configuration objects with subnets containing this IP address.
     """
 
 
 @dataclass
 class GetDHCPRequest:
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     dhcp_id: str
     """
-    ID of the DHCP config to fetch.
+    ID of the DHCP configuration to fetch.
     """
 
 
 @dataclass
 class CreateDHCPRequest:
     zone: Optional[Zone]
     """
@@ -1193,65 +1195,65 @@
     subnet: str
     """
     Subnet for the DHCP server.
     """
 
     address: Optional[str]
     """
-    Address of the DHCP server. This will be the gateway's address in the private network. Defaults to the first address of the subnet.
+    IP address of the DHCP server. This will be the gateway's address in the Private Network. Defaults to the first address of the subnet.
     """
 
     pool_low: Optional[str]
     """
-    Low IP (included) of the dynamic address pool. Defaults to the second address of the subnet.
+    Low IP (inclusive) of the dynamic address pool. Must be in the config's subnet. Defaults to the second address of the subnet.
     """
 
     pool_high: Optional[str]
     """
-    High IP (included) of the dynamic address pool. Defaults to the last address of the subnet.
+    High IP (inclusive) of the dynamic address pool. Must be in the config's subnet. Defaults to the last address of the subnet.
     """
 
     enable_dynamic: Optional[bool]
     """
-    Whether to enable dynamic pooling of IPs. By turning the dynamic pool off, only pre-existing DHCP reservations will be handed out. Defaults to true.
+    Defines whether to enable dynamic pooling of IPs. When false, only pre-existing DHCP reservations will be handed out. Defaults to true.
     """
 
     valid_lifetime: Optional[str]
     """
-    For how long, in seconds, will DHCP entries will be valid. Defaults to 1h (3600s).
+    How long DHCP entries will be valid for. Defaults to 1h (3600s).
     """
 
     renew_timer: Optional[str]
     """
-    After how long, in seconds, a renew will be attempted. Must be 30s lower than `rebind_timer`. Defaults to 50m (3000s).
+    After how long a renew will be attempted. Must be 30s lower than `rebind_timer`. Defaults to 50m (3000s).
     """
 
     rebind_timer: Optional[str]
     """
-    After how long, in seconds, a DHCP client will query for a new lease if previous renews fail. Must be 30s lower than `valid_lifetime`. Defaults to 51m (3060s).
+    After how long a DHCP client will query for a new lease if previous renews fail. Must be 30s lower than `valid_lifetime`. Defaults to 51m (3060s).
     """
 
     push_default_route: Optional[bool]
     """
-    Whether the gateway should push a default route to DHCP clients or only hand out IPs. Defaults to true.
+    Defines whether the gateway should push a default route to DHCP clients or only hand out IPs. Defaults to true.
     """
 
     push_dns_server: Optional[bool]
     """
-    Whether the gateway should push custom DNS servers to clients. This allows for instance hostname -> IP resolution. Defaults to true.
+    Defines whether the gateway should push custom DNS servers to clients. This allows for Instance hostname -> IP resolution. Defaults to true.
     """
 
     dns_servers_override: Optional[List[str]]
     """
-    Override the DNS server list pushed to DHCP clients, instead of the gateway itself.
+    Array of DNS server IP addresses used to override the DNS server list pushed to DHCP clients, instead of the gateway itself.
     """
 
     dns_search: Optional[List[str]]
     """
-    Additional DNS search paths.
+    Array of search paths in addition to the pushed DNS configuration.
     """
 
     dns_local_name: Optional[str]
     """
     TLD given to hostnames in the Private Network. Allowed characters are `a-z0-9-.`. Defaults to the slugified Private Network name if created along a GatewayNetwork, or else to `priv`.
     """
 
@@ -1261,93 +1263,93 @@
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     dhcp_id: str
     """
-    DHCP config to update.
+    DHCP configuration to update.
     """
 
     subnet: Optional[str]
     """
     Subnet for the DHCP server.
     """
 
     address: Optional[str]
     """
-    Address of the DHCP server. This will be the gateway's address in the private network.
+    IP address of the DHCP server. This will be the Public Gateway's address in the Private Network. It must be part of config's subnet.
     """
 
     pool_low: Optional[str]
     """
-    Low IP (included) of the dynamic address pool.
+    Low IP (inclusive) of the dynamic address pool. Must be in the config's subnet.
     """
 
     pool_high: Optional[str]
     """
-    High IP (included) of the dynamic address pool.
+    High IP (inclusive) of the dynamic address pool. Must be in the config's subnet.
     """
 
     enable_dynamic: Optional[bool]
     """
-    Whether to enable dynamic pooling of IPs. By turning the dynamic pool off, only pre-existing DHCP reservations will be handed out. Defaults to true.
+    Defines whether to enable dynamic pooling of IPs. When false, only pre-existing DHCP reservations will be handed out. Defaults to true.
     """
 
     valid_lifetime: Optional[str]
     """
-    How long, in seconds, DHCP entries will be valid for.
+    How long DHCP entries will be valid for.
     """
 
     renew_timer: Optional[str]
     """
-    After how long, in seconds, a renew will be attempted. Must be 30s lower than `rebind_timer`.
+    After how long a renew will be attempted. Must be 30s lower than `rebind_timer`.
     """
 
     rebind_timer: Optional[str]
     """
-    After how long, in seconds, a DHCP client will query for a new lease if previous renews fail. Must be 30s lower than `valid_lifetime`.
+    After how long a DHCP client will query for a new lease if previous renews fail. Must be 30s lower than `valid_lifetime`.
     """
 
     push_default_route: Optional[bool]
     """
-    Whether the gateway should push a default route to DHCP clients or only hand out IPs.
+    Defines whether the gateway should push a default route to DHCP clients, or only hand out IPs.
     """
 
     push_dns_server: Optional[bool]
     """
-    Whether the gateway should push custom DNS servers to clients. This allows for instance hostname -> IP resolution.
+    Defines whether the gateway should push custom DNS servers to clients. This allows for instance hostname -> IP resolution.
     """
 
     dns_servers_override: Optional[List[str]]
     """
-    Override the DNS server list pushed to DHCP clients, instead of the gateway itself.
+    Array of DNS server IP addresses used to override the DNS server list pushed to DHCP clients, instead of the gateway itself.
     """
 
     dns_search: Optional[List[str]]
     """
-    Additional DNS search paths.
+    Array of search paths in addition to the pushed DNS configuration.
     """
 
     dns_local_name: Optional[str]
     """
-    TLD given to hostnames in the Private Network. Allowed characters are `a-z0-9-.`.
+    TLD given to hostnames in the Private Networks. If an instance with hostname `foo` gets a lease, and this is set to `bar`, `foo.bar` will resolve. Allowed characters are `a-z0-9-.`.
     """
 
 
 @dataclass
 class DeleteDHCPRequest:
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     dhcp_id: str
     """
-    DHCP config id to delete.
+    DHCP configuration ID to delete.
     """
 
 
 @dataclass
 class ListDHCPEntriesRequest:
     zone: Optional[Zone]
     """
@@ -1367,35 +1369,35 @@
     page_size: Optional[int]
     """
     DHCP entries per page.
     """
 
     gateway_network_id: Optional[str]
     """
-    Filter entries based on the gateway network they are on.
+    Filter for entries on this GatewayNetwork.
     """
 
     mac_address: Optional[str]
     """
-    Filter entries on their MAC address.
+    Filter for entries with this MAC address.
     """
 
     ip_address: Optional[str]
     """
-    Filter entries on their IP address.
+    Filter for entries with this IP address.
     """
 
     hostname: Optional[str]
     """
-    Filter entries on their hostname substring.
+    Filter for entries with this hostname substring.
     """
 
     type_: Optional[DHCPEntryType]
     """
-    Filter entries on their type.
+    Filter for entries of this type.
     """
 
 
 @dataclass
 class GetDHCPEntryRequest:
     zone: Optional[Zone]
     """
@@ -1423,46 +1425,46 @@
     mac_address: str
     """
     MAC address to give a static entry to.
     """
 
     ip_address: str
     """
-    IP address to give to the machine.
+    IP address to give to the device.
     """
 
 
 @dataclass
 class UpdateDHCPEntryRequest:
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     dhcp_entry_id: str
     """
-    DHCP entry ID to update.
+    ID of the DHCP entry to update.
     """
 
     ip_address: Optional[str]
     """
-    New IP address to give to the machine.
+    New IP address to give to the device.
     """
 
 
 @dataclass
 class SetDHCPEntriesRequest:
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     gateway_network_id: str
     """
-    Gateway Network on which to set DHCP reservation list.
+    ID of the Gateway Network on which to set DHCP reservation list.
     """
 
     dhcp_entries: Optional[List[SetDHCPEntriesRequestEntry]]
     """
     New list of DHCP reservations.
     """
 
@@ -1472,15 +1474,15 @@
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     dhcp_entry_id: str
     """
-    DHCP entry ID to delete.
+    ID of the DHCP entry to delete.
     """
 
 
 @dataclass
 class ListPATRulesRequest:
     zone: Optional[Zone]
     """
@@ -1500,51 +1502,51 @@
     page_size: Optional[int]
     """
     PAT rules per page.
     """
 
     gateway_id: Optional[str]
     """
-    Fetch rules for this gateway.
+    Filter for PAT rules on this Gateway.
     """
 
     private_ip: Optional[str]
     """
-    Fetch rules targeting this private ip.
+    Filter for PAT rules targeting this private ip.
     """
 
     protocol: Optional[PATRuleProtocol]
     """
-    Fetch rules for this protocol.
+    Filter for PAT rules with this protocol.
     """
 
 
 @dataclass
 class GetPATRuleRequest:
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     pat_rule_id: str
     """
-    PAT rule to get.
+    ID of the PAT rule to get.
     """
 
 
 @dataclass
 class CreatePATRuleRequest:
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     gateway_id: str
     """
-    Gateway on which to attach the rule to.
+    ID of the Gateway on which to create the rule.
     """
 
     public_port: int
     """
     Public port to listen on.
     """
 
@@ -1569,15 +1571,15 @@
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     pat_rule_id: str
     """
-    PAT rule to update.
+    ID of the PAT rule to update.
     """
 
     public_port: Optional[int]
     """
     Public port to listen on.
     """
 
@@ -1602,15 +1604,15 @@
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     gateway_id: str
     """
-    Gateway on which to set the PAT rules.
+    ID of the gateway on which to set the PAT rules.
     """
 
     pat_rules: List[SetPATRulesRequestRule]
     """
     New list of PAT rules.
     """
 
@@ -1620,15 +1622,15 @@
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     pat_rule_id: str
     """
-    PAT rule to delete.
+    ID of the PAT rule to delete.
     """
 
 
 @dataclass
 class ListGatewayTypesRequest:
     zone: Optional[Zone]
     """
@@ -1651,119 +1653,119 @@
     page: Optional[int]
     """
     Page number.
     """
 
     page_size: Optional[int]
     """
-    IPs per page.
+    IP addresses per page.
     """
 
     organization_id: Optional[str]
     """
-    Include only IPs in this organization.
+    Filter for IP addresses in this Organization.
     """
 
     project_id: Optional[str]
     """
-    Include only IPs in this project.
+    Filter for IP addresses in this Project.
     """
 
     tags: Optional[List[str]]
     """
-    Filter IPs with these tags.
+    Filter for IP addresses with these tags.
     """
 
     reverse: Optional[str]
     """
-    Filter by reverse containing this string.
+    Filter for IP addresses that have a reverse containing this string.
     """
 
     is_free: Optional[bool]
     """
-    Filter whether the IP is attached to a gateway or not.
+    Filter based on whether the IP is attached to a gateway or not.
     """
 
 
 @dataclass
 class GetIPRequest:
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     ip_id: str
     """
-    ID of the IP to get.
+    ID of the IP address to get.
     """
 
 
 @dataclass
 class CreateIPRequest:
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     project_id: Optional[str]
     """
-    Project to create the IP into.
+    Project to create the IP address in.
     """
 
     tags: Optional[List[str]]
     """
-    Tags to give to the IP.
+    Tags to give to the IP address.
     """
 
 
 @dataclass
 class UpdateIPRequest:
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     ip_id: str
     """
-    ID of the IP to update.
+    ID of the IP address to update.
     """
 
     tags: Optional[List[str]]
     """
-    Tags to give to the IP.
+    Tags to give to the IP address.
     """
 
     reverse: Optional[str]
     """
-    Reverse to set on the IP. Empty string to unset.
+    Reverse to set on the address. Empty string to unset.
     """
 
     gateway_id: Optional[str]
     """
-    Gateway to attach the IP to. Empty string to detach.
+    Gateway to attach the IP address to. Empty string to detach.
     """
 
 
 @dataclass
 class DeleteIPRequest:
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     ip_id: str
     """
-    ID of the IP to delete.
+    ID of the IP address to delete.
     """
 
 
 @dataclass
 class RefreshSSHKeysRequest:
     zone: Optional[Zone]
     """
     Zone to target. If none is passed will use default zone from the config.
     """
 
     gateway_id: str
     """
-    ID of the gateway that needs fresh ssh keys.
+    ID of the gateway to refresh SSH keys on.
     """
```

### Comparing `scaleway_async-0.9.0/scaleway_async/webhosting/v1alpha1/__init__.py` & `scaleway_async-1.0.0/scaleway_async/webhosting/v1alpha1/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -4,14 +4,15 @@
 from .types import DnsRecordType
 from .types import DnsRecordsStatus
 from .types import HostingDnsStatus
 from .types import HostingStatus
 from .types import ListHostingsRequestOrderBy
 from .types import ListOffersRequestOrderBy
 from .types import NameserverStatus
+from .types import OfferQuotaWarning
 from .types import DnsRecord
 from .types import DnsRecords
 from .types import Hosting
 from .types import HostingCpanelUrls
 from .types import HostingOption
 from .types import ListHostingsResponse
 from .types import ListOffersResponse
@@ -26,14 +27,15 @@
     "DnsRecordType",
     "DnsRecordsStatus",
     "HostingDnsStatus",
     "HostingStatus",
     "ListHostingsRequestOrderBy",
     "ListOffersRequestOrderBy",
     "NameserverStatus",
+    "OfferQuotaWarning",
     "DnsRecord",
     "DnsRecords",
     "Hosting",
     "HostingCpanelUrls",
     "HostingOption",
     "ListHostingsResponse",
     "ListOffersResponse",
```

### Comparing `scaleway_async-0.9.0/scaleway_async/webhosting/v1alpha1/api.py` & `scaleway_async-1.0.0/scaleway_async/webhosting/v1alpha1/api.py`

 * *Files 26% similar despite different names*

```diff
@@ -35,37 +35,40 @@
     unmarshal_ListHostingsResponse,
     unmarshal_ListOffersResponse,
 )
 
 
 class WebhostingV1Alpha1API(API):
     """
-    Webhosting API.
+    Web Hosting API.
+
+    Web Hosting API.
     """
 
     async def create_hosting(
         self,
         *,
         offer_id: str,
         domain: str,
         region: Optional[Region] = None,
         project_id: Optional[str] = None,
         email: Optional[str] = None,
         tags: Optional[List[str]] = None,
         option_ids: Optional[List[str]] = None,
     ) -> Hosting:
         """
-        Create a hosting
+        Order a Web Hosting plan.
+        Order a Web Hosting plan, specifying the offer type required via the `offer_id` parameter.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param offer_id: ID of the selected offer for the hosting.
-        :param project_id: Project ID of the hosting.
-        :param email: Contact email of the client for the hosting.
-        :param tags: The tags of the hosting.
-        :param domain: The domain name of the hosting.
-        :param option_ids: IDs of the selected options for the hosting.
+        :param offer_id: ID of the selected offer for the Web Hosting plan.
+        :param project_id: ID of the Scaleway Project in which to create the Web Hosting plan.
+        :param email: Contact email for the Web Hosting client.
+        :param tags: List of tags for the Web Hosting plan.
+        :param domain: Domain name to link to the Web Hosting plan. You must already own this domain name, and have completed the DNS validation process beforehand.
+        :param option_ids: IDs of any selected additional options for the Web Hosting plan.
         :return: :class:`Hosting <Hosting>`
 
         Usage:
         ::
 
             result = await api.create_hosting(
                 offer_id="example",
@@ -107,24 +110,25 @@
         tags: Optional[List[str]] = None,
         statuses: Optional[List[HostingStatus]] = None,
         domain: Optional[str] = None,
         project_id: Optional[str] = None,
         organization_id: Optional[str] = None,
     ) -> ListHostingsResponse:
         """
-        List all hostings
+        List all Web Hosting plans.
+        List all of your existing Web Hosting plans. Various filters are available to limit the results, including filtering by domain, status, tag and Project ID.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param page: A positive integer to choose the page to return.
-        :param page_size: A positive integer lower or equal to 100 to select the number of items to return.
-        :param order_by: Define the order of the returned hostings.
-        :param tags: Return hostings with these tags.
-        :param statuses: Return hostings with these statuses.
-        :param domain: Return hostings with this domain.
-        :param project_id: Return hostings from this project ID.
-        :param organization_id: Return hostings from this organization ID.
+        :param page: Page number to return, from the paginated results (must be a positive integer).
+        :param page_size: Number of Web Hosting plans to return (must be a positive integer lower or equal to 100).
+        :param order_by: Sort order for Web Hosting plans in the response.
+        :param tags: Tags to filter for, only Web Hosting plans with matching tags will be returned.
+        :param statuses: Statuses to filter for, only Web Hosting plans with matching statuses will be returned.
+        :param domain: Domain to filter for, only Web Hosting plans associated with this domain will be returned.
+        :param project_id: Project ID to filter for, only Web Hosting plans from this Project will be returned.
+        :param organization_id: Organization ID to filter for, only Web Hosting plans from this Organization will be returned.
         :return: :class:`ListHostingsResponse <ListHostingsResponse>`
 
         Usage:
         ::
 
             result = await api.list_hostings()
         """
@@ -162,24 +166,25 @@
         tags: Optional[List[str]] = None,
         statuses: Optional[List[HostingStatus]] = None,
         domain: Optional[str] = None,
         project_id: Optional[str] = None,
         organization_id: Optional[str] = None,
     ) -> List[Hosting]:
         """
-        List all hostings
+        List all Web Hosting plans.
+        List all of your existing Web Hosting plans. Various filters are available to limit the results, including filtering by domain, status, tag and Project ID.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param page: A positive integer to choose the page to return.
-        :param page_size: A positive integer lower or equal to 100 to select the number of items to return.
-        :param order_by: Define the order of the returned hostings.
-        :param tags: Return hostings with these tags.
-        :param statuses: Return hostings with these statuses.
-        :param domain: Return hostings with this domain.
-        :param project_id: Return hostings from this project ID.
-        :param organization_id: Return hostings from this organization ID.
+        :param page: Page number to return, from the paginated results (must be a positive integer).
+        :param page_size: Number of Web Hosting plans to return (must be a positive integer lower or equal to 100).
+        :param order_by: Sort order for Web Hosting plans in the response.
+        :param tags: Tags to filter for, only Web Hosting plans with matching tags will be returned.
+        :param statuses: Statuses to filter for, only Web Hosting plans with matching statuses will be returned.
+        :param domain: Domain to filter for, only Web Hosting plans associated with this domain will be returned.
+        :param project_id: Project ID to filter for, only Web Hosting plans from this Project will be returned.
+        :param organization_id: Organization ID to filter for, only Web Hosting plans from this Organization will be returned.
         :return: :class:`List[ListHostingsResponse] <List[ListHostingsResponse]>`
 
         Usage:
         ::
 
             result = await api.list_hostings_all()
         """
@@ -204,15 +209,16 @@
     async def get_hosting(
         self,
         *,
         hosting_id: str,
         region: Optional[Region] = None,
     ) -> Hosting:
         """
-        Get the details of a Hosting with the given ID.
+        Get a Web Hosting plan.
+        Get the details of one of your existing Web Hosting plans, specified by its `hosting_id`.
         :param region: Region to target. If none is passed will use default region from the config.
         :param hosting_id: Hosting ID.
         :return: :class:`Hosting <Hosting>`
 
         Usage:
         ::
 
@@ -274,21 +280,22 @@
         region: Optional[Region] = None,
         email: Optional[str] = None,
         tags: Optional[List[str]] = None,
         option_ids: Optional[List[str]] = None,
         offer_id: Optional[str] = None,
     ) -> Hosting:
         """
-        Update a hosting
+        Update a Web Hosting plan.
+        Update the details of one of your existing Web Hosting plans, specified by its `hosting_id`. You can update parameters including the contact email address, tags, options and offer.
         :param region: Region to target. If none is passed will use default region from the config.
         :param hosting_id: Hosting ID.
-        :param email: New contact email for the hosting.
-        :param tags: New tags for the hosting.
-        :param option_ids: New options IDs for the hosting.
-        :param offer_id: New offer ID for the hosting.
+        :param email: New contact email for the Web Hosting plan.
+        :param tags: New tags for the Web Hosting plan.
+        :param option_ids: IDs of the new options for the Web Hosting plan.
+        :param offer_id: ID of the new offer for the Web Hosting plan.
         :return: :class:`Hosting <Hosting>`
 
         Usage:
         ::
 
             result = await api.update_hosting(hosting_id="example")
         """
@@ -320,15 +327,16 @@
     async def delete_hosting(
         self,
         *,
         hosting_id: str,
         region: Optional[Region] = None,
     ) -> Hosting:
         """
-        Delete a hosting with the given ID.
+        Delete a Web Hosting plan.
+        Delete a Web Hosting plan, specified by its `hosting_id`. Note that deletion is not immediate: it will take place at the end of the calendar month, after which time your Web Hosting plan and all its data (files and emails) will be irreversibly lost.
         :param region: Region to target. If none is passed will use default region from the config.
         :param hosting_id: Hosting ID.
         :return: :class:`Hosting <Hosting>`
 
         Usage:
         ::
 
@@ -351,15 +359,16 @@
     async def restore_hosting(
         self,
         *,
         hosting_id: str,
         region: Optional[Region] = None,
     ) -> Hosting:
         """
-        Restore a hosting with the given ID.
+        Restore a Web Hosting plan.
+        When you [delete a Web Hosting plan](#path-hostings-delete-a-hosting), definitive deletion does not take place until the end of the calendar month. In the time between initiating the deletion, and definitive deletion at the end of the month, you can choose to **restore** the Web Hosting plan, using this endpoint and specifying its `hosting_id`.
         :param region: Region to target. If none is passed will use default region from the config.
         :param hosting_id: Hosting ID.
         :return: :class:`Hosting <Hosting>`
 
         Usage:
         ::
 
@@ -382,17 +391,18 @@
     async def get_domain_dns_records(
         self,
         *,
         domain: str,
         region: Optional[Region] = None,
     ) -> DnsRecords:
         """
-        Get the DNS records of a specified domain.
+        Get DNS records.
+        Get the set of DNS records of a specified domain associated with a Web Hosting plan.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param domain: Domain associated to the DNS records.
+        :param domain: Domain associated with the DNS records.
         :return: :class:`DnsRecords <DnsRecords>`
 
         Usage:
         ::
 
             result = await api.get_domain_dns_records(domain="example")
         """
@@ -413,21 +423,24 @@
     async def list_offers(
         self,
         *,
         order_by: ListOffersRequestOrderBy,
         without_options: bool,
         only_options: bool,
         region: Optional[Region] = None,
+        hosting_id: Optional[str] = None,
     ) -> ListOffersResponse:
         """
-        List all offers
+        List all offers.
+        List the different Web Hosting offers, and their options, available to order from Scaleway.
         :param region: Region to target. If none is passed will use default region from the config.
-        :param order_by: Define the order of the returned hostings.
-        :param without_options: Select only offers, no options.
-        :param only_options: Select only options.
+        :param order_by: Sort order of offers in the response.
+        :param without_options: Defines whether the response should consist of offers only, without options.
+        :param only_options: Defines whether the response should consist of options only, without offers.
+        :param hosting_id: ID of a Web Hosting plan, to check compatibility with returned offers (in case of wanting to update the plan).
         :return: :class:`ListOffersResponse <ListOffersResponse>`
 
         Usage:
         ::
 
             result = await api.list_offers(
                 order_by=price_asc,
@@ -440,14 +453,15 @@
             "region", region or self.client.default_region
         )
 
         res = self._request(
             "GET",
             f"/webhosting/v1alpha1/regions/{param_region}/offers",
             params={
+                "hosting_id": hosting_id,
                 "only_options": only_options,
                 "order_by": order_by,
                 "without_options": without_options,
             },
         )
 
         self._throw_on_error(res)
```

### Comparing `scaleway_async-0.9.0/scaleway_async/webhosting/v1alpha1/marshalling.py` & `scaleway_async-1.0.0/scaleway_async/registry/v1/marshalling.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,309 +1,267 @@
 # This file was automatically generated. DO NOT EDIT.
 # If you have any remark or suggestion do not hesitate to open an issue.
 
 from typing import Any, Dict
 
 from scaleway_core.profile import ProfileDefaults
-from scaleway_core.bridge import (
-    unmarshal_Money,
+from scaleway_core.utils import (
+    OneOfPossibility,
+    resolve_one_of,
 )
 from dateutil import parser
 from .types import (
-    DnsRecord,
-    DnsRecords,
-    Hosting,
-    HostingCpanelUrls,
-    HostingOption,
-    ListHostingsResponse,
-    ListOffersResponse,
-    Nameserver,
-    Offer,
-    OfferProduct,
-    CreateHostingRequest,
-    UpdateHostingRequest,
+    ImageVisibility,
+    Image,
+    ListImagesResponse,
+    ListNamespacesResponse,
+    ListTagsResponse,
+    Namespace,
+    Tag,
+    CreateNamespaceRequest,
+    UpdateNamespaceRequest,
+    UpdateImageRequest,
 )
 
 
-def unmarshal_HostingCpanelUrls(data: Any) -> HostingCpanelUrls:
+def unmarshal_Image(data: Any) -> Image:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'HostingCpanelUrls' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Image' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("dashboard")
-    args["dashboard"] = field
-
-    field = data.get("webmail")
-    args["webmail"] = field
-
-    return HostingCpanelUrls(**args)
-
-
-def unmarshal_HostingOption(data: Any) -> HostingOption:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'HostingOption' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
+    field = data.get("created_at", None)
+    args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("name")
+    field = data.get("name", None)
     args["name"] = field
 
-    return HostingOption(**args)
-
-
-def unmarshal_OfferProduct(data: Any) -> OfferProduct:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'OfferProduct' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
-
-    field = data.get("databases_quota")
-    args["databases_quota"] = field
-
-    field = data.get("email_accounts_quota")
-    args["email_accounts_quota"] = field
-
-    field = data.get("email_storage_quota")
-    args["email_storage_quota"] = field
+    field = data.get("namespace_id", None)
+    args["namespace_id"] = field
 
-    field = data.get("hosting_storage_quota")
-    args["hosting_storage_quota"] = field
+    field = data.get("size", None)
+    args["size"] = field
 
-    field = data.get("name")
-    args["name"] = field
-
-    field = data.get("option")
-    args["option"] = field
-
-    field = data.get("ram")
-    args["ram"] = field
-
-    field = data.get("support_included")
-    args["support_included"] = field
-
-    field = data.get("v_cpu")
-    args["v_cpu"] = field
-
-    return OfferProduct(**args)
-
-
-def unmarshal_DnsRecord(data: Any) -> DnsRecord:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'DnsRecord' failed as data isn't a dictionary."
-        )
-
-    args: Dict[str, Any] = {}
-
-    field = data.get("name")
-    args["name"] = field
-
-    field = data.get("priority")
-    args["priority"] = field
-
-    field = data.get("status")
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("ttl")
-    args["ttl"] = field
+    field = data.get("status_message", None)
+    args["status_message"] = field
 
-    field = data.get("type_")
-    args["type_"] = field
+    field = data.get("tags", None)
+    args["tags"] = field
 
-    field = data.get("value")
-    args["value"] = field
+    field = data.get("updated_at", None)
+    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    return DnsRecord(**args)
+    field = data.get("visibility", None)
+    args["visibility"] = field
 
+    return Image(**args)
 
-def unmarshal_Hosting(data: Any) -> Hosting:
+
+def unmarshal_Namespace(data: Any) -> Namespace:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Hosting' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Namespace' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("cpanel_urls")
-    args["cpanel_urls"] = (
-        unmarshal_HostingCpanelUrls(field) if field is not None else None
-    )
-
-    field = data.get("created_at")
+    field = data.get("created_at", None)
     args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("dns_status")
-    args["dns_status"] = field
+    field = data.get("description", None)
+    args["description"] = field
 
-    field = data.get("domain")
-    args["domain"] = field
+    field = data.get("endpoint", None)
+    args["endpoint"] = field
 
-    field = data.get("id")
+    field = data.get("id", None)
     args["id"] = field
 
-    field = data.get("offer_id")
-    args["offer_id"] = field
+    field = data.get("image_count", None)
+    args["image_count"] = field
 
-    field = data.get("offer_name")
-    args["offer_name"] = field
+    field = data.get("is_public", None)
+    args["is_public"] = field
 
-    field = data.get("options")
-    args["options"] = [unmarshal_HostingOption(v) for v in data["options"]]
+    field = data.get("name", None)
+    args["name"] = field
 
-    field = data.get("organization_id")
+    field = data.get("organization_id", None)
     args["organization_id"] = field
 
-    field = data.get("platform_hostname")
-    args["platform_hostname"] = field
-
-    field = data.get("platform_number")
-    args["platform_number"] = field
-
-    field = data.get("project_id")
+    field = data.get("project_id", None)
     args["project_id"] = field
 
-    field = data.get("region")
+    field = data.get("region", None)
     args["region"] = field
 
-    field = data.get("status")
+    field = data.get("size", None)
+    args["size"] = field
+
+    field = data.get("status", None)
     args["status"] = field
 
-    field = data.get("tags")
-    args["tags"] = field
+    field = data.get("status_message", None)
+    args["status_message"] = field
 
-    field = data.get("updated_at")
+    field = data.get("updated_at", None)
     args["updated_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("username")
-    args["username"] = field
+    return Namespace(**args)
 
-    return Hosting(**args)
 
-
-def unmarshal_Nameserver(data: Any) -> Nameserver:
+def unmarshal_Tag(data: Any) -> Tag:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Nameserver' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'Tag' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("hostname")
-    args["hostname"] = field
+    field = data.get("created_at", None)
+    args["created_at"] = parser.isoparse(field) if type(field) is str else field
 
-    field = data.get("is_default")
-    args["is_default"] = field
+    field = data.get("digest", None)
+    args["digest"] = field
 
-    field = data.get("status")
+    field = data.get("id", None)
+    args["id"] = field
+
+    field = data.get("image_id", None)
+    args["image_id"] = field
+
+    field = data.get("name", None)
+    args["name"] = field
+
+    field = data.get("status", None)
     args["status"] = field
 
-    return Nameserver(**args)
+    field = data.get("updated_at", None)
+    args["updated_at"] = parser.isoparse(field) if type(field) is str else field
+
+    return Tag(**args)
 
 
-def unmarshal_Offer(data: Any) -> Offer:
+def unmarshal_ListImagesResponse(data: Any) -> ListImagesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'Offer' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListImagesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("billing_operation_path")
-    args["billing_operation_path"] = field
-
-    field = data.get("id")
-    args["id"] = field
-
-    field = data.get("price")
-    args["price"] = unmarshal_Money(field) if field is not None else None
+    field = data.get("images", None)
+    args["images"] = [unmarshal_Image(v) for v in field] if field is not None else None
 
-    field = data.get("product")
-    args["product"] = unmarshal_OfferProduct(field) if field is not None else None
+    field = data.get("total_count", None)
+    args["total_count"] = field
 
-    return Offer(**args)
+    return ListImagesResponse(**args)
 
 
-def unmarshal_DnsRecords(data: Any) -> DnsRecords:
+def unmarshal_ListNamespacesResponse(data: Any) -> ListNamespacesResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'DnsRecords' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListNamespacesResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("name_servers")
-    args["name_servers"] = [unmarshal_Nameserver(v) for v in data["name_servers"]]
-
-    field = data.get("records")
-    args["records"] = [unmarshal_DnsRecord(v) for v in data["records"]]
+    field = data.get("namespaces", None)
+    args["namespaces"] = (
+        [unmarshal_Namespace(v) for v in field] if field is not None else None
+    )
 
-    field = data.get("status")
-    args["status"] = field
+    field = data.get("total_count", None)
+    args["total_count"] = field
 
-    return DnsRecords(**args)
+    return ListNamespacesResponse(**args)
 
 
-def unmarshal_ListHostingsResponse(data: Any) -> ListHostingsResponse:
+def unmarshal_ListTagsResponse(data: Any) -> ListTagsResponse:
     if type(data) is not dict:
         raise TypeError(
-            f"Unmarshalling the type 'ListHostingsResponse' failed as data isn't a dictionary."
+            f"Unmarshalling the type 'ListTagsResponse' failed as data isn't a dictionary."
         )
 
     args: Dict[str, Any] = {}
 
-    field = data.get("hostings")
-    args["hostings"] = [unmarshal_Hosting(v) for v in data["hostings"]]
+    field = data.get("tags", None)
+    args["tags"] = [unmarshal_Tag(v) for v in field] if field is not None else None
 
-    field = data.get("total_count")
+    field = data.get("total_count", None)
     args["total_count"] = field
 
-    return ListHostingsResponse(**args)
+    return ListTagsResponse(**args)
 
 
-def unmarshal_ListOffersResponse(data: Any) -> ListOffersResponse:
-    if type(data) is not dict:
-        raise TypeError(
-            f"Unmarshalling the type 'ListOffersResponse' failed as data isn't a dictionary."
-        )
+def marshal_CreateNamespaceRequest(
+    request: CreateNamespaceRequest,
+    defaults: ProfileDefaults,
+) -> Dict[str, Any]:
+    output: Dict[str, Any] = {}
+    output.update(
+        resolve_one_of(
+            [
+                OneOfPossibility(
+                    "project_id",
+                    request.project_id or defaults.default_project_id
+                    if request.project_id is not None
+                    else None,
+                    defaults.default_project_id,
+                ),
+                OneOfPossibility(
+                    "organization_id",
+                    request.organization_id or defaults.default_organization_id
+                    if request.organization_id is not None
+                    else None,
+                    defaults.default_organization_id,
+                ),
+            ]
+        ),
+    )
 
-    args: Dict[str, Any] = {}
+    if request.description is not None:
+        output["description"] = request.description
 
-    field = data.get("offers")
-    args["offers"] = [unmarshal_Offer(v) for v in data["offers"]]
+    if request.is_public is not None:
+        output["is_public"] = request.is_public
 
-    return ListOffersResponse(**args)
+    if request.name is not None:
+        output["name"] = request.name
 
+    return output
 
-def marshal_CreateHostingRequest(
-    request: CreateHostingRequest,
+
+def marshal_UpdateImageRequest(
+    request: UpdateImageRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "domain": request.domain,
-        "email": request.email,
-        "offer_id": request.offer_id,
-        "option_ids": request.option_ids,
-        "project_id": request.project_id or defaults.default_project_id,
-        "tags": request.tags,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.visibility is not None:
+        output["visibility"] = ImageVisibility(request.visibility)
 
+    return output
 
-def marshal_UpdateHostingRequest(
-    request: UpdateHostingRequest,
+
+def marshal_UpdateNamespaceRequest(
+    request: UpdateNamespaceRequest,
     defaults: ProfileDefaults,
 ) -> Dict[str, Any]:
-    return {
-        "email": request.email,
-        "offer_id": request.offer_id,
-        "option_ids": request.option_ids,
-        "tags": request.tags,
-    }
+    output: Dict[str, Any] = {}
+
+    if request.description is not None:
+        output["description"] = request.description
+
+    if request.is_public is not None:
+        output["is_public"] = request.is_public
+
+    return output
```

