# Comparing `tmp/stixorm-0.1.3.tar.gz` & `tmp/stixorm-0.1.9.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "stixorm-0.1.3.tar", max compression
+gzip compressed data, was "stixorm-0.1.9.tar", max compression
```

## Comparing `stixorm-0.1.3.tar` & `stixorm-0.1.9.tar`

### file list

```diff
@@ -1,194 +1,194 @@
--rw-r--r--   0        0        0    34523 2023-08-07 00:14:08.411316 stixorm-0.1.3/LICENSE
--rw-r--r--   0        0        0     5405 2023-08-07 00:14:08.411316 stixorm-0.1.3/README.md
--rw-r--r--   0        0        0     1098 2023-08-07 00:14:35.275759 stixorm-0.1.3/pyproject.toml
--rw-r--r--   0        0        0      131 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/__init__.py
--rw-r--r--   0        0        0        0 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/__init__.py
--rw-r--r--   0        0        0     7943 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/authorise.py
--rw-r--r--   0        0        0        0 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/__init__.py
--rw-r--r--   0        0        0     1234 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/__init__.py
--rw-r--r--   0        0        0      275 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/base/attack_base.json
--rw-r--r--   0        0        0    36573 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/classes.py
--rw-r--r--   0        0        0      288 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/data/attack-campaign.json
--rw-r--r--   0        0        0      290 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/data/attack-group.json
--rw-r--r--   0        0        0      185 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/data/attack-identity.json
--rw-r--r--   0        0        0        4 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/data/attack-relation.json
--rw-r--r--   0        0        0       78 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/data/collection.json
--rw-r--r--   0        0        0       85 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/data/data-component.json
--rw-r--r--   0        0        0      156 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/data/data-source.json
--rw-r--r--   0        0        0       84 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/data/matrix.json
--rw-r--r--   0        0        0       74 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/data/mitigation.json
--rw-r--r--   0        0        0      517 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/data/software-malware.json
--rw-r--r--   0        0        0      250 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/data/software-tool.json
--rw-r--r--   0        0        0      769 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/data/sub-technique.json
--rw-r--r--   0        0        0       96 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/data/tactic.json
--rw-r--r--   0        0        0      835 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/data/technique.json
--rw-r--r--   0        0        0       29 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/mappings/is_list_meta.json
--rw-r--r--   0        0        0        4 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/mappings/is_list_sco.json
--rw-r--r--   0        0        0     1523 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/mappings/is_list_sdo.json
--rw-r--r--   0        0        0       71 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/mappings/is_list_sro.json
--rw-r--r--   0        0        0       26 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/mappings/is_list_sub_objects.json
--rw-r--r--   0        0        0     7685 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/mappings/object_conversion.json
--rw-r--r--   0        0        0      573 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/mappings/relations_embedded.json
--rw-r--r--   0        0        0      164 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/mappings/relations_list_of_objects.json
--rw-r--r--   0        0        0      442 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/mappings/relations_sro_roles.json
--rw-r--r--   0        0        0      846 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/schema/cti-attack-rules.tql
--rw-r--r--   0        0        0    13174 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/schema/cti-attack.tql
--rw-r--r--   0        0        0       70 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/attack/sub_objects/object-version.json
--rw-r--r--   0        0        0      556 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/cacao/__init__.py
--rw-r--r--   0        0        0      752 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/cacao/classes.py
--rw-r--r--   0        0        0      571 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/cacao/mappings/is_list_sub_objects.json
--rw-r--r--   0        0        0      447 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/kestrel/__init__.py
--rw-r--r--   0        0        0      752 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/kestrel/classes.py
--rw-r--r--   0        0        0      571 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/kestrel/mappings/is_list_sub_objects.json
--rw-r--r--   0        0        0     1624 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/os_threat/__init__.py
--rw-r--r--   0        0        0    21738 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/os_threat/classes.py
--rw-r--r--   0        0        0      486 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/os_threat/data/event.json
--rw-r--r--   0        0        0      131 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/os_threat/data/evidence.json
--rw-r--r--   0        0        0      106 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/os_threat/data/feed.json
--rw-r--r--   0        0        0      107 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/os_threat/data/feeds.json
--rw-r--r--   0        0        0      375 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/os_threat/data/impact.json
--rw-r--r--   0        0        0      481 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/os_threat/data/task.json
--rw-r--r--   0        0        0      325 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/os_threat/mappings/is_list_sdo.json
--rw-r--r--   0        0        0      488 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/os_threat/mappings/is_list_sub_objects.json
--rw-r--r--   0        0        0     4854 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/os_threat/mappings/object_conversion.json
--rw-r--r--   0        0        0     1779 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/os_threat/mappings/relations_embedded.json
--rw-r--r--   0        0        0     2491 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/os_threat/mappings/relations_extensions_and_objects.json
--rw-r--r--   0        0        0      320 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/os_threat/mappings/relations_list_of_objects.json
--rw-r--r--   0        0        0     1529 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/os_threat/mappings/relations_sro_roles.json
--rw-r--r--   0        0        0      829 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/os_threat/schema/cti-os-hunt.tql
--rw-r--r--   0        0        0    17826 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/os_threat/schema/cti-os-threat.tql
--rw-r--r--   0        0        0       53 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/os_threat/sub_objects/availability.json
--rw-r--r--   0        0        0      142 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/os_threat/sub_objects/confidentiality.json
--rw-r--r--   0        0        0      192 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/os_threat/sub_objects/entity-count-object.json
--rw-r--r--   0        0        0       41 2023-08-07 00:14:08.451317 stixorm-0.1.3/stixorm/module/definitions/os_threat/sub_objects/extension-definition--2074a052-8be4-4932-849e-f5e7798e0030.json
--rw-r--r--   0        0        0       41 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/os_threat/sub_objects/extension-definition--4ca6de00-5b0d-45ef-a1dc-ea7279ea910e.json
--rw-r--r--   0        0        0       41 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/os_threat/sub_objects/extension-definition--7cc33dd6-f6a1-489b-98ea-522d351d71b9.json
--rw-r--r--   0        0        0       41 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/os_threat/sub_objects/extension-definition--7ff5b5a5-a342-417e-9c0d-339561d9d78a.json
--rw-r--r--   0        0        0      452 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/os_threat/sub_objects/extension-definition--ef765651-680c-498d-9894-99799f2fa126.json
--rw-r--r--   0        0        0       36 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/os_threat/sub_objects/external.json
--rw-r--r--   0        0        0       81 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/os_threat/sub_objects/incident-score-object.json
--rw-r--r--   0        0        0      144 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/os_threat/sub_objects/integrity.json
--rw-r--r--   0        0        0      240 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/os_threat/sub_objects/monetary.json
--rw-r--r--   0        0        0       66 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/os_threat/sub_objects/physical.json
--rw-r--r--   0        0        0       90 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/os_threat/sub_objects/state-change-object.json
--rw-r--r--   0        0        0       75 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/os_threat/sub_objects/threat-sub-object.json
--rw-r--r--   0        0        0       49 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/os_threat/sub_objects/traceability.json
--rw-r--r--   0        0        0     8020 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/property_definitions.py
--rw-r--r--   0        0        0     3528 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/__init__.py
--rw-r--r--   0        0        0      328 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/base/base_sco.json
--rw-r--r--   0        0        0      352 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/base/base_sdo.json
--rw-r--r--   0        0        0      352 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/base/base_sro.json
--rw-r--r--   0        0        0     8561 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/classes.py
--rw-r--r--   0        0        0      187 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/artifact.json
--rw-r--r--   0        0        0      103 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/attack-pattern.json
--rw-r--r--   0        0        0       50 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/autonomous-system.json
--rw-r--r--   0        0        0      162 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/campaign.json
--rw-r--r--   0        0        0       74 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/course-of-action.json
--rw-r--r--   0        0        0      115 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/directory.json
--rw-r--r--   0        0        0       47 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/domain-name.json
--rw-r--r--   0        0        0       85 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/email-addr.json
--rw-r--r--   0        0        0      369 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/email-message.json
--rw-r--r--   0        0        0      284 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/file.json
--rw-r--r--   0        0        0       87 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/grouping.json
--rw-r--r--   0        0        0      185 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/identity.json
--rw-r--r--   0        0        0       46 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/incident.json
--rw-r--r--   0        0        0      258 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/indicator.json
--rw-r--r--   0        0        0      195 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/infrastructure.json
--rw-r--r--   0        0        0      290 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/intrusion-set.json
--rw-r--r--   0        0        0       70 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/ipv4-addr.json
--rw-r--r--   0        0        0       70 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/ipv6-addr.json
--rw-r--r--   0        0        0      292 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/location.json
--rw-r--r--   0        0        0       23 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/mac-addr.json
--rw-r--r--   0        0        0      539 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/malware-analysis.json
--rw-r--r--   0        0        0      433 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/malware.json
--rw-r--r--   0        0        0       93 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/marking-definition.json
--rw-r--r--   0        0        0       16 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/mutex.json
--rw-r--r--   0        0        0      441 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/network-traffic.json
--rw-r--r--   0        0        0       92 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/note.json
--rw-r--r--   0        0        0      137 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/observed-data.json
--rw-r--r--   0        0        0       98 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/opinion.json
--rw-r--r--   0        0        0      254 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/process.json
--rw-r--r--   0        0        0      176 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/relationship.json
--rw-r--r--   0        0        0      122 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/report.json
--rw-r--r--   0        0        0      226 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/sighting.json
--rw-r--r--   0        0        0      113 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/software.json
--rw-r--r--   0        0        0      447 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/threat-actor.json
--rw-r--r--   0        0        0      166 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/tool.json
--rw-r--r--   0        0        0       23 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/url.json
--rw-r--r--   0        0        0      520 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/user-account.json
--rw-r--r--   0        0        0       46 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/vulnerability.json
--rw-r--r--   0        0        0      135 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/windows-registry-key.json
--rw-r--r--   0        0        0      524 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/data/x509-certificate.json
--rw-r--r--   0        0        0    38949 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/definitions.py
--rw-r--r--   0        0        0      859 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/generator.py
--rw-r--r--   0        0        0       33 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/mappings/is_list_meta.json
--rw-r--r--   0        0        0     1482 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/mappings/is_list_sco.json
--rw-r--r--   0        0        0     1390 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/mappings/is_list_sdo.json
--rw-r--r--   0        0        0      182 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/mappings/is_list_sro.json
--rw-r--r--   0        0        0      571 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/mappings/is_list_sub_objects.json
--rw-r--r--   0        0        0    49539 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/mappings/object_conversion.json
--rw-r--r--   0        0        0     6324 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/mappings/relations_embedded.json
--rw-r--r--   0        0        0     2604 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/mappings/relations_extensions_and_objects.json
--rw-r--r--   0        0        0     1384 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/mappings/relations_key_value.json
--rw-r--r--   0        0        0     1162 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/mappings/relations_list_of_objects.json
--rw-r--r--   0        0        0     3628 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/mappings/relations_sro_roles.json
--rw-r--r--   0        0        0       93 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/mappings/types_meta.json
--rw-r--r--   0        0        0     5040 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/schema/cti-rules.tql
--rw-r--r--   0        0        0    49156 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/schema/cti-schema-v2.tql
--rw-r--r--   0        0        0       46 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/sub_objects/alternate-data-stream.json
--rw-r--r--   0        0        0       43 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/sub_objects/archive-ext.json
--rw-r--r--   0        0        0      114 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/sub_objects/email-mime-part.json
--rw-r--r--   0        0        0      135 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/sub_objects/external-reference.json
--rw-r--r--   0        0        0      161 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/sub_objects/hash_typeql_dict.json
--rw-r--r--   0        0        0      219 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/sub_objects/http-request-ext.json
--rw-r--r--   0        0        0       68 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/sub_objects/icmp-ext.json
--rw-r--r--   0        0        0       66 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/sub_objects/kill-chain-phase.json
--rw-r--r--   0        0        0       44 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/sub_objects/ntfs-ext.json
--rw-r--r--   0        0        0      120 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/sub_objects/pdf-ext.json
--rw-r--r--   0        0        0      115 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/sub_objects/raster-image-ext.json
--rw-r--r--   0        0        0      221 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/sub_objects/socket-ext.json
--rw-r--r--   0        0        0       68 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/sub_objects/tcp-ext.json
--rw-r--r--   0        0        0       80 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/sub_objects/unix-account-ext.json
--rw-r--r--   0        0        0     1318 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/sub_objects/windows-pe-optional-header-type.json
--rw-r--r--   0        0        0       68 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/sub_objects/windows-pe-section.json
--rw-r--r--   0        0        0      451 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/sub_objects/windows-pebinary-ext.json
--rw-r--r--   0        0        0      202 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/sub_objects/windows-process-ext.json
--rw-r--r--   0        0        0       58 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/sub_objects/windows-registry-value-type.json
--rw-r--r--   0        0        0      243 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/sub_objects/windows-service-ext.json
--rw-r--r--   0        0        0      848 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/stix21/sub_objects/x509-v3-extension.json
--rw-r--r--   0        0        0      557 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/us_dod/__init__.py
--rw-r--r--   0        0        0      752 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/us_dod/classes.py
--rw-r--r--   0        0        0      571 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/definitions/us_dod/mappings/is_list_sub_objects.json
--rw-r--r--   0        0        0    13277 2023-08-07 00:14:08.455317 stixorm-0.1.3/stixorm/module/generate_docs.py
--rw-r--r--   0        0        0    16238 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/initialise.py
--rw-r--r--   0        0        0        0 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/orm/__init__.py
--rw-r--r--   0        0        0    20952 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/orm/delete_object.py
--rw-r--r--   0        0        0    34210 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/orm/export_object.py
--rw-r--r--   0        0        0    20374 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/orm/export_utilities.py
--rw-r--r--   0        0        0    24351 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/orm/import_objects.py
--rw-r--r--   0        0        0    27409 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/orm/import_utilities.py
--rw-r--r--   0        0        0        0 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/parsing/__init__.py
--rw-r--r--   0        0        0    11873 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/parsing/conversion_decisions.py
--rw-r--r--   0        0        0    10448 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/parsing/parse_objects.py
--rw-r--r--   0        0        0    29772 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/typedb.py
--rw-r--r--   0        0        0        0 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/typedb_lib/__init__.py
--rw-r--r--   0        0        0       46 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/typedb_lib/auth_types.py
--rw-r--r--   0        0        0        0 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/typedb_lib/factories/__init__.py
--rw-r--r--   0        0        0      880 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/typedb_lib/factories/auth_factory.py
--rw-r--r--   0        0        0     1105 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/typedb_lib/factories/auth_type_factory.py
--rw-r--r--   0        0        0     6890 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/typedb_lib/factories/definition_factory.py
--rw-r--r--   0        0        0     4076 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/typedb_lib/factories/import_type_factory.py
--rw-r--r--   0        0        0     3376 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/typedb_lib/factories/mappings_factory.py
--rw-r--r--   0        0        0     2135 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/typedb_lib/factories/process_map.json
--rw-r--r--   0        0        0      812 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/typedb_lib/factories/process_map_factory.py
--rw-r--r--   0        0        0      199 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/typedb_lib/file.py
--rw-r--r--   0        0        0      819 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/typedb_lib/handlers.py
--rw-r--r--   0        0        0     9664 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/typedb_lib/instructions.py
--rw-r--r--   0        0        0     2686 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/typedb_lib/logging.py
--rw-r--r--   0        0        0        0 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/typedb_lib/model/__init__.py
--rw-r--r--   0        0        0     1142 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/typedb_lib/model/definitions.py
--rw-r--r--   0        0        0    13003 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/module/typedb_lib/queries.py
--rw-r--r--   0        0        0      870 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/unit/utils/check_func.py
--rw-r--r--   0        0        0     2631 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/unit/utils/dep_regex.py
--rw-r--r--   0        0        0     1380 2023-08-07 00:14:08.459317 stixorm-0.1.3/stixorm/unit/utils/example.txt
--rw-r--r--   0        0        0     6349 1970-01-01 00:00:00.000000 stixorm-0.1.3/PKG-INFO
+-rw-r--r--   0        0        0    35184 2023-08-07 01:09:01.055452 stixorm-0.1.9/LICENSE
+-rw-r--r--   0        0        0     1148 2023-08-07 01:10:20.387673 stixorm-0.1.9/pyproject.toml
+-rw-r--r--   0        0        0     5501 2023-08-07 01:09:01.055452 stixorm-0.1.9/README.md
+-rw-r--r--   0        0        0      134 2023-08-07 01:09:01.149200 stixorm-0.1.9/stixorm/__init__.py
+-rw-r--r--   0        0        0        0 2023-08-07 01:09:01.149200 stixorm-0.1.9/stixorm/module/__init__.py
+-rw-r--r--   0        0        0     8107 2023-08-07 01:09:01.149200 stixorm-0.1.9/stixorm/module/authorise.py
+-rw-r--r--   0        0        0        0 2023-08-07 01:09:01.149200 stixorm-0.1.9/stixorm/module/definitions/__init__.py
+-rw-r--r--   0        0        0     1285 2023-08-07 01:09:01.149200 stixorm-0.1.9/stixorm/module/definitions/attack/__init__.py
+-rw-r--r--   0        0        0      282 2023-08-07 01:09:01.149200 stixorm-0.1.9/stixorm/module/definitions/attack/base/attack_base.json
+-rw-r--r--   0        0        0    37265 2023-08-07 01:09:01.149200 stixorm-0.1.9/stixorm/module/definitions/attack/classes.py
+-rw-r--r--   0        0        0      297 2023-08-07 01:09:01.149200 stixorm-0.1.9/stixorm/module/definitions/attack/data/attack-campaign.json
+-rw-r--r--   0        0        0      300 2023-08-07 01:09:01.149200 stixorm-0.1.9/stixorm/module/definitions/attack/data/attack-group.json
+-rw-r--r--   0        0        0      192 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/data/attack-identity.json
+-rw-r--r--   0        0        0        6 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/data/attack-relation.json
+-rw-r--r--   0        0        0       82 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/data/collection.json
+-rw-r--r--   0        0        0       89 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/data/data-component.json
+-rw-r--r--   0        0        0      161 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/data/data-source.json
+-rw-r--r--   0        0        0       88 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/data/matrix.json
+-rw-r--r--   0        0        0       78 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/data/mitigation.json
+-rw-r--r--   0        0        0      533 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/data/software-malware.json
+-rw-r--r--   0        0        0      259 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/data/software-tool.json
+-rw-r--r--   0        0        0      786 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/data/sub-technique.json
+-rw-r--r--   0        0        0      100 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/data/tactic.json
+-rw-r--r--   0        0        0      853 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/data/technique.json
+-rw-r--r--   0        0        0       32 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/mappings/is_list_meta.json
+-rw-r--r--   0        0        0        6 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/mappings/is_list_sco.json
+-rw-r--r--   0        0        0     1597 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/mappings/is_list_sdo.json
+-rw-r--r--   0        0        0       76 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/mappings/is_list_sro.json
+-rw-r--r--   0        0        0       28 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/mappings/is_list_sub_objects.json
+-rw-r--r--   0        0        0     7873 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/mappings/object_conversion.json
+-rw-r--r--   0        0        0      598 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/mappings/relations_embedded.json
+-rw-r--r--   0        0        0      172 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/mappings/relations_list_of_objects.json
+-rw-r--r--   0        0        0      467 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/mappings/relations_sro_roles.json
+-rw-r--r--   0        0        0      876 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/schema/cti-attack-rules.tql
+-rw-r--r--   0        0        0    13531 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/schema/cti-attack.tql
+-rw-r--r--   0        0        0       73 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/attack/sub_objects/object-version.json
+-rw-r--r--   0        0        0      589 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/cacao/__init__.py
+-rw-r--r--   0        0        0      775 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/cacao/classes.py
+-rw-r--r--   0        0        0      571 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/cacao/mappings/is_list_sub_objects.json
+-rw-r--r--   0        0        0      471 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/kestrel/__init__.py
+-rw-r--r--   0        0        0      775 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/kestrel/classes.py
+-rw-r--r--   0        0        0      571 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/kestrel/mappings/is_list_sub_objects.json
+-rw-r--r--   0        0        0     1689 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/__init__.py
+-rw-r--r--   0        0        0    22201 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/classes.py
+-rw-r--r--   0        0        0      503 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/data/event.json
+-rw-r--r--   0        0        0      137 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/data/evidence.json
+-rw-r--r--   0        0        0      112 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/data/feed.json
+-rw-r--r--   0        0        0      113 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/data/feeds.json
+-rw-r--r--   0        0        0      387 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/data/impact.json
+-rw-r--r--   0        0        0      500 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/data/task.json
+-rw-r--r--   0        0        0      349 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/mappings/is_list_sdo.json
+-rw-r--r--   0        0        0      514 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/mappings/is_list_sub_objects.json
+-rw-r--r--   0        0        0     5097 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/mappings/object_conversion.json
+-rw-r--r--   0        0        0     1870 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/mappings/relations_embedded.json
+-rw-r--r--   0        0        0     2590 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/mappings/relations_extensions_and_objects.json
+-rw-r--r--   0        0        0      335 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/mappings/relations_list_of_objects.json
+-rw-r--r--   0        0        0     1614 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/mappings/relations_sro_roles.json
+-rw-r--r--   0        0        0      850 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/schema/cti-os-hunt.tql
+-rw-r--r--   0        0        0    18414 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/schema/cti-os-threat.tql
+-rw-r--r--   0        0        0       55 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/sub_objects/availability.json
+-rw-r--r--   0        0        0      147 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/sub_objects/confidentiality.json
+-rw-r--r--   0        0        0      199 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/sub_objects/entity-count-object.json
+-rw-r--r--   0        0        0       43 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/sub_objects/extension-definition--2074a052-8be4-4932-849e-f5e7798e0030.json
+-rw-r--r--   0        0        0       43 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/sub_objects/extension-definition--4ca6de00-5b0d-45ef-a1dc-ea7279ea910e.json
+-rw-r--r--   0        0        0       43 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/sub_objects/extension-definition--7cc33dd6-f6a1-489b-98ea-522d351d71b9.json
+-rw-r--r--   0        0        0       43 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/sub_objects/extension-definition--7ff5b5a5-a342-417e-9c0d-339561d9d78a.json
+-rw-r--r--   0        0        0      468 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/sub_objects/extension-definition--ef765651-680c-498d-9894-99799f2fa126.json
+-rw-r--r--   0        0        0       38 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/sub_objects/external.json
+-rw-r--r--   0        0        0       85 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/sub_objects/incident-score-object.json
+-rw-r--r--   0        0        0      149 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/sub_objects/integrity.json
+-rw-r--r--   0        0        0      248 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/sub_objects/monetary.json
+-rw-r--r--   0        0        0       69 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/sub_objects/physical.json
+-rw-r--r--   0        0        0       94 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/sub_objects/state-change-object.json
+-rw-r--r--   0        0        0       79 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/sub_objects/threat-sub-object.json
+-rw-r--r--   0        0        0       51 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/os_threat/sub_objects/traceability.json
+-rw-r--r--   0        0        0     8260 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/property_definitions.py
+-rw-r--r--   0        0        0     3645 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/stix21/__init__.py
+-rw-r--r--   0        0        0      342 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/stix21/base/base_sco.json
+-rw-r--r--   0        0        0      367 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/stix21/base/base_sdo.json
+-rw-r--r--   0        0        0      367 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/stix21/base/base_sro.json
+-rw-r--r--   0        0        0     8734 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/stix21/classes.py
+-rw-r--r--   0        0        0      194 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/stix21/data/artifact.json
+-rw-r--r--   0        0        0      108 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/stix21/data/attack-pattern.json
+-rw-r--r--   0        0        0       50 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/stix21/data/autonomous-system.json
+-rw-r--r--   0        0        0      169 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/stix21/data/campaign.json
+-rw-r--r--   0        0        0       78 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/stix21/data/course-of-action.json
+-rw-r--r--   0        0        0      115 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/stix21/data/directory.json
+-rw-r--r--   0        0        0       47 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/stix21/data/domain-name.json
+-rw-r--r--   0        0        0       89 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/stix21/data/email-addr.json
+-rw-r--r--   0        0        0      385 2023-08-07 01:09:01.164758 stixorm-0.1.9/stixorm/module/definitions/stix21/data/email-message.json
+-rw-r--r--   0        0        0      297 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/file.json
+-rw-r--r--   0        0        0       87 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/grouping.json
+-rw-r--r--   0        0        0      192 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/identity.json
+-rw-r--r--   0        0        0       46 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/incident.json
+-rw-r--r--   0        0        0      258 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/indicator.json
+-rw-r--r--   0        0        0      195 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/infrastructure.json
+-rw-r--r--   0        0        0      300 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/intrusion-set.json
+-rw-r--r--   0        0        0       70 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/ipv4-addr.json
+-rw-r--r--   0        0        0       70 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/ipv6-addr.json
+-rw-r--r--   0        0        0      292 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/location.json
+-rw-r--r--   0        0        0       23 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/mac-addr.json
+-rw-r--r--   0        0        0      556 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/malware-analysis.json
+-rw-r--r--   0        0        0      447 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/malware.json
+-rw-r--r--   0        0        0       98 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/marking-definition.json
+-rw-r--r--   0        0        0       16 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/mutex.json
+-rw-r--r--   0        0        0      459 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/network-traffic.json
+-rw-r--r--   0        0        0       92 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/note.json
+-rw-r--r--   0        0        0      142 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/observed-data.json
+-rw-r--r--   0        0        0       98 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/opinion.json
+-rw-r--r--   0        0        0      254 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/process.json
+-rw-r--r--   0        0        0      183 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/relationship.json
+-rw-r--r--   0        0        0      122 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/report.json
+-rw-r--r--   0        0        0      235 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/sighting.json
+-rw-r--r--   0        0        0      113 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/software.json
+-rw-r--r--   0        0        0      461 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/threat-actor.json
+-rw-r--r--   0        0        0      173 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/tool.json
+-rw-r--r--   0        0        0       23 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/url.json
+-rw-r--r--   0        0        0      520 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/user-account.json
+-rw-r--r--   0        0        0       46 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/vulnerability.json
+-rw-r--r--   0        0        0      135 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/windows-registry-key.json
+-rw-r--r--   0        0        0      538 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/data/x509-certificate.json
+-rw-r--r--   0        0        0    40176 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/definitions.py
+-rw-r--r--   0        0        0      894 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/generator.py
+-rw-r--r--   0        0        0       36 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/mappings/is_list_meta.json
+-rw-r--r--   0        0        0     1564 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/mappings/is_list_sco.json
+-rw-r--r--   0        0        0     1473 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/mappings/is_list_sdo.json
+-rw-r--r--   0        0        0      193 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/mappings/is_list_sro.json
+-rw-r--r--   0        0        0      571 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/mappings/is_list_sub_objects.json
+-rw-r--r--   0        0        0    50213 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/mappings/object_conversion.json
+-rw-r--r--   0        0        0     6605 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/mappings/relations_embedded.json
+-rw-r--r--   0        0        0     2717 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/mappings/relations_extensions_and_objects.json
+-rw-r--r--   0        0        0     1449 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/mappings/relations_key_value.json
+-rw-r--r--   0        0        0     1212 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/mappings/relations_list_of_objects.json
+-rw-r--r--   0        0        0     3815 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/mappings/relations_sro_roles.json
+-rw-r--r--   0        0        0       93 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/mappings/types_meta.json
+-rw-r--r--   0        0        0     5154 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/schema/cti-rules.tql
+-rw-r--r--   0        0        0    51109 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/schema/cti-schema-v2.tql
+-rw-r--r--   0        0        0       46 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/sub_objects/alternate-data-stream.json
+-rw-r--r--   0        0        0       43 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/sub_objects/archive-ext.json
+-rw-r--r--   0        0        0      114 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/sub_objects/email-mime-part.json
+-rw-r--r--   0        0        0      141 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/sub_objects/external-reference.json
+-rw-r--r--   0        0        0      161 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/sub_objects/hash_typeql_dict.json
+-rw-r--r--   0        0        0      226 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/sub_objects/http-request-ext.json
+-rw-r--r--   0        0        0       68 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/sub_objects/icmp-ext.json
+-rw-r--r--   0        0        0       66 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/sub_objects/kill-chain-phase.json
+-rw-r--r--   0        0        0       44 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/sub_objects/ntfs-ext.json
+-rw-r--r--   0        0        0      120 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/sub_objects/pdf-ext.json
+-rw-r--r--   0        0        0      115 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/sub_objects/raster-image-ext.json
+-rw-r--r--   0        0        0      221 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/sub_objects/socket-ext.json
+-rw-r--r--   0        0        0       68 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/sub_objects/tcp-ext.json
+-rw-r--r--   0        0        0       80 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/sub_objects/unix-account-ext.json
+-rw-r--r--   0        0        0     1318 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/sub_objects/windows-pe-optional-header-type.json
+-rw-r--r--   0        0        0       68 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/sub_objects/windows-pe-section.json
+-rw-r--r--   0        0        0      464 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/sub_objects/windows-pebinary-ext.json
+-rw-r--r--   0        0        0      202 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/sub_objects/windows-process-ext.json
+-rw-r--r--   0        0        0       58 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/sub_objects/windows-registry-value-type.json
+-rw-r--r--   0        0        0      243 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/sub_objects/windows-service-ext.json
+-rw-r--r--   0        0        0      865 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/stix21/sub_objects/x509-v3-extension.json
+-rw-r--r--   0        0        0      589 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/us_dod/__init__.py
+-rw-r--r--   0        0        0      775 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/us_dod/classes.py
+-rw-r--r--   0        0        0      571 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/definitions/us_dod/mappings/is_list_sub_objects.json
+-rw-r--r--   0        0        0    13658 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/generate_docs.py
+-rw-r--r--   0        0        0    16631 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/initialise.py
+-rw-r--r--   0        0        0        0 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/orm/__init__.py
+-rw-r--r--   0        0        0    21462 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/orm/delete_object.py
+-rw-r--r--   0        0        0    35064 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/orm/export_object.py
+-rw-r--r--   0        0        0    20979 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/orm/export_utilities.py
+-rw-r--r--   0        0        0    24888 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/orm/import_objects.py
+-rw-r--r--   0        0        0    28136 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/orm/import_utilities.py
+-rw-r--r--   0        0        0        0 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/parsing/__init__.py
+-rw-r--r--   0        0        0    12151 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/parsing/conversion_decisions.py
+-rw-r--r--   0        0        0    10679 2023-08-07 01:09:01.180382 stixorm-0.1.9/stixorm/module/parsing/parse_objects.py
+-rw-r--r--   0        0        0    30514 2023-08-07 01:09:01.196074 stixorm-0.1.9/stixorm/module/typedb.py
+-rw-r--r--   0        0        0        0 2023-08-07 01:09:01.196074 stixorm-0.1.9/stixorm/module/typedb_lib/__init__.py
+-rw-r--r--   0        0        0       51 2023-08-07 01:09:01.196074 stixorm-0.1.9/stixorm/module/typedb_lib/auth_types.py
+-rw-r--r--   0        0        0        0 2023-08-07 01:09:01.196074 stixorm-0.1.9/stixorm/module/typedb_lib/factories/__init__.py
+-rw-r--r--   0        0        0      906 2023-08-07 01:09:01.196074 stixorm-0.1.9/stixorm/module/typedb_lib/factories/auth_factory.py
+-rw-r--r--   0        0        0     1128 2023-08-07 01:09:01.196074 stixorm-0.1.9/stixorm/module/typedb_lib/factories/auth_type_factory.py
+-rw-r--r--   0        0        0     7072 2023-08-07 01:09:01.196074 stixorm-0.1.9/stixorm/module/typedb_lib/factories/definition_factory.py
+-rw-r--r--   0        0        0     4221 2023-08-07 01:09:01.196074 stixorm-0.1.9/stixorm/module/typedb_lib/factories/import_type_factory.py
+-rw-r--r--   0        0        0     3475 2023-08-07 01:09:01.196074 stixorm-0.1.9/stixorm/module/typedb_lib/factories/mappings_factory.py
+-rw-r--r--   0        0        0     2175 2023-08-07 01:09:01.196074 stixorm-0.1.9/stixorm/module/typedb_lib/factories/process_map.json
+-rw-r--r--   0        0        0      845 2023-08-07 01:09:01.196074 stixorm-0.1.9/stixorm/module/typedb_lib/factories/process_map_factory.py
+-rw-r--r--   0        0        0      206 2023-08-07 01:09:01.196074 stixorm-0.1.9/stixorm/module/typedb_lib/file.py
+-rw-r--r--   0        0        0      846 2023-08-07 01:09:01.196074 stixorm-0.1.9/stixorm/module/typedb_lib/handlers.py
+-rw-r--r--   0        0        0     9946 2023-08-07 01:09:01.196074 stixorm-0.1.9/stixorm/module/typedb_lib/instructions.py
+-rw-r--r--   0        0        0     2770 2023-08-07 01:09:01.196074 stixorm-0.1.9/stixorm/module/typedb_lib/logging.py
+-rw-r--r--   0        0        0        0 2023-08-07 01:09:01.196074 stixorm-0.1.9/stixorm/module/typedb_lib/model/__init__.py
+-rw-r--r--   0        0        0     1197 2023-08-07 01:09:01.196074 stixorm-0.1.9/stixorm/module/typedb_lib/model/definitions.py
+-rw-r--r--   0        0        0    13258 2023-08-07 01:09:01.196074 stixorm-0.1.9/stixorm/module/typedb_lib/queries.py
+-rw-r--r--   0        0        0      895 2023-08-07 01:09:01.196074 stixorm-0.1.9/stixorm/unit/utils/check_func.py
+-rw-r--r--   0        0        0     2716 2023-08-07 01:09:01.196074 stixorm-0.1.9/stixorm/unit/utils/dep_regex.py
+-rw-r--r--   0        0        0     1418 2023-08-07 01:09:01.196074 stixorm-0.1.9/stixorm/unit/utils/example.txt
+-rw-r--r--   0        0        0     6349 1970-01-01 00:00:00.000000 stixorm-0.1.9/PKG-INFO
```

### Comparing `stixorm-0.1.3/LICENSE` & `stixorm-0.1.9/LICENSE`

 * *Ordering differences only*

 * *Files 6% similar despite different names*

```diff
@@ -1,661 +1,661 @@
-                    GNU AFFERO GENERAL PUBLIC LICENSE
-                       Version 3, 19 November 2007
-
- Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-                            Preamble
-
-  The GNU Affero General Public License is a free, copyleft license for
-software and other kinds of works, specifically designed to ensure
-cooperation with the community in the case of network server software.
-
-  The licenses for most software and other practical works are designed
-to take away your freedom to share and change the works.  By contrast,
-our General Public Licenses are intended to guarantee your freedom to
-share and change all versions of a program--to make sure it remains free
-software for all its users.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-them if you wish), that you receive source code or can get it if you
-want it, that you can change the software or use pieces of it in new
-free programs, and that you know you can do these things.
-
-  Developers that use our General Public Licenses protect your rights
-with two steps: (1) assert copyright on the software, and (2) offer
-you this License which gives you legal permission to copy, distribute
-and/or modify the software.
-
-  A secondary benefit of defending all users' freedom is that
-improvements made in alternate versions of the program, if they
-receive widespread use, become available for other developers to
-incorporate.  Many developers of free software are heartened and
-encouraged by the resulting cooperation.  However, in the case of
-software used on network servers, this result may fail to come about.
-The GNU General Public License permits making a modified version and
-letting the public access it on a server without ever releasing its
-source code to the public.
-
-  The GNU Affero General Public License is designed specifically to
-ensure that, in such cases, the modified source code becomes available
-to the community.  It requires the operator of a network server to
-provide the source code of the modified version running there to the
-users of that server.  Therefore, public use of a modified version, on
-a publicly accessible server, gives the public access to the source
-code of the modified version.
-
-  An older license, called the Affero General Public License and
-published by Affero, was designed to accomplish similar goals.  This is
-a different license, not a version of the Affero GPL, but Affero has
-released a new version of the Affero GPL which permits relicensing under
-this license.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-                       TERMS AND CONDITIONS
-
-  0. Definitions.
-
-  "This License" refers to version 3 of the GNU Affero General Public License.
-
-  "Copyright" also means copyright-like laws that apply to other kinds of
-works, such as semiconductor masks.
-
-  "The Program" refers to any copyrightable work licensed under this
-License.  Each licensee is addressed as "you".  "Licensees" and
-"recipients" may be individuals or organizations.
-
-  To "modify" a work means to copy from or adapt all or part of the work
-in a fashion requiring copyright permission, other than the making of an
-exact copy.  The resulting work is called a "modified version" of the
-earlier work or a work "based on" the earlier work.
-
-  A "covered work" means either the unmodified Program or a work based
-on the Program.
-
-  To "propagate" a work means to do anything with it that, without
-permission, would make you directly or secondarily liable for
-infringement under applicable copyright law, except executing it on a
-computer or modifying a private copy.  Propagation includes copying,
-distribution (with or without modification), making available to the
-public, and in some countries other activities as well.
-
-  To "convey" a work means any kind of propagation that enables other
-parties to make or receive copies.  Mere interaction with a user through
-a computer network, with no transfer of a copy, is not conveying.
-
-  An interactive user interface displays "Appropriate Legal Notices"
-to the extent that it includes a convenient and prominently visible
-feature that (1) displays an appropriate copyright notice, and (2)
-tells the user that there is no warranty for the work (except to the
-extent that warranties are provided), that licensees may convey the
-work under this License, and how to view a copy of this License.  If
-the interface presents a list of user commands or options, such as a
-menu, a prominent item in the list meets this criterion.
-
-  1. Source Code.
-
-  The "source code" for a work means the preferred form of the work
-for making modifications to it.  "Object code" means any non-source
-form of a work.
-
-  A "Standard Interface" means an interface that either is an official
-standard defined by a recognized standards body, or, in the case of
-interfaces specified for a particular programming language, one that
-is widely used among developers working in that language.
-
-  The "System Libraries" of an executable work include anything, other
-than the work as a whole, that (a) is included in the normal form of
-packaging a Major Component, but which is not part of that Major
-Component, and (b) serves only to enable use of the work with that
-Major Component, or to implement a Standard Interface for which an
-implementation is available to the public in source code form.  A
-"Major Component", in this context, means a major essential component
-(kernel, window system, and so on) of the specific operating system
-(if any) on which the executable work runs, or a compiler used to
-produce the work, or an object code interpreter used to run it.
-
-  The "Corresponding Source" for a work in object code form means all
-the source code needed to generate, install, and (for an executable
-work) run the object code and to modify the work, including scripts to
-control those activities.  However, it does not include the work's
-System Libraries, or general-purpose tools or generally available free
-programs which are used unmodified in performing those activities but
-which are not part of the work.  For example, Corresponding Source
-includes interface definition files associated with source files for
-the work, and the source code for shared libraries and dynamically
-linked subprograms that the work is specifically designed to require,
-such as by intimate data communication or control flow between those
-subprograms and other parts of the work.
-
-  The Corresponding Source need not include anything that users
-can regenerate automatically from other parts of the Corresponding
-Source.
-
-  The Corresponding Source for a work in source code form is that
-same work.
-
-  2. Basic Permissions.
-
-  All rights granted under this License are granted for the term of
-copyright on the Program, and are irrevocable provided the stated
-conditions are met.  This License explicitly affirms your unlimited
-permission to run the unmodified Program.  The output from running a
-covered work is covered by this License only if the output, given its
-content, constitutes a covered work.  This License acknowledges your
-rights of fair use or other equivalent, as provided by copyright law.
-
-  You may make, run and propagate covered works that you do not
-convey, without conditions so long as your license otherwise remains
-in force.  You may convey covered works to others for the sole purpose
-of having them make modifications exclusively for you, or provide you
-with facilities for running those works, provided that you comply with
-the terms of this License in conveying all material for which you do
-not control copyright.  Those thus making or running the covered works
-for you must do so exclusively on your behalf, under your direction
-and control, on terms that prohibit them from making any copies of
-your copyrighted material outside their relationship with you.
-
-  Conveying under any other circumstances is permitted solely under
-the conditions stated below.  Sublicensing is not allowed; section 10
-makes it unnecessary.
-
-  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
-
-  No covered work shall be deemed part of an effective technological
-measure under any applicable law fulfilling obligations under article
-11 of the WIPO copyright treaty adopted on 20 December 1996, or
-similar laws prohibiting or restricting circumvention of such
-measures.
-
-  When you convey a covered work, you waive any legal power to forbid
-circumvention of technological measures to the extent such circumvention
-is effected by exercising rights under this License with respect to
-the covered work, and you disclaim any intention to limit operation or
-modification of the work as a means of enforcing, against the work's
-users, your or third parties' legal rights to forbid circumvention of
-technological measures.
-
-  4. Conveying Verbatim Copies.
-
-  You may convey verbatim copies of the Program's source code as you
-receive it, in any medium, provided that you conspicuously and
-appropriately publish on each copy an appropriate copyright notice;
-keep intact all notices stating that this License and any
-non-permissive terms added in accord with section 7 apply to the code;
-keep intact all notices of the absence of any warranty; and give all
-recipients a copy of this License along with the Program.
-
-  You may charge any price or no price for each copy that you convey,
-and you may offer support or warranty protection for a fee.
-
-  5. Conveying Modified Source Versions.
-
-  You may convey a work based on the Program, or the modifications to
-produce it from the Program, in the form of source code under the
-terms of section 4, provided that you also meet all of these conditions:
-
-    a) The work must carry prominent notices stating that you modified
-    it, and giving a relevant date.
-
-    b) The work must carry prominent notices stating that it is
-    released under this License and any conditions added under section
-    7.  This requirement modifies the requirement in section 4 to
-    "keep intact all notices".
-
-    c) You must license the entire work, as a whole, under this
-    License to anyone who comes into possession of a copy.  This
-    License will therefore apply, along with any applicable section 7
-    additional terms, to the whole of the work, and all its parts,
-    regardless of how they are packaged.  This License gives no
-    permission to license the work in any other way, but it does not
-    invalidate such permission if you have separately received it.
-
-    d) If the work has interactive user interfaces, each must display
-    Appropriate Legal Notices; however, if the Program has interactive
-    interfaces that do not display Appropriate Legal Notices, your
-    work need not make them do so.
-
-  A compilation of a covered work with other separate and independent
-works, which are not by their nature extensions of the covered work,
-and which are not combined with it such as to form a larger program,
-in or on a volume of a storage or distribution medium, is called an
-"aggregate" if the compilation and its resulting copyright are not
-used to limit the access or legal rights of the compilation's users
-beyond what the individual works permit.  Inclusion of a covered work
-in an aggregate does not cause this License to apply to the other
-parts of the aggregate.
-
-  6. Conveying Non-Source Forms.
-
-  You may convey a covered work in object code form under the terms
-of sections 4 and 5, provided that you also convey the
-machine-readable Corresponding Source under the terms of this License,
-in one of these ways:
-
-    a) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by the
-    Corresponding Source fixed on a durable physical medium
-    customarily used for software interchange.
-
-    b) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by a
-    written offer, valid for at least three years and valid for as
-    long as you offer spare parts or customer support for that product
-    model, to give anyone who possesses the object code either (1) a
-    copy of the Corresponding Source for all the software in the
-    product that is covered by this License, on a durable physical
-    medium customarily used for software interchange, for a price no
-    more than your reasonable cost of physically performing this
-    conveying of source, or (2) access to copy the
-    Corresponding Source from a network server at no charge.
-
-    c) Convey individual copies of the object code with a copy of the
-    written offer to provide the Corresponding Source.  This
-    alternative is allowed only occasionally and noncommercially, and
-    only if you received the object code with such an offer, in accord
-    with subsection 6b.
-
-    d) Convey the object code by offering access from a designated
-    place (gratis or for a charge), and offer equivalent access to the
-    Corresponding Source in the same way through the same place at no
-    further charge.  You need not require recipients to copy the
-    Corresponding Source along with the object code.  If the place to
-    copy the object code is a network server, the Corresponding Source
-    may be on a different server (operated by you or a third party)
-    that supports equivalent copying facilities, provided you maintain
-    clear directions next to the object code saying where to find the
-    Corresponding Source.  Regardless of what server hosts the
-    Corresponding Source, you remain obligated to ensure that it is
-    available for as long as needed to satisfy these requirements.
-
-    e) Convey the object code using peer-to-peer transmission, provided
-    you inform other peers where the object code and Corresponding
-    Source of the work are being offered to the general public at no
-    charge under subsection 6d.
-
-  A separable portion of the object code, whose source code is excluded
-from the Corresponding Source as a System Library, need not be
-included in conveying the object code work.
-
-  A "User Product" is either (1) a "consumer product", which means any
-tangible personal property which is normally used for personal, family,
-or household purposes, or (2) anything designed or sold for incorporation
-into a dwelling.  In determining whether a product is a consumer product,
-doubtful cases shall be resolved in favor of coverage.  For a particular
-product received by a particular user, "normally used" refers to a
-typical or common use of that class of product, regardless of the status
-of the particular user or of the way in which the particular user
-actually uses, or expects or is expected to use, the product.  A product
-is a consumer product regardless of whether the product has substantial
-commercial, industrial or non-consumer uses, unless such uses represent
-the only significant mode of use of the product.
-
-  "Installation Information" for a User Product means any methods,
-procedures, authorization keys, or other information required to install
-and execute modified versions of a covered work in that User Product from
-a modified version of its Corresponding Source.  The information must
-suffice to ensure that the continued functioning of the modified object
-code is in no case prevented or interfered with solely because
-modification has been made.
-
-  If you convey an object code work under this section in, or with, or
-specifically for use in, a User Product, and the conveying occurs as
-part of a transaction in which the right of possession and use of the
-User Product is transferred to the recipient in perpetuity or for a
-fixed term (regardless of how the transaction is characterized), the
-Corresponding Source conveyed under this section must be accompanied
-by the Installation Information.  But this requirement does not apply
-if neither you nor any third party retains the ability to install
-modified object code on the User Product (for example, the work has
-been installed in ROM).
-
-  The requirement to provide Installation Information does not include a
-requirement to continue to provide support service, warranty, or updates
-for a work that has been modified or installed by the recipient, or for
-the User Product in which it has been modified or installed.  Access to a
-network may be denied when the modification itself materially and
-adversely affects the operation of the network or violates the rules and
-protocols for communication across the network.
-
-  Corresponding Source conveyed, and Installation Information provided,
-in accord with this section must be in a format that is publicly
-documented (and with an implementation available to the public in
-source code form), and must require no special password or key for
-unpacking, reading or copying.
-
-  7. Additional Terms.
-
-  "Additional permissions" are terms that supplement the terms of this
-License by making exceptions from one or more of its conditions.
-Additional permissions that are applicable to the entire Program shall
-be treated as though they were included in this License, to the extent
-that they are valid under applicable law.  If additional permissions
-apply only to part of the Program, that part may be used separately
-under those permissions, but the entire Program remains governed by
-this License without regard to the additional permissions.
-
-  When you convey a copy of a covered work, you may at your option
-remove any additional permissions from that copy, or from any part of
-it.  (Additional permissions may be written to require their own
-removal in certain cases when you modify the work.)  You may place
-additional permissions on material, added by you to a covered work,
-for which you have or can give appropriate copyright permission.
-
-  Notwithstanding any other provision of this License, for material you
-add to a covered work, you may (if authorized by the copyright holders of
-that material) supplement the terms of this License with terms:
-
-    a) Disclaiming warranty or limiting liability differently from the
-    terms of sections 15 and 16 of this License; or
-
-    b) Requiring preservation of specified reasonable legal notices or
-    author attributions in that material or in the Appropriate Legal
-    Notices displayed by works containing it; or
-
-    c) Prohibiting misrepresentation of the origin of that material, or
-    requiring that modified versions of such material be marked in
-    reasonable ways as different from the original version; or
-
-    d) Limiting the use for publicity purposes of names of licensors or
-    authors of the material; or
-
-    e) Declining to grant rights under trademark law for use of some
-    trade names, trademarks, or service marks; or
-
-    f) Requiring indemnification of licensors and authors of that
-    material by anyone who conveys the material (or modified versions of
-    it) with contractual assumptions of liability to the recipient, for
-    any liability that these contractual assumptions directly impose on
-    those licensors and authors.
-
-  All other non-permissive additional terms are considered "further
-restrictions" within the meaning of section 10.  If the Program as you
-received it, or any part of it, contains a notice stating that it is
-governed by this License along with a term that is a further
-restriction, you may remove that term.  If a license document contains
-a further restriction but permits relicensing or conveying under this
-License, you may add to a covered work material governed by the terms
-of that license document, provided that the further restriction does
-not survive such relicensing or conveying.
-
-  If you add terms to a covered work in accord with this section, you
-must place, in the relevant source files, a statement of the
-additional terms that apply to those files, or a notice indicating
-where to find the applicable terms.
-
-  Additional terms, permissive or non-permissive, may be stated in the
-form of a separately written license, or stated as exceptions;
-the above requirements apply either way.
-
-  8. Termination.
-
-  You may not propagate or modify a covered work except as expressly
-provided under this License.  Any attempt otherwise to propagate or
-modify it is void, and will automatically terminate your rights under
-this License (including any patent licenses granted under the third
-paragraph of section 11).
-
-  However, if you cease all violation of this License, then your
-license from a particular copyright holder is reinstated (a)
-provisionally, unless and until the copyright holder explicitly and
-finally terminates your license, and (b) permanently, if the copyright
-holder fails to notify you of the violation by some reasonable means
-prior to 60 days after the cessation.
-
-  Moreover, your license from a particular copyright holder is
-reinstated permanently if the copyright holder notifies you of the
-violation by some reasonable means, this is the first time you have
-received notice of violation of this License (for any work) from that
-copyright holder, and you cure the violation prior to 30 days after
-your receipt of the notice.
-
-  Termination of your rights under this section does not terminate the
-licenses of parties who have received copies or rights from you under
-this License.  If your rights have been terminated and not permanently
-reinstated, you do not qualify to receive new licenses for the same
-material under section 10.
-
-  9. Acceptance Not Required for Having Copies.
-
-  You are not required to accept this License in order to receive or
-run a copy of the Program.  Ancillary propagation of a covered work
-occurring solely as a consequence of using peer-to-peer transmission
-to receive a copy likewise does not require acceptance.  However,
-nothing other than this License grants you permission to propagate or
-modify any covered work.  These actions infringe copyright if you do
-not accept this License.  Therefore, by modifying or propagating a
-covered work, you indicate your acceptance of this License to do so.
-
-  10. Automatic Licensing of Downstream Recipients.
-
-  Each time you convey a covered work, the recipient automatically
-receives a license from the original licensors, to run, modify and
-propagate that work, subject to this License.  You are not responsible
-for enforcing compliance by third parties with this License.
-
-  An "entity transaction" is a transaction transferring control of an
-organization, or substantially all assets of one, or subdividing an
-organization, or merging organizations.  If propagation of a covered
-work results from an entity transaction, each party to that
-transaction who receives a copy of the work also receives whatever
-licenses to the work the party's predecessor in interest had or could
-give under the previous paragraph, plus a right to possession of the
-Corresponding Source of the work from the predecessor in interest, if
-the predecessor has it or can get it with reasonable efforts.
-
-  You may not impose any further restrictions on the exercise of the
-rights granted or affirmed under this License.  For example, you may
-not impose a license fee, royalty, or other charge for exercise of
-rights granted under this License, and you may not initiate litigation
-(including a cross-claim or counterclaim in a lawsuit) alleging that
-any patent claim is infringed by making, using, selling, offering for
-sale, or importing the Program or any portion of it.
-
-  11. Patents.
-
-  A "contributor" is a copyright holder who authorizes use under this
-License of the Program or a work on which the Program is based.  The
-work thus licensed is called the contributor's "contributor version".
-
-  A contributor's "essential patent claims" are all patent claims
-owned or controlled by the contributor, whether already acquired or
-hereafter acquired, that would be infringed by some manner, permitted
-by this License, of making, using, or selling its contributor version,
-but do not include claims that would be infringed only as a
-consequence of further modification of the contributor version.  For
-purposes of this definition, "control" includes the right to grant
-patent sublicenses in a manner consistent with the requirements of
-this License.
-
-  Each contributor grants you a non-exclusive, worldwide, royalty-free
-patent license under the contributor's essential patent claims, to
-make, use, sell, offer for sale, import and otherwise run, modify and
-propagate the contents of its contributor version.
-
-  In the following three paragraphs, a "patent license" is any express
-agreement or commitment, however denominated, not to enforce a patent
-(such as an express permission to practice a patent or covenant not to
-sue for patent infringement).  To "grant" such a patent license to a
-party means to make such an agreement or commitment not to enforce a
-patent against the party.
-
-  If you convey a covered work, knowingly relying on a patent license,
-and the Corresponding Source of the work is not available for anyone
-to copy, free of charge and under the terms of this License, through a
-publicly available network server or other readily accessible means,
-then you must either (1) cause the Corresponding Source to be so
-available, or (2) arrange to deprive yourself of the benefit of the
-patent license for this particular work, or (3) arrange, in a manner
-consistent with the requirements of this License, to extend the patent
-license to downstream recipients.  "Knowingly relying" means you have
-actual knowledge that, but for the patent license, your conveying the
-covered work in a country, or your recipient's use of the covered work
-in a country, would infringe one or more identifiable patents in that
-country that you have reason to believe are valid.
-
-  If, pursuant to or in connection with a single transaction or
-arrangement, you convey, or propagate by procuring conveyance of, a
-covered work, and grant a patent license to some of the parties
-receiving the covered work authorizing them to use, propagate, modify
-or convey a specific copy of the covered work, then the patent license
-you grant is automatically extended to all recipients of the covered
-work and works based on it.
-
-  A patent license is "discriminatory" if it does not include within
-the scope of its coverage, prohibits the exercise of, or is
-conditioned on the non-exercise of one or more of the rights that are
-specifically granted under this License.  You may not convey a covered
-work if you are a party to an arrangement with a third party that is
-in the business of distributing software, under which you make payment
-to the third party based on the extent of your activity of conveying
-the work, and under which the third party grants, to any of the
-parties who would receive the covered work from you, a discriminatory
-patent license (a) in connection with copies of the covered work
-conveyed by you (or copies made from those copies), or (b) primarily
-for and in connection with specific products or compilations that
-contain the covered work, unless you entered into that arrangement,
-or that patent license was granted, prior to 28 March 2007.
-
-  Nothing in this License shall be construed as excluding or limiting
-any implied license or other defenses to infringement that may
-otherwise be available to you under applicable patent law.
-
-  12. No Surrender of Others' Freedom.
-
-  If conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot convey a
-covered work so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you may
-not convey it at all.  For example, if you agree to terms that obligate you
-to collect a royalty for further conveying from those to whom you convey
-the Program, the only way you could satisfy both those terms and this
-License would be to refrain entirely from conveying the Program.
-
-  13. Remote Network Interaction; Use with the GNU General Public License.
-
-  Notwithstanding any other provision of this License, if you modify the
-Program, your modified version must prominently offer all users
-interacting with it remotely through a computer network (if your version
-supports such interaction) an opportunity to receive the Corresponding
-Source of your version by providing access to the Corresponding Source
-from a network server at no charge, through some standard or customary
-means of facilitating copying of software.  This Corresponding Source
-shall include the Corresponding Source for any work covered by version 3
-of the GNU General Public License that is incorporated pursuant to the
-following paragraph.
-
-  Notwithstanding any other provision of this License, you have
-permission to link or combine any covered work with a work licensed
-under version 3 of the GNU General Public License into a single
-combined work, and to convey the resulting work.  The terms of this
-License will continue to apply to the part which is the covered work,
-but the work with which it is combined will remain governed by version
-3 of the GNU General Public License.
-
-  14. Revised Versions of this License.
-
-  The Free Software Foundation may publish revised and/or new versions of
-the GNU Affero General Public License from time to time.  Such new versions
-will be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-  Each version is given a distinguishing version number.  If the
-Program specifies that a certain numbered version of the GNU Affero General
-Public License "or any later version" applies to it, you have the
-option of following the terms and conditions either of that numbered
-version or of any later version published by the Free Software
-Foundation.  If the Program does not specify a version number of the
-GNU Affero General Public License, you may choose any version ever published
-by the Free Software Foundation.
-
-  If the Program specifies that a proxy can decide which future
-versions of the GNU Affero General Public License can be used, that proxy's
-public statement of acceptance of a version permanently authorizes you
-to choose that version for the Program.
-
-  Later license versions may give you additional or different
-permissions.  However, no additional obligations are imposed on any
-author or copyright holder as a result of your choosing to follow a
-later version.
-
-  15. Disclaimer of Warranty.
-
-  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
-APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
-HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
-OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
-IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
-ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. Limitation of Liability.
-
-  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
-THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
-GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
-USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
-DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
-PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
-EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
-SUCH DAMAGES.
-
-  17. Interpretation of Sections 15 and 16.
-
-  If the disclaimer of warranty and limitation of liability provided
-above cannot be given local legal effect according to their terms,
-reviewing courts shall apply local law that most closely approximates
-an absolute waiver of all civil liability in connection with the
-Program, unless a warranty or assumption of liability accompanies a
-copy of the Program in return for a fee.
-
-                     END OF TERMS AND CONDITIONS
-
-            How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-state the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Affero General Public License as published
-    by the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Affero General Public License for more details.
-
-    You should have received a copy of the GNU Affero General Public License
-    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-Also add information on how to contact you by electronic and paper mail.
-
-  If your software can interact with users remotely through a computer
-network, you should also make sure that it provides a way for users to
-get its source.  For example, if your program is a web application, its
-interface could display a "Source" link that leads users to an archive
-of the code.  There are many ways you could offer source, and different
-solutions will be better for different programs; see section 13 for the
-specific requirements.
-
-  You should also get your employer (if you work as a programmer) or school,
-if any, to sign a "copyright disclaimer" for the program, if necessary.
-For more information on this, and how to apply and follow the GNU AGPL, see
-<https://www.gnu.org/licenses/>.
+                    GNU AFFERO GENERAL PUBLIC LICENSE
+                       Version 3, 19 November 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU Affero General Public License is a free, copyleft license for
+software and other kinds of works, specifically designed to ensure
+cooperation with the community in the case of network server software.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+our General Public Licenses are intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  Developers that use our General Public Licenses protect your rights
+with two steps: (1) assert copyright on the software, and (2) offer
+you this License which gives you legal permission to copy, distribute
+and/or modify the software.
+
+  A secondary benefit of defending all users' freedom is that
+improvements made in alternate versions of the program, if they
+receive widespread use, become available for other developers to
+incorporate.  Many developers of free software are heartened and
+encouraged by the resulting cooperation.  However, in the case of
+software used on network servers, this result may fail to come about.
+The GNU General Public License permits making a modified version and
+letting the public access it on a server without ever releasing its
+source code to the public.
+
+  The GNU Affero General Public License is designed specifically to
+ensure that, in such cases, the modified source code becomes available
+to the community.  It requires the operator of a network server to
+provide the source code of the modified version running there to the
+users of that server.  Therefore, public use of a modified version, on
+a publicly accessible server, gives the public access to the source
+code of the modified version.
+
+  An older license, called the Affero General Public License and
+published by Affero, was designed to accomplish similar goals.  This is
+a different license, not a version of the Affero GPL, but Affero has
+released a new version of the Affero GPL which permits relicensing under
+this license.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU Affero General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Remote Network Interaction; Use with the GNU General Public License.
+
+  Notwithstanding any other provision of this License, if you modify the
+Program, your modified version must prominently offer all users
+interacting with it remotely through a computer network (if your version
+supports such interaction) an opportunity to receive the Corresponding
+Source of your version by providing access to the Corresponding Source
+from a network server at no charge, through some standard or customary
+means of facilitating copying of software.  This Corresponding Source
+shall include the Corresponding Source for any work covered by version 3
+of the GNU General Public License that is incorporated pursuant to the
+following paragraph.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the work with which it is combined will remain governed by version
+3 of the GNU General Public License.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU Affero General Public License from time to time.  Such new versions
+will be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU Affero General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU Affero General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU Affero General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Affero General Public License as published
+    by the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Affero General Public License for more details.
+
+    You should have received a copy of the GNU Affero General Public License
+    along with this program.  If not, see <https://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If your software can interact with users remotely through a computer
+network, you should also make sure that it provides a way for users to
+get its source.  For example, if your program is a web application, its
+interface could display a "Source" link that leads users to an archive
+of the code.  There are many ways you could offer source, and different
+solutions will be better for different programs; see section 13 for the
+specific requirements.
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU AGPL, see
+<https://www.gnu.org/licenses/>.
```

### Comparing `stixorm-0.1.3/README.md` & `stixorm-0.1.9/README.md`

 * *Ordering differences only*

 * *Files 8% similar despite different names*

```diff
@@ -1,96 +1,96 @@
-# Stix <-> TypeDB ORM
-
-# Explanation of Repo
-This Repo is designed to make it easy to build, test and play with the Stix <-> TypeDB ORM. It is based around the OASIS Stix2 Python Library, and is an implementation of their datastore api (https://stix2.readthedocs.io/en/latest/api/stix2.datastore.html).
-
-The implementation is minimal, it enables TypeDB to be setup as a Stix2 DataSink and DataSource, with implementation of both the DataSink init and  add methods, and the DataSource init and get methods.
-
-A number of features from the library are not developed yet, including combining the DataSource and DataSink into a DataStore, running filters on queries, loading from files and other methods.
-
-## Installation
-Download and install using
-
-    pipenv install
-
-then start the virtual environment with 
-
-    pipenv shell    
-
-## Suggested Experiments
-Examine and run the granular marking example with
-
-    python test.py
-    
-Notice how the granular marking input example, has different markings for each of the items in a list? Compare those indexes to the TypeQL statements and the final output. See how the indexes and the list are now reversed?
-
-Examine how the ORM handles different shaped objects in the various directories. Check out:
-- examples directory: Granular markings versus Data Markings
-- standard directory: Email_mime, file_binary, file_ntfs_stream, network_ext_HTTP_request, X509_cert_v3_ext
-- threat_reports director: Check out the final report, and the size of the auto-generated relation
-
-To do this, use 
-
-    python check_dir.py
-
-and scroll through the logging output. Change the directory name as needed to change the directory focus
-
-## Contents
-There are 3 directories and some local files.
-
-### 1. Stix Directory
-The Stix directory contains the actual module needed to be integrated with the Stix2 python library. 
-
-The module sub-drectory has two files:
-- Typedb.py: Our implementation of https://github.com/oasis-open/cti-python-stix2/blob/master/stix2/datastore/filesystem.py. 
-- stql.py: Handles all of the translation tasks for the typedb file. The file is split into four sections:
-1. Convert Stix to TypeQL Match, Insert: Lines 1-735
-2. Dispatch Dicts: Lines 735 - 1,980
-3. Retrieve Stage 2: Intermediate to Final Shape: Lines 1,980 to 2,580
-4. Retrieve Stage 1: TypeDB to Intermediate Shape: Lines 2,580 to 3,120
-
-The schema sub directory has 3 files:
-- cti-schema-v2.tql - updated Tomas schema
-- cti-rules.tql - updated Tomas rules
-- initialise.py - updated initialise file
-
-### 2. Data Directory
-The data directory contains all of the test examples harvested from the web
-
-- examples dir: Stix examples harvested from https://oasis-open.github.io/cti-documentation/stix/examples
-- standard dir: Stix examples harvested from chapters 3, 4, 5, 6 and 7 of the official Stix webpage https://docs.oasis-open.org/cti/stix/v2.1/os/stix-v2.1-os.html. Contains sub directory of Issues (e.g. cyclical relations)
-- threat_reports dir: Stix examples harvested from the threat reports section of https://oasis-open.github.io/cti-documentation/stix/examples
-- mitre dir: Stix examples harvested from https://github.com/mitre-attack/attack-stix-data WARNING ATT&CK EXTENSIONS NOT IMPLEMENTED YET. DO NOT USE
-- appendix_c dir: Appendix C examples from the main documentation page https://docs.oasis-open.org/cti/stix/v2.1/os/stix-v2.1-os.html#_wwok3b866yjl 
-
-
-### 3. Docs Directory
-There are some markdown docs that contain incomplete documentation describing the transform between TypeDB and Stix names and structures,
-
-### 4. Local Files
-There are four local files:
-- test.py: Enables loading of individual data files, and retrieving of a single Stix_id. It is currently set to examine the Granular Markings and how polymorphic lists mean outputs lose their absolute order, but retain their relative order.
-- check_dir.py: Enables each data file in a a directory to be loaded into TypeDB, and then every object to be sequentially retrieved and printed. The process handles files with either bundles or lists of objects. 
-- export_test.json: An export of the intermediate form of the last object to be retrieved from the datastore
-- export_final.json: An export of the final form of the last object to be retrieved from the datastore
-
-### 5. Code information
-
-TypeDB:
-- init() - create clean database with schema and marking objects loaded
-- add() - can add single objects, lists and bundles
-- get() - can get single object based on id
-- get_all_ids() - get all of the stix ids in the database as a list (except for marking objects)
-- delete () - delete a list of sitx ids, orders the records and checks for missing dependencies and circular references
-
-
-Raw STIX method:
-
-dep_match, dep_insert, indep_ql, core_ql, dep_obj = raw_stix2_to_typeql(local_obj, self.import_type)
-
-Returned description:
-* dep_match: the matches needed for the new object that are dependent on other objects, already inserted
-* dep_insert: the inserts needed for the new objects that are dependent on matches with existing objects
-* indep-ql: the inserts for the new object that are indepdpent of other objects
-* core_ql: statements describing the main  object and its stix id
-* dep_obj: The dependency object for this objects, used to order it in a list. Contains its own id, and a list of all of the ids it is dependent on (i.e. dependent objects must be added before, or deleted after, this object)
-
+# Stix <-> TypeDB ORM
+
+# Explanation of Repo
+This Repo is designed to make it easy to build, test and play with the Stix <-> TypeDB ORM. It is based around the OASIS Stix2 Python Library, and is an implementation of their datastore api (https://stix2.readthedocs.io/en/latest/api/stix2.datastore.html).
+
+The implementation is minimal, it enables TypeDB to be setup as a Stix2 DataSink and DataSource, with implementation of both the DataSink init and  add methods, and the DataSource init and get methods.
+
+A number of features from the library are not developed yet, including combining the DataSource and DataSink into a DataStore, running filters on queries, loading from files and other methods.
+
+## Installation
+Download and install using
+
+    pipenv install
+
+then start the virtual environment with 
+
+    pipenv shell    
+
+## Suggested Experiments
+Examine and run the granular marking example with
+
+    python test.py
+    
+Notice how the granular marking input example, has different markings for each of the items in a list? Compare those indexes to the TypeQL statements and the final output. See how the indexes and the list are now reversed?
+
+Examine how the ORM handles different shaped objects in the various directories. Check out:
+- examples directory: Granular markings versus Data Markings
+- standard directory: Email_mime, file_binary, file_ntfs_stream, network_ext_HTTP_request, X509_cert_v3_ext
+- threat_reports director: Check out the final report, and the size of the auto-generated relation
+
+To do this, use 
+
+    python check_dir.py
+
+and scroll through the logging output. Change the directory name as needed to change the directory focus
+
+## Contents
+There are 3 directories and some local files.
+
+### 1. Stix Directory
+The Stix directory contains the actual module needed to be integrated with the Stix2 python library. 
+
+The module sub-drectory has two files:
+- Typedb.py: Our implementation of https://github.com/oasis-open/cti-python-stix2/blob/master/stix2/datastore/filesystem.py. 
+- stql.py: Handles all of the translation tasks for the typedb file. The file is split into four sections:
+1. Convert Stix to TypeQL Match, Insert: Lines 1-735
+2. Dispatch Dicts: Lines 735 - 1,980
+3. Retrieve Stage 2: Intermediate to Final Shape: Lines 1,980 to 2,580
+4. Retrieve Stage 1: TypeDB to Intermediate Shape: Lines 2,580 to 3,120
+
+The schema sub directory has 3 files:
+- cti-schema-v2.tql - updated Tomas schema
+- cti-rules.tql - updated Tomas rules
+- initialise.py - updated initialise file
+
+### 2. Data Directory
+The data directory contains all of the test examples harvested from the web
+
+- examples dir: Stix examples harvested from https://oasis-open.github.io/cti-documentation/stix/examples
+- standard dir: Stix examples harvested from chapters 3, 4, 5, 6 and 7 of the official Stix webpage https://docs.oasis-open.org/cti/stix/v2.1/os/stix-v2.1-os.html. Contains sub directory of Issues (e.g. cyclical relations)
+- threat_reports dir: Stix examples harvested from the threat reports section of https://oasis-open.github.io/cti-documentation/stix/examples
+- mitre dir: Stix examples harvested from https://github.com/mitre-attack/attack-stix-data WARNING ATT&CK EXTENSIONS NOT IMPLEMENTED YET. DO NOT USE
+- appendix_c dir: Appendix C examples from the main documentation page https://docs.oasis-open.org/cti/stix/v2.1/os/stix-v2.1-os.html#_wwok3b866yjl 
+
+
+### 3. Docs Directory
+There are some markdown docs that contain incomplete documentation describing the transform between TypeDB and Stix names and structures,
+
+### 4. Local Files
+There are four local files:
+- test.py: Enables loading of individual data files, and retrieving of a single Stix_id. It is currently set to examine the Granular Markings and how polymorphic lists mean outputs lose their absolute order, but retain their relative order.
+- check_dir.py: Enables each data file in a a directory to be loaded into TypeDB, and then every object to be sequentially retrieved and printed. The process handles files with either bundles or lists of objects. 
+- export_test.json: An export of the intermediate form of the last object to be retrieved from the datastore
+- export_final.json: An export of the final form of the last object to be retrieved from the datastore
+
+### 5. Code information
+
+TypeDB:
+- init() - create clean database with schema and marking objects loaded
+- add() - can add single objects, lists and bundles
+- get() - can get single object based on id
+- get_all_ids() - get all of the stix ids in the database as a list (except for marking objects)
+- delete () - delete a list of sitx ids, orders the records and checks for missing dependencies and circular references
+
+
+Raw STIX method:
+
+dep_match, dep_insert, indep_ql, core_ql, dep_obj = raw_stix2_to_typeql(local_obj, self.import_type)
+
+Returned description:
+* dep_match: the matches needed for the new object that are dependent on other objects, already inserted
+* dep_insert: the inserts needed for the new objects that are dependent on matches with existing objects
+* indep-ql: the inserts for the new object that are indepdpent of other objects
+* core_ql: statements describing the main  object and its stix id
+* dep_obj: The dependency object for this objects, used to order it in a list. Contains its own id, and a list of all of the ids it is dependent on (i.e. dependent objects must be added before, or deleted after, this object)
+
```

### Comparing `stixorm-0.1.3/stixorm/module/authorise.py` & `stixorm-0.1.9/stixorm/module/authorise.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,164 +1,164 @@
-
-import logging
-from typing import List
-
-from stixorm.module.definitions.property_definitions import get_libraries
-from stixorm.module.typedb_lib.factories.definition_factory import get_definition_factory_instance, DomainDefinition
-from stixorm.module.typedb_lib.factories.import_type_factory import ImportTypeFactory, ImportType
-from stixorm.module.typedb_lib.factories.process_map_factory import ProcessMapFactory
-
-logger = logging.getLogger(__name__)
-
-
-
-##############################################################
-#  1.) Default Import Type at only Stix Objects, all else False
-############################################################
-
-
-import_type_factory = ImportTypeFactory.get_import_type_factory()
-default_import_type = import_type_factory.get_default_import()
-
-
-def authorised_mappings(import_type: ImportType=default_import_type):
-    auth = {}
-    auth["reln_name"] = {}
-    auth["reln"] = {}
-    auth["tql_types"] = {}
-    auth["types"] = {}
-    auth["is_lists"] = {}
-    definition_factory = get_definition_factory_instance()
-    auth_domains: List[DomainDefinition] = definition_factory.get_definitions_for_import(import_type)
-
-
-    dom= get_libraries()
-    # initialise authorisation object, for documentation purposes
-    auth["reln_name"]["embedded_relations"] = []
-    auth["reln_name"]["standard_relations"] = []
-    auth["reln_name"]["list_of_objects"] = []
-    auth["reln_name"]["key_value_relations"] = []
-    auth["reln_name"]["extension_relations"] = []
-    auth["reln_name"]["relations_sro_roles"] = []
-    auth["reln"]["embedded_relations"] = []
-    auth["reln"]["standard_relations"] = []
-    auth["reln"]["list_of_objects"] = []
-    auth["reln"]["key_value_relations"] = []
-    auth["reln"]["extension_relations"] = []
-    auth["reln"]["relations_sro_roles"] = []
-    auth["tql_types"]["embedded_relations"] = []
-    auth["tql_types"]["standard_relations"] = []
-    auth["tql_types"]["list_of_objects"] = []
-    auth["tql_types"]["key_value_relations"] = []
-    auth["tql_types"]["extension_relations"] = []
-    auth["tql_types"]["relations_sro_roles"] = []
-    auth["tql_types"]["sdo"] = []
-    auth["tql_types"]["sro"] = []
-    auth["tql_types"]["sco"] = []
-    auth["tql_types"]["sub"] = []
-    auth["tql_types"]["meta"] = []
-    auth["types"]["sdo"] = []
-    auth["types"]["sro"] = []
-    auth["types"]["sco"] = []
-    auth["types"]["sub"] = []
-    auth["types"]["meta"] = []
-    auth["is_lists"]["sdo"] = {}
-    auth["is_lists"]["sro"] = {}
-    auth["is_lists"]["sco"] = {}
-    auth["is_lists"]["sub"] = {}
-    auth["is_lists"]["meta"] = {}
-    auth["sub_objects"] = {}
-    auth["objects"] = {}
-    auth["conv"] = {}
-    auth["conv"]["sdo"] = []
-    auth["conv"]["sro"] = []
-    auth["conv"]["sco"] = []
-    auth["conv"]["sub"] = []
-    auth["conv"]["meta"] = []
-    auth["classes"] = {}
-    auth["classes"]["sdo"] = {}
-    auth["classes"]["sro"] = {}
-    auth["classes"]["sco"] = {}
-    auth["classes"]["sub"] = {}
-    auth["classes"]["meta"] = {}
-
-    process_map_factory = ProcessMapFactory.process_map_factory()
-    process_maps = process_map_factory.all_process_maps()
-
-    for j, domain in enumerate(auth_domains):
-        for process in process_maps:
-            name = process.name
-            keys = process.keys
-            matches = process.match
-            conds = process.cond
-            if name == "reln_name":
-                #logger.debug("----------- reln_name ------------")
-                for i, key in enumerate(keys):
-                    if domain.contains_mapping(matches[i]):
-                        #logger.debug(f'Auth Loading: domain->{dom[j]}, name->{name}, key->{keys[i]}, match->{matches[i]}, cond->{conds[i]}')
-                        value_list = [x[conds[i]] for x in domain.get_mapping(matches[i])]
-                        auth[name][key].extend(value_list)
-            elif name == "reln":
-                #logger.debug("--------- reln--------------")
-                for i, key in enumerate(keys):
-                    if domain.contains_mapping(matches[i]):
-                        #logger.debug(f'Auth Loading: domain->{dom[j]}, name->{name}, key->{key}, match->{matches[i]}')
-                        value_list =  domain.get_mapping(matches[i])
-                        auth[name][key].extend(value_list)
-            elif name == "tql_types1":
-                #logger.debug("--------- reln--------------")
-                for i, key in enumerate(keys):
-                    if domain.contains_mapping(matches[i]):
-                        logger.debug(f'\nAuth Loading: domain->{dom[j]}, name->{name}, key->{key}, match->{matches[i]}')
-                        value_list = [x[conds[i]] for x in domain.get_mapping(matches[i])]
-                        logger.debug(f'value list -> {value_list}')
-                        auth["tql_types"][key].extend(value_list)
-            elif name == "tql_types":
-                #logger.debug("---------- tql_types -------------")
-                for i, key in enumerate(keys):
-                    if domain.contains_mapping("object_conversion"):
-                        #logger.debug(f'Auth Loading: domain->{dom[j]}, name->{name}, key->{keys[i]}, match->{matches[i]}, cond->{conds[i]}')
-                        value_list_type = [x["type"] for x in domain.get_mapping(matches[i]) if x["object"] == conds[i]]
-                        value_list_typeql = [x["typeql"] for x in domain.get_mapping(matches[i]) if x["object"] == conds[i]]
-                        logger.debug(f' value_list_type -> {value_list_type}\n\n value_list_typeql -> {value_list_typeql}')
-                        auth["tql_types"][key].extend(value_list_typeql)
-                        auth["types"][key].extend(value_list_type)
-
-                #auth["tql_types"]["meta"] = stix_models["mappings"]["types_meta"]
-            elif name == "is_lists":
-                #logger.debug("--------- is_lists --------------")
-                for i, key in enumerate(keys):
-                    if domain.contains_mapping(matches[i]):
-                        #logger.debug(f'Auth Loading: domain->{dom[j]}, name->{name}, key->{keys[i]}, match->{matches[i]}, cond->{conds[i]}')
-                        value_dict = domain.get_mapping(matches[i])
-                        auth[name][key].update(value_dict)
-            elif name == "direct":
-                #logger.debug("-------- direct ---------------")
-                for i, key in enumerate(keys):
-                    if domain.does_property_contain_values(matches[i]):
-                        #logger.debug(f'Auth Loading: domain->{dom[j]}, name->{name}, key->{keys[i]}, match->{matches[i]}')
-                        value_dict = domain.get_property_values(matches[i])
-                        auth[key].update(value_dict)
-            elif name == "conv":
-                #logger.debug("-------- conv ---------------")
-                for i, key in enumerate(keys):
-                    if domain.contains_mapping("object_conversion"):
-                        #logger.debug(f'Auth Loading: domain->{dom[j]}, name->{name}, key->{keys[i]}, match->{matches[i]}, cond->{conds[i]}')
-                        value_list = [x for x in domain.get_mapping("object_conversion") if x["object"] == conds[i]]
-                        auth[name][key].extend(value_list)
-            elif name == "classes":
-                #logger.debug("-------- conv ---------------")
-                for i, key in enumerate(keys):
-                    if domain.does_classes_contain_values(key):
-                        #logger.debug(f'Auth Loading: domain->{dom[j]}, name->{name}, key->{keys[i]}, match->{matches[i]}, cond->{conds[i]}')
-                        value_dict = domain.get_classes_property_values(key)
-                        auth[name][key].update(value_dict)
-
-            else:
-                pass
-
-
-    # finally add the import type to the auth object
-    auth.update(ImportTypeFactory.convert_to_dict(import_type))
-
-    return auth
-
+
+import logging
+from typing import List
+
+from stixorm.module.definitions.property_definitions import get_libraries
+from stixorm.module.typedb_lib.factories.definition_factory import get_definition_factory_instance, DomainDefinition
+from stixorm.module.typedb_lib.factories.import_type_factory import ImportTypeFactory, ImportType
+from stixorm.module.typedb_lib.factories.process_map_factory import ProcessMapFactory
+
+logger = logging.getLogger(__name__)
+
+
+
+##############################################################
+#  1.) Default Import Type at only Stix Objects, all else False
+############################################################
+
+
+import_type_factory = ImportTypeFactory.get_import_type_factory()
+default_import_type = import_type_factory.get_default_import()
+
+
+def authorised_mappings(import_type: ImportType=default_import_type):
+    auth = {}
+    auth["reln_name"] = {}
+    auth["reln"] = {}
+    auth["tql_types"] = {}
+    auth["types"] = {}
+    auth["is_lists"] = {}
+    definition_factory = get_definition_factory_instance()
+    auth_domains: List[DomainDefinition] = definition_factory.get_definitions_for_import(import_type)
+
+
+    dom= get_libraries()
+    # initialise authorisation object, for documentation purposes
+    auth["reln_name"]["embedded_relations"] = []
+    auth["reln_name"]["standard_relations"] = []
+    auth["reln_name"]["list_of_objects"] = []
+    auth["reln_name"]["key_value_relations"] = []
+    auth["reln_name"]["extension_relations"] = []
+    auth["reln_name"]["relations_sro_roles"] = []
+    auth["reln"]["embedded_relations"] = []
+    auth["reln"]["standard_relations"] = []
+    auth["reln"]["list_of_objects"] = []
+    auth["reln"]["key_value_relations"] = []
+    auth["reln"]["extension_relations"] = []
+    auth["reln"]["relations_sro_roles"] = []
+    auth["tql_types"]["embedded_relations"] = []
+    auth["tql_types"]["standard_relations"] = []
+    auth["tql_types"]["list_of_objects"] = []
+    auth["tql_types"]["key_value_relations"] = []
+    auth["tql_types"]["extension_relations"] = []
+    auth["tql_types"]["relations_sro_roles"] = []
+    auth["tql_types"]["sdo"] = []
+    auth["tql_types"]["sro"] = []
+    auth["tql_types"]["sco"] = []
+    auth["tql_types"]["sub"] = []
+    auth["tql_types"]["meta"] = []
+    auth["types"]["sdo"] = []
+    auth["types"]["sro"] = []
+    auth["types"]["sco"] = []
+    auth["types"]["sub"] = []
+    auth["types"]["meta"] = []
+    auth["is_lists"]["sdo"] = {}
+    auth["is_lists"]["sro"] = {}
+    auth["is_lists"]["sco"] = {}
+    auth["is_lists"]["sub"] = {}
+    auth["is_lists"]["meta"] = {}
+    auth["sub_objects"] = {}
+    auth["objects"] = {}
+    auth["conv"] = {}
+    auth["conv"]["sdo"] = []
+    auth["conv"]["sro"] = []
+    auth["conv"]["sco"] = []
+    auth["conv"]["sub"] = []
+    auth["conv"]["meta"] = []
+    auth["classes"] = {}
+    auth["classes"]["sdo"] = {}
+    auth["classes"]["sro"] = {}
+    auth["classes"]["sco"] = {}
+    auth["classes"]["sub"] = {}
+    auth["classes"]["meta"] = {}
+
+    process_map_factory = ProcessMapFactory.process_map_factory()
+    process_maps = process_map_factory.all_process_maps()
+
+    for j, domain in enumerate(auth_domains):
+        for process in process_maps:
+            name = process.name
+            keys = process.keys
+            matches = process.match
+            conds = process.cond
+            if name == "reln_name":
+                #logger.debug("----------- reln_name ------------")
+                for i, key in enumerate(keys):
+                    if domain.contains_mapping(matches[i]):
+                        #logger.debug(f'Auth Loading: domain->{dom[j]}, name->{name}, key->{keys[i]}, match->{matches[i]}, cond->{conds[i]}')
+                        value_list = [x[conds[i]] for x in domain.get_mapping(matches[i])]
+                        auth[name][key].extend(value_list)
+            elif name == "reln":
+                #logger.debug("--------- reln--------------")
+                for i, key in enumerate(keys):
+                    if domain.contains_mapping(matches[i]):
+                        #logger.debug(f'Auth Loading: domain->{dom[j]}, name->{name}, key->{key}, match->{matches[i]}')
+                        value_list =  domain.get_mapping(matches[i])
+                        auth[name][key].extend(value_list)
+            elif name == "tql_types1":
+                #logger.debug("--------- reln--------------")
+                for i, key in enumerate(keys):
+                    if domain.contains_mapping(matches[i]):
+                        logger.debug(f'\nAuth Loading: domain->{dom[j]}, name->{name}, key->{key}, match->{matches[i]}')
+                        value_list = [x[conds[i]] for x in domain.get_mapping(matches[i])]
+                        logger.debug(f'value list -> {value_list}')
+                        auth["tql_types"][key].extend(value_list)
+            elif name == "tql_types":
+                #logger.debug("---------- tql_types -------------")
+                for i, key in enumerate(keys):
+                    if domain.contains_mapping("object_conversion"):
+                        #logger.debug(f'Auth Loading: domain->{dom[j]}, name->{name}, key->{keys[i]}, match->{matches[i]}, cond->{conds[i]}')
+                        value_list_type = [x["type"] for x in domain.get_mapping(matches[i]) if x["object"] == conds[i]]
+                        value_list_typeql = [x["typeql"] for x in domain.get_mapping(matches[i]) if x["object"] == conds[i]]
+                        logger.debug(f' value_list_type -> {value_list_type}\n\n value_list_typeql -> {value_list_typeql}')
+                        auth["tql_types"][key].extend(value_list_typeql)
+                        auth["types"][key].extend(value_list_type)
+
+                #auth["tql_types"]["meta"] = stix_models["mappings"]["types_meta"]
+            elif name == "is_lists":
+                #logger.debug("--------- is_lists --------------")
+                for i, key in enumerate(keys):
+                    if domain.contains_mapping(matches[i]):
+                        #logger.debug(f'Auth Loading: domain->{dom[j]}, name->{name}, key->{keys[i]}, match->{matches[i]}, cond->{conds[i]}')
+                        value_dict = domain.get_mapping(matches[i])
+                        auth[name][key].update(value_dict)
+            elif name == "direct":
+                #logger.debug("-------- direct ---------------")
+                for i, key in enumerate(keys):
+                    if domain.does_property_contain_values(matches[i]):
+                        #logger.debug(f'Auth Loading: domain->{dom[j]}, name->{name}, key->{keys[i]}, match->{matches[i]}')
+                        value_dict = domain.get_property_values(matches[i])
+                        auth[key].update(value_dict)
+            elif name == "conv":
+                #logger.debug("-------- conv ---------------")
+                for i, key in enumerate(keys):
+                    if domain.contains_mapping("object_conversion"):
+                        #logger.debug(f'Auth Loading: domain->{dom[j]}, name->{name}, key->{keys[i]}, match->{matches[i]}, cond->{conds[i]}')
+                        value_list = [x for x in domain.get_mapping("object_conversion") if x["object"] == conds[i]]
+                        auth[name][key].extend(value_list)
+            elif name == "classes":
+                #logger.debug("-------- conv ---------------")
+                for i, key in enumerate(keys):
+                    if domain.does_classes_contain_values(key):
+                        #logger.debug(f'Auth Loading: domain->{dom[j]}, name->{name}, key->{keys[i]}, match->{matches[i]}, cond->{conds[i]}')
+                        value_dict = domain.get_classes_property_values(key)
+                        auth[name][key].update(value_dict)
+
+            else:
+                pass
+
+
+    # finally add the import type to the auth object
+    auth.update(ImportTypeFactory.convert_to_dict(import_type))
+
+    return auth
+
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/attack/__init__.py` & `stixorm-0.1.9/stixorm/module/definitions/attack/__init__.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-"""
-Loader module for all ATT&CK data model
-"""
-
-__author__ = "Brett Forbes"
-__credits__ = ["Paolo Di Prodi"]
-__license__ = "GPL"
-__version__ = "0.1.0"
-__maintainer__ = "Paolo Di Prodi"
-__email__ = "paolo@priam.ai"
-__status__ = "Production"
-
-
-
-
-from stixorm.module.definitions.attack.classes import (
-    Matrix, Tactic, Technique, SubTechnique, Mitigation, Group, SoftwareMalware,
-    SoftwareTool, DataSource, DataComponent, AttackCampaign, Collection,
-    ObjectVersion, AttackRelation, AttackMarking, AttackIdentity
-)
-name = "attack"
-class_model={}
-class_model["sdo"] = {
-    "Matrix": Matrix,
-    "Tactic": Tactic,
-    "Technique": Technique,
-    "SubTechnique": SubTechnique,
-    "Mitigation": Mitigation,
-    "Group": Group,
-    "SoftwareMalware": SoftwareMalware,
-    "SoftwareTool": SoftwareTool,
-    "DataSource": DataSource,
-    "DataComponent": DataComponent,
-    "AttackCampaign": AttackCampaign,
-    "Collection": Collection,
-    "AttackIdentity": AttackIdentity
-}
-class_model["sub"] = {
-    "ObjectVersion": ObjectVersion
-}
-class_model["sco"] = {}
-class_model["meta"] = {
-    "AttackMarking": AttackMarking
-}
-class_model["sro"] = {
-    "AttackRelation": AttackRelation
-}
-
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+"""
+Loader module for all ATT&CK data model
+"""
+
+__author__ = "Brett Forbes"
+__credits__ = ["Paolo Di Prodi"]
+__license__ = "GPL"
+__version__ = "0.1.0"
+__maintainer__ = "Paolo Di Prodi"
+__email__ = "paolo@priam.ai"
+__status__ = "Production"
+
+
+
+
+from stixorm.module.definitions.attack.classes import (
+    Matrix, Tactic, Technique, SubTechnique, Mitigation, Group, SoftwareMalware,
+    SoftwareTool, DataSource, DataComponent, AttackCampaign, Collection,
+    ObjectVersion, AttackRelation, AttackMarking, AttackIdentity
+)
+name = "attack"
+class_model={}
+class_model["sdo"] = {
+    "Matrix": Matrix,
+    "Tactic": Tactic,
+    "Technique": Technique,
+    "SubTechnique": SubTechnique,
+    "Mitigation": Mitigation,
+    "Group": Group,
+    "SoftwareMalware": SoftwareMalware,
+    "SoftwareTool": SoftwareTool,
+    "DataSource": DataSource,
+    "DataComponent": DataComponent,
+    "AttackCampaign": AttackCampaign,
+    "Collection": Collection,
+    "AttackIdentity": AttackIdentity
+}
+class_model["sub"] = {
+    "ObjectVersion": ObjectVersion
+}
+class_model["sco"] = {}
+class_model["meta"] = {
+    "AttackMarking": AttackMarking
+}
+class_model["sro"] = {
+    "AttackRelation": AttackRelation
+}
+
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/attack/classes.py` & `stixorm-0.1.9/stixorm/module/definitions/attack/classes.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,693 +1,693 @@
-"""Python Mitre ATT&CK Stix Class Definitions """
-import json
-import pathlib
-from collections import OrderedDict
-
-from stix2.exceptions import (
-    PropertyPresenceError, )
-from stix2.properties import (
-    BooleanProperty, ExtensionsProperty, IDProperty, IntegerProperty, ListProperty,
-    OpenVocabProperty, ReferenceProperty, StringProperty,
-    TimestampProperty, TypeProperty, EmbeddedObjectProperty
-)
-from stix2.utils import NOW, _get_dict
-from stix2.markings import _MarkingsMixin
-from stix2.markings.utils import check_tlp_marking
-from stix2.v21.base import _DomainObject, _STIXBase21, _RelationshipObject
-from stix2.v21.common import (
-    ExternalReference, GranularMarking, KillChainPhase,
-    MarkingProperty, TLPMarking, StatementMarking,
-)
-from stix2.v21.vocab import (
-    ATTACK_MOTIVATION, ATTACK_RESOURCE_LEVEL, IMPLEMENTATION_LANGUAGE, MALWARE_CAPABILITIES, MALWARE_TYPE,
-    PROCESSOR_ARCHITECTURE, TOOL_TYPE, IDENTITY_CLASS, INDUSTRY_SECTOR,
-)
-
-import logging
-
-from stixorm.module.definitions.property_definitions import ThreatReference
-from stixorm.module.typedb_lib.auth_types import all_auth_types
-from stixorm.module.typedb_lib.factories.mappings_factory import get_mapping_factory_instance
-
-logger = logging.getLogger(__name__)
-
-valid_obj =  get_mapping_factory_instance().get_all_types()
-# i) allows x- prefix see properties.py line 592 obj_type.startswith("x-") and
-# ii) allows non stix definitiosn to be added see properties.py line 592 is_object(obj_type, self.spec_version)
-
-class AttackRelation(_RelationshipObject):
-    """For more detailed information on this object's properties, see
-    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
-    """
-
-    _type = 'relationship'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('relationship_type', StringProperty(required=True)),
-        ('description', StringProperty()),
-        ('x_mitre_version', StringProperty()),
-        ('x_mitre_contributors', ListProperty(StringProperty)),
-        ('x_mitre_modified_by_ref', StringProperty()),
-        ('x_mitre_domains', ListProperty(StringProperty)),
-        ('x_mitre_attack_spec_version', StringProperty()),
-        ('x_mitre_platforms', ListProperty(StringProperty)),
-        ('source_ref', ThreatReference(valid_types=valid_obj, spec_version='2.1', required=True)),
-        ('target_ref', ThreatReference(valid_types=valid_obj, spec_version='2.1', required=True)),
-        ('start_time', TimestampProperty()),
-        ('stop_time', TimestampProperty()),
-        ('revoked', BooleanProperty(default=lambda: False)),
-        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ExtensionsProperty(spec_version='2.1')),
-    ])
-
-    # Explicitly define the first three kwargs to make readable Relationship declarations.
-    # def __init__(
-    #     self, source_ref=None, relationship_type=None,
-    #     target_ref=None, **kwargs
-    # ):
-    #     # Allow (source_ref, relationship_type, target_ref) as positional args.
-    #     if source_ref and not kwargs.get('source_ref'):
-    #         kwargs['source_ref'] = source_ref
-    #     if relationship_type and not kwargs.get('relationship_type'):
-    #         kwargs['relationship_type'] = relationship_type
-    #     if target_ref and not kwargs.get('target_ref'):
-    #         kwargs['target_ref'] = target_ref
-    #
-    #     super(AttackRelation, self).__init__(**kwargs)
-
-    def _check_object_constraints(self):
-        super(self.__class__, self)._check_object_constraints()
-
-        start_time = self.get('start_time')
-        stop_time = self.get('stop_time')
-
-        if start_time and stop_time and stop_time <= start_time:
-            msg = "{0.id} 'stop_time' must be later than 'start_time'"
-            raise ValueError(msg.format(self))
-
-class Matrix(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
-    """
-
-    _type = 'x-mitre-matrix'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('name', StringProperty(required=True)),
-        ('description', StringProperty()),
-        ('x_mitre_version', StringProperty()),
-        ('x_mitre_contributors', ListProperty(StringProperty)),
-        ('x_mitre_modified_by_ref', StringProperty()),
-        ('x_mitre_domains', ListProperty(StringProperty)),
-        ('x_mitre_attack_spec_version', StringProperty()),
-        ('revoked', BooleanProperty(default=lambda: False)),
-        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ExtensionsProperty(spec_version='2.1')),
-        ('tactic_refs', ListProperty(StringProperty)),
-    ])
-
-
-class Tactic(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
-    """
-
-    _type = 'x-mitre-tactic'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('name', StringProperty(required=True)),
-        ('description', StringProperty()),
-        ('x_mitre_version', StringProperty()),
-        ('x_mitre_contributors', ListProperty(StringProperty)),
-        ('x_mitre_modified_by_ref', StringProperty()),
-        ('x_mitre_domains', ListProperty(StringProperty)),
-        ('x_mitre_attack_spec_version', StringProperty()),
-        ('revoked', BooleanProperty(default=lambda: False)),
-        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ExtensionsProperty(spec_version='2.1')),
-        ('x_mitre_shortname', StringProperty()),
-    ])
-
-class Technique(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
-    """
-
-    _type = 'attack-pattern'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('name', StringProperty(required=True)),
-        ('description', StringProperty()),
-        ('x_mitre_version', StringProperty()),
-        ('x_mitre_contributors', ListProperty(StringProperty)),
-        ('x_mitre_modified_by_ref', StringProperty()),
-        ('x_mitre_domains', ListProperty(StringProperty)),
-        ('x_mitre_attack_spec_version', StringProperty()),
-        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
-        ('x_mitre_network_requirements', BooleanProperty(default=lambda: False)),
-        ('aliases', ListProperty(StringProperty)),
-        ('kill_chain_phases', ListProperty(KillChainPhase)),
-        ('x_mitre_network_requirements', BooleanProperty(default=lambda: False)),
-        ('revoked', BooleanProperty(default=lambda: False)),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ExtensionsProperty(spec_version='2.1')),
-        ('x_mitre_detection', StringProperty()),
-        ('x_mitre_platforms', ListProperty(StringProperty)),
-        ('x_mitre_data_sources', ListProperty(StringProperty)),
-        ('x_mitre_is_subtechnique', BooleanProperty(default=lambda: False)),
-        ('x_mitre_system_requirements', ListProperty(StringProperty)),
-        ('x_mitre_tactic_type', ListProperty(StringProperty)),
-        ('x_mitre_permissions_required', ListProperty(StringProperty)),
-        ('x_mitre_effective_permissions', ListProperty(StringProperty)),
-        ('x_mitre_defense_bypassed', ListProperty(StringProperty)),
-        ('x_mitre_remote_support', BooleanProperty(default=lambda: False)),
-        ('x_mitre_impact_type', ListProperty(StringProperty)),
-    ])
-
-
-class SubTechnique(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
-    """
-
-    _type = 'attack-pattern'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('name', StringProperty(required=True)),
-        ('description', StringProperty()),
-        ('x_mitre_version', StringProperty()),
-        ('x_mitre_contributors', ListProperty(StringProperty)),
-        ('x_mitre_modified_by_ref', StringProperty()),
-        ('x_mitre_domains', ListProperty(StringProperty)),
-        ('x_mitre_attack_spec_version', StringProperty()),
-        ('aliases', ListProperty(StringProperty)),
-        ('kill_chain_phases', ListProperty(KillChainPhase)),
-        ('x_mitre_network_requirements', BooleanProperty(default=lambda: False)),
-        ('revoked', BooleanProperty(default=lambda: True)),
-        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ExtensionsProperty(spec_version='2.1')),
-        ('x_mitre_detection', StringProperty()),
-        ('x_mitre_platforms', ListProperty(StringProperty)),
-        ('x_mitre_data_sources', ListProperty(StringProperty)),
-        ('x_mitre_is_subtechnique', BooleanProperty(default=lambda: True)),
-        ('x_mitre_system_requirements', ListProperty(StringProperty)),
-        ('x_mitre_tactic_type', ListProperty(StringProperty)),
-        ('x_mitre_permissions_required', ListProperty(StringProperty)),
-        ('x_mitre_effective_permissions', ListProperty(StringProperty)),
-        ('x_mitre_defense_bypassed', ListProperty(StringProperty)),
-        ('x_mitre_remote_support', BooleanProperty(default=lambda: False)),
-        ('x_mitre_impact_type', ListProperty(StringProperty)),
-    ])
-
-
-class Mitigation(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
-    """
-
-    _type = 'course-of-action'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('name', StringProperty(required=True)),
-        ('description', StringProperty()),
-        ('x_mitre_version', StringProperty()),
-        ('x_mitre_contributors', ListProperty(StringProperty)),
-        ('x_mitre_modified_by_ref', StringProperty()),
-        ('x_mitre_domains', ListProperty(StringProperty)),
-        ('x_mitre_attack_spec_version', StringProperty()),
-        ('revoked', BooleanProperty(default=lambda: False)),
-        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ExtensionsProperty(spec_version='2.1')),
-    ])
-
-class Group(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
-    """
-
-    _type = 'intrusion-set'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('name', StringProperty(required=True)),
-        ('description', StringProperty()),
-        ('x_mitre_version', StringProperty()),
-        ('x_mitre_contributors', ListProperty(StringProperty)),
-        ('x_mitre_modified_by_ref', StringProperty()),
-        ('x_mitre_domains', ListProperty(StringProperty)),
-        ('x_mitre_attack_spec_version', StringProperty()),
-        ('aliases', ListProperty(StringProperty)),
-        ('first_seen', TimestampProperty()),
-        ('last_seen', TimestampProperty()),
-        ('goals', ListProperty(StringProperty)),
-        ('resource_level', OpenVocabProperty(ATTACK_RESOURCE_LEVEL)),
-        ('primary_motivation', OpenVocabProperty(ATTACK_MOTIVATION)),
-        ('secondary_motivations', ListProperty(OpenVocabProperty(ATTACK_MOTIVATION))),
-        ('revoked', BooleanProperty(default=lambda: False)),
-        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ExtensionsProperty(spec_version='2.1')),
-    ])
-
-    def _check_object_constraints(self):
-        super(Group, self)._check_object_constraints()
-
-        first_seen = self.get('first_seen')
-        last_seen = self.get('last_seen')
-
-        if first_seen and last_seen and last_seen < first_seen:
-            msg = "{0.id} 'last_seen' must be greater than or equal to 'first_seen'"
-            raise ValueError(msg.format(self))
-
-
-class SoftwareMalware(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
-    """
-
-    _type = 'malware'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('name', StringProperty()),
-        ('description', StringProperty()),
-        ('x_mitre_version', StringProperty()),
-        ('x_mitre_contributors', ListProperty(StringProperty)),
-        ('x_mitre_modified_by_ref', StringProperty()),
-        ('x_mitre_domains', ListProperty(StringProperty)),
-        ('x_mitre_attack_spec_version', StringProperty()),
-        ('malware_types', ListProperty(OpenVocabProperty(MALWARE_TYPE))),
-        ('is_family', BooleanProperty(required=True)),
-        ('aliases', ListProperty(StringProperty)),
-        ('kill_chain_phases', ListProperty(KillChainPhase)),
-        ('first_seen', TimestampProperty()),
-        ('last_seen', TimestampProperty()),
-        ('operating_system_refs', ListProperty(ReferenceProperty(valid_types='software', spec_version='2.1'))),
-        ('architecture_execution_envs', ListProperty(OpenVocabProperty(PROCESSOR_ARCHITECTURE))),
-        ('implementation_languages', ListProperty(OpenVocabProperty(IMPLEMENTATION_LANGUAGE))),
-        ('capabilities', ListProperty(OpenVocabProperty(MALWARE_CAPABILITIES))),
-        ('sample_refs', ListProperty(ReferenceProperty(valid_types=['artifact', 'file'], spec_version='2.1'))),
-        ('revoked', BooleanProperty(default=lambda: False)),
-        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ExtensionsProperty(spec_version='2.1')),
-        ('x_mitre_platforms', ListProperty(StringProperty)),
-        ('x_mitre_aliases', ListProperty(StringProperty)),
-    ])
-
-    def _check_object_constraints(self):
-        super(SoftwareMalware, self)._check_object_constraints()
-
-        first_seen = self.get('first_seen')
-        last_seen = self.get('last_seen')
-
-        if first_seen and last_seen and last_seen < first_seen:
-            msg = "{0.id} 'last_seen' must be greater than or equal to 'first_seen'"
-            raise ValueError(msg.format(self))
-
-        if self.is_family and "name" not in self:
-            raise PropertyPresenceError(
-                "'name' is a required property for malware families",
-                SoftwareMalware,
-            )
-
-
-class SoftwareTool(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
-    """
-
-    _type = 'tool'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('name', StringProperty(required=True)),
-        ('description', StringProperty()),
-        ('x_mitre_version', StringProperty()),
-        ('x_mitre_contributors', ListProperty(StringProperty)),
-        ('x_mitre_modified_by_ref', StringProperty()),
-        ('x_mitre_domains', ListProperty(StringProperty)),
-        ('x_mitre_attack_spec_version', StringProperty()),
-        ('tool_types', ListProperty(OpenVocabProperty(TOOL_TYPE))),
-        ('aliases', ListProperty(StringProperty)),
-        ('kill_chain_phases', ListProperty(KillChainPhase)),
-        ('tool_version', StringProperty()),
-        ('revoked', BooleanProperty(default=lambda: False)),
-        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ExtensionsProperty(spec_version='2.1')),
-        ('x_mitre_platforms', ListProperty(StringProperty)),
-        ('x_mitre_aliases', ListProperty(StringProperty)),
-    ])
-
-
-
-class DataSource(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
-    """
-
-    _type = 'x-mitre-data-source'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('name', StringProperty(required=True)),
-        ('description', StringProperty()),
-        ('x_mitre_version', StringProperty()),
-        ('x_mitre_contributors', ListProperty(StringProperty)),
-        ('x_mitre_modified_by_ref', StringProperty()),
-        ('x_mitre_domains', ListProperty(StringProperty)),
-        ('x_mitre_attack_spec_version', StringProperty()),
-        ('revoked', BooleanProperty(default=lambda: False)),
-        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ExtensionsProperty(spec_version='2.1')),
-        ('x_mitre_platforms', ListProperty(StringProperty)),
-        ('x_mitre_collection_layers', ListProperty(StringProperty)),
-    ])
-
-
-class DataComponent(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
-    """
-
-    _type = 'x-mitre-data-component'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('name', StringProperty(required=True)),
-        ('description', StringProperty()),
-        ('x_mitre_version', StringProperty()),
-        ('x_mitre_contributors', ListProperty(StringProperty)),
-        ('x_mitre_modified_by_ref', StringProperty()),
-        ('x_mitre_domains', ListProperty(StringProperty)),
-        ('x_mitre_attack_spec_version', StringProperty()),
-        ('revoked', BooleanProperty(default=lambda: False)),
-        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ExtensionsProperty(spec_version='2.1')),
-        ('x_mitre_data_source_ref', StringProperty())
-    ])
-
-class AttackCampaign(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
-    """
-
-    _type = 'campaign'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('name', StringProperty(required=True)),
-        ('description', StringProperty()),
-        ('x_mitre_version', StringProperty()),
-        ('x_mitre_contributors', ListProperty(StringProperty)),
-        ('x_mitre_modified_by_ref', StringProperty()),
-        ('x_mitre_domains', ListProperty(StringProperty)),
-        ('x_mitre_attack_spec_version', StringProperty()),
-        ('x_mitre_first_seen_citation', StringProperty()),
-        ('x_mitre_last_seen_citation', StringProperty()),
-        ('x_mitre_aliases', StringProperty()),
-        ('aliases', ListProperty(StringProperty)),
-        ('first_seen', TimestampProperty()),
-        ('last_seen', TimestampProperty()),
-        ('objective', StringProperty()),
-        ('revoked', BooleanProperty(default=lambda: False)),
-        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ExtensionsProperty(spec_version='2.1')),
-    ])
-
-    def _check_object_constraints(self):
-        super(AttackCampaign, self)._check_object_constraints()
-
-        first_seen = self.get('first_seen')
-        last_seen = self.get('last_seen')
-
-        if first_seen and last_seen and last_seen < first_seen:
-            msg = "{0.id} 'last_seen' must be greater than or equal to 'first_seen'"
-            raise ValueError(msg.format(self))
-
-
-
-class ObjectVersion(_STIXBase21):
-    """For more detailed information on this object's properties, see
-    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
-    """
-    _properties = OrderedDict([
-        ('object_ref', ThreatReference(valid_types=valid_obj, spec_version='2.1')),
-        ('object_modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-    ])
-
-
-class Collection(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
-    """
-
-    _type = 'x-mitre-collection'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('name', StringProperty(required=True)),
-        ('description', StringProperty()),
-        ('x_mitre_version', StringProperty()),
-        ('x_mitre_contributors', ListProperty(StringProperty)),
-        ('x_mitre_modified_by_ref', StringProperty()),
-        ('x_mitre_domains', ListProperty(StringProperty)),
-        ('x_mitre_attack_spec_version', StringProperty()),
-        ('revoked', BooleanProperty(default=lambda: False)),
-        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ExtensionsProperty(spec_version='2.1')),
-        ('x_mitre_contents', ListProperty(EmbeddedObjectProperty(type=ObjectVersion))),
-    ])
-
-class AttackMarking(_STIXBase21, _MarkingsMixin):
-    """For more detailed information on this object's properties, see
-    `the STIX 2.1 specification <https://docs.oasis-open.org/cti/stix/v2.1/os/stix-v2.1-os.html#_k5fndj2c7c1k>`__.
-    """
-
-    _type = 'marking-definition'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('definition_type', StringProperty()),
-        ('name', StringProperty()),
-        ('definition', MarkingProperty()),
-        ('x_mitre_version', StringProperty()),
-        ('x_mitre_contributors', ListProperty(StringProperty)),
-        ('x_mitre_modified_by_ref', StringProperty()),
-        ('x_mitre_domains', ListProperty(StringProperty)),
-        ('x_mitre_attack_spec_version', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ExtensionsProperty(spec_version='2.1')),
-    ])
-
-    def __init__(self, **kwargs):
-        if {'definition_type', 'definition'}.issubset(kwargs.keys()):
-            # Create correct marking type object
-            try:
-                marking_type = OBJ_MAP_MARKING[kwargs['definition_type']]
-            except KeyError:
-                raise ValueError("definition_type must be a valid marking type")
-
-            if not isinstance(kwargs['definition'], marking_type): # noqa
-                defn = _get_dict(kwargs['definition'])
-                kwargs['definition'] = marking_type(**defn)
-
-        super(AttackMarking, self).__init__(**kwargs)
-
-    def _check_object_constraints(self):
-        super(AttackMarking, self)._check_object_constraints()
-
-        definition = self.get("definition")
-        definition_type = self.get("definition_type")
-        extensions = self.get("extensions")
-
-        if not (definition_type and definition) and not extensions:
-            raise PropertyPresenceError(
-                "MarkingDefinition objects must have the properties "
-                "'definition_type' and 'definition' if 'extensions' is not present",
-                AttackMarking,
-            )
-
-        check_tlp_marking(self, '2.1')
-
-    def serialize(self, pretty=False, include_optional_defaults=False, **kwargs):
-        check_tlp_marking(self, '2.1')
-        return super(AttackMarking, self).serialize(pretty, include_optional_defaults, **kwargs)
-
-
-OBJ_MAP_MARKING = {
-    'tlp': TLPMarking,
-    'statement': StatementMarking,
-}
-
-class AttackIdentity(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the STIX 2.1 specification <https://docs.oasis-open.org/cti/stix/v2.1/os/stix-v2.1-os.html#_wh296fiwpklp>`__.
-    """
-
-    _type = 'identity'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('name', StringProperty(required=True)),
-        ('description', StringProperty()),
-        ('x_mitre_version', StringProperty()),
-        ('x_mitre_contributors', ListProperty(StringProperty)),
-        ('x_mitre_modified_by_ref', StringProperty()),
-        ('x_mitre_domains', ListProperty(StringProperty)),
-        ('x_mitre_attack_spec_version', StringProperty()),
-        ('roles', ListProperty(StringProperty)),
-        ('identity_class', OpenVocabProperty(IDENTITY_CLASS)),
-        ('sectors', ListProperty(OpenVocabProperty(INDUSTRY_SECTOR))),
-        ('contact_information', StringProperty()),
-        ('revoked', BooleanProperty(default=lambda: False)),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ExtensionsProperty(spec_version='2.1')),
+"""Python Mitre ATT&CK Stix Class Definitions """
+import json
+import pathlib
+from collections import OrderedDict
+
+from stix2.exceptions import (
+    PropertyPresenceError, )
+from stix2.properties import (
+    BooleanProperty, ExtensionsProperty, IDProperty, IntegerProperty, ListProperty,
+    OpenVocabProperty, ReferenceProperty, StringProperty,
+    TimestampProperty, TypeProperty, EmbeddedObjectProperty
+)
+from stix2.utils import NOW, _get_dict
+from stix2.markings import _MarkingsMixin
+from stix2.markings.utils import check_tlp_marking
+from stix2.v21.base import _DomainObject, _STIXBase21, _RelationshipObject
+from stix2.v21.common import (
+    ExternalReference, GranularMarking, KillChainPhase,
+    MarkingProperty, TLPMarking, StatementMarking,
+)
+from stix2.v21.vocab import (
+    ATTACK_MOTIVATION, ATTACK_RESOURCE_LEVEL, IMPLEMENTATION_LANGUAGE, MALWARE_CAPABILITIES, MALWARE_TYPE,
+    PROCESSOR_ARCHITECTURE, TOOL_TYPE, IDENTITY_CLASS, INDUSTRY_SECTOR,
+)
+
+import logging
+
+from stixorm.module.definitions.property_definitions import ThreatReference
+from stixorm.module.typedb_lib.auth_types import all_auth_types
+from stixorm.module.typedb_lib.factories.mappings_factory import get_mapping_factory_instance
+
+logger = logging.getLogger(__name__)
+
+valid_obj =  get_mapping_factory_instance().get_all_types()
+# i) allows x- prefix see properties.py line 592 obj_type.startswith("x-") and
+# ii) allows non stix definitiosn to be added see properties.py line 592 is_object(obj_type, self.spec_version)
+
+class AttackRelation(_RelationshipObject):
+    """For more detailed information on this object's properties, see
+    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
+    """
+
+    _type = 'relationship'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('relationship_type', StringProperty(required=True)),
+        ('description', StringProperty()),
+        ('x_mitre_version', StringProperty()),
+        ('x_mitre_contributors', ListProperty(StringProperty)),
+        ('x_mitre_modified_by_ref', StringProperty()),
+        ('x_mitre_domains', ListProperty(StringProperty)),
+        ('x_mitre_attack_spec_version', StringProperty()),
+        ('x_mitre_platforms', ListProperty(StringProperty)),
+        ('source_ref', ThreatReference(valid_types=valid_obj, spec_version='2.1', required=True)),
+        ('target_ref', ThreatReference(valid_types=valid_obj, spec_version='2.1', required=True)),
+        ('start_time', TimestampProperty()),
+        ('stop_time', TimestampProperty()),
+        ('revoked', BooleanProperty(default=lambda: False)),
+        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ExtensionsProperty(spec_version='2.1')),
+    ])
+
+    # Explicitly define the first three kwargs to make readable Relationship declarations.
+    # def __init__(
+    #     self, source_ref=None, relationship_type=None,
+    #     target_ref=None, **kwargs
+    # ):
+    #     # Allow (source_ref, relationship_type, target_ref) as positional args.
+    #     if source_ref and not kwargs.get('source_ref'):
+    #         kwargs['source_ref'] = source_ref
+    #     if relationship_type and not kwargs.get('relationship_type'):
+    #         kwargs['relationship_type'] = relationship_type
+    #     if target_ref and not kwargs.get('target_ref'):
+    #         kwargs['target_ref'] = target_ref
+    #
+    #     super(AttackRelation, self).__init__(**kwargs)
+
+    def _check_object_constraints(self):
+        super(self.__class__, self)._check_object_constraints()
+
+        start_time = self.get('start_time')
+        stop_time = self.get('stop_time')
+
+        if start_time and stop_time and stop_time <= start_time:
+            msg = "{0.id} 'stop_time' must be later than 'start_time'"
+            raise ValueError(msg.format(self))
+
+class Matrix(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
+    """
+
+    _type = 'x-mitre-matrix'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('name', StringProperty(required=True)),
+        ('description', StringProperty()),
+        ('x_mitre_version', StringProperty()),
+        ('x_mitre_contributors', ListProperty(StringProperty)),
+        ('x_mitre_modified_by_ref', StringProperty()),
+        ('x_mitre_domains', ListProperty(StringProperty)),
+        ('x_mitre_attack_spec_version', StringProperty()),
+        ('revoked', BooleanProperty(default=lambda: False)),
+        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ExtensionsProperty(spec_version='2.1')),
+        ('tactic_refs', ListProperty(StringProperty)),
+    ])
+
+
+class Tactic(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
+    """
+
+    _type = 'x-mitre-tactic'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('name', StringProperty(required=True)),
+        ('description', StringProperty()),
+        ('x_mitre_version', StringProperty()),
+        ('x_mitre_contributors', ListProperty(StringProperty)),
+        ('x_mitre_modified_by_ref', StringProperty()),
+        ('x_mitre_domains', ListProperty(StringProperty)),
+        ('x_mitre_attack_spec_version', StringProperty()),
+        ('revoked', BooleanProperty(default=lambda: False)),
+        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ExtensionsProperty(spec_version='2.1')),
+        ('x_mitre_shortname', StringProperty()),
+    ])
+
+class Technique(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
+    """
+
+    _type = 'attack-pattern'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('name', StringProperty(required=True)),
+        ('description', StringProperty()),
+        ('x_mitre_version', StringProperty()),
+        ('x_mitre_contributors', ListProperty(StringProperty)),
+        ('x_mitre_modified_by_ref', StringProperty()),
+        ('x_mitre_domains', ListProperty(StringProperty)),
+        ('x_mitre_attack_spec_version', StringProperty()),
+        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
+        ('x_mitre_network_requirements', BooleanProperty(default=lambda: False)),
+        ('aliases', ListProperty(StringProperty)),
+        ('kill_chain_phases', ListProperty(KillChainPhase)),
+        ('x_mitre_network_requirements', BooleanProperty(default=lambda: False)),
+        ('revoked', BooleanProperty(default=lambda: False)),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ExtensionsProperty(spec_version='2.1')),
+        ('x_mitre_detection', StringProperty()),
+        ('x_mitre_platforms', ListProperty(StringProperty)),
+        ('x_mitre_data_sources', ListProperty(StringProperty)),
+        ('x_mitre_is_subtechnique', BooleanProperty(default=lambda: False)),
+        ('x_mitre_system_requirements', ListProperty(StringProperty)),
+        ('x_mitre_tactic_type', ListProperty(StringProperty)),
+        ('x_mitre_permissions_required', ListProperty(StringProperty)),
+        ('x_mitre_effective_permissions', ListProperty(StringProperty)),
+        ('x_mitre_defense_bypassed', ListProperty(StringProperty)),
+        ('x_mitre_remote_support', BooleanProperty(default=lambda: False)),
+        ('x_mitre_impact_type', ListProperty(StringProperty)),
+    ])
+
+
+class SubTechnique(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
+    """
+
+    _type = 'attack-pattern'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('name', StringProperty(required=True)),
+        ('description', StringProperty()),
+        ('x_mitre_version', StringProperty()),
+        ('x_mitre_contributors', ListProperty(StringProperty)),
+        ('x_mitre_modified_by_ref', StringProperty()),
+        ('x_mitre_domains', ListProperty(StringProperty)),
+        ('x_mitre_attack_spec_version', StringProperty()),
+        ('aliases', ListProperty(StringProperty)),
+        ('kill_chain_phases', ListProperty(KillChainPhase)),
+        ('x_mitre_network_requirements', BooleanProperty(default=lambda: False)),
+        ('revoked', BooleanProperty(default=lambda: True)),
+        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ExtensionsProperty(spec_version='2.1')),
+        ('x_mitre_detection', StringProperty()),
+        ('x_mitre_platforms', ListProperty(StringProperty)),
+        ('x_mitre_data_sources', ListProperty(StringProperty)),
+        ('x_mitre_is_subtechnique', BooleanProperty(default=lambda: True)),
+        ('x_mitre_system_requirements', ListProperty(StringProperty)),
+        ('x_mitre_tactic_type', ListProperty(StringProperty)),
+        ('x_mitre_permissions_required', ListProperty(StringProperty)),
+        ('x_mitre_effective_permissions', ListProperty(StringProperty)),
+        ('x_mitre_defense_bypassed', ListProperty(StringProperty)),
+        ('x_mitre_remote_support', BooleanProperty(default=lambda: False)),
+        ('x_mitre_impact_type', ListProperty(StringProperty)),
+    ])
+
+
+class Mitigation(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
+    """
+
+    _type = 'course-of-action'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('name', StringProperty(required=True)),
+        ('description', StringProperty()),
+        ('x_mitre_version', StringProperty()),
+        ('x_mitre_contributors', ListProperty(StringProperty)),
+        ('x_mitre_modified_by_ref', StringProperty()),
+        ('x_mitre_domains', ListProperty(StringProperty)),
+        ('x_mitre_attack_spec_version', StringProperty()),
+        ('revoked', BooleanProperty(default=lambda: False)),
+        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ExtensionsProperty(spec_version='2.1')),
+    ])
+
+class Group(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
+    """
+
+    _type = 'intrusion-set'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('name', StringProperty(required=True)),
+        ('description', StringProperty()),
+        ('x_mitre_version', StringProperty()),
+        ('x_mitre_contributors', ListProperty(StringProperty)),
+        ('x_mitre_modified_by_ref', StringProperty()),
+        ('x_mitre_domains', ListProperty(StringProperty)),
+        ('x_mitre_attack_spec_version', StringProperty()),
+        ('aliases', ListProperty(StringProperty)),
+        ('first_seen', TimestampProperty()),
+        ('last_seen', TimestampProperty()),
+        ('goals', ListProperty(StringProperty)),
+        ('resource_level', OpenVocabProperty(ATTACK_RESOURCE_LEVEL)),
+        ('primary_motivation', OpenVocabProperty(ATTACK_MOTIVATION)),
+        ('secondary_motivations', ListProperty(OpenVocabProperty(ATTACK_MOTIVATION))),
+        ('revoked', BooleanProperty(default=lambda: False)),
+        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ExtensionsProperty(spec_version='2.1')),
+    ])
+
+    def _check_object_constraints(self):
+        super(Group, self)._check_object_constraints()
+
+        first_seen = self.get('first_seen')
+        last_seen = self.get('last_seen')
+
+        if first_seen and last_seen and last_seen < first_seen:
+            msg = "{0.id} 'last_seen' must be greater than or equal to 'first_seen'"
+            raise ValueError(msg.format(self))
+
+
+class SoftwareMalware(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
+    """
+
+    _type = 'malware'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('name', StringProperty()),
+        ('description', StringProperty()),
+        ('x_mitre_version', StringProperty()),
+        ('x_mitre_contributors', ListProperty(StringProperty)),
+        ('x_mitre_modified_by_ref', StringProperty()),
+        ('x_mitre_domains', ListProperty(StringProperty)),
+        ('x_mitre_attack_spec_version', StringProperty()),
+        ('malware_types', ListProperty(OpenVocabProperty(MALWARE_TYPE))),
+        ('is_family', BooleanProperty(required=True)),
+        ('aliases', ListProperty(StringProperty)),
+        ('kill_chain_phases', ListProperty(KillChainPhase)),
+        ('first_seen', TimestampProperty()),
+        ('last_seen', TimestampProperty()),
+        ('operating_system_refs', ListProperty(ReferenceProperty(valid_types='software', spec_version='2.1'))),
+        ('architecture_execution_envs', ListProperty(OpenVocabProperty(PROCESSOR_ARCHITECTURE))),
+        ('implementation_languages', ListProperty(OpenVocabProperty(IMPLEMENTATION_LANGUAGE))),
+        ('capabilities', ListProperty(OpenVocabProperty(MALWARE_CAPABILITIES))),
+        ('sample_refs', ListProperty(ReferenceProperty(valid_types=['artifact', 'file'], spec_version='2.1'))),
+        ('revoked', BooleanProperty(default=lambda: False)),
+        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ExtensionsProperty(spec_version='2.1')),
+        ('x_mitre_platforms', ListProperty(StringProperty)),
+        ('x_mitre_aliases', ListProperty(StringProperty)),
+    ])
+
+    def _check_object_constraints(self):
+        super(SoftwareMalware, self)._check_object_constraints()
+
+        first_seen = self.get('first_seen')
+        last_seen = self.get('last_seen')
+
+        if first_seen and last_seen and last_seen < first_seen:
+            msg = "{0.id} 'last_seen' must be greater than or equal to 'first_seen'"
+            raise ValueError(msg.format(self))
+
+        if self.is_family and "name" not in self:
+            raise PropertyPresenceError(
+                "'name' is a required property for malware families",
+                SoftwareMalware,
+            )
+
+
+class SoftwareTool(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
+    """
+
+    _type = 'tool'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('name', StringProperty(required=True)),
+        ('description', StringProperty()),
+        ('x_mitre_version', StringProperty()),
+        ('x_mitre_contributors', ListProperty(StringProperty)),
+        ('x_mitre_modified_by_ref', StringProperty()),
+        ('x_mitre_domains', ListProperty(StringProperty)),
+        ('x_mitre_attack_spec_version', StringProperty()),
+        ('tool_types', ListProperty(OpenVocabProperty(TOOL_TYPE))),
+        ('aliases', ListProperty(StringProperty)),
+        ('kill_chain_phases', ListProperty(KillChainPhase)),
+        ('tool_version', StringProperty()),
+        ('revoked', BooleanProperty(default=lambda: False)),
+        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ExtensionsProperty(spec_version='2.1')),
+        ('x_mitre_platforms', ListProperty(StringProperty)),
+        ('x_mitre_aliases', ListProperty(StringProperty)),
+    ])
+
+
+
+class DataSource(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
+    """
+
+    _type = 'x-mitre-data-source'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('name', StringProperty(required=True)),
+        ('description', StringProperty()),
+        ('x_mitre_version', StringProperty()),
+        ('x_mitre_contributors', ListProperty(StringProperty)),
+        ('x_mitre_modified_by_ref', StringProperty()),
+        ('x_mitre_domains', ListProperty(StringProperty)),
+        ('x_mitre_attack_spec_version', StringProperty()),
+        ('revoked', BooleanProperty(default=lambda: False)),
+        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ExtensionsProperty(spec_version='2.1')),
+        ('x_mitre_platforms', ListProperty(StringProperty)),
+        ('x_mitre_collection_layers', ListProperty(StringProperty)),
+    ])
+
+
+class DataComponent(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
+    """
+
+    _type = 'x-mitre-data-component'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('name', StringProperty(required=True)),
+        ('description', StringProperty()),
+        ('x_mitre_version', StringProperty()),
+        ('x_mitre_contributors', ListProperty(StringProperty)),
+        ('x_mitre_modified_by_ref', StringProperty()),
+        ('x_mitre_domains', ListProperty(StringProperty)),
+        ('x_mitre_attack_spec_version', StringProperty()),
+        ('revoked', BooleanProperty(default=lambda: False)),
+        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ExtensionsProperty(spec_version='2.1')),
+        ('x_mitre_data_source_ref', StringProperty())
+    ])
+
+class AttackCampaign(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
+    """
+
+    _type = 'campaign'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('name', StringProperty(required=True)),
+        ('description', StringProperty()),
+        ('x_mitre_version', StringProperty()),
+        ('x_mitre_contributors', ListProperty(StringProperty)),
+        ('x_mitre_modified_by_ref', StringProperty()),
+        ('x_mitre_domains', ListProperty(StringProperty)),
+        ('x_mitre_attack_spec_version', StringProperty()),
+        ('x_mitre_first_seen_citation', StringProperty()),
+        ('x_mitre_last_seen_citation', StringProperty()),
+        ('x_mitre_aliases', StringProperty()),
+        ('aliases', ListProperty(StringProperty)),
+        ('first_seen', TimestampProperty()),
+        ('last_seen', TimestampProperty()),
+        ('objective', StringProperty()),
+        ('revoked', BooleanProperty(default=lambda: False)),
+        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ExtensionsProperty(spec_version='2.1')),
+    ])
+
+    def _check_object_constraints(self):
+        super(AttackCampaign, self)._check_object_constraints()
+
+        first_seen = self.get('first_seen')
+        last_seen = self.get('last_seen')
+
+        if first_seen and last_seen and last_seen < first_seen:
+            msg = "{0.id} 'last_seen' must be greater than or equal to 'first_seen'"
+            raise ValueError(msg.format(self))
+
+
+
+class ObjectVersion(_STIXBase21):
+    """For more detailed information on this object's properties, see
+    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
+    """
+    _properties = OrderedDict([
+        ('object_ref', ThreatReference(valid_types=valid_obj, spec_version='2.1')),
+        ('object_modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+    ])
+
+
+class Collection(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the MITRE ATT&CK Stix specifications <https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md>`__.
+    """
+
+    _type = 'x-mitre-collection'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('name', StringProperty(required=True)),
+        ('description', StringProperty()),
+        ('x_mitre_version', StringProperty()),
+        ('x_mitre_contributors', ListProperty(StringProperty)),
+        ('x_mitre_modified_by_ref', StringProperty()),
+        ('x_mitre_domains', ListProperty(StringProperty)),
+        ('x_mitre_attack_spec_version', StringProperty()),
+        ('revoked', BooleanProperty(default=lambda: False)),
+        ('x_mitre_deprecated', BooleanProperty(default=lambda: False)),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ExtensionsProperty(spec_version='2.1')),
+        ('x_mitre_contents', ListProperty(EmbeddedObjectProperty(type=ObjectVersion))),
+    ])
+
+class AttackMarking(_STIXBase21, _MarkingsMixin):
+    """For more detailed information on this object's properties, see
+    `the STIX 2.1 specification <https://docs.oasis-open.org/cti/stix/v2.1/os/stix-v2.1-os.html#_k5fndj2c7c1k>`__.
+    """
+
+    _type = 'marking-definition'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('definition_type', StringProperty()),
+        ('name', StringProperty()),
+        ('definition', MarkingProperty()),
+        ('x_mitre_version', StringProperty()),
+        ('x_mitre_contributors', ListProperty(StringProperty)),
+        ('x_mitre_modified_by_ref', StringProperty()),
+        ('x_mitre_domains', ListProperty(StringProperty)),
+        ('x_mitre_attack_spec_version', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ExtensionsProperty(spec_version='2.1')),
+    ])
+
+    def __init__(self, **kwargs):
+        if {'definition_type', 'definition'}.issubset(kwargs.keys()):
+            # Create correct marking type object
+            try:
+                marking_type = OBJ_MAP_MARKING[kwargs['definition_type']]
+            except KeyError:
+                raise ValueError("definition_type must be a valid marking type")
+
+            if not isinstance(kwargs['definition'], marking_type): # noqa
+                defn = _get_dict(kwargs['definition'])
+                kwargs['definition'] = marking_type(**defn)
+
+        super(AttackMarking, self).__init__(**kwargs)
+
+    def _check_object_constraints(self):
+        super(AttackMarking, self)._check_object_constraints()
+
+        definition = self.get("definition")
+        definition_type = self.get("definition_type")
+        extensions = self.get("extensions")
+
+        if not (definition_type and definition) and not extensions:
+            raise PropertyPresenceError(
+                "MarkingDefinition objects must have the properties "
+                "'definition_type' and 'definition' if 'extensions' is not present",
+                AttackMarking,
+            )
+
+        check_tlp_marking(self, '2.1')
+
+    def serialize(self, pretty=False, include_optional_defaults=False, **kwargs):
+        check_tlp_marking(self, '2.1')
+        return super(AttackMarking, self).serialize(pretty, include_optional_defaults, **kwargs)
+
+
+OBJ_MAP_MARKING = {
+    'tlp': TLPMarking,
+    'statement': StatementMarking,
+}
+
+class AttackIdentity(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the STIX 2.1 specification <https://docs.oasis-open.org/cti/stix/v2.1/os/stix-v2.1-os.html#_wh296fiwpklp>`__.
+    """
+
+    _type = 'identity'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('name', StringProperty(required=True)),
+        ('description', StringProperty()),
+        ('x_mitre_version', StringProperty()),
+        ('x_mitre_contributors', ListProperty(StringProperty)),
+        ('x_mitre_modified_by_ref', StringProperty()),
+        ('x_mitre_domains', ListProperty(StringProperty)),
+        ('x_mitre_attack_spec_version', StringProperty()),
+        ('roles', ListProperty(StringProperty)),
+        ('identity_class', OpenVocabProperty(IDENTITY_CLASS)),
+        ('sectors', ListProperty(OpenVocabProperty(INDUSTRY_SECTOR))),
+        ('contact_information', StringProperty()),
+        ('revoked', BooleanProperty(default=lambda: False)),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ExtensionsProperty(spec_version='2.1')),
     ])
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/attack/data/sub-technique.json` & `stixorm-0.1.9/stixorm/module/definitions/attack/data/technique.json`

 * *Format-specific differences are supported for JSON files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: JSON text data*

 * *Files 22% similar despite different names*

```diff
@@ -1,49 +1,54 @@
-00000000: 7b0a 2020 226e 616d 6522 3a20 226e 616d  {.  "name": "nam
-00000010: 6522 2c0a 2020 2264 6573 6372 6970 7469  e",.  "descripti
-00000020: 6f6e 223a 2022 6465 7363 7269 7074 696f  on": "descriptio
-00000030: 6e22 2c0a 2020 2278 5f6d 6974 7265 5f64  n",.  "x_mitre_d
-00000040: 6574 6563 7469 6f6e 223a 2022 782d 6d69  etection": "x-mi
-00000050: 7472 652d 6465 7465 6374 696f 6e22 2c0a  tre-detection",.
-00000060: 2020 2278 5f6d 6974 7265 5f70 6c61 7466    "x_mitre_platf
-00000070: 6f72 6d73 223a 2022 782d 6d69 7472 652d  orms": "x-mitre-
-00000080: 706c 6174 666f 726d 7322 2c0a 2020 2278  platforms",.  "x
-00000090: 5f6d 6974 7265 5f64 6174 615f 736f 7572  _mitre_data_sour
-000000a0: 6365 7322 3a20 2278 2d6d 6974 7265 2d64  ces": "x-mitre-d
-000000b0: 6174 612d 736f 7572 6365 7322 2c0a 2020  ata-sources",.  
-000000c0: 2278 5f6d 6974 7265 5f69 735f 7375 6274  "x_mitre_is_subt
-000000d0: 6563 686e 6971 7565 223a 2022 782d 6d69  echnique": "x-mi
-000000e0: 7472 652d 6973 2d73 7562 7465 6368 6e69  tre-is-subtechni
-000000f0: 7175 6522 2c0a 2020 2278 5f6d 6974 7265  que",.  "x_mitre
-00000100: 5f73 7973 7465 6d5f 7265 7175 6972 656d  _system_requirem
-00000110: 656e 7473 223a 2022 782d 6d69 7472 652d  ents": "x-mitre-
-00000120: 7379 7374 656d 2d72 6571 7569 7265 6d65  system-requireme
-00000130: 6e74 7322 2c0a 2020 2278 5f6d 6974 7265  nts",.  "x_mitre
-00000140: 5f74 6163 7469 635f 7479 7065 223a 2022  _tactic_type": "
-00000150: 782d 6d69 7472 652d 7461 6374 6963 2d74  x-mitre-tactic-t
-00000160: 7970 6522 2c0a 2020 2278 5f6d 6974 7265  ype",.  "x_mitre
-00000170: 5f70 6572 6d69 7373 696f 6e73 5f72 6571  _permissions_req
-00000180: 7569 7265 6422 3a20 2278 2d6d 6974 7265  uired": "x-mitre
-00000190: 2d70 6572 6d69 7373 696f 6e73 2d72 6571  -permissions-req
-000001a0: 7569 7265 6422 2c0a 2020 2278 5f6d 6974  uired",.  "x_mit
-000001b0: 7265 5f6e 6574 776f 726b 5f72 6571 7569  re_network_requi
-000001c0: 7265 6d65 6e74 7322 3a20 2278 2d6d 6974  rements": "x-mit
-000001d0: 7265 2d6e 6574 776f 726b 2d72 6571 7569  re-network-requi
-000001e0: 7265 6d65 6e74 7322 2c0a 2020 2278 5f6d  rements",.  "x_m
-000001f0: 6974 7265 5f65 6666 6563 7469 7665 5f70  itre_effective_p
-00000200: 6572 6d69 7373 696f 6e73 223a 2022 782d  ermissions": "x-
-00000210: 6d69 7472 652d 6566 6665 6374 6976 652d  mitre-effective-
-00000220: 7065 726d 6973 7369 6f6e 7322 2c0a 2020  permissions",.  
-00000230: 2278 5f6d 6974 7265 5f64 6566 656e 7365  "x_mitre_defense
-00000240: 5f62 7970 6173 7365 6422 3a20 2278 2d6d  _bypassed": "x-m
-00000250: 6974 7265 2d64 6566 656e 7365 2d62 7970  itre-defense-byp
-00000260: 6173 7365 6422 2c0a 2020 2278 5f6d 6974  assed",.  "x_mit
-00000270: 7265 5f72 656d 6f74 655f 7375 7070 6f72  re_remote_suppor
-00000280: 7422 3a20 2278 2d6d 6974 7265 2d72 656d  t": "x-mitre-rem
-00000290: 6f74 652d 7375 7070 6f72 7422 2c0a 2020  ote-support",.  
-000002a0: 2278 5f6d 6974 7265 5f69 6d70 6163 745f  "x_mitre_impact_
-000002b0: 7479 7065 223a 2022 782d 6d69 7472 652d  type": "x-mitre-
-000002c0: 696d 7061 6374 2d74 7970 6522 2c0a 2020  impact-type",.  
-000002d0: 226b 696c 6c5f 6368 6169 6e5f 7068 6173  "kill_chain_phas
-000002e0: 6573 223a 2022 222c 0a20 2022 616c 6961  es": "",.  "alia
-000002f0: 7365 7322 3a20 2261 6c69 6173 6573 220a  ses": "aliases".
-00000300: 7d                                       }
+00000000: 7b0d 0a20 2022 6e61 6d65 223a 2022 6e61  {..  "name": "na
+00000010: 6d65 222c 0d0a 2020 2264 6573 6372 6970  me",..  "descrip
+00000020: 7469 6f6e 223a 2022 6465 7363 7269 7074  tion": "descript
+00000030: 696f 6e22 2c0d 0a20 2022 785f 6d69 7472  ion",..  "x_mitr
+00000040: 655f 6465 7465 6374 696f 6e22 3a20 2278  e_detection": "x
+00000050: 2d6d 6974 7265 2d64 6574 6563 7469 6f6e  -mitre-detection
+00000060: 222c 0d0a 2020 2278 5f6d 6974 7265 5f70  ",..  "x_mitre_p
+00000070: 6c61 7466 6f72 6d73 223a 2022 782d 6d69  latforms": "x-mi
+00000080: 7472 652d 706c 6174 666f 726d 7322 2c0d  tre-platforms",.
+00000090: 0a20 2022 785f 6d69 7472 655f 6461 7461  .  "x_mitre_data
+000000a0: 5f73 6f75 7263 6573 223a 2022 782d 6d69  _sources": "x-mi
+000000b0: 7472 652d 6461 7461 2d73 6f75 7263 6573  tre-data-sources
+000000c0: 222c 0d0a 2020 2278 5f6d 6974 7265 5f69  ",..  "x_mitre_i
+000000d0: 735f 7375 6274 6563 686e 6971 7565 223a  s_subtechnique":
+000000e0: 2022 782d 6d69 7472 652d 6973 2d73 7562   "x-mitre-is-sub
+000000f0: 7465 6368 6e69 7175 6522 2c0d 0a20 2022  technique",..  "
+00000100: 785f 6d69 7472 655f 7379 7374 656d 5f72  x_mitre_system_r
+00000110: 6571 7569 7265 6d65 6e74 7322 3a20 2278  equirements": "x
+00000120: 2d6d 6974 7265 2d73 7973 7465 6d2d 7265  -mitre-system-re
+00000130: 7175 6972 656d 656e 7473 222c 0d0a 2020  quirements",..  
+00000140: 2278 5f6d 6974 7265 5f74 6163 7469 635f  "x_mitre_tactic_
+00000150: 7479 7065 223a 2022 782d 6d69 7472 652d  type": "x-mitre-
+00000160: 7461 6374 6963 2d74 7970 6522 2c0d 0a20  tactic-type",.. 
+00000170: 2022 785f 6d69 7472 655f 7065 726d 6973   "x_mitre_permis
+00000180: 7369 6f6e 735f 7265 7175 6972 6564 223a  sions_required":
+00000190: 2022 782d 6d69 7472 652d 7065 726d 6973   "x-mitre-permis
+000001a0: 7369 6f6e 732d 7265 7175 6972 6564 222c  sions-required",
+000001b0: 0d0a 2020 2278 5f6d 6974 7265 5f6e 6574  ..  "x_mitre_net
+000001c0: 776f 726b 5f72 6571 7569 7265 6d65 6e74  work_requirement
+000001d0: 7322 3a20 2278 2d6d 6974 7265 2d6e 6574  s": "x-mitre-net
+000001e0: 776f 726b 2d72 6571 7569 7265 6d65 6e74  work-requirement
+000001f0: 7322 2c0d 0a20 2022 785f 6d69 7472 655f  s",..  "x_mitre_
+00000200: 6566 6665 6374 6976 655f 7065 726d 6973  effective_permis
+00000210: 7369 6f6e 7322 3a20 2278 2d6d 6974 7265  sions": "x-mitre
+00000220: 2d65 6666 6563 7469 7665 2d70 6572 6d69  -effective-permi
+00000230: 7373 696f 6e73 222c 0d0a 2020 2278 5f6d  ssions",..  "x_m
+00000240: 6974 7265 5f6e 6574 776f 726b 5f72 6571  itre_network_req
+00000250: 7569 7265 6d65 6e74 7322 3a20 2278 2d6d  uirements": "x-m
+00000260: 6974 7265 2d6e 6574 776f 726b 2d72 6571  itre-network-req
+00000270: 7569 7265 6d65 6e74 7322 2c0d 0a20 2022  uirements",..  "
+00000280: 785f 6d69 7472 655f 6465 6665 6e73 655f  x_mitre_defense_
+00000290: 6279 7061 7373 6564 223a 2022 782d 6d69  bypassed": "x-mi
+000002a0: 7472 652d 6465 6665 6e73 652d 6279 7061  tre-defense-bypa
+000002b0: 7373 6564 222c 0d0a 2020 2278 5f6d 6974  ssed",..  "x_mit
+000002c0: 7265 5f72 656d 6f74 655f 7375 7070 6f72  re_remote_suppor
+000002d0: 7422 3a20 2278 2d6d 6974 7265 2d72 656d  t": "x-mitre-rem
+000002e0: 6f74 652d 7375 7070 6f72 7422 2c0d 0a20  ote-support",.. 
+000002f0: 2022 785f 6d69 7472 655f 696d 7061 6374   "x_mitre_impact
+00000300: 5f74 7970 6522 3a20 2278 2d6d 6974 7265  _type": "x-mitre
+00000310: 2d69 6d70 6163 742d 7479 7065 222c 0d0a  -impact-type",..
+00000320: 2020 226b 696c 6c5f 6368 6169 6e5f 7068    "kill_chain_ph
+00000330: 6173 6573 223a 2022 222c 0d0a 2020 2261  ases": "",..  "a
+00000340: 6c69 6173 6573 223a 2022 616c 6961 7365  liases": "aliase
+00000350: 7322 0d0a 7d                             s"..}
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/attack/data/technique.json` & `stixorm-0.1.9/stixorm/module/definitions/attack/data/sub-technique.json`

 * *Format-specific differences are supported for JSON files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: JSON text data*

 * *Files 14% similar despite different names*

```diff
@@ -1,53 +1,50 @@
-00000000: 7b0a 2020 226e 616d 6522 3a20 226e 616d  {.  "name": "nam
-00000010: 6522 2c0a 2020 2264 6573 6372 6970 7469  e",.  "descripti
-00000020: 6f6e 223a 2022 6465 7363 7269 7074 696f  on": "descriptio
-00000030: 6e22 2c0a 2020 2278 5f6d 6974 7265 5f64  n",.  "x_mitre_d
-00000040: 6574 6563 7469 6f6e 223a 2022 782d 6d69  etection": "x-mi
-00000050: 7472 652d 6465 7465 6374 696f 6e22 2c0a  tre-detection",.
-00000060: 2020 2278 5f6d 6974 7265 5f70 6c61 7466    "x_mitre_platf
-00000070: 6f72 6d73 223a 2022 782d 6d69 7472 652d  orms": "x-mitre-
-00000080: 706c 6174 666f 726d 7322 2c0a 2020 2278  platforms",.  "x
-00000090: 5f6d 6974 7265 5f64 6174 615f 736f 7572  _mitre_data_sour
-000000a0: 6365 7322 3a20 2278 2d6d 6974 7265 2d64  ces": "x-mitre-d
-000000b0: 6174 612d 736f 7572 6365 7322 2c0a 2020  ata-sources",.  
-000000c0: 2278 5f6d 6974 7265 5f69 735f 7375 6274  "x_mitre_is_subt
-000000d0: 6563 686e 6971 7565 223a 2022 782d 6d69  echnique": "x-mi
-000000e0: 7472 652d 6973 2d73 7562 7465 6368 6e69  tre-is-subtechni
-000000f0: 7175 6522 2c0a 2020 2278 5f6d 6974 7265  que",.  "x_mitre
-00000100: 5f73 7973 7465 6d5f 7265 7175 6972 656d  _system_requirem
-00000110: 656e 7473 223a 2022 782d 6d69 7472 652d  ents": "x-mitre-
-00000120: 7379 7374 656d 2d72 6571 7569 7265 6d65  system-requireme
-00000130: 6e74 7322 2c0a 2020 2278 5f6d 6974 7265  nts",.  "x_mitre
-00000140: 5f74 6163 7469 635f 7479 7065 223a 2022  _tactic_type": "
-00000150: 782d 6d69 7472 652d 7461 6374 6963 2d74  x-mitre-tactic-t
-00000160: 7970 6522 2c0a 2020 2278 5f6d 6974 7265  ype",.  "x_mitre
-00000170: 5f70 6572 6d69 7373 696f 6e73 5f72 6571  _permissions_req
-00000180: 7569 7265 6422 3a20 2278 2d6d 6974 7265  uired": "x-mitre
-00000190: 2d70 6572 6d69 7373 696f 6e73 2d72 6571  -permissions-req
-000001a0: 7569 7265 6422 2c0a 2020 2278 5f6d 6974  uired",.  "x_mit
-000001b0: 7265 5f6e 6574 776f 726b 5f72 6571 7569  re_network_requi
-000001c0: 7265 6d65 6e74 7322 3a20 2278 2d6d 6974  rements": "x-mit
-000001d0: 7265 2d6e 6574 776f 726b 2d72 6571 7569  re-network-requi
-000001e0: 7265 6d65 6e74 7322 2c0a 2020 2278 5f6d  rements",.  "x_m
-000001f0: 6974 7265 5f65 6666 6563 7469 7665 5f70  itre_effective_p
-00000200: 6572 6d69 7373 696f 6e73 223a 2022 782d  ermissions": "x-
-00000210: 6d69 7472 652d 6566 6665 6374 6976 652d  mitre-effective-
-00000220: 7065 726d 6973 7369 6f6e 7322 2c0a 2020  permissions",.  
-00000230: 2278 5f6d 6974 7265 5f6e 6574 776f 726b  "x_mitre_network
-00000240: 5f72 6571 7569 7265 6d65 6e74 7322 3a20  _requirements": 
-00000250: 2278 2d6d 6974 7265 2d6e 6574 776f 726b  "x-mitre-network
-00000260: 2d72 6571 7569 7265 6d65 6e74 7322 2c0a  -requirements",.
-00000270: 2020 2278 5f6d 6974 7265 5f64 6566 656e    "x_mitre_defen
-00000280: 7365 5f62 7970 6173 7365 6422 3a20 2278  se_bypassed": "x
-00000290: 2d6d 6974 7265 2d64 6566 656e 7365 2d62  -mitre-defense-b
-000002a0: 7970 6173 7365 6422 2c0a 2020 2278 5f6d  ypassed",.  "x_m
-000002b0: 6974 7265 5f72 656d 6f74 655f 7375 7070  itre_remote_supp
-000002c0: 6f72 7422 3a20 2278 2d6d 6974 7265 2d72  ort": "x-mitre-r
-000002d0: 656d 6f74 652d 7375 7070 6f72 7422 2c0a  emote-support",.
-000002e0: 2020 2278 5f6d 6974 7265 5f69 6d70 6163    "x_mitre_impac
-000002f0: 745f 7479 7065 223a 2022 782d 6d69 7472  t_type": "x-mitr
-00000300: 652d 696d 7061 6374 2d74 7970 6522 2c0a  e-impact-type",.
-00000310: 2020 226b 696c 6c5f 6368 6169 6e5f 7068    "kill_chain_ph
-00000320: 6173 6573 223a 2022 222c 0a20 2022 616c  ases": "",.  "al
-00000330: 6961 7365 7322 3a20 2261 6c69 6173 6573  iases": "aliases
-00000340: 220a 7d                                  ".}
+00000000: 7b0d 0a20 2022 6e61 6d65 223a 2022 6e61  {..  "name": "na
+00000010: 6d65 222c 0d0a 2020 2264 6573 6372 6970  me",..  "descrip
+00000020: 7469 6f6e 223a 2022 6465 7363 7269 7074  tion": "descript
+00000030: 696f 6e22 2c0d 0a20 2022 785f 6d69 7472  ion",..  "x_mitr
+00000040: 655f 6465 7465 6374 696f 6e22 3a20 2278  e_detection": "x
+00000050: 2d6d 6974 7265 2d64 6574 6563 7469 6f6e  -mitre-detection
+00000060: 222c 0d0a 2020 2278 5f6d 6974 7265 5f70  ",..  "x_mitre_p
+00000070: 6c61 7466 6f72 6d73 223a 2022 782d 6d69  latforms": "x-mi
+00000080: 7472 652d 706c 6174 666f 726d 7322 2c0d  tre-platforms",.
+00000090: 0a20 2022 785f 6d69 7472 655f 6461 7461  .  "x_mitre_data
+000000a0: 5f73 6f75 7263 6573 223a 2022 782d 6d69  _sources": "x-mi
+000000b0: 7472 652d 6461 7461 2d73 6f75 7263 6573  tre-data-sources
+000000c0: 222c 0d0a 2020 2278 5f6d 6974 7265 5f69  ",..  "x_mitre_i
+000000d0: 735f 7375 6274 6563 686e 6971 7565 223a  s_subtechnique":
+000000e0: 2022 782d 6d69 7472 652d 6973 2d73 7562   "x-mitre-is-sub
+000000f0: 7465 6368 6e69 7175 6522 2c0d 0a20 2022  technique",..  "
+00000100: 785f 6d69 7472 655f 7379 7374 656d 5f72  x_mitre_system_r
+00000110: 6571 7569 7265 6d65 6e74 7322 3a20 2278  equirements": "x
+00000120: 2d6d 6974 7265 2d73 7973 7465 6d2d 7265  -mitre-system-re
+00000130: 7175 6972 656d 656e 7473 222c 0d0a 2020  quirements",..  
+00000140: 2278 5f6d 6974 7265 5f74 6163 7469 635f  "x_mitre_tactic_
+00000150: 7479 7065 223a 2022 782d 6d69 7472 652d  type": "x-mitre-
+00000160: 7461 6374 6963 2d74 7970 6522 2c0d 0a20  tactic-type",.. 
+00000170: 2022 785f 6d69 7472 655f 7065 726d 6973   "x_mitre_permis
+00000180: 7369 6f6e 735f 7265 7175 6972 6564 223a  sions_required":
+00000190: 2022 782d 6d69 7472 652d 7065 726d 6973   "x-mitre-permis
+000001a0: 7369 6f6e 732d 7265 7175 6972 6564 222c  sions-required",
+000001b0: 0d0a 2020 2278 5f6d 6974 7265 5f6e 6574  ..  "x_mitre_net
+000001c0: 776f 726b 5f72 6571 7569 7265 6d65 6e74  work_requirement
+000001d0: 7322 3a20 2278 2d6d 6974 7265 2d6e 6574  s": "x-mitre-net
+000001e0: 776f 726b 2d72 6571 7569 7265 6d65 6e74  work-requirement
+000001f0: 7322 2c0d 0a20 2022 785f 6d69 7472 655f  s",..  "x_mitre_
+00000200: 6566 6665 6374 6976 655f 7065 726d 6973  effective_permis
+00000210: 7369 6f6e 7322 3a20 2278 2d6d 6974 7265  sions": "x-mitre
+00000220: 2d65 6666 6563 7469 7665 2d70 6572 6d69  -effective-permi
+00000230: 7373 696f 6e73 222c 0d0a 2020 2278 5f6d  ssions",..  "x_m
+00000240: 6974 7265 5f64 6566 656e 7365 5f62 7970  itre_defense_byp
+00000250: 6173 7365 6422 3a20 2278 2d6d 6974 7265  assed": "x-mitre
+00000260: 2d64 6566 656e 7365 2d62 7970 6173 7365  -defense-bypasse
+00000270: 6422 2c0d 0a20 2022 785f 6d69 7472 655f  d",..  "x_mitre_
+00000280: 7265 6d6f 7465 5f73 7570 706f 7274 223a  remote_support":
+00000290: 2022 782d 6d69 7472 652d 7265 6d6f 7465   "x-mitre-remote
+000002a0: 2d73 7570 706f 7274 222c 0d0a 2020 2278  -support",..  "x
+000002b0: 5f6d 6974 7265 5f69 6d70 6163 745f 7479  _mitre_impact_ty
+000002c0: 7065 223a 2022 782d 6d69 7472 652d 696d  pe": "x-mitre-im
+000002d0: 7061 6374 2d74 7970 6522 2c0d 0a20 2022  pact-type",..  "
+000002e0: 6b69 6c6c 5f63 6861 696e 5f70 6861 7365  kill_chain_phase
+000002f0: 7322 3a20 2222 2c0d 0a20 2022 616c 6961  s": "",..  "alia
+00000300: 7365 7322 3a20 2261 6c69 6173 6573 220d  ses": "aliases".
+00000310: 0a7d                                     .}
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/attack/mappings/object_conversion.json` & `stixorm-0.1.9/stixorm/module/definitions/attack/mappings/object_conversion.json`

 * *Format-specific differences are supported for JSON files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: JSON text data*

 * *Files 13% similar despite different names*

```diff
@@ -1,481 +1,493 @@
-00000000: 5b0a 2020 7b0a 2020 2020 2274 7970 6522  [.  {.    "type"
-00000010: 3a20 2022 782d 6d69 7472 652d 6d61 7472  :  "x-mitre-matr
-00000020: 6978 222c 0a20 2020 2022 7479 7065 716c  ix",.    "typeql
-00000030: 223a 2022 6d61 7472 6978 222c 0a20 2020  ": "matrix",.   
-00000040: 2022 636c 6173 7322 3a20 224d 6174 7269   "class": "Matri
-00000050: 7822 2c0a 2020 2020 226f 626a 6563 7422  x",.    "object"
-00000060: 3a20 2273 646f 222c 0a20 2020 2022 7572  : "sdo",.    "ur
-00000070: 6c22 3a20 2268 7474 7073 3a2f 2f67 6974  l": "https://git
-00000080: 6875 622e 636f 6d2f 6d69 7472 652d 6174  hub.com/mitre-at
-00000090: 7461 636b 2f61 7474 6163 6b2d 7374 6978  tack/attack-stix
-000000a0: 2d64 6174 612f 626c 6f62 2f6d 6173 7465  -data/blob/maste
-000000b0: 722f 5553 4147 452e 6d64 236d 6174 7269  r/USAGE.md#matri
-000000c0: 6365 7322 2c0a 2020 2020 2264 6f63 5f75  ces",.    "doc_u
-000000d0: 726c 223a 2022 222c 0a20 2020 2022 7375  rl": "",.    "su
-000000e0: 6d6d 6172 7922 3a20 2254 6865 206f 7665  mmary": "The ove
-000000f0: 7261 6c6c 206c 6179 6f75 7420 6f66 2074  rall layout of t
-00000100: 6865 2041 5454 2643 4b20 4d61 7472 6963  he ATT&CK Matric
-00000110: 6573 2069 7320 7374 6f72 6564 2069 6e20  es is stored in 
-00000120: 782d 6d69 7472 652d 6d61 7472 6978 206f  x-mitre-matrix o
-00000130: 626a 6563 7473 2e20 4173 2061 2063 7573  bjects. As a cus
-00000140: 746f 6d20 5354 4958 2074 7970 6520 7468  tom STIX type th
-00000150: 6579 2066 6f6c 6c6f 7720 6f6e 6c79 2074  ey follow only t
-00000160: 6865 2067 656e 6572 6963 2053 5449 5820  he generic STIX 
-00000170: 446f 6d61 696e 204f 626a 6563 7420 7061  Domain Object pa
-00000180: 7474 6572 6e2e 222c 0a20 2020 2022 7072  ttern.",.    "pr
-00000190: 6f74 6f63 6f6c 223a 2022 6174 7461 636b  otocol": "attack
-000001a0: 222c 0a20 2020 2022 6963 6f6e 223a 2261  ",.    "icon":"a
-000001b0: 7474 6163 6b5f 6963 6f6e 5f6d 6174 7269  ttack_icon_matri
-000001c0: 782e 706e 6722 0a20 207d 2c0a 2020 7b0a  x.png".  },.  {.
-000001d0: 2020 2020 2274 7970 6522 3a20 2022 782d      "type":  "x-
-000001e0: 6d69 7472 652d 7461 6374 6963 222c 0a20  mitre-tactic",. 
-000001f0: 2020 2022 7479 7065 716c 223a 2022 7461     "typeql": "ta
-00000200: 6374 6963 222c 0a20 2020 2022 636c 6173  ctic",.    "clas
-00000210: 7322 3a20 2254 6163 7469 6322 2c0a 2020  s": "Tactic",.  
-00000220: 2020 226f 626a 6563 7422 3a20 2273 646f    "object": "sdo
-00000230: 222c 0a20 2020 2022 7572 6c22 3a20 2268  ",.    "url": "h
-00000240: 7474 7073 3a2f 2f67 6974 6875 622e 636f  ttps://github.co
-00000250: 6d2f 6d69 7472 652d 6174 7461 636b 2f61  m/mitre-attack/a
-00000260: 7474 6163 6b2d 7374 6978 2d64 6174 612f  ttack-stix-data/
-00000270: 626c 6f62 2f6d 6173 7465 722f 5553 4147  blob/master/USAG
-00000280: 452e 6d64 2374 6163 7469 6373 222c 0a20  E.md#tactics",. 
-00000290: 2020 2022 646f 635f 7572 6c22 3a20 2222     "doc_url": ""
-000002a0: 2c0a 2020 2020 2273 756d 6d61 7279 223a  ,.    "summary":
-000002b0: 2022 4120 5461 6374 6963 2069 6e20 4154   "A Tactic in AT
-000002c0: 5426 434b 2069 7320 6465 6669 6e65 6420  T&CK is defined 
-000002d0: 6279 2061 6e20 782d 6d69 7472 652d 7461  by an x-mitre-ta
-000002e0: 6374 6963 206f 626a 6563 742e 2041 7320  ctic object. As 
-000002f0: 6120 6375 7374 6f6d 2053 5449 5820 7479  a custom STIX ty
-00000300: 7065 2074 6865 7920 666f 6c6c 6f77 206f  pe they follow o
-00000310: 6e6c 7920 7468 6520 6765 6e65 7269 6320  nly the generic 
-00000320: 5354 4958 2044 6f6d 6169 6e20 4f62 6a65  STIX Domain Obje
-00000330: 6374 2070 6174 7465 726e 2e22 2c0a 2020  ct pattern.",.  
-00000340: 2020 2270 726f 746f 636f 6c22 3a20 2261    "protocol": "a
-00000350: 7474 6163 6b22 2c0a 2020 2020 2269 636f  ttack",.    "ico
-00000360: 6e22 3a22 6174 7461 636b 5f69 636f 6e5f  n":"attack_icon_
-00000370: 7461 6374 6963 2e70 6e67 220a 2020 7d2c  tactic.png".  },
-00000380: 0a20 207b 0a20 2020 2022 7479 7065 223a  .  {.    "type":
-00000390: 2020 2261 7474 6163 6b2d 7061 7474 6572    "attack-patter
-000003a0: 6e22 2c0a 2020 2020 2274 7970 6571 6c22  n",.    "typeql"
-000003b0: 3a20 2274 6563 686e 6971 7565 222c 0a20  : "technique",. 
-000003c0: 2020 2022 636c 6173 7322 3a20 2254 6563     "class": "Tec
-000003d0: 686e 6971 7565 222c 0a20 2020 2022 6f62  hnique",.    "ob
-000003e0: 6a65 6374 223a 2022 7364 6f22 2c0a 2020  ject": "sdo",.  
-000003f0: 2020 2275 726c 223a 2022 6874 7470 733a    "url": "https:
-00000400: 2f2f 6769 7468 7562 2e63 6f6d 2f6d 6974  //github.com/mit
-00000410: 7265 2d61 7474 6163 6b2f 6174 7461 636b  re-attack/attack
-00000420: 2d73 7469 782d 6461 7461 2f62 6c6f 622f  -stix-data/blob/
-00000430: 6d61 7374 6572 2f55 5341 4745 2e6d 6423  master/USAGE.md#
-00000440: 7465 6368 6e69 7175 6573 222c 0a20 2020  techniques",.   
-00000450: 2022 646f 635f 7572 6c22 3a20 2222 2c0a   "doc_url": "",.
-00000460: 2020 2020 2273 756d 6d61 7279 223a 2022      "summary": "
-00000470: 4120 5465 6368 6e69 7175 6520 696e 2041  A Technique in A
-00000480: 5454 2643 4b20 6973 2064 6566 696e 6564  TT&CK is defined
-00000490: 2061 7320 616e 2061 7474 6163 6b2d 7061   as an attack-pa
-000004a0: 7474 6572 6e20 6f62 6a65 6374 2e22 2c0a  ttern object.",.
-000004b0: 2020 2020 2270 726f 746f 636f 6c22 3a20      "protocol": 
-000004c0: 2261 7474 6163 6b22 2c0a 2020 2020 2269  "attack",.    "i
-000004d0: 636f 6e22 3a22 6174 7461 636b 5f69 636f  con":"attack_ico
-000004e0: 6e5f 7465 6368 6e69 7175 652e 706e 6722  n_technique.png"
-000004f0: 0a20 207d 2c0a 2020 7b0a 2020 2020 2274  .  },.  {.    "t
-00000500: 7970 6522 3a20 2022 6174 7461 636b 2d70  ype":  "attack-p
-00000510: 6174 7465 726e 222c 0a20 2020 2022 7479  attern",.    "ty
-00000520: 7065 716c 223a 2022 7375 622d 7465 6368  peql": "sub-tech
-00000530: 6e69 7175 6522 2c0a 2020 2020 2263 6c61  nique",.    "cla
-00000540: 7373 223a 2022 5375 6254 6563 686e 6971  ss": "SubTechniq
-00000550: 7565 222c 0a20 2020 2022 6f62 6a65 6374  ue",.    "object
-00000560: 223a 2022 7364 6f22 2c0a 2020 2020 2275  ": "sdo",.    "u
-00000570: 726c 223a 2022 6874 7470 733a 2f2f 6769  rl": "https://gi
-00000580: 7468 7562 2e63 6f6d 2f6d 6974 7265 2d61  thub.com/mitre-a
-00000590: 7474 6163 6b2f 6174 7461 636b 2d73 7469  ttack/attack-sti
-000005a0: 782d 6461 7461 2f62 6c6f 622f 6d61 7374  x-data/blob/mast
-000005b0: 6572 2f55 5341 4745 2e6d 6423 7375 622d  er/USAGE.md#sub-
-000005c0: 7465 6368 6e69 7175 6573 222c 0a20 2020  techniques",.   
-000005d0: 2022 646f 635f 7572 6c22 3a20 2222 2c0a   "doc_url": "",.
-000005e0: 2020 2020 2273 756d 6d61 7279 223a 2022      "summary": "
-000005f0: 4120 7375 622d 7465 6368 6e69 7175 6520  A sub-technique 
-00000600: 696e 2041 5454 2643 4b20 6973 2072 6570  in ATT&CK is rep
-00000610: 7265 7365 6e74 6564 2061 7320 616e 2061  resented as an a
-00000620: 7474 6163 6b2d 7061 7474 6572 6e20 616e  ttack-pattern an
-00000630: 6420 666f 6c6c 6f77 7320 7468 6520 7361  d follows the sa
-00000640: 6d65 2066 6f72 6d61 7420 6173 2074 6563  me format as tec
-00000650: 686e 6971 7565 732e 2054 6865 7920 6469  hniques. They di
-00000660: 6666 6572 2069 6e20 7468 6174 2074 6865  ffer in that the
-00000670: 7920 6861 7665 2061 2062 6f6f 6c65 616e  y have a boolean
-00000680: 2066 6965 6c64 2028 785f 6d69 7472 655f   field (x_mitre_
-00000690: 6973 5f73 7562 7465 6368 6e69 7175 6529  is_subtechnique)
-000006a0: 206d 6172 6b69 6e67 2074 6865 6d20 6173   marking them as
-000006b0: 2073 7562 2d74 6563 686e 6971 7565 732c   sub-techniques,
-000006c0: 2061 6e64 2061 2072 656c 6174 696f 6e73   and a relations
-000006d0: 6869 7020 6f66 2074 6865 2074 7970 6520  hip of the type 
-000006e0: 7375 6274 6563 686e 6971 7565 2d6f 6620  subtechnique-of 
-000006f0: 7768 6572 6520 7468 6520 736f 7572 6365  where the source
-00000700: 5f72 6566 2069 7320 7468 6520 7375 622d  _ref is the sub-
-00000710: 7465 6368 6e69 7175 6520 616e 6420 7468  technique and th
-00000720: 6520 7461 7267 6574 5f72 6566 2069 7320  e target_ref is 
-00000730: 7468 6520 7061 7265 6e74 2074 6563 686e  the parent techn
-00000740: 6971 7565 2e20 4120 7375 622d 7465 6368  ique. A sub-tech
-00000750: 6e69 7175 6520 6361 6e20 6f6e 6c79 2068  nique can only h
-00000760: 6176 6520 3120 7061 7265 6e74 2074 6563  ave 1 parent tec
-00000770: 686e 6971 7565 2c20 6275 7420 7465 6368  hnique, but tech
-00000780: 6e69 7175 6573 2063 616e 2068 6176 6520  niques can have 
-00000790: 6d75 6c74 6970 6c65 2073 7562 2d74 6563  multiple sub-tec
-000007a0: 686e 6971 7565 732e 222c 0a20 2020 2022  hniques.",.    "
-000007b0: 7072 6f74 6f63 6f6c 223a 2022 6174 7461  protocol": "atta
-000007c0: 636b 222c 0a20 2020 2022 6963 6f6e 223a  ck",.    "icon":
-000007d0: 2261 7474 6163 6b5f 6963 6f6e 5f73 7562  "attack_icon_sub
-000007e0: 7465 6368 6e69 7175 652e 706e 6722 0a20  technique.png". 
-000007f0: 207d 2c0a 2020 7b0a 2020 2020 2274 7970   },.  {.    "typ
-00000800: 6522 3a20 2022 7265 6c61 7469 6f6e 7368  e":  "relationsh
-00000810: 6970 222c 0a20 2020 2022 7479 7065 716c  ip",.    "typeql
-00000820: 223a 2022 6174 7461 636b 2d72 656c 6174  ": "attack-relat
-00000830: 696f 6e22 2c0a 2020 2020 2263 6c61 7373  ion",.    "class
-00000840: 223a 2022 4174 7461 636b 5265 6c61 7469  ": "AttackRelati
-00000850: 6f6e 222c 0a20 2020 2022 6f62 6a65 6374  on",.    "object
-00000860: 223a 2022 7372 6f22 2c0a 2020 2020 2275  ": "sro",.    "u
-00000870: 726c 223a 2022 6874 7470 733a 2f2f 6769  rl": "https://gi
-00000880: 7468 7562 2e63 6f6d 2f6d 6974 7265 2d61  thub.com/mitre-a
-00000890: 7474 6163 6b2f 6174 7461 636b 2d73 7469  ttack/attack-sti
-000008a0: 782d 6461 7461 2f62 6c6f 622f 6d61 7374  x-data/blob/mast
-000008b0: 6572 2f55 5341 4745 2e6d 6423 7265 6c61  er/USAGE.md#rela
-000008c0: 7469 6f6e 7368 6970 7322 2c0a 2020 2020  tionships",.    
-000008d0: 2264 6f63 5f75 726c 223a 2022 222c 0a20  "doc_url": "",. 
-000008e0: 2020 2022 7375 6d6d 6172 7922 3a20 2222     "summary": ""
-000008f0: 2c0a 2020 2020 2270 726f 746f 636f 6c22  ,.    "protocol"
-00000900: 3a20 2261 7474 6163 6b22 2c0a 2020 2020  : "attack",.    
-00000910: 2269 636f 6e22 3a22 220a 2020 7d2c 0a20  "icon":"".  },. 
-00000920: 207b 0a20 2020 2022 7479 7065 223a 2020   {.    "type":  
-00000930: 2263 6f75 7273 652d 6f66 2d61 6374 696f  "course-of-actio
-00000940: 6e22 2c0a 2020 2020 2274 7970 6571 6c22  n",.    "typeql"
-00000950: 3a20 226d 6974 6967 6174 696f 6e22 2c0a  : "mitigation",.
-00000960: 2020 2020 2263 6c61 7373 223a 2022 4d69      "class": "Mi
-00000970: 7469 6761 7469 6f6e 222c 0a20 2020 2022  tigation",.    "
-00000980: 6f62 6a65 6374 223a 2022 7364 6f22 2c0a  object": "sdo",.
-00000990: 2020 2020 2275 726c 223a 2022 6874 7470      "url": "http
-000009a0: 733a 2f2f 6769 7468 7562 2e63 6f6d 2f6d  s://github.com/m
-000009b0: 6974 7265 2d61 7474 6163 6b2f 6174 7461  itre-attack/atta
-000009c0: 636b 2d73 7469 782d 6461 7461 2f62 6c6f  ck-stix-data/blo
-000009d0: 622f 6d61 7374 6572 2f55 5341 4745 2e6d  b/master/USAGE.m
-000009e0: 6423 6d69 7469 6761 7469 6f6e 7322 2c0a  d#mitigations",.
-000009f0: 2020 2020 2264 6f63 5f75 726c 223a 2022      "doc_url": "
-00000a00: 222c 0a20 2020 2022 7375 6d6d 6172 7922  ",.    "summary"
-00000a10: 3a20 2241 204d 6974 6967 6174 696f 6e20  : "A Mitigation 
-00000a20: 696e 2041 5454 2643 4b20 6973 2064 6566  in ATT&CK is def
-00000a30: 696e 6564 2061 7320 6120 636f 7572 7365  ined as a course
-00000a40: 2d6f 662d 6163 7469 6f6e 206f 626a 6563  -of-action objec
-00000a50: 742e 2041 5454 2643 4b20 4d69 7469 6761  t. ATT&CK Mitiga
-00000a60: 7469 6f6e 7320 646f 206e 6f74 2064 6570  tions do not dep
-00000a70: 6172 7420 6672 6f6d 2074 6865 2053 5449  art from the STI
-00000a80: 5820 636f 7572 7365 2d6f 662d 6163 7469  X course-of-acti
-00000a90: 6f6e 2073 7065 632e 222c 0a20 2020 2022  on spec.",.    "
-00000aa0: 7072 6f74 6f63 6f6c 223a 2022 6174 7461  protocol": "atta
-00000ab0: 636b 222c 0a20 2020 2022 6963 6f6e 223a  ck",.    "icon":
-00000ac0: 2261 7474 6163 6b5f 6963 6f6e 5f6d 6974  "attack_icon_mit
-00000ad0: 6967 6174 696f 6e2e 706e 6722 0a20 207d  igation.png".  }
-00000ae0: 2c0a 2020 7b0a 2020 2020 2274 7970 6522  ,.  {.    "type"
-00000af0: 3a20 2022 6d61 726b 696e 672d 6465 6669  :  "marking-defi
-00000b00: 6e69 7469 6f6e 222c 0a20 2020 2022 7479  nition",.    "ty
-00000b10: 7065 716c 223a 2022 6174 7461 636b 2d6d  peql": "attack-m
-00000b20: 6172 6b69 6e67 222c 0a20 2020 2022 636c  arking",.    "cl
-00000b30: 6173 7322 3a20 2241 7474 6163 6b4d 6172  ass": "AttackMar
-00000b40: 6b69 6e67 222c 0a20 2020 2022 6f62 6a65  king",.    "obje
-00000b50: 6374 223a 2022 6d65 7461 222c 0a20 2020  ct": "meta",.   
-00000b60: 2022 7572 6c22 3a20 2268 7474 7073 3a2f   "url": "https:/
-00000b70: 2f67 6974 6875 622e 636f 6d2f 6d69 7472  /github.com/mitr
-00000b80: 652d 6174 7461 636b 2f61 7474 6163 6b2d  e-attack/attack-
-00000b90: 7374 6978 2d64 6174 612f 626c 6f62 2f6d  stix-data/blob/m
-00000ba0: 6173 7465 722f 5553 4147 452e 6d64 2374  aster/USAGE.md#t
-00000bb0: 6865 2d61 7474 636b 2d73 7065 6322 2c0a  he-attck-spec",.
-00000bc0: 2020 2020 2264 6f63 5f75 726c 223a 2022      "doc_url": "
-00000bd0: 222c 0a20 2020 2022 7375 6d6d 6172 7922  ",.    "summary"
-00000be0: 3a20 2222 2c0a 2020 2020 2270 726f 746f  : "",.    "proto
-00000bf0: 636f 6c22 3a20 2261 7474 6163 6b22 2c0a  col": "attack",.
-00000c00: 2020 2020 2269 636f 6e22 3a22 220a 2020      "icon":"".  
-00000c10: 7d2c 0a20 207b 0a20 2020 2022 7479 7065  },.  {.    "type
-00000c20: 223a 2020 2269 6465 6e74 6974 7922 2c0a  ":  "identity",.
-00000c30: 2020 2020 2274 7970 6571 6c22 3a20 2261      "typeql": "a
-00000c40: 7474 6163 6b2d 6964 656e 7469 7479 222c  ttack-identity",
-00000c50: 0a20 2020 2022 636c 6173 7322 3a20 2241  .    "class": "A
-00000c60: 7474 6163 6b49 6465 6e74 6974 7922 2c0a  ttackIdentity",.
-00000c70: 2020 2020 226f 626a 6563 7422 3a20 2273      "object": "s
-00000c80: 646f 222c 0a20 2020 2022 7572 6c22 3a20  do",.    "url": 
-00000c90: 2268 7474 7073 3a2f 2f67 6974 6875 622e  "https://github.
-00000ca0: 636f 6d2f 6d69 7472 652d 6174 7461 636b  com/mitre-attack
-00000cb0: 2f61 7474 6163 6b2d 7374 6978 2d64 6174  /attack-stix-dat
-00000cc0: 612f 626c 6f62 2f6d 6173 7465 722f 5553  a/blob/master/US
-00000cd0: 4147 452e 6d64 2374 6865 2d61 7474 636b  AGE.md#the-attck
-00000ce0: 2d73 7065 6322 2c0a 2020 2020 2264 6f63  -spec",.    "doc
-00000cf0: 5f75 726c 223a 2022 222c 0a20 2020 2022  _url": "",.    "
-00000d00: 7375 6d6d 6172 7922 3a20 2252 6566 6572  summary": "Refer
-00000d10: 656e 6365 6420 6279 2063 7265 6174 6564  enced by created
-00000d20: 5f62 795f 7265 6620 616e 6420 785f 6d69  _by_ref and x_mi
-00000d30: 7472 655f 6d6f 6469 6669 6564 5f62 795f  tre_modified_by_
-00000d40: 7265 6620 746f 2063 6f6e 7665 7920 7468  ref to convey th
-00000d50: 6520 6372 6561 746f 7220 616e 6420 6d6f  e creator and mo
-00000d60: 7374 2072 6563 656e 7420 6d6f 6469 6669  st recent modifi
-00000d70: 6572 206f 6620 6561 6368 206f 626a 6563  er of each objec
-00000d80: 7422 2c0a 2020 2020 2270 726f 746f 636f  t",.    "protoco
-00000d90: 6c22 3a20 2261 7474 6163 6b22 2c0a 2020  l": "attack",.  
-00000da0: 2020 2269 636f 6e22 3a22 220a 2020 7d2c    "icon":"".  },
-00000db0: 0a20 207b 0a20 2020 2022 7479 7065 223a  .  {.    "type":
-00000dc0: 2020 2269 6e74 7275 7369 6f6e 2d73 6574    "intrusion-set
-00000dd0: 222c 0a20 2020 2022 7479 7065 716c 223a  ",.    "typeql":
-00000de0: 2022 6174 7461 636b 2d67 726f 7570 222c   "attack-group",
-00000df0: 0a20 2020 2022 636c 6173 7322 3a20 2247  .    "class": "G
-00000e00: 726f 7570 222c 0a20 2020 2022 6f62 6a65  roup",.    "obje
-00000e10: 6374 223a 2022 7364 6f22 2c0a 2020 2020  ct": "sdo",.    
-00000e20: 2275 726c 223a 2022 6874 7470 733a 2f2f  "url": "https://
-00000e30: 6769 7468 7562 2e63 6f6d 2f6d 6974 7265  github.com/mitre
-00000e40: 2d61 7474 6163 6b2f 6174 7461 636b 2d73  -attack/attack-s
-00000e50: 7469 782d 6461 7461 2f62 6c6f 622f 6d61  tix-data/blob/ma
-00000e60: 7374 6572 2f55 5341 4745 2e6d 6423 6772  ster/USAGE.md#gr
-00000e70: 6f75 7073 222c 0a20 2020 2022 646f 635f  oups",.    "doc_
-00000e80: 7572 6c22 3a20 2222 2c0a 2020 2020 2273  url": "",.    "s
-00000e90: 756d 6d61 7279 223a 2022 4120 4772 6f75  ummary": "A Grou
-00000ea0: 7020 696e 2041 5454 2643 4b20 6973 2064  p in ATT&CK is d
-00000eb0: 6566 696e 6564 2061 7320 616e 2069 6e74  efined as an int
-00000ec0: 7275 7369 6f6e 2d73 6574 206f 626a 6563  rusion-set objec
-00000ed0: 742e 2041 5454 2643 4b20 4772 6f75 7073  t. ATT&CK Groups
-00000ee0: 2064 6f20 6e6f 7420 6465 7061 7274 2066   do not depart f
-00000ef0: 726f 6d20 7468 6520 5354 4958 2069 6e74  rom the STIX int
-00000f00: 7275 7369 6f6e 2d73 6574 2073 7065 632e  rusion-set spec.
-00000f10: 222c 0a20 2020 2022 7072 6f74 6f63 6f6c  ",.    "protocol
-00000f20: 223a 2022 6174 7461 636b 222c 0a20 2020  ": "attack",.   
-00000f30: 2022 6963 6f6e 223a 2261 7474 6163 6b5f   "icon":"attack_
-00000f40: 6963 6f6e 5f67 726f 7570 2e70 6e67 220a  icon_group.png".
-00000f50: 2020 7d2c 0a20 207b 0a20 2020 2022 7479    },.  {.    "ty
-00000f60: 7065 223a 2020 226d 616c 7761 7265 222c  pe":  "malware",
-00000f70: 0a20 2020 2022 7479 7065 716c 223a 2022  .    "typeql": "
-00000f80: 736f 6674 7761 7265 2d6d 616c 7761 7265  software-malware
-00000f90: 222c 0a20 2020 2022 636c 6173 7322 3a20  ",.    "class": 
-00000fa0: 2253 6f66 7477 6172 654d 616c 7761 7265  "SoftwareMalware
-00000fb0: 222c 0a20 2020 2022 6f62 6a65 6374 223a  ",.    "object":
-00000fc0: 2022 7364 6f22 2c0a 2020 2020 2275 726c   "sdo",.    "url
-00000fd0: 223a 2022 6874 7470 733a 2f2f 6769 7468  ": "https://gith
-00000fe0: 7562 2e63 6f6d 2f6d 6974 7265 2d61 7474  ub.com/mitre-att
-00000ff0: 6163 6b2f 6174 7461 636b 2d73 7469 782d  ack/attack-stix-
-00001000: 6461 7461 2f62 6c6f 622f 6d61 7374 6572  data/blob/master
-00001010: 2f55 5341 4745 2e6d 6423 736f 6674 7761  /USAGE.md#softwa
-00001020: 7265 222c 0a20 2020 2022 646f 635f 7572  re",.    "doc_ur
-00001030: 6c22 3a20 2222 2c0a 2020 2020 2273 756d  l": "",.    "sum
-00001040: 6d61 7279 223a 2022 536f 6674 7761 7265  mary": "Software
-00001050: 2069 6e20 4154 5426 434b 2069 7320 7468   in ATT&CK is th
-00001060: 6520 756e 696f 6e20 6f66 2074 776f 2064  e union of two d
-00001070: 6973 7469 6e63 7420 5354 4958 2074 7970  istinct STIX typ
-00001080: 6573 3a20 6d61 6c77 6172 6520 616e 6420  es: malware and 
-00001090: 746f 6f6c 2e22 2c0a 2020 2020 2270 726f  tool.",.    "pro
-000010a0: 746f 636f 6c22 3a20 2261 7474 6163 6b22  tocol": "attack"
-000010b0: 2c0a 2020 2020 2269 636f 6e22 3a22 6174  ,.    "icon":"at
-000010c0: 7461 636b 5f69 636f 6e5f 736f 6674 7761  tack_icon_softwa
-000010d0: 7265 2e70 6e67 220a 2020 7d2c 0a20 207b  re.png".  },.  {
-000010e0: 0a20 2020 2022 7479 7065 223a 2020 2274  .    "type":  "t
-000010f0: 6f6f 6c22 2c0a 2020 2020 2274 7970 6571  ool",.    "typeq
-00001100: 6c22 3a20 2273 6f66 7477 6172 652d 746f  l": "software-to
-00001110: 6f6c 222c 0a20 2020 2022 636c 6173 7322  ol",.    "class"
-00001120: 3a20 2253 6f66 7477 6172 6554 6f6f 6c22  : "SoftwareTool"
-00001130: 2c0a 2020 2020 226f 626a 6563 7422 3a20  ,.    "object": 
-00001140: 2273 646f 222c 0a20 2020 2022 7572 6c22  "sdo",.    "url"
-00001150: 3a20 2268 7474 7073 3a2f 2f67 6974 6875  : "https://githu
-00001160: 622e 636f 6d2f 6d69 7472 652d 6174 7461  b.com/mitre-atta
-00001170: 636b 2f61 7474 6163 6b2d 7374 6978 2d64  ck/attack-stix-d
-00001180: 6174 612f 626c 6f62 2f6d 6173 7465 722f  ata/blob/master/
-00001190: 5553 4147 452e 6d64 2373 6f66 7477 6172  USAGE.md#softwar
-000011a0: 6522 2c0a 2020 2020 2264 6f63 5f75 726c  e",.    "doc_url
-000011b0: 223a 2022 222c 0a20 2020 2022 7375 6d6d  ": "",.    "summ
-000011c0: 6172 7922 3a20 2253 6f66 7477 6172 6520  ary": "Software 
-000011d0: 696e 2041 5454 2643 4b20 6973 2074 6865  in ATT&CK is the
-000011e0: 2075 6e69 6f6e 206f 6620 7477 6f20 6469   union of two di
-000011f0: 7374 696e 6374 2053 5449 5820 7479 7065  stinct STIX type
-00001200: 733a 206d 616c 7761 7265 2061 6e64 2074  s: malware and t
-00001210: 6f6f 6c2e 222c 0a20 2020 2022 7072 6f74  ool.",.    "prot
-00001220: 6f63 6f6c 223a 2022 6174 7461 636b 222c  ocol": "attack",
-00001230: 0a20 2020 2022 6963 6f6e 223a 2261 7474  .    "icon":"att
-00001240: 6163 6b5f 6963 6f6e 5f73 6f66 7477 6172  ack_icon_softwar
-00001250: 652e 706e 6722 0a20 207d 2c0a 2020 7b0a  e.png".  },.  {.
-00001260: 2020 2020 2274 7970 6522 3a20 2022 782d      "type":  "x-
-00001270: 6d69 7472 652d 636f 6c6c 6563 7469 6f6e  mitre-collection
-00001280: 222c 0a20 2020 2022 7479 7065 716c 223a  ",.    "typeql":
-00001290: 2022 636f 6c6c 6563 7469 6f6e 222c 0a20   "collection",. 
-000012a0: 2020 2022 636c 6173 7322 3a20 2243 6f6c     "class": "Col
-000012b0: 6c65 6374 696f 6e22 2c0a 2020 2020 226f  lection",.    "o
-000012c0: 626a 6563 7422 3a20 2273 646f 222c 0a20  bject": "sdo",. 
-000012d0: 2020 2022 7572 6c22 3a20 2268 7474 7073     "url": "https
-000012e0: 3a2f 2f67 6974 6875 622e 636f 6d2f 6365  ://github.com/ce
-000012f0: 6e74 6572 2d66 6f72 2d74 6872 6561 742d  nter-for-threat-
-00001300: 696e 666f 726d 6564 2d64 6566 656e 7365  informed-defense
-00001310: 2f61 7474 6163 6b2d 776f 726b 6265 6e63  /attack-workbenc
-00001320: 682d 6672 6f6e 7465 6e64 2f62 6c6f 622f  h-frontend/blob/
-00001330: 6d61 7374 6572 2f64 6f63 732f 636f 6c6c  master/docs/coll
-00001340: 6563 7469 6f6e 732e 6d64 222c 0a20 2020  ections.md",.   
-00001350: 2022 646f 635f 7572 6c22 3a20 2222 2c0a   "doc_url": "",.
-00001360: 2020 2020 2273 756d 6d61 7279 223a 2022      "summary": "
-00001370: 4120 636f 6c6c 6563 7469 6f6e 2069 7320  A collection is 
-00001380: 6120 7365 7420 6f66 2072 656c 6174 6564  a set of related
-00001390: 2041 5454 2643 4b20 6f62 6a65 6374 733b   ATT&CK objects;
-000013a0: 2063 6f6c 6c65 6374 696f 6e73 206d 6179   collections may
-000013b0: 2062 6520 7573 6564 2074 6f20 7265 7072   be used to repr
-000013c0: 6573 656e 7420 7370 6563 6966 6963 2072  esent specific r
-000013d0: 656c 6561 7365 7320 6f66 2061 2064 6174  eleases of a dat
-000013e0: 6173 6574 2073 7563 6820 6173 205c 2245  aset such as \"E
-000013f0: 6e74 6572 7072 6973 6520 4154 5426 434b  nterprise ATT&CK
-00001400: 2076 372e 325c 222c 206f 7220 616e 7920   v7.2\", or any 
-00001410: 6f74 6865 7220 7365 7420 6f66 206f 626a  other set of obj
-00001420: 6563 7473 206f 6e65 206d 6179 2077 616e  ects one may wan
-00001430: 7420 746f 2073 6861 7265 2077 6974 6820  t to share with 
-00001440: 736f 6d65 6f6e 6520 656c 7365 2e20 436f  someone else. Co
-00001450: 6c6c 6563 7469 6f6e 7320 6172 6520 6d65  llections are me
-00001460: 616e 7420 746f 2062 6520 7368 6172 6564  ant to be shared
-00001470: 2e20 436f 6c6c 6563 7469 6f6e 7320 6361  . Collections ca
-00001480: 6e20 6265 2073 6861 7265 6420 6173 2053  n be shared as S
-00001490: 5449 5820 6275 6e64 6c65 732c 2075 706c  TIX bundles, upl
-000014a0: 6f61 6465 6420 746f 2074 6865 2069 6e74  oaded to the int
-000014b0: 6572 6e65 742c 206f 7220 7365 6e74 2074  ernet, or sent t
-000014c0: 6872 6f75 6768 2065 6d61 696c 2e22 2c0a  hrough email.",.
-000014d0: 2020 2020 2270 726f 746f 636f 6c22 3a20      "protocol": 
-000014e0: 2261 7474 6163 6b22 2c0a 2020 2020 2269  "attack",.    "i
-000014f0: 636f 6e22 3a22 6174 7461 636b 5f69 636f  con":"attack_ico
-00001500: 6e5f 636f 6c6c 6563 7469 6f6e 2e70 6e67  n_collection.png
-00001510: 220a 2020 7d2c 0a20 207b 0a20 2020 2022  ".  },.  {.    "
-00001520: 7479 7065 223a 2020 2278 2d6d 6974 7265  type":  "x-mitre
-00001530: 2d64 6174 612d 736f 7572 6365 222c 0a20  -data-source",. 
-00001540: 2020 2022 7479 7065 716c 223a 2022 6461     "typeql": "da
-00001550: 7461 2d73 6f75 7263 6522 2c0a 2020 2020  ta-source",.    
-00001560: 2263 6c61 7373 223a 2022 4461 7461 536f  "class": "DataSo
-00001570: 7572 6365 222c 0a20 2020 2022 6f62 6a65  urce",.    "obje
-00001580: 6374 223a 2022 7364 6f22 2c0a 2020 2020  ct": "sdo",.    
-00001590: 2275 726c 223a 2022 6874 7470 733a 2f2f  "url": "https://
-000015a0: 6769 7468 7562 2e63 6f6d 2f6d 6974 7265  github.com/mitre
-000015b0: 2d61 7474 6163 6b2f 6174 7461 636b 2d73  -attack/attack-s
-000015c0: 7469 782d 6461 7461 2f62 6c6f 622f 6d61  tix-data/blob/ma
-000015d0: 7374 6572 2f55 5341 4745 2e6d 6423 6461  ster/USAGE.md#da
-000015e0: 7461 2d73 6f75 7263 6573 2d61 6e64 2d64  ta-sources-and-d
-000015f0: 6174 612d 636f 6d70 6f6e 656e 7473 222c  ata-components",
-00001600: 0a20 2020 2022 646f 635f 7572 6c22 3a20  .    "doc_url": 
-00001610: 2222 2c0a 2020 2020 2273 756d 6d61 7279  "",.    "summary
-00001620: 223a 2022 4120 4461 7461 2053 6f75 7263  ": "A Data Sourc
-00001630: 6520 696e 2041 5454 2643 4b20 6973 2064  e in ATT&CK is d
-00001640: 6566 696e 6564 2062 7920 616e 2078 2d6d  efined by an x-m
-00001650: 6974 7265 2d64 6174 612d 736f 7572 6365  itre-data-source
-00001660: 206f 626a 6563 742e 2041 7320 6120 6375   object. As a cu
-00001670: 7374 6f6d 2053 5449 5820 7479 7065 2074  stom STIX type t
-00001680: 6865 7920 666f 6c6c 6f77 206f 6e6c 7920  hey follow only 
-00001690: 7468 6520 6765 6e65 7269 6320 5354 4958  the generic STIX
-000016a0: 2044 6f6d 6169 6e20 4f62 6a65 6374 2070   Domain Object p
-000016b0: 6174 7465 726e 2e22 2c0a 2020 2020 2270  attern.",.    "p
-000016c0: 726f 746f 636f 6c22 3a20 2261 7474 6163  rotocol": "attac
-000016d0: 6b22 2c0a 2020 2020 2269 636f 6e22 3a22  k",.    "icon":"
-000016e0: 6174 7461 636b 5f69 636f 6e5f 6461 7461  attack_icon_data
-000016f0: 5f73 6f75 7263 652e 706e 6722 0a20 207d  _source.png".  }
-00001700: 2c0a 2020 7b0a 2020 2020 2274 7970 6522  ,.  {.    "type"
-00001710: 3a20 2022 782d 6d69 7472 652d 6461 7461  :  "x-mitre-data
-00001720: 2d63 6f6d 706f 6e65 6e74 222c 0a20 2020  -component",.   
-00001730: 2022 7479 7065 716c 223a 2022 6461 7461   "typeql": "data
-00001740: 2d63 6f6d 706f 6e65 6e74 222c 0a20 2020  -component",.   
-00001750: 2022 636c 6173 7322 3a20 2244 6174 6143   "class": "DataC
-00001760: 6f6d 706f 6e65 6e74 222c 0a20 2020 2022  omponent",.    "
-00001770: 6f62 6a65 6374 223a 2022 7364 6f22 2c0a  object": "sdo",.
-00001780: 2020 2020 2275 726c 223a 2022 6874 7470      "url": "http
-00001790: 733a 2f2f 6769 7468 7562 2e63 6f6d 2f6d  s://github.com/m
-000017a0: 6974 7265 2d61 7474 6163 6b2f 6174 7461  itre-attack/atta
-000017b0: 636b 2d73 7469 782d 6461 7461 2f62 6c6f  ck-stix-data/blo
-000017c0: 622f 6d61 7374 6572 2f55 5341 4745 2e6d  b/master/USAGE.m
-000017d0: 6423 6461 7461 2d73 6f75 7263 6573 2d61  d#data-sources-a
-000017e0: 6e64 2d64 6174 612d 636f 6d70 6f6e 656e  nd-data-componen
-000017f0: 7473 222c 0a20 2020 2022 646f 635f 7572  ts",.    "doc_ur
-00001800: 6c22 3a20 2222 2c0a 2020 2020 2273 756d  l": "",.    "sum
-00001810: 6d61 7279 223a 2022 4120 4461 7461 2043  mary": "A Data C
-00001820: 6f6d 706f 6e65 6e74 2069 6e20 4154 5426  omponent in ATT&
-00001830: 434b 2069 7320 7265 7072 6573 656e 7465  CK is represente
-00001840: 6420 6173 2061 6e20 782d 6d69 7472 652d  d as an x-mitre-
-00001850: 6461 7461 2d63 6f6d 706f 6e65 6e74 206f  data-component o
-00001860: 626a 6563 742e 2041 7320 6120 6375 7374  bject. As a cust
-00001870: 6f6d 2053 5449 5820 7479 7065 2074 6865  om STIX type the
-00001880: 7920 666f 6c6c 6f77 206f 6e6c 7920 7468  y follow only th
-00001890: 6520 6765 6e65 7269 6320 5354 4958 2044  e generic STIX D
-000018a0: 6f6d 6169 6e20 4f62 6a65 6374 2070 6174  omain Object pat
-000018b0: 7465 726e 2e22 2c0a 2020 2020 2270 726f  tern.",.    "pro
-000018c0: 746f 636f 6c22 3a20 2261 7474 6163 6b22  tocol": "attack"
-000018d0: 2c0a 2020 2020 2269 636f 6e22 3a22 6174  ,.    "icon":"at
-000018e0: 7461 636b 5f69 636f 6e5f 6461 7461 5f63  tack_icon_data_c
-000018f0: 6f6d 706f 6e65 6e74 2e70 6e67 220a 2020  omponent.png".  
-00001900: 7d2c 0a20 207b 0a20 2020 2022 7479 7065  },.  {.    "type
-00001910: 223a 2020 2263 616d 7061 6967 6e22 2c0a  ":  "campaign",.
-00001920: 2020 2020 2274 7970 6571 6c22 3a20 2261      "typeql": "a
-00001930: 7474 6163 6b2d 6361 6d70 6169 676e 222c  ttack-campaign",
-00001940: 0a20 2020 2022 636c 6173 7322 3a20 2241  .    "class": "A
-00001950: 7474 6163 6b43 616d 7061 6967 6e22 2c0a  ttackCampaign",.
-00001960: 2020 2020 226f 626a 6563 7422 3a20 2273      "object": "s
-00001970: 646f 222c 0a20 2020 2022 7572 6c22 3a20  do",.    "url": 
-00001980: 2268 7474 7073 3a2f 2f67 6974 6875 622e  "https://github.
-00001990: 636f 6d2f 6d69 7472 652d 6174 7461 636b  com/mitre-attack
-000019a0: 2f61 7474 6163 6b2d 7374 6978 2d64 6174  /attack-stix-dat
-000019b0: 612f 626c 6f62 2f6d 6173 7465 722f 5553  a/blob/master/US
-000019c0: 4147 452e 6d64 2363 616d 7061 6967 6e73  AGE.md#campaigns
-000019d0: 222c 0a20 2020 2022 646f 635f 7572 6c22  ",.    "doc_url"
-000019e0: 3a20 2222 2c0a 2020 2020 2273 756d 6d61  : "",.    "summa
-000019f0: 7279 223a 2022 4120 4361 6d70 6169 676e  ry": "A Campaign
-00001a00: 2069 6e20 4154 5426 434b 2069 7320 6465   in ATT&CK is de
-00001a10: 6669 6e65 6420 6173 2061 2063 616d 7061  fined as a campa
-00001a20: 6967 6e20 6f62 6a65 6374 2e22 2c0a 2020  ign object.",.  
-00001a30: 2020 2270 726f 746f 636f 6c22 3a20 2261    "protocol": "a
-00001a40: 7474 6163 6b22 2c0a 2020 2020 2269 636f  ttack",.    "ico
-00001a50: 6e22 3a22 6174 7461 636b 5f69 636f 6e5f  n":"attack_icon_
-00001a60: 6361 6d70 6169 676e 2e70 6e67 220a 2020  campaign.png".  
-00001a70: 7d2c 0a20 207b 0a20 2020 2022 7479 7065  },.  {.    "type
-00001a80: 223a 2020 226f 626a 6563 742d 7665 7273  ":  "object-vers
-00001a90: 696f 6e2d 7265 6622 2c0a 2020 2020 2274  ion-ref",.    "t
-00001aa0: 7970 6571 6c22 3a20 226f 626a 6563 742d  ypeql": "object-
-00001ab0: 7665 7273 696f 6e22 2c0a 2020 2020 2263  version",.    "c
-00001ac0: 6c61 7373 223a 2022 4f62 6a65 6374 5665  lass": "ObjectVe
-00001ad0: 7273 696f 6e22 2c0a 2020 2020 226f 626a  rsion",.    "obj
-00001ae0: 6563 7422 3a20 2273 7562 222c 0a20 2020  ect": "sub",.   
-00001af0: 2022 7572 6c22 3a20 2268 7474 7073 3a2f   "url": "https:/
-00001b00: 2f67 6974 6875 622e 636f 6d2f 6365 6e74  /github.com/cent
-00001b10: 6572 2d66 6f72 2d74 6872 6561 742d 696e  er-for-threat-in
-00001b20: 666f 726d 6564 2d64 6566 656e 7365 2f61  formed-defense/a
-00001b30: 7474 6163 6b2d 776f 726b 6265 6e63 682d  ttack-workbench-
-00001b40: 6672 6f6e 7465 6e64 2f62 6c6f 622f 6d61  frontend/blob/ma
-00001b50: 7374 6572 2f64 6f63 732f 636f 6c6c 6563  ster/docs/collec
-00001b60: 7469 6f6e 732e 6d64 222c 0a20 2020 2022  tions.md",.    "
-00001b70: 646f 635f 7572 6c22 3a20 2222 2c0a 2020  doc_url": "",.  
-00001b80: 2020 2273 756d 6d61 7279 223a 2022 4f62    "summary": "Ob
-00001b90: 6a65 6374 2076 6572 7369 6f6e 2072 6566  ject version ref
-00001ba0: 6572 656e 6365 7320 6172 6520 7573 6564  erences are used
-00001bb0: 2074 6f20 7265 6665 7220 746f 2061 2073   to refer to a s
-00001bc0: 7065 6369 6669 6320 7665 7273 696f 6e20  pecific version 
-00001bd0: 6f66 2061 2053 5449 5820 6f62 6a65 6374  of a STIX object
-00001be0: 2e20 5468 6579 2064 6f20 7468 6973 2062  . They do this b
-00001bf0: 7920 636f 6d62 696e 696e 6720 6120 5354  y combining a ST
-00001c00: 4958 2049 4420 6f66 2074 6865 206f 626a  IX ID of the obj
-00001c10: 6563 7420 7769 7468 2074 6865 206d 6f64  ect with the mod
-00001c20: 6966 6965 6420 7469 6d65 7374 616d 7020  ified timestamp 
-00001c30: 6f66 2074 6865 2067 6976 656e 2076 6572  of the given ver
-00001c40: 7369 6f6e 2e22 2c0a 2020 2020 2270 726f  sion.",.    "pro
-00001c50: 746f 636f 6c22 3a20 2261 7474 6163 6b22  tocol": "attack"
-00001c60: 2c0a 2020 2020 2269 636f 6e22 3a22 220a  ,.    "icon":"".
-00001c70: 2020 7d2c 0a20 207b 0a20 2020 2022 7479    },.  {.    "ty
-00001c80: 7065 223a 2020 226d 6172 6b69 6e67 2d64  pe":  "marking-d
-00001c90: 6566 696e 6974 696f 6e22 2c0a 2020 2020  efinition",.    
-00001ca0: 2274 7970 6571 6c22 3a20 2261 7474 6163  "typeql": "attac
-00001cb0: 6b2d 6d61 726b 696e 6722 2c0a 2020 2020  k-marking",.    
-00001cc0: 2263 6c61 7373 223a 2022 4174 7461 636b  "class": "Attack
-00001cd0: 4d61 726b 696e 6722 2c0a 2020 2020 226f  Marking",.    "o
-00001ce0: 626a 6563 7422 3a20 226d 6574 6122 2c0a  bject": "meta",.
-00001cf0: 2020 2020 2275 726c 223a 2022 6874 7470      "url": "http
-00001d00: 733a 2f2f 6769 7468 7562 2e63 6f6d 2f6d  s://github.com/m
-00001d10: 6974 7265 2d61 7474 6163 6b2f 6174 7461  itre-attack/atta
-00001d20: 636b 2d73 7469 782d 6461 7461 2f62 6c6f  ck-stix-data/blo
-00001d30: 622f 6d61 7374 6572 2f55 5341 4745 2e6d  b/master/USAGE.m
-00001d40: 6423 7468 652d 6174 7463 6b2d 7370 6563  d#the-attck-spec
-00001d50: 222c 0a20 2020 2022 646f 635f 7572 6c22  ",.    "doc_url"
-00001d60: 3a20 2222 2c0a 2020 2020 2273 756d 6d61  : "",.    "summa
-00001d70: 7279 223a 2022 5265 6665 7265 6e63 6564  ry": "Referenced
-00001d80: 2069 6e20 7468 6520 6f62 6a65 6374 5f6d   in the object_m
-00001d90: 6172 6b69 6e67 5f72 6566 7320 6f66 2061  arking_refs of a
-00001da0: 6c6c 206f 626a 6563 7473 2074 6f20 6578  ll objects to ex
-00001db0: 7072 6573 7320 7468 6520 4d49 5452 4520  press the MITRE 
-00001dc0: 436f 7270 6f72 6174 696f 6e20 636f 7079  Corporation copy
-00001dd0: 7269 6768 7422 2c0a 2020 2020 2270 726f  right",.    "pro
-00001de0: 746f 636f 6c22 3a20 2261 7474 6163 6b22  tocol": "attack"
-00001df0: 2c0a 2020 2020 2269 636f 6e22 3a22 220a  ,.    "icon":"".
-00001e00: 2020 7d0a 5d                               }.]
+00000000: 5b0d 0a20 207b 0d0a 2020 2020 2274 7970  [..  {..    "typ
+00000010: 6522 3a20 2022 782d 6d69 7472 652d 6d61  e":  "x-mitre-ma
+00000020: 7472 6978 222c 0d0a 2020 2020 2274 7970  trix",..    "typ
+00000030: 6571 6c22 3a20 226d 6174 7269 7822 2c0d  eql": "matrix",.
+00000040: 0a20 2020 2022 636c 6173 7322 3a20 224d  .    "class": "M
+00000050: 6174 7269 7822 2c0d 0a20 2020 2022 6f62  atrix",..    "ob
+00000060: 6a65 6374 223a 2022 7364 6f22 2c0d 0a20  ject": "sdo",.. 
+00000070: 2020 2022 7572 6c22 3a20 2268 7474 7073     "url": "https
+00000080: 3a2f 2f67 6974 6875 622e 636f 6d2f 6d69  ://github.com/mi
+00000090: 7472 652d 6174 7461 636b 2f61 7474 6163  tre-attack/attac
+000000a0: 6b2d 7374 6978 2d64 6174 612f 626c 6f62  k-stix-data/blob
+000000b0: 2f6d 6173 7465 722f 5553 4147 452e 6d64  /master/USAGE.md
+000000c0: 236d 6174 7269 6365 7322 2c0d 0a20 2020  #matrices",..   
+000000d0: 2022 646f 635f 7572 6c22 3a20 2222 2c0d   "doc_url": "",.
+000000e0: 0a20 2020 2022 7375 6d6d 6172 7922 3a20  .    "summary": 
+000000f0: 2254 6865 206f 7665 7261 6c6c 206c 6179  "The overall lay
+00000100: 6f75 7420 6f66 2074 6865 2041 5454 2643  out of the ATT&C
+00000110: 4b20 4d61 7472 6963 6573 2069 7320 7374  K Matrices is st
+00000120: 6f72 6564 2069 6e20 782d 6d69 7472 652d  ored in x-mitre-
+00000130: 6d61 7472 6978 206f 626a 6563 7473 2e20  matrix objects. 
+00000140: 4173 2061 2063 7573 746f 6d20 5354 4958  As a custom STIX
+00000150: 2074 7970 6520 7468 6579 2066 6f6c 6c6f   type they follo
+00000160: 7720 6f6e 6c79 2074 6865 2067 656e 6572  w only the gener
+00000170: 6963 2053 5449 5820 446f 6d61 696e 204f  ic STIX Domain O
+00000180: 626a 6563 7420 7061 7474 6572 6e2e 222c  bject pattern.",
+00000190: 0d0a 2020 2020 2270 726f 746f 636f 6c22  ..    "protocol"
+000001a0: 3a20 2261 7474 6163 6b22 2c0d 0a20 2020  : "attack",..   
+000001b0: 2022 6963 6f6e 223a 2261 7474 6163 6b5f   "icon":"attack_
+000001c0: 6963 6f6e 5f6d 6174 7269 782e 706e 6722  icon_matrix.png"
+000001d0: 0d0a 2020 7d2c 0d0a 2020 7b0d 0a20 2020  ..  },..  {..   
+000001e0: 2022 7479 7065 223a 2020 2278 2d6d 6974   "type":  "x-mit
+000001f0: 7265 2d74 6163 7469 6322 2c0d 0a20 2020  re-tactic",..   
+00000200: 2022 7479 7065 716c 223a 2022 7461 6374   "typeql": "tact
+00000210: 6963 222c 0d0a 2020 2020 2263 6c61 7373  ic",..    "class
+00000220: 223a 2022 5461 6374 6963 222c 0d0a 2020  ": "Tactic",..  
+00000230: 2020 226f 626a 6563 7422 3a20 2273 646f    "object": "sdo
+00000240: 222c 0d0a 2020 2020 2275 726c 223a 2022  ",..    "url": "
+00000250: 6874 7470 733a 2f2f 6769 7468 7562 2e63  https://github.c
+00000260: 6f6d 2f6d 6974 7265 2d61 7474 6163 6b2f  om/mitre-attack/
+00000270: 6174 7461 636b 2d73 7469 782d 6461 7461  attack-stix-data
+00000280: 2f62 6c6f 622f 6d61 7374 6572 2f55 5341  /blob/master/USA
+00000290: 4745 2e6d 6423 7461 6374 6963 7322 2c0d  GE.md#tactics",.
+000002a0: 0a20 2020 2022 646f 635f 7572 6c22 3a20  .    "doc_url": 
+000002b0: 2222 2c0d 0a20 2020 2022 7375 6d6d 6172  "",..    "summar
+000002c0: 7922 3a20 2241 2054 6163 7469 6320 696e  y": "A Tactic in
+000002d0: 2041 5454 2643 4b20 6973 2064 6566 696e   ATT&CK is defin
+000002e0: 6564 2062 7920 616e 2078 2d6d 6974 7265  ed by an x-mitre
+000002f0: 2d74 6163 7469 6320 6f62 6a65 6374 2e20  -tactic object. 
+00000300: 4173 2061 2063 7573 746f 6d20 5354 4958  As a custom STIX
+00000310: 2074 7970 6520 7468 6579 2066 6f6c 6c6f   type they follo
+00000320: 7720 6f6e 6c79 2074 6865 2067 656e 6572  w only the gener
+00000330: 6963 2053 5449 5820 446f 6d61 696e 204f  ic STIX Domain O
+00000340: 626a 6563 7420 7061 7474 6572 6e2e 222c  bject pattern.",
+00000350: 0d0a 2020 2020 2270 726f 746f 636f 6c22  ..    "protocol"
+00000360: 3a20 2261 7474 6163 6b22 2c0d 0a20 2020  : "attack",..   
+00000370: 2022 6963 6f6e 223a 2261 7474 6163 6b5f   "icon":"attack_
+00000380: 6963 6f6e 5f74 6163 7469 632e 706e 6722  icon_tactic.png"
+00000390: 0d0a 2020 7d2c 0d0a 2020 7b0d 0a20 2020  ..  },..  {..   
+000003a0: 2022 7479 7065 223a 2020 2261 7474 6163   "type":  "attac
+000003b0: 6b2d 7061 7474 6572 6e22 2c0d 0a20 2020  k-pattern",..   
+000003c0: 2022 7479 7065 716c 223a 2022 7465 6368   "typeql": "tech
+000003d0: 6e69 7175 6522 2c0d 0a20 2020 2022 636c  nique",..    "cl
+000003e0: 6173 7322 3a20 2254 6563 686e 6971 7565  ass": "Technique
+000003f0: 222c 0d0a 2020 2020 226f 626a 6563 7422  ",..    "object"
+00000400: 3a20 2273 646f 222c 0d0a 2020 2020 2275  : "sdo",..    "u
+00000410: 726c 223a 2022 6874 7470 733a 2f2f 6769  rl": "https://gi
+00000420: 7468 7562 2e63 6f6d 2f6d 6974 7265 2d61  thub.com/mitre-a
+00000430: 7474 6163 6b2f 6174 7461 636b 2d73 7469  ttack/attack-sti
+00000440: 782d 6461 7461 2f62 6c6f 622f 6d61 7374  x-data/blob/mast
+00000450: 6572 2f55 5341 4745 2e6d 6423 7465 6368  er/USAGE.md#tech
+00000460: 6e69 7175 6573 222c 0d0a 2020 2020 2264  niques",..    "d
+00000470: 6f63 5f75 726c 223a 2022 222c 0d0a 2020  oc_url": "",..  
+00000480: 2020 2273 756d 6d61 7279 223a 2022 4120    "summary": "A 
+00000490: 5465 6368 6e69 7175 6520 696e 2041 5454  Technique in ATT
+000004a0: 2643 4b20 6973 2064 6566 696e 6564 2061  &CK is defined a
+000004b0: 7320 616e 2061 7474 6163 6b2d 7061 7474  s an attack-patt
+000004c0: 6572 6e20 6f62 6a65 6374 2e22 2c0d 0a20  ern object.",.. 
+000004d0: 2020 2022 7072 6f74 6f63 6f6c 223a 2022     "protocol": "
+000004e0: 6174 7461 636b 222c 0d0a 2020 2020 2269  attack",..    "i
+000004f0: 636f 6e22 3a22 6174 7461 636b 5f69 636f  con":"attack_ico
+00000500: 6e5f 7465 6368 6e69 7175 652e 706e 6722  n_technique.png"
+00000510: 0d0a 2020 7d2c 0d0a 2020 7b0d 0a20 2020  ..  },..  {..   
+00000520: 2022 7479 7065 223a 2020 2261 7474 6163   "type":  "attac
+00000530: 6b2d 7061 7474 6572 6e22 2c0d 0a20 2020  k-pattern",..   
+00000540: 2022 7479 7065 716c 223a 2022 7375 622d   "typeql": "sub-
+00000550: 7465 6368 6e69 7175 6522 2c0d 0a20 2020  technique",..   
+00000560: 2022 636c 6173 7322 3a20 2253 7562 5465   "class": "SubTe
+00000570: 6368 6e69 7175 6522 2c0d 0a20 2020 2022  chnique",..    "
+00000580: 6f62 6a65 6374 223a 2022 7364 6f22 2c0d  object": "sdo",.
+00000590: 0a20 2020 2022 7572 6c22 3a20 2268 7474  .    "url": "htt
+000005a0: 7073 3a2f 2f67 6974 6875 622e 636f 6d2f  ps://github.com/
+000005b0: 6d69 7472 652d 6174 7461 636b 2f61 7474  mitre-attack/att
+000005c0: 6163 6b2d 7374 6978 2d64 6174 612f 626c  ack-stix-data/bl
+000005d0: 6f62 2f6d 6173 7465 722f 5553 4147 452e  ob/master/USAGE.
+000005e0: 6d64 2373 7562 2d74 6563 686e 6971 7565  md#sub-technique
+000005f0: 7322 2c0d 0a20 2020 2022 646f 635f 7572  s",..    "doc_ur
+00000600: 6c22 3a20 2222 2c0d 0a20 2020 2022 7375  l": "",..    "su
+00000610: 6d6d 6172 7922 3a20 2241 2073 7562 2d74  mmary": "A sub-t
+00000620: 6563 686e 6971 7565 2069 6e20 4154 5426  echnique in ATT&
+00000630: 434b 2069 7320 7265 7072 6573 656e 7465  CK is represente
+00000640: 6420 6173 2061 6e20 6174 7461 636b 2d70  d as an attack-p
+00000650: 6174 7465 726e 2061 6e64 2066 6f6c 6c6f  attern and follo
+00000660: 7773 2074 6865 2073 616d 6520 666f 726d  ws the same form
+00000670: 6174 2061 7320 7465 6368 6e69 7175 6573  at as techniques
+00000680: 2e20 5468 6579 2064 6966 6665 7220 696e  . They differ in
+00000690: 2074 6861 7420 7468 6579 2068 6176 6520   that they have 
+000006a0: 6120 626f 6f6c 6561 6e20 6669 656c 6420  a boolean field 
+000006b0: 2878 5f6d 6974 7265 5f69 735f 7375 6274  (x_mitre_is_subt
+000006c0: 6563 686e 6971 7565 2920 6d61 726b 696e  echnique) markin
+000006d0: 6720 7468 656d 2061 7320 7375 622d 7465  g them as sub-te
+000006e0: 6368 6e69 7175 6573 2c20 616e 6420 6120  chniques, and a 
+000006f0: 7265 6c61 7469 6f6e 7368 6970 206f 6620  relationship of 
+00000700: 7468 6520 7479 7065 2073 7562 7465 6368  the type subtech
+00000710: 6e69 7175 652d 6f66 2077 6865 7265 2074  nique-of where t
+00000720: 6865 2073 6f75 7263 655f 7265 6620 6973  he source_ref is
+00000730: 2074 6865 2073 7562 2d74 6563 686e 6971   the sub-techniq
+00000740: 7565 2061 6e64 2074 6865 2074 6172 6765  ue and the targe
+00000750: 745f 7265 6620 6973 2074 6865 2070 6172  t_ref is the par
+00000760: 656e 7420 7465 6368 6e69 7175 652e 2041  ent technique. A
+00000770: 2073 7562 2d74 6563 686e 6971 7565 2063   sub-technique c
+00000780: 616e 206f 6e6c 7920 6861 7665 2031 2070  an only have 1 p
+00000790: 6172 656e 7420 7465 6368 6e69 7175 652c  arent technique,
+000007a0: 2062 7574 2074 6563 686e 6971 7565 7320   but techniques 
+000007b0: 6361 6e20 6861 7665 206d 756c 7469 706c  can have multipl
+000007c0: 6520 7375 622d 7465 6368 6e69 7175 6573  e sub-techniques
+000007d0: 2e22 2c0d 0a20 2020 2022 7072 6f74 6f63  .",..    "protoc
+000007e0: 6f6c 223a 2022 6174 7461 636b 222c 0d0a  ol": "attack",..
+000007f0: 2020 2020 2269 636f 6e22 3a22 6174 7461      "icon":"atta
+00000800: 636b 5f69 636f 6e5f 7375 6274 6563 686e  ck_icon_subtechn
+00000810: 6971 7565 2e70 6e67 220d 0a20 207d 2c0d  ique.png"..  },.
+00000820: 0a20 207b 0d0a 2020 2020 2274 7970 6522  .  {..    "type"
+00000830: 3a20 2022 7265 6c61 7469 6f6e 7368 6970  :  "relationship
+00000840: 222c 0d0a 2020 2020 2274 7970 6571 6c22  ",..    "typeql"
+00000850: 3a20 2261 7474 6163 6b2d 7265 6c61 7469  : "attack-relati
+00000860: 6f6e 222c 0d0a 2020 2020 2263 6c61 7373  on",..    "class
+00000870: 223a 2022 4174 7461 636b 5265 6c61 7469  ": "AttackRelati
+00000880: 6f6e 222c 0d0a 2020 2020 226f 626a 6563  on",..    "objec
+00000890: 7422 3a20 2273 726f 222c 0d0a 2020 2020  t": "sro",..    
+000008a0: 2275 726c 223a 2022 6874 7470 733a 2f2f  "url": "https://
+000008b0: 6769 7468 7562 2e63 6f6d 2f6d 6974 7265  github.com/mitre
+000008c0: 2d61 7474 6163 6b2f 6174 7461 636b 2d73  -attack/attack-s
+000008d0: 7469 782d 6461 7461 2f62 6c6f 622f 6d61  tix-data/blob/ma
+000008e0: 7374 6572 2f55 5341 4745 2e6d 6423 7265  ster/USAGE.md#re
+000008f0: 6c61 7469 6f6e 7368 6970 7322 2c0d 0a20  lationships",.. 
+00000900: 2020 2022 646f 635f 7572 6c22 3a20 2222     "doc_url": ""
+00000910: 2c0d 0a20 2020 2022 7375 6d6d 6172 7922  ,..    "summary"
+00000920: 3a20 2222 2c0d 0a20 2020 2022 7072 6f74  : "",..    "prot
+00000930: 6f63 6f6c 223a 2022 6174 7461 636b 222c  ocol": "attack",
+00000940: 0d0a 2020 2020 2269 636f 6e22 3a22 220d  ..    "icon":"".
+00000950: 0a20 207d 2c0d 0a20 207b 0d0a 2020 2020  .  },..  {..    
+00000960: 2274 7970 6522 3a20 2022 636f 7572 7365  "type":  "course
+00000970: 2d6f 662d 6163 7469 6f6e 222c 0d0a 2020  -of-action",..  
+00000980: 2020 2274 7970 6571 6c22 3a20 226d 6974    "typeql": "mit
+00000990: 6967 6174 696f 6e22 2c0d 0a20 2020 2022  igation",..    "
+000009a0: 636c 6173 7322 3a20 224d 6974 6967 6174  class": "Mitigat
+000009b0: 696f 6e22 2c0d 0a20 2020 2022 6f62 6a65  ion",..    "obje
+000009c0: 6374 223a 2022 7364 6f22 2c0d 0a20 2020  ct": "sdo",..   
+000009d0: 2022 7572 6c22 3a20 2268 7474 7073 3a2f   "url": "https:/
+000009e0: 2f67 6974 6875 622e 636f 6d2f 6d69 7472  /github.com/mitr
+000009f0: 652d 6174 7461 636b 2f61 7474 6163 6b2d  e-attack/attack-
+00000a00: 7374 6978 2d64 6174 612f 626c 6f62 2f6d  stix-data/blob/m
+00000a10: 6173 7465 722f 5553 4147 452e 6d64 236d  aster/USAGE.md#m
+00000a20: 6974 6967 6174 696f 6e73 222c 0d0a 2020  itigations",..  
+00000a30: 2020 2264 6f63 5f75 726c 223a 2022 222c    "doc_url": "",
+00000a40: 0d0a 2020 2020 2273 756d 6d61 7279 223a  ..    "summary":
+00000a50: 2022 4120 4d69 7469 6761 7469 6f6e 2069   "A Mitigation i
+00000a60: 6e20 4154 5426 434b 2069 7320 6465 6669  n ATT&CK is defi
+00000a70: 6e65 6420 6173 2061 2063 6f75 7273 652d  ned as a course-
+00000a80: 6f66 2d61 6374 696f 6e20 6f62 6a65 6374  of-action object
+00000a90: 2e20 4154 5426 434b 204d 6974 6967 6174  . ATT&CK Mitigat
+00000aa0: 696f 6e73 2064 6f20 6e6f 7420 6465 7061  ions do not depa
+00000ab0: 7274 2066 726f 6d20 7468 6520 5354 4958  rt from the STIX
+00000ac0: 2063 6f75 7273 652d 6f66 2d61 6374 696f   course-of-actio
+00000ad0: 6e20 7370 6563 2e22 2c0d 0a20 2020 2022  n spec.",..    "
+00000ae0: 7072 6f74 6f63 6f6c 223a 2022 6174 7461  protocol": "atta
+00000af0: 636b 222c 0d0a 2020 2020 2269 636f 6e22  ck",..    "icon"
+00000b00: 3a22 6174 7461 636b 5f69 636f 6e5f 6d69  :"attack_icon_mi
+00000b10: 7469 6761 7469 6f6e 2e70 6e67 220d 0a20  tigation.png".. 
+00000b20: 207d 2c0d 0a20 207b 0d0a 2020 2020 2274   },..  {..    "t
+00000b30: 7970 6522 3a20 2022 6d61 726b 696e 672d  ype":  "marking-
+00000b40: 6465 6669 6e69 7469 6f6e 222c 0d0a 2020  definition",..  
+00000b50: 2020 2274 7970 6571 6c22 3a20 2261 7474    "typeql": "att
+00000b60: 6163 6b2d 6d61 726b 696e 6722 2c0d 0a20  ack-marking",.. 
+00000b70: 2020 2022 636c 6173 7322 3a20 2241 7474     "class": "Att
+00000b80: 6163 6b4d 6172 6b69 6e67 222c 0d0a 2020  ackMarking",..  
+00000b90: 2020 226f 626a 6563 7422 3a20 226d 6574    "object": "met
+00000ba0: 6122 2c0d 0a20 2020 2022 7572 6c22 3a20  a",..    "url": 
+00000bb0: 2268 7474 7073 3a2f 2f67 6974 6875 622e  "https://github.
+00000bc0: 636f 6d2f 6d69 7472 652d 6174 7461 636b  com/mitre-attack
+00000bd0: 2f61 7474 6163 6b2d 7374 6978 2d64 6174  /attack-stix-dat
+00000be0: 612f 626c 6f62 2f6d 6173 7465 722f 5553  a/blob/master/US
+00000bf0: 4147 452e 6d64 2374 6865 2d61 7474 636b  AGE.md#the-attck
+00000c00: 2d73 7065 6322 2c0d 0a20 2020 2022 646f  -spec",..    "do
+00000c10: 635f 7572 6c22 3a20 2222 2c0d 0a20 2020  c_url": "",..   
+00000c20: 2022 7375 6d6d 6172 7922 3a20 2222 2c0d   "summary": "",.
+00000c30: 0a20 2020 2022 7072 6f74 6f63 6f6c 223a  .    "protocol":
+00000c40: 2022 6174 7461 636b 222c 0d0a 2020 2020   "attack",..    
+00000c50: 2269 636f 6e22 3a22 220d 0a20 207d 2c0d  "icon":""..  },.
+00000c60: 0a20 207b 0d0a 2020 2020 2274 7970 6522  .  {..    "type"
+00000c70: 3a20 2022 6964 656e 7469 7479 222c 0d0a  :  "identity",..
+00000c80: 2020 2020 2274 7970 6571 6c22 3a20 2261      "typeql": "a
+00000c90: 7474 6163 6b2d 6964 656e 7469 7479 222c  ttack-identity",
+00000ca0: 0d0a 2020 2020 2263 6c61 7373 223a 2022  ..    "class": "
+00000cb0: 4174 7461 636b 4964 656e 7469 7479 222c  AttackIdentity",
+00000cc0: 0d0a 2020 2020 226f 626a 6563 7422 3a20  ..    "object": 
+00000cd0: 2273 646f 222c 0d0a 2020 2020 2275 726c  "sdo",..    "url
+00000ce0: 223a 2022 6874 7470 733a 2f2f 6769 7468  ": "https://gith
+00000cf0: 7562 2e63 6f6d 2f6d 6974 7265 2d61 7474  ub.com/mitre-att
+00000d00: 6163 6b2f 6174 7461 636b 2d73 7469 782d  ack/attack-stix-
+00000d10: 6461 7461 2f62 6c6f 622f 6d61 7374 6572  data/blob/master
+00000d20: 2f55 5341 4745 2e6d 6423 7468 652d 6174  /USAGE.md#the-at
+00000d30: 7463 6b2d 7370 6563 222c 0d0a 2020 2020  tck-spec",..    
+00000d40: 2264 6f63 5f75 726c 223a 2022 222c 0d0a  "doc_url": "",..
+00000d50: 2020 2020 2273 756d 6d61 7279 223a 2022      "summary": "
+00000d60: 5265 6665 7265 6e63 6564 2062 7920 6372  Referenced by cr
+00000d70: 6561 7465 645f 6279 5f72 6566 2061 6e64  eated_by_ref and
+00000d80: 2078 5f6d 6974 7265 5f6d 6f64 6966 6965   x_mitre_modifie
+00000d90: 645f 6279 5f72 6566 2074 6f20 636f 6e76  d_by_ref to conv
+00000da0: 6579 2074 6865 2063 7265 6174 6f72 2061  ey the creator a
+00000db0: 6e64 206d 6f73 7420 7265 6365 6e74 206d  nd most recent m
+00000dc0: 6f64 6966 6965 7220 6f66 2065 6163 6820  odifier of each 
+00000dd0: 6f62 6a65 6374 222c 0d0a 2020 2020 2270  object",..    "p
+00000de0: 726f 746f 636f 6c22 3a20 2261 7474 6163  rotocol": "attac
+00000df0: 6b22 2c0d 0a20 2020 2022 6963 6f6e 223a  k",..    "icon":
+00000e00: 2222 0d0a 2020 7d2c 0d0a 2020 7b0d 0a20  ""..  },..  {.. 
+00000e10: 2020 2022 7479 7065 223a 2020 2269 6e74     "type":  "int
+00000e20: 7275 7369 6f6e 2d73 6574 222c 0d0a 2020  rusion-set",..  
+00000e30: 2020 2274 7970 6571 6c22 3a20 2261 7474    "typeql": "att
+00000e40: 6163 6b2d 6772 6f75 7022 2c0d 0a20 2020  ack-group",..   
+00000e50: 2022 636c 6173 7322 3a20 2247 726f 7570   "class": "Group
+00000e60: 222c 0d0a 2020 2020 226f 626a 6563 7422  ",..    "object"
+00000e70: 3a20 2273 646f 222c 0d0a 2020 2020 2275  : "sdo",..    "u
+00000e80: 726c 223a 2022 6874 7470 733a 2f2f 6769  rl": "https://gi
+00000e90: 7468 7562 2e63 6f6d 2f6d 6974 7265 2d61  thub.com/mitre-a
+00000ea0: 7474 6163 6b2f 6174 7461 636b 2d73 7469  ttack/attack-sti
+00000eb0: 782d 6461 7461 2f62 6c6f 622f 6d61 7374  x-data/blob/mast
+00000ec0: 6572 2f55 5341 4745 2e6d 6423 6772 6f75  er/USAGE.md#grou
+00000ed0: 7073 222c 0d0a 2020 2020 2264 6f63 5f75  ps",..    "doc_u
+00000ee0: 726c 223a 2022 222c 0d0a 2020 2020 2273  rl": "",..    "s
+00000ef0: 756d 6d61 7279 223a 2022 4120 4772 6f75  ummary": "A Grou
+00000f00: 7020 696e 2041 5454 2643 4b20 6973 2064  p in ATT&CK is d
+00000f10: 6566 696e 6564 2061 7320 616e 2069 6e74  efined as an int
+00000f20: 7275 7369 6f6e 2d73 6574 206f 626a 6563  rusion-set objec
+00000f30: 742e 2041 5454 2643 4b20 4772 6f75 7073  t. ATT&CK Groups
+00000f40: 2064 6f20 6e6f 7420 6465 7061 7274 2066   do not depart f
+00000f50: 726f 6d20 7468 6520 5354 4958 2069 6e74  rom the STIX int
+00000f60: 7275 7369 6f6e 2d73 6574 2073 7065 632e  rusion-set spec.
+00000f70: 222c 0d0a 2020 2020 2270 726f 746f 636f  ",..    "protoco
+00000f80: 6c22 3a20 2261 7474 6163 6b22 2c0d 0a20  l": "attack",.. 
+00000f90: 2020 2022 6963 6f6e 223a 2261 7474 6163     "icon":"attac
+00000fa0: 6b5f 6963 6f6e 5f67 726f 7570 2e70 6e67  k_icon_group.png
+00000fb0: 220d 0a20 207d 2c0d 0a20 207b 0d0a 2020  "..  },..  {..  
+00000fc0: 2020 2274 7970 6522 3a20 2022 6d61 6c77    "type":  "malw
+00000fd0: 6172 6522 2c0d 0a20 2020 2022 7479 7065  are",..    "type
+00000fe0: 716c 223a 2022 736f 6674 7761 7265 2d6d  ql": "software-m
+00000ff0: 616c 7761 7265 222c 0d0a 2020 2020 2263  alware",..    "c
+00001000: 6c61 7373 223a 2022 536f 6674 7761 7265  lass": "Software
+00001010: 4d61 6c77 6172 6522 2c0d 0a20 2020 2022  Malware",..    "
+00001020: 6f62 6a65 6374 223a 2022 7364 6f22 2c0d  object": "sdo",.
+00001030: 0a20 2020 2022 7572 6c22 3a20 2268 7474  .    "url": "htt
+00001040: 7073 3a2f 2f67 6974 6875 622e 636f 6d2f  ps://github.com/
+00001050: 6d69 7472 652d 6174 7461 636b 2f61 7474  mitre-attack/att
+00001060: 6163 6b2d 7374 6978 2d64 6174 612f 626c  ack-stix-data/bl
+00001070: 6f62 2f6d 6173 7465 722f 5553 4147 452e  ob/master/USAGE.
+00001080: 6d64 2373 6f66 7477 6172 6522 2c0d 0a20  md#software",.. 
+00001090: 2020 2022 646f 635f 7572 6c22 3a20 2222     "doc_url": ""
+000010a0: 2c0d 0a20 2020 2022 7375 6d6d 6172 7922  ,..    "summary"
+000010b0: 3a20 2253 6f66 7477 6172 6520 696e 2041  : "Software in A
+000010c0: 5454 2643 4b20 6973 2074 6865 2075 6e69  TT&CK is the uni
+000010d0: 6f6e 206f 6620 7477 6f20 6469 7374 696e  on of two distin
+000010e0: 6374 2053 5449 5820 7479 7065 733a 206d  ct STIX types: m
+000010f0: 616c 7761 7265 2061 6e64 2074 6f6f 6c2e  alware and tool.
+00001100: 222c 0d0a 2020 2020 2270 726f 746f 636f  ",..    "protoco
+00001110: 6c22 3a20 2261 7474 6163 6b22 2c0d 0a20  l": "attack",.. 
+00001120: 2020 2022 6963 6f6e 223a 2261 7474 6163     "icon":"attac
+00001130: 6b5f 6963 6f6e 5f73 6f66 7477 6172 652e  k_icon_software.
+00001140: 706e 6722 0d0a 2020 7d2c 0d0a 2020 7b0d  png"..  },..  {.
+00001150: 0a20 2020 2022 7479 7065 223a 2020 2274  .    "type":  "t
+00001160: 6f6f 6c22 2c0d 0a20 2020 2022 7479 7065  ool",..    "type
+00001170: 716c 223a 2022 736f 6674 7761 7265 2d74  ql": "software-t
+00001180: 6f6f 6c22 2c0d 0a20 2020 2022 636c 6173  ool",..    "clas
+00001190: 7322 3a20 2253 6f66 7477 6172 6554 6f6f  s": "SoftwareToo
+000011a0: 6c22 2c0d 0a20 2020 2022 6f62 6a65 6374  l",..    "object
+000011b0: 223a 2022 7364 6f22 2c0d 0a20 2020 2022  ": "sdo",..    "
+000011c0: 7572 6c22 3a20 2268 7474 7073 3a2f 2f67  url": "https://g
+000011d0: 6974 6875 622e 636f 6d2f 6d69 7472 652d  ithub.com/mitre-
+000011e0: 6174 7461 636b 2f61 7474 6163 6b2d 7374  attack/attack-st
+000011f0: 6978 2d64 6174 612f 626c 6f62 2f6d 6173  ix-data/blob/mas
+00001200: 7465 722f 5553 4147 452e 6d64 2373 6f66  ter/USAGE.md#sof
+00001210: 7477 6172 6522 2c0d 0a20 2020 2022 646f  tware",..    "do
+00001220: 635f 7572 6c22 3a20 2222 2c0d 0a20 2020  c_url": "",..   
+00001230: 2022 7375 6d6d 6172 7922 3a20 2253 6f66   "summary": "Sof
+00001240: 7477 6172 6520 696e 2041 5454 2643 4b20  tware in ATT&CK 
+00001250: 6973 2074 6865 2075 6e69 6f6e 206f 6620  is the union of 
+00001260: 7477 6f20 6469 7374 696e 6374 2053 5449  two distinct STI
+00001270: 5820 7479 7065 733a 206d 616c 7761 7265  X types: malware
+00001280: 2061 6e64 2074 6f6f 6c2e 222c 0d0a 2020   and tool.",..  
+00001290: 2020 2270 726f 746f 636f 6c22 3a20 2261    "protocol": "a
+000012a0: 7474 6163 6b22 2c0d 0a20 2020 2022 6963  ttack",..    "ic
+000012b0: 6f6e 223a 2261 7474 6163 6b5f 6963 6f6e  on":"attack_icon
+000012c0: 5f73 6f66 7477 6172 652e 706e 6722 0d0a  _software.png"..
+000012d0: 2020 7d2c 0d0a 2020 7b0d 0a20 2020 2022    },..  {..    "
+000012e0: 7479 7065 223a 2020 2278 2d6d 6974 7265  type":  "x-mitre
+000012f0: 2d63 6f6c 6c65 6374 696f 6e22 2c0d 0a20  -collection",.. 
+00001300: 2020 2022 7479 7065 716c 223a 2022 636f     "typeql": "co
+00001310: 6c6c 6563 7469 6f6e 222c 0d0a 2020 2020  llection",..    
+00001320: 2263 6c61 7373 223a 2022 436f 6c6c 6563  "class": "Collec
+00001330: 7469 6f6e 222c 0d0a 2020 2020 226f 626a  tion",..    "obj
+00001340: 6563 7422 3a20 2273 646f 222c 0d0a 2020  ect": "sdo",..  
+00001350: 2020 2275 726c 223a 2022 6874 7470 733a    "url": "https:
+00001360: 2f2f 6769 7468 7562 2e63 6f6d 2f63 656e  //github.com/cen
+00001370: 7465 722d 666f 722d 7468 7265 6174 2d69  ter-for-threat-i
+00001380: 6e66 6f72 6d65 642d 6465 6665 6e73 652f  nformed-defense/
+00001390: 6174 7461 636b 2d77 6f72 6b62 656e 6368  attack-workbench
+000013a0: 2d66 726f 6e74 656e 642f 626c 6f62 2f6d  -frontend/blob/m
+000013b0: 6173 7465 722f 646f 6373 2f63 6f6c 6c65  aster/docs/colle
+000013c0: 6374 696f 6e73 2e6d 6422 2c0d 0a20 2020  ctions.md",..   
+000013d0: 2022 646f 635f 7572 6c22 3a20 2222 2c0d   "doc_url": "",.
+000013e0: 0a20 2020 2022 7375 6d6d 6172 7922 3a20  .    "summary": 
+000013f0: 2241 2063 6f6c 6c65 6374 696f 6e20 6973  "A collection is
+00001400: 2061 2073 6574 206f 6620 7265 6c61 7465   a set of relate
+00001410: 6420 4154 5426 434b 206f 626a 6563 7473  d ATT&CK objects
+00001420: 3b20 636f 6c6c 6563 7469 6f6e 7320 6d61  ; collections ma
+00001430: 7920 6265 2075 7365 6420 746f 2072 6570  y be used to rep
+00001440: 7265 7365 6e74 2073 7065 6369 6669 6320  resent specific 
+00001450: 7265 6c65 6173 6573 206f 6620 6120 6461  releases of a da
+00001460: 7461 7365 7420 7375 6368 2061 7320 5c22  taset such as \"
+00001470: 456e 7465 7270 7269 7365 2041 5454 2643  Enterprise ATT&C
+00001480: 4b20 7637 2e32 5c22 2c20 6f72 2061 6e79  K v7.2\", or any
+00001490: 206f 7468 6572 2073 6574 206f 6620 6f62   other set of ob
+000014a0: 6a65 6374 7320 6f6e 6520 6d61 7920 7761  jects one may wa
+000014b0: 6e74 2074 6f20 7368 6172 6520 7769 7468  nt to share with
+000014c0: 2073 6f6d 656f 6e65 2065 6c73 652e 2043   someone else. C
+000014d0: 6f6c 6c65 6374 696f 6e73 2061 7265 206d  ollections are m
+000014e0: 6561 6e74 2074 6f20 6265 2073 6861 7265  eant to be share
+000014f0: 642e 2043 6f6c 6c65 6374 696f 6e73 2063  d. Collections c
+00001500: 616e 2062 6520 7368 6172 6564 2061 7320  an be shared as 
+00001510: 5354 4958 2062 756e 646c 6573 2c20 7570  STIX bundles, up
+00001520: 6c6f 6164 6564 2074 6f20 7468 6520 696e  loaded to the in
+00001530: 7465 726e 6574 2c20 6f72 2073 656e 7420  ternet, or sent 
+00001540: 7468 726f 7567 6820 656d 6169 6c2e 222c  through email.",
+00001550: 0d0a 2020 2020 2270 726f 746f 636f 6c22  ..    "protocol"
+00001560: 3a20 2261 7474 6163 6b22 2c0d 0a20 2020  : "attack",..   
+00001570: 2022 6963 6f6e 223a 2261 7474 6163 6b5f   "icon":"attack_
+00001580: 6963 6f6e 5f63 6f6c 6c65 6374 696f 6e2e  icon_collection.
+00001590: 706e 6722 0d0a 2020 7d2c 0d0a 2020 7b0d  png"..  },..  {.
+000015a0: 0a20 2020 2022 7479 7065 223a 2020 2278  .    "type":  "x
+000015b0: 2d6d 6974 7265 2d64 6174 612d 736f 7572  -mitre-data-sour
+000015c0: 6365 222c 0d0a 2020 2020 2274 7970 6571  ce",..    "typeq
+000015d0: 6c22 3a20 2264 6174 612d 736f 7572 6365  l": "data-source
+000015e0: 222c 0d0a 2020 2020 2263 6c61 7373 223a  ",..    "class":
+000015f0: 2022 4461 7461 536f 7572 6365 222c 0d0a   "DataSource",..
+00001600: 2020 2020 226f 626a 6563 7422 3a20 2273      "object": "s
+00001610: 646f 222c 0d0a 2020 2020 2275 726c 223a  do",..    "url":
+00001620: 2022 6874 7470 733a 2f2f 6769 7468 7562   "https://github
+00001630: 2e63 6f6d 2f6d 6974 7265 2d61 7474 6163  .com/mitre-attac
+00001640: 6b2f 6174 7461 636b 2d73 7469 782d 6461  k/attack-stix-da
+00001650: 7461 2f62 6c6f 622f 6d61 7374 6572 2f55  ta/blob/master/U
+00001660: 5341 4745 2e6d 6423 6461 7461 2d73 6f75  SAGE.md#data-sou
+00001670: 7263 6573 2d61 6e64 2d64 6174 612d 636f  rces-and-data-co
+00001680: 6d70 6f6e 656e 7473 222c 0d0a 2020 2020  mponents",..    
+00001690: 2264 6f63 5f75 726c 223a 2022 222c 0d0a  "doc_url": "",..
+000016a0: 2020 2020 2273 756d 6d61 7279 223a 2022      "summary": "
+000016b0: 4120 4461 7461 2053 6f75 7263 6520 696e  A Data Source in
+000016c0: 2041 5454 2643 4b20 6973 2064 6566 696e   ATT&CK is defin
+000016d0: 6564 2062 7920 616e 2078 2d6d 6974 7265  ed by an x-mitre
+000016e0: 2d64 6174 612d 736f 7572 6365 206f 626a  -data-source obj
+000016f0: 6563 742e 2041 7320 6120 6375 7374 6f6d  ect. As a custom
+00001700: 2053 5449 5820 7479 7065 2074 6865 7920   STIX type they 
+00001710: 666f 6c6c 6f77 206f 6e6c 7920 7468 6520  follow only the 
+00001720: 6765 6e65 7269 6320 5354 4958 2044 6f6d  generic STIX Dom
+00001730: 6169 6e20 4f62 6a65 6374 2070 6174 7465  ain Object patte
+00001740: 726e 2e22 2c0d 0a20 2020 2022 7072 6f74  rn.",..    "prot
+00001750: 6f63 6f6c 223a 2022 6174 7461 636b 222c  ocol": "attack",
+00001760: 0d0a 2020 2020 2269 636f 6e22 3a22 6174  ..    "icon":"at
+00001770: 7461 636b 5f69 636f 6e5f 6461 7461 5f73  tack_icon_data_s
+00001780: 6f75 7263 652e 706e 6722 0d0a 2020 7d2c  ource.png"..  },
+00001790: 0d0a 2020 7b0d 0a20 2020 2022 7479 7065  ..  {..    "type
+000017a0: 223a 2020 2278 2d6d 6974 7265 2d64 6174  ":  "x-mitre-dat
+000017b0: 612d 636f 6d70 6f6e 656e 7422 2c0d 0a20  a-component",.. 
+000017c0: 2020 2022 7479 7065 716c 223a 2022 6461     "typeql": "da
+000017d0: 7461 2d63 6f6d 706f 6e65 6e74 222c 0d0a  ta-component",..
+000017e0: 2020 2020 2263 6c61 7373 223a 2022 4461      "class": "Da
+000017f0: 7461 436f 6d70 6f6e 656e 7422 2c0d 0a20  taComponent",.. 
+00001800: 2020 2022 6f62 6a65 6374 223a 2022 7364     "object": "sd
+00001810: 6f22 2c0d 0a20 2020 2022 7572 6c22 3a20  o",..    "url": 
+00001820: 2268 7474 7073 3a2f 2f67 6974 6875 622e  "https://github.
+00001830: 636f 6d2f 6d69 7472 652d 6174 7461 636b  com/mitre-attack
+00001840: 2f61 7474 6163 6b2d 7374 6978 2d64 6174  /attack-stix-dat
+00001850: 612f 626c 6f62 2f6d 6173 7465 722f 5553  a/blob/master/US
+00001860: 4147 452e 6d64 2364 6174 612d 736f 7572  AGE.md#data-sour
+00001870: 6365 732d 616e 642d 6461 7461 2d63 6f6d  ces-and-data-com
+00001880: 706f 6e65 6e74 7322 2c0d 0a20 2020 2022  ponents",..    "
+00001890: 646f 635f 7572 6c22 3a20 2222 2c0d 0a20  doc_url": "",.. 
+000018a0: 2020 2022 7375 6d6d 6172 7922 3a20 2241     "summary": "A
+000018b0: 2044 6174 6120 436f 6d70 6f6e 656e 7420   Data Component 
+000018c0: 696e 2041 5454 2643 4b20 6973 2072 6570  in ATT&CK is rep
+000018d0: 7265 7365 6e74 6564 2061 7320 616e 2078  resented as an x
+000018e0: 2d6d 6974 7265 2d64 6174 612d 636f 6d70  -mitre-data-comp
+000018f0: 6f6e 656e 7420 6f62 6a65 6374 2e20 4173  onent object. As
+00001900: 2061 2063 7573 746f 6d20 5354 4958 2074   a custom STIX t
+00001910: 7970 6520 7468 6579 2066 6f6c 6c6f 7720  ype they follow 
+00001920: 6f6e 6c79 2074 6865 2067 656e 6572 6963  only the generic
+00001930: 2053 5449 5820 446f 6d61 696e 204f 626a   STIX Domain Obj
+00001940: 6563 7420 7061 7474 6572 6e2e 222c 0d0a  ect pattern.",..
+00001950: 2020 2020 2270 726f 746f 636f 6c22 3a20      "protocol": 
+00001960: 2261 7474 6163 6b22 2c0d 0a20 2020 2022  "attack",..    "
+00001970: 6963 6f6e 223a 2261 7474 6163 6b5f 6963  icon":"attack_ic
+00001980: 6f6e 5f64 6174 615f 636f 6d70 6f6e 656e  on_data_componen
+00001990: 742e 706e 6722 0d0a 2020 7d2c 0d0a 2020  t.png"..  },..  
+000019a0: 7b0d 0a20 2020 2022 7479 7065 223a 2020  {..    "type":  
+000019b0: 2263 616d 7061 6967 6e22 2c0d 0a20 2020  "campaign",..   
+000019c0: 2022 7479 7065 716c 223a 2022 6174 7461   "typeql": "atta
+000019d0: 636b 2d63 616d 7061 6967 6e22 2c0d 0a20  ck-campaign",.. 
+000019e0: 2020 2022 636c 6173 7322 3a20 2241 7474     "class": "Att
+000019f0: 6163 6b43 616d 7061 6967 6e22 2c0d 0a20  ackCampaign",.. 
+00001a00: 2020 2022 6f62 6a65 6374 223a 2022 7364     "object": "sd
+00001a10: 6f22 2c0d 0a20 2020 2022 7572 6c22 3a20  o",..    "url": 
+00001a20: 2268 7474 7073 3a2f 2f67 6974 6875 622e  "https://github.
+00001a30: 636f 6d2f 6d69 7472 652d 6174 7461 636b  com/mitre-attack
+00001a40: 2f61 7474 6163 6b2d 7374 6978 2d64 6174  /attack-stix-dat
+00001a50: 612f 626c 6f62 2f6d 6173 7465 722f 5553  a/blob/master/US
+00001a60: 4147 452e 6d64 2363 616d 7061 6967 6e73  AGE.md#campaigns
+00001a70: 222c 0d0a 2020 2020 2264 6f63 5f75 726c  ",..    "doc_url
+00001a80: 223a 2022 222c 0d0a 2020 2020 2273 756d  ": "",..    "sum
+00001a90: 6d61 7279 223a 2022 4120 4361 6d70 6169  mary": "A Campai
+00001aa0: 676e 2069 6e20 4154 5426 434b 2069 7320  gn in ATT&CK is 
+00001ab0: 6465 6669 6e65 6420 6173 2061 2063 616d  defined as a cam
+00001ac0: 7061 6967 6e20 6f62 6a65 6374 2e22 2c0d  paign object.",.
+00001ad0: 0a20 2020 2022 7072 6f74 6f63 6f6c 223a  .    "protocol":
+00001ae0: 2022 6174 7461 636b 222c 0d0a 2020 2020   "attack",..    
+00001af0: 2269 636f 6e22 3a22 6174 7461 636b 5f69  "icon":"attack_i
+00001b00: 636f 6e5f 6361 6d70 6169 676e 2e70 6e67  con_campaign.png
+00001b10: 220d 0a20 207d 2c0d 0a20 207b 0d0a 2020  "..  },..  {..  
+00001b20: 2020 2274 7970 6522 3a20 2022 6f62 6a65    "type":  "obje
+00001b30: 6374 2d76 6572 7369 6f6e 2d72 6566 222c  ct-version-ref",
+00001b40: 0d0a 2020 2020 2274 7970 6571 6c22 3a20  ..    "typeql": 
+00001b50: 226f 626a 6563 742d 7665 7273 696f 6e22  "object-version"
+00001b60: 2c0d 0a20 2020 2022 636c 6173 7322 3a20  ,..    "class": 
+00001b70: 224f 626a 6563 7456 6572 7369 6f6e 222c  "ObjectVersion",
+00001b80: 0d0a 2020 2020 226f 626a 6563 7422 3a20  ..    "object": 
+00001b90: 2273 7562 222c 0d0a 2020 2020 2275 726c  "sub",..    "url
+00001ba0: 223a 2022 6874 7470 733a 2f2f 6769 7468  ": "https://gith
+00001bb0: 7562 2e63 6f6d 2f63 656e 7465 722d 666f  ub.com/center-fo
+00001bc0: 722d 7468 7265 6174 2d69 6e66 6f72 6d65  r-threat-informe
+00001bd0: 642d 6465 6665 6e73 652f 6174 7461 636b  d-defense/attack
+00001be0: 2d77 6f72 6b62 656e 6368 2d66 726f 6e74  -workbench-front
+00001bf0: 656e 642f 626c 6f62 2f6d 6173 7465 722f  end/blob/master/
+00001c00: 646f 6373 2f63 6f6c 6c65 6374 696f 6e73  docs/collections
+00001c10: 2e6d 6422 2c0d 0a20 2020 2022 646f 635f  .md",..    "doc_
+00001c20: 7572 6c22 3a20 2222 2c0d 0a20 2020 2022  url": "",..    "
+00001c30: 7375 6d6d 6172 7922 3a20 224f 626a 6563  summary": "Objec
+00001c40: 7420 7665 7273 696f 6e20 7265 6665 7265  t version refere
+00001c50: 6e63 6573 2061 7265 2075 7365 6420 746f  nces are used to
+00001c60: 2072 6566 6572 2074 6f20 6120 7370 6563   refer to a spec
+00001c70: 6966 6963 2076 6572 7369 6f6e 206f 6620  ific version of 
+00001c80: 6120 5354 4958 206f 626a 6563 742e 2054  a STIX object. T
+00001c90: 6865 7920 646f 2074 6869 7320 6279 2063  hey do this by c
+00001ca0: 6f6d 6269 6e69 6e67 2061 2053 5449 5820  ombining a STIX 
+00001cb0: 4944 206f 6620 7468 6520 6f62 6a65 6374  ID of the object
+00001cc0: 2077 6974 6820 7468 6520 6d6f 6469 6669   with the modifi
+00001cd0: 6564 2074 696d 6573 7461 6d70 206f 6620  ed timestamp of 
+00001ce0: 7468 6520 6769 7665 6e20 7665 7273 696f  the given versio
+00001cf0: 6e2e 222c 0d0a 2020 2020 2270 726f 746f  n.",..    "proto
+00001d00: 636f 6c22 3a20 2261 7474 6163 6b22 2c0d  col": "attack",.
+00001d10: 0a20 2020 2022 6963 6f6e 223a 2222 0d0a  .    "icon":""..
+00001d20: 2020 7d2c 0d0a 2020 7b0d 0a20 2020 2022    },..  {..    "
+00001d30: 7479 7065 223a 2020 226d 6172 6b69 6e67  type":  "marking
+00001d40: 2d64 6566 696e 6974 696f 6e22 2c0d 0a20  -definition",.. 
+00001d50: 2020 2022 7479 7065 716c 223a 2022 6174     "typeql": "at
+00001d60: 7461 636b 2d6d 6172 6b69 6e67 222c 0d0a  tack-marking",..
+00001d70: 2020 2020 2263 6c61 7373 223a 2022 4174      "class": "At
+00001d80: 7461 636b 4d61 726b 696e 6722 2c0d 0a20  tackMarking",.. 
+00001d90: 2020 2022 6f62 6a65 6374 223a 2022 6d65     "object": "me
+00001da0: 7461 222c 0d0a 2020 2020 2275 726c 223a  ta",..    "url":
+00001db0: 2022 6874 7470 733a 2f2f 6769 7468 7562   "https://github
+00001dc0: 2e63 6f6d 2f6d 6974 7265 2d61 7474 6163  .com/mitre-attac
+00001dd0: 6b2f 6174 7461 636b 2d73 7469 782d 6461  k/attack-stix-da
+00001de0: 7461 2f62 6c6f 622f 6d61 7374 6572 2f55  ta/blob/master/U
+00001df0: 5341 4745 2e6d 6423 7468 652d 6174 7463  SAGE.md#the-attc
+00001e00: 6b2d 7370 6563 222c 0d0a 2020 2020 2264  k-spec",..    "d
+00001e10: 6f63 5f75 726c 223a 2022 222c 0d0a 2020  oc_url": "",..  
+00001e20: 2020 2273 756d 6d61 7279 223a 2022 5265    "summary": "Re
+00001e30: 6665 7265 6e63 6564 2069 6e20 7468 6520  ferenced in the 
+00001e40: 6f62 6a65 6374 5f6d 6172 6b69 6e67 5f72  object_marking_r
+00001e50: 6566 7320 6f66 2061 6c6c 206f 626a 6563  efs of all objec
+00001e60: 7473 2074 6f20 6578 7072 6573 7320 7468  ts to express th
+00001e70: 6520 4d49 5452 4520 436f 7270 6f72 6174  e MITRE Corporat
+00001e80: 696f 6e20 636f 7079 7269 6768 7422 2c0d  ion copyright",.
+00001e90: 0a20 2020 2022 7072 6f74 6f63 6f6c 223a  .    "protocol":
+00001ea0: 2022 6174 7461 636b 222c 0d0a 2020 2020   "attack",..    
+00001eb0: 2269 636f 6e22 3a22 220d 0a20 207d 0d0a  "icon":""..  }..
+00001ec0: 5d                                       ]
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/attack/schema/cti-attack-rules.tql` & `stixorm-0.1.9/stixorm/module/definitions/attack/schema/cti-attack-rules.tql`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,31 +1,31 @@
-# sketch of tql to create a union out of software and tool
-# needs fixing to work
-
-define
-  software sub stix-domain-object,
-    plays domain-object-union:object; // or truth/reference/main/?
-
-  malware-software sub malware,
-    plays domain-object-union:secondary; // or member/view/?
-  tool-software sub tool,
-    plays domain-object-union:secondary;
-
-rule transfer-union-attrs:
-when {
-  $x isa stix-domain-object;
-  $y isa stix-domain-object, has attribute $a;
-  (object: $x, secondary: $y) isa domain-object-union;
-} then {
-  $x has $a;
-}
-
-rule transfer-union-rels:
-when {
-when {
-  $x isa stix-domain-object;
-  $y isa stix-domain-object;
-  (object: $x, secondary: $y) isa domain-object-union;
-  ($role-y: $y, $role-z: $z) isa! $rel-type; $rel-type relates $role-y; $rel-type relates $role-z;
-} then {
-  ($role-y: $x, $role-z) isa $rel-type;
+# sketch of tql to create a union out of software and tool
+# needs fixing to work
+
+define
+  software sub stix-domain-object,
+    plays domain-object-union:object; // or truth/reference/main/?
+
+  malware-software sub malware,
+    plays domain-object-union:secondary; // or member/view/?
+  tool-software sub tool,
+    plays domain-object-union:secondary;
+
+rule transfer-union-attrs:
+when {
+  $x isa stix-domain-object;
+  $y isa stix-domain-object, has attribute $a;
+  (object: $x, secondary: $y) isa domain-object-union;
+} then {
+  $x has $a;
+}
+
+rule transfer-union-rels:
+when {
+when {
+  $x isa stix-domain-object;
+  $y isa stix-domain-object;
+  (object: $x, secondary: $y) isa domain-object-union;
+  ($role-y: $y, $role-z: $z) isa! $rel-type; $rel-type relates $role-y; $rel-type relates $role-z;
+} then {
+  ($role-y: $x, $role-z) isa $rel-type;
 }
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/attack/schema/cti-attack.tql` & `stixorm-0.1.9/stixorm/module/definitions/attack/schema/cti-attack.tql`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,358 +1,358 @@
-
-# Copyright (C) 2022 OS-Threat
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-define
-
-    # Matrices - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#matrices 
-    matrix sub stix-domain-object,
-        owns name,
-        owns description,
-        owns x-mitre-version,
-        owns x-mitre-contributors,
-        owns x-mitre-domains,
-        owns x-mitre-attack-spec-version,
-        owns x-mitre-deprecated,
-        owns tactic-refs,
-        plays revoked-by:revoked,
-        plays revoked-by:new-version,
-        plays x-mitre-modified-by-ref:modified,
-        plays obj-ref:content;
-
-    # Tactics - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#tactics
-    tactic sub stix-domain-object,
-        owns name,
-        owns description,
-        owns x-mitre-version,
-        owns x-mitre-contributors,
-        owns x-mitre-domains,
-        owns x-mitre-attack-spec-version,
-        owns x-mitre-shortname,
-        owns x-mitre-deprecated,
-        plays revoked-by:revoked,
-        plays revoked-by:new-version,
-        plays x-mitre-modified-by-ref:modified,
-        plays obj-ref:content;
-
-    # Techniques - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#techniques
-    technique sub attack-pattern,
-        owns x-mitre-version,
-        owns x-mitre-contributors,
-        owns x-mitre-domains,
-        owns x-mitre-attack-spec-version,
-        owns x-mitre-detection,
-        owns x-mitre-platforms,
-        owns x-mitre-data-sources,
-        owns x-mitre-is-subtechnique,
-        owns x-mitre-system-requirements,
-        owns x-mitre-tactic-type,
-        owns x-mitre-permissions-required,
-        owns x-mitre-network-requirements,
-        owns x-mitre-effective-permissions,
-        owns x-mitre-defense-bypassed,
-        owns x-mitre-remote-support,
-        owns x-mitre-impact-type,
-        owns x-mitre-deprecated,
-        plays subtechnique-of:parent,
-        owns x-mitre-network-requirements,
-        #plays subtechnique-of:child,
-        plays detects:ttp,
-        plays revoked-by:revoked,
-        plays revoked-by:new-version,
-        plays x-mitre-modified-by-ref:modified,
-        plays obj-ref:content;
-
-    # Sub Techniques - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#sub-techniques
-    sub-technique sub technique,
-        plays subtechnique-of:child;
-
-    # Mitigations - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#mitigations
-    mitigation sub course-of-action,
-        owns x-mitre-version,
-        owns x-mitre-contributors,
-        owns x-mitre-domains,
-        owns x-mitre-attack-spec-version,
-        owns x-mitre-deprecated,
-        plays revoked-by:revoked,
-        plays revoked-by:new-version,
-        plays x-mitre-modified-by-ref:modified,
-        plays obj-ref:content;
-
-    # Groups - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#groups
-    attack-group sub intrusion-set,
-        owns x-mitre-version,
-        owns x-mitre-contributors,
-        owns x-mitre-domains,
-        owns x-mitre-attack-spec-version,
-        owns x-mitre-deprecated,
-        plays revoked-by:revoked,
-        plays revoked-by:new-version,
-        plays x-mitre-modified-by-ref:modified,
-        plays obj-ref:content;
-
-    # Software- Malware and Tool - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#software
-    software-malware sub malware,
-        owns x-mitre-version,
-        owns x-mitre-contributors,
-        owns x-mitre-domains,
-        owns x-mitre-attack-spec-version,
-        owns x-mitre-platforms,
-        owns x-mitre-aliases,
-        owns x-mitre-deprecated,
-        plays revoked-by:revoked,
-        plays revoked-by:new-version,
-        plays x-mitre-modified-by-ref:modified,
-        plays obj-ref:content;
-
-    software-tool sub tool,
-        owns x-mitre-version,
-        owns x-mitre-contributors,
-        owns x-mitre-domains,
-        owns x-mitre-attack-spec-version,
-        owns x-mitre-platforms,
-        owns x-mitre-aliases,
-        owns x-mitre-deprecated,
-        plays revoked-by:revoked,
-        plays revoked-by:new-version,
-        plays x-mitre-modified-by-ref:modified,
-        plays obj-ref:content;
-
-    # Data Sources and Components - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#data-sources-and-data-components
-    data-source  sub stix-domain-object,
-        owns name,
-        owns description,
-        owns x-mitre-version,
-        owns x-mitre-contributors,
-        owns x-mitre-domains,
-        owns x-mitre-attack-spec-version,
-        owns x-mitre-platforms,
-        owns x-mitre-collection-layers,
-        owns x-mitre-deprecated,
-        plays revoked-by:revoked,
-        plays revoked-by:new-version,
-        plays x-mitre-data-source-ref:data-source,
-        plays x-mitre-modified-by-ref:modified,
-        plays obj-ref:content;
-
-    # Data Components - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#data-components
-    data-component  sub stix-domain-object,
-        owns name,
-        owns description,
-        owns x-mitre-version,
-        owns x-mitre-contributors,
-        owns x-mitre-domains,
-        owns x-mitre-attack-spec-version,
-        owns x-mitre-deprecated,
-        plays detects:sensor,
-        plays revoked-by:revoked,
-        plays revoked-by:new-version,
-        plays x-mitre-data-source-ref:component,
-        plays x-mitre-modified-by-ref:modified,
-        plays obj-ref:content;
-
-    # Campaigns - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#campaigns
-    attack-campaign sub campaign,
-        owns x-mitre-version,
-        owns x-mitre-contributors,
-        owns x-mitre-domains,
-        owns x-mitre-attack-spec-version,
-        owns x-mitre-first-seen-citation,
-        owns x-mitre-last-seen-citation,
-        owns x-mitre-deprecated,
-        plays revoked-by:revoked,
-        plays revoked-by:new-version,
-        plays x-mitre-modified-by-ref:modified,
-        plays obj-ref:content;
-
-    # Statement Markings - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#the-attck-spec
-    attack-marking sub statement-marking,
-        owns x-mitre-domains,
-        owns x-mitre-version,
-        owns x-mitre-attack-spec-version;
-
-    # Attack Identity - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#the-attck-spec
-    attack-identity sub identity,
-        owns x-mitre-domains,
-        owns x-mitre-attack-spec-version,
-        owns x-mitre-version,
-        plays obj-ref:content,
-        plays x-mitre-modified-by-ref:modifier;
-
-    # Relations
-    #===================
-    # Existing Stix Relations,now with ATT&CK properties -
-    # https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#relationships
-    uses
-        owns x-mitre-version,
-        owns x-mitre-contributors,
-        owns x-mitre-domains,
-        owns x-mitre-attack-spec-version,
-        owns x-mitre-deprecated,
-        owns x-mitre-platforms,
-        plays x-mitre-modified-by-ref:modified,
-        plays obj-ref:content;
-
-    attributed-to
-        owns x-mitre-version,
-        owns x-mitre-contributors,
-        owns x-mitre-domains,
-        owns x-mitre-attack-spec-version,
-        owns x-mitre-deprecated,
-        owns x-mitre-platforms,
-        plays x-mitre-modified-by-ref:modified,
-        plays obj-ref:content;
-
-   mitigates
-        owns x-mitre-version,
-        owns x-mitre-contributors,
-        owns x-mitre-domains,
-        owns x-mitre-attack-spec-version,
-        owns x-mitre-deprecated,
-        owns x-mitre-platforms,
-        plays x-mitre-modified-by-ref:modified,
-        plays obj-ref:content;
-
-    #=================================
-    # Custom ATT&CK Relations -https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#relationships
-	subtechnique-of sub stix-core-relationship,
-        owns x-mitre-version,
-        owns x-mitre-contributors,
-        owns x-mitre-domains,
-        owns x-mitre-attack-spec-version,
-        owns x-mitre-deprecated,
-        owns x-mitre-platforms,
-        plays obj-ref:content,
-		relates child as source,
-		relates parent as target,
-        plays x-mitre-modified-by-ref:modified,
-        plays obj-ref:content,
-        plays revoked-by:revoked,
-        plays revoked-by:new-version;
-
-	detects sub  stix-core-relationship,
-        owns x-mitre-version,
-        owns x-mitre-contributors,
-        owns x-mitre-domains,
-        owns x-mitre-attack-spec-version,
-        owns x-mitre-deprecated,
-        owns x-mitre-platforms,
-        plays obj-ref:content,
-		relates sensor as source,
-		relates ttp as target,
-        plays x-mitre-modified-by-ref:modified,
-        plays obj-ref:content,
-        plays revoked-by:revoked,
-        plays revoked-by:new-version;
-
-	revoked-by sub stix-core-relationship,
-        owns x-mitre-version,
-        owns x-mitre-contributors,
-        owns x-mitre-domains,
-        owns x-mitre-attack-spec-version,
-        owns x-mitre-deprecated,
-        owns x-mitre-platforms,
-        plays obj-ref:content,
-		relates revoked as source,
-		relates new-version as target,
-        plays x-mitre-modified-by-ref:modified,
-        plays obj-ref:content;
-
-    procedure sub  stix-core-relationship,
-        owns x-mitre-version,
-        owns x-mitre-contributors,
-        owns x-mitre-domains,
-        owns x-mitre-attack-spec-version,
-        owns x-mitre-deprecated,
-        owns x-mitre-platforms,
-        plays obj-ref:content,
-		relates user as source,
-		relates technique as target,
-        plays x-mitre-modified-by-ref:modified,
-        plays obj-ref:content;
-
-    # Built-in Embedded Relations for Mitre Attack objects
-	x-mitre-data-source-ref sub embedded,
-		relates data-source as pointed-to,
-		relates component as owner,
-        plays obj-ref:content;
-
-    # ATT&CK Collection Object
-    collection   sub stix-domain-object,
-        owns name,
-        owns description,
-        owns x-mitre-version,
-        owns x-mitre-contributors,
-        owns x-mitre-domains,
-        owns x-mitre-attack-spec-version,
-        owns x-mitre-deprecated,
-        plays x-mitre-modified-by-ref:modified,
-        plays x-mitre-content:collector;
-
-    # Collection External Reference
-    attack-sub-object sub stix-sub-object;
-    object-version sub attack-sub-object,
-        owns object-modified,
-        plays obj-ref:container,
-        plays x-mitre-content:collected;
-
-    # Collection embedded Relation
-    obj-ref sub embedded,
-		relates content as pointed-to,
-		relates container as owner;
-
-    x-mitre-content sub embedded,
-		relates collector as owner,
-		relates collected as pointed-to;
-
-	x-mitre-modified-by-ref sub created-by,
-	    relates modified as created,
-	    relates modifier as creator,
-        plays obj-ref:content;
-
-
-    # Attribute Definitions
-    mitre-attribute-string sub stix-attribute-string, abstract;
-        x-mitre-version sub mitre-attribute-string;
-        x-mitre-domains sub mitre-attribute-string;
-        x-mitre-contributors sub mitre-attribute-string;
-        x-mitre-attack-spec-version sub mitre-attribute-string;
-        tactic-refs sub mitre-attribute-string;
-        x-mitre-shortname sub mitre-attribute-string;
-        x-mitre-detection sub mitre-attribute-string;
-        x-mitre-platforms sub mitre-attribute-string;
-        x-mitre-data-sources sub mitre-attribute-string;
-        x-mitre-system-requirements sub mitre-attribute-string;
-        x-mitre-tactic-type sub mitre-attribute-string;
-        x-mitre-permissions-required sub mitre-attribute-string;
-        x-mitre-effective-permissions sub mitre-attribute-string;
-        x-mitre-defense-bypassed sub mitre-attribute-string;
-        x-mitre-impact-type sub mitre-attribute-string;
-        x-mitre-aliases sub mitre-attribute-string;
-        x-mitre-collection-layers sub mitre-attribute-string;
-        x-mitre-first-seen-citation sub mitre-attribute-string;
-        x-mitre-last-seen-citation sub mitre-attribute-string;
-
-    mitre-attribute-boolean sub stix-attribute-boolean, abstract;
-        x-mitre-is-subtechnique sub mitre-attribute-boolean;
-        x-mitre-deprecated sub mitre-attribute-boolean;
-        x-mitre-remote-support sub mitre-attribute-boolean;
-        x-mitre-network-requirements sub mitre-attribute-boolean;
-
-    mitre-attribute-timestamp sub stix-attribute-timestamp, abstract;
+
+# Copyright (C) 2022 OS-Threat
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+define
+
+    # Matrices - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#matrices 
+    matrix sub stix-domain-object,
+        owns name,
+        owns description,
+        owns x-mitre-version,
+        owns x-mitre-contributors,
+        owns x-mitre-domains,
+        owns x-mitre-attack-spec-version,
+        owns x-mitre-deprecated,
+        owns tactic-refs,
+        plays revoked-by:revoked,
+        plays revoked-by:new-version,
+        plays x-mitre-modified-by-ref:modified,
+        plays obj-ref:content;
+
+    # Tactics - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#tactics
+    tactic sub stix-domain-object,
+        owns name,
+        owns description,
+        owns x-mitre-version,
+        owns x-mitre-contributors,
+        owns x-mitre-domains,
+        owns x-mitre-attack-spec-version,
+        owns x-mitre-shortname,
+        owns x-mitre-deprecated,
+        plays revoked-by:revoked,
+        plays revoked-by:new-version,
+        plays x-mitre-modified-by-ref:modified,
+        plays obj-ref:content;
+
+    # Techniques - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#techniques
+    technique sub attack-pattern,
+        owns x-mitre-version,
+        owns x-mitre-contributors,
+        owns x-mitre-domains,
+        owns x-mitre-attack-spec-version,
+        owns x-mitre-detection,
+        owns x-mitre-platforms,
+        owns x-mitre-data-sources,
+        owns x-mitre-is-subtechnique,
+        owns x-mitre-system-requirements,
+        owns x-mitre-tactic-type,
+        owns x-mitre-permissions-required,
+        owns x-mitre-network-requirements,
+        owns x-mitre-effective-permissions,
+        owns x-mitre-defense-bypassed,
+        owns x-mitre-remote-support,
+        owns x-mitre-impact-type,
+        owns x-mitre-deprecated,
+        plays subtechnique-of:parent,
+        owns x-mitre-network-requirements,
+        #plays subtechnique-of:child,
+        plays detects:ttp,
+        plays revoked-by:revoked,
+        plays revoked-by:new-version,
+        plays x-mitre-modified-by-ref:modified,
+        plays obj-ref:content;
+
+    # Sub Techniques - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#sub-techniques
+    sub-technique sub technique,
+        plays subtechnique-of:child;
+
+    # Mitigations - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#mitigations
+    mitigation sub course-of-action,
+        owns x-mitre-version,
+        owns x-mitre-contributors,
+        owns x-mitre-domains,
+        owns x-mitre-attack-spec-version,
+        owns x-mitre-deprecated,
+        plays revoked-by:revoked,
+        plays revoked-by:new-version,
+        plays x-mitre-modified-by-ref:modified,
+        plays obj-ref:content;
+
+    # Groups - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#groups
+    attack-group sub intrusion-set,
+        owns x-mitre-version,
+        owns x-mitre-contributors,
+        owns x-mitre-domains,
+        owns x-mitre-attack-spec-version,
+        owns x-mitre-deprecated,
+        plays revoked-by:revoked,
+        plays revoked-by:new-version,
+        plays x-mitre-modified-by-ref:modified,
+        plays obj-ref:content;
+
+    # Software- Malware and Tool - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#software
+    software-malware sub malware,
+        owns x-mitre-version,
+        owns x-mitre-contributors,
+        owns x-mitre-domains,
+        owns x-mitre-attack-spec-version,
+        owns x-mitre-platforms,
+        owns x-mitre-aliases,
+        owns x-mitre-deprecated,
+        plays revoked-by:revoked,
+        plays revoked-by:new-version,
+        plays x-mitre-modified-by-ref:modified,
+        plays obj-ref:content;
+
+    software-tool sub tool,
+        owns x-mitre-version,
+        owns x-mitre-contributors,
+        owns x-mitre-domains,
+        owns x-mitre-attack-spec-version,
+        owns x-mitre-platforms,
+        owns x-mitre-aliases,
+        owns x-mitre-deprecated,
+        plays revoked-by:revoked,
+        plays revoked-by:new-version,
+        plays x-mitre-modified-by-ref:modified,
+        plays obj-ref:content;
+
+    # Data Sources and Components - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#data-sources-and-data-components
+    data-source  sub stix-domain-object,
+        owns name,
+        owns description,
+        owns x-mitre-version,
+        owns x-mitre-contributors,
+        owns x-mitre-domains,
+        owns x-mitre-attack-spec-version,
+        owns x-mitre-platforms,
+        owns x-mitre-collection-layers,
+        owns x-mitre-deprecated,
+        plays revoked-by:revoked,
+        plays revoked-by:new-version,
+        plays x-mitre-data-source-ref:data-source,
+        plays x-mitre-modified-by-ref:modified,
+        plays obj-ref:content;
+
+    # Data Components - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#data-components
+    data-component  sub stix-domain-object,
+        owns name,
+        owns description,
+        owns x-mitre-version,
+        owns x-mitre-contributors,
+        owns x-mitre-domains,
+        owns x-mitre-attack-spec-version,
+        owns x-mitre-deprecated,
+        plays detects:sensor,
+        plays revoked-by:revoked,
+        plays revoked-by:new-version,
+        plays x-mitre-data-source-ref:component,
+        plays x-mitre-modified-by-ref:modified,
+        plays obj-ref:content;
+
+    # Campaigns - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#campaigns
+    attack-campaign sub campaign,
+        owns x-mitre-version,
+        owns x-mitre-contributors,
+        owns x-mitre-domains,
+        owns x-mitre-attack-spec-version,
+        owns x-mitre-first-seen-citation,
+        owns x-mitre-last-seen-citation,
+        owns x-mitre-deprecated,
+        plays revoked-by:revoked,
+        plays revoked-by:new-version,
+        plays x-mitre-modified-by-ref:modified,
+        plays obj-ref:content;
+
+    # Statement Markings - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#the-attck-spec
+    attack-marking sub statement-marking,
+        owns x-mitre-domains,
+        owns x-mitre-version,
+        owns x-mitre-attack-spec-version;
+
+    # Attack Identity - https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#the-attck-spec
+    attack-identity sub identity,
+        owns x-mitre-domains,
+        owns x-mitre-attack-spec-version,
+        owns x-mitre-version,
+        plays obj-ref:content,
+        plays x-mitre-modified-by-ref:modifier;
+
+    # Relations
+    #===================
+    # Existing Stix Relations,now with ATT&CK properties -
+    # https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#relationships
+    uses
+        owns x-mitre-version,
+        owns x-mitre-contributors,
+        owns x-mitre-domains,
+        owns x-mitre-attack-spec-version,
+        owns x-mitre-deprecated,
+        owns x-mitre-platforms,
+        plays x-mitre-modified-by-ref:modified,
+        plays obj-ref:content;
+
+    attributed-to
+        owns x-mitre-version,
+        owns x-mitre-contributors,
+        owns x-mitre-domains,
+        owns x-mitre-attack-spec-version,
+        owns x-mitre-deprecated,
+        owns x-mitre-platforms,
+        plays x-mitre-modified-by-ref:modified,
+        plays obj-ref:content;
+
+   mitigates
+        owns x-mitre-version,
+        owns x-mitre-contributors,
+        owns x-mitre-domains,
+        owns x-mitre-attack-spec-version,
+        owns x-mitre-deprecated,
+        owns x-mitre-platforms,
+        plays x-mitre-modified-by-ref:modified,
+        plays obj-ref:content;
+
+    #=================================
+    # Custom ATT&CK Relations -https://github.com/mitre-attack/attack-stix-data/blob/master/USAGE.md#relationships
+	subtechnique-of sub stix-core-relationship,
+        owns x-mitre-version,
+        owns x-mitre-contributors,
+        owns x-mitre-domains,
+        owns x-mitre-attack-spec-version,
+        owns x-mitre-deprecated,
+        owns x-mitre-platforms,
+        plays obj-ref:content,
+		relates child as source,
+		relates parent as target,
+        plays x-mitre-modified-by-ref:modified,
+        plays obj-ref:content,
+        plays revoked-by:revoked,
+        plays revoked-by:new-version;
+
+	detects sub  stix-core-relationship,
+        owns x-mitre-version,
+        owns x-mitre-contributors,
+        owns x-mitre-domains,
+        owns x-mitre-attack-spec-version,
+        owns x-mitre-deprecated,
+        owns x-mitre-platforms,
+        plays obj-ref:content,
+		relates sensor as source,
+		relates ttp as target,
+        plays x-mitre-modified-by-ref:modified,
+        plays obj-ref:content,
+        plays revoked-by:revoked,
+        plays revoked-by:new-version;
+
+	revoked-by sub stix-core-relationship,
+        owns x-mitre-version,
+        owns x-mitre-contributors,
+        owns x-mitre-domains,
+        owns x-mitre-attack-spec-version,
+        owns x-mitre-deprecated,
+        owns x-mitre-platforms,
+        plays obj-ref:content,
+		relates revoked as source,
+		relates new-version as target,
+        plays x-mitre-modified-by-ref:modified,
+        plays obj-ref:content;
+
+    procedure sub  stix-core-relationship,
+        owns x-mitre-version,
+        owns x-mitre-contributors,
+        owns x-mitre-domains,
+        owns x-mitre-attack-spec-version,
+        owns x-mitre-deprecated,
+        owns x-mitre-platforms,
+        plays obj-ref:content,
+		relates user as source,
+		relates technique as target,
+        plays x-mitre-modified-by-ref:modified,
+        plays obj-ref:content;
+
+    # Built-in Embedded Relations for Mitre Attack objects
+	x-mitre-data-source-ref sub embedded,
+		relates data-source as pointed-to,
+		relates component as owner,
+        plays obj-ref:content;
+
+    # ATT&CK Collection Object
+    collection   sub stix-domain-object,
+        owns name,
+        owns description,
+        owns x-mitre-version,
+        owns x-mitre-contributors,
+        owns x-mitre-domains,
+        owns x-mitre-attack-spec-version,
+        owns x-mitre-deprecated,
+        plays x-mitre-modified-by-ref:modified,
+        plays x-mitre-content:collector;
+
+    # Collection External Reference
+    attack-sub-object sub stix-sub-object;
+    object-version sub attack-sub-object,
+        owns object-modified,
+        plays obj-ref:container,
+        plays x-mitre-content:collected;
+
+    # Collection embedded Relation
+    obj-ref sub embedded,
+		relates content as pointed-to,
+		relates container as owner;
+
+    x-mitre-content sub embedded,
+		relates collector as owner,
+		relates collected as pointed-to;
+
+	x-mitre-modified-by-ref sub created-by,
+	    relates modified as created,
+	    relates modifier as creator,
+        plays obj-ref:content;
+
+
+    # Attribute Definitions
+    mitre-attribute-string sub stix-attribute-string, abstract;
+        x-mitre-version sub mitre-attribute-string;
+        x-mitre-domains sub mitre-attribute-string;
+        x-mitre-contributors sub mitre-attribute-string;
+        x-mitre-attack-spec-version sub mitre-attribute-string;
+        tactic-refs sub mitre-attribute-string;
+        x-mitre-shortname sub mitre-attribute-string;
+        x-mitre-detection sub mitre-attribute-string;
+        x-mitre-platforms sub mitre-attribute-string;
+        x-mitre-data-sources sub mitre-attribute-string;
+        x-mitre-system-requirements sub mitre-attribute-string;
+        x-mitre-tactic-type sub mitre-attribute-string;
+        x-mitre-permissions-required sub mitre-attribute-string;
+        x-mitre-effective-permissions sub mitre-attribute-string;
+        x-mitre-defense-bypassed sub mitre-attribute-string;
+        x-mitre-impact-type sub mitre-attribute-string;
+        x-mitre-aliases sub mitre-attribute-string;
+        x-mitre-collection-layers sub mitre-attribute-string;
+        x-mitre-first-seen-citation sub mitre-attribute-string;
+        x-mitre-last-seen-citation sub mitre-attribute-string;
+
+    mitre-attribute-boolean sub stix-attribute-boolean, abstract;
+        x-mitre-is-subtechnique sub mitre-attribute-boolean;
+        x-mitre-deprecated sub mitre-attribute-boolean;
+        x-mitre-remote-support sub mitre-attribute-boolean;
+        x-mitre-network-requirements sub mitre-attribute-boolean;
+
+    mitre-attribute-timestamp sub stix-attribute-timestamp, abstract;
         object-modified sub mitre-attribute-timestamp;
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/cacao/__init__.py` & `stixorm-0.1.9/stixorm/module/definitions/cacao/__init__.py`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,33 +1,33 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-"""
-Loader module for all cacao data model
-"""
-
-__author__ = "Brett Forbes"
-__credits__ = ["Paolo Di Prodi"]
-__license__ = "GPL"
-__version__ = "0.1.0"
-__maintainer__ = "Paolo Di Prodi"
-__email__ = "paolo@priam.ai"
-__status__ = "Production"
-
-import json
-from glob import glob
-
-import pathlib
-from loguru import logger
-import os
-from pathlib import Path
-
-
-name = "cacao"
-class_model = {}
-class_model["sdo"] = {}
-class_model["sco"] = {}
-class_model["sro"] = {}
-class_model["sub"] = {}
-class_model["meta"] = {}
-
-
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+"""
+Loader module for all cacao data model
+"""
+
+__author__ = "Brett Forbes"
+__credits__ = ["Paolo Di Prodi"]
+__license__ = "GPL"
+__version__ = "0.1.0"
+__maintainer__ = "Paolo Di Prodi"
+__email__ = "paolo@priam.ai"
+__status__ = "Production"
+
+import json
+from glob import glob
+
+import pathlib
+from loguru import logger
+import os
+from pathlib import Path
+
+
+name = "cacao"
+class_model = {}
+class_model["sdo"] = {}
+class_model["sco"] = {}
+class_model["sro"] = {}
+class_model["sub"] = {}
+class_model["meta"] = {}
+
+
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/cacao/mappings/is_list_sub_objects.json` & `stixorm-0.1.9/stixorm/module/definitions/cacao/mappings/is_list_sub_objects.json`

 * *Files identical despite different names*

### Comparing `stixorm-0.1.3/stixorm/module/definitions/kestrel/mappings/is_list_sub_objects.json` & `stixorm-0.1.9/stixorm/module/definitions/kestrel/mappings/is_list_sub_objects.json`

 * *Files identical despite different names*

### Comparing `stixorm-0.1.3/stixorm/module/definitions/os_threat/classes.py` & `stixorm-0.1.9/stixorm/module/definitions/os_threat/classes.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,463 +1,463 @@
-"""Python Mitre ATT&CK Stix Class Definitions """
-from stixorm.module.typedb_lib.factories.mappings_factory import get_mapping_factory_instance
-
-"""Python Mitre ATT&CK Stix Class Definitions """
-import json
-import pathlib
-from collections import OrderedDict
-
-from stix2.exceptions import (
-    PropertyPresenceError, )
-from stix2.properties import (
-    BooleanProperty, ExtensionsProperty, IDProperty, IntegerProperty, ListProperty,
-    OpenVocabProperty, ReferenceProperty, StringProperty, FloatProperty,
-    TimestampProperty, TypeProperty, EmbeddedObjectProperty
-)
-from stix2.utils import NOW, _get_dict
-from stix2.markings import _MarkingsMixin
-from stix2.markings.utils import check_tlp_marking
-from stix2.v21.base import _DomainObject, _STIXBase21, _RelationshipObject, _Extension
-from stix2.v21.common import (
-    ExternalReference, GranularMarking, KillChainPhase,
-    MarkingProperty, TLPMarking, StatementMarking,
-)
-from stix2.v21.vocab import (
-    ATTACK_MOTIVATION, ATTACK_RESOURCE_LEVEL, IMPLEMENTATION_LANGUAGE, MALWARE_CAPABILITIES, MALWARE_TYPE,
-    PROCESSOR_ARCHITECTURE, TOOL_TYPE, IDENTITY_CLASS, INDUSTRY_SECTOR,
-)
-
-import logging
-
-from stixorm.module.definitions.property_definitions import ThreatReference, ThreatExtensionsProperty
-
-
-logger = logging.getLogger(__name__)
-
-valid_obj =  get_mapping_factory_instance().get_all_types()
-# i) allows x- prefix see properties.py line 592 obj_type.startswith("x-") and
-# ii) allows non stix definitiosn to be added see properties.py line 592 is_object(obj_type, self.spec_version)
-
-############################################################################################
-#
-# Feed Definitions
-#
-############################################################################################
-class ThreatSubObject(_STIXBase21):
-    """For more detailed information on this object's properties, see
-    `the OS-Threat documentation`__.
-    """
-    _properties = OrderedDict([
-        ('object_ref', ThreatReference(valid_types=valid_obj, spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-    ])
-
-
-class Feed(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the OS-Threat documentation`__.
-    """
-    _type = 'feed'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('name', StringProperty(required=True)),
-        ('description', StringProperty()),
-        ('paid', BooleanProperty()),
-        ('free', BooleanProperty()),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ExtensionsProperty(spec_version='2.1')),
-        ('contents', ListProperty(EmbeddedObjectProperty(type=ThreatSubObject))),
-    ])
-
-
-
-class Feeds(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the OS-Threat documentation`__.
-    """
-    _type = 'feeds'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('name', StringProperty(required=True)),
-        ('description', StringProperty()),
-        ('paid', BooleanProperty()),
-        ('free', BooleanProperty()),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ExtensionsProperty(spec_version='2.1')),
-        ('contained', ListProperty(ThreatReference(valid_types='feed', spec_version='2.1'))),
-    ])
-
-
-############################################################################################
-#
-# Incident Definitions
-#
-############################################################################################
-# Event Object
-##################################################################################
-class StateChangeObject(_STIXBase21):
-    """For more detailed information on this object's properties, see
-    `the https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
-    """
-    _properties = OrderedDict([
-        ('state_change_type', StringProperty()),
-        ('initial_ref', ThreatReference(valid_types=valid_obj, spec_version='2.1')),
-        ('result_ref', ThreatReference(valid_types=valid_obj, spec_version='2.1')),
-    ])
-
-
-class EventCoreExt(_Extension):
-    """For more detailed information on this object's properties, see
-    `the  https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
-    """
-
-    _type = 'extension-definition--4ca6de00-5b0d-45ef-a1dc-ea7279ea910e'
-    _properties = OrderedDict([
-        ('extension_type', StringProperty(fixed='new-sdo')),
-    ])
-
-
-class Event(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
-    """
-    _type = 'event'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('status', StringProperty()),
-        ('changed_objects', ListProperty(EmbeddedObjectProperty(type=StateChangeObject))),
-        ('description', StringProperty()),
-        ('detection_methods', ListProperty(StringProperty)),
-        ('detection_rule', StringProperty()),
-        ('detection_system', StringProperty()),
-        ('end_time', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('end_time_fidelity', StringProperty()),
-        ('event_seq', IntegerProperty()),
-        ('event_types', ListProperty(StringProperty)),
-        ('goal', StringProperty()),
-        ('name', StringProperty()),
-        ('sighting_refs', ListProperty(ThreatReference(valid_types=valid_obj, spec_version='2.1'))),
-        ('start_time', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('start_time_fidelity', StringProperty()),
-        ('subevents', ListProperty(ThreatReference(valid_types='event', spec_version='2.1'))),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ThreatExtensionsProperty(spec_version='2.1')),
-    ])
-###############################################################################
-# Imapct object
-#################################################################################
-
-
-class EntityCountObject(_STIXBase21):
-    """For more detailed information on this object's properties, see
-    `the https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
-    """
-    _properties = OrderedDict([
-        ('individual', IntegerProperty()),
-        ('group', IntegerProperty()),
-        ('system', IntegerProperty()),
-        ('organization', IntegerProperty()),
-        ('class', IntegerProperty()),
-        ('unknown', IntegerProperty()),
-    ])
-
-
-class ImpactCoreExt(_Extension):
-    """For more detailed information on this object's properties, see
-    `the  https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
-    """
-
-    _type = 'extension-definition--7cc33dd6-f6a1-489b-98ea-522d351d71b9'
-    _properties = OrderedDict([
-        ('extension_type', StringProperty(fixed='new-sdo')),
-    ])
-
-
-class Availability(_Extension):
-    """For more detailed information on this object's properties, see
-    `the  https://github.com/dod-cyber-crime-center/cti-stix-common-objects/blob/incident_rework/extension-definition-specifications/incident-core/Incident%20Extension%20Suite.adoc`__.
-    """
-
-    _type = 'availability'
-    _properties = OrderedDict([
-        ('availability_impact', IntegerProperty()),
-    ])
-
-
-class Confidentiality(_Extension):
-    """For more detailed information on this object's properties, see
-    `the  https://github.com/dod-cyber-crime-center/cti-stix-common-objects/blob/incident_rework/extension-definition-specifications/incident-core/Incident%20Extension%20Suite.adoc`__.
-    """
-
-    _type = 'confidentiality'
-    _properties = OrderedDict([
-        ('information_type', StringProperty()),
-        ('loss_type', StringProperty()),
-        ('record_count', IntegerProperty()),
-        ('record_size', IntegerProperty()),
-    ])
-
-class External(_Extension):
-    """For more detailed information on this object's properties, see
-    `the  https://github.com/dod-cyber-crime-center/cti-stix-common-objects/blob/incident_rework/extension-definition-specifications/incident-core/Incident%20Extension%20Suite.adoc`__.
-    """
-
-    _type = 'external'
-    _properties = OrderedDict([
-        ('impact_type', StringProperty()),
-    ])
-
-
-class Integrity(_Extension):
-    """For more detailed information on this object's properties, see
-    `the  https://github.com/dod-cyber-crime-center/cti-stix-common-objects/blob/incident_rework/extension-definition-specifications/incident-core/Incident%20Extension%20Suite.adoc`__.
-    """
-
-    _type = 'integrity'
-    _properties = OrderedDict([
-        ('alteration', StringProperty()),
-        ('information_type', StringProperty()),
-        ('record_count', IntegerProperty()),
-        ('record_size', IntegerProperty()),
-    ])
-
-
-class Monetary(_Extension):
-    """For more detailed information on this object's properties, see
-    `the  https://github.com/dod-cyber-crime-center/cti-stix-common-objects/blob/incident_rework/extension-definition-specifications/incident-core/Incident%20Extension%20Suite.adoc`__.
-    """
-
-    _type = 'monetary'
-    _properties = OrderedDict([
-        ('variety', StringProperty()),
-        ('conversion_rate', FloatProperty()),
-        ('conversion_time', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('currency', StringProperty()),
-        ('currency_actual', StringProperty()),
-        ('max_amount', FloatProperty()),
-        ('min_amount', FloatProperty()),
-    ])
-
-
-class Physical(_Extension):
-    """For more detailed information on this object's properties, see
-    `the  https://github.com/dod-cyber-crime-center/cti-stix-common-objects/blob/incident_rework/extension-definition-specifications/incident-core/Incident%20Extension%20Suite.adoc`__.
-    """
-
-    _type = 'physical'
-    _properties = OrderedDict([
-        ('impact_type', StringProperty()),
-        ('asset_type', StringProperty()),
-    ])
-
-
-
-class Traceability(_Extension):
-    """For more detailed information on this object's properties, see
-    `the  https://github.com/dod-cyber-crime-center/cti-stix-common-objects/blob/incident_rework/extension-definition-specifications/incident-core/Incident%20Extension%20Suite.adoc`__.
-    """
-
-    _type = 'traceability'
-    _properties = OrderedDict([
-        ('traceability_impact', StringProperty()),
-    ])
-
-
-class Impact(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
-    """
-    _type = 'impact'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('impact_category', StringProperty()),
-        ('criticality', IntegerProperty()),
-        ('description', StringProperty()),
-        ('end_time', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('end_time_fidelity', StringProperty()),
-        ('impacted_entity_counts', EmbeddedObjectProperty(type=EntityCountObject)),
-        ('impacted_refs', ListProperty(ThreatReference(valid_types=valid_obj, spec_version='2.1'))),
-        ('recoverability', StringProperty()),
-        ('start_time', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('start_time_fidelity', StringProperty()),
-        ('superseded_by_ref', ThreatReference(valid_types='impact', spec_version='2.1')),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ThreatExtensionsProperty(spec_version='2.1')),
-    ])
-
-
-###############################################################################
-# Incident Extension object
-#################################################################################
-
-class IncidentScoreObject(_STIXBase21):
-    """For more detailed information on this object's properties, see
-    `the https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
-    """
-    _properties = OrderedDict([
-        ('name', StringProperty()),
-        ('value', IntegerProperty()),
-        ('description', StringProperty()),
-    ])
-
-
-class IncidentCoreExt(_Extension):
-    """For more detailed information on this object's properties, see
-    `the https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
-    """
-
-    _type = 'extension-definition--ef765651-680c-498d-9894-99799f2fa126'
-    _properties = OrderedDict([
-        ('determination', StringProperty()),
-        ('extension_type', StringProperty(fixed='property-extension')),
-        ('investigation_status', StringProperty()),
-        ('criticality', IntegerProperty(min=0)),
-        ('blocked', BooleanProperty()),
-        ('malicious', BooleanProperty()),
-        ('impacted_entity_counts', EmbeddedObjectProperty(type=EntityCountObject)),
-        ('recoverability', ListProperty(StringProperty)),
-        ('scores', EmbeddedObjectProperty(type=IncidentScoreObject)),
-        ('incident_types', ListProperty(StringProperty)),
-        ('task_refs', ListProperty(ThreatReference(valid_types='task'))),
-        ('event_refs', ListProperty(ThreatReference(valid_types='event'))),
-        ('impact_refs', ListProperty(ThreatReference(valid_types='impact'))),
-        ('notes_refs', ListProperty(ThreatReference(valid_types='notes'))),
-        ('evidence_refs', ListProperty(ThreatReference(valid_types='evidence'))),
-    ])
-
-###############################################################################
-# Task object
-#################################################################################
-
-class TaskCoreExt(_Extension):
-    """For more detailed information on this object's properties, see
-    `the  https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
-    """
-
-    _type = 'extension-definition--2074a052-8be4-4932-849e-f5e7798e0030'
-    _properties = OrderedDict([
-        ('extension_type', StringProperty(fixed='new-sdo')),
-    ])
-
-
-class Task(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
-    """
-    _type = 'task'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('changed_objects', ListProperty(EmbeddedObjectProperty(type=StateChangeObject))),
-        ('task_type', StringProperty()),
-        ('step_type', StringProperty()),
-        ('outcome', StringProperty()),
-        ('description', StringProperty()),
-        ('end_time', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('end_time_fidelity', StringProperty()),
-        ('error', StringProperty()),
-        ('impacted_entity_counts', EmbeddedObjectProperty(type=EntityCountObject)),
-        ('name', StringProperty(required=True)),
-        ('priority', IntegerProperty(min=0)),
-        ('start_time', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('start_time_fidelity', StringProperty()),
-        ('owner', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('on_completion', ThreatReference(valid_types='task')),
-        ('on_failure', ThreatReference(valid_types='task')),
-        ('on_success', ThreatReference(valid_types='task')),
-        ('next_steps', ListProperty(ThreatReference(valid_types='task'))),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ExtensionsProperty(spec_version='2.1')),
-    ])
-
-
-###############################################################################
-# Evidence object
-#################################################################################
-
-class EvidenceCoreExt(_Extension):
-    """For more detailed information on this object's properties, see
-    `the  https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
-    """
-
-    _type = 'extension-definition--7ff5b5a5-a342-417e-9c0d-339561d9d78a'
-    _properties = OrderedDict([
-        ('extension_type', StringProperty(fixed='new-sdo')),
-    ])
-
-
-class Evidence(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
-    """
-    _type = 'evidence'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('name', StringProperty(required=True)),
-        ('description', StringProperty()),
-        ('evidence_type', StringProperty()),
-        ('source', StringProperty()),
-        ('object_refs', ListProperty(ThreatReference(valid_types=valid_obj, spec_version='2.1'))),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ExtensionsProperty(spec_version='2.1')),
-    ])
-
+"""Python Mitre ATT&CK Stix Class Definitions """
+from stixorm.module.typedb_lib.factories.mappings_factory import get_mapping_factory_instance
+
+"""Python Mitre ATT&CK Stix Class Definitions """
+import json
+import pathlib
+from collections import OrderedDict
+
+from stix2.exceptions import (
+    PropertyPresenceError, )
+from stix2.properties import (
+    BooleanProperty, ExtensionsProperty, IDProperty, IntegerProperty, ListProperty,
+    OpenVocabProperty, ReferenceProperty, StringProperty, FloatProperty,
+    TimestampProperty, TypeProperty, EmbeddedObjectProperty
+)
+from stix2.utils import NOW, _get_dict
+from stix2.markings import _MarkingsMixin
+from stix2.markings.utils import check_tlp_marking
+from stix2.v21.base import _DomainObject, _STIXBase21, _RelationshipObject, _Extension
+from stix2.v21.common import (
+    ExternalReference, GranularMarking, KillChainPhase,
+    MarkingProperty, TLPMarking, StatementMarking,
+)
+from stix2.v21.vocab import (
+    ATTACK_MOTIVATION, ATTACK_RESOURCE_LEVEL, IMPLEMENTATION_LANGUAGE, MALWARE_CAPABILITIES, MALWARE_TYPE,
+    PROCESSOR_ARCHITECTURE, TOOL_TYPE, IDENTITY_CLASS, INDUSTRY_SECTOR,
+)
+
+import logging
+
+from stixorm.module.definitions.property_definitions import ThreatReference, ThreatExtensionsProperty
+
+
+logger = logging.getLogger(__name__)
+
+valid_obj =  get_mapping_factory_instance().get_all_types()
+# i) allows x- prefix see properties.py line 592 obj_type.startswith("x-") and
+# ii) allows non stix definitiosn to be added see properties.py line 592 is_object(obj_type, self.spec_version)
+
+############################################################################################
+#
+# Feed Definitions
+#
+############################################################################################
+class ThreatSubObject(_STIXBase21):
+    """For more detailed information on this object's properties, see
+    `the OS-Threat documentation`__.
+    """
+    _properties = OrderedDict([
+        ('object_ref', ThreatReference(valid_types=valid_obj, spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+    ])
+
+
+class Feed(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the OS-Threat documentation`__.
+    """
+    _type = 'feed'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('name', StringProperty(required=True)),
+        ('description', StringProperty()),
+        ('paid', BooleanProperty()),
+        ('free', BooleanProperty()),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ExtensionsProperty(spec_version='2.1')),
+        ('contents', ListProperty(EmbeddedObjectProperty(type=ThreatSubObject))),
+    ])
+
+
+
+class Feeds(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the OS-Threat documentation`__.
+    """
+    _type = 'feeds'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('name', StringProperty(required=True)),
+        ('description', StringProperty()),
+        ('paid', BooleanProperty()),
+        ('free', BooleanProperty()),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ExtensionsProperty(spec_version='2.1')),
+        ('contained', ListProperty(ThreatReference(valid_types='feed', spec_version='2.1'))),
+    ])
+
+
+############################################################################################
+#
+# Incident Definitions
+#
+############################################################################################
+# Event Object
+##################################################################################
+class StateChangeObject(_STIXBase21):
+    """For more detailed information on this object's properties, see
+    `the https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
+    """
+    _properties = OrderedDict([
+        ('state_change_type', StringProperty()),
+        ('initial_ref', ThreatReference(valid_types=valid_obj, spec_version='2.1')),
+        ('result_ref', ThreatReference(valid_types=valid_obj, spec_version='2.1')),
+    ])
+
+
+class EventCoreExt(_Extension):
+    """For more detailed information on this object's properties, see
+    `the  https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
+    """
+
+    _type = 'extension-definition--4ca6de00-5b0d-45ef-a1dc-ea7279ea910e'
+    _properties = OrderedDict([
+        ('extension_type', StringProperty(fixed='new-sdo')),
+    ])
+
+
+class Event(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
+    """
+    _type = 'event'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('status', StringProperty()),
+        ('changed_objects', ListProperty(EmbeddedObjectProperty(type=StateChangeObject))),
+        ('description', StringProperty()),
+        ('detection_methods', ListProperty(StringProperty)),
+        ('detection_rule', StringProperty()),
+        ('detection_system', StringProperty()),
+        ('end_time', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('end_time_fidelity', StringProperty()),
+        ('event_seq', IntegerProperty()),
+        ('event_types', ListProperty(StringProperty)),
+        ('goal', StringProperty()),
+        ('name', StringProperty()),
+        ('sighting_refs', ListProperty(ThreatReference(valid_types=valid_obj, spec_version='2.1'))),
+        ('start_time', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('start_time_fidelity', StringProperty()),
+        ('subevents', ListProperty(ThreatReference(valid_types='event', spec_version='2.1'))),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ThreatExtensionsProperty(spec_version='2.1')),
+    ])
+###############################################################################
+# Imapct object
+#################################################################################
+
+
+class EntityCountObject(_STIXBase21):
+    """For more detailed information on this object's properties, see
+    `the https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
+    """
+    _properties = OrderedDict([
+        ('individual', IntegerProperty()),
+        ('group', IntegerProperty()),
+        ('system', IntegerProperty()),
+        ('organization', IntegerProperty()),
+        ('class', IntegerProperty()),
+        ('unknown', IntegerProperty()),
+    ])
+
+
+class ImpactCoreExt(_Extension):
+    """For more detailed information on this object's properties, see
+    `the  https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
+    """
+
+    _type = 'extension-definition--7cc33dd6-f6a1-489b-98ea-522d351d71b9'
+    _properties = OrderedDict([
+        ('extension_type', StringProperty(fixed='new-sdo')),
+    ])
+
+
+class Availability(_Extension):
+    """For more detailed information on this object's properties, see
+    `the  https://github.com/dod-cyber-crime-center/cti-stix-common-objects/blob/incident_rework/extension-definition-specifications/incident-core/Incident%20Extension%20Suite.adoc`__.
+    """
+
+    _type = 'availability'
+    _properties = OrderedDict([
+        ('availability_impact', IntegerProperty()),
+    ])
+
+
+class Confidentiality(_Extension):
+    """For more detailed information on this object's properties, see
+    `the  https://github.com/dod-cyber-crime-center/cti-stix-common-objects/blob/incident_rework/extension-definition-specifications/incident-core/Incident%20Extension%20Suite.adoc`__.
+    """
+
+    _type = 'confidentiality'
+    _properties = OrderedDict([
+        ('information_type', StringProperty()),
+        ('loss_type', StringProperty()),
+        ('record_count', IntegerProperty()),
+        ('record_size', IntegerProperty()),
+    ])
+
+class External(_Extension):
+    """For more detailed information on this object's properties, see
+    `the  https://github.com/dod-cyber-crime-center/cti-stix-common-objects/blob/incident_rework/extension-definition-specifications/incident-core/Incident%20Extension%20Suite.adoc`__.
+    """
+
+    _type = 'external'
+    _properties = OrderedDict([
+        ('impact_type', StringProperty()),
+    ])
+
+
+class Integrity(_Extension):
+    """For more detailed information on this object's properties, see
+    `the  https://github.com/dod-cyber-crime-center/cti-stix-common-objects/blob/incident_rework/extension-definition-specifications/incident-core/Incident%20Extension%20Suite.adoc`__.
+    """
+
+    _type = 'integrity'
+    _properties = OrderedDict([
+        ('alteration', StringProperty()),
+        ('information_type', StringProperty()),
+        ('record_count', IntegerProperty()),
+        ('record_size', IntegerProperty()),
+    ])
+
+
+class Monetary(_Extension):
+    """For more detailed information on this object's properties, see
+    `the  https://github.com/dod-cyber-crime-center/cti-stix-common-objects/blob/incident_rework/extension-definition-specifications/incident-core/Incident%20Extension%20Suite.adoc`__.
+    """
+
+    _type = 'monetary'
+    _properties = OrderedDict([
+        ('variety', StringProperty()),
+        ('conversion_rate', FloatProperty()),
+        ('conversion_time', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('currency', StringProperty()),
+        ('currency_actual', StringProperty()),
+        ('max_amount', FloatProperty()),
+        ('min_amount', FloatProperty()),
+    ])
+
+
+class Physical(_Extension):
+    """For more detailed information on this object's properties, see
+    `the  https://github.com/dod-cyber-crime-center/cti-stix-common-objects/blob/incident_rework/extension-definition-specifications/incident-core/Incident%20Extension%20Suite.adoc`__.
+    """
+
+    _type = 'physical'
+    _properties = OrderedDict([
+        ('impact_type', StringProperty()),
+        ('asset_type', StringProperty()),
+    ])
+
+
+
+class Traceability(_Extension):
+    """For more detailed information on this object's properties, see
+    `the  https://github.com/dod-cyber-crime-center/cti-stix-common-objects/blob/incident_rework/extension-definition-specifications/incident-core/Incident%20Extension%20Suite.adoc`__.
+    """
+
+    _type = 'traceability'
+    _properties = OrderedDict([
+        ('traceability_impact', StringProperty()),
+    ])
+
+
+class Impact(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
+    """
+    _type = 'impact'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('impact_category', StringProperty()),
+        ('criticality', IntegerProperty()),
+        ('description', StringProperty()),
+        ('end_time', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('end_time_fidelity', StringProperty()),
+        ('impacted_entity_counts', EmbeddedObjectProperty(type=EntityCountObject)),
+        ('impacted_refs', ListProperty(ThreatReference(valid_types=valid_obj, spec_version='2.1'))),
+        ('recoverability', StringProperty()),
+        ('start_time', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('start_time_fidelity', StringProperty()),
+        ('superseded_by_ref', ThreatReference(valid_types='impact', spec_version='2.1')),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ThreatExtensionsProperty(spec_version='2.1')),
+    ])
+
+
+###############################################################################
+# Incident Extension object
+#################################################################################
+
+class IncidentScoreObject(_STIXBase21):
+    """For more detailed information on this object's properties, see
+    `the https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
+    """
+    _properties = OrderedDict([
+        ('name', StringProperty()),
+        ('value', IntegerProperty()),
+        ('description', StringProperty()),
+    ])
+
+
+class IncidentCoreExt(_Extension):
+    """For more detailed information on this object's properties, see
+    `the https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
+    """
+
+    _type = 'extension-definition--ef765651-680c-498d-9894-99799f2fa126'
+    _properties = OrderedDict([
+        ('determination', StringProperty()),
+        ('extension_type', StringProperty(fixed='property-extension')),
+        ('investigation_status', StringProperty()),
+        ('criticality', IntegerProperty(min=0)),
+        ('blocked', BooleanProperty()),
+        ('malicious', BooleanProperty()),
+        ('impacted_entity_counts', EmbeddedObjectProperty(type=EntityCountObject)),
+        ('recoverability', ListProperty(StringProperty)),
+        ('scores', EmbeddedObjectProperty(type=IncidentScoreObject)),
+        ('incident_types', ListProperty(StringProperty)),
+        ('task_refs', ListProperty(ThreatReference(valid_types='task'))),
+        ('event_refs', ListProperty(ThreatReference(valid_types='event'))),
+        ('impact_refs', ListProperty(ThreatReference(valid_types='impact'))),
+        ('notes_refs', ListProperty(ThreatReference(valid_types='notes'))),
+        ('evidence_refs', ListProperty(ThreatReference(valid_types='evidence'))),
+    ])
+
+###############################################################################
+# Task object
+#################################################################################
+
+class TaskCoreExt(_Extension):
+    """For more detailed information on this object's properties, see
+    `the  https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
+    """
+
+    _type = 'extension-definition--2074a052-8be4-4932-849e-f5e7798e0030'
+    _properties = OrderedDict([
+        ('extension_type', StringProperty(fixed='new-sdo')),
+    ])
+
+
+class Task(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
+    """
+    _type = 'task'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('changed_objects', ListProperty(EmbeddedObjectProperty(type=StateChangeObject))),
+        ('task_type', StringProperty()),
+        ('step_type', StringProperty()),
+        ('outcome', StringProperty()),
+        ('description', StringProperty()),
+        ('end_time', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('end_time_fidelity', StringProperty()),
+        ('error', StringProperty()),
+        ('impacted_entity_counts', EmbeddedObjectProperty(type=EntityCountObject)),
+        ('name', StringProperty(required=True)),
+        ('priority', IntegerProperty(min=0)),
+        ('start_time', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('start_time_fidelity', StringProperty()),
+        ('owner', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('on_completion', ThreatReference(valid_types='task')),
+        ('on_failure', ThreatReference(valid_types='task')),
+        ('on_success', ThreatReference(valid_types='task')),
+        ('next_steps', ListProperty(ThreatReference(valid_types='task'))),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ExtensionsProperty(spec_version='2.1')),
+    ])
+
+
+###############################################################################
+# Evidence object
+#################################################################################
+
+class EvidenceCoreExt(_Extension):
+    """For more detailed information on this object's properties, see
+    `the  https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
+    """
+
+    _type = 'extension-definition--7ff5b5a5-a342-417e-9c0d-339561d9d78a'
+    _properties = OrderedDict([
+        ('extension_type', StringProperty(fixed='new-sdo')),
+    ])
+
+
+class Evidence(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the https://github.com/os-threat/stix-extensions/wiki/2.-Description-of-Incident-Model`__.
+    """
+    _type = 'evidence'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('name', StringProperty(required=True)),
+        ('description', StringProperty()),
+        ('evidence_type', StringProperty()),
+        ('source', StringProperty()),
+        ('object_refs', ListProperty(ThreatReference(valid_types=valid_obj, spec_version='2.1'))),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ExtensionsProperty(spec_version='2.1')),
+    ])
+
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/os_threat/mappings/relations_extensions_and_objects.json` & `stixorm-0.1.9/stixorm/module/definitions/os_threat/mappings/relations_extensions_and_objects.json`

 * *Format-specific differences are supported for JSON files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: JSON text data*

 * *Files 22% similar despite different names*

```diff
@@ -1,156 +1,162 @@
-00000000: 5b0a 2020 7b0a 2020 2020 2273 7469 7822  [.  {.    "stix"
-00000010: 3a20 2269 6d70 6163 7465 645f 656e 7469  : "impacted_enti
-00000020: 7479 5f63 6f75 6e74 7322 2c0a 2020 2020  ty_counts",.    
-00000030: 226f 626a 6563 7422 3a20 2265 6e74 6974  "object": "entit
-00000040: 792d 636f 756e 7465 7222 2c0a 2020 2020  y-counter",.    
-00000050: 2272 656c 6174 696f 6e22 3a20 2269 6d70  "relation": "imp
-00000060: 6163 742d 636f 756e 7465 7222 2c0a 2020  act-counter",.  
-00000070: 2020 226f 776e 6572 223a 2022 696d 7061    "owner": "impa
-00000080: 6374 2d64 7269 7665 7222 2c0a 2020 2020  ct-driver",.    
-00000090: 2270 6f69 6e74 6564 2d74 6f22 3a20 2263  "pointed-to": "c
-000000a0: 6f75 6e74 6572 7322 0a20 207d 2c0a 2020  ounters".  },.  
-000000b0: 7b0a 2020 2020 2273 7469 7822 3a20 2265  {.    "stix": "e
-000000c0: 7874 656e 7369 6f6e 2d64 6566 696e 6974  xtension-definit
-000000d0: 696f 6e2d 2d34 6361 3664 6530 302d 3562  ion--4ca6de00-5b
-000000e0: 3064 2d34 3565 662d 6131 6463 2d65 6137  0d-45ef-a1dc-ea7
-000000f0: 3237 3965 6139 3130 6522 2c0a 2020 2020  279ea910e",.    
-00000100: 226f 626a 6563 7422 3a20 2265 7665 6e74  "object": "event
-00000110: 2d65 7874 656e 7369 6f6e 222c 0a20 2020  -extension",.   
-00000120: 2022 7265 6c61 7469 6f6e 223a 2022 6576   "relation": "ev
-00000130: 656e 742d 6578 7422 2c0a 2020 2020 226f  ent-ext",.    "o
-00000140: 776e 6572 223a 2022 6576 656e 742d 6261  wner": "event-ba
-00000150: 7365 222c 0a20 2020 2022 706f 696e 7465  se",.    "pointe
-00000160: 642d 746f 223a 2022 6576 656e 742d 7370  d-to": "event-sp
-00000170: 6563 220a 2020 7d2c 0a20 207b 0a20 2020  ec".  },.  {.   
-00000180: 2022 7374 6978 223a 2022 6578 7465 6e73   "stix": "extens
-00000190: 696f 6e2d 6465 6669 6e69 7469 6f6e 2d2d  ion-definition--
-000001a0: 3763 6333 3364 6436 2d66 3661 312d 3438  7cc33dd6-f6a1-48
-000001b0: 3962 2d39 3865 612d 3532 3264 3335 3164  9b-98ea-522d351d
-000001c0: 3731 6239 222c 0a20 2020 2022 6f62 6a65  71b9",.    "obje
-000001d0: 6374 223a 2022 696d 7061 6374 2d65 7874  ct": "impact-ext
-000001e0: 656e 7369 6f6e 222c 0a20 2020 2022 7265  ension",.    "re
-000001f0: 6c61 7469 6f6e 223a 2022 696d 7061 6374  lation": "impact
-00000200: 2d65 7874 222c 0a20 2020 2022 6f77 6e65  -ext",.    "owne
-00000210: 7222 3a20 2269 6d70 6163 742d 6578 7422  r": "impact-ext"
-00000220: 2c0a 2020 2020 2270 6f69 6e74 6564 2d74  ,.    "pointed-t
-00000230: 6f22 3a20 2269 6d70 6163 742d 7370 6563  o": "impact-spec
-00000240: 220a 2020 7d2c 0a20 207b 0a20 2020 2022  ".  },.  {.    "
-00000250: 7374 6978 223a 2022 6176 6169 6c61 6269  stix": "availabi
-00000260: 6c69 7479 222c 0a20 2020 2022 6f62 6a65  lity",.    "obje
-00000270: 6374 223a 2022 6176 6169 6c61 6269 6c69  ct": "availabili
-00000280: 7479 222c 0a20 2020 2022 7265 6c61 7469  ty",.    "relati
-00000290: 6f6e 223a 2022 6176 6169 6c61 6269 6c69  on": "availabili
-000002a0: 7479 2d65 7874 222c 0a20 2020 2022 6f77  ty-ext",.    "ow
-000002b0: 6e65 7222 3a20 2269 6d70 6163 742d 6261  ner": "impact-ba
-000002c0: 7365 222c 0a20 2020 2022 706f 696e 7465  se",.    "pointe
-000002d0: 642d 746f 223a 2022 6176 6169 6c61 6269  d-to": "availabi
-000002e0: 6c69 7479 2d69 6d70 6163 7422 0a20 207d  lity-impact".  }
-000002f0: 2c0a 2020 7b0a 2020 2020 2273 7469 7822  ,.  {.    "stix"
-00000300: 3a20 2263 6f6e 6669 6465 6e74 6961 6c69  : "confidentiali
-00000310: 7479 222c 0a20 2020 2022 6f62 6a65 6374  ty",.    "object
-00000320: 223a 2022 636f 6e66 6964 656e 7469 616c  ": "confidential
-00000330: 6974 7922 2c0a 2020 2020 2272 656c 6174  ity",.    "relat
-00000340: 696f 6e22 3a20 2263 6f6e 6669 6465 6e74  ion": "confident
-00000350: 6961 6c69 7479 2d65 7874 222c 0a20 2020  iality-ext",.   
-00000360: 2022 6f77 6e65 7222 3a20 2269 6d70 6163   "owner": "impac
-00000370: 742d 6261 7365 222c 0a20 2020 2022 706f  t-base",.    "po
-00000380: 696e 7465 642d 746f 223a 2022 636f 6e66  inted-to": "conf
-00000390: 6964 656e 7469 616c 6974 792d 696d 7061  identiality-impa
-000003a0: 6374 220a 2020 7d2c 0a20 207b 0a20 2020  ct".  },.  {.   
-000003b0: 2022 7374 6978 223a 2022 6578 7465 726e   "stix": "extern
-000003c0: 616c 222c 0a20 2020 2022 6f62 6a65 6374  al",.    "object
-000003d0: 223a 2022 6578 7465 726e 616c 222c 0a20  ": "external",. 
-000003e0: 2020 2022 7265 6c61 7469 6f6e 223a 2022     "relation": "
-000003f0: 6578 7465 726e 616c 2d65 7874 222c 0a20  external-ext",. 
-00000400: 2020 2022 6f77 6e65 7222 3a20 2269 6d70     "owner": "imp
-00000410: 6163 742d 6261 7365 222c 0a20 2020 2022  act-base",.    "
-00000420: 706f 696e 7465 642d 746f 223a 2022 6578  pointed-to": "ex
-00000430: 7465 726e 616c 2d69 6d70 6163 7422 0a20  ternal-impact". 
-00000440: 207d 2c0a 2020 7b0a 2020 2020 2273 7469   },.  {.    "sti
-00000450: 7822 3a20 2269 6e74 6567 7269 7479 222c  x": "integrity",
-00000460: 0a20 2020 2022 6f62 6a65 6374 223a 2022  .    "object": "
-00000470: 696e 7465 6772 6974 7922 2c0a 2020 2020  integrity",.    
-00000480: 2272 656c 6174 696f 6e22 3a20 2269 6e74  "relation": "int
-00000490: 6567 7269 7479 2d65 7874 222c 0a20 2020  egrity-ext",.   
-000004a0: 2022 6f77 6e65 7222 3a20 2269 6d70 6163   "owner": "impac
-000004b0: 742d 6261 7365 222c 0a20 2020 2022 706f  t-base",.    "po
-000004c0: 696e 7465 642d 746f 223a 2022 696e 7465  inted-to": "inte
-000004d0: 6772 6974 792d 696d 7061 6374 220a 2020  grity-impact".  
-000004e0: 7d2c 0a20 207b 0a20 2020 2022 7374 6978  },.  {.    "stix
-000004f0: 223a 2022 6d6f 6e65 7461 7279 222c 0a20  ": "monetary",. 
-00000500: 2020 2022 6f62 6a65 6374 223a 2022 6d6f     "object": "mo
-00000510: 6e65 7461 7279 222c 0a20 2020 2022 7265  netary",.    "re
-00000520: 6c61 7469 6f6e 223a 2022 6d6f 6e65 7461  lation": "moneta
-00000530: 7279 2d65 7874 222c 0a20 2020 2022 6f77  ry-ext",.    "ow
-00000540: 6e65 7222 3a20 2269 6d70 6163 742d 6261  ner": "impact-ba
-00000550: 7365 222c 0a20 2020 2022 706f 696e 7465  se",.    "pointe
-00000560: 642d 746f 223a 2022 6d6f 6e65 7461 7279  d-to": "monetary
-00000570: 2d69 6d70 6163 7422 0a20 207d 2c0a 2020  -impact".  },.  
-00000580: 7b0a 2020 2020 2273 7469 7822 3a20 2270  {.    "stix": "p
-00000590: 6879 7369 6361 6c22 2c0a 2020 2020 226f  hysical",.    "o
-000005a0: 626a 6563 7422 3a20 2270 6879 7369 6361  bject": "physica
-000005b0: 6c22 2c0a 2020 2020 2272 656c 6174 696f  l",.    "relatio
-000005c0: 6e22 3a20 2270 6879 7369 6361 6c2d 6578  n": "physical-ex
-000005d0: 7422 2c0a 2020 2020 226f 776e 6572 223a  t",.    "owner":
-000005e0: 2022 7068 7973 6963 616c 2d65 7874 222c   "physical-ext",
-000005f0: 0a20 2020 2022 706f 696e 7465 642d 746f  .    "pointed-to
-00000600: 223a 2022 7068 7973 6963 616c 2d69 6d70  ": "physical-imp
-00000610: 6163 7422 0a20 207d 2c0a 2020 7b0a 2020  act".  },.  {.  
-00000620: 2020 2273 7469 7822 3a20 2274 7261 6365    "stix": "trace
-00000630: 6162 696c 6974 7922 2c0a 2020 2020 226f  ability",.    "o
-00000640: 626a 6563 7422 3a20 2274 7261 6365 6162  bject": "traceab
-00000650: 696c 6974 7922 2c0a 2020 2020 2272 656c  ility",.    "rel
-00000660: 6174 696f 6e22 3a20 2274 7261 6365 6162  ation": "traceab
-00000670: 696c 6974 792d 6578 7422 2c0a 2020 2020  ility-ext",.    
-00000680: 226f 776e 6572 223a 2022 696d 7061 6374  "owner": "impact
-00000690: 2d62 6173 6522 2c0a 2020 2020 2270 6f69  -base",.    "poi
-000006a0: 6e74 6564 2d74 6f22 3a20 2274 7261 6365  nted-to": "trace
-000006b0: 6162 696c 6974 792d 696d 7061 6374 220a  ability-impact".
-000006c0: 2020 7d2c 0a20 207b 0a20 2020 2022 7374    },.  {.    "st
-000006d0: 6978 223a 2022 7363 6f72 6573 222c 0a20  ix": "scores",. 
-000006e0: 2020 2022 6f62 6a65 6374 223a 2022 696e     "object": "in
-000006f0: 6369 6465 6e74 2d73 636f 7265 222c 0a20  cident-score",. 
-00000700: 2020 2022 7265 6c61 7469 6f6e 223a 2022     "relation": "
-00000710: 7363 6f72 6573 222c 0a20 2020 2022 6f77  scores",.    "ow
-00000720: 6e65 7222 3a20 2273 636f 7265 6422 2c0a  ner": "scored",.
-00000730: 2020 2020 2270 6f69 6e74 6564 2d74 6f22      "pointed-to"
-00000740: 3a20 2273 636f 7265 220a 2020 7d2c 0a20  : "score".  },. 
-00000750: 207b 0a20 2020 2022 7374 6978 223a 2022   {.    "stix": "
-00000760: 6578 7465 6e73 696f 6e2d 6465 6669 6e69  extension-defini
-00000770: 7469 6f6e 2d2d 6566 3736 3536 3531 2d36  tion--ef765651-6
-00000780: 3830 632d 3439 3864 2d39 3839 342d 3939  80c-498d-9894-99
-00000790: 3739 3966 3266 6131 3236 222c 0a20 2020  799f2fa126",.   
-000007a0: 2022 6f62 6a65 6374 223a 2022 696e 6369   "object": "inci
-000007b0: 6465 6e74 2d65 7874 222c 0a20 2020 2022  dent-ext",.    "
-000007c0: 7265 6c61 7469 6f6e 223a 2022 6f63 6375  relation": "occu
-000007d0: 7265 6e63 652d 6578 7422 2c0a 2020 2020  rence-ext",.    
-000007e0: 226f 776e 6572 223a 2022 6f63 6375 7265  "owner": "occure
-000007f0: 6e63 6522 2c0a 2020 2020 2270 6f69 6e74  nce",.    "point
-00000800: 6564 2d74 6f22 3a20 2269 6e63 6964 656e  ed-to": "inciden
-00000810: 742d 636f 7265 220a 2020 7d2c 0a20 207b  t-core".  },.  {
-00000820: 0a20 2020 2022 7374 6978 223a 2022 6578  .    "stix": "ex
-00000830: 7465 6e73 696f 6e2d 6465 6669 6e69 7469  tension-definiti
-00000840: 6f6e 2d2d 3230 3734 6130 3532 2d38 6265  on--2074a052-8be
-00000850: 342d 3439 3332 2d38 3439 652d 6635 6537  4-4932-849e-f5e7
-00000860: 3739 3865 3030 3330 222c 0a20 2020 2022  798e0030",.    "
-00000870: 6f62 6a65 6374 223a 2022 7461 736b 2d65  object": "task-e
-00000880: 7874 656e 7369 6f6e 222c 0a20 2020 2022  xtension",.    "
-00000890: 7265 6c61 7469 6f6e 223a 2022 7461 736b  relation": "task
-000008a0: 2d65 7874 222c 0a20 2020 2022 6f77 6e65  -ext",.    "owne
-000008b0: 7222 3a20 2274 6173 6b2d 6261 7365 222c  r": "task-base",
-000008c0: 0a20 2020 2022 706f 696e 7465 642d 746f  .    "pointed-to
-000008d0: 223a 2022 7461 736b 2d73 7065 6322 0a20  ": "task-spec". 
-000008e0: 207d 2c0a 2020 7b0a 2020 2020 2273 7469   },.  {.    "sti
-000008f0: 7822 3a20 2265 7874 656e 7369 6f6e 2d64  x": "extension-d
-00000900: 6566 696e 6974 696f 6e2d 2d37 6666 3562  efinition--7ff5b
-00000910: 3561 352d 6133 3432 2d34 3137 652d 3963  5a5-a342-417e-9c
-00000920: 3064 2d33 3339 3536 3164 3964 3738 6122  0d-339561d9d78a"
-00000930: 2c0a 2020 2020 226f 626a 6563 7422 3a20  ,.    "object": 
-00000940: 2265 7669 6465 6e63 652d 6578 7465 6e73  "evidence-extens
-00000950: 696f 6e22 2c0a 2020 2020 2272 656c 6174  ion",.    "relat
-00000960: 696f 6e22 3a20 2265 7669 6465 6e63 652d  ion": "evidence-
-00000970: 6578 7422 2c0a 2020 2020 226f 776e 6572  ext",.    "owner
-00000980: 223a 2022 6576 6964 656e 6365 2d62 6173  ": "evidence-bas
-00000990: 6522 2c0a 2020 2020 2270 6f69 6e74 6564  e",.    "pointed
-000009a0: 2d74 6f22 3a20 2265 7669 6465 6e63 652d  -to": "evidence-
-000009b0: 7370 6563 220a 2020 7d0a 5d              spec".  }.]
+00000000: 5b0d 0a20 207b 0d0a 2020 2020 2273 7469  [..  {..    "sti
+00000010: 7822 3a20 2269 6d70 6163 7465 645f 656e  x": "impacted_en
+00000020: 7469 7479 5f63 6f75 6e74 7322 2c0d 0a20  tity_counts",.. 
+00000030: 2020 2022 6f62 6a65 6374 223a 2022 656e     "object": "en
+00000040: 7469 7479 2d63 6f75 6e74 6572 222c 0d0a  tity-counter",..
+00000050: 2020 2020 2272 656c 6174 696f 6e22 3a20      "relation": 
+00000060: 2269 6d70 6163 742d 636f 756e 7465 7222  "impact-counter"
+00000070: 2c0d 0a20 2020 2022 6f77 6e65 7222 3a20  ,..    "owner": 
+00000080: 2269 6d70 6163 742d 6472 6976 6572 222c  "impact-driver",
+00000090: 0d0a 2020 2020 2270 6f69 6e74 6564 2d74  ..    "pointed-t
+000000a0: 6f22 3a20 2263 6f75 6e74 6572 7322 0d0a  o": "counters"..
+000000b0: 2020 7d2c 0d0a 2020 7b0d 0a20 2020 2022    },..  {..    "
+000000c0: 7374 6978 223a 2022 6578 7465 6e73 696f  stix": "extensio
+000000d0: 6e2d 6465 6669 6e69 7469 6f6e 2d2d 3463  n-definition--4c
+000000e0: 6136 6465 3030 2d35 6230 642d 3435 6566  a6de00-5b0d-45ef
+000000f0: 2d61 3164 632d 6561 3732 3739 6561 3931  -a1dc-ea7279ea91
+00000100: 3065 222c 0d0a 2020 2020 226f 626a 6563  0e",..    "objec
+00000110: 7422 3a20 2265 7665 6e74 2d65 7874 656e  t": "event-exten
+00000120: 7369 6f6e 222c 0d0a 2020 2020 2272 656c  sion",..    "rel
+00000130: 6174 696f 6e22 3a20 2265 7665 6e74 2d65  ation": "event-e
+00000140: 7874 222c 0d0a 2020 2020 226f 776e 6572  xt",..    "owner
+00000150: 223a 2022 6576 656e 742d 6261 7365 222c  ": "event-base",
+00000160: 0d0a 2020 2020 2270 6f69 6e74 6564 2d74  ..    "pointed-t
+00000170: 6f22 3a20 2265 7665 6e74 2d73 7065 6322  o": "event-spec"
+00000180: 0d0a 2020 7d2c 0d0a 2020 7b0d 0a20 2020  ..  },..  {..   
+00000190: 2022 7374 6978 223a 2022 6578 7465 6e73   "stix": "extens
+000001a0: 696f 6e2d 6465 6669 6e69 7469 6f6e 2d2d  ion-definition--
+000001b0: 3763 6333 3364 6436 2d66 3661 312d 3438  7cc33dd6-f6a1-48
+000001c0: 3962 2d39 3865 612d 3532 3264 3335 3164  9b-98ea-522d351d
+000001d0: 3731 6239 222c 0d0a 2020 2020 226f 626a  71b9",..    "obj
+000001e0: 6563 7422 3a20 2269 6d70 6163 742d 6578  ect": "impact-ex
+000001f0: 7465 6e73 696f 6e22 2c0d 0a20 2020 2022  tension",..    "
+00000200: 7265 6c61 7469 6f6e 223a 2022 696d 7061  relation": "impa
+00000210: 6374 2d65 7874 222c 0d0a 2020 2020 226f  ct-ext",..    "o
+00000220: 776e 6572 223a 2022 696d 7061 6374 2d65  wner": "impact-e
+00000230: 7874 222c 0d0a 2020 2020 2270 6f69 6e74  xt",..    "point
+00000240: 6564 2d74 6f22 3a20 2269 6d70 6163 742d  ed-to": "impact-
+00000250: 7370 6563 220d 0a20 207d 2c0d 0a20 207b  spec"..  },..  {
+00000260: 0d0a 2020 2020 2273 7469 7822 3a20 2261  ..    "stix": "a
+00000270: 7661 696c 6162 696c 6974 7922 2c0d 0a20  vailability",.. 
+00000280: 2020 2022 6f62 6a65 6374 223a 2022 6176     "object": "av
+00000290: 6169 6c61 6269 6c69 7479 222c 0d0a 2020  ailability",..  
+000002a0: 2020 2272 656c 6174 696f 6e22 3a20 2261    "relation": "a
+000002b0: 7661 696c 6162 696c 6974 792d 6578 7422  vailability-ext"
+000002c0: 2c0d 0a20 2020 2022 6f77 6e65 7222 3a20  ,..    "owner": 
+000002d0: 2269 6d70 6163 742d 6261 7365 222c 0d0a  "impact-base",..
+000002e0: 2020 2020 2270 6f69 6e74 6564 2d74 6f22      "pointed-to"
+000002f0: 3a20 2261 7661 696c 6162 696c 6974 792d  : "availability-
+00000300: 696d 7061 6374 220d 0a20 207d 2c0d 0a20  impact"..  },.. 
+00000310: 207b 0d0a 2020 2020 2273 7469 7822 3a20   {..    "stix": 
+00000320: 2263 6f6e 6669 6465 6e74 6961 6c69 7479  "confidentiality
+00000330: 222c 0d0a 2020 2020 226f 626a 6563 7422  ",..    "object"
+00000340: 3a20 2263 6f6e 6669 6465 6e74 6961 6c69  : "confidentiali
+00000350: 7479 222c 0d0a 2020 2020 2272 656c 6174  ty",..    "relat
+00000360: 696f 6e22 3a20 2263 6f6e 6669 6465 6e74  ion": "confident
+00000370: 6961 6c69 7479 2d65 7874 222c 0d0a 2020  iality-ext",..  
+00000380: 2020 226f 776e 6572 223a 2022 696d 7061    "owner": "impa
+00000390: 6374 2d62 6173 6522 2c0d 0a20 2020 2022  ct-base",..    "
+000003a0: 706f 696e 7465 642d 746f 223a 2022 636f  pointed-to": "co
+000003b0: 6e66 6964 656e 7469 616c 6974 792d 696d  nfidentiality-im
+000003c0: 7061 6374 220d 0a20 207d 2c0d 0a20 207b  pact"..  },..  {
+000003d0: 0d0a 2020 2020 2273 7469 7822 3a20 2265  ..    "stix": "e
+000003e0: 7874 6572 6e61 6c22 2c0d 0a20 2020 2022  xternal",..    "
+000003f0: 6f62 6a65 6374 223a 2022 6578 7465 726e  object": "extern
+00000400: 616c 222c 0d0a 2020 2020 2272 656c 6174  al",..    "relat
+00000410: 696f 6e22 3a20 2265 7874 6572 6e61 6c2d  ion": "external-
+00000420: 6578 7422 2c0d 0a20 2020 2022 6f77 6e65  ext",..    "owne
+00000430: 7222 3a20 2269 6d70 6163 742d 6261 7365  r": "impact-base
+00000440: 222c 0d0a 2020 2020 2270 6f69 6e74 6564  ",..    "pointed
+00000450: 2d74 6f22 3a20 2265 7874 6572 6e61 6c2d  -to": "external-
+00000460: 696d 7061 6374 220d 0a20 207d 2c0d 0a20  impact"..  },.. 
+00000470: 207b 0d0a 2020 2020 2273 7469 7822 3a20   {..    "stix": 
+00000480: 2269 6e74 6567 7269 7479 222c 0d0a 2020  "integrity",..  
+00000490: 2020 226f 626a 6563 7422 3a20 2269 6e74    "object": "int
+000004a0: 6567 7269 7479 222c 0d0a 2020 2020 2272  egrity",..    "r
+000004b0: 656c 6174 696f 6e22 3a20 2269 6e74 6567  elation": "integ
+000004c0: 7269 7479 2d65 7874 222c 0d0a 2020 2020  rity-ext",..    
+000004d0: 226f 776e 6572 223a 2022 696d 7061 6374  "owner": "impact
+000004e0: 2d62 6173 6522 2c0d 0a20 2020 2022 706f  -base",..    "po
+000004f0: 696e 7465 642d 746f 223a 2022 696e 7465  inted-to": "inte
+00000500: 6772 6974 792d 696d 7061 6374 220d 0a20  grity-impact".. 
+00000510: 207d 2c0d 0a20 207b 0d0a 2020 2020 2273   },..  {..    "s
+00000520: 7469 7822 3a20 226d 6f6e 6574 6172 7922  tix": "monetary"
+00000530: 2c0d 0a20 2020 2022 6f62 6a65 6374 223a  ,..    "object":
+00000540: 2022 6d6f 6e65 7461 7279 222c 0d0a 2020   "monetary",..  
+00000550: 2020 2272 656c 6174 696f 6e22 3a20 226d    "relation": "m
+00000560: 6f6e 6574 6172 792d 6578 7422 2c0d 0a20  onetary-ext",.. 
+00000570: 2020 2022 6f77 6e65 7222 3a20 2269 6d70     "owner": "imp
+00000580: 6163 742d 6261 7365 222c 0d0a 2020 2020  act-base",..    
+00000590: 2270 6f69 6e74 6564 2d74 6f22 3a20 226d  "pointed-to": "m
+000005a0: 6f6e 6574 6172 792d 696d 7061 6374 220d  onetary-impact".
+000005b0: 0a20 207d 2c0d 0a20 207b 0d0a 2020 2020  .  },..  {..    
+000005c0: 2273 7469 7822 3a20 2270 6879 7369 6361  "stix": "physica
+000005d0: 6c22 2c0d 0a20 2020 2022 6f62 6a65 6374  l",..    "object
+000005e0: 223a 2022 7068 7973 6963 616c 222c 0d0a  ": "physical",..
+000005f0: 2020 2020 2272 656c 6174 696f 6e22 3a20      "relation": 
+00000600: 2270 6879 7369 6361 6c2d 6578 7422 2c0d  "physical-ext",.
+00000610: 0a20 2020 2022 6f77 6e65 7222 3a20 2270  .    "owner": "p
+00000620: 6879 7369 6361 6c2d 6578 7422 2c0d 0a20  hysical-ext",.. 
+00000630: 2020 2022 706f 696e 7465 642d 746f 223a     "pointed-to":
+00000640: 2022 7068 7973 6963 616c 2d69 6d70 6163   "physical-impac
+00000650: 7422 0d0a 2020 7d2c 0d0a 2020 7b0d 0a20  t"..  },..  {.. 
+00000660: 2020 2022 7374 6978 223a 2022 7472 6163     "stix": "trac
+00000670: 6561 6269 6c69 7479 222c 0d0a 2020 2020  eability",..    
+00000680: 226f 626a 6563 7422 3a20 2274 7261 6365  "object": "trace
+00000690: 6162 696c 6974 7922 2c0d 0a20 2020 2022  ability",..    "
+000006a0: 7265 6c61 7469 6f6e 223a 2022 7472 6163  relation": "trac
+000006b0: 6561 6269 6c69 7479 2d65 7874 222c 0d0a  eability-ext",..
+000006c0: 2020 2020 226f 776e 6572 223a 2022 696d      "owner": "im
+000006d0: 7061 6374 2d62 6173 6522 2c0d 0a20 2020  pact-base",..   
+000006e0: 2022 706f 696e 7465 642d 746f 223a 2022   "pointed-to": "
+000006f0: 7472 6163 6561 6269 6c69 7479 2d69 6d70  traceability-imp
+00000700: 6163 7422 0d0a 2020 7d2c 0d0a 2020 7b0d  act"..  },..  {.
+00000710: 0a20 2020 2022 7374 6978 223a 2022 7363  .    "stix": "sc
+00000720: 6f72 6573 222c 0d0a 2020 2020 226f 626a  ores",..    "obj
+00000730: 6563 7422 3a20 2269 6e63 6964 656e 742d  ect": "incident-
+00000740: 7363 6f72 6522 2c0d 0a20 2020 2022 7265  score",..    "re
+00000750: 6c61 7469 6f6e 223a 2022 7363 6f72 6573  lation": "scores
+00000760: 222c 0d0a 2020 2020 226f 776e 6572 223a  ",..    "owner":
+00000770: 2022 7363 6f72 6564 222c 0d0a 2020 2020   "scored",..    
+00000780: 2270 6f69 6e74 6564 2d74 6f22 3a20 2273  "pointed-to": "s
+00000790: 636f 7265 220d 0a20 207d 2c0d 0a20 207b  core"..  },..  {
+000007a0: 0d0a 2020 2020 2273 7469 7822 3a20 2265  ..    "stix": "e
+000007b0: 7874 656e 7369 6f6e 2d64 6566 696e 6974  xtension-definit
+000007c0: 696f 6e2d 2d65 6637 3635 3635 312d 3638  ion--ef765651-68
+000007d0: 3063 2d34 3938 642d 3938 3934 2d39 3937  0c-498d-9894-997
+000007e0: 3939 6632 6661 3132 3622 2c0d 0a20 2020  99f2fa126",..   
+000007f0: 2022 6f62 6a65 6374 223a 2022 696e 6369   "object": "inci
+00000800: 6465 6e74 2d65 7874 222c 0d0a 2020 2020  dent-ext",..    
+00000810: 2272 656c 6174 696f 6e22 3a20 226f 6363  "relation": "occ
+00000820: 7572 656e 6365 2d65 7874 222c 0d0a 2020  urence-ext",..  
+00000830: 2020 226f 776e 6572 223a 2022 6f63 6375    "owner": "occu
+00000840: 7265 6e63 6522 2c0d 0a20 2020 2022 706f  rence",..    "po
+00000850: 696e 7465 642d 746f 223a 2022 696e 6369  inted-to": "inci
+00000860: 6465 6e74 2d63 6f72 6522 0d0a 2020 7d2c  dent-core"..  },
+00000870: 0d0a 2020 7b0d 0a20 2020 2022 7374 6978  ..  {..    "stix
+00000880: 223a 2022 6578 7465 6e73 696f 6e2d 6465  ": "extension-de
+00000890: 6669 6e69 7469 6f6e 2d2d 3230 3734 6130  finition--2074a0
+000008a0: 3532 2d38 6265 342d 3439 3332 2d38 3439  52-8be4-4932-849
+000008b0: 652d 6635 6537 3739 3865 3030 3330 222c  e-f5e7798e0030",
+000008c0: 0d0a 2020 2020 226f 626a 6563 7422 3a20  ..    "object": 
+000008d0: 2274 6173 6b2d 6578 7465 6e73 696f 6e22  "task-extension"
+000008e0: 2c0d 0a20 2020 2022 7265 6c61 7469 6f6e  ,..    "relation
+000008f0: 223a 2022 7461 736b 2d65 7874 222c 0d0a  ": "task-ext",..
+00000900: 2020 2020 226f 776e 6572 223a 2022 7461      "owner": "ta
+00000910: 736b 2d62 6173 6522 2c0d 0a20 2020 2022  sk-base",..    "
+00000920: 706f 696e 7465 642d 746f 223a 2022 7461  pointed-to": "ta
+00000930: 736b 2d73 7065 6322 0d0a 2020 7d2c 0d0a  sk-spec"..  },..
+00000940: 2020 7b0d 0a20 2020 2022 7374 6978 223a    {..    "stix":
+00000950: 2022 6578 7465 6e73 696f 6e2d 6465 6669   "extension-defi
+00000960: 6e69 7469 6f6e 2d2d 3766 6635 6235 6135  nition--7ff5b5a5
+00000970: 2d61 3334 322d 3431 3765 2d39 6330 642d  -a342-417e-9c0d-
+00000980: 3333 3935 3631 6439 6437 3861 222c 0d0a  339561d9d78a",..
+00000990: 2020 2020 226f 626a 6563 7422 3a20 2265      "object": "e
+000009a0: 7669 6465 6e63 652d 6578 7465 6e73 696f  vidence-extensio
+000009b0: 6e22 2c0d 0a20 2020 2022 7265 6c61 7469  n",..    "relati
+000009c0: 6f6e 223a 2022 6576 6964 656e 6365 2d65  on": "evidence-e
+000009d0: 7874 222c 0d0a 2020 2020 226f 776e 6572  xt",..    "owner
+000009e0: 223a 2022 6576 6964 656e 6365 2d62 6173  ": "evidence-bas
+000009f0: 6522 2c0d 0a20 2020 2022 706f 696e 7465  e",..    "pointe
+00000a00: 642d 746f 223a 2022 6576 6964 656e 6365  d-to": "evidence
+00000a10: 2d73 7065 6322 0d0a 2020 7d0d 0a5d       -spec"..  }..]
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/os_threat/schema/cti-os-hunt.tql` & `stixorm-0.1.9/stixorm/module/definitions/os_threat/schema/cti-os-hunt.tql`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-#
-# Copyright (C) 2022 OS-Threat
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-define
+#
+# Copyright (C) 2022 OS-Threat
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+define
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/os_threat/schema/cti-os-threat.tql` & `stixorm-0.1.9/stixorm/module/definitions/os_threat/schema/cti-os-threat.tql`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,588 +1,588 @@
-#
-# Copyright (C) 2022 OS-Threat
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-define
-
-    # Incident Event Object
-    event sub stix-domain-object,
-        owns name,
-        owns description,
-        owns status,
-        owns end-time,
-        owns end-time-fidelity,
-        owns event-types,
-        owns goal,
-        owns start-time,
-        owns start-time-fidelity,
-        owns event-seq,
-        owns detection-emthods,
-        owns detection-system,
-        owns detection-rule,
-        plays blocks:stops,
-        plays causes:caused,
-        plays detects:found,
-        plays performed:outcome,
-	    plays based-on:basis,
-        plays located-at:locating,
-	    plays led-to:initial,
-	    plays led-to:subsequent,
-	    plays impacts:issue,
-        plays event-refs:the-event,
-        plays subevents:parent,
-        plays subevents:sub-event,
-        plays list-of-sightings:sighting-event,
-        plays objects-changed:change-driver,
-        plays event-ext:event-base;
-
-    # Incoident Impact Object
-    impact sub stix-domain-object,
-        owns impact-category,
-        owns criticality,
-        owns description,
-        owns end-time,
-        owns end-time-fidelity,
-        owns recoverability,
-        owns start-time,
-        owns start-time-fidelity,
-        plays impact-counter:impact-driver,
-        plays impacted-refs:the-impact,
-        plays superseded:superseded-by,
-        plays superseded:precedes,
-        plays impact-ext:impact-base,
-        plays availability-ext:impact-base,
-        plays confidentiality-ext:impact-base,
-        plays external-ext:impact-base,
-        plays integrity-ext:impact-base,
-        plays monetary-ext:impact-base,
-        plays physical-ext:impact-base,
-        plays traceability-ext:impact-base,
-        plays impact-refs:the-impact;
-
-    # Incident Evidence Object
-    evidence sub stix-domain-object,
-        owns evidence-type,
-        owns description,
-        owns name,
-        owns source,
-        plays obj-refs:object,
-        plays evidence-refs:the-evidence,
-        plays evidence-ext:evidence-base;
-
-    # Incident Tasks Object
-    task sub stix-domain-object, abstract,
-        owns step-type,
-        owns outcome,
-        owns task-type,
-        owns description,
-        owns name,
-        owns end-time,
-        owns end-time-fidelity,
-        owns error,
-        owns priority,
-        owns start-time,
-        owns start-time-fidelity,
-        plays task-ext:task-base,
-        plays blocks:effort,
-        plays causes:effort,
-        plays detects:effort,
-        plays creates:effort,
-        plays uses:used,
-        plays detects:effort,
-        plays impacts:issue,
-        plays located-at:locating,
-        plays errored-to:started,
-        plays errored-to:on-error,
-        plays followed-by:initial,
-        plays followed-by:subsequent,
-        plays assigned:effort,
-        plays contact-for:issue,
-        plays participated-in:assisted,
-        plays performed:outcome;
-
-    start-step sub task,
-        plays on-completion:source,
-        plays task-refs:the-task;
-
-    end-step sub task,
-        plays on-completion:target,
-        plays on-success:target,
-        plays on-failure:target,
-        plays task-refs:the-task;
-
-    single-step sub task,
-        plays on-completion:target,
-        plays on-success:target,
-        plays on-failure:target,
-        plays on-completion:source,
-        plays on-success:source,
-        plays on-failure:source,
-        plays next-steps:target,
-        plays owned-by:owned,
-        plays impact-counter:impact-driver,
-        plays objects-changed:change-driver,
-        plays task-refs:the-task;
-
-    parallel-step sub task,
-        plays on-completion:target,
-        plays on-success:target,
-        plays on-failure:target,
-        plays next-steps:source,
-        plays task-refs:the-task;
-
-    # Incident State Change Sub Object
-    state-change sub stix-sub-object,
-        owns state-change-type,
-        plays  changed-objects-initial:changed-objects,
-        plays  changed-objects-result:changed-objects,
-        plays objects-changed:object-list;
-
-    entity-counter sub stix-sub-object,
-        owns individual-count,
-        owns group-count,
-        owns system-count,
-        owns organization-count,
-        owns class-count,
-        owns unknown-count,
-        plays impact-counter:counters;
-
-    incident-score sub stix-sub-object,
-        owns name,
-        owns description,
-        owns score-value,
-        plays scores:score;
-
-
-    # Generic Incident Extension Objects
-    incident-extension sub stix-sub-object,
-        owns extension-type;
-
-    # incident core extension
-    incident-ext sub incident-extension,
-        owns determination,
-        owns investigation-status,
-        owns malicious,
-        owns blocked,
-        owns criticality,
-        owns recoverability,
-        owns incident-types,
-        plays impact-counter:impact-driver,
-        plays scores:scored,
-        plays task-refs:incident,
-        plays event-refs:incident,
-        plays evidence-refs:incident,
-        plays notes-refs:incident,
-        plays impact-refs:incident,
-	    plays  occurence-ext:incident-core,
-        plays derived-from:raw-material;
-    # incident core extension embedded relation
-    occurence-ext sub extensions,
-        relates occurence as sco,
-        relates incident-core as extension;
-
-    # evidence extension object
-    evidence-extension sub incident-extension,
-        plays evidence-ext:evidence-spec;
-    # incident core extension embedded relation
-    evidence-ext sub extensions,
-        relates evidence-base as sco,
-        relates evidence-spec as extension;
-
-    # task extension object
-    task-extension sub incident-extension,
-        plays task-ext:task-spec;
-    # task extension embedded relation
-    task-ext sub extensions,
-        relates task-base as sco,
-        relates task-spec as extension;
-
-    # event extension object
-    event-extension sub incident-extension,
-        plays event-ext:event-spec;
-    # event extension embedded relation
-    event-ext sub extensions,
-        relates event-base as sco,
-        relates event-spec as extension;
-
-    # base impact extension object
-    impact-extension sub incident-extension,
-        plays impact-ext:impact-spec;
-    # base impact extension embedded relation
-    impact-ext sub extensions,
-        relates impact-base as sco,
-        relates impact-spec as extension;
-
-    # availability-impact extension object
-    availability sub incident-extension,
-        owns impacted-availability,
-        plays availability-ext:availability-impact;
-    # availability-impact extension embedded relation
-    availability-ext sub extensions,
-        relates impact-base as sco,
-        relates availability-impact as extension;
-
-    # confidentiality-impact extension object
-    confidentiality sub incident-extension,
-        owns information-type,
-        owns loss-type,
-        owns record-count,
-        owns record-size,
-        plays confidentiality-ext:confidentiality-impact;
-    # confidentiality-impact extension embedded relation
-    confidentiality-ext sub extensions,
-        relates impact-base as sco,
-        relates confidentiality-impact as extension;
-
-    # external-impact extension object
-    external sub incident-extension,
-        owns impact-type,
-        plays external-ext:external-impact;
-    # external-impact extension embedded relation
-     external-ext sub extensions,
-        relates impact-base as sco,
-        relates external-impact as extension;
-
-    # integrity-impact extension object
-    integrity sub incident-extension,
-        owns alteration,
-        owns information-type,
-        owns record-count,
-        owns record-size,
-        plays integrity-ext:integrity-impact;
-    # integrity-impact extension embedded relation
-    integrity-ext sub extensions,
-        relates impact-base as sco,
-        relates integrity-impact as extension;
-
-    # monetary-impact extension object
-    monetary sub incident-extension,
-        owns variety,
-        owns conversion-rate,
-        owns conversion-time,
-        owns currrency,
-        owns currency-actual,
-        owns max-amount,
-        owns min-amount,
-        plays monetary-ext:monetary-impact;
-    # monetary-impact extension embedded relation
-    monetary-ext sub extensions,
-        relates impact-base as sco,
-        relates monetary-impact as extension;
-
-    # physical-impact extension object
-    physical sub incident-extension,
-        owns impact-type,
-        owns asset-type,
-        plays physical-ext:physical-impact;
-    # physical-impact extension embedded relation
-    physical-ext sub extensions,
-        relates impact-base as sco,
-        relates physical-impact as extension;
-
-    # traceability-impact extension object
-    traceability sub incident-extension,
-        owns traceability-type,
-        plays traceability-ext:traceability-impact;
-    # traceability-impact extension embedded relation
-    traceability-ext sub extensions,
-        relates impact-base as sco,
-        relates traceability-impact as extension;
-
-    # Incident SRO's
-    led-to sub stix-core-relationship,
-		relates initial as source,
-		relates subsequent as target;
-
-    impacts sub stix-core-relationship,
-		relates issue as source,
-		relates impacted as target;
-
-    contact-for sub stix-core-relationship,
-		relates contact as source,
-		relates issue as target;
-
-    detected sub stix-core-relationship,
-		relates method as source,
-		relates issue as target;
-
-	performed sub stix-core-relationship,
-	    relates initiator as source,
-	    relates outcome as target;
-
-    blocks sub stix-core-relationship,
-		relates effort as source,
-		relates stops as target;
-
-    causes sub stix-core-relationship,
-		relates effort as source,
-		relates caused as target;
-
-    detects sub stix-core-relationship,
-		relates effort as source,
-		relates found as target;
-
-    creates sub stix-core-relationship,
-		relates effort as source,
-		relates made as target;
-
-    errored-to sub stix-core-relationship,
-		relates started as source,
-		relates on-error as target;
-
-    followed-by sub stix-core-relationship,
-		relates initial as source,
-		relates subsequent as target;
-
-    assigned sub stix-core-relationship,
-		relates owner as source,
-		relates effort as target;
-
-    participated-in sub stix-core-relationship,
-		relates contact as source,
-		relates assisted as target;
-
-    derived-from sub stix-core-relationship,
-		relates result as source,
-		relates raw-material as target;
-
-    # Incident Relationhs
-    sighting
-        plays list-of-sightings:sights;
-
-    # Incident Embedded Relations
-    list-of-sightings sub embedded,
-        relates sighting-event as owner,
-        relates sights as pointed-to;
-
-    subevents sub embedded,
-        relates parent as owner,
-        relates sub-event as pointed-to;
-
-    objects-changed sub embedded,
-        relates change-driver as owner,
-        relates object-list as pointed-to;
-
-    changed-objects-initial sub embedded,
-        relates changed-objects as owner,
-        relates changed as pointed-to;
-
-    changed-objects-result sub embedded,
-        relates changed-objects as owner,
-        relates changed as pointed-to;
-
-    impact-counter sub embedded,
-        relates impact-driver as owner,
-        relates counters as pointed-to;
-
-    impacted-refs sub embedded,
-        relates the-impact as owner,
-        relates impacted-thing as pointed-to;
-
-    superseded sub embedded,
-        relates superseded-by as pointed-to,
-        relates precedes as owner;
-
-    on-completion sub embedded,
-        relates source as owner,
-        relates target as pointed-to;
-
-    on-success sub embedded,
-        relates source as owner,
-        relates target as pointed-to;
-
-    on-failure sub embedded,
-        relates source as owner,
-        relates target as pointed-to;
-
-    next-steps sub embedded,
-        relates source as owner,
-        relates target as pointed-to;
-
-    owned-by sub embedded,
-        relates owned as owner,
-        relates who as pointed-to;
-
-    scores sub embedded,
-        relates scored as owner,
-        relates score as pointed-to;
-
-    task-refs sub embedded,
-        relates incident as owner,
-        relates the-task as pointed-to;
-
-    event-refs sub embedded,
-        relates incident as owner,
-        relates the-event as pointed-to;
-
-    evidence-refs sub embedded,
-        relates incident as owner,
-        relates the-evidence as pointed-to;
-
-    notes-refs sub embedded,
-        relates incident as owner,
-        relates the-note as pointed-to;
-
-    impact-refs sub embedded,
-        relates incident as owner,
-        relates the-impact as pointed-to;
-
-    # Feed Embedded Relations
-    list-of-feeds sub embedded,
-		relates feed-list-owner as owner,
-		relates single-feed as pointed-to;
-
-    feed-content sub embedded,
-		relates feed-owner as owner,
-		relates content as pointed-to;
-
-    # Feeds Collection Object
-    feeds sub stix-domain-object,
-        owns name,
-        owns description,
-        owns paid,
-        owns free,
-        plays list-of-feeds:feed-list-owner;
-
-    # Individual Feed Object
-    feed sub stix-domain-object,
-        owns name,
-        owns description,
-        owns paid,
-        owns free,
-        plays list-of-feeds:single-feed,
-        plays feed-content:feed-owner;
-
-    # Sub Object Reference, sub object includes created and modified
-    threat-sub-object sub stix-sub-object,
-        plays obj-refs:object,
-        plays obj-ref:container,
-        plays feed-content:content;
-
-	# Feed and Incident Contained References, can contain SDO, SCO or SRO, or Meta
-	stix-domain-object
-	    plays feed-content:content,
-	    plays obj-ref:content,
-	    plays changed-objects-initial:changed,
-	    plays changed-objects-result:changed,
-	    plays impacted-refs:impacted-thing;
-
-	stix-cyber-observable-object
-	    plays feed-content:content,
-	    plays obj-ref:content,
-	    plays impacted-refs:impacted-thing,
-	    plays impacts:impacted;
-
-	stix-core-relationship
-	    plays feed-content:content;
-
-    marking-definition
-	    plays feed-content:content;
-
-	identity
-	    plays owned-by:who,
-	    plays impacts:impacted,
-	    plays contact-for:contact,
-        plays assigned:owner,
-        plays participated-in:contact;
-
-	infrastructure
-	    plays impacts:impacted;
-
-	note
-	    plays notes-refs:the-note;
-
-	incident
-	    plays  occurence-ext:occurence,
-	    plays led-to:initial,
-	    plays led-to:subsequent,
-	    plays impacts:issue,
-	    plays contact-for:issue,
-	    plays detected:issue;
-
-    indicator
-        plays detected:method,
-        plays creates:made;
-
-    malware
-        plays performed:initiator;
-
-    tool
-        plays performed:initiator;
-
-    report
-        plays derived-from:result;
-
-    # Attribute Definitions
-    paid sub stix-attribute-boolean;
-    free sub stix-attribute-boolean;
-    malicious sub stix-attribute-boolean;
-    blocked sub stix-attribute-boolean;
-
-    status sub stix-attribute-string;
-    end-time-fidelity sub stix-attribute-string;
-    start-time-fidelity sub stix-attribute-string;
-    event-types sub stix-attribute-string;
-    goal sub stix-attribute-string;
-    detection-emthods sub stix-attribute-string;
-    detection-system sub stix-attribute-string;
-    detection-rule sub stix-attribute-string;
-    state-change-type sub stix-attribute-string;
-    impact-category sub stix-attribute-string;
-    recoverability sub stix-attribute-string;
-    information-type sub stix-attribute-string;
-    loss-type sub stix-attribute-string;
-    impact-type sub stix-attribute-string;
-    alteration sub stix-attribute-string;
-    variety sub stix-attribute-string;
-    currrency sub stix-attribute-string;
-    currency-actual sub stix-attribute-string;
-    asset-type sub stix-attribute-string;
-    traceability-type sub stix-attribute-string;
-    evidence-type sub stix-attribute-string;
-    source sub stix-attribute-string;
-    outcome sub stix-attribute-string;
-    task-type sub stix-attribute-string;
-    step-type sub stix-attribute-string;
-    error sub stix-attribute-string;
-    determination sub stix-attribute-string;
-    extension-type sub stix-attribute-string;
-    investigation-status sub stix-attribute-string;
-    incident-types sub stix-attribute-string;
-
-
-    event-seq sub stix-attribute-integer;
-    individual-count sub stix-attribute-integer;
-    group-count sub stix-attribute-integer;
-    system-count sub stix-attribute-integer;
-    organization-count sub stix-attribute-integer;
-    class-count sub stix-attribute-integer;
-    unknown-count sub stix-attribute-integer;
-    criticality sub stix-attribute-integer;
-    record-count sub stix-attribute-integer;
-    record-size sub stix-attribute-integer;
-    impacted-availability sub stix-attribute-integer;
-    conversion-rate sub stix-attribute-integer;
-    max-amount sub stix-attribute-integer;
-    min-amount sub stix-attribute-integer;
-    score-value sub stix-attribute-integer;
-
-    end-time sub stix-attribute-timestamp;
-    conversion-time sub stix-attribute-timestamp;
-
-
+#
+# Copyright (C) 2022 OS-Threat
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+define
+
+    # Incident Event Object
+    event sub stix-domain-object,
+        owns name,
+        owns description,
+        owns status,
+        owns end-time,
+        owns end-time-fidelity,
+        owns event-types,
+        owns goal,
+        owns start-time,
+        owns start-time-fidelity,
+        owns event-seq,
+        owns detection-emthods,
+        owns detection-system,
+        owns detection-rule,
+        plays blocks:stops,
+        plays causes:caused,
+        plays detects:found,
+        plays performed:outcome,
+	    plays based-on:basis,
+        plays located-at:locating,
+	    plays led-to:initial,
+	    plays led-to:subsequent,
+	    plays impacts:issue,
+        plays event-refs:the-event,
+        plays subevents:parent,
+        plays subevents:sub-event,
+        plays list-of-sightings:sighting-event,
+        plays objects-changed:change-driver,
+        plays event-ext:event-base;
+
+    # Incoident Impact Object
+    impact sub stix-domain-object,
+        owns impact-category,
+        owns criticality,
+        owns description,
+        owns end-time,
+        owns end-time-fidelity,
+        owns recoverability,
+        owns start-time,
+        owns start-time-fidelity,
+        plays impact-counter:impact-driver,
+        plays impacted-refs:the-impact,
+        plays superseded:superseded-by,
+        plays superseded:precedes,
+        plays impact-ext:impact-base,
+        plays availability-ext:impact-base,
+        plays confidentiality-ext:impact-base,
+        plays external-ext:impact-base,
+        plays integrity-ext:impact-base,
+        plays monetary-ext:impact-base,
+        plays physical-ext:impact-base,
+        plays traceability-ext:impact-base,
+        plays impact-refs:the-impact;
+
+    # Incident Evidence Object
+    evidence sub stix-domain-object,
+        owns evidence-type,
+        owns description,
+        owns name,
+        owns source,
+        plays obj-refs:object,
+        plays evidence-refs:the-evidence,
+        plays evidence-ext:evidence-base;
+
+    # Incident Tasks Object
+    task sub stix-domain-object, abstract,
+        owns step-type,
+        owns outcome,
+        owns task-type,
+        owns description,
+        owns name,
+        owns end-time,
+        owns end-time-fidelity,
+        owns error,
+        owns priority,
+        owns start-time,
+        owns start-time-fidelity,
+        plays task-ext:task-base,
+        plays blocks:effort,
+        plays causes:effort,
+        plays detects:effort,
+        plays creates:effort,
+        plays uses:used,
+        plays detects:effort,
+        plays impacts:issue,
+        plays located-at:locating,
+        plays errored-to:started,
+        plays errored-to:on-error,
+        plays followed-by:initial,
+        plays followed-by:subsequent,
+        plays assigned:effort,
+        plays contact-for:issue,
+        plays participated-in:assisted,
+        plays performed:outcome;
+
+    start-step sub task,
+        plays on-completion:source,
+        plays task-refs:the-task;
+
+    end-step sub task,
+        plays on-completion:target,
+        plays on-success:target,
+        plays on-failure:target,
+        plays task-refs:the-task;
+
+    single-step sub task,
+        plays on-completion:target,
+        plays on-success:target,
+        plays on-failure:target,
+        plays on-completion:source,
+        plays on-success:source,
+        plays on-failure:source,
+        plays next-steps:target,
+        plays owned-by:owned,
+        plays impact-counter:impact-driver,
+        plays objects-changed:change-driver,
+        plays task-refs:the-task;
+
+    parallel-step sub task,
+        plays on-completion:target,
+        plays on-success:target,
+        plays on-failure:target,
+        plays next-steps:source,
+        plays task-refs:the-task;
+
+    # Incident State Change Sub Object
+    state-change sub stix-sub-object,
+        owns state-change-type,
+        plays  changed-objects-initial:changed-objects,
+        plays  changed-objects-result:changed-objects,
+        plays objects-changed:object-list;
+
+    entity-counter sub stix-sub-object,
+        owns individual-count,
+        owns group-count,
+        owns system-count,
+        owns organization-count,
+        owns class-count,
+        owns unknown-count,
+        plays impact-counter:counters;
+
+    incident-score sub stix-sub-object,
+        owns name,
+        owns description,
+        owns score-value,
+        plays scores:score;
+
+
+    # Generic Incident Extension Objects
+    incident-extension sub stix-sub-object,
+        owns extension-type;
+
+    # incident core extension
+    incident-ext sub incident-extension,
+        owns determination,
+        owns investigation-status,
+        owns malicious,
+        owns blocked,
+        owns criticality,
+        owns recoverability,
+        owns incident-types,
+        plays impact-counter:impact-driver,
+        plays scores:scored,
+        plays task-refs:incident,
+        plays event-refs:incident,
+        plays evidence-refs:incident,
+        plays notes-refs:incident,
+        plays impact-refs:incident,
+	    plays  occurence-ext:incident-core,
+        plays derived-from:raw-material;
+    # incident core extension embedded relation
+    occurence-ext sub extensions,
+        relates occurence as sco,
+        relates incident-core as extension;
+
+    # evidence extension object
+    evidence-extension sub incident-extension,
+        plays evidence-ext:evidence-spec;
+    # incident core extension embedded relation
+    evidence-ext sub extensions,
+        relates evidence-base as sco,
+        relates evidence-spec as extension;
+
+    # task extension object
+    task-extension sub incident-extension,
+        plays task-ext:task-spec;
+    # task extension embedded relation
+    task-ext sub extensions,
+        relates task-base as sco,
+        relates task-spec as extension;
+
+    # event extension object
+    event-extension sub incident-extension,
+        plays event-ext:event-spec;
+    # event extension embedded relation
+    event-ext sub extensions,
+        relates event-base as sco,
+        relates event-spec as extension;
+
+    # base impact extension object
+    impact-extension sub incident-extension,
+        plays impact-ext:impact-spec;
+    # base impact extension embedded relation
+    impact-ext sub extensions,
+        relates impact-base as sco,
+        relates impact-spec as extension;
+
+    # availability-impact extension object
+    availability sub incident-extension,
+        owns impacted-availability,
+        plays availability-ext:availability-impact;
+    # availability-impact extension embedded relation
+    availability-ext sub extensions,
+        relates impact-base as sco,
+        relates availability-impact as extension;
+
+    # confidentiality-impact extension object
+    confidentiality sub incident-extension,
+        owns information-type,
+        owns loss-type,
+        owns record-count,
+        owns record-size,
+        plays confidentiality-ext:confidentiality-impact;
+    # confidentiality-impact extension embedded relation
+    confidentiality-ext sub extensions,
+        relates impact-base as sco,
+        relates confidentiality-impact as extension;
+
+    # external-impact extension object
+    external sub incident-extension,
+        owns impact-type,
+        plays external-ext:external-impact;
+    # external-impact extension embedded relation
+     external-ext sub extensions,
+        relates impact-base as sco,
+        relates external-impact as extension;
+
+    # integrity-impact extension object
+    integrity sub incident-extension,
+        owns alteration,
+        owns information-type,
+        owns record-count,
+        owns record-size,
+        plays integrity-ext:integrity-impact;
+    # integrity-impact extension embedded relation
+    integrity-ext sub extensions,
+        relates impact-base as sco,
+        relates integrity-impact as extension;
+
+    # monetary-impact extension object
+    monetary sub incident-extension,
+        owns variety,
+        owns conversion-rate,
+        owns conversion-time,
+        owns currrency,
+        owns currency-actual,
+        owns max-amount,
+        owns min-amount,
+        plays monetary-ext:monetary-impact;
+    # monetary-impact extension embedded relation
+    monetary-ext sub extensions,
+        relates impact-base as sco,
+        relates monetary-impact as extension;
+
+    # physical-impact extension object
+    physical sub incident-extension,
+        owns impact-type,
+        owns asset-type,
+        plays physical-ext:physical-impact;
+    # physical-impact extension embedded relation
+    physical-ext sub extensions,
+        relates impact-base as sco,
+        relates physical-impact as extension;
+
+    # traceability-impact extension object
+    traceability sub incident-extension,
+        owns traceability-type,
+        plays traceability-ext:traceability-impact;
+    # traceability-impact extension embedded relation
+    traceability-ext sub extensions,
+        relates impact-base as sco,
+        relates traceability-impact as extension;
+
+    # Incident SRO's
+    led-to sub stix-core-relationship,
+		relates initial as source,
+		relates subsequent as target;
+
+    impacts sub stix-core-relationship,
+		relates issue as source,
+		relates impacted as target;
+
+    contact-for sub stix-core-relationship,
+		relates contact as source,
+		relates issue as target;
+
+    detected sub stix-core-relationship,
+		relates method as source,
+		relates issue as target;
+
+	performed sub stix-core-relationship,
+	    relates initiator as source,
+	    relates outcome as target;
+
+    blocks sub stix-core-relationship,
+		relates effort as source,
+		relates stops as target;
+
+    causes sub stix-core-relationship,
+		relates effort as source,
+		relates caused as target;
+
+    detects sub stix-core-relationship,
+		relates effort as source,
+		relates found as target;
+
+    creates sub stix-core-relationship,
+		relates effort as source,
+		relates made as target;
+
+    errored-to sub stix-core-relationship,
+		relates started as source,
+		relates on-error as target;
+
+    followed-by sub stix-core-relationship,
+		relates initial as source,
+		relates subsequent as target;
+
+    assigned sub stix-core-relationship,
+		relates owner as source,
+		relates effort as target;
+
+    participated-in sub stix-core-relationship,
+		relates contact as source,
+		relates assisted as target;
+
+    derived-from sub stix-core-relationship,
+		relates result as source,
+		relates raw-material as target;
+
+    # Incident Relationhs
+    sighting
+        plays list-of-sightings:sights;
+
+    # Incident Embedded Relations
+    list-of-sightings sub embedded,
+        relates sighting-event as owner,
+        relates sights as pointed-to;
+
+    subevents sub embedded,
+        relates parent as owner,
+        relates sub-event as pointed-to;
+
+    objects-changed sub embedded,
+        relates change-driver as owner,
+        relates object-list as pointed-to;
+
+    changed-objects-initial sub embedded,
+        relates changed-objects as owner,
+        relates changed as pointed-to;
+
+    changed-objects-result sub embedded,
+        relates changed-objects as owner,
+        relates changed as pointed-to;
+
+    impact-counter sub embedded,
+        relates impact-driver as owner,
+        relates counters as pointed-to;
+
+    impacted-refs sub embedded,
+        relates the-impact as owner,
+        relates impacted-thing as pointed-to;
+
+    superseded sub embedded,
+        relates superseded-by as pointed-to,
+        relates precedes as owner;
+
+    on-completion sub embedded,
+        relates source as owner,
+        relates target as pointed-to;
+
+    on-success sub embedded,
+        relates source as owner,
+        relates target as pointed-to;
+
+    on-failure sub embedded,
+        relates source as owner,
+        relates target as pointed-to;
+
+    next-steps sub embedded,
+        relates source as owner,
+        relates target as pointed-to;
+
+    owned-by sub embedded,
+        relates owned as owner,
+        relates who as pointed-to;
+
+    scores sub embedded,
+        relates scored as owner,
+        relates score as pointed-to;
+
+    task-refs sub embedded,
+        relates incident as owner,
+        relates the-task as pointed-to;
+
+    event-refs sub embedded,
+        relates incident as owner,
+        relates the-event as pointed-to;
+
+    evidence-refs sub embedded,
+        relates incident as owner,
+        relates the-evidence as pointed-to;
+
+    notes-refs sub embedded,
+        relates incident as owner,
+        relates the-note as pointed-to;
+
+    impact-refs sub embedded,
+        relates incident as owner,
+        relates the-impact as pointed-to;
+
+    # Feed Embedded Relations
+    list-of-feeds sub embedded,
+		relates feed-list-owner as owner,
+		relates single-feed as pointed-to;
+
+    feed-content sub embedded,
+		relates feed-owner as owner,
+		relates content as pointed-to;
+
+    # Feeds Collection Object
+    feeds sub stix-domain-object,
+        owns name,
+        owns description,
+        owns paid,
+        owns free,
+        plays list-of-feeds:feed-list-owner;
+
+    # Individual Feed Object
+    feed sub stix-domain-object,
+        owns name,
+        owns description,
+        owns paid,
+        owns free,
+        plays list-of-feeds:single-feed,
+        plays feed-content:feed-owner;
+
+    # Sub Object Reference, sub object includes created and modified
+    threat-sub-object sub stix-sub-object,
+        plays obj-refs:object,
+        plays obj-ref:container,
+        plays feed-content:content;
+
+	# Feed and Incident Contained References, can contain SDO, SCO or SRO, or Meta
+	stix-domain-object
+	    plays feed-content:content,
+	    plays obj-ref:content,
+	    plays changed-objects-initial:changed,
+	    plays changed-objects-result:changed,
+	    plays impacted-refs:impacted-thing;
+
+	stix-cyber-observable-object
+	    plays feed-content:content,
+	    plays obj-ref:content,
+	    plays impacted-refs:impacted-thing,
+	    plays impacts:impacted;
+
+	stix-core-relationship
+	    plays feed-content:content;
+
+    marking-definition
+	    plays feed-content:content;
+
+	identity
+	    plays owned-by:who,
+	    plays impacts:impacted,
+	    plays contact-for:contact,
+        plays assigned:owner,
+        plays participated-in:contact;
+
+	infrastructure
+	    plays impacts:impacted;
+
+	note
+	    plays notes-refs:the-note;
+
+	incident
+	    plays  occurence-ext:occurence,
+	    plays led-to:initial,
+	    plays led-to:subsequent,
+	    plays impacts:issue,
+	    plays contact-for:issue,
+	    plays detected:issue;
+
+    indicator
+        plays detected:method,
+        plays creates:made;
+
+    malware
+        plays performed:initiator;
+
+    tool
+        plays performed:initiator;
+
+    report
+        plays derived-from:result;
+
+    # Attribute Definitions
+    paid sub stix-attribute-boolean;
+    free sub stix-attribute-boolean;
+    malicious sub stix-attribute-boolean;
+    blocked sub stix-attribute-boolean;
+
+    status sub stix-attribute-string;
+    end-time-fidelity sub stix-attribute-string;
+    start-time-fidelity sub stix-attribute-string;
+    event-types sub stix-attribute-string;
+    goal sub stix-attribute-string;
+    detection-emthods sub stix-attribute-string;
+    detection-system sub stix-attribute-string;
+    detection-rule sub stix-attribute-string;
+    state-change-type sub stix-attribute-string;
+    impact-category sub stix-attribute-string;
+    recoverability sub stix-attribute-string;
+    information-type sub stix-attribute-string;
+    loss-type sub stix-attribute-string;
+    impact-type sub stix-attribute-string;
+    alteration sub stix-attribute-string;
+    variety sub stix-attribute-string;
+    currrency sub stix-attribute-string;
+    currency-actual sub stix-attribute-string;
+    asset-type sub stix-attribute-string;
+    traceability-type sub stix-attribute-string;
+    evidence-type sub stix-attribute-string;
+    source sub stix-attribute-string;
+    outcome sub stix-attribute-string;
+    task-type sub stix-attribute-string;
+    step-type sub stix-attribute-string;
+    error sub stix-attribute-string;
+    determination sub stix-attribute-string;
+    extension-type sub stix-attribute-string;
+    investigation-status sub stix-attribute-string;
+    incident-types sub stix-attribute-string;
+
+
+    event-seq sub stix-attribute-integer;
+    individual-count sub stix-attribute-integer;
+    group-count sub stix-attribute-integer;
+    system-count sub stix-attribute-integer;
+    organization-count sub stix-attribute-integer;
+    class-count sub stix-attribute-integer;
+    unknown-count sub stix-attribute-integer;
+    criticality sub stix-attribute-integer;
+    record-count sub stix-attribute-integer;
+    record-size sub stix-attribute-integer;
+    impacted-availability sub stix-attribute-integer;
+    conversion-rate sub stix-attribute-integer;
+    max-amount sub stix-attribute-integer;
+    min-amount sub stix-attribute-integer;
+    score-value sub stix-attribute-integer;
+
+    end-time sub stix-attribute-timestamp;
+    conversion-time sub stix-attribute-timestamp;
+
+
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/property_definitions.py` & `stixorm-0.1.9/stixorm/module/definitions/property_definitions.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,240 +1,240 @@
-import json
-import os
-import uuid
-import copy
-from enum import Enum
-from typing import Optional
-from stix2.properties import Property
-from stix2.utils import STIXTypeClass
-from stix2.exceptions import CustomContentError
-from stix2.base import _STIXBase
-from stix2.properties import (
-    DictionaryProperty, ExtensionsProperty, IDProperty, IntegerProperty, ListProperty,
-    OpenVocabProperty, ReferenceProperty, StringProperty,
-    TimestampProperty, TypeProperty, EmbeddedObjectProperty, ObservableProperty
-)
-
-
-DEFAULT_VERSION = '2.1'
-ERROR_INVALID_ID = (
-    "not a valid STIX identifier, must match <object-type>--<UUID>: {}"
-)
-
-def get_ext_class(key, spec_version):
-    defin = Definitions()
-    list_of_ext = defin.sub_objects
-    for ext in list_of_ext:
-        if ext["type"] == key:
-            pass
-           # return os_threat_models[ext["class"]]
-
-
-
-# TODO: Kestrel was missing from original definition, does this need to be fixed?
-def get_libraries():
-    return ["stix", "attack", "os-threat", "cacao"]
-
-
-def get_type_from_id(stix_id):
-    return stix_id.split('--', 1)[0]
-
-
-def _check_uuid(uuid_str, spec_version):
-    """
-    Check whether the given UUID string is valid with respect to the given STIX
-    spec version.  STIX 2.0 requires UUIDv4; 2.1 only requires the RFC 4122
-    variant.
-    :param uuid_str: A UUID as a string
-    :param spec_version: The STIX spec version
-    :return: True if the UUID is valid, False if not
-    :raises ValueError: If uuid_str is malformed
-    """
-    uuid_obj = uuid.UUID(uuid_str)
-
-    ok = uuid_obj.variant == uuid.RFC_4122
-    if ok and spec_version == "2.0":
-        ok = uuid_obj.version == 4
-
-    return ok
-
-
-def _validate_id(id_, spec_version, required_prefix):
-    """
-    Check the STIX identifier for correctness, raise an exception if there are
-    errors.
-    :param id_: The STIX identifier
-    :param spec_version: The STIX specification version to use
-    :param required_prefix: The required prefix on the identifier, if any.
-        This function doesn't add a "--" suffix to the prefix, so callers must
-        add it if it is important.  Pass None to skip the prefix check.
-    :raises ValueError: If there are any errors with the identifier
-    """
-    if required_prefix:
-        if not id_.startswith(required_prefix):
-            raise ValueError("must start with '{}'.".format(required_prefix))
-
-    try:
-        if required_prefix:
-            uuid_part = id_[len(required_prefix):]
-        else:
-            idx = id_.index("--")
-            uuid_part = id_[idx+2:]
-
-        result = _check_uuid(uuid_part, spec_version)
-    except ValueError:
-        # replace their ValueError with ours
-        raise ValueError(ERROR_INVALID_ID.format(id_))
-
-    if not result:
-        raise ValueError(ERROR_INVALID_ID.format(id_))
-
-
-def is_stix_type(obj_type, spec_version, valid_types):
-    if obj_type in valid_types:
-        return True
-    else:
-        return False
-
-
-class ThreatReference(Property):
-
-    _WHITELIST, _BLACKLIST = range(2)
-
-    def __init__(self, valid_types=None, invalid_types=None, spec_version=DEFAULT_VERSION, **kwargs):
-        """
-        references sometimes must be to a specific object type
-        """
-        self.spec_version = spec_version
-
-        if (valid_types is not None and invalid_types is not None) or \
-                (valid_types is None and invalid_types is None):
-            raise ValueError(
-                "Exactly one of 'valid_types' and 'invalid_types' must be "
-                "given",
-            )
-
-        if valid_types and not isinstance(valid_types, list):
-            valid_types = [valid_types]
-        elif invalid_types and not isinstance(invalid_types, list):
-            invalid_types = [invalid_types]
-
-        if valid_types is not None and len(valid_types) == 0:
-            raise ValueError("Impossible type constraint: empty whitelist")
-
-        # Divide type requirements into generic type classes and specific
-        # types.  With respect to strings, values recognized as STIXTypeClass
-        # enum names are generic; all else are specifics.
-        self.valid_types = valid_types
-        self.invalid_types = invalid_types
-
-        super(ThreatReference, self).__init__(**kwargs)
-
-    def clean(self, value, allow_custom):
-        if isinstance(value, _STIXBase):
-            value = value.id
-        value = str(value)
-
-        _validate_id(value, self.spec_version, None)
-
-        obj_type = get_type_from_id(value)
-
-        type_ok = is_stix_type(obj_type, self.spec_version, self.valid_types)
-
-        if not type_ok:
-            raise ValueError(
-                "The type-specifying prefix '%s' for this property is %s"
-                % obj_type,
-            )
-
-        return value, allow_custom
-
-
-
-def _get_dict(data):
-    """Return data as a dictionary.
-
-    Input can be a dictionary, string, or file-like object.
-    """
-
-    if type(data) is dict:
-        return data
-    else:
-        try:
-            return json.loads(data)
-        except TypeError:
-            pass
-        try:
-            return json.load(data)
-        except AttributeError:
-            pass
-        try:
-            return dict(data)
-        except (ValueError, TypeError):
-            raise ValueError("Cannot convert '%s' to dictionary." % str(data))
-
-
-class ThreatExtensionsProperty(DictionaryProperty):
-    """Property for representing extensions on Observable objects.
-    """
-
-    def __init__(self, spec_version=DEFAULT_VERSION, required=False):
-        super(ThreatExtensionsProperty, self).__init__(spec_version=spec_version, required=required)
-
-    def clean(self, value, allow_custom):
-        try:
-            dictified = _get_dict(value)
-            # get deep copy since we are going modify the dict and might
-            # modify the original dict as _get_dict() does not return new
-            # dict when passed a dict
-            dictified = copy.deepcopy(dictified)
-        except ValueError:
-            raise ValueError("The extensions property must contain a dictionary")
-
-        has_custom = False
-        for key, subvalue in dictified.items():
-            cls = get_ext_class(key, self.spec_version)
-            if cls:
-                if isinstance(subvalue, dict):
-                    ext = cls(allow_custom=False, **subvalue)
-                elif isinstance(subvalue, cls):
-                    # If already an instance of the registered class, assume
-                    # it's valid
-                    ext = subvalue
-                else:
-                    raise TypeError(
-                        "Can't create extension '{}' from {}.".format(
-                            key, type(subvalue),
-                        ),
-                    )
-
-                has_custom = has_custom or ext.has_custom
-
-                if not allow_custom and has_custom:
-                    raise CustomContentError(
-                        "custom content found in {} extension".format(
-                            key,
-                        ),
-                    )
-
-                dictified[key] = ext
-
-            else:
-                # If an unregistered "extension-definition--" style extension,
-                # we don't know what's supposed to be in it, so we can't
-                # determine whether there's anything custom.  So, assume there
-                # are no customizations.  If it's a different type of extension,
-                # non-registration implies customization (since all spec-defined
-                # extensions should be pre-registered with the library).
-
-                if key.startswith('extension-definition--'):
-                    _validate_id(
-                        key, self.spec_version, 'extension-definition--',
-                    )
-                elif allow_custom:
-                    has_custom = True
-                else:
-                    raise CustomContentError("Can't parse unknown extension type: {}".format(key))
-
-                dictified[key] = subvalue
-
-        return dictified, has_custom
+import json
+import os
+import uuid
+import copy
+from enum import Enum
+from typing import Optional
+from stix2.properties import Property
+from stix2.utils import STIXTypeClass
+from stix2.exceptions import CustomContentError
+from stix2.base import _STIXBase
+from stix2.properties import (
+    DictionaryProperty, ExtensionsProperty, IDProperty, IntegerProperty, ListProperty,
+    OpenVocabProperty, ReferenceProperty, StringProperty,
+    TimestampProperty, TypeProperty, EmbeddedObjectProperty, ObservableProperty
+)
+
+
+DEFAULT_VERSION = '2.1'
+ERROR_INVALID_ID = (
+    "not a valid STIX identifier, must match <object-type>--<UUID>: {}"
+)
+
+def get_ext_class(key, spec_version):
+    defin = Definitions()
+    list_of_ext = defin.sub_objects
+    for ext in list_of_ext:
+        if ext["type"] == key:
+            pass
+           # return os_threat_models[ext["class"]]
+
+
+
+# TODO: Kestrel was missing from original definition, does this need to be fixed?
+def get_libraries():
+    return ["stix", "attack", "os-threat", "cacao"]
+
+
+def get_type_from_id(stix_id):
+    return stix_id.split('--', 1)[0]
+
+
+def _check_uuid(uuid_str, spec_version):
+    """
+    Check whether the given UUID string is valid with respect to the given STIX
+    spec version.  STIX 2.0 requires UUIDv4; 2.1 only requires the RFC 4122
+    variant.
+    :param uuid_str: A UUID as a string
+    :param spec_version: The STIX spec version
+    :return: True if the UUID is valid, False if not
+    :raises ValueError: If uuid_str is malformed
+    """
+    uuid_obj = uuid.UUID(uuid_str)
+
+    ok = uuid_obj.variant == uuid.RFC_4122
+    if ok and spec_version == "2.0":
+        ok = uuid_obj.version == 4
+
+    return ok
+
+
+def _validate_id(id_, spec_version, required_prefix):
+    """
+    Check the STIX identifier for correctness, raise an exception if there are
+    errors.
+    :param id_: The STIX identifier
+    :param spec_version: The STIX specification version to use
+    :param required_prefix: The required prefix on the identifier, if any.
+        This function doesn't add a "--" suffix to the prefix, so callers must
+        add it if it is important.  Pass None to skip the prefix check.
+    :raises ValueError: If there are any errors with the identifier
+    """
+    if required_prefix:
+        if not id_.startswith(required_prefix):
+            raise ValueError("must start with '{}'.".format(required_prefix))
+
+    try:
+        if required_prefix:
+            uuid_part = id_[len(required_prefix):]
+        else:
+            idx = id_.index("--")
+            uuid_part = id_[idx+2:]
+
+        result = _check_uuid(uuid_part, spec_version)
+    except ValueError:
+        # replace their ValueError with ours
+        raise ValueError(ERROR_INVALID_ID.format(id_))
+
+    if not result:
+        raise ValueError(ERROR_INVALID_ID.format(id_))
+
+
+def is_stix_type(obj_type, spec_version, valid_types):
+    if obj_type in valid_types:
+        return True
+    else:
+        return False
+
+
+class ThreatReference(Property):
+
+    _WHITELIST, _BLACKLIST = range(2)
+
+    def __init__(self, valid_types=None, invalid_types=None, spec_version=DEFAULT_VERSION, **kwargs):
+        """
+        references sometimes must be to a specific object type
+        """
+        self.spec_version = spec_version
+
+        if (valid_types is not None and invalid_types is not None) or \
+                (valid_types is None and invalid_types is None):
+            raise ValueError(
+                "Exactly one of 'valid_types' and 'invalid_types' must be "
+                "given",
+            )
+
+        if valid_types and not isinstance(valid_types, list):
+            valid_types = [valid_types]
+        elif invalid_types and not isinstance(invalid_types, list):
+            invalid_types = [invalid_types]
+
+        if valid_types is not None and len(valid_types) == 0:
+            raise ValueError("Impossible type constraint: empty whitelist")
+
+        # Divide type requirements into generic type classes and specific
+        # types.  With respect to strings, values recognized as STIXTypeClass
+        # enum names are generic; all else are specifics.
+        self.valid_types = valid_types
+        self.invalid_types = invalid_types
+
+        super(ThreatReference, self).__init__(**kwargs)
+
+    def clean(self, value, allow_custom):
+        if isinstance(value, _STIXBase):
+            value = value.id
+        value = str(value)
+
+        _validate_id(value, self.spec_version, None)
+
+        obj_type = get_type_from_id(value)
+
+        type_ok = is_stix_type(obj_type, self.spec_version, self.valid_types)
+
+        if not type_ok:
+            raise ValueError(
+                "The type-specifying prefix '%s' for this property is %s"
+                % obj_type,
+            )
+
+        return value, allow_custom
+
+
+
+def _get_dict(data):
+    """Return data as a dictionary.
+
+    Input can be a dictionary, string, or file-like object.
+    """
+
+    if type(data) is dict:
+        return data
+    else:
+        try:
+            return json.loads(data)
+        except TypeError:
+            pass
+        try:
+            return json.load(data)
+        except AttributeError:
+            pass
+        try:
+            return dict(data)
+        except (ValueError, TypeError):
+            raise ValueError("Cannot convert '%s' to dictionary." % str(data))
+
+
+class ThreatExtensionsProperty(DictionaryProperty):
+    """Property for representing extensions on Observable objects.
+    """
+
+    def __init__(self, spec_version=DEFAULT_VERSION, required=False):
+        super(ThreatExtensionsProperty, self).__init__(spec_version=spec_version, required=required)
+
+    def clean(self, value, allow_custom):
+        try:
+            dictified = _get_dict(value)
+            # get deep copy since we are going modify the dict and might
+            # modify the original dict as _get_dict() does not return new
+            # dict when passed a dict
+            dictified = copy.deepcopy(dictified)
+        except ValueError:
+            raise ValueError("The extensions property must contain a dictionary")
+
+        has_custom = False
+        for key, subvalue in dictified.items():
+            cls = get_ext_class(key, self.spec_version)
+            if cls:
+                if isinstance(subvalue, dict):
+                    ext = cls(allow_custom=False, **subvalue)
+                elif isinstance(subvalue, cls):
+                    # If already an instance of the registered class, assume
+                    # it's valid
+                    ext = subvalue
+                else:
+                    raise TypeError(
+                        "Can't create extension '{}' from {}.".format(
+                            key, type(subvalue),
+                        ),
+                    )
+
+                has_custom = has_custom or ext.has_custom
+
+                if not allow_custom and has_custom:
+                    raise CustomContentError(
+                        "custom content found in {} extension".format(
+                            key,
+                        ),
+                    )
+
+                dictified[key] = ext
+
+            else:
+                # If an unregistered "extension-definition--" style extension,
+                # we don't know what's supposed to be in it, so we can't
+                # determine whether there's anything custom.  So, assume there
+                # are no customizations.  If it's a different type of extension,
+                # non-registration implies customization (since all spec-defined
+                # extensions should be pre-registered with the library).
+
+                if key.startswith('extension-definition--'):
+                    _validate_id(
+                        key, self.spec_version, 'extension-definition--',
+                    )
+                elif allow_custom:
+                    has_custom = True
+                else:
+                    raise CustomContentError("Can't parse unknown extension type: {}".format(key))
+
+                dictified[key] = subvalue
+
+        return dictified, has_custom
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/stix21/__init__.py` & `stixorm-0.1.9/stixorm/module/definitions/stix21/__init__.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,117 +1,117 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-"""
-Loader module for all STIX data model
-"""
-
-__author__ = "Paolo Di Prodi"
-__credits__ = ["Brett Forbes"]
-__license__ = "GPL"
-__version__ = "0.1.0"
-__maintainer__ = "Paolo Di Prodi"
-__email__ = "paolo@priam.ai"
-__status__ = "Production"
-
-import json
-from glob import glob
-
-import pathlib
-from loguru import logger
-import os
-from pathlib import Path
-from stixorm.module.definitions.stix21.classes import (
-    Note, ObservedData, Incident, Report
-)
-from stix2.v21.sdo import (
-    AttackPattern, Campaign, CourseOfAction, CustomObject, Grouping, Identity,
-    Indicator, Infrastructure, IntrusionSet, Location, Malware,
-    MalwareAnalysis, Opinion, ThreatActor, Tool,
-    Vulnerability,
-)
-from stix2.v21.observables import (
-    URL, AlternateDataStream, ArchiveExt, Artifact, AutonomousSystem,
-    CustomObservable, Directory, DomainName, EmailAddress, EmailMessage,
-    EmailMIMEComponent, File, HTTPRequestExt, ICMPExt, IPv4Address,
-    IPv6Address, MACAddress, Mutex, NetworkTraffic, NTFSExt, PDFExt, Process,
-    RasterImageExt, SocketExt, Software, TCPExt, UNIXAccountExt, UserAccount,
-    WindowsPEBinaryExt, WindowsPEOptionalHeaderType, WindowsPESection,
-    WindowsProcessExt, WindowsRegistryKey, WindowsRegistryValueType,
-    WindowsServiceExt, X509Certificate, X509V3ExtensionsType,
-)
-from stix2.v21.sro import Relationship, Sighting
-from stix2.v21.common import MarkingDefinition
-
-name = "stix21"
-class_model = {}
-class_model["sro"] = {
-    "Relationship": Relationship,
-    "Sighting": Sighting
-}
-class_model["sdo"] = {
-    "AttackPattern":AttackPattern,
-    "Campaign":Campaign,
-    "CourseOfAction":CourseOfAction,
-    "CustomObject":CustomObject,
-    "Grouping":Grouping,
-    "Identity":Identity,
-    "Incident":Incident,
-    "Indicator":Indicator,
-    "Infrastructure":Infrastructure,
-    "IntrusionSet":IntrusionSet,
-    "Location":Location,
-    "Malware":Malware,
-    "MalwareAnalysis":MalwareAnalysis,
-    "Note":Note,
-    "ObservedData":ObservedData,
-    "Opinion":Opinion,
-    "Report":Report,
-    "ThreatActor":ThreatActor,
-    "Tool":Tool,
-    "Vulnerability":Vulnerability,
-}
-class_model["sub"] = {
-    "AlternateDataStream":AlternateDataStream,
-    "ArchiveExt":ArchiveExt,
-    "EmailMIMEComponent": EmailMIMEComponent,
-    "HTTPRequestExt":HTTPRequestExt,
-    "ICMPExt":ICMPExt,
-    "NTFSExt":NTFSExt,
-    "PDFExt":PDFExt,
-    "RasterImageExt":RasterImageExt,
-    "SocketExt":SocketExt,
-    "TCPExt":TCPExt,
-    "UNIXAccountExt":UNIXAccountExt,
-    "WindowsPEBinaryExt":WindowsPEBinaryExt,
-    "WindowsPEOptionalHeaderType":WindowsPEOptionalHeaderType,
-    "WindowsPESection":WindowsPESection,
-    "WindowsProcessExt":WindowsProcessExt,
-    "WindowsRegistryValueType":WindowsRegistryValueType,
-    "WindowsServiceExt":WindowsServiceExt,
-    "X509V3ExtensionsType":X509V3ExtensionsType
-}
-class_model["sco"] = {
-    "URL":URL,
-    "Artifact":Artifact,
-    "AutonomousSystem":AutonomousSystem,
-    "CustomObservable":CustomObservable,
-    "Directory":Directory,
-    "DomainName":DomainName,
-    "EmailAddress":EmailAddress,
-    "EmailMessage":EmailMessage,
-    "File":File,
-    "IPv4Address":IPv4Address,
-    "IPv6Address":IPv6Address,
-    "MACAddress":MACAddress,
-    "Mutex":Mutex,
-    "NetworkTraffic":NetworkTraffic,
-    "Process":Process,
-    "Software":Software,
-    "UserAccount":UserAccount,
-    "WindowsRegistryKey":WindowsRegistryKey,
-    "X509Certificate":X509Certificate,
-}
-class_model["meta"] = {
-    "MarkingDefinition":MarkingDefinition
-}
-
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+"""
+Loader module for all STIX data model
+"""
+
+__author__ = "Paolo Di Prodi"
+__credits__ = ["Brett Forbes"]
+__license__ = "GPL"
+__version__ = "0.1.0"
+__maintainer__ = "Paolo Di Prodi"
+__email__ = "paolo@priam.ai"
+__status__ = "Production"
+
+import json
+from glob import glob
+
+import pathlib
+from loguru import logger
+import os
+from pathlib import Path
+from stixorm.module.definitions.stix21.classes import (
+    Note, ObservedData, Incident, Report
+)
+from stix2.v21.sdo import (
+    AttackPattern, Campaign, CourseOfAction, CustomObject, Grouping, Identity,
+    Indicator, Infrastructure, IntrusionSet, Location, Malware,
+    MalwareAnalysis, Opinion, ThreatActor, Tool,
+    Vulnerability,
+)
+from stix2.v21.observables import (
+    URL, AlternateDataStream, ArchiveExt, Artifact, AutonomousSystem,
+    CustomObservable, Directory, DomainName, EmailAddress, EmailMessage,
+    EmailMIMEComponent, File, HTTPRequestExt, ICMPExt, IPv4Address,
+    IPv6Address, MACAddress, Mutex, NetworkTraffic, NTFSExt, PDFExt, Process,
+    RasterImageExt, SocketExt, Software, TCPExt, UNIXAccountExt, UserAccount,
+    WindowsPEBinaryExt, WindowsPEOptionalHeaderType, WindowsPESection,
+    WindowsProcessExt, WindowsRegistryKey, WindowsRegistryValueType,
+    WindowsServiceExt, X509Certificate, X509V3ExtensionsType,
+)
+from stix2.v21.sro import Relationship, Sighting
+from stix2.v21.common import MarkingDefinition
+
+name = "stix21"
+class_model = {}
+class_model["sro"] = {
+    "Relationship": Relationship,
+    "Sighting": Sighting
+}
+class_model["sdo"] = {
+    "AttackPattern":AttackPattern,
+    "Campaign":Campaign,
+    "CourseOfAction":CourseOfAction,
+    "CustomObject":CustomObject,
+    "Grouping":Grouping,
+    "Identity":Identity,
+    "Incident":Incident,
+    "Indicator":Indicator,
+    "Infrastructure":Infrastructure,
+    "IntrusionSet":IntrusionSet,
+    "Location":Location,
+    "Malware":Malware,
+    "MalwareAnalysis":MalwareAnalysis,
+    "Note":Note,
+    "ObservedData":ObservedData,
+    "Opinion":Opinion,
+    "Report":Report,
+    "ThreatActor":ThreatActor,
+    "Tool":Tool,
+    "Vulnerability":Vulnerability,
+}
+class_model["sub"] = {
+    "AlternateDataStream":AlternateDataStream,
+    "ArchiveExt":ArchiveExt,
+    "EmailMIMEComponent": EmailMIMEComponent,
+    "HTTPRequestExt":HTTPRequestExt,
+    "ICMPExt":ICMPExt,
+    "NTFSExt":NTFSExt,
+    "PDFExt":PDFExt,
+    "RasterImageExt":RasterImageExt,
+    "SocketExt":SocketExt,
+    "TCPExt":TCPExt,
+    "UNIXAccountExt":UNIXAccountExt,
+    "WindowsPEBinaryExt":WindowsPEBinaryExt,
+    "WindowsPEOptionalHeaderType":WindowsPEOptionalHeaderType,
+    "WindowsPESection":WindowsPESection,
+    "WindowsProcessExt":WindowsProcessExt,
+    "WindowsRegistryValueType":WindowsRegistryValueType,
+    "WindowsServiceExt":WindowsServiceExt,
+    "X509V3ExtensionsType":X509V3ExtensionsType
+}
+class_model["sco"] = {
+    "URL":URL,
+    "Artifact":Artifact,
+    "AutonomousSystem":AutonomousSystem,
+    "CustomObservable":CustomObservable,
+    "Directory":Directory,
+    "DomainName":DomainName,
+    "EmailAddress":EmailAddress,
+    "EmailMessage":EmailMessage,
+    "File":File,
+    "IPv4Address":IPv4Address,
+    "IPv6Address":IPv6Address,
+    "MACAddress":MACAddress,
+    "Mutex":Mutex,
+    "NetworkTraffic":NetworkTraffic,
+    "Process":Process,
+    "Software":Software,
+    "UserAccount":UserAccount,
+    "WindowsRegistryKey":WindowsRegistryKey,
+    "X509Certificate":X509Certificate,
+}
+class_model["meta"] = {
+    "MarkingDefinition":MarkingDefinition
+}
+
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/stix21/classes.py` & `stixorm-0.1.9/stixorm/module/definitions/stix21/classes.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,174 +1,174 @@
-"""Python Mitre ATT&CK Stix Class Definitions """
-from stixorm.module.typedb_lib.factories.mappings_factory import get_mapping_factory_instance
-
-"""Python Mitre ATT&CK Stix Class Definitions """
-import json
-import pathlib
-import warnings
-from collections import OrderedDict
-
-from stix2.exceptions import (
-    PropertyPresenceError, STIXDeprecationWarning, )
-from stix2.properties import (
-    BooleanProperty, ExtensionsProperty, IDProperty, IntegerProperty, ListProperty,
-    OpenVocabProperty, ReferenceProperty, StringProperty,
-    TimestampProperty, TypeProperty, EmbeddedObjectProperty, ObservableProperty
-)
-from stix2.utils import NOW, _get_dict
-from stix2.markings import _MarkingsMixin
-from stix2.markings.utils import check_tlp_marking
-from stix2.v21.base import _DomainObject, _STIXBase21, _RelationshipObject
-from stix2.v21.common import (
-    ExternalReference, GranularMarking, KillChainPhase,
-    MarkingProperty, TLPMarking, StatementMarking,
-)
-from stix2.v21.vocab import (
-    ATTACK_MOTIVATION, ATTACK_RESOURCE_LEVEL, IMPLEMENTATION_LANGUAGE, MALWARE_CAPABILITIES, MALWARE_TYPE,
-    PROCESSOR_ARCHITECTURE, TOOL_TYPE, IDENTITY_CLASS, INDUSTRY_SECTOR, REPORT_TYPE
-)
-
-import logging
-
-from stixorm.module.definitions.property_definitions import ThreatReference, ThreatExtensionsProperty
-
-
-logger = logging.getLogger(__name__)
-
-valid_obj =  get_mapping_factory_instance().get_all_types()
-
-
-class Note(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the STIX 2.1 specification <https://docs.oasis-open.org/cti/stix/v2.1/os/stix-v2.1-os.html#_gudodcg1sbb9>`__.
-    """
-
-    _type = 'note'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('abstract', StringProperty()),
-        ('content', StringProperty(required=True)),
-        ('authors', ListProperty(StringProperty)),
-        ('object_refs', ListProperty(ThreatReference(valid_types=valid_obj, spec_version='2.1'), required=True)),
-        ('revoked', BooleanProperty(default=lambda: False)),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ExtensionsProperty(spec_version='2.1')),
-    ])
-
-
-class ObservedData(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the STIX 2.1 specification <https://docs.oasis-open.org/cti/stix/v2.1/os/stix-v2.1-os.html#_p49j1fwoxldc>`__.
-    """
-
-    _type = 'observed-data'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('first_observed', TimestampProperty(required=True)),
-        ('last_observed', TimestampProperty(required=True)),
-        ('number_observed', IntegerProperty(min=1, max=999999999, required=True)),
-        ('objects', ObservableProperty(spec_version='2.1')),
-        ('object_refs', ListProperty(ThreatReference(valid_types=valid_obj, spec_version='2.1'), required=True)),
-        ('revoked', BooleanProperty(default=lambda: False)),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ExtensionsProperty(spec_version='2.1')),
-    ])
-
-    def __init__(self, *args, **kwargs):
-
-        if "objects" in kwargs:
-            warnings.warn(
-                "The 'objects' property of observed-data is deprecated in "
-                "STIX 2.1.",
-                STIXDeprecationWarning,
-            )
-
-        super(ObservedData, self).__init__(*args, **kwargs)
-
-    def _check_object_constraints(self):
-        super(ObservedData, self)._check_object_constraints()
-
-        first_observed = self.get('first_observed')
-        last_observed = self.get('last_observed')
-
-        if first_observed and last_observed and last_observed < first_observed:
-            msg = "{0.id} 'last_observed' must be greater than or equal to 'first_observed'"
-            raise ValueError(msg.format(self))
-
-        self._check_mutually_exclusive_properties(
-            ["objects", "object_refs"],
-        )
-
-class Incident(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the STIX 2.1 specification <https://docs.oasis-open.org/cti/stix/v2.1/os/stix-v2.1-os.html#_sczfhw64pjxt>`__.
-    """
-
-    _type = 'incident'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('name', StringProperty(required=True)),
-        ('description', StringProperty()),
-        ('kill_chain_phases', ListProperty(KillChainPhase)),
-        ('revoked', BooleanProperty(default=lambda: False)),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ThreatExtensionsProperty(spec_version='2.1')),
-    ])
-
-valid_obj =  get_mapping_factory_instance().get_all_types()
-class Report(_DomainObject):
-    """For more detailed information on this object's properties, see
-    `the STIX 2.1 specification <https://docs.oasis-open.org/cti/stix/v2.1/os/stix-v2.1-os.html#_n8bjzg1ysgdq>`__.
-    """
-
-    _type = 'report'
-    _properties = OrderedDict([
-        ('type', TypeProperty(_type, spec_version='2.1')),
-        ('spec_version', StringProperty(fixed='2.1')),
-        ('id', IDProperty(_type, spec_version='2.1')),
-        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
-        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
-        ('name', StringProperty(required=True)),
-        ('description', StringProperty()),
-        ('report_types', ListProperty(OpenVocabProperty(REPORT_TYPE))),
-        ('published', TimestampProperty(required=True)),
-        ('object_refs', ListProperty(ThreatReference(valid_types=valid_obj, spec_version='2.1'), required=True)),
-        ('revoked', BooleanProperty(default=lambda: False)),
-        ('labels', ListProperty(StringProperty)),
-        ('confidence', IntegerProperty()),
-        ('lang', StringProperty()),
-        ('external_references', ListProperty(ExternalReference)),
-        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
-        ('granular_markings', ListProperty(GranularMarking)),
-        ('extensions', ExtensionsProperty(spec_version='2.1')),
+"""Python Mitre ATT&CK Stix Class Definitions """
+from stixorm.module.typedb_lib.factories.mappings_factory import get_mapping_factory_instance
+
+"""Python Mitre ATT&CK Stix Class Definitions """
+import json
+import pathlib
+import warnings
+from collections import OrderedDict
+
+from stix2.exceptions import (
+    PropertyPresenceError, STIXDeprecationWarning, )
+from stix2.properties import (
+    BooleanProperty, ExtensionsProperty, IDProperty, IntegerProperty, ListProperty,
+    OpenVocabProperty, ReferenceProperty, StringProperty,
+    TimestampProperty, TypeProperty, EmbeddedObjectProperty, ObservableProperty
+)
+from stix2.utils import NOW, _get_dict
+from stix2.markings import _MarkingsMixin
+from stix2.markings.utils import check_tlp_marking
+from stix2.v21.base import _DomainObject, _STIXBase21, _RelationshipObject
+from stix2.v21.common import (
+    ExternalReference, GranularMarking, KillChainPhase,
+    MarkingProperty, TLPMarking, StatementMarking,
+)
+from stix2.v21.vocab import (
+    ATTACK_MOTIVATION, ATTACK_RESOURCE_LEVEL, IMPLEMENTATION_LANGUAGE, MALWARE_CAPABILITIES, MALWARE_TYPE,
+    PROCESSOR_ARCHITECTURE, TOOL_TYPE, IDENTITY_CLASS, INDUSTRY_SECTOR, REPORT_TYPE
+)
+
+import logging
+
+from stixorm.module.definitions.property_definitions import ThreatReference, ThreatExtensionsProperty
+
+
+logger = logging.getLogger(__name__)
+
+valid_obj =  get_mapping_factory_instance().get_all_types()
+
+
+class Note(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the STIX 2.1 specification <https://docs.oasis-open.org/cti/stix/v2.1/os/stix-v2.1-os.html#_gudodcg1sbb9>`__.
+    """
+
+    _type = 'note'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('abstract', StringProperty()),
+        ('content', StringProperty(required=True)),
+        ('authors', ListProperty(StringProperty)),
+        ('object_refs', ListProperty(ThreatReference(valid_types=valid_obj, spec_version='2.1'), required=True)),
+        ('revoked', BooleanProperty(default=lambda: False)),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ExtensionsProperty(spec_version='2.1')),
+    ])
+
+
+class ObservedData(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the STIX 2.1 specification <https://docs.oasis-open.org/cti/stix/v2.1/os/stix-v2.1-os.html#_p49j1fwoxldc>`__.
+    """
+
+    _type = 'observed-data'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('first_observed', TimestampProperty(required=True)),
+        ('last_observed', TimestampProperty(required=True)),
+        ('number_observed', IntegerProperty(min=1, max=999999999, required=True)),
+        ('objects', ObservableProperty(spec_version='2.1')),
+        ('object_refs', ListProperty(ThreatReference(valid_types=valid_obj, spec_version='2.1'), required=True)),
+        ('revoked', BooleanProperty(default=lambda: False)),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ExtensionsProperty(spec_version='2.1')),
+    ])
+
+    def __init__(self, *args, **kwargs):
+
+        if "objects" in kwargs:
+            warnings.warn(
+                "The 'objects' property of observed-data is deprecated in "
+                "STIX 2.1.",
+                STIXDeprecationWarning,
+            )
+
+        super(ObservedData, self).__init__(*args, **kwargs)
+
+    def _check_object_constraints(self):
+        super(ObservedData, self)._check_object_constraints()
+
+        first_observed = self.get('first_observed')
+        last_observed = self.get('last_observed')
+
+        if first_observed and last_observed and last_observed < first_observed:
+            msg = "{0.id} 'last_observed' must be greater than or equal to 'first_observed'"
+            raise ValueError(msg.format(self))
+
+        self._check_mutually_exclusive_properties(
+            ["objects", "object_refs"],
+        )
+
+class Incident(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the STIX 2.1 specification <https://docs.oasis-open.org/cti/stix/v2.1/os/stix-v2.1-os.html#_sczfhw64pjxt>`__.
+    """
+
+    _type = 'incident'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('name', StringProperty(required=True)),
+        ('description', StringProperty()),
+        ('kill_chain_phases', ListProperty(KillChainPhase)),
+        ('revoked', BooleanProperty(default=lambda: False)),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ThreatExtensionsProperty(spec_version='2.1')),
+    ])
+
+valid_obj =  get_mapping_factory_instance().get_all_types()
+class Report(_DomainObject):
+    """For more detailed information on this object's properties, see
+    `the STIX 2.1 specification <https://docs.oasis-open.org/cti/stix/v2.1/os/stix-v2.1-os.html#_n8bjzg1ysgdq>`__.
+    """
+
+    _type = 'report'
+    _properties = OrderedDict([
+        ('type', TypeProperty(_type, spec_version='2.1')),
+        ('spec_version', StringProperty(fixed='2.1')),
+        ('id', IDProperty(_type, spec_version='2.1')),
+        ('created_by_ref', ReferenceProperty(valid_types='identity', spec_version='2.1')),
+        ('created', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('modified', TimestampProperty(default=lambda: NOW, precision='millisecond', precision_constraint='min')),
+        ('name', StringProperty(required=True)),
+        ('description', StringProperty()),
+        ('report_types', ListProperty(OpenVocabProperty(REPORT_TYPE))),
+        ('published', TimestampProperty(required=True)),
+        ('object_refs', ListProperty(ThreatReference(valid_types=valid_obj, spec_version='2.1'), required=True)),
+        ('revoked', BooleanProperty(default=lambda: False)),
+        ('labels', ListProperty(StringProperty)),
+        ('confidence', IntegerProperty()),
+        ('lang', StringProperty()),
+        ('external_references', ListProperty(ExternalReference)),
+        ('object_marking_refs', ListProperty(ReferenceProperty(valid_types='marking-definition', spec_version='2.1'))),
+        ('granular_markings', ListProperty(GranularMarking)),
+        ('extensions', ExtensionsProperty(spec_version='2.1')),
     ])
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/stix21/data/user-account.json` & `stixorm-0.1.9/stixorm/module/definitions/stix21/data/user-account.json`

 * *Files identical despite different names*

### Comparing `stixorm-0.1.3/stixorm/module/definitions/stix21/definitions.py` & `stixorm-0.1.9/stixorm/module/definitions/stix21/definitions.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,1228 +1,1228 @@
-##################################################
-# 2. Dispatch Dicts to convert between:
-#      - Stix2 Object Property Name --> TypeQL Name
-#      - Stix 2 Object Type --> Dict Name
-###################################################
-
-#---------------------------------------------------
-# 2.1) Stix Domain Object Dicts
-#---------------------------------------------------
-sdo_typeql_dict = {
-  "type" :  "stix-type",
-  "spec_version" : "spec-version",
-  "id"  : "stix-id",
-  "created_by_ref"  : "",
-  "created"  : "created",
-  "modified" : "modified",
-  "revoked"  : "revoked",
-  "labels"  : "labels",
-  "confidence"  : "confidence",
-  "lang"  : "langs",
-  "external_references"  : "",
-  "object_marking_refs"  : "",
-  "granular_markings"  : "",
-  "extensions"  : ""
-}
-
-attack_pattern_typeql_dict = {
-  "name": "name",
-  "description": "description",
-  "aliases": "aliases",
-  "kill_chain_phases": ""
-}
-
-campaign_typeql_dict = {
-  "name": "name",
-  "description": "description",
-  "aliases": "aliases",
-  "first_seen": "first-seen",
-  "last_seen": "last-seen",
-  "objective": "objective"
-}
-
-grouping_typeql_dict = {
-  "name": "name",
-  "description": "description",
-  "context": "context",
-  "object_refs": ""
-}
-
-course_of_action_typeql_dict = {
-  "name": "name",
-  "description": "description",	
-  "action": "action"
-}
-
-identity_typeql_dict = {
-  "name" :  "name",
-  "description" :  "description",
-  "roles" :  "stix-role",
-  "identity_class" :  "identity-class",
-  "sectors" :  "sector",
-  "contact_information" :  "contact-information"
-}
-
-incident_typeql_dict = {
-  "name": "name",
-  "description": "description",
-}
-
-indicator_typeql_dict = {
-  "name": "name",
-  "description": "description",
-  "pattern_version": "pattern-version",
-  "indicator_types": "indicator-type",
-  "pattern": "pattern",
-  "pattern_type": "pattern-type",
-  "valid_from": "valid-from",
-  "valid_until": "valid-until",
-  "kill_chain_phases": ""
-}
-
-infrastructure_typeql_dict = {
-  "name": "name",
-  "description": "description",
-  "infrastructure_types": "infrastructure-types",
-  "aliases": "aliases",
-  "kill_chain_phases": "",
-  "first_seen": "first-seen",
-  "last_seen": "last-seen"
-}
-
-intrusion_set_typeql_dict = {
-  "name": "name",
-  "description": "description",
-  "aliases": "aliases",
-  "first_seen": "first-seen",
-  "last_seen": "last-seen",
-  "goals": "goals",
-  "resource_level": "resource-level",
-  "primary_motivation": "primary-motivation",
-  "secondary_motivations": "secondary-motivations"
-}
-
-location_typeql_dict = {
-  "name": "name",
-  "description": "description",
-  "latitude": "latitude",
-  "longitude": "longitude",
-  "precision": "precision",
-  "region": "region",
-  "country": "country",
-  "administrative_area": "administrative-area",
-  "city": "city",
-  "street_address": "street-address",
-  "postal_code": "postal-code"
-}
-
-malware_typeql_dict = {
-  "name": "name",	
-  "description": "description",
-  "malware_types": "malware-types",
-  "is_family": "is-family",
-  "aliases": "aliases",
-  "kill_chain_phases": "",
-  "first_seen": "first-seen",
-  "last_seen": "last-seen",
-  "operating_system_refs": "",
-  "architecture_execution_envs": "architecture-execution-envs",
-  "implementation_languages": "implementation-languages",
-  "capabilities": "capabilities",
-  "sample_refs": ""
-}
-
-malware_analysis_typeql_dict = {
-  "product": "product",
-  "version": "version",
-  "host_vm_ref": "",
-  "operating_system_ref": "",
-  "installed_software_refs": "",
-  "configuration_version": "configuration-version",
-  "modules": "modules",
-  "analysis_engine_version": "analysis-engine-version",
-  "analysis_definition_version": "analysis-definition-version",
-  "submitted": "submitted",
-  "analysis_started": "analysis-started",
-  "analysis_ended": "analysis-ended",
-  "result_name": "result-name",
-  "result": "result",
-  "analysis_sco_refs": "",
-  "sample_ref": ""
-}
-
-note_type_dict = {
-  "abstract": "abstract",
-  "content": "content",
-  "authors": "authors",
-  "object_refs": ""
-}
-
-observed_data_typeql_dict = {
-  "first_observed": "first-observed",
-  "last_observed": "last-observed",
-  "number_observed": "number-observed",
-  "object_refs": ""
-}
-
-opinion_typeql_dict = {
-  "explanation": "explanation",
-  "authors": "authors",
-  "opinion": "opinion-enum",
-  "object_refs": ""
-}
-
-report_typeql_dict = {
-  "name": "name",
-  "description": "description",
-  "report_types": "report-type",
-  "published": "published",
-  "object_refs": ""
-}
-
-threat_actor_typeql_dict = {        
-  "name"  : "name",
-  "description"  : "description",
-  "threat_actor_types"  : "threat-actor-type",
-  "aliases"  : "aliases",
-  "first_seen"  : "first-seen",
-  "last_seen"  : "last-seen",
-  "roles"  : "stix-role",
-  "goals"  : "goals",
-  "sophistication"  : "sophistication",
-  "resource_level"  : "resource-level",
-  "primary_motivation"  : "primary-motivation",
-  "secondary_motivations"  : "secondary-motivations",
-  "personal_motivations"  : "personal-motivations"        
-}
-
-tool_typeql_dict = {
-  "name": "name",
-  "description": "description",
-  "tool_types": "tool-type",
-  "aliases": "aliases",
-  "kill_chain_phases": "",
-  "tool_version": "tool-version"
-}
-
-vulnerability_typeql_dict = {
-  "name": "name",
-  "description": "description"
-}
-
-kill_chain_phases_typeql_dict = {
-  "kill_chain_name": "kill-chain-name",
-  "phase_name": "phase-name"
-  
-}
-
-
-#---------------------------------------------------
-# 2.2) Stix Cyber Observable Object Dicts
-#---------------------------------------------------
-
-sco_base_typeql_dict = {
-  "type" :  "stix-type",
-  "spec_version" : "spec-version",
-  "id"  : "stix-id",
-  "created_by_ref"  : "",
-  "revoked"  : "revoked",
-  "labels"  : "labels",
-  "confidence"  : "confidence",
-  "lang"  : "langs",
-  "external_references"  : "",
-  "object_marking_refs"  : "",
-  "granular_markings"  : "",
-  "defanged"  : "defanged",
-  "extensions"  : ""
-}
-
-artifact_typeql_dict = {
-  "mime_type": "mime-type",
-  "payload_bin": "payload-bin",
-  "url": "url-link",
-  "hashes": "",
-  "encryption_algorithm": "encryption-algorithm",
-  "decryption_key": "decryption-key"
-}
-
-autonomous_system_typeql_dict = {
-    "number": "number",
-    "name": "name",
-    "rir": "rir"
-}
-
-directory_typeql_dict = {
-    "path": "path",
-    "path_enc": "path-enc",
-    "ctime": "ctime",
-    "mtime": "mtime",
-    "atime": "atime",
-    "contains_refs": "",
-}
-
-
-domain_name_typeql_dict = {
-    "value": "stix-value",
-    "resolves_to_refs": ""
-}
-
-email_addr_typeql_dict = {
-    "value": "stix-value",
-    "display_name": "display-name",
-    "belongs_to_ref": ""
-}
-
-email_message_typeql_dict = {
-    "is_multipart": "is-multipart",
-    "date": "date",
-    "content_type": "content-type",
-    "from_ref": "",
-    "sender_ref": "",
-    "to_refs": "",
-    "cc_refs": "",
-    "bcc_refs": "",
-    "message_id": "message-id",
-    "subject": "subject",
-    "received_lines": "received-lines",
-    "additional_header_fields": "",
-    "body": "body",
-    "body_multipart": "",
-    "raw_email_ref": ""
-}
-
-file_typeql_dict = {
-    "hashes": "",
-    "size": "size",
-    "name": "name",
-    "name_enc": "name-enc",
-    "magic_number_hex": "magic-number-hex",
-    "mime_type": "mime-type",
-    "ctime": "ctime",
-    "dtime": "dtime",
-    "atime": "atime",
-    "parent_directory_ref": "",
-    "contains_refs": "",
-    "content_ref": ""
-}
-
-ipv4_addr_typeql_dict = {
-    "value": "stix-value",
-    "resolves_to_refs": "",
-    "belongs_to_refs": ""
-}
-
-ipv6_addr_typeql_dict = {
-    "value": "stix-value",
-    "resolves_to_refs": "",
-    "belongs_to_refs": ""
-}
-
-mac_addr_typeql_dict = {
-    "value": "stix-value"
-}
-
-mutex_typeql_dict = {
-    "name": "name"
-}
-
-network_traffic_typeql_dict = {
-    "start": "start",
-    "end": "end",
-    "is_active": "is-active",
-    "src_ref": "",
-    "dst_ref": "",
-    "src_port": "src-port",
-    "dst_port": "dst-port",
-    "protocols": "protocols",
-    "src_byte_count": "src-byte-count",
-    "dst_byte_count": "dst-byte-count",
-    "src_packets": "src-packets",
-    "dst_packets": "dst-packets",
-    "ipfix": "",
-    "src_payload_ref": "",
-    "dst_payload_ref": "",
-    "encapsulates_refs": "",
-    "encapsulated_by_ref": ""    
-}
-
-process_typeql_dict = {
-    "is_hidden": "is-hidden",
-    "pid": "pid",
-    "created_time": "created-time",
-    "cwd": "cwd",
-    "command_line": "command-line",
-    "environment_variables": "",
-    "opened_connection_refs": "",
-    "creator_user_ref": "",
-    "image_ref": "",
-    "parent_ref": "",
-    "child_refs": ""   
-    
-}
-
-software_typeql_dict = {
-    "name": "name",
-    "cpe": "cpe",
-    "swid": "swid",
-    "languages": "language",
-    "vendor": "vendor",
-    "version": "version"
-}
-
-
-url_typeql_dict = {
-    "value": "stix-value"
-}
-
-user_account_typeql_dict = {
-    "user_id": "user-id",
-    "credential": "credential",
-    "account_login": "account-login",
-    "account_type": "account-type",
-    "display_name": "display-name",
-    "is_service_account": "is-service-account",
-    "is_privileged": "is-privileged",
-    "can_escalate_privs": "can-escalate-privs",
-    "is_disabled": "is-disabled",
-    "account_created": "account-created",
-    "account_expires": "account-expires",
-    "credential_last_changed": "credential-last-changed",
-    "account_first_login": "account-first-login",
-    "account_last_login": "account-last-login"
-}
-
-windows_registry_key_typeql_dict = {
-    "key": "attribute-key",
-    "values": "",
-    "modified_time": "modified-time",
-    "creator_user_ref": "",
-    "number_of_subkeys": "number-subkeys"
-}
-
-windows_registry_value_typeql_dict = {
-    "name": "name",
-    "data": "data",
-    "data_type": "data-type"
-}
-
-x509_certificate_typeql_dict = {
-    "is_self_signed": "is-self-signed",
-    "hashes": "",
-    "version": "version",
-    "serial_number": "serial-number",
-    "signature_algorithm": "signature-algorithm",
-    "issuer": "issuer",
-    "validity_not_before": "validity-not-before",
-    "validity_not_after": "validity-not-after",
-    "subject": "subject",
-    "subject_public_key_algorithm": "subject-public-key-algorithm",
-    "subject_public_key_modulus": "subject-public-key-modulus",
-    "subject_public_key_exponent": "subject-public-key-exponent",
-    "x509_v3_extensions": ""
-}
-
-
-
-
-#---------------------------------------------------
-# 2.2b) SCO Extensions and Similar
-#---------------------------------------------------
-
-email_mime_part_typeql_dict = {
-    "body": "body",
-    "content_type": "content-type",
-    "content_disposition": "content-disposition",
-    "body_raw_ref": ""
-}
-
-archive_ext_typeql_dict = {
-    "comment": "comment",
-    "contains_refs": ""
-}
-
-ntfs_ext_typeql_dict = {
-    "sid": "sid",
-    "alternate_data_streams": ""
-}
-
-alternate_data_stream_ext_typeql_dict = {
-    "name": "name",
-    "size": "size",
-    "hashes": ""
-}
-
-pdf_ext_typeql_dict = {
-    "version": "version",
-    "is_optimized": "is-optimized",
-    "document_info_dict": "",
-    "pdfid0": "pdfid0",
-    "pdfid1": "pdfid1"
-}
-
-raster_image_ext_typeql_dict = {
-    "image_height": "image-height",
-    "image_width": "image-width",
-    "exif_tags": "",
-    "bits_per_pixel": "bits-per-pixel"
-}
-
-windows_pebinary_ext_typeql_dict = {
-    "pe_type": "pe-type",
-    "imphash": "imphash",
-    "machine_hex": "machine-hex",
-    "number_of_sections": "number-of-sections",
-    "time_date_stamp": "time-date-stamp",
-    "pointer_to_symbol_table_hex": "pointer-to-symbol-table-hex",
-    "number_of_symbols": "number-of-symbols",
-    "size_of_optional_header": "size-of-optional-header",
-    "characteristics_hex": "characteristics-hex",
-    "file_header_hashes": "",
-    "optional_header": "",
-    "sections": ""
-}
-
-windows_optional_header_ext_typeql_dict = {
-    "magic_hex": "magic-hex",
-    "major_linker_version": "major-linker-version",
-    "minor_linker_version": "minor-linker-version",
-    "size_of_code": "size-of-code",
-    "size_of_initialized_data": "size-of-initialized-data",
-    "size_of_uninitialized_data": "size-of-uninitialized-data",
-    "address_of_entry_point": "address-of-entry-point",
-    "base_of_code": "base-of-code",
-    "base_of_data": "base-of-data",
-    "image_base": "image-base",
-    "section_alignment": "section-alignment",
-    "file_alignment": "file-alignment",
-    "major_os_version": "major-os-version",
-    "minor_os_version": "minor-os-version",
-    "major_image_version": "major-image-version",
-    "minor_image_version": "minor-image-version",
-    "major_subsystem_version": "major-subsystem-version",
-    "minor_subsystem_version": "minor-subsystem-version",
-    "win32_version_value_hex": "win32-version-value-hex",
-    "size_of_image": "size-of-image",
-    "size_of_headers": "size-of-headers",
-    "checksum_hex": "checksum-hex",
-    "subsystem_hex": "subsystem-hex",
-    "dll_characteristics_hex": "dll-characteristics-hex",
-    "size_of_stack_reserve": "size-of-stack-reserve",
-    "size_of_stack_commit": "size-of-stack-commit",
-    "size_of_heap_reserve": "size-of-heap-reserve",
-    "size_of_heap_commit": "size-of-heap-commit",
-    "loader_flags_hex": "loader-flags-hex",
-    "number_of_rva_and_sizes": "number-of-rva-and-sizes",
-    "hashes": ""
-}
-
-windows_pe_section_ext_typeql_dict = {
-    "name": "name",
-    "size": "size",
-    "entropy": "entropy",
-    "hashes": ""
-}
-
-HTTP_request_ext_typeql_dict = {
-    "request_method": "request-method",
-    "request_value": "request-value",
-    "request_version": "request-version",
-    "request_header": "",
-    "message_body_length": "message-body-length",
-    "message_body_data_ref": ""
-}
-
-icmp_ext_typeql_dict = {
-    "icmp_type_hex": "icmp-type-hex",
-    "icmp_code_hex": "icmp-code-hex"
-}
-
-socket_ext_typeql_dict = {
-    "address_family": "address-family",
-    "is_blocking": "is-blocking",
-    "is_listening": "is-listening",
-    "options": "",
-    "socket_type": "socket-type",
-    "socket_description": "socket-description",
-    "socket_handle": "socket-handle"
-}
-
-
-tcp_ext_typeql_dict = {
-    "src_flags_hex": "src-flags-hex",
-    "dst_flags_hex": "dst-flags-hex"
-}
-
-windows_process_ext_typeql_dict = {
-    "aslr_enabled": "aslr-enabled",
-    "dep_enabled": "dep-enabled",
-    "priority": "priority",
-    "owner_sid": "owner-sid",
-    "window_title": "window-title",
-    "startup_info": "",
-    "integrity_level": "integrity-level"
-}
-
-windows_service_ext_typeql_dict = {
-    "service_name": "service-name",
-    "descriptions": "description",
-    "display_name": "display-name",
-    "group_name": "group-name",
-    "start_type": "start-type",
-    "service_dll_refs": "",
-    "service_type": "service-type",
-    "service_status": "service-status"
-}
-
-unix_account_ext_typeql_dict = {
-    "gid": "gid",
-    "groups": "unix-group",
-    "home_dir": "home-dir",
-    "shell": "shell"
-}
-
-x509_v3_ext_typeql_dict = {
-    "basic_constraints": "basic-constraints",
-    "name_constraints": "name-constraints",
-    "policy_constraints": "policy-constraints",
-    "key_usage": "key-usage",
-    "extended_key_usage": "extended-key-usage",
-    "subject_key_identifier": "subject-key-identifier",
-    "authority_key_identifier": "authority-key-identifier",
-    "subject_alternative_name": "subject-alternative-name",
-    "issuer_alternative_name": "issuer-alternative-name",
-    "subject_directory_attributes": "subject-directory-attributes",
-    "crl_distribution_points": "crl-distribution-points",
-    "inhibit_any_policy": "inhibit-any-policy",
-    "private_key_usage_period_not_before": "private-key-usage-period-not-before",
-    "private_key_usage_period_not_after": "private-key-usage-period-not-after",
-    "certificate_policies": "certificate-policies",
-    "policy mapping": "policy-mapping"
-}
-
-
-
-ext_typeql_dict_list = [
-    {   "stix": "archive-ext",
-        "dict": archive_ext_typeql_dict,
-        "object": "archive-ext",
-        "relation": "archive-extension", 
-        "owner": "file",
-        "pointed-to": "an-archive"},
-    {   "stix": "ntfs-ext",
-        "dict": ntfs_ext_typeql_dict,
-        "object": "ntfs-ext",
-        "relation": "ntfs-extension", 
-        "owner": "file",
-        "pointed-to": "ntfs"},
-    {   "stix": "alternate_data_streams",
-        "dict": alternate_data_stream_ext_typeql_dict,
-        "object": "alternate-data-stream",
-        "relation": "alt-data-streams",
-        "owner": "ntfs-ext",
-        "pointed-to": "alt-data-stream"},
-    {   "stix": "pdf-ext",
-        "dict": pdf_ext_typeql_dict,
-        "object": "pdf-ext",
-        "relation": "pdf-extension", 
-        "owner": "file",
-        "pointed-to": "pdf"},
-    {   "stix": "raster-image-ext",
-        "dict": raster_image_ext_typeql_dict,
-        "object": "raster-image-ext",
-        "relation": "raster-image-extension", 
-        "owner": "file",
-        "pointed-to": "image"},
-    {   "stix": "windows-pebinary-ext",
-        "dict": windows_pebinary_ext_typeql_dict,
-        "object": "windows-pebinary-ext",
-        "relation": "windows-pebinary-extension", 
-        "owner": "file",
-        "pointed-to": "pebinary"},
-    {   "stix": "windows-pe-section-type",
-        "dict": windows_pe_section_ext_typeql_dict,
-        "object": "windows-pe-section",
-        "relation": "sections", 
-        "owner": "pebinary",
-        "pointed-to": "pe-section"},
-    {   "stix": "http-request-ext",
-        "dict": HTTP_request_ext_typeql_dict,
-        "object": "http-request-ext",
-        "relation": "http-request-extension", 
-        "owner": "traffic",
-        "pointed-to": "request"},
-    {   "stix": "icmp-ext",
-        "dict": icmp_ext_typeql_dict,
-        "object": "icmp-ext",
-        "relation": "icmp-extension", 
-        "owner": "traffic",
-        "pointed-to": "icmp"},
-    {   "stix": "socket-ext",
-        "dict": socket_ext_typeql_dict,
-        "object": "socket-ext",
-        "relation": "socket-extension", 
-        "owner": "traffic",
-        "pointed-to": "socket"},
-    {   "stix": "tcp-ext",
-        "dict": tcp_ext_typeql_dict,
-        "object": "tcp-ext",
-        "relation": "tcp-extension", 
-        "owner": "traffic",
-        "pointed-to": "tcp"},
-    {   "stix": "windows-process-ext",
-        "dict": windows_process_ext_typeql_dict,
-        "object": "windows-process-ext",
-        "relation": "windows-process-extension", 
-        "owner": "process",
-        "pointed-to": "win-process"},
-    {   "stix": "windows-service-ext",
-        "dict": windows_service_ext_typeql_dict,
-        "object": "windows-service-ext",
-        "relation": "windows-service-extension", 
-        "owner": "process",
-        "pointed-to": "win-service"},
-    {   "stix": "unix-account-ext",
-        "dict": unix_account_ext_typeql_dict,
-        "object": "unix-account-ext",
-        "relation": "unix-account-extension", 
-        "owner": "account",
-        "pointed-to": "unix"},
-    {   "stix": "x509_v3_extensions",
-        "dict": x509_v3_ext_typeql_dict,
-        "object": "x509-v3-extension",
-        "relation": "v3-extensions", 
-        "owner": "cert",
-        "pointed-to": "v3-extension"},
-    {   "stix": "optional_header",
-        "dict": windows_optional_header_ext_typeql_dict,
-        "object": "windows-pe-optional-header-type",
-        "relation": "optional-headers", 
-        "owner": "pebinary",
-        "pointed-to": "optional-header"}
-]
-  
-  
-  
-
-#---------------------------------------------------
-# 2.3) Marking Definition
-#---------------------------------------------------
-
-marking_typeql_dict = {
-  "type": "stix-type",
-  "id": "stix-id",
-  "spec_version": "spec-version",
-  "created": "created",
-  "name": "name",
-  "statement": "statement"
-  
-}
-
-ext_ref_typeql_dict = {
-  "source_name": "source-name",
-  "description": "description",
-  "url": "url-link",
-  "hashes": "",
-  "external_id": "external-id"	
-}
-
-hash_typeql_dict = {
-  "MD5": "md-5",
-  "SHA-1": "sha-1",
-  "SHA-256": "sha-256",
-  "SHA-512": "sha-512",
-  "SHA3-256": "sha3-256",
-  "SHA3-512": "sha3-512",
-  "SSDEEP": "ssdeep",
-  "TLSH": "tlsh"
-}
-
-
-
-#---------------------------------------------------
-# 2.4) Stix type_ql_relationhip Object Dict and TypeQL Roles List of Dicts
-#---------------------------------------------------
-
-sro_base_typeql_dict = {
-  "type" :  "stix-type",
-  "spec_version" :  "spec-version",
-  "id" :  "stix-id",
-  "created_by_ref" :  "",
-  "created" :  "created",
-  "modified" :  "modified",
-  "revoked" :  "revoked",
-  "labels" :  "labels",
-  "confidence" :  "confidence",
-  "lang" :  "langs",
-  "external_references" :  "",
-  "object_marking_refs" :  "",
-  "granular_markings" :  "",
-  "extensions" :  ""
-}
-
-relationship_typeql_dict = {        
-  "relationship_type" :  "relationship-type",
-  "description" :  "description",
-  "source_ref" :  "",
-  "target_ref" :  "",
-  "start_time" :  "start-time",
-  "stop_time" :  "stop-time"        
-}
-
-sighting_typeql_dict = {
-  "description" :  "description",
-  "first_seen" :  "first-seen",
-  "last_seen" :  "last-seen",
-  "count" :  "count",
-  "sighting_of_ref" :  "",
-  "observed_data_refs" :  "",
-  "where_sighted_refs" :  "",
-  "summary" :  "summary"
-}
-    
-
-stix_rel_roles = [
- {   "stix": "delivers",    "typeql": "delivers",    "source": "delivering",    "target": "delivered" }, 
- {   "stix": "targets",    "typeql": "targets",   "source": "targetter",   "target": "targetted" }, 
- {   "stix": "uses",   "typeql": "uses",   "source": "used-by",   "target": "used" }, 
- {   "stix": "attributed-to",   "typeql": "attributed-to",   "source": "result",   "target": "fault-of" }, 
- {   "stix": "compromises",   "typeql": "compromises",   "source": "compromising",   "target": "compromised" }, 
- {   "stix": "originates-from", "typeql": "originates-from",   "source": "originating",   "target": "originated-from" }, 
- {   "stix": "investigates",   "typeql": "investigates",   "source": "investigating",   "target": "investigated" }, 
- {   "stix": "mitigates",   "typeql": "mitigates",   "source": "mitigator",   "target": "mitigated" }, 
- {   "stix": "located-at",   "typeql": "located-at",   "source": "locating",   "target": "located" }, 
- {   "stix": "indicates",   "typeql": "indicates",   "source": "indicating",   "target": "indicated" }, 
- {   "stix": "based-on",   "typeql": "based-on",   "source": "basing-on",   "target": "basis" }, 
- {   "stix": "communicates-with",   "typeql": "communicates-with",   "source": "communicating",   "target": "communicated" }, 
- {   "stix": "consists-of",   "typeql": "consist",   "source": "consisting",   "target": "consisted" }, 
- {   "stix": "controls",   "typeql": "control",   "source": "controlling",   "target": "controlled" }, 
- {   "stix": "has",   "typeql": "have",   "source": "having",   "target": "had" }, 
- {   "stix": "hosts",   "typeql": "hosts",   "source": "hosting",   "target": "hosted" }, 
- {   "stix": "owns",   "typeql": "ownership",   "source": "owning",   "target": "owned" }, 
- {   "stix": "authored-by",   "typeql": "authored-by",   "source": "authoring",   "target": "authored" }, 
- {   "stix": "beacons-to",   "typeql": "beacon",   "source": "beaconing-to",   "target": "beaconed-to" }, 
- {   "stix": "exfiltrate-to",   "typeql": "exfiltrate",   "source": "exfiltrating-to",   "target": "exfiltrated-to" }, 
- {   "stix": "downloads",   "typeql": "download",   "source": "downloading",   "target": "downloaded" }, 
- {   "stix": "drops",   "typeql": "drop",   "source": "dropping",   "target": "dropped" }, 
- {   "stix": "exploits",   "typeql": "exploit",   "source": "exploiting",   "target": "exploited" }, 
- {   "stix": "variant-of",   "typeql": "variant",   "source": "variant-source",   "target": "variant-target" }, 
- {   "stix": "characterizes",   "typeql": "characterise",   "source": "characterising",   "target": "characterised" }, 
- {   "stix": "analysis-of",   "typeql": "av-analysis",   "source": "analysing",   "target": "analysed" }, 
- {   "stix": "static-analysis-of",   "typeql": "static-analysis",   "source": "analysing",   "target": "analysed" }, 
- {   "stix": "dynamic-analysis-of",   "typeql": "dynamic-analysis",   "source": "analysing",   "target": "analysed" }, 
- {   "stix": "impersonates",   "typeql": "impersonate",   "source": "impersonating",   "target": "impersonated" }
-]
-
-embedded_relations_typeql = [
-  {"rel": "object_refs", "owner": "object", "pointed-to": "referred", "typeql": "obj-ref"},
-  {"rel": "created_by_ref", "owner": "created", "pointed-to": "creator", "typeql": "created-by"},
-  {"rel": "object_marking_refs", "owner": "marked", "pointed-to": "marking", "typeql": "object-marking"},
-  {"rel": "sample_refs", "owner": "sample-for", "pointed-to": "sco-sample", "typeql": "malware-sample"},
-  {"rel": "sample_ref", "owner": "sample-for", "pointed-to": "sco-sample", "typeql": "malware-analysis-sample"},
-  {"rel": "host_vm_ref", "owner": "object", "pointed-to": "env", "typeql": "host-vm-ref"},
-  {"rel": "operating_system_ref", "owner": "object", "pointed-to": "env", "typeql": "operating-system"},
-  {"rel": "installed_software_refs", "owner": "object", "pointed-to": "env", "typeql": "installed-software"},
-  {"rel": "contains_refs", "owner": "container", "pointed-to": "contained", "typeql": "directory-contains"},
-  {"rel": "parent_directory_ref", "owner": "contained", "pointed-to": "container", "typeql": "directory-parent"},
-  {"rel": "resolves_to_refs", "owner": "resolve", "pointed-to": "resolves-to", "typeql": "resolves"},
-  {"rel": "belongs_to_ref", "owner": "belonged", "pointed-to": "belongs-to", "typeql": "belongs"},
-  {"rel": "belongs_to_refs", "owner": "belonged", "pointed-to": "belongs-to", "typeql": "belongs-to-autonomous"},
-  {"rel": "analysis_sco_refs", "owner": "object", "pointed-to": "env", "typeql": "captured-objects"},
-  {"rel": "raw_email_ref", "owner": "email", "pointed-to": "binary", "typeql": "raw-email-references"},
-  {"rel": "from_ref", "owner": "email", "pointed-to": "email-address", "typeql": "from-email"},
-  {"rel": "sender_ref", "owner": "email", "pointed-to": "email-address", "typeql": "sender-email"},
-  {"rel": "to_refs", "owner": "email", "pointed-to": "email-address", "typeql": "to-email"},
-  {"rel": "cc_refs", "owner": "email", "pointed-to": "email-address", "typeql": "cc-email"},
-  {"rel": "bcc_refs", "owner": "email", "pointed-to": "email-address", "typeql": "bcc-email"},
-  {"rel": "body_raw_ref", "owner": "containing-mime", "pointed-to": "non-textual", "typeql": "body-raw-references"},
-  {"rel": "content_ref", "owner": "containing-file", "pointed-to": "content", "typeql": "content-file"},
-  {"rel": "src_ref", "owner": "traffic", "pointed-to": "source", "typeql": "traffic-src"},
-  {"rel": "src_payload_ref", "owner": "traffic", "pointed-to": "source", "typeql": "payload-src"},
-  {"rel": "dst_ref", "owner": "traffic", "pointed-to": "destination", "typeql": "traffic-dst"},
-  {"rel": "dst_payload_ref", "owner": "traffic", "pointed-to": "payload", "typeql": "payload-dst"},
-  {"rel": "encapsulates_refs", "owner": "container", "pointed-to": "contained", "typeql": "encapsulate"},
-  {"rel": "encapsulated_by_ref", "owner": "contained", "pointed-to": "container", "typeql": "encapsulated"},
-  {"rel": "message_body_data_ref", "owner": "HTPP-message", "pointed-to": "container", "typeql": "HTTP-body-data"},
-  {"rel": "opened_connection_refs", "owner": "process", "pointed-to": "opened-connection", "typeql": "open-connections"},
-  {"rel": "creator_user_ref", "owner": "created", "pointed-to": "creator", "typeql": "user-created-by"},
-  {"rel": "image_ref", "owner": "process", "pointed-to": "executed-image", "typeql": "process-image"},
-  {"rel": "parent_ref", "owner": "process", "pointed-to": "parent", "typeql": "process-parent"},
-  {"rel": "child_refs", "owner": "process", "pointed-to": "child", "typeql": "process-child"},
-  {"rel": "service_dll_refs", "owner": "process", "pointed-to": "loaded-dll", "typeql": "service-dll"}
-]
-
-
-
-key_value_typeql_list = [
-    {
-        "name": "additional_header_fields", 
-        "typeql": "additional-header", 
-        "owner": "email", 
-        "pointed_to": "item", 
-        "key": "header-key",
-        "value": "header-value"
-    },{
-        "name": "document_info_dict", 
-        "typeql": "doc-info", 
-        "owner": "pdf", 
-        "pointed_to": "info", 
-        "key": "doc-key",
-        "value": "doc-value"
-    },{
-        "name": "exif_tags", 
-        "typeql": "EXIF-tags", 
-        "owner": "image", 
-        "pointed_to": "info", 
-        "key": "EXIF-key",
-        "value": "EXIF-value"
-    },{
-        "name": "ipfix", 
-        "typeql": "IPFIX-store", 
-        "owner": "traffic", 
-        "pointed_to": "item", 
-        "key": "IPFIX-key",
-        "value": "IPFIX-value"
-    },{
-        "name": "request_header", 
-        "typeql": "HTTP-header", 
-        "owner": "request", 
-        "pointed_to": "header", 
-        "key": "HTTP-key",
-        "value": "HTTP-value"
-    },{
-        "name": "options", 
-        "typeql": "socket-options", 
-        "owner": "socket", 
-        "pointed_to": "option", 
-        "key": "socket-key",
-        "value": "socket-value"
-    },{
-        "name": "environment_variables", 
-        "typeql": "environment-variables", 
-        "owner": "process", 
-        "pointed_to": "env-variable", 
-        "key": "environment-key",
-        "value": "environment-value"
-    },{
-        "name": "startup_info", 
-        "typeql": "startup-info", 
-        "owner": "process", 
-        "pointed_to": "option", 
-        "key": "startup-key",
-        "value": "startup-value"
-    }
-]
-
-
-
-list_of_object_typeql = [
-    {
-        "name": "body_multipart", 
-        "typeql": "body-multipart", 
-        "typeql_props": email_mime_part_typeql_dict, 
-        "owner": "email", 
-        "pointed_to": "mime-part", 
-        "object": "email-mime-part"
-    },{
-        "name": "external_references", 
-        "typeql": "external-references", 
-        "typeql_props": ext_ref_typeql_dict, 
-        "owner": "referencing", 
-        "pointed_to": "referenced", 
-        "object": "external-reference"
-    },{
-        "name": "kill_chain_phases", 
-        "typeql": "kill-chain-usage", 
-        "typeql_props": kill_chain_phases_typeql_dict, 
-        "owner": "kill-chain-used", 
-        "pointed_to": "kill-chain-using", 
-        "object": "kill-chain-phase"
-    },{
-        "name": "alternate_data_streams", 
-        "typeql": "alt-data-streams",
-        "typeql_props": alternate_data_stream_ext_typeql_dict, 
-        "owner": "ntfs-ext", 
-        "pointed_to": "alt-data-stream",
-        "object": "alternate-data-stream"
-    },{
-        "name": "sections",
-        "typeql_props": windows_pe_section_ext_typeql_dict,
-        "object": "windows-pe-section",
-        "typeql": "sections", 
-        "owner": "pebinary",
-        "pointed_to": "pe-section"
-    },{
-        "name": "values",
-        "typeql_props": windows_registry_value_typeql_dict,
-        "object": "windows-registry-value-type",
-        "typeql": "reg-val", 
-        "owner": "reg-key",
-        "pointed_to": "reg-value"
-    }
-]
- 
-
-    
-
-#---------------------------------------------------
-# 2.5) Object to Dict Mapping
-#---------------------------------------------------
-
-dispatch_stix = {
-    
-    "attack-pattern" :  attack_pattern_typeql_dict,
-    "campaign" :  campaign_typeql_dict,
-    "course-of-action" :  course_of_action_typeql_dict,
-    "grouping" :  grouping_typeql_dict,
-    "identity": identity_typeql_dict,
-    "incident": incident_typeql_dict,
-    "indicator": indicator_typeql_dict,
-    "infrastructure": infrastructure_typeql_dict,
-    "intrusion-set": intrusion_set_typeql_dict,
-    "location": location_typeql_dict,
-    "malware": malware_typeql_dict,
-    "malware-analysis": malware_analysis_typeql_dict,
-    "note" :  note_type_dict,
-    "observed-data" :  observed_data_typeql_dict,
-    "opinion" :  opinion_typeql_dict,
-    "report" :  report_typeql_dict,
-    "threat-actor": threat_actor_typeql_dict,
-    "tool": tool_typeql_dict,
-    "vulnerability": vulnerability_typeql_dict,
-    "relationship": relationship_typeql_dict,
-    "sighting": sighting_typeql_dict,
-    "artifact": artifact_typeql_dict,
-    "autonomous-system": autonomous_system_typeql_dict,
-    "directory": directory_typeql_dict,
-    "domain-name": domain_name_typeql_dict,
-    "email-addr": email_addr_typeql_dict,
-    "email-message": email_message_typeql_dict,
-    "file": file_typeql_dict,
-    "ipv4-addr": ipv4_addr_typeql_dict,
-    "ipv6-addr": ipv6_addr_typeql_dict,
-    "mac-addr": mac_addr_typeql_dict,
-    "mutex": mutex_typeql_dict,
-    "network-traffic": network_traffic_typeql_dict,
-    "process": process_typeql_dict,
-    "software": software_typeql_dict,
-    "url": url_typeql_dict,
-    "user-account": user_account_typeql_dict,
-    "windows-registry-key": windows_registry_key_typeql_dict,
-    "windows-registry-value-type": windows_registry_value_typeql_dict,
-    "x509-certificate": x509_certificate_typeql_dict,
-    "external-reference": ext_ref_typeql_dict,
-    "email-mime-part": email_mime_part_typeql_dict,
-    "archive-ext":  archive_ext_typeql_dict,
-    "ntfs-ext":  ntfs_ext_typeql_dict,
-    "alternate-data-stream": alternate_data_stream_ext_typeql_dict,
-    "pdf-ext": pdf_ext_typeql_dict,
-    "raster-image-ext": raster_image_ext_typeql_dict,
-    "windows-pebinary-ext": windows_pebinary_ext_typeql_dict,
-    "windows-pe-optional-header-type": windows_optional_header_ext_typeql_dict,
-    "windows-pe-section": windows_pe_section_ext_typeql_dict,
-    "http-request-ext": HTTP_request_ext_typeql_dict,
-    "icmp-ext": icmp_ext_typeql_dict,
-    "socket-ext": socket_ext_typeql_dict,
-    "tcp-ext": tcp_ext_typeql_dict,
-    "unix-account-ext": unix_account_ext_typeql_dict,
-    "windows-process-ext": windows_process_ext_typeql_dict,
-    "windows-service-ext": windows_service_ext_typeql_dict,
-    "kill-chain-phase": kill_chain_phases_typeql_dict,
-    "x509-v3-extension": x509_v3_ext_typeql_dict
-}
-
-sdo_obj = [
-    "attack-pattern",
-    "campaign" ,
-    "course-of-action",
-    "grouping",
-    "identity",
-    "incident",
-    "indicator",
-    "infrastructure",
-    "intrusion-set",
-    "location",
-    "malware",
-    "malware-analysis",
-    "note",
-    "observed-data" ,
-    "opinion",
-    "report",
-    "threat-actor",
-    "tool",
-    "vulnerability"
-]
-
-sro_obj = [    
-    "relationship",
-    "sighting",
-    "delivers",
-    "targets",
-    "uses",
-    "attributed-to",
-    "compromises",
-    "originates-from",
-    "investigates",
-    "mitigates",
-    "located-at",
-    "indicates",
-    "based-on",
-    "communicates-with",
-    "consist",
-    "control",
-    "have",
-    "hosts",
-    "ownership",
-    "authored-by",
-    "beacon",
-    "exfiltrate",
-    "download",
-    "drop",
-    "exploit",
-    "variant",
-    "characterise",
-    "impersonate",
-    "av-analysis",
-    "static-analysis",
-    "dynamic-analysis",
-    "remediation"
-]
-
-sco_obj =[   
-    "artifact",
-    "autonomous-system",
-    "directory",
-    "domain-name",
-    "email-addr",
-    "email-message",
-    "file",
-    "ipv4-addr",
-    "ipv6-addr",
-    "mac-addr",
-    "mutex",
-    "network-traffic",
-    "process",
-    "software",
-    "url",
-    "user-account",
-    "windows-registry-key",
-    "windows-registry-value-type",
-    "x509-certificate"
-]    
-    
-meta_obj = [
-    "marking-definition",
-    "tlp-white",
-    "tlp-green",
-    "tlp-amber",
-    "tlp-red",
-    "statement-marking"
-]
-    
-
-dispatch_attack = {}
-
-extensions_only = [
-    "archive-extension",
-    "ntfs-extension",
-    "pdf-extension",
-    "raster-image-extension",
-    "windows-pebinary-extension",
-    "http-request-extension",
-    "icmp-extension",
-    "socket-extension",
-    "tcp-extension",
-    "unix-account-extension",
-    "windows-process-extension",
-    "windows-service-extension"
-]
-
-object_is_list = {
-    "external-reference": [],
-    "email-mime-part": [],
-    "archive-ext":  ["contains_refs"],
-    "ntfs-ext":  ["alternate_data_streams"],
-    "alternate-data-stream": [],
-    "pdf-ext": [],
-    "raster-image-ext": [],
-    "windows-pebinary-ext": ["sections"],
-    "windows-pe-optional-header-type": [],
-    "windows-pe-section": [],
-    "http-request-ext": [],
-    "icmp-ext": [],
-    "socket-ext": [],
-    "tcp-ext": [],
-    "unix-account-ext": ["groups"],
-    "windows-process-ext": [],
-    "windows-service-ext": ["descriptions", "service_dll_refs"],
-    "kill-chain-phase": [],
-    "windows-registry-value-type": [],
-    "x509-v3-extension": []
-}
-
-sdo_is_list = {
-    "sdo": ["labels","external_references", "object_marking_refs", "granular_markings"],
-    "attack-pattern": ["aliases", "kill_chain_phases"],
-    "campaign": ["aliases"],
-    "course-of-action": [],
-    "grouping": ["object_refs"],
-    "identity": ["roles", "sectors"],
-    "incident": [],
-    "indicator": ["indicator_types", "kill_chain_phases"],
-    "infrastructure": ["infrastructure_types", "aliases", "kill_chain_phases"],
-    "intrusion-set": ["aliases", "goals", "secondary_motivations" ],
-    "location": [],
-    "malware": ["malware_types", "kill_chain_phases","aliases", "operating_system_refs", "architecture_execution_envs", "implementation_languages", "capabilities", "sample_refs"],
-    "malware-analysis": ["installed_software_refs", "modules", "analysis_sco_refs"],
-    "note": ["authors", "object_refs"],
-    "observed-data": ["object_refs"],
-    "opinion": ["authors", "object_refs"],
-    "report": ["report_types", "object_refs"],
-    "threat-actor": ["threat_actor_types", "aliases", "roles", "goals","resource-level", "secondary_motivations", "personal_motivations"],
-    "tool": ["tool_types", "kill_chain_phases", "aliases"],
-    "vulnerability": []
-}
-
-sro_is_list = {
-    "sro": ["labels","external_references", "object_marking_refs", "granular_markings"],
-    "sighting": [ "observed_data_refs", "where_sighted_refs"]
-}
-
-sco_is_list = {
-    "sco": ["labels","external_references", "object_marking_refs", "granular_markings"],
-    "artifact": [],
-    "autonomous-system": [],
-    "directory": ["contains_refs"],
-    "domain-name": ["resolves_to_refs"],
-    "email-addr": [],
-    "email-message": ["to_refs", "cc_refs", "bcc_refs", "received_lines", "body_multipart"],
-    "email-mime-part": [],
-    "file": ["contains_refs"],    
-    "archive-ext":  ["contains_refs"],
-    "ntfs-ext":  ["alternate_data_streams"],
-    "alternate-data-stream-type": [],
-    "pdf-ext": [],
-    "raster-image-ext": [],
-    "windows-pebinary-ext": ["sections"],
-    "windows-pe-optional-header-type": [],
-    "windows-pe-section-type": [],
-    "ipv4-addr": ["resolves_to_refs", "belongs_to_refs"],
-    "ipv6-addr": ["resolves_to_refs", "belongs_to_refs"],
-    "mac-addr": [],
-    "mutex": [],
-    "network-traffic": [ "protocols", "encapsulates_refs"],
-    "http-request-ext": [],
-    "icmp-ext": [],
-    "socket-ext": [],
-    "tcp-ext": [],
-    "process": ["opened_connection_refs", "child_refs"],
-    "windows-process-ext": [],
-    "windows-service-ext": ["descriptions", "service_dll_refs"],
-    "software": ["languages"],
-    "url": [],
-    "user-account": [],
-    "unix-account-ext": ["groups"],
-    "windows-registry-key": ["values"],
-    "windows-registry-value-type": [],
-    "x509-certificate": [],
-    "x509-v3-extensions-type": []
+##################################################
+# 2. Dispatch Dicts to convert between:
+#      - Stix2 Object Property Name --> TypeQL Name
+#      - Stix 2 Object Type --> Dict Name
+###################################################
+
+#---------------------------------------------------
+# 2.1) Stix Domain Object Dicts
+#---------------------------------------------------
+sdo_typeql_dict = {
+  "type" :  "stix-type",
+  "spec_version" : "spec-version",
+  "id"  : "stix-id",
+  "created_by_ref"  : "",
+  "created"  : "created",
+  "modified" : "modified",
+  "revoked"  : "revoked",
+  "labels"  : "labels",
+  "confidence"  : "confidence",
+  "lang"  : "langs",
+  "external_references"  : "",
+  "object_marking_refs"  : "",
+  "granular_markings"  : "",
+  "extensions"  : ""
+}
+
+attack_pattern_typeql_dict = {
+  "name": "name",
+  "description": "description",
+  "aliases": "aliases",
+  "kill_chain_phases": ""
+}
+
+campaign_typeql_dict = {
+  "name": "name",
+  "description": "description",
+  "aliases": "aliases",
+  "first_seen": "first-seen",
+  "last_seen": "last-seen",
+  "objective": "objective"
+}
+
+grouping_typeql_dict = {
+  "name": "name",
+  "description": "description",
+  "context": "context",
+  "object_refs": ""
+}
+
+course_of_action_typeql_dict = {
+  "name": "name",
+  "description": "description",	
+  "action": "action"
+}
+
+identity_typeql_dict = {
+  "name" :  "name",
+  "description" :  "description",
+  "roles" :  "stix-role",
+  "identity_class" :  "identity-class",
+  "sectors" :  "sector",
+  "contact_information" :  "contact-information"
+}
+
+incident_typeql_dict = {
+  "name": "name",
+  "description": "description",
+}
+
+indicator_typeql_dict = {
+  "name": "name",
+  "description": "description",
+  "pattern_version": "pattern-version",
+  "indicator_types": "indicator-type",
+  "pattern": "pattern",
+  "pattern_type": "pattern-type",
+  "valid_from": "valid-from",
+  "valid_until": "valid-until",
+  "kill_chain_phases": ""
+}
+
+infrastructure_typeql_dict = {
+  "name": "name",
+  "description": "description",
+  "infrastructure_types": "infrastructure-types",
+  "aliases": "aliases",
+  "kill_chain_phases": "",
+  "first_seen": "first-seen",
+  "last_seen": "last-seen"
+}
+
+intrusion_set_typeql_dict = {
+  "name": "name",
+  "description": "description",
+  "aliases": "aliases",
+  "first_seen": "first-seen",
+  "last_seen": "last-seen",
+  "goals": "goals",
+  "resource_level": "resource-level",
+  "primary_motivation": "primary-motivation",
+  "secondary_motivations": "secondary-motivations"
+}
+
+location_typeql_dict = {
+  "name": "name",
+  "description": "description",
+  "latitude": "latitude",
+  "longitude": "longitude",
+  "precision": "precision",
+  "region": "region",
+  "country": "country",
+  "administrative_area": "administrative-area",
+  "city": "city",
+  "street_address": "street-address",
+  "postal_code": "postal-code"
+}
+
+malware_typeql_dict = {
+  "name": "name",	
+  "description": "description",
+  "malware_types": "malware-types",
+  "is_family": "is-family",
+  "aliases": "aliases",
+  "kill_chain_phases": "",
+  "first_seen": "first-seen",
+  "last_seen": "last-seen",
+  "operating_system_refs": "",
+  "architecture_execution_envs": "architecture-execution-envs",
+  "implementation_languages": "implementation-languages",
+  "capabilities": "capabilities",
+  "sample_refs": ""
+}
+
+malware_analysis_typeql_dict = {
+  "product": "product",
+  "version": "version",
+  "host_vm_ref": "",
+  "operating_system_ref": "",
+  "installed_software_refs": "",
+  "configuration_version": "configuration-version",
+  "modules": "modules",
+  "analysis_engine_version": "analysis-engine-version",
+  "analysis_definition_version": "analysis-definition-version",
+  "submitted": "submitted",
+  "analysis_started": "analysis-started",
+  "analysis_ended": "analysis-ended",
+  "result_name": "result-name",
+  "result": "result",
+  "analysis_sco_refs": "",
+  "sample_ref": ""
+}
+
+note_type_dict = {
+  "abstract": "abstract",
+  "content": "content",
+  "authors": "authors",
+  "object_refs": ""
+}
+
+observed_data_typeql_dict = {
+  "first_observed": "first-observed",
+  "last_observed": "last-observed",
+  "number_observed": "number-observed",
+  "object_refs": ""
+}
+
+opinion_typeql_dict = {
+  "explanation": "explanation",
+  "authors": "authors",
+  "opinion": "opinion-enum",
+  "object_refs": ""
+}
+
+report_typeql_dict = {
+  "name": "name",
+  "description": "description",
+  "report_types": "report-type",
+  "published": "published",
+  "object_refs": ""
+}
+
+threat_actor_typeql_dict = {        
+  "name"  : "name",
+  "description"  : "description",
+  "threat_actor_types"  : "threat-actor-type",
+  "aliases"  : "aliases",
+  "first_seen"  : "first-seen",
+  "last_seen"  : "last-seen",
+  "roles"  : "stix-role",
+  "goals"  : "goals",
+  "sophistication"  : "sophistication",
+  "resource_level"  : "resource-level",
+  "primary_motivation"  : "primary-motivation",
+  "secondary_motivations"  : "secondary-motivations",
+  "personal_motivations"  : "personal-motivations"        
+}
+
+tool_typeql_dict = {
+  "name": "name",
+  "description": "description",
+  "tool_types": "tool-type",
+  "aliases": "aliases",
+  "kill_chain_phases": "",
+  "tool_version": "tool-version"
+}
+
+vulnerability_typeql_dict = {
+  "name": "name",
+  "description": "description"
+}
+
+kill_chain_phases_typeql_dict = {
+  "kill_chain_name": "kill-chain-name",
+  "phase_name": "phase-name"
+  
+}
+
+
+#---------------------------------------------------
+# 2.2) Stix Cyber Observable Object Dicts
+#---------------------------------------------------
+
+sco_base_typeql_dict = {
+  "type" :  "stix-type",
+  "spec_version" : "spec-version",
+  "id"  : "stix-id",
+  "created_by_ref"  : "",
+  "revoked"  : "revoked",
+  "labels"  : "labels",
+  "confidence"  : "confidence",
+  "lang"  : "langs",
+  "external_references"  : "",
+  "object_marking_refs"  : "",
+  "granular_markings"  : "",
+  "defanged"  : "defanged",
+  "extensions"  : ""
+}
+
+artifact_typeql_dict = {
+  "mime_type": "mime-type",
+  "payload_bin": "payload-bin",
+  "url": "url-link",
+  "hashes": "",
+  "encryption_algorithm": "encryption-algorithm",
+  "decryption_key": "decryption-key"
+}
+
+autonomous_system_typeql_dict = {
+    "number": "number",
+    "name": "name",
+    "rir": "rir"
+}
+
+directory_typeql_dict = {
+    "path": "path",
+    "path_enc": "path-enc",
+    "ctime": "ctime",
+    "mtime": "mtime",
+    "atime": "atime",
+    "contains_refs": "",
+}
+
+
+domain_name_typeql_dict = {
+    "value": "stix-value",
+    "resolves_to_refs": ""
+}
+
+email_addr_typeql_dict = {
+    "value": "stix-value",
+    "display_name": "display-name",
+    "belongs_to_ref": ""
+}
+
+email_message_typeql_dict = {
+    "is_multipart": "is-multipart",
+    "date": "date",
+    "content_type": "content-type",
+    "from_ref": "",
+    "sender_ref": "",
+    "to_refs": "",
+    "cc_refs": "",
+    "bcc_refs": "",
+    "message_id": "message-id",
+    "subject": "subject",
+    "received_lines": "received-lines",
+    "additional_header_fields": "",
+    "body": "body",
+    "body_multipart": "",
+    "raw_email_ref": ""
+}
+
+file_typeql_dict = {
+    "hashes": "",
+    "size": "size",
+    "name": "name",
+    "name_enc": "name-enc",
+    "magic_number_hex": "magic-number-hex",
+    "mime_type": "mime-type",
+    "ctime": "ctime",
+    "dtime": "dtime",
+    "atime": "atime",
+    "parent_directory_ref": "",
+    "contains_refs": "",
+    "content_ref": ""
+}
+
+ipv4_addr_typeql_dict = {
+    "value": "stix-value",
+    "resolves_to_refs": "",
+    "belongs_to_refs": ""
+}
+
+ipv6_addr_typeql_dict = {
+    "value": "stix-value",
+    "resolves_to_refs": "",
+    "belongs_to_refs": ""
+}
+
+mac_addr_typeql_dict = {
+    "value": "stix-value"
+}
+
+mutex_typeql_dict = {
+    "name": "name"
+}
+
+network_traffic_typeql_dict = {
+    "start": "start",
+    "end": "end",
+    "is_active": "is-active",
+    "src_ref": "",
+    "dst_ref": "",
+    "src_port": "src-port",
+    "dst_port": "dst-port",
+    "protocols": "protocols",
+    "src_byte_count": "src-byte-count",
+    "dst_byte_count": "dst-byte-count",
+    "src_packets": "src-packets",
+    "dst_packets": "dst-packets",
+    "ipfix": "",
+    "src_payload_ref": "",
+    "dst_payload_ref": "",
+    "encapsulates_refs": "",
+    "encapsulated_by_ref": ""    
+}
+
+process_typeql_dict = {
+    "is_hidden": "is-hidden",
+    "pid": "pid",
+    "created_time": "created-time",
+    "cwd": "cwd",
+    "command_line": "command-line",
+    "environment_variables": "",
+    "opened_connection_refs": "",
+    "creator_user_ref": "",
+    "image_ref": "",
+    "parent_ref": "",
+    "child_refs": ""   
+    
+}
+
+software_typeql_dict = {
+    "name": "name",
+    "cpe": "cpe",
+    "swid": "swid",
+    "languages": "language",
+    "vendor": "vendor",
+    "version": "version"
+}
+
+
+url_typeql_dict = {
+    "value": "stix-value"
+}
+
+user_account_typeql_dict = {
+    "user_id": "user-id",
+    "credential": "credential",
+    "account_login": "account-login",
+    "account_type": "account-type",
+    "display_name": "display-name",
+    "is_service_account": "is-service-account",
+    "is_privileged": "is-privileged",
+    "can_escalate_privs": "can-escalate-privs",
+    "is_disabled": "is-disabled",
+    "account_created": "account-created",
+    "account_expires": "account-expires",
+    "credential_last_changed": "credential-last-changed",
+    "account_first_login": "account-first-login",
+    "account_last_login": "account-last-login"
+}
+
+windows_registry_key_typeql_dict = {
+    "key": "attribute-key",
+    "values": "",
+    "modified_time": "modified-time",
+    "creator_user_ref": "",
+    "number_of_subkeys": "number-subkeys"
+}
+
+windows_registry_value_typeql_dict = {
+    "name": "name",
+    "data": "data",
+    "data_type": "data-type"
+}
+
+x509_certificate_typeql_dict = {
+    "is_self_signed": "is-self-signed",
+    "hashes": "",
+    "version": "version",
+    "serial_number": "serial-number",
+    "signature_algorithm": "signature-algorithm",
+    "issuer": "issuer",
+    "validity_not_before": "validity-not-before",
+    "validity_not_after": "validity-not-after",
+    "subject": "subject",
+    "subject_public_key_algorithm": "subject-public-key-algorithm",
+    "subject_public_key_modulus": "subject-public-key-modulus",
+    "subject_public_key_exponent": "subject-public-key-exponent",
+    "x509_v3_extensions": ""
+}
+
+
+
+
+#---------------------------------------------------
+# 2.2b) SCO Extensions and Similar
+#---------------------------------------------------
+
+email_mime_part_typeql_dict = {
+    "body": "body",
+    "content_type": "content-type",
+    "content_disposition": "content-disposition",
+    "body_raw_ref": ""
+}
+
+archive_ext_typeql_dict = {
+    "comment": "comment",
+    "contains_refs": ""
+}
+
+ntfs_ext_typeql_dict = {
+    "sid": "sid",
+    "alternate_data_streams": ""
+}
+
+alternate_data_stream_ext_typeql_dict = {
+    "name": "name",
+    "size": "size",
+    "hashes": ""
+}
+
+pdf_ext_typeql_dict = {
+    "version": "version",
+    "is_optimized": "is-optimized",
+    "document_info_dict": "",
+    "pdfid0": "pdfid0",
+    "pdfid1": "pdfid1"
+}
+
+raster_image_ext_typeql_dict = {
+    "image_height": "image-height",
+    "image_width": "image-width",
+    "exif_tags": "",
+    "bits_per_pixel": "bits-per-pixel"
+}
+
+windows_pebinary_ext_typeql_dict = {
+    "pe_type": "pe-type",
+    "imphash": "imphash",
+    "machine_hex": "machine-hex",
+    "number_of_sections": "number-of-sections",
+    "time_date_stamp": "time-date-stamp",
+    "pointer_to_symbol_table_hex": "pointer-to-symbol-table-hex",
+    "number_of_symbols": "number-of-symbols",
+    "size_of_optional_header": "size-of-optional-header",
+    "characteristics_hex": "characteristics-hex",
+    "file_header_hashes": "",
+    "optional_header": "",
+    "sections": ""
+}
+
+windows_optional_header_ext_typeql_dict = {
+    "magic_hex": "magic-hex",
+    "major_linker_version": "major-linker-version",
+    "minor_linker_version": "minor-linker-version",
+    "size_of_code": "size-of-code",
+    "size_of_initialized_data": "size-of-initialized-data",
+    "size_of_uninitialized_data": "size-of-uninitialized-data",
+    "address_of_entry_point": "address-of-entry-point",
+    "base_of_code": "base-of-code",
+    "base_of_data": "base-of-data",
+    "image_base": "image-base",
+    "section_alignment": "section-alignment",
+    "file_alignment": "file-alignment",
+    "major_os_version": "major-os-version",
+    "minor_os_version": "minor-os-version",
+    "major_image_version": "major-image-version",
+    "minor_image_version": "minor-image-version",
+    "major_subsystem_version": "major-subsystem-version",
+    "minor_subsystem_version": "minor-subsystem-version",
+    "win32_version_value_hex": "win32-version-value-hex",
+    "size_of_image": "size-of-image",
+    "size_of_headers": "size-of-headers",
+    "checksum_hex": "checksum-hex",
+    "subsystem_hex": "subsystem-hex",
+    "dll_characteristics_hex": "dll-characteristics-hex",
+    "size_of_stack_reserve": "size-of-stack-reserve",
+    "size_of_stack_commit": "size-of-stack-commit",
+    "size_of_heap_reserve": "size-of-heap-reserve",
+    "size_of_heap_commit": "size-of-heap-commit",
+    "loader_flags_hex": "loader-flags-hex",
+    "number_of_rva_and_sizes": "number-of-rva-and-sizes",
+    "hashes": ""
+}
+
+windows_pe_section_ext_typeql_dict = {
+    "name": "name",
+    "size": "size",
+    "entropy": "entropy",
+    "hashes": ""
+}
+
+HTTP_request_ext_typeql_dict = {
+    "request_method": "request-method",
+    "request_value": "request-value",
+    "request_version": "request-version",
+    "request_header": "",
+    "message_body_length": "message-body-length",
+    "message_body_data_ref": ""
+}
+
+icmp_ext_typeql_dict = {
+    "icmp_type_hex": "icmp-type-hex",
+    "icmp_code_hex": "icmp-code-hex"
+}
+
+socket_ext_typeql_dict = {
+    "address_family": "address-family",
+    "is_blocking": "is-blocking",
+    "is_listening": "is-listening",
+    "options": "",
+    "socket_type": "socket-type",
+    "socket_description": "socket-description",
+    "socket_handle": "socket-handle"
+}
+
+
+tcp_ext_typeql_dict = {
+    "src_flags_hex": "src-flags-hex",
+    "dst_flags_hex": "dst-flags-hex"
+}
+
+windows_process_ext_typeql_dict = {
+    "aslr_enabled": "aslr-enabled",
+    "dep_enabled": "dep-enabled",
+    "priority": "priority",
+    "owner_sid": "owner-sid",
+    "window_title": "window-title",
+    "startup_info": "",
+    "integrity_level": "integrity-level"
+}
+
+windows_service_ext_typeql_dict = {
+    "service_name": "service-name",
+    "descriptions": "description",
+    "display_name": "display-name",
+    "group_name": "group-name",
+    "start_type": "start-type",
+    "service_dll_refs": "",
+    "service_type": "service-type",
+    "service_status": "service-status"
+}
+
+unix_account_ext_typeql_dict = {
+    "gid": "gid",
+    "groups": "unix-group",
+    "home_dir": "home-dir",
+    "shell": "shell"
+}
+
+x509_v3_ext_typeql_dict = {
+    "basic_constraints": "basic-constraints",
+    "name_constraints": "name-constraints",
+    "policy_constraints": "policy-constraints",
+    "key_usage": "key-usage",
+    "extended_key_usage": "extended-key-usage",
+    "subject_key_identifier": "subject-key-identifier",
+    "authority_key_identifier": "authority-key-identifier",
+    "subject_alternative_name": "subject-alternative-name",
+    "issuer_alternative_name": "issuer-alternative-name",
+    "subject_directory_attributes": "subject-directory-attributes",
+    "crl_distribution_points": "crl-distribution-points",
+    "inhibit_any_policy": "inhibit-any-policy",
+    "private_key_usage_period_not_before": "private-key-usage-period-not-before",
+    "private_key_usage_period_not_after": "private-key-usage-period-not-after",
+    "certificate_policies": "certificate-policies",
+    "policy mapping": "policy-mapping"
+}
+
+
+
+ext_typeql_dict_list = [
+    {   "stix": "archive-ext",
+        "dict": archive_ext_typeql_dict,
+        "object": "archive-ext",
+        "relation": "archive-extension", 
+        "owner": "file",
+        "pointed-to": "an-archive"},
+    {   "stix": "ntfs-ext",
+        "dict": ntfs_ext_typeql_dict,
+        "object": "ntfs-ext",
+        "relation": "ntfs-extension", 
+        "owner": "file",
+        "pointed-to": "ntfs"},
+    {   "stix": "alternate_data_streams",
+        "dict": alternate_data_stream_ext_typeql_dict,
+        "object": "alternate-data-stream",
+        "relation": "alt-data-streams",
+        "owner": "ntfs-ext",
+        "pointed-to": "alt-data-stream"},
+    {   "stix": "pdf-ext",
+        "dict": pdf_ext_typeql_dict,
+        "object": "pdf-ext",
+        "relation": "pdf-extension", 
+        "owner": "file",
+        "pointed-to": "pdf"},
+    {   "stix": "raster-image-ext",
+        "dict": raster_image_ext_typeql_dict,
+        "object": "raster-image-ext",
+        "relation": "raster-image-extension", 
+        "owner": "file",
+        "pointed-to": "image"},
+    {   "stix": "windows-pebinary-ext",
+        "dict": windows_pebinary_ext_typeql_dict,
+        "object": "windows-pebinary-ext",
+        "relation": "windows-pebinary-extension", 
+        "owner": "file",
+        "pointed-to": "pebinary"},
+    {   "stix": "windows-pe-section-type",
+        "dict": windows_pe_section_ext_typeql_dict,
+        "object": "windows-pe-section",
+        "relation": "sections", 
+        "owner": "pebinary",
+        "pointed-to": "pe-section"},
+    {   "stix": "http-request-ext",
+        "dict": HTTP_request_ext_typeql_dict,
+        "object": "http-request-ext",
+        "relation": "http-request-extension", 
+        "owner": "traffic",
+        "pointed-to": "request"},
+    {   "stix": "icmp-ext",
+        "dict": icmp_ext_typeql_dict,
+        "object": "icmp-ext",
+        "relation": "icmp-extension", 
+        "owner": "traffic",
+        "pointed-to": "icmp"},
+    {   "stix": "socket-ext",
+        "dict": socket_ext_typeql_dict,
+        "object": "socket-ext",
+        "relation": "socket-extension", 
+        "owner": "traffic",
+        "pointed-to": "socket"},
+    {   "stix": "tcp-ext",
+        "dict": tcp_ext_typeql_dict,
+        "object": "tcp-ext",
+        "relation": "tcp-extension", 
+        "owner": "traffic",
+        "pointed-to": "tcp"},
+    {   "stix": "windows-process-ext",
+        "dict": windows_process_ext_typeql_dict,
+        "object": "windows-process-ext",
+        "relation": "windows-process-extension", 
+        "owner": "process",
+        "pointed-to": "win-process"},
+    {   "stix": "windows-service-ext",
+        "dict": windows_service_ext_typeql_dict,
+        "object": "windows-service-ext",
+        "relation": "windows-service-extension", 
+        "owner": "process",
+        "pointed-to": "win-service"},
+    {   "stix": "unix-account-ext",
+        "dict": unix_account_ext_typeql_dict,
+        "object": "unix-account-ext",
+        "relation": "unix-account-extension", 
+        "owner": "account",
+        "pointed-to": "unix"},
+    {   "stix": "x509_v3_extensions",
+        "dict": x509_v3_ext_typeql_dict,
+        "object": "x509-v3-extension",
+        "relation": "v3-extensions", 
+        "owner": "cert",
+        "pointed-to": "v3-extension"},
+    {   "stix": "optional_header",
+        "dict": windows_optional_header_ext_typeql_dict,
+        "object": "windows-pe-optional-header-type",
+        "relation": "optional-headers", 
+        "owner": "pebinary",
+        "pointed-to": "optional-header"}
+]
+  
+  
+  
+
+#---------------------------------------------------
+# 2.3) Marking Definition
+#---------------------------------------------------
+
+marking_typeql_dict = {
+  "type": "stix-type",
+  "id": "stix-id",
+  "spec_version": "spec-version",
+  "created": "created",
+  "name": "name",
+  "statement": "statement"
+  
+}
+
+ext_ref_typeql_dict = {
+  "source_name": "source-name",
+  "description": "description",
+  "url": "url-link",
+  "hashes": "",
+  "external_id": "external-id"	
+}
+
+hash_typeql_dict = {
+  "MD5": "md-5",
+  "SHA-1": "sha-1",
+  "SHA-256": "sha-256",
+  "SHA-512": "sha-512",
+  "SHA3-256": "sha3-256",
+  "SHA3-512": "sha3-512",
+  "SSDEEP": "ssdeep",
+  "TLSH": "tlsh"
+}
+
+
+
+#---------------------------------------------------
+# 2.4) Stix type_ql_relationhip Object Dict and TypeQL Roles List of Dicts
+#---------------------------------------------------
+
+sro_base_typeql_dict = {
+  "type" :  "stix-type",
+  "spec_version" :  "spec-version",
+  "id" :  "stix-id",
+  "created_by_ref" :  "",
+  "created" :  "created",
+  "modified" :  "modified",
+  "revoked" :  "revoked",
+  "labels" :  "labels",
+  "confidence" :  "confidence",
+  "lang" :  "langs",
+  "external_references" :  "",
+  "object_marking_refs" :  "",
+  "granular_markings" :  "",
+  "extensions" :  ""
+}
+
+relationship_typeql_dict = {        
+  "relationship_type" :  "relationship-type",
+  "description" :  "description",
+  "source_ref" :  "",
+  "target_ref" :  "",
+  "start_time" :  "start-time",
+  "stop_time" :  "stop-time"        
+}
+
+sighting_typeql_dict = {
+  "description" :  "description",
+  "first_seen" :  "first-seen",
+  "last_seen" :  "last-seen",
+  "count" :  "count",
+  "sighting_of_ref" :  "",
+  "observed_data_refs" :  "",
+  "where_sighted_refs" :  "",
+  "summary" :  "summary"
+}
+    
+
+stix_rel_roles = [
+ {   "stix": "delivers",    "typeql": "delivers",    "source": "delivering",    "target": "delivered" }, 
+ {   "stix": "targets",    "typeql": "targets",   "source": "targetter",   "target": "targetted" }, 
+ {   "stix": "uses",   "typeql": "uses",   "source": "used-by",   "target": "used" }, 
+ {   "stix": "attributed-to",   "typeql": "attributed-to",   "source": "result",   "target": "fault-of" }, 
+ {   "stix": "compromises",   "typeql": "compromises",   "source": "compromising",   "target": "compromised" }, 
+ {   "stix": "originates-from", "typeql": "originates-from",   "source": "originating",   "target": "originated-from" }, 
+ {   "stix": "investigates",   "typeql": "investigates",   "source": "investigating",   "target": "investigated" }, 
+ {   "stix": "mitigates",   "typeql": "mitigates",   "source": "mitigator",   "target": "mitigated" }, 
+ {   "stix": "located-at",   "typeql": "located-at",   "source": "locating",   "target": "located" }, 
+ {   "stix": "indicates",   "typeql": "indicates",   "source": "indicating",   "target": "indicated" }, 
+ {   "stix": "based-on",   "typeql": "based-on",   "source": "basing-on",   "target": "basis" }, 
+ {   "stix": "communicates-with",   "typeql": "communicates-with",   "source": "communicating",   "target": "communicated" }, 
+ {   "stix": "consists-of",   "typeql": "consist",   "source": "consisting",   "target": "consisted" }, 
+ {   "stix": "controls",   "typeql": "control",   "source": "controlling",   "target": "controlled" }, 
+ {   "stix": "has",   "typeql": "have",   "source": "having",   "target": "had" }, 
+ {   "stix": "hosts",   "typeql": "hosts",   "source": "hosting",   "target": "hosted" }, 
+ {   "stix": "owns",   "typeql": "ownership",   "source": "owning",   "target": "owned" }, 
+ {   "stix": "authored-by",   "typeql": "authored-by",   "source": "authoring",   "target": "authored" }, 
+ {   "stix": "beacons-to",   "typeql": "beacon",   "source": "beaconing-to",   "target": "beaconed-to" }, 
+ {   "stix": "exfiltrate-to",   "typeql": "exfiltrate",   "source": "exfiltrating-to",   "target": "exfiltrated-to" }, 
+ {   "stix": "downloads",   "typeql": "download",   "source": "downloading",   "target": "downloaded" }, 
+ {   "stix": "drops",   "typeql": "drop",   "source": "dropping",   "target": "dropped" }, 
+ {   "stix": "exploits",   "typeql": "exploit",   "source": "exploiting",   "target": "exploited" }, 
+ {   "stix": "variant-of",   "typeql": "variant",   "source": "variant-source",   "target": "variant-target" }, 
+ {   "stix": "characterizes",   "typeql": "characterise",   "source": "characterising",   "target": "characterised" }, 
+ {   "stix": "analysis-of",   "typeql": "av-analysis",   "source": "analysing",   "target": "analysed" }, 
+ {   "stix": "static-analysis-of",   "typeql": "static-analysis",   "source": "analysing",   "target": "analysed" }, 
+ {   "stix": "dynamic-analysis-of",   "typeql": "dynamic-analysis",   "source": "analysing",   "target": "analysed" }, 
+ {   "stix": "impersonates",   "typeql": "impersonate",   "source": "impersonating",   "target": "impersonated" }
+]
+
+embedded_relations_typeql = [
+  {"rel": "object_refs", "owner": "object", "pointed-to": "referred", "typeql": "obj-ref"},
+  {"rel": "created_by_ref", "owner": "created", "pointed-to": "creator", "typeql": "created-by"},
+  {"rel": "object_marking_refs", "owner": "marked", "pointed-to": "marking", "typeql": "object-marking"},
+  {"rel": "sample_refs", "owner": "sample-for", "pointed-to": "sco-sample", "typeql": "malware-sample"},
+  {"rel": "sample_ref", "owner": "sample-for", "pointed-to": "sco-sample", "typeql": "malware-analysis-sample"},
+  {"rel": "host_vm_ref", "owner": "object", "pointed-to": "env", "typeql": "host-vm-ref"},
+  {"rel": "operating_system_ref", "owner": "object", "pointed-to": "env", "typeql": "operating-system"},
+  {"rel": "installed_software_refs", "owner": "object", "pointed-to": "env", "typeql": "installed-software"},
+  {"rel": "contains_refs", "owner": "container", "pointed-to": "contained", "typeql": "directory-contains"},
+  {"rel": "parent_directory_ref", "owner": "contained", "pointed-to": "container", "typeql": "directory-parent"},
+  {"rel": "resolves_to_refs", "owner": "resolve", "pointed-to": "resolves-to", "typeql": "resolves"},
+  {"rel": "belongs_to_ref", "owner": "belonged", "pointed-to": "belongs-to", "typeql": "belongs"},
+  {"rel": "belongs_to_refs", "owner": "belonged", "pointed-to": "belongs-to", "typeql": "belongs-to-autonomous"},
+  {"rel": "analysis_sco_refs", "owner": "object", "pointed-to": "env", "typeql": "captured-objects"},
+  {"rel": "raw_email_ref", "owner": "email", "pointed-to": "binary", "typeql": "raw-email-references"},
+  {"rel": "from_ref", "owner": "email", "pointed-to": "email-address", "typeql": "from-email"},
+  {"rel": "sender_ref", "owner": "email", "pointed-to": "email-address", "typeql": "sender-email"},
+  {"rel": "to_refs", "owner": "email", "pointed-to": "email-address", "typeql": "to-email"},
+  {"rel": "cc_refs", "owner": "email", "pointed-to": "email-address", "typeql": "cc-email"},
+  {"rel": "bcc_refs", "owner": "email", "pointed-to": "email-address", "typeql": "bcc-email"},
+  {"rel": "body_raw_ref", "owner": "containing-mime", "pointed-to": "non-textual", "typeql": "body-raw-references"},
+  {"rel": "content_ref", "owner": "containing-file", "pointed-to": "content", "typeql": "content-file"},
+  {"rel": "src_ref", "owner": "traffic", "pointed-to": "source", "typeql": "traffic-src"},
+  {"rel": "src_payload_ref", "owner": "traffic", "pointed-to": "source", "typeql": "payload-src"},
+  {"rel": "dst_ref", "owner": "traffic", "pointed-to": "destination", "typeql": "traffic-dst"},
+  {"rel": "dst_payload_ref", "owner": "traffic", "pointed-to": "payload", "typeql": "payload-dst"},
+  {"rel": "encapsulates_refs", "owner": "container", "pointed-to": "contained", "typeql": "encapsulate"},
+  {"rel": "encapsulated_by_ref", "owner": "contained", "pointed-to": "container", "typeql": "encapsulated"},
+  {"rel": "message_body_data_ref", "owner": "HTPP-message", "pointed-to": "container", "typeql": "HTTP-body-data"},
+  {"rel": "opened_connection_refs", "owner": "process", "pointed-to": "opened-connection", "typeql": "open-connections"},
+  {"rel": "creator_user_ref", "owner": "created", "pointed-to": "creator", "typeql": "user-created-by"},
+  {"rel": "image_ref", "owner": "process", "pointed-to": "executed-image", "typeql": "process-image"},
+  {"rel": "parent_ref", "owner": "process", "pointed-to": "parent", "typeql": "process-parent"},
+  {"rel": "child_refs", "owner": "process", "pointed-to": "child", "typeql": "process-child"},
+  {"rel": "service_dll_refs", "owner": "process", "pointed-to": "loaded-dll", "typeql": "service-dll"}
+]
+
+
+
+key_value_typeql_list = [
+    {
+        "name": "additional_header_fields", 
+        "typeql": "additional-header", 
+        "owner": "email", 
+        "pointed_to": "item", 
+        "key": "header-key",
+        "value": "header-value"
+    },{
+        "name": "document_info_dict", 
+        "typeql": "doc-info", 
+        "owner": "pdf", 
+        "pointed_to": "info", 
+        "key": "doc-key",
+        "value": "doc-value"
+    },{
+        "name": "exif_tags", 
+        "typeql": "EXIF-tags", 
+        "owner": "image", 
+        "pointed_to": "info", 
+        "key": "EXIF-key",
+        "value": "EXIF-value"
+    },{
+        "name": "ipfix", 
+        "typeql": "IPFIX-store", 
+        "owner": "traffic", 
+        "pointed_to": "item", 
+        "key": "IPFIX-key",
+        "value": "IPFIX-value"
+    },{
+        "name": "request_header", 
+        "typeql": "HTTP-header", 
+        "owner": "request", 
+        "pointed_to": "header", 
+        "key": "HTTP-key",
+        "value": "HTTP-value"
+    },{
+        "name": "options", 
+        "typeql": "socket-options", 
+        "owner": "socket", 
+        "pointed_to": "option", 
+        "key": "socket-key",
+        "value": "socket-value"
+    },{
+        "name": "environment_variables", 
+        "typeql": "environment-variables", 
+        "owner": "process", 
+        "pointed_to": "env-variable", 
+        "key": "environment-key",
+        "value": "environment-value"
+    },{
+        "name": "startup_info", 
+        "typeql": "startup-info", 
+        "owner": "process", 
+        "pointed_to": "option", 
+        "key": "startup-key",
+        "value": "startup-value"
+    }
+]
+
+
+
+list_of_object_typeql = [
+    {
+        "name": "body_multipart", 
+        "typeql": "body-multipart", 
+        "typeql_props": email_mime_part_typeql_dict, 
+        "owner": "email", 
+        "pointed_to": "mime-part", 
+        "object": "email-mime-part"
+    },{
+        "name": "external_references", 
+        "typeql": "external-references", 
+        "typeql_props": ext_ref_typeql_dict, 
+        "owner": "referencing", 
+        "pointed_to": "referenced", 
+        "object": "external-reference"
+    },{
+        "name": "kill_chain_phases", 
+        "typeql": "kill-chain-usage", 
+        "typeql_props": kill_chain_phases_typeql_dict, 
+        "owner": "kill-chain-used", 
+        "pointed_to": "kill-chain-using", 
+        "object": "kill-chain-phase"
+    },{
+        "name": "alternate_data_streams", 
+        "typeql": "alt-data-streams",
+        "typeql_props": alternate_data_stream_ext_typeql_dict, 
+        "owner": "ntfs-ext", 
+        "pointed_to": "alt-data-stream",
+        "object": "alternate-data-stream"
+    },{
+        "name": "sections",
+        "typeql_props": windows_pe_section_ext_typeql_dict,
+        "object": "windows-pe-section",
+        "typeql": "sections", 
+        "owner": "pebinary",
+        "pointed_to": "pe-section"
+    },{
+        "name": "values",
+        "typeql_props": windows_registry_value_typeql_dict,
+        "object": "windows-registry-value-type",
+        "typeql": "reg-val", 
+        "owner": "reg-key",
+        "pointed_to": "reg-value"
+    }
+]
+ 
+
+    
+
+#---------------------------------------------------
+# 2.5) Object to Dict Mapping
+#---------------------------------------------------
+
+dispatch_stix = {
+    
+    "attack-pattern" :  attack_pattern_typeql_dict,
+    "campaign" :  campaign_typeql_dict,
+    "course-of-action" :  course_of_action_typeql_dict,
+    "grouping" :  grouping_typeql_dict,
+    "identity": identity_typeql_dict,
+    "incident": incident_typeql_dict,
+    "indicator": indicator_typeql_dict,
+    "infrastructure": infrastructure_typeql_dict,
+    "intrusion-set": intrusion_set_typeql_dict,
+    "location": location_typeql_dict,
+    "malware": malware_typeql_dict,
+    "malware-analysis": malware_analysis_typeql_dict,
+    "note" :  note_type_dict,
+    "observed-data" :  observed_data_typeql_dict,
+    "opinion" :  opinion_typeql_dict,
+    "report" :  report_typeql_dict,
+    "threat-actor": threat_actor_typeql_dict,
+    "tool": tool_typeql_dict,
+    "vulnerability": vulnerability_typeql_dict,
+    "relationship": relationship_typeql_dict,
+    "sighting": sighting_typeql_dict,
+    "artifact": artifact_typeql_dict,
+    "autonomous-system": autonomous_system_typeql_dict,
+    "directory": directory_typeql_dict,
+    "domain-name": domain_name_typeql_dict,
+    "email-addr": email_addr_typeql_dict,
+    "email-message": email_message_typeql_dict,
+    "file": file_typeql_dict,
+    "ipv4-addr": ipv4_addr_typeql_dict,
+    "ipv6-addr": ipv6_addr_typeql_dict,
+    "mac-addr": mac_addr_typeql_dict,
+    "mutex": mutex_typeql_dict,
+    "network-traffic": network_traffic_typeql_dict,
+    "process": process_typeql_dict,
+    "software": software_typeql_dict,
+    "url": url_typeql_dict,
+    "user-account": user_account_typeql_dict,
+    "windows-registry-key": windows_registry_key_typeql_dict,
+    "windows-registry-value-type": windows_registry_value_typeql_dict,
+    "x509-certificate": x509_certificate_typeql_dict,
+    "external-reference": ext_ref_typeql_dict,
+    "email-mime-part": email_mime_part_typeql_dict,
+    "archive-ext":  archive_ext_typeql_dict,
+    "ntfs-ext":  ntfs_ext_typeql_dict,
+    "alternate-data-stream": alternate_data_stream_ext_typeql_dict,
+    "pdf-ext": pdf_ext_typeql_dict,
+    "raster-image-ext": raster_image_ext_typeql_dict,
+    "windows-pebinary-ext": windows_pebinary_ext_typeql_dict,
+    "windows-pe-optional-header-type": windows_optional_header_ext_typeql_dict,
+    "windows-pe-section": windows_pe_section_ext_typeql_dict,
+    "http-request-ext": HTTP_request_ext_typeql_dict,
+    "icmp-ext": icmp_ext_typeql_dict,
+    "socket-ext": socket_ext_typeql_dict,
+    "tcp-ext": tcp_ext_typeql_dict,
+    "unix-account-ext": unix_account_ext_typeql_dict,
+    "windows-process-ext": windows_process_ext_typeql_dict,
+    "windows-service-ext": windows_service_ext_typeql_dict,
+    "kill-chain-phase": kill_chain_phases_typeql_dict,
+    "x509-v3-extension": x509_v3_ext_typeql_dict
+}
+
+sdo_obj = [
+    "attack-pattern",
+    "campaign" ,
+    "course-of-action",
+    "grouping",
+    "identity",
+    "incident",
+    "indicator",
+    "infrastructure",
+    "intrusion-set",
+    "location",
+    "malware",
+    "malware-analysis",
+    "note",
+    "observed-data" ,
+    "opinion",
+    "report",
+    "threat-actor",
+    "tool",
+    "vulnerability"
+]
+
+sro_obj = [    
+    "relationship",
+    "sighting",
+    "delivers",
+    "targets",
+    "uses",
+    "attributed-to",
+    "compromises",
+    "originates-from",
+    "investigates",
+    "mitigates",
+    "located-at",
+    "indicates",
+    "based-on",
+    "communicates-with",
+    "consist",
+    "control",
+    "have",
+    "hosts",
+    "ownership",
+    "authored-by",
+    "beacon",
+    "exfiltrate",
+    "download",
+    "drop",
+    "exploit",
+    "variant",
+    "characterise",
+    "impersonate",
+    "av-analysis",
+    "static-analysis",
+    "dynamic-analysis",
+    "remediation"
+]
+
+sco_obj =[   
+    "artifact",
+    "autonomous-system",
+    "directory",
+    "domain-name",
+    "email-addr",
+    "email-message",
+    "file",
+    "ipv4-addr",
+    "ipv6-addr",
+    "mac-addr",
+    "mutex",
+    "network-traffic",
+    "process",
+    "software",
+    "url",
+    "user-account",
+    "windows-registry-key",
+    "windows-registry-value-type",
+    "x509-certificate"
+]    
+    
+meta_obj = [
+    "marking-definition",
+    "tlp-white",
+    "tlp-green",
+    "tlp-amber",
+    "tlp-red",
+    "statement-marking"
+]
+    
+
+dispatch_attack = {}
+
+extensions_only = [
+    "archive-extension",
+    "ntfs-extension",
+    "pdf-extension",
+    "raster-image-extension",
+    "windows-pebinary-extension",
+    "http-request-extension",
+    "icmp-extension",
+    "socket-extension",
+    "tcp-extension",
+    "unix-account-extension",
+    "windows-process-extension",
+    "windows-service-extension"
+]
+
+object_is_list = {
+    "external-reference": [],
+    "email-mime-part": [],
+    "archive-ext":  ["contains_refs"],
+    "ntfs-ext":  ["alternate_data_streams"],
+    "alternate-data-stream": [],
+    "pdf-ext": [],
+    "raster-image-ext": [],
+    "windows-pebinary-ext": ["sections"],
+    "windows-pe-optional-header-type": [],
+    "windows-pe-section": [],
+    "http-request-ext": [],
+    "icmp-ext": [],
+    "socket-ext": [],
+    "tcp-ext": [],
+    "unix-account-ext": ["groups"],
+    "windows-process-ext": [],
+    "windows-service-ext": ["descriptions", "service_dll_refs"],
+    "kill-chain-phase": [],
+    "windows-registry-value-type": [],
+    "x509-v3-extension": []
+}
+
+sdo_is_list = {
+    "sdo": ["labels","external_references", "object_marking_refs", "granular_markings"],
+    "attack-pattern": ["aliases", "kill_chain_phases"],
+    "campaign": ["aliases"],
+    "course-of-action": [],
+    "grouping": ["object_refs"],
+    "identity": ["roles", "sectors"],
+    "incident": [],
+    "indicator": ["indicator_types", "kill_chain_phases"],
+    "infrastructure": ["infrastructure_types", "aliases", "kill_chain_phases"],
+    "intrusion-set": ["aliases", "goals", "secondary_motivations" ],
+    "location": [],
+    "malware": ["malware_types", "kill_chain_phases","aliases", "operating_system_refs", "architecture_execution_envs", "implementation_languages", "capabilities", "sample_refs"],
+    "malware-analysis": ["installed_software_refs", "modules", "analysis_sco_refs"],
+    "note": ["authors", "object_refs"],
+    "observed-data": ["object_refs"],
+    "opinion": ["authors", "object_refs"],
+    "report": ["report_types", "object_refs"],
+    "threat-actor": ["threat_actor_types", "aliases", "roles", "goals","resource-level", "secondary_motivations", "personal_motivations"],
+    "tool": ["tool_types", "kill_chain_phases", "aliases"],
+    "vulnerability": []
+}
+
+sro_is_list = {
+    "sro": ["labels","external_references", "object_marking_refs", "granular_markings"],
+    "sighting": [ "observed_data_refs", "where_sighted_refs"]
+}
+
+sco_is_list = {
+    "sco": ["labels","external_references", "object_marking_refs", "granular_markings"],
+    "artifact": [],
+    "autonomous-system": [],
+    "directory": ["contains_refs"],
+    "domain-name": ["resolves_to_refs"],
+    "email-addr": [],
+    "email-message": ["to_refs", "cc_refs", "bcc_refs", "received_lines", "body_multipart"],
+    "email-mime-part": [],
+    "file": ["contains_refs"],    
+    "archive-ext":  ["contains_refs"],
+    "ntfs-ext":  ["alternate_data_streams"],
+    "alternate-data-stream-type": [],
+    "pdf-ext": [],
+    "raster-image-ext": [],
+    "windows-pebinary-ext": ["sections"],
+    "windows-pe-optional-header-type": [],
+    "windows-pe-section-type": [],
+    "ipv4-addr": ["resolves_to_refs", "belongs_to_refs"],
+    "ipv6-addr": ["resolves_to_refs", "belongs_to_refs"],
+    "mac-addr": [],
+    "mutex": [],
+    "network-traffic": [ "protocols", "encapsulates_refs"],
+    "http-request-ext": [],
+    "icmp-ext": [],
+    "socket-ext": [],
+    "tcp-ext": [],
+    "process": ["opened_connection_refs", "child_refs"],
+    "windows-process-ext": [],
+    "windows-service-ext": ["descriptions", "service_dll_refs"],
+    "software": ["languages"],
+    "url": [],
+    "user-account": [],
+    "unix-account-ext": ["groups"],
+    "windows-registry-key": ["values"],
+    "windows-registry-value-type": [],
+    "x509-certificate": [],
+    "x509-v3-extensions-type": []
 }
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/stix21/generator.py` & `stixorm-0.1.9/stixorm/module/definitions/stix21/generator.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-"""
-This history all the dictionary definitions and save them as JSON objects
-"""
-
-__author__ = "Paolo Di Prodi"
-__credits__ = ["Brett Forbes"]
-__license__ = "GPL"
-__version__ = "0.1.0"
-__maintainer__ = "Paolo Di Prodi"
-__email__ = "paolo@priam.ai"
-__status__ = "Production"
-
-import json
-import definitions
-import os
-
-os.makedirs('data', exist_ok=True)
-
-for id in dir(definitions):
-    obj = getattr(definitions,id)
-
-    # filter the dictionary objects only
-    if isinstance(obj, dict) and id!='__builtins__':
-        # save the object as dictionary
-        with open(f'data/{id}.json', 'w') as file:
-            json.dump(obj,file)
-
-    if isinstance(obj, list) and id!='__builtins__':
-        # save the object as dictionary
-        with open(f'data/{id}.json', 'w') as file:
-            json.dump(obj,file)
-
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+"""
+This history all the dictionary definitions and save them as JSON objects
+"""
+
+__author__ = "Paolo Di Prodi"
+__credits__ = ["Brett Forbes"]
+__license__ = "GPL"
+__version__ = "0.1.0"
+__maintainer__ = "Paolo Di Prodi"
+__email__ = "paolo@priam.ai"
+__status__ = "Production"
+
+import json
+import definitions
+import os
+
+os.makedirs('data', exist_ok=True)
+
+for id in dir(definitions):
+    obj = getattr(definitions,id)
+
+    # filter the dictionary objects only
+    if isinstance(obj, dict) and id!='__builtins__':
+        # save the object as dictionary
+        with open(f'data/{id}.json', 'w') as file:
+            json.dump(obj,file)
+
+    if isinstance(obj, list) and id!='__builtins__':
+        # save the object as dictionary
+        with open(f'data/{id}.json', 'w') as file:
+            json.dump(obj,file)
+
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/stix21/mappings/is_list_sub_objects.json` & `stixorm-0.1.9/stixorm/module/definitions/stix21/mappings/is_list_sub_objects.json`

 * *Files identical despite different names*

### Comparing `stixorm-0.1.3/stixorm/module/definitions/stix21/mappings/relations_extensions_and_objects.json` & `stixorm-0.1.9/stixorm/module/definitions/stix21/mappings/relations_extensions_and_objects.json`

 * *Format-specific differences are supported for JSON files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: JSON text data*

 * *Files 24% similar despite different names*

```diff
@@ -1,163 +1,170 @@
-00000000: 5b0a 2020 7b0a 2020 2020 2273 7469 7822  [.  {.    "stix"
-00000010: 3a20 2261 6c74 6572 6e61 7465 5f64 6174  : "alternate_dat
-00000020: 615f 7374 7265 616d 7322 2c0a 2020 2020  a_streams",.    
-00000030: 226f 626a 6563 7422 3a20 2261 6c74 6572  "object": "alter
-00000040: 6e61 7465 2d64 6174 612d 7374 7265 616d  nate-data-stream
-00000050: 222c 0a20 2020 2022 7265 6c61 7469 6f6e  ",.    "relation
-00000060: 223a 2022 616c 742d 6461 7461 2d73 7472  ": "alt-data-str
-00000070: 6561 6d73 222c 0a20 2020 2022 6f77 6e65  eams",.    "owne
-00000080: 7222 3a20 226e 7466 732d 6578 7422 2c0a  r": "ntfs-ext",.
-00000090: 2020 2020 2270 6f69 6e74 6564 2d74 6f22      "pointed-to"
-000000a0: 3a20 2261 6c74 2d64 6174 612d 7374 7265  : "alt-data-stre
-000000b0: 616d 220a 2020 7d2c 0a20 207b 0a20 2020  am".  },.  {.   
-000000c0: 2022 7374 6978 223a 2022 6172 6368 6976   "stix": "archiv
-000000d0: 652d 6578 7422 2c0a 2020 2020 226f 626a  e-ext",.    "obj
-000000e0: 6563 7422 3a20 2261 7263 6869 7665 2d65  ect": "archive-e
-000000f0: 7874 222c 0a20 2020 2022 7265 6c61 7469  xt",.    "relati
-00000100: 6f6e 223a 2022 6172 6368 6976 652d 6578  on": "archive-ex
-00000110: 7465 6e73 696f 6e22 2c0a 2020 2020 226f  tension",.    "o
-00000120: 776e 6572 223a 2022 6669 6c65 222c 0a20  wner": "file",. 
-00000130: 2020 2022 706f 696e 7465 642d 746f 223a     "pointed-to":
-00000140: 2022 616e 2d61 7263 6869 7665 220a 2020   "an-archive".  
-00000150: 7d2c 0a20 207b 0a20 2020 2022 7374 6978  },.  {.    "stix
-00000160: 223a 2022 6874 7470 2d72 6571 7565 7374  ": "http-request
-00000170: 2d65 7874 222c 0a20 2020 2022 6f62 6a65  -ext",.    "obje
-00000180: 6374 223a 2022 6874 7470 2d72 6571 7565  ct": "http-reque
-00000190: 7374 2d65 7874 222c 0a20 2020 2022 7265  st-ext",.    "re
-000001a0: 6c61 7469 6f6e 223a 2022 6874 7470 2d72  lation": "http-r
-000001b0: 6571 7565 7374 2d65 7874 656e 7369 6f6e  equest-extension
-000001c0: 222c 0a20 2020 2022 6f77 6e65 7222 3a20  ",.    "owner": 
-000001d0: 2274 7261 6666 6963 222c 0a20 2020 2022  "traffic",.    "
-000001e0: 706f 696e 7465 642d 746f 223a 2022 7265  pointed-to": "re
-000001f0: 7175 6573 7422 0a20 207d 2c0a 2020 7b0a  quest".  },.  {.
-00000200: 2020 2020 2273 7469 7822 3a20 2269 636d      "stix": "icm
-00000210: 702d 6578 7422 2c0a 2020 2020 226f 626a  p-ext",.    "obj
-00000220: 6563 7422 3a20 2269 636d 702d 6578 7422  ect": "icmp-ext"
-00000230: 2c0a 2020 2020 2272 656c 6174 696f 6e22  ,.    "relation"
-00000240: 3a20 2269 636d 702d 6578 7465 6e73 696f  : "icmp-extensio
-00000250: 6e22 2c0a 2020 2020 226f 776e 6572 223a  n",.    "owner":
-00000260: 2022 7472 6166 6669 6322 2c0a 2020 2020   "traffic",.    
-00000270: 2270 6f69 6e74 6564 2d74 6f22 3a20 2269  "pointed-to": "i
-00000280: 636d 7022 0a20 207d 2c0a 2020 7b0a 2020  cmp".  },.  {.  
-00000290: 2020 2273 7469 7822 3a20 226e 7466 732d    "stix": "ntfs-
-000002a0: 6578 7422 2c0a 2020 2020 226f 626a 6563  ext",.    "objec
-000002b0: 7422 3a20 226e 7466 732d 6578 7422 2c0a  t": "ntfs-ext",.
-000002c0: 2020 2020 2272 656c 6174 696f 6e22 3a20      "relation": 
-000002d0: 226e 7466 732d 6578 7465 6e73 696f 6e22  "ntfs-extension"
-000002e0: 2c0a 2020 2020 226f 776e 6572 223a 2022  ,.    "owner": "
-000002f0: 6669 6c65 222c 0a20 2020 2022 706f 696e  file",.    "poin
-00000300: 7465 642d 746f 223a 2022 6e74 6673 220a  ted-to": "ntfs".
-00000310: 2020 7d2c 0a20 207b 0a20 2020 2022 7374    },.  {.    "st
-00000320: 6978 223a 2022 7064 662d 6578 7422 2c0a  ix": "pdf-ext",.
-00000330: 2020 2020 226f 626a 6563 7422 3a20 2270      "object": "p
-00000340: 6466 2d65 7874 222c 0a20 2020 2022 7265  df-ext",.    "re
-00000350: 6c61 7469 6f6e 223a 2022 7064 662d 6578  lation": "pdf-ex
-00000360: 7465 6e73 696f 6e22 2c0a 2020 2020 226f  tension",.    "o
-00000370: 776e 6572 223a 2022 6669 6c65 222c 0a20  wner": "file",. 
-00000380: 2020 2022 706f 696e 7465 642d 746f 223a     "pointed-to":
-00000390: 2022 7064 6622 0a20 207d 2c0a 2020 7b0a   "pdf".  },.  {.
-000003a0: 2020 2020 2273 7469 7822 3a20 2272 6173      "stix": "ras
-000003b0: 7465 722d 696d 6167 652d 6578 7422 2c0a  ter-image-ext",.
-000003c0: 2020 2020 226f 626a 6563 7422 3a20 2272      "object": "r
-000003d0: 6173 7465 722d 696d 6167 652d 6578 7422  aster-image-ext"
-000003e0: 2c0a 2020 2020 2272 656c 6174 696f 6e22  ,.    "relation"
-000003f0: 3a20 2272 6173 7465 722d 696d 6167 652d  : "raster-image-
-00000400: 6578 7465 6e73 696f 6e22 2c0a 2020 2020  extension",.    
-00000410: 226f 776e 6572 223a 2022 6669 6c65 222c  "owner": "file",
-00000420: 0a20 2020 2022 706f 696e 7465 642d 746f  .    "pointed-to
-00000430: 223a 2022 696d 6167 6522 0a20 207d 2c0a  ": "image".  },.
-00000440: 2020 7b0a 2020 2020 2273 7469 7822 3a20    {.    "stix": 
-00000450: 2273 6f63 6b65 742d 6578 7422 2c0a 2020  "socket-ext",.  
-00000460: 2020 226f 626a 6563 7422 3a20 2273 6f63    "object": "soc
-00000470: 6b65 742d 6578 7422 2c0a 2020 2020 2272  ket-ext",.    "r
-00000480: 656c 6174 696f 6e22 3a20 2273 6f63 6b65  elation": "socke
-00000490: 742d 6578 7465 6e73 696f 6e22 2c0a 2020  t-extension",.  
-000004a0: 2020 226f 776e 6572 223a 2022 7472 6166    "owner": "traf
-000004b0: 6669 6322 2c0a 2020 2020 2270 6f69 6e74  fic",.    "point
-000004c0: 6564 2d74 6f22 3a20 2273 6f63 6b65 7422  ed-to": "socket"
-000004d0: 0a20 207d 2c0a 2020 7b0a 2020 2020 2273  .  },.  {.    "s
-000004e0: 7469 7822 3a20 2274 6370 2d65 7874 222c  tix": "tcp-ext",
-000004f0: 0a20 2020 2022 6f62 6a65 6374 223a 2022  .    "object": "
-00000500: 7463 702d 6578 7422 2c0a 2020 2020 2272  tcp-ext",.    "r
-00000510: 656c 6174 696f 6e22 3a20 2274 6370 2d65  elation": "tcp-e
-00000520: 7874 656e 7369 6f6e 222c 0a20 2020 2022  xtension",.    "
-00000530: 6f77 6e65 7222 3a20 2274 7261 6666 6963  owner": "traffic
-00000540: 222c 0a20 2020 2022 706f 696e 7465 642d  ",.    "pointed-
-00000550: 746f 223a 2022 7463 7022 0a20 207d 2c0a  to": "tcp".  },.
-00000560: 2020 7b0a 2020 2020 2273 7469 7822 3a20    {.    "stix": 
-00000570: 2275 6e69 782d 6163 636f 756e 742d 6578  "unix-account-ex
-00000580: 7422 2c0a 2020 2020 226f 626a 6563 7422  t",.    "object"
-00000590: 3a20 2275 6e69 782d 6163 636f 756e 742d  : "unix-account-
-000005a0: 6578 7422 2c0a 2020 2020 2272 656c 6174  ext",.    "relat
-000005b0: 696f 6e22 3a20 2275 6e69 782d 6163 636f  ion": "unix-acco
-000005c0: 756e 742d 6578 7465 6e73 696f 6e22 2c0a  unt-extension",.
-000005d0: 2020 2020 226f 776e 6572 223a 2022 6163      "owner": "ac
-000005e0: 636f 756e 7422 2c0a 2020 2020 2270 6f69  count",.    "poi
-000005f0: 6e74 6564 2d74 6f22 3a20 2275 6e69 7822  nted-to": "unix"
-00000600: 0a20 207d 2c0a 2020 7b0a 2020 2020 2273  .  },.  {.    "s
-00000610: 7469 7822 3a20 2277 696e 646f 7773 2d70  tix": "windows-p
-00000620: 6562 696e 6172 792d 6578 7422 2c0a 2020  ebinary-ext",.  
-00000630: 2020 226f 626a 6563 7422 3a20 2277 696e    "object": "win
-00000640: 646f 7773 2d70 6562 696e 6172 792d 6578  dows-pebinary-ex
-00000650: 7422 2c0a 2020 2020 2272 656c 6174 696f  t",.    "relatio
-00000660: 6e22 3a20 2277 696e 646f 7773 2d70 6562  n": "windows-peb
-00000670: 696e 6172 792d 6578 7465 6e73 696f 6e22  inary-extension"
-00000680: 2c0a 2020 2020 226f 776e 6572 223a 2022  ,.    "owner": "
-00000690: 6669 6c65 222c 0a20 2020 2022 706f 696e  file",.    "poin
-000006a0: 7465 642d 746f 223a 2022 7065 6269 6e61  ted-to": "pebina
-000006b0: 7279 220a 2020 7d2c 0a20 207b 0a20 2020  ry".  },.  {.   
-000006c0: 2022 7374 6978 223a 2022 7769 6e64 6f77   "stix": "window
-000006d0: 732d 7065 2d73 6563 7469 6f6e 2d74 7970  s-pe-section-typ
-000006e0: 6522 2c0a 2020 2020 226f 626a 6563 7422  e",.    "object"
-000006f0: 3a20 2277 696e 646f 7773 2d70 652d 7365  : "windows-pe-se
-00000700: 6374 696f 6e22 2c0a 2020 2020 2272 656c  ction",.    "rel
-00000710: 6174 696f 6e22 3a20 2273 6563 7469 6f6e  ation": "section
-00000720: 7322 2c0a 2020 2020 226f 776e 6572 223a  s",.    "owner":
-00000730: 2022 7065 6269 6e61 7279 222c 0a20 2020   "pebinary",.   
-00000740: 2022 706f 696e 7465 642d 746f 223a 2022   "pointed-to": "
-00000750: 7065 2d73 6563 7469 6f6e 220a 2020 7d2c  pe-section".  },
-00000760: 0a20 207b 0a20 2020 2022 7374 6978 223a  .  {.    "stix":
-00000770: 2022 7769 6e64 6f77 732d 7072 6f63 6573   "windows-proces
-00000780: 732d 6578 7422 2c0a 2020 2020 226f 626a  s-ext",.    "obj
-00000790: 6563 7422 3a20 2277 696e 646f 7773 2d70  ect": "windows-p
-000007a0: 726f 6365 7373 2d65 7874 222c 0a20 2020  rocess-ext",.   
-000007b0: 2022 7265 6c61 7469 6f6e 223a 2022 7769   "relation": "wi
-000007c0: 6e64 6f77 732d 7072 6f63 6573 732d 6578  ndows-process-ex
-000007d0: 7465 6e73 696f 6e22 2c0a 2020 2020 226f  tension",.    "o
-000007e0: 776e 6572 223a 2022 7072 6f63 6573 7322  wner": "process"
-000007f0: 2c0a 2020 2020 2270 6f69 6e74 6564 2d74  ,.    "pointed-t
-00000800: 6f22 3a20 2277 696e 2d70 726f 6365 7373  o": "win-process
-00000810: 220a 2020 7d2c 0a20 207b 0a20 2020 2022  ".  },.  {.    "
-00000820: 7374 6978 223a 2022 7769 6e64 6f77 732d  stix": "windows-
-00000830: 7365 7276 6963 652d 6578 7422 2c0a 2020  service-ext",.  
-00000840: 2020 226f 626a 6563 7422 3a20 2277 696e    "object": "win
-00000850: 646f 7773 2d73 6572 7669 6365 2d65 7874  dows-service-ext
-00000860: 222c 0a20 2020 2022 7265 6c61 7469 6f6e  ",.    "relation
-00000870: 223a 2022 7769 6e64 6f77 732d 7365 7276  ": "windows-serv
-00000880: 6963 652d 6578 7465 6e73 696f 6e22 2c0a  ice-extension",.
-00000890: 2020 2020 226f 776e 6572 223a 2022 7072      "owner": "pr
-000008a0: 6f63 6573 7322 2c0a 2020 2020 2270 6f69  ocess",.    "poi
-000008b0: 6e74 6564 2d74 6f22 3a20 2277 696e 2d73  nted-to": "win-s
-000008c0: 6572 7669 6365 220a 2020 7d2c 0a20 207b  ervice".  },.  {
-000008d0: 0a20 2020 2022 7374 6978 223a 2022 7835  .    "stix": "x5
-000008e0: 3039 5f76 335f 6578 7465 6e73 696f 6e73  09_v3_extensions
-000008f0: 222c 0a20 2020 2022 6f62 6a65 6374 223a  ",.    "object":
-00000900: 2022 7835 3039 2d76 332d 6578 7465 6e73   "x509-v3-extens
-00000910: 696f 6e22 2c0a 2020 2020 2272 656c 6174  ion",.    "relat
-00000920: 696f 6e22 3a20 2276 332d 6578 7465 6e73  ion": "v3-extens
-00000930: 696f 6e73 222c 0a20 2020 2022 6f77 6e65  ions",.    "owne
-00000940: 7222 3a20 2263 6572 7422 2c0a 2020 2020  r": "cert",.    
-00000950: 2270 6f69 6e74 6564 2d74 6f22 3a20 2276  "pointed-to": "v
-00000960: 332d 6578 7465 6e73 696f 6e22 0a20 207d  3-extension".  }
-00000970: 2c0a 2020 7b0a 2020 2020 2273 7469 7822  ,.  {.    "stix"
-00000980: 3a20 226f 7074 696f 6e61 6c5f 6865 6164  : "optional_head
-00000990: 6572 222c 0a20 2020 2022 6f62 6a65 6374  er",.    "object
-000009a0: 223a 2022 7769 6e64 6f77 732d 7065 2d6f  ": "windows-pe-o
-000009b0: 7074 696f 6e61 6c2d 6865 6164 6572 2d74  ptional-header-t
-000009c0: 7970 6522 2c0a 2020 2020 2272 656c 6174  ype",.    "relat
-000009d0: 696f 6e22 3a20 226f 7074 696f 6e61 6c2d  ion": "optional-
-000009e0: 6865 6164 6572 7322 2c0a 2020 2020 226f  headers",.    "o
-000009f0: 776e 6572 223a 2022 7065 6269 6e61 7279  wner": "pebinary
-00000a00: 222c 0a20 2020 2022 706f 696e 7465 642d  ",.    "pointed-
-00000a10: 746f 223a 2022 6f70 7469 6f6e 616c 2d68  to": "optional-h
-00000a20: 6561 6465 7222 0a20 207d 0a5d            eader".  }.]
+00000000: 5b0d 0a20 207b 0d0a 2020 2020 2273 7469  [..  {..    "sti
+00000010: 7822 3a20 2261 6c74 6572 6e61 7465 5f64  x": "alternate_d
+00000020: 6174 615f 7374 7265 616d 7322 2c0d 0a20  ata_streams",.. 
+00000030: 2020 2022 6f62 6a65 6374 223a 2022 616c     "object": "al
+00000040: 7465 726e 6174 652d 6461 7461 2d73 7472  ternate-data-str
+00000050: 6561 6d22 2c0d 0a20 2020 2022 7265 6c61  eam",..    "rela
+00000060: 7469 6f6e 223a 2022 616c 742d 6461 7461  tion": "alt-data
+00000070: 2d73 7472 6561 6d73 222c 0d0a 2020 2020  -streams",..    
+00000080: 226f 776e 6572 223a 2022 6e74 6673 2d65  "owner": "ntfs-e
+00000090: 7874 222c 0d0a 2020 2020 2270 6f69 6e74  xt",..    "point
+000000a0: 6564 2d74 6f22 3a20 2261 6c74 2d64 6174  ed-to": "alt-dat
+000000b0: 612d 7374 7265 616d 220d 0a20 207d 2c0d  a-stream"..  },.
+000000c0: 0a20 207b 0d0a 2020 2020 2273 7469 7822  .  {..    "stix"
+000000d0: 3a20 2261 7263 6869 7665 2d65 7874 222c  : "archive-ext",
+000000e0: 0d0a 2020 2020 226f 626a 6563 7422 3a20  ..    "object": 
+000000f0: 2261 7263 6869 7665 2d65 7874 222c 0d0a  "archive-ext",..
+00000100: 2020 2020 2272 656c 6174 696f 6e22 3a20      "relation": 
+00000110: 2261 7263 6869 7665 2d65 7874 656e 7369  "archive-extensi
+00000120: 6f6e 222c 0d0a 2020 2020 226f 776e 6572  on",..    "owner
+00000130: 223a 2022 6669 6c65 222c 0d0a 2020 2020  ": "file",..    
+00000140: 2270 6f69 6e74 6564 2d74 6f22 3a20 2261  "pointed-to": "a
+00000150: 6e2d 6172 6368 6976 6522 0d0a 2020 7d2c  n-archive"..  },
+00000160: 0d0a 2020 7b0d 0a20 2020 2022 7374 6978  ..  {..    "stix
+00000170: 223a 2022 6874 7470 2d72 6571 7565 7374  ": "http-request
+00000180: 2d65 7874 222c 0d0a 2020 2020 226f 626a  -ext",..    "obj
+00000190: 6563 7422 3a20 2268 7474 702d 7265 7175  ect": "http-requ
+000001a0: 6573 742d 6578 7422 2c0d 0a20 2020 2022  est-ext",..    "
+000001b0: 7265 6c61 7469 6f6e 223a 2022 6874 7470  relation": "http
+000001c0: 2d72 6571 7565 7374 2d65 7874 656e 7369  -request-extensi
+000001d0: 6f6e 222c 0d0a 2020 2020 226f 776e 6572  on",..    "owner
+000001e0: 223a 2022 7472 6166 6669 6322 2c0d 0a20  ": "traffic",.. 
+000001f0: 2020 2022 706f 696e 7465 642d 746f 223a     "pointed-to":
+00000200: 2022 7265 7175 6573 7422 0d0a 2020 7d2c   "request"..  },
+00000210: 0d0a 2020 7b0d 0a20 2020 2022 7374 6978  ..  {..    "stix
+00000220: 223a 2022 6963 6d70 2d65 7874 222c 0d0a  ": "icmp-ext",..
+00000230: 2020 2020 226f 626a 6563 7422 3a20 2269      "object": "i
+00000240: 636d 702d 6578 7422 2c0d 0a20 2020 2022  cmp-ext",..    "
+00000250: 7265 6c61 7469 6f6e 223a 2022 6963 6d70  relation": "icmp
+00000260: 2d65 7874 656e 7369 6f6e 222c 0d0a 2020  -extension",..  
+00000270: 2020 226f 776e 6572 223a 2022 7472 6166    "owner": "traf
+00000280: 6669 6322 2c0d 0a20 2020 2022 706f 696e  fic",..    "poin
+00000290: 7465 642d 746f 223a 2022 6963 6d70 220d  ted-to": "icmp".
+000002a0: 0a20 207d 2c0d 0a20 207b 0d0a 2020 2020  .  },..  {..    
+000002b0: 2273 7469 7822 3a20 226e 7466 732d 6578  "stix": "ntfs-ex
+000002c0: 7422 2c0d 0a20 2020 2022 6f62 6a65 6374  t",..    "object
+000002d0: 223a 2022 6e74 6673 2d65 7874 222c 0d0a  ": "ntfs-ext",..
+000002e0: 2020 2020 2272 656c 6174 696f 6e22 3a20      "relation": 
+000002f0: 226e 7466 732d 6578 7465 6e73 696f 6e22  "ntfs-extension"
+00000300: 2c0d 0a20 2020 2022 6f77 6e65 7222 3a20  ,..    "owner": 
+00000310: 2266 696c 6522 2c0d 0a20 2020 2022 706f  "file",..    "po
+00000320: 696e 7465 642d 746f 223a 2022 6e74 6673  inted-to": "ntfs
+00000330: 220d 0a20 207d 2c0d 0a20 207b 0d0a 2020  "..  },..  {..  
+00000340: 2020 2273 7469 7822 3a20 2270 6466 2d65    "stix": "pdf-e
+00000350: 7874 222c 0d0a 2020 2020 226f 626a 6563  xt",..    "objec
+00000360: 7422 3a20 2270 6466 2d65 7874 222c 0d0a  t": "pdf-ext",..
+00000370: 2020 2020 2272 656c 6174 696f 6e22 3a20      "relation": 
+00000380: 2270 6466 2d65 7874 656e 7369 6f6e 222c  "pdf-extension",
+00000390: 0d0a 2020 2020 226f 776e 6572 223a 2022  ..    "owner": "
+000003a0: 6669 6c65 222c 0d0a 2020 2020 2270 6f69  file",..    "poi
+000003b0: 6e74 6564 2d74 6f22 3a20 2270 6466 220d  nted-to": "pdf".
+000003c0: 0a20 207d 2c0d 0a20 207b 0d0a 2020 2020  .  },..  {..    
+000003d0: 2273 7469 7822 3a20 2272 6173 7465 722d  "stix": "raster-
+000003e0: 696d 6167 652d 6578 7422 2c0d 0a20 2020  image-ext",..   
+000003f0: 2022 6f62 6a65 6374 223a 2022 7261 7374   "object": "rast
+00000400: 6572 2d69 6d61 6765 2d65 7874 222c 0d0a  er-image-ext",..
+00000410: 2020 2020 2272 656c 6174 696f 6e22 3a20      "relation": 
+00000420: 2272 6173 7465 722d 696d 6167 652d 6578  "raster-image-ex
+00000430: 7465 6e73 696f 6e22 2c0d 0a20 2020 2022  tension",..    "
+00000440: 6f77 6e65 7222 3a20 2266 696c 6522 2c0d  owner": "file",.
+00000450: 0a20 2020 2022 706f 696e 7465 642d 746f  .    "pointed-to
+00000460: 223a 2022 696d 6167 6522 0d0a 2020 7d2c  ": "image"..  },
+00000470: 0d0a 2020 7b0d 0a20 2020 2022 7374 6978  ..  {..    "stix
+00000480: 223a 2022 736f 636b 6574 2d65 7874 222c  ": "socket-ext",
+00000490: 0d0a 2020 2020 226f 626a 6563 7422 3a20  ..    "object": 
+000004a0: 2273 6f63 6b65 742d 6578 7422 2c0d 0a20  "socket-ext",.. 
+000004b0: 2020 2022 7265 6c61 7469 6f6e 223a 2022     "relation": "
+000004c0: 736f 636b 6574 2d65 7874 656e 7369 6f6e  socket-extension
+000004d0: 222c 0d0a 2020 2020 226f 776e 6572 223a  ",..    "owner":
+000004e0: 2022 7472 6166 6669 6322 2c0d 0a20 2020   "traffic",..   
+000004f0: 2022 706f 696e 7465 642d 746f 223a 2022   "pointed-to": "
+00000500: 736f 636b 6574 220d 0a20 207d 2c0d 0a20  socket"..  },.. 
+00000510: 207b 0d0a 2020 2020 2273 7469 7822 3a20   {..    "stix": 
+00000520: 2274 6370 2d65 7874 222c 0d0a 2020 2020  "tcp-ext",..    
+00000530: 226f 626a 6563 7422 3a20 2274 6370 2d65  "object": "tcp-e
+00000540: 7874 222c 0d0a 2020 2020 2272 656c 6174  xt",..    "relat
+00000550: 696f 6e22 3a20 2274 6370 2d65 7874 656e  ion": "tcp-exten
+00000560: 7369 6f6e 222c 0d0a 2020 2020 226f 776e  sion",..    "own
+00000570: 6572 223a 2022 7472 6166 6669 6322 2c0d  er": "traffic",.
+00000580: 0a20 2020 2022 706f 696e 7465 642d 746f  .    "pointed-to
+00000590: 223a 2022 7463 7022 0d0a 2020 7d2c 0d0a  ": "tcp"..  },..
+000005a0: 2020 7b0d 0a20 2020 2022 7374 6978 223a    {..    "stix":
+000005b0: 2022 756e 6978 2d61 6363 6f75 6e74 2d65   "unix-account-e
+000005c0: 7874 222c 0d0a 2020 2020 226f 626a 6563  xt",..    "objec
+000005d0: 7422 3a20 2275 6e69 782d 6163 636f 756e  t": "unix-accoun
+000005e0: 742d 6578 7422 2c0d 0a20 2020 2022 7265  t-ext",..    "re
+000005f0: 6c61 7469 6f6e 223a 2022 756e 6978 2d61  lation": "unix-a
+00000600: 6363 6f75 6e74 2d65 7874 656e 7369 6f6e  ccount-extension
+00000610: 222c 0d0a 2020 2020 226f 776e 6572 223a  ",..    "owner":
+00000620: 2022 6163 636f 756e 7422 2c0d 0a20 2020   "account",..   
+00000630: 2022 706f 696e 7465 642d 746f 223a 2022   "pointed-to": "
+00000640: 756e 6978 220d 0a20 207d 2c0d 0a20 207b  unix"..  },..  {
+00000650: 0d0a 2020 2020 2273 7469 7822 3a20 2277  ..    "stix": "w
+00000660: 696e 646f 7773 2d70 6562 696e 6172 792d  indows-pebinary-
+00000670: 6578 7422 2c0d 0a20 2020 2022 6f62 6a65  ext",..    "obje
+00000680: 6374 223a 2022 7769 6e64 6f77 732d 7065  ct": "windows-pe
+00000690: 6269 6e61 7279 2d65 7874 222c 0d0a 2020  binary-ext",..  
+000006a0: 2020 2272 656c 6174 696f 6e22 3a20 2277    "relation": "w
+000006b0: 696e 646f 7773 2d70 6562 696e 6172 792d  indows-pebinary-
+000006c0: 6578 7465 6e73 696f 6e22 2c0d 0a20 2020  extension",..   
+000006d0: 2022 6f77 6e65 7222 3a20 2266 696c 6522   "owner": "file"
+000006e0: 2c0d 0a20 2020 2022 706f 696e 7465 642d  ,..    "pointed-
+000006f0: 746f 223a 2022 7065 6269 6e61 7279 220d  to": "pebinary".
+00000700: 0a20 207d 2c0d 0a20 207b 0d0a 2020 2020  .  },..  {..    
+00000710: 2273 7469 7822 3a20 2277 696e 646f 7773  "stix": "windows
+00000720: 2d70 652d 7365 6374 696f 6e2d 7479 7065  -pe-section-type
+00000730: 222c 0d0a 2020 2020 226f 626a 6563 7422  ",..    "object"
+00000740: 3a20 2277 696e 646f 7773 2d70 652d 7365  : "windows-pe-se
+00000750: 6374 696f 6e22 2c0d 0a20 2020 2022 7265  ction",..    "re
+00000760: 6c61 7469 6f6e 223a 2022 7365 6374 696f  lation": "sectio
+00000770: 6e73 222c 0d0a 2020 2020 226f 776e 6572  ns",..    "owner
+00000780: 223a 2022 7065 6269 6e61 7279 222c 0d0a  ": "pebinary",..
+00000790: 2020 2020 2270 6f69 6e74 6564 2d74 6f22      "pointed-to"
+000007a0: 3a20 2270 652d 7365 6374 696f 6e22 0d0a  : "pe-section"..
+000007b0: 2020 7d2c 0d0a 2020 7b0d 0a20 2020 2022    },..  {..    "
+000007c0: 7374 6978 223a 2022 7769 6e64 6f77 732d  stix": "windows-
+000007d0: 7072 6f63 6573 732d 6578 7422 2c0d 0a20  process-ext",.. 
+000007e0: 2020 2022 6f62 6a65 6374 223a 2022 7769     "object": "wi
+000007f0: 6e64 6f77 732d 7072 6f63 6573 732d 6578  ndows-process-ex
+00000800: 7422 2c0d 0a20 2020 2022 7265 6c61 7469  t",..    "relati
+00000810: 6f6e 223a 2022 7769 6e64 6f77 732d 7072  on": "windows-pr
+00000820: 6f63 6573 732d 6578 7465 6e73 696f 6e22  ocess-extension"
+00000830: 2c0d 0a20 2020 2022 6f77 6e65 7222 3a20  ,..    "owner": 
+00000840: 2270 726f 6365 7373 222c 0d0a 2020 2020  "process",..    
+00000850: 2270 6f69 6e74 6564 2d74 6f22 3a20 2277  "pointed-to": "w
+00000860: 696e 2d70 726f 6365 7373 220d 0a20 207d  in-process"..  }
+00000870: 2c0d 0a20 207b 0d0a 2020 2020 2273 7469  ,..  {..    "sti
+00000880: 7822 3a20 2277 696e 646f 7773 2d73 6572  x": "windows-ser
+00000890: 7669 6365 2d65 7874 222c 0d0a 2020 2020  vice-ext",..    
+000008a0: 226f 626a 6563 7422 3a20 2277 696e 646f  "object": "windo
+000008b0: 7773 2d73 6572 7669 6365 2d65 7874 222c  ws-service-ext",
+000008c0: 0d0a 2020 2020 2272 656c 6174 696f 6e22  ..    "relation"
+000008d0: 3a20 2277 696e 646f 7773 2d73 6572 7669  : "windows-servi
+000008e0: 6365 2d65 7874 656e 7369 6f6e 222c 0d0a  ce-extension",..
+000008f0: 2020 2020 226f 776e 6572 223a 2022 7072      "owner": "pr
+00000900: 6f63 6573 7322 2c0d 0a20 2020 2022 706f  ocess",..    "po
+00000910: 696e 7465 642d 746f 223a 2022 7769 6e2d  inted-to": "win-
+00000920: 7365 7276 6963 6522 0d0a 2020 7d2c 0d0a  service"..  },..
+00000930: 2020 7b0d 0a20 2020 2022 7374 6978 223a    {..    "stix":
+00000940: 2022 7835 3039 5f76 335f 6578 7465 6e73   "x509_v3_extens
+00000950: 696f 6e73 222c 0d0a 2020 2020 226f 626a  ions",..    "obj
+00000960: 6563 7422 3a20 2278 3530 392d 7633 2d65  ect": "x509-v3-e
+00000970: 7874 656e 7369 6f6e 222c 0d0a 2020 2020  xtension",..    
+00000980: 2272 656c 6174 696f 6e22 3a20 2276 332d  "relation": "v3-
+00000990: 6578 7465 6e73 696f 6e73 222c 0d0a 2020  extensions",..  
+000009a0: 2020 226f 776e 6572 223a 2022 6365 7274    "owner": "cert
+000009b0: 222c 0d0a 2020 2020 2270 6f69 6e74 6564  ",..    "pointed
+000009c0: 2d74 6f22 3a20 2276 332d 6578 7465 6e73  -to": "v3-extens
+000009d0: 696f 6e22 0d0a 2020 7d2c 0d0a 2020 7b0d  ion"..  },..  {.
+000009e0: 0a20 2020 2022 7374 6978 223a 2022 6f70  .    "stix": "op
+000009f0: 7469 6f6e 616c 5f68 6561 6465 7222 2c0d  tional_header",.
+00000a00: 0a20 2020 2022 6f62 6a65 6374 223a 2022  .    "object": "
+00000a10: 7769 6e64 6f77 732d 7065 2d6f 7074 696f  windows-pe-optio
+00000a20: 6e61 6c2d 6865 6164 6572 2d74 7970 6522  nal-header-type"
+00000a30: 2c0d 0a20 2020 2022 7265 6c61 7469 6f6e  ,..    "relation
+00000a40: 223a 2022 6f70 7469 6f6e 616c 2d68 6561  ": "optional-hea
+00000a50: 6465 7273 222c 0d0a 2020 2020 226f 776e  ders",..    "own
+00000a60: 6572 223a 2022 7065 6269 6e61 7279 222c  er": "pebinary",
+00000a70: 0d0a 2020 2020 2270 6f69 6e74 6564 2d74  ..    "pointed-t
+00000a80: 6f22 3a20 226f 7074 696f 6e61 6c2d 6865  o": "optional-he
+00000a90: 6164 6572 220d 0a20 207d 0d0a 5d         ader"..  }..]
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/stix21/mappings/relations_key_value.json` & `stixorm-0.1.9/stixorm/module/definitions/stix21/mappings/relations_key_value.json`

 * *Format-specific differences are supported for JSON files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: JSON text data*

 * *Files 20% similar despite different names*

```diff
@@ -1,87 +1,91 @@
-00000000: 5b0a 2020 7b0a 2020 2020 226e 616d 6522  [.  {.    "name"
-00000010: 3a20 2261 6464 6974 696f 6e61 6c5f 6865  : "additional_he
-00000020: 6164 6572 5f66 6965 6c64 7322 2c0a 2020  ader_fields",.  
-00000030: 2020 2274 7970 6571 6c22 3a20 2261 6464    "typeql": "add
-00000040: 6974 696f 6e61 6c2d 6865 6164 6572 222c  itional-header",
-00000050: 0a20 2020 2022 6f77 6e65 7222 3a20 2265  .    "owner": "e
-00000060: 6d61 696c 222c 0a20 2020 2022 706f 696e  mail",.    "poin
-00000070: 7465 645f 746f 223a 2022 6974 656d 222c  ted_to": "item",
-00000080: 0a20 2020 2022 6b65 7922 3a20 2268 6561  .    "key": "hea
-00000090: 6465 722d 6b65 7922 2c0a 2020 2020 2276  der-key",.    "v
-000000a0: 616c 7565 223a 2022 6865 6164 6572 2d76  alue": "header-v
-000000b0: 616c 7565 220a 2020 7d2c 0a20 207b 0a20  alue".  },.  {. 
-000000c0: 2020 2022 6e61 6d65 223a 2022 646f 6375     "name": "docu
-000000d0: 6d65 6e74 5f69 6e66 6f5f 6469 6374 222c  ment_info_dict",
-000000e0: 0a20 2020 2022 7479 7065 716c 223a 2022  .    "typeql": "
-000000f0: 646f 632d 696e 666f 222c 0a20 2020 2022  doc-info",.    "
-00000100: 6f77 6e65 7222 3a20 2270 6466 222c 0a20  owner": "pdf",. 
-00000110: 2020 2022 706f 696e 7465 645f 746f 223a     "pointed_to":
-00000120: 2022 696e 666f 222c 0a20 2020 2022 6b65   "info",.    "ke
-00000130: 7922 3a20 2264 6f63 2d6b 6579 222c 0a20  y": "doc-key",. 
-00000140: 2020 2022 7661 6c75 6522 3a20 2264 6f63     "value": "doc
-00000150: 2d76 616c 7565 220a 2020 7d2c 0a20 207b  -value".  },.  {
-00000160: 0a20 2020 2022 6e61 6d65 223a 2022 6578  .    "name": "ex
-00000170: 6966 5f74 6167 7322 2c0a 2020 2020 2274  if_tags",.    "t
-00000180: 7970 6571 6c22 3a20 2245 5849 462d 7461  ypeql": "EXIF-ta
-00000190: 6773 222c 0a20 2020 2022 6f77 6e65 7222  gs",.    "owner"
-000001a0: 3a20 2269 6d61 6765 222c 0a20 2020 2022  : "image",.    "
-000001b0: 706f 696e 7465 645f 746f 223a 2022 696e  pointed_to": "in
-000001c0: 666f 222c 0a20 2020 2022 6b65 7922 3a20  fo",.    "key": 
-000001d0: 2245 5849 462d 6b65 7922 2c0a 2020 2020  "EXIF-key",.    
-000001e0: 2276 616c 7565 223a 2022 4558 4946 2d76  "value": "EXIF-v
-000001f0: 616c 7565 220a 2020 7d2c 0a20 207b 0a20  alue".  },.  {. 
-00000200: 2020 2022 6e61 6d65 223a 2022 6970 6669     "name": "ipfi
-00000210: 7822 2c0a 2020 2020 2274 7970 6571 6c22  x",.    "typeql"
-00000220: 3a20 2249 5046 4958 2d73 746f 7265 222c  : "IPFIX-store",
-00000230: 0a20 2020 2022 6f77 6e65 7222 3a20 2274  .    "owner": "t
-00000240: 7261 6666 6963 222c 0a20 2020 2022 706f  raffic",.    "po
-00000250: 696e 7465 645f 746f 223a 2022 6974 656d  inted_to": "item
-00000260: 222c 0a20 2020 2022 6b65 7922 3a20 2249  ",.    "key": "I
-00000270: 5046 4958 2d6b 6579 222c 0a20 2020 2022  PFIX-key",.    "
-00000280: 7661 6c75 6522 3a20 2249 5046 4958 2d76  value": "IPFIX-v
-00000290: 616c 7565 220a 2020 7d2c 0a20 207b 0a20  alue".  },.  {. 
-000002a0: 2020 2022 6e61 6d65 223a 2022 7265 7175     "name": "requ
-000002b0: 6573 745f 6865 6164 6572 222c 0a20 2020  est_header",.   
-000002c0: 2022 7479 7065 716c 223a 2022 4854 5450   "typeql": "HTTP
-000002d0: 2d68 6561 6465 7222 2c0a 2020 2020 226f  -header",.    "o
-000002e0: 776e 6572 223a 2022 7265 7175 6573 7422  wner": "request"
-000002f0: 2c0a 2020 2020 2270 6f69 6e74 6564 5f74  ,.    "pointed_t
-00000300: 6f22 3a20 2268 6561 6465 7222 2c0a 2020  o": "header",.  
-00000310: 2020 226b 6579 223a 2022 4854 5450 2d6b    "key": "HTTP-k
-00000320: 6579 222c 0a20 2020 2022 7661 6c75 6522  ey",.    "value"
-00000330: 3a20 2248 5454 502d 7661 6c75 6522 0a20  : "HTTP-value". 
-00000340: 207d 2c0a 2020 7b0a 2020 2020 226e 616d   },.  {.    "nam
-00000350: 6522 3a20 226f 7074 696f 6e73 222c 0a20  e": "options",. 
-00000360: 2020 2022 7479 7065 716c 223a 2022 736f     "typeql": "so
-00000370: 636b 6574 2d6f 7074 696f 6e73 222c 0a20  cket-options",. 
-00000380: 2020 2022 6f77 6e65 7222 3a20 2273 6f63     "owner": "soc
-00000390: 6b65 7422 2c0a 2020 2020 2270 6f69 6e74  ket",.    "point
-000003a0: 6564 5f74 6f22 3a20 226f 7074 696f 6e22  ed_to": "option"
-000003b0: 2c0a 2020 2020 226b 6579 223a 2022 736f  ,.    "key": "so
-000003c0: 636b 6574 2d6b 6579 222c 0a20 2020 2022  cket-key",.    "
-000003d0: 7661 6c75 6522 3a20 2273 6f63 6b65 742d  value": "socket-
-000003e0: 7661 6c75 6522 0a20 207d 2c0a 2020 7b0a  value".  },.  {.
-000003f0: 2020 2020 226e 616d 6522 3a20 2265 6e76      "name": "env
-00000400: 6972 6f6e 6d65 6e74 5f76 6172 6961 626c  ironment_variabl
-00000410: 6573 222c 0a20 2020 2022 7479 7065 716c  es",.    "typeql
-00000420: 223a 2022 656e 7669 726f 6e6d 656e 742d  ": "environment-
-00000430: 7661 7269 6162 6c65 7322 2c0a 2020 2020  variables",.    
-00000440: 226f 776e 6572 223a 2022 7072 6f63 6573  "owner": "proces
-00000450: 7322 2c0a 2020 2020 2270 6f69 6e74 6564  s",.    "pointed
-00000460: 5f74 6f22 3a20 2265 6e76 2d76 6172 6961  _to": "env-varia
-00000470: 626c 6522 2c0a 2020 2020 226b 6579 223a  ble",.    "key":
-00000480: 2022 656e 7669 726f 6e6d 656e 742d 6b65   "environment-ke
-00000490: 7922 2c0a 2020 2020 2276 616c 7565 223a  y",.    "value":
-000004a0: 2022 656e 7669 726f 6e6d 656e 742d 7661   "environment-va
-000004b0: 6c75 6522 0a20 207d 2c0a 2020 7b0a 2020  lue".  },.  {.  
-000004c0: 2020 226e 616d 6522 3a20 2273 7461 7274    "name": "start
-000004d0: 7570 5f69 6e66 6f22 2c0a 2020 2020 2274  up_info",.    "t
-000004e0: 7970 6571 6c22 3a20 2273 7461 7274 7570  ypeql": "startup
-000004f0: 2d69 6e66 6f22 2c0a 2020 2020 226f 776e  -info",.    "own
-00000500: 6572 223a 2022 7072 6f63 6573 7322 2c0a  er": "process",.
-00000510: 2020 2020 2270 6f69 6e74 6564 5f74 6f22      "pointed_to"
-00000520: 3a20 226f 7074 696f 6e22 2c0a 2020 2020  : "option",.    
-00000530: 226b 6579 223a 2022 7374 6172 7475 702d  "key": "startup-
-00000540: 6b65 7922 2c0a 2020 2020 2276 616c 7565  key",.    "value
-00000550: 223a 2022 7374 6172 7475 702d 7661 6c75  ": "startup-valu
-00000560: 6522 0a20 207d 0a5d                      e".  }.]
+00000000: 5b0d 0a20 207b 0d0a 2020 2020 226e 616d  [..  {..    "nam
+00000010: 6522 3a20 2261 6464 6974 696f 6e61 6c5f  e": "additional_
+00000020: 6865 6164 6572 5f66 6965 6c64 7322 2c0d  header_fields",.
+00000030: 0a20 2020 2022 7479 7065 716c 223a 2022  .    "typeql": "
+00000040: 6164 6469 7469 6f6e 616c 2d68 6561 6465  additional-heade
+00000050: 7222 2c0d 0a20 2020 2022 6f77 6e65 7222  r",..    "owner"
+00000060: 3a20 2265 6d61 696c 222c 0d0a 2020 2020  : "email",..    
+00000070: 2270 6f69 6e74 6564 5f74 6f22 3a20 2269  "pointed_to": "i
+00000080: 7465 6d22 2c0d 0a20 2020 2022 6b65 7922  tem",..    "key"
+00000090: 3a20 2268 6561 6465 722d 6b65 7922 2c0d  : "header-key",.
+000000a0: 0a20 2020 2022 7661 6c75 6522 3a20 2268  .    "value": "h
+000000b0: 6561 6465 722d 7661 6c75 6522 0d0a 2020  eader-value"..  
+000000c0: 7d2c 0d0a 2020 7b0d 0a20 2020 2022 6e61  },..  {..    "na
+000000d0: 6d65 223a 2022 646f 6375 6d65 6e74 5f69  me": "document_i
+000000e0: 6e66 6f5f 6469 6374 222c 0d0a 2020 2020  nfo_dict",..    
+000000f0: 2274 7970 6571 6c22 3a20 2264 6f63 2d69  "typeql": "doc-i
+00000100: 6e66 6f22 2c0d 0a20 2020 2022 6f77 6e65  nfo",..    "owne
+00000110: 7222 3a20 2270 6466 222c 0d0a 2020 2020  r": "pdf",..    
+00000120: 2270 6f69 6e74 6564 5f74 6f22 3a20 2269  "pointed_to": "i
+00000130: 6e66 6f22 2c0d 0a20 2020 2022 6b65 7922  nfo",..    "key"
+00000140: 3a20 2264 6f63 2d6b 6579 222c 0d0a 2020  : "doc-key",..  
+00000150: 2020 2276 616c 7565 223a 2022 646f 632d    "value": "doc-
+00000160: 7661 6c75 6522 0d0a 2020 7d2c 0d0a 2020  value"..  },..  
+00000170: 7b0d 0a20 2020 2022 6e61 6d65 223a 2022  {..    "name": "
+00000180: 6578 6966 5f74 6167 7322 2c0d 0a20 2020  exif_tags",..   
+00000190: 2022 7479 7065 716c 223a 2022 4558 4946   "typeql": "EXIF
+000001a0: 2d74 6167 7322 2c0d 0a20 2020 2022 6f77  -tags",..    "ow
+000001b0: 6e65 7222 3a20 2269 6d61 6765 222c 0d0a  ner": "image",..
+000001c0: 2020 2020 2270 6f69 6e74 6564 5f74 6f22      "pointed_to"
+000001d0: 3a20 2269 6e66 6f22 2c0d 0a20 2020 2022  : "info",..    "
+000001e0: 6b65 7922 3a20 2245 5849 462d 6b65 7922  key": "EXIF-key"
+000001f0: 2c0d 0a20 2020 2022 7661 6c75 6522 3a20  ,..    "value": 
+00000200: 2245 5849 462d 7661 6c75 6522 0d0a 2020  "EXIF-value"..  
+00000210: 7d2c 0d0a 2020 7b0d 0a20 2020 2022 6e61  },..  {..    "na
+00000220: 6d65 223a 2022 6970 6669 7822 2c0d 0a20  me": "ipfix",.. 
+00000230: 2020 2022 7479 7065 716c 223a 2022 4950     "typeql": "IP
+00000240: 4649 582d 7374 6f72 6522 2c0d 0a20 2020  FIX-store",..   
+00000250: 2022 6f77 6e65 7222 3a20 2274 7261 6666   "owner": "traff
+00000260: 6963 222c 0d0a 2020 2020 2270 6f69 6e74  ic",..    "point
+00000270: 6564 5f74 6f22 3a20 2269 7465 6d22 2c0d  ed_to": "item",.
+00000280: 0a20 2020 2022 6b65 7922 3a20 2249 5046  .    "key": "IPF
+00000290: 4958 2d6b 6579 222c 0d0a 2020 2020 2276  IX-key",..    "v
+000002a0: 616c 7565 223a 2022 4950 4649 582d 7661  alue": "IPFIX-va
+000002b0: 6c75 6522 0d0a 2020 7d2c 0d0a 2020 7b0d  lue"..  },..  {.
+000002c0: 0a20 2020 2022 6e61 6d65 223a 2022 7265  .    "name": "re
+000002d0: 7175 6573 745f 6865 6164 6572 222c 0d0a  quest_header",..
+000002e0: 2020 2020 2274 7970 6571 6c22 3a20 2248      "typeql": "H
+000002f0: 5454 502d 6865 6164 6572 222c 0d0a 2020  TTP-header",..  
+00000300: 2020 226f 776e 6572 223a 2022 7265 7175    "owner": "requ
+00000310: 6573 7422 2c0d 0a20 2020 2022 706f 696e  est",..    "poin
+00000320: 7465 645f 746f 223a 2022 6865 6164 6572  ted_to": "header
+00000330: 222c 0d0a 2020 2020 226b 6579 223a 2022  ",..    "key": "
+00000340: 4854 5450 2d6b 6579 222c 0d0a 2020 2020  HTTP-key",..    
+00000350: 2276 616c 7565 223a 2022 4854 5450 2d76  "value": "HTTP-v
+00000360: 616c 7565 220d 0a20 207d 2c0d 0a20 207b  alue"..  },..  {
+00000370: 0d0a 2020 2020 226e 616d 6522 3a20 226f  ..    "name": "o
+00000380: 7074 696f 6e73 222c 0d0a 2020 2020 2274  ptions",..    "t
+00000390: 7970 6571 6c22 3a20 2273 6f63 6b65 742d  ypeql": "socket-
+000003a0: 6f70 7469 6f6e 7322 2c0d 0a20 2020 2022  options",..    "
+000003b0: 6f77 6e65 7222 3a20 2273 6f63 6b65 7422  owner": "socket"
+000003c0: 2c0d 0a20 2020 2022 706f 696e 7465 645f  ,..    "pointed_
+000003d0: 746f 223a 2022 6f70 7469 6f6e 222c 0d0a  to": "option",..
+000003e0: 2020 2020 226b 6579 223a 2022 736f 636b      "key": "sock
+000003f0: 6574 2d6b 6579 222c 0d0a 2020 2020 2276  et-key",..    "v
+00000400: 616c 7565 223a 2022 736f 636b 6574 2d76  alue": "socket-v
+00000410: 616c 7565 220d 0a20 207d 2c0d 0a20 207b  alue"..  },..  {
+00000420: 0d0a 2020 2020 226e 616d 6522 3a20 2265  ..    "name": "e
+00000430: 6e76 6972 6f6e 6d65 6e74 5f76 6172 6961  nvironment_varia
+00000440: 626c 6573 222c 0d0a 2020 2020 2274 7970  bles",..    "typ
+00000450: 6571 6c22 3a20 2265 6e76 6972 6f6e 6d65  eql": "environme
+00000460: 6e74 2d76 6172 6961 626c 6573 222c 0d0a  nt-variables",..
+00000470: 2020 2020 226f 776e 6572 223a 2022 7072      "owner": "pr
+00000480: 6f63 6573 7322 2c0d 0a20 2020 2022 706f  ocess",..    "po
+00000490: 696e 7465 645f 746f 223a 2022 656e 762d  inted_to": "env-
+000004a0: 7661 7269 6162 6c65 222c 0d0a 2020 2020  variable",..    
+000004b0: 226b 6579 223a 2022 656e 7669 726f 6e6d  "key": "environm
+000004c0: 656e 742d 6b65 7922 2c0d 0a20 2020 2022  ent-key",..    "
+000004d0: 7661 6c75 6522 3a20 2265 6e76 6972 6f6e  value": "environ
+000004e0: 6d65 6e74 2d76 616c 7565 220d 0a20 207d  ment-value"..  }
+000004f0: 2c0d 0a20 207b 0d0a 2020 2020 226e 616d  ,..  {..    "nam
+00000500: 6522 3a20 2273 7461 7274 7570 5f69 6e66  e": "startup_inf
+00000510: 6f22 2c0d 0a20 2020 2022 7479 7065 716c  o",..    "typeql
+00000520: 223a 2022 7374 6172 7475 702d 696e 666f  ": "startup-info
+00000530: 222c 0d0a 2020 2020 226f 776e 6572 223a  ",..    "owner":
+00000540: 2022 7072 6f63 6573 7322 2c0d 0a20 2020   "process",..   
+00000550: 2022 706f 696e 7465 645f 746f 223a 2022   "pointed_to": "
+00000560: 6f70 7469 6f6e 222c 0d0a 2020 2020 226b  option",..    "k
+00000570: 6579 223a 2022 7374 6172 7475 702d 6b65  ey": "startup-ke
+00000580: 7922 2c0d 0a20 2020 2022 7661 6c75 6522  y",..    "value"
+00000590: 3a20 2273 7461 7274 7570 2d76 616c 7565  : "startup-value
+000005a0: 220d 0a20 207d 0d0a 5d                   "..  }..]
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/stix21/mappings/relations_list_of_objects.json` & `stixorm-0.1.9/stixorm/module/definitions/stix21/mappings/relations_list_of_objects.json`

 * *Format-specific differences are supported for JSON files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: JSON text data*

 * *Files 19% similar despite different names*

```diff
@@ -1,73 +1,76 @@
-00000000: 5b0a 2020 7b0a 2020 2020 226e 616d 6522  [.  {.    "name"
-00000010: 3a20 2262 6f64 795f 6d75 6c74 6970 6172  : "body_multipar
-00000020: 7422 2c0a 2020 2020 2274 7970 6571 6c22  t",.    "typeql"
-00000030: 3a20 2262 6f64 792d 6d75 6c74 6970 6172  : "body-multipar
-00000040: 7422 2c0a 2020 2020 226f 776e 6572 223a  t",.    "owner":
-00000050: 2022 656d 6169 6c22 2c0a 2020 2020 2270   "email",.    "p
-00000060: 6f69 6e74 6564 5f74 6f22 3a20 226d 696d  ointed_to": "mim
-00000070: 652d 7061 7274 222c 0a20 2020 2022 6f62  e-part",.    "ob
-00000080: 6a65 6374 223a 2022 656d 6169 6c2d 6d69  ject": "email-mi
-00000090: 6d65 2d70 6172 7422 0a20 207d 2c0a 2020  me-part".  },.  
-000000a0: 7b0a 2020 2020 226e 616d 6522 3a20 2265  {.    "name": "e
-000000b0: 7874 6572 6e61 6c5f 7265 6665 7265 6e63  xternal_referenc
-000000c0: 6573 222c 0a20 2020 2022 7479 7065 716c  es",.    "typeql
-000000d0: 223a 2022 6578 7465 726e 616c 2d72 6566  ": "external-ref
-000000e0: 6572 656e 6365 7322 2c0a 2020 2020 226f  erences",.    "o
-000000f0: 776e 6572 223a 2022 7265 6665 7265 6e63  wner": "referenc
-00000100: 6564 222c 0a20 2020 2022 706f 696e 7465  ed",.    "pointe
-00000110: 645f 746f 223a 2022 7265 6665 7265 6e63  d_to": "referenc
-00000120: 696e 6722 2c0a 2020 2020 226f 626a 6563  ing",.    "objec
-00000130: 7422 3a20 2265 7874 6572 6e61 6c2d 7265  t": "external-re
-00000140: 6665 7265 6e63 6522 0a20 207d 2c0a 2020  ference".  },.  
-00000150: 7b0a 2020 2020 226e 616d 6522 3a20 226b  {.    "name": "k
-00000160: 696c 6c5f 6368 6169 6e5f 7068 6173 6573  ill_chain_phases
-00000170: 222c 0a20 2020 2022 7479 7065 716c 223a  ",.    "typeql":
-00000180: 2022 6b69 6c6c 2d63 6861 696e 2d75 7361   "kill-chain-usa
-00000190: 6765 222c 0a20 2020 2022 6f77 6e65 7222  ge",.    "owner"
-000001a0: 3a20 226b 696c 6c2d 6368 6169 6e2d 7573  : "kill-chain-us
-000001b0: 6564 222c 0a20 2020 2022 706f 696e 7465  ed",.    "pointe
-000001c0: 645f 746f 223a 2022 6b69 6c6c 2d63 6861  d_to": "kill-cha
-000001d0: 696e 2d75 7369 6e67 222c 0a20 2020 2022  in-using",.    "
-000001e0: 6f62 6a65 6374 223a 2022 6b69 6c6c 2d63  object": "kill-c
-000001f0: 6861 696e 2d70 6861 7365 220a 2020 7d2c  hain-phase".  },
-00000200: 0a20 207b 0a20 2020 2022 6e61 6d65 223a  .  {.    "name":
-00000210: 2022 616c 7465 726e 6174 655f 6461 7461   "alternate_data
-00000220: 5f73 7472 6561 6d73 222c 0a20 2020 2022  _streams",.    "
-00000230: 7479 7065 716c 223a 2022 616c 742d 6461  typeql": "alt-da
-00000240: 7461 2d73 7472 6561 6d73 222c 0a20 2020  ta-streams",.   
-00000250: 2022 6f77 6e65 7222 3a20 226e 7466 732d   "owner": "ntfs-
-00000260: 6578 7422 2c0a 2020 2020 2270 6f69 6e74  ext",.    "point
-00000270: 6564 5f74 6f22 3a20 2261 6c74 2d64 6174  ed_to": "alt-dat
-00000280: 612d 7374 7265 616d 222c 0a20 2020 2022  a-stream",.    "
-00000290: 6f62 6a65 6374 223a 2022 616c 7465 726e  object": "altern
-000002a0: 6174 652d 6461 7461 2d73 7472 6561 6d22  ate-data-stream"
-000002b0: 0a20 207d 2c0a 2020 7b0a 2020 2020 226e  .  },.  {.    "n
-000002c0: 616d 6522 3a20 2273 6563 7469 6f6e 7322  ame": "sections"
-000002d0: 2c0a 2020 2020 226f 626a 6563 7422 3a20  ,.    "object": 
-000002e0: 2277 696e 646f 7773 2d70 652d 7365 6374  "windows-pe-sect
-000002f0: 696f 6e22 2c0a 2020 2020 2274 7970 6571  ion",.    "typeq
-00000300: 6c22 3a20 2273 6563 7469 6f6e 7322 2c0a  l": "sections",.
-00000310: 2020 2020 226f 776e 6572 223a 2022 7065      "owner": "pe
-00000320: 6269 6e61 7279 222c 0a20 2020 2022 706f  binary",.    "po
-00000330: 696e 7465 645f 746f 223a 2022 7065 2d73  inted_to": "pe-s
-00000340: 6563 7469 6f6e 220a 2020 7d2c 0a20 207b  ection".  },.  {
-00000350: 0a20 2020 2022 6e61 6d65 223a 2022 7661  .    "name": "va
-00000360: 6c75 6573 222c 0a20 2020 2022 6f62 6a65  lues",.    "obje
-00000370: 6374 223a 2022 7769 6e64 6f77 732d 7265  ct": "windows-re
-00000380: 6769 7374 7279 2d76 616c 7565 2d74 7970  gistry-value-typ
-00000390: 6522 2c0a 2020 2020 2274 7970 6571 6c22  e",.    "typeql"
-000003a0: 3a20 2272 6567 2d76 616c 222c 0a20 2020  : "reg-val",.   
-000003b0: 2022 6f77 6e65 7222 3a20 2272 6567 2d6b   "owner": "reg-k
-000003c0: 6579 222c 0a20 2020 2022 706f 696e 7465  ey",.    "pointe
-000003d0: 645f 746f 223a 2022 7265 672d 7661 6c75  d_to": "reg-valu
-000003e0: 6522 0a20 207d 2c0a 2020 7b0a 2020 2020  e".  },.  {.    
-000003f0: 226e 616d 6522 3a20 2278 5f6d 6974 7265  "name": "x_mitre
-00000400: 5f63 6f6e 7465 6e74 7322 2c0a 2020 2020  _contents",.    
-00000410: 226f 626a 6563 7422 3a20 226f 626a 6563  "object": "objec
-00000420: 742d 7665 7273 696f 6e22 2c0a 2020 2020  t-version",.    
-00000430: 2274 7970 6571 6c22 3a20 2278 2d6d 6974  "typeql": "x-mit
-00000440: 7265 2d63 6f6e 7465 6e74 222c 0a20 2020  re-content",.   
-00000450: 2022 6f77 6e65 7222 3a20 2263 6f6c 6c65   "owner": "colle
-00000460: 6374 6f72 222c 0a20 2020 2022 706f 696e  ctor",.    "poin
-00000470: 7465 645f 746f 223a 2022 636f 6c6c 6563  ted_to": "collec
-00000480: 7465 6422 0a20 207d 0a5d                 ted".  }.]
+00000000: 5b0d 0a20 207b 0d0a 2020 2020 226e 616d  [..  {..    "nam
+00000010: 6522 3a20 2262 6f64 795f 6d75 6c74 6970  e": "body_multip
+00000020: 6172 7422 2c0d 0a20 2020 2022 7479 7065  art",..    "type
+00000030: 716c 223a 2022 626f 6479 2d6d 756c 7469  ql": "body-multi
+00000040: 7061 7274 222c 0d0a 2020 2020 226f 776e  part",..    "own
+00000050: 6572 223a 2022 656d 6169 6c22 2c0d 0a20  er": "email",.. 
+00000060: 2020 2022 706f 696e 7465 645f 746f 223a     "pointed_to":
+00000070: 2022 6d69 6d65 2d70 6172 7422 2c0d 0a20   "mime-part",.. 
+00000080: 2020 2022 6f62 6a65 6374 223a 2022 656d     "object": "em
+00000090: 6169 6c2d 6d69 6d65 2d70 6172 7422 0d0a  ail-mime-part"..
+000000a0: 2020 7d2c 0d0a 2020 7b0d 0a20 2020 2022    },..  {..    "
+000000b0: 6e61 6d65 223a 2022 6578 7465 726e 616c  name": "external
+000000c0: 5f72 6566 6572 656e 6365 7322 2c0d 0a20  _references",.. 
+000000d0: 2020 2022 7479 7065 716c 223a 2022 6578     "typeql": "ex
+000000e0: 7465 726e 616c 2d72 6566 6572 656e 6365  ternal-reference
+000000f0: 7322 2c0d 0a20 2020 2022 6f77 6e65 7222  s",..    "owner"
+00000100: 3a20 2272 6566 6572 656e 6365 6422 2c0d  : "referenced",.
+00000110: 0a20 2020 2022 706f 696e 7465 645f 746f  .    "pointed_to
+00000120: 223a 2022 7265 6665 7265 6e63 696e 6722  ": "referencing"
+00000130: 2c0d 0a20 2020 2022 6f62 6a65 6374 223a  ,..    "object":
+00000140: 2022 6578 7465 726e 616c 2d72 6566 6572   "external-refer
+00000150: 656e 6365 220d 0a20 207d 2c0d 0a20 207b  ence"..  },..  {
+00000160: 0d0a 2020 2020 226e 616d 6522 3a20 226b  ..    "name": "k
+00000170: 696c 6c5f 6368 6169 6e5f 7068 6173 6573  ill_chain_phases
+00000180: 222c 0d0a 2020 2020 2274 7970 6571 6c22  ",..    "typeql"
+00000190: 3a20 226b 696c 6c2d 6368 6169 6e2d 7573  : "kill-chain-us
+000001a0: 6167 6522 2c0d 0a20 2020 2022 6f77 6e65  age",..    "owne
+000001b0: 7222 3a20 226b 696c 6c2d 6368 6169 6e2d  r": "kill-chain-
+000001c0: 7573 6564 222c 0d0a 2020 2020 2270 6f69  used",..    "poi
+000001d0: 6e74 6564 5f74 6f22 3a20 226b 696c 6c2d  nted_to": "kill-
+000001e0: 6368 6169 6e2d 7573 696e 6722 2c0d 0a20  chain-using",.. 
+000001f0: 2020 2022 6f62 6a65 6374 223a 2022 6b69     "object": "ki
+00000200: 6c6c 2d63 6861 696e 2d70 6861 7365 220d  ll-chain-phase".
+00000210: 0a20 207d 2c0d 0a20 207b 0d0a 2020 2020  .  },..  {..    
+00000220: 226e 616d 6522 3a20 2261 6c74 6572 6e61  "name": "alterna
+00000230: 7465 5f64 6174 615f 7374 7265 616d 7322  te_data_streams"
+00000240: 2c0d 0a20 2020 2022 7479 7065 716c 223a  ,..    "typeql":
+00000250: 2022 616c 742d 6461 7461 2d73 7472 6561   "alt-data-strea
+00000260: 6d73 222c 0d0a 2020 2020 226f 776e 6572  ms",..    "owner
+00000270: 223a 2022 6e74 6673 2d65 7874 222c 0d0a  ": "ntfs-ext",..
+00000280: 2020 2020 2270 6f69 6e74 6564 5f74 6f22      "pointed_to"
+00000290: 3a20 2261 6c74 2d64 6174 612d 7374 7265  : "alt-data-stre
+000002a0: 616d 222c 0d0a 2020 2020 226f 626a 6563  am",..    "objec
+000002b0: 7422 3a20 2261 6c74 6572 6e61 7465 2d64  t": "alternate-d
+000002c0: 6174 612d 7374 7265 616d 220d 0a20 207d  ata-stream"..  }
+000002d0: 2c0d 0a20 207b 0d0a 2020 2020 226e 616d  ,..  {..    "nam
+000002e0: 6522 3a20 2273 6563 7469 6f6e 7322 2c0d  e": "sections",.
+000002f0: 0a20 2020 2022 6f62 6a65 6374 223a 2022  .    "object": "
+00000300: 7769 6e64 6f77 732d 7065 2d73 6563 7469  windows-pe-secti
+00000310: 6f6e 222c 0d0a 2020 2020 2274 7970 6571  on",..    "typeq
+00000320: 6c22 3a20 2273 6563 7469 6f6e 7322 2c0d  l": "sections",.
+00000330: 0a20 2020 2022 6f77 6e65 7222 3a20 2270  .    "owner": "p
+00000340: 6562 696e 6172 7922 2c0d 0a20 2020 2022  ebinary",..    "
+00000350: 706f 696e 7465 645f 746f 223a 2022 7065  pointed_to": "pe
+00000360: 2d73 6563 7469 6f6e 220d 0a20 207d 2c0d  -section"..  },.
+00000370: 0a20 207b 0d0a 2020 2020 226e 616d 6522  .  {..    "name"
+00000380: 3a20 2276 616c 7565 7322 2c0d 0a20 2020  : "values",..   
+00000390: 2022 6f62 6a65 6374 223a 2022 7769 6e64   "object": "wind
+000003a0: 6f77 732d 7265 6769 7374 7279 2d76 616c  ows-registry-val
+000003b0: 7565 2d74 7970 6522 2c0d 0a20 2020 2022  ue-type",..    "
+000003c0: 7479 7065 716c 223a 2022 7265 672d 7661  typeql": "reg-va
+000003d0: 6c22 2c0d 0a20 2020 2022 6f77 6e65 7222  l",..    "owner"
+000003e0: 3a20 2272 6567 2d6b 6579 222c 0d0a 2020  : "reg-key",..  
+000003f0: 2020 2270 6f69 6e74 6564 5f74 6f22 3a20    "pointed_to": 
+00000400: 2272 6567 2d76 616c 7565 220d 0a20 207d  "reg-value"..  }
+00000410: 2c0d 0a20 207b 0d0a 2020 2020 226e 616d  ,..  {..    "nam
+00000420: 6522 3a20 2278 5f6d 6974 7265 5f63 6f6e  e": "x_mitre_con
+00000430: 7465 6e74 7322 2c0d 0a20 2020 2022 6f62  tents",..    "ob
+00000440: 6a65 6374 223a 2022 6f62 6a65 6374 2d76  ject": "object-v
+00000450: 6572 7369 6f6e 222c 0d0a 2020 2020 2274  ersion",..    "t
+00000460: 7970 6571 6c22 3a20 2278 2d6d 6974 7265  ypeql": "x-mitre
+00000470: 2d63 6f6e 7465 6e74 222c 0d0a 2020 2020  -content",..    
+00000480: 226f 776e 6572 223a 2022 636f 6c6c 6563  "owner": "collec
+00000490: 746f 7222 2c0d 0a20 2020 2022 706f 696e  tor",..    "poin
+000004a0: 7465 645f 746f 223a 2022 636f 6c6c 6563  ted_to": "collec
+000004b0: 7465 6422 0d0a 2020 7d0d 0a5d            ted"..  }..]
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/stix21/schema/cti-rules.tql` & `stixorm-0.1.9/stixorm/module/definitions/stix21/schema/cti-rules.tql`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,115 +1,115 @@
-#
-# Copyright (C) 2021 Vaticle
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-define
-
-#
-# Description
-# These two rules create a relation of type kill-chain between all the kill-chain-phase entities
-# that have the same name. The first rule infers the relation, and the second rule infers the attribute
-# kill-chain-name. We need to split this up into two rules as we can only infer one relation or one attribute
-#per rule.
-# Example:
-# If we have many different kill-chain-phase entites that are called "Mitre Attack", but with different phases,
-# we can infer a kill-chain relation between all the phases in that kill chain. This makes it easy for us to
-# query across all the phases in that kill chain.
-rule part-of-one-kill-chain-relation:
-when {
-	$kill-chain-1 isa kill-chain-phase, has kill-chain-name $x;
-	$kill-chain-2 isa kill-chain-phase, has kill-chain-name $x;
-	not {$kill-chain-1 is $kill-chain-2;};
-} then {
-	(participating-kill-chain-phase: $kill-chain-1, participating-kill-chain-phase: $kill-chain-2) isa kill-chain;
-};
-
-rule part-of-one-kill-chain-attribute-name:
-when {
-	$kill-chain-1 isa kill-chain-phase, has kill-chain-name $x;
-	$kill-chain-2 isa kill-chain-phase, has kill-chain-name $x;
-	not {$kill-chain-1 is $kill-chain-2;};
-	$kill-chain (participating-kill-chain-phase: $kill-chain-1, participating-kill-chain-phase: $kill-chain-2) isa kill-chain;
-} then {
-	$kill-chain has $x;
-};
-
-# Description
-# This rule infers that if X is using Y, and if Y is using Z, then that means that X is also using Z
-# Example:
-# If an intrusion set is using a malware, and if that malware is using a specific attack pattern,
-# then we want to infer that that intrusion set is using that specific attack pattern
-rule transitive-use:
-when {
-	$x isa stix-domain-object, has name $name1;
-	$y isa stix-domain-object, has name $name2;
-	$z isa stix-domain-object, has name $name3;
-	$use1 (used-by: $x, used: $y) isa uses;
-	$use2 (used-by: $y, used: $z) isa uses;
-} then {
-	(used-by: $x, used: $z) isa uses;
-};
-
-# Description:
-#If y has been attributed to x, and if y is using z, then we infer that x is using z also
-# Example:
-# If an identity has been attributed to a threat actor,
-# and if that identity is using a malware, then we want to create a "use" relation
-# between the threat actor and the malware; the threat actor is using the malware
-# through the identiy
-rule attribution-when-using:
-when {
-	(result: $x, fault-of: $y) isa attributed-to;
-	(used-by: $y, used: $z) isa uses;
-} then {
-	(used-by: $x, used: $z) isa uses;
-};
-
-# Description:
-# If y has been attributed to x, and if y is targetting z, then we can infer that x is targetting z
-# Example:
-# If an attack pattern, for example "spear fishing", has been attributed to a specific identity named "Bravo",
-# and if that attack pattern is targetting a location, for example New York,
-# we can infer that the identiy "Bravo" is targeting the location New York
-rule attribution-when-targeting:
-when {
-	(result: $x, fault-of: $y) isa attributed-to;
-	(targetter: $y, targetted: $z) isa targets;
-} then {
-	(targetter: $x, targetted: $z) isa targets;
-};
-
-# Description
-# This rule infers a relation of type inferred-mitigation between a course of action and an intursion set, if the
-#course of action mitigates an SDO which is used by an intrusion set. Note: as the relation "use" is transitive (see rule above),
-# the SDO and the intrusion set may not be directly connected.
-# Example:
-# The entity type "course-of-action" with name "Restrict File and Directory Permissions" is mitigating against an entity "attack-pattern"
-#with name "indicator Blocking". If that "attack-pattern" is being used by an entiy of type "intrusion-set" with name "BlackTech", then an i
-# nferred relation of type "inferred-mitigation" will be created between the "course-of-action" and "the intrusion-set"
-rule mitigating-course-of-action-with-intrusion-set:
-when {
-	$course-of-action isa course-of-action, has name $name1;
-	$sdo isa stix-domain-object, has name $name2;
-	$intrusion-set isa intrusion-set, has name $name3;
-	$mitigation (mitigator: $course-of-action, mitigated: $sdo) isa mitigates;
-	$use (used: $sdo, used-by: $intrusion-set) isa uses;
-} then {
-	(mitigator: $course-of-action, mitigated: $intrusion-set) isa inferred-mitigation;
+#
+# Copyright (C) 2021 Vaticle
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+define
+
+#
+# Description
+# These two rules create a relation of type kill-chain between all the kill-chain-phase entities
+# that have the same name. The first rule infers the relation, and the second rule infers the attribute
+# kill-chain-name. We need to split this up into two rules as we can only infer one relation or one attribute
+#per rule.
+# Example:
+# If we have many different kill-chain-phase entites that are called "Mitre Attack", but with different phases,
+# we can infer a kill-chain relation between all the phases in that kill chain. This makes it easy for us to
+# query across all the phases in that kill chain.
+rule part-of-one-kill-chain-relation:
+when {
+	$kill-chain-1 isa kill-chain-phase, has kill-chain-name $x;
+	$kill-chain-2 isa kill-chain-phase, has kill-chain-name $x;
+	not {$kill-chain-1 is $kill-chain-2;};
+} then {
+	(participating-kill-chain-phase: $kill-chain-1, participating-kill-chain-phase: $kill-chain-2) isa kill-chain;
+};
+
+rule part-of-one-kill-chain-attribute-name:
+when {
+	$kill-chain-1 isa kill-chain-phase, has kill-chain-name $x;
+	$kill-chain-2 isa kill-chain-phase, has kill-chain-name $x;
+	not {$kill-chain-1 is $kill-chain-2;};
+	$kill-chain (participating-kill-chain-phase: $kill-chain-1, participating-kill-chain-phase: $kill-chain-2) isa kill-chain;
+} then {
+	$kill-chain has $x;
+};
+
+# Description
+# This rule infers that if X is using Y, and if Y is using Z, then that means that X is also using Z
+# Example:
+# If an intrusion set is using a malware, and if that malware is using a specific attack pattern,
+# then we want to infer that that intrusion set is using that specific attack pattern
+rule transitive-use:
+when {
+	$x isa stix-domain-object, has name $name1;
+	$y isa stix-domain-object, has name $name2;
+	$z isa stix-domain-object, has name $name3;
+	$use1 (used-by: $x, used: $y) isa uses;
+	$use2 (used-by: $y, used: $z) isa uses;
+} then {
+	(used-by: $x, used: $z) isa uses;
+};
+
+# Description:
+#If y has been attributed to x, and if y is using z, then we infer that x is using z also
+# Example:
+# If an identity has been attributed to a threat actor,
+# and if that identity is using a malware, then we want to create a "use" relation
+# between the threat actor and the malware; the threat actor is using the malware
+# through the identiy
+rule attribution-when-using:
+when {
+	(result: $x, fault-of: $y) isa attributed-to;
+	(used-by: $y, used: $z) isa uses;
+} then {
+	(used-by: $x, used: $z) isa uses;
+};
+
+# Description:
+# If y has been attributed to x, and if y is targetting z, then we can infer that x is targetting z
+# Example:
+# If an attack pattern, for example "spear fishing", has been attributed to a specific identity named "Bravo",
+# and if that attack pattern is targetting a location, for example New York,
+# we can infer that the identiy "Bravo" is targeting the location New York
+rule attribution-when-targeting:
+when {
+	(result: $x, fault-of: $y) isa attributed-to;
+	(targetter: $y, targetted: $z) isa targets;
+} then {
+	(targetter: $x, targetted: $z) isa targets;
+};
+
+# Description
+# This rule infers a relation of type inferred-mitigation between a course of action and an intursion set, if the
+#course of action mitigates an SDO which is used by an intrusion set. Note: as the relation "use" is transitive (see rule above),
+# the SDO and the intrusion set may not be directly connected.
+# Example:
+# The entity type "course-of-action" with name "Restrict File and Directory Permissions" is mitigating against an entity "attack-pattern"
+#with name "indicator Blocking". If that "attack-pattern" is being used by an entiy of type "intrusion-set" with name "BlackTech", then an i
+# nferred relation of type "inferred-mitigation" will be created between the "course-of-action" and "the intrusion-set"
+rule mitigating-course-of-action-with-intrusion-set:
+when {
+	$course-of-action isa course-of-action, has name $name1;
+	$sdo isa stix-domain-object, has name $name2;
+	$intrusion-set isa intrusion-set, has name $name3;
+	$mitigation (mitigator: $course-of-action, mitigated: $sdo) isa mitigates;
+	$use (used: $sdo, used-by: $intrusion-set) isa uses;
+} then {
+	(mitigator: $course-of-action, mitigated: $intrusion-set) isa inferred-mitigation;
 };
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/stix21/schema/cti-schema-v2.tql` & `stixorm-0.1.9/stixorm/module/definitions/stix21/schema/cti-schema-v2.tql`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,1953 +1,1953 @@
-#
-# Copyright (C) 2022 OS-Threat
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-# Note: Large portions of this schema were originally defined by Tomas Sabat, Vaticle, 2021
-#
-
-define
-stix-entity sub entity,
-    abstract;
-
-stix-object sub stix-entity,
-	# Required
-	owns stix-type,
-	owns stix-id @key, #
-	owns custom-attribute,
-	plays stix-core-relationship:source,
-	plays stix-core-relationship:target,
-	plays obj-refs:referred, 
-	plays granular-marking:object;
-
-	stix-core-object sub stix-object, 
-		# Required for SDO but Optional for SCO
-		owns spec-version,
-
-		# Optional
-		plays object-marking:marked,
-		plays created-by:created,
-
-		# Common relations for SDOs and SCOs. Defined in 3.7. 
-		plays derivation:derived-from,
-		plays derivation:deriving,
-		plays duplicate:duplicated-object,
-		plays relatedness:related-to;
-
-			stix-domain-object sub stix-core-object, 
-				# Required
-				owns created,
-				owns modified, 
-
-				# Optional
-				owns revoked, 
-				owns labels,
-				owns confidence,
-				owns langs,
-				plays external-references:referenced,
-				plays sighting:sighting-of,
-
-				plays indicates:indicated;
-
-			stix-cyber-observable-object sub stix-core-object,
-				owns defanged,
-				plays malware-env:env,
-				plays extensions:sco,
-				plays consist:consisted;
-
-	stix-sub-object sub stix-entity,
-		abstract, 
-		owns created, 
-		owns modified,
-        plays stix-core-relationship:source,
-        plays stix-core-relationship:target,
-        plays obj-refs:referred,
-        plays granular-marking:object;
-
-
-##### 2 Common Data Types #####
-
-# 2.5 External Reference
-external-reference sub stix-sub-object,
-	# In addition to source-name, at least one of description, url or external-id must be present
-	# Required
-	owns source-name, 
-
-	# Optional
-	owns description,
-	owns url-link, 
-	owns external-id, 
-	plays hashes:owner,
-	plays external-references:referencing;
-
-
-# 2.7 Hash
-hash sub stix-sub-object,
-	owns hash-value, 
-	plays hashes:pointed-to; 
-
-	md-5 sub hash;
-	sha-1 sub hash; 
-	sha-256 sub hash;
-	sha-512 sub hash; 
-	sha3-256 sub hash; 
-	sha3-512 sub hash;
-	ssdeep sub hash; 
-	tlsh sub hash; 
-
-
-
-# 2.11 Kill Chain Phase
-kill-chain-phase sub stix-sub-object,
-	owns kill-chain-name, 
-	owns phase-name,
-	plays kill-chain-usage:kill-chain-using,
-
-	# inferred role player
-	plays kill-chain:participating-kill-chain-phase;
-
-
-##### 4 STIX Domain Objects #####
-
-# Custom object
-custom-object sub stix-domain-object,
-	owns name, 
-	owns description, 
-	owns aliases, 
-	owns first-seen,
-	owns last-seen,
-	owns objective,
-	plays kill-chain-usage:kill-chain-used,
-	plays delivers:delivering,
-	plays targets:targetter,
-	plays uses:used-by,
-	plays mitigates:mitigated,
-	plays uses:used;
-
-
-# 4.1 
-attack-pattern sub stix-domain-object,
-	owns name,
-	owns description,
-	owns aliases,
-
-	# Relations defined as properties in STIX
-	plays kill-chain-usage:kill-chain-used,
-
-	# Common Relations
-	plays delivers:delivering,
-	plays targets:targetter,
-	plays uses:used-by,
-
-	# Reverse Relations
-	# plays indicates:indicated, -> Defined in SDO
-	plays mitigates:mitigated,
-	plays uses:used;
-
-	# Embedded Relations
-	# created-by
-	# Object marking ref
-
-# 4.2 Campaign
-campaign sub stix-domain-object, 
-	owns name, 
-	owns description, 
-	owns aliases, 
-	owns first-seen,
-	owns last-seen,
-	owns objective, 
-
-	# Common Relations
-	plays attributed-to:result,
-	plays compromises:compromising,
-	plays originates-from:originating,
-	plays targets:targetter,
-	plays uses:used-by;
-
-	# Reverse Relations
-	#plays indicates:indicated; -> Defined in SDO
-
-	# Embedded relations
-	# created-by
-	# Object marking
-
-# 4.3 Course of Action
-course-of-action sub stix-domain-object,
-	owns name, 
-	owns description, 
-	owns action,
-
-	# Common Relations
-	plays investigates:investigating,
-	plays mitigates:mitigator,
-	plays remediation:remediating,
-	plays uses:used-by;
-
-	# Reverse Relations
-	# NA
-
-	# Embedded relations
-	# created-by
-	# Object marking ref
-
-# 4.4 Grouping 
-grouping sub stix-domain-object,
-	owns name, 
-	owns description, 
-	owns context,
-
-	# Common Relations
-	# NA 
-
-	# Reverse Relations
-	# NA
-
-	# Embedded Relations
-	# created-by
-	# Object markings
-	plays obj-refs:object;
-
-# 4.5 Identity
-identity sub stix-domain-object,
-	owns name, 
-	owns description, 
-	owns stix-role,
-	owns identity-class,
-	owns sector,  # should this perhaps be a relation?
-	owns contact-information,
-
-	# Common Relations
-	plays located-at:locating,
-
-	# Reverse Relations
-	plays targets:targetted,
-	plays attributed-to:fault-of, 
-	plays impersonate:impersonated,
-
-	# Embedded Relations
-	plays created-by:creator,
-	# Object marking ref
-	
-	plays sighting:where-sighted; 
-
-	# 10.7 Identity Class Vocabulary
-	individual sub identity;
-	identity-group sub identity;
-	system sub identity;
-	organization sub identity;
-	class sub identity;
-	id-unknown sub identity;
-
-# 4.6 Incident
-incident sub stix-domain-object, 
-	owns name, 
-	owns description;
-
- 	# Common Relations
- 	# NA
-
- 	# Reverse Relations
- 	# NA
-
-	# Embedded relations
-	# created-by
-	# Object Marking
-
-# 4.7 Indicator
-indicator sub stix-domain-object, 
-	owns name, 
-	owns description, 
-	owns indicator-type,
-	owns pattern, 
-	owns pattern-type, 
-	owns pattern-version,
-	owns valid-from,
-	owns valid-until,
-
-	# Relations defined as properties in STIX
-	plays kill-chain-usage:kill-chain-used,
-
-	# Common Relations
-	plays indicates:indicating,
-	plays based-on:basing-on,
-
-	# Reverse Relations
-	plays investigates:investigated,
-	plays mitigates:mitigated;
-
-	# Embedded Relations
-	# created-by
-	# Object marking ref
-
-# 4.8 Infrastructure 
-infrastructure sub stix-domain-object,
-	owns name, 
-	owns description,
-	owns infrastructure-types, # Should this OV be a relation to define?
-	owns aliases, 
-	plays kill-chain-usage:kill-chain-used, 
-	owns first-seen,
-	owns last-seen,
-
-	# Common Relations
-	plays communicates-with:communicating,
-	plays consist:consisting,
-	plays control:controlling,
-
-	plays delivers:delivering,
-	plays have:having,
-	plays hosts:hosting,
-	plays located-at:locating,
-	plays uses:used-by,
-
-	# Reverse Relations
-	plays control:controlled,
-	plays communicates-with:communicated,
-	plays compromises:compromised,
-	plays beacon:beaconed-to,
-	plays exfiltrate:exfiltrated-to,
-	plays hosts:hosted,
-	# plays indicates:indicated, defined in SDO
-	plays ownership:owned,
-	plays targets:targetted,
-	plays uses:used;
-
-	# Object marking ref
-
-# 4.9 Intrusion Set
-intrusion-set sub stix-domain-object,
-	owns name, 
-	owns description, 
-	owns aliases, 
-	owns first-seen,
-	owns last-seen,
-	owns goals, 
-	owns resource-level, 
-	owns primary-motivation, 
-	owns secondary-motivations,
-
-	# Common Relations
-	plays attributed-to:result,
-	plays compromises:compromising,
-	plays hosts:hosting,
-	plays ownership:owning,
-	plays originates-from:originating,
-	plays targets:targetter,
-	plays uses:used-by,
-	plays uses:used,
-
-	# Reverse Relations
-	plays attributed-to:fault-of, 
-	plays authored-by:authored,
-	# plays indicates:indicated; Already defined in SDO
-
-	# Embedded Relations
-	# created-by
-	# Object marking 
-
-	# Inferred role player
-	plays inferred-mitigation:mitigated;
-
-# 4.10 Location
-location sub stix-domain-object,
-	owns name, 
-	owns description,
-	owns latitude,
-	owns longitude,
-	owns precision,
-	owns region,
-	owns country,
-	owns administrative-area,
-	owns city,
-	owns street-address,
-	owns postal-code,
-
-	# Common Relations
-	# NA
-
-	# Reverse relations
-	plays located-at:located,
-	plays originates-from:originated-from,
-	plays targets:targetted,
-	plays sighting:where-sighted;
-
-	# Embedded Relations
-	#created-by
-	# Object marking
-
-# 4.11 Malware
-malware sub stix-domain-object, 
-	owns name, 
-	owns description, 
-	owns malware-types,
-	owns is-family, 
-    owns aliases,
-    owns first-seen,
-    owns last-seen,
-    owns architecture-execution-envs,
-    owns implementation-languages,
-    owns capabilities,
-    
-    # Relations defined as properties in STIX
-	plays kill-chain-usage:kill-chain-used,
-	plays malware-sample:sample-for, # ssample_refs
-
-    # Common Relations
-    plays authored-by:authoring,
-    plays beacon:beaconing-to,
-    plays exfiltrate:exfiltrating-to,
-    plays control:controlling,
-    plays download:downloading,
-    plays drop:dropping,
-    plays exploit:exploiting,
-    plays originates-from:originating,
-    plays targets:targetter,
-    plays hosts:hosting,
-    plays uses:used-by,
-    plays variant:variant-source,
-    plays communicates-with:communicating,
-
-   	# Reverse Relations
-   	plays variant:variant-target,
-   	plays delivers:delivered,
-   	plays mitigates:mitigated,
-	plays remediation:remediated,
-	plays uses:used,
-	plays drop:dropped,
-	plays control:controlled,
-	plays characterise:characterised,
-	plays av-analysis:analysed,
-	plays static-analysis:analysed,
-	plays dynamic-analysis:analysed,
-
-    plays download:downloaded,
-    plays exploit:exploiting,
-
-    # Embedded Relations
-    # created-by
-    #Obejct marking
-    # Sample ref
-	plays malware-env:object;
-
-
-# 4.12 Malware Analysis
-malware-analysis sub stix-domain-object,
-	owns product, 
-	owns version,
-	owns configuration-version,
-	owns module,
-	owns analysis-engine-version,
-	owns analysis-definition-version,
-	owns submitted,
-	owns analysis-started,
-	owns analysis-ended,
-	owns result-name,
-	owns result,
-
-	# Relations defined as properties in STIX
-	# host_vm_ref, _operating_system_ref, instsalled_software_ref, analysis-sco are all defined as 
-	# playing roles in the analysis relation
-	plays malware-analysis-sample:sample-for, # sample_refs
-
-	# Common Relations
-	plays characterise:characterising,
-	plays av-analysis:analysing,
-	plays static-analysis:analysing,
-	plays dynamic-analysis:analysing,
-
-	# Reverse Relations
-	# NA
-
-	# Embedded Relations
-	# created-by
-	# Object markingss
-	# hosts-vm
-	# operating-system
-	# installed-software
-	# analysis-sco
-	# sample-ref
-	plays malware-env:object;
-
-
-# 4.13 Note
-note sub stix-domain-object, 
-	owns note-abstract, 
-	owns content, 
-	owns authors,
-
-	# Relations 
-	# NA
-
-	# Embedded Relations
-	# created-by
-	# Object marking
-	plays obj-refs:object;
-
-# 4.14
-observed-data sub stix-domain-object,
-	owns first-observed, 
-	owns last-observed, 
-	owns number-observed,
-
-	# Common Relations
-	# NA
-
-	# Reverse Relations
-	plays based-on:basis,
-	plays consist:consisted,
-
-	plays sighting:observed, # This is for SRO 5.2 sighting
-
-	# Embedded Relations
-	#created-by
-	#Object marking
-	plays obj-refs:object; # Object ref
-
-# 4.15 Opinion
-opinion sub stix-domain-object, 
-	owns explanation,
-	owns authors,
-	owns opinion-enum, 
-
-	# Common Relations
-	# NA
-
-	# Reverse Relations
-	# NA
-
-	# Embedded relations
-	# created-by
-	# Object marking
-	plays obj-refs:object;
-
-# 4.16 Report
-report sub stix-domain-object, 
-	owns name, 
-	owns description,
-	owns report-type, 
-	owns published, 
-
-	# Common Relations
-	# NA
-
-	# Reverse Relations
-	# NA
-
-	# Embedded relations
-	# created-by 
-	# Object Marking
-	plays obj-refs:object;
-
-# 4.17
-threat-actor sub stix-domain-object,
-	owns name, 
-	owns description, 
-	owns threat-actor-type,
-	owns aliases,
-	owns first-seen,
-	owns last-seen,
-	owns stix-role,
-	owns goals,
-	owns sophistication,
-	owns resource-level, 
-	owns primary-motivation,
-	owns secondary-motivations,
-	owns personal-motivations,
-
-
-	# Common Relations
-	plays attributed-to:result,
-	plays compromises:compromising,
-	plays hosts:hosting,
-	plays ownership:owning,
-	plays impersonate:impersonating,
-	plays located-at:locating,
-	plays targets:targetter,
-	plays uses:used-by,
-
-	# Reverse Relations
-	plays attributed-to:fault-of,
-	plays authored-by:authored;
-	# plays indicates:indicated # defined in SDO
-
-	# Embedded relations
-	# created-by 
-	# Object Marking
-
-# 4.18 Tool
-tool sub stix-domain-object,
-	owns name,
-	owns description,
-	owns tool-type,
-	owns aliases, 
-	owns tool-version,
-
-	# Relations defined as properties in STIX
-	plays kill-chain-usage:kill-chain-used,
-
-	#Common Relations
-	plays delivers:delivering,
-	plays drop:dropping,
-	plays have:having,
-	plays targets:targetter,
-	plays uses:used-by,
-
-	# Reverse Relations
-	plays download:downloaded,
-	plays drop:dropped,
-	plays hosts:hosted,
-	plays mitigates:mitigated,
-	plays uses:used;
-	# plays indicates:indicated, Already defined in SDO
-
-	# Embedded Relations
-	# created-by
-	# Object Marking
-
-# 4.19 Vulnerability
-vulnerability sub stix-domain-object,
-	owns name, 
-	owns description,
-
-	# Relations defined as properties in STIX
-	# plays external-references:referencing, Defined in SDO
-
-	# Common Relations
-	# NA
-
-	# Reverse Relations
- 	plays targets:targetted,
- 	plays exploit:exploited,
- 	plays mitigates:mitigated,
- 	plays remediation:remediated,
- 	plays have:had;
-
- 	#Embedded Relations
- 	# created-by
- 	# Object Marking
-
-##### 5 STIX Relationship Objects #####
-
-# 5.1 Specification-Defined Relatinoships Summary
-stix-core-relationship sub relation,
-	# Required
-	owns spec-version,
-	owns stix-id @key,
-	owns created,
-	owns modified,
-	owns stix-type,
-
-	# Optional
-	owns description,
-	owns revoked,
-	owns labels,
-	owns confidence, 
-	owns langs,
-	owns start-time,
-	owns stop-time,
-	owns relationship-type,
-	owns custom-attribute,
-
-	relates source, 
-	relates target,
-	plays obj-refs:referred,
-	plays object-marking:marked,
-	plays granular-marking:object, 
-	plays external-references:referenced,
-	plays created-by:created;
-
-
-	# Specific Relationships from Appendix C
-	delivers sub stix-core-relationship, 
-		relates delivering as source, 
-		relates delivered as target;
-
-	targets sub stix-core-relationship, 
-		relates targetter as source,
-		relates targetted as target;
-
-	uses sub stix-core-relationship,
-		relates used-by as source,
-		relates used as target;
-
-	attributed-to sub stix-core-relationship, 
-		relates result as source,
-		relates fault-of as target; 
-	
-	compromises sub stix-core-relationship,
-		relates compromising as source,
-		relates compromised as target;
-	
-	originates-from sub stix-core-relationship,
-		relates originated-from as target,
-		relates originating as source;
-	
-	investigates sub stix-core-relationship,
-		relates investigating as source,
-		relates investigated as target;
-
-	mitigates sub stix-core-relationship,
-		relates mitigated as target,
-		relates mitigator as source;
-	
-	located-at sub stix-core-relationship,
-		relates located as target,
-		relates locating as source;
-
-	indicates sub stix-core-relationship, 
-		relates indicating as source,
-		relates indicated as target; 
-	
-	based-on sub stix-core-relationship,
-		relates basing-on as source,
-		relates basis as target;
-	
-	communicates-with sub stix-core-relationship,
-		relates communicating as source,
-		relates communicated as target;
-
-	consist sub stix-core-relationship,
-		relates consisting as source,
-		relates consisted as target;
-
-	control sub stix-core-relationship,
-		relates controlling as source,
-		relates controlled as target;
-	
-	have sub stix-core-relationship, # Could come up with a better name?
-		relates having as source,
-		relates had as target;
-	
-	hosts sub stix-core-relationship,
-		relates hosting as source,
-		relates hosted as target;
-	
-	ownership sub stix-core-relationship,
-		relates owned as target,
-		relates owning as source;
-	
-	authored-by sub stix-core-relationship,
-		relates authoring as source,
-		relates authored as target;
-
-	resolve-to sub stix-core-relationship,
-	    relates resolves-from as source,
-	    relates resolves-to as target;
-
-	beacon sub stix-core-relationship,
-		relates beaconed-to as target,
-		relates beaconing-to as source;
-	
-	exfiltrate sub stix-core-relationship,
-		relates exfiltrated-to as target,
-		relates exfiltrating-to as source;
-	
-	download sub stix-core-relationship,
-		relates downloaded as target,
-		relates downloading as source;
-
-	drop sub stix-core-relationship,
-		relates dropped as target,
-		relates dropping as source;
-
-	exploit sub stix-core-relationship,
-		relates exploiting as source,
-		relates exploited as target;
-
-	variant sub stix-core-relationship,
-		relates variant-source as source,
-		relates variant-target as target;
-
-	characterise sub stix-core-relationship,
-		relates characterised as target,
-		relates characterising as source;
-
-	impersonate sub stix-core-relationship,
-		relates impersonating as source,
-		relates impersonated as target;
-
-
-	analysis sub stix-core-relationship,
-		relates analysing as source,
-		relates analysed as target;
-
-		av-analysis sub analysis;
-		static-analysis sub analysis;
-		dynamic-analysis sub analysis;
-		analysis-of sub analysis;
-
-	remediation sub stix-core-relationship,
-		relates remediating as source,
-		relates remediated as target;
-
-
-# 5.2 Sighting
-sighting sub stix-core-relationship, 
-	owns first-seen,
-	owns last-seen,
-	owns sighting-count,
-	owns summary,
-	relates where-sighted,
-	relates sighting-of as source, 
-	relates observed;
-
-##### 6 STIX Cyber-observable Objects #####
-
-# 6.1 Artifact Object
-artifact sub stix-cyber-observable-object,
-	owns mime-type,
-	owns payload-bin,
-	owns url-link, 
-	plays hashes:owner,
-	owns encryption-algorithm,
-	owns decryption-key,
-	plays payload-src:payload,
-	plays payload-dst:payload,
-	plays malware-analysis-sample:sco-sample,
-	plays malware-sample:sco-sample,
-	plays raw-email-references:binary,
-	plays body-raw-references:non-textual,
-	plays content-file:containing-file,
-	plays HTTP-body-data:contained-data;
-
-# 6.2 Autonomous System Object
-autonomous-system sub stix-cyber-observable-object,
-	owns number,
-	owns name,
-	owns rir,
-	plays belongs-to-autonomous:belongs-to;
-
-# 6.3 Directory Object
-directory sub stix-cyber-observable-object,
-	owns path, 
-	owns path-enc,
-	owns ctime,
-	owns mtime,
-	owns atime,
-	plays directory-contains:container,
-	plays directory-contains:contained,
-	plays directory-parent:contained,
-	plays directory-parent:container;
-
-# 6.4 Domain Name Object
-domain-name sub stix-cyber-observable-object,
-	owns stix-value, 
-	plays resolves-to-ref:from-ref,
-	plays resolves-to-ref:to-ref,
-	plays communicates-with:communicated,
-	plays traffic-src:source,
-	plays traffic-dst:destination,
-	plays resolve-to:resolves-from,
-	plays resolve-to:resolves-to;
-
-# 6.5 Email Address Object
-email-addr sub stix-cyber-observable-object,
-	owns stix-value, 
-	owns display-name,
-	plays belongs:belonged,
-	plays from-email:email-address,
-	plays to-email:email-address,
-	plays cc-email:email-address,
-	plays bcc-email:email-address;
-
-# 6.6 Email Message
-email-message sub stix-cyber-observable-object,
-	owns is-multipart,
-	owns date,
-	owns content-type,
-	owns message-id,
-	owns subject,
-	owns received-lines, # List of type string
-	owns body,
-
-	plays body-multipart:email,
-	plays email-connection:email,
-	plays additional-header:email,
-	plays raw-email-references:email;
-
-
-header-value sub stix-attribute-string;
-header-key sub stix-attribute-string,
-	owns header-value,
-	plays additional-header:item;
-
-email-mime-part sub stix-sub-object,
-	owns body,
-	owns content-type, 
-	owns content-disposition, 
-	plays body-multipart:mime-part,
-	plays body-raw-references:containing-mime;
-
-# 6.7 File
-file sub stix-cyber-observable-object,
-	plays hashes:owner, 
-	owns size,
-	owns name,
-	owns name-enc,
-	owns magic-number-hex,
-	owns mime-type,
-	owns ctime,
-	owns mtime,
-	owns atime, 
-
-	plays directory-contains:contained,
-	plays directory-parent:contained,
-	plays content-file:containing-file,
-	plays body-raw-references:non-textual,
-	plays malware-analysis-sample:sco-sample,
-	plays malware-sample:sco-sample,
-	plays download:downloaded,
-	plays process-image:executed-image,
-	plays service-dll:loaded-dll,
-	plays archive-extension:file,
-	plays ntfs-extension:file,
-	plays pdf-extension:file,
-	plays raster-image-extension:file,
-	plays windows-pebinary-extension:file;
-
-#### SCO EXTENSIONS ####
-
-SCO-extension sub stix-sub-object,
-	plays extensions:extension;
-
-	archive-ext sub SCO-extension,
-		owns comment,
-		plays directory-contains:container,
-		plays archive-extension:an-archive;
-
-	ntfs-ext sub SCO-extension,
-		owns sid, 
-		plays alt-data-streams:ntfs-ext,
-		plays ntfs-extension:ntfs;
-
-	alternate-data-stream sub SCO-extension, 
-		owns name, 
-		plays hashes:owner, 
-		owns size, 
-		plays alt-data-streams:alt-data-stream; 
-
-	pdf-ext sub SCO-extension,
-		owns version,
-		owns is-optimized,
-		owns pdfid0,
-		owns pdfid1,
-		plays doc-info:pdf,
-		plays pdf-extension:pdf;
-
-	doc-value sub stix-attribute-string;
-	doc-key sub stix-attribute-string,
-		owns doc-value,
-		plays doc-info:info;
-
-	raster-image-ext sub SCO-extension,
-		owns image-height,
-		owns image-width,
-		owns bits-per-pixel,
-		plays EXIF-tags:image,
-		plays raster-image-extension:image; 
-	
-	EXIF-value sub stix-attribute-string;
-	EXIF-key sub stix-attribute-string,
-		owns EXIF-value,
-		plays EXIF-tags:info;
-
-
-	windows-pebinary-ext sub SCO-extension, 	
-		owns pe-type,
-		owns imphash,
-		owns machine-hex,
-		owns number-of-sections,
-		owns time-date-stamp,
-		owns pointer-to-symbol-table-hex,
-		owns number-of-symbols,
-		owns size-of-optional-header,
-		owns characteristics-hex,
-		plays hashes:owner, 
-		plays optional-headers:pebinary,
-		plays sections:pebinary,
-		plays windows-pebinary-extension:pebinary;
-
-	windows-pe-optional-header-type sub SCO-extension, 
-		owns magic-hex,
-		owns major-linker-version,
-		owns minor-linker-version,
-		owns size-of-code,
-		owns size-of-initialized-data,
-		owns size-of-uninitialized-data,
-		owns address-of-entry-point,
-		owns base-of-code,
-		owns base-of-data,
-		owns image-base,
-		owns section-alignment,
-		owns file-alignment,
-		owns major-os-version,
-		owns minor-os-version,
-		owns major-image-version,
-		owns minor-image-version,
-		owns major-subsystem-version,
-		owns minor-subsystem-version,
-		owns win32-version-value-hex,
-		owns size-of-image,
-		owns size-of-headers,
-		owns checksum-hex,
-		owns subsystem-hex,
-		owns dll-characteristics-hex,
-		owns size-of-stack-reserve,
-		owns size-of-stack-commit,
-		owns size-of-heap-reserve,
-		owns size-of-heap-commit,
-		owns loader-flags-hex,
-		owns number-of-rva-and-sizes, 
-		plays hashes:owner,
-		plays optional-headers:optional-header;
-
-	windows-pe-section sub SCO-extension,
-		owns name, 
-		owns size, 
-		owns entropy, 
-		plays hashes:owner, 
-		plays sections:pe-section;
-
-# 6.8 IPv4 Address
-ipv4-addr sub stix-cyber-observable-object,
-	owns stix-value, 
-	plays resolves-to-ref:to-ref,
-	plays resolves-to-ref:from-ref,
-	plays belongs-to-autonomous:belonged,
-	plays communicates-with:communicated,
-	plays traffic-src:source,
-	plays traffic-dst:destination,
-	#plays consist:consisted,
-	plays resolve-to:resolves-from,
-	plays resolve-to:resolves-to;
-
-# 6.9 IPv6 Address
-ipv6-addr sub stix-cyber-observable-object,
-	owns stix-value, 
-	plays resolves-to-ref:to-ref,
-	plays resolves-to-ref:from-ref,
-	plays belongs-to-autonomous:belonged,	
-	plays communicates-with:communicated,
-	plays traffic-src:source,
-	plays traffic-dst:destination,
-	#plays consist:consisted,
-	plays resolve-to:resolves-from,
-	plays resolve-to:resolves-to;
-
-# 6.10 MAC Address
-mac-addr sub stix-cyber-observable-object,
-	owns stix-value,
-	plays resolves-to-ref:to-ref,
-	plays traffic-src:source,
-	plays traffic-dst:destination,
-	plays resolve-to:resolves-to;
-
-# 6.11 Mutex
-mutex sub stix-cyber-observable-object,
-	owns name; 
-
-# 6.12 Network Traffic - This should really be a relation? 
-network-traffic sub stix-cyber-observable-object,
-	owns start, 
-	owns end,
-	owns is-active, 
-	owns protocols, 
-	owns src-port,
-	owns dst-port,
-	owns src-byte-count,
-	owns dst-byte-count,
-	owns src-packets,
-	owns dst-packets,
-	plays traffic-src:traffic,
-	plays payload-src:traffic,
-	plays traffic-dst:traffic,
-	plays payload-dst:traffic,
-	
-	plays encapsulate:container,
-	plays encapsulate:contained,
-	plays encapsulated:container,
-	plays encapsulated:contained,
-	plays malware-analysis-sample:sco-sample,
-	plays IPFIX-store:traffic,
-	plays open-connections:opened-connection,
-	plays http-request-extension:traffic,
-	plays icmp-extension:traffic,
-	plays socket-extension:traffic,
-	plays tcp-extension:traffic;
-
-	IPFIX-value sub stix-attribute-string;
-	IPFIX-key sub stix-attribute-string,
-		owns IPFIX-value,
-		plays IPFIX-store:item;
-
-#### SCO EXTENSIONS Pt 2 ####
-	http-request-ext sub SCO-extension,
-		owns request-method,
-		owns request-value,
-		owns request-version,
-		owns request-header,
-		owns message-body-length,
-		plays HTTP-header:request,
-		plays HTTP-body-data:HTPP-message,
-		plays http-request-extension:request;
-
-	HTTP-value sub stix-attribute-string;
-	HTTP-key sub stix-attribute-string,
-		owns HTTP-value,
-		plays HTTP-header:header;
-
-
-	icmp-ext sub SCO-extension,
-		owns icmp-type-hex,
-		owns icmp-code-hex,
-		plays icmp-extension:icmp;
-
-	socket-ext sub SCO-extension, 
-		owns address-family, 
-		owns is-blocking,
-		owns is-listening,
-		owns socket-type, 
-		owns socket-descriptor,
-		owns socket-handle,
-		plays socket-options:socket,
-		plays socket-extension:socket;
-
-	socket-value sub stix-attribute-string;
-	socket-key sub stix-attribute-string,
-		owns socket-value,
-		plays socket-options:option;
-
-	tcp-ext sub SCO-extension,
-		owns src-flags-hex,
-		owns dst-flags-hex,
-		plays tcp-extension:tcp;
-
-# 6.13 Process 
-process sub stix-cyber-observable-object,
-	owns is-hidden, 
-	owns pid,
-	owns created-time,
-	owns cwd,
-	owns command-line,
-	plays environment-variables:process,
-
-	plays open-connections:process,
-	plays user-created-by:created,
-	plays process-image:process,
-	plays process-parent:parent,
-	plays process-parent:process,
-	plays process-child:child,
-	plays process-child:process,
-	plays windows-process-extension:process,
-	plays windows-service-extension:process;
-
-	environment-value sub stix-attribute-string;
-	environment-key sub stix-attribute-string,
-		owns environment-value,
-		plays environment-variables:env-variable;
-
-	
-
-#### SCO EXTENSIONS Pt 3 ####
-	windows-process-ext sub SCO-extension,
-		owns aslr-enabled,
-		owns dep-enabled,
-		owns priority,
-		owns owner-sid,
-		owns window-title,
-		owns integrity-level,
-		plays startup-info:process,
-		plays windows-process-extension:win-process;
-
-	startup-value sub stix-attribute-string;
-	startup-key sub stix-attribute-string,
-		owns startup-value,
-		plays startup-info:info;
-
-	windows-service-ext sub SCO-extension, 
-		owns service-name,
-		owns description,
-		owns display-name,
-		owns group-name,
-		owns start-type,
-		owns service-type,
-		owns service-status,
-		plays service-dll:process,
-		plays windows-service-extension:win-service;
-
-
-# 6.14 Software
-software sub stix-cyber-observable-object,
-	owns name, 
-	owns cpe, 
-	owns swid,
-	owns language,
-	owns vendor,
-	owns version;
-
-		
-
-# 6.15 URL
-url sub stix-cyber-observable-object,
-	owns stix-value,
-	plays communicates-with:communicated;
-
-# 6.16 User Account
-user-account sub stix-cyber-observable-object,
-	owns user-id,
-	owns credential,
-	owns account-login,
-	owns account-type,
-	owns display-name,
-	owns is-service-account,
-	owns can-escalate-privs,
-	owns is-disabled,
-	owns account-created,
-	owns account-expires,
-	owns credential-last-changed,
-	owns account-first-login,
-	owns account-last-login,
-	owns is-privileged,
-	plays user-created-by:creator,
-	plays belongs:belongs-to,
-	plays unix-account-extension:account;
-
-	unix-account-ext sub SCO-extension, 
-		owns gid,
-		owns unix-group,
-		owns home-dir,
-		owns shell,
-		plays unix-account-extension:unix;
-
-# 6.17 Windows Registry Key
-windows-registry-key sub stix-cyber-observable-object, 
-	owns attribute-key, 
-	owns modified-time, 
-	owns number-subkeys, 
-	plays reg-val:reg-key,
-	plays user-created-by:created;
-
-windows-registry-value-type sub stix-sub-object,
-	owns name, 
-	owns data,
-	owns data-type,
-	plays reg-val:reg-value;
-
-# 6.18 X.509 Certificate
-x509-certificate sub stix-cyber-observable-object, 
-	owns is-self-signed, 
-	plays hashes:owner, 
-	owns version,
-	owns serial-number,
-	owns signature-algorithm,
-	owns issuer,
-	owns validity-not-before,
-	owns validity-not-after,
-	owns subject,
-	owns subject-public-key-algorithm,
-	owns subject-public-key-modulus,
-	owns subject-public-key-exponent,
-	plays v3-extensions:cert;
-
-	x509-v3-extension sub SCO-extension,
-		owns basic-constraints,
-		owns name-constraints,
-		owns policy-constraints,
-		owns key-usage,
-		owns extended-key-usage,
-		owns subject-key-identifier,
-		owns authority-key-identifier,
-		owns subject-alternative-name,
-		owns issuer-alternative-name,
-		owns subject-directory-attributes,
-		owns crl-distribution-points,
-		owns inhibit-any-policy,
-		owns private-key-usage-period-not-before,
-		owns private-key-usage-period-not-after,
-		owns certificate-policies,
-		owns policy-mappings,
-		plays v3-extensions:v3-extension;
-
-	
-
-##### 7 STIX Meta Objects #####
-
-
-# 7.1 Language Content 
-
-# owns spec-version
-
-# 7.2 Data markings - this describes how data can be used/shared
-
-marking-definition sub stix-object,
-    owns created,
-    owns modified,
-	owns name, 
-	owns spec-version,
-	plays created-by:created,
-	plays data-marking:marking,
-	plays object-marking:marked,
-	plays external-references:referencing;
-
-	statement-marking sub marking-definition, 
-		owns statement; 
-
-	tlp-marking sub marking-definition;
-		tlp-white sub tlp-marking;
-		tlp-green sub tlp-marking;
-		tlp-amber sub tlp-marking;
-		tlp-red sub tlp-marking;
-
-
-
-# 7.3 Extension Definition
-#-----------------------------------------------------------------------------------------------------------------------
-#
-# Extra Pieces
-#-----------------------------------------------------------------------------------------------------------------------
-
-##### Embedded Relations #####
-
-embedded sub relation,
-	relates pointed-to, # the object being pointed to
-	relates owner; # the current object
-
-	data-marking sub embedded, 
-		relates marking as pointed-to,
-		relates marked as owner;
-
-		object-marking sub data-marking; 
-
-		granular-marking sub data-marking,
-			relates object;
-
-	created-by sub embedded, 
-		relates created as owner,
-		relates creator as pointed-to;
-
-	sample sub embedded, 
-		relates sample-for as owner, 
-		relates sco-sample as pointed-to;
-
-		malware-sample sub sample;
-		malware-analysis-sample sub sample;
-
-	kill-chain-usage sub embedded,
-		relates kill-chain-used as owner,
-		relates kill-chain-using as pointed-to;
-		
-
-	external-references sub embedded, 
-		relates referenced as owner,
-		relates referencing as pointed-to;
-
-	hashes sub embedded;
-
-	malware-env sub embedded,
-		relates object as owner,
-		relates env as pointed-to;
-
-		operating-system sub malware-env;   # operating_system_ref
-		installed-software sub malware-env; # installed_software_refs
-		host-vm-ref sub malware-env;            # host_vm_ref 
-		captured-objects sub malware-env;   # analysis_sco_refs 
-
-	obj-refs sub embedded, 
-		relates referred as pointed-to,
-		relates object as owner;
-
-	# file or directory containing relation
-	orig-container sub embedded,
-		relates container as owner,
-		relates contained as pointed-to;
-
-		directory-contains sub orig-container;
-		# network traffic enxapsulate
-		encapsulate sub orig-container;
-
-	
-	# reverse file or directory containing relation
-	orig-contained sub embedded,
-		relates contained as owner,
-		relates container as pointed-to;
-		
-		directory-parent sub orig-contained;
-		# network-traffic encapsulated-by
-		encapsulated sub orig-contained;
-
-	# IP Address or Domain Name
-	resolves-to-ref sub embedded,
-		relates from-ref as owner,
-		relates to-ref as pointed-to;
-
-	# User Account email address belongs to
-	belongs sub embedded,
-		relates belonged as owner,
-		relates belongs-to as pointed-to;
-
-	# IP belongs to autonomous system
-	belongs-to-autonomous sub belongs;
-
-	# Email specific relations
-	body-multipart sub embedded, 
-		relates email as owner,
-		relates mime-part as pointed-to;
- 
-	raw-email-references sub embedded, 
-		relates email as owner,
-		relates binary as pointed-to;
-
-	
-	email-connection sub embedded, 
-		relates email as owner,
-		relates email-address as pointed-to;
-
-		from-email sub email-connection;
-		sender-email sub email-connection;
-		to-email sub email-connection;
-		cc-email sub email-connection;
-		bcc-email sub email-connection;
-	
-	additional-header sub embedded,
-		relates email as owner,
-		relates item as pointed-to;
-
-	body-raw-references sub embedded,
-		relates containing-mime as owner,
-		relates non-textual as pointed-to;
-
-	# file relation
-	content-file sub embedded, 
-		relates containing-file as owner,
-		relates content as pointed-to;
-
-	# network-traffic SCO,
-	traffic-src sub embedded, 
-		relates traffic as owner,
-		relates source as pointed-to;
-
-		payload-src sub traffic-src,
-			relates payload as source;
-
-	traffic-dst sub embedded, 
-		relates traffic as owner,
-		relates destination as pointed-to;
-
-		payload-dst sub traffic-dst,
-			relates payload as destination;
-
-	IPFIX-store sub embedded, 
-		relates traffic as owner,
-		relates item as pointed-to;
-
-	# HTTP Request Extension
-	HTTP_Req_Headers sub embedded, 
-		relates traffic as owner,
-		relates item as pointed-to;	
-
-	# Process Object
-	environment-variables sub embedded, 
-		relates process as owner,
-		relates env-variable as pointed-to;
-
-	
-	open-connections sub embedded,
-		relates opened-connection as pointed-to,
-		relates process as owner;
-
-	
-	user-created-by sub embedded,
-		relates created as owner,
-		relates creator as pointed-to;
-
-	process-image sub embedded,	
-		relates executed-image as pointed-to,
-		relates process as owner;
-
-	process-parent sub embedded,
-		relates parent as pointed-to,
-		relates process as owner;
-
-	process-child sub embedded,
-		relates child as pointed-to,
-		relates process as owner;
-
-	# Windows Registry Key-Value
-	reg-val sub embedded,
-		relates reg-key as owner,
-		relates reg-value as pointed-to;
-
-	
-
-		
-
-	# Extension-Type Embedded Relations
-	#-----------------------------------------------------------------------------------------------------------------------
-	extensions sub embedded, 
-		relates sco as owner,
-		relates extension as pointed-to;
-
-		archive-extension sub extensions,
-			relates file as sco,
-			relates an-archive as extension;
-
-		ntfs-extension sub extensions,
-			relates file as sco,
-			relates ntfs as extension;
-
-		alt-data-streams sub extensions,
-			relates ntfs-ext as sco,
-			relates alt-data-stream as extension;
-
-		pdf-extension sub extensions,
-			relates file as sco,
-			relates pdf as extension;
-
-		doc-info sub extensions,
-			relates pdf as sco,
-			relates info as extension;
-
-		raster-image-extension sub extensions,
-			relates file as sco,
-			relates image as extension;
-			
-		EXIF-tags sub extensions,
-			relates image as sco,
-			relates info as extension;
-
-		windows-pebinary-extension sub extensions,
-			relates file as sco,
-			relates pebinary as extension;
-		
-		optional-headers sub extensions, 
-			relates pebinary as sco,
-			relates optional-header as extension;
-
-		
-		sections sub extensions, 
-			relates pe-section as extension,
-			relates pebinary as sco;
-
-		# HTTP Request Extension
-		http-request-extension sub extensions,
-			relates traffic as sco,
-			relates request as extension;
-
-		HTTP-header sub extensions, 
-			relates request as sco,
-			relates header as extension;
-
-		HTTP-body-data sub extensions,
-			relates contained-data as extension,
-			relates HTPP-message as sco;
-
-		icmp-extension sub extensions,
-			relates traffic as sco,
-			relates icmp as extension;
-
-		# Socket Extension
-		socket-extension sub extensions,
-			relates traffic as sco,
-			relates socket as extension;
-
-		socket-options sub extensions, 
-			relates socket as sco,
-			relates option as extension;
-
-		tcp-extension sub extensions,
-			relates traffic as sco,
-			relates tcp as extension;
-
-		# windows process Extension
-		windows-process-extension sub extensions,
-			relates process as sco,
-			relates win-process as extension;
-		
-		startup-info sub extensions, 
-			relates process as sco,
-			relates info as extension;
-
-		# windows service extension		
-		windows-service-extension sub extensions,
-			relates process as sco,
-			relates win-service as extension;
-
-		service-dll sub extensions, 
-			relates loaded-dll as extension,
-			relates process as sco;
-
-		# unix account extension
-		unix-account-extension sub extensions,
-			relates account as sco,
-			relates unix as extension;
-
-		# windows registry extension
-		v3-extensions sub extensions,
-			relates cert as sco,
-			relates v3-extension as extension;
-
-
-
-
-
-
-
-
-# 3.7 Common Relationships 
-# These are relation types that are shared by SDOs and SCOs
-
-derivation sub relation, 
-	relates derived-from,
-	relates deriving;
-
-duplicate sub relation, 
-	relates duplicated-object; 
-
-relatedness sub relation,
-	relates related-to; 
-
-## INFERRED RELATIONS ## 
-
-kill-chain sub relation, 
-	owns kill-chain-name, 
-	relates participating-kill-chain-phase; 
-
-inferred-mitigation sub mitigates;
-
-
-##### ATTRIBUTES #####
-
-stix-attribute-string sub attribute, value string, abstract,
-	plays granular-marking:marked;
-
-	stix-type sub stix-attribute-string;
-	stix-id sub stix-attribute-string;
-	stix-value sub stix-attribute-string;
-	object-marking-refs sub stix-attribute-string;
-	labels sub stix-attribute-string;
-	langs sub stix-attribute-string;
-	source-name sub stix-attribute-string;
-	description sub stix-attribute-string;
-	url-link sub stix-attribute-string;
-	external-id sub stix-attribute-string;
-	hash-value sub stix-attribute-string;
-
-	kill-chain-name sub stix-attribute-string; 
-	phase-name sub stix-attribute-string; 
-	name sub stix-attribute-string; 
-	sector sub stix-attribute-string; 
-	contact-information sub stix-attribute-string; 
-	indicator-type sub stix-attribute-string; 
-	pattern sub stix-attribute-string; 
-	pattern-type sub stix-attribute-string; 
-	pattern-version sub stix-attribute-string; 
-	
-
-	malware-types sub stix-attribute-string; 
-	architecture-execution-envs sub stix-attribute-string; 
-	implementation-languages sub stix-attribute-string; 
-	capabilities sub stix-attribute-string; 
-	sample-refs sub stix-attribute-string; 
-
-	 
-	object sub stix-attribute-string; 
-
-	threat-actor-type sub stix-attribute-string; 
-	aliases sub stix-attribute-string; 
-	stix-role sub stix-attribute-string; 
-	goals sub stix-attribute-string; 
-	sophistication sub stix-attribute-string; 
-	resource-level sub stix-attribute-string; 
-	primary-motivation sub stix-attribute-string; 
-	secondary-motivations sub stix-attribute-string; 
-	personal-motivations sub stix-attribute-string; 
-	identity-class sub stix-attribute-string;
-
-	summary sub stix-attribute-string; 
-	spec-version sub stix-attribute-string; 
-	attribute-key sub stix-attribute-string; 
-#	value sub stix-attribute-string;
-	number-subkeys sub stix-attribute-string; 
-	objective sub stix-attribute-string;
-	statement sub stix-attribute-string;
-	action sub stix-attribute-string;  
-	tool-type sub stix-attribute-string; # OPEN VOCAB?
-	tool-version sub stix-attribute-string; 
-
-	region sub stix-attribute-string; # open vocab TODO (10.21 Region Vocabulary)
-	country sub stix-attribute-string; 
-	administrative-area sub stix-attribute-string; 
-	city sub stix-attribute-string; 
-	street-address sub stix-attribute-string; 
-	postal-code sub stix-attribute-string; 
-	infrastructure-types sub stix-attribute-string;
-	context sub stix-attribute-string;
-
-	product sub stix-attribute-string;
-	version sub stix-attribute-string;
-	configuration-version sub stix-attribute-string;
-	module sub stix-attribute-string;
-	analysis-engine-version sub stix-attribute-string;
-	analysis-definition-version sub stix-attribute-string;
-	result-name sub stix-attribute-string;
-	result sub stix-attribute-string;
-
-	note-abstract sub stix-attribute-string;
-	content sub stix-attribute-string;
-	report-type sub stix-attribute-string;
-	explanation sub stix-attribute-string;
-	authors sub stix-attribute-string;
-	opinion-enum sub stix-attribute-string;
-	imphash sub stix-attribute-string;
-	magic-number-hex sub stix-attribute-string;
-	pe-type sub stix-attribute-string;
-	name-enc sub stix-attribute-string;
-	mime-type sub stix-attribute-string;
-	payload-bin sub stix-attribute-string;
-	encryption-algorithm sub stix-attribute-string;
-	decryption-key sub stix-attribute-string;
-	rir sub stix-attribute-string;
-	path sub stix-attribute-string;
-	path-enc sub stix-attribute-string;
-
-	display-name sub stix-attribute-string;
-	content-type sub stix-attribute-string;
-	message-id sub stix-attribute-string;
-	subject sub stix-attribute-string;
-	received-lines sub stix-attribute-string;
-	body sub stix-attribute-string;
-
-	socket-value sub stix-attribute-string;
-	socket-key sub stix-attribute-string;
-	HTTP-value sub stix-attribute-string;
-	HTTP-key sub stix-attribute-string;
-	IPFIX-value sub stix-attribute-string;
-	IPFIX-key sub stix-attribute-string;
-	relationship-type sub stix-attribute-string;
-	
-
-	content-disposition sub stix-attribute-string;
-	sid sub stix-attribute-string;
-	is-optimized sub stix-attribute-string;
-	pdfid0 sub stix-attribute-string;
-	pdfid1 sub stix-attribute-string;
-	exif-tags sub stix-attribute-string;
-
-	machine-hex sub stix-attribute-string;
-	pointer-to-symbol-table-hex sub stix-attribute-string;
-	characteristics-hex sub stix-attribute-string;
-	loader-flags-hex sub stix-attribute-string;
-	dll-characteristics-hex sub stix-attribute-string;
-	win32-version-value-hex sub stix-attribute-string;
-	magic-hex sub stix-attribute-string;
-	protocols sub stix-attribute-string;
-	ipfix sub stix-attribute-string;
-
-	icmp-type-hex sub stix-attribute-string;
-	icmp-code-hex sub stix-attribute-string;
-	request-method sub stix-attribute-string;
-	request-value sub stix-attribute-string;
-	request-version sub stix-attribute-string;
-	request-header sub stix-attribute-string;
-	address-family sub stix-attribute-string;
-	options sub stix-attribute-string;
-	socket-type sub stix-attribute-string;
-	src-flags-hex sub stix-attribute-string;
-	dst-flags-hex sub stix-attribute-string;
-
-	checksum-hex sub stix-attribute-string;
-	subsystem-hex sub stix-attribute-string;	
-	cwd sub stix-attribute-string;
-	command-line sub stix-attribute-string;
-	priority sub stix-attribute-string;
-	owner-sid sub stix-attribute-string;
-	window-title sub stix-attribute-string;
-	integrity-level sub stix-attribute-string;
-	service-name sub stix-attribute-string;
-	display-name sub stix-attribute-string;
-	group-name sub stix-attribute-string;
-	start-type sub stix-attribute-string;
-	service-type sub stix-attribute-string;
-	service-status sub stix-attribute-string;
-
-	cpe sub stix-attribute-string;
-	swid sub stix-attribute-string;
-	language sub stix-attribute-string;
-	vendor sub stix-attribute-string;
-	user-id sub stix-attribute-string;
-	credential sub stix-attribute-string;
-	account-login sub stix-attribute-string;
-	account-type sub stix-attribute-string;
-	display-name sub stix-attribute-string;
-
-	unix-group sub stix-attribute-string;
-	home-dir sub stix-attribute-string;
-	shell sub stix-attribute-string;
-	data-type sub stix-attribute-string;
-	serial-number sub stix-attribute-string;
-	signature-algorithm sub stix-attribute-string;
-	issuer sub stix-attribute-string;
-	subject-public-key-algorithm sub stix-attribute-string;
-	subject-public-key-modulus sub stix-attribute-string;
-
-	basic-constraints sub stix-attribute-string;
-	name-constraints sub stix-attribute-string;
-	policy-constraints sub stix-attribute-string;
-	key-usage sub stix-attribute-string;
-	extended-key-usage sub stix-attribute-string;
-	subject-key-identifier sub stix-attribute-string;
-	authority-key-identifier sub stix-attribute-string;
-	subject-alternative-name sub stix-attribute-string;
-	issuer-alternative-name sub stix-attribute-string;
-	subject-directory-attributes sub stix-attribute-string;
-	crl-distribution-points sub stix-attribute-string;
-	inhibit-any-policy sub stix-attribute-string;
-	certificate-policies sub stix-attribute-string;
-	policy-mappings sub stix-attribute-string;
-	data sub stix-attribute-string;
-	comment sub stix-attribute-string;
-
-stix-attribute-integer sub attribute, value long, abstract,
-	plays granular-marking:marked;
-
-	gid sub stix-attribute-integer;
-	image-height sub stix-attribute-integer;
-	image-width sub stix-attribute-integer;
-	bits-per-pixel sub stix-attribute-integer;
-	confidence sub stix-attribute-integer;
-
-	number-of-sections sub stix-attribute-integer;
-	number-of-symbols sub stix-attribute-integer;
-	size-of-optional-header sub stix-attribute-integer;
-	
-	major-linker-version sub stix-attribute-integer;
-	minor-linker-version sub stix-attribute-integer;
-	size-of-code sub stix-attribute-integer;
-	size-of-initialized-data sub stix-attribute-integer;
-	size-of-uninitialized-data sub stix-attribute-integer;
-	address-of-entry-point sub stix-attribute-integer;
-	base-of-code sub stix-attribute-integer;
-	base-of-data sub stix-attribute-integer;
-	image-base sub stix-attribute-integer;
-	section-alignment sub stix-attribute-integer;
-	file-alignment sub stix-attribute-integer;
-	major-os-version sub stix-attribute-integer;
-	minor-os-version sub stix-attribute-integer;
-	major-image-version sub stix-attribute-integer;
-	minor-image-version sub stix-attribute-integer;
-	major-subsystem-version sub stix-attribute-integer;
-	minor-subsystem-version sub stix-attribute-integer;
-	size-of-image sub stix-attribute-integer;
-	size-of-headers sub stix-attribute-integer;
-	size-of-stack-reserve sub stix-attribute-integer;
-	size-of-stack-commit sub stix-attribute-integer;
-	size-of-heap-reserve sub stix-attribute-integer;
-	size-of-heap-commit sub stix-attribute-integer;
-	number-of-rva-and-sizes sub stix-attribute-integer;
-	number-observed sub stix-attribute-integer;
-	size sub stix-attribute-integer; 
-
-	src-port sub stix-attribute-integer; 
-	dst-port sub stix-attribute-integer; 
-	src-byte-count sub stix-attribute-integer; 
-	dst-byte-count sub stix-attribute-integer; 
-	src-packets sub stix-attribute-integer; 
-	dst-packets sub stix-attribute-integer; 
-	
-	
-
-stix-attribute-double sub attribute, value double, abstract,
-	plays granular-marking:marked;		
-
-	latitude sub stix-attribute-double;
-	longitude sub stix-attribute-double;
-	precision sub stix-attribute-double;
-	
-	sighting-count sub stix-attribute-double;
-	number sub stix-attribute-double;
-	
-	entropy sub stix-attribute-double;
-	message-body-length sub stix-attribute-double;
-	socket-descriptor sub stix-attribute-double;
-	socket-handle sub stix-attribute-double;
-	pid sub stix-attribute-double;
-	subject-public-key-exponent sub stix-attribute-double;
-
-stix-attribute-boolean sub attribute, value boolean, abstract, 
-	plays granular-marking:marked;
-
-	revoked sub stix-attribute-boolean;
-	is-family sub stix-attribute-boolean;
-	is-multipart sub stix-attribute-boolean;
-	is-active sub stix-attribute-boolean;
-	is-blocking sub stix-attribute-boolean;
-	is-listening sub stix-attribute-boolean;
-	is-hidden sub stix-attribute-boolean;
-	aslr-enabled sub stix-attribute-boolean;
-	dep-enabled sub stix-attribute-boolean;
-	is-service-account sub stix-attribute-boolean;
-	is-privileged sub stix-attribute-boolean;
-	can-escalate-privs sub stix-attribute-boolean;
-	is-disabled sub stix-attribute-boolean;
-	is-self-signed sub stix-attribute-boolean;
-	defanged sub stix-attribute-boolean;
-	
-
-stix-attribute-timestamp sub attribute, value datetime, abstract, 
-	plays granular-marking:marked;
-
-	date sub stix-attribute-timestamp;
-	submitted sub stix-attribute-timestamp;
-	analysis-started sub stix-attribute-timestamp;
-	analysis-ended sub stix-attribute-timestamp;
-	published sub stix-attribute-timestamp;
-	ctime sub stix-attribute-timestamp;
-	mtime sub stix-attribute-timestamp;
-	atime sub stix-attribute-timestamp;
-	time-date-stamp sub stix-attribute-timestamp;
-	start sub stix-attribute-timestamp;
-	end sub stix-attribute-timestamp;
-	created-time sub stix-attribute-timestamp;
-	account-created sub stix-attribute-timestamp;
-	account-expires sub stix-attribute-timestamp;
-	credential-last-changed sub stix-attribute-timestamp;
-	account-first-login sub stix-attribute-timestamp;
-	account-last-login sub stix-attribute-timestamp;
-	validity-not-before sub stix-attribute-timestamp;
-	validity-not-after sub stix-attribute-timestamp;
-	private-key-usage-period-not-before sub stix-attribute-timestamp;
-	private-key-usage-period-not-after sub stix-attribute-timestamp;
-	start-time sub stix-attribute-timestamp;
-	stop-time sub stix-attribute-timestamp;
-	created sub stix-attribute-timestamp;
-	modified sub stix-attribute-timestamp;
-	valid-from sub stix-attribute-timestamp; 
-	valid-until sub stix-attribute-timestamp; 
-	
-	modified-time sub stix-attribute-timestamp; 
-	first-seen sub stix-attribute-timestamp; 
-	last-seen sub stix-attribute-timestamp; 
-	first-observed sub stix-attribute-timestamp; 
-	last-observed sub stix-attribute-timestamp;
-	
-
-custom-attribute sub attribute, value string, 
-	plays granular-marking:marked,
-	owns attribute-type; 
-
-attribute-type sub attribute, value string;
+#
+# Copyright (C) 2022 OS-Threat
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+# Note: Large portions of this schema were originally defined by Tomas Sabat, Vaticle, 2021
+#
+
+define
+stix-entity sub entity,
+    abstract;
+
+stix-object sub stix-entity,
+	# Required
+	owns stix-type,
+	owns stix-id @key, #
+	owns custom-attribute,
+	plays stix-core-relationship:source,
+	plays stix-core-relationship:target,
+	plays obj-refs:referred, 
+	plays granular-marking:object;
+
+	stix-core-object sub stix-object, 
+		# Required for SDO but Optional for SCO
+		owns spec-version,
+
+		# Optional
+		plays object-marking:marked,
+		plays created-by:created,
+
+		# Common relations for SDOs and SCOs. Defined in 3.7. 
+		plays derivation:derived-from,
+		plays derivation:deriving,
+		plays duplicate:duplicated-object,
+		plays relatedness:related-to;
+
+			stix-domain-object sub stix-core-object, 
+				# Required
+				owns created,
+				owns modified, 
+
+				# Optional
+				owns revoked, 
+				owns labels,
+				owns confidence,
+				owns langs,
+				plays external-references:referenced,
+				plays sighting:sighting-of,
+
+				plays indicates:indicated;
+
+			stix-cyber-observable-object sub stix-core-object,
+				owns defanged,
+				plays malware-env:env,
+				plays extensions:sco,
+				plays consist:consisted;
+
+	stix-sub-object sub stix-entity,
+		abstract, 
+		owns created, 
+		owns modified,
+        plays stix-core-relationship:source,
+        plays stix-core-relationship:target,
+        plays obj-refs:referred,
+        plays granular-marking:object;
+
+
+##### 2 Common Data Types #####
+
+# 2.5 External Reference
+external-reference sub stix-sub-object,
+	# In addition to source-name, at least one of description, url or external-id must be present
+	# Required
+	owns source-name, 
+
+	# Optional
+	owns description,
+	owns url-link, 
+	owns external-id, 
+	plays hashes:owner,
+	plays external-references:referencing;
+
+
+# 2.7 Hash
+hash sub stix-sub-object,
+	owns hash-value, 
+	plays hashes:pointed-to; 
+
+	md-5 sub hash;
+	sha-1 sub hash; 
+	sha-256 sub hash;
+	sha-512 sub hash; 
+	sha3-256 sub hash; 
+	sha3-512 sub hash;
+	ssdeep sub hash; 
+	tlsh sub hash; 
+
+
+
+# 2.11 Kill Chain Phase
+kill-chain-phase sub stix-sub-object,
+	owns kill-chain-name, 
+	owns phase-name,
+	plays kill-chain-usage:kill-chain-using,
+
+	# inferred role player
+	plays kill-chain:participating-kill-chain-phase;
+
+
+##### 4 STIX Domain Objects #####
+
+# Custom object
+custom-object sub stix-domain-object,
+	owns name, 
+	owns description, 
+	owns aliases, 
+	owns first-seen,
+	owns last-seen,
+	owns objective,
+	plays kill-chain-usage:kill-chain-used,
+	plays delivers:delivering,
+	plays targets:targetter,
+	plays uses:used-by,
+	plays mitigates:mitigated,
+	plays uses:used;
+
+
+# 4.1 
+attack-pattern sub stix-domain-object,
+	owns name,
+	owns description,
+	owns aliases,
+
+	# Relations defined as properties in STIX
+	plays kill-chain-usage:kill-chain-used,
+
+	# Common Relations
+	plays delivers:delivering,
+	plays targets:targetter,
+	plays uses:used-by,
+
+	# Reverse Relations
+	# plays indicates:indicated, -> Defined in SDO
+	plays mitigates:mitigated,
+	plays uses:used;
+
+	# Embedded Relations
+	# created-by
+	# Object marking ref
+
+# 4.2 Campaign
+campaign sub stix-domain-object, 
+	owns name, 
+	owns description, 
+	owns aliases, 
+	owns first-seen,
+	owns last-seen,
+	owns objective, 
+
+	# Common Relations
+	plays attributed-to:result,
+	plays compromises:compromising,
+	plays originates-from:originating,
+	plays targets:targetter,
+	plays uses:used-by;
+
+	# Reverse Relations
+	#plays indicates:indicated; -> Defined in SDO
+
+	# Embedded relations
+	# created-by
+	# Object marking
+
+# 4.3 Course of Action
+course-of-action sub stix-domain-object,
+	owns name, 
+	owns description, 
+	owns action,
+
+	# Common Relations
+	plays investigates:investigating,
+	plays mitigates:mitigator,
+	plays remediation:remediating,
+	plays uses:used-by;
+
+	# Reverse Relations
+	# NA
+
+	# Embedded relations
+	# created-by
+	# Object marking ref
+
+# 4.4 Grouping 
+grouping sub stix-domain-object,
+	owns name, 
+	owns description, 
+	owns context,
+
+	# Common Relations
+	# NA 
+
+	# Reverse Relations
+	# NA
+
+	# Embedded Relations
+	# created-by
+	# Object markings
+	plays obj-refs:object;
+
+# 4.5 Identity
+identity sub stix-domain-object,
+	owns name, 
+	owns description, 
+	owns stix-role,
+	owns identity-class,
+	owns sector,  # should this perhaps be a relation?
+	owns contact-information,
+
+	# Common Relations
+	plays located-at:locating,
+
+	# Reverse Relations
+	plays targets:targetted,
+	plays attributed-to:fault-of, 
+	plays impersonate:impersonated,
+
+	# Embedded Relations
+	plays created-by:creator,
+	# Object marking ref
+	
+	plays sighting:where-sighted; 
+
+	# 10.7 Identity Class Vocabulary
+	individual sub identity;
+	identity-group sub identity;
+	system sub identity;
+	organization sub identity;
+	class sub identity;
+	id-unknown sub identity;
+
+# 4.6 Incident
+incident sub stix-domain-object, 
+	owns name, 
+	owns description;
+
+ 	# Common Relations
+ 	# NA
+
+ 	# Reverse Relations
+ 	# NA
+
+	# Embedded relations
+	# created-by
+	# Object Marking
+
+# 4.7 Indicator
+indicator sub stix-domain-object, 
+	owns name, 
+	owns description, 
+	owns indicator-type,
+	owns pattern, 
+	owns pattern-type, 
+	owns pattern-version,
+	owns valid-from,
+	owns valid-until,
+
+	# Relations defined as properties in STIX
+	plays kill-chain-usage:kill-chain-used,
+
+	# Common Relations
+	plays indicates:indicating,
+	plays based-on:basing-on,
+
+	# Reverse Relations
+	plays investigates:investigated,
+	plays mitigates:mitigated;
+
+	# Embedded Relations
+	# created-by
+	# Object marking ref
+
+# 4.8 Infrastructure 
+infrastructure sub stix-domain-object,
+	owns name, 
+	owns description,
+	owns infrastructure-types, # Should this OV be a relation to define?
+	owns aliases, 
+	plays kill-chain-usage:kill-chain-used, 
+	owns first-seen,
+	owns last-seen,
+
+	# Common Relations
+	plays communicates-with:communicating,
+	plays consist:consisting,
+	plays control:controlling,
+
+	plays delivers:delivering,
+	plays have:having,
+	plays hosts:hosting,
+	plays located-at:locating,
+	plays uses:used-by,
+
+	# Reverse Relations
+	plays control:controlled,
+	plays communicates-with:communicated,
+	plays compromises:compromised,
+	plays beacon:beaconed-to,
+	plays exfiltrate:exfiltrated-to,
+	plays hosts:hosted,
+	# plays indicates:indicated, defined in SDO
+	plays ownership:owned,
+	plays targets:targetted,
+	plays uses:used;
+
+	# Object marking ref
+
+# 4.9 Intrusion Set
+intrusion-set sub stix-domain-object,
+	owns name, 
+	owns description, 
+	owns aliases, 
+	owns first-seen,
+	owns last-seen,
+	owns goals, 
+	owns resource-level, 
+	owns primary-motivation, 
+	owns secondary-motivations,
+
+	# Common Relations
+	plays attributed-to:result,
+	plays compromises:compromising,
+	plays hosts:hosting,
+	plays ownership:owning,
+	plays originates-from:originating,
+	plays targets:targetter,
+	plays uses:used-by,
+	plays uses:used,
+
+	# Reverse Relations
+	plays attributed-to:fault-of, 
+	plays authored-by:authored,
+	# plays indicates:indicated; Already defined in SDO
+
+	# Embedded Relations
+	# created-by
+	# Object marking 
+
+	# Inferred role player
+	plays inferred-mitigation:mitigated;
+
+# 4.10 Location
+location sub stix-domain-object,
+	owns name, 
+	owns description,
+	owns latitude,
+	owns longitude,
+	owns precision,
+	owns region,
+	owns country,
+	owns administrative-area,
+	owns city,
+	owns street-address,
+	owns postal-code,
+
+	# Common Relations
+	# NA
+
+	# Reverse relations
+	plays located-at:located,
+	plays originates-from:originated-from,
+	plays targets:targetted,
+	plays sighting:where-sighted;
+
+	# Embedded Relations
+	#created-by
+	# Object marking
+
+# 4.11 Malware
+malware sub stix-domain-object, 
+	owns name, 
+	owns description, 
+	owns malware-types,
+	owns is-family, 
+    owns aliases,
+    owns first-seen,
+    owns last-seen,
+    owns architecture-execution-envs,
+    owns implementation-languages,
+    owns capabilities,
+    
+    # Relations defined as properties in STIX
+	plays kill-chain-usage:kill-chain-used,
+	plays malware-sample:sample-for, # ssample_refs
+
+    # Common Relations
+    plays authored-by:authoring,
+    plays beacon:beaconing-to,
+    plays exfiltrate:exfiltrating-to,
+    plays control:controlling,
+    plays download:downloading,
+    plays drop:dropping,
+    plays exploit:exploiting,
+    plays originates-from:originating,
+    plays targets:targetter,
+    plays hosts:hosting,
+    plays uses:used-by,
+    plays variant:variant-source,
+    plays communicates-with:communicating,
+
+   	# Reverse Relations
+   	plays variant:variant-target,
+   	plays delivers:delivered,
+   	plays mitigates:mitigated,
+	plays remediation:remediated,
+	plays uses:used,
+	plays drop:dropped,
+	plays control:controlled,
+	plays characterise:characterised,
+	plays av-analysis:analysed,
+	plays static-analysis:analysed,
+	plays dynamic-analysis:analysed,
+
+    plays download:downloaded,
+    plays exploit:exploiting,
+
+    # Embedded Relations
+    # created-by
+    #Obejct marking
+    # Sample ref
+	plays malware-env:object;
+
+
+# 4.12 Malware Analysis
+malware-analysis sub stix-domain-object,
+	owns product, 
+	owns version,
+	owns configuration-version,
+	owns module,
+	owns analysis-engine-version,
+	owns analysis-definition-version,
+	owns submitted,
+	owns analysis-started,
+	owns analysis-ended,
+	owns result-name,
+	owns result,
+
+	# Relations defined as properties in STIX
+	# host_vm_ref, _operating_system_ref, instsalled_software_ref, analysis-sco are all defined as 
+	# playing roles in the analysis relation
+	plays malware-analysis-sample:sample-for, # sample_refs
+
+	# Common Relations
+	plays characterise:characterising,
+	plays av-analysis:analysing,
+	plays static-analysis:analysing,
+	plays dynamic-analysis:analysing,
+
+	# Reverse Relations
+	# NA
+
+	# Embedded Relations
+	# created-by
+	# Object markingss
+	# hosts-vm
+	# operating-system
+	# installed-software
+	# analysis-sco
+	# sample-ref
+	plays malware-env:object;
+
+
+# 4.13 Note
+note sub stix-domain-object, 
+	owns note-abstract, 
+	owns content, 
+	owns authors,
+
+	# Relations 
+	# NA
+
+	# Embedded Relations
+	# created-by
+	# Object marking
+	plays obj-refs:object;
+
+# 4.14
+observed-data sub stix-domain-object,
+	owns first-observed, 
+	owns last-observed, 
+	owns number-observed,
+
+	# Common Relations
+	# NA
+
+	# Reverse Relations
+	plays based-on:basis,
+	plays consist:consisted,
+
+	plays sighting:observed, # This is for SRO 5.2 sighting
+
+	# Embedded Relations
+	#created-by
+	#Object marking
+	plays obj-refs:object; # Object ref
+
+# 4.15 Opinion
+opinion sub stix-domain-object, 
+	owns explanation,
+	owns authors,
+	owns opinion-enum, 
+
+	# Common Relations
+	# NA
+
+	# Reverse Relations
+	# NA
+
+	# Embedded relations
+	# created-by
+	# Object marking
+	plays obj-refs:object;
+
+# 4.16 Report
+report sub stix-domain-object, 
+	owns name, 
+	owns description,
+	owns report-type, 
+	owns published, 
+
+	# Common Relations
+	# NA
+
+	# Reverse Relations
+	# NA
+
+	# Embedded relations
+	# created-by 
+	# Object Marking
+	plays obj-refs:object;
+
+# 4.17
+threat-actor sub stix-domain-object,
+	owns name, 
+	owns description, 
+	owns threat-actor-type,
+	owns aliases,
+	owns first-seen,
+	owns last-seen,
+	owns stix-role,
+	owns goals,
+	owns sophistication,
+	owns resource-level, 
+	owns primary-motivation,
+	owns secondary-motivations,
+	owns personal-motivations,
+
+
+	# Common Relations
+	plays attributed-to:result,
+	plays compromises:compromising,
+	plays hosts:hosting,
+	plays ownership:owning,
+	plays impersonate:impersonating,
+	plays located-at:locating,
+	plays targets:targetter,
+	plays uses:used-by,
+
+	# Reverse Relations
+	plays attributed-to:fault-of,
+	plays authored-by:authored;
+	# plays indicates:indicated # defined in SDO
+
+	# Embedded relations
+	# created-by 
+	# Object Marking
+
+# 4.18 Tool
+tool sub stix-domain-object,
+	owns name,
+	owns description,
+	owns tool-type,
+	owns aliases, 
+	owns tool-version,
+
+	# Relations defined as properties in STIX
+	plays kill-chain-usage:kill-chain-used,
+
+	#Common Relations
+	plays delivers:delivering,
+	plays drop:dropping,
+	plays have:having,
+	plays targets:targetter,
+	plays uses:used-by,
+
+	# Reverse Relations
+	plays download:downloaded,
+	plays drop:dropped,
+	plays hosts:hosted,
+	plays mitigates:mitigated,
+	plays uses:used;
+	# plays indicates:indicated, Already defined in SDO
+
+	# Embedded Relations
+	# created-by
+	# Object Marking
+
+# 4.19 Vulnerability
+vulnerability sub stix-domain-object,
+	owns name, 
+	owns description,
+
+	# Relations defined as properties in STIX
+	# plays external-references:referencing, Defined in SDO
+
+	# Common Relations
+	# NA
+
+	# Reverse Relations
+ 	plays targets:targetted,
+ 	plays exploit:exploited,
+ 	plays mitigates:mitigated,
+ 	plays remediation:remediated,
+ 	plays have:had;
+
+ 	#Embedded Relations
+ 	# created-by
+ 	# Object Marking
+
+##### 5 STIX Relationship Objects #####
+
+# 5.1 Specification-Defined Relatinoships Summary
+stix-core-relationship sub relation,
+	# Required
+	owns spec-version,
+	owns stix-id @key,
+	owns created,
+	owns modified,
+	owns stix-type,
+
+	# Optional
+	owns description,
+	owns revoked,
+	owns labels,
+	owns confidence, 
+	owns langs,
+	owns start-time,
+	owns stop-time,
+	owns relationship-type,
+	owns custom-attribute,
+
+	relates source, 
+	relates target,
+	plays obj-refs:referred,
+	plays object-marking:marked,
+	plays granular-marking:object, 
+	plays external-references:referenced,
+	plays created-by:created;
+
+
+	# Specific Relationships from Appendix C
+	delivers sub stix-core-relationship, 
+		relates delivering as source, 
+		relates delivered as target;
+
+	targets sub stix-core-relationship, 
+		relates targetter as source,
+		relates targetted as target;
+
+	uses sub stix-core-relationship,
+		relates used-by as source,
+		relates used as target;
+
+	attributed-to sub stix-core-relationship, 
+		relates result as source,
+		relates fault-of as target; 
+	
+	compromises sub stix-core-relationship,
+		relates compromising as source,
+		relates compromised as target;
+	
+	originates-from sub stix-core-relationship,
+		relates originated-from as target,
+		relates originating as source;
+	
+	investigates sub stix-core-relationship,
+		relates investigating as source,
+		relates investigated as target;
+
+	mitigates sub stix-core-relationship,
+		relates mitigated as target,
+		relates mitigator as source;
+	
+	located-at sub stix-core-relationship,
+		relates located as target,
+		relates locating as source;
+
+	indicates sub stix-core-relationship, 
+		relates indicating as source,
+		relates indicated as target; 
+	
+	based-on sub stix-core-relationship,
+		relates basing-on as source,
+		relates basis as target;
+	
+	communicates-with sub stix-core-relationship,
+		relates communicating as source,
+		relates communicated as target;
+
+	consist sub stix-core-relationship,
+		relates consisting as source,
+		relates consisted as target;
+
+	control sub stix-core-relationship,
+		relates controlling as source,
+		relates controlled as target;
+	
+	have sub stix-core-relationship, # Could come up with a better name?
+		relates having as source,
+		relates had as target;
+	
+	hosts sub stix-core-relationship,
+		relates hosting as source,
+		relates hosted as target;
+	
+	ownership sub stix-core-relationship,
+		relates owned as target,
+		relates owning as source;
+	
+	authored-by sub stix-core-relationship,
+		relates authoring as source,
+		relates authored as target;
+
+	resolve-to sub stix-core-relationship,
+	    relates resolves-from as source,
+	    relates resolves-to as target;
+
+	beacon sub stix-core-relationship,
+		relates beaconed-to as target,
+		relates beaconing-to as source;
+	
+	exfiltrate sub stix-core-relationship,
+		relates exfiltrated-to as target,
+		relates exfiltrating-to as source;
+	
+	download sub stix-core-relationship,
+		relates downloaded as target,
+		relates downloading as source;
+
+	drop sub stix-core-relationship,
+		relates dropped as target,
+		relates dropping as source;
+
+	exploit sub stix-core-relationship,
+		relates exploiting as source,
+		relates exploited as target;
+
+	variant sub stix-core-relationship,
+		relates variant-source as source,
+		relates variant-target as target;
+
+	characterise sub stix-core-relationship,
+		relates characterised as target,
+		relates characterising as source;
+
+	impersonate sub stix-core-relationship,
+		relates impersonating as source,
+		relates impersonated as target;
+
+
+	analysis sub stix-core-relationship,
+		relates analysing as source,
+		relates analysed as target;
+
+		av-analysis sub analysis;
+		static-analysis sub analysis;
+		dynamic-analysis sub analysis;
+		analysis-of sub analysis;
+
+	remediation sub stix-core-relationship,
+		relates remediating as source,
+		relates remediated as target;
+
+
+# 5.2 Sighting
+sighting sub stix-core-relationship, 
+	owns first-seen,
+	owns last-seen,
+	owns sighting-count,
+	owns summary,
+	relates where-sighted,
+	relates sighting-of as source, 
+	relates observed;
+
+##### 6 STIX Cyber-observable Objects #####
+
+# 6.1 Artifact Object
+artifact sub stix-cyber-observable-object,
+	owns mime-type,
+	owns payload-bin,
+	owns url-link, 
+	plays hashes:owner,
+	owns encryption-algorithm,
+	owns decryption-key,
+	plays payload-src:payload,
+	plays payload-dst:payload,
+	plays malware-analysis-sample:sco-sample,
+	plays malware-sample:sco-sample,
+	plays raw-email-references:binary,
+	plays body-raw-references:non-textual,
+	plays content-file:containing-file,
+	plays HTTP-body-data:contained-data;
+
+# 6.2 Autonomous System Object
+autonomous-system sub stix-cyber-observable-object,
+	owns number,
+	owns name,
+	owns rir,
+	plays belongs-to-autonomous:belongs-to;
+
+# 6.3 Directory Object
+directory sub stix-cyber-observable-object,
+	owns path, 
+	owns path-enc,
+	owns ctime,
+	owns mtime,
+	owns atime,
+	plays directory-contains:container,
+	plays directory-contains:contained,
+	plays directory-parent:contained,
+	plays directory-parent:container;
+
+# 6.4 Domain Name Object
+domain-name sub stix-cyber-observable-object,
+	owns stix-value, 
+	plays resolves-to-ref:from-ref,
+	plays resolves-to-ref:to-ref,
+	plays communicates-with:communicated,
+	plays traffic-src:source,
+	plays traffic-dst:destination,
+	plays resolve-to:resolves-from,
+	plays resolve-to:resolves-to;
+
+# 6.5 Email Address Object
+email-addr sub stix-cyber-observable-object,
+	owns stix-value, 
+	owns display-name,
+	plays belongs:belonged,
+	plays from-email:email-address,
+	plays to-email:email-address,
+	plays cc-email:email-address,
+	plays bcc-email:email-address;
+
+# 6.6 Email Message
+email-message sub stix-cyber-observable-object,
+	owns is-multipart,
+	owns date,
+	owns content-type,
+	owns message-id,
+	owns subject,
+	owns received-lines, # List of type string
+	owns body,
+
+	plays body-multipart:email,
+	plays email-connection:email,
+	plays additional-header:email,
+	plays raw-email-references:email;
+
+
+header-value sub stix-attribute-string;
+header-key sub stix-attribute-string,
+	owns header-value,
+	plays additional-header:item;
+
+email-mime-part sub stix-sub-object,
+	owns body,
+	owns content-type, 
+	owns content-disposition, 
+	plays body-multipart:mime-part,
+	plays body-raw-references:containing-mime;
+
+# 6.7 File
+file sub stix-cyber-observable-object,
+	plays hashes:owner, 
+	owns size,
+	owns name,
+	owns name-enc,
+	owns magic-number-hex,
+	owns mime-type,
+	owns ctime,
+	owns mtime,
+	owns atime, 
+
+	plays directory-contains:contained,
+	plays directory-parent:contained,
+	plays content-file:containing-file,
+	plays body-raw-references:non-textual,
+	plays malware-analysis-sample:sco-sample,
+	plays malware-sample:sco-sample,
+	plays download:downloaded,
+	plays process-image:executed-image,
+	plays service-dll:loaded-dll,
+	plays archive-extension:file,
+	plays ntfs-extension:file,
+	plays pdf-extension:file,
+	plays raster-image-extension:file,
+	plays windows-pebinary-extension:file;
+
+#### SCO EXTENSIONS ####
+
+SCO-extension sub stix-sub-object,
+	plays extensions:extension;
+
+	archive-ext sub SCO-extension,
+		owns comment,
+		plays directory-contains:container,
+		plays archive-extension:an-archive;
+
+	ntfs-ext sub SCO-extension,
+		owns sid, 
+		plays alt-data-streams:ntfs-ext,
+		plays ntfs-extension:ntfs;
+
+	alternate-data-stream sub SCO-extension, 
+		owns name, 
+		plays hashes:owner, 
+		owns size, 
+		plays alt-data-streams:alt-data-stream; 
+
+	pdf-ext sub SCO-extension,
+		owns version,
+		owns is-optimized,
+		owns pdfid0,
+		owns pdfid1,
+		plays doc-info:pdf,
+		plays pdf-extension:pdf;
+
+	doc-value sub stix-attribute-string;
+	doc-key sub stix-attribute-string,
+		owns doc-value,
+		plays doc-info:info;
+
+	raster-image-ext sub SCO-extension,
+		owns image-height,
+		owns image-width,
+		owns bits-per-pixel,
+		plays EXIF-tags:image,
+		plays raster-image-extension:image; 
+	
+	EXIF-value sub stix-attribute-string;
+	EXIF-key sub stix-attribute-string,
+		owns EXIF-value,
+		plays EXIF-tags:info;
+
+
+	windows-pebinary-ext sub SCO-extension, 	
+		owns pe-type,
+		owns imphash,
+		owns machine-hex,
+		owns number-of-sections,
+		owns time-date-stamp,
+		owns pointer-to-symbol-table-hex,
+		owns number-of-symbols,
+		owns size-of-optional-header,
+		owns characteristics-hex,
+		plays hashes:owner, 
+		plays optional-headers:pebinary,
+		plays sections:pebinary,
+		plays windows-pebinary-extension:pebinary;
+
+	windows-pe-optional-header-type sub SCO-extension, 
+		owns magic-hex,
+		owns major-linker-version,
+		owns minor-linker-version,
+		owns size-of-code,
+		owns size-of-initialized-data,
+		owns size-of-uninitialized-data,
+		owns address-of-entry-point,
+		owns base-of-code,
+		owns base-of-data,
+		owns image-base,
+		owns section-alignment,
+		owns file-alignment,
+		owns major-os-version,
+		owns minor-os-version,
+		owns major-image-version,
+		owns minor-image-version,
+		owns major-subsystem-version,
+		owns minor-subsystem-version,
+		owns win32-version-value-hex,
+		owns size-of-image,
+		owns size-of-headers,
+		owns checksum-hex,
+		owns subsystem-hex,
+		owns dll-characteristics-hex,
+		owns size-of-stack-reserve,
+		owns size-of-stack-commit,
+		owns size-of-heap-reserve,
+		owns size-of-heap-commit,
+		owns loader-flags-hex,
+		owns number-of-rva-and-sizes, 
+		plays hashes:owner,
+		plays optional-headers:optional-header;
+
+	windows-pe-section sub SCO-extension,
+		owns name, 
+		owns size, 
+		owns entropy, 
+		plays hashes:owner, 
+		plays sections:pe-section;
+
+# 6.8 IPv4 Address
+ipv4-addr sub stix-cyber-observable-object,
+	owns stix-value, 
+	plays resolves-to-ref:to-ref,
+	plays resolves-to-ref:from-ref,
+	plays belongs-to-autonomous:belonged,
+	plays communicates-with:communicated,
+	plays traffic-src:source,
+	plays traffic-dst:destination,
+	#plays consist:consisted,
+	plays resolve-to:resolves-from,
+	plays resolve-to:resolves-to;
+
+# 6.9 IPv6 Address
+ipv6-addr sub stix-cyber-observable-object,
+	owns stix-value, 
+	plays resolves-to-ref:to-ref,
+	plays resolves-to-ref:from-ref,
+	plays belongs-to-autonomous:belonged,	
+	plays communicates-with:communicated,
+	plays traffic-src:source,
+	plays traffic-dst:destination,
+	#plays consist:consisted,
+	plays resolve-to:resolves-from,
+	plays resolve-to:resolves-to;
+
+# 6.10 MAC Address
+mac-addr sub stix-cyber-observable-object,
+	owns stix-value,
+	plays resolves-to-ref:to-ref,
+	plays traffic-src:source,
+	plays traffic-dst:destination,
+	plays resolve-to:resolves-to;
+
+# 6.11 Mutex
+mutex sub stix-cyber-observable-object,
+	owns name; 
+
+# 6.12 Network Traffic - This should really be a relation? 
+network-traffic sub stix-cyber-observable-object,
+	owns start, 
+	owns end,
+	owns is-active, 
+	owns protocols, 
+	owns src-port,
+	owns dst-port,
+	owns src-byte-count,
+	owns dst-byte-count,
+	owns src-packets,
+	owns dst-packets,
+	plays traffic-src:traffic,
+	plays payload-src:traffic,
+	plays traffic-dst:traffic,
+	plays payload-dst:traffic,
+	
+	plays encapsulate:container,
+	plays encapsulate:contained,
+	plays encapsulated:container,
+	plays encapsulated:contained,
+	plays malware-analysis-sample:sco-sample,
+	plays IPFIX-store:traffic,
+	plays open-connections:opened-connection,
+	plays http-request-extension:traffic,
+	plays icmp-extension:traffic,
+	plays socket-extension:traffic,
+	plays tcp-extension:traffic;
+
+	IPFIX-value sub stix-attribute-string;
+	IPFIX-key sub stix-attribute-string,
+		owns IPFIX-value,
+		plays IPFIX-store:item;
+
+#### SCO EXTENSIONS Pt 2 ####
+	http-request-ext sub SCO-extension,
+		owns request-method,
+		owns request-value,
+		owns request-version,
+		owns request-header,
+		owns message-body-length,
+		plays HTTP-header:request,
+		plays HTTP-body-data:HTPP-message,
+		plays http-request-extension:request;
+
+	HTTP-value sub stix-attribute-string;
+	HTTP-key sub stix-attribute-string,
+		owns HTTP-value,
+		plays HTTP-header:header;
+
+
+	icmp-ext sub SCO-extension,
+		owns icmp-type-hex,
+		owns icmp-code-hex,
+		plays icmp-extension:icmp;
+
+	socket-ext sub SCO-extension, 
+		owns address-family, 
+		owns is-blocking,
+		owns is-listening,
+		owns socket-type, 
+		owns socket-descriptor,
+		owns socket-handle,
+		plays socket-options:socket,
+		plays socket-extension:socket;
+
+	socket-value sub stix-attribute-string;
+	socket-key sub stix-attribute-string,
+		owns socket-value,
+		plays socket-options:option;
+
+	tcp-ext sub SCO-extension,
+		owns src-flags-hex,
+		owns dst-flags-hex,
+		plays tcp-extension:tcp;
+
+# 6.13 Process 
+process sub stix-cyber-observable-object,
+	owns is-hidden, 
+	owns pid,
+	owns created-time,
+	owns cwd,
+	owns command-line,
+	plays environment-variables:process,
+
+	plays open-connections:process,
+	plays user-created-by:created,
+	plays process-image:process,
+	plays process-parent:parent,
+	plays process-parent:process,
+	plays process-child:child,
+	plays process-child:process,
+	plays windows-process-extension:process,
+	plays windows-service-extension:process;
+
+	environment-value sub stix-attribute-string;
+	environment-key sub stix-attribute-string,
+		owns environment-value,
+		plays environment-variables:env-variable;
+
+	
+
+#### SCO EXTENSIONS Pt 3 ####
+	windows-process-ext sub SCO-extension,
+		owns aslr-enabled,
+		owns dep-enabled,
+		owns priority,
+		owns owner-sid,
+		owns window-title,
+		owns integrity-level,
+		plays startup-info:process,
+		plays windows-process-extension:win-process;
+
+	startup-value sub stix-attribute-string;
+	startup-key sub stix-attribute-string,
+		owns startup-value,
+		plays startup-info:info;
+
+	windows-service-ext sub SCO-extension, 
+		owns service-name,
+		owns description,
+		owns display-name,
+		owns group-name,
+		owns start-type,
+		owns service-type,
+		owns service-status,
+		plays service-dll:process,
+		plays windows-service-extension:win-service;
+
+
+# 6.14 Software
+software sub stix-cyber-observable-object,
+	owns name, 
+	owns cpe, 
+	owns swid,
+	owns language,
+	owns vendor,
+	owns version;
+
+		
+
+# 6.15 URL
+url sub stix-cyber-observable-object,
+	owns stix-value,
+	plays communicates-with:communicated;
+
+# 6.16 User Account
+user-account sub stix-cyber-observable-object,
+	owns user-id,
+	owns credential,
+	owns account-login,
+	owns account-type,
+	owns display-name,
+	owns is-service-account,
+	owns can-escalate-privs,
+	owns is-disabled,
+	owns account-created,
+	owns account-expires,
+	owns credential-last-changed,
+	owns account-first-login,
+	owns account-last-login,
+	owns is-privileged,
+	plays user-created-by:creator,
+	plays belongs:belongs-to,
+	plays unix-account-extension:account;
+
+	unix-account-ext sub SCO-extension, 
+		owns gid,
+		owns unix-group,
+		owns home-dir,
+		owns shell,
+		plays unix-account-extension:unix;
+
+# 6.17 Windows Registry Key
+windows-registry-key sub stix-cyber-observable-object, 
+	owns attribute-key, 
+	owns modified-time, 
+	owns number-subkeys, 
+	plays reg-val:reg-key,
+	plays user-created-by:created;
+
+windows-registry-value-type sub stix-sub-object,
+	owns name, 
+	owns data,
+	owns data-type,
+	plays reg-val:reg-value;
+
+# 6.18 X.509 Certificate
+x509-certificate sub stix-cyber-observable-object, 
+	owns is-self-signed, 
+	plays hashes:owner, 
+	owns version,
+	owns serial-number,
+	owns signature-algorithm,
+	owns issuer,
+	owns validity-not-before,
+	owns validity-not-after,
+	owns subject,
+	owns subject-public-key-algorithm,
+	owns subject-public-key-modulus,
+	owns subject-public-key-exponent,
+	plays v3-extensions:cert;
+
+	x509-v3-extension sub SCO-extension,
+		owns basic-constraints,
+		owns name-constraints,
+		owns policy-constraints,
+		owns key-usage,
+		owns extended-key-usage,
+		owns subject-key-identifier,
+		owns authority-key-identifier,
+		owns subject-alternative-name,
+		owns issuer-alternative-name,
+		owns subject-directory-attributes,
+		owns crl-distribution-points,
+		owns inhibit-any-policy,
+		owns private-key-usage-period-not-before,
+		owns private-key-usage-period-not-after,
+		owns certificate-policies,
+		owns policy-mappings,
+		plays v3-extensions:v3-extension;
+
+	
+
+##### 7 STIX Meta Objects #####
+
+
+# 7.1 Language Content 
+
+# owns spec-version
+
+# 7.2 Data markings - this describes how data can be used/shared
+
+marking-definition sub stix-object,
+    owns created,
+    owns modified,
+	owns name, 
+	owns spec-version,
+	plays created-by:created,
+	plays data-marking:marking,
+	plays object-marking:marked,
+	plays external-references:referencing;
+
+	statement-marking sub marking-definition, 
+		owns statement; 
+
+	tlp-marking sub marking-definition;
+		tlp-white sub tlp-marking;
+		tlp-green sub tlp-marking;
+		tlp-amber sub tlp-marking;
+		tlp-red sub tlp-marking;
+
+
+
+# 7.3 Extension Definition
+#-----------------------------------------------------------------------------------------------------------------------
+#
+# Extra Pieces
+#-----------------------------------------------------------------------------------------------------------------------
+
+##### Embedded Relations #####
+
+embedded sub relation,
+	relates pointed-to, # the object being pointed to
+	relates owner; # the current object
+
+	data-marking sub embedded, 
+		relates marking as pointed-to,
+		relates marked as owner;
+
+		object-marking sub data-marking; 
+
+		granular-marking sub data-marking,
+			relates object;
+
+	created-by sub embedded, 
+		relates created as owner,
+		relates creator as pointed-to;
+
+	sample sub embedded, 
+		relates sample-for as owner, 
+		relates sco-sample as pointed-to;
+
+		malware-sample sub sample;
+		malware-analysis-sample sub sample;
+
+	kill-chain-usage sub embedded,
+		relates kill-chain-used as owner,
+		relates kill-chain-using as pointed-to;
+		
+
+	external-references sub embedded, 
+		relates referenced as owner,
+		relates referencing as pointed-to;
+
+	hashes sub embedded;
+
+	malware-env sub embedded,
+		relates object as owner,
+		relates env as pointed-to;
+
+		operating-system sub malware-env;   # operating_system_ref
+		installed-software sub malware-env; # installed_software_refs
+		host-vm-ref sub malware-env;            # host_vm_ref 
+		captured-objects sub malware-env;   # analysis_sco_refs 
+
+	obj-refs sub embedded, 
+		relates referred as pointed-to,
+		relates object as owner;
+
+	# file or directory containing relation
+	orig-container sub embedded,
+		relates container as owner,
+		relates contained as pointed-to;
+
+		directory-contains sub orig-container;
+		# network traffic enxapsulate
+		encapsulate sub orig-container;
+
+	
+	# reverse file or directory containing relation
+	orig-contained sub embedded,
+		relates contained as owner,
+		relates container as pointed-to;
+		
+		directory-parent sub orig-contained;
+		# network-traffic encapsulated-by
+		encapsulated sub orig-contained;
+
+	# IP Address or Domain Name
+	resolves-to-ref sub embedded,
+		relates from-ref as owner,
+		relates to-ref as pointed-to;
+
+	# User Account email address belongs to
+	belongs sub embedded,
+		relates belonged as owner,
+		relates belongs-to as pointed-to;
+
+	# IP belongs to autonomous system
+	belongs-to-autonomous sub belongs;
+
+	# Email specific relations
+	body-multipart sub embedded, 
+		relates email as owner,
+		relates mime-part as pointed-to;
+ 
+	raw-email-references sub embedded, 
+		relates email as owner,
+		relates binary as pointed-to;
+
+	
+	email-connection sub embedded, 
+		relates email as owner,
+		relates email-address as pointed-to;
+
+		from-email sub email-connection;
+		sender-email sub email-connection;
+		to-email sub email-connection;
+		cc-email sub email-connection;
+		bcc-email sub email-connection;
+	
+	additional-header sub embedded,
+		relates email as owner,
+		relates item as pointed-to;
+
+	body-raw-references sub embedded,
+		relates containing-mime as owner,
+		relates non-textual as pointed-to;
+
+	# file relation
+	content-file sub embedded, 
+		relates containing-file as owner,
+		relates content as pointed-to;
+
+	# network-traffic SCO,
+	traffic-src sub embedded, 
+		relates traffic as owner,
+		relates source as pointed-to;
+
+		payload-src sub traffic-src,
+			relates payload as source;
+
+	traffic-dst sub embedded, 
+		relates traffic as owner,
+		relates destination as pointed-to;
+
+		payload-dst sub traffic-dst,
+			relates payload as destination;
+
+	IPFIX-store sub embedded, 
+		relates traffic as owner,
+		relates item as pointed-to;
+
+	# HTTP Request Extension
+	HTTP_Req_Headers sub embedded, 
+		relates traffic as owner,
+		relates item as pointed-to;	
+
+	# Process Object
+	environment-variables sub embedded, 
+		relates process as owner,
+		relates env-variable as pointed-to;
+
+	
+	open-connections sub embedded,
+		relates opened-connection as pointed-to,
+		relates process as owner;
+
+	
+	user-created-by sub embedded,
+		relates created as owner,
+		relates creator as pointed-to;
+
+	process-image sub embedded,	
+		relates executed-image as pointed-to,
+		relates process as owner;
+
+	process-parent sub embedded,
+		relates parent as pointed-to,
+		relates process as owner;
+
+	process-child sub embedded,
+		relates child as pointed-to,
+		relates process as owner;
+
+	# Windows Registry Key-Value
+	reg-val sub embedded,
+		relates reg-key as owner,
+		relates reg-value as pointed-to;
+
+	
+
+		
+
+	# Extension-Type Embedded Relations
+	#-----------------------------------------------------------------------------------------------------------------------
+	extensions sub embedded, 
+		relates sco as owner,
+		relates extension as pointed-to;
+
+		archive-extension sub extensions,
+			relates file as sco,
+			relates an-archive as extension;
+
+		ntfs-extension sub extensions,
+			relates file as sco,
+			relates ntfs as extension;
+
+		alt-data-streams sub extensions,
+			relates ntfs-ext as sco,
+			relates alt-data-stream as extension;
+
+		pdf-extension sub extensions,
+			relates file as sco,
+			relates pdf as extension;
+
+		doc-info sub extensions,
+			relates pdf as sco,
+			relates info as extension;
+
+		raster-image-extension sub extensions,
+			relates file as sco,
+			relates image as extension;
+			
+		EXIF-tags sub extensions,
+			relates image as sco,
+			relates info as extension;
+
+		windows-pebinary-extension sub extensions,
+			relates file as sco,
+			relates pebinary as extension;
+		
+		optional-headers sub extensions, 
+			relates pebinary as sco,
+			relates optional-header as extension;
+
+		
+		sections sub extensions, 
+			relates pe-section as extension,
+			relates pebinary as sco;
+
+		# HTTP Request Extension
+		http-request-extension sub extensions,
+			relates traffic as sco,
+			relates request as extension;
+
+		HTTP-header sub extensions, 
+			relates request as sco,
+			relates header as extension;
+
+		HTTP-body-data sub extensions,
+			relates contained-data as extension,
+			relates HTPP-message as sco;
+
+		icmp-extension sub extensions,
+			relates traffic as sco,
+			relates icmp as extension;
+
+		# Socket Extension
+		socket-extension sub extensions,
+			relates traffic as sco,
+			relates socket as extension;
+
+		socket-options sub extensions, 
+			relates socket as sco,
+			relates option as extension;
+
+		tcp-extension sub extensions,
+			relates traffic as sco,
+			relates tcp as extension;
+
+		# windows process Extension
+		windows-process-extension sub extensions,
+			relates process as sco,
+			relates win-process as extension;
+		
+		startup-info sub extensions, 
+			relates process as sco,
+			relates info as extension;
+
+		# windows service extension		
+		windows-service-extension sub extensions,
+			relates process as sco,
+			relates win-service as extension;
+
+		service-dll sub extensions, 
+			relates loaded-dll as extension,
+			relates process as sco;
+
+		# unix account extension
+		unix-account-extension sub extensions,
+			relates account as sco,
+			relates unix as extension;
+
+		# windows registry extension
+		v3-extensions sub extensions,
+			relates cert as sco,
+			relates v3-extension as extension;
+
+
+
+
+
+
+
+
+# 3.7 Common Relationships 
+# These are relation types that are shared by SDOs and SCOs
+
+derivation sub relation, 
+	relates derived-from,
+	relates deriving;
+
+duplicate sub relation, 
+	relates duplicated-object; 
+
+relatedness sub relation,
+	relates related-to; 
+
+## INFERRED RELATIONS ## 
+
+kill-chain sub relation, 
+	owns kill-chain-name, 
+	relates participating-kill-chain-phase; 
+
+inferred-mitigation sub mitigates;
+
+
+##### ATTRIBUTES #####
+
+stix-attribute-string sub attribute, value string, abstract,
+	plays granular-marking:marked;
+
+	stix-type sub stix-attribute-string;
+	stix-id sub stix-attribute-string;
+	stix-value sub stix-attribute-string;
+	object-marking-refs sub stix-attribute-string;
+	labels sub stix-attribute-string;
+	langs sub stix-attribute-string;
+	source-name sub stix-attribute-string;
+	description sub stix-attribute-string;
+	url-link sub stix-attribute-string;
+	external-id sub stix-attribute-string;
+	hash-value sub stix-attribute-string;
+
+	kill-chain-name sub stix-attribute-string; 
+	phase-name sub stix-attribute-string; 
+	name sub stix-attribute-string; 
+	sector sub stix-attribute-string; 
+	contact-information sub stix-attribute-string; 
+	indicator-type sub stix-attribute-string; 
+	pattern sub stix-attribute-string; 
+	pattern-type sub stix-attribute-string; 
+	pattern-version sub stix-attribute-string; 
+	
+
+	malware-types sub stix-attribute-string; 
+	architecture-execution-envs sub stix-attribute-string; 
+	implementation-languages sub stix-attribute-string; 
+	capabilities sub stix-attribute-string; 
+	sample-refs sub stix-attribute-string; 
+
+	 
+	object sub stix-attribute-string; 
+
+	threat-actor-type sub stix-attribute-string; 
+	aliases sub stix-attribute-string; 
+	stix-role sub stix-attribute-string; 
+	goals sub stix-attribute-string; 
+	sophistication sub stix-attribute-string; 
+	resource-level sub stix-attribute-string; 
+	primary-motivation sub stix-attribute-string; 
+	secondary-motivations sub stix-attribute-string; 
+	personal-motivations sub stix-attribute-string; 
+	identity-class sub stix-attribute-string;
+
+	summary sub stix-attribute-string; 
+	spec-version sub stix-attribute-string; 
+	attribute-key sub stix-attribute-string; 
+#	value sub stix-attribute-string;
+	number-subkeys sub stix-attribute-string; 
+	objective sub stix-attribute-string;
+	statement sub stix-attribute-string;
+	action sub stix-attribute-string;  
+	tool-type sub stix-attribute-string; # OPEN VOCAB?
+	tool-version sub stix-attribute-string; 
+
+	region sub stix-attribute-string; # open vocab TODO (10.21 Region Vocabulary)
+	country sub stix-attribute-string; 
+	administrative-area sub stix-attribute-string; 
+	city sub stix-attribute-string; 
+	street-address sub stix-attribute-string; 
+	postal-code sub stix-attribute-string; 
+	infrastructure-types sub stix-attribute-string;
+	context sub stix-attribute-string;
+
+	product sub stix-attribute-string;
+	version sub stix-attribute-string;
+	configuration-version sub stix-attribute-string;
+	module sub stix-attribute-string;
+	analysis-engine-version sub stix-attribute-string;
+	analysis-definition-version sub stix-attribute-string;
+	result-name sub stix-attribute-string;
+	result sub stix-attribute-string;
+
+	note-abstract sub stix-attribute-string;
+	content sub stix-attribute-string;
+	report-type sub stix-attribute-string;
+	explanation sub stix-attribute-string;
+	authors sub stix-attribute-string;
+	opinion-enum sub stix-attribute-string;
+	imphash sub stix-attribute-string;
+	magic-number-hex sub stix-attribute-string;
+	pe-type sub stix-attribute-string;
+	name-enc sub stix-attribute-string;
+	mime-type sub stix-attribute-string;
+	payload-bin sub stix-attribute-string;
+	encryption-algorithm sub stix-attribute-string;
+	decryption-key sub stix-attribute-string;
+	rir sub stix-attribute-string;
+	path sub stix-attribute-string;
+	path-enc sub stix-attribute-string;
+
+	display-name sub stix-attribute-string;
+	content-type sub stix-attribute-string;
+	message-id sub stix-attribute-string;
+	subject sub stix-attribute-string;
+	received-lines sub stix-attribute-string;
+	body sub stix-attribute-string;
+
+	socket-value sub stix-attribute-string;
+	socket-key sub stix-attribute-string;
+	HTTP-value sub stix-attribute-string;
+	HTTP-key sub stix-attribute-string;
+	IPFIX-value sub stix-attribute-string;
+	IPFIX-key sub stix-attribute-string;
+	relationship-type sub stix-attribute-string;
+	
+
+	content-disposition sub stix-attribute-string;
+	sid sub stix-attribute-string;
+	is-optimized sub stix-attribute-string;
+	pdfid0 sub stix-attribute-string;
+	pdfid1 sub stix-attribute-string;
+	exif-tags sub stix-attribute-string;
+
+	machine-hex sub stix-attribute-string;
+	pointer-to-symbol-table-hex sub stix-attribute-string;
+	characteristics-hex sub stix-attribute-string;
+	loader-flags-hex sub stix-attribute-string;
+	dll-characteristics-hex sub stix-attribute-string;
+	win32-version-value-hex sub stix-attribute-string;
+	magic-hex sub stix-attribute-string;
+	protocols sub stix-attribute-string;
+	ipfix sub stix-attribute-string;
+
+	icmp-type-hex sub stix-attribute-string;
+	icmp-code-hex sub stix-attribute-string;
+	request-method sub stix-attribute-string;
+	request-value sub stix-attribute-string;
+	request-version sub stix-attribute-string;
+	request-header sub stix-attribute-string;
+	address-family sub stix-attribute-string;
+	options sub stix-attribute-string;
+	socket-type sub stix-attribute-string;
+	src-flags-hex sub stix-attribute-string;
+	dst-flags-hex sub stix-attribute-string;
+
+	checksum-hex sub stix-attribute-string;
+	subsystem-hex sub stix-attribute-string;	
+	cwd sub stix-attribute-string;
+	command-line sub stix-attribute-string;
+	priority sub stix-attribute-string;
+	owner-sid sub stix-attribute-string;
+	window-title sub stix-attribute-string;
+	integrity-level sub stix-attribute-string;
+	service-name sub stix-attribute-string;
+	display-name sub stix-attribute-string;
+	group-name sub stix-attribute-string;
+	start-type sub stix-attribute-string;
+	service-type sub stix-attribute-string;
+	service-status sub stix-attribute-string;
+
+	cpe sub stix-attribute-string;
+	swid sub stix-attribute-string;
+	language sub stix-attribute-string;
+	vendor sub stix-attribute-string;
+	user-id sub stix-attribute-string;
+	credential sub stix-attribute-string;
+	account-login sub stix-attribute-string;
+	account-type sub stix-attribute-string;
+	display-name sub stix-attribute-string;
+
+	unix-group sub stix-attribute-string;
+	home-dir sub stix-attribute-string;
+	shell sub stix-attribute-string;
+	data-type sub stix-attribute-string;
+	serial-number sub stix-attribute-string;
+	signature-algorithm sub stix-attribute-string;
+	issuer sub stix-attribute-string;
+	subject-public-key-algorithm sub stix-attribute-string;
+	subject-public-key-modulus sub stix-attribute-string;
+
+	basic-constraints sub stix-attribute-string;
+	name-constraints sub stix-attribute-string;
+	policy-constraints sub stix-attribute-string;
+	key-usage sub stix-attribute-string;
+	extended-key-usage sub stix-attribute-string;
+	subject-key-identifier sub stix-attribute-string;
+	authority-key-identifier sub stix-attribute-string;
+	subject-alternative-name sub stix-attribute-string;
+	issuer-alternative-name sub stix-attribute-string;
+	subject-directory-attributes sub stix-attribute-string;
+	crl-distribution-points sub stix-attribute-string;
+	inhibit-any-policy sub stix-attribute-string;
+	certificate-policies sub stix-attribute-string;
+	policy-mappings sub stix-attribute-string;
+	data sub stix-attribute-string;
+	comment sub stix-attribute-string;
+
+stix-attribute-integer sub attribute, value long, abstract,
+	plays granular-marking:marked;
+
+	gid sub stix-attribute-integer;
+	image-height sub stix-attribute-integer;
+	image-width sub stix-attribute-integer;
+	bits-per-pixel sub stix-attribute-integer;
+	confidence sub stix-attribute-integer;
+
+	number-of-sections sub stix-attribute-integer;
+	number-of-symbols sub stix-attribute-integer;
+	size-of-optional-header sub stix-attribute-integer;
+	
+	major-linker-version sub stix-attribute-integer;
+	minor-linker-version sub stix-attribute-integer;
+	size-of-code sub stix-attribute-integer;
+	size-of-initialized-data sub stix-attribute-integer;
+	size-of-uninitialized-data sub stix-attribute-integer;
+	address-of-entry-point sub stix-attribute-integer;
+	base-of-code sub stix-attribute-integer;
+	base-of-data sub stix-attribute-integer;
+	image-base sub stix-attribute-integer;
+	section-alignment sub stix-attribute-integer;
+	file-alignment sub stix-attribute-integer;
+	major-os-version sub stix-attribute-integer;
+	minor-os-version sub stix-attribute-integer;
+	major-image-version sub stix-attribute-integer;
+	minor-image-version sub stix-attribute-integer;
+	major-subsystem-version sub stix-attribute-integer;
+	minor-subsystem-version sub stix-attribute-integer;
+	size-of-image sub stix-attribute-integer;
+	size-of-headers sub stix-attribute-integer;
+	size-of-stack-reserve sub stix-attribute-integer;
+	size-of-stack-commit sub stix-attribute-integer;
+	size-of-heap-reserve sub stix-attribute-integer;
+	size-of-heap-commit sub stix-attribute-integer;
+	number-of-rva-and-sizes sub stix-attribute-integer;
+	number-observed sub stix-attribute-integer;
+	size sub stix-attribute-integer; 
+
+	src-port sub stix-attribute-integer; 
+	dst-port sub stix-attribute-integer; 
+	src-byte-count sub stix-attribute-integer; 
+	dst-byte-count sub stix-attribute-integer; 
+	src-packets sub stix-attribute-integer; 
+	dst-packets sub stix-attribute-integer; 
+	
+	
+
+stix-attribute-double sub attribute, value double, abstract,
+	plays granular-marking:marked;		
+
+	latitude sub stix-attribute-double;
+	longitude sub stix-attribute-double;
+	precision sub stix-attribute-double;
+	
+	sighting-count sub stix-attribute-double;
+	number sub stix-attribute-double;
+	
+	entropy sub stix-attribute-double;
+	message-body-length sub stix-attribute-double;
+	socket-descriptor sub stix-attribute-double;
+	socket-handle sub stix-attribute-double;
+	pid sub stix-attribute-double;
+	subject-public-key-exponent sub stix-attribute-double;
+
+stix-attribute-boolean sub attribute, value boolean, abstract, 
+	plays granular-marking:marked;
+
+	revoked sub stix-attribute-boolean;
+	is-family sub stix-attribute-boolean;
+	is-multipart sub stix-attribute-boolean;
+	is-active sub stix-attribute-boolean;
+	is-blocking sub stix-attribute-boolean;
+	is-listening sub stix-attribute-boolean;
+	is-hidden sub stix-attribute-boolean;
+	aslr-enabled sub stix-attribute-boolean;
+	dep-enabled sub stix-attribute-boolean;
+	is-service-account sub stix-attribute-boolean;
+	is-privileged sub stix-attribute-boolean;
+	can-escalate-privs sub stix-attribute-boolean;
+	is-disabled sub stix-attribute-boolean;
+	is-self-signed sub stix-attribute-boolean;
+	defanged sub stix-attribute-boolean;
+	
+
+stix-attribute-timestamp sub attribute, value datetime, abstract, 
+	plays granular-marking:marked;
+
+	date sub stix-attribute-timestamp;
+	submitted sub stix-attribute-timestamp;
+	analysis-started sub stix-attribute-timestamp;
+	analysis-ended sub stix-attribute-timestamp;
+	published sub stix-attribute-timestamp;
+	ctime sub stix-attribute-timestamp;
+	mtime sub stix-attribute-timestamp;
+	atime sub stix-attribute-timestamp;
+	time-date-stamp sub stix-attribute-timestamp;
+	start sub stix-attribute-timestamp;
+	end sub stix-attribute-timestamp;
+	created-time sub stix-attribute-timestamp;
+	account-created sub stix-attribute-timestamp;
+	account-expires sub stix-attribute-timestamp;
+	credential-last-changed sub stix-attribute-timestamp;
+	account-first-login sub stix-attribute-timestamp;
+	account-last-login sub stix-attribute-timestamp;
+	validity-not-before sub stix-attribute-timestamp;
+	validity-not-after sub stix-attribute-timestamp;
+	private-key-usage-period-not-before sub stix-attribute-timestamp;
+	private-key-usage-period-not-after sub stix-attribute-timestamp;
+	start-time sub stix-attribute-timestamp;
+	stop-time sub stix-attribute-timestamp;
+	created sub stix-attribute-timestamp;
+	modified sub stix-attribute-timestamp;
+	valid-from sub stix-attribute-timestamp; 
+	valid-until sub stix-attribute-timestamp; 
+	
+	modified-time sub stix-attribute-timestamp; 
+	first-seen sub stix-attribute-timestamp; 
+	last-seen sub stix-attribute-timestamp; 
+	first-observed sub stix-attribute-timestamp; 
+	last-observed sub stix-attribute-timestamp;
+	
+
+custom-attribute sub attribute, value string, 
+	plays granular-marking:marked,
+	owns attribute-type; 
+
+attribute-type sub attribute, value string;
```

### Comparing `stixorm-0.1.3/stixorm/module/definitions/stix21/sub_objects/windows-pe-optional-header-type.json` & `stixorm-0.1.9/stixorm/module/definitions/stix21/sub_objects/windows-pe-optional-header-type.json`

 * *Files identical despite different names*

### Comparing `stixorm-0.1.3/stixorm/module/definitions/us_dod/mappings/is_list_sub_objects.json` & `stixorm-0.1.9/stixorm/module/definitions/us_dod/mappings/is_list_sub_objects.json`

 * *Files identical despite different names*

### Comparing `stixorm-0.1.3/stixorm/module/generate_docs.py` & `stixorm-0.1.9/stixorm/module/generate_docs.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,381 +1,381 @@
-import csv
-import logging
-import os
-import glob
-import csv
-import json
-
-from stixorm.module.typedb_lib.factories.definition_factory import get_definition_factory_instance
-from stixorm.module.typedb_lib.model.definitions import DefinitionName
-logger = logging.getLogger(__name__)
-stix_models = get_definition_factory_instance().lookup_definition(DefinitionName.STIX_21)
-attack_models = get_definition_factory_instance().lookup_definition(DefinitionName.ATTACK)
-
-heading_align = [
-    ":--------------------|",
-    ":--------------------------------:|",
-    ":------------------:|",
-    ":------------------------:|",
-    ":-------------:|"
-]
-
-object_docs = [
-    {
-        "dir": "sdo",
-        "protocol": "stix21",
-        "file": "sdo.csv",
-        "obj_type": "Domain"
-    },
-    {
-        "dir": "sco",
-        "protocol": "stix21",
-        "file": "sco.csv",
-        "obj_type": "Cyber Obervable"
-    }
-]
-
-
-object_tables = [
-    {
-        "title": "OASIS Stix 2.1",
-        "protocol": "stix21",
-        "objects": stix_models.get_mapping("object_conversion")
-    },
-    {
-        "title": "Mitre ATT&CK",
-        "protocol": "attack",
-        "objects": attack_models.get_mapping("object_conversion")
-    }
-]
-protocols = [
-    "stix21",
-    "attack"
-]
-
-titles = {
-    "stix21": "OASIS Stix 2.1",
-    "attack": "MITRE ATT&CK",
-    "os-threat": "OS-Threat Custom",
-    "sdo": "Domain Object's Types",
-    "sco": "Cyber Observable Object Types",
-    "sro": "Relationship Object Types",
-    "sub": "Sub-Object Types"
-}
-object_types = [
-    "sdo",
-    "sco",
-    "sro",
-    "sub"
-]
-
-def gen_tables(obj_tables):
-    bucket = {}
-    bucket["stix21"] = {}
-    bucket["attack"] = {}
-    bucket["stix21"]["sdo"] = []
-    bucket["stix21"]["sro"] = []
-    bucket["stix21"]["sco"] = []
-    bucket["stix21"]["sub"] = []
-    bucket["attack"]["sdo"] = []
-    bucket["attack"]["sro"] = []
-    bucket["attack"]["sco"] = []
-    bucket["attack"]["sub"] = []
-    for table in obj_tables:
-        obj_set = table["objects"]
-        protocol = table["protocol"]
-        layer = {}
-        for obj in obj_set:
-            obj_type = obj["object"]
-            bucket[protocol][obj_type].append(obj)
-
-    return bucket
-
-
-def print_normal_rows(rel_dir, size, outfile, bucket_list, icon_dir, md_dir):
-    for obj in bucket_list:
-        detail_string = ""
-        icon = obj["icon"]
-        name = obj["typeql"]
-        docs = obj["doc_url"]
-        summary = obj["summary"]
-        #logger.info(f"---- summary -> {summary}")
-        logger.info(f"icon dir -> {icon_dir}, md dir {md_dir}")
-        if icon == "":
-            icon_name = ""
-            icon_dir_name = ""
-        else:
-            icon_name = name
-            icon_dir_name = icon_dir + icon
-        if docs == "":
-            name_dir = ""
-        else:
-            name_dir = md_dir + docs
-
-        icon_md = "![" + icon_name + "](" + icon_dir_name + ")"
-        name_md = "[" + name + "](" + name_dir + ")"
-        detail_string += "| " + icon_md + " | " + name_md + " | " + summary + " |"
-        logger.info(detail_string, file=outfile)
-
-
-def print_summary_rows(rel_dir, size, outfile, bucket_list, icon_dir, md_dir):
-    num_objs = len(bucket_list)
-    rows = num_objs // size
-    remainder = num_objs % size
-    rel_path = "protocols/"
-    k = 0
-    if remainder != 0:
-        rows += 1
-        filler = size - remainder
-    for j in range(rows):
-        detail_string = ""
-        for i in range(size):
-            icon = ""
-            name = ""
-            docs = ""
-            if k < num_objs:
-                layer = bucket_list[k]
-                icon = layer["icon"]
-                name = layer["typeql"]
-                docs = layer["doc_url"]
-
-            if icon == "":
-                icon_name = ""
-                icon_dir_name = ""
-            else:
-                icon_name = name
-                icon_dir_name = icon_dir + icon
-            if docs == "":
-                name_dir = ""
-            else:
-                name_dir = md_dir + docs
-            icon_md = "![" + icon_name + "](" + icon_dir_name + ")"
-            name_md = "[" + name + "](" + name_dir + ")"
-            detail_string += "| " + icon_md + " | " + name_md
-            k += 1
-
-        detail_string += " |"
-        logger.info(detail_string, file=outfile)
-
-
-def print_summary_tables(rel_dir, outfile, protocol, bucket, size):
-    logger.info("In summary tables")
-    logger.info(f"reldir 1-> {rel_dir}")
-
-    # Setup Table Headers
-    if rel_dir == "./docs":
-        rel_dir = "./protocols"
-    elif rel_dir == "./docs/protocols":
-        rel_dir = "."
-    elif rel_dir == "./docs/protocols/stix21":
-        rel_dir = "."
-    sub_head = ""
-    logger.info(f"reldir 2-> {rel_dir}")
-    head_string = ""
-    under_string = ""
-    row_string = ""
-    for i in range(size):
-        head_string += "| Icon | Object Type "
-        under_string += "|:----------:|:-----------"
-    if size == 1:
-        head_string = "| Icon | Object Type | Description"
-        under_string = "|:----------:|:-----------|:-----------"
-    head_string += " |"
-    under_string += " |"
-    logger.info(f"I am ready to process summary tables, size {size}")
-    logger.info(f"object types {object_types}")
-    for obj_type in object_types:
-        logger.info(f"\n###  {titles[obj_type]}\n", file=outfile)
-        logger.info(f'obj type {obj_type}, protocol {protocol}, protocols {protocols}')
-        if protocol == "all":
-            for proto in protocols:
-                local_bucket = bucket[proto][obj_type]
-                logger.info(f'local bucket length is -> {len(local_bucket)}')
-                if len(local_bucket) != 0:
-                    md_dir = rel_dir + "/" + proto + "/" + obj_type + "/"
-                    icon_dir = rel_dir + "/" + proto + "/icons/"
-                    logger.info(f"#### {titles[proto]} \n", file=outfile)
-                    logger.info(head_string, file=outfile)
-                    logger.info(under_string, file=outfile)
-                    if size == 1:
-                        logger.info("go down the size==1 route and protocol !=1")
-                        print_normal_rows(rel_dir, size, outfile, bucket[proto][obj_type], icon_dir, md_dir)
-                    else:
-                        logger.info("go down the size!=1 and protocol !=1 route")
-                        print_summary_rows(rel_dir, size, outfile, bucket[proto][obj_type], icon_dir, md_dir)
-                    logger.info("\n\n", file=outfile)
-        else:
-            local_bucket = bucket[protocol][obj_type]
-            if len(local_bucket) != 0:
-                md_dir = rel_dir + "/" + obj_type + "/"
-                icon_dir = rel_dir + "/icons/"
-                logger.info(f"#### {titles[protocol]} \n", file=outfile)
-                logger.info(head_string, file=outfile)
-                logger.info(under_string, file=outfile)
-                if size == 1:
-                    logger.info("go down the size==1 route")
-                    print_normal_rows(rel_dir, size, outfile, bucket[protocol][obj_type], icon_dir, md_dir)
-                else:
-                    logger.info("go down the size!=1 route")
-                    print_summary_rows(rel_dir, size, outfile, bucket[protocol][obj_type], icon_dir, md_dir)
-                logger.info("\n\n", file=outfile)
-
-
-def gen_overview_doc(rel_dir, bucket, protocol, size):
-    logger.info("generate overview")
-    # open up generic overview doc
-    md_name = rel_dir + "/" + "overview.md"
-    or_mname = rel_dir + "/" + "_orig.md"
-    if os.path.exists(md_name):
-        os.remove(md_name)
-    outfile = open(md_name, "w")
-    # insert the top part of the file
-    origfile = open(or_mname, "r")
-    lines = origfile.readlines()
-    for line in lines:
-        logger.info(line, file=outfile)
-    # now generate overview table
-    logger.info("## Total Objects in the System\n\n", file=outfile)
-    try:
-        print_summary_tables(rel_dir, outfile, protocol, bucket, size)
-    except:
-        logger.info("ERROR IN OBJECT Table GENERATION")
-    # close the overview markdown file
-    outfile.close()
-
-
-def configure_overview_table_docs(obj_tables):
-    logger.info("starting to process the list of objects")
-    bucket = gen_tables(obj_tables)
-    # Setup Library Overview Document
-    rel_dir = "./docs"
-    gen_overview_doc(rel_dir, bucket, "all", 3)
-    # Setup Protocol Overview Document
-    rel_dir = "./docs/protocols"
-    gen_overview_doc(rel_dir, bucket, "all", 1)
-    # Setup Library Overview Document
-    rel_dir = "./docs/protocols/stix21"
-    gen_overview_doc(rel_dir, bucket, "stix21", 1)
-
-
-
-def delete_existing_markdown(dir):
-    cwd = os.getcwd()
-    del_dir = cwd + "\\" + dir
-    del_pattern = del_dir + "\\" + "*.md"
-    fileList = glob.glob(del_pattern)
-    logger.info(f'delete fileList is {fileList}')
-    for filePath in fileList:
-        try:
-            os.remove(filePath)
-        except:
-            logger.info("Error while deleting file : " ,filePath)
-    return del_dir
-
-
-def generate_object_doc(dir, fields, row, obj_type):
-    image = row[0]
-    table = row[1]
-    stix_type = row[2]
-    obj = row[3]
-    para1 = row[4]
-    para2 = row[5]
-    url = row[6]
-    json_example = row[7]
-    tql_ins = row[8]
-    tql_match = row[9]
-    py_match = row[10]
-    md_name = dir + "\\" + obj + ".md"
-    outfile = open(md_name, "w")
-    # 1. Setup Page title
-    logger.info(f'# {obj} {obj_type} Object\n', file=outfile)
-    logger.info(f'**Stix and TypeQL Object Type:**  `{stix_type}`\n', file=outfile)
-    # 2. Setup Overview paragraphs
-    logger.info(f'{para1}\n', file=outfile)
-    if para2 != "":
-        logger.info(f'{para2}\n', file=outfile)
-    logger.info(f'[Reference in Stix2.1 Standard]({url})', file=outfile)
-    # 3. Setup Table
-    logger.info(f'## Stix 2.1 Properties Converted to TypeQL', file=outfile)
-    logger.info(f'Mapping of the Stix Attack Pattern Properties to TypeDB\n', file=outfile)
-    table_name = dir + "\\csv\\" + table
-    rows = []
-    with open(table_name, 'r') as csvfile:
-        # creating a csv reader object
-        csvreader = csv.reader(csvfile)
-
-        # extracting field names through first row
-        field_list = next(csvreader)
-        fields = "| "
-        for field in field_list:
-            fields += field + " |"
-        heading = "|"
-        for head in heading_align:
-            heading += head
-        logger.info(f'{fields}', file=outfile)
-        logger.info(f'{heading}', file=outfile)
-        # extracting each data row one by one
-        for row in csvreader:
-            cols = "| "
-            for col in row:
-                cols += col + " |"
-            logger.info(f'{cols}', file=outfile)
-    # 4. Setup JSON Section
-    logger.info(f'\n## The Example {obj} in JSON', file=outfile)
-    logger.info(f'The original JSON, accessible in the Python environment', file=outfile)
-    logger.info(f'```json\n{json_example}\n```\n', file=outfile)
-    # 5. Setup TypeQL Insert Section
-    logger.info(f'\n## Inserting the Example {obj} in TypeQL', file=outfile)
-    logger.info(f'The TypeQL insert statement', file=outfile)
-    logger.info(f'```typeql\n{tql_ins}\n```\n', file=outfile)
-    # 6. Setup TypeQL Match Section
-    logger.info(f'## Retrieving the Example {obj} in TypeQL', file=outfile)
-    logger.info(f'The typeQL match statement\n', file=outfile)
-    logger.info(f'```typeql\n{tql_match}\n```\n', file=outfile)
-    # 7. Setup Force Graph Image Section
-    logger.info(f'\nwill retrieve the example attack-pattern object in Vaticle Studio', file=outfile)
-    imagefile = "./img/"+image
-    logger.info(f'![{obj} Example]({imagefile})', file=outfile)
-    # 8. Setup Python Match Section
-    logger.info(f'\n## Retrieving the Example {obj}  in Python', file=outfile)
-    logger.info(f'The Python retrieval statement\n', file=outfile)
-    logger.info(f'```python\n{py_match}\n```\n', file=outfile)
-    # 9. Close the File
-    outfile.close()
-    return
-
-
-def gen_obj_docs(docs):
-    # generate object docs
-    for doc_set in docs:
-        # Get details for each set of documents
-        sub_dir = doc_set["dir"]
-        doc_file = doc_set["file"]
-        obj_type = doc_set["obj_type"]
-        prot_type = doc_set["protocol"]
-        # delete existing markdown documents
-        rel_path = "protocols/" +prot_type +"/" + sub_dir
-        full_doc_dir = delete_existing_markdown(rel_path)
-        # generate new markdown docs in the target directory
-        if full_doc_dir != "":
-            file_path = full_doc_dir + "/" + doc_file
-            rows=[]
-            with open(file_path, 'r') as csvfile:
-                # creating a csv reader object
-                csvreader = csv.reader(csvfile)
-
-                # extracting field names through first row
-                fields = next(csvreader)
-
-                # extracting each data row one by one
-                for row in csvreader:
-                    generate_object_doc(full_doc_dir, fields, row, obj_type)
-                    rows.append(row)
-
-                # get total number of rows
-                logger.info("Total no. of rows: %d" % (csvreader.line_num))
-
-
-# if this file is run directly, then start here
-if __name__ == '__main__':
-    #gen_obj_docs(object_docs)
-    configure_overview_table_docs(object_tables)
+import csv
+import logging
+import os
+import glob
+import csv
+import json
+
+from stixorm.module.typedb_lib.factories.definition_factory import get_definition_factory_instance
+from stixorm.module.typedb_lib.model.definitions import DefinitionName
+logger = logging.getLogger(__name__)
+stix_models = get_definition_factory_instance().lookup_definition(DefinitionName.STIX_21)
+attack_models = get_definition_factory_instance().lookup_definition(DefinitionName.ATTACK)
+
+heading_align = [
+    ":--------------------|",
+    ":--------------------------------:|",
+    ":------------------:|",
+    ":------------------------:|",
+    ":-------------:|"
+]
+
+object_docs = [
+    {
+        "dir": "sdo",
+        "protocol": "stix21",
+        "file": "sdo.csv",
+        "obj_type": "Domain"
+    },
+    {
+        "dir": "sco",
+        "protocol": "stix21",
+        "file": "sco.csv",
+        "obj_type": "Cyber Obervable"
+    }
+]
+
+
+object_tables = [
+    {
+        "title": "OASIS Stix 2.1",
+        "protocol": "stix21",
+        "objects": stix_models.get_mapping("object_conversion")
+    },
+    {
+        "title": "Mitre ATT&CK",
+        "protocol": "attack",
+        "objects": attack_models.get_mapping("object_conversion")
+    }
+]
+protocols = [
+    "stix21",
+    "attack"
+]
+
+titles = {
+    "stix21": "OASIS Stix 2.1",
+    "attack": "MITRE ATT&CK",
+    "os-threat": "OS-Threat Custom",
+    "sdo": "Domain Object's Types",
+    "sco": "Cyber Observable Object Types",
+    "sro": "Relationship Object Types",
+    "sub": "Sub-Object Types"
+}
+object_types = [
+    "sdo",
+    "sco",
+    "sro",
+    "sub"
+]
+
+def gen_tables(obj_tables):
+    bucket = {}
+    bucket["stix21"] = {}
+    bucket["attack"] = {}
+    bucket["stix21"]["sdo"] = []
+    bucket["stix21"]["sro"] = []
+    bucket["stix21"]["sco"] = []
+    bucket["stix21"]["sub"] = []
+    bucket["attack"]["sdo"] = []
+    bucket["attack"]["sro"] = []
+    bucket["attack"]["sco"] = []
+    bucket["attack"]["sub"] = []
+    for table in obj_tables:
+        obj_set = table["objects"]
+        protocol = table["protocol"]
+        layer = {}
+        for obj in obj_set:
+            obj_type = obj["object"]
+            bucket[protocol][obj_type].append(obj)
+
+    return bucket
+
+
+def print_normal_rows(rel_dir, size, outfile, bucket_list, icon_dir, md_dir):
+    for obj in bucket_list:
+        detail_string = ""
+        icon = obj["icon"]
+        name = obj["typeql"]
+        docs = obj["doc_url"]
+        summary = obj["summary"]
+        #logger.info(f"---- summary -> {summary}")
+        logger.info(f"icon dir -> {icon_dir}, md dir {md_dir}")
+        if icon == "":
+            icon_name = ""
+            icon_dir_name = ""
+        else:
+            icon_name = name
+            icon_dir_name = icon_dir + icon
+        if docs == "":
+            name_dir = ""
+        else:
+            name_dir = md_dir + docs
+
+        icon_md = "![" + icon_name + "](" + icon_dir_name + ")"
+        name_md = "[" + name + "](" + name_dir + ")"
+        detail_string += "| " + icon_md + " | " + name_md + " | " + summary + " |"
+        logger.info(detail_string, file=outfile)
+
+
+def print_summary_rows(rel_dir, size, outfile, bucket_list, icon_dir, md_dir):
+    num_objs = len(bucket_list)
+    rows = num_objs // size
+    remainder = num_objs % size
+    rel_path = "protocols/"
+    k = 0
+    if remainder != 0:
+        rows += 1
+        filler = size - remainder
+    for j in range(rows):
+        detail_string = ""
+        for i in range(size):
+            icon = ""
+            name = ""
+            docs = ""
+            if k < num_objs:
+                layer = bucket_list[k]
+                icon = layer["icon"]
+                name = layer["typeql"]
+                docs = layer["doc_url"]
+
+            if icon == "":
+                icon_name = ""
+                icon_dir_name = ""
+            else:
+                icon_name = name
+                icon_dir_name = icon_dir + icon
+            if docs == "":
+                name_dir = ""
+            else:
+                name_dir = md_dir + docs
+            icon_md = "![" + icon_name + "](" + icon_dir_name + ")"
+            name_md = "[" + name + "](" + name_dir + ")"
+            detail_string += "| " + icon_md + " | " + name_md
+            k += 1
+
+        detail_string += " |"
+        logger.info(detail_string, file=outfile)
+
+
+def print_summary_tables(rel_dir, outfile, protocol, bucket, size):
+    logger.info("In summary tables")
+    logger.info(f"reldir 1-> {rel_dir}")
+
+    # Setup Table Headers
+    if rel_dir == "./docs":
+        rel_dir = "./protocols"
+    elif rel_dir == "./docs/protocols":
+        rel_dir = "."
+    elif rel_dir == "./docs/protocols/stix21":
+        rel_dir = "."
+    sub_head = ""
+    logger.info(f"reldir 2-> {rel_dir}")
+    head_string = ""
+    under_string = ""
+    row_string = ""
+    for i in range(size):
+        head_string += "| Icon | Object Type "
+        under_string += "|:----------:|:-----------"
+    if size == 1:
+        head_string = "| Icon | Object Type | Description"
+        under_string = "|:----------:|:-----------|:-----------"
+    head_string += " |"
+    under_string += " |"
+    logger.info(f"I am ready to process summary tables, size {size}")
+    logger.info(f"object types {object_types}")
+    for obj_type in object_types:
+        logger.info(f"\n###  {titles[obj_type]}\n", file=outfile)
+        logger.info(f'obj type {obj_type}, protocol {protocol}, protocols {protocols}')
+        if protocol == "all":
+            for proto in protocols:
+                local_bucket = bucket[proto][obj_type]
+                logger.info(f'local bucket length is -> {len(local_bucket)}')
+                if len(local_bucket) != 0:
+                    md_dir = rel_dir + "/" + proto + "/" + obj_type + "/"
+                    icon_dir = rel_dir + "/" + proto + "/icons/"
+                    logger.info(f"#### {titles[proto]} \n", file=outfile)
+                    logger.info(head_string, file=outfile)
+                    logger.info(under_string, file=outfile)
+                    if size == 1:
+                        logger.info("go down the size==1 route and protocol !=1")
+                        print_normal_rows(rel_dir, size, outfile, bucket[proto][obj_type], icon_dir, md_dir)
+                    else:
+                        logger.info("go down the size!=1 and protocol !=1 route")
+                        print_summary_rows(rel_dir, size, outfile, bucket[proto][obj_type], icon_dir, md_dir)
+                    logger.info("\n\n", file=outfile)
+        else:
+            local_bucket = bucket[protocol][obj_type]
+            if len(local_bucket) != 0:
+                md_dir = rel_dir + "/" + obj_type + "/"
+                icon_dir = rel_dir + "/icons/"
+                logger.info(f"#### {titles[protocol]} \n", file=outfile)
+                logger.info(head_string, file=outfile)
+                logger.info(under_string, file=outfile)
+                if size == 1:
+                    logger.info("go down the size==1 route")
+                    print_normal_rows(rel_dir, size, outfile, bucket[protocol][obj_type], icon_dir, md_dir)
+                else:
+                    logger.info("go down the size!=1 route")
+                    print_summary_rows(rel_dir, size, outfile, bucket[protocol][obj_type], icon_dir, md_dir)
+                logger.info("\n\n", file=outfile)
+
+
+def gen_overview_doc(rel_dir, bucket, protocol, size):
+    logger.info("generate overview")
+    # open up generic overview doc
+    md_name = rel_dir + "/" + "overview.md"
+    or_mname = rel_dir + "/" + "_orig.md"
+    if os.path.exists(md_name):
+        os.remove(md_name)
+    outfile = open(md_name, "w")
+    # insert the top part of the file
+    origfile = open(or_mname, "r")
+    lines = origfile.readlines()
+    for line in lines:
+        logger.info(line, file=outfile)
+    # now generate overview table
+    logger.info("## Total Objects in the System\n\n", file=outfile)
+    try:
+        print_summary_tables(rel_dir, outfile, protocol, bucket, size)
+    except:
+        logger.info("ERROR IN OBJECT Table GENERATION")
+    # close the overview markdown file
+    outfile.close()
+
+
+def configure_overview_table_docs(obj_tables):
+    logger.info("starting to process the list of objects")
+    bucket = gen_tables(obj_tables)
+    # Setup Library Overview Document
+    rel_dir = "./docs"
+    gen_overview_doc(rel_dir, bucket, "all", 3)
+    # Setup Protocol Overview Document
+    rel_dir = "./docs/protocols"
+    gen_overview_doc(rel_dir, bucket, "all", 1)
+    # Setup Library Overview Document
+    rel_dir = "./docs/protocols/stix21"
+    gen_overview_doc(rel_dir, bucket, "stix21", 1)
+
+
+
+def delete_existing_markdown(dir):
+    cwd = os.getcwd()
+    del_dir = cwd + "\\" + dir
+    del_pattern = del_dir + "\\" + "*.md"
+    fileList = glob.glob(del_pattern)
+    logger.info(f'delete fileList is {fileList}')
+    for filePath in fileList:
+        try:
+            os.remove(filePath)
+        except:
+            logger.info("Error while deleting file : " ,filePath)
+    return del_dir
+
+
+def generate_object_doc(dir, fields, row, obj_type):
+    image = row[0]
+    table = row[1]
+    stix_type = row[2]
+    obj = row[3]
+    para1 = row[4]
+    para2 = row[5]
+    url = row[6]
+    json_example = row[7]
+    tql_ins = row[8]
+    tql_match = row[9]
+    py_match = row[10]
+    md_name = dir + "\\" + obj + ".md"
+    outfile = open(md_name, "w")
+    # 1. Setup Page title
+    logger.info(f'# {obj} {obj_type} Object\n', file=outfile)
+    logger.info(f'**Stix and TypeQL Object Type:**  `{stix_type}`\n', file=outfile)
+    # 2. Setup Overview paragraphs
+    logger.info(f'{para1}\n', file=outfile)
+    if para2 != "":
+        logger.info(f'{para2}\n', file=outfile)
+    logger.info(f'[Reference in Stix2.1 Standard]({url})', file=outfile)
+    # 3. Setup Table
+    logger.info(f'## Stix 2.1 Properties Converted to TypeQL', file=outfile)
+    logger.info(f'Mapping of the Stix Attack Pattern Properties to TypeDB\n', file=outfile)
+    table_name = dir + "\\csv\\" + table
+    rows = []
+    with open(table_name, 'r') as csvfile:
+        # creating a csv reader object
+        csvreader = csv.reader(csvfile)
+
+        # extracting field names through first row
+        field_list = next(csvreader)
+        fields = "| "
+        for field in field_list:
+            fields += field + " |"
+        heading = "|"
+        for head in heading_align:
+            heading += head
+        logger.info(f'{fields}', file=outfile)
+        logger.info(f'{heading}', file=outfile)
+        # extracting each data row one by one
+        for row in csvreader:
+            cols = "| "
+            for col in row:
+                cols += col + " |"
+            logger.info(f'{cols}', file=outfile)
+    # 4. Setup JSON Section
+    logger.info(f'\n## The Example {obj} in JSON', file=outfile)
+    logger.info(f'The original JSON, accessible in the Python environment', file=outfile)
+    logger.info(f'```json\n{json_example}\n```\n', file=outfile)
+    # 5. Setup TypeQL Insert Section
+    logger.info(f'\n## Inserting the Example {obj} in TypeQL', file=outfile)
+    logger.info(f'The TypeQL insert statement', file=outfile)
+    logger.info(f'```typeql\n{tql_ins}\n```\n', file=outfile)
+    # 6. Setup TypeQL Match Section
+    logger.info(f'## Retrieving the Example {obj} in TypeQL', file=outfile)
+    logger.info(f'The typeQL match statement\n', file=outfile)
+    logger.info(f'```typeql\n{tql_match}\n```\n', file=outfile)
+    # 7. Setup Force Graph Image Section
+    logger.info(f'\nwill retrieve the example attack-pattern object in Vaticle Studio', file=outfile)
+    imagefile = "./img/"+image
+    logger.info(f'![{obj} Example]({imagefile})', file=outfile)
+    # 8. Setup Python Match Section
+    logger.info(f'\n## Retrieving the Example {obj}  in Python', file=outfile)
+    logger.info(f'The Python retrieval statement\n', file=outfile)
+    logger.info(f'```python\n{py_match}\n```\n', file=outfile)
+    # 9. Close the File
+    outfile.close()
+    return
+
+
+def gen_obj_docs(docs):
+    # generate object docs
+    for doc_set in docs:
+        # Get details for each set of documents
+        sub_dir = doc_set["dir"]
+        doc_file = doc_set["file"]
+        obj_type = doc_set["obj_type"]
+        prot_type = doc_set["protocol"]
+        # delete existing markdown documents
+        rel_path = "protocols/" +prot_type +"/" + sub_dir
+        full_doc_dir = delete_existing_markdown(rel_path)
+        # generate new markdown docs in the target directory
+        if full_doc_dir != "":
+            file_path = full_doc_dir + "/" + doc_file
+            rows=[]
+            with open(file_path, 'r') as csvfile:
+                # creating a csv reader object
+                csvreader = csv.reader(csvfile)
+
+                # extracting field names through first row
+                fields = next(csvreader)
+
+                # extracting each data row one by one
+                for row in csvreader:
+                    generate_object_doc(full_doc_dir, fields, row, obj_type)
+                    rows.append(row)
+
+                # get total number of rows
+                logger.info("Total no. of rows: %d" % (csvreader.line_num))
+
+
+# if this file is run directly, then start here
+if __name__ == '__main__':
+    #gen_obj_docs(object_docs)
+    configure_overview_table_docs(object_tables)
```

### Comparing `stixorm-0.1.3/stixorm/module/initialise.py` & `stixorm-0.1.9/stixorm/module/initialise.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,393 +1,393 @@
-#
-# Copyright (C) 2022 Vaticle
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-import os
-
-from typedb.client import *
-import logging
-
-logger = logging.getLogger(__name__)
-
-attack_raw = "https://raw.githubusercontent.com/mitre-attack/attack-stix-data/master/index.json"
-
-# make sure the four TLP Markings are loaded when the database initialises
-initial_markings = [[
-    '$mark isa tlp-white, has stix-type "marking-definition"',
-    ', has stix-id "marking-definition--613f2e26-407d-48c7-9eca-b8e91df99dc9"',
-    ', has spec-version "2.1", has created 2017-01-20T00:00:00.000;'
-], [
-    '$mark isa tlp-green, has stix-type "marking-definition"',
-    ', has stix-id "marking-definition--34098fce-860f-48ae-8e50-ebd3cc5e41da"',
-    ', has spec-version "2.1", has created 2017-01-20T00:00:00.000;'
-], [
-    '$mark isa tlp-amber, has stix-type "marking-definition"',
-    ', has stix-id "marking-definition--f88d31f6-486f-44da-b317-01333bde0b82"',
-    ', has spec-version "2.1", has created 2017-01-20T00:00:00.000;'
-], [
-    '$mark isa tlp-red, has stix-type "marking-definition"',
-    ', has stix-id "marking-definition--5e57c739-391a-4eb3-b6be-7d15ca92d5ed"',
-    ', has spec-version "2.1", has created 2017-01-20T00:00:00.000;'
-]]
-tlp_ids = ["marking-definition--613f2e26-407d-48c7-9eca-b8e91df99dc9",
-                   "marking-definition--34098fce-860f-48ae-8e50-ebd3cc5e41da",
-                   "marking-definition--f88d31f6-486f-44da-b317-01333bde0b82",
-                   "marking-definition--5e57c739-391a-4eb3-b6be-7d15ca92d5ed"]
-
-def setup_database(stix_connection: Dict[str, str], clear: bool):
-    url = stix_connection["uri"] + ":" + stix_connection["port"]
-    with TypeDB.core_client(url) as client:
-        logger.debug(f'Database Clearing is [{clear}]')
-        if client.databases().contains(stix_connection["database"]):
-            if clear:
-                client.databases().get(stix_connection["database"]).delete()
-                client.databases().create(stix_connection["database"])
-            else:
-                return
-                # raise ValueError(f"Database '{database}' already exists")
-        else:
-            client.databases().create(stix_connection["database"])
-
-        logger.debug('.......................... clear complete')
-
-
-def load_schema(stix_connection: Dict[str, str], rel_path=None, schema_type: str = "schema"):
-    logger.debug(f'{stix_connection}')
-    logger.debug(rel_path)
-    logger.debug(schema_type)
-    assert rel_path is not None, "Need a path to history a schema"
-    assert os.path.exists(rel_path), "File path needs to exist"
-
-    url = stix_connection["uri"] + ":" + stix_connection["port"]
-    with TypeDB.core_client(url) as client:
-        # Stage 1: Create the schema
-        with client.session(stix_connection["database"], SessionType.SCHEMA) as session:
-            # Load schema from file
-            with open(rel_path, "r") as schema_file:
-                schema = schema_file.read()
-            logger.debug('.....')
-            logger.debug(f'Inserting {schema_type} ...')
-            logger.debug('.....')
-            with session.transaction(TransactionType.WRITE) as write_transaction:
-                write_transaction.query().define(schema)
-                write_transaction.commit()
-            logger.debug('.....')
-            logger.debug('Successfully committed schema!')
-            logger.debug('.....')
-            session.close()
-
-
-def load_markings(stix_connection: Dict[str, str]):
-    type_ql_list = []
-    logger.info(f"========================== Database initialisation ============================")
-    for mark_list in initial_markings:
-        type_ql = " insert "
-        for line in mark_list:
-            type_ql += line
-        type_ql_list.append(type_ql)
-    load_typeql_data(type_ql_list, stix_connection)
-    logger.info(f"===============================================================================\n\n")
-    return_list = tlp_ids
-    return return_list
-
-
-def load_typeql_data(data_list, stix_connection: Dict[str, str]):
-    url = stix_connection["uri"] + ":" + stix_connection["port"]
-    with TypeDB.core_client(url) as client:
-        # Stage 1: Create the schema
-        with client.session(stix_connection["database"], SessionType.DATA) as session:
-            with session.transaction(TransactionType.WRITE) as write_transaction:
-                logger.debug(f'Loading TLP markings')
-                for data in data_list:
-                    logger.debug(f'\n\n{data}\n\n')
-                    insert_iterator = write_transaction.query().insert(data)
-
-                    logger.debug(f'insert_iterator response ->\n{insert_iterator}')
-                    for result in insert_iterator:
-                        logger.info(f'typedb response ->\n{result}')
-
-                write_transaction.commit()
-
-
-
-
-def sort_layers(layers,
-                cyclical,
-                indexes: List[str],
-                missing: List[str],
-                dep_obj, add_or_del='del'):
-    """ Sort the layers depending on whether they are "add" or "del" layers
-
-    Args:
-        layers ():
-        cyclical ():
-        indexes ():
-        missing ():
-        dep_obj ():
-        add_or_del ():
-
-    Returns:
-
-    """
-    logger.debug(
-        f"################################### enter sort_layers {add_or_del} ###############################################")
-    logger.debug(f'\nlayers -> {layers}\ncyclical indexes -> {cyclical}\nindexes -> {indexes}\nmissing -> {missing}')
-    logger.debug(f'add_or_del -> {add_or_del}\ndep_obj -> {dep_obj}')
-    logger.debug("-------------------------------  ------------------------------------------------")
-    # Stage 1 - Initialise Variables
-    # 1. Setup key variables
-    loc_id = dep_obj['id']
-    loc_list = dep_obj["dep_list"]
-    locset = set(loc_list)
-    mset = set(missing)
-    iset = set(indexes)
-    intset = locset.intersection(iset)
-    diffset = locset.difference(intset)
-    # Stage 2 - Analyse Choices
-    # 2. check whether the object has dependencies in its dep_list
-    if not loc_list:
-        # 2.a empty depedency list
-        dep_list_items = False
-        logger.debug('### There are no dependencies')
-    else:
-        # 2.b dependency list has indexes in it
-        dep_list_items = True
-        logger.debug('### There are some dependencies')
-    # 3. check whether the object id is in the missing list
-    if loc_id in mset:
-        id_in_missing = True
-        logger.debug('### Current is the missing dependency of an existing record')
-    else:
-        id_in_missing = False
-        logger.debug('### Current is not a missing dependency of an existing record')
-    # 4. check whether any id in the object dependency list is not already loaded
-    if not diffset:
-        dep_id_not_loaded = False
-        logger.debug('### No dependencies need to be added to missing')
-    else:
-        dep_id_not_loaded = True
-        mset = mset | diffset
-        logger.debug('### Missing - Some dependencies need to be added to missing')
-
-    # Stage 3 - Execute Choices
-    # 5. No dependencies and not in missing, append only
-    if not dep_list_items and not id_in_missing:
-        logger.debug('### Append object and return')
-        if add_or_del == 'del':
-            layers.append(dep_obj)
-            indexes.append(loc_id)
-        elif add_or_del == 'add':
-            layers.insert(0, dep_obj)
-            indexes.insert(0, loc_id)
-        logger.debug(f'layers -> {layers}\nindexes -> {indexes}\nmset -> {mset}')
-        logger.debug(
-            f"################################## end of  sort_layers {add_or_del} ####################################################")
-        return layers, indexes, list(mset), cyclical
-    # 6. There are no dependencies but id is in missing, delete from missing,follow the tree and reorder
-    if not dep_list_items and id_in_missing:
-        logger.debug('### delete from missing,follow the tree and reorder')
-        mset.remove(loc_id)
-        tree, circular = follow_the_tree(layers, dep_obj)
-        cyclical = cyclical + circular
-        logger.debug(f' tree -> {tree}')
-        layers, indexes = reorder(layers, indexes, tree, dep_obj, add_or_del)
-        logger.debug(f'layers -> {layers}\nindexes -> {indexes}\nmset -> {mset}')
-        logger.debug(
-            f"################################## end of  sort_layers {add_or_del} ####################################################")
-        return layers, indexes, list(mset), cyclical
-    # 7 There are dependencies, object is not in missing, insert at front
-    if dep_list_items and not id_in_missing:
-        logger.debug('### Add current to the front of the record')
-        if add_or_del == 'del':
-            layers.insert(0, dep_obj)
-            indexes.insert(0, loc_id)
-        elif add_or_del == 'add':
-            layers.append(dep_obj)
-            indexes.append(loc_id)
-        logger.debug(f'layers -> {layers}\nindexes -> {indexes}\nmset -> {mset}')
-        logger.debug(
-            f"################################## end of  sort_layers {add_or_del} ####################################################")
-        return layers, indexes, list(mset), cyclical
-    # 8 There are dependencies, object is in missing , delete from missing,follow the tree and reorder
-    if dep_list_items and id_in_missing:
-        logger.debug(f'### delete from missing,follow the tree and reorder')
-        mset.remove(loc_id)
-        tree, circular = follow_the_tree(layers, dep_obj)
-        cyclical = cyclical + circular
-        logger.debug(f' tree -> {tree}')
-        layers, indexes = reorder(layers, indexes, tree, dep_obj, add_or_del)
-        logger.debug(f'layers -> {layers}\nindexes -> {indexes}\nmset -> {mset}')
-        logger.debug(
-            f"################################## end of  sort_layers {add_or_del} ####################################################")
-        return layers, indexes, list(mset), cyclical
-
-    logger.debug("theres a massive problem")
-    return layers, indexes, list(mset), cyclical
-
-
-
-def reorder(layers, indexes, tree, dep_obj, add_or_del):
-    """ Reorder the layers list of objects based on dependencies
-    Args:
-        layers (): ordered list of layers
-        indexes (): list of indexes in the same order as layers
-        tree (): list of indexes, based on finding a hierarchy depdnent on this record
-        dep_obj (): a dependency object containing the new layer element to be added
-        add_or_del (): a flag on whether the records represent insert or delete operations (order)
-    Returns:
-        layers (): ordered list of layers now including the dep_object
-        indexes (): ordered list of stix ids to match the layers
-    """
-    front_layers = []
-    front_indexes = []
-    dep_layers = []
-    dep_indexes = []
-    dtree = []
-    loc_list = dep_obj["dep_list"]
-    tree = list(set(tree))
-    logger.debug("%%%%%%%%%%%%%%% reorder 1 %%%%%%%%%%%%%%%%%%")
-    logger.debug(f'\n orig indexes -> {indexes}\n orig layers, {layers}\n dep_obj , {dep_obj}')
-    logger.debug("%%%%%%%%%%%%%%% reorder 2 %%%%%%%%%%dep_obj%%%%%%%%")
-    # 1. Copy elements from layers and indexes so they are in the order we want them
-    if add_or_del == 'del':
-        up_tree = reversed(tree)
-    elif add_or_del == 'add':
-        up_tree = tree
-    for t in up_tree:
-        front_layers.append(layers[t])
-        front_indexes.append(indexes[t])
-    # 1.B Handle the dep_list linkages
-    for d in loc_list:
-        for index, i in enumerate(indexes):
-            if d == i:
-                dtree.append(index)
-                dep_layers.append(layers[index])
-                dep_indexes.append(layers[index]['id'])
-    # 2. Now order the tree in reverse numeric order, biggest first
-    total_tree = tree + dtree
-    total_tree.sort(reverse=True)
-    # 3. Now delete the elements from layers and indexes
-    # TODO: Error here for test_add_files
-    for t in total_tree:
-        layers.pop(t)
-        indexes.pop(t)
-    # 4. Add the dep_obj to the new lists
-    if add_or_del == 'del':
-        front_indexes.append(dep_obj['id'])
-        front_layers.append(dep_obj)
-        layers = front_layers + dep_layers + layers
-        indexes = front_indexes + dep_indexes + indexes
-    elif add_or_del == 'add':
-        front_layers.insert(0, dep_obj)
-        front_indexes.insert(0, dep_obj['id'])
-        layers = dep_layers + front_layers + layers
-        indexes = dep_indexes + front_indexes + indexes
-    # 5. Assemble the final lists
-    logger.debug(
-        f'\nfront_indexes -> {front_indexes}\n\nfront_layers, {front_layers}\n\n old layers, {layers}\n\nold indexes -> {indexes}')
-    logger.debug("-------------------------------------------------------------------------------------")
-    logger.debug("%%%%%%%%%%%%%%% end reorder %%%%%%%%%%%%%%%%%%")
-    return layers, indexes
-
-
-def follow_the_tree(layers, dep_obj):
-    """ Follow the tree of dependencies and report back the list and any cyclical id's
-
-    Args:
-        layers ():
-        dep_obj ():
-
-    Returns:
-        tree: a ist of imdexes numbers
-        cyclical: a list of stix-ds in a cyclical relationship (error condition)
-
-    """
-    tree = []
-    cyclical = []
-    loc_id = dep_obj['id']
-    loc_ids = [loc_id]
-    loc_dep = dep_obj['dep_list']
-    found = True
-    found, ret_indexes, ret_ids, circular = find_id(loc_ids, loc_dep, layers)
-    logger.debug(f'### Following First Level Tree, found {found},index {ret_indexes}, loc_id {ret_ids}')
-    if found:
-        tree = tree + ret_indexes
-        loc_ids = ret_ids
-        cyclical = circular
-    while found:
-        found, ret_indexes, ret_ids, circular = find_id(loc_ids, loc_dep, layers)
-        logger.debug(f'### Following Tree, found {found},index {ret_indexes}, loc_id {ret_ids}')
-        if found:
-            tree = tree + ret_indexes
-            loc_ids = ret_ids
-    return tree, cyclical
-
-
-def find_id(loc_ids, loc_dep, layers):
-    """ Compare a list of ids, and find which layers are dependent on this list
-
-    Args:
-        loc_ids (list): one or more stix ids describing the record
-        loc_dep (list): a list of stix ids that this record is dependent on
-
-    Returns:
-        found (boolean): whether the stix-ids were found in the depednency's of the layers
-        indexes (list): a list of the index numbers that are dependencies
-        ids (list): a list of layer stix-ids that are dependent on this record
-    """
-    cyclical = []
-    found = False
-    indexes = []
-    ids = []
-    for loc_id in loc_ids:
-        for index, lay in enumerate(layers):
-            if loc_id in lay['dep_list']:
-                if lay['id'] in loc_dep:
-                    cyclical.append(lay['id'])
-                    cyclical.append(loc_id)
-                found = True
-                indexes.append(index)
-                ids.append(lay['id'])
-
-    return found, indexes, ids, cyclical
-
-
-# if this file is run directly, then start here
-if __name__ == '__main__':
-    # define the localhost and default stix2 setup
-    connection = {
-        "uri": "localhost",
-        "port": "1729",
-        "database": "stix2",
-        "user": None,
-        "password": None,
-        "clear": True
-    }
-
-    import_type = {
-        "STIX21": True,
-        "CVE": False,
-        "identity": False,
-        "location": False,
-        "rules": False,
-        "ATT&CK": True,
-        "ATT&CK_Versions": ["12.0"],
-        "ATT&CK_Domains": ["enterprise-attack", "mobile-attack", "ics-attack"],
-        "CACAO": False
-    }
+#
+# Copyright (C) 2022 Vaticle
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+import os
+
+from typedb.client import *
+import logging
+
+logger = logging.getLogger(__name__)
+
+attack_raw = "https://raw.githubusercontent.com/mitre-attack/attack-stix-data/master/index.json"
+
+# make sure the four TLP Markings are loaded when the database initialises
+initial_markings = [[
+    '$mark isa tlp-white, has stix-type "marking-definition"',
+    ', has stix-id "marking-definition--613f2e26-407d-48c7-9eca-b8e91df99dc9"',
+    ', has spec-version "2.1", has created 2017-01-20T00:00:00.000;'
+], [
+    '$mark isa tlp-green, has stix-type "marking-definition"',
+    ', has stix-id "marking-definition--34098fce-860f-48ae-8e50-ebd3cc5e41da"',
+    ', has spec-version "2.1", has created 2017-01-20T00:00:00.000;'
+], [
+    '$mark isa tlp-amber, has stix-type "marking-definition"',
+    ', has stix-id "marking-definition--f88d31f6-486f-44da-b317-01333bde0b82"',
+    ', has spec-version "2.1", has created 2017-01-20T00:00:00.000;'
+], [
+    '$mark isa tlp-red, has stix-type "marking-definition"',
+    ', has stix-id "marking-definition--5e57c739-391a-4eb3-b6be-7d15ca92d5ed"',
+    ', has spec-version "2.1", has created 2017-01-20T00:00:00.000;'
+]]
+tlp_ids = ["marking-definition--613f2e26-407d-48c7-9eca-b8e91df99dc9",
+                   "marking-definition--34098fce-860f-48ae-8e50-ebd3cc5e41da",
+                   "marking-definition--f88d31f6-486f-44da-b317-01333bde0b82",
+                   "marking-definition--5e57c739-391a-4eb3-b6be-7d15ca92d5ed"]
+
+def setup_database(stix_connection: Dict[str, str], clear: bool):
+    url = stix_connection["uri"] + ":" + stix_connection["port"]
+    with TypeDB.core_client(url) as client:
+        logger.debug(f'Database Clearing is [{clear}]')
+        if client.databases().contains(stix_connection["database"]):
+            if clear:
+                client.databases().get(stix_connection["database"]).delete()
+                client.databases().create(stix_connection["database"])
+            else:
+                return
+                # raise ValueError(f"Database '{database}' already exists")
+        else:
+            client.databases().create(stix_connection["database"])
+
+        logger.debug('.......................... clear complete')
+
+
+def load_schema(stix_connection: Dict[str, str], rel_path=None, schema_type: str = "schema"):
+    logger.debug(f'{stix_connection}')
+    logger.debug(rel_path)
+    logger.debug(schema_type)
+    assert rel_path is not None, "Need a path to history a schema"
+    assert os.path.exists(rel_path), "File path needs to exist"
+
+    url = stix_connection["uri"] + ":" + stix_connection["port"]
+    with TypeDB.core_client(url) as client:
+        # Stage 1: Create the schema
+        with client.session(stix_connection["database"], SessionType.SCHEMA) as session:
+            # Load schema from file
+            with open(rel_path, "r") as schema_file:
+                schema = schema_file.read()
+            logger.debug('.....')
+            logger.debug(f'Inserting {schema_type} ...')
+            logger.debug('.....')
+            with session.transaction(TransactionType.WRITE) as write_transaction:
+                write_transaction.query().define(schema)
+                write_transaction.commit()
+            logger.debug('.....')
+            logger.debug('Successfully committed schema!')
+            logger.debug('.....')
+            session.close()
+
+
+def load_markings(stix_connection: Dict[str, str]):
+    type_ql_list = []
+    logger.info(f"========================== Database initialisation ============================")
+    for mark_list in initial_markings:
+        type_ql = " insert "
+        for line in mark_list:
+            type_ql += line
+        type_ql_list.append(type_ql)
+    load_typeql_data(type_ql_list, stix_connection)
+    logger.info(f"===============================================================================\n\n")
+    return_list = tlp_ids
+    return return_list
+
+
+def load_typeql_data(data_list, stix_connection: Dict[str, str]):
+    url = stix_connection["uri"] + ":" + stix_connection["port"]
+    with TypeDB.core_client(url) as client:
+        # Stage 1: Create the schema
+        with client.session(stix_connection["database"], SessionType.DATA) as session:
+            with session.transaction(TransactionType.WRITE) as write_transaction:
+                logger.debug(f'Loading TLP markings')
+                for data in data_list:
+                    logger.debug(f'\n\n{data}\n\n')
+                    insert_iterator = write_transaction.query().insert(data)
+
+                    logger.debug(f'insert_iterator response ->\n{insert_iterator}')
+                    for result in insert_iterator:
+                        logger.info(f'typedb response ->\n{result}')
+
+                write_transaction.commit()
+
+
+
+
+def sort_layers(layers,
+                cyclical,
+                indexes: List[str],
+                missing: List[str],
+                dep_obj, add_or_del='del'):
+    """ Sort the layers depending on whether they are "add" or "del" layers
+
+    Args:
+        layers ():
+        cyclical ():
+        indexes ():
+        missing ():
+        dep_obj ():
+        add_or_del ():
+
+    Returns:
+
+    """
+    logger.debug(
+        f"################################### enter sort_layers {add_or_del} ###############################################")
+    logger.debug(f'\nlayers -> {layers}\ncyclical indexes -> {cyclical}\nindexes -> {indexes}\nmissing -> {missing}')
+    logger.debug(f'add_or_del -> {add_or_del}\ndep_obj -> {dep_obj}')
+    logger.debug("-------------------------------  ------------------------------------------------")
+    # Stage 1 - Initialise Variables
+    # 1. Setup key variables
+    loc_id = dep_obj['id']
+    loc_list = dep_obj["dep_list"]
+    locset = set(loc_list)
+    mset = set(missing)
+    iset = set(indexes)
+    intset = locset.intersection(iset)
+    diffset = locset.difference(intset)
+    # Stage 2 - Analyse Choices
+    # 2. check whether the object has dependencies in its dep_list
+    if not loc_list:
+        # 2.a empty depedency list
+        dep_list_items = False
+        logger.debug('### There are no dependencies')
+    else:
+        # 2.b dependency list has indexes in it
+        dep_list_items = True
+        logger.debug('### There are some dependencies')
+    # 3. check whether the object id is in the missing list
+    if loc_id in mset:
+        id_in_missing = True
+        logger.debug('### Current is the missing dependency of an existing record')
+    else:
+        id_in_missing = False
+        logger.debug('### Current is not a missing dependency of an existing record')
+    # 4. check whether any id in the object dependency list is not already loaded
+    if not diffset:
+        dep_id_not_loaded = False
+        logger.debug('### No dependencies need to be added to missing')
+    else:
+        dep_id_not_loaded = True
+        mset = mset | diffset
+        logger.debug('### Missing - Some dependencies need to be added to missing')
+
+    # Stage 3 - Execute Choices
+    # 5. No dependencies and not in missing, append only
+    if not dep_list_items and not id_in_missing:
+        logger.debug('### Append object and return')
+        if add_or_del == 'del':
+            layers.append(dep_obj)
+            indexes.append(loc_id)
+        elif add_or_del == 'add':
+            layers.insert(0, dep_obj)
+            indexes.insert(0, loc_id)
+        logger.debug(f'layers -> {layers}\nindexes -> {indexes}\nmset -> {mset}')
+        logger.debug(
+            f"################################## end of  sort_layers {add_or_del} ####################################################")
+        return layers, indexes, list(mset), cyclical
+    # 6. There are no dependencies but id is in missing, delete from missing,follow the tree and reorder
+    if not dep_list_items and id_in_missing:
+        logger.debug('### delete from missing,follow the tree and reorder')
+        mset.remove(loc_id)
+        tree, circular = follow_the_tree(layers, dep_obj)
+        cyclical = cyclical + circular
+        logger.debug(f' tree -> {tree}')
+        layers, indexes = reorder(layers, indexes, tree, dep_obj, add_or_del)
+        logger.debug(f'layers -> {layers}\nindexes -> {indexes}\nmset -> {mset}')
+        logger.debug(
+            f"################################## end of  sort_layers {add_or_del} ####################################################")
+        return layers, indexes, list(mset), cyclical
+    # 7 There are dependencies, object is not in missing, insert at front
+    if dep_list_items and not id_in_missing:
+        logger.debug('### Add current to the front of the record')
+        if add_or_del == 'del':
+            layers.insert(0, dep_obj)
+            indexes.insert(0, loc_id)
+        elif add_or_del == 'add':
+            layers.append(dep_obj)
+            indexes.append(loc_id)
+        logger.debug(f'layers -> {layers}\nindexes -> {indexes}\nmset -> {mset}')
+        logger.debug(
+            f"################################## end of  sort_layers {add_or_del} ####################################################")
+        return layers, indexes, list(mset), cyclical
+    # 8 There are dependencies, object is in missing , delete from missing,follow the tree and reorder
+    if dep_list_items and id_in_missing:
+        logger.debug(f'### delete from missing,follow the tree and reorder')
+        mset.remove(loc_id)
+        tree, circular = follow_the_tree(layers, dep_obj)
+        cyclical = cyclical + circular
+        logger.debug(f' tree -> {tree}')
+        layers, indexes = reorder(layers, indexes, tree, dep_obj, add_or_del)
+        logger.debug(f'layers -> {layers}\nindexes -> {indexes}\nmset -> {mset}')
+        logger.debug(
+            f"################################## end of  sort_layers {add_or_del} ####################################################")
+        return layers, indexes, list(mset), cyclical
+
+    logger.debug("theres a massive problem")
+    return layers, indexes, list(mset), cyclical
+
+
+
+def reorder(layers, indexes, tree, dep_obj, add_or_del):
+    """ Reorder the layers list of objects based on dependencies
+    Args:
+        layers (): ordered list of layers
+        indexes (): list of indexes in the same order as layers
+        tree (): list of indexes, based on finding a hierarchy depdnent on this record
+        dep_obj (): a dependency object containing the new layer element to be added
+        add_or_del (): a flag on whether the records represent insert or delete operations (order)
+    Returns:
+        layers (): ordered list of layers now including the dep_object
+        indexes (): ordered list of stix ids to match the layers
+    """
+    front_layers = []
+    front_indexes = []
+    dep_layers = []
+    dep_indexes = []
+    dtree = []
+    loc_list = dep_obj["dep_list"]
+    tree = list(set(tree))
+    logger.debug("%%%%%%%%%%%%%%% reorder 1 %%%%%%%%%%%%%%%%%%")
+    logger.debug(f'\n orig indexes -> {indexes}\n orig layers, {layers}\n dep_obj , {dep_obj}')
+    logger.debug("%%%%%%%%%%%%%%% reorder 2 %%%%%%%%%%dep_obj%%%%%%%%")
+    # 1. Copy elements from layers and indexes so they are in the order we want them
+    if add_or_del == 'del':
+        up_tree = reversed(tree)
+    elif add_or_del == 'add':
+        up_tree = tree
+    for t in up_tree:
+        front_layers.append(layers[t])
+        front_indexes.append(indexes[t])
+    # 1.B Handle the dep_list linkages
+    for d in loc_list:
+        for index, i in enumerate(indexes):
+            if d == i:
+                dtree.append(index)
+                dep_layers.append(layers[index])
+                dep_indexes.append(layers[index]['id'])
+    # 2. Now order the tree in reverse numeric order, biggest first
+    total_tree = tree + dtree
+    total_tree.sort(reverse=True)
+    # 3. Now delete the elements from layers and indexes
+    # TODO: Error here for test_add_files
+    for t in total_tree:
+        layers.pop(t)
+        indexes.pop(t)
+    # 4. Add the dep_obj to the new lists
+    if add_or_del == 'del':
+        front_indexes.append(dep_obj['id'])
+        front_layers.append(dep_obj)
+        layers = front_layers + dep_layers + layers
+        indexes = front_indexes + dep_indexes + indexes
+    elif add_or_del == 'add':
+        front_layers.insert(0, dep_obj)
+        front_indexes.insert(0, dep_obj['id'])
+        layers = dep_layers + front_layers + layers
+        indexes = dep_indexes + front_indexes + indexes
+    # 5. Assemble the final lists
+    logger.debug(
+        f'\nfront_indexes -> {front_indexes}\n\nfront_layers, {front_layers}\n\n old layers, {layers}\n\nold indexes -> {indexes}')
+    logger.debug("-------------------------------------------------------------------------------------")
+    logger.debug("%%%%%%%%%%%%%%% end reorder %%%%%%%%%%%%%%%%%%")
+    return layers, indexes
+
+
+def follow_the_tree(layers, dep_obj):
+    """ Follow the tree of dependencies and report back the list and any cyclical id's
+
+    Args:
+        layers ():
+        dep_obj ():
+
+    Returns:
+        tree: a ist of imdexes numbers
+        cyclical: a list of stix-ds in a cyclical relationship (error condition)
+
+    """
+    tree = []
+    cyclical = []
+    loc_id = dep_obj['id']
+    loc_ids = [loc_id]
+    loc_dep = dep_obj['dep_list']
+    found = True
+    found, ret_indexes, ret_ids, circular = find_id(loc_ids, loc_dep, layers)
+    logger.debug(f'### Following First Level Tree, found {found},index {ret_indexes}, loc_id {ret_ids}')
+    if found:
+        tree = tree + ret_indexes
+        loc_ids = ret_ids
+        cyclical = circular
+    while found:
+        found, ret_indexes, ret_ids, circular = find_id(loc_ids, loc_dep, layers)
+        logger.debug(f'### Following Tree, found {found},index {ret_indexes}, loc_id {ret_ids}')
+        if found:
+            tree = tree + ret_indexes
+            loc_ids = ret_ids
+    return tree, cyclical
+
+
+def find_id(loc_ids, loc_dep, layers):
+    """ Compare a list of ids, and find which layers are dependent on this list
+
+    Args:
+        loc_ids (list): one or more stix ids describing the record
+        loc_dep (list): a list of stix ids that this record is dependent on
+
+    Returns:
+        found (boolean): whether the stix-ids were found in the depednency's of the layers
+        indexes (list): a list of the index numbers that are dependencies
+        ids (list): a list of layer stix-ids that are dependent on this record
+    """
+    cyclical = []
+    found = False
+    indexes = []
+    ids = []
+    for loc_id in loc_ids:
+        for index, lay in enumerate(layers):
+            if loc_id in lay['dep_list']:
+                if lay['id'] in loc_dep:
+                    cyclical.append(lay['id'])
+                    cyclical.append(loc_id)
+                found = True
+                indexes.append(index)
+                ids.append(lay['id'])
+
+    return found, indexes, ids, cyclical
+
+
+# if this file is run directly, then start here
+if __name__ == '__main__':
+    # define the localhost and default stix2 setup
+    connection = {
+        "uri": "localhost",
+        "port": "1729",
+        "database": "stix2",
+        "user": None,
+        "password": None,
+        "clear": True
+    }
+
+    import_type = {
+        "STIX21": True,
+        "CVE": False,
+        "identity": False,
+        "location": False,
+        "rules": False,
+        "ATT&CK": True,
+        "ATT&CK_Versions": ["12.0"],
+        "ATT&CK_Domains": ["enterprise-attack", "mobile-attack", "ics-attack"],
+        "CACAO": False
+    }
```

### Comparing `stixorm-0.1.3/stixorm/module/orm/delete_object.py` & `stixorm-0.1.9/stixorm/module/orm/delete_object.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,510 +1,510 @@
-import re
-from typing import List
-import copy
-
-from stixorm.module.authorise import authorised_mappings
-
-from stixorm.module.orm.import_objects import sdo_to_data, sro_to_data, sco_to_data
-from stixorm.module.orm.import_utilities import split_on_activity_type, val_tql
-
-import logging
-
-from stixorm.module.typedb_lib.factories.auth_factory import get_auth_factory_instance
-
-logger = logging.getLogger(__name__)
-logger.setLevel(logging.INFO)
-##############################################################
-#  1.) Methods to Delete any Stix Objects
-############################################################
-
-#---------------------------------------------------
-# 1.0) Helper method to direct the right typeql method to an incoming Stix object
-#---------------------------------------------------
-
-
-def delete_stix_object(stix_object,
-                       dep_match: str,
-                       dep_insert: str,
-                       indep_ql: str,
-                       core_ql: str,
-                       import_type) -> [str, str]:
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    if stix_object.type in auth["types"]["sdo"]:
-        total_props, obj_tql, sdo_tql_name, protocol = sdo_to_data(stix_object, import_type)
-        var_name: List[str] = get_obj_var(indep_ql)
-        del_match, del_tql = delete_object(stix_object, core_ql, total_props, obj_tql, var_name, sdo_tql_name, import_type)
-    elif stix_object.type in auth["types"]["sro"]:
-        total_props, obj_tql, sro_tql_name, protocol = sro_to_data(stix_object, import_type)
-        var_name: List[str] = get_obj_var(dep_insert)
-        del_match, del_tql = delete_object(stix_object, core_ql, total_props, obj_tql, var_name, sro_tql_name, import_type)
-    elif stix_object.type in auth["types"]["sco"]:
-        total_props, obj_tql, sro_tql_name, protocol = sco_to_data(stix_object, import_type)
-        var_name: List[str] = get_obj_var(core_ql)
-        # Need to change this line to suit scenarios where object name is not type name (e.g. future)
-        del_match, del_tql = delete_object(stix_object, core_ql, total_props, obj_tql, var_name, sro_tql_name, import_type)
-    elif stix_object.type == 'marking-definition':
-        del_match, del_tql = delete_marking(stix_object, dep_match, dep_insert, indep_ql, core_ql, import_type)
-    else:
-        logger.error(f'object type not supported in delete stix object: {stix_object.type}')
-        logger.error(f' import type {dep_match + dep_insert + indep_ql + core_ql}')
-        del_match = del_tql = ""
-
-    return del_match, del_tql
-
-
-def delete_object(stix_object,
-                  core_ql: str,
-                  total_props,
-                  obj_tql,
-                  var_name: List[str],
-                  tql_name: str,
-                  import_type) -> [str, str]:
-    # 1.B) get the data model
-    properties, relations = split_on_activity_type(total_props, obj_tql)
-    # 2.0) MAtch in the object, the id and all attributes not owned by another object
-    del_match = 'match \n' + core_ql
-    del_match += var_name[0] + ' has $a;\n'
-    del_match += 'not { ' + var_name[0] + ' isa thing; $p2 isa thing, has $a; not {'
-    del_match += var_name[0] + ' is $p2;}; };\n\n'
-    del_tql = 'delete \n'
-    # 3.0) Now setup the match and delete statements for the local relations or  sub objects
-    for i, reln in enumerate(relations):
-        del_match2, del_tql2 = delete_sub_reln(reln, stix_object, var_name[0], i, import_type)
-        del_match += del_match2
-        del_tql += del_tql2
-
-    # 4.0) Now setup the delete and match for the actual attributes, stix-id and object in reverse
-    del_tql += '\n'
-    del_tql += var_name[0] + ' isa ' + tql_name + ';\n'
-    del_tql += '$a isa attribute;\n'
-    del_tql += '$stix-id isa stix-id;\n'
-
-    return del_match, del_tql
-
-
-def delete_marking(stix_object, dep_match, dep_insert, indep_ql, core_ql, import_type) -> [str, str]:
-    del_match = del_tql = ''
-    if stix_object.definition_type == "statement":
-        del_match = 'match \n$marking isa statement-marking'
-        del_match += ',\n has stix-id $stix-id; $stix-id ' + val_tql(stix_object.id)
-        del_match += ';\n$marking has $a;\n'
-        del_match += 'not { $marking isa thing; $p2 isa thing, has $a; not {'
-        del_match += '$marking is $p2;}; };\n\n'
-        del_tql = 'delete \n'
-        del_tql += '$marking isa statement-marking;\n'
-        del_tql += '$stix-id isa stix-id;\n'
-        del_tql += '$a isa attribute;\n'
-
-    return del_match, del_tql
-
-
-def get_obj_var(core_ql) -> List[str]:
-    m = re.findall(r"(\$[a-z\-0-9]+)\s+(.+)?isa\s+", core_ql,re.MULTILINE)
-    output = []
-    #logger.debug(f'local 1 -> {m}')
-    if m:
-        #logger.debug(f'local -> {m}')
-        for found in m:
-            output.append(found[0])
-            #logger.debug(f'Found first {found[0]}')
-
-    return output
-
-
-def get_tql_name(dep_insert):
-    m = re.findall(r"([a-z\-]+),$",dep_insert,re.MULTILINE)
-    output = []
-    #logger.debug(f'local 1 -> {m}')
-    if m:
-        for found in m:
-            output.append(found)
-            #logger.debug(f'Found name {found}')
-
-    return output
-
-
-def delete_sub_reln(rel, obj, obj_var, i, import_type):
-    """
-        Top level function to delete one of the sub objects from the stix object
-    Args:
-        rel (): the relation object to delete
-        obj (): the stix object to delete it from
-        obj_var (): the typeql variable string
-
-    Returns:
-        match: the typeql match string
-        delete: the typeql delete string
-    """
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    if rel == "granular_markings":
-        match, delete = del_granular_markings(obj_var)
-
-    # hashes type
-    elif (rel == "hashes"
-          or rel == "file_header_hashes"):
-        match, delete = del_hashes(rel, obj[rel], obj_var, i)
-
-    # insert key value store
-    elif rel in auth["reln_name"]["key_value_relations"]:
-        match, delete = del_key_value_store(rel, obj[rel], obj_var, i, import_type)
-
-    # insert list of object relation
-    elif rel in auth["reln_name"]["list_of_objects"]:
-        match, delete = del_list_of_object(rel, obj[rel], obj_var, i, import_type)
-
-    # insert embedded relations based on stix-id
-    elif rel in auth["reln_name"]["embedded_relations"]:
-        match, delete = del_embedded_relation(rel, obj[rel], obj_var, i, import_type)
-
-    # insert plain sub-object with relation
-    elif (rel == "x509_v3_extensions"
-          or rel == "optional_header"):
-        match, delete = del_load_object(rel, obj[rel], obj_var, i, import_type)
-
-    # insert  SCO Extensions here, a possible dict of sub-objects
-    elif rel in auth["reln_name"]["extension_relations"]:
-        match, delete = del_extensions(rel, obj[rel], obj_var, i, import_type)
-
-    # ignore the following relations as they are already processed, for Relationships, Sightings and Extensions
-    elif (rel == "sighting_of_ref"
-          or rel == "observed_data_refs"
-          or rel == "where_sighted_refs"
-          or rel == "source_ref"
-          or rel == "target_ref"
-          or rel == "definition"
-          or rel == "definition_type"):
-        match = delete = ''
-
-    else:
-        logger.error(f'relation type not known, rel -> {rel}')
-        match = delete = ""
-
-    return match, delete
-
-
-def del_granular_markings(obj_var):
-    match = '$granular (object:' + obj_var + ') isa granular-marking;\n'
-    delete = '$granular isa granular-marking;\n'
-
-    return match, delete
-
-
-def del_hashes(rel_name, rel_object, obj_var, i):
-    match = '$hash isa hash, has hash-value $h;\n'
-    match += '$hash_rel (owner:'+obj_var
-    match += ', pointed-to:$hash) isa hashes;\n'
-    delete = '$hash_rel isa hashes;\n'
-    delete += '$hash isa hash;\n'
-    return match, delete
-
-
-def del_key_value_store(rel_name, rel_object, obj_var, i, import_type):
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    for config in auth["reln"]["key_value_relations"]:
-        if config["name"] == rel_name:
-            rel_typeql = config["typeql"]
-            role_owner = config["owner"]
-            role_pointed = config["pointed_to"]
-            d_key = config["key"]
-            d_value = config["value"]
-            break
-
-    key_var = '$' + d_key + str(i)
-    val_var = ' $' + d_value + str(i)
-    match = key_var + ' isa ' + d_key + ';\n'
-    match += key_var + ' has ' + d_value + val_var + ';\n'
-    match += '$' + rel_typeql + ' (' + role_owner + ':' + obj_var
-    match += ', ' + role_pointed + ':' + key_var
-    match += ') isa ' + rel_typeql + ';\n\n'
-    delete = '\n'
-    delete += '$' + rel_typeql + ' isa ' + rel_typeql + ';\n'
-    #delete += val_var + ' isa ' + d_value + ';\n'
-    #delete += key_var + ' isa ' + d_key + ';\n'
-
-    return match, delete
-
-
-def del_list_of_object(rel_name, prop_value_list, parent_var, i, import_type):
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    logger.debug(f'rl name -> {rel_name}')
-    for config in auth["reln"]["list_of_objects"]:
-        if config["name"] == rel_name:
-            rel_typeql = config["typeql"]
-            role_owner = config["owner"]
-            role_pointed = config["pointed_to"]
-            typeql_obj = config["object"]
-            obj_props_tql = copy.deepcopy(auth["sub_objects"][typeql_obj])
-            break
-    lod_list = []
-    match = delete = ''
-    for j, dict_instance in enumerate(prop_value_list):
-        lod_var = '$' + typeql_obj + str(j)
-        lod_list.append(lod_var)
-        match += lod_var + ' isa ' + typeql_obj + ';\n'
-        for key in dict_instance:
-            typeql_prop = obj_props_tql[key]
-            if typeql_prop == '':
-                # split off for relation processing
-                match2, delete2 = delete_sub_reln(key, dict_instance, lod_var, i + j, import_type)
-                # then add it back together
-                match = match + match2
-                delete = delete + "\n" + delete2 + "\n"
-        delete += lod_var + ' isa ' + typeql_obj + ';\n'
-
-    loc_var = '$' + typeql_obj + str(i)
-    #match += loc_var + ' isa ' + typeql_obj + ';\n'
-    #match += loc_var + ' has $b' + str(i) + ';\n'
-    #match += 'not { ' + loc_var + ' isa thing; $lob' + str(i) + ' isa thing, has $b' + str(i) + '; not {'
-    #match += loc_var + ' is $lob' + str(i) + ';}; };\n\n'
-
-    match += '\n $' + rel_typeql + str(i) + ' (' + role_owner + ':' + parent_var
-    for lod_var in lod_list:
-        match += ', ' + role_pointed + ':' + lod_var
-    match += ') isa ' + rel_typeql + ';\n'
-
-    #delete += loc_var + ' isa ' + typeql_obj + ';\n'
-    #delete += '$b' + str(i) + ' isa attribute; \n'
-    delete += '$' + rel_typeql + str(i) + ' isa ' + rel_typeql + ';\n'
-
-    return match, delete
-
-
-def del_embedded_relation(rel_name, rel_object, obj_var, i, import_type):
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    for ex in auth["reln"]["embedded_relations"]:
-      if ex["rel"] == rel_name:
-        owner = ex["owner"]
-        relation = ex["typeql"]
-        break
-    loc_var = '$' + relation + str(i)
-    match = loc_var + ' (' + owner + ':' + obj_var + ') isa ' + relation + ';\n'
-    delete = loc_var + ' isa ' + relation + ';\n'
-
-    return match, delete
-
-
-def del_load_object(prop_name, prop_dict, parent_var, i, import_type):
-    # as long as it is predefined, history the object
-    #logger.debug('------------------- history object ------------------------------')
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    logger.debug(f'prop dict {prop_dict}')
-    for prop_type in auth["reln"]["extension_relations"]:
-        if prop_name == prop_type["stix"]:
-            tot_prop_list = [tot for tot in prop_dict.keys()]
-            obj_name = prop_type["object"]
-            obj_tql = copy.deepcopy(auth["sub_objects"][obj_name])
-            obj_var = '$' + obj_name
-            reln = prop_type["relation"]
-            rel_var = '$' + reln
-            rel_owner = prop_type["owner"]
-            rel_pointed_to = prop_type["pointed-to"]
-
-            match = obj_var + ' isa ' + prop_type["object"] + ';\n'
-            #match += obj_var + ' has $d' + str(i) + ';\n'
-            #match += 'not { ' + obj_var + ' isa thing; $lobj' + str(i) + ' isa thing, has $d' + str(i) + '; not {'
-            #match += obj_var + ' is $lobj' + str(i) + ';}; };\n\n'
-
-            match += rel_var + ' (' + rel_owner + ':' + parent_var
-            match += ', ' + rel_pointed_to + ':' + obj_var + ')'
-            match += ' isa ' + reln + ';\n'
-
-            # Split them into properties and relations
-            properties, relations = split_on_activity_type(prop_dict, obj_tql)
-            delete = ''
-
-            # add each of the relations to the match and insert statements
-            for rel in relations:
-                # split off for relation processing
-                match2, delete2= delete_sub_reln(rel, prop_dict, obj_var, i+1)
-                # then add it back together
-                match = match + match2
-                delete = delete + "\n" + delete2
-
-            # finally, connect the local object to the parent object
-            #delete = '$d' + str(i) + ' isa attribute;\n'
-            delete += rel_var + ' isa ' + reln + ';\n'
-            delete += obj_var + ' isa ' + prop_type["object"] + ';\n'
-
-            break
-
-    return match, delete
-
-
-def del_extensions(prop_name, prop_dict, parent_var, i, import_type):
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    match = ''
-    delete = ''
-    # for each key in the dict (extension type)
-    # logger.debug('--------------------- extensions ----------------------------')
-    for ext_type in prop_dict:
-        for ext_type_ql in auth["reln"]["extension_relations"]:
-            if ext_type == ext_type_ql["stix"]:
-                match2, delete2 = del_load_object(ext_type, prop_dict[ext_type], parent_var, i)
-                match = match + match2
-                delete = delete + delete2
-                break
-    return match, delete
-
-
-def add_delete_layers(layers, dep_obj, indexes, missing):
-    logger.debug("################################### enter add_layers ###############################################")
-    logger.debug(f'\nlayers -> {layers}')
-    logger.debug(f'\ndep_obj -> {dep_obj}')
-    logger.debug(f'indexes -> {indexes}')
-    logger.debug(f'missing -> {missing}')
-    logger.debug("-------------------------------  ------------------------------------------------")
-    # Stage 1 - Initialise Variables
-    # 1. Setup key variables
-    loc_id = dep_obj['id']
-    loc_list = dep_obj["dep_list"]
-    locset = set(loc_list)
-    mset = set(missing)
-    iset = set(indexes)
-    intset = locset.intersection(iset)
-    diffset = locset.difference(intset)
-    # Stage 2 - Analyse Choices
-    # 2. check whether the object has dependencies in its dep_list
-    if not loc_list:
-        dep_list_items = False
-        logger.debug('### There are no dependencies')
-    else:
-        dep_list_items = True
-        logger.debug('### There are some dependencies')
-    # 3. check whether the object id is in the missing list
-    if loc_id in mset:
-        id_in_missing = True
-        logger.debug('### Current is the missing dependency of an existing record')
-    else:
-        id_in_missing = False
-        logger.debug('### Current is not a missing dependency of an existing record')
-    # 4. check whether any id in the object dependency list is not already loaded
-    if not diffset:
-        dep_id_not_loaded = False
-        logger.debug('### No dependencies need to be added to missing')
-    else:
-        dep_id_not_loaded = True
-        mset = mset | diffset
-        logger.debug('### Missing - Some dependencies need to be added to missing')
-
-    # Stage 3 - Execute Choices
-    # 5. No dependencies and not in missing, append only
-    if not dep_list_items and not id_in_missing:
-        logger.debug('### Append object and return')
-        layers.append(dep_obj)
-        indexes.append(loc_id)
-        logger.debug(f'layers -> {layers}')
-        logger.debug(f'indexes -> {indexes}')
-        logger.debug(f'mset -> {mset}')
-        logger.debug("################################## end of  add_layers ####################################################")
-        return layers, indexes, list(mset)
-    # 6. There are no dependencies but id is in missing, delete from missing,follow the tree and reorder
-    if not dep_list_items and id_in_missing:
-        logger.debug('### delete from missing,follow the tree and reorder')
-        mset.remove(loc_id)
-        tree = follow_the_tree(layers, dep_obj)
-        logger.debug(f' tree -> {tree}')
-        layers, indexes = reorder(layers, indexes, tree, dep_obj)
-        logger.debug(f'layers -> {layers}')
-        logger.debug(f'indexes -> {indexes}')
-        logger.debug(f'mset -> {mset}')
-        logger.debug("################################## end of  add_layers ####################################################")
-        return layers, indexes, list(mset)
-    # 7 There are dependencies, object is not in missing, insert at front
-    if dep_list_items and not id_in_missing:
-        logger.debug('### Add current to the front of the record')
-        layers.insert(0, dep_obj)
-        indexes.insert(0, loc_id)
-        logger.debug(f'layers -> {layers}')
-        logger.debug(f'indexes -> {indexes}')
-        logger.debug(f'mset -> {mset}')
-        logger.debug("################################## end of  add_layers ####################################################")
-        return layers, indexes, list(mset)
-    # 8 There are dependencies, object is in missing , delete from missing,follow the tree and reorder
-    if dep_list_items and id_in_missing:
-        logger.debug('### delete from missing,follow the tree and reorder')
-        mset.remove(loc_id)
-        tree = follow_the_tree(layers, dep_obj)
-        logger.debug(f' tree -> {tree}')
-        layers, indexes = reorder(layers, indexes, tree, dep_obj)
-        logger.debug(f'layers -> {layers}')
-        logger.debug(f'indexes -> {indexes}')
-        logger.debug(f'mset -> {mset}')
-        logger.debug("################################## end of  add_layers ####################################################")
-        return layers, indexes, list(mset)
-
-    logger.debug("theres a massive problem")
-    return layers, indexes, list(mset)
-
-
-def reorder(layers, indexes, tree, dep_obj):
-    front_layers = []
-    front_indexes = []
-    tree = list(set(tree))
-    logger.debug("%%%%%%%%%%%%%%% reorder 1 %%%%%%%%%%%%%%%%%%")
-    logger.debug(f'\n orig indexes -> {indexes}')
-    logger.debug(f"\n orig layers, {layers}")
-    logger.debug(f"\n dep_obj , {dep_obj}")
-    logger.debug("%%%%%%%%%%%%%%% reorder 2 %%%%%%%%%%dep_obj%%%%%%%%")
-    # 1. Copy elements from layers and indexes so they are in the order we want them
-    for t in reversed(tree):
-        front_layers.append(layers[t])
-        front_indexes.append(indexes[t])
-    # 2. Now order the tree in reverse numeric order, biggest first
-    tree.sort(reverse=True)
-    # 3. Now delete the elements from layers and indexes
-    for t in tree:
-        layers.pop(t)
-        indexes.pop(t)
-    # 4. Add the dep_obj to the new lists
-    front_indexes.append(dep_obj['id'])
-    front_layers.append(dep_obj)
-    # 5. Assemble the final lists
-    logger.debug(f'\nfront_indexes -> {front_indexes}')
-    logger.debug(f"\nfront_layers, {front_layers}")
-    logger.debug(f"\n old layers, {layers}")
-    logger.debug(f'\nold indexes -> {indexes}')
-    logger.debug("-------------------------------------------------------------------------------------")
-    layers = front_layers + layers
-    indexes = front_indexes + indexes
-    #logger.debug(f"\nlayers, {layers}")
-    #logger.debug(f'\nindexes -> {indexes}')
-    logger.debug("%%%%%%%%%%%%%%% end reorder %%%%%%%%%%%%%%%%%%")
-    return layers, indexes
-
-
-def follow_the_tree(layers, dep_obj):
-    tree = []
-    loc_id = dep_obj['id']
-    loc_ids = [loc_id]
-    found = True
-    while found:
-        found, ret_indexes, ret_ids = find_id(loc_ids, layers)
-        logger.debug(f'### Following Tree, found {found},index {ret_indexes}, loc_id {ret_ids}')
-        if found:
-            tree = tree + ret_indexes
-            loc_ids = ret_ids
-    return tree
-
-
-def find_id(loc_ids, layers) -> [bool, List[int], List[str]]:
-    found = False
-    indexes = []
-    ids = []
-    for loc_id in loc_ids:
-        for index, lay in enumerate(layers):
-            if loc_id in lay['dep_list']:
-                found = True
-                indexes.append(index)
-                ids.append(lay['id'])
-
-    return found, indexes, ids
-
-
-
+import re
+from typing import List
+import copy
+
+from stixorm.module.authorise import authorised_mappings
+
+from stixorm.module.orm.import_objects import sdo_to_data, sro_to_data, sco_to_data
+from stixorm.module.orm.import_utilities import split_on_activity_type, val_tql
+
+import logging
+
+from stixorm.module.typedb_lib.factories.auth_factory import get_auth_factory_instance
+
+logger = logging.getLogger(__name__)
+logger.setLevel(logging.INFO)
+##############################################################
+#  1.) Methods to Delete any Stix Objects
+############################################################
+
+#---------------------------------------------------
+# 1.0) Helper method to direct the right typeql method to an incoming Stix object
+#---------------------------------------------------
+
+
+def delete_stix_object(stix_object,
+                       dep_match: str,
+                       dep_insert: str,
+                       indep_ql: str,
+                       core_ql: str,
+                       import_type) -> [str, str]:
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    if stix_object.type in auth["types"]["sdo"]:
+        total_props, obj_tql, sdo_tql_name, protocol = sdo_to_data(stix_object, import_type)
+        var_name: List[str] = get_obj_var(indep_ql)
+        del_match, del_tql = delete_object(stix_object, core_ql, total_props, obj_tql, var_name, sdo_tql_name, import_type)
+    elif stix_object.type in auth["types"]["sro"]:
+        total_props, obj_tql, sro_tql_name, protocol = sro_to_data(stix_object, import_type)
+        var_name: List[str] = get_obj_var(dep_insert)
+        del_match, del_tql = delete_object(stix_object, core_ql, total_props, obj_tql, var_name, sro_tql_name, import_type)
+    elif stix_object.type in auth["types"]["sco"]:
+        total_props, obj_tql, sro_tql_name, protocol = sco_to_data(stix_object, import_type)
+        var_name: List[str] = get_obj_var(core_ql)
+        # Need to change this line to suit scenarios where object name is not type name (e.g. future)
+        del_match, del_tql = delete_object(stix_object, core_ql, total_props, obj_tql, var_name, sro_tql_name, import_type)
+    elif stix_object.type == 'marking-definition':
+        del_match, del_tql = delete_marking(stix_object, dep_match, dep_insert, indep_ql, core_ql, import_type)
+    else:
+        logger.error(f'object type not supported in delete stix object: {stix_object.type}')
+        logger.error(f' import type {dep_match + dep_insert + indep_ql + core_ql}')
+        del_match = del_tql = ""
+
+    return del_match, del_tql
+
+
+def delete_object(stix_object,
+                  core_ql: str,
+                  total_props,
+                  obj_tql,
+                  var_name: List[str],
+                  tql_name: str,
+                  import_type) -> [str, str]:
+    # 1.B) get the data model
+    properties, relations = split_on_activity_type(total_props, obj_tql)
+    # 2.0) MAtch in the object, the id and all attributes not owned by another object
+    del_match = 'match \n' + core_ql
+    del_match += var_name[0] + ' has $a;\n'
+    del_match += 'not { ' + var_name[0] + ' isa thing; $p2 isa thing, has $a; not {'
+    del_match += var_name[0] + ' is $p2;}; };\n\n'
+    del_tql = 'delete \n'
+    # 3.0) Now setup the match and delete statements for the local relations or  sub objects
+    for i, reln in enumerate(relations):
+        del_match2, del_tql2 = delete_sub_reln(reln, stix_object, var_name[0], i, import_type)
+        del_match += del_match2
+        del_tql += del_tql2
+
+    # 4.0) Now setup the delete and match for the actual attributes, stix-id and object in reverse
+    del_tql += '\n'
+    del_tql += var_name[0] + ' isa ' + tql_name + ';\n'
+    del_tql += '$a isa attribute;\n'
+    del_tql += '$stix-id isa stix-id;\n'
+
+    return del_match, del_tql
+
+
+def delete_marking(stix_object, dep_match, dep_insert, indep_ql, core_ql, import_type) -> [str, str]:
+    del_match = del_tql = ''
+    if stix_object.definition_type == "statement":
+        del_match = 'match \n$marking isa statement-marking'
+        del_match += ',\n has stix-id $stix-id; $stix-id ' + val_tql(stix_object.id)
+        del_match += ';\n$marking has $a;\n'
+        del_match += 'not { $marking isa thing; $p2 isa thing, has $a; not {'
+        del_match += '$marking is $p2;}; };\n\n'
+        del_tql = 'delete \n'
+        del_tql += '$marking isa statement-marking;\n'
+        del_tql += '$stix-id isa stix-id;\n'
+        del_tql += '$a isa attribute;\n'
+
+    return del_match, del_tql
+
+
+def get_obj_var(core_ql) -> List[str]:
+    m = re.findall(r"(\$[a-z\-0-9]+)\s+(.+)?isa\s+", core_ql,re.MULTILINE)
+    output = []
+    #logger.debug(f'local 1 -> {m}')
+    if m:
+        #logger.debug(f'local -> {m}')
+        for found in m:
+            output.append(found[0])
+            #logger.debug(f'Found first {found[0]}')
+
+    return output
+
+
+def get_tql_name(dep_insert):
+    m = re.findall(r"([a-z\-]+),$",dep_insert,re.MULTILINE)
+    output = []
+    #logger.debug(f'local 1 -> {m}')
+    if m:
+        for found in m:
+            output.append(found)
+            #logger.debug(f'Found name {found}')
+
+    return output
+
+
+def delete_sub_reln(rel, obj, obj_var, i, import_type):
+    """
+        Top level function to delete one of the sub objects from the stix object
+    Args:
+        rel (): the relation object to delete
+        obj (): the stix object to delete it from
+        obj_var (): the typeql variable string
+
+    Returns:
+        match: the typeql match string
+        delete: the typeql delete string
+    """
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    if rel == "granular_markings":
+        match, delete = del_granular_markings(obj_var)
+
+    # hashes type
+    elif (rel == "hashes"
+          or rel == "file_header_hashes"):
+        match, delete = del_hashes(rel, obj[rel], obj_var, i)
+
+    # insert key value store
+    elif rel in auth["reln_name"]["key_value_relations"]:
+        match, delete = del_key_value_store(rel, obj[rel], obj_var, i, import_type)
+
+    # insert list of object relation
+    elif rel in auth["reln_name"]["list_of_objects"]:
+        match, delete = del_list_of_object(rel, obj[rel], obj_var, i, import_type)
+
+    # insert embedded relations based on stix-id
+    elif rel in auth["reln_name"]["embedded_relations"]:
+        match, delete = del_embedded_relation(rel, obj[rel], obj_var, i, import_type)
+
+    # insert plain sub-object with relation
+    elif (rel == "x509_v3_extensions"
+          or rel == "optional_header"):
+        match, delete = del_load_object(rel, obj[rel], obj_var, i, import_type)
+
+    # insert  SCO Extensions here, a possible dict of sub-objects
+    elif rel in auth["reln_name"]["extension_relations"]:
+        match, delete = del_extensions(rel, obj[rel], obj_var, i, import_type)
+
+    # ignore the following relations as they are already processed, for Relationships, Sightings and Extensions
+    elif (rel == "sighting_of_ref"
+          or rel == "observed_data_refs"
+          or rel == "where_sighted_refs"
+          or rel == "source_ref"
+          or rel == "target_ref"
+          or rel == "definition"
+          or rel == "definition_type"):
+        match = delete = ''
+
+    else:
+        logger.error(f'relation type not known, rel -> {rel}')
+        match = delete = ""
+
+    return match, delete
+
+
+def del_granular_markings(obj_var):
+    match = '$granular (object:' + obj_var + ') isa granular-marking;\n'
+    delete = '$granular isa granular-marking;\n'
+
+    return match, delete
+
+
+def del_hashes(rel_name, rel_object, obj_var, i):
+    match = '$hash isa hash, has hash-value $h;\n'
+    match += '$hash_rel (owner:'+obj_var
+    match += ', pointed-to:$hash) isa hashes;\n'
+    delete = '$hash_rel isa hashes;\n'
+    delete += '$hash isa hash;\n'
+    return match, delete
+
+
+def del_key_value_store(rel_name, rel_object, obj_var, i, import_type):
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    for config in auth["reln"]["key_value_relations"]:
+        if config["name"] == rel_name:
+            rel_typeql = config["typeql"]
+            role_owner = config["owner"]
+            role_pointed = config["pointed_to"]
+            d_key = config["key"]
+            d_value = config["value"]
+            break
+
+    key_var = '$' + d_key + str(i)
+    val_var = ' $' + d_value + str(i)
+    match = key_var + ' isa ' + d_key + ';\n'
+    match += key_var + ' has ' + d_value + val_var + ';\n'
+    match += '$' + rel_typeql + ' (' + role_owner + ':' + obj_var
+    match += ', ' + role_pointed + ':' + key_var
+    match += ') isa ' + rel_typeql + ';\n\n'
+    delete = '\n'
+    delete += '$' + rel_typeql + ' isa ' + rel_typeql + ';\n'
+    #delete += val_var + ' isa ' + d_value + ';\n'
+    #delete += key_var + ' isa ' + d_key + ';\n'
+
+    return match, delete
+
+
+def del_list_of_object(rel_name, prop_value_list, parent_var, i, import_type):
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    logger.debug(f'rl name -> {rel_name}')
+    for config in auth["reln"]["list_of_objects"]:
+        if config["name"] == rel_name:
+            rel_typeql = config["typeql"]
+            role_owner = config["owner"]
+            role_pointed = config["pointed_to"]
+            typeql_obj = config["object"]
+            obj_props_tql = copy.deepcopy(auth["sub_objects"][typeql_obj])
+            break
+    lod_list = []
+    match = delete = ''
+    for j, dict_instance in enumerate(prop_value_list):
+        lod_var = '$' + typeql_obj + str(j)
+        lod_list.append(lod_var)
+        match += lod_var + ' isa ' + typeql_obj + ';\n'
+        for key in dict_instance:
+            typeql_prop = obj_props_tql[key]
+            if typeql_prop == '':
+                # split off for relation processing
+                match2, delete2 = delete_sub_reln(key, dict_instance, lod_var, i + j, import_type)
+                # then add it back together
+                match = match + match2
+                delete = delete + "\n" + delete2 + "\n"
+        delete += lod_var + ' isa ' + typeql_obj + ';\n'
+
+    loc_var = '$' + typeql_obj + str(i)
+    #match += loc_var + ' isa ' + typeql_obj + ';\n'
+    #match += loc_var + ' has $b' + str(i) + ';\n'
+    #match += 'not { ' + loc_var + ' isa thing; $lob' + str(i) + ' isa thing, has $b' + str(i) + '; not {'
+    #match += loc_var + ' is $lob' + str(i) + ';}; };\n\n'
+
+    match += '\n $' + rel_typeql + str(i) + ' (' + role_owner + ':' + parent_var
+    for lod_var in lod_list:
+        match += ', ' + role_pointed + ':' + lod_var
+    match += ') isa ' + rel_typeql + ';\n'
+
+    #delete += loc_var + ' isa ' + typeql_obj + ';\n'
+    #delete += '$b' + str(i) + ' isa attribute; \n'
+    delete += '$' + rel_typeql + str(i) + ' isa ' + rel_typeql + ';\n'
+
+    return match, delete
+
+
+def del_embedded_relation(rel_name, rel_object, obj_var, i, import_type):
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    for ex in auth["reln"]["embedded_relations"]:
+      if ex["rel"] == rel_name:
+        owner = ex["owner"]
+        relation = ex["typeql"]
+        break
+    loc_var = '$' + relation + str(i)
+    match = loc_var + ' (' + owner + ':' + obj_var + ') isa ' + relation + ';\n'
+    delete = loc_var + ' isa ' + relation + ';\n'
+
+    return match, delete
+
+
+def del_load_object(prop_name, prop_dict, parent_var, i, import_type):
+    # as long as it is predefined, history the object
+    #logger.debug('------------------- history object ------------------------------')
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    logger.debug(f'prop dict {prop_dict}')
+    for prop_type in auth["reln"]["extension_relations"]:
+        if prop_name == prop_type["stix"]:
+            tot_prop_list = [tot for tot in prop_dict.keys()]
+            obj_name = prop_type["object"]
+            obj_tql = copy.deepcopy(auth["sub_objects"][obj_name])
+            obj_var = '$' + obj_name
+            reln = prop_type["relation"]
+            rel_var = '$' + reln
+            rel_owner = prop_type["owner"]
+            rel_pointed_to = prop_type["pointed-to"]
+
+            match = obj_var + ' isa ' + prop_type["object"] + ';\n'
+            #match += obj_var + ' has $d' + str(i) + ';\n'
+            #match += 'not { ' + obj_var + ' isa thing; $lobj' + str(i) + ' isa thing, has $d' + str(i) + '; not {'
+            #match += obj_var + ' is $lobj' + str(i) + ';}; };\n\n'
+
+            match += rel_var + ' (' + rel_owner + ':' + parent_var
+            match += ', ' + rel_pointed_to + ':' + obj_var + ')'
+            match += ' isa ' + reln + ';\n'
+
+            # Split them into properties and relations
+            properties, relations = split_on_activity_type(prop_dict, obj_tql)
+            delete = ''
+
+            # add each of the relations to the match and insert statements
+            for rel in relations:
+                # split off for relation processing
+                match2, delete2= delete_sub_reln(rel, prop_dict, obj_var, i+1)
+                # then add it back together
+                match = match + match2
+                delete = delete + "\n" + delete2
+
+            # finally, connect the local object to the parent object
+            #delete = '$d' + str(i) + ' isa attribute;\n'
+            delete += rel_var + ' isa ' + reln + ';\n'
+            delete += obj_var + ' isa ' + prop_type["object"] + ';\n'
+
+            break
+
+    return match, delete
+
+
+def del_extensions(prop_name, prop_dict, parent_var, i, import_type):
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    match = ''
+    delete = ''
+    # for each key in the dict (extension type)
+    # logger.debug('--------------------- extensions ----------------------------')
+    for ext_type in prop_dict:
+        for ext_type_ql in auth["reln"]["extension_relations"]:
+            if ext_type == ext_type_ql["stix"]:
+                match2, delete2 = del_load_object(ext_type, prop_dict[ext_type], parent_var, i)
+                match = match + match2
+                delete = delete + delete2
+                break
+    return match, delete
+
+
+def add_delete_layers(layers, dep_obj, indexes, missing):
+    logger.debug("################################### enter add_layers ###############################################")
+    logger.debug(f'\nlayers -> {layers}')
+    logger.debug(f'\ndep_obj -> {dep_obj}')
+    logger.debug(f'indexes -> {indexes}')
+    logger.debug(f'missing -> {missing}')
+    logger.debug("-------------------------------  ------------------------------------------------")
+    # Stage 1 - Initialise Variables
+    # 1. Setup key variables
+    loc_id = dep_obj['id']
+    loc_list = dep_obj["dep_list"]
+    locset = set(loc_list)
+    mset = set(missing)
+    iset = set(indexes)
+    intset = locset.intersection(iset)
+    diffset = locset.difference(intset)
+    # Stage 2 - Analyse Choices
+    # 2. check whether the object has dependencies in its dep_list
+    if not loc_list:
+        dep_list_items = False
+        logger.debug('### There are no dependencies')
+    else:
+        dep_list_items = True
+        logger.debug('### There are some dependencies')
+    # 3. check whether the object id is in the missing list
+    if loc_id in mset:
+        id_in_missing = True
+        logger.debug('### Current is the missing dependency of an existing record')
+    else:
+        id_in_missing = False
+        logger.debug('### Current is not a missing dependency of an existing record')
+    # 4. check whether any id in the object dependency list is not already loaded
+    if not diffset:
+        dep_id_not_loaded = False
+        logger.debug('### No dependencies need to be added to missing')
+    else:
+        dep_id_not_loaded = True
+        mset = mset | diffset
+        logger.debug('### Missing - Some dependencies need to be added to missing')
+
+    # Stage 3 - Execute Choices
+    # 5. No dependencies and not in missing, append only
+    if not dep_list_items and not id_in_missing:
+        logger.debug('### Append object and return')
+        layers.append(dep_obj)
+        indexes.append(loc_id)
+        logger.debug(f'layers -> {layers}')
+        logger.debug(f'indexes -> {indexes}')
+        logger.debug(f'mset -> {mset}')
+        logger.debug("################################## end of  add_layers ####################################################")
+        return layers, indexes, list(mset)
+    # 6. There are no dependencies but id is in missing, delete from missing,follow the tree and reorder
+    if not dep_list_items and id_in_missing:
+        logger.debug('### delete from missing,follow the tree and reorder')
+        mset.remove(loc_id)
+        tree = follow_the_tree(layers, dep_obj)
+        logger.debug(f' tree -> {tree}')
+        layers, indexes = reorder(layers, indexes, tree, dep_obj)
+        logger.debug(f'layers -> {layers}')
+        logger.debug(f'indexes -> {indexes}')
+        logger.debug(f'mset -> {mset}')
+        logger.debug("################################## end of  add_layers ####################################################")
+        return layers, indexes, list(mset)
+    # 7 There are dependencies, object is not in missing, insert at front
+    if dep_list_items and not id_in_missing:
+        logger.debug('### Add current to the front of the record')
+        layers.insert(0, dep_obj)
+        indexes.insert(0, loc_id)
+        logger.debug(f'layers -> {layers}')
+        logger.debug(f'indexes -> {indexes}')
+        logger.debug(f'mset -> {mset}')
+        logger.debug("################################## end of  add_layers ####################################################")
+        return layers, indexes, list(mset)
+    # 8 There are dependencies, object is in missing , delete from missing,follow the tree and reorder
+    if dep_list_items and id_in_missing:
+        logger.debug('### delete from missing,follow the tree and reorder')
+        mset.remove(loc_id)
+        tree = follow_the_tree(layers, dep_obj)
+        logger.debug(f' tree -> {tree}')
+        layers, indexes = reorder(layers, indexes, tree, dep_obj)
+        logger.debug(f'layers -> {layers}')
+        logger.debug(f'indexes -> {indexes}')
+        logger.debug(f'mset -> {mset}')
+        logger.debug("################################## end of  add_layers ####################################################")
+        return layers, indexes, list(mset)
+
+    logger.debug("theres a massive problem")
+    return layers, indexes, list(mset)
+
+
+def reorder(layers, indexes, tree, dep_obj):
+    front_layers = []
+    front_indexes = []
+    tree = list(set(tree))
+    logger.debug("%%%%%%%%%%%%%%% reorder 1 %%%%%%%%%%%%%%%%%%")
+    logger.debug(f'\n orig indexes -> {indexes}')
+    logger.debug(f"\n orig layers, {layers}")
+    logger.debug(f"\n dep_obj , {dep_obj}")
+    logger.debug("%%%%%%%%%%%%%%% reorder 2 %%%%%%%%%%dep_obj%%%%%%%%")
+    # 1. Copy elements from layers and indexes so they are in the order we want them
+    for t in reversed(tree):
+        front_layers.append(layers[t])
+        front_indexes.append(indexes[t])
+    # 2. Now order the tree in reverse numeric order, biggest first
+    tree.sort(reverse=True)
+    # 3. Now delete the elements from layers and indexes
+    for t in tree:
+        layers.pop(t)
+        indexes.pop(t)
+    # 4. Add the dep_obj to the new lists
+    front_indexes.append(dep_obj['id'])
+    front_layers.append(dep_obj)
+    # 5. Assemble the final lists
+    logger.debug(f'\nfront_indexes -> {front_indexes}')
+    logger.debug(f"\nfront_layers, {front_layers}")
+    logger.debug(f"\n old layers, {layers}")
+    logger.debug(f'\nold indexes -> {indexes}')
+    logger.debug("-------------------------------------------------------------------------------------")
+    layers = front_layers + layers
+    indexes = front_indexes + indexes
+    #logger.debug(f"\nlayers, {layers}")
+    #logger.debug(f'\nindexes -> {indexes}')
+    logger.debug("%%%%%%%%%%%%%%% end reorder %%%%%%%%%%%%%%%%%%")
+    return layers, indexes
+
+
+def follow_the_tree(layers, dep_obj):
+    tree = []
+    loc_id = dep_obj['id']
+    loc_ids = [loc_id]
+    found = True
+    while found:
+        found, ret_indexes, ret_ids = find_id(loc_ids, layers)
+        logger.debug(f'### Following Tree, found {found},index {ret_indexes}, loc_id {ret_ids}')
+        if found:
+            tree = tree + ret_indexes
+            loc_ids = ret_ids
+    return tree
+
+
+def find_id(loc_ids, layers) -> [bool, List[int], List[str]]:
+    found = False
+    indexes = []
+    ids = []
+    for loc_id in loc_ids:
+        for index, lay in enumerate(layers):
+            if loc_id in lay['dep_list']:
+                found = True
+                indexes.append(index)
+                ids.append(lay['id'])
+
+    return found, indexes, ids
+
+
+
```

### Comparing `stixorm-0.1.3/stixorm/module/orm/export_object.py` & `stixorm-0.1.9/stixorm/module/orm/export_object.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,854 +1,854 @@
-import json
-import pathlib
-import traceback
-from typing import List
-import copy
-
-from stixorm.module.authorise import authorised_mappings
-from stixorm.module.parsing.conversion_decisions import sdo_type_to_tql, sro_type_to_tql, sco__type_to_tql, meta_type_to_tql
-from stixorm.module.orm.export_utilities import convert_ans_to_res
-import logging
-
-from stixorm.module.typedb_lib.factories.auth_factory import get_auth_factory_instance
-from stixorm.module.typedb_lib.factories.import_type_factory import ImportType
-
-logger = logging.getLogger(__name__)
-
-
-###################################################################################################
-#
-#    TypeQL to Stix Mapping
-#
-###################################################################################################
-
-
-# --------------------------------------------------------------------------------------------------------
-#  Overview:
-#     1. Convert TypeQL Ans to Res, using the transaction
-#     2. Convert Res to Stix, creating first the dict, then parsing the dict to Stix object
-# --------------------------------------------------------------------------------------------------------
-
-
-def convert_ans_to_stix(query, answer_iterator, r_tx, import_type: ImportType):
-    """
-        High level function to convert the typedb_lib return into a Stix object.
-        Firstly, drive the grpc to make an intermediate format, then convert that to a Stix dict
-    Args:
-        answer_iterator (): the returned iterator from the typedb_lib query
-        r_tx (): the transaction
-        import_type (): the type of import STIX21 or ATT&CK
-
-    Returns:
-        stix_dict {}: a dict containing the stix object
-    """
-    res = convert_ans_to_res(answer_iterator, r_tx, import_type)
-    path = pathlib.Path(__file__).parent.joinpath("export_test.json")
-    #with open(str(path), 'w') as outfile:
-    #    json.dump(res, outfile)
-    logger.debug(f'got res, now for stix')
-    stix_dict = convert_res_to_stix(res, import_type)
-    logger.debug((f'got stix now for object'))
-    logger.debug("=========================================")
-    json_object = json.dumps(stix_dict, indent=4)
-    logger.debug(json_object)
-    logger.debug("=========================================")
-    return json_object
-
-
-# --------------------------------------------------------------------------------------------------------
-#  2. Convert Res to Stix
-# --------------------------------------------------------------------------------------------------------
-
-def convert_res_to_stix(res: List[dict], import_type: ImportType):
-    """
-        High level function to conver the intermediate form into a stix dict
-    Args:
-        res (): the intermediate form
-        import_type (): the type of import "STIX21" or "ATT&CK"
-
-    Returns:
-        stix_dict {}: a dict containing the stix object
-    """
-
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    stix_dict = {}
-    for obj in res:
-        obj_type = obj["T_name"]
-        tql_type = obj["type"]
-        if obj_type in auth["tql_types"]["sdo"]:
-            stix_dict = make_sdo(obj, import_type)
-        elif obj_type in auth["tql_types"]["sco"]:
-            stix_dict = make_sco(obj, import_type)
-        elif tql_type in auth["tql_types"]["sro"] or tql_type == 'relationship':
-            stix_dict = make_sro(obj, import_type)
-        elif obj_type in auth["tql_types"]["meta"] or obj_type == "statement-marking":
-            stix_dict = make_meta(obj, import_type)
-        else:
-            logger.error(f'Unknown object type: {obj}')
-
-    logger.debug(f'\n\n')
-    logger.debug(f'stix dict -> {stix_dict}\n')
-    return stix_dict
-
-
-def make_sdo(res, import_type: ImportType):
-    """
-        High-level function to convert intermediate format into a Stix domain object
-    Args:
-        res (): intermediate format
-        import_type (): the type of import "STIX21" or "ATT&CK"
-
-    Returns:
-        stix_dict {}: a dict containing the stix object
-    """
-    try:
-        auth_factory = get_auth_factory_instance()
-        auth = auth_factory.get_auth_for_import(import_type)
-        stix_dict = {}
-        # 2.A) get the typeql properties and relations
-        sdo_tql_name = res["T_name"]
-        sdo_type = ""
-        for model in auth["conv"]["sdo"]:
-            if model["typeql"] == sdo_tql_name:
-                sdo_type = model["type"]
-        props = res["has"]
-        relns = res["relns"]
-        attack_object = False
-        sub_technique = False
-        for prop in props:
-            if prop["typeql"] == "x-mitre-version":
-                attack_object = True
-            if prop["typeql"] == "x-mitre-is-subtechnique" and prop["value"] is True:
-                sub_technique = True
-
-        obj_tql, sdo_tql_name, is_list, protocol = sdo_type_to_tql(sdo_type, import_type, attack_object, sub_technique)
-
-        #logger.debug(f"obj tql -> {obj_tql}\n sdo tql name -> {sdo_tql_name}")
-        # 2.B) get the is_list list, the list of properties that are lists for that object
-        #is_list = auth["is_lists"]["sdo"]["sdo"] + auth["is_lists"]["sdo"][sdo_tql_name]
-        # 3.A) add the properties onto the the object
-        stix_dict = make_properties(props, obj_tql, stix_dict, is_list)
-        #logger.debug(f'sdo, add properties, stix_dict -> {stix_dict}\n')
-        # 3.B) add the relations onto the object
-        stix_dict = make_relations(relns, obj_tql, stix_dict, is_list, sdo_tql_name, import_type)
-        #logger.debug(f'sdo, add relations, , stix_dict -> {stix_dict}\n')
-        # 4.0 Check for the edge case where an identity creates an identity, but they are the same id
-        if "created_by_ref" in stix_dict and stix_dict["type"] == "identity":
-            if stix_dict["created_by_ref"] == stix_dict["id"]:
-                del stix_dict["created_by_ref"]
-    except Exception as e:
-        logger.exception(e)
-
-    return stix_dict
-
-
-def make_sro(res, import_type: ImportType):
-    """
-        High-level function to convert intermediate format into a Stix relationship object
-    Args:
-        res (): intermediate format
-        import_type (): the type of import "STIX21" or "ATT&CK"
-
-    Returns:
-        stix_dict {}: a dict containing the stix object
-    """
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    stix_dict = {}
-    # 2.A) get the typeql properties and relations
-    sro_tql_name = res["type"]
-    sro_type = ""
-    props = res["has"]
-    relns = res["relns"]
-    sro_sub_rel = ""
-    if sro_tql_name in auth["tql_types"]["relations_sro_roles"]:
-        sro_sub_rel = sro_tql_name
-        sro_type = "relationship"
-    elif sro_tql_name == "relationship":
-        sro_type = "relationship"
-        for has in props:
-            if has["typeql"] == "relationship-type":
-                sro_sub_rel = has["value"]
-                logger.debug(f'found relationship type -> {sro_sub_rel}\n')
-                break
-    else:
-        sro_type = "sighting"
-    #
-    # Note, Issue, cannot yet tell what to do with a procedure
-    #
-    attack_object = False
-    uses_relation = False
-    if sro_tql_name == "procedire":
-        sro_sub_rel = sro_tql_name
-        is_procedure = True
-    else:
-        is_procedure = False
-    for prop in props:
-        if prop["typeql"] == "x-mitre-version":
-            attack_object = True
-
-    obj_tql, sro_tql_name, is_list, protocol = sro_type_to_tql(sro_type, sro_sub_rel, import_type, attack_object, uses_relation, is_procedure)
-
-    logger.debug(f'make sro obj_tql ->{obj_tql}\n sro tql name ->{sro_tql_name}')
-    # 2.A) get the typeql properties and relations
-    props = res["has"]
-    relns = res["relns"]
-    edges = res["edges"]
-    # 2.) setup the match statements first, depending on whether the object is a sighting or a relationship
-    # A. If it is a Relationship then find the source and target roles for the relation, and match them in
-    if sro_tql_name in auth["reln_name"]["standard_relations"]:
-        for stix_rel in auth["reln"]["standard_relations"]:
-            if stix_rel["stix"] == sro_tql_name:
-                source_role = stix_rel["source"]
-                target_role = stix_rel["target"]
-                break
-
-        for edge in edges:
-            players = edge["player"]
-            if edge["role"] == source_role:
-                for p in players:
-                    stix_dict["source_ref"] = p["stix_id"]
-                    break
-
-            elif edge["role"] == target_role:
-                for p in players:
-                    stix_dict["target_ref"] = p["stix_id"]
-                    break
-            else:
-                logger.error(f'edge role {edge["role"]} not supported')
-                return ''
-
-    # B. If it is a Sighting then match the object to the sighting
-    elif sro_tql_name == 'sighting':
-        is_list = copy.deepcopy(auth["is_lists"]["sro"]["sro"]) + copy.deepcopy(auth["is_lists"]["sro"]["sighting"])
-        for edge in edges:
-            players = edge["player"]
-            if edge["role"] == "sighting-of":
-                for p in players:
-                    stix_dict["sighting_of_ref"] = p["stix_id"]
-
-            elif edge["role"] == "where-sighted":
-                for p in players:
-                    if "where_sighted_refs" in stix_dict:
-                        stix_dict["where_sighted_refs"].append(p["stix_id"])
-                    else:
-                        stix_dict["where_sighted_refs"] = []
-                        stix_dict["where_sighted_refs"].append(p["stix_id"])
-            elif edge["role"] == "observed":
-                for p in players:
-                    if "observed_data_refs" in stix_dict:
-                        stix_dict["observed_data_refs"].append(p["stix_id"])
-                    else:
-                        stix_dict["observed_data_refs"] = []
-                        stix_dict["observed_data_refs"].append(p["stix_id"])
-            else:
-                logger.error(f'edge role {edge["role"]} not supported')
-                return ''
-
-    else:
-        logger.error(f'relationship type {sro_tql_name} not supported')
-        return ''
-
-    # 3.A) add the properties onto the the object
-    stix_dict = make_properties(props, obj_tql, stix_dict, is_list)
-    # 3.B) add the relations onto the object
-    stix_dict = make_relations(relns, obj_tql, stix_dict, is_list, sro_tql_name, import_type)
-    return stix_dict
-
-
-def make_sco(res: dict, import_type: ImportType):
-    """
-        High-level function to convert intermediate format into a Stix cyber observable object
-    Args:
-        res (): intermediate format
-        import_type (): the type of import "STIX21" or "ATT&CK"
-
-    Returns:
-        stix_dict {}: a dict containing the stix object
-    """
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    # - work out the type of object
-    stix_dict = {}
-    obj_type = res["T_name"]
-    # - get the object-specific typeql names, sighting or relationship
-    # - work out the type of object
-    sco_tql_name = obj_type
-    # - get the object-specific typeql names, sighting or relationship
-    obj_tql, sco_tql_name, is_list, protocol = sco__type_to_tql(sco_tql_name, import_type)
-
-    # 2.A) get the typeql properties and relations
-    props = res["has"]
-    relns = res["relns"]
-
-    is_list = copy.deepcopy(auth["is_lists"]["sco"]["sco"]) + copy.deepcopy(auth["is_lists"]["sco"][obj_type])
-    # 3.A) add the properties onto the the object
-    stix_dict = make_properties(props, obj_tql, stix_dict, is_list)
-    # 3.B) add the relations onto the object
-    stix_dict = make_relations(relns, obj_tql, stix_dict, is_list, obj_type, import_type)
-    return stix_dict
-
-
-colours_dict = {
-    "tlp-amber": {"type": "marking-definition", "spec_version": "2.1",
-                  "id": "marking-definition--f88d31f6-486f-44da-b317-01333bde0b82",
-                  "created": "2017-01-20T00:00:00.000Z", "definition_type": "tlp",
-                  "name": "TLP:AMBER", "definition": {"tlp": "amber"}},
-    "tlp-green": {"type": "marking-definition", "spec_version": "2.1",
-                  "id": "marking-definition--34098fce-860f-48ae-8e50-ebd3cc5e41da",
-                  "created": "2017-01-20T00:00:00.000Z", "definition_type": "tlp",
-                  "name": "TLP:GREEN", "definition": {"tlp": "green"}},
-    "tlp-white": {"type": "marking-definition", "spec_version": "2.1",
-                  "id": "marking-definition--613f2e26-407d-48c7-9eca-b8e91df99dc9",
-                  "created": "2017-01-20T00:00:00.000Z", "definition_type": "tlp",
-                  "name": "TLP:WHITE", "definition": {"tlp": "white"}},
-    "tlp-red": {"type": "marking-definition", "spec_version": "2.1",
-                "id": "marking-definition--5e57c739-391a-4eb3-b6be-7d15ca92d5ed",
-                "created": "2017-01-20T00:00:00.000Z", "definition_type": "tlp",
-                "name": "TLP:RED", "definition": {"tlp": "red"}}
-}
-
-
-def make_meta(res, import_type: ImportType):
-    """
-        High-level function to convert intermediate format into a Stix meta object
-    Args:
-        res (): intermediate format
-        import_type (): the type of import "STIX21" or "ATT&CK"
-
-    Returns:
-        stix_dict {}: a dict containing the stix object
-    """
-    stix_dict = {}
-
-    obj_type = res["T_name"]
-    props = res["has"]
-    relns = res["relns"]
-    attack_object = False
-    if obj_type == "tlp-white" or obj_type == "tlp-green" or obj_type == "tlp-amber" or obj_type == "tlp-red":
-        return colours_dict[obj_type]
-    j=0
-    tmp_val = ""
-    for i, prop in enumerate(props):
-        if prop["typeql"] == "x-mitre-attack-spec-version":
-            attack_object = True
-        elif prop["typeql"] == "statement":
-            tmp_val = prop["value"]
-            j = i
-
-    if tmp_val != "":
-        del props[j]
-
-    obj_tql, sdo_tql_name, is_list, protocol = meta_type_to_tql(obj_type, import_type, attack_object)
-
-    # Add the properties onto the the object
-    stix_dict = make_properties(props, obj_tql, stix_dict, is_list)
-    # Add the relations onto the object
-    stix_dict = make_relations(relns, obj_tql, stix_dict, is_list, obj_type, import_type)
-
-    if tmp_val != "":
-        stix_dict["definition"] = {"statement": tmp_val}
-        stix_dict["definition_type"] = "statement"
-
-    return stix_dict
-
-
-def make_properties(props, obj_tql, stix_dict, is_list: bool):
-    """
-        Unpack properties for a stix object (i.e. values at the 'has' level)
-    Args:
-        props (): a list of proeprties
-        obj_tql (): the tql that describes the object
-        stix_dict (): the stix dict that we are building
-        is_list (): a list of the properties that are lists
-
-    Returns:
-        stix_dict {}: a dict containing the stix object
-    """
-    for prop in props:
-        prop_tql_name = prop["typeql"]
-        prop_value = prop["value"]
-        for stix_name, stix_value in obj_tql.items():
-            if prop_tql_name == stix_value:
-                # if property is a list, then
-                if stix_name in is_list:
-                    if stix_name not in stix_dict:
-                        stix_dict[stix_name] = []
-                        stix_dict[stix_name].append(prop_value)
-                        break
-                    else:
-                        stix_dict[stix_name].append(prop_value)
-                        break
-                # else property is a value, not a list
-                else:
-                    stix_dict[stix_name] = prop_value
-
-    return stix_dict
-
-
-def make_relations(relns, obj_tql, stix_dict, is_list, obj_name, import_type: ImportType):
-    """
-        Overall branching function for processing all the sub objects
-    Args:
-        relns (): the list of relations to process
-        obj_tql (): the object tql for this stix object
-        stix_dict (): the stix dict we are building
-        is_list (): the list of properties that are a list
-        obj_name (): the stix object these sub objects belong to
-
-    Returns:
-        stix_dict {}: a dict containing the stix object
-    """
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    for reln in relns:
-        reln_name = reln["T_name"]
-        if reln_name in auth["tql_types"]["embedded_relations"]:
-            stix_dict = make_embedded_relations(reln, reln_name, stix_dict, is_list, obj_name, import_type)
-
-        elif reln_name in auth["tql_types"]["standard_relations"] or reln_name == "sighting":
-            stix_dict = make_standard_relations(reln, reln_name, stix_dict, is_list, obj_name, import_type)
-
-        elif reln_name in auth["tql_types"]["key_value_relations"]:
-            stix_dict = make_key_value_relations(reln, reln_name, stix_dict, is_list, obj_name, import_type)
-
-        elif reln_name in auth["tql_types"]["list_of_objects"]:
-            stix_dict = make_list_of_objects(reln, reln_name, stix_dict, is_list, obj_name, import_type)
-
-        elif reln_name == "v3-extensions" or reln_name == "optional-headers":
-            stix_dict = make_object(reln, reln_name, stix_dict, is_list, obj_name, import_type)
-
-        elif reln_name in auth["tql_types"]["extension_relations"]:
-            stix_dict = make_extension_relations(reln, reln_name, stix_dict, is_list, obj_name, import_type)
-
-        elif reln_name == "granular-marking":
-            stix_dict = make_granular_marking(reln, reln_name, stix_dict, is_list, obj_tql, obj_name)
-
-        elif reln_name == "hashes" or reln_name == "file-header-hashes":
-            stix_dict = make_hashes(reln, reln_name, stix_dict)
-
-        else:
-            logger.error(f'Error, relation name is {reln_name}')
-            break
-
-    return stix_dict
-
-
-def make_embedded_relations(reln, reln_name, stix_dict, is_list: bool, obj_name, import_type: ImportType):
-    """
-        Setup embedded relations based on stix-id's
-    Args:
-        reln (): relation object
-        reln_name (): relation name
-        stix_dict (): stix dict being built
-        is_list (): list of parameters that are lists
-        obj_name (): stix object that owns the embedded relation
-
-    Returns:
-        stix_dict {}: a dict containing the stix object
-    """
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    stix_object_type = obj_name
-    for embedded_r in auth["reln"]["embedded_relations"]:
-        if reln_name == embedded_r["typeql"]:
-            role_pointed = embedded_r["pointed-to"]
-            stix_name = embedded_r["rel"]
-            role_owner = embedded_r["owner"]
-
-    roles = reln["roles"]
-    for role in roles:
-        if role["role"] == role_pointed:
-            pointed = role
-        elif role["role"] == role_owner:
-            owner = role
-        else:
-            logger.error(f'unsupported role in embedded relation {role["role"]}')
-
-    # 1. Is Owner correct, basically my super object?
-    # - should be only one object in the owner role list, and its type is the same as my super object type
-    own_players = owner["player"]
-    own_player = own_players[0]
-    if own_player['tql'] == stix_object_type:
-        # 2. If 1 is yes, then we want to find the emebedded relation, else not
-        pointed_players = pointed["player"]
-        for p in pointed_players:
-            prop_value = p['stix_id']
-            # if property is a list, then
-            if stix_name in is_list:
-                if stix_name not in stix_dict:
-                    stix_dict[stix_name] = []
-                    stix_dict[stix_name].append(prop_value)
-
-                else:
-                    stix_dict[stix_name].append(prop_value)
-
-            # else property is a value, not a list
-            else:
-                stix_dict[stix_name] = prop_value
-    else:
-        return stix_dict
-
-    return stix_dict
-
-
-def make_standard_relations(reln, reln_name, stix_dict, is_list, obj_name, import_type: ImportType):
-    #logger.warning(" make standard relations visited, but not implemented")
-    return stix_dict
-
-
-def make_key_value_relations(reln, reln_name, stix_dict, is_list, obj_type, import_type: ImportType):
-    """
-        Setup embedded relations based on stix-id's
-    Args:
-        reln (): relation object
-        reln_name (): relation name
-        stix_dict (): stix dict being built
-        is_list (): list of parameters that are lists
-        obj_type (): stix object that owns the embedded relation
-
-    Returns:
-        stix_dict {}: a dict containing the stix object
-    """
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    for kv_obj in auth["reln"]["key_value_relations"]:
-        if reln_name == kv_obj["typeql"]:
-            role_pointed = kv_obj["pointed_to"]
-            reln_owner = kv_obj["owner"]
-            key_name = kv_obj["key"]
-            val_name = kv_obj["value"]
-            stix_field_name = kv_obj["name"]
-            break
-
-    roles = reln["roles"]
-    dict_of_kv = {}
-    for role in roles:
-        if role["role"] == role_pointed:
-            players = role["player"]
-            for p in players:
-                key_value = p["value"]
-                props = p['props']
-                prop_list = []
-                if len(props) > 1:
-                    for prop in props:
-                        val_value = prop["value"]
-                        prop_list.append(val_value)
-
-                    dict_of_kv[key_value] = prop_list
-
-                else:
-                    val_value = props[0]["value"]
-                    dict_of_kv[key_value] = val_value
-
-    stix_dict[stix_field_name] = dict_of_kv
-    return stix_dict
-
-
-def make_extension_relations(reln, reln_name, stix_dict, is_list, obj_type, import_type: ImportType):
-    """
-        Setup extension relations based on stix-id's
-    Args:
-        reln (): relation object
-        reln_name (): relation name
-        stix_dict (): stix dict being built
-        is_list (): list of parameters that are lists
-        obj_type (): stix object that owns the embedded relation
-
-    Returns:
-        stix_dict {}: a dict containing the stix object
-    """
-    logger.debug("make extension relations visited")
-
-    local_dict = {}
-    local_dict = make_object(reln, reln_name, local_dict, is_list, obj_type, import_type)
-    stix_dict["extensions"] = local_dict
-    return stix_dict
-
-
-def make_object(reln, reln_name, stix_dict, is_list, obj_type, import_type: ImportType):
-    """
-        Setup a sub object
-    Args:
-        reln (): relation object
-        reln_name (): relation name
-        stix_dict (): stix dict being built
-        is_list (): list of parameters that are lists
-        obj_type (): stix object that owns the embedded relation
-
-    Returns:
-        stix_dict {}: a dict containing the stix object
-    """
-    logger.debug("make object visited")
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    for ext_obj in auth["reln"]["extension_relations"]:
-        if reln_name == ext_obj["relation"]:
-            role_pointed = ext_obj["pointed-to"]
-            role_owner = ext_obj["owner"]
-            ext_object = ext_obj["object"]
-            stix_ext_name = ext_obj["stix"]
-            obj_is_list = copy.deepcopy(auth["is_lists"]["sub"][ext_object])
-            break
-
-    if ext_object in auth["sub_objects"]:
-        obj_props_tql = copy.deepcopy(auth["sub_objects"][ext_object])
-    else:
-        raise ValueError("no sub-object available")
-    roles = reln["roles"]
-    ext_data_object = {}
-    for role in roles:
-        if role["role"] == role_pointed:
-            players = role["player"]
-            for p in players:
-                player = {}
-                # get properties for the sub object
-                props = p['has']
-                for prop in props:
-                    prop_name = prop["typeql"]
-                    prop_stix_name = prop_value = None
-                    for stix, tql in obj_props_tql.items():
-                        if prop_name == tql:
-                            prop_stix_name = stix
-                            prop_value = prop["value"]
-                            break
-                    # if property is a list, then
-                    if prop_stix_name in obj_is_list:
-                        if prop_stix_name not in player:
-                            player[prop_stix_name] = []
-                            player[prop_stix_name].append(prop_value)
-
-                        else:
-                            player[prop_stix_name].append(prop_value)
-
-                    # else property is a value, not a list
-                    else:
-                        player[prop_stix_name] = prop_value
-                # now look to see if there are relations
-                obj_relns = [k for k, v in obj_props_tql.items() if v == ""]
-                sub_relns = p['relns']
-                obj_tql = copy.deepcopy(auth["sub_objects"][ext_object])
-                new_dict = {}
-                new_dict = make_relations(sub_relns, obj_tql, new_dict, is_list, ext_object, import_type)
-                for k, v in new_dict.items():
-                    player[k] = v
-
-    stix_dict[stix_ext_name] = player
-    return stix_dict
-
-
-def make_list_of_objects(reln, reln_name, stix_dict, is_list, obj_type, import_type: ImportType):
-    """
-    Args:
-        Setup a list of sub objects
-        reln (): relation object
-        reln_name (): relation name
-        stix_dict (): stix dict being built
-        is_list (): list of parameters that are lists
-        obj_type (): stix object that owns the embedded relation
-
-    Returns:
-        stix_dict {}: a dict containing the stix object
-    """
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    for l_obj in auth["reln"]["list_of_objects"]:
-        if reln_name == l_obj["typeql"]:
-            role_pointed = l_obj["pointed_to"]
-            reln_object = l_obj["object"]
-            stix_field_name = l_obj["name"]
-            obj_is_list = copy.deepcopy(auth["is_lists"]["sub"][reln_object])
-            logger.debug("obj_is_list: {}".format(obj_is_list))
-            logger.debug("reln_object: {}".format(reln_object))
-            logger.debug("stix_field_name: {}".format(stix_field_name))
-            logger.debug("role_pointed: {}".format(role_pointed))
-            break
-
-    if reln_object in auth["sub_objects"]:
-        obj_props_tql = copy.deepcopy(auth["sub_objects"][reln_object])
-    else:
-        raise ValueError("no sub-object available")
-    roles = reln["roles"]
-    list_of_objects = []
-    for role in roles:
-        if role["role"] == role_pointed:
-            players = role["player"]
-            for p in players:
-                player = {}
-                # get properties for the sub object
-                props = p['has']
-                sub_relns = p['relns']
-                for prop in props:
-                    prop_name = prop["typeql"]
-                    prop_stix_name = prop_value = None
-                    for stix, tql in obj_props_tql.items():
-                        if prop_name == tql:
-                            prop_stix_name = stix
-                            prop_value = prop["value"]
-                            break
-                    # if property is a list, then
-                    if prop_stix_name in obj_is_list:
-                        if prop_stix_name not in player:
-                            player[prop_stix_name] = []
-                            player[prop_stix_name].append(prop_value)
-
-                        else:
-                            player[prop_stix_name].append(prop_value)
-
-                    # else property is a value, not a list
-                    else:
-                        player[prop_stix_name] = prop_value
-                # now look to see if there are relations
-                obj_relns = [k for k, v in obj_props_tql.items() if v == ""]
-                logger.debug(f'sub relns -> {sub_relns}')
-                for sub_reln in sub_relns:
-                    logger.debug(f'\n\nsub reln -> {sub_reln}')
-                    # if the relation is embedded
-                    if sub_reln["T_name"] in auth["tql_types"]["embedded_relations"]:
-                        for inst in auth["reln"]["embedded_relations"]:
-                            if inst["typeql"] == sub_reln["T_name"]:
-                                obj_reln_name = inst["typeql"]
-                                obj_owner = inst["owner"]
-                                obj_pointed = inst["pointed-to"]
-                                obj_stix_name = inst["rel"]
-                                logger.debug(f'obj_reln_name -> {obj_reln_name}')
-                                logger.debug(f'obj_owner -> {obj_owner}')
-                                logger.debug(f'obj_pointed -> {obj_pointed}')
-                                logger.debug(f'obj_stix_name -> {obj_stix_name}')
-                                break
-
-                        local_roles = sub_reln["roles"]
-                        for l_r in local_roles:
-                            # if the owner role  is considered
-                            if l_r["role"] == obj_owner:
-                                local_players = l_r["player"]
-                                # and the existing object used in the list of objects
-                                if local_players[0]["tql"] == reln_object:
-                                    for l_r2 in local_roles:
-                                        if l_r2["role"] == obj_pointed:
-                                            players2 = l_r2["player"]
-                                            for p2 in players2:
-                                                # then we write the result as an embedded relation
-                                                answer = p2['stix_id']
-                                                if obj_stix_name in obj_is_list:
-                                                    if obj_stix_name not in player:
-                                                        player[obj_stix_name] = []
-                                                        player[obj_stix_name].append(answer)
-
-                                                    else:
-                                                        player[obj_stix_name].append(answer)
-
-                                                else:
-                                                    player[obj_stix_name] = answer
-
-                    else:
-                        logger.debug(f'unsupported relation for list of objects {sub_reln}')
-                        #logger.info(f'embedded --> {stix_models["embedded_relations_typeql"]}')
-
-                list_of_objects.append(player)
-
-    stix_dict[stix_field_name] = list_of_objects
-    return stix_dict
-
-
-def make_granular_marking(reln, reln_name, stix_dict, is_list, obj_tql, obj_type=None):
-    """
-        Setup granular marking sub object
-    Args:
-        reln (): relation object
-        reln_name (): relation name
-        stix_dict (): stix dict being built
-        is_list (): list of parameters that are lists
-        obj_type (): stix object that owns the embedded relation
-
-    Returns:
-        stix_dict {}: a dict containing the stix object
-    """
-    stix_label = "granular_markings"
-    local_marking = {}
-    roles = reln["roles"]
-    lang_marking = stix_marking = None
-    for role in roles:
-        if role["role"] == "marking":
-            local_p = role["player"][0]
-            local_id = local_p["stix_id"]
-            local_type = local_id.split('--')[0]
-            if local_type == "marking-definition":
-                stix_marking = local_id
-            else:
-                lang_marking = local_id
-
-        elif role["role"] == "marked":
-            local_p = role["player"]
-            selectors = []
-            for p in local_p:
-                tql_name = p["tql"]
-                stix_name = ''
-                for key, value in obj_tql.items():
-                    if value == tql_name:
-                        stix_name = key
-                        break
-
-                # if property being marked is a list, then
-                if stix_name in is_list:
-                    # find the item in the property list with the same value, as my typeql value
-                    tql_value = p["value"]
-                    list_to_check = stix_dict[stix_name]
-                    for i, item in enumerate(list_to_check):
-                        if item == tql_value:
-                            stix_name = stix_name + '.[' + str(i) + ']'
-                            selectors.append(stix_name)
-
-                            # else property is a value, not a list
-                else:
-                    selectors.append(stix_name)
-
-    if stix_marking is not None:
-        local_marking["marking_ref"] = stix_marking
-        local_marking["selectors"] = selectors
-    else:
-        local_marking["lang"] = lang_marking
-        local_marking["selectors"] = selectors
-
-    if "granular_markings" in stix_dict:
-        stix_dict["granular_markings"].append(local_marking)
-    else:
-        stix_dict["granular_markings"] = []
-        stix_dict["granular_markings"].append(local_marking)
-
-    return stix_dict
-
-
-def make_hashes(reln, reln_name, stix_dict):
-    """
-        Setup hashes sub object
-    Args:
-        reln (): relation object
-        reln_name (): relation name
-        stix_dict (): stix dict being built
-
-    Returns:
-        stix_dict {}: a dict containing the stix object
-    """
-    stix_label = "hashes"
-    hashes = {}
-    roles = reln["roles"]
-    for r in roles:
-        if r["role"] == "owner":
-            own_players = r["player"]
-        elif r['role'] == "pointed-to":
-            own_players = r["player"]
-            for p in own_players:
-                hash_type = p["tql"]
-                hash_value = p["hash_value"]
-                hashes[hash_type] = hash_value
-
-        else:
-            logger.error(f" make hashes relation not implemented {r['role']}")
-
-    stix_dict[stix_label] = hashes
-    return stix_dict
-
-
-
+import json
+import pathlib
+import traceback
+from typing import List
+import copy
+
+from stixorm.module.authorise import authorised_mappings
+from stixorm.module.parsing.conversion_decisions import sdo_type_to_tql, sro_type_to_tql, sco__type_to_tql, meta_type_to_tql
+from stixorm.module.orm.export_utilities import convert_ans_to_res
+import logging
+
+from stixorm.module.typedb_lib.factories.auth_factory import get_auth_factory_instance
+from stixorm.module.typedb_lib.factories.import_type_factory import ImportType
+
+logger = logging.getLogger(__name__)
+
+
+###################################################################################################
+#
+#    TypeQL to Stix Mapping
+#
+###################################################################################################
+
+
+# --------------------------------------------------------------------------------------------------------
+#  Overview:
+#     1. Convert TypeQL Ans to Res, using the transaction
+#     2. Convert Res to Stix, creating first the dict, then parsing the dict to Stix object
+# --------------------------------------------------------------------------------------------------------
+
+
+def convert_ans_to_stix(query, answer_iterator, r_tx, import_type: ImportType):
+    """
+        High level function to convert the typedb_lib return into a Stix object.
+        Firstly, drive the grpc to make an intermediate format, then convert that to a Stix dict
+    Args:
+        answer_iterator (): the returned iterator from the typedb_lib query
+        r_tx (): the transaction
+        import_type (): the type of import STIX21 or ATT&CK
+
+    Returns:
+        stix_dict {}: a dict containing the stix object
+    """
+    res = convert_ans_to_res(answer_iterator, r_tx, import_type)
+    path = pathlib.Path(__file__).parent.joinpath("export_test.json")
+    #with open(str(path), 'w') as outfile:
+    #    json.dump(res, outfile)
+    logger.debug(f'got res, now for stix')
+    stix_dict = convert_res_to_stix(res, import_type)
+    logger.debug((f'got stix now for object'))
+    logger.debug("=========================================")
+    json_object = json.dumps(stix_dict, indent=4)
+    logger.debug(json_object)
+    logger.debug("=========================================")
+    return json_object
+
+
+# --------------------------------------------------------------------------------------------------------
+#  2. Convert Res to Stix
+# --------------------------------------------------------------------------------------------------------
+
+def convert_res_to_stix(res: List[dict], import_type: ImportType):
+    """
+        High level function to conver the intermediate form into a stix dict
+    Args:
+        res (): the intermediate form
+        import_type (): the type of import "STIX21" or "ATT&CK"
+
+    Returns:
+        stix_dict {}: a dict containing the stix object
+    """
+
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    stix_dict = {}
+    for obj in res:
+        obj_type = obj["T_name"]
+        tql_type = obj["type"]
+        if obj_type in auth["tql_types"]["sdo"]:
+            stix_dict = make_sdo(obj, import_type)
+        elif obj_type in auth["tql_types"]["sco"]:
+            stix_dict = make_sco(obj, import_type)
+        elif tql_type in auth["tql_types"]["sro"] or tql_type == 'relationship':
+            stix_dict = make_sro(obj, import_type)
+        elif obj_type in auth["tql_types"]["meta"] or obj_type == "statement-marking":
+            stix_dict = make_meta(obj, import_type)
+        else:
+            logger.error(f'Unknown object type: {obj}')
+
+    logger.debug(f'\n\n')
+    logger.debug(f'stix dict -> {stix_dict}\n')
+    return stix_dict
+
+
+def make_sdo(res, import_type: ImportType):
+    """
+        High-level function to convert intermediate format into a Stix domain object
+    Args:
+        res (): intermediate format
+        import_type (): the type of import "STIX21" or "ATT&CK"
+
+    Returns:
+        stix_dict {}: a dict containing the stix object
+    """
+    try:
+        auth_factory = get_auth_factory_instance()
+        auth = auth_factory.get_auth_for_import(import_type)
+        stix_dict = {}
+        # 2.A) get the typeql properties and relations
+        sdo_tql_name = res["T_name"]
+        sdo_type = ""
+        for model in auth["conv"]["sdo"]:
+            if model["typeql"] == sdo_tql_name:
+                sdo_type = model["type"]
+        props = res["has"]
+        relns = res["relns"]
+        attack_object = False
+        sub_technique = False
+        for prop in props:
+            if prop["typeql"] == "x-mitre-version":
+                attack_object = True
+            if prop["typeql"] == "x-mitre-is-subtechnique" and prop["value"] is True:
+                sub_technique = True
+
+        obj_tql, sdo_tql_name, is_list, protocol = sdo_type_to_tql(sdo_type, import_type, attack_object, sub_technique)
+
+        #logger.debug(f"obj tql -> {obj_tql}\n sdo tql name -> {sdo_tql_name}")
+        # 2.B) get the is_list list, the list of properties that are lists for that object
+        #is_list = auth["is_lists"]["sdo"]["sdo"] + auth["is_lists"]["sdo"][sdo_tql_name]
+        # 3.A) add the properties onto the the object
+        stix_dict = make_properties(props, obj_tql, stix_dict, is_list)
+        #logger.debug(f'sdo, add properties, stix_dict -> {stix_dict}\n')
+        # 3.B) add the relations onto the object
+        stix_dict = make_relations(relns, obj_tql, stix_dict, is_list, sdo_tql_name, import_type)
+        #logger.debug(f'sdo, add relations, , stix_dict -> {stix_dict}\n')
+        # 4.0 Check for the edge case where an identity creates an identity, but they are the same id
+        if "created_by_ref" in stix_dict and stix_dict["type"] == "identity":
+            if stix_dict["created_by_ref"] == stix_dict["id"]:
+                del stix_dict["created_by_ref"]
+    except Exception as e:
+        logger.exception(e)
+
+    return stix_dict
+
+
+def make_sro(res, import_type: ImportType):
+    """
+        High-level function to convert intermediate format into a Stix relationship object
+    Args:
+        res (): intermediate format
+        import_type (): the type of import "STIX21" or "ATT&CK"
+
+    Returns:
+        stix_dict {}: a dict containing the stix object
+    """
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    stix_dict = {}
+    # 2.A) get the typeql properties and relations
+    sro_tql_name = res["type"]
+    sro_type = ""
+    props = res["has"]
+    relns = res["relns"]
+    sro_sub_rel = ""
+    if sro_tql_name in auth["tql_types"]["relations_sro_roles"]:
+        sro_sub_rel = sro_tql_name
+        sro_type = "relationship"
+    elif sro_tql_name == "relationship":
+        sro_type = "relationship"
+        for has in props:
+            if has["typeql"] == "relationship-type":
+                sro_sub_rel = has["value"]
+                logger.debug(f'found relationship type -> {sro_sub_rel}\n')
+                break
+    else:
+        sro_type = "sighting"
+    #
+    # Note, Issue, cannot yet tell what to do with a procedure
+    #
+    attack_object = False
+    uses_relation = False
+    if sro_tql_name == "procedire":
+        sro_sub_rel = sro_tql_name
+        is_procedure = True
+    else:
+        is_procedure = False
+    for prop in props:
+        if prop["typeql"] == "x-mitre-version":
+            attack_object = True
+
+    obj_tql, sro_tql_name, is_list, protocol = sro_type_to_tql(sro_type, sro_sub_rel, import_type, attack_object, uses_relation, is_procedure)
+
+    logger.debug(f'make sro obj_tql ->{obj_tql}\n sro tql name ->{sro_tql_name}')
+    # 2.A) get the typeql properties and relations
+    props = res["has"]
+    relns = res["relns"]
+    edges = res["edges"]
+    # 2.) setup the match statements first, depending on whether the object is a sighting or a relationship
+    # A. If it is a Relationship then find the source and target roles for the relation, and match them in
+    if sro_tql_name in auth["reln_name"]["standard_relations"]:
+        for stix_rel in auth["reln"]["standard_relations"]:
+            if stix_rel["stix"] == sro_tql_name:
+                source_role = stix_rel["source"]
+                target_role = stix_rel["target"]
+                break
+
+        for edge in edges:
+            players = edge["player"]
+            if edge["role"] == source_role:
+                for p in players:
+                    stix_dict["source_ref"] = p["stix_id"]
+                    break
+
+            elif edge["role"] == target_role:
+                for p in players:
+                    stix_dict["target_ref"] = p["stix_id"]
+                    break
+            else:
+                logger.error(f'edge role {edge["role"]} not supported')
+                return ''
+
+    # B. If it is a Sighting then match the object to the sighting
+    elif sro_tql_name == 'sighting':
+        is_list = copy.deepcopy(auth["is_lists"]["sro"]["sro"]) + copy.deepcopy(auth["is_lists"]["sro"]["sighting"])
+        for edge in edges:
+            players = edge["player"]
+            if edge["role"] == "sighting-of":
+                for p in players:
+                    stix_dict["sighting_of_ref"] = p["stix_id"]
+
+            elif edge["role"] == "where-sighted":
+                for p in players:
+                    if "where_sighted_refs" in stix_dict:
+                        stix_dict["where_sighted_refs"].append(p["stix_id"])
+                    else:
+                        stix_dict["where_sighted_refs"] = []
+                        stix_dict["where_sighted_refs"].append(p["stix_id"])
+            elif edge["role"] == "observed":
+                for p in players:
+                    if "observed_data_refs" in stix_dict:
+                        stix_dict["observed_data_refs"].append(p["stix_id"])
+                    else:
+                        stix_dict["observed_data_refs"] = []
+                        stix_dict["observed_data_refs"].append(p["stix_id"])
+            else:
+                logger.error(f'edge role {edge["role"]} not supported')
+                return ''
+
+    else:
+        logger.error(f'relationship type {sro_tql_name} not supported')
+        return ''
+
+    # 3.A) add the properties onto the the object
+    stix_dict = make_properties(props, obj_tql, stix_dict, is_list)
+    # 3.B) add the relations onto the object
+    stix_dict = make_relations(relns, obj_tql, stix_dict, is_list, sro_tql_name, import_type)
+    return stix_dict
+
+
+def make_sco(res: dict, import_type: ImportType):
+    """
+        High-level function to convert intermediate format into a Stix cyber observable object
+    Args:
+        res (): intermediate format
+        import_type (): the type of import "STIX21" or "ATT&CK"
+
+    Returns:
+        stix_dict {}: a dict containing the stix object
+    """
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    # - work out the type of object
+    stix_dict = {}
+    obj_type = res["T_name"]
+    # - get the object-specific typeql names, sighting or relationship
+    # - work out the type of object
+    sco_tql_name = obj_type
+    # - get the object-specific typeql names, sighting or relationship
+    obj_tql, sco_tql_name, is_list, protocol = sco__type_to_tql(sco_tql_name, import_type)
+
+    # 2.A) get the typeql properties and relations
+    props = res["has"]
+    relns = res["relns"]
+
+    is_list = copy.deepcopy(auth["is_lists"]["sco"]["sco"]) + copy.deepcopy(auth["is_lists"]["sco"][obj_type])
+    # 3.A) add the properties onto the the object
+    stix_dict = make_properties(props, obj_tql, stix_dict, is_list)
+    # 3.B) add the relations onto the object
+    stix_dict = make_relations(relns, obj_tql, stix_dict, is_list, obj_type, import_type)
+    return stix_dict
+
+
+colours_dict = {
+    "tlp-amber": {"type": "marking-definition", "spec_version": "2.1",
+                  "id": "marking-definition--f88d31f6-486f-44da-b317-01333bde0b82",
+                  "created": "2017-01-20T00:00:00.000Z", "definition_type": "tlp",
+                  "name": "TLP:AMBER", "definition": {"tlp": "amber"}},
+    "tlp-green": {"type": "marking-definition", "spec_version": "2.1",
+                  "id": "marking-definition--34098fce-860f-48ae-8e50-ebd3cc5e41da",
+                  "created": "2017-01-20T00:00:00.000Z", "definition_type": "tlp",
+                  "name": "TLP:GREEN", "definition": {"tlp": "green"}},
+    "tlp-white": {"type": "marking-definition", "spec_version": "2.1",
+                  "id": "marking-definition--613f2e26-407d-48c7-9eca-b8e91df99dc9",
+                  "created": "2017-01-20T00:00:00.000Z", "definition_type": "tlp",
+                  "name": "TLP:WHITE", "definition": {"tlp": "white"}},
+    "tlp-red": {"type": "marking-definition", "spec_version": "2.1",
+                "id": "marking-definition--5e57c739-391a-4eb3-b6be-7d15ca92d5ed",
+                "created": "2017-01-20T00:00:00.000Z", "definition_type": "tlp",
+                "name": "TLP:RED", "definition": {"tlp": "red"}}
+}
+
+
+def make_meta(res, import_type: ImportType):
+    """
+        High-level function to convert intermediate format into a Stix meta object
+    Args:
+        res (): intermediate format
+        import_type (): the type of import "STIX21" or "ATT&CK"
+
+    Returns:
+        stix_dict {}: a dict containing the stix object
+    """
+    stix_dict = {}
+
+    obj_type = res["T_name"]
+    props = res["has"]
+    relns = res["relns"]
+    attack_object = False
+    if obj_type == "tlp-white" or obj_type == "tlp-green" or obj_type == "tlp-amber" or obj_type == "tlp-red":
+        return colours_dict[obj_type]
+    j=0
+    tmp_val = ""
+    for i, prop in enumerate(props):
+        if prop["typeql"] == "x-mitre-attack-spec-version":
+            attack_object = True
+        elif prop["typeql"] == "statement":
+            tmp_val = prop["value"]
+            j = i
+
+    if tmp_val != "":
+        del props[j]
+
+    obj_tql, sdo_tql_name, is_list, protocol = meta_type_to_tql(obj_type, import_type, attack_object)
+
+    # Add the properties onto the the object
+    stix_dict = make_properties(props, obj_tql, stix_dict, is_list)
+    # Add the relations onto the object
+    stix_dict = make_relations(relns, obj_tql, stix_dict, is_list, obj_type, import_type)
+
+    if tmp_val != "":
+        stix_dict["definition"] = {"statement": tmp_val}
+        stix_dict["definition_type"] = "statement"
+
+    return stix_dict
+
+
+def make_properties(props, obj_tql, stix_dict, is_list: bool):
+    """
+        Unpack properties for a stix object (i.e. values at the 'has' level)
+    Args:
+        props (): a list of proeprties
+        obj_tql (): the tql that describes the object
+        stix_dict (): the stix dict that we are building
+        is_list (): a list of the properties that are lists
+
+    Returns:
+        stix_dict {}: a dict containing the stix object
+    """
+    for prop in props:
+        prop_tql_name = prop["typeql"]
+        prop_value = prop["value"]
+        for stix_name, stix_value in obj_tql.items():
+            if prop_tql_name == stix_value:
+                # if property is a list, then
+                if stix_name in is_list:
+                    if stix_name not in stix_dict:
+                        stix_dict[stix_name] = []
+                        stix_dict[stix_name].append(prop_value)
+                        break
+                    else:
+                        stix_dict[stix_name].append(prop_value)
+                        break
+                # else property is a value, not a list
+                else:
+                    stix_dict[stix_name] = prop_value
+
+    return stix_dict
+
+
+def make_relations(relns, obj_tql, stix_dict, is_list, obj_name, import_type: ImportType):
+    """
+        Overall branching function for processing all the sub objects
+    Args:
+        relns (): the list of relations to process
+        obj_tql (): the object tql for this stix object
+        stix_dict (): the stix dict we are building
+        is_list (): the list of properties that are a list
+        obj_name (): the stix object these sub objects belong to
+
+    Returns:
+        stix_dict {}: a dict containing the stix object
+    """
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    for reln in relns:
+        reln_name = reln["T_name"]
+        if reln_name in auth["tql_types"]["embedded_relations"]:
+            stix_dict = make_embedded_relations(reln, reln_name, stix_dict, is_list, obj_name, import_type)
+
+        elif reln_name in auth["tql_types"]["standard_relations"] or reln_name == "sighting":
+            stix_dict = make_standard_relations(reln, reln_name, stix_dict, is_list, obj_name, import_type)
+
+        elif reln_name in auth["tql_types"]["key_value_relations"]:
+            stix_dict = make_key_value_relations(reln, reln_name, stix_dict, is_list, obj_name, import_type)
+
+        elif reln_name in auth["tql_types"]["list_of_objects"]:
+            stix_dict = make_list_of_objects(reln, reln_name, stix_dict, is_list, obj_name, import_type)
+
+        elif reln_name == "v3-extensions" or reln_name == "optional-headers":
+            stix_dict = make_object(reln, reln_name, stix_dict, is_list, obj_name, import_type)
+
+        elif reln_name in auth["tql_types"]["extension_relations"]:
+            stix_dict = make_extension_relations(reln, reln_name, stix_dict, is_list, obj_name, import_type)
+
+        elif reln_name == "granular-marking":
+            stix_dict = make_granular_marking(reln, reln_name, stix_dict, is_list, obj_tql, obj_name)
+
+        elif reln_name == "hashes" or reln_name == "file-header-hashes":
+            stix_dict = make_hashes(reln, reln_name, stix_dict)
+
+        else:
+            logger.error(f'Error, relation name is {reln_name}')
+            break
+
+    return stix_dict
+
+
+def make_embedded_relations(reln, reln_name, stix_dict, is_list: bool, obj_name, import_type: ImportType):
+    """
+        Setup embedded relations based on stix-id's
+    Args:
+        reln (): relation object
+        reln_name (): relation name
+        stix_dict (): stix dict being built
+        is_list (): list of parameters that are lists
+        obj_name (): stix object that owns the embedded relation
+
+    Returns:
+        stix_dict {}: a dict containing the stix object
+    """
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    stix_object_type = obj_name
+    for embedded_r in auth["reln"]["embedded_relations"]:
+        if reln_name == embedded_r["typeql"]:
+            role_pointed = embedded_r["pointed-to"]
+            stix_name = embedded_r["rel"]
+            role_owner = embedded_r["owner"]
+
+    roles = reln["roles"]
+    for role in roles:
+        if role["role"] == role_pointed:
+            pointed = role
+        elif role["role"] == role_owner:
+            owner = role
+        else:
+            logger.error(f'unsupported role in embedded relation {role["role"]}')
+
+    # 1. Is Owner correct, basically my super object?
+    # - should be only one object in the owner role list, and its type is the same as my super object type
+    own_players = owner["player"]
+    own_player = own_players[0]
+    if own_player['tql'] == stix_object_type:
+        # 2. If 1 is yes, then we want to find the emebedded relation, else not
+        pointed_players = pointed["player"]
+        for p in pointed_players:
+            prop_value = p['stix_id']
+            # if property is a list, then
+            if stix_name in is_list:
+                if stix_name not in stix_dict:
+                    stix_dict[stix_name] = []
+                    stix_dict[stix_name].append(prop_value)
+
+                else:
+                    stix_dict[stix_name].append(prop_value)
+
+            # else property is a value, not a list
+            else:
+                stix_dict[stix_name] = prop_value
+    else:
+        return stix_dict
+
+    return stix_dict
+
+
+def make_standard_relations(reln, reln_name, stix_dict, is_list, obj_name, import_type: ImportType):
+    #logger.warning(" make standard relations visited, but not implemented")
+    return stix_dict
+
+
+def make_key_value_relations(reln, reln_name, stix_dict, is_list, obj_type, import_type: ImportType):
+    """
+        Setup embedded relations based on stix-id's
+    Args:
+        reln (): relation object
+        reln_name (): relation name
+        stix_dict (): stix dict being built
+        is_list (): list of parameters that are lists
+        obj_type (): stix object that owns the embedded relation
+
+    Returns:
+        stix_dict {}: a dict containing the stix object
+    """
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    for kv_obj in auth["reln"]["key_value_relations"]:
+        if reln_name == kv_obj["typeql"]:
+            role_pointed = kv_obj["pointed_to"]
+            reln_owner = kv_obj["owner"]
+            key_name = kv_obj["key"]
+            val_name = kv_obj["value"]
+            stix_field_name = kv_obj["name"]
+            break
+
+    roles = reln["roles"]
+    dict_of_kv = {}
+    for role in roles:
+        if role["role"] == role_pointed:
+            players = role["player"]
+            for p in players:
+                key_value = p["value"]
+                props = p['props']
+                prop_list = []
+                if len(props) > 1:
+                    for prop in props:
+                        val_value = prop["value"]
+                        prop_list.append(val_value)
+
+                    dict_of_kv[key_value] = prop_list
+
+                else:
+                    val_value = props[0]["value"]
+                    dict_of_kv[key_value] = val_value
+
+    stix_dict[stix_field_name] = dict_of_kv
+    return stix_dict
+
+
+def make_extension_relations(reln, reln_name, stix_dict, is_list, obj_type, import_type: ImportType):
+    """
+        Setup extension relations based on stix-id's
+    Args:
+        reln (): relation object
+        reln_name (): relation name
+        stix_dict (): stix dict being built
+        is_list (): list of parameters that are lists
+        obj_type (): stix object that owns the embedded relation
+
+    Returns:
+        stix_dict {}: a dict containing the stix object
+    """
+    logger.debug("make extension relations visited")
+
+    local_dict = {}
+    local_dict = make_object(reln, reln_name, local_dict, is_list, obj_type, import_type)
+    stix_dict["extensions"] = local_dict
+    return stix_dict
+
+
+def make_object(reln, reln_name, stix_dict, is_list, obj_type, import_type: ImportType):
+    """
+        Setup a sub object
+    Args:
+        reln (): relation object
+        reln_name (): relation name
+        stix_dict (): stix dict being built
+        is_list (): list of parameters that are lists
+        obj_type (): stix object that owns the embedded relation
+
+    Returns:
+        stix_dict {}: a dict containing the stix object
+    """
+    logger.debug("make object visited")
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    for ext_obj in auth["reln"]["extension_relations"]:
+        if reln_name == ext_obj["relation"]:
+            role_pointed = ext_obj["pointed-to"]
+            role_owner = ext_obj["owner"]
+            ext_object = ext_obj["object"]
+            stix_ext_name = ext_obj["stix"]
+            obj_is_list = copy.deepcopy(auth["is_lists"]["sub"][ext_object])
+            break
+
+    if ext_object in auth["sub_objects"]:
+        obj_props_tql = copy.deepcopy(auth["sub_objects"][ext_object])
+    else:
+        raise ValueError("no sub-object available")
+    roles = reln["roles"]
+    ext_data_object = {}
+    for role in roles:
+        if role["role"] == role_pointed:
+            players = role["player"]
+            for p in players:
+                player = {}
+                # get properties for the sub object
+                props = p['has']
+                for prop in props:
+                    prop_name = prop["typeql"]
+                    prop_stix_name = prop_value = None
+                    for stix, tql in obj_props_tql.items():
+                        if prop_name == tql:
+                            prop_stix_name = stix
+                            prop_value = prop["value"]
+                            break
+                    # if property is a list, then
+                    if prop_stix_name in obj_is_list:
+                        if prop_stix_name not in player:
+                            player[prop_stix_name] = []
+                            player[prop_stix_name].append(prop_value)
+
+                        else:
+                            player[prop_stix_name].append(prop_value)
+
+                    # else property is a value, not a list
+                    else:
+                        player[prop_stix_name] = prop_value
+                # now look to see if there are relations
+                obj_relns = [k for k, v in obj_props_tql.items() if v == ""]
+                sub_relns = p['relns']
+                obj_tql = copy.deepcopy(auth["sub_objects"][ext_object])
+                new_dict = {}
+                new_dict = make_relations(sub_relns, obj_tql, new_dict, is_list, ext_object, import_type)
+                for k, v in new_dict.items():
+                    player[k] = v
+
+    stix_dict[stix_ext_name] = player
+    return stix_dict
+
+
+def make_list_of_objects(reln, reln_name, stix_dict, is_list, obj_type, import_type: ImportType):
+    """
+    Args:
+        Setup a list of sub objects
+        reln (): relation object
+        reln_name (): relation name
+        stix_dict (): stix dict being built
+        is_list (): list of parameters that are lists
+        obj_type (): stix object that owns the embedded relation
+
+    Returns:
+        stix_dict {}: a dict containing the stix object
+    """
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    for l_obj in auth["reln"]["list_of_objects"]:
+        if reln_name == l_obj["typeql"]:
+            role_pointed = l_obj["pointed_to"]
+            reln_object = l_obj["object"]
+            stix_field_name = l_obj["name"]
+            obj_is_list = copy.deepcopy(auth["is_lists"]["sub"][reln_object])
+            logger.debug("obj_is_list: {}".format(obj_is_list))
+            logger.debug("reln_object: {}".format(reln_object))
+            logger.debug("stix_field_name: {}".format(stix_field_name))
+            logger.debug("role_pointed: {}".format(role_pointed))
+            break
+
+    if reln_object in auth["sub_objects"]:
+        obj_props_tql = copy.deepcopy(auth["sub_objects"][reln_object])
+    else:
+        raise ValueError("no sub-object available")
+    roles = reln["roles"]
+    list_of_objects = []
+    for role in roles:
+        if role["role"] == role_pointed:
+            players = role["player"]
+            for p in players:
+                player = {}
+                # get properties for the sub object
+                props = p['has']
+                sub_relns = p['relns']
+                for prop in props:
+                    prop_name = prop["typeql"]
+                    prop_stix_name = prop_value = None
+                    for stix, tql in obj_props_tql.items():
+                        if prop_name == tql:
+                            prop_stix_name = stix
+                            prop_value = prop["value"]
+                            break
+                    # if property is a list, then
+                    if prop_stix_name in obj_is_list:
+                        if prop_stix_name not in player:
+                            player[prop_stix_name] = []
+                            player[prop_stix_name].append(prop_value)
+
+                        else:
+                            player[prop_stix_name].append(prop_value)
+
+                    # else property is a value, not a list
+                    else:
+                        player[prop_stix_name] = prop_value
+                # now look to see if there are relations
+                obj_relns = [k for k, v in obj_props_tql.items() if v == ""]
+                logger.debug(f'sub relns -> {sub_relns}')
+                for sub_reln in sub_relns:
+                    logger.debug(f'\n\nsub reln -> {sub_reln}')
+                    # if the relation is embedded
+                    if sub_reln["T_name"] in auth["tql_types"]["embedded_relations"]:
+                        for inst in auth["reln"]["embedded_relations"]:
+                            if inst["typeql"] == sub_reln["T_name"]:
+                                obj_reln_name = inst["typeql"]
+                                obj_owner = inst["owner"]
+                                obj_pointed = inst["pointed-to"]
+                                obj_stix_name = inst["rel"]
+                                logger.debug(f'obj_reln_name -> {obj_reln_name}')
+                                logger.debug(f'obj_owner -> {obj_owner}')
+                                logger.debug(f'obj_pointed -> {obj_pointed}')
+                                logger.debug(f'obj_stix_name -> {obj_stix_name}')
+                                break
+
+                        local_roles = sub_reln["roles"]
+                        for l_r in local_roles:
+                            # if the owner role  is considered
+                            if l_r["role"] == obj_owner:
+                                local_players = l_r["player"]
+                                # and the existing object used in the list of objects
+                                if local_players[0]["tql"] == reln_object:
+                                    for l_r2 in local_roles:
+                                        if l_r2["role"] == obj_pointed:
+                                            players2 = l_r2["player"]
+                                            for p2 in players2:
+                                                # then we write the result as an embedded relation
+                                                answer = p2['stix_id']
+                                                if obj_stix_name in obj_is_list:
+                                                    if obj_stix_name not in player:
+                                                        player[obj_stix_name] = []
+                                                        player[obj_stix_name].append(answer)
+
+                                                    else:
+                                                        player[obj_stix_name].append(answer)
+
+                                                else:
+                                                    player[obj_stix_name] = answer
+
+                    else:
+                        logger.debug(f'unsupported relation for list of objects {sub_reln}')
+                        #logger.info(f'embedded --> {stix_models["embedded_relations_typeql"]}')
+
+                list_of_objects.append(player)
+
+    stix_dict[stix_field_name] = list_of_objects
+    return stix_dict
+
+
+def make_granular_marking(reln, reln_name, stix_dict, is_list, obj_tql, obj_type=None):
+    """
+        Setup granular marking sub object
+    Args:
+        reln (): relation object
+        reln_name (): relation name
+        stix_dict (): stix dict being built
+        is_list (): list of parameters that are lists
+        obj_type (): stix object that owns the embedded relation
+
+    Returns:
+        stix_dict {}: a dict containing the stix object
+    """
+    stix_label = "granular_markings"
+    local_marking = {}
+    roles = reln["roles"]
+    lang_marking = stix_marking = None
+    for role in roles:
+        if role["role"] == "marking":
+            local_p = role["player"][0]
+            local_id = local_p["stix_id"]
+            local_type = local_id.split('--')[0]
+            if local_type == "marking-definition":
+                stix_marking = local_id
+            else:
+                lang_marking = local_id
+
+        elif role["role"] == "marked":
+            local_p = role["player"]
+            selectors = []
+            for p in local_p:
+                tql_name = p["tql"]
+                stix_name = ''
+                for key, value in obj_tql.items():
+                    if value == tql_name:
+                        stix_name = key
+                        break
+
+                # if property being marked is a list, then
+                if stix_name in is_list:
+                    # find the item in the property list with the same value, as my typeql value
+                    tql_value = p["value"]
+                    list_to_check = stix_dict[stix_name]
+                    for i, item in enumerate(list_to_check):
+                        if item == tql_value:
+                            stix_name = stix_name + '.[' + str(i) + ']'
+                            selectors.append(stix_name)
+
+                            # else property is a value, not a list
+                else:
+                    selectors.append(stix_name)
+
+    if stix_marking is not None:
+        local_marking["marking_ref"] = stix_marking
+        local_marking["selectors"] = selectors
+    else:
+        local_marking["lang"] = lang_marking
+        local_marking["selectors"] = selectors
+
+    if "granular_markings" in stix_dict:
+        stix_dict["granular_markings"].append(local_marking)
+    else:
+        stix_dict["granular_markings"] = []
+        stix_dict["granular_markings"].append(local_marking)
+
+    return stix_dict
+
+
+def make_hashes(reln, reln_name, stix_dict):
+    """
+        Setup hashes sub object
+    Args:
+        reln (): relation object
+        reln_name (): relation name
+        stix_dict (): stix dict being built
+
+    Returns:
+        stix_dict {}: a dict containing the stix object
+    """
+    stix_label = "hashes"
+    hashes = {}
+    roles = reln["roles"]
+    for r in roles:
+        if r["role"] == "owner":
+            own_players = r["player"]
+        elif r['role'] == "pointed-to":
+            own_players = r["player"]
+            for p in own_players:
+                hash_type = p["tql"]
+                hash_value = p["hash_value"]
+                hashes[hash_type] = hash_value
+
+        else:
+            logger.error(f" make hashes relation not implemented {r['role']}")
+
+    stix_dict[stix_label] = hashes
+    return stix_dict
+
+
+
```

### Comparing `stixorm-0.1.3/stixorm/module/orm/export_utilities.py` & `stixorm-0.1.9/stixorm/module/orm/export_utilities.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,605 +1,605 @@
-import copy
-from datetime import timezone
-
-from stixorm.module.authorise import authorised_mappings
-
-import logging
-
-from stixorm.module.typedb_lib.factories.auth_factory import get_auth_factory_instance
-from stixorm.module.typedb_lib.factories.import_type_factory import ImportType
-
-logger = logging.getLogger(__name__)
-
-
-# --------------------------------------------------------------------------------------------------------
-#  1. Convert TypeQl Ans to Res
-# --------------------------------------------------------------------------------------------------------
-
-
-def convert_ans_to_res(answer_iterator, r_tx, import_type: ImportType):
-    """
-    Take the response from TypeDB to a query, and start the process to use GRPC (typedb_lib-client) commands
-    to expand on the returned data to some potential object shape (i.e. mandatory and optional),
-    and report it back in some intermediate form that can then be reprocessed into Stix 2.1 format.
-    This depends on the shape of the Stix object involved.
-
-    The first step is to branch depending on whether we are decoding an entity or relation.
-
-    Args:
-        answer_iterator (): current answers
-        r_tx (): transaction thread to query
-        import_type (): stix2.1 or att&ck, used in the second half
-
-    Returns:
-        res: A list of data objects, in the intermediate form for processing into Stix objects
-    """
-    res = []
-
-    for answer in answer_iterator:
-        dict_answer = answer.map()
-        for key, thing in dict_answer.items():
-            # pull entity data
-            if thing.is_entity():
-                # 1. describe entity
-                ent = {'type': 'entity', 'symbol': key, 'T_id': thing.get_iid(),
-                       'T_name': thing.get_type().get_label().name()}
-                # 2 get and dsecribe properties
-                props_obj = thing.as_remote(r_tx).get_has()
-                ent['has'] = process_props(props_obj)
-                # 3. get and describe relations
-                reln_types = thing.as_remote(r_tx).get_relations()
-                ent['relns'] = process_relns(reln_types, r_tx, import_type)
-                res.append(ent)
-                # logger.debug(f'ent -> {ent}')
-
-            # pull relation data
-            elif thing.is_relation():
-                # 1. setup basis
-                rel = {'type': 'relationship', 'symbol': key, 'T_id': thing.get_iid(),
-                       'T_name': thing.get_type().get_label().name()}
-                att_obj = thing.as_remote(r_tx).get_has()
-                rel['has'] = process_props(att_obj)
-                # 3. get and describe relations
-                reln_types = thing.as_remote(r_tx).get_relations()
-                rel['relns'] = process_relns(reln_types, r_tx, import_type)
-                # 4. get and describe the edges
-                edges = []
-                edge_types = thing.as_remote(r_tx).get_players_by_role_type()
-                stix_id = r_tx.concepts().get_attribute_type("stix-id")
-                for role, things in edge_types.items():
-                    edge = {"role": role.get_label().name(), 'player': []}
-                    for thing in things:
-                        if thing.is_entity():
-                            edge['player'].append(process_entity(thing, r_tx,stix_id))
-
-                    edges.append(edge)
-
-                rel['edges'] = edges
-                res.append(rel)
-
-            # else log out error condition
-            else:
-                logger.debug(f'Error key is {key}, thing is {thing}')
-
-    return res
-
-
-def process_entity(thing, r_tx, stix_id: str):
-    """
-        If the current returned object from typedb_lib contains an entity then unpack it using grpc commands
-        into an interim list
-    Args:
-        thing (): the grpc entity reference
-        r_tx (): the typedb_lib transaction
-        stix_id (): the stix object id
-
-    Returns:
-        play {}: a return dict
-    """
-    play = {"type": "entity", "tql": thing.get_type().get_label().name()}
-    attr_stix_id = thing.as_remote(r_tx).get_has(attribute_type=stix_id)
-    for attr in attr_stix_id:
-        play["stix_id"] = attr.get_value()
-
-    return play
-
-
-def process_relns(reln_types, r_tx, import_type: ImportType):
-    """
-        If the current returned object is a list of relations (i.e. a list of embedded objects), then unpack them
-    Args:
-        reln_types (): iterable of relation types
-        r_tx (): returned transaction
-
-    Returns:
-        relns []: a list of reln's
-    """
-    relns = []
-    for r in reln_types:
-        logger.debug(f'r  - >{r}, rtx -> {r_tx}')
-        reln = get_relation_details(r, r_tx, import_type)
-        relns.append(reln)
-
-    return relns
-
-
-def process_relation(p, r_tx, stix_id):
-    """
-        If the current returned object is a relation (i.e. embedded object) then unpack it
-    Args:
-        p ():  returned object
-        r_tx (): returned transaction
-        stix_id (): the id of the stix object
-
-    Returns:
-        plays {}: a dict containing the unpacked relation
-    """
-    plays = {"type": "attribute", "tql": p.get_type().get_label().name()}
-    attr_stix_id = p.as_remote(r_tx).get_has(attribute_type=stix_id)
-    for attr in attr_stix_id:
-        plays["stix_id"] = attr.get_value()
-
-    return plays
-
-
-def process_props(props_obj):
-    """
-        Unpack  a list of properties/values
-    Args:
-        props_obj (): iterable object of properties
-
-    Returns:
-        props []: a list of properties
-    """
-    props = []
-    for a in props_obj:
-        prop = {"typeql": a.get_type().get_label().name()}
-        if a.is_datetime():
-            nt_obj = a.get_value()
-            dt_obj = nt_obj.astimezone(timezone.utc)
-            prop["value"] = dt_obj.strftime("%Y-%m-%dT%H:%M:%S.%fZ")
-            prop['datetime'] = True
-        elif a.is_string():
-            temp_string = a.get_value()
-            prop["value"] = temp_string.replace("\\\\", "\\")
-            prop['datetime'] = False
-        else:
-            prop["value"] = a.get_value()
-            prop['datetime'] = False
-
-        props.append(prop)
-
-    return props
-
-
-def process_value(p):
-    """
-        If object is a value, then unpack it
-    Args:
-        p (): an object that is a value
-
-    Returns:
-        ret_value : a returned value
-    """
-    if p.is_datetime():
-        nt_obj = p.get_value()
-        dt_obj = nt_obj.astimezone(timezone.utc)
-        ret_value = dt_obj.strftime("%Y-%m-%dT%H:%M:%S.%fZ")
-    else:
-        ret_value = p.get_value()
-
-    return ret_value
-
-
-def get_relation_details(r, r_tx, import_type: ImportType):
-    """
-        For a given sub-object type, unpack it
-    Args:
-        r (): the embedded relation object
-        r_tx (): the retrned transaction
-
-    Returns:
-        reln {}: a dict containing the reln details
-    """
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    reln = {}
-    reln_name = r.get_type().get_label().name()
-    reln['T_name'] = reln_name
-    reln['T_id'] = r.get_iid()
-    if reln_name in auth["tql_types"]["embedded_relations"]:
-        reln['roles'] = get_embedded_relations(r, r_tx)
-
-    elif reln_name in auth["tql_types"]["standard_relations"] or reln_name == "sighting":
-        reln['roles'] = get_standard_relations(r, r_tx)
-
-    elif reln_name in auth["tql_types"]["key_value_relations"]:
-        reln['roles'] = get_key_value_relations(r, r_tx)
-
-    elif reln_name in auth["tql_types"]["extension_relations"]:
-        reln['roles'] = get_extension_relations(r, r_tx, import_type)
-
-    elif reln_name in auth["tql_types"]["list_of_objects"]:
-        reln['roles'] = get_list_of_objects(r, r_tx, import_type)
-
-    elif reln_name == "granular-marking":
-        reln['roles'] = get_granular_marking(r, r_tx)
-
-    elif reln_name == "hashes" or reln_name == "file-header-hashes":
-        reln['roles'] = get_hashes(r, r_tx)
-
-    else:
-        logger.error(f'Error, relation name is {reln_name}')
-
-    return reln
-
-
-def reln_map_entity_attribute(reln_map, r_tx, stix_id: str, is_kv):
-    """
-        Process a map of Player by Role types, and unpack entity and attribute
-    Args:
-        reln_map (): relation map of player by role types
-        r_tx (): transaction
-        stix_id (): stix id
-        is_kv (): do extra stuff if coming froma key-value relationship
-
-    Returns:
-        roles []: list of dict objects
-    """
-    roles = []
-    for role, player in reln_map.items():
-        role_i = {'role': role.get_label().name(), 'player': []}
-        for p in player:
-            play = {}
-            if p.is_entity():
-                role_i['player'].append(process_entity(p, r_tx, stix_id))
-            elif p.is_attribute():
-                play["type"] = "attribute"
-                play["tql"] = p.get_type().get_label().name()
-                play["value"] = process_value(p)
-                if is_kv:
-                    att_obj = p.as_remote(r_tx).get_has()
-                    play['props'] = process_props(att_obj)
-                role_i['player'].append(play)
-
-            else:
-                logger.debug(f'player is not entity type {p}')
-
-        roles.append(role_i)
-
-    return roles
-
-
-def get_granular_marking(r, r_tx):
-    """
-        Process a granular marking sub object through grpc
-    Args:
-        r (): the typedb_lib object
-        r_tx (): the transaction
-
-    Returns:
-        roles []: list of dict objects
-    """
-    stix_id = r_tx.concepts().get_attribute_type("stix-id")
-    reln_map = r.as_remote(r_tx).get_players_by_role_type()
-    is_kv: object = False
-    roles = reln_map_entity_attribute(reln_map, r_tx, stix_id, is_kv)
-    return roles
-
-
-def get_hashes(r, r_tx):
-    """
-        Process a get hashes sub object through grpc
-    Args:
-        r (): the typedb_lib object
-        r_tx (): the transaction
-
-    Returns:
-        roles []: list of dict objects
-    """
-    roles = []
-    stix_id = r_tx.concepts().get_attribute_type("stix-id")
-    hash_value = r_tx.concepts().get_attribute_type("hash-value")
-    reln_map = r.as_remote(r_tx).get_players_by_role_type()
-
-    for role, player in reln_map.items():
-        role_name = role.get_label().name()
-        role_i = {'role': role_name, 'player': []}
-        for p in player:
-            play = {}
-            if p.is_entity():
-                play["type"] = "entity"
-                play["tql"] = p.get_type().get_label().name()
-                if role_name == "owner":
-                    attr_stix_id = p.as_remote(r_tx).get_has(attribute_type=stix_id)
-                    for attr in attr_stix_id:
-                        play["stix_id"] = attr.get_value()
-                else:
-                    attr_hash_value = p.as_remote(r_tx).get_has(attribute_type=hash_value)
-                    for attr in attr_hash_value:
-                        play["hash_value"] = attr.get_value()
-
-                role_i['player'].append(play)
-
-            else:
-                logger.debug(f'player is not entity type {p}')
-
-        roles.append(role_i)
-    return roles
-
-
-def get_key_value_relations(r, r_tx):
-    """
-        Process a key-value sub object through grpc
-    Args:
-        r (): the typedb_lib object
-        r_tx (): the transaction
-
-    Returns:
-        roles []: list of dict objects
-    """
-    stix_id = r_tx.concepts().get_attribute_type("stix-id")
-    reln_map = r.as_remote(r_tx).get_players_by_role_type()
-    is_kv: object = True
-    roles = reln_map_entity_attribute(reln_map, r_tx, stix_id, is_kv)
-    return roles
-
-
-def get_list_of_objects(r,
-                        r_tx,
-                        import_type: ImportType):
-    """
-        Process a list of objects sub object through grpc
-    Args:
-        r (): the typedb_lib object
-        r_tx (): the transaction
-
-    Returns:
-        roles []: list of dict objects
-    """
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    reln_name = r.get_type().get_label().name()
-    for lot in auth["reln"]["list_of_objects"]:
-        if reln_name == lot["typeql"]:
-            reln_pointed_to = lot["pointed_to"]
-            reln_object = lot["object"]
-            reln_object_props = copy.deepcopy(auth["sub_objects"][reln_object])
-            reln_stix = lot["name"]
-
-    stix_id = r_tx.concepts().get_attribute_type("stix-id")
-    reln_map = r.as_remote(r_tx).get_players_by_role_type()
-    roles = []
-    for role, player in reln_map.items():
-        role_i = {'role': role.get_label().name(), 'player': []}
-        for p in player:
-            play = {}
-            if p.is_entity():
-                play["type"] = "entity"
-                play["tql"] = p.get_type().get_label().name()
-                props_obj = p.as_remote(r_tx).get_has()
-                play['has'] = process_props(props_obj)
-                # 3. get and describe relations
-                reln_types = p.as_remote(r_tx).get_relations()
-                relns = []
-                for rel in reln_types:
-                    reln = {}
-                    reln_name = rel.get_type().get_label().name()
-
-                    reln['T_name'] = reln_name
-                    reln['T_id'] = rel.get_iid()
-                    reln_map = rel.as_remote(r_tx).get_players_by_role_type()
-                    reln['roles'] = reln_map_entity_relation(reln_map, r_tx, stix_id)
-                    relns.append(reln)
-
-                play['relns'] = relns
-                role_i['player'].append(play)
-
-
-            else:
-                logger.debug(f'player is not entity type {p}')
-
-        roles.append(role_i)
-    return roles
-
-
-def reln_map_entity_relation(reln_map,
-                             r_tx,
-                             stix_id: str):
-    """
-
-    Args:
-        reln_map ():
-        r_tx ():
-        stix_id ():
-
-    Returns:
-
-    """
-    roles = []
-    for role, player in reln_map.items():
-        role_i = {'role': role.get_label().name(), 'player': []}
-        for p in player:
-            play = {}
-            if p.is_entity():
-                role_i['player'].append(process_entity(p, r_tx, stix_id))
-            elif p.is_relation():
-                role_i['player'].append(process_relation(p, r_tx, stix_id))
-
-            else:
-                logger.debug(f'player is not entity type {p}')
-
-        roles.append(role_i)
-
-    return roles
-
-
-def get_embedded_relations(r, r_tx):
-    """
-        Process embedded relationships (i.e. based on Stix-id)
-    Args:
-        r (): relation
-        r_tx (): transaction
-
-    Returns:
-        roles []: list of dict objects
-    """
-    stix_id = r_tx.concepts().get_attribute_type("stix-id")
-    reln_map = r.as_remote(r_tx).get_players_by_role_type()
-    roles = reln_map_entity_relation(reln_map, r_tx, stix_id)
-    return roles
-
-
-def get_extension_relations(r,
-                            r_tx,
-                            import_type: ImportType):
-    """
-        Process a Stix extension sub object through grpc
-    Args:
-        r (): the typedb_lib object
-        r_tx (): the transaction
-
-    Returns:
-        roles []: list of dict objects
-    """
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    reln_name = r.get_type().get_label().name()
-    for ext in auth["reln"]["extension_relations"]:
-        if ext['relation'] == reln_name:
-            reln_object = ext['object']
-
-    stix_id = r_tx.concepts().get_attribute_type("stix-id")
-    reln_map = r.as_remote(r_tx).get_players_by_role_type()
-    roles = []
-    for role, player in reln_map.items():
-        role_i = {'role': role.get_label().name(), 'player': []}
-        for p in player:
-            play = {}
-            if p.is_entity():
-                play["type"] = "entity"
-                p_name = p.get_type().get_label().name()
-                play["tql"] = p_name
-                if p_name == reln_object:
-                    props_obj = p.as_remote(r_tx).get_has()
-                    play['has'] = process_props(props_obj)
-                    # 3. get and describe relations
-                    reln_types = p.as_remote(r_tx).get_relations()
-                    relns = []
-                    for rel in reln_types:
-                        reln = {}
-                        reln = validate_get_relns(rel, r_tx, reln_object, import_type)
-                        if reln == {} or reln is None:
-                            pass
-                        else:
-                            relns.append(reln)
-
-                    play['relns'] = relns
-
-                else:
-                    attr_stix_id = p.as_remote(r_tx).get_has(attribute_type=stix_id)
-                    for attr in attr_stix_id:
-                        play["stix_id"] = attr.get_value()
-
-                role_i['player'].append(play)
-            elif p.is_attribute():
-                play["type"] = "attribute"
-                play["tql"] = p.get_type().get_label().name()
-                play["value"] = process_value(p)
-                role_i['player'].append(play)
-
-            else:
-                logger.debug(f'player is not entity type {p}')
-
-        roles.append(role_i)
-    return roles
-
-
-def validate_get_relns(rel,
-                       r_tx,
-                       obj_name,
-                       import_type: ImportType):
-    """
-        When processing relations for an object, ensure we only access relations for sub objects,
-        and not Stix relations or sightings
-    Args:
-        rel (): the relation
-        r_tx (): the transaction
-        obj_name (): the object involved in the relation
-
-    Returns:
-        reln {}: a dict containing the reln details
-    """
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    reln={}
-    reln_name = rel.get_type().get_label().name()
-    if reln_name in auth["tql_types"]["embedded_relations"]:
-        for emb in auth["reln"]["embedded_relations"]:
-            if emb['typeql'] == reln_name:
-                role_owner = emb['owner']
-        return return_valid_relations(rel, r_tx, obj_name, role_owner, import_type)
-
-    elif reln_name in auth["tql_types"]["key_value_relations"]:
-        for kvt in auth["reln"]["key_value_relations"]:
-            if kvt['typeql'] == reln_name:
-                role_owner = kvt['owner']
-        return return_valid_relations(rel, r_tx, obj_name, role_owner, import_type)
-
-    elif reln_name in auth["tql_types"]["extension_relations"]:
-        logger.debug(f'reln name {reln_name}')
-        for kvt in auth["reln"]["extension_relations"]:
-            if kvt['relation'] == reln_name:
-                role_owner = kvt['owner']
-        return return_valid_relations(rel, r_tx, obj_name, role_owner, import_type)
-
-    elif reln_name in auth["tql_types"]["list_of_objects"]:
-        for kvt in auth["reln"]["list_of_objects"]:
-            if kvt['typeql'] == reln_name:
-                role_owner = kvt['owner']
-        return return_valid_relations(rel, r_tx, obj_name, role_owner, import_type)
-
-    elif reln_name == "granular-marking":
-        return get_relation_details(rel, r_tx, import_type)
-
-    elif reln_name == "hashes":
-        return get_relation_details(rel, r_tx, import_type)
-
-    else:
-        logger.error(f'Error, relation name is {reln_name}')
-
-
-def return_valid_relations(rel,
-                           r_tx,
-                           obj_name,
-                           role_owner,
-                           import_type: ImportType):
-    """
-        return only the valid relations to the relation check
-    Args:
-        rel (): the actual relation
-        r_tx (): the transaction
-        obj_name (): the object involved
-        role_owner (): the owner of the role
-
-    Returns:
-        reln {}: a dict containing the reln details
-    """
-    reln_map = rel.as_remote(r_tx).get_players_by_role_type()
-    for role, player in reln_map.items():
-        role_name = role.get_label().name()
-        if role_name == role_owner:
-            for p in player:
-                if p.is_entity():
-                    play_name = p.get_type().get_label().name()
-                    if play_name == obj_name:
-                        return get_relation_details(rel, r_tx, import_type)
-
-
-def get_standard_relations(r, r_tx):
-    """
-        Ignore standard relations, as they are not sub objects
-    Returns:
-        Emptyy List:
-    """
-    return []
+import copy
+from datetime import timezone
+
+from stixorm.module.authorise import authorised_mappings
+
+import logging
+
+from stixorm.module.typedb_lib.factories.auth_factory import get_auth_factory_instance
+from stixorm.module.typedb_lib.factories.import_type_factory import ImportType
+
+logger = logging.getLogger(__name__)
+
+
+# --------------------------------------------------------------------------------------------------------
+#  1. Convert TypeQl Ans to Res
+# --------------------------------------------------------------------------------------------------------
+
+
+def convert_ans_to_res(answer_iterator, r_tx, import_type: ImportType):
+    """
+    Take the response from TypeDB to a query, and start the process to use GRPC (typedb_lib-client) commands
+    to expand on the returned data to some potential object shape (i.e. mandatory and optional),
+    and report it back in some intermediate form that can then be reprocessed into Stix 2.1 format.
+    This depends on the shape of the Stix object involved.
+
+    The first step is to branch depending on whether we are decoding an entity or relation.
+
+    Args:
+        answer_iterator (): current answers
+        r_tx (): transaction thread to query
+        import_type (): stix2.1 or att&ck, used in the second half
+
+    Returns:
+        res: A list of data objects, in the intermediate form for processing into Stix objects
+    """
+    res = []
+
+    for answer in answer_iterator:
+        dict_answer = answer.map()
+        for key, thing in dict_answer.items():
+            # pull entity data
+            if thing.is_entity():
+                # 1. describe entity
+                ent = {'type': 'entity', 'symbol': key, 'T_id': thing.get_iid(),
+                       'T_name': thing.get_type().get_label().name()}
+                # 2 get and dsecribe properties
+                props_obj = thing.as_remote(r_tx).get_has()
+                ent['has'] = process_props(props_obj)
+                # 3. get and describe relations
+                reln_types = thing.as_remote(r_tx).get_relations()
+                ent['relns'] = process_relns(reln_types, r_tx, import_type)
+                res.append(ent)
+                # logger.debug(f'ent -> {ent}')
+
+            # pull relation data
+            elif thing.is_relation():
+                # 1. setup basis
+                rel = {'type': 'relationship', 'symbol': key, 'T_id': thing.get_iid(),
+                       'T_name': thing.get_type().get_label().name()}
+                att_obj = thing.as_remote(r_tx).get_has()
+                rel['has'] = process_props(att_obj)
+                # 3. get and describe relations
+                reln_types = thing.as_remote(r_tx).get_relations()
+                rel['relns'] = process_relns(reln_types, r_tx, import_type)
+                # 4. get and describe the edges
+                edges = []
+                edge_types = thing.as_remote(r_tx).get_players_by_role_type()
+                stix_id = r_tx.concepts().get_attribute_type("stix-id")
+                for role, things in edge_types.items():
+                    edge = {"role": role.get_label().name(), 'player': []}
+                    for thing in things:
+                        if thing.is_entity():
+                            edge['player'].append(process_entity(thing, r_tx,stix_id))
+
+                    edges.append(edge)
+
+                rel['edges'] = edges
+                res.append(rel)
+
+            # else log out error condition
+            else:
+                logger.debug(f'Error key is {key}, thing is {thing}')
+
+    return res
+
+
+def process_entity(thing, r_tx, stix_id: str):
+    """
+        If the current returned object from typedb_lib contains an entity then unpack it using grpc commands
+        into an interim list
+    Args:
+        thing (): the grpc entity reference
+        r_tx (): the typedb_lib transaction
+        stix_id (): the stix object id
+
+    Returns:
+        play {}: a return dict
+    """
+    play = {"type": "entity", "tql": thing.get_type().get_label().name()}
+    attr_stix_id = thing.as_remote(r_tx).get_has(attribute_type=stix_id)
+    for attr in attr_stix_id:
+        play["stix_id"] = attr.get_value()
+
+    return play
+
+
+def process_relns(reln_types, r_tx, import_type: ImportType):
+    """
+        If the current returned object is a list of relations (i.e. a list of embedded objects), then unpack them
+    Args:
+        reln_types (): iterable of relation types
+        r_tx (): returned transaction
+
+    Returns:
+        relns []: a list of reln's
+    """
+    relns = []
+    for r in reln_types:
+        logger.debug(f'r  - >{r}, rtx -> {r_tx}')
+        reln = get_relation_details(r, r_tx, import_type)
+        relns.append(reln)
+
+    return relns
+
+
+def process_relation(p, r_tx, stix_id):
+    """
+        If the current returned object is a relation (i.e. embedded object) then unpack it
+    Args:
+        p ():  returned object
+        r_tx (): returned transaction
+        stix_id (): the id of the stix object
+
+    Returns:
+        plays {}: a dict containing the unpacked relation
+    """
+    plays = {"type": "attribute", "tql": p.get_type().get_label().name()}
+    attr_stix_id = p.as_remote(r_tx).get_has(attribute_type=stix_id)
+    for attr in attr_stix_id:
+        plays["stix_id"] = attr.get_value()
+
+    return plays
+
+
+def process_props(props_obj):
+    """
+        Unpack  a list of properties/values
+    Args:
+        props_obj (): iterable object of properties
+
+    Returns:
+        props []: a list of properties
+    """
+    props = []
+    for a in props_obj:
+        prop = {"typeql": a.get_type().get_label().name()}
+        if a.is_datetime():
+            nt_obj = a.get_value()
+            dt_obj = nt_obj.astimezone(timezone.utc)
+            prop["value"] = dt_obj.strftime("%Y-%m-%dT%H:%M:%S.%fZ")
+            prop['datetime'] = True
+        elif a.is_string():
+            temp_string = a.get_value()
+            prop["value"] = temp_string.replace("\\\\", "\\")
+            prop['datetime'] = False
+        else:
+            prop["value"] = a.get_value()
+            prop['datetime'] = False
+
+        props.append(prop)
+
+    return props
+
+
+def process_value(p):
+    """
+        If object is a value, then unpack it
+    Args:
+        p (): an object that is a value
+
+    Returns:
+        ret_value : a returned value
+    """
+    if p.is_datetime():
+        nt_obj = p.get_value()
+        dt_obj = nt_obj.astimezone(timezone.utc)
+        ret_value = dt_obj.strftime("%Y-%m-%dT%H:%M:%S.%fZ")
+    else:
+        ret_value = p.get_value()
+
+    return ret_value
+
+
+def get_relation_details(r, r_tx, import_type: ImportType):
+    """
+        For a given sub-object type, unpack it
+    Args:
+        r (): the embedded relation object
+        r_tx (): the retrned transaction
+
+    Returns:
+        reln {}: a dict containing the reln details
+    """
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    reln = {}
+    reln_name = r.get_type().get_label().name()
+    reln['T_name'] = reln_name
+    reln['T_id'] = r.get_iid()
+    if reln_name in auth["tql_types"]["embedded_relations"]:
+        reln['roles'] = get_embedded_relations(r, r_tx)
+
+    elif reln_name in auth["tql_types"]["standard_relations"] or reln_name == "sighting":
+        reln['roles'] = get_standard_relations(r, r_tx)
+
+    elif reln_name in auth["tql_types"]["key_value_relations"]:
+        reln['roles'] = get_key_value_relations(r, r_tx)
+
+    elif reln_name in auth["tql_types"]["extension_relations"]:
+        reln['roles'] = get_extension_relations(r, r_tx, import_type)
+
+    elif reln_name in auth["tql_types"]["list_of_objects"]:
+        reln['roles'] = get_list_of_objects(r, r_tx, import_type)
+
+    elif reln_name == "granular-marking":
+        reln['roles'] = get_granular_marking(r, r_tx)
+
+    elif reln_name == "hashes" or reln_name == "file-header-hashes":
+        reln['roles'] = get_hashes(r, r_tx)
+
+    else:
+        logger.error(f'Error, relation name is {reln_name}')
+
+    return reln
+
+
+def reln_map_entity_attribute(reln_map, r_tx, stix_id: str, is_kv):
+    """
+        Process a map of Player by Role types, and unpack entity and attribute
+    Args:
+        reln_map (): relation map of player by role types
+        r_tx (): transaction
+        stix_id (): stix id
+        is_kv (): do extra stuff if coming froma key-value relationship
+
+    Returns:
+        roles []: list of dict objects
+    """
+    roles = []
+    for role, player in reln_map.items():
+        role_i = {'role': role.get_label().name(), 'player': []}
+        for p in player:
+            play = {}
+            if p.is_entity():
+                role_i['player'].append(process_entity(p, r_tx, stix_id))
+            elif p.is_attribute():
+                play["type"] = "attribute"
+                play["tql"] = p.get_type().get_label().name()
+                play["value"] = process_value(p)
+                if is_kv:
+                    att_obj = p.as_remote(r_tx).get_has()
+                    play['props'] = process_props(att_obj)
+                role_i['player'].append(play)
+
+            else:
+                logger.debug(f'player is not entity type {p}')
+
+        roles.append(role_i)
+
+    return roles
+
+
+def get_granular_marking(r, r_tx):
+    """
+        Process a granular marking sub object through grpc
+    Args:
+        r (): the typedb_lib object
+        r_tx (): the transaction
+
+    Returns:
+        roles []: list of dict objects
+    """
+    stix_id = r_tx.concepts().get_attribute_type("stix-id")
+    reln_map = r.as_remote(r_tx).get_players_by_role_type()
+    is_kv: object = False
+    roles = reln_map_entity_attribute(reln_map, r_tx, stix_id, is_kv)
+    return roles
+
+
+def get_hashes(r, r_tx):
+    """
+        Process a get hashes sub object through grpc
+    Args:
+        r (): the typedb_lib object
+        r_tx (): the transaction
+
+    Returns:
+        roles []: list of dict objects
+    """
+    roles = []
+    stix_id = r_tx.concepts().get_attribute_type("stix-id")
+    hash_value = r_tx.concepts().get_attribute_type("hash-value")
+    reln_map = r.as_remote(r_tx).get_players_by_role_type()
+
+    for role, player in reln_map.items():
+        role_name = role.get_label().name()
+        role_i = {'role': role_name, 'player': []}
+        for p in player:
+            play = {}
+            if p.is_entity():
+                play["type"] = "entity"
+                play["tql"] = p.get_type().get_label().name()
+                if role_name == "owner":
+                    attr_stix_id = p.as_remote(r_tx).get_has(attribute_type=stix_id)
+                    for attr in attr_stix_id:
+                        play["stix_id"] = attr.get_value()
+                else:
+                    attr_hash_value = p.as_remote(r_tx).get_has(attribute_type=hash_value)
+                    for attr in attr_hash_value:
+                        play["hash_value"] = attr.get_value()
+
+                role_i['player'].append(play)
+
+            else:
+                logger.debug(f'player is not entity type {p}')
+
+        roles.append(role_i)
+    return roles
+
+
+def get_key_value_relations(r, r_tx):
+    """
+        Process a key-value sub object through grpc
+    Args:
+        r (): the typedb_lib object
+        r_tx (): the transaction
+
+    Returns:
+        roles []: list of dict objects
+    """
+    stix_id = r_tx.concepts().get_attribute_type("stix-id")
+    reln_map = r.as_remote(r_tx).get_players_by_role_type()
+    is_kv: object = True
+    roles = reln_map_entity_attribute(reln_map, r_tx, stix_id, is_kv)
+    return roles
+
+
+def get_list_of_objects(r,
+                        r_tx,
+                        import_type: ImportType):
+    """
+        Process a list of objects sub object through grpc
+    Args:
+        r (): the typedb_lib object
+        r_tx (): the transaction
+
+    Returns:
+        roles []: list of dict objects
+    """
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    reln_name = r.get_type().get_label().name()
+    for lot in auth["reln"]["list_of_objects"]:
+        if reln_name == lot["typeql"]:
+            reln_pointed_to = lot["pointed_to"]
+            reln_object = lot["object"]
+            reln_object_props = copy.deepcopy(auth["sub_objects"][reln_object])
+            reln_stix = lot["name"]
+
+    stix_id = r_tx.concepts().get_attribute_type("stix-id")
+    reln_map = r.as_remote(r_tx).get_players_by_role_type()
+    roles = []
+    for role, player in reln_map.items():
+        role_i = {'role': role.get_label().name(), 'player': []}
+        for p in player:
+            play = {}
+            if p.is_entity():
+                play["type"] = "entity"
+                play["tql"] = p.get_type().get_label().name()
+                props_obj = p.as_remote(r_tx).get_has()
+                play['has'] = process_props(props_obj)
+                # 3. get and describe relations
+                reln_types = p.as_remote(r_tx).get_relations()
+                relns = []
+                for rel in reln_types:
+                    reln = {}
+                    reln_name = rel.get_type().get_label().name()
+
+                    reln['T_name'] = reln_name
+                    reln['T_id'] = rel.get_iid()
+                    reln_map = rel.as_remote(r_tx).get_players_by_role_type()
+                    reln['roles'] = reln_map_entity_relation(reln_map, r_tx, stix_id)
+                    relns.append(reln)
+
+                play['relns'] = relns
+                role_i['player'].append(play)
+
+
+            else:
+                logger.debug(f'player is not entity type {p}')
+
+        roles.append(role_i)
+    return roles
+
+
+def reln_map_entity_relation(reln_map,
+                             r_tx,
+                             stix_id: str):
+    """
+
+    Args:
+        reln_map ():
+        r_tx ():
+        stix_id ():
+
+    Returns:
+
+    """
+    roles = []
+    for role, player in reln_map.items():
+        role_i = {'role': role.get_label().name(), 'player': []}
+        for p in player:
+            play = {}
+            if p.is_entity():
+                role_i['player'].append(process_entity(p, r_tx, stix_id))
+            elif p.is_relation():
+                role_i['player'].append(process_relation(p, r_tx, stix_id))
+
+            else:
+                logger.debug(f'player is not entity type {p}')
+
+        roles.append(role_i)
+
+    return roles
+
+
+def get_embedded_relations(r, r_tx):
+    """
+        Process embedded relationships (i.e. based on Stix-id)
+    Args:
+        r (): relation
+        r_tx (): transaction
+
+    Returns:
+        roles []: list of dict objects
+    """
+    stix_id = r_tx.concepts().get_attribute_type("stix-id")
+    reln_map = r.as_remote(r_tx).get_players_by_role_type()
+    roles = reln_map_entity_relation(reln_map, r_tx, stix_id)
+    return roles
+
+
+def get_extension_relations(r,
+                            r_tx,
+                            import_type: ImportType):
+    """
+        Process a Stix extension sub object through grpc
+    Args:
+        r (): the typedb_lib object
+        r_tx (): the transaction
+
+    Returns:
+        roles []: list of dict objects
+    """
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    reln_name = r.get_type().get_label().name()
+    for ext in auth["reln"]["extension_relations"]:
+        if ext['relation'] == reln_name:
+            reln_object = ext['object']
+
+    stix_id = r_tx.concepts().get_attribute_type("stix-id")
+    reln_map = r.as_remote(r_tx).get_players_by_role_type()
+    roles = []
+    for role, player in reln_map.items():
+        role_i = {'role': role.get_label().name(), 'player': []}
+        for p in player:
+            play = {}
+            if p.is_entity():
+                play["type"] = "entity"
+                p_name = p.get_type().get_label().name()
+                play["tql"] = p_name
+                if p_name == reln_object:
+                    props_obj = p.as_remote(r_tx).get_has()
+                    play['has'] = process_props(props_obj)
+                    # 3. get and describe relations
+                    reln_types = p.as_remote(r_tx).get_relations()
+                    relns = []
+                    for rel in reln_types:
+                        reln = {}
+                        reln = validate_get_relns(rel, r_tx, reln_object, import_type)
+                        if reln == {} or reln is None:
+                            pass
+                        else:
+                            relns.append(reln)
+
+                    play['relns'] = relns
+
+                else:
+                    attr_stix_id = p.as_remote(r_tx).get_has(attribute_type=stix_id)
+                    for attr in attr_stix_id:
+                        play["stix_id"] = attr.get_value()
+
+                role_i['player'].append(play)
+            elif p.is_attribute():
+                play["type"] = "attribute"
+                play["tql"] = p.get_type().get_label().name()
+                play["value"] = process_value(p)
+                role_i['player'].append(play)
+
+            else:
+                logger.debug(f'player is not entity type {p}')
+
+        roles.append(role_i)
+    return roles
+
+
+def validate_get_relns(rel,
+                       r_tx,
+                       obj_name,
+                       import_type: ImportType):
+    """
+        When processing relations for an object, ensure we only access relations for sub objects,
+        and not Stix relations or sightings
+    Args:
+        rel (): the relation
+        r_tx (): the transaction
+        obj_name (): the object involved in the relation
+
+    Returns:
+        reln {}: a dict containing the reln details
+    """
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    reln={}
+    reln_name = rel.get_type().get_label().name()
+    if reln_name in auth["tql_types"]["embedded_relations"]:
+        for emb in auth["reln"]["embedded_relations"]:
+            if emb['typeql'] == reln_name:
+                role_owner = emb['owner']
+        return return_valid_relations(rel, r_tx, obj_name, role_owner, import_type)
+
+    elif reln_name in auth["tql_types"]["key_value_relations"]:
+        for kvt in auth["reln"]["key_value_relations"]:
+            if kvt['typeql'] == reln_name:
+                role_owner = kvt['owner']
+        return return_valid_relations(rel, r_tx, obj_name, role_owner, import_type)
+
+    elif reln_name in auth["tql_types"]["extension_relations"]:
+        logger.debug(f'reln name {reln_name}')
+        for kvt in auth["reln"]["extension_relations"]:
+            if kvt['relation'] == reln_name:
+                role_owner = kvt['owner']
+        return return_valid_relations(rel, r_tx, obj_name, role_owner, import_type)
+
+    elif reln_name in auth["tql_types"]["list_of_objects"]:
+        for kvt in auth["reln"]["list_of_objects"]:
+            if kvt['typeql'] == reln_name:
+                role_owner = kvt['owner']
+        return return_valid_relations(rel, r_tx, obj_name, role_owner, import_type)
+
+    elif reln_name == "granular-marking":
+        return get_relation_details(rel, r_tx, import_type)
+
+    elif reln_name == "hashes":
+        return get_relation_details(rel, r_tx, import_type)
+
+    else:
+        logger.error(f'Error, relation name is {reln_name}')
+
+
+def return_valid_relations(rel,
+                           r_tx,
+                           obj_name,
+                           role_owner,
+                           import_type: ImportType):
+    """
+        return only the valid relations to the relation check
+    Args:
+        rel (): the actual relation
+        r_tx (): the transaction
+        obj_name (): the object involved
+        role_owner (): the owner of the role
+
+    Returns:
+        reln {}: a dict containing the reln details
+    """
+    reln_map = rel.as_remote(r_tx).get_players_by_role_type()
+    for role, player in reln_map.items():
+        role_name = role.get_label().name()
+        if role_name == role_owner:
+            for p in player:
+                if p.is_entity():
+                    play_name = p.get_type().get_label().name()
+                    if play_name == obj_name:
+                        return get_relation_details(rel, r_tx, import_type)
+
+
+def get_standard_relations(r, r_tx):
+    """
+        Ignore standard relations, as they are not sub objects
+    Returns:
+        Emptyy List:
+    """
+    return []
```

### Comparing `stixorm-0.1.3/stixorm/module/orm/import_objects.py` & `stixorm-0.1.9/stixorm/module/orm/import_utilities.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,537 +1,727 @@
-import copy
-from typing import Dict
-
-from stixorm.module.authorise import authorised_mappings, default_import_type
-from stixorm.module.parsing.conversion_decisions import sdo_type_to_tql, sro_type_to_tql, sco__type_to_tql, meta_type_to_tql
-
-from stixorm.module.orm.import_utilities import clean_props, get_embedded_match, split_on_activity_type, \
-    add_property_to_typeql, add_relation_to_typeql, val_tql
-
-import logging
-
-from stixorm.module.typedb_lib.factories.auth_factory import get_auth_factory_instance
-logger = logging.getLogger(__name__)
-
-
-
-marking =["marking-definition--613f2e26-407d-48c7-9eca-b8e91df99dc9",
-          "marking-definition--34098fce-860f-48ae-8e50-ebd3cc5e41da",
-          "marking-definition--f88d31f6-486f-44da-b317-01333bde0b82",
-          "marking-definition--5e57c739-391a-4eb3-b6be-7d15ca92d5ed"]
-
-# ---------------------------------------------------
-# 1.0) Helper method to direct the right typeql method to an incoming Stix object
-# ---------------------------------------------------
-
-
-def stix2_to_typeql(stix_object, import_type=default_import_type):
-    """
-    Initial function to convert Stix into typeql, it adds together the match and insert statements
-
-    Args:
-        stix_object (): valid Stix2 object
-        import_type (): string, either Stix2 or ATT&CK
-
-    Returns:
-        typeql: a string of typeql to match and insert the object int typedb_lib
-
-    """
-    match, insert, dep_obj = stix2_to_match_insert(stix_object, import_type)
-    typeql = match + insert
-
-    return typeql, dep_obj
-
-
-def stix2_to_match_insert(stix_object, import_type=default_import_type):
-    """
-    Initial function to convert Stix into match/insert statments
-
-    Args:
-        stix_object (): valid Stix2 object
-        import_type (): string, either Stix2 or ATT&CK
-
-    Returns:
-        match: a typeql match statement for this object
-        insert: a typeql insert statement for this object
-
-    """
-    dep_match, dep_insert, indep_ql, core_ql, dep_obj = raw_stix2_to_typeql(stix_object, import_type)
-    if dep_match == '':
-        match = ''
-    else:
-        match = 'match ' + dep_match
-    if indep_ql == '' and dep_insert == '':
-        insert = ''
-    else:
-        insert = 'insert ' + indep_ql + dep_insert
-
-    return match, insert, dep_obj
-
-
-def raw_stix2_to_typeql(stix_object,
-                        import_type=None) -> [str, str, str, str, {}]:
-    """
-    Initial function to convert Stix into typeql, it splits the incoming object into different
-    channels based on its object type: sdo, sro, sco or meta
-
-    Args:
-        stix_object (): valid Stix2 object
-        import_type (): string, either Stix2 or ATT&CK
-
-    Returns:
-        dep_match: a typeql match statement that depends on other objects
-        dep_insert: a typeql insert statement that depends on other objects
-        indep_ql: a typeql insert statement with no extenral dependencies
-        core_ql: a typeql insert statement that describes the object head, so the independent and dependent parts can be injected seaparately
-
-    """
-    if import_type is None:
-        import_type = default_import_type
-
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    logger.debug(f'stix object type {stix_object["type"]}\n')
-
-    auth_types = copy.deepcopy(auth["types"])
-    if stix_object.type in auth_types["sdo"]:
-        logger.debug(f' going into sdo ---? {stix_object}')
-        dep_match, dep_insert, indep_ql, core_ql, dep_obj = sdo_to_typeql(stix_object, import_type)
-    elif stix_object.type in auth_types["sro"]:
-        logger.debug(f' going into sro ---> {stix_object}')
-        dep_match, dep_insert, indep_ql, core_ql, dep_obj = sro_to_typeql(stix_object, import_type)
-    elif stix_object.type in auth_types["sco"]:
-        logger.debug(f' going into sco ---> {stix_object}')
-        dep_match, dep_insert, indep_ql, core_ql, dep_obj = sco_to_typeql(stix_object, import_type)
-    elif stix_object.type == 'marking-definition':
-        dep_match, dep_insert, indep_ql, core_ql, dep_obj = marking_definition_to_typeql(stix_object, import_type)
-    else:
-        logger.error(f'object type not supported: {stix_object.type}, import type {import_type}')
-        dep_match, dep_insert, indep_ql, core_ql, dep_obj = '', '', '', '', ''
-        dep_list = []
-
-    return dep_match, dep_insert, indep_ql, core_ql, dep_obj
-
-
-# -------------------------------------------------------------
-# 1.1) SDO Object Method to convert a Python object --> typeql string
-#                 -   
-# -------------------------------------------------------------
-def sdo_to_data(sdo, import_type=default_import_type) -> [dict, Dict[str, str], str]:
-    """ convert Stix object into a data model for processing
-
-    Args:
-        sdo (): the Stix2 SDO object
-        import_type (): the type of import to use
-
-    Returns:
-        total_props, : a list of all properties
-        obj_tql : the dict of the tql properties
-
-    """
-    sdo_tql_name = sdo.type
-    # - list of property names that have values
-    total_props = sdo._inner
-    total_props = clean_props(total_props)
-    # 1.B) get the specific typeql names for an object into a dictionary
-    # b. Instance details
-    attack_object = False if not sdo.get("x_mitre_version", False) else True
-    sub_technique = False
-    if attack_object:
-        sub_technique = False if not sdo.get("x_mitre_is_subtechnique", False) else True
-
-    obj_tql, sdo_tql_name, is_list, protocol = sdo_type_to_tql(sdo_tql_name, import_type, attack_object, sub_technique)
-    logger.debug(f'\nobject tql {obj_tql}, \nsdo tql name {sdo_tql_name},\n is_list {is_list}')
-
-    return total_props, obj_tql, sdo_tql_name, protocol
-
-
-def sdo_to_typeql(sdo, import_type=default_import_type) -> [str, str, str, str, dict]:
-    """
-    Initial function to convert Stix2 SDO object into typeql
-
-    Args:
-        sdo (): valid Stix2 object
-        import_type (): string, either Stix2 or ATT&CK
-
-    Returns:
-        dep_match: a typeql match statement that depends on other objects
-        dep_insert: a typeql insert statement that depends on other objects
-        indep_ql: a typeql insert statement with no extenral dependencies
-        core_ql: a typeql insert statement that describes the object head, so the independent and dependent parts can be injected seaparately
-
-    """
-    # 1.A) get configuration parameters
-    # - variable for use in typeql statements
-    dep_list = []
-    # 1.B) get the data model
-    total_props, obj_tql, sdo_tql_name, protocol = sdo_to_data(sdo, import_type)
-    logger.debug("\n Step 0 I've just gotten through getting data")
-    logger.debug(f'\n\n total_props {total_props}\n\nobj_tql {obj_tql}\n\nsdo_tql_name {sdo_tql_name}')
-    sdo_var = '$' + sdo_tql_name
-    if obj_tql == '':
-        return '', '', '', '', {}
-    properties, relations = split_on_activity_type(total_props, obj_tql)
-    logger.debug("\n----> Step 1 sdo to typeql")
-
-    # 2.) setup the typeql statement for the sdo entity
-    sdo_var = '$' + sdo_tql_name
-    indep_ql = sdo_var + ' isa ' + sdo_tql_name
-    core_ql = sdo_var + ' isa ' + sdo_tql_name + ', has stix-id $stix-id;\n$stix-id ' + val_tql(sdo.id) + ';\n'
-    indep_ql_props = dep_match = dep_insert = ''
-    logger.debug("----> Step 2 sdo to typeql")
-    # 3.) add each of the properties and values of the properties to the typeql statement
-    prop_var_list = []
-    for prop in properties:
-        # split off for properties processing
-        indep_ql2, indep_ql_props2, prop_var_list = add_property_to_typeql(prop, obj_tql, sdo, prop_var_list)
-        # then add them all together
-        indep_ql += indep_ql2
-        indep_ql_props += indep_ql_props2
-        # add a terminator on the end of the query statement
-    indep_ql += ";\n" + indep_ql_props + "\n\n"
-    logger.debug("----> Step 3 sdo to typeql")
-
-    # 4.) add each of the relations to the match and insert statements
-    for j, rel in enumerate(relations):
-        # split off for relation processing
-        dep_match2, dep_insert2, dep_list2 = add_relation_to_typeql(rel, sdo, sdo_var, prop_var_list, import_type, j, protocol)
-        # then add it back together
-        dep_match = dep_match + dep_match2
-        dep_insert = dep_insert + dep_insert2
-        dep_list = dep_list + dep_list2
-
-    logger.debug("----> Step 4 sdo to typeql")
-    dep_obj = {"id": sdo.id, "dep_list": dep_list, "type": sdo.type}
-    return dep_match, dep_insert, indep_ql, core_ql, dep_obj
-
-
-# -------------------------------------------------------
-# 1.2) SRO Object Method to convert a Python object --> typeql string
-#                 -   
-# -----------------------------------------------------
-def sro_to_data(sro, import_type=default_import_type) -> [dict, Dict[str, str], str]:
-    """ convert Stix object into a data model for processing
-
-        Args:
-            sro (): the Stix2 sco object
-            import_type (): the type of import to use
-
-        Returns:
-            total_props, : a list of all properties
-            obj_tql : the dict of the twl proeprties
-
-    """
-    # - list of property names that have values, and do not include False values
-    total_props = sro._inner
-    total_props = clean_props(total_props)
-
-    logger.debug(f'into sro -> {sro}')
-    # - work out the type of object
-    uses_relation = False
-    is_procedure = False
-    attack_object = False if not sro.get("x_mitre_version", False) else True
-    if attack_object:
-        uses_relation = False if not sro.get("relationship_type", False) == "uses" else True
-        is_procedure = False if not sro.get("target_ref", False) == "attack-pattern" else True
-    obj_tql = {}
-    sro_tql_name = sro.type
-    sro_sub_rel = "" if not sro.get("relationship_type", False) else sro["relationship_type"]
-
-    obj_tql, sro_tql_name, is_list, protocol = sro_type_to_tql(sro_tql_name, sro_sub_rel, import_type, attack_object, uses_relation, is_procedure)
-    logger.debug(f'object tql {obj_tql}, sro tql name {sro_tql_name}')
-
-    return total_props, obj_tql, sro_tql_name, protocol
-
-
-def sro_to_typeql(sro, import_type=default_import_type) -> [str, str, str, str, dict]:
-    """
-    Initial function to convert Stix2 SRO object into typeql
-
-    Args:
-        sro (): valid Stix2 object
-        import_type (): string, either Stix2 or ATT&CK
-
-    Returns:
-        dep_match: a typeql match statement that depends on other objects
-        dep_insert: a typeql insert statement that depends on other objects
-        indep_ql: a typeql insert statement with no extenral dependencies
-        core_ql: a typeql insert statement that describes the object head, so the independent and dependent parts can be injected seaparately
-
-    """
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    # 1.) get configuration parameters
-    # - variable for use in typeql statements
-    dep_list = []
-    # - work out the type of object
-    obj_type = sro.type
-    total_props, obj_tql, sro_tql_name, protocol = sro_to_data(sro, import_type)
-    sro_var = '$' + sro_tql_name
-    if obj_tql == '':
-        return '', '', '', '', {}
-    # initialise the typeql insert statement
-    dep_match = dep_insert = indep_ql = core_ql = dep_insert_props = ''
-
-    # 2.) setup the match statements first, depending on whether the object is a sighting or a relationship
-    # A. If it is a Relationship then find the source and target roles for the relation, and match them in
-    if obj_type == 'relationship':
-        source_id = sro.source_ref
-        dep_list.append(source_id)
-        source_var, source_match = get_embedded_match(source_id, 0, protocol, import_type)
-        target_id = sro.target_ref
-        dep_list.append(target_id)
-        target_var, target_match = get_embedded_match(target_id, 0, protocol, import_type)
-        dep_match += source_match + target_match
-        # 3.)  then setup the typeql statement to insert the specific sro relation, from the dict, with the matches
-        for record in auth["reln"]["standard_relations"]:
-            if record['stix'] == sro_tql_name:
-                dep_insert += '\n' + sro_var
-                dep_insert += ' (' + record['source'] + ':' + source_var
-                dep_insert += ', ' + record['target'] + ':' + target_var + ')'
-                dep_insert += ' isa ' + record['typeql']
-                core_ql = sro_var + ' isa ' + sro_tql_name
-                core_ql += ', has stix-id $stix-id;\n$stix-id ' + val_tql(sro.id) + ';\n'
-                break
-                # B. If it is a Sighting then match the object to the sighting
-        logger.debug(f'dep_insert -> {dep_insert}')
-    elif obj_type == 'sighting':
-        sighting_of_id = sro.sighting_of_ref
-        dep_list.append(sighting_of_id)
-        sighting_of_var, sighting_of_match = get_embedded_match(sighting_of_id, 0, protocol, import_type)
-        dep_match += ' \n' + sighting_of_match
-        dep_insert += '\n' + sro_var + ' (sighting-of:' + sighting_of_var
-        # if there is observed data list, then add it to the match statement
-        observed_data_list = sro.get("observed_data_refs")
-        if (observed_data_list is not None) and (len(observed_data_list) > 0):
-            for i, observed_data_id in enumerate(observed_data_list):
-                dep_list.append(observed_data_id)
-                observed_data_var, observed_data_match = get_embedded_match(observed_data_id, i, protocol, import_type)
-                dep_match += observed_data_match
-                dep_insert += ', observed:' + observed_data_var
-        # if there is a list of who and where the sighting's occured, then match it in
-        where_sighted_list = sro.get("where_sighted_refs")
-        if (where_sighted_list is not None) and (len(where_sighted_list) > 0):
-            for where_sighted_id in where_sighted_list:
-                dep_list.append(where_sighted_id)
-                where_sighted_var, where_sighted_match = get_embedded_match(where_sighted_id, 1, protocol, import_type)
-                dep_match += where_sighted_match
-                dep_insert += ', where-sighted:' + where_sighted_var
-
-        # then finalise the typeql statement for the sro sighting
-        dep_insert += ') isa sighting'
-        core_ql = sro_var + ' ($role:$any) isa sighting'
-        core_ql += ', has stix-id $stix-id;\n$stix-id ' + val_tql(sro.id) + ';\n'
-    else:
-        logger.error(f'relationship type {obj_type} not supported')
-        return ''
-
-    # 4.) next, split total properties into actual properties and nested structures (Relations)
-    properties, relations = split_on_activity_type(total_props, obj_tql)
-
-    # 5.) add each of the properties and values of the properties to the typeql statement
-    prop_var_list = []
-    for prop in properties:
-        # split off for properties processing
-        dep_insert2, dep_insert_props2, prop_var_list = add_property_to_typeql(prop, obj_tql, sro, prop_var_list)
-        # then add them all together
-        dep_insert += dep_insert2
-        dep_insert_props += dep_insert_props2
-        # add a terminator on the end of the query statement
-    dep_insert += ";\n" + dep_insert_props + "\n\n"
-
-    # 6.) add each of the relations to the match and insert statements
-    for j, rel in enumerate(relations):
-        # split off for relation processing
-        dep_match2, dep_insert2, dep_list2 = add_relation_to_typeql(rel,
-                                                                    sro,
-                                                                    sro_var,
-                                                                    prop_var_list,
-                                                                    import_type,
-                                                                    j,
-                                                                    protocol)
-        # then add it back together
-        dep_match = dep_match + dep_match2
-        dep_insert = dep_insert + dep_insert2
-        dep_list = dep_list + dep_list2
-
-    dep_obj = {"id": sro.id, "dep_list": dep_list, "type": "relation"}
-    return dep_match, dep_insert, indep_ql, core_ql, dep_obj
-
-
-# ---------------------------------------------------
-# 1.3) SCO Object Method to convert a Python object --> typeql string
-#                 -
-# --------------------------------------------------
-def sco_to_data(sco, import_type=default_import_type) -> [dict, dict, str]:
-    """ convert Stix object into a data model for processing
-
-        Args:
-            sco (): the Stix2 sco object
-            import_type (): the type of import to use
-
-        Returns:
-            total_props, : a list of all properties
-            obj_tql : the dict of the twl proeprties
-
-    """
-    # - list of property names that have values
-    total_props = sco._inner
-    total_props = clean_props(total_props)
-    # logger.debug(properties)
-    # - work out the type of object
-    sco_tql_name = sco.type
-    # - get the object-specific typeql names, sighting or relationship
-    obj_tql, sco_tql_name, is_list, protocol = sco__type_to_tql(sco_tql_name, import_type)
-
-    return total_props, obj_tql, sco_tql_name, protocol
-
-
-def sco_to_typeql(sco, import_type=default_import_type):
-    """
-    Initial function to convert Stix2 SCO object into typeql
-
-    Args:
-        sco (): valid Stix2 object
-        import_type (): string, either Stix2 or ATT&CK
-
-    Returns:
-        dep_match: a typeql match statement that depends on other objects
-        dep_insert: a typeql insert statement that depends on other objects
-        indep_ql: a typeql insert statement with no extenral dependencies
-        core_ql: a typeql insert statement that describes the object head, so the independent and dependent parts can be injected seaparately
-
-    """
-    # 1.) get configuration parameters
-    # - variable for use in typeql statements
-    sco_var = '$' + sco.type
-    dep_list = []
-    # initialise the typeql insert statement
-    dep_match = dep_insert = indep_ql = core_ql = dep_insert_props = ''
-
-    # 1.C) Split them into properties and relations
-    total_props, obj_tql, sco_tql_name, protocol = sco_to_data(sco, import_type)
-    properties, relations = split_on_activity_type(total_props, obj_tql)
-
-    # 2.) setup the typeql statement for the sco entity
-    dep_insert = sco_var + ' isa ' + sco.type
-    core_ql = sco_var + ' isa ' + sco.type + ', has stix-id $stix-id;\n$stix-id ' + val_tql(sco.id) + ';\n'
-
-    # 3.) add each of the properties and values of the properties to the typeql statement
-    # 5.) add each of the properties and values of the properties to the typeql statement
-    prop_var_list = []
-    for prop in properties:
-        # split off for properties processing
-        dep_insert2, dep_insert_props2, prop_var_list = add_property_to_typeql(prop, obj_tql, sco, prop_var_list)
-        # then add them all together
-        dep_insert += dep_insert2
-        dep_insert_props += dep_insert_props2
-        # add a terminator on the end of the insert statement
-    dep_insert += ";\n" + dep_insert_props + "\n\n"
-
-    # 6.) add each of the relations to the match and insert statements
-    for j, rel in enumerate(relations):
-        # split off for relation processing
-        dep_match2, dep_insert2, dep_list2 = add_relation_to_typeql(rel, sco, sco_var, prop_var_list, import_type, j, protocol)
-        # then add it back together
-        dep_match = dep_match + dep_match2
-        dep_insert = dep_insert + dep_insert2
-        dep_list = dep_list + dep_list2
-
-    dep_obj = {"id": sco.id, "dep_list": dep_list, "type": sco.type}
-    return dep_match, dep_insert, indep_ql, core_ql, dep_obj
-
-
-# ---------------------------------------------------
-# 1.4) Meta Object Method to convert a Python object --> typeql string
-#                 -  marking definitions, statement, colour and Mitre copyright
-# --------------------------------------------------
-
-
-def marking_definition_to_typeql(meta, import_type=default_import_type):
-    """
-    Initial function to convert Stix2 marking object into typeql
-
-    Args:
-        meta (): valid Stix2 object
-        import_type (): string, either Stix2 or ATT&CK
-
-    Returns:
-        dep_match: a typeql match statement that depends on other objects
-        dep_insert: a typeql insert statement that depends on other objects
-        indep_ql: a typeql insert statement with no extenral dependencies
-        core_ql: a typeql insert statement that describes the object head, so the independent and dependent parts can be injected seaparately
-
-    """
-    total_props = meta._inner
-    total_props = clean_props(total_props)
-    dep_list = []
-    statement = {}
-    dep_match = dep_insert = indep_ql = core_ql = ''
-    # 1.A) if one of the existing colours, return an empty string
-    if meta.id in marking:
-        return dep_match, dep_insert, indep_ql, core_ql, {}
-    # 1.B) Test for attack object and handle statement if a statement marking
-    attack_object = False if not meta.get("x_mitre_attack_spec_version", False) else True
-    if total_props.get("definition", False):
-        statement = total_props["definition"]
-        total_props.update(statement)
-
-    obj_tql, meta_tql_name, is_list, protocol = meta_type_to_tql(meta.type, import_type, attack_object)
-
-    properties, relations = split_on_activity_type(total_props, obj_tql)
-
-    # 2.) setup the typeql statement for the sdo entity
-    meta_var = '$' + meta_tql_name
-    indep_ql = meta_var + ' isa ' + meta_tql_name
-    core_ql = meta_var + ' isa ' + meta_tql_name + ', has stix-id $stix-id;\n$stix-id ' + val_tql(meta.id) + ';\n'
-    indep_ql_props = dep_match = dep_insert = ''
-    logger.debug("----> Step 2 meta to typeql")
-    # 3.) add each of the properties and values of the properties to the typeql statement
-    prop_var_list = []
-    for prop in properties:
-        # split off for properties processing
-        indep_ql2, indep_ql_props2, prop_var_list = add_property_to_typeql(prop, obj_tql, meta, prop_var_list)
-        # then add them all together
-        indep_ql += indep_ql2
-        indep_ql_props += indep_ql_props2
-        # add a terminator on the end of the query statement
-    indep_ql += ";\n" + indep_ql_props + "\n\n"
-    logger.debug("----> Step 3 sdo to typeql")
-
-    # 4.) add each of the relations to the match and insert statements
-    for j, rel in enumerate(relations):
-        # split off for relation processing
-        dep_match2, dep_insert2, dep_list2 = add_relation_to_typeql(rel, meta, meta_var, prop_var_list, import_type, j,
-                                                                    protocol)
-        # then add it back together
-        dep_match = dep_match + dep_match2
-        dep_insert = dep_insert + dep_insert2
-        dep_list = dep_list + dep_list2
-
-    logger.debug("----> Step 4 sdo to typeql")
-    dep_obj = {"id": meta.id, "dep_list": dep_list, "type": meta.type}
-    return dep_match, dep_insert, indep_ql, core_ql, dep_obj
-
-    # # if the marking is a colour, match it in, else it is a statement type
-    # if stix_object.definition_type == "statement":
-    #     if attack_object:
-    #         indep_ql = '\n $marking isa attack-marking'
-    #         indep_ql += ',\n has x-mitre-attack-spec-version ' + val_tql(stix_object.x_mitre_attack_spec_version)
-    #         loc_list = stix_object.x_mitre_domains
-    #         for dom in loc_list:
-    #             indep_ql += ',\n has x-mitre-domains ' + val_tql(dom)
-    #         core_ql = '$marking isa attack-marking'
-    #     else:
-    #         indep_ql = '\n $marking isa statement-marking'
-    #         core_ql = '$marking isa statement-marking'
-    #     indep_ql += ',\n has statement ' + val_tql(stix_object.definition.statement)
-    #     indep_ql += ',\n has stix-type "marking-definition"'
-    #     indep_ql += ',\n has stix-id ' + val_tql(stix_object.id)
-    #     indep_ql += ',\n has created ' + val_tql(stix_object.created)
-    #     indep_ql += ',\n has spec-version ' + val_tql(stix_object.spec_version)
-    #     indep_ql += ';\n'
-    #     core_ql += ', has stix-id $stix-id;\n$stix-id ' + val_tql(stix_object.id)
-    #     core_ql += ';'
-    #
-    # dep_obj = {"id": stix_object.id, "dep_list": dep_list, "type": "marking"}
-    # return dep_match, dep_insert, indep_ql, core_ql, dep_obj
+import datetime
+from typing import List, Dict
+from stixorm.module.authorise import authorised_mappings
+import copy
+
+import logging
+
+from stixorm.module.typedb_lib.factories.auth_factory import get_auth_factory_instance
+from stixorm.module.typedb_lib.factories.definition_factory import get_definition_factory_instance
+from stixorm.module.typedb_lib.factories.import_type_factory import ImportType
+from stixorm.module.typedb_lib.model.definitions import DefinitionName
+
+stix_models = get_definition_factory_instance().lookup_definition(DefinitionName.STIX_21)
+logger = logging.getLogger(__name__)
+
+
+# ---------------------------------------------------
+# 1.5) Sub Object Methods for adding common standard properties
+#                -  e.g. stix-type, stix-id, name, description etc.
+# --------------------------------------------------
+
+
+def clean_props(total_props):
+    """
+        Future function to clean the list of properties
+    Args:
+        total_props []:
+
+    Returns:
+        total_props []:
+    """
+    # remove the properties that are mistakes
+
+    return total_props
+
+
+def add_property_to_typeql(prop, obj_tql, obj, prop_var_list):
+    """
+        Add a property by typeql
+    Args:
+        prop (): property
+        obj_tql (): the tql that applies to this
+        obj (): the stix object this is part of
+        prop_var_list ():
+
+    Returns:
+        type_ql, the basic typeql statement for the property
+        type_ql_props, the typeql statement that defines the property
+        prop_var_list, a list of dicts describing the property
+    """
+    type_ql = type_ql_props = ''
+    tql_prop_name = obj_tql[prop]
+    # if property is defanged, summary or revoked, and the value is false, then don't add it to typedb_lib description
+    if prop == "defanged" and obj.defanged == False:
+        return type_ql, type_ql_props, prop_var_list
+    elif prop == "revoked" and obj.revoked == False:
+        return type_ql, type_ql_props, prop_var_list
+    elif prop == "summary" and obj.summary == False:
+        return type_ql, type_ql_props, prop_var_list
+
+    # or else add the property to the typeql statement
+    if isinstance(obj[prop], list):
+        # if the property is a list, add each item to the typeql statement
+        for i, instance in enumerate(obj[prop]):
+            prop_var_dict = {}
+            # import statements for each of the list items
+            prop_var = '$' + prop + str(i)
+            type_ql += ',\n has ' + tql_prop_name + ' ' + prop_var
+            type_ql_props += '\n ' + prop_var + ' ' + val_tql(instance) + ';'
+            prop_var_dict["prop_var"] = prop_var
+            prop_var_dict["prop"] = prop
+            prop_var_dict["index"] = i
+            prop_var_list.append(prop_var_dict)
+    else:
+        prop_var_dict = {}
+        # import statements for a single value
+        prop_var = '$' + tql_prop_name
+        type_ql += ',\n has ' + tql_prop_name + ' ' + prop_var
+        type_ql_props += '\n ' + prop_var + ' ' + val_tql(obj[prop]) + ';'
+        prop_var_dict["prop_var"] = prop_var
+        prop_var_dict["prop"] = prop
+        prop_var_dict["index"] = -1
+        prop_var_list.append(prop_var_dict)
+
+    return type_ql, type_ql_props, prop_var_list
+
+
+# ---------------------------------------------------
+# 1.6) Sub Object Methods for adding embedded structures
+#                -  e.g. hasehs, kill-chain-phases, created_by, external_references, object_marking_refs etc.
+# --------------------------------------------------
+# Giant Switch statement to add the embedded relations to the typeql statement
+
+def add_relation_to_typeql(rel,
+                           obj,
+                           obj_var,
+                           prop_var_list,
+                           import_type: ImportType,
+                           inc,
+                           protocol: str):
+    """
+        Top level function to add one of the sub objects to the stix object
+    Args:
+        rel (): the relation object to add
+        obj (): the stix object to add it too
+        obj_var (): the typeql variable string
+        prop_var_list (): the property variable list
+        import_type: the dict describing import preferences
+        inc (): an incrementing variable that is used to add to the var string
+
+    Returns:
+        match: the typeql match strings
+        insert: the typeql insert string
+    """
+    logger.debug(f'===============\n=====================\n===================\n')
+    logger.debug(f'rel {rel}')
+    logger.debug(f'obj[rel] {obj[rel]}')
+    logger.debug(f'obj {obj}')
+    logger.debug(f'obj_Var {obj_var}')
+    logger.debug(f'\nprop var list {prop_var_list}')
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    dep_list = []
+    logger.debug("\nstarting into choices")
+    if rel == "granular_markings":
+        logger.debug("in granular")
+        match, insert = granular_markings(rel, obj[rel], obj_var, prop_var_list)
+
+    # hashes type
+    elif (rel == "hashes"
+          or rel == "file_header_hashes"):
+        logger.debug("in hashes")
+        match, insert = hashes(rel, obj[rel], obj_var)
+
+    # insert key value store
+    elif rel in auth["reln_name"]["key_value_relations"]:
+        logger.debug("in key value")
+        match, insert = key_value_store(rel, obj[rel], obj_var, import_type)
+
+    # insert list of object relation
+    elif rel in auth["reln_name"]["list_of_objects"]:
+        logger.debug("list of objects")
+        match, insert, dep_list = list_of_object(rel, obj[rel], obj_var, inc, import_type, protocol)
+
+    # insert embedded relations based on stix-id
+    elif rel in auth["reln_name"]["embedded_relations"]:
+        logger.debug("embedded")
+        match, insert, dep_list = embedded_relation(rel, obj[rel], obj_var, inc, import_type, protocol)
+
+    # insert plain sub-object with relation
+    elif (rel == "x509_v3_extensions"
+          or rel == "optional_header"):
+        logger.debug("X509")
+        match, insert, dep_list = load_object(rel, obj[rel], obj_var, inc, import_type, protocol)
+
+    # insert  SCO Extensions here, a possible dict of sub-objects
+    elif rel in auth["reln_name"]["extension_relations"] or rel == "extensions":
+        logger.debug("extension")
+        match, insert, dep_list = extensions(rel, obj[rel], obj_var, inc, import_type, protocol)
+
+    # ignore the following relations as they are already processed, for Relationships, Sightings and Extensions
+    elif rel in auth["reln_name"]["standard_relations"] or rel == "definition" or "definition_type":
+        logger.debug("standard")
+        match = insert = ''
+
+    else:
+        logger.debug(f'relation type not known, ignore if "source_ref" or "target_ref" -> {rel}')
+        logger.debug("in else")
+        match = insert = ""
+
+    return match, insert, dep_list
+
+
+# ---------------------------------------------------
+# Methods for adding the embedded structures to the typeql statement
+# --------------------------------------------------
+# generic methods
+
+
+def extensions(prop_name: str,
+               prop_dict,
+               parent_var,
+               inc,
+               import_type: ImportType,
+               protocol: str):
+    """
+        Create the Typeql for the extensions sub object
+    Args:
+        prop_name (): the name of the extension
+        prop_dict (): the dict for the extension
+        parent_var (): the var of the Stix object that is the owner
+        import_type: the dict describing import preferences
+
+    Returns:
+        match: the typeql match string
+        insert: the typeql insert string
+    """
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    match = insert = ''
+    dep_list = []
+    # for each key in the dict (extension type)
+    # logger.debug('--------------------- extensions ----------------------------')
+    for ext_type in prop_dict:
+        for ext_type_ql in auth["reln"]["extension_relations"]:
+            if ext_type == ext_type_ql["stix"]:
+                match2, insert2, dep_list2 = load_object(ext_type, prop_dict[ext_type], parent_var, inc, import_type, protocol)
+                match = match + match2
+                insert = insert + insert2
+                dep_list = dep_list + dep_list2
+                break
+
+    return match, insert, dep_list
+
+
+def load_object(prop_name: str,
+                prop_dict,
+                parent_var: str,
+                inc,
+                import_type: ImportType,
+                protocol: str):
+    """
+        Create the Typeql for a sub object
+    Args:
+        prop_name (): the name of the extension
+        prop_dict (): the dict for the extension
+        parent_var (): the var of the Stix object that is the owner
+        import_type: the dict describing import preferences
+
+    Returns:
+        match: the typeql match string
+        insert: the typeql insert string
+    """
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    match = insert = type_ql = type_ql_props = ''
+    # as long as it is predefined, history the object
+    # logger.debug('------------------- history object ------------------------------')
+    for prop_type in auth["reln"]["extension_relations"]:
+        if prop_name == prop_type["stix"]:
+            tot_prop_list = [tot for tot in prop_dict.keys()]
+            obj_type = prop_type["object"]
+            obj_tql = copy.deepcopy(auth["sub_objects"][obj_type])
+            obj_var = '$' + obj_type
+            reln = prop_type["relation"]
+            rel_var = '$' + reln
+            rel_owner = prop_type["owner"]
+            rel_pointed_to = prop_type["pointed-to"]
+            type_ql += ' ' + obj_var + ' isa ' + obj_type
+            # Split them into properties and relations
+            total_props = prop_dict._inner
+            logger.debug(f'load object properties: {total_props}')
+            properties, relations = split_on_activity_type(total_props, obj_tql)
+            prop_var_list = []
+            dep_list = []
+            logger.debug(f'load object relations: {relations}')
+            for prop in properties:
+                # split off for properties processing
+                type_ql2, type_ql_props2, prop_var_list = add_property_to_typeql(prop, obj_tql, prop_dict,
+                                                                                 prop_var_list)
+                # then add them all together
+                type_ql += type_ql2
+                type_ql_props += type_ql_props2
+                # add a terminator on the end of the insert statement
+            type_ql += ";\n" + type_ql_props + "\n\n"
+
+            # add each of the relations to the match and insert statements
+            logger.debug(f'load object relations: {relations}')
+            for rel in relations:
+                # split off for relation processing
+                logger.debug(f'load object relation: {rel}, protocol: {protocol}')
+                match2, insert2, dep_list2 = add_relation_to_typeql(rel, prop_dict, obj_var, prop_var_list, import_type, inc, protocol)
+                # then add it back together    
+                match = match + match2
+                insert = insert + "\n" + insert2
+                dep_list = dep_list + dep_list2
+
+            # finally, connect the local object to the parent object
+            type_ql += ' ' + rel_var + ' (' + rel_owner + ':' + parent_var
+            type_ql += ', ' + rel_pointed_to + ':' + obj_var + ')'
+            type_ql += ' isa ' + reln + ';\n'
+            break
+
+    insert = type_ql + "\n" + insert
+    return match, insert, dep_list
+
+
+def list_of_object(prop_name: str,
+                   prop_value_list: List[str],
+                   parent_var,
+                   inc,
+                   import_type: ImportType,
+                   protocol: str):
+    """
+        Create the Typeql for the list of object sub object
+    Args:
+        prop_name (): the name of the object
+        prop_value_list (): the list of object
+        parent_var (): the var of the Stix object that is the owner
+        import_type: the dict describing import preferences
+
+    Returns:
+        match: the typeql match string
+        insert: the typeql insert string
+    """
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    for config in auth["reln"]["list_of_objects"]:
+        if config["name"] == prop_name:
+            rel_typeql = config["typeql"]
+            role_owner = config["owner"]
+            role_pointed = config["pointed_to"]
+            typeql_obj = config["object"]
+            break
+
+    if typeql_obj in auth["sub_objects"]:
+        obj_props_tql = copy.deepcopy(auth["sub_objects"][typeql_obj])
+    else:
+        raise ValueError("no sub-object available")
+
+    lod_list = []
+    dep_list = []
+    match = rel_insert = rel_match = insert = ''
+    for i, dict_instance in enumerate(prop_value_list):
+        lod_var = '$' + typeql_obj + str(i)
+        lod_list.append(lod_var)
+        insert += lod_var + ' isa ' + typeql_obj
+        for key in dict_instance:
+            typeql_prop = obj_props_tql[key]
+            if typeql_prop == '':
+                rel_match2, rel_insert2, dep_list2 = add_relation_to_typeql(key, dict_instance, lod_var, [], import_type, i, protocol)
+                rel_insert += rel_insert2
+                rel_match += rel_match2
+                dep_list = dep_list + dep_list2
+            else:
+                insert += ',\n has ' + typeql_prop + ' ' + val_tql(dict_instance[key])
+        insert += ';\n'
+
+    insert += '\n $' + rel_typeql + ' (' + role_owner + ':' + parent_var
+    for lod_var in lod_list:
+        insert += ', ' + role_pointed + ':' + lod_var
+
+    insert += ') isa ' + rel_typeql + ';\n' + rel_insert
+    match += rel_match
+    return match, insert, dep_list
+
+
+def key_value_store(prop,
+                    prop_value_dict,
+                    obj_var,
+                    import_type: ImportType):
+    """
+        Create the Typeql for the key-value store sub object
+    Args:
+        prop (): the name of the object
+        prop_value_dict (): the dict of object
+        obj_var (): the var of the Stix object that is the owner
+        import_type: the dict describing import preferences
+
+    Returns:
+        match: the typeql match string
+        insert: the typeql insert string
+    """
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    for config in auth["reln"]["key_value_relations"]:
+        if config["name"] == prop:
+            rel_typeql = config["typeql"]
+            role_owner = config["owner"]
+            role_pointed = config["pointed_to"]
+            d_key = config["key"]
+            d_value = config["value"]
+            break
+
+    match = ''
+    insert = '\n'
+    field_var_list = []
+    for i, key in enumerate(prop_value_dict):
+        a_value = prop_value_dict[key]
+        key_var = ' $' + d_key + str(i)
+        field_var_list.append(key_var)
+        insert += key_var + ' isa ' + d_key + '; ' + key_var + ' "' + key + '";\n'
+        if isinstance(a_value, list):
+            for j, n in enumerate(a_value):
+                value_var = ' $' + d_value + str(j)
+                insert += key_var + ' ' + 'has ' + d_value + ' "' + str(n) + '";\n'
+        else:
+            value_var = ' $' + d_value + str(i)
+            insert += key_var + ' ' + 'has ' + d_value + ' "' + str(a_value) + '";\n'
+
+    insert += ' $' + rel_typeql + ' (' + role_owner + ':' + obj_var
+    for var in field_var_list:
+        insert += ', ' + role_pointed + ':' + var
+    insert += ') isa ' + rel_typeql + ';\n\n'
+    return match, insert
+
+
+# specific methods
+def hashes(prop_name, prop_dict, parent_var):
+    """
+        Create the Typeql for the hashes sub object
+    Args:
+        prop_name (): the name of the object
+        prop_dict (): the dict of object
+        parent_var (): the var of the Stix object that is the owner
+
+    Returns:
+        match: the typeql match string
+        insert: the typeql insert string
+    """
+    match = insert = ''
+    hash_var_list = []
+    for i, key in enumerate(prop_dict):
+        hash_var = '$hash' + str(i)
+        hash_var_list.append(hash_var)
+        if key in stix_models.get_sub_objects("hash_typeql_dict"):
+            insert += ' ' + hash_var + ' isa ' + stix_models.get_sub_objects("hash_typeql_dict")[
+                key] + ', has hash-value ' + val_tql(prop_dict[key]) + ';\n'
+        else:
+            logger.error(f'Unknown hash type {key}')
+
+    # insert the hash objects into the hashes relation with the parent object
+    insert += '\n $hash_rel (owner:' + parent_var
+    for hash_var in hash_var_list:
+        insert += ', pointed-to:' + hash_var
+
+    insert += ') isa hashes;\n'
+    return match, insert
+
+
+def granular_markings(prop_name, prop_value_List, parent_var, prop_var_list):
+    """
+        Create the Typeql for the granular markings sub object
+    Args:
+        prop_name (): the name of the object
+        prop_value_List (): the list of object values
+        parent_var (): the var of the Stix object that is the owner
+        prop_var_list: the list of property variables
+
+    Returns:
+        match: the typeql match string
+        insert: the typeql insert string
+    """
+    match = insert = ''
+    for i, prop_dict in enumerate(prop_value_List):
+        # setup and match in the marking, based on its id
+        m_id = prop_dict['marking_ref']
+        m_var = '$marking' + str(i)
+        g_var = '$granular' + str(i)
+        match += ' ' + m_var + ' isa marking-definition, has stix-id ' + '"' + m_id + '";\n'
+        insert += ' ' + g_var + ' (marking:' + m_var + ', object:' + parent_var
+        prop_list = prop_dict['selectors']
+        for selector in prop_list:
+            selector_var = get_selector_var(selector, prop_var_list)
+            insert += ', marked:' + selector_var
+
+        insert += ') isa granular-marking;\n'
+
+    return match, insert
+
+
+def get_selector_var(selector, prop_var_list):
+    """
+        Get the typeql variable for the property
+    Args:
+        selector (): the property to select
+        prop_var_list (): the variable list to select from
+
+    Returns:
+        selector_var: the typeql variable for the property
+    """
+    if selector[-1] == ']':
+        text = selector.split(".")
+        selector = text[0]
+        index = int(text[1][1])
+    else:
+        selector = selector
+        index = -1
+
+    # logger.debug(f'selector after processing -> {selector}, index after procesing -> {index}')
+    for prop_var_dict in prop_var_list:
+        if selector == prop_var_dict['prop'] and index == prop_var_dict['index']:
+            selector_var = prop_var_dict['prop_var']
+            break
+
+    return selector_var
+
+
+# ---------------------------------------------------
+#        EMBEDDED RELATION METHODS
+# ---------------------------------------------------
+# object_refs
+# sample_refs
+# sample_ref
+# host_vm_ref
+# operating_system_ref
+# installed_software_refs
+# analysis_sco_refs
+# etc.
+
+def  embedded_relation(prop,
+                      prop_value,
+                      obj_var,
+                      inc: int,
+                      import_type: ImportType,
+                      protocol: str):
+    """
+        Create the Typeql for the embedded relation sub object
+    Args:
+        prop (): the name of the object
+        prop_value (): the value of object
+        obj_var (): the var of the Stix object that is the owner
+
+    Returns:
+        match: the typeql match string
+        insert: the typeql insert string
+    """
+    logger.debug("I'm in embedded")
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    for ex in auth["reln"]["embedded_relations"]:
+        if ex["rel"] == prop:
+            owner = ex["owner"]
+            pointed_to = ex["pointed-to"]
+            relation = ex["typeql"]
+            break
+
+    prop_var_list = []
+    dep_list = []
+    match = ''
+    if inc == -1:
+        inc_add = ''
+    else:
+        inc_add = str(inc)
+    # if the prop_value is a list, then match in each item
+    logger.debug(f'\n1\n')
+    if isinstance(prop_value, list):
+        dep_list = prop_value
+        logger.debug(f'deplist {dep_list}')
+        for i, prop_v in enumerate(prop_value):
+            prop_type = get_source_from_id(prop_v, protocol, import_type)
+            if prop_type == 'relationship':
+                prop_type = 'stix-core-relationship'
+            prop_var = '$' + prop_type + str(i) + inc_add
+            prop_var_list.append(prop_var)
+            match += ' ' + prop_var + ' isa ' + prop_type + ', has stix-id ' + '"' + prop_v + '";\n'
+    # else, match in the single prop_value
+    else:
+        dep_list.append(prop_value)
+        prop_type = get_source_from_id(prop_value, protocol, import_type)
+        logger.debug(f'deplist {dep_list}')
+        if prop_type == 'relationship':
+            prop_type = 'stix-core-relationship'
+        prop_var = '$' + prop_type + inc_add
+        prop_var_list.append(prop_var)
+        match += ' ' + prop_var + ' isa ' + prop_type + ', has stix-id ' + '"' + prop_value + '";\n'
+
+    # Then setup and insert the relation
+    logger.debug(f'\n2\n')
+    insert = '\n $' + relation + inc_add + ' (' + owner + ':' + obj_var
+    for prop_var in prop_var_list:
+        insert += ', ' + pointed_to + ':' + prop_var
+    insert += ') isa ' + relation + ';\n'
+    return match, insert, dep_list
+
+
+def get_source_from_id(stid: str,
+                       protocol: str,
+                       import_type: ImportType):
+    """
+        Get the source of the stix object
+    Args:
+        stid (): the stix-id of the object
+
+    Returns:
+        source: the source of the object
+    """
+    tmp_source = stid.split('--')[0]
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    source = ""
+    for model in auth["conv"]["sdo"]:
+        if model["protocol"] == protocol and model["type"] == tmp_source:
+            source = model["typeql"]
+            return source
+    for model in auth["conv"]["sro"]:
+        if model["protocol"] == protocol and model["type"] == tmp_source:
+            source = model["typeql"]
+            if source == 'relationship' or source == "attack-relation":
+                source = 'stix-core-relationship'
+            return source
+    for model in auth["conv"]["sco"]:
+        if model["protocol"] == protocol and model["type"] == tmp_source:
+            source = model["typeql"]
+            return source
+    for model in auth["conv"]["meta"]:
+        if model["protocol"] == protocol and model["type"] == tmp_source:
+            source = model["typeql"]
+            return source
+    for model in auth["conv"]["sdo"]:
+        if model["type"] == tmp_source:
+            source = model["typeql"]
+            return source
+    for model in auth["conv"]["sro"]:
+        if model["type"] == tmp_source:
+            source = model["typeql"]
+            return source
+    for model in auth["conv"]["sco"]:
+        if model["type"] == tmp_source:
+            source = model["typeql"]
+            return source
+    for model in auth["conv"]["meta"]:
+        if model["type"] == tmp_source:
+            source = model["typeql"]
+            return source
+    return source
+
+
+def get_embedded_match(source_id: str,
+                       i: int,
+                       protocol: str,
+                       import_type: ImportType):
+    """
+        Assemble the typeql variable and match statement given the stix-id, and the increment
+    Args:
+        source_id (): stix-id to use
+        i (): number of times this type of object has been used
+
+    Returns:
+        source_var, the typeql string of the variable
+        match, the typeql match statement
+    """
+    source_type = get_source_from_id(source_id, protocol, import_type)
+    source_var = '$' + source_type + str(i)
+    if source_type == 'relationship' or source_type == "attack-relation":
+        source_type = 'stix-core-relationship'
+    match = f' {source_var} isa {source_type}, has stix-id "{source_id}";\n'
+    return source_var, match
+
+
+def get_full_object_match(source_id: str, protocol: str, import_type: ImportType):
+    """
+        Return a typeql match statement for this stix object
+    Args:
+        source_id (): the stix-id to look for
+
+    Returns:
+        source_var, the typeql string of the variable
+        match, the typeql match statement
+    """
+    source_var, match = get_embedded_match(source_id, 0, protocol, import_type)
+    match += source_var + ' has $properties;\n'
+    # match += '$embedded (owner:' + source_var + ', pointed-to:$point ) isa embedded;\n'
+    return source_var, match
+
+
+# ---------------------------------------------------
+# 1.7) Helper Methods for 
+#           - converting a Python value --> typeql string
+#           - splitting a list of total properties into properties and relations
+# ---------------------------------------------------
+
+
+def val_tql(val):
+    """
+        Modify the value used in a typeql statement, depending on its type
+    Args:
+        val (): the value being used
+
+    Returns:
+        val: the value formatted for typeql
+    """
+    if isinstance(val, str):
+        replaced_val = val.replace('"', "'")
+        replaced_val2 = replaced_val.replace('\\', '\\\\')
+        return '"' + replaced_val2 + '"'
+    elif isinstance(val, bool):
+        return str(val).lower()
+    elif isinstance(val, int):
+        return str(val)
+    elif isinstance(val, float):
+        return str(val)
+    elif isinstance(val, datetime.datetime):
+        return str(val.strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3])
+    else:
+        return logger.error(f'value  not supported: {val}')
+
+
+def split_on_activity_type(total_props: dict, obj_tql: Dict[str, str]) -> [List[str], List[str]]:
+    """
+        Split the Stix object properties into flat properties and sub objects
+    Args:
+        total_props (): the total properties for this object
+        obj_tql (): the mapping dict for this object
+
+    Returns:
+        prop_list, a list of the flat properties
+        rel_list, a list of the sub objects
+    """
+    prop_list = []
+    rel_list = []
+    logger.debug("@@@@@@@@@@@@@@@@@@@@@@ splitting @@@@@@@@@@@@@@@")
+    logger.debug("========================================")
+    logger.debug(f'total props: {total_props}')
+    # for k, v in total_props.items():
+    #     logger.debug(k, v)
+    # logger.debug("=========================================")
+    logger.debug("========================================")
+    logger.debug(f'obj tql: {obj_tql}')
+    # for k, v in obj_tql.items():
+    #     logger.debug(k, v)
+    # logger.debug("=========================================")
+    logger.debug("@@@@@@@@@@@@@@@@@@@@@@ end splitting @@@@@@@@@@@@@@@")
+    for prop in total_props:
+        tql_prop_name = obj_tql[prop]
+        logger.debug(f'prop {prop}, object tql -> {tql_prop_name}')
+
+        if tql_prop_name == "":
+            rel_list.append(prop)
+            # logger.debug(f'Im a rel --> {prop},        tql --> {tql_prop_name}')
+        else:
+            prop_list.append(prop)
+            # logger.debug(f'Im a prop --> {prop},        tql --> {tql_prop_name}')
+
+    return prop_list, rel_list
+
+###################################################################################################
```

### Comparing `stixorm-0.1.3/stixorm/module/orm/import_utilities.py` & `stixorm-0.1.9/stixorm/module/orm/import_objects.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,727 +1,537 @@
-import datetime
-from typing import List, Dict
-from stixorm.module.authorise import authorised_mappings
-import copy
-
-import logging
-
-from stixorm.module.typedb_lib.factories.auth_factory import get_auth_factory_instance
-from stixorm.module.typedb_lib.factories.definition_factory import get_definition_factory_instance
-from stixorm.module.typedb_lib.factories.import_type_factory import ImportType
-from stixorm.module.typedb_lib.model.definitions import DefinitionName
-
-stix_models = get_definition_factory_instance().lookup_definition(DefinitionName.STIX_21)
-logger = logging.getLogger(__name__)
-
-
-# ---------------------------------------------------
-# 1.5) Sub Object Methods for adding common standard properties
-#                -  e.g. stix-type, stix-id, name, description etc.
-# --------------------------------------------------
-
-
-def clean_props(total_props):
-    """
-        Future function to clean the list of properties
-    Args:
-        total_props []:
-
-    Returns:
-        total_props []:
-    """
-    # remove the properties that are mistakes
-
-    return total_props
-
-
-def add_property_to_typeql(prop, obj_tql, obj, prop_var_list):
-    """
-        Add a property by typeql
-    Args:
-        prop (): property
-        obj_tql (): the tql that applies to this
-        obj (): the stix object this is part of
-        prop_var_list ():
-
-    Returns:
-        type_ql, the basic typeql statement for the property
-        type_ql_props, the typeql statement that defines the property
-        prop_var_list, a list of dicts describing the property
-    """
-    type_ql = type_ql_props = ''
-    tql_prop_name = obj_tql[prop]
-    # if property is defanged, summary or revoked, and the value is false, then don't add it to typedb_lib description
-    if prop == "defanged" and obj.defanged == False:
-        return type_ql, type_ql_props, prop_var_list
-    elif prop == "revoked" and obj.revoked == False:
-        return type_ql, type_ql_props, prop_var_list
-    elif prop == "summary" and obj.summary == False:
-        return type_ql, type_ql_props, prop_var_list
-
-    # or else add the property to the typeql statement
-    if isinstance(obj[prop], list):
-        # if the property is a list, add each item to the typeql statement
-        for i, instance in enumerate(obj[prop]):
-            prop_var_dict = {}
-            # import statements for each of the list items
-            prop_var = '$' + prop + str(i)
-            type_ql += ',\n has ' + tql_prop_name + ' ' + prop_var
-            type_ql_props += '\n ' + prop_var + ' ' + val_tql(instance) + ';'
-            prop_var_dict["prop_var"] = prop_var
-            prop_var_dict["prop"] = prop
-            prop_var_dict["index"] = i
-            prop_var_list.append(prop_var_dict)
-    else:
-        prop_var_dict = {}
-        # import statements for a single value
-        prop_var = '$' + tql_prop_name
-        type_ql += ',\n has ' + tql_prop_name + ' ' + prop_var
-        type_ql_props += '\n ' + prop_var + ' ' + val_tql(obj[prop]) + ';'
-        prop_var_dict["prop_var"] = prop_var
-        prop_var_dict["prop"] = prop
-        prop_var_dict["index"] = -1
-        prop_var_list.append(prop_var_dict)
-
-    return type_ql, type_ql_props, prop_var_list
-
-
-# ---------------------------------------------------
-# 1.6) Sub Object Methods for adding embedded structures
-#                -  e.g. hasehs, kill-chain-phases, created_by, external_references, object_marking_refs etc.
-# --------------------------------------------------
-# Giant Switch statement to add the embedded relations to the typeql statement
-
-def add_relation_to_typeql(rel,
-                           obj,
-                           obj_var,
-                           prop_var_list,
-                           import_type: ImportType,
-                           inc,
-                           protocol: str):
-    """
-        Top level function to add one of the sub objects to the stix object
-    Args:
-        rel (): the relation object to add
-        obj (): the stix object to add it too
-        obj_var (): the typeql variable string
-        prop_var_list (): the property variable list
-        import_type: the dict describing import preferences
-        inc (): an incrementing variable that is used to add to the var string
-
-    Returns:
-        match: the typeql match strings
-        insert: the typeql insert string
-    """
-    logger.debug(f'===============\n=====================\n===================\n')
-    logger.debug(f'rel {rel}')
-    logger.debug(f'obj[rel] {obj[rel]}')
-    logger.debug(f'obj {obj}')
-    logger.debug(f'obj_Var {obj_var}')
-    logger.debug(f'\nprop var list {prop_var_list}')
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    dep_list = []
-    logger.debug("\nstarting into choices")
-    if rel == "granular_markings":
-        logger.debug("in granular")
-        match, insert = granular_markings(rel, obj[rel], obj_var, prop_var_list)
-
-    # hashes type
-    elif (rel == "hashes"
-          or rel == "file_header_hashes"):
-        logger.debug("in hashes")
-        match, insert = hashes(rel, obj[rel], obj_var)
-
-    # insert key value store
-    elif rel in auth["reln_name"]["key_value_relations"]:
-        logger.debug("in key value")
-        match, insert = key_value_store(rel, obj[rel], obj_var, import_type)
-
-    # insert list of object relation
-    elif rel in auth["reln_name"]["list_of_objects"]:
-        logger.debug("list of objects")
-        match, insert, dep_list = list_of_object(rel, obj[rel], obj_var, inc, import_type, protocol)
-
-    # insert embedded relations based on stix-id
-    elif rel in auth["reln_name"]["embedded_relations"]:
-        logger.debug("embedded")
-        match, insert, dep_list = embedded_relation(rel, obj[rel], obj_var, inc, import_type, protocol)
-
-    # insert plain sub-object with relation
-    elif (rel == "x509_v3_extensions"
-          or rel == "optional_header"):
-        logger.debug("X509")
-        match, insert, dep_list = load_object(rel, obj[rel], obj_var, inc, import_type, protocol)
-
-    # insert  SCO Extensions here, a possible dict of sub-objects
-    elif rel in auth["reln_name"]["extension_relations"] or rel == "extensions":
-        logger.debug("extension")
-        match, insert, dep_list = extensions(rel, obj[rel], obj_var, inc, import_type, protocol)
-
-    # ignore the following relations as they are already processed, for Relationships, Sightings and Extensions
-    elif rel in auth["reln_name"]["standard_relations"] or rel == "definition" or "definition_type":
-        logger.debug("standard")
-        match = insert = ''
-
-    else:
-        logger.debug(f'relation type not known, ignore if "source_ref" or "target_ref" -> {rel}')
-        logger.debug("in else")
-        match = insert = ""
-
-    return match, insert, dep_list
-
-
-# ---------------------------------------------------
-# Methods for adding the embedded structures to the typeql statement
-# --------------------------------------------------
-# generic methods
-
-
-def extensions(prop_name: str,
-               prop_dict,
-               parent_var,
-               inc,
-               import_type: ImportType,
-               protocol: str):
-    """
-        Create the Typeql for the extensions sub object
-    Args:
-        prop_name (): the name of the extension
-        prop_dict (): the dict for the extension
-        parent_var (): the var of the Stix object that is the owner
-        import_type: the dict describing import preferences
-
-    Returns:
-        match: the typeql match string
-        insert: the typeql insert string
-    """
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    match = insert = ''
-    dep_list = []
-    # for each key in the dict (extension type)
-    # logger.debug('--------------------- extensions ----------------------------')
-    for ext_type in prop_dict:
-        for ext_type_ql in auth["reln"]["extension_relations"]:
-            if ext_type == ext_type_ql["stix"]:
-                match2, insert2, dep_list2 = load_object(ext_type, prop_dict[ext_type], parent_var, inc, import_type, protocol)
-                match = match + match2
-                insert = insert + insert2
-                dep_list = dep_list + dep_list2
-                break
-
-    return match, insert, dep_list
-
-
-def load_object(prop_name: str,
-                prop_dict,
-                parent_var: str,
-                inc,
-                import_type: ImportType,
-                protocol: str):
-    """
-        Create the Typeql for a sub object
-    Args:
-        prop_name (): the name of the extension
-        prop_dict (): the dict for the extension
-        parent_var (): the var of the Stix object that is the owner
-        import_type: the dict describing import preferences
-
-    Returns:
-        match: the typeql match string
-        insert: the typeql insert string
-    """
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    match = insert = type_ql = type_ql_props = ''
-    # as long as it is predefined, history the object
-    # logger.debug('------------------- history object ------------------------------')
-    for prop_type in auth["reln"]["extension_relations"]:
-        if prop_name == prop_type["stix"]:
-            tot_prop_list = [tot for tot in prop_dict.keys()]
-            obj_type = prop_type["object"]
-            obj_tql = copy.deepcopy(auth["sub_objects"][obj_type])
-            obj_var = '$' + obj_type
-            reln = prop_type["relation"]
-            rel_var = '$' + reln
-            rel_owner = prop_type["owner"]
-            rel_pointed_to = prop_type["pointed-to"]
-            type_ql += ' ' + obj_var + ' isa ' + obj_type
-            # Split them into properties and relations
-            total_props = prop_dict._inner
-            logger.debug(f'load object properties: {total_props}')
-            properties, relations = split_on_activity_type(total_props, obj_tql)
-            prop_var_list = []
-            dep_list = []
-            logger.debug(f'load object relations: {relations}')
-            for prop in properties:
-                # split off for properties processing
-                type_ql2, type_ql_props2, prop_var_list = add_property_to_typeql(prop, obj_tql, prop_dict,
-                                                                                 prop_var_list)
-                # then add them all together
-                type_ql += type_ql2
-                type_ql_props += type_ql_props2
-                # add a terminator on the end of the insert statement
-            type_ql += ";\n" + type_ql_props + "\n\n"
-
-            # add each of the relations to the match and insert statements
-            logger.debug(f'load object relations: {relations}')
-            for rel in relations:
-                # split off for relation processing
-                logger.debug(f'load object relation: {rel}, protocol: {protocol}')
-                match2, insert2, dep_list2 = add_relation_to_typeql(rel, prop_dict, obj_var, prop_var_list, import_type, inc, protocol)
-                # then add it back together    
-                match = match + match2
-                insert = insert + "\n" + insert2
-                dep_list = dep_list + dep_list2
-
-            # finally, connect the local object to the parent object
-            type_ql += ' ' + rel_var + ' (' + rel_owner + ':' + parent_var
-            type_ql += ', ' + rel_pointed_to + ':' + obj_var + ')'
-            type_ql += ' isa ' + reln + ';\n'
-            break
-
-    insert = type_ql + "\n" + insert
-    return match, insert, dep_list
-
-
-def list_of_object(prop_name: str,
-                   prop_value_list: List[str],
-                   parent_var,
-                   inc,
-                   import_type: ImportType,
-                   protocol: str):
-    """
-        Create the Typeql for the list of object sub object
-    Args:
-        prop_name (): the name of the object
-        prop_value_list (): the list of object
-        parent_var (): the var of the Stix object that is the owner
-        import_type: the dict describing import preferences
-
-    Returns:
-        match: the typeql match string
-        insert: the typeql insert string
-    """
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    for config in auth["reln"]["list_of_objects"]:
-        if config["name"] == prop_name:
-            rel_typeql = config["typeql"]
-            role_owner = config["owner"]
-            role_pointed = config["pointed_to"]
-            typeql_obj = config["object"]
-            break
-
-    if typeql_obj in auth["sub_objects"]:
-        obj_props_tql = copy.deepcopy(auth["sub_objects"][typeql_obj])
-    else:
-        raise ValueError("no sub-object available")
-
-    lod_list = []
-    dep_list = []
-    match = rel_insert = rel_match = insert = ''
-    for i, dict_instance in enumerate(prop_value_list):
-        lod_var = '$' + typeql_obj + str(i)
-        lod_list.append(lod_var)
-        insert += lod_var + ' isa ' + typeql_obj
-        for key in dict_instance:
-            typeql_prop = obj_props_tql[key]
-            if typeql_prop == '':
-                rel_match2, rel_insert2, dep_list2 = add_relation_to_typeql(key, dict_instance, lod_var, [], import_type, i, protocol)
-                rel_insert += rel_insert2
-                rel_match += rel_match2
-                dep_list = dep_list + dep_list2
-            else:
-                insert += ',\n has ' + typeql_prop + ' ' + val_tql(dict_instance[key])
-        insert += ';\n'
-
-    insert += '\n $' + rel_typeql + ' (' + role_owner + ':' + parent_var
-    for lod_var in lod_list:
-        insert += ', ' + role_pointed + ':' + lod_var
-
-    insert += ') isa ' + rel_typeql + ';\n' + rel_insert
-    match += rel_match
-    return match, insert, dep_list
-
-
-def key_value_store(prop,
-                    prop_value_dict,
-                    obj_var,
-                    import_type: ImportType):
-    """
-        Create the Typeql for the key-value store sub object
-    Args:
-        prop (): the name of the object
-        prop_value_dict (): the dict of object
-        obj_var (): the var of the Stix object that is the owner
-        import_type: the dict describing import preferences
-
-    Returns:
-        match: the typeql match string
-        insert: the typeql insert string
-    """
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    for config in auth["reln"]["key_value_relations"]:
-        if config["name"] == prop:
-            rel_typeql = config["typeql"]
-            role_owner = config["owner"]
-            role_pointed = config["pointed_to"]
-            d_key = config["key"]
-            d_value = config["value"]
-            break
-
-    match = ''
-    insert = '\n'
-    field_var_list = []
-    for i, key in enumerate(prop_value_dict):
-        a_value = prop_value_dict[key]
-        key_var = ' $' + d_key + str(i)
-        field_var_list.append(key_var)
-        insert += key_var + ' isa ' + d_key + '; ' + key_var + ' "' + key + '";\n'
-        if isinstance(a_value, list):
-            for j, n in enumerate(a_value):
-                value_var = ' $' + d_value + str(j)
-                insert += key_var + ' ' + 'has ' + d_value + ' "' + str(n) + '";\n'
-        else:
-            value_var = ' $' + d_value + str(i)
-            insert += key_var + ' ' + 'has ' + d_value + ' "' + str(a_value) + '";\n'
-
-    insert += ' $' + rel_typeql + ' (' + role_owner + ':' + obj_var
-    for var in field_var_list:
-        insert += ', ' + role_pointed + ':' + var
-    insert += ') isa ' + rel_typeql + ';\n\n'
-    return match, insert
-
-
-# specific methods
-def hashes(prop_name, prop_dict, parent_var):
-    """
-        Create the Typeql for the hashes sub object
-    Args:
-        prop_name (): the name of the object
-        prop_dict (): the dict of object
-        parent_var (): the var of the Stix object that is the owner
-
-    Returns:
-        match: the typeql match string
-        insert: the typeql insert string
-    """
-    match = insert = ''
-    hash_var_list = []
-    for i, key in enumerate(prop_dict):
-        hash_var = '$hash' + str(i)
-        hash_var_list.append(hash_var)
-        if key in stix_models.get_sub_objects("hash_typeql_dict"):
-            insert += ' ' + hash_var + ' isa ' + stix_models.get_sub_objects("hash_typeql_dict")[
-                key] + ', has hash-value ' + val_tql(prop_dict[key]) + ';\n'
-        else:
-            logger.error(f'Unknown hash type {key}')
-
-    # insert the hash objects into the hashes relation with the parent object
-    insert += '\n $hash_rel (owner:' + parent_var
-    for hash_var in hash_var_list:
-        insert += ', pointed-to:' + hash_var
-
-    insert += ') isa hashes;\n'
-    return match, insert
-
-
-def granular_markings(prop_name, prop_value_List, parent_var, prop_var_list):
-    """
-        Create the Typeql for the granular markings sub object
-    Args:
-        prop_name (): the name of the object
-        prop_value_List (): the list of object values
-        parent_var (): the var of the Stix object that is the owner
-        prop_var_list: the list of property variables
-
-    Returns:
-        match: the typeql match string
-        insert: the typeql insert string
-    """
-    match = insert = ''
-    for i, prop_dict in enumerate(prop_value_List):
-        # setup and match in the marking, based on its id
-        m_id = prop_dict['marking_ref']
-        m_var = '$marking' + str(i)
-        g_var = '$granular' + str(i)
-        match += ' ' + m_var + ' isa marking-definition, has stix-id ' + '"' + m_id + '";\n'
-        insert += ' ' + g_var + ' (marking:' + m_var + ', object:' + parent_var
-        prop_list = prop_dict['selectors']
-        for selector in prop_list:
-            selector_var = get_selector_var(selector, prop_var_list)
-            insert += ', marked:' + selector_var
-
-        insert += ') isa granular-marking;\n'
-
-    return match, insert
-
-
-def get_selector_var(selector, prop_var_list):
-    """
-        Get the typeql variable for the property
-    Args:
-        selector (): the property to select
-        prop_var_list (): the variable list to select from
-
-    Returns:
-        selector_var: the typeql variable for the property
-    """
-    if selector[-1] == ']':
-        text = selector.split(".")
-        selector = text[0]
-        index = int(text[1][1])
-    else:
-        selector = selector
-        index = -1
-
-    # logger.debug(f'selector after processing -> {selector}, index after procesing -> {index}')
-    for prop_var_dict in prop_var_list:
-        if selector == prop_var_dict['prop'] and index == prop_var_dict['index']:
-            selector_var = prop_var_dict['prop_var']
-            break
-
-    return selector_var
-
-
-# ---------------------------------------------------
-#        EMBEDDED RELATION METHODS
-# ---------------------------------------------------
-# object_refs
-# sample_refs
-# sample_ref
-# host_vm_ref
-# operating_system_ref
-# installed_software_refs
-# analysis_sco_refs
-# etc.
-
-def  embedded_relation(prop,
-                      prop_value,
-                      obj_var,
-                      inc: int,
-                      import_type: ImportType,
-                      protocol: str):
-    """
-        Create the Typeql for the embedded relation sub object
-    Args:
-        prop (): the name of the object
-        prop_value (): the value of object
-        obj_var (): the var of the Stix object that is the owner
-
-    Returns:
-        match: the typeql match string
-        insert: the typeql insert string
-    """
-    logger.debug("I'm in embedded")
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    for ex in auth["reln"]["embedded_relations"]:
-        if ex["rel"] == prop:
-            owner = ex["owner"]
-            pointed_to = ex["pointed-to"]
-            relation = ex["typeql"]
-            break
-
-    prop_var_list = []
-    dep_list = []
-    match = ''
-    if inc == -1:
-        inc_add = ''
-    else:
-        inc_add = str(inc)
-    # if the prop_value is a list, then match in each item
-    logger.debug(f'\n1\n')
-    if isinstance(prop_value, list):
-        dep_list = prop_value
-        logger.debug(f'deplist {dep_list}')
-        for i, prop_v in enumerate(prop_value):
-            prop_type = get_source_from_id(prop_v, protocol, import_type)
-            if prop_type == 'relationship':
-                prop_type = 'stix-core-relationship'
-            prop_var = '$' + prop_type + str(i) + inc_add
-            prop_var_list.append(prop_var)
-            match += ' ' + prop_var + ' isa ' + prop_type + ', has stix-id ' + '"' + prop_v + '";\n'
-    # else, match in the single prop_value
-    else:
-        dep_list.append(prop_value)
-        prop_type = get_source_from_id(prop_value, protocol, import_type)
-        logger.debug(f'deplist {dep_list}')
-        if prop_type == 'relationship':
-            prop_type = 'stix-core-relationship'
-        prop_var = '$' + prop_type + inc_add
-        prop_var_list.append(prop_var)
-        match += ' ' + prop_var + ' isa ' + prop_type + ', has stix-id ' + '"' + prop_value + '";\n'
-
-    # Then setup and insert the relation
-    logger.debug(f'\n2\n')
-    insert = '\n $' + relation + inc_add + ' (' + owner + ':' + obj_var
-    for prop_var in prop_var_list:
-        insert += ', ' + pointed_to + ':' + prop_var
-    insert += ') isa ' + relation + ';\n'
-    return match, insert, dep_list
-
-
-def get_source_from_id(stid: str,
-                       protocol: str,
-                       import_type: ImportType):
-    """
-        Get the source of the stix object
-    Args:
-        stid (): the stix-id of the object
-
-    Returns:
-        source: the source of the object
-    """
-    tmp_source = stid.split('--')[0]
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    source = ""
-    for model in auth["conv"]["sdo"]:
-        if model["protocol"] == protocol and model["type"] == tmp_source:
-            source = model["typeql"]
-            return source
-    for model in auth["conv"]["sro"]:
-        if model["protocol"] == protocol and model["type"] == tmp_source:
-            source = model["typeql"]
-            if source == 'relationship' or source == "attack-relation":
-                source = 'stix-core-relationship'
-            return source
-    for model in auth["conv"]["sco"]:
-        if model["protocol"] == protocol and model["type"] == tmp_source:
-            source = model["typeql"]
-            return source
-    for model in auth["conv"]["meta"]:
-        if model["protocol"] == protocol and model["type"] == tmp_source:
-            source = model["typeql"]
-            return source
-    for model in auth["conv"]["sdo"]:
-        if model["type"] == tmp_source:
-            source = model["typeql"]
-            return source
-    for model in auth["conv"]["sro"]:
-        if model["type"] == tmp_source:
-            source = model["typeql"]
-            return source
-    for model in auth["conv"]["sco"]:
-        if model["type"] == tmp_source:
-            source = model["typeql"]
-            return source
-    for model in auth["conv"]["meta"]:
-        if model["type"] == tmp_source:
-            source = model["typeql"]
-            return source
-    return source
-
-
-def get_embedded_match(source_id: str,
-                       i: int,
-                       protocol: str,
-                       import_type: ImportType):
-    """
-        Assemble the typeql variable and match statement given the stix-id, and the increment
-    Args:
-        source_id (): stix-id to use
-        i (): number of times this type of object has been used
-
-    Returns:
-        source_var, the typeql string of the variable
-        match, the typeql match statement
-    """
-    source_type = get_source_from_id(source_id, protocol, import_type)
-    source_var = '$' + source_type + str(i)
-    if source_type == 'relationship' or source_type == "attack-relation":
-        source_type = 'stix-core-relationship'
-    match = f' {source_var} isa {source_type}, has stix-id "{source_id}";\n'
-    return source_var, match
-
-
-def get_full_object_match(source_id: str, protocol: str, import_type: ImportType):
-    """
-        Return a typeql match statement for this stix object
-    Args:
-        source_id (): the stix-id to look for
-
-    Returns:
-        source_var, the typeql string of the variable
-        match, the typeql match statement
-    """
-    source_var, match = get_embedded_match(source_id, 0, protocol, import_type)
-    match += source_var + ' has $properties;\n'
-    # match += '$embedded (owner:' + source_var + ', pointed-to:$point ) isa embedded;\n'
-    return source_var, match
-
-
-# ---------------------------------------------------
-# 1.7) Helper Methods for 
-#           - converting a Python value --> typeql string
-#           - splitting a list of total properties into properties and relations
-# ---------------------------------------------------
-
-
-def val_tql(val):
-    """
-        Modify the value used in a typeql statement, depending on its type
-    Args:
-        val (): the value being used
-
-    Returns:
-        val: the value formatted for typeql
-    """
-    if isinstance(val, str):
-        replaced_val = val.replace('"', "'")
-        replaced_val2 = replaced_val.replace('\\', '\\\\')
-        return '"' + replaced_val2 + '"'
-    elif isinstance(val, bool):
-        return str(val).lower()
-    elif isinstance(val, int):
-        return str(val)
-    elif isinstance(val, float):
-        return str(val)
-    elif isinstance(val, datetime.datetime):
-        return str(val.strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3])
-    else:
-        return logger.error(f'value  not supported: {val}')
-
-
-def split_on_activity_type(total_props: dict, obj_tql: Dict[str, str]) -> [List[str], List[str]]:
-    """
-        Split the Stix object properties into flat properties and sub objects
-    Args:
-        total_props (): the total properties for this object
-        obj_tql (): the mapping dict for this object
-
-    Returns:
-        prop_list, a list of the flat properties
-        rel_list, a list of the sub objects
-    """
-    prop_list = []
-    rel_list = []
-    logger.debug("@@@@@@@@@@@@@@@@@@@@@@ splitting @@@@@@@@@@@@@@@")
-    logger.debug("========================================")
-    logger.debug(f'total props: {total_props}')
-    # for k, v in total_props.items():
-    #     logger.debug(k, v)
-    # logger.debug("=========================================")
-    logger.debug("========================================")
-    logger.debug(f'obj tql: {obj_tql}')
-    # for k, v in obj_tql.items():
-    #     logger.debug(k, v)
-    # logger.debug("=========================================")
-    logger.debug("@@@@@@@@@@@@@@@@@@@@@@ end splitting @@@@@@@@@@@@@@@")
-    for prop in total_props:
-        tql_prop_name = obj_tql[prop]
-        logger.debug(f'prop {prop}, object tql -> {tql_prop_name}')
-
-        if tql_prop_name == "":
-            rel_list.append(prop)
-            # logger.debug(f'Im a rel --> {prop},        tql --> {tql_prop_name}')
-        else:
-            prop_list.append(prop)
-            # logger.debug(f'Im a prop --> {prop},        tql --> {tql_prop_name}')
-
-    return prop_list, rel_list
-
-###################################################################################################
+import copy
+from typing import Dict
+
+from stixorm.module.authorise import authorised_mappings, default_import_type
+from stixorm.module.parsing.conversion_decisions import sdo_type_to_tql, sro_type_to_tql, sco__type_to_tql, meta_type_to_tql
+
+from stixorm.module.orm.import_utilities import clean_props, get_embedded_match, split_on_activity_type, \
+    add_property_to_typeql, add_relation_to_typeql, val_tql
+
+import logging
+
+from stixorm.module.typedb_lib.factories.auth_factory import get_auth_factory_instance
+logger = logging.getLogger(__name__)
+
+
+
+marking =["marking-definition--613f2e26-407d-48c7-9eca-b8e91df99dc9",
+          "marking-definition--34098fce-860f-48ae-8e50-ebd3cc5e41da",
+          "marking-definition--f88d31f6-486f-44da-b317-01333bde0b82",
+          "marking-definition--5e57c739-391a-4eb3-b6be-7d15ca92d5ed"]
+
+# ---------------------------------------------------
+# 1.0) Helper method to direct the right typeql method to an incoming Stix object
+# ---------------------------------------------------
+
+
+def stix2_to_typeql(stix_object, import_type=default_import_type):
+    """
+    Initial function to convert Stix into typeql, it adds together the match and insert statements
+
+    Args:
+        stix_object (): valid Stix2 object
+        import_type (): string, either Stix2 or ATT&CK
+
+    Returns:
+        typeql: a string of typeql to match and insert the object int typedb_lib
+
+    """
+    match, insert, dep_obj = stix2_to_match_insert(stix_object, import_type)
+    typeql = match + insert
+
+    return typeql, dep_obj
+
+
+def stix2_to_match_insert(stix_object, import_type=default_import_type):
+    """
+    Initial function to convert Stix into match/insert statments
+
+    Args:
+        stix_object (): valid Stix2 object
+        import_type (): string, either Stix2 or ATT&CK
+
+    Returns:
+        match: a typeql match statement for this object
+        insert: a typeql insert statement for this object
+
+    """
+    dep_match, dep_insert, indep_ql, core_ql, dep_obj = raw_stix2_to_typeql(stix_object, import_type)
+    if dep_match == '':
+        match = ''
+    else:
+        match = 'match ' + dep_match
+    if indep_ql == '' and dep_insert == '':
+        insert = ''
+    else:
+        insert = 'insert ' + indep_ql + dep_insert
+
+    return match, insert, dep_obj
+
+
+def raw_stix2_to_typeql(stix_object,
+                        import_type=None) -> [str, str, str, str, {}]:
+    """
+    Initial function to convert Stix into typeql, it splits the incoming object into different
+    channels based on its object type: sdo, sro, sco or meta
+
+    Args:
+        stix_object (): valid Stix2 object
+        import_type (): string, either Stix2 or ATT&CK
+
+    Returns:
+        dep_match: a typeql match statement that depends on other objects
+        dep_insert: a typeql insert statement that depends on other objects
+        indep_ql: a typeql insert statement with no extenral dependencies
+        core_ql: a typeql insert statement that describes the object head, so the independent and dependent parts can be injected seaparately
+
+    """
+    if import_type is None:
+        import_type = default_import_type
+
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    logger.debug(f'stix object type {stix_object["type"]}\n')
+
+    auth_types = copy.deepcopy(auth["types"])
+    if stix_object.type in auth_types["sdo"]:
+        logger.debug(f' going into sdo ---? {stix_object}')
+        dep_match, dep_insert, indep_ql, core_ql, dep_obj = sdo_to_typeql(stix_object, import_type)
+    elif stix_object.type in auth_types["sro"]:
+        logger.debug(f' going into sro ---> {stix_object}')
+        dep_match, dep_insert, indep_ql, core_ql, dep_obj = sro_to_typeql(stix_object, import_type)
+    elif stix_object.type in auth_types["sco"]:
+        logger.debug(f' going into sco ---> {stix_object}')
+        dep_match, dep_insert, indep_ql, core_ql, dep_obj = sco_to_typeql(stix_object, import_type)
+    elif stix_object.type == 'marking-definition':
+        dep_match, dep_insert, indep_ql, core_ql, dep_obj = marking_definition_to_typeql(stix_object, import_type)
+    else:
+        logger.error(f'object type not supported: {stix_object.type}, import type {import_type}')
+        dep_match, dep_insert, indep_ql, core_ql, dep_obj = '', '', '', '', ''
+        dep_list = []
+
+    return dep_match, dep_insert, indep_ql, core_ql, dep_obj
+
+
+# -------------------------------------------------------------
+# 1.1) SDO Object Method to convert a Python object --> typeql string
+#                 -   
+# -------------------------------------------------------------
+def sdo_to_data(sdo, import_type=default_import_type) -> [dict, Dict[str, str], str]:
+    """ convert Stix object into a data model for processing
+
+    Args:
+        sdo (): the Stix2 SDO object
+        import_type (): the type of import to use
+
+    Returns:
+        total_props, : a list of all properties
+        obj_tql : the dict of the tql properties
+
+    """
+    sdo_tql_name = sdo.type
+    # - list of property names that have values
+    total_props = sdo._inner
+    total_props = clean_props(total_props)
+    # 1.B) get the specific typeql names for an object into a dictionary
+    # b. Instance details
+    attack_object = False if not sdo.get("x_mitre_version", False) else True
+    sub_technique = False
+    if attack_object:
+        sub_technique = False if not sdo.get("x_mitre_is_subtechnique", False) else True
+
+    obj_tql, sdo_tql_name, is_list, protocol = sdo_type_to_tql(sdo_tql_name, import_type, attack_object, sub_technique)
+    logger.debug(f'\nobject tql {obj_tql}, \nsdo tql name {sdo_tql_name},\n is_list {is_list}')
+
+    return total_props, obj_tql, sdo_tql_name, protocol
+
+
+def sdo_to_typeql(sdo, import_type=default_import_type) -> [str, str, str, str, dict]:
+    """
+    Initial function to convert Stix2 SDO object into typeql
+
+    Args:
+        sdo (): valid Stix2 object
+        import_type (): string, either Stix2 or ATT&CK
+
+    Returns:
+        dep_match: a typeql match statement that depends on other objects
+        dep_insert: a typeql insert statement that depends on other objects
+        indep_ql: a typeql insert statement with no extenral dependencies
+        core_ql: a typeql insert statement that describes the object head, so the independent and dependent parts can be injected seaparately
+
+    """
+    # 1.A) get configuration parameters
+    # - variable for use in typeql statements
+    dep_list = []
+    # 1.B) get the data model
+    total_props, obj_tql, sdo_tql_name, protocol = sdo_to_data(sdo, import_type)
+    logger.debug("\n Step 0 I've just gotten through getting data")
+    logger.debug(f'\n\n total_props {total_props}\n\nobj_tql {obj_tql}\n\nsdo_tql_name {sdo_tql_name}')
+    sdo_var = '$' + sdo_tql_name
+    if obj_tql == '':
+        return '', '', '', '', {}
+    properties, relations = split_on_activity_type(total_props, obj_tql)
+    logger.debug("\n----> Step 1 sdo to typeql")
+
+    # 2.) setup the typeql statement for the sdo entity
+    sdo_var = '$' + sdo_tql_name
+    indep_ql = sdo_var + ' isa ' + sdo_tql_name
+    core_ql = sdo_var + ' isa ' + sdo_tql_name + ', has stix-id $stix-id;\n$stix-id ' + val_tql(sdo.id) + ';\n'
+    indep_ql_props = dep_match = dep_insert = ''
+    logger.debug("----> Step 2 sdo to typeql")
+    # 3.) add each of the properties and values of the properties to the typeql statement
+    prop_var_list = []
+    for prop in properties:
+        # split off for properties processing
+        indep_ql2, indep_ql_props2, prop_var_list = add_property_to_typeql(prop, obj_tql, sdo, prop_var_list)
+        # then add them all together
+        indep_ql += indep_ql2
+        indep_ql_props += indep_ql_props2
+        # add a terminator on the end of the query statement
+    indep_ql += ";\n" + indep_ql_props + "\n\n"
+    logger.debug("----> Step 3 sdo to typeql")
+
+    # 4.) add each of the relations to the match and insert statements
+    for j, rel in enumerate(relations):
+        # split off for relation processing
+        dep_match2, dep_insert2, dep_list2 = add_relation_to_typeql(rel, sdo, sdo_var, prop_var_list, import_type, j, protocol)
+        # then add it back together
+        dep_match = dep_match + dep_match2
+        dep_insert = dep_insert + dep_insert2
+        dep_list = dep_list + dep_list2
+
+    logger.debug("----> Step 4 sdo to typeql")
+    dep_obj = {"id": sdo.id, "dep_list": dep_list, "type": sdo.type}
+    return dep_match, dep_insert, indep_ql, core_ql, dep_obj
+
+
+# -------------------------------------------------------
+# 1.2) SRO Object Method to convert a Python object --> typeql string
+#                 -   
+# -----------------------------------------------------
+def sro_to_data(sro, import_type=default_import_type) -> [dict, Dict[str, str], str]:
+    """ convert Stix object into a data model for processing
+
+        Args:
+            sro (): the Stix2 sco object
+            import_type (): the type of import to use
+
+        Returns:
+            total_props, : a list of all properties
+            obj_tql : the dict of the twl proeprties
+
+    """
+    # - list of property names that have values, and do not include False values
+    total_props = sro._inner
+    total_props = clean_props(total_props)
+
+    logger.debug(f'into sro -> {sro}')
+    # - work out the type of object
+    uses_relation = False
+    is_procedure = False
+    attack_object = False if not sro.get("x_mitre_version", False) else True
+    if attack_object:
+        uses_relation = False if not sro.get("relationship_type", False) == "uses" else True
+        is_procedure = False if not sro.get("target_ref", False) == "attack-pattern" else True
+    obj_tql = {}
+    sro_tql_name = sro.type
+    sro_sub_rel = "" if not sro.get("relationship_type", False) else sro["relationship_type"]
+
+    obj_tql, sro_tql_name, is_list, protocol = sro_type_to_tql(sro_tql_name, sro_sub_rel, import_type, attack_object, uses_relation, is_procedure)
+    logger.debug(f'object tql {obj_tql}, sro tql name {sro_tql_name}')
+
+    return total_props, obj_tql, sro_tql_name, protocol
+
+
+def sro_to_typeql(sro, import_type=default_import_type) -> [str, str, str, str, dict]:
+    """
+    Initial function to convert Stix2 SRO object into typeql
+
+    Args:
+        sro (): valid Stix2 object
+        import_type (): string, either Stix2 or ATT&CK
+
+    Returns:
+        dep_match: a typeql match statement that depends on other objects
+        dep_insert: a typeql insert statement that depends on other objects
+        indep_ql: a typeql insert statement with no extenral dependencies
+        core_ql: a typeql insert statement that describes the object head, so the independent and dependent parts can be injected seaparately
+
+    """
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    # 1.) get configuration parameters
+    # - variable for use in typeql statements
+    dep_list = []
+    # - work out the type of object
+    obj_type = sro.type
+    total_props, obj_tql, sro_tql_name, protocol = sro_to_data(sro, import_type)
+    sro_var = '$' + sro_tql_name
+    if obj_tql == '':
+        return '', '', '', '', {}
+    # initialise the typeql insert statement
+    dep_match = dep_insert = indep_ql = core_ql = dep_insert_props = ''
+
+    # 2.) setup the match statements first, depending on whether the object is a sighting or a relationship
+    # A. If it is a Relationship then find the source and target roles for the relation, and match them in
+    if obj_type == 'relationship':
+        source_id = sro.source_ref
+        dep_list.append(source_id)
+        source_var, source_match = get_embedded_match(source_id, 0, protocol, import_type)
+        target_id = sro.target_ref
+        dep_list.append(target_id)
+        target_var, target_match = get_embedded_match(target_id, 0, protocol, import_type)
+        dep_match += source_match + target_match
+        # 3.)  then setup the typeql statement to insert the specific sro relation, from the dict, with the matches
+        for record in auth["reln"]["standard_relations"]:
+            if record['stix'] == sro_tql_name:
+                dep_insert += '\n' + sro_var
+                dep_insert += ' (' + record['source'] + ':' + source_var
+                dep_insert += ', ' + record['target'] + ':' + target_var + ')'
+                dep_insert += ' isa ' + record['typeql']
+                core_ql = sro_var + ' isa ' + sro_tql_name
+                core_ql += ', has stix-id $stix-id;\n$stix-id ' + val_tql(sro.id) + ';\n'
+                break
+                # B. If it is a Sighting then match the object to the sighting
+        logger.debug(f'dep_insert -> {dep_insert}')
+    elif obj_type == 'sighting':
+        sighting_of_id = sro.sighting_of_ref
+        dep_list.append(sighting_of_id)
+        sighting_of_var, sighting_of_match = get_embedded_match(sighting_of_id, 0, protocol, import_type)
+        dep_match += ' \n' + sighting_of_match
+        dep_insert += '\n' + sro_var + ' (sighting-of:' + sighting_of_var
+        # if there is observed data list, then add it to the match statement
+        observed_data_list = sro.get("observed_data_refs")
+        if (observed_data_list is not None) and (len(observed_data_list) > 0):
+            for i, observed_data_id in enumerate(observed_data_list):
+                dep_list.append(observed_data_id)
+                observed_data_var, observed_data_match = get_embedded_match(observed_data_id, i, protocol, import_type)
+                dep_match += observed_data_match
+                dep_insert += ', observed:' + observed_data_var
+        # if there is a list of who and where the sighting's occured, then match it in
+        where_sighted_list = sro.get("where_sighted_refs")
+        if (where_sighted_list is not None) and (len(where_sighted_list) > 0):
+            for where_sighted_id in where_sighted_list:
+                dep_list.append(where_sighted_id)
+                where_sighted_var, where_sighted_match = get_embedded_match(where_sighted_id, 1, protocol, import_type)
+                dep_match += where_sighted_match
+                dep_insert += ', where-sighted:' + where_sighted_var
+
+        # then finalise the typeql statement for the sro sighting
+        dep_insert += ') isa sighting'
+        core_ql = sro_var + ' ($role:$any) isa sighting'
+        core_ql += ', has stix-id $stix-id;\n$stix-id ' + val_tql(sro.id) + ';\n'
+    else:
+        logger.error(f'relationship type {obj_type} not supported')
+        return ''
+
+    # 4.) next, split total properties into actual properties and nested structures (Relations)
+    properties, relations = split_on_activity_type(total_props, obj_tql)
+
+    # 5.) add each of the properties and values of the properties to the typeql statement
+    prop_var_list = []
+    for prop in properties:
+        # split off for properties processing
+        dep_insert2, dep_insert_props2, prop_var_list = add_property_to_typeql(prop, obj_tql, sro, prop_var_list)
+        # then add them all together
+        dep_insert += dep_insert2
+        dep_insert_props += dep_insert_props2
+        # add a terminator on the end of the query statement
+    dep_insert += ";\n" + dep_insert_props + "\n\n"
+
+    # 6.) add each of the relations to the match and insert statements
+    for j, rel in enumerate(relations):
+        # split off for relation processing
+        dep_match2, dep_insert2, dep_list2 = add_relation_to_typeql(rel,
+                                                                    sro,
+                                                                    sro_var,
+                                                                    prop_var_list,
+                                                                    import_type,
+                                                                    j,
+                                                                    protocol)
+        # then add it back together
+        dep_match = dep_match + dep_match2
+        dep_insert = dep_insert + dep_insert2
+        dep_list = dep_list + dep_list2
+
+    dep_obj = {"id": sro.id, "dep_list": dep_list, "type": "relation"}
+    return dep_match, dep_insert, indep_ql, core_ql, dep_obj
+
+
+# ---------------------------------------------------
+# 1.3) SCO Object Method to convert a Python object --> typeql string
+#                 -
+# --------------------------------------------------
+def sco_to_data(sco, import_type=default_import_type) -> [dict, dict, str]:
+    """ convert Stix object into a data model for processing
+
+        Args:
+            sco (): the Stix2 sco object
+            import_type (): the type of import to use
+
+        Returns:
+            total_props, : a list of all properties
+            obj_tql : the dict of the twl proeprties
+
+    """
+    # - list of property names that have values
+    total_props = sco._inner
+    total_props = clean_props(total_props)
+    # logger.debug(properties)
+    # - work out the type of object
+    sco_tql_name = sco.type
+    # - get the object-specific typeql names, sighting or relationship
+    obj_tql, sco_tql_name, is_list, protocol = sco__type_to_tql(sco_tql_name, import_type)
+
+    return total_props, obj_tql, sco_tql_name, protocol
+
+
+def sco_to_typeql(sco, import_type=default_import_type):
+    """
+    Initial function to convert Stix2 SCO object into typeql
+
+    Args:
+        sco (): valid Stix2 object
+        import_type (): string, either Stix2 or ATT&CK
+
+    Returns:
+        dep_match: a typeql match statement that depends on other objects
+        dep_insert: a typeql insert statement that depends on other objects
+        indep_ql: a typeql insert statement with no extenral dependencies
+        core_ql: a typeql insert statement that describes the object head, so the independent and dependent parts can be injected seaparately
+
+    """
+    # 1.) get configuration parameters
+    # - variable for use in typeql statements
+    sco_var = '$' + sco.type
+    dep_list = []
+    # initialise the typeql insert statement
+    dep_match = dep_insert = indep_ql = core_ql = dep_insert_props = ''
+
+    # 1.C) Split them into properties and relations
+    total_props, obj_tql, sco_tql_name, protocol = sco_to_data(sco, import_type)
+    properties, relations = split_on_activity_type(total_props, obj_tql)
+
+    # 2.) setup the typeql statement for the sco entity
+    dep_insert = sco_var + ' isa ' + sco.type
+    core_ql = sco_var + ' isa ' + sco.type + ', has stix-id $stix-id;\n$stix-id ' + val_tql(sco.id) + ';\n'
+
+    # 3.) add each of the properties and values of the properties to the typeql statement
+    # 5.) add each of the properties and values of the properties to the typeql statement
+    prop_var_list = []
+    for prop in properties:
+        # split off for properties processing
+        dep_insert2, dep_insert_props2, prop_var_list = add_property_to_typeql(prop, obj_tql, sco, prop_var_list)
+        # then add them all together
+        dep_insert += dep_insert2
+        dep_insert_props += dep_insert_props2
+        # add a terminator on the end of the insert statement
+    dep_insert += ";\n" + dep_insert_props + "\n\n"
+
+    # 6.) add each of the relations to the match and insert statements
+    for j, rel in enumerate(relations):
+        # split off for relation processing
+        dep_match2, dep_insert2, dep_list2 = add_relation_to_typeql(rel, sco, sco_var, prop_var_list, import_type, j, protocol)
+        # then add it back together
+        dep_match = dep_match + dep_match2
+        dep_insert = dep_insert + dep_insert2
+        dep_list = dep_list + dep_list2
+
+    dep_obj = {"id": sco.id, "dep_list": dep_list, "type": sco.type}
+    return dep_match, dep_insert, indep_ql, core_ql, dep_obj
+
+
+# ---------------------------------------------------
+# 1.4) Meta Object Method to convert a Python object --> typeql string
+#                 -  marking definitions, statement, colour and Mitre copyright
+# --------------------------------------------------
+
+
+def marking_definition_to_typeql(meta, import_type=default_import_type):
+    """
+    Initial function to convert Stix2 marking object into typeql
+
+    Args:
+        meta (): valid Stix2 object
+        import_type (): string, either Stix2 or ATT&CK
+
+    Returns:
+        dep_match: a typeql match statement that depends on other objects
+        dep_insert: a typeql insert statement that depends on other objects
+        indep_ql: a typeql insert statement with no extenral dependencies
+        core_ql: a typeql insert statement that describes the object head, so the independent and dependent parts can be injected seaparately
+
+    """
+    total_props = meta._inner
+    total_props = clean_props(total_props)
+    dep_list = []
+    statement = {}
+    dep_match = dep_insert = indep_ql = core_ql = ''
+    # 1.A) if one of the existing colours, return an empty string
+    if meta.id in marking:
+        return dep_match, dep_insert, indep_ql, core_ql, {}
+    # 1.B) Test for attack object and handle statement if a statement marking
+    attack_object = False if not meta.get("x_mitre_attack_spec_version", False) else True
+    if total_props.get("definition", False):
+        statement = total_props["definition"]
+        total_props.update(statement)
+
+    obj_tql, meta_tql_name, is_list, protocol = meta_type_to_tql(meta.type, import_type, attack_object)
+
+    properties, relations = split_on_activity_type(total_props, obj_tql)
+
+    # 2.) setup the typeql statement for the sdo entity
+    meta_var = '$' + meta_tql_name
+    indep_ql = meta_var + ' isa ' + meta_tql_name
+    core_ql = meta_var + ' isa ' + meta_tql_name + ', has stix-id $stix-id;\n$stix-id ' + val_tql(meta.id) + ';\n'
+    indep_ql_props = dep_match = dep_insert = ''
+    logger.debug("----> Step 2 meta to typeql")
+    # 3.) add each of the properties and values of the properties to the typeql statement
+    prop_var_list = []
+    for prop in properties:
+        # split off for properties processing
+        indep_ql2, indep_ql_props2, prop_var_list = add_property_to_typeql(prop, obj_tql, meta, prop_var_list)
+        # then add them all together
+        indep_ql += indep_ql2
+        indep_ql_props += indep_ql_props2
+        # add a terminator on the end of the query statement
+    indep_ql += ";\n" + indep_ql_props + "\n\n"
+    logger.debug("----> Step 3 sdo to typeql")
+
+    # 4.) add each of the relations to the match and insert statements
+    for j, rel in enumerate(relations):
+        # split off for relation processing
+        dep_match2, dep_insert2, dep_list2 = add_relation_to_typeql(rel, meta, meta_var, prop_var_list, import_type, j,
+                                                                    protocol)
+        # then add it back together
+        dep_match = dep_match + dep_match2
+        dep_insert = dep_insert + dep_insert2
+        dep_list = dep_list + dep_list2
+
+    logger.debug("----> Step 4 sdo to typeql")
+    dep_obj = {"id": meta.id, "dep_list": dep_list, "type": meta.type}
+    return dep_match, dep_insert, indep_ql, core_ql, dep_obj
+
+    # # if the marking is a colour, match it in, else it is a statement type
+    # if stix_object.definition_type == "statement":
+    #     if attack_object:
+    #         indep_ql = '\n $marking isa attack-marking'
+    #         indep_ql += ',\n has x-mitre-attack-spec-version ' + val_tql(stix_object.x_mitre_attack_spec_version)
+    #         loc_list = stix_object.x_mitre_domains
+    #         for dom in loc_list:
+    #             indep_ql += ',\n has x-mitre-domains ' + val_tql(dom)
+    #         core_ql = '$marking isa attack-marking'
+    #     else:
+    #         indep_ql = '\n $marking isa statement-marking'
+    #         core_ql = '$marking isa statement-marking'
+    #     indep_ql += ',\n has statement ' + val_tql(stix_object.definition.statement)
+    #     indep_ql += ',\n has stix-type "marking-definition"'
+    #     indep_ql += ',\n has stix-id ' + val_tql(stix_object.id)
+    #     indep_ql += ',\n has created ' + val_tql(stix_object.created)
+    #     indep_ql += ',\n has spec-version ' + val_tql(stix_object.spec_version)
+    #     indep_ql += ';\n'
+    #     core_ql += ', has stix-id $stix-id;\n$stix-id ' + val_tql(stix_object.id)
+    #     core_ql += ';'
+    #
+    # dep_obj = {"id": stix_object.id, "dep_list": dep_list, "type": "marking"}
+    # return dep_match, dep_insert, indep_ql, core_ql, dep_obj
```

### Comparing `stixorm-0.1.3/stixorm/module/parsing/parse_objects.py` & `stixorm-0.1.9/stixorm/module/parsing/parse_objects.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,231 +1,231 @@
-
-import json
-import copy
-from stixorm.module.authorise import authorised_mappings, import_type_factory
-from stix2.exceptions import ParseError
-from stix2.parsing import dict_to_stix2
-from stixorm.module.parsing.conversion_decisions import sdo_type_to_tql, sro_type_to_tql
-import logging
-
-from stixorm.module.typedb_lib.factories.auth_factory import get_auth_factory_instance
-from stixorm.module.typedb_lib.factories.import_type_factory import ImportType
-
-logger = logging.getLogger(__name__)
-default_import_type = import_type_factory.get_default_import()
-
-
-def parse(data: dict, allow_custom=False, import_type: ImportType=default_import_type):
-    """Convert a string, dict or file-like object into a STIX object.
-    Args:
-        data (str, dict, file-like object): The STIX 2 content to be parsed.
-        allow_custom (bool): Whether to allow custom properties as well unknown
-            custom objects. Note that unknown custom objects cannot be parsed
-            into STIX objects, and will be returned as is. Default: False.
-        import_type (dict): If present, it describes the set of configuration
-            options, which impact the classes the parser will see
-    Returns:
-        An instantiated Python STIX object.
-    Warnings:
-        'allow_custom=True' will allow for the return of any supplied STIX
-        dict(s) that cannot be found to map to any known STIX object types
-        (both STIX2 domain objects or defined custom STIX2 objects); NO
-        validation is done. This is done to allow the processing of possibly
-        unknown custom STIX objects (example scenario: I need to query a
-        third-party TAXII endpoint that could provide custom STIX objects that
-        I don't know about ahead of time)
-    """
-    # convert STIX object to dict, if not already
-    logger.debug("i'm in parse, bout to get dict")
-    obj = _get_dict(data)
-    logger.debug("i'm in parse after get dict")
-
-    # convert dict to full python-stix2 obj
-    obj = dict_to_stix(obj, allow_custom, import_type)
-    logger.debug(f"############## obj is {obj} ########")
-
-    return obj
-
-
-def _get_dict(data):
-    """Return data as a dictionary.
-    Input can be a dictionary, string, or file-like object.
-    """
-
-    if type(data) is dict:
-        return data
-    else:
-        try:
-            return json.loads(data)
-        except TypeError:
-            pass
-        try:
-            return json.load(data)
-        except AttributeError:
-            pass
-        try:
-            return dict(data)
-        except (ValueError, TypeError):
-            raise ValueError(f"Cannot convert {str(data)} to dictionary.")
-
-
-def is_attack_object(stix_dict):
-    if stix_dict.get("x_mitre_domains", False) or stix_dict.get("x_mitre_attack_spec_version", False):
-        return True
-    else:
-        return False
-
-
-def dict_to_stix(stix_dict: dict,
-                 allow_custom=False,
-                 import_type: ImportType=default_import_type):
-    """convert dictionary to full python-stix2 object
-    Args:
-        stix_dict (dict): a python dictionary of a STIX object
-            that (presumably) is semantically correct to be parsed
-            into a full python-stix2 obj
-        allow_custom (bool): Whether to allow custom properties as well
-            unknown custom objects. Note that unknown custom objects cannot
-            be parsed into STIX objects, and will be returned as is.
-            Default: False.
-        import_type (dict): If present, it describes the set of configuration
-            options, which impact the classes the parser will see
-    Returns:
-        An instantiated Python STIX object
-    Warnings:
-        'allow_custom=True' will allow for the return of any supplied STIX
-        dict(s) that cannot be found to map to any known STIX object types
-        (both STIX2 domain objects or defined custom STIX2 objects); NO
-        validation is done. This is done to allow the processing of
-        possibly unknown custom STIX objects (example scenario: I need to
-        query a third-party TAXII endpoint that could provide custom STIX
-        objects that I don't know about ahead of time)
-    """
-    assert len(stix_dict) > 0
-    logger.debug(f"I'm in dict to stix, {stix_dict}")
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    if 'type' not in stix_dict:
-        raise ParseError(f"Can't parse object with no 'type' property: {str(stix_dict)}")
-
-    obj_type = stix_dict["type"]
-    logger.debug(f'\nin parse, raw type is --> {obj_type}')
-    logger.debug(f'\n auth-sdo -->{auth["tql_types"]["sdo"]}\n')
-    logger.debug(f'\n\n auth-sro -->{auth["tql_types"]["sro"]}\n')
-    attack_object = is_attack_object(stix_dict)
-    logger.debug(f'attack object {attack_object}')
-    #logger.info(f'auth is {auth["tql_types"]["meta"]}')
-    if obj_type in auth["types"]["sdo"]:
-        logger.debug("Im in sdo")
-        sub_technique = False
-        if attack_object:
-            sub_technique = stix_dict.get("x_mitre_is_subtechnique", False)
-        logger.debug(f'subtechnique {sub_technique}, attack {attack_object}')
-        obj_tql, sdo_tql_name, is_list, protocol = sdo_type_to_tql(obj_type, import_type, attack_object, sub_technique)
-        logger.debug(f"tql name {sdo_tql_name}, obj tql {obj_tql}")
-        obj_class = class_for_type(sdo_tql_name, import_type, "sdo")
-        logger.debug(f'output  object class is {obj_class}')
-    elif obj_type in auth["types"]["sco"]:
-        logger.debug("I'm in sco")
-        obj_class = class_for_type(obj_type, import_type, "sco")
-    elif obj_type in auth["types"]["sro"]:
-        logger.debug("I'm in sro")
-        uses_relation = False
-        is_procedure = False
-        if attack_object:
-            uses_relation = False if not stix_dict.get("relationship_type", False) == "uses" else True
-            is_procedure = False if not stix_dict.get("target_ref", False) == "attack-pattern" else True
-        obj_tql = {}
-        sro_sub_rel = "" if not stix_dict.get("relationship_type", False) else stix_dict["relationship_type"]
-
-        obj_tql, sro_tql_name, is_list, protocol = sro_type_to_tql(obj_type, sro_sub_rel, import_type, attack_object,
-                                                         uses_relation, is_procedure)
-        logger.debug(f"~~~~~~~~~~~ sro tql name {sro_tql_name}")
-        if obj_type == "relationship":
-            if attack_object:
-                obj_tql_name = "attack-relation"
-            else:
-                obj_tql_name = "stix-core-relationship"
-        elif obj_type == "sighting":
-            obj_tql_name = "sighting"
-        if sro_tql_name == "attack-relation":
-            obj_tql_name = sro_tql_name
-        obj_class = class_for_type(obj_tql_name, import_type, "sro")
-    elif obj_type in auth["types"]["sub"]:
-        logger.debug("I'm in sub")
-        obj_class = class_for_type(obj_type, import_type, "sub")
-    elif obj_type in auth["types"]["meta"]:
-        logger.debug("I'm in meta")
-        if attack_object:
-            obj_class = class_for_type("attack-marking", import_type, "meta")
-        else:
-            obj_class = dict_to_stix2(stix_dict, True)
-            logger.debug(f'object class is finally {obj_class}')
-            return obj_class
-
-    elif allow_custom:
-        logger.debug("I'm in custom")
-        raise ParseError(f'the object is not known, and custom is enabled but not implemented')
-    else:
-        logger.debug("object is not known")
-        raise ParseError(f'the object is not known, and custom is not enabled')
-
-    if not obj_class:
-        if allow_custom:
-            # flag allows for unknown custom objects too, but will not
-            # be parsed into STIX object, returned as is
-            return stix_dict
-        for key_id, ext_def in stix_dict.get('extensions', {}).items():
-            if (
-                key_id.startswith('extension-definition--') and
-                'property-extension' not in ext_def.get('extension_type', '')
-            ):
-                # prevents ParseError for unregistered objects when
-                # allow_custom=False and the extension defines a new object
-                return stix_dict
-        raise ParseError(f"Can't parse unknown object type {obj_type}! For custom types, use the CustomObject decorator." + str(obj_type))
-
-    logger.debug(f'object class is finally {obj_class}')
-    logger.debug("========================================")
-    for k, v in stix_dict.items():
-        logger.debug(f'k-> {k}, v->{v}')
-    logger.debug("=========================================")
-    stix_dict['allow_custom'] = allow_custom
-    return obj_class(**stix_dict)
-
-
-def class_for_type(stix_typeql, import_type, category=None):
-    """
-    Get the registered class which implements a particular STIX type for a
-    particular STIX version.
-    :param stix_typeql: A STIX type as a string, or for extension-definition
-        style extensions, the STIX ID of the definition.
-    :param import_type: If present, it describes the set of configuration
-            options, which impact the classes the parser will see
-    :param category: An optional "category" value, which is just used directly
-        as a second key after the STIX version, and depends on how the types
-        are internally categorized.  This would be useful if the same STIX type
-        is used to mean two different things within the same STIX version.  So
-        it's unlikely to be necessary.  Pass None to just search all the
-        categories and return the first class found.
-    :return: A registered python class which implements the given STIX type, or
-        None if one is not found.
-    """
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    conv_cls = ""
-    cls = None
-    logger.debug(f' working out classes, typeql {stix_typeql}, category {category}')
-
-    # find the conversion record
-    if category is not None:
-        for obj in auth["conv"][category]:
-            logger.debug(f'object tql is {obj["typeql"]}, wanted {stix_typeql}')
-            if obj["typeql"] == stix_typeql:
-                logger.debug("found the right type")
-                conv_cls = obj["class"]
-                logger.debug(f'classs is {conv_cls}')
-                cls = copy.deepcopy(auth["classes"][category][conv_cls])
-                logger.debug(f'classs 2 is {cls}')
-                return cls
-
-    return cls
+
+import json
+import copy
+from stixorm.module.authorise import authorised_mappings, import_type_factory
+from stix2.exceptions import ParseError
+from stix2.parsing import dict_to_stix2
+from stixorm.module.parsing.conversion_decisions import sdo_type_to_tql, sro_type_to_tql
+import logging
+
+from stixorm.module.typedb_lib.factories.auth_factory import get_auth_factory_instance
+from stixorm.module.typedb_lib.factories.import_type_factory import ImportType
+
+logger = logging.getLogger(__name__)
+default_import_type = import_type_factory.get_default_import()
+
+
+def parse(data: dict, allow_custom=False, import_type: ImportType=default_import_type):
+    """Convert a string, dict or file-like object into a STIX object.
+    Args:
+        data (str, dict, file-like object): The STIX 2 content to be parsed.
+        allow_custom (bool): Whether to allow custom properties as well unknown
+            custom objects. Note that unknown custom objects cannot be parsed
+            into STIX objects, and will be returned as is. Default: False.
+        import_type (dict): If present, it describes the set of configuration
+            options, which impact the classes the parser will see
+    Returns:
+        An instantiated Python STIX object.
+    Warnings:
+        'allow_custom=True' will allow for the return of any supplied STIX
+        dict(s) that cannot be found to map to any known STIX object types
+        (both STIX2 domain objects or defined custom STIX2 objects); NO
+        validation is done. This is done to allow the processing of possibly
+        unknown custom STIX objects (example scenario: I need to query a
+        third-party TAXII endpoint that could provide custom STIX objects that
+        I don't know about ahead of time)
+    """
+    # convert STIX object to dict, if not already
+    logger.debug("i'm in parse, bout to get dict")
+    obj = _get_dict(data)
+    logger.debug("i'm in parse after get dict")
+
+    # convert dict to full python-stix2 obj
+    obj = dict_to_stix(obj, allow_custom, import_type)
+    logger.debug(f"############## obj is {obj} ########")
+
+    return obj
+
+
+def _get_dict(data):
+    """Return data as a dictionary.
+    Input can be a dictionary, string, or file-like object.
+    """
+
+    if type(data) is dict:
+        return data
+    else:
+        try:
+            return json.loads(data)
+        except TypeError:
+            pass
+        try:
+            return json.load(data)
+        except AttributeError:
+            pass
+        try:
+            return dict(data)
+        except (ValueError, TypeError):
+            raise ValueError(f"Cannot convert {str(data)} to dictionary.")
+
+
+def is_attack_object(stix_dict):
+    if stix_dict.get("x_mitre_domains", False) or stix_dict.get("x_mitre_attack_spec_version", False):
+        return True
+    else:
+        return False
+
+
+def dict_to_stix(stix_dict: dict,
+                 allow_custom=False,
+                 import_type: ImportType=default_import_type):
+    """convert dictionary to full python-stix2 object
+    Args:
+        stix_dict (dict): a python dictionary of a STIX object
+            that (presumably) is semantically correct to be parsed
+            into a full python-stix2 obj
+        allow_custom (bool): Whether to allow custom properties as well
+            unknown custom objects. Note that unknown custom objects cannot
+            be parsed into STIX objects, and will be returned as is.
+            Default: False.
+        import_type (dict): If present, it describes the set of configuration
+            options, which impact the classes the parser will see
+    Returns:
+        An instantiated Python STIX object
+    Warnings:
+        'allow_custom=True' will allow for the return of any supplied STIX
+        dict(s) that cannot be found to map to any known STIX object types
+        (both STIX2 domain objects or defined custom STIX2 objects); NO
+        validation is done. This is done to allow the processing of
+        possibly unknown custom STIX objects (example scenario: I need to
+        query a third-party TAXII endpoint that could provide custom STIX
+        objects that I don't know about ahead of time)
+    """
+    assert len(stix_dict) > 0
+    logger.debug(f"I'm in dict to stix, {stix_dict}")
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    if 'type' not in stix_dict:
+        raise ParseError(f"Can't parse object with no 'type' property: {str(stix_dict)}")
+
+    obj_type = stix_dict["type"]
+    logger.debug(f'\nin parse, raw type is --> {obj_type}')
+    logger.debug(f'\n auth-sdo -->{auth["tql_types"]["sdo"]}\n')
+    logger.debug(f'\n\n auth-sro -->{auth["tql_types"]["sro"]}\n')
+    attack_object = is_attack_object(stix_dict)
+    logger.debug(f'attack object {attack_object}')
+    #logger.info(f'auth is {auth["tql_types"]["meta"]}')
+    if obj_type in auth["types"]["sdo"]:
+        logger.debug("Im in sdo")
+        sub_technique = False
+        if attack_object:
+            sub_technique = stix_dict.get("x_mitre_is_subtechnique", False)
+        logger.debug(f'subtechnique {sub_technique}, attack {attack_object}')
+        obj_tql, sdo_tql_name, is_list, protocol = sdo_type_to_tql(obj_type, import_type, attack_object, sub_technique)
+        logger.debug(f"tql name {sdo_tql_name}, obj tql {obj_tql}")
+        obj_class = class_for_type(sdo_tql_name, import_type, "sdo")
+        logger.debug(f'output  object class is {obj_class}')
+    elif obj_type in auth["types"]["sco"]:
+        logger.debug("I'm in sco")
+        obj_class = class_for_type(obj_type, import_type, "sco")
+    elif obj_type in auth["types"]["sro"]:
+        logger.debug("I'm in sro")
+        uses_relation = False
+        is_procedure = False
+        if attack_object:
+            uses_relation = False if not stix_dict.get("relationship_type", False) == "uses" else True
+            is_procedure = False if not stix_dict.get("target_ref", False) == "attack-pattern" else True
+        obj_tql = {}
+        sro_sub_rel = "" if not stix_dict.get("relationship_type", False) else stix_dict["relationship_type"]
+
+        obj_tql, sro_tql_name, is_list, protocol = sro_type_to_tql(obj_type, sro_sub_rel, import_type, attack_object,
+                                                         uses_relation, is_procedure)
+        logger.debug(f"~~~~~~~~~~~ sro tql name {sro_tql_name}")
+        if obj_type == "relationship":
+            if attack_object:
+                obj_tql_name = "attack-relation"
+            else:
+                obj_tql_name = "stix-core-relationship"
+        elif obj_type == "sighting":
+            obj_tql_name = "sighting"
+        if sro_tql_name == "attack-relation":
+            obj_tql_name = sro_tql_name
+        obj_class = class_for_type(obj_tql_name, import_type, "sro")
+    elif obj_type in auth["types"]["sub"]:
+        logger.debug("I'm in sub")
+        obj_class = class_for_type(obj_type, import_type, "sub")
+    elif obj_type in auth["types"]["meta"]:
+        logger.debug("I'm in meta")
+        if attack_object:
+            obj_class = class_for_type("attack-marking", import_type, "meta")
+        else:
+            obj_class = dict_to_stix2(stix_dict, True)
+            logger.debug(f'object class is finally {obj_class}')
+            return obj_class
+
+    elif allow_custom:
+        logger.debug("I'm in custom")
+        raise ParseError(f'the object is not known, and custom is enabled but not implemented')
+    else:
+        logger.debug("object is not known")
+        raise ParseError(f'the object is not known, and custom is not enabled')
+
+    if not obj_class:
+        if allow_custom:
+            # flag allows for unknown custom objects too, but will not
+            # be parsed into STIX object, returned as is
+            return stix_dict
+        for key_id, ext_def in stix_dict.get('extensions', {}).items():
+            if (
+                key_id.startswith('extension-definition--') and
+                'property-extension' not in ext_def.get('extension_type', '')
+            ):
+                # prevents ParseError for unregistered objects when
+                # allow_custom=False and the extension defines a new object
+                return stix_dict
+        raise ParseError(f"Can't parse unknown object type {obj_type}! For custom types, use the CustomObject decorator." + str(obj_type))
+
+    logger.debug(f'object class is finally {obj_class}')
+    logger.debug("========================================")
+    for k, v in stix_dict.items():
+        logger.debug(f'k-> {k}, v->{v}')
+    logger.debug("=========================================")
+    stix_dict['allow_custom'] = allow_custom
+    return obj_class(**stix_dict)
+
+
+def class_for_type(stix_typeql, import_type, category=None):
+    """
+    Get the registered class which implements a particular STIX type for a
+    particular STIX version.
+    :param stix_typeql: A STIX type as a string, or for extension-definition
+        style extensions, the STIX ID of the definition.
+    :param import_type: If present, it describes the set of configuration
+            options, which impact the classes the parser will see
+    :param category: An optional "category" value, which is just used directly
+        as a second key after the STIX version, and depends on how the types
+        are internally categorized.  This would be useful if the same STIX type
+        is used to mean two different things within the same STIX version.  So
+        it's unlikely to be necessary.  Pass None to just search all the
+        categories and return the first class found.
+    :return: A registered python class which implements the given STIX type, or
+        None if one is not found.
+    """
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    conv_cls = ""
+    cls = None
+    logger.debug(f' working out classes, typeql {stix_typeql}, category {category}')
+
+    # find the conversion record
+    if category is not None:
+        for obj in auth["conv"][category]:
+            logger.debug(f'object tql is {obj["typeql"]}, wanted {stix_typeql}')
+            if obj["typeql"] == stix_typeql:
+                logger.debug("found the right type")
+                conv_cls = obj["class"]
+                logger.debug(f'classs is {conv_cls}')
+                cls = copy.deepcopy(auth["classes"][category][conv_cls])
+                logger.debug(f'classs 2 is {cls}')
+                return cls
+
+    return cls
```

### Comparing `stixorm-0.1.3/stixorm/module/typedb.py` & `stixorm-0.1.9/stixorm/module/typedb.py`

 * *Ordering differences only*

 * *Files 9% similar despite different names*

```diff
@@ -1,742 +1,742 @@
-"""Python STIX2 TypeDB Source/Sink"""
-import os.path
-import pathlib
-import traceback
-from dataclasses import dataclass
-from typedb.client import *
-from stixorm.module.orm.import_objects import raw_stix2_to_typeql
-from stixorm.module.orm.delete_object import delete_stix_object, add_delete_layers
-from stixorm.module.orm.export_object import convert_ans_to_stix
-from stixorm.module.parsing.parse_objects import parse
-from .authorise import authorised_mappings, import_type_factory
-from .initialise import setup_database, load_schema, load_markings
-import networkx as nx
-from stix2 import v21
-from stix2.base import _STIXBase
-from stix2.datastore import (
-    DataSink, DataSource, )
-from stix2.datastore.filters import FilterSet
-
-import logging
-
-from stixorm.module.typedb_lib.handlers import handle_result
-from stixorm.module.typedb_lib.logging import log_delete_instruction, log_delete_instruction_update_layer, log_delete_layers
-from stixorm.module.typedb_lib.queries import delete_database, match_query, query_ids, delete_layers, build_match_id_query,\
-    build_insert_query, query_id, add_instructions_to_typedb
-from stixorm.module.typedb_lib.file import write_to_file
-from stixorm.module.typedb_lib.instructions import Instructions, Status, AddInstruction, TypeQLObject, Result
-from stixorm.module.typedb_lib.factories.import_type_factory import ImportType, ImportTypeFactory
-from stixorm.module.typedb_lib.factories.auth_factory import get_auth_factory_instance
-
-# logging.basicConfig(level=logging.INFO, format='[%(asctime)s] %(levelname)s [%(name)s:%(lineno)s] %(message)s')
-
-logger = logging.getLogger(__name__)
-
-
-@dataclass
-class TransactionObject:
-    transaction: TypeDBTransaction
-    session: TypeDBSession
-
-
-
-class TypeDBSink(DataSink):
-    """Interface for adding/pushing STIX objects to TypeDB.
-
-    Can be paired with a TypeDBSource, together as the two
-    components of a TypeDBStore.
-
-    Args:
-        - connection is a dict, containing:
-            - uri (str): URI to TypeDB.
-            - port (int): Port to TypeDB.
-            - db (str): Name of TypeDB database.
-            - user (str): Username for TypeDB, if cluster, otherwise None
-            - password (str): Password for TypeDB, if cluster, otherwise None
-        - clear (bool): If True, clear the TypeDB before adding objects.
-        - import_type (str): It forces the parser to use either the stix2.1, or mitre att&ck
-
-    """
-
-    def __init__(self,
-                 connection: Dict[str, str],
-                 clear=False,
-                 import_type: Optional[ImportType]=None,
-                 schema_path: Optional[str] = None,
-                 strict_failure: bool = False, **kwargs):
-        super(TypeDBSink, self).__init__()
-        logger.debug(f'TypeDBSink: {connection}')
-
-        assert connection["uri"] is not None
-        assert connection["port"] is not None
-        assert connection["database"] is not None
-
-        self._stix_connection = connection
-        self.uri: str = connection["uri"]
-        self.port: str = connection["port"]
-        self.database: str = connection["database"]
-        self.user: str = connection["user"]
-        self.password: str = connection["password"]
-        self.clear: bool = clear
-        self.strict_failure = strict_failure
-
-        self.schema_path = schema_path
-        self.import_type: ImportType = import_type
-
-        self.__initialise()
-
-
-
-    def __initialise(self):
-        assign_result = self.__assign_schemas()
-        handle_result(assign_result, "assign result", self.strict_failure)
-
-        assign_import_result = self.__assign_import_type()
-        handle_result(assign_import_result, "assign import result", self.strict_failure)
-
-        # Validate database can be connected
-        validate_connection = self.__validate_connect_to_db()
-        handle_result(validate_connection, "validate connection result", self.strict_failure)
-
-        # 1. Setup database
-        setup_database(self._stix_connection, self.clear)
-
-        # 2. Load the Schema's
-        # A. Load the Stix Schema
-        schema_result = self.__load_stix_schema()
-        handle_result(schema_result, "history schema result", self.strict_failure)
-        # B. Load Stix Rules Schema
-        rules_result = self.__load_stix_rules()
-        handle_result(rules_result, "history stix rules result", self.strict_failure)
-        # C. Load the Attack Schema
-        attack_result = self.__load_attack_schema()
-        handle_result(attack_result, "history attack result", self.strict_failure)
-        # D. Load the OS-Threat Schema
-        os_threat_result = self.__load_os_threat_schema()
-        handle_result(os_threat_result, "history os threat result", self.strict_failure)
-
-        # 3. Load the Objects
-        # Still to do
-
-    def __validate_connect_to_db(self):
-        logger.debug("Attempting DB Connection")
-        self.__get_core_client()
-        logger.debug("DB Connection Successful")
-
-
-    def __load_attack_schema(self):
-        if self.clear and self.import_type.ATTACK:
-            logger.debug("ATT&CK")
-            load_schema(self._stix_connection, str(self.cti_schema_attack), "ATT&CK Schema")
-            logger.info("we have loaded ATT&CK schema")
-        else:
-            logger.debug("ignoring history ATT&CK schema")
-
-
-    def __load_os_threat_schema(self):
-        if self.clear and self.import_type.os_threat:
-            logger.debug("os-threat")
-            load_schema(self._stix_connection, str(self.cti_schema_os_threat), "os-threat Schema ")
-            logger.info("we have loaded os-threat schema")
-        else:
-            logger.debug("ignoring history  os hunt")
-
-
-    def __load_stix_rules(self):
-        if self.clear and self.import_type.rules:
-            logger.debug("rules")
-            load_schema(self._stix_connection, str(self.cti_schema_stix_rules), "Stix 2.1 Rules")
-            logger.info("we have loaded Stix rules")
-        else:
-            logger.debug("ignoring check of stix rules")
-
-
-    def __load_stix_schema(self):
-        if self.clear:
-            load_schema(self._stix_connection, str(self.cti_schema_stix), "Stix 2.1 Schema ")
-            self.loaded = load_markings(self._stix_connection)
-            logger.info("we have loaded Stix schema")
-        else:
-            logger.debug("ignoring history stix schema")
-
-
-    def __assign_schemas(self):
-        if self.schema_path is None:
-             self.schema_path = str(pathlib.Path(__file__).parent)
-
-        # If relative paths are used it will depend upon the entry point i.e. working directory will need to be same level as typedb.py
-        self.cti_schema_stix = pathlib.Path(self.schema_path).joinpath("definitions/stix21/schema/cti-schema-v2.tql")
-        assert os.path.isfile(self.cti_schema_stix)
-        self.cti_schema_stix_rules = pathlib.Path(self.schema_path).joinpath("definitions/stix21/schema/cti-rules.tql")
-        assert os.path.isfile(self.cti_schema_stix_rules)
-        self.cti_schema_os_threat = pathlib.Path(self.schema_path).joinpath("definitions/os_threat/schema/cti-os-threat.tql")
-        assert os.path.isfile(self.cti_schema_os_threat)
-        self.cti_schema_os_hunt = pathlib.Path(self.schema_path).joinpath("definitions/os_threat/schema/cti-os-hunt.tql")
-        assert os.path.isfile(self.cti_schema_os_hunt)
-        self.cti_schema_attack = pathlib.Path(self.schema_path).joinpath("definitions/attack/schema/cti-attack.tql")
-        assert os.path.isfile(self.cti_schema_attack)
-        # if self.schema_path is None:
-        #     self.schema_path = str(pathlib.Path.parent)
-        #
-        # self.cti_schema_path = pathlib.Path(self.schema_path).joinpath("stix/schema/cti-schema-v2.tql")
-        # assert self.cti_schema_path.is_file(), "The schema does not exist: " + str(self.cti_schema_path)
-        #
-        # self.cti_schema_rules_path = pathlib.Path(self.schema_path).joinpath("stix/schema/cti-rules.tql")
-        # assert self.cti_schema_rules_path.is_file(), "The schema does not exist: " + str(self.cti_schema_rules_path)
-
-    def __assign_import_type(self):
-        if self.import_type is None:
-            self.import_type = import_type_factory.get_default_import()
-
-    @property
-    def stix_connection(self):
-        return self._stix_connection
-
-    def clear_db(self):
-
-        result = delete_database(self.uri, self.port, self.database)
-        logger.debug("Successfully cleared database")
-
-
-    def __filter_markings(self, stix_ids: List[StringAttribute]) -> List[str]:
-        marking = ["marking-definition--613f2e26-407d-48c7-9eca-b8e91df99dc9",
-                   "marking-definition--34098fce-860f-48ae-8e50-ebd3cc5e41da",
-                   "marking-definition--f88d31f6-486f-44da-b317-01333bde0b82",
-                   "marking-definition--5e57c739-391a-4eb3-b6be-7d15ca92d5ed"]
-
-        filtered_list = list(filter(lambda x: x.get_value() not in marking, stix_ids))
-        return self.__string_attibute_to_string(filtered_list)
-
-    def __string_attibute_to_string(self,
-                                    string_attributes: List[StringAttribute]):
-        return [stix_id.get_value() for stix_id in string_attributes]
-
-    def __query_stix_ids(self):
-        get_ids_tql = 'match $ids isa stix-id;'
-        data_query = query_ids
-        query_data = match_query(self.uri,
-                                 self.port,
-                                 self.database,
-                                 get_ids_tql,
-                                 data_query)
-
-        return query_data
-
-
-    def get_stix_ids(self):
-        """ Get all the stix-ids in a database, should be moved to DataSource object
-
-        Returns:
-            id_list : list of the stix-ids in the database
-        """
-        stix_ids_query = self.__query_stix_ids()
-
-        result = self.__filter_markings(stix_ids_query)
-        return result
-
-
-    def __retrieve_stix_id(self,
-                           stix_id: str):
-        type_db_source = self.__get_source_client()
-        return type_db_source.get(stix_id)
-
-
-    def __delete_instruction(self,
-                             stixid: str):
-
-        stix_obj = self.__retrieve_stix_id(stixid)
-
-        dep_match, dep_insert, indep_ql, core_ql, dep_obj = raw_stix2_to_typeql(stix_obj, self.import_type)
-        del_match, del_tql = delete_stix_object(stix_obj, dep_match, dep_insert, indep_ql, core_ql, self.import_type)
-        dep_obj["delete"] = del_match + '\n' + del_tql
-
-        log_delete_instruction(del_match, dep_insert, indep_ql, dep_obj, del_match, del_tql)
-        if del_match == '' and del_tql == '':
-            return None
-        else:
-            return dep_obj
-
-
-    def __update_delete_layers(self,
-                               layers,
-                               indexes,
-                               missing,
-                               dep_obj):
-        if dep_obj is None:
-            return layers, indexes, missing
-        if len(layers) == 0:
-            missing = dep_obj['dep_list']
-            indexes.append(dep_obj['id'])
-            layers.append(dep_obj)
-        else:
-            layers, indexes, missing = add_delete_layers(layers, dep_obj, indexes, missing)
-        return layers, indexes, missing
-
-
-    def __retrieve_delete_instructions(self,
-                                       stixids: List[str]) -> Instructions:
-
-        layers = []
-        indexes = []
-        missing = []
-
-        instructions = Instructions()
-
-        for stixid in stixids:
-            del_result = self.__delete_instruction(stixid)
-            layers, indexes, missing = self.__update_delete_layers(layers, indexes, missing, del_result)
-
-        for layer in layers:
-            instructions.insert_delete_instruction(layer['id'], layer)
-        return instructions
-
-
-    def __order_delete_instructions(self,
-                                    delete_instructions: Instructions):
-        layer = {}
-        layer['delete'] = 'match $a isa attribute; not { $b isa thing; $b has $a;}; delete $a isa attribute;'
-        delete_instructions.insert_delete_instruction(
-            "cleanup-1", layer
-        )
-        delete_instructions.insert_delete_instruction(
-            "cleanup-2", layer
-        )
-        return delete_instructions
-
-    def delete(self, stixid_list: List[str]) -> Instructions:
-        """ Delete a list of STIX objects from the typedb_lib server. Must include all related objects and relations
-
-        Args:
-            stixid_list (): The list of Stix-id's of the object's to delete
-        """
-
-        delete_instruction_result = self.__retrieve_delete_instructions(stixid_list)
-        order_instruction_result = self.__order_delete_instructions(delete_instruction_result)
-        delete_from_database_result = delete_layers(self.uri,
-                                                    self.port,
-                                                    self.database,
-                                                    order_instruction_result)
-
-        instructions = delete_from_database_result
-
-        return instructions.convert_to_result()
-
-
-
-    def __get_core_client(self) -> TypeDBClient:
-        typedb_url = self.uri + ":" + self.port
-        return TypeDB.core_client(typedb_url)
-
-
-    def __get_source_client(self):
-        connection = {'uri': self.uri,
-                      'port': self.port,
-                      'database': self.database,
-                      'user': self.user,
-                      'password': self.password}
-
-        return TypeDBSource(connection, self.import_type)
-
-
-
-
-    def __generate_typeql_object(self, stix_dict: dict) -> TypeQLObject:
-
-        logger.debug(f"\n================================================================\nim about to parse \n")
-        stix_obj = parse(stix_dict, False, self.import_type)
-        logger.debug(f'\n-------------------------------------------------------------\n i have parsed\n')
-        dep_match, dep_insert, indep_ql, core_ql, dep_obj = raw_stix2_to_typeql(stix_obj, self.import_type)
-        logger.debug(f'\ndep_match {dep_match} \ndep_insert {dep_insert} \nindep_ql {indep_ql} \ncore_ql {core_ql}')
-        typeql_obj = TypeQLObject(
-            dep_match=dep_match,
-            dep_insert=dep_insert,
-            indep_ql=indep_ql,
-            core_ql=core_ql,
-            dep_list=dep_obj.get('dep_list', [])
-        )
-
-        return typeql_obj
-
-
-    def __generate_instructions(self,
-                                obj_list) -> Instructions:
-        instructions = Instructions()
-        for stix_dict in obj_list:
-            try:
-                typeql_object_result = self.__generate_typeql_object(stix_dict)
-
-                typeql_object: TypeQLObject = typeql_object_result
-                instructions.insert_add_instruction(stix_dict['id'], typeql_object)
-            except Exception as e:
-                logging.exception(e)
-                logging.info("Error generating instructions for " + stix_dict['id'])
-                instructions.insert_add_instruction(stix_dict['id'], None)
-                traceback_str = traceback.format_exc()
-                instructions.update_instruction_as_error(stix_dict['id'], traceback_str)
-
-
-        return instructions
-
-
-    def __create_instruction_dependency_graph(self,
-                                              instructions: Instructions):
-        directed_graph = nx.DiGraph()
-        instruction: AddInstruction
-        for instruction in instructions.instructions.values():
-            try:
-                if instruction.status in [Status.ERROR]:
-                    logging.debug("Skipping error " + instruction.id)
-                    continue
-
-                dependencies = instruction.typeql_obj.dep_list
-
-                this_node = instruction.id
-                if not directed_graph.has_node(this_node):
-                    # logging.info("Already has node id " + this_node)
-                    # logging.info("Inserting dependency node " + this_node)
-                    directed_graph.add_node(this_node)
-
-                for dependency_node in dependencies:
-                    if not directed_graph.has_node(dependency_node):
-                       # logging.info("Already has dependency node id " + this_node)
-
-                       # logging.info("Dependency node does not exist id " + this_node)
-                        directed_graph.add_node(this_node)
-                    directed_graph.add_edge(dependency_node, this_node)
-                instructions.add_dependencies(directed_graph)
-            except Exception as e:
-                logging.error("Error creating dependency graph for " + instruction.id)
-                logging.error(e)
-                traceback_str = traceback.format_exc()
-                instructions.update_instruction_as_error(instruction.id, traceback_str)
-
-        return instructions
-
-
-
-    def __generate_queries(self,
-                           instructions: Instructions):
-        result = instructions.create_insert_queries(build_insert_query)
-        return result
-
-
-    def __check_missing_dependencies(self,
-                                     instructions: Instructions):
-        missing_ids_from_tree = instructions.missing_dependency_ids()
-
-        result = []
-        for missing_ids in missing_ids_from_tree[:500]:
-            query_result = build_match_id_query(missing_ids)
-
-            data_result = match_query(uri=self.uri,
-                                      port=self.port,
-                                      database=self.database,
-                                      query=query_result,
-                                      data_query=query_id,
-                                      import_type=None)
-            result = result + data_result
-
-
-        missing_ids_found_in_db = result
-        # ids with no record in db and in dependency tree
-        ids_missing = list(set(missing_ids_from_tree) - set(missing_ids_found_in_db))
-        instructions.register_missing_dependencies(ids_missing)
-
-        return instructions
-
-
-
-    def __reorder_instructions(self,
-                               instructions: Instructions):
-        try:
-            order = list(nx.topological_sort(instructions.dependencies))
-            instructions.add_insertion_order(order)
-        except Exception as e:
-            logging.exception(e)
-        return instructions
-
-
-
-
-    def add(self, stix_data: Optional[List[dict]] = None) -> List[Result]:
-        """Add STIX objects to the typedb_lib server.
-            1. Gather objects into a list
-            2. For each object
-                a. get raw stix to tql
-                b. add object to an ordered list
-                c. return the ordered list
-            3. Add each object in the ordered list
-        Args:
-            stix_data (STIX object OR Bundle OR dict OR list): valid STIX 2.1 content
-                in a STIX object (or list of), dict (or list of), or a STIX 2.1
-                json encoded string.
-            import_type (dict): It forces the parser to use either the stix2.1,
-                or the mitre attack typeql description. Values can be either:
-                        - "STIX21"
-                        - "mitre"
-        Note:
-            ``stix_data`` can be a Bundle object, but each object in it will be
-            saved separately; you will be able to retrieve any of the objects
-            the Bundle contained, but not the Bundle itself.
-        """
-        logger.debug("1. starting in add")
-        obj_result = self._gather_objects(stix_data)
-
-        generate_instructions_result = self.__generate_instructions(obj_result)
-        logger.info("\n##########################################################################################################################################################\n")
-        #logger.info(f"generate instructions is {generate_instructions_result}")
-        instruction_dependency_graph_result =  self.__create_instruction_dependency_graph(generate_instructions_result)
-        check_missing_dependency_result = self.__check_missing_dependencies(instruction_dependency_graph_result)
-
-        instructions: Instructions = check_missing_dependency_result
-        if instructions.exist_missing_dependencies():
-            return instructions.convert_to_result()
-        if instructions.exist_cyclical_ids():
-            instructions.register_cyclical_dependencies()
-            return instructions.convert_to_result()
-
-        reorder_result = self.__reorder_instructions(instructions)
-
-        queries_result = self.__generate_queries(reorder_result)
-
-        add_to_database_result = add_instructions_to_typedb(self.uri,
-                                                            self.port,
-                                                            self.database,
-                                                            reorder_result)
-
-        instructions = add_to_database_result
-
-        return instructions.convert_to_result()
-
-
-
-    def _gather_objects(self, stix_data):
-        """
-          the details for the add details, checking what import_type of data object it is
-        """
-        #logger.debug(f" gethering ...{stix_data}")
-        #logger.debug('----------------------------------------')
-        #logger.debug(f'going into separate objects function {stix_data}')
-        #logger.debug('-----------------------------------------------------')
-
-        if isinstance(stix_data, (v21.Bundle)):
-            logger.debug(f'isinstance Bundle')
-            # recursively add individual STIX objects
-            logger.debug(f'obects are {stix_data["objects"]}')
-            return stix_data.get("objects", [])
-
-
-        elif isinstance(stix_data, _STIXBase):
-            logger.debug("base")
-            logger.debug(f'isinstance _STIXBase')
-            temp_list = []
-            temp_list.append(stix_data)
-            return temp_list
-
-        elif isinstance(stix_data, (str, dict)):
-            if stix_data.get("type", '') == 'bundle':
-                return stix_data.get("objects", [])
-            else:
-                logger.debug("dcit")
-                logger.debug(f'isinstance dict')
-                temp_list = []
-                temp_list.append(stix_data)
-                return temp_list
-
-        elif isinstance(stix_data, list):
-            item_list = []
-            for item in stix_data:
-                if item.get("type", '') == 'bundle':
-                    item_list = item_list + item.get("objects", [])
-                else:
-                    item_list.append(item)
-
-            logger.debug(f'isinstance list')
-            # recursively add individual STIX objects
-            return item_list
-
-        else:
-            raise TypeError(
-                "stix_data must be a STIX object (or list of), "
-                "JSON formatted STIX (or list of), "
-                "or a JSON formatted STIX bundle",
-            )
-
-
-class TypeDBSource(DataSource):
-    """Interface for searching/retrieving STIX objects from a TypeDB Database.
-
-    Can be paired with a TypeDBSink, together as the two
-    components of a TypeDBStore.
-
-    Args:
-        - connection is a dict, containing:
-            - uri (str): URI to TypeDB.
-            - port (int): Port to TypeDB.
-            - db (str): Name of TypeDB database.
-            - user (str): Username for TypeDB, if cluster, otherwise None
-            - password (str): Password for TypeDB, if cluster, otherwise None
-        - import_type (str): It forces the parser to use either the stix2.1, or mitre att&ck
-
-    """
-
-    def __init__(self, connection: Dict[str, str], import_type: Optional[ImportType]=None, **kwargs):
-        super(TypeDBSource, self).__init__()
-        logger.debug(f'TypeDBSource: {connection}')
-
-        assert connection["uri"] is not None
-        assert connection["port"] is not None
-        assert connection["database"] is not None
-        assert import_type is None or isinstance(import_type, ImportType)
-
-        self._stix_connection = connection
-        self.uri = connection["uri"]
-        self.port = connection["port"]
-        self.database = connection["database"]
-        self.user = connection["user"]
-        self.password = connection["password"]
-        self.import_type: ImportType = self.__default_import_type() if import_type is None else import_type
-
-    def __default_import_type(self):
-        return ImportTypeFactory.get_default_import()
-
-    @property
-    def stix_connection(self):
-        return self._stix_connection
-
-
-    def __retrieve_stix_object(self,
-                               stix_id: str):
-        logger.debug(f'__retrieve_stix_object: {stix_id}')
-        obj_var, type_ql = get_embedded_match(stix_id, self.import_type)
-        query = 'match ' + type_ql
-        logger.debug(f'query is {query}')
-
-        data = match_query(uri=self.uri,
-                           port=self.port,
-                           database=self.database,
-                           query=query,
-                           data_query=convert_ans_to_stix,
-                           import_type=self.import_type)
-
-        logger.debug(f'data is -> {data}')
-        stix_obj = parse(data=data, allow_custom=False, import_type=self.import_type)
-
-        # result = write_to_file("stixorm/module/orm/export_final.json", stix_obj)
-        # if not is_successful(result):
-        #     logging.exception("\n".join(traceback.format_exception(result.failure())))
-        #     logger.error(str(result.failure()))
-
-        return stix_obj
-
-    def get(self, stix_id: str, _composite_filters=None):
-        """Retrieve STIX object from file directory via STIX ID.
-
-        Args:
-            stix_id (str): The STIX ID of the STIX object to be retrieved.
-            _composite_filters (FilterSet): collection of filters passed from the parent
-                CompositeDataSource, not user supplied
-
-        Returns:
-            (STIX object): STIX object that has the supplied STIX ID.
-                The STIX object is loaded from its json file, parsed into
-                a python STIX object and then returned
-
-        """
-
-        result = self.__retrieve_stix_object(stix_id)
-        return result
-
-    def query(self, query=None, version=None, _composite_filters=None):
-        """Search and retrieve STIX objects based on the complete query.
-
-        A "complete query" includes the filters from the query, the filters
-        attached to this FileSystemSource, and any filters passed from a
-        CompositeDataSource (i.e. _composite_filters).
-
-        Args:
-            query (list): list of filters to search on
-            _composite_filters (FilterSet): collection of filters passed from
-                the CompositeDataSource, not user supplied
-            version (str): If present, it forces the parser to use the version
-                provided. Otherwise, the library will make the best effort based
-                on checking the "spec_version" property.
-
-        Returns:
-            (list): list of STIX objects that matches the supplied
-                query. The STIX objects are loaded from their json files,
-                parsed into a python STIX objects and then returned.
-
-        """
-        pass
-
-    def all_versions(self, stix_id, version=None, _composite_filters=None):
-        """Retrieve STIX object from file directory via STIX ID, all versions.
-
-        Note: Since FileSystem sources/sinks don't handle multiple versions
-        of a STIX object, this operation is unnecessary. Pass call to get().
-
-        Args:
-            stix_id (str): The STIX ID of the STIX objects to be retrieved.
-            _composite_filters (FilterSet): collection of filters passed from
-                the parent CompositeDataSource, not user supplied
-            version (str): If present, it forces the parser to use the version
-                provided. Otherwise, the library will make the best effort based
-                on checking the "spec_version" property.
-
-        Returns:
-            (list): of STIX objects that has the supplied STIX ID.
-                The STIX objects are loaded from their json files, parsed into
-                a python STIX objects and then returned
-
-        """
-        pass
-
-
-
-def get_embedded_match(source_id, import_type):
-    """
-        Assemble the typeql variable and match statement given the stix-id, and the increment
-    Args:
-        source_id (): stix-id to use
-        i (): number of times this type of object has been used
-    Returns:
-        source_var, the typeql string of the variable
-        match, the typeql match statement
-    """
-    source_type = get_source_type(source_id, import_type)
-    source_var = '$' + source_type
-    if source_type == 'relationship':
-        source_type = 'stix-core-relationship'
-    match = f' {source_var} isa {source_type}, has stix-id "{source_id}";\n'
-    return source_var, match
-
-def get_source_type(source_id, import_type):
-    """
-        Get the type of the source_id
-    Args:
-        source_id (): stix-id to use
-    Returns:
-        source_type, the type of the source_id
-    """
-    auth_factory = get_auth_factory_instance()
-    auth = auth_factory.get_auth_for_import(import_type)
-    tmp_source = source_id.split('--')[0]
-    source = ""
-    for model in auth["conv"]["sdo"]:
-        if model["type"] == tmp_source:
-            source = model["typeql"]
-            return source
-    for model in auth["conv"]["sro"]:
-        if model["type"] == tmp_source:
-            source = model["typeql"]
-            return source
-    for model in auth["conv"]["sco"]:
-        if model["type"] == tmp_source:
-            source = model["typeql"]
-            return source
-    for model in auth["conv"]["meta"]:
-        if model["type"] == tmp_source:
-            source = model["typeql"]
-            return source
-    return source
+"""Python STIX2 TypeDB Source/Sink"""
+import os.path
+import pathlib
+import traceback
+from dataclasses import dataclass
+from typedb.client import *
+from stixorm.module.orm.import_objects import raw_stix2_to_typeql
+from stixorm.module.orm.delete_object import delete_stix_object, add_delete_layers
+from stixorm.module.orm.export_object import convert_ans_to_stix
+from stixorm.module.parsing.parse_objects import parse
+from .authorise import authorised_mappings, import_type_factory
+from .initialise import setup_database, load_schema, load_markings
+import networkx as nx
+from stix2 import v21
+from stix2.base import _STIXBase
+from stix2.datastore import (
+    DataSink, DataSource, )
+from stix2.datastore.filters import FilterSet
+
+import logging
+
+from stixorm.module.typedb_lib.handlers import handle_result
+from stixorm.module.typedb_lib.logging import log_delete_instruction, log_delete_instruction_update_layer, log_delete_layers
+from stixorm.module.typedb_lib.queries import delete_database, match_query, query_ids, delete_layers, build_match_id_query,\
+    build_insert_query, query_id, add_instructions_to_typedb
+from stixorm.module.typedb_lib.file import write_to_file
+from stixorm.module.typedb_lib.instructions import Instructions, Status, AddInstruction, TypeQLObject, Result
+from stixorm.module.typedb_lib.factories.import_type_factory import ImportType, ImportTypeFactory
+from stixorm.module.typedb_lib.factories.auth_factory import get_auth_factory_instance
+
+# logging.basicConfig(level=logging.INFO, format='[%(asctime)s] %(levelname)s [%(name)s:%(lineno)s] %(message)s')
+
+logger = logging.getLogger(__name__)
+
+
+@dataclass
+class TransactionObject:
+    transaction: TypeDBTransaction
+    session: TypeDBSession
+
+
+
+class TypeDBSink(DataSink):
+    """Interface for adding/pushing STIX objects to TypeDB.
+
+    Can be paired with a TypeDBSource, together as the two
+    components of a TypeDBStore.
+
+    Args:
+        - connection is a dict, containing:
+            - uri (str): URI to TypeDB.
+            - port (int): Port to TypeDB.
+            - db (str): Name of TypeDB database.
+            - user (str): Username for TypeDB, if cluster, otherwise None
+            - password (str): Password for TypeDB, if cluster, otherwise None
+        - clear (bool): If True, clear the TypeDB before adding objects.
+        - import_type (str): It forces the parser to use either the stix2.1, or mitre att&ck
+
+    """
+
+    def __init__(self,
+                 connection: Dict[str, str],
+                 clear=False,
+                 import_type: Optional[ImportType]=None,
+                 schema_path: Optional[str] = None,
+                 strict_failure: bool = False, **kwargs):
+        super(TypeDBSink, self).__init__()
+        logger.debug(f'TypeDBSink: {connection}')
+
+        assert connection["uri"] is not None
+        assert connection["port"] is not None
+        assert connection["database"] is not None
+
+        self._stix_connection = connection
+        self.uri: str = connection["uri"]
+        self.port: str = connection["port"]
+        self.database: str = connection["database"]
+        self.user: str = connection["user"]
+        self.password: str = connection["password"]
+        self.clear: bool = clear
+        self.strict_failure = strict_failure
+
+        self.schema_path = schema_path
+        self.import_type: ImportType = import_type
+
+        self.__initialise()
+
+
+
+    def __initialise(self):
+        assign_result = self.__assign_schemas()
+        handle_result(assign_result, "assign result", self.strict_failure)
+
+        assign_import_result = self.__assign_import_type()
+        handle_result(assign_import_result, "assign import result", self.strict_failure)
+
+        # Validate database can be connected
+        validate_connection = self.__validate_connect_to_db()
+        handle_result(validate_connection, "validate connection result", self.strict_failure)
+
+        # 1. Setup database
+        setup_database(self._stix_connection, self.clear)
+
+        # 2. Load the Schema's
+        # A. Load the Stix Schema
+        schema_result = self.__load_stix_schema()
+        handle_result(schema_result, "history schema result", self.strict_failure)
+        # B. Load Stix Rules Schema
+        rules_result = self.__load_stix_rules()
+        handle_result(rules_result, "history stix rules result", self.strict_failure)
+        # C. Load the Attack Schema
+        attack_result = self.__load_attack_schema()
+        handle_result(attack_result, "history attack result", self.strict_failure)
+        # D. Load the OS-Threat Schema
+        os_threat_result = self.__load_os_threat_schema()
+        handle_result(os_threat_result, "history os threat result", self.strict_failure)
+
+        # 3. Load the Objects
+        # Still to do
+
+    def __validate_connect_to_db(self):
+        logger.debug("Attempting DB Connection")
+        self.__get_core_client()
+        logger.debug("DB Connection Successful")
+
+
+    def __load_attack_schema(self):
+        if self.clear and self.import_type.ATTACK:
+            logger.debug("ATT&CK")
+            load_schema(self._stix_connection, str(self.cti_schema_attack), "ATT&CK Schema")
+            logger.info("we have loaded ATT&CK schema")
+        else:
+            logger.debug("ignoring history ATT&CK schema")
+
+
+    def __load_os_threat_schema(self):
+        if self.clear and self.import_type.os_threat:
+            logger.debug("os-threat")
+            load_schema(self._stix_connection, str(self.cti_schema_os_threat), "os-threat Schema ")
+            logger.info("we have loaded os-threat schema")
+        else:
+            logger.debug("ignoring history  os hunt")
+
+
+    def __load_stix_rules(self):
+        if self.clear and self.import_type.rules:
+            logger.debug("rules")
+            load_schema(self._stix_connection, str(self.cti_schema_stix_rules), "Stix 2.1 Rules")
+            logger.info("we have loaded Stix rules")
+        else:
+            logger.debug("ignoring check of stix rules")
+
+
+    def __load_stix_schema(self):
+        if self.clear:
+            load_schema(self._stix_connection, str(self.cti_schema_stix), "Stix 2.1 Schema ")
+            self.loaded = load_markings(self._stix_connection)
+            logger.info("we have loaded Stix schema")
+        else:
+            logger.debug("ignoring history stix schema")
+
+
+    def __assign_schemas(self):
+        if self.schema_path is None:
+             self.schema_path = str(pathlib.Path(__file__).parent)
+
+        # If relative paths are used it will depend upon the entry point i.e. working directory will need to be same level as typedb.py
+        self.cti_schema_stix = pathlib.Path(self.schema_path).joinpath("definitions/stix21/schema/cti-schema-v2.tql")
+        assert os.path.isfile(self.cti_schema_stix)
+        self.cti_schema_stix_rules = pathlib.Path(self.schema_path).joinpath("definitions/stix21/schema/cti-rules.tql")
+        assert os.path.isfile(self.cti_schema_stix_rules)
+        self.cti_schema_os_threat = pathlib.Path(self.schema_path).joinpath("definitions/os_threat/schema/cti-os-threat.tql")
+        assert os.path.isfile(self.cti_schema_os_threat)
+        self.cti_schema_os_hunt = pathlib.Path(self.schema_path).joinpath("definitions/os_threat/schema/cti-os-hunt.tql")
+        assert os.path.isfile(self.cti_schema_os_hunt)
+        self.cti_schema_attack = pathlib.Path(self.schema_path).joinpath("definitions/attack/schema/cti-attack.tql")
+        assert os.path.isfile(self.cti_schema_attack)
+        # if self.schema_path is None:
+        #     self.schema_path = str(pathlib.Path.parent)
+        #
+        # self.cti_schema_path = pathlib.Path(self.schema_path).joinpath("stix/schema/cti-schema-v2.tql")
+        # assert self.cti_schema_path.is_file(), "The schema does not exist: " + str(self.cti_schema_path)
+        #
+        # self.cti_schema_rules_path = pathlib.Path(self.schema_path).joinpath("stix/schema/cti-rules.tql")
+        # assert self.cti_schema_rules_path.is_file(), "The schema does not exist: " + str(self.cti_schema_rules_path)
+
+    def __assign_import_type(self):
+        if self.import_type is None:
+            self.import_type = import_type_factory.get_default_import()
+
+    @property
+    def stix_connection(self):
+        return self._stix_connection
+
+    def clear_db(self):
+
+        result = delete_database(self.uri, self.port, self.database)
+        logger.debug("Successfully cleared database")
+
+
+    def __filter_markings(self, stix_ids: List[StringAttribute]) -> List[str]:
+        marking = ["marking-definition--613f2e26-407d-48c7-9eca-b8e91df99dc9",
+                   "marking-definition--34098fce-860f-48ae-8e50-ebd3cc5e41da",
+                   "marking-definition--f88d31f6-486f-44da-b317-01333bde0b82",
+                   "marking-definition--5e57c739-391a-4eb3-b6be-7d15ca92d5ed"]
+
+        filtered_list = list(filter(lambda x: x.get_value() not in marking, stix_ids))
+        return self.__string_attibute_to_string(filtered_list)
+
+    def __string_attibute_to_string(self,
+                                    string_attributes: List[StringAttribute]):
+        return [stix_id.get_value() for stix_id in string_attributes]
+
+    def __query_stix_ids(self):
+        get_ids_tql = 'match $ids isa stix-id;'
+        data_query = query_ids
+        query_data = match_query(self.uri,
+                                 self.port,
+                                 self.database,
+                                 get_ids_tql,
+                                 data_query)
+
+        return query_data
+
+
+    def get_stix_ids(self):
+        """ Get all the stix-ids in a database, should be moved to DataSource object
+
+        Returns:
+            id_list : list of the stix-ids in the database
+        """
+        stix_ids_query = self.__query_stix_ids()
+
+        result = self.__filter_markings(stix_ids_query)
+        return result
+
+
+    def __retrieve_stix_id(self,
+                           stix_id: str):
+        type_db_source = self.__get_source_client()
+        return type_db_source.get(stix_id)
+
+
+    def __delete_instruction(self,
+                             stixid: str):
+
+        stix_obj = self.__retrieve_stix_id(stixid)
+
+        dep_match, dep_insert, indep_ql, core_ql, dep_obj = raw_stix2_to_typeql(stix_obj, self.import_type)
+        del_match, del_tql = delete_stix_object(stix_obj, dep_match, dep_insert, indep_ql, core_ql, self.import_type)
+        dep_obj["delete"] = del_match + '\n' + del_tql
+
+        log_delete_instruction(del_match, dep_insert, indep_ql, dep_obj, del_match, del_tql)
+        if del_match == '' and del_tql == '':
+            return None
+        else:
+            return dep_obj
+
+
+    def __update_delete_layers(self,
+                               layers,
+                               indexes,
+                               missing,
+                               dep_obj):
+        if dep_obj is None:
+            return layers, indexes, missing
+        if len(layers) == 0:
+            missing = dep_obj['dep_list']
+            indexes.append(dep_obj['id'])
+            layers.append(dep_obj)
+        else:
+            layers, indexes, missing = add_delete_layers(layers, dep_obj, indexes, missing)
+        return layers, indexes, missing
+
+
+    def __retrieve_delete_instructions(self,
+                                       stixids: List[str]) -> Instructions:
+
+        layers = []
+        indexes = []
+        missing = []
+
+        instructions = Instructions()
+
+        for stixid in stixids:
+            del_result = self.__delete_instruction(stixid)
+            layers, indexes, missing = self.__update_delete_layers(layers, indexes, missing, del_result)
+
+        for layer in layers:
+            instructions.insert_delete_instruction(layer['id'], layer)
+        return instructions
+
+
+    def __order_delete_instructions(self,
+                                    delete_instructions: Instructions):
+        layer = {}
+        layer['delete'] = 'match $a isa attribute; not { $b isa thing; $b has $a;}; delete $a isa attribute;'
+        delete_instructions.insert_delete_instruction(
+            "cleanup-1", layer
+        )
+        delete_instructions.insert_delete_instruction(
+            "cleanup-2", layer
+        )
+        return delete_instructions
+
+    def delete(self, stixid_list: List[str]) -> Instructions:
+        """ Delete a list of STIX objects from the typedb_lib server. Must include all related objects and relations
+
+        Args:
+            stixid_list (): The list of Stix-id's of the object's to delete
+        """
+
+        delete_instruction_result = self.__retrieve_delete_instructions(stixid_list)
+        order_instruction_result = self.__order_delete_instructions(delete_instruction_result)
+        delete_from_database_result = delete_layers(self.uri,
+                                                    self.port,
+                                                    self.database,
+                                                    order_instruction_result)
+
+        instructions = delete_from_database_result
+
+        return instructions.convert_to_result()
+
+
+
+    def __get_core_client(self) -> TypeDBClient:
+        typedb_url = self.uri + ":" + self.port
+        return TypeDB.core_client(typedb_url)
+
+
+    def __get_source_client(self):
+        connection = {'uri': self.uri,
+                      'port': self.port,
+                      'database': self.database,
+                      'user': self.user,
+                      'password': self.password}
+
+        return TypeDBSource(connection, self.import_type)
+
+
+
+
+    def __generate_typeql_object(self, stix_dict: dict) -> TypeQLObject:
+
+        logger.debug(f"\n================================================================\nim about to parse \n")
+        stix_obj = parse(stix_dict, False, self.import_type)
+        logger.debug(f'\n-------------------------------------------------------------\n i have parsed\n')
+        dep_match, dep_insert, indep_ql, core_ql, dep_obj = raw_stix2_to_typeql(stix_obj, self.import_type)
+        logger.debug(f'\ndep_match {dep_match} \ndep_insert {dep_insert} \nindep_ql {indep_ql} \ncore_ql {core_ql}')
+        typeql_obj = TypeQLObject(
+            dep_match=dep_match,
+            dep_insert=dep_insert,
+            indep_ql=indep_ql,
+            core_ql=core_ql,
+            dep_list=dep_obj.get('dep_list', [])
+        )
+
+        return typeql_obj
+
+
+    def __generate_instructions(self,
+                                obj_list) -> Instructions:
+        instructions = Instructions()
+        for stix_dict in obj_list:
+            try:
+                typeql_object_result = self.__generate_typeql_object(stix_dict)
+
+                typeql_object: TypeQLObject = typeql_object_result
+                instructions.insert_add_instruction(stix_dict['id'], typeql_object)
+            except Exception as e:
+                logging.exception(e)
+                logging.info("Error generating instructions for " + stix_dict['id'])
+                instructions.insert_add_instruction(stix_dict['id'], None)
+                traceback_str = traceback.format_exc()
+                instructions.update_instruction_as_error(stix_dict['id'], traceback_str)
+
+
+        return instructions
+
+
+    def __create_instruction_dependency_graph(self,
+                                              instructions: Instructions):
+        directed_graph = nx.DiGraph()
+        instruction: AddInstruction
+        for instruction in instructions.instructions.values():
+            try:
+                if instruction.status in [Status.ERROR]:
+                    logging.debug("Skipping error " + instruction.id)
+                    continue
+
+                dependencies = instruction.typeql_obj.dep_list
+
+                this_node = instruction.id
+                if not directed_graph.has_node(this_node):
+                    # logging.info("Already has node id " + this_node)
+                    # logging.info("Inserting dependency node " + this_node)
+                    directed_graph.add_node(this_node)
+
+                for dependency_node in dependencies:
+                    if not directed_graph.has_node(dependency_node):
+                       # logging.info("Already has dependency node id " + this_node)
+
+                       # logging.info("Dependency node does not exist id " + this_node)
+                        directed_graph.add_node(this_node)
+                    directed_graph.add_edge(dependency_node, this_node)
+                instructions.add_dependencies(directed_graph)
+            except Exception as e:
+                logging.error("Error creating dependency graph for " + instruction.id)
+                logging.error(e)
+                traceback_str = traceback.format_exc()
+                instructions.update_instruction_as_error(instruction.id, traceback_str)
+
+        return instructions
+
+
+
+    def __generate_queries(self,
+                           instructions: Instructions):
+        result = instructions.create_insert_queries(build_insert_query)
+        return result
+
+
+    def __check_missing_dependencies(self,
+                                     instructions: Instructions):
+        missing_ids_from_tree = instructions.missing_dependency_ids()
+
+        result = []
+        for missing_ids in missing_ids_from_tree[:500]:
+            query_result = build_match_id_query(missing_ids)
+
+            data_result = match_query(uri=self.uri,
+                                      port=self.port,
+                                      database=self.database,
+                                      query=query_result,
+                                      data_query=query_id,
+                                      import_type=None)
+            result = result + data_result
+
+
+        missing_ids_found_in_db = result
+        # ids with no record in db and in dependency tree
+        ids_missing = list(set(missing_ids_from_tree) - set(missing_ids_found_in_db))
+        instructions.register_missing_dependencies(ids_missing)
+
+        return instructions
+
+
+
+    def __reorder_instructions(self,
+                               instructions: Instructions):
+        try:
+            order = list(nx.topological_sort(instructions.dependencies))
+            instructions.add_insertion_order(order)
+        except Exception as e:
+            logging.exception(e)
+        return instructions
+
+
+
+
+    def add(self, stix_data: Optional[List[dict]] = None) -> List[Result]:
+        """Add STIX objects to the typedb_lib server.
+            1. Gather objects into a list
+            2. For each object
+                a. get raw stix to tql
+                b. add object to an ordered list
+                c. return the ordered list
+            3. Add each object in the ordered list
+        Args:
+            stix_data (STIX object OR Bundle OR dict OR list): valid STIX 2.1 content
+                in a STIX object (or list of), dict (or list of), or a STIX 2.1
+                json encoded string.
+            import_type (dict): It forces the parser to use either the stix2.1,
+                or the mitre attack typeql description. Values can be either:
+                        - "STIX21"
+                        - "mitre"
+        Note:
+            ``stix_data`` can be a Bundle object, but each object in it will be
+            saved separately; you will be able to retrieve any of the objects
+            the Bundle contained, but not the Bundle itself.
+        """
+        logger.debug("1. starting in add")
+        obj_result = self._gather_objects(stix_data)
+
+        generate_instructions_result = self.__generate_instructions(obj_result)
+        logger.info("\n##########################################################################################################################################################\n")
+        #logger.info(f"generate instructions is {generate_instructions_result}")
+        instruction_dependency_graph_result =  self.__create_instruction_dependency_graph(generate_instructions_result)
+        check_missing_dependency_result = self.__check_missing_dependencies(instruction_dependency_graph_result)
+
+        instructions: Instructions = check_missing_dependency_result
+        if instructions.exist_missing_dependencies():
+            return instructions.convert_to_result()
+        if instructions.exist_cyclical_ids():
+            instructions.register_cyclical_dependencies()
+            return instructions.convert_to_result()
+
+        reorder_result = self.__reorder_instructions(instructions)
+
+        queries_result = self.__generate_queries(reorder_result)
+
+        add_to_database_result = add_instructions_to_typedb(self.uri,
+                                                            self.port,
+                                                            self.database,
+                                                            reorder_result)
+
+        instructions = add_to_database_result
+
+        return instructions.convert_to_result()
+
+
+
+    def _gather_objects(self, stix_data):
+        """
+          the details for the add details, checking what import_type of data object it is
+        """
+        #logger.debug(f" gethering ...{stix_data}")
+        #logger.debug('----------------------------------------')
+        #logger.debug(f'going into separate objects function {stix_data}')
+        #logger.debug('-----------------------------------------------------')
+
+        if isinstance(stix_data, (v21.Bundle)):
+            logger.debug(f'isinstance Bundle')
+            # recursively add individual STIX objects
+            logger.debug(f'obects are {stix_data["objects"]}')
+            return stix_data.get("objects", [])
+
+
+        elif isinstance(stix_data, _STIXBase):
+            logger.debug("base")
+            logger.debug(f'isinstance _STIXBase')
+            temp_list = []
+            temp_list.append(stix_data)
+            return temp_list
+
+        elif isinstance(stix_data, (str, dict)):
+            if stix_data.get("type", '') == 'bundle':
+                return stix_data.get("objects", [])
+            else:
+                logger.debug("dcit")
+                logger.debug(f'isinstance dict')
+                temp_list = []
+                temp_list.append(stix_data)
+                return temp_list
+
+        elif isinstance(stix_data, list):
+            item_list = []
+            for item in stix_data:
+                if item.get("type", '') == 'bundle':
+                    item_list = item_list + item.get("objects", [])
+                else:
+                    item_list.append(item)
+
+            logger.debug(f'isinstance list')
+            # recursively add individual STIX objects
+            return item_list
+
+        else:
+            raise TypeError(
+                "stix_data must be a STIX object (or list of), "
+                "JSON formatted STIX (or list of), "
+                "or a JSON formatted STIX bundle",
+            )
+
+
+class TypeDBSource(DataSource):
+    """Interface for searching/retrieving STIX objects from a TypeDB Database.
+
+    Can be paired with a TypeDBSink, together as the two
+    components of a TypeDBStore.
+
+    Args:
+        - connection is a dict, containing:
+            - uri (str): URI to TypeDB.
+            - port (int): Port to TypeDB.
+            - db (str): Name of TypeDB database.
+            - user (str): Username for TypeDB, if cluster, otherwise None
+            - password (str): Password for TypeDB, if cluster, otherwise None
+        - import_type (str): It forces the parser to use either the stix2.1, or mitre att&ck
+
+    """
+
+    def __init__(self, connection: Dict[str, str], import_type: Optional[ImportType]=None, **kwargs):
+        super(TypeDBSource, self).__init__()
+        logger.debug(f'TypeDBSource: {connection}')
+
+        assert connection["uri"] is not None
+        assert connection["port"] is not None
+        assert connection["database"] is not None
+        assert import_type is None or isinstance(import_type, ImportType)
+
+        self._stix_connection = connection
+        self.uri = connection["uri"]
+        self.port = connection["port"]
+        self.database = connection["database"]
+        self.user = connection["user"]
+        self.password = connection["password"]
+        self.import_type: ImportType = self.__default_import_type() if import_type is None else import_type
+
+    def __default_import_type(self):
+        return ImportTypeFactory.get_default_import()
+
+    @property
+    def stix_connection(self):
+        return self._stix_connection
+
+
+    def __retrieve_stix_object(self,
+                               stix_id: str):
+        logger.debug(f'__retrieve_stix_object: {stix_id}')
+        obj_var, type_ql = get_embedded_match(stix_id, self.import_type)
+        query = 'match ' + type_ql
+        logger.debug(f'query is {query}')
+
+        data = match_query(uri=self.uri,
+                           port=self.port,
+                           database=self.database,
+                           query=query,
+                           data_query=convert_ans_to_stix,
+                           import_type=self.import_type)
+
+        logger.debug(f'data is -> {data}')
+        stix_obj = parse(data=data, allow_custom=False, import_type=self.import_type)
+
+        # result = write_to_file("stixorm/module/orm/export_final.json", stix_obj)
+        # if not is_successful(result):
+        #     logging.exception("\n".join(traceback.format_exception(result.failure())))
+        #     logger.error(str(result.failure()))
+
+        return stix_obj
+
+    def get(self, stix_id: str, _composite_filters=None):
+        """Retrieve STIX object from file directory via STIX ID.
+
+        Args:
+            stix_id (str): The STIX ID of the STIX object to be retrieved.
+            _composite_filters (FilterSet): collection of filters passed from the parent
+                CompositeDataSource, not user supplied
+
+        Returns:
+            (STIX object): STIX object that has the supplied STIX ID.
+                The STIX object is loaded from its json file, parsed into
+                a python STIX object and then returned
+
+        """
+
+        result = self.__retrieve_stix_object(stix_id)
+        return result
+
+    def query(self, query=None, version=None, _composite_filters=None):
+        """Search and retrieve STIX objects based on the complete query.
+
+        A "complete query" includes the filters from the query, the filters
+        attached to this FileSystemSource, and any filters passed from a
+        CompositeDataSource (i.e. _composite_filters).
+
+        Args:
+            query (list): list of filters to search on
+            _composite_filters (FilterSet): collection of filters passed from
+                the CompositeDataSource, not user supplied
+            version (str): If present, it forces the parser to use the version
+                provided. Otherwise, the library will make the best effort based
+                on checking the "spec_version" property.
+
+        Returns:
+            (list): list of STIX objects that matches the supplied
+                query. The STIX objects are loaded from their json files,
+                parsed into a python STIX objects and then returned.
+
+        """
+        pass
+
+    def all_versions(self, stix_id, version=None, _composite_filters=None):
+        """Retrieve STIX object from file directory via STIX ID, all versions.
+
+        Note: Since FileSystem sources/sinks don't handle multiple versions
+        of a STIX object, this operation is unnecessary. Pass call to get().
+
+        Args:
+            stix_id (str): The STIX ID of the STIX objects to be retrieved.
+            _composite_filters (FilterSet): collection of filters passed from
+                the parent CompositeDataSource, not user supplied
+            version (str): If present, it forces the parser to use the version
+                provided. Otherwise, the library will make the best effort based
+                on checking the "spec_version" property.
+
+        Returns:
+            (list): of STIX objects that has the supplied STIX ID.
+                The STIX objects are loaded from their json files, parsed into
+                a python STIX objects and then returned
+
+        """
+        pass
+
+
+
+def get_embedded_match(source_id, import_type):
+    """
+        Assemble the typeql variable and match statement given the stix-id, and the increment
+    Args:
+        source_id (): stix-id to use
+        i (): number of times this type of object has been used
+    Returns:
+        source_var, the typeql string of the variable
+        match, the typeql match statement
+    """
+    source_type = get_source_type(source_id, import_type)
+    source_var = '$' + source_type
+    if source_type == 'relationship':
+        source_type = 'stix-core-relationship'
+    match = f' {source_var} isa {source_type}, has stix-id "{source_id}";\n'
+    return source_var, match
+
+def get_source_type(source_id, import_type):
+    """
+        Get the type of the source_id
+    Args:
+        source_id (): stix-id to use
+    Returns:
+        source_type, the type of the source_id
+    """
+    auth_factory = get_auth_factory_instance()
+    auth = auth_factory.get_auth_for_import(import_type)
+    tmp_source = source_id.split('--')[0]
+    source = ""
+    for model in auth["conv"]["sdo"]:
+        if model["type"] == tmp_source:
+            source = model["typeql"]
+            return source
+    for model in auth["conv"]["sro"]:
+        if model["type"] == tmp_source:
+            source = model["typeql"]
+            return source
+    for model in auth["conv"]["sco"]:
+        if model["type"] == tmp_source:
+            source = model["typeql"]
+            return source
+    for model in auth["conv"]["meta"]:
+        if model["type"] == tmp_source:
+            source = model["typeql"]
+            return source
+    return source
```

### Comparing `stixorm-0.1.3/stixorm/module/typedb_lib/factories/auth_factory.py` & `stixorm-0.1.9/stixorm/module/typedb_lib/factories/auth_factory.py`

 * *Ordering differences only*

 * *Files 8% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-import functools
-import hashlib
-
-from stixorm.module.authorise import authorised_mappings
-from stixorm.module.typedb_lib.factories.import_type_factory import ImportType
-
-
-class AuthFactory:
-
-    def __init__(self):
-        self.auths_by_import_type = {}
-
-
-    def get_auth_for_import(self,
-                            import_type: ImportType):
-        json_string = import_type.json()
-        hashed_string = hashlib.sha256(json_string.encode()).hexdigest()
-        if hashed_string in self.auths_by_import_type.keys():
-            return self.auths_by_import_type[hashed_string]
-        else:
-            authorised_mapping = authorised_mappings(import_type)
-            self.auths_by_import_type[hashed_string] = authorised_mapping
-            return authorised_mapping
-
-@functools.lru_cache(maxsize=None)
-def get_auth_factory_instance() -> AuthFactory:
+import functools
+import hashlib
+
+from stixorm.module.authorise import authorised_mappings
+from stixorm.module.typedb_lib.factories.import_type_factory import ImportType
+
+
+class AuthFactory:
+
+    def __init__(self):
+        self.auths_by_import_type = {}
+
+
+    def get_auth_for_import(self,
+                            import_type: ImportType):
+        json_string = import_type.json()
+        hashed_string = hashlib.sha256(json_string.encode()).hexdigest()
+        if hashed_string in self.auths_by_import_type.keys():
+            return self.auths_by_import_type[hashed_string]
+        else:
+            authorised_mapping = authorised_mappings(import_type)
+            self.auths_by_import_type[hashed_string] = authorised_mapping
+            return authorised_mapping
+
+@functools.lru_cache(maxsize=None)
+def get_auth_factory_instance() -> AuthFactory:
     return AuthFactory()
```

### Comparing `stixorm-0.1.3/stixorm/module/typedb_lib/factories/auth_type_factory.py` & `stixorm-0.1.9/stixorm/module/typedb_lib/factories/auth_type_factory.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,23 +1,23 @@
-from stixorm.module.typedb_lib.factories.definition_factory import get_definition_factory_instance
-from stixorm.module.typedb_lib.model.definitions import DefinitionName
-
-stix_models = get_definition_factory_instance().lookup_definition(DefinitionName.STIX_21)
-attack_models = get_definition_factory_instance().lookup_definition(DefinitionName.ATTACK)
-os_threat_models = get_definition_factory_instance().lookup_definition(DefinitionName.OS_THREAT)
-cacao_models = get_definition_factory_instance().lookup_definition(DefinitionName.CACAO)
-kestrel_models = get_definition_factory_instance().lookup_definition(DefinitionName.KESTREL)
-us_dod_models = get_definition_factory_instance().lookup_definition(DefinitionName.US_DoD)
-
-class AuthTypeFactory:
-
-
-    def __init__(self):
-        self.auth_types = {}
-        self.auth_types["stix"] = stix_models
-        self.auth_types["attack"] = attack_models
-        self.auth_types["os_threat"] = os_threat_models
-        self.auth_types["cacao"] = cacao_models
-        self.auth_types["kestrel"] = kestrel_models
-        self.auth_types["us_dod"] = us_dod_models
-
-
+from stixorm.module.typedb_lib.factories.definition_factory import get_definition_factory_instance
+from stixorm.module.typedb_lib.model.definitions import DefinitionName
+
+stix_models = get_definition_factory_instance().lookup_definition(DefinitionName.STIX_21)
+attack_models = get_definition_factory_instance().lookup_definition(DefinitionName.ATTACK)
+os_threat_models = get_definition_factory_instance().lookup_definition(DefinitionName.OS_THREAT)
+cacao_models = get_definition_factory_instance().lookup_definition(DefinitionName.CACAO)
+kestrel_models = get_definition_factory_instance().lookup_definition(DefinitionName.KESTREL)
+us_dod_models = get_definition_factory_instance().lookup_definition(DefinitionName.US_DoD)
+
+class AuthTypeFactory:
+
+
+    def __init__(self):
+        self.auth_types = {}
+        self.auth_types["stix"] = stix_models
+        self.auth_types["attack"] = attack_models
+        self.auth_types["os_threat"] = os_threat_models
+        self.auth_types["cacao"] = cacao_models
+        self.auth_types["kestrel"] = kestrel_models
+        self.auth_types["us_dod"] = us_dod_models
+
+
```

### Comparing `stixorm-0.1.3/stixorm/module/typedb_lib/factories/import_type_factory.py` & `stixorm-0.1.9/stixorm/module/typedb_lib/factories/import_type_factory.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,145 +1,145 @@
-from enum import Enum
-from typing import List
-
-from pydantic import BaseModel
-
-class AttackVersions(Enum):
-    V12_1 = "12.1"
-
-class AttackDomains(Enum):
-    ENTERPRISE_ATTACK = "enterprise-attack"
-    MOBILE_ATTACK = "mobile-attack"
-    ICS_ATTACK = "ics-attack"
-
-class ImportType(BaseModel):
-    STIX21: bool
-    CVE: bool
-    identity: bool
-    location: bool
-    os_threat: bool
-    kestrel: bool
-    rules: bool
-    ATTACK: bool
-    ATTACK_Versions: List[AttackVersions]
-    ATTACK_Domains: List[AttackDomains]
-    CACAO: bool
-    US_DoD: bool
-
-
-
-class ImportTypeFactory:
-
-    @staticmethod
-    def get_import_type_factory():
-        return ImportTypeFactory()
-
-    @staticmethod
-    def create_import(stix_21=False,
-                      attack=False,
-                      cve=False,
-                      identity=False,
-                      location=False,
-                      os_threat=False,
-                      kestrel=False,
-                      rules=False,
-                      us_dod=False,
-                      attack_versions=[],
-                      attack_domains=[],
-                      cacao=False):
-        if os_threat and (not stix_21 or not attack):
-            raise ValueError("os_threat requires stix_21 and attack")
-
-        return ImportType(
-            STIX21=stix_21,
-            CVE=cve,
-            identity=identity,
-            location=location,
-            os_threat=os_threat,
-            kestrel=kestrel,
-            rules=rules,
-            ATTACK=attack,
-            ATTACK_Versions=attack_versions,
-            ATTACK_Domains=attack_domains,
-            CACAO=cacao,
-            US_DoD=us_dod,
-        )
-
-    @staticmethod
-    def get_attack_import():
-        return ImportType(
-            STIX21=True,
-            CVE=False,
-            identity=False,
-            location=False,
-            os_threat=False,
-            kestrel=False,
-            rules=False,
-            ATTACK=True,
-            ATTACK_Versions=[AttackVersions.V12_1],
-            ATTACK_Domains=[AttackDomains.ENTERPRISE_ATTACK, AttackDomains.ICS_ATTACK, AttackDomains.MOBILE_ATTACK],
-            CACAO=False,
-            US_DoD=False
-        )
-
-    @staticmethod
-    def get_all_imports():
-        return ImportType(
-            STIX21=True,
-            CVE=True,
-            identity=True,
-            location=True,
-            os_threat=True,
-            kestrel=True,
-            rules=True,
-            ATTACK=True,
-            ATTACK_Versions=[AttackVersions.V12_1],
-            ATTACK_Domains=[AttackDomains.ENTERPRISE_ATTACK, AttackDomains.ICS_ATTACK, AttackDomains.MOBILE_ATTACK],
-            CACAO=True,
-            US_DoD=True
-        )
-
-    @staticmethod
-    def get_default_import():
-        return ImportType(
-            STIX21 = True,
-            CVE = False,
-            identity = False,
-            location = False,
-            os_threat = False,
-            kestrel = False,
-            rules = False,
-            ATTACK = False,
-            ATTACK_Versions = [AttackVersions.V12_1],
-            ATTACK_Domains = [AttackDomains.ENTERPRISE_ATTACK, AttackDomains.ICS_ATTACK, AttackDomains.MOBILE_ATTACK],
-            CACAO= False,
-            US_DoD= False
-        )
-
-    @staticmethod
-    def convert_to_dict(
-                        import_type: ImportType):
-        versions = []
-        for version in import_type.ATTACK_Versions:
-            versions.append(version.value)
-
-        domains = []
-        for domain in import_type.ATTACK_Domains:
-            domains.append(domain.value)
-
-
-        return {
-            "STIX21": import_type.STIX21,
-            "ATT&CK": import_type.ATTACK,
-            "os-threat": import_type.os_threat,
-            "kestrel": import_type.kestrel,
-            "CACAO": import_type.CACAO,
-            "US_DoD": import_type.US_DoD,
-            "CVE": import_type.CVE,
-            "identity": import_type.identity,
-            "location": import_type.location,
-            "rules": import_type.rules,
-            "ATT&CK_Versions": versions,
-            "ATT&CK_Domains": domains
-        }
-
-
+from enum import Enum
+from typing import List
+
+from pydantic import BaseModel
+
+class AttackVersions(Enum):
+    V12_1 = "12.1"
+
+class AttackDomains(Enum):
+    ENTERPRISE_ATTACK = "enterprise-attack"
+    MOBILE_ATTACK = "mobile-attack"
+    ICS_ATTACK = "ics-attack"
+
+class ImportType(BaseModel):
+    STIX21: bool
+    CVE: bool
+    identity: bool
+    location: bool
+    os_threat: bool
+    kestrel: bool
+    rules: bool
+    ATTACK: bool
+    ATTACK_Versions: List[AttackVersions]
+    ATTACK_Domains: List[AttackDomains]
+    CACAO: bool
+    US_DoD: bool
+
+
+
+class ImportTypeFactory:
+
+    @staticmethod
+    def get_import_type_factory():
+        return ImportTypeFactory()
+
+    @staticmethod
+    def create_import(stix_21=False,
+                      attack=False,
+                      cve=False,
+                      identity=False,
+                      location=False,
+                      os_threat=False,
+                      kestrel=False,
+                      rules=False,
+                      us_dod=False,
+                      attack_versions=[],
+                      attack_domains=[],
+                      cacao=False):
+        if os_threat and (not stix_21 or not attack):
+            raise ValueError("os_threat requires stix_21 and attack")
+
+        return ImportType(
+            STIX21=stix_21,
+            CVE=cve,
+            identity=identity,
+            location=location,
+            os_threat=os_threat,
+            kestrel=kestrel,
+            rules=rules,
+            ATTACK=attack,
+            ATTACK_Versions=attack_versions,
+            ATTACK_Domains=attack_domains,
+            CACAO=cacao,
+            US_DoD=us_dod,
+        )
+
+    @staticmethod
+    def get_attack_import():
+        return ImportType(
+            STIX21=True,
+            CVE=False,
+            identity=False,
+            location=False,
+            os_threat=False,
+            kestrel=False,
+            rules=False,
+            ATTACK=True,
+            ATTACK_Versions=[AttackVersions.V12_1],
+            ATTACK_Domains=[AttackDomains.ENTERPRISE_ATTACK, AttackDomains.ICS_ATTACK, AttackDomains.MOBILE_ATTACK],
+            CACAO=False,
+            US_DoD=False
+        )
+
+    @staticmethod
+    def get_all_imports():
+        return ImportType(
+            STIX21=True,
+            CVE=True,
+            identity=True,
+            location=True,
+            os_threat=True,
+            kestrel=True,
+            rules=True,
+            ATTACK=True,
+            ATTACK_Versions=[AttackVersions.V12_1],
+            ATTACK_Domains=[AttackDomains.ENTERPRISE_ATTACK, AttackDomains.ICS_ATTACK, AttackDomains.MOBILE_ATTACK],
+            CACAO=True,
+            US_DoD=True
+        )
+
+    @staticmethod
+    def get_default_import():
+        return ImportType(
+            STIX21 = True,
+            CVE = False,
+            identity = False,
+            location = False,
+            os_threat = False,
+            kestrel = False,
+            rules = False,
+            ATTACK = False,
+            ATTACK_Versions = [AttackVersions.V12_1],
+            ATTACK_Domains = [AttackDomains.ENTERPRISE_ATTACK, AttackDomains.ICS_ATTACK, AttackDomains.MOBILE_ATTACK],
+            CACAO= False,
+            US_DoD= False
+        )
+
+    @staticmethod
+    def convert_to_dict(
+                        import_type: ImportType):
+        versions = []
+        for version in import_type.ATTACK_Versions:
+            versions.append(version.value)
+
+        domains = []
+        for domain in import_type.ATTACK_Domains:
+            domains.append(domain.value)
+
+
+        return {
+            "STIX21": import_type.STIX21,
+            "ATT&CK": import_type.ATTACK,
+            "os-threat": import_type.os_threat,
+            "kestrel": import_type.kestrel,
+            "CACAO": import_type.CACAO,
+            "US_DoD": import_type.US_DoD,
+            "CVE": import_type.CVE,
+            "identity": import_type.identity,
+            "location": import_type.location,
+            "rules": import_type.rules,
+            "ATT&CK_Versions": versions,
+            "ATT&CK_Domains": domains
+        }
+
+
```

### Comparing `stixorm-0.1.3/stixorm/module/typedb_lib/factories/mappings_factory.py` & `stixorm-0.1.9/stixorm/module/typedb_lib/factories/mappings_factory.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,100 +1,100 @@
-import json
-import os
-import pathlib
-from typing import Dict, List
-import functools
-
-from stixorm.module.typedb_lib.model.definitions import ObjectKeys
-
-@functools.lru_cache(maxsize=None)
-def get_mapping_factory_instance():
-    return MappingsFactory()
-
-class MappingsDefinition():
-
-    def __init__(self,
-                 name,
-                 path):
-        self.definition_name = name
-        self.definition_path = path
-
-        self.mapping = self.__load_mappings()
-
-    def is_json_file(self, filepath):
-        _, file_extension = os.path.splitext(filepath)
-        return file_extension.lower() == ".json"
-
-    def __load_definition(self,
-                          directory_path: str) -> dict:
-        if not os.path.isdir(directory_path):
-            return {}
-
-        definitions = {}
-
-        # Iterate over every file in the directory
-        for filename in os.listdir(directory_path):
-            filepath = os.path.join(directory_path, filename)
-            if os.path.isfile(filepath) and self.is_json_file(filepath):
-                # Do something with the file, for example, print its contents
-                file_name, file_ext = os.path.splitext(filename)
-                with open(filepath, 'r') as file:
-                    definitions[file_name] = json.load(file)
-        return definitions
-
-    def __load_mappings(self) -> dict:
-
-        # Define the directory path
-        directory_path = str(self.definition_path.joinpath("mappings"))
-
-        return self.__load_definition(directory_path)
-
-    def get_mappings(self) -> dict:
-        return self.mapping
-
-    def get_object_conversion(self) -> list:
-        return self.mapping.get("object_conversion", [])
-class MappingsFactory():
-
-    def __init__(self):
-        self.definition_dir = pathlib.Path(__file__).parents[2].joinpath('definitions')
-
-        self.definitions: Dict[str, MappingsDefinition] = {}
-
-        subfolder_names = self.get_subfolder_names(self.definition_dir)
-
-        for name in subfolder_names:
-            self.definitions[name] = MappingsDefinition(name, self.definition_dir.joinpath(name))
-
-    def all_object_keys(self) -> set[ObjectKeys]:
-        return set(list(ObjectKeys))
-
-    def all_object_keys_as_string(self) -> set[str]:
-        return set([key.value for key in self.all_object_keys()])
-
-    def get_all_types(self) -> List[str]:
-        types = []
-        for mapping in self.definitions.values():
-            for object_conversion in mapping.get_object_conversion():
-                if "type" in object_conversion and object_conversion["object"] in self.all_object_keys_as_string():
-                    types.append(object_conversion["type"])
-        return list(set(types))
-
-
-    def get_subfolder_names(self, folder_path):
-        subfolder_names = []
-        for item in os.listdir(folder_path):
-            item_path = os.path.join(folder_path, item)
-            if os.path.isdir(item_path):
-                subfolder_names.append(item)
-        return subfolder_names
-
-    def get_mapping_definition(self,
-                               name):
-        if name in self.definitions.keys():
-            return self.definitions.get(name)
-        raise Exception(f"Mapping definition {name} not found")
-
-
-    def get_mappings_from_definition(self,
-                                     name):
+import json
+import os
+import pathlib
+from typing import Dict, List
+import functools
+
+from stixorm.module.typedb_lib.model.definitions import ObjectKeys
+
+@functools.lru_cache(maxsize=None)
+def get_mapping_factory_instance():
+    return MappingsFactory()
+
+class MappingsDefinition():
+
+    def __init__(self,
+                 name,
+                 path):
+        self.definition_name = name
+        self.definition_path = path
+
+        self.mapping = self.__load_mappings()
+
+    def is_json_file(self, filepath):
+        _, file_extension = os.path.splitext(filepath)
+        return file_extension.lower() == ".json"
+
+    def __load_definition(self,
+                          directory_path: str) -> dict:
+        if not os.path.isdir(directory_path):
+            return {}
+
+        definitions = {}
+
+        # Iterate over every file in the directory
+        for filename in os.listdir(directory_path):
+            filepath = os.path.join(directory_path, filename)
+            if os.path.isfile(filepath) and self.is_json_file(filepath):
+                # Do something with the file, for example, print its contents
+                file_name, file_ext = os.path.splitext(filename)
+                with open(filepath, 'r') as file:
+                    definitions[file_name] = json.load(file)
+        return definitions
+
+    def __load_mappings(self) -> dict:
+
+        # Define the directory path
+        directory_path = str(self.definition_path.joinpath("mappings"))
+
+        return self.__load_definition(directory_path)
+
+    def get_mappings(self) -> dict:
+        return self.mapping
+
+    def get_object_conversion(self) -> list:
+        return self.mapping.get("object_conversion", [])
+class MappingsFactory():
+
+    def __init__(self):
+        self.definition_dir = pathlib.Path(__file__).parents[2].joinpath('definitions')
+
+        self.definitions: Dict[str, MappingsDefinition] = {}
+
+        subfolder_names = self.get_subfolder_names(self.definition_dir)
+
+        for name in subfolder_names:
+            self.definitions[name] = MappingsDefinition(name, self.definition_dir.joinpath(name))
+
+    def all_object_keys(self) -> set[ObjectKeys]:
+        return set(list(ObjectKeys))
+
+    def all_object_keys_as_string(self) -> set[str]:
+        return set([key.value for key in self.all_object_keys()])
+
+    def get_all_types(self) -> List[str]:
+        types = []
+        for mapping in self.definitions.values():
+            for object_conversion in mapping.get_object_conversion():
+                if "type" in object_conversion and object_conversion["object"] in self.all_object_keys_as_string():
+                    types.append(object_conversion["type"])
+        return list(set(types))
+
+
+    def get_subfolder_names(self, folder_path):
+        subfolder_names = []
+        for item in os.listdir(folder_path):
+            item_path = os.path.join(folder_path, item)
+            if os.path.isdir(item_path):
+                subfolder_names.append(item)
+        return subfolder_names
+
+    def get_mapping_definition(self,
+                               name):
+        if name in self.definitions.keys():
+            return self.definitions.get(name)
+        raise Exception(f"Mapping definition {name} not found")
+
+
+    def get_mappings_from_definition(self,
+                                     name):
         return self.get_mapping_definition(name).get_mappings()
```

### Comparing `stixorm-0.1.3/stixorm/module/typedb_lib/factories/process_map.json` & `stixorm-0.1.9/stixorm/module/typedb_lib/factories/process_map.json`

 * *Format-specific differences are supported for JSON files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: JSON text data*

 * *Files 15% similar despite different names*

```diff
@@ -1,134 +1,136 @@
-00000000: 5b7b 0a20 2020 2022 6e61 6d65 223a 2022  [{.    "name": "
-00000010: 7265 6c6e 5f6e 616d 6522 2c0a 2020 2020  reln_name",.    
-00000020: 226b 6579 7322 3a20 5b22 656d 6265 6464  "keys": ["embedd
-00000030: 6564 5f72 656c 6174 696f 6e73 222c 2022  ed_relations", "
-00000040: 7374 616e 6461 7264 5f72 656c 6174 696f  standard_relatio
-00000050: 6e73 222c 2022 6c69 7374 5f6f 665f 6f62  ns", "list_of_ob
-00000060: 6a65 6374 7322 2c20 226b 6579 5f76 616c  jects", "key_val
-00000070: 7565 5f72 656c 6174 696f 6e73 222c 2022  ue_relations", "
-00000080: 6578 7465 6e73 696f 6e5f 7265 6c61 7469  extension_relati
-00000090: 6f6e 7322 2c20 2272 656c 6174 696f 6e73  ons", "relations
-000000a0: 5f73 726f 5f72 6f6c 6573 225d 2c0a 2020  _sro_roles"],.  
-000000b0: 2020 226d 6174 6368 223a 5b22 7265 6c61    "match":["rela
-000000c0: 7469 6f6e 735f 656d 6265 6464 6564 222c  tions_embedded",
-000000d0: 2022 7265 6c61 7469 6f6e 735f 7372 6f5f   "relations_sro_
-000000e0: 726f 6c65 7322 2c20 2272 656c 6174 696f  roles", "relatio
-000000f0: 6e73 5f6c 6973 745f 6f66 5f6f 626a 6563  ns_list_of_objec
-00000100: 7473 222c 2022 7265 6c61 7469 6f6e 735f  ts", "relations_
-00000110: 6b65 795f 7661 6c75 6522 2c20 2272 656c  key_value", "rel
-00000120: 6174 696f 6e73 5f65 7874 656e 7369 6f6e  ations_extension
-00000130: 735f 616e 645f 6f62 6a65 6374 7322 2c20  s_and_objects", 
-00000140: 2272 656c 6174 696f 6e73 5f73 726f 5f72  "relations_sro_r
-00000150: 6f6c 6573 225d 2c0a 2020 2020 2263 6f6e  oles"],.    "con
-00000160: 6422 3a20 5b22 7265 6c22 2c20 2273 7469  d": ["rel", "sti
-00000170: 7822 2c20 226e 616d 6522 2c20 226e 616d  x", "name", "nam
-00000180: 6522 2c20 2273 7469 7822 2c20 2273 7469  e", "stix", "sti
-00000190: 7822 5d0a 7d2c 7b0a 2020 2020 226e 616d  x"].},{.    "nam
-000001a0: 6522 3a20 2272 656c 6e22 2c0a 2020 2020  e": "reln",.    
-000001b0: 226b 6579 7322 3a20 5b22 656d 6265 6464  "keys": ["embedd
-000001c0: 6564 5f72 656c 6174 696f 6e73 222c 2022  ed_relations", "
-000001d0: 7374 616e 6461 7264 5f72 656c 6174 696f  standard_relatio
-000001e0: 6e73 222c 2022 6c69 7374 5f6f 665f 6f62  ns", "list_of_ob
-000001f0: 6a65 6374 7322 2c20 226b 6579 5f76 616c  jects", "key_val
-00000200: 7565 5f72 656c 6174 696f 6e73 222c 2022  ue_relations", "
-00000210: 6578 7465 6e73 696f 6e5f 7265 6c61 7469  extension_relati
-00000220: 6f6e 7322 2c20 2272 656c 6174 696f 6e73  ons", "relations
-00000230: 5f73 726f 5f72 6f6c 6573 225d 2c0a 2020  _sro_roles"],.  
-00000240: 2020 226d 6174 6368 223a 5b22 7265 6c61    "match":["rela
-00000250: 7469 6f6e 735f 656d 6265 6464 6564 222c  tions_embedded",
-00000260: 2022 7265 6c61 7469 6f6e 735f 7372 6f5f   "relations_sro_
-00000270: 726f 6c65 7322 2c20 2272 656c 6174 696f  roles", "relatio
-00000280: 6e73 5f6c 6973 745f 6f66 5f6f 626a 6563  ns_list_of_objec
-00000290: 7473 222c 2022 7265 6c61 7469 6f6e 735f  ts", "relations_
-000002a0: 6b65 795f 7661 6c75 6522 2c20 2272 656c  key_value", "rel
-000002b0: 6174 696f 6e73 5f65 7874 656e 7369 6f6e  ations_extension
-000002c0: 735f 616e 645f 6f62 6a65 6374 7322 2c20  s_and_objects", 
-000002d0: 2272 656c 6174 696f 6e73 5f73 726f 5f72  "relations_sro_r
-000002e0: 6f6c 6573 225d 2c0a 2020 2020 2263 6f6e  oles"],.    "con
-000002f0: 6422 3a20 5b5d 0a7d 2c7b 0a20 2020 2022  d": [].},{.    "
-00000300: 6e61 6d65 223a 2022 7471 6c5f 7479 7065  name": "tql_type
-00000310: 7331 222c 0a20 2020 2022 6b65 7973 223a  s1",.    "keys":
-00000320: 205b 2265 6d62 6564 6465 645f 7265 6c61   ["embedded_rela
-00000330: 7469 6f6e 7322 2c20 2273 7461 6e64 6172  tions", "standar
-00000340: 645f 7265 6c61 7469 6f6e 7322 2c20 226c  d_relations", "l
-00000350: 6973 745f 6f66 5f6f 626a 6563 7473 222c  ist_of_objects",
-00000360: 2022 6b65 795f 7661 6c75 655f 7265 6c61   "key_value_rela
-00000370: 7469 6f6e 7322 2c20 2265 7874 656e 7369  tions", "extensi
-00000380: 6f6e 5f72 656c 6174 696f 6e73 222c 2022  on_relations", "
-00000390: 7265 6c61 7469 6f6e 735f 7372 6f5f 726f  relations_sro_ro
-000003a0: 6c65 7322 5d2c 0a20 2020 2022 6d61 7463  les"],.    "matc
-000003b0: 6822 3a5b 2272 656c 6174 696f 6e73 5f65  h":["relations_e
-000003c0: 6d62 6564 6465 6422 2c20 2272 656c 6174  mbedded", "relat
-000003d0: 696f 6e73 5f73 726f 5f72 6f6c 6573 222c  ions_sro_roles",
-000003e0: 2022 7265 6c61 7469 6f6e 735f 6c69 7374   "relations_list
-000003f0: 5f6f 665f 6f62 6a65 6374 7322 2c20 2272  _of_objects", "r
-00000400: 656c 6174 696f 6e73 5f6b 6579 5f76 616c  elations_key_val
-00000410: 7565 222c 2022 7265 6c61 7469 6f6e 735f  ue", "relations_
-00000420: 6578 7465 6e73 696f 6e73 5f61 6e64 5f6f  extensions_and_o
-00000430: 626a 6563 7473 222c 2022 7265 6c61 7469  bjects", "relati
-00000440: 6f6e 735f 7372 6f5f 726f 6c65 7322 5d2c  ons_sro_roles"],
-00000450: 0a20 2020 2022 636f 6e64 223a 205b 2274  .    "cond": ["t
-00000460: 7970 6571 6c22 2c20 2274 7970 6571 6c22  ypeql", "typeql"
-00000470: 2c20 2274 7970 6571 6c22 2c20 2274 7970  , "typeql", "typ
-00000480: 6571 6c22 2c20 2272 656c 6174 696f 6e22  eql", "relation"
-00000490: 2c20 2274 7970 6571 6c22 5d0a 7d2c 207b  , "typeql"].}, {
-000004a0: 0a20 2020 2022 6e61 6d65 223a 2022 7471  .    "name": "tq
-000004b0: 6c5f 7479 7065 7322 2c0a 2020 2020 226b  l_types",.    "k
-000004c0: 6579 7322 3a20 5b22 7364 6f22 2c20 2273  eys": ["sdo", "s
-000004d0: 726f 222c 2022 7363 6f22 2c20 2273 7562  ro", "sco", "sub
-000004e0: 222c 2022 6d65 7461 225d 2c0a 2020 2020  ", "meta"],.    
-000004f0: 226d 6174 6368 223a 5b22 6f62 6a65 6374  "match":["object
-00000500: 5f63 6f6e 7665 7273 696f 6e22 2c20 226f  _conversion", "o
-00000510: 626a 6563 745f 636f 6e76 6572 7369 6f6e  bject_conversion
-00000520: 222c 2022 6f62 6a65 6374 5f63 6f6e 7665  ", "object_conve
-00000530: 7273 696f 6e22 2c20 226f 626a 6563 745f  rsion", "object_
-00000540: 636f 6e76 6572 7369 6f6e 222c 2022 6f62  conversion", "ob
-00000550: 6a65 6374 5f63 6f6e 7665 7273 696f 6e22  ject_conversion"
-00000560: 5d2c 0a20 2020 2022 636f 6e64 223a 205b  ],.    "cond": [
-00000570: 2273 646f 222c 2022 7372 6f22 2c20 2273  "sdo", "sro", "s
-00000580: 636f 222c 2022 7375 6222 2c20 226d 6574  co", "sub", "met
-00000590: 6122 205d 0a7d 2c20 7b0a 2020 2020 226e  a" ].}, {.    "n
-000005a0: 616d 6522 3a20 2269 735f 6c69 7374 7322  ame": "is_lists"
-000005b0: 2c0a 2020 2020 226b 6579 7322 3a20 5b22  ,.    "keys": ["
-000005c0: 7364 6f22 2c20 2273 726f 222c 2022 7363  sdo", "sro", "sc
-000005d0: 6f22 2c20 2273 7562 222c 2022 6d65 7461  o", "sub", "meta
-000005e0: 225d 2c0a 2020 2020 226d 6174 6368 223a  "],.    "match":
-000005f0: 5b22 6973 5f6c 6973 745f 7364 6f22 2c20  ["is_list_sdo", 
-00000600: 2269 735f 6c69 7374 5f73 726f 222c 2022  "is_list_sro", "
-00000610: 6973 5f6c 6973 745f 7363 6f22 2c20 2269  is_list_sco", "i
-00000620: 735f 6c69 7374 5f73 7562 5f6f 626a 6563  s_list_sub_objec
-00000630: 7473 222c 2022 6973 5f6c 6973 745f 6d65  ts", "is_list_me
-00000640: 7461 225d 2c0a 2020 2020 2263 6f6e 6422  ta"],.    "cond"
-00000650: 3a20 5b22 7364 6f22 2c20 2273 726f 222c  : ["sdo", "sro",
-00000660: 2022 7363 6f22 2c20 2273 7562 222c 2022   "sco", "sub", "
-00000670: 6d65 7461 225d 0a7d 2c20 7b0a 2020 2020  meta"].}, {.    
-00000680: 226e 616d 6522 3a20 2264 6972 6563 7422  "name": "direct"
-00000690: 2c0a 2020 2020 226b 6579 7322 3a20 5b22  ,.    "keys": ["
-000006a0: 7375 625f 6f62 6a65 6374 7322 2c20 226f  sub_objects", "o
-000006b0: 626a 6563 7473 225d 2c0a 2020 2020 226d  bjects"],.    "m
-000006c0: 6174 6368 223a 5b22 7375 625f 6f62 6a65  atch":["sub_obje
-000006d0: 6374 7322 2c20 2264 6174 6122 5d2c 0a20  cts", "data"],. 
-000006e0: 2020 2022 636f 6e64 223a 205b 5d0a 7d2c     "cond": [].},
-000006f0: 207b 0a20 2020 2022 6e61 6d65 223a 2022   {.    "name": "
-00000700: 636f 6e76 222c 0a20 2020 2022 6b65 7973  conv",.    "keys
-00000710: 223a 205b 2273 646f 222c 2022 7372 6f22  ": ["sdo", "sro"
-00000720: 2c20 2273 636f 222c 2022 7375 6222 2c20  , "sco", "sub", 
-00000730: 226d 6574 6122 5d2c 0a20 2020 2022 6d61  "meta"],.    "ma
-00000740: 7463 6822 3a5b 226f 626a 6563 7422 2c20  tch":["object", 
-00000750: 226f 626a 6563 7422 2c20 226f 626a 6563  "object", "objec
-00000760: 7422 2c20 226f 626a 6563 7422 5d2c 0a20  t", "object"],. 
-00000770: 2020 2022 636f 6e64 223a 205b 2273 646f     "cond": ["sdo
-00000780: 222c 2022 7372 6f22 2c20 2273 636f 222c  ", "sro", "sco",
-00000790: 2022 7375 6222 2c20 226d 6574 6122 5d0a   "sub", "meta"].
-000007a0: 7d2c 207b 0a20 2020 2022 6e61 6d65 223a  }, {.    "name":
-000007b0: 2022 636c 6173 7365 7322 2c0a 2020 2020   "classes",.    
-000007c0: 226b 6579 7322 3a20 5b22 7364 6f22 2c20  "keys": ["sdo", 
-000007d0: 2273 726f 222c 2022 7363 6f22 2c20 2273  "sro", "sco", "s
-000007e0: 7562 222c 2022 6d65 7461 225d 2c0a 2020  ub", "meta"],.  
-000007f0: 2020 226d 6174 6368 223a 5b22 6f62 6a65    "match":["obje
-00000800: 6374 222c 2022 6f62 6a65 6374 222c 2022  ct", "object", "
-00000810: 6f62 6a65 6374 222c 2022 6f62 6a65 6374  object", "object
-00000820: 225d 2c0a 2020 2020 2263 6f6e 6422 3a20  "],.    "cond": 
-00000830: 5b22 7364 6f22 2c20 2273 726f 222c 2022  ["sdo", "sro", "
-00000840: 7363 6f22 2c20 2273 7562 222c 2022 6d65  sco", "sub", "me
-00000850: 7461 225d 0a7d 5d                        ta"].}]
+00000000: 5b7b 0d0a 2020 2020 226e 616d 6522 3a20  [{..    "name": 
+00000010: 2272 656c 6e5f 6e61 6d65 222c 0d0a 2020  "reln_name",..  
+00000020: 2020 226b 6579 7322 3a20 5b22 656d 6265    "keys": ["embe
+00000030: 6464 6564 5f72 656c 6174 696f 6e73 222c  dded_relations",
+00000040: 2022 7374 616e 6461 7264 5f72 656c 6174   "standard_relat
+00000050: 696f 6e73 222c 2022 6c69 7374 5f6f 665f  ions", "list_of_
+00000060: 6f62 6a65 6374 7322 2c20 226b 6579 5f76  objects", "key_v
+00000070: 616c 7565 5f72 656c 6174 696f 6e73 222c  alue_relations",
+00000080: 2022 6578 7465 6e73 696f 6e5f 7265 6c61   "extension_rela
+00000090: 7469 6f6e 7322 2c20 2272 656c 6174 696f  tions", "relatio
+000000a0: 6e73 5f73 726f 5f72 6f6c 6573 225d 2c0d  ns_sro_roles"],.
+000000b0: 0a20 2020 2022 6d61 7463 6822 3a5b 2272  .    "match":["r
+000000c0: 656c 6174 696f 6e73 5f65 6d62 6564 6465  elations_embedde
+000000d0: 6422 2c20 2272 656c 6174 696f 6e73 5f73  d", "relations_s
+000000e0: 726f 5f72 6f6c 6573 222c 2022 7265 6c61  ro_roles", "rela
+000000f0: 7469 6f6e 735f 6c69 7374 5f6f 665f 6f62  tions_list_of_ob
+00000100: 6a65 6374 7322 2c20 2272 656c 6174 696f  jects", "relatio
+00000110: 6e73 5f6b 6579 5f76 616c 7565 222c 2022  ns_key_value", "
+00000120: 7265 6c61 7469 6f6e 735f 6578 7465 6e73  relations_extens
+00000130: 696f 6e73 5f61 6e64 5f6f 626a 6563 7473  ions_and_objects
+00000140: 222c 2022 7265 6c61 7469 6f6e 735f 7372  ", "relations_sr
+00000150: 6f5f 726f 6c65 7322 5d2c 0d0a 2020 2020  o_roles"],..    
+00000160: 2263 6f6e 6422 3a20 5b22 7265 6c22 2c20  "cond": ["rel", 
+00000170: 2273 7469 7822 2c20 226e 616d 6522 2c20  "stix", "name", 
+00000180: 226e 616d 6522 2c20 2273 7469 7822 2c20  "name", "stix", 
+00000190: 2273 7469 7822 5d0d 0a7d 2c7b 0d0a 2020  "stix"]..},{..  
+000001a0: 2020 226e 616d 6522 3a20 2272 656c 6e22    "name": "reln"
+000001b0: 2c0d 0a20 2020 2022 6b65 7973 223a 205b  ,..    "keys": [
+000001c0: 2265 6d62 6564 6465 645f 7265 6c61 7469  "embedded_relati
+000001d0: 6f6e 7322 2c20 2273 7461 6e64 6172 645f  ons", "standard_
+000001e0: 7265 6c61 7469 6f6e 7322 2c20 226c 6973  relations", "lis
+000001f0: 745f 6f66 5f6f 626a 6563 7473 222c 2022  t_of_objects", "
+00000200: 6b65 795f 7661 6c75 655f 7265 6c61 7469  key_value_relati
+00000210: 6f6e 7322 2c20 2265 7874 656e 7369 6f6e  ons", "extension
+00000220: 5f72 656c 6174 696f 6e73 222c 2022 7265  _relations", "re
+00000230: 6c61 7469 6f6e 735f 7372 6f5f 726f 6c65  lations_sro_role
+00000240: 7322 5d2c 0d0a 2020 2020 226d 6174 6368  s"],..    "match
+00000250: 223a 5b22 7265 6c61 7469 6f6e 735f 656d  ":["relations_em
+00000260: 6265 6464 6564 222c 2022 7265 6c61 7469  bedded", "relati
+00000270: 6f6e 735f 7372 6f5f 726f 6c65 7322 2c20  ons_sro_roles", 
+00000280: 2272 656c 6174 696f 6e73 5f6c 6973 745f  "relations_list_
+00000290: 6f66 5f6f 626a 6563 7473 222c 2022 7265  of_objects", "re
+000002a0: 6c61 7469 6f6e 735f 6b65 795f 7661 6c75  lations_key_valu
+000002b0: 6522 2c20 2272 656c 6174 696f 6e73 5f65  e", "relations_e
+000002c0: 7874 656e 7369 6f6e 735f 616e 645f 6f62  xtensions_and_ob
+000002d0: 6a65 6374 7322 2c20 2272 656c 6174 696f  jects", "relatio
+000002e0: 6e73 5f73 726f 5f72 6f6c 6573 225d 2c0d  ns_sro_roles"],.
+000002f0: 0a20 2020 2022 636f 6e64 223a 205b 5d0d  .    "cond": [].
+00000300: 0a7d 2c7b 0d0a 2020 2020 226e 616d 6522  .},{..    "name"
+00000310: 3a20 2274 716c 5f74 7970 6573 3122 2c0d  : "tql_types1",.
+00000320: 0a20 2020 2022 6b65 7973 223a 205b 2265  .    "keys": ["e
+00000330: 6d62 6564 6465 645f 7265 6c61 7469 6f6e  mbedded_relation
+00000340: 7322 2c20 2273 7461 6e64 6172 645f 7265  s", "standard_re
+00000350: 6c61 7469 6f6e 7322 2c20 226c 6973 745f  lations", "list_
+00000360: 6f66 5f6f 626a 6563 7473 222c 2022 6b65  of_objects", "ke
+00000370: 795f 7661 6c75 655f 7265 6c61 7469 6f6e  y_value_relation
+00000380: 7322 2c20 2265 7874 656e 7369 6f6e 5f72  s", "extension_r
+00000390: 656c 6174 696f 6e73 222c 2022 7265 6c61  elations", "rela
+000003a0: 7469 6f6e 735f 7372 6f5f 726f 6c65 7322  tions_sro_roles"
+000003b0: 5d2c 0d0a 2020 2020 226d 6174 6368 223a  ],..    "match":
+000003c0: 5b22 7265 6c61 7469 6f6e 735f 656d 6265  ["relations_embe
+000003d0: 6464 6564 222c 2022 7265 6c61 7469 6f6e  dded", "relation
+000003e0: 735f 7372 6f5f 726f 6c65 7322 2c20 2272  s_sro_roles", "r
+000003f0: 656c 6174 696f 6e73 5f6c 6973 745f 6f66  elations_list_of
+00000400: 5f6f 626a 6563 7473 222c 2022 7265 6c61  _objects", "rela
+00000410: 7469 6f6e 735f 6b65 795f 7661 6c75 6522  tions_key_value"
+00000420: 2c20 2272 656c 6174 696f 6e73 5f65 7874  , "relations_ext
+00000430: 656e 7369 6f6e 735f 616e 645f 6f62 6a65  ensions_and_obje
+00000440: 6374 7322 2c20 2272 656c 6174 696f 6e73  cts", "relations
+00000450: 5f73 726f 5f72 6f6c 6573 225d 2c0d 0a20  _sro_roles"],.. 
+00000460: 2020 2022 636f 6e64 223a 205b 2274 7970     "cond": ["typ
+00000470: 6571 6c22 2c20 2274 7970 6571 6c22 2c20  eql", "typeql", 
+00000480: 2274 7970 6571 6c22 2c20 2274 7970 6571  "typeql", "typeq
+00000490: 6c22 2c20 2272 656c 6174 696f 6e22 2c20  l", "relation", 
+000004a0: 2274 7970 6571 6c22 5d0d 0a7d 2c20 7b0d  "typeql"]..}, {.
+000004b0: 0a20 2020 2022 6e61 6d65 223a 2022 7471  .    "name": "tq
+000004c0: 6c5f 7479 7065 7322 2c0d 0a20 2020 2022  l_types",..    "
+000004d0: 6b65 7973 223a 205b 2273 646f 222c 2022  keys": ["sdo", "
+000004e0: 7372 6f22 2c20 2273 636f 222c 2022 7375  sro", "sco", "su
+000004f0: 6222 2c20 226d 6574 6122 5d2c 0d0a 2020  b", "meta"],..  
+00000500: 2020 226d 6174 6368 223a 5b22 6f62 6a65    "match":["obje
+00000510: 6374 5f63 6f6e 7665 7273 696f 6e22 2c20  ct_conversion", 
+00000520: 226f 626a 6563 745f 636f 6e76 6572 7369  "object_conversi
+00000530: 6f6e 222c 2022 6f62 6a65 6374 5f63 6f6e  on", "object_con
+00000540: 7665 7273 696f 6e22 2c20 226f 626a 6563  version", "objec
+00000550: 745f 636f 6e76 6572 7369 6f6e 222c 2022  t_conversion", "
+00000560: 6f62 6a65 6374 5f63 6f6e 7665 7273 696f  object_conversio
+00000570: 6e22 5d2c 0d0a 2020 2020 2263 6f6e 6422  n"],..    "cond"
+00000580: 3a20 5b22 7364 6f22 2c20 2273 726f 222c  : ["sdo", "sro",
+00000590: 2022 7363 6f22 2c20 2273 7562 222c 2022   "sco", "sub", "
+000005a0: 6d65 7461 2220 5d0d 0a7d 2c20 7b0d 0a20  meta" ]..}, {.. 
+000005b0: 2020 2022 6e61 6d65 223a 2022 6973 5f6c     "name": "is_l
+000005c0: 6973 7473 222c 0d0a 2020 2020 226b 6579  ists",..    "key
+000005d0: 7322 3a20 5b22 7364 6f22 2c20 2273 726f  s": ["sdo", "sro
+000005e0: 222c 2022 7363 6f22 2c20 2273 7562 222c  ", "sco", "sub",
+000005f0: 2022 6d65 7461 225d 2c0d 0a20 2020 2022   "meta"],..    "
+00000600: 6d61 7463 6822 3a5b 2269 735f 6c69 7374  match":["is_list
+00000610: 5f73 646f 222c 2022 6973 5f6c 6973 745f  _sdo", "is_list_
+00000620: 7372 6f22 2c20 2269 735f 6c69 7374 5f73  sro", "is_list_s
+00000630: 636f 222c 2022 6973 5f6c 6973 745f 7375  co", "is_list_su
+00000640: 625f 6f62 6a65 6374 7322 2c20 2269 735f  b_objects", "is_
+00000650: 6c69 7374 5f6d 6574 6122 5d2c 0d0a 2020  list_meta"],..  
+00000660: 2020 2263 6f6e 6422 3a20 5b22 7364 6f22    "cond": ["sdo"
+00000670: 2c20 2273 726f 222c 2022 7363 6f22 2c20  , "sro", "sco", 
+00000680: 2273 7562 222c 2022 6d65 7461 225d 0d0a  "sub", "meta"]..
+00000690: 7d2c 207b 0d0a 2020 2020 226e 616d 6522  }, {..    "name"
+000006a0: 3a20 2264 6972 6563 7422 2c0d 0a20 2020  : "direct",..   
+000006b0: 2022 6b65 7973 223a 205b 2273 7562 5f6f   "keys": ["sub_o
+000006c0: 626a 6563 7473 222c 2022 6f62 6a65 6374  bjects", "object
+000006d0: 7322 5d2c 0d0a 2020 2020 226d 6174 6368  s"],..    "match
+000006e0: 223a 5b22 7375 625f 6f62 6a65 6374 7322  ":["sub_objects"
+000006f0: 2c20 2264 6174 6122 5d2c 0d0a 2020 2020  , "data"],..    
+00000700: 2263 6f6e 6422 3a20 5b5d 0d0a 7d2c 207b  "cond": []..}, {
+00000710: 0d0a 2020 2020 226e 616d 6522 3a20 2263  ..    "name": "c
+00000720: 6f6e 7622 2c0d 0a20 2020 2022 6b65 7973  onv",..    "keys
+00000730: 223a 205b 2273 646f 222c 2022 7372 6f22  ": ["sdo", "sro"
+00000740: 2c20 2273 636f 222c 2022 7375 6222 2c20  , "sco", "sub", 
+00000750: 226d 6574 6122 5d2c 0d0a 2020 2020 226d  "meta"],..    "m
+00000760: 6174 6368 223a 5b22 6f62 6a65 6374 222c  atch":["object",
+00000770: 2022 6f62 6a65 6374 222c 2022 6f62 6a65   "object", "obje
+00000780: 6374 222c 2022 6f62 6a65 6374 225d 2c0d  ct", "object"],.
+00000790: 0a20 2020 2022 636f 6e64 223a 205b 2273  .    "cond": ["s
+000007a0: 646f 222c 2022 7372 6f22 2c20 2273 636f  do", "sro", "sco
+000007b0: 222c 2022 7375 6222 2c20 226d 6574 6122  ", "sub", "meta"
+000007c0: 5d0d 0a7d 2c20 7b0d 0a20 2020 2022 6e61  ]..}, {..    "na
+000007d0: 6d65 223a 2022 636c 6173 7365 7322 2c0d  me": "classes",.
+000007e0: 0a20 2020 2022 6b65 7973 223a 205b 2273  .    "keys": ["s
+000007f0: 646f 222c 2022 7372 6f22 2c20 2273 636f  do", "sro", "sco
+00000800: 222c 2022 7375 6222 2c20 226d 6574 6122  ", "sub", "meta"
+00000810: 5d2c 0d0a 2020 2020 226d 6174 6368 223a  ],..    "match":
+00000820: 5b22 6f62 6a65 6374 222c 2022 6f62 6a65  ["object", "obje
+00000830: 6374 222c 2022 6f62 6a65 6374 222c 2022  ct", "object", "
+00000840: 6f62 6a65 6374 225d 2c0d 0a20 2020 2022  object"],..    "
+00000850: 636f 6e64 223a 205b 2273 646f 222c 2022  cond": ["sdo", "
+00000860: 7372 6f22 2c20 2273 636f 222c 2022 7375  sro", "sco", "su
+00000870: 6222 2c20 226d 6574 6122 5d0d 0a7d 5d    b", "meta"]..}]
```

### Comparing `stixorm-0.1.3/stixorm/module/typedb_lib/logging.py` & `stixorm-0.1.9/stixorm/module/typedb_lib/logging.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,84 +1,84 @@
-import traceback
-
-
-import logging
-logger = logging.getLogger(__name__)
-
-
-def log_delete_layers(result):
-    try:
-        if result is None:
-            logger.debug("Successfully deleted layer")
-        else:
-            logger.debug("Failed to delete layers")
-            logger.exception("\n".join(traceback.format_exception(result.failure())))
-    except Exception as e:
-        logger.error(e)
-
-def log_delete_layer(result, layer):
-    try:
-        if result is None:
-            logger.debug("Failed to delete layer")
-            logger.debug(layer)
-    except Exception as e:
-        logger.error(e)
-
-def log_add_layer(result, layer):
-    try:
-        if result is None:
-            logger.debug("Failed to add layer")
-            logger.debug(layer)
-    except Exception as e:
-        logger.error(e)
-
-def log_insert_query(result, layer):
-    try:
-        if result is None:
-            logger.debug("Failed to creare insert query")
-            logger.debug(layer)
-    except Exception as e:
-        logger.error(e)
-
-def log_delete_instruction_update_layer(result):
-    try:
-        if result is None:
-            logger.debug("Failed to delete layer")
-    except Exception as e:
-        logger.error(e)
-
-def log_add_instruction_update_layer(result):
-    try:
-        if result is None:
-            logger.debug("Failed to update layer")
-    except Exception as e:
-        logger.error(e)
-
-
-def log_delete_instruction_outcome(result):
-    try:
-        logger.debug("=========================== delete typeql instruction ====================================")
-        if result is None:
-            logger.debug("Successfully added instruction")
-
-        else:
-            logger.debug("Failed to add the instruction")
-            logger.exception("\n".join(traceback.format_exception(result.failure())))
-        logger.debug("============================================================================================")
-
-    except Exception as e:
-        logger.error(e)
-
-def log_delete_instruction(dep_match,
-                           dep_insert,
-                           indep_ql,
-                           dep_obj,
-                           del_match,
-                           del_tql):
-    try:
-        logger.debug(' ---------------------------Delete Object----------------------')
-        logger.debug(f'dep_match -> {dep_match}\n dep_insert -> {dep_insert}')
-        logger.debug(f'indep_ql -> {indep_ql}\n dep_obj -> {dep_obj}')
-        logger.debug("=========================== delete typeql below ====================================")
-        logger.debug(f'del_match -> {del_match}\n del_tql -> {del_tql}')
-    except Exception as e:
-        logger.error(e)
+import traceback
+
+
+import logging
+logger = logging.getLogger(__name__)
+
+
+def log_delete_layers(result):
+    try:
+        if result is None:
+            logger.debug("Successfully deleted layer")
+        else:
+            logger.debug("Failed to delete layers")
+            logger.exception("\n".join(traceback.format_exception(result.failure())))
+    except Exception as e:
+        logger.error(e)
+
+def log_delete_layer(result, layer):
+    try:
+        if result is None:
+            logger.debug("Failed to delete layer")
+            logger.debug(layer)
+    except Exception as e:
+        logger.error(e)
+
+def log_add_layer(result, layer):
+    try:
+        if result is None:
+            logger.debug("Failed to add layer")
+            logger.debug(layer)
+    except Exception as e:
+        logger.error(e)
+
+def log_insert_query(result, layer):
+    try:
+        if result is None:
+            logger.debug("Failed to creare insert query")
+            logger.debug(layer)
+    except Exception as e:
+        logger.error(e)
+
+def log_delete_instruction_update_layer(result):
+    try:
+        if result is None:
+            logger.debug("Failed to delete layer")
+    except Exception as e:
+        logger.error(e)
+
+def log_add_instruction_update_layer(result):
+    try:
+        if result is None:
+            logger.debug("Failed to update layer")
+    except Exception as e:
+        logger.error(e)
+
+
+def log_delete_instruction_outcome(result):
+    try:
+        logger.debug("=========================== delete typeql instruction ====================================")
+        if result is None:
+            logger.debug("Successfully added instruction")
+
+        else:
+            logger.debug("Failed to add the instruction")
+            logger.exception("\n".join(traceback.format_exception(result.failure())))
+        logger.debug("============================================================================================")
+
+    except Exception as e:
+        logger.error(e)
+
+def log_delete_instruction(dep_match,
+                           dep_insert,
+                           indep_ql,
+                           dep_obj,
+                           del_match,
+                           del_tql):
+    try:
+        logger.debug(' ---------------------------Delete Object----------------------')
+        logger.debug(f'dep_match -> {dep_match}\n dep_insert -> {dep_insert}')
+        logger.debug(f'indep_ql -> {indep_ql}\n dep_obj -> {dep_obj}')
+        logger.debug("=========================== delete typeql below ====================================")
+        logger.debug(f'del_match -> {del_match}\n del_tql -> {del_tql}')
+    except Exception as e:
+        logger.error(e)
```

### Comparing `stixorm-0.1.3/stixorm/module/typedb_lib/queries.py` & `stixorm-0.1.9/stixorm/module/typedb_lib/queries.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,255 +1,255 @@
-import logging
-import traceback
-from typing import List, Iterator
-from typedb.api.answer.concept_map import ConceptMap
-from typedb.api.connection.client import TypeDBClient
-from typedb.api.connection.session import SessionType, TypeDBSession
-from typedb.api.connection.transaction import TransactionType, TypeDBTransaction
-from typedb.api.query.future import QueryFuture
-from typedb.api.query.query_manager import QueryManager
-from typedb.client import TypeDB
-from typedb.stream.bidirectional_stream import BidirectionalStream
-
-from stixorm.module.typedb_lib.logging import log_delete_layer, log_add_layer
-from stixorm.module.typedb_lib.instructions import Instructions
-
-logger = logging.getLogger(__name__)
-
-
-
-def build_insert_query(layer):
-    dep_match = layer["dep_match"]
-    dep_insert = layer["dep_insert"]
-    indep_ql = layer["indep_ql"]
-    if dep_match == '':
-        match_tql = ''
-    else:
-        match_tql = 'match ' + dep_match
-    if indep_ql == '' and dep_insert == '':
-        insert_tql = ''
-    else:
-        insert_tql = 'insert ' + indep_ql + dep_insert
-    logger.info(f'\n match_tql string?-> {match_tql}')
-    logger.info(f'\n insert_tql string?-> {insert_tql}')
-    typeql_string = match_tql + insert_tql
-
-    insertion_is_empty = len(insert_tql) == 0
-    if insertion_is_empty:
-        return None
-    return typeql_string
-
-
-def build_match_id_query(stix_ids: List[str]):
-    get_ids_tql = 'match $id isa stix-id;'
-    len_id = len(stix_ids)
-    if len_id == 1:
-        get_ids_tql += '$id "' + stix_ids[0] + '";'
-    else:
-        for index, id_l in enumerate(stix_ids):
-            get_ids_tql += ' {$id "' + id_l + '";}'
-            if index == len_id - 1:
-                get_ids_tql += " ;"
-            else:
-                get_ids_tql += ' or '
-    return get_ids_tql
-
-
-def get_core_client(uri: str,
-                    port: str):
-    typedb_url = uri + ":" + port
-    return TypeDB.core_client(typedb_url)
-
-def get_data_session(core_client: TypeDBClient,
-                     database: str):
-    return core_client.session(database, SessionType.DATA)
-
-def get_read_transaction(session: TypeDBSession):
-    return session.transaction(TransactionType.READ)
-
-def get_write_transaction(session: TypeDBSession):
-    return session.transaction(TransactionType.WRITE)
-
-
-
-
-def match_query(uri: str, port: str, database: str, query: str, data_query, **data_query_args):
-    data = []
-    try:
-        with get_core_client(uri, port) as client:
-            client_session = get_data_session(client, database)
-            with client_session as session:
-                read_transaction = get_read_transaction(session)
-                with read_transaction as transaction:
-                    answer_iterator = transaction.query().match(query)
-                    data = data_query(query, answer_iterator, transaction, **data_query_args)
-                    return data
-    except Exception as e:
-        logger.exception(e)
-        raise Exception("Problem matching")
-
-def get_all_databases(uri: str, port: str):
-    client = get_core_client(uri, port)
-    return client.databases().all()
-
-def delete_database(uri: str, port: str, database: str):
-    client = get_core_client(uri, port)
-    if client.databases().contains(database):
-       logger.info('Database ' + database + ' exists... deleting')
-       client.databases().get(database).delete()
-    else:
-       logger.info('Database ' + database + ' does not exists... skipping')
-
-
-def query_ids(query, generator, transaction, **data_query_args):
-    logger.info(
-        '\n\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n' + \
-        '---------------------------------------------------------------------------------------- Query ids ------------------------------------------------------------------------------\n' + \
-        '-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n')
-
-    logger.info(query)
-
-    number = 0
-    ids = []
-    for result in generator:
-        ids.append(result.get("ids"))
-        logger.info(
-            '\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n' + \
-            'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    Query IDs Concept Map ' + str(
-                number) + 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n' + \
-            'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n')
-        for concept in enumerate(result.concepts()):
-            if concept[1].is_type():
-                logger.info('   Type:' + concept[1].as_type().get_label())
-            if concept[1].is_relation():
-                logger.info('   Relation: iid ' + concept[1].as_relation().get_iid())
-            if concept[1].is_attribute():
-                logger.info('   Attribute iid: ' + concept[1].as_attribute().get_iid())
-                logger.info('           value: ' + str(concept[1].as_attribute().get_value()))
-        number = number + 1
-
-    logger.info('\n')
-
-    return ids
-
-def query_id(query, generator, transaction, **data_query_args):
-    logger.info(
-        '\n\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n' + \
-        '---------------------------------------------------------------------------------------- Query ids ------------------------------------------------------------------------------\n' + \
-        '-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n')
-
-    logger.info(query)
-
-    number = 0
-    ids = []
-    for result in generator:
-        ids.append(result.get("id").get_value())
-        logger.info(
-            '\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n' + \
-            'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    Query ID Concept Map ' + str(
-                number) + 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n' + \
-            'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n')
-        for concept in enumerate(result.concepts()):
-            if concept[1].is_type():
-                logger.info('   Type:' + concept[1].as_type().get_label())
-            if concept[1].is_relation():
-                logger.info('   Relation: iid ' + concept[1].as_relation().get_iid())
-            if concept[1].is_attribute():
-                logger.info('   Attribute iid: ' + concept[1].as_attribute().get_iid())
-                logger.info('           value: ' + str(concept[1].as_attribute().get_value()))
-        number = number + 1
-
-    logger.info('\n')
-
-    return ids
-
-
-def delete_layers(uri: str, port: str, database: str, instructions: Instructions):
-    with get_core_client(uri, port) as client:
-        client_session = get_data_session(client, database)
-        with client_session as session:
-            for instruction_id in instructions.get_ordered_ids():
-                write_transaction = get_write_transaction(session)
-                with write_transaction as transaction:
-                    query = instructions.get_query_for_id(instruction_id)
-                    result = delete_layer(transaction, query)
-                    log_delete_layer(result, query)
-                    instructions.update_delete_instruction_as_success(instruction_id)
-    return instructions
-
-
-
-def delete_layer(transaction: TypeDBTransaction, query: str):
-    transaction_query: QueryManager = transaction.query()
-    query_future: QueryFuture = transaction_query.delete(query)
-    bi_d: BidirectionalStream = query_future.get()
-    logger.info(
-        '\n\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n' + \
-        '---------------------------------------------------------------------------------------- Delete Layer Query ------------------------------------------------------------------------------\n' + \
-        '-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n')
-
-    logger.info(query)
-
-    logger.info(
-        '\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n' + \
-        'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    Delete Result ' + 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n' + \
-        'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n')
-
-    logger.info(str(bi_d))
-
-    transaction.commit()
-
-
-def add_layer(transaction: TypeDBTransaction, layer: str):
-    transaction_query: QueryManager = transaction.query()
-    query_future: Iterator[ConceptMap] = transaction_query.insert(layer)
-
-    logger.debug('\n\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n')
-    logger.info('\n------------------------------------------------ Add Layer Query ----------------------------------------------\n')
-    logger.debug('-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n')
-
-    logger.info(layer)
-
-    number = 0
-    logger.info('\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    Add Layer Response     xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n')
-    logger.info(f'insert_iterator response ->\n{query_future}')
-    for result in query_future:
-        logger.debug('\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n' )
-        logger.debug('\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    Add Layer Concept Map ' + str(number) +      'xxxxxxxxxxxxxxxxxxxxxx\n')
-        logger.debug('\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n')
-
-        logger.debug(f'typedb response ->\n{result}')
-
-        for concept in enumerate(result.concepts()):
-            if concept[1].is_type():
-                logger.debug('   Type:' + concept[1].as_type().get_label())
-            if concept[1].is_relation():
-                logger.debug('   Relation: iid ' + concept[1].as_relation().get_iid() )
-            if concept[1].is_attribute():
-                logger.debug('   Attribute iid: ' + concept[1].as_attribute().get_iid())
-                logger.debug('           value: ' + str(concept[1].as_attribute().get_value()))
-        number = number + 1
-
-    logger.info('\n\n')
-
-    transaction.commit()
-
-
-def add_instructions_to_typedb(uri: str, port: str, database: str, instructions: Instructions):
-    try:
-        with get_core_client(uri, port) as client:
-            client_session = get_data_session(client, database)
-            with client_session as session:
-                for instruction_id in instructions.get_ordered_ids():
-                    if instructions.not_allow_insertion(instruction_id):
-                        continue
-                    write_transaction = get_write_transaction(session)
-                    with write_transaction as transaction:
-                        query = instructions.get_query_for_id(instruction_id)
-                        add_layer(transaction, query)
-                        instructions.update_instruction_as_success(instruction_id)
-    except Exception as e:
-        traceback_str = traceback.format_exc()
-        instructions.update_instruction_as_error(instruction_id, traceback_str)
-    return instructions
-
-
+import logging
+import traceback
+from typing import List, Iterator
+from typedb.api.answer.concept_map import ConceptMap
+from typedb.api.connection.client import TypeDBClient
+from typedb.api.connection.session import SessionType, TypeDBSession
+from typedb.api.connection.transaction import TransactionType, TypeDBTransaction
+from typedb.api.query.future import QueryFuture
+from typedb.api.query.query_manager import QueryManager
+from typedb.client import TypeDB
+from typedb.stream.bidirectional_stream import BidirectionalStream
+
+from stixorm.module.typedb_lib.logging import log_delete_layer, log_add_layer
+from stixorm.module.typedb_lib.instructions import Instructions
+
+logger = logging.getLogger(__name__)
+
+
+
+def build_insert_query(layer):
+    dep_match = layer["dep_match"]
+    dep_insert = layer["dep_insert"]
+    indep_ql = layer["indep_ql"]
+    if dep_match == '':
+        match_tql = ''
+    else:
+        match_tql = 'match ' + dep_match
+    if indep_ql == '' and dep_insert == '':
+        insert_tql = ''
+    else:
+        insert_tql = 'insert ' + indep_ql + dep_insert
+    logger.info(f'\n match_tql string?-> {match_tql}')
+    logger.info(f'\n insert_tql string?-> {insert_tql}')
+    typeql_string = match_tql + insert_tql
+
+    insertion_is_empty = len(insert_tql) == 0
+    if insertion_is_empty:
+        return None
+    return typeql_string
+
+
+def build_match_id_query(stix_ids: List[str]):
+    get_ids_tql = 'match $id isa stix-id;'
+    len_id = len(stix_ids)
+    if len_id == 1:
+        get_ids_tql += '$id "' + stix_ids[0] + '";'
+    else:
+        for index, id_l in enumerate(stix_ids):
+            get_ids_tql += ' {$id "' + id_l + '";}'
+            if index == len_id - 1:
+                get_ids_tql += " ;"
+            else:
+                get_ids_tql += ' or '
+    return get_ids_tql
+
+
+def get_core_client(uri: str,
+                    port: str):
+    typedb_url = uri + ":" + port
+    return TypeDB.core_client(typedb_url)
+
+def get_data_session(core_client: TypeDBClient,
+                     database: str):
+    return core_client.session(database, SessionType.DATA)
+
+def get_read_transaction(session: TypeDBSession):
+    return session.transaction(TransactionType.READ)
+
+def get_write_transaction(session: TypeDBSession):
+    return session.transaction(TransactionType.WRITE)
+
+
+
+
+def match_query(uri: str, port: str, database: str, query: str, data_query, **data_query_args):
+    data = []
+    try:
+        with get_core_client(uri, port) as client:
+            client_session = get_data_session(client, database)
+            with client_session as session:
+                read_transaction = get_read_transaction(session)
+                with read_transaction as transaction:
+                    answer_iterator = transaction.query().match(query)
+                    data = data_query(query, answer_iterator, transaction, **data_query_args)
+                    return data
+    except Exception as e:
+        logger.exception(e)
+        raise Exception("Problem matching")
+
+def get_all_databases(uri: str, port: str):
+    client = get_core_client(uri, port)
+    return client.databases().all()
+
+def delete_database(uri: str, port: str, database: str):
+    client = get_core_client(uri, port)
+    if client.databases().contains(database):
+       logger.info('Database ' + database + ' exists... deleting')
+       client.databases().get(database).delete()
+    else:
+       logger.info('Database ' + database + ' does not exists... skipping')
+
+
+def query_ids(query, generator, transaction, **data_query_args):
+    logger.info(
+        '\n\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n' + \
+        '---------------------------------------------------------------------------------------- Query ids ------------------------------------------------------------------------------\n' + \
+        '-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n')
+
+    logger.info(query)
+
+    number = 0
+    ids = []
+    for result in generator:
+        ids.append(result.get("ids"))
+        logger.info(
+            '\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n' + \
+            'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    Query IDs Concept Map ' + str(
+                number) + 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n' + \
+            'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n')
+        for concept in enumerate(result.concepts()):
+            if concept[1].is_type():
+                logger.info('   Type:' + concept[1].as_type().get_label())
+            if concept[1].is_relation():
+                logger.info('   Relation: iid ' + concept[1].as_relation().get_iid())
+            if concept[1].is_attribute():
+                logger.info('   Attribute iid: ' + concept[1].as_attribute().get_iid())
+                logger.info('           value: ' + str(concept[1].as_attribute().get_value()))
+        number = number + 1
+
+    logger.info('\n')
+
+    return ids
+
+def query_id(query, generator, transaction, **data_query_args):
+    logger.info(
+        '\n\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n' + \
+        '---------------------------------------------------------------------------------------- Query ids ------------------------------------------------------------------------------\n' + \
+        '-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n')
+
+    logger.info(query)
+
+    number = 0
+    ids = []
+    for result in generator:
+        ids.append(result.get("id").get_value())
+        logger.info(
+            '\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n' + \
+            'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    Query ID Concept Map ' + str(
+                number) + 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n' + \
+            'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n')
+        for concept in enumerate(result.concepts()):
+            if concept[1].is_type():
+                logger.info('   Type:' + concept[1].as_type().get_label())
+            if concept[1].is_relation():
+                logger.info('   Relation: iid ' + concept[1].as_relation().get_iid())
+            if concept[1].is_attribute():
+                logger.info('   Attribute iid: ' + concept[1].as_attribute().get_iid())
+                logger.info('           value: ' + str(concept[1].as_attribute().get_value()))
+        number = number + 1
+
+    logger.info('\n')
+
+    return ids
+
+
+def delete_layers(uri: str, port: str, database: str, instructions: Instructions):
+    with get_core_client(uri, port) as client:
+        client_session = get_data_session(client, database)
+        with client_session as session:
+            for instruction_id in instructions.get_ordered_ids():
+                write_transaction = get_write_transaction(session)
+                with write_transaction as transaction:
+                    query = instructions.get_query_for_id(instruction_id)
+                    result = delete_layer(transaction, query)
+                    log_delete_layer(result, query)
+                    instructions.update_delete_instruction_as_success(instruction_id)
+    return instructions
+
+
+
+def delete_layer(transaction: TypeDBTransaction, query: str):
+    transaction_query: QueryManager = transaction.query()
+    query_future: QueryFuture = transaction_query.delete(query)
+    bi_d: BidirectionalStream = query_future.get()
+    logger.info(
+        '\n\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n' + \
+        '---------------------------------------------------------------------------------------- Delete Layer Query ------------------------------------------------------------------------------\n' + \
+        '-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n')
+
+    logger.info(query)
+
+    logger.info(
+        '\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n' + \
+        'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    Delete Result ' + 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n' + \
+        'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n')
+
+    logger.info(str(bi_d))
+
+    transaction.commit()
+
+
+def add_layer(transaction: TypeDBTransaction, layer: str):
+    transaction_query: QueryManager = transaction.query()
+    query_future: Iterator[ConceptMap] = transaction_query.insert(layer)
+
+    logger.debug('\n\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n')
+    logger.info('\n------------------------------------------------ Add Layer Query ----------------------------------------------\n')
+    logger.debug('-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n')
+
+    logger.info(layer)
+
+    number = 0
+    logger.info('\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    Add Layer Response     xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n')
+    logger.info(f'insert_iterator response ->\n{query_future}')
+    for result in query_future:
+        logger.debug('\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n' )
+        logger.debug('\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    Add Layer Concept Map ' + str(number) +      'xxxxxxxxxxxxxxxxxxxxxx\n')
+        logger.debug('\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n')
+
+        logger.debug(f'typedb response ->\n{result}')
+
+        for concept in enumerate(result.concepts()):
+            if concept[1].is_type():
+                logger.debug('   Type:' + concept[1].as_type().get_label())
+            if concept[1].is_relation():
+                logger.debug('   Relation: iid ' + concept[1].as_relation().get_iid() )
+            if concept[1].is_attribute():
+                logger.debug('   Attribute iid: ' + concept[1].as_attribute().get_iid())
+                logger.debug('           value: ' + str(concept[1].as_attribute().get_value()))
+        number = number + 1
+
+    logger.info('\n\n')
+
+    transaction.commit()
+
+
+def add_instructions_to_typedb(uri: str, port: str, database: str, instructions: Instructions):
+    try:
+        with get_core_client(uri, port) as client:
+            client_session = get_data_session(client, database)
+            with client_session as session:
+                for instruction_id in instructions.get_ordered_ids():
+                    if instructions.not_allow_insertion(instruction_id):
+                        continue
+                    write_transaction = get_write_transaction(session)
+                    with write_transaction as transaction:
+                        query = instructions.get_query_for_id(instruction_id)
+                        add_layer(transaction, query)
+                        instructions.update_instruction_as_success(instruction_id)
+    except Exception as e:
+        traceback_str = traceback.format_exc()
+        instructions.update_instruction_as_error(instruction_id, traceback_str)
+    return instructions
+
+
```

### Comparing `stixorm-0.1.3/stixorm/unit/utils/dep_regex.py` & `stixorm-0.1.9/stixorm/unit/utils/dep_regex.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,85 +1,85 @@
-import sys,os,json
-import re
-
-def check_status(key:str,status:dict):
-    if key in status:
-        return status[key]
-    else:
-        return False
-
-def set_status(key:str,status:dict):
-
-    status[key]=True
-
-    for kk in status.keys():
-        if key != kk: status[kk]=False
-
-
-if __name__ == '__main__':
-
-    with open('example.txt','r') as file:
-        text = file.read()
-
-        status = {}
-        for no,line in enumerate(text.split('\n')):
-            if line.startswith('core_ql'):
-                print(f'Core found at {no}')
-                # check rest of line
-                query = line[line.index('>')+1:].strip()
-                set_status('core_ql',status)
-
-            elif check_status('core_ql',status):
-                query = line.strip()
-
-            if line.startswith('indep_ql'):
-                print(f'Indep found at {no}')
-                # check rest of line
-                query = line[line.index('>')+1:].strip()
-                if len(query)>0:
-                    m = re.search(r"(\$[a-z\-\_]+)\s+isa\s+", query)
-                    if m:
-                        first_word = m.groups()[0]
-                        print(f'Found first {first_word}')
-
-                set_status('indep_ql',status)
-            elif check_status('indep_ql',status):
-                query = line.strip()
-                if len(query)>0:
-                    m = re.search(r"(\$[a-z\-\_]+)\s+isa\s+", query)
-                    if m:
-                        first_word = m.groups()[0]
-                        print(f'Found first {first_word}')
-
-            if line.startswith('dep_match'):
-                print(f'Dep match found at {no}')
-                # check rest of line
-                query = line[line.index('>')+1:].strip()
-
-                set_status('dep_match',status)
-            elif check_status('dep_match',status):
-                query = line.strip()
-
-            if line.startswith('dep_insert ->'):
-                print(f'Dep Insert found at {no}')
-                # check rest of line
-                query = line[line.index('>')+1:].strip()
-                if len(query)>0:
-                    m = re.search(r"[a-z\-\_]+;$",query)
-                    last_word = m.group(0)
-                    print(f'Found last {last_word}')
-
-                set_status('dep_insert',status)
-            elif check_status('dep_insert',status):
-                query = line.strip()
-                if len(query)>0:
-                    m = re.search(r"[a-z\-\_]+;$",query)
-                    if m:
-                        last_word = m.group(0)
-                        print(f'Found last {last_word}')
-
-
-
-
-
-
-
+import sys,os,json
+import re
+
+def check_status(key:str,status:dict):
+    if key in status:
+        return status[key]
+    else:
+        return False
+
+def set_status(key:str,status:dict):
+
+    status[key]=True
+
+    for kk in status.keys():
+        if key != kk: status[kk]=False
+
+
+if __name__ == '__main__':
+
+    with open('example.txt','r') as file:
+        text = file.read()
+
+        status = {}
+        for no,line in enumerate(text.split('\n')):
+            if line.startswith('core_ql'):
+                print(f'Core found at {no}')
+                # check rest of line
+                query = line[line.index('>')+1:].strip()
+                set_status('core_ql',status)
+
+            elif check_status('core_ql',status):
+                query = line.strip()
+
+            if line.startswith('indep_ql'):
+                print(f'Indep found at {no}')
+                # check rest of line
+                query = line[line.index('>')+1:].strip()
+                if len(query)>0:
+                    m = re.search(r"(\$[a-z\-\_]+)\s+isa\s+", query)
+                    if m:
+                        first_word = m.groups()[0]
+                        print(f'Found first {first_word}')
+
+                set_status('indep_ql',status)
+            elif check_status('indep_ql',status):
+                query = line.strip()
+                if len(query)>0:
+                    m = re.search(r"(\$[a-z\-\_]+)\s+isa\s+", query)
+                    if m:
+                        first_word = m.groups()[0]
+                        print(f'Found first {first_word}')
+
+            if line.startswith('dep_match'):
+                print(f'Dep match found at {no}')
+                # check rest of line
+                query = line[line.index('>')+1:].strip()
+
+                set_status('dep_match',status)
+            elif check_status('dep_match',status):
+                query = line.strip()
+
+            if line.startswith('dep_insert ->'):
+                print(f'Dep Insert found at {no}')
+                # check rest of line
+                query = line[line.index('>')+1:].strip()
+                if len(query)>0:
+                    m = re.search(r"[a-z\-\_]+;$",query)
+                    last_word = m.group(0)
+                    print(f'Found last {last_word}')
+
+                set_status('dep_insert',status)
+            elif check_status('dep_insert',status):
+                query = line.strip()
+                if len(query)>0:
+                    m = re.search(r"[a-z\-\_]+;$",query)
+                    if m:
+                        last_word = m.group(0)
+                        print(f'Found last {last_word}')
+
+
+
+
+
+
+
```

### Comparing `stixorm-0.1.3/stixorm/unit/utils/example.txt` & `stixorm-0.1.9/stixorm/unit/utils/example.txt`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,39 +1,39 @@
-dep_match ->  $identity0 isa identity, has stix-id "identity--b38dfe21-7477-40d1-aa90-5c8671ce51ca";
- $marking-definition01 isa marking-definition, has stix-id "marking-definition--5e57c739-391a-4eb3-b6be-7d15ca92d5ed";
-
-dep_insert ->
- $created-by0 (created:$threat-actor, creator:$identity0) isa created-by;
-
- $object-marking1 (marked:$threat-actor, marking:$marking-definition01) isa object-marking;
-
-indep_ql -> $threat-actor isa threat-actor,
- has stix-type $stix-type,
- has spec-version $spec-version,
- has stix-id $stix-id,
- has created $created,
- has modified $modified,
- has name $name,
- has threat-actor-type $threat_actor_types0,
- has threat-actor-type $threat_actor_types1,
- has aliases $aliases0,
- has aliases $aliases1,
- has stix-role $roles0,
- has resource-level $resource-level,
- has primary-motivation $primary-motivation;
-
- $stix-type "threat-actor";
- $spec-version "2.1";
- $stix-id "threat-actor--8b6297fe-cae7-47c6-9256-5584b417849c";
- $created 2017-04-27T16:18:24.318;
- $modified 2017-04-27T16:18:24.318;
- $name "The Joker";
- $threat_actor_types0 "criminal";
- $threat_actor_types1 "terrorist";
- $aliases0 "Joe Kerr";
- $aliases1 "The Clown Prince of Crime";
- $roles0 "director";
- $resource-level "team";
- $primary-motivation "personal-satisfaction";
-
-
+dep_match ->  $identity0 isa identity, has stix-id "identity--b38dfe21-7477-40d1-aa90-5c8671ce51ca";
+ $marking-definition01 isa marking-definition, has stix-id "marking-definition--5e57c739-391a-4eb3-b6be-7d15ca92d5ed";
+
+dep_insert ->
+ $created-by0 (created:$threat-actor, creator:$identity0) isa created-by;
+
+ $object-marking1 (marked:$threat-actor, marking:$marking-definition01) isa object-marking;
+
+indep_ql -> $threat-actor isa threat-actor,
+ has stix-type $stix-type,
+ has spec-version $spec-version,
+ has stix-id $stix-id,
+ has created $created,
+ has modified $modified,
+ has name $name,
+ has threat-actor-type $threat_actor_types0,
+ has threat-actor-type $threat_actor_types1,
+ has aliases $aliases0,
+ has aliases $aliases1,
+ has stix-role $roles0,
+ has resource-level $resource-level,
+ has primary-motivation $primary-motivation;
+
+ $stix-type "threat-actor";
+ $spec-version "2.1";
+ $stix-id "threat-actor--8b6297fe-cae7-47c6-9256-5584b417849c";
+ $created 2017-04-27T16:18:24.318;
+ $modified 2017-04-27T16:18:24.318;
+ $name "The Joker";
+ $threat_actor_types0 "criminal";
+ $threat_actor_types1 "terrorist";
+ $aliases0 "Joe Kerr";
+ $aliases1 "The Clown Prince of Crime";
+ $roles0 "director";
+ $resource-level "team";
+ $primary-motivation "personal-satisfaction";
+
+
 core_ql ->  $threat-actor isa threat-actor, has stix-id "threat-actor--8b6297fe-cae7-47c6-9256-5584b417849c";
```

### Comparing `stixorm-0.1.3/PKG-INFO` & `stixorm-0.1.9/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: stixorm
-Version: 0.1.3
+Version: 0.1.9
 Summary: Description
 Home-page: https://github.com/os-threat/Stix-ORM
 Author: Brett Forbes
 Author-email: brett@cloudaccelerator.co
 Requires-Python: >=3.8.1,<4.0.0
 Classifier: Development Status :: 3 - Alpha
 Classifier: License :: OSI Approved :: Apache Software License
```

