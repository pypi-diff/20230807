# Comparing `tmp/polars_lts_cpu-0.18.8.tar.gz` & `tmp/polars_lts_cpu-0.18.9.tar.gz`

## Comparing `polars_lts_cpu-0.18.8.tar` & `polars_lts_cpu-0.18.9.tar`

### file list

```diff
@@ -1,1293 +1,1308 @@
--rw-r--r--   0        0        0     1598 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/LICENSE
--rw-r--r--   0     1001      123      144 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/README.md
--rw-r--r--   0     1001      123     1975 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/array/default_arrays.rs
--rw-r--r--   0     1001      123     1791 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/array/fixed_size_list.rs
--rw-r--r--   0     1001      123     3773 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/array/get.rs
--rw-r--r--   0     1001      123     6664 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/array/list.rs
--rw-r--r--   0     1001      123     8165 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/array/mod.rs
--rw-r--r--   0     1001      123      878 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/array/null.rs
--rw-r--r--   0     1001      123     1125 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/array/slice.rs
--rw-r--r--   0     1001      123     2253 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/array/utf8.rs
--rw-r--r--   0     1001      123     2294 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/bit_util.rs
--rw-r--r--   0     1001      123       17 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/bitmap/mod.rs
--rw-r--r--   0     1001      123      819 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/bitmap/mutable.rs
--rw-r--r--   0     1001      123      370 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/add.rs
--rw-r--r--   0     1001      123     2181 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/commutative.rs
--rw-r--r--   0     1001      123     1482 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/div.rs
--rw-r--r--   0     1001      123     1028 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/mod.rs
--rw-r--r--   0     1001      123     1177 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/mul.rs
--rw-r--r--   0     1001      123      508 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/sub.rs
--rw-r--r--   0     1001      123       51 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/arithmetics/mod.rs
--rw-r--r--   0     1001      123        1 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/arity.rs
--rw-r--r--   0     1001      123      727 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/bitwise.rs
--rw-r--r--   0     1001      123     1206 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/cast.rs
--rw-r--r--   0     1001      123     3964 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/decimal.rs
--rw-r--r--   0     1001      123     1250 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/mod.rs
--rw-r--r--   0     1001      123      391 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/take/bitmap.rs
--rw-r--r--   0     1001      123     2767 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/take/boolean.rs
--rw-r--r--   0     1001      123     3489 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/take/fixed_size_list.rs
--rw-r--r--   0     1001      123    25290 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/take/mod.rs
--rw-r--r--   0     1001      123      797 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/tile.rs
--rw-r--r--   0     1001      123     1102 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/conversion.rs
--rw-r--r--   0     1001      123     1609 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/data_types.rs
--rw-r--r--   0     1001      123       25 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/error.rs
--rw-r--r--   0     1001      123       28 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/export.rs
--rw-r--r--   0     1001      123       26 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/floats/mod.rs
--rw-r--r--   0     1001      123     2066 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/floats/ord.rs
--rw-r--r--   0     1001      123     1273 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/index.rs
--rw-r--r--   0     1001      123      984 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/is_valid.rs
--rw-r--r--   0     1001      123     4783 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/agg_mean.rs
--rw-r--r--   0     1001      123     1074 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/comparison.rs
--rw-r--r--   0     1001      123     1068 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/concatenate.rs
--rw-r--r--   0     1001      123     5153 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/ewm/average.rs
--rw-r--r--   0     1001      123     1808 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/ewm/mod.rs
--rw-r--r--   0     1001      123    25065 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/ewm/variance.rs
--rw-r--r--   0     1001      123     1406 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/float.rs
--rw-r--r--   0     1001      123     4908 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/list.rs
--rw-r--r--   0     1001      123     1885 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/list_bytes_iter.rs
--rw-r--r--   0     1001      123     9783 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/mod.rs
--rw-r--r--   0     1001      123     4040 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/mod.rs
--rw-r--r--   0     1001      123     2019 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/mean.rs
--rw-r--r--   0     1001      123    13019 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/min_max.rs
--rw-r--r--   0     1001      123     3848 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/mod.rs
--rw-r--r--   0     1001      123    11331 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/quantile.rs
--rw-r--r--   0     1001      123     5684 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/sum.rs
--rw-r--r--   0     1001      123     7807 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/variance.rs
--rw-r--r--   0     1001      123     1879 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/nulls/mean.rs
--rw-r--r--   0     1001      123    14722 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/nulls/min_max.rs
--rw-r--r--   0     1001      123    10055 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/nulls/mod.rs
--rw-r--r--   0     1001      123     8128 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/nulls/quantile.rs
--rw-r--r--   0     1001      123     4821 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/nulls/sum.rs
--rw-r--r--   0     1001      123     6856 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/nulls/variance.rs
--rw-r--r--   0     1001      123     8244 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/window.rs
--rw-r--r--   0     1001      123     4753 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/set.rs
--rw-r--r--   0     1001      123     4529 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/sort_partition.rs
--rw-r--r--   0     1001      123     2948 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/sorted_join/inner.rs
--rw-r--r--   0     1001      123     5974 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/sorted_join/left.rs
--rw-r--r--   0     1001      123      231 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/sorted_join/mod.rs
--rw-r--r--   0     1001      123      842 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/string.rs
--rw-r--r--   0     1001      123     2310 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/take_agg/boolean.rs
--rw-r--r--   0     1001      123     4315 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/take_agg/mod.rs
--rw-r--r--   0     1001      123     2606 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/take_agg/var.rs
--rw-r--r--   0     1001      123     3658 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/time.rs
--rw-r--r--   0     1001      123      341 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/lib.rs
--rw-r--r--   0     1001      123      519 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/prelude.rs
--rw-r--r--   0     1001      123      534 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/slice.rs
--rw-r--r--   0     1001      123      183 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/time_zone.rs
--rw-r--r--   0     1001      123      998 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/trusted_len/boolean.rs
--rw-r--r--   0     1001      123     2821 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/trusted_len/mod.rs
--rw-r--r--   0     1001      123     2054 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/trusted_len/push_unchecked.rs
--rw-r--r--   0     1001      123      158 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/trusted_len/rev.rs
--rw-r--r--   0     1001      123     5233 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/utils.rs
--rw-r--r--   0        0        0     2043 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/LICENSE
--rw-r--r--   0     1001      123      143 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/README.md
--rw-r--r--   0     1001      123     1018 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/base_utc_offset.rs
--rw-r--r--   0     1001      123     3569 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/date.rs
--rw-r--r--   0     1001      123     6465 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/datetime.rs
--rw-r--r--   0     1001      123     3305 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/duration.rs
--rw-r--r--   0     1001      123     5607 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/kernels.rs
--rw-r--r--   0     1001      123     1062 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/mod.rs
--rw-r--r--   0     1001      123     6289 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/rolling_window/floats.rs
--rw-r--r--   0     1001      123     2437 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/rolling_window/ints.rs
--rw-r--r--   0     1001      123    10941 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/rolling_window/mod.rs
--rw-r--r--   0     1001      123      413 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/rolling_window/rolling_kernels/mod.rs
--rw-r--r--   0     1001      123     5502 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/rolling_window/rolling_kernels/no_nulls.rs
--rw-r--r--   0     1001      123     2372 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/time.rs
--rw-r--r--   0     1001      123    21334 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/utf8/infer.rs
--rw-r--r--   0     1001      123    18997 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/utf8/mod.rs
--rw-r--r--   0     1001      123     3975 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/utf8/patterns.rs
--rw-r--r--   0     1001      123    11229 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/utf8/strptime.rs
--rw-r--r--   0     1001      123     3340 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/date_range.rs
--rw-r--r--   0     1001      123      994 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/dst_offset.rs
--rw-r--r--   0     1001      123    34617 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/groupby/dynamic.rs
--rw-r--r--   0     1001      123       88 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/groupby/mod.rs
--rw-r--r--   0     1001      123      769 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/lib.rs
--rw-r--r--   0     1001      123     2976 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/month_end.rs
--rw-r--r--   0     1001      123     3371 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/month_start.rs
--rw-r--r--   0     1001      123      274 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/prelude.rs
--rw-r--r--   0     1001      123     1381 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/round.rs
--rw-r--r--   0     1001      123     3763 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/series/_trait.rs
--rw-r--r--   0     1001      123      136 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/series/implementations/boolean.rs
--rw-r--r--   0     1001      123      140 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/series/implementations/categoricals.rs
--rw-r--r--   0     1001      123      133 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/series/implementations/date.rs
--rw-r--r--   0     1001      123      137 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/series/implementations/datetime.rs
--rw-r--r--   0     1001      123      137 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/series/implementations/duration.rs
--rw-r--r--   0     1001      123     1744 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/series/implementations/floats.rs
--rw-r--r--   0     1001      123     1673 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/series/implementations/integers.rs
--rw-r--r--   0     1001      123      133 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/series/implementations/list.rs
--rw-r--r--   0     1001      123      486 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/series/implementations/mod.rs
--rw-r--r--   0     1001      123      155 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/series/implementations/object.rs
--rw-r--r--   0     1001      123      135 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/series/implementations/struct_.rs
--rw-r--r--   0     1001      123      133 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/series/implementations/time.rs
--rw-r--r--   0     1001      123      133 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/series/implementations/utf8.rs
--rw-r--r--   0     1001      123    12791 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/series/mod.rs
--rw-r--r--   0     1001      123     2044 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/truncate.rs
--rw-r--r--   0     1001      123     7619 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/upsample.rs
--rw-r--r--   0     1001      123     3113 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/utils.rs
--rw-r--r--   0     1001      123     1524 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/windows/bounds.rs
--rw-r--r--   0     1001      123     2672 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/windows/calendar.rs
--rw-r--r--   0     1001      123    26124 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/windows/duration.rs
--rw-r--r--   0     1001      123    20201 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/windows/groupby.rs
--rw-r--r--   0     1001      123      503 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/windows/mod.rs
--rw-r--r--   0     1001      123    23627 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/windows/test.rs
--rw-r--r--   0     1001      123    10954 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/windows/window.rs
--rw-r--r--   0        0        0      899 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-error/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-error/LICENSE
--rw-r--r--   0     1001      123      145 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-error/README.md
--rw-r--r--   0     1001      123     7602 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-error/src/lib.rs
--rw-r--r--   0     1001      123      877 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-error/src/warning.rs
--rw-r--r--   0        0        0     4438 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/LICENSE
--rw-r--r--   0     1001      123      138 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/README.md
--rw-r--r--   0     1001      123     2383 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/avro/mod.rs
--rw-r--r--   0     1001      123     3608 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/avro/read.rs
--rw-r--r--   0     1001      123     2622 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/avro/write.rs
--rw-r--r--   0     1001      123     4505 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/cloud/adaptors.rs
--rw-r--r--   0     1001      123     9506 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/cloud/glob.rs
--rw-r--r--   0     1001      123     3089 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/cloud/mod.rs
--rw-r--r--   0     1001      123    28829 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/csv/buffer.rs
--rw-r--r--   0     1001      123     1815 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/csv/mod.rs
--rw-r--r--   0     1001      123    19446 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/csv/parser.rs
--rw-r--r--   0     1001      123    22228 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/csv/read.rs
--rw-r--r--   0     1001      123    10847 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/csv/read_impl/batched_mmap.rs
--rw-r--r--   0     1001      123    13939 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/csv/read_impl/batched_read.rs
--rw-r--r--   0     1001      123    30724 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/csv/read_impl/mod.rs
--rw-r--r--   0     1001      123    11466 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/csv/splitfields.rs
--rw-r--r--   0     1001      123    25561 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/csv/utils.rs
--rw-r--r--   0     1001      123     2796 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/csv/write.rs
--rw-r--r--   0     1001      123    14759 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/csv/write_impl.rs
--rw-r--r--   0     1001      123      184 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/export.rs
--rw-r--r--   0     1001      123     7586 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/ipc/ipc_file.rs
--rw-r--r--   0     1001      123     9227 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/ipc/ipc_stream.rs
--rw-r--r--   0     1001      123     3253 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/ipc/mmap.rs
--rw-r--r--   0     1001      123      401 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/ipc/mod.rs
--rw-r--r--   0     1001      123     8287 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/ipc/write.rs
--rw-r--r--   0     1001      123     1471 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/ipc/write_async.rs
--rw-r--r--   0     1001      123    13383 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/json/mod.rs
--rw-r--r--   0     1001      123     4771 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/lib.rs
--rw-r--r--   0     1001      123     1969 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/mmap.rs
--rw-r--r--   0     1001      123     7743 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/ndjson/buffer.rs
--rw-r--r--   0     1001      123    12607 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/ndjson/core.rs
--rw-r--r--   0     1001      123       37 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/ndjson/mod.rs
--rw-r--r--   0     1001      123      273 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/options.rs
--rw-r--r--   0     1001      123     7360 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/parquet/async_impl.rs
--rw-r--r--   0     1001      123     3093 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/parquet/mmap.rs
--rw-r--r--   0     1001      123     3132 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/parquet/mod.rs
--rw-r--r--   0     1001      123     4784 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/parquet/predicates.rs
--rw-r--r--   0     1001      123     9623 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/parquet/read.rs
--rw-r--r--   0     1001      123    17321 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/parquet/read_impl.rs
--rw-r--r--   0     1001      123    10129 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/parquet/write.rs
--rw-r--r--   0     1001      123     5499 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/partition.rs
--rw-r--r--   0     1001      123     1455 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/predicates.rs
--rw-r--r--   0     1001      123      621 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/prelude.rs
--rw-r--r--   0     1001      123      417 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/tests.rs
--rw-r--r--   0     1001      123     4632 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/utils.rs
--rw-r--r--   0        0        0     1359 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-json/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-json/LICENSE
--rw-r--r--   0     1001      123    16461 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-json/src/json/deserialize.rs
--rw-r--r--   0     1001      123     6564 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-json/src/json/infer_schema.rs
--rw-r--r--   0     1001      123      189 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-json/src/json/mod.rs
--rw-r--r--   0     1001      123       30 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-json/src/lib.rs
--rw-r--r--   0     1001      123     1198 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-json/src/ndjson/deserialize.rs
--rw-r--r--   0     1001      123     4808 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-json/src/ndjson/file.rs
--rw-r--r--   0     1001      123      143 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-json/src/ndjson/mod.rs
--rw-r--r--   0        0        0      960 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-row/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-row/LICENSE
--rw-r--r--   0     1001      123      137 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-row/README.md
--rw-r--r--   0     1001      123     2377 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-row/src/decode.rs
--rw-r--r--   0     1001      123    14130 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-row/src/encode.rs
--rw-r--r--   0     1001      123     7767 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-row/src/fixed.rs
--rw-r--r--   0     1001      123    13846 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-row/src/lib.rs
--rw-r--r--   0     1001      123     3019 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-row/src/row.rs
--rw-r--r--   0     1001      123      682 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-row/src/utils.rs
--rw-r--r--   0     1001      123     8702 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-row/src/variable.rs
--rw-r--r--   0        0        0     1106 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-sql/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-sql/LICENSE
--rw-r--r--   0     1001      123      466 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-sql/README.md
--rw-r--r--   0     1001      123    23380 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-sql/src/context.rs
--rw-r--r--   0     1001      123    29575 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-sql/src/functions.rs
--rw-r--r--   0     1001      123     2122 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-sql/src/keywords.rs
--rw-r--r--   0     1001      123      239 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-sql/src/lib.rs
--rw-r--r--   0     1001      123    21602 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-sql/src/sql_expr.rs
--rw-r--r--   0     1001      123     4572 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-sql/src/table_functions.rs
--rw-r--r--   0     1001      123     1682 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/functions_cumulative.rs
--rw-r--r--   0     1001      123     3063 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/functions_io.rs
--rw-r--r--   0     1001      123     1843 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/functions_math.rs
--rw-r--r--   0     1001      123      860 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/functions_meta.rs
--rw-r--r--   0     1001      123     2982 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/functions_string.rs
--rw-r--r--   0     1001      123     1056 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/iss_7436.rs
--rw-r--r--   0     1001      123      902 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/iss_7437.rs
--rw-r--r--   0     1001      123      652 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/iss_7440.rs
--rw-r--r--   0     1001      123      700 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/iss_8395.rs
--rw-r--r--   0     1001      123     1062 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/iss_8419.rs
--rw-r--r--   0     1001      123     1001 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/ops_distinct_on.rs
--rw-r--r--   0     1001      123    15921 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/simple_exprs.rs
--rw-r--r--   0     1001      123     3976 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/statements.rs
--rw-r--r--   0        0        0     5509 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/LICENSE
--rw-r--r--   0     1001      123      144 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/README.md
--rw-r--r--   0     1001      123     5158 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/arithmetic/decimal.rs
--rw-r--r--   0     1001      123     8275 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/arithmetic/mod.rs
--rw-r--r--   0     1001      123     9417 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/arithmetic/numeric.rs
--rw-r--r--   0     1001      123     3588 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/array/iterator.rs
--rw-r--r--   0     1001      123     2551 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/array/mod.rs
--rw-r--r--   0     1001      123     6448 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/bitwise.rs
--rw-r--r--   0     1001      123     2298 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/binary.rs
--rw-r--r--   0     1001      123     1258 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/boolean.rs
--rw-r--r--   0     1001      123     4311 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/fixed_size_list.rs
--rw-r--r--   0     1001      123     1556 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/from.rs
--rw-r--r--   0     1001      123     5762 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/list/anonymous.rs
--rw-r--r--   0     1001      123     4418 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/list/binary.rs
--rw-r--r--   0     1001      123     2374 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/list/boolean.rs
--rw-r--r--   0     1001      123     1392 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/list/categorical.rs
--rw-r--r--   0     1001      123     1575 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/list/dtypes.rs
--rw-r--r--   0     1001      123     4953 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/list/mod.rs
--rw-r--r--   0     1001      123     3506 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/list/primitive.rs
--rw-r--r--   0     1001      123     8996 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/mod.rs
--rw-r--r--   0     1001      123     1461 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/primitive.rs
--rw-r--r--   0     1001      123     2342 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/utf8.rs
--rw-r--r--   0     1001      123    17014 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/cast.rs
--rw-r--r--   0     1001      123    50941 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/comparison/mod.rs
--rw-r--r--   0     1001      123    10096 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/comparison/scalar.rs
--rw-r--r--   0     1001      123      551 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/drop.rs
--rw-r--r--   0     1001      123      963 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/float.rs
--rw-r--r--   0     1001      123     7945 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/from.rs
--rw-r--r--   0     1001      123    42339 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/iterator/mod.rs
--rw-r--r--   0     1001      123     1453 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/iterator/par/list.rs
--rw-r--r--   0     1001      123       28 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/iterator/par/mod.rs
--rw-r--r--   0     1001      123     1129 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/iterator/par/utf8.rs
--rw-r--r--   0     1001      123       21 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/kernels/mod.rs
--rw-r--r--   0     1001      123     2347 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/kernels/take.rs
--rw-r--r--   0     1001      123     7990 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/list/iterator.rs
--rw-r--r--   0     1001      123     3242 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/list/mod.rs
--rw-r--r--   0     1001      123    19962 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/categorical/builder.rs
--rw-r--r--   0     1001      123     3688 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/categorical/from.rs
--rw-r--r--   0     1001      123     5693 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/categorical/merge.rs
--rw-r--r--   0     1001      123    10219 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/categorical/mod.rs
--rw-r--r--   0     1001      123     1263 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/append.rs
--rw-r--r--   0     1001      123      358 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/full.rs
--rw-r--r--   0     1001      123      192 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/mod.rs
--rw-r--r--   0     1001      123     2731 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/take_random.rs
--rw-r--r--   0     1001      123     2179 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/unique.rs
--rw-r--r--   0     1001      123      925 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/zip.rs
--rw-r--r--   0     1001      123     6805 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/categorical/stringcache.rs
--rw-r--r--   0     1001      123     1604 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/date.rs
--rw-r--r--   0     1001      123     4105 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/datetime.rs
--rw-r--r--   0     1001      123     4443 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/decimal.rs
--rw-r--r--   0     1001      123     2434 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/duration.rs
--rw-r--r--   0     1001      123     2556 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/mod.rs
--rw-r--r--   0     1001      123      476 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/struct_/from.rs
--rw-r--r--   0     1001      123    15983 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/struct_/mod.rs
--rw-r--r--   0     1001      123     1182 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/time.rs
--rw-r--r--   0     1001      123    23309 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/mod.rs
--rw-r--r--   0     1001      123     9064 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ndarray.rs
--rw-r--r--   0     1001      123     4484 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/object/builder.rs
--rw-r--r--   0     1001      123     1547 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/object/extension/drop.rs
--rw-r--r--   0     1001      123     3097 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/object/extension/list.rs
--rw-r--r--   0     1001      123     7054 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/object/extension/mod.rs
--rw-r--r--   0     1001      123     3410 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/object/extension/polars_extension.rs
--rw-r--r--   0     1001      123      137 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/object/is_valid.rs
--rw-r--r--   0     1001      123     4419 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/object/iterator.rs
--rw-r--r--   0     1001      123     4806 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/object/mod.rs
--rw-r--r--   0     1001      123     2956 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/object/registry.rs
--rw-r--r--   0     1001      123      272 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/abs.rs
--rw-r--r--   0     1001      123    32918 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/aggregate/mod.rs
--rw-r--r--   0     1001      123    10025 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/aggregate/quantile.rs
--rw-r--r--   0     1001      123     2880 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/aggregate/var.rs
--rw-r--r--   0     1001      123    10551 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/any_value.rs
--rw-r--r--   0     1001      123     4526 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/append.rs
--rw-r--r--   0     1001      123    28257 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/apply.rs
--rw-r--r--   0     1001      123    12799 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/bit_repr.rs
--rw-r--r--   0     1001      123     6332 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/chunkops.rs
--rw-r--r--   0     1001      123    11537 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/compare_inner.rs
--rw-r--r--   0     1001      123     1737 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/concat_str.rs
--rw-r--r--   0     1001      123     4801 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/cum_agg.rs
--rw-r--r--   0     1001      123      908 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/decimal.rs
--rw-r--r--   0     1001      123     7056 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/downcast.rs
--rw-r--r--   0     1001      123    20007 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/explode.rs
--rw-r--r--   0     1001      123     8691 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/explode_and_offsets.rs
--rw-r--r--   0     1001      123     9103 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/extend.rs
--rw-r--r--   0     1001      123    13777 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/fill_null.rs
--rw-r--r--   0     1001      123     6356 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/filter.rs
--rw-r--r--   0     1001      123     5886 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/full.rs
--rw-r--r--   0     1001      123        1 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/interpolate.rs
--rw-r--r--   0     1001      123    16797 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/is_in.rs
--rw-r--r--   0     1001      123        1 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/len.rs
--rw-r--r--   0     1001      123     2658 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/min_max_binary.rs
--rw-r--r--   0     1001      123    23364 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/mod.rs
--rw-r--r--   0     1001      123     2414 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/nulls.rs
--rw-r--r--   0     1001      123      593 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/peaks.rs
--rw-r--r--   0     1001      123     4375 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/repeat_by.rs
--rw-r--r--   0     1001      123     2771 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/reverse.rs
--rw-r--r--   0     1001      123    10267 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/rolling_window.rs
--rw-r--r--   0     1001      123    12518 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/set.rs
--rw-r--r--   0     1001      123     7391 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/shift.rs
--rw-r--r--   0     1001      123     2299 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/sort/arg_sort.rs
--rw-r--r--   0     1001      123     5522 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/sort/arg_sort_multiple.rs
--rw-r--r--   0     1001      123     7592 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/sort/categorical.rs
--rw-r--r--   0     1001      123    28481 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/sort/mod.rs
--rw-r--r--   0     1001      123      380 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/sort/slice.rs
--rw-r--r--   0     1001      123    22089 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/take/mod.rs
--rw-r--r--   0     1001      123     7848 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/take/take_chunked.rs
--rw-r--r--   0     1001      123      301 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/take/take_every.rs
--rw-r--r--   0     1001      123    16256 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/take/take_random.rs
--rw-r--r--   0     1001      123     6275 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/take/take_single.rs
--rw-r--r--   0     1001      123     6072 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/take/traits.rs
--rw-r--r--   0     1001      123      459 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/tile.rs
--rw-r--r--   0     1001      123    12251 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/unique/mod.rs
--rw-r--r--   0     1001      123    14620 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/unique/rank.rs
--rw-r--r--   0     1001      123     5846 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/zip.rs
--rw-r--r--   0     1001      123     9093 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/random.rs
--rw-r--r--   0     1001      123     1875 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/temporal/conversion.rs
--rw-r--r--   0     1001      123     2826 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/temporal/date.rs
--rw-r--r--   0     1001      123    10336 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/temporal/datetime.rs
--rw-r--r--   0     1001      123     3201 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/temporal/duration.rs
--rw-r--r--   0     1001      123     1061 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/temporal/mod.rs
--rw-r--r--   0     1001      123     3042 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/temporal/time.rs
--rw-r--r--   0     1001      123      872 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/to_vec.rs
--rw-r--r--   0     1001      123     8114 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/trusted_len.rs
--rw-r--r--   0     1001      123    25856 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/upstream_traits.rs
--rw-r--r--   0     1001      123     7955 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/cloud.rs
--rw-r--r--   0     1001      123     1549 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/config.rs
--rw-r--r--   0     1001      123     4497 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/datatypes/_serde.rs
--rw-r--r--   0     1001      123     2509 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/datatypes/aliases.rs
--rw-r--r--   0     1001      123    42659 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/datatypes/any_value.rs
--rw-r--r--   0     1001      123    13376 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/datatypes/dtype.rs
--rw-r--r--   0     1001      123     5609 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/datatypes/field.rs
--rw-r--r--   0     1001      123     8059 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/datatypes/mod.rs
--rw-r--r--   0     1001      123     2016 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/datatypes/time_unit.rs
--rw-r--r--   0     1001      123      118 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/doc/changelog/mod.rs
--rw-r--r--   0     1001      123      898 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/doc/changelog/v0_10_0_11.rs
--rw-r--r--   0     1001      123      481 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/doc/changelog/v0_3.rs
--rw-r--r--   0     1001      123      293 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/doc/changelog/v0_4.rs
--rw-r--r--   0     1001      123      499 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/doc/changelog/v0_5.rs
--rw-r--r--   0     1001      123      288 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/doc/changelog/v0_6.rs
--rw-r--r--   0     1001      123     1071 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/doc/changelog/v0_7.rs
--rw-r--r--   0     1001      123      819 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/doc/changelog/v0_8.rs
--rw-r--r--   0     1001      123      596 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/doc/changelog/v0_9.rs
--rw-r--r--   0     1001      123       43 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/doc/mod.rs
--rw-r--r--   0     1001      123       25 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/error.rs
--rw-r--r--   0     1001      123      263 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/export.rs
--rw-r--r--   0     1001      123    38812 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/fmt.rs
--rw-r--r--   0     1001      123     5177 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/arithmetic.rs
--rw-r--r--   0     1001      123     9916 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/asof_join/asof.rs
--rw-r--r--   0     1001      123    35734 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/asof_join/groups.rs
--rw-r--r--   0     1001      123     7168 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/asof_join/mod.rs
--rw-r--r--   0     1001      123      559 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/chunks.rs
--rw-r--r--   0     1001      123     5181 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/cross_join.rs
--rw-r--r--   0     1001      123    16744 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/explode.rs
--rw-r--r--   0     1001      123     1019 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/from.rs
--rw-r--r--   0     1001      123    19239 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/groupby/aggregations/agg_list.rs
--rw-r--r--   0     1001      123     4113 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/groupby/aggregations/boolean.rs
--rw-r--r--   0     1001      123     7749 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/groupby/aggregations/dispatch.rs
--rw-r--r--   0     1001      123    41956 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/groupby/aggregations/mod.rs
--rw-r--r--   0     1001      123     5634 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/groupby/aggregations/utf8.rs
--rw-r--r--   0     1001      123      218 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/groupby/expr.rs
--rw-r--r--   0     1001      123    22901 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/groupby/hashing.rs
--rw-r--r--   0     1001      123    14380 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/groupby/into_groups.rs
--rw-r--r--   0     1001      123    39630 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/groupby/mod.rs
--rw-r--r--   0     1001      123    10637 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/groupby/perfect.rs
--rw-r--r--   0     1001      123    19780 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/groupby/proxy.rs
--rw-r--r--   0     1001      123     5416 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/hash_join/args.rs
--rw-r--r--   0     1001      123    13204 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/hash_join/mod.rs
--rw-r--r--   0     1001      123    22364 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/hash_join/multiple_keys.rs
--rw-r--r--   0     1001      123     2400 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/hash_join/single_keys.rs
--rw-r--r--   0     1001      123    17372 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/hash_join/single_keys_dispatch.rs
--rw-r--r--   0     1001      123     4677 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/hash_join/single_keys_inner.rs
--rw-r--r--   0     1001      123     6502 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/hash_join/single_keys_left.rs
--rw-r--r--   0     1001      123     4665 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/hash_join/single_keys_outer.rs
--rw-r--r--   0     1001      123     3913 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/hash_join/single_keys_semi_anti.rs
--rw-r--r--   0     1001      123    12430 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/hash_join/sort_merge.rs
--rw-r--r--   0     1001      123     3865 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/hash_join/zip_outer.rs
--rw-r--r--   0     1001      123   126958 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/mod.rs
--rw-r--r--   0     1001      123    27652 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/row/av_buffer.rs
--rw-r--r--   0     1001      123     5183 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/row/dataframe.rs
--rw-r--r--   0     1001      123     6036 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/row/mod.rs
--rw-r--r--   0     1001      123    10145 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/row/transpose.rs
--rw-r--r--   0     1001      123     3129 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/top_k.rs
--rw-r--r--   0     1001      123     1388 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/upstream_traits.rs
--rw-r--r--   0     1001      123    10198 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/functions.rs
--rw-r--r--   0     1001      123     2149 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/hashing/fx.rs
--rw-r--r--   0     1001      123     1503 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/hashing/identity.rs
--rw-r--r--   0     1001      123      457 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/hashing/mod.rs
--rw-r--r--   0     1001      123     2684 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/hashing/partition.rs
--rw-r--r--   0     1001      123    17704 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/hashing/vector_hasher.rs
--rw-r--r--   0     1001      123     1896 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/lib.rs
--rw-r--r--   0     1001      123    15763 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/named_from.rs
--rw-r--r--   0     1001      123     2522 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/prelude.rs
--rw-r--r--   0     1001      123    18589 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/schema.rs
--rw-r--r--   0     1001      123     3995 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/serde/chunked_array.rs
--rw-r--r--   0     1001      123     1094 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/serde/df.rs
--rw-r--r--   0     1001      123     4734 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/serde/mod.rs
--rw-r--r--   0     1001      123     9938 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/serde/series.rs
--rw-r--r--   0     1001      123    18543 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/any_value.rs
--rw-r--r--   0     1001      123    28755 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/arithmetic/borrowed.rs
--rw-r--r--   0     1001      123      222 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/arithmetic/mod.rs
--rw-r--r--   0     1001      123     3546 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/arithmetic/owned.rs
--rw-r--r--   0     1001      123    19293 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/comparison.rs
--rw-r--r--   0     1001      123    29865 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/from.rs
--rw-r--r--   0     1001      123     6098 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/array.rs
--rw-r--r--   0     1001      123     9089 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/binary.rs
--rw-r--r--   0     1001      123    10835 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/boolean.rs
--rw-r--r--   0     1001      123    12800 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/categorical.rs
--rw-r--r--   0     1001      123    18214 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/dates_time.rs
--rw-r--r--   0     1001      123    15034 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/datetime.rs
--rw-r--r--   0     1001      123     8014 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/decimal.rs
--rw-r--r--   0     1001      123    14734 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/duration.rs
--rw-r--r--   0     1001      123    14063 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/floats.rs
--rw-r--r--   0     1001      123     6078 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/list.rs
--rw-r--r--   0     1001      123    18396 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/mod.rs
--rw-r--r--   0     1001      123     5522 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/null.rs
--rw-r--r--   0     1001      123     7939 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/object.rs
--rw-r--r--   0     1001      123    11828 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/struct_.rs
--rw-r--r--   0     1001      123     9607 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/utf8.rs
--rw-r--r--   0     1001      123     4471 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/into.rs
--rw-r--r--   0     1001      123     6581 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/iterator.rs
--rw-r--r--   0     1001      123    39074 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/mod.rs
--rw-r--r--   0     1001      123      853 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/ops/diff.rs
--rw-r--r--   0     1001      123     5814 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/ops/downcast.rs
--rw-r--r--   0     1001      123     3601 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/ops/ewm.rs
--rw-r--r--   0     1001      123      413 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/ops/extend.rs
--rw-r--r--   0     1001      123      562 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/ops/mod.rs
--rw-r--r--   0     1001      123     5992 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/ops/moment.rs
--rw-r--r--   0     1001      123     3390 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/ops/null.rs
--rw-r--r--   0     1001      123     1347 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/ops/pct_change.rs
--rw-r--r--   0     1001      123     4620 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/ops/round.rs
--rw-r--r--   0     1001      123     5091 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/ops/to_list.rs
--rw-r--r--   0     1001      123     1476 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/ops/unique.rs
--rw-r--r--   0     1001      123    18534 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/series_trait.rs
--rw-r--r--   0     1001      123     2912 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/unstable.rs
--rw-r--r--   0     1001      123     7046 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/testing.rs
--rw-r--r--   0     1001      123      508 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/tests.rs
--rw-r--r--   0     1001      123     2492 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/utils/flatten.rs
--rw-r--r--   0     1001      123    31194 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/utils/mod.rs
--rw-r--r--   0     1001      123     1600 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/utils/series.rs
--rw-r--r--   0     1001      123    13201 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/utils/supertype.rs
--rw-r--r--   0        0        0    10781 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/LICENSE
--rw-r--r--   0     1001      123     3722 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/Makefile
--rw-r--r--   0     1001      123      215 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/build.rs
--rw-r--r--   0     1001      123       78 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/clippy.toml
--rw-r--r--   0     1001      123    17620 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/src/docs/eager.rs
--rw-r--r--   0     1001      123     8822 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/src/docs/lazy.rs
--rw-r--r--   0     1001      123       50 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/src/docs/mod.rs
--rw-r--r--   0     1001      123     3806 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/src/docs/performance.rs
--rw-r--r--   0     1001      123       59 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/src/export.rs
--rw-r--r--   0     1001      123    19848 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/src/lib.rs
--rw-r--r--   0     1001      123      387 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/src/prelude.rs
--rw-r--r--   0     1001      123       54 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/src/sql.rs
--rw-r--r--   0     1001      123     4243 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/core/date_like.rs
--rw-r--r--   0     1001      123     2401 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/core/groupby.rs
--rw-r--r--   0     1001      123    17838 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/core/joins.rs
--rw-r--r--   0     1001      123      545 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/core/list.rs
--rw-r--r--   0     1001      123      198 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/core/mod.rs
--rw-r--r--   0     1001      123       24 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/core/ops/mod.rs
--rw-r--r--   0     1001      123      449 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/core/ops/take.rs
--rw-r--r--   0     1001      123     6259 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/core/pivot.rs
--rw-r--r--   0     1001      123     1102 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/core/random.rs
--rw-r--r--   0     1001      123    10952 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/core/rolling_window.rs
--rw-r--r--   0     1001      123     1093 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/core/series.rs
--rw-r--r--   0     1001      123      370 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/core/utils.rs
--rw-r--r--   0     1001      123    30377 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/io/csv.rs
--rw-r--r--   0     1001      123     4500 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/io/ipc_stream.rs
--rw-r--r--   0     1001      123     6972 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/io/json.rs
--rw-r--r--   0     1001      123      378 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/io/mod.rs
--rw-r--r--   0     1001      123      531 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/io/parquet.rs
--rw-r--r--   0     1001      123     1530 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/joins.rs
--rw-r--r--   0     1001      123     2452 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/aggregation.rs
--rw-r--r--   0     1001      123      839 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/cse.rs
--rw-r--r--   0     1001      123      500 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/explodes.rs
--rw-r--r--   0     1001      123     2281 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/expressions/apply.rs
--rw-r--r--   0     1001      123    10351 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/expressions/arity.rs
--rw-r--r--   0     1001      123     1065 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/expressions/expand.rs
--rw-r--r--   0     1001      123     1008 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/expressions/filter.rs
--rw-r--r--   0     1001      123      428 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/expressions/is_in.rs
--rw-r--r--   0     1001      123      121 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/expressions/mod.rs
--rw-r--r--   0     1001      123      659 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/expressions/slice.rs
--rw-r--r--   0     1001      123    10655 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/expressions/window.rs
--rw-r--r--   0     1001      123      584 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/folds.rs
--rw-r--r--   0     1001      123      557 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/functions.rs
--rw-r--r--   0     1001      123     4485 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/groupby.rs
--rw-r--r--   0     1001      123     1681 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/groupby_dynamic.rs
--rw-r--r--   0     1001      123      691 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/mod.rs
--rw-r--r--   0     1001      123     6091 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/predicate_queries.rs
--rw-r--r--   0     1001      123     4482 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/projection_queries.rs
--rw-r--r--   0     1001      123     6585 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/queries.rs
--rw-r--r--   0     1001      123      151 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/main.rs
--rw-r--r--   0     1001      123    12591 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/schema.rs
--rw-r--r--   0     1001      123     1899 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/time/date_range.rs
--rw-r--r--   0     1001      123       16 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/time/mod.rs
--rw-r--r--   0        0        0     3597 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/LICENSE
--rw-r--r--   0     1001      123      132 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/README.md
--rw-r--r--   0     1001      123     2393 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/array/min_max.rs
--rw-r--r--   0     1001      123      267 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/array/mod.rs
--rw-r--r--   0     1001      123     1512 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/array/namespace.rs
--rw-r--r--   0     1001      123     4108 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/array/sum_mean.rs
--rw-r--r--   0     1001      123      234 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/binary/mod.rs
--rw-r--r--   0     1001      123     3549 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/binary/namespace.rs
--rw-r--r--   0     1001      123    11023 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/interpolate.rs
--rw-r--r--   0     1001      123     1941 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/list/any_all.rs
--rw-r--r--   0     1001      123     1687 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/list/count.rs
--rw-r--r--   0     1001      123     2419 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/list/hash.rs
--rw-r--r--   0     1001      123     7861 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/list/min_max.rs
--rw-r--r--   0     1001      123      644 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/list/mod.rs
--rw-r--r--   0     1001      123    19916 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/list/namespace.rs
--rw-r--r--   0     1001      123     9376 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/list/sets.rs
--rw-r--r--   0     1001      123     7633 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/list/sum_mean.rs
--rw-r--r--   0     1001      123     2435 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/list/to_struct.rs
--rw-r--r--   0     1001      123      545 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/mod.rs
--rw-r--r--   0     1001      123     9452 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/nan_propagating_aggregate.rs
--rw-r--r--   0     1001      123     6795 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/set.rs
--rw-r--r--   0     1001      123     8781 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/strings/case.rs
--rw-r--r--   0     1001      123     8593 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/strings/json_path.rs
--rw-r--r--   0     1001      123     2345 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/strings/justify.rs
--rw-r--r--   0     1001      123      514 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/strings/mod.rs
--rw-r--r--   0     1001      123    14951 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/strings/namespace.rs
--rw-r--r--   0     1001      123     4053 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/strings/replace.rs
--rw-r--r--   0     1001      123      439 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/sum.rs
--rw-r--r--   0     1001      123     2486 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/top_k.rs
--rw-r--r--   0     1001      123     7727 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/frame/join/merge_sorted.rs
--rw-r--r--   0     1001      123    18232 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/frame/join/mod.rs
--rw-r--r--   0     1001      123     4291 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/frame/mod.rs
--rw-r--r--   0     1001      123    10257 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/frame/pivot/mod.rs
--rw-r--r--   0     1001      123    13486 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/frame/pivot/positioning.rs
--rw-r--r--   0     1001      123      237 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/lib.rs
--rw-r--r--   0     1001      123      290 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/prelude.rs
--rw-r--r--   0     1001      123       25 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/mod.rs
--rw-r--r--   0     1001      123     9623 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/approx_algo/hyperloglogplus.rs
--rw-r--r--   0     1001      123      118 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/approx_algo/mod.rs
--rw-r--r--   0     1001      123     2016 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/approx_unique.rs
--rw-r--r--   0     1001      123    11866 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/arg_min_max.rs
--rw-r--r--   0     1001      123     5129 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/cut.rs
--rw-r--r--   0     1001      123     3688 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/floor_divide.rs
--rw-r--r--   0     1001      123     5245 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/fused.rs
--rw-r--r--   0     1001      123     3423 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/is_first.rs
--rw-r--r--   0     1001      123     2975 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/is_unique.rs
--rw-r--r--   0     1001      123     3626 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/log.rs
--rw-r--r--   0     1001      123     1341 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/mod.rs
--rw-r--r--   0     1001      123     1342 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/rle.rs
--rw-r--r--   0     1001      123     1769 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/rolling.rs
--rw-r--r--   0     1001      123     7642 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/search_sorted.rs
--rw-r--r--   0     1001      123     2603 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/to_dummies.rs
--rw-r--r--   0     1001      123     3039 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/various.rs
--rw-r--r--   0        0        0      827 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-algo/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-algo/LICENSE
--rw-r--r--   0     1001      123      142 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-algo/README.md
--rw-r--r--   0     1001      123     3503 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-algo/src/algo.rs
--rw-r--r--   0     1001      123       88 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-algo/src/lib.rs
--rw-r--r--   0     1001      123       21 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-algo/src/prelude.rs
--rw-r--r--   0        0        0     6330 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/LICENSE
--rw-r--r--   0     1001      123      358 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/README.md
--rw-r--r--   0     1001      123     1796 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/dot.rs
--rw-r--r--   0     1001      123     4479 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/dsl/eval.rs
--rw-r--r--   0     1001      123     7115 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/dsl/functions.rs
--rw-r--r--   0     1001      123      164 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/dsl/into.rs
--rw-r--r--   0     1001      123     6756 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/dsl/list.rs
--rw-r--r--   0     1001      123     2899 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/dsl/mod.rs
--rw-r--r--   0     1001      123     1182 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/frame/anonymous_scan.rs
--rw-r--r--   0     1001      123     9285 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/frame/csv.rs
--rw-r--r--   0     1001      123      476 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/frame/err.rs
--rw-r--r--   0     1001      123     4368 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/frame/file_list_reader.rs
--rw-r--r--   0     1001      123     2231 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/frame/ipc.rs
--rw-r--r--   0     1001      123    49004 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/frame/mod.rs
--rw-r--r--   0     1001      123     3382 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/frame/ndjson.rs
--rw-r--r--   0     1001      123     2734 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/frame/parquet.rs
--rw-r--r--   0     1001      123     2892 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/frame/pivot.rs
--rw-r--r--   0     1001      123      459 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/frame/python.rs
--rw-r--r--   0     1001      123     6374 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/lib.rs
--rw-r--r--   0     1001      123     1049 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/cache.rs
--rw-r--r--   0     1001      123      776 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/executor.rs
--rw-r--r--   0     1001      123      670 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/ext_context.rs
--rw-r--r--   0     1001      123     1555 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/filter.rs
--rw-r--r--   0     1001      123     3986 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/groupby.rs
--rw-r--r--   0     1001      123     4125 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_dynamic.rs
--rw-r--r--   0     1001      123    13599 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_partitioned.rs
--rw-r--r--   0     1001      123     4883 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_rolling.rs
--rw-r--r--   0     1001      123     5859 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/join.rs
--rw-r--r--   0     1001      123     6753 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/mod.rs
--rw-r--r--   0     1001      123     2050 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/projection.rs
--rw-r--r--   0     1001      123     1761 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/python_scan.rs
--rw-r--r--   0     1001      123     2971 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/scan/csv.rs
--rw-r--r--   0     1001      123     2085 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/scan/ipc.rs
--rw-r--r--   0     1001      123     4353 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/scan/mod.rs
--rw-r--r--   0     1001      123     1208 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/scan/ndjson.rs
--rw-r--r--   0     1001      123     2650 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/scan/parquet.rs
--rw-r--r--   0     1001      123      548 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/slice.rs
--rw-r--r--   0     1001      123     2235 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/sort.rs
--rw-r--r--   0     1001      123     2015 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/stack.rs
--rw-r--r--   0     1001      123      663 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/udf.rs
--rw-r--r--   0     1001      123     4041 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/union.rs
--rw-r--r--   0     1001      123      838 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/unique.rs
--rw-r--r--   0     1001      123     1335 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/exotic.rs
--rw-r--r--   0     1001      123    21959 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/aggregation.rs
--rw-r--r--   0     1001      123     2689 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/alias.rs
--rw-r--r--   0     1001      123    18581 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/apply.rs
--rw-r--r--   0     1001      123    17674 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/binary.rs
--rw-r--r--   0     1001      123     2583 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/cache.rs
--rw-r--r--   0     1001      123     3153 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/cast.rs
--rw-r--r--   0     1001      123     6326 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/column.rs
--rw-r--r--   0     1001      123     1996 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/count.rs
--rw-r--r--   0     1001      123     5809 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/filter.rs
--rw-r--r--   0     1001      123     4643 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/group_iter.rs
--rw-r--r--   0     1001      123     5304 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/literal.rs
--rw-r--r--   0     1001      123    23569 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/mod.rs
--rw-r--r--   0     1001      123    10091 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/slice.rs
--rw-r--r--   0     1001      123     4332 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/sort.rs
--rw-r--r--   0     1001      123    13549 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/sortby.rs
--rw-r--r--   0     1001      123     8331 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/take.rs
--rw-r--r--   0     1001      123    14360 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/ternary.rs
--rw-r--r--   0     1001      123    31970 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/window.rs
--rw-r--r--   0     1001      123     2039 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/file_cache.rs
--rw-r--r--   0     1001      123      414 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/mod.rs
--rw-r--r--   0     1001      123     2046 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/node_timer.rs
--rw-r--r--   0     1001      123    24174 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/planner/expr.rs
--rw-r--r--   0     1001      123    19892 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/planner/lp.rs
--rw-r--r--   0     1001      123       87 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/planner/mod.rs
--rw-r--r--   0     1001      123    10203 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/state.rs
--rw-r--r--   0     1001      123     2901 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/streaming/checks.rs
--rw-r--r--   0     1001      123     9280 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/streaming/construct_pipeline.rs
--rw-r--r--   0     1001      123    17011 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/streaming/convert_alp.rs
--rw-r--r--   0     1001      123      116 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/streaming/mod.rs
--rw-r--r--   0     1001      123     5827 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/streaming/tree.rs
--rw-r--r--   0     1001      123      722 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/prelude.rs
--rw-r--r--   0     1001      123    15189 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/aggregations.rs
--rw-r--r--   0     1001      123     2339 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/arity.rs
--rw-r--r--   0     1001      123     7224 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/cse.rs
--rw-r--r--   0     1001      123    12736 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/io.rs
--rw-r--r--   0     1001      123     4166 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/logical.rs
--rw-r--r--   0     1001      123     4273 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/mod.rs
--rw-r--r--   0     1001      123    15027 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/optimization_checks.rs
--rw-r--r--   0     1001      123     6739 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/predicate_queries.rs
--rw-r--r--   0     1001      123     3153 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/projection_queries.rs
--rw-r--r--   0     1001      123    48167 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/queries.rs
--rw-r--r--   0     1001      123     9970 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/streaming.rs
--rw-r--r--   0     1001      123     2904 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/tpch.rs
--rw-r--r--   0     1001      123      717 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/utils.rs
--rw-r--r--   0        0        0     1998 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/LICENSE
--rw-r--r--   0     1001      123      165 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/README.md
--rw-r--r--   0     1001      123       98 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/mod.rs
--rw-r--r--   0     1001      123     1219 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/operators/filter.rs
--rw-r--r--   0     1001      123     4103 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/operators/function.rs
--rw-r--r--   0     1001      123      266 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/operators/mod.rs
--rw-r--r--   0     1001      123      682 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/operators/pass.rs
--rw-r--r--   0     1001      123      548 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/operators/placeholder.rs
--rw-r--r--   0     1001      123     3553 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/operators/projection.rs
--rw-r--r--   0     1001      123     3559 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/operators/reproject.rs
--rw-r--r--   0     1001      123     6479 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/file_sink.rs
--rw-r--r--   0     1001      123    11288 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/convert.rs
--rw-r--r--   0     1001      123     1207 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/count.rs
--rw-r--r--   0     1001      123     1888 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/first.rs
--rw-r--r--   0     1001      123     4554 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/interface.rs
--rw-r--r--   0     1001      123     1746 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/last.rs
--rw-r--r--   0     1001      123     5413 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/mean.rs
--rw-r--r--   0     1001      123     4951 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/min_max.rs
--rw-r--r--   0     1001      123      211 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/mod.rs
--rw-r--r--   0     1001      123      856 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/null.rs
--rw-r--r--   0     1001      123     4294 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/sum.rs
--rw-r--r--   0     1001      123     4109 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/eval.rs
--rw-r--r--   0     1001      123     7404 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/global.rs
--rw-r--r--   0     1001      123    10554 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/hash_table.rs
--rw-r--r--   0     1001      123     3589 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/mod.rs
--rw-r--r--   0     1001      123     2767 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/ooc_state.rs
--rw-r--r--   0     1001      123     6326 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/sink.rs
--rw-r--r--   0     1001      123     3116 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/source.rs
--rw-r--r--   0     1001      123    10194 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/thread_local.rs
--rw-r--r--   0     1001      123     2119 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/mod.rs
--rw-r--r--   0     1001      123     4695 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/ooc.rs
--rw-r--r--   0     1001      123     1887 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/ooc_state.rs
--rw-r--r--   0     1001      123    20783 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/primitive/mod.rs
--rw-r--r--   0     1001      123    23825 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/string.rs
--rw-r--r--   0     1001      123     2457 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/utils.rs
--rw-r--r--   0     1001      123     9239 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/io.rs
--rw-r--r--   0     1001      123     5451 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/joins/cross.rs
--rw-r--r--   0     1001      123    12056 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/joins/generic_build.rs
--rw-r--r--   0     1001      123    11845 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/joins/inner_left.rs
--rw-r--r--   0     1001      123      178 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/joins/mod.rs
--rw-r--r--   0     1001      123     2241 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/memory.rs
--rw-r--r--   0     1001      123      589 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/mod.rs
--rw-r--r--   0     1001      123     1492 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/ordered.rs
--rw-r--r--   0     1001      123     1824 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/reproject.rs
--rw-r--r--   0     1001      123     3108 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/slice.rs
--rw-r--r--   0     1001      123      130 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/sort/mod.rs
--rw-r--r--   0     1001      123     6848 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/sort/ooc.rs
--rw-r--r--   0     1001      123     7404 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/sort/sink.rs
--rw-r--r--   0     1001      123    11718 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/sort/sink_multiple.rs
--rw-r--r--   0     1001      123     3908 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/sort/source.rs
--rw-r--r--   0     1001      123      526 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/utils.rs
--rw-r--r--   0     1001      123     6208 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sources/csv.rs
--rw-r--r--   0     1001      123     1231 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sources/frame.rs
--rw-r--r--   0     1001      123      987 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sources/ipc_one_shot.rs
--rw-r--r--   0     1001      123      366 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sources/mod.rs
--rw-r--r--   0     1001      123     4569 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sources/parquet.rs
--rw-r--r--   0     1001      123     1146 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sources/reproject.rs
--rw-r--r--   0     1001      123     1022 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sources/union.rs
--rw-r--r--   0     1001      123      448 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/expressions.rs
--rw-r--r--   0     1001      123      272 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/lib.rs
--rw-r--r--   0     1001      123      719 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/operators/chunks.rs
--rw-r--r--   0     1001      123      474 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/operators/context.rs
--rw-r--r--   0     1001      123      223 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/operators/mod.rs
--rw-r--r--   0     1001      123      514 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/operators/operator.rs
--rw-r--r--   0     1001      123      626 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/operators/sink.rs
--rw-r--r--   0     1001      123      241 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/operators/source.rs
--rw-r--r--   0     1001      123        1 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/pipeline/config.rs
--rw-r--r--   0     1001      123    21076 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/pipeline/convert.rs
--rw-r--r--   0     1001      123    20362 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/pipeline/dispatcher.rs
--rw-r--r--   0     1001      123     1155 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/pipeline/mod.rs
--rw-r--r--   0        0        0     5455 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/LICENSE
--rw-r--r--   0     1001      123       45 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/constants.rs
--rw-r--r--   0     1001      123    16258 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dot.rs
--rw-r--r--   0     1001      123     5125 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/arithmetic.rs
--rw-r--r--   0     1001      123     3992 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/arity.rs
--rw-r--r--   0     1001      123     1278 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/array.rs
--rw-r--r--   0     1001      123      935 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/binary.rs
--rw-r--r--   0     1001      123      782 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/cat.rs
--rw-r--r--   0     1001      123    10625 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/dt.rs
--rw-r--r--   0     1001      123     9542 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/expr.rs
--rw-r--r--   0     1001      123     8359 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/expr_dyn_fn.rs
--rw-r--r--   0     1001      123      753 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/from.rs
--rw-r--r--   0     1001      123       85 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/abs.rs
--rw-r--r--   0     1001      123     1431 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/arg_where.rs
--rw-r--r--   0     1001      123     1074 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/array.rs
--rw-r--r--   0     1001      123     1327 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/binary.rs
--rw-r--r--   0     1001      123     4263 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/boolean.rs
--rw-r--r--   0     1001      123     1910 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/bounds.rs
--rw-r--r--   0     1001      123     1773 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/cat.rs
--rw-r--r--   0     1001      123      344 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/clip.rs
--rw-r--r--   0     1001      123      257 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/concat.rs
--rw-r--r--   0     1001      123     6125 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/correlation.rs
--rw-r--r--   0     1001      123     1593 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/cum.rs
--rw-r--r--   0     1001      123    11396 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/datetime.rs
--rw-r--r--   0     1001      123      939 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/dispatch.rs
--rw-r--r--   0     1001      123     2567 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/fill_null.rs
--rw-r--r--   0     1001      123      992 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/fused.rs
--rw-r--r--   0     1001      123     8997 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/list.rs
--rw-r--r--   0     1001      123      581 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/log.rs
--rw-r--r--   0     1001      123    26081 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/mod.rs
--rw-r--r--   0     1001      123      462 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/nan.rs
--rw-r--r--   0     1001      123     5028 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/pow.rs
--rw-r--r--   0     1001      123     1410 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/random.rs
--rw-r--r--   0     1001      123     5150 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/range.rs
--rw-r--r--   0     1001      123      152 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/rolling.rs
--rw-r--r--   0     1001      123      260 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/round.rs
--rw-r--r--   0     1001      123      200 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/row_hash.rs
--rw-r--r--   0     1001      123    19674 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/schema.rs
--rw-r--r--   0     1001      123      306 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/search_sorted.rs
--rw-r--r--   0     1001      123     3812 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/shift_and_fill.rs
--rw-r--r--   0     1001      123     1517 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/shrink_type.rs
--rw-r--r--   0     1001      123      972 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/sign.rs
--rw-r--r--   0     1001      123    22744 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/strings.rs
--rw-r--r--   0     1001      123     1017 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/struct_.rs
--rw-r--r--   0     1001      123     8934 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/temporal.rs
--rw-r--r--   0     1001      123     6112 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/trigonometry.rs
--rw-r--r--   0     1001      123      170 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/unique.rs
--rw-r--r--   0     1001      123     1155 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/functions/arity.rs
--rw-r--r--   0     1001      123      611 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/functions/coerce.rs
--rw-r--r--   0     1001      123     2717 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/functions/concat.rs
--rw-r--r--   0     1001      123     4525 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/functions/correlation.rs
--rw-r--r--   0     1001      123     8987 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/functions/horizontal.rs
--rw-r--r--   0     1001      123     1045 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/functions/index.rs
--rw-r--r--   0     1001      123      968 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/functions/mod.rs
--rw-r--r--   0     1001      123     4129 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/functions/range.rs
--rw-r--r--   0     1001      123     1308 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/functions/selectors.rs
--rw-r--r--   0     1001      123     1973 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/functions/syntactic_sugar.rs
--rw-r--r--   0     1001      123    11324 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/functions/temporal.rs
--rw-r--r--   0     1001      123    12280 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/list.rs
--rw-r--r--   0     1001      123     4501 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/meta.rs
--rw-r--r--   0     1001      123    61982 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/mod.rs
--rw-r--r--   0     1001      123       40 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/names.rs
--rw-r--r--   0     1001      123     2658 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/options.rs
--rw-r--r--   0     1001      123     7426 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/python_udf.rs
--rw-r--r--   0     1001      123     1432 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/random.rs
--rw-r--r--   0     1001      123     1068 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/selector.rs
--rw-r--r--   0     1001      123    17989 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/string.rs
--rw-r--r--   0     1001      123     2715 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/struct_.rs
--rw-r--r--   0     1001      123       38 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/frame/mod.rs
--rw-r--r--   0     1001      123      940 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/frame/opt_state.rs
--rw-r--r--   0     1001      123      466 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/global.rs
--rw-r--r--   0     1001      123      175 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/lib.rs
--rw-r--r--   0     1001      123    10651 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/aexpr/mod.rs
--rw-r--r--   0     1001      123    11920 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/aexpr/schema.rs
--rw-r--r--   0     1001      123    21934 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/alp.rs
--rw-r--r--   0     1001      123     1622 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/anonymous_scan.rs
--rw-r--r--   0     1001      123     1428 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/apply.rs
--rw-r--r--   0     1001      123    26994 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/builder.rs
--rw-r--r--   0     1001      123    28379 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/conversion.rs
--rw-r--r--   0     1001      123      301 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/debug.rs
--rw-r--r--   0     1001      123     1518 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/file_scan.rs
--rw-r--r--   0     1001      123    14404 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/format.rs
--rw-r--r--   0     1001      123      895 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/functions/drop.rs
--rw-r--r--   0     1001      123      137 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/functions/explode.rs
--rw-r--r--   0     1001      123     1169 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/functions/merge_sorted.rs
--rw-r--r--   0     1001      123    14110 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/functions/mod.rs
--rw-r--r--   0     1001      123     1031 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/functions/python_udf.rs
--rw-r--r--   0     1001      123     1330 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/functions/rename.rs
--rw-r--r--   0     1001      123    10157 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/iterator.rs
--rw-r--r--   0     1001      123    10559 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/lit.rs
--rw-r--r--   0     1001      123     7665 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/mod.rs
--rw-r--r--   0     1001      123     7416 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/cache_states.rs
--rw-r--r--   0     1001      123    13628 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/cse.rs
--rw-r--r--   0     1001      123     2100 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/delay_rechunk.rs
--rw-r--r--   0     1001      123     3236 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/drop_nulls.rs
--rw-r--r--   0     1001      123     4663 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/fast_projection.rs
--rw-r--r--   0     1001      123     9013 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/file_caching.rs
--rw-r--r--   0     1001      123     1556 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/flatten_union.rs
--rw-r--r--   0     1001      123     6017 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/fused.rs
--rw-r--r--   0     1001      123     6778 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/mod.rs
--rw-r--r--   0     1001      123     1222 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/keys.rs
--rw-r--r--   0     1001      123    27692 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/mod.rs
--rw-r--r--   0     1001      123     2571 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/rename.rs
--rw-r--r--   0     1001      123    16314 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/utils.rs
--rw-r--r--   0     1001      123     1755 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/functions/melt.rs
--rw-r--r--   0     1001      123     3930 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/functions/mod.rs
--rw-r--r--   0     1001      123     1799 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/generic.rs
--rw-r--r--   0     1001      123     3269 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/groupby.rs
--rw-r--r--   0     1001      123     2638 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/hstack.rs
--rw-r--r--   0     1001      123    15874 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/joins.rs
--rw-r--r--   0     1001      123    25294 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/mod.rs
--rw-r--r--   0     1001      123     3707 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/projection.rs
--rw-r--r--   0     1001      123     2639 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/rename.rs
--rw-r--r--   0     1001      123     3509 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/semi_anti_join.rs
--rw-r--r--   0     1001      123    27269 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/simplify_expr.rs
--rw-r--r--   0     1001      123     3496 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/slice_pushdown_expr.rs
--rw-r--r--   0     1001      123    12611 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/slice_pushdown_lp.rs
--rw-r--r--   0     1001      123     4181 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/stack_opt.rs
--rw-r--r--   0     1001      123     9796 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/type_coercion/binary.rs
--rw-r--r--   0     1001      123    20344 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/type_coercion/mod.rs
--rw-r--r--   0     1001      123     9748 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/options.rs
--rw-r--r--   0     1001      123    20848 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/projection.rs
--rw-r--r--   0     1001      123     6178 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/pyarrow.rs
--rw-r--r--   0     1001      123    12286 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/schema.rs
--rw-r--r--   0     1001      123     6681 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/tree_format.rs
--rw-r--r--   0     1001      123     3544 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/visitor/expr.rs
--rw-r--r--   0     1001      123      930 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/visitor/mod.rs
--rw-r--r--   0     1001      123     4440 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/visitor/visitors.rs
--rw-r--r--   0     1001      123      832 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/prelude.rs
--rw-r--r--   0     1001      123    12335 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/utils.rs
--rw-r--r--   0        0        0      587 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/Cargo.toml
--rw-r--r--   0     1001      123     1055 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/LICENSE
--rw-r--r--   0     1001      123      141 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/README.md
--rw-r--r--   0     1001      123      151 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/aliases.rs
--rw-r--r--   0     1001      123     2879 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/arena.rs
--rw-r--r--   0     1001      123     1379 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/atomic.rs
--rw-r--r--   0     1001      123     2659 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/cell.rs
--rw-r--r--   0     1001      123     1015 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/contention_pool.rs
--rw-r--r--   0     1001      123      509 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/error.rs
--rw-r--r--   0     1001      123      271 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/fmt.rs
--rw-r--r--   0     1001      123      763 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/functions.rs
--rw-r--r--   0     1001      123     2709 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/iter/enumerate_idx.rs
--rw-r--r--   0     1001      123       61 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/iter/mod.rs
--rw-r--r--   0     1001      123      503 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/lib.rs
--rw-r--r--   0     1001      123      573 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/macros.rs
--rw-r--r--   0     1001      123      282 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/mem.rs
--rw-r--r--   0     1001      123     2642 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/slice.rs
--rw-r--r--   0     1001      123     2467 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/sort.rs
--rw-r--r--   0     1001      123     1115 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/sync.rs
--rw-r--r--   0     1001      123      504 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/sys.rs
--rw-r--r--   0     1001      123      697 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/unwrap.rs
--rw-r--r--   0     1001      123     2024 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/vec.rs
--rw-r--r--   0     1001      123      616 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/wasm.rs
--rw-r--r--   0        0        0     4634 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.8/Cargo.toml
--rw-r--r--   0     1001      123       76 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/.gitignore
--rw-r--r--   0     1001      123     1055 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/LICENSE
--rw-r--r--   0     1001      123     2412 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/Makefile
--rw-r--r--   0     1001      123    11696 2023-07-20 08:31:54.000000 polars_lts_cpu-0.18.8/README.md
--rw-r--r--   0     1001      123      651 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/build.rs
--rw-r--r--   0     1001      123       32 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/.gitignore
--rw-r--r--   0     1001      123      682 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/Makefile
--rw-r--r--   0     1001      123      318 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/_templates/api_redirect.html
--rw-r--r--   0     1001      123      151 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/_templates/autosummary/accessor.rst
--rw-r--r--   0     1001      123      160 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/_templates/autosummary/accessor_attribute.rst
--rw-r--r--   0     1001      123      168 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/_templates/autosummary/accessor_callable.rst
--rw-r--r--   0     1001      123      157 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/_templates/autosummary/accessor_method.rst
--rw-r--r--   0     1001      123      836 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/_templates/autosummary/class.rst
--rw-r--r--   0     1001      123       94 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/_templates/autosummary/class_without_autosummary.rst
--rw-r--r--   0     1001      123      406 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/_templates/sidebar-nav-bs.html
--rw-r--r--   0     1001      123      559 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/requirements-docs.txt
--rw-r--r--   0     1001      123     1164 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/run_live_docs_server.py
--rw-r--r--   0     1001      123     1567 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/_static/css/custom.css
--rw-r--r--   0     1001      123     7414 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/conf.py
--rw-r--r--   0     1001      123       51 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/index.rst
--rw-r--r--   0     1001      123     6767 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/api.rst
--rw-r--r--   0     1001      123     2069 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/config.rst
--rw-r--r--   0     1001      123      274 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/dataframe/aggregation.rst
--rw-r--r--   0     1001      123      221 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/dataframe/attributes.rst
--rw-r--r--   0     1001      123      142 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/dataframe/computation.rst
--rw-r--r--   0     1001      123      319 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/dataframe/descriptive.rst
--rw-r--r--   0     1001      123      319 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/dataframe/export.rst
--rw-r--r--   0     1001      123      464 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/dataframe/groupby.rst
--rw-r--r--   0     1001      123      379 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/dataframe/index.rst
--rw-r--r--   0     1001      123      189 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/dataframe/miscellaneous.rst
--rw-r--r--   0     1001      123     1564 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/dataframe/modify_select.rst
--rw-r--r--   0     1001      123      673 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/datatypes.rst
--rw-r--r--   0     1001      123      421 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/exceptions.rst
--rw-r--r--   0     1001      123      391 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/expressions/aggregation.rst
--rw-r--r--   0     1001      123      267 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/expressions/array.rst
--rw-r--r--   0     1001      123      309 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/expressions/binary.rst
--rw-r--r--   0     1001      123      338 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/expressions/boolean.rst
--rw-r--r--   0     1001      123      265 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/expressions/categories.rst
--rw-r--r--   0     1001      123      221 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/expressions/columns.rst
--rw-r--r--   0     1001      123     1109 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/expressions/computation.rst
--rw-r--r--   0     1001      123     1334 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/expressions/functions.rst
--rw-r--r--   0     1001      123      470 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/expressions/index.rst
--rw-r--r--   0     1001      123      830 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/expressions/list.rst
--rw-r--r--   0     1001      123      458 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/expressions/meta.rst
--rw-r--r--   0     1001      123      159 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/expressions/miscellaneous.rst
--rw-r--r--   0     1001      123     1033 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/expressions/modify_select.rst
--rw-r--r--   0     1001      123      679 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/expressions/operators.rst
--rw-r--r--   0     1001      123      977 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/expressions/string.rst
--rw-r--r--   0     1001      123      254 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/expressions/struct.rst
--rw-r--r--   0     1001      123     1087 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/expressions/temporal.rst
--rw-r--r--   0     1001      123       98 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/expressions/window.rst
--rw-r--r--   0     1001      123      694 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/functions.rst
--rw-r--r--   0     1001      123      405 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/index.rst
--rw-r--r--   0     1001      123     1342 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/io.rst
--rw-r--r--   0     1001      123      277 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/lazyframe/aggregation.rst
--rw-r--r--   0     1001      123      179 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/lazyframe/attributes.rst
--rw-r--r--   0     1001      123      146 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/lazyframe/descriptive.rst
--rw-r--r--   0     1001      123      497 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/lazyframe/groupby.rst
--rw-r--r--   0     1001      123      354 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/lazyframe/index.rst
--rw-r--r--   0     1001      123      404 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/lazyframe/miscellaneous.rst
--rw-r--r--   0     1001      123     1013 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/lazyframe/modify_select.rst
--rw-r--r--   0     1001      123     3279 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/selectors.rst
--rw-r--r--   0     1001      123      358 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/series/aggregation.rst
--rw-r--r--   0     1001      123      277 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/series/array.rst
--rw-r--r--   0     1001      123      257 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/series/attributes.rst
--rw-r--r--   0     1001      123      321 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/series/binary.rst
--rw-r--r--   0     1001      123      117 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/series/boolean.rst
--rw-r--r--   0     1001      123      271 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/series/categories.rst
--rw-r--r--   0     1001      123     1119 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/series/computation.rst
--rw-r--r--   0     1001      123      744 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/series/descriptive.rst
--rw-r--r--   0     1001      123      240 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/series/export.rst
--rw-r--r--   0     1001      123      437 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/series/index.rst
--rw-r--r--   0     1001      123      894 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/series/list.rst
--rw-r--r--   0     1001      123      236 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/series/miscellaneous.rst
--rw-r--r--   0     1001      123     1128 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/series/modify_select.rst
--rw-r--r--   0     1001      123     1049 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/series/string.rst
--rw-r--r--   0     1001      123      421 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/series/struct.rst
--rw-r--r--   0     1001      123     1247 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/series/temporal.rst
--rw-r--r--   0     1001      123      503 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/sql.rst
--rw-r--r--   0     1001      123     8067 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/testing.rst
--rw-r--r--   0     1001      123      168 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/docs/source/reference/utils.rst
--rw-r--r--   0     1001      123     6663 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/__init__.py
--rw-r--r--   0     1001      123      280 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/_reexport.py
--rw-r--r--   0     1001      123    13229 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/api.py
--rw-r--r--   0     1001      123    29669 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/config.py
--rw-r--r--   0     1001      123    28065 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/convert.py
--rw-r--r--   0     1001      123       77 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/dataframe/__init__.py
--rw-r--r--   0     1001      123     5227 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/dataframe/_html.py
--rw-r--r--   0     1001      123   331100 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/dataframe/frame.py
--rw-r--r--   0     1001      123    42790 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/dataframe/groupby.py
--rw-r--r--   0     1001      123     2692 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/datatypes/__init__.py
--rw-r--r--   0     1001      123    18791 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/datatypes/classes.py
--rw-r--r--   0     1001      123     1690 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/datatypes/constants.py
--rw-r--r--   0     1001      123     4962 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/datatypes/constructor.py
--rw-r--r--   0     1001      123    15527 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/datatypes/convert.py
--rw-r--r--   0     1001      123     7358 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/dependencies.py
--rw-r--r--   0     1001      123     4041 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/exceptions.py
--rw-r--r--   0     1001      123       61 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/expr/__init__.py
--rw-r--r--   0     1001      123     3020 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/expr/array.py
--rw-r--r--   0     1001      123    10330 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/expr/binary.py
--rw-r--r--   0     1001      123     2351 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/expr/categorical.py
--rw-r--r--   0     1001      123    85391 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/expr/datetime.py
--rw-r--r--   0     1001      123   324682 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/expr/expr.py
--rw-r--r--   0     1001      123    31956 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/expr/list.py
--rw-r--r--   0     1001      123     4683 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/expr/meta.py
--rw-r--r--   0     1001      123    60086 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/expr/string.py
--rw-r--r--   0     1001      123     5426 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/expr/struct.py
--rw-r--r--   0     1001      123     2464 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/functions/__init__.py
--rw-r--r--   0     1001      123      480 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/functions/aggregation/__init__.py
--rw-r--r--   0     1001      123     8369 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/functions/aggregation/horizontal.py
--rw-r--r--   0     1001      123    15214 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/functions/aggregation/vertical.py
--rw-r--r--   0     1001      123    16430 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/functions/as_datatype.py
--rw-r--r--   0     1001      123    19285 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/functions/eager.py
--rw-r--r--   0     1001      123    58222 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/functions/lazy.py
--rw-r--r--   0     1001      123    20769 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/functions/range.py
--rw-r--r--   0     1001      123     6043 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/functions/repeat.py
--rw-r--r--   0     1001      123     6051 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/functions/whenthen.py
--rw-r--r--   0     1001      123      952 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/__init__.py
--rw-r--r--   0     1001      123     6369 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/_utils.py
--rw-r--r--   0     1001      123      861 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/avro.py
--rw-r--r--   0     1001      123      144 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/csv/__init__.py
--rw-r--r--   0     1001      123     1072 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/csv/_utils.py
--rw-r--r--   0     1001      123     4720 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/csv/batched_reader.py
--rw-r--r--   0     1001      123    35482 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/csv/functions.py
--rw-r--r--   0     1001      123     6428 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/database.py
--rw-r--r--   0     1001      123    11052 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/delta.py
--rw-r--r--   0     1001      123       75 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/excel/__init__.py
--rw-r--r--   0     1001      123    18338 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/excel/_write_utils.py
--rw-r--r--   0     1001      123     6355 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/excel/functions.py
--rw-r--r--   0     1001      123      142 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/ipc/__init__.py
--rw-r--r--   0     1001      123     1227 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/ipc/anonymous_scan.py
--rw-r--r--   0     1001      123     5804 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/ipc/functions.py
--rw-r--r--   0     1001      123     1637 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/json.py
--rw-r--r--   0     1001      123     3516 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/ndjson.py
--rw-r--r--   0     1001      123      170 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/parquet/__init__.py
--rw-r--r--   0     1001      123     1259 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/parquet/anonymous_scan.py
--rw-r--r--   0     1001      123     7177 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/parquet/functions.py
--rw-r--r--   0     1001      123      136 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/pyarrow_dataset/__init__.py
--rw-r--r--   0     1001      123     2186 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/pyarrow_dataset/anonymous_scan.py
--rw-r--r--   0     1001      123     3601 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/io/pyarrow_dataset/functions.py
--rw-r--r--   0     1001      123       77 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/lazyframe/__init__.py
--rw-r--r--   0     1001      123   172958 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/lazyframe/frame.py
--rw-r--r--   0     1001      123    25258 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/lazyframe/groupby.py
--rw-r--r--   0     1001      123        0 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/py.typed
--rw-r--r--   0     1001      123    42936 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/selectors.py
--rw-r--r--   0     1001      123       69 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/series/__init__.py
--rw-r--r--   0     1001      123     1572 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/series/_numpy.py
--rw-r--r--   0     1001      123     2515 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/series/array.py
--rw-r--r--   0     1001      123     1913 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/series/binary.py
--rw-r--r--   0     1001      123     2085 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/series/categorical.py
--rw-r--r--   0     1001      123    56363 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/series/datetime.py
--rw-r--r--   0     1001      123    16940 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/series/list.py
--rw-r--r--   0     1001      123   177772 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/series/series.py
--rw-r--r--   0     1001      123    38879 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/series/string.py
--rw-r--r--   0     1001      123     2542 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/series/struct.py
--rw-r--r--   0     1001      123     5361 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/series/utils.py
--rw-r--r--   0     1001      123     7559 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/slice.py
--rw-r--r--   0     1001      123       75 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/sql/__init__.py
--rw-r--r--   0     1001      123    17286 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/sql/context.py
--rw-r--r--   0     1001      123     4793 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/string_cache.py
--rw-r--r--   0     1001      123      362 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/testing/__init__.py
--rw-r--r--   0     1001      123     1060 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/testing/_private.py
--rw-r--r--   0     1001      123    16964 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/testing/asserts.py
--rw-r--r--   0     1001      123      898 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/testing/parametric/__init__.py
--rw-r--r--   0     1001      123    28167 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/testing/parametric/primitives.py
--rw-r--r--   0     1001      123     3371 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/testing/parametric/profiles.py
--rw-r--r--   0     1001      123    13165 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/testing/parametric/strategies.py
--rw-r--r--   0     1001      123     6460 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/type_aliases.py
--rw-r--r--   0     1001      123     1191 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/utils/__init__.py
--rw-r--r--   0     1001      123    56926 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/utils/_construction.py
--rw-r--r--   0     1001      123     4937 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/utils/_parse_expr_input.py
--rw-r--r--   0     1001      123      647 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/utils/_scan.py
--rw-r--r--   0     1001      123      579 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/utils/_wrap.py
--rw-r--r--   0     1001      123      683 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/utils/build_info.py
--rw-r--r--   0     1001      123     8730 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/utils/convert.py
--rw-r--r--   0     1001      123     7199 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/utils/decorators.py
--rw-r--r--   0     1001      123     1660 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/utils/meta.py
--rw-r--r--   0     1001      123      514 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/utils/polars_version.py
--rw-r--r--   0     1001      123     2552 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/utils/show_versions.py
--rw-r--r--   0     1001      123    11221 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/utils/udfs.py
--rw-r--r--   0     1001      123    14038 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/polars/utils/various.py
--rw-r--r--   0     1001      123     5523 2023-07-20 08:31:54.000000 polars_lts_cpu-0.18.8/pyproject.toml
--rw-r--r--   0     1001      123      779 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/requirements-dev.txt
--rw-r--r--   0     1001      123       70 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/requirements-lint.txt
--rw-r--r--   0     1001      123     1643 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/scripts/check_stacklevels.py
--rw-r--r--   0     1001      123    10980 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/apply/dataframe.rs
--rw-r--r--   0     1001      123     6428 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/apply/lazy.rs
--rw-r--r--   0     1001      123     8535 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/apply/mod.rs
--rw-r--r--   0     1001      123    90654 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/apply/series.rs
--rw-r--r--   0     1001      123       32 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/arrow_interop/mod.rs
--rw-r--r--   0     1001      123     1306 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/arrow_interop/to_py.rs
--rw-r--r--   0     1001      123     3902 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/arrow_interop/to_rust.rs
--rw-r--r--   0     1001      123     5250 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/batched_csv.rs
--rw-r--r--   0     1001      123    55017 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/conversion.rs
--rw-r--r--   0     1001      123    46712 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/dataframe.rs
--rw-r--r--   0     1001      123     3950 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/datatypes.rs
--rw-r--r--   0     1001      123     3506 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/error.rs
--rw-r--r--   0     1001      123      570 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/expr/array.rs
--rw-r--r--   0     1001      123     2080 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/expr/binary.rs
--rw-r--r--   0     1001      123      381 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/expr/categorical.rs
--rw-r--r--   0     1001      123     6385 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/expr/datetime.rs
--rw-r--r--   0     1001      123    36616 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/expr/general.rs
--rw-r--r--   0     1001      123     4693 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/expr/list.rs
--rw-r--r--   0     1001      123     3152 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/expr/meta.rs
--rw-r--r--   0     1001      123      870 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/expr/mod.rs
--rw-r--r--   0     1001      123     7872 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/expr/string.rs
--rw-r--r--   0     1001      123      467 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/expr/struct.rs
--rw-r--r--   0     1001      123     9482 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/file.rs
--rw-r--r--   0     1001      123      806 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/functions/aggregation.rs
--rw-r--r--   0     1001      123     2777 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/functions/eager.rs
--rw-r--r--   0     1001      123     1657 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/functions/io.rs
--rw-r--r--   0     1001      123    11196 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/functions/lazy.rs
--rw-r--r--   0     1001      123     1312 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/functions/meta.rs
--rw-r--r--   0     1001      123      217 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/functions/misc.rs
--rw-r--r--   0     1001      123      123 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/functions/mod.rs
--rw-r--r--   0     1001      123      845 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/functions/range.rs
--rw-r--r--   0     1001      123     1474 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/functions/whenthen.rs
--rw-r--r--   0     1001      123     1597 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/gil_once_cell.rs
--rw-r--r--   0     1001      123    28437 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/lazyframe.rs
--rw-r--r--   0     1001      123     2670 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/lazygroupby.rs
--rw-r--r--   0     1001      123     8841 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/lib.rs
--rw-r--r--   0     1001      123       47 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/object.rs
--rw-r--r--   0     1001      123     3685 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/on_startup.rs
--rw-r--r--   0     1001      123      122 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/prelude.rs
--rw-r--r--   0     1001      123      435 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/py_modules.rs
--rw-r--r--   0     1001      123     1964 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/series/aggregation.rs
--rw-r--r--   0     1001      123     5406 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/series/arithmetic.rs
--rw-r--r--   0     1001      123     5138 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/series/comparison.rs
--rw-r--r--   0     1001      123     9077 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/series/construction.rs
--rw-r--r--   0     1001      123     8971 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/series/export.rs
--rw-r--r--   0     1001      123    25167 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/series/mod.rs
--rw-r--r--   0     1001      123     4569 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/series/numpy_ufunc.rs
--rw-r--r--   0     1001      123     4046 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/series/set_at_idx.rs
--rw-r--r--   0     1001      123     1036 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/sql.rs
--rw-r--r--   0     1001      123     2335 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/src/utils.rs
--rw-r--r--   0     1001      123     6165 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/README.md
--rw-r--r--   0     1001      123     2189 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/benchmark/groupby-datagen.R
--rw-r--r--   0     1001      123     7963 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/benchmark/run_h2oai_benchmark.py
--rw-r--r--   0     1001      123     6500 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/benchmark/test_release.py
--rw-r--r--   0     1001      123     4766 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/docs/run_doctest.py
--rw-r--r--   0     1001      123        0 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/parametric/__init__.py
--rw-r--r--   0     1001      123      179 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/parametric/conftest.py
--rw-r--r--   0     1001      123     3856 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/parametric/test_dataframe.py
--rw-r--r--   0     1001      123     2398 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/parametric/test_groupby_rolling.py
--rw-r--r--   0     1001      123     1692 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/parametric/test_lazyframe.py
--rw-r--r--   0     1001      123      976 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/parametric/test_lit.py
--rw-r--r--   0     1001      123     6853 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/parametric/test_series.py
--rw-r--r--   0     1001      123     8467 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/parametric/test_testing.py
--rw-r--r--   0     1001      123     1554 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/parametric/time_series/test_to_datetime.py
--rw-r--r--   0     1001      123        0 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/__init__.py
--rw-r--r--   0     1001      123     3382 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/conftest.py
--rw-r--r--   0     1001      123        0 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/dataframe/__init__.py
--rw-r--r--   0     1001      123   114497 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/dataframe/test_df.py
--rw-r--r--   0     1001      123     2306 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/dataframe/test_extend.py
--rw-r--r--   0     1001      123     1666 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/dataframe/test_vstack.py
--rw-r--r--   0     1001      123       86 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/datatypes/__init__.py
--rw-r--r--   0     1001      123     1673 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/datatypes/test_array.py
--rw-r--r--   0     1001      123      847 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/datatypes/test_binary.py
--rw-r--r--   0     1001      123     1420 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/datatypes/test_bool.py
--rw-r--r--   0     1001      123    13983 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/datatypes/test_categorical.py
--rw-r--r--   0     1001      123     5222 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/datatypes/test_decimal.py
--rw-r--r--   0     1001      123      549 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/datatypes/test_duration.py
--rw-r--r--   0     1001      123      423 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/datatypes/test_integer.py
--rw-r--r--   0     1001      123    14052 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/datatypes/test_list.py
--rw-r--r--   0     1001      123      284 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/datatypes/test_null.py
--rw-r--r--   0     1001      123     3028 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/datatypes/test_object.py
--rw-r--r--   0     1001      123    26392 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/datatypes/test_struct.py
--rw-r--r--   0     1001      123    89717 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/datatypes/test_temporal.py
--rw-r--r--   0     1001      123      418 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/datatypes/test_time.py
--rw-r--r--   0     1001      123        0 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/functions/__init__.py
--rw-r--r--   0     1001      123        0 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/functions/aggregation/__init__.py
--rw-r--r--   0     1001      123     6783 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/functions/aggregation/test_horizontal.py
--rw-r--r--   0     1001      123     3008 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/functions/aggregation/test_vertical.py
--rw-r--r--   0     1001      123    13970 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/functions/test_as_datatype.py
--rw-r--r--   0     1001      123      480 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/functions/test_concat.py
--rw-r--r--   0     1001      123    15544 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/functions/test_functions.py
--rw-r--r--   0     1001      123    30418 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/functions/test_range.py
--rw-r--r--   0     1001      123     3847 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/functions/test_repeat.py
--rw-r--r--   0     1001      123      168 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/conftest.py
--rw-r--r--   0     1001      123       16 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/delta-table/.part-00000-e42312d7-60e5-454d-acbc-db192d220e73-c000.snappy.parquet.crc
--rw-r--r--   0     1001      123       16 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/delta-table/.part-00000-e4a999da-df45-4fb0-bdc4-d999fc0f58aa-c000.snappy.parquet.crc
--rw-r--r--   0     1001      123       16 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/delta-table/_delta_log/.00000000000000000000.json.crc
--rw-r--r--   0     1001      123       16 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/delta-table/_delta_log/.00000000000000000001.json.crc
--rw-r--r--   0     1001      123      905 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/delta-table/_delta_log/00000000000000000000.json
--rw-r--r--   0     1001      123      936 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/delta-table/_delta_log/00000000000000000001.json
--rw-r--r--   0     1001      123      972 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/delta-table/part-00000-e42312d7-60e5-454d-acbc-db192d220e73-c000.snappy.parquet
--rw-r--r--   0     1001      123      690 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/delta-table/part-00000-e4a999da-df45-4fb0-bdc4-d999fc0f58aa-c000.snappy.parquet
--rw-r--r--   0     1001      123        0 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/empty.csv
--rw-r--r--   0     1001      123     5959 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/example.xlsx
--rw-r--r--   0     1001      123      457 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/foods1.csv
--rw-r--r--   0     1001      123     2351 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/foods1.ipc
--rw-r--r--   0     1001      123     1713 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/foods1.ndjson
--rw-r--r--   0     1001      123     1427 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/foods1.parquet
--rw-r--r--   0     1001      123      455 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/foods2.csv
--rw-r--r--   0     1001      123     2351 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/foods2.ipc
--rw-r--r--   0     1001      123     1711 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/foods2.ndjson
--rw-r--r--   0     1001      123     1916 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/foods2.parquet
--rw-r--r--   0     1001      123      455 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/foods3.csv
--rw-r--r--   0     1001      123      457 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/foods4.csv
--rw-r--r--   0     1001      123      452 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/foods5.csv
--rw-r--r--   0     1001      123       49 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/gzipped.csv
--rw-r--r--   0     1001      123       57 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/small.csv
--rw-r--r--   0     1001      123      756 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/small.parquet
--rwxr-xr-x   0     1001      123      420 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/files/tz_aware.parquet
--rw-r--r--   0     1001      123     1884 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/test_avro.py
--rw-r--r--   0     1001      123    41288 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/test_csv.py
--rw-r--r--   0     1001      123     7125 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/test_database.py
--rw-r--r--   0     1001      123     6172 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/test_delta.py
--rw-r--r--   0     1001      123    12215 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/test_excel.py
--rw-r--r--   0     1001      123     5483 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/test_ipc.py
--rw-r--r--   0     1001      123     6215 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/test_json.py
--rw-r--r--   0     1001      123     7314 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/test_lazy_csv.py
--rw-r--r--   0     1001      123     2060 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/test_lazy_ipc.py
--rw-r--r--   0     1001      123     2841 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/test_lazy_json.py
--rw-r--r--   0     1001      123    11153 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/test_lazy_parquet.py
--rw-r--r--   0     1001      123     1996 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/test_other.py
--rw-r--r--   0     1001      123    14862 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/test_parquet.py
--rw-r--r--   0     1001      123      612 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/test_pickle.py
--rw-r--r--   0     1001      123     3706 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/io/test_pyarrow_dataset.py
--rw-r--r--   0     1001      123      509 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/namespaces/__init__.py
--rw-r--r--   0     1001      123      940 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/namespaces/test_array.py
--rw-r--r--   0     1001      123     3218 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/namespaces/test_binary.py
--rw-r--r--   0     1001      123     2696 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/namespaces/test_categorical.py
--rw-r--r--   0     1001      123    24151 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/namespaces/test_datetime.py
--rw-r--r--   0     1001      123    15528 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/namespaces/test_list.py
--rw-r--r--   0     1001      123     2472 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/namespaces/test_meta.py
--rw-r--r--   0     1001      123    24050 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/namespaces/test_string.py
--rw-r--r--   0     1001      123    20819 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/namespaces/test_strptime.py
--rw-r--r--   0     1001      123     1084 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/namespaces/test_struct.py
--rw-r--r--   0     1001      123       85 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/__init__.py
--rw-r--r--   0     1001      123     8185 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_aggregations.py
--rw-r--r--   0     1001      123    10975 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_apply.py
--rw-r--r--   0     1001      123     6915 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_arithmetic.py
--rw-r--r--   0     1001      123     4940 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_comparison.py
--rw-r--r--   0     1001      123     3275 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_drop.py
--rw-r--r--   0     1001      123     8813 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_explode.py
--rw-r--r--   0     1001      123     3732 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_filter.py
--rw-r--r--   0     1001      123     1096 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_folds.py
--rw-r--r--   0     1001      123    25037 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_groupby.py
--rw-r--r--   0     1001      123     7593 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_groupby_rolling.py
--rw-r--r--   0     1001      123     2704 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_inefficient_apply.py
--rw-r--r--   0     1001      123     2983 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_is_in.py
--rw-r--r--   0     1001      123    19313 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_join.py
--rw-r--r--   0     1001      123    15633 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_join_asof.py
--rw-r--r--   0     1001      123      643 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_melt.py
--rw-r--r--   0     1001      123    10253 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_pivot.py
--rw-r--r--   0     1001      123     3187 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_random.py
--rw-r--r--   0     1001      123    24491 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_rolling.py
--rw-r--r--   0     1001      123     2389 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_select.py
--rw-r--r--   0     1001      123    21314 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_sort.py
--rw-r--r--   0     1001      123     6619 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_statistics.py
--rw-r--r--   0     1001      123     4312 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_transpose.py
--rw-r--r--   0     1001      123      771 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_unique.py
--rw-r--r--   0     1001      123    11641 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_window.py
--rw-r--r--   0     1001      123     5480 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/operations/test_with_columns.py
--rw-r--r--   0     1001      123        0 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/series/__init__.py
--rw-r--r--   0     1001      123     2307 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/series/test_append.py
--rw-r--r--   0     1001      123      735 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/series/test_extend.py
--rw-r--r--   0     1001      123    82831 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/series/test_series.py
--rw-r--r--   0     1001      123        0 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/streaming/__init__.py
--rw-r--r--   0     1001      123      146 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/streaming/conftest.py
--rw-r--r--   0     1001      123      908 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/streaming/test_ooc.py
--rw-r--r--   0     1001      123    21247 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/streaming/test_streaming.py
--rw-r--r--   0     1001      123     5492 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_api.py
--rw-r--r--   0     1001      123     2035 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_arity.py
--rw-r--r--   0     1001      123    22128 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_cfg.py
--rw-r--r--   0     1001      123    43560 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_constructors.py
--rw-r--r--   0     1001      123      454 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_context.py
--rw-r--r--   0     1001      123     3224 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_cse.py
--rw-r--r--   0     1001      123     5191 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_datatypes.py
--rw-r--r--   0     1001      123     2741 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_empty.py
--rw-r--r--   0     1001      123    19296 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_errors.py
--rw-r--r--   0     1001      123     1391 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_expansion.py
--rw-r--r--   0     1001      123     2435 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_expr_multi_cols.py
--rw-r--r--   0     1001      123    32477 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_exprs.py
--rw-r--r--   0     1001      123     3516 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_fmt.py
--rw-r--r--   0     1001      123     3512 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_interchange.py
--rw-r--r--   0     1001      123    38530 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_interop.py
--rw-r--r--   0     1001      123    48249 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_lazy.py
--rw-r--r--   0     1001      123     2463 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_polars_import.py
--rw-r--r--   0     1001      123     4900 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_predicates.py
--rw-r--r--   0     1001      123     8323 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_projections.py
--rw-r--r--   0     1001      123    11550 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_queries.py
--rw-r--r--   0     1001      123     8100 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_rows.py
--rw-r--r--   0     1001      123    15615 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_schema.py
--rw-r--r--   0     1001      123    13149 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_selectors.py
--rw-r--r--   0     1001      123     4509 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_serde.py
--rw-r--r--   0     1001      123      452 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_show_graph.py
--rw-r--r--   0     1001      123      657 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_single.py
--rw-r--r--   0     1001      123    22470 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_sql.py
--rw-r--r--   0     1001      123    35314 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/test_testing.py
--rw-r--r--   0     1001      123       41 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/utils/__init__.py
--rw-r--r--   0     1001      123      306 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/utils/test_build_info.py
--rw-r--r--   0     1001      123     3182 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/utils/test_parse_expr_input.py
--rw-r--r--   0     1001      123      247 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/utils/test_show_versions.py
--rw-r--r--   0     1001      123     5380 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/tests/unit/utils/test_utils.py
--rw-r--r--   0     1001      123    65172 2023-07-20 08:31:53.000000 polars_lts_cpu-0.18.8/Cargo.lock
--rw-r--r--   0        0        0    14378 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.8/PKG-INFO
+-rw-r--r--   0        0        0     3766 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/LICENSE
+-rw-r--r--   0     1001      123      132 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/README.md
+-rw-r--r--   0     1001      123     2393 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/array/min_max.rs
+-rw-r--r--   0     1001      123      267 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/array/mod.rs
+-rw-r--r--   0     1001      123     1512 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/array/namespace.rs
+-rw-r--r--   0     1001      123     4108 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/array/sum_mean.rs
+-rw-r--r--   0     1001      123      234 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/binary/mod.rs
+-rw-r--r--   0     1001      123     3549 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/binary/namespace.rs
+-rw-r--r--   0     1001      123      113 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/datetime/mod.rs
+-rw-r--r--   0     1001      123      875 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/datetime/replace_time_zone.rs
+-rw-r--r--   0     1001      123    11023 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/interpolate.rs
+-rw-r--r--   0     1001      123     1941 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/list/any_all.rs
+-rw-r--r--   0     1001      123     1687 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/list/count.rs
+-rw-r--r--   0     1001      123     2419 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/list/hash.rs
+-rw-r--r--   0     1001      123     7861 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/list/min_max.rs
+-rw-r--r--   0     1001      123      644 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/list/mod.rs
+-rw-r--r--   0     1001      123    19904 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/list/namespace.rs
+-rw-r--r--   0     1001      123     9376 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/list/sets.rs
+-rw-r--r--   0     1001      123     7633 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/list/sum_mean.rs
+-rw-r--r--   0     1001      123     2435 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/list/to_struct.rs
+-rw-r--r--   0     1001      123      644 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/mod.rs
+-rw-r--r--   0     1001      123     9452 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/nan_propagating_aggregate.rs
+-rw-r--r--   0     1001      123     6795 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/set.rs
+-rw-r--r--   0     1001      123     8781 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/strings/case.rs
+-rw-r--r--   0     1001      123     8593 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/strings/json_path.rs
+-rw-r--r--   0     1001      123     2345 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/strings/justify.rs
+-rw-r--r--   0     1001      123      514 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/strings/mod.rs
+-rw-r--r--   0     1001      123    14939 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/strings/namespace.rs
+-rw-r--r--   0     1001      123     4248 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/strings/replace.rs
+-rw-r--r--   0     1001      123      439 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/sum.rs
+-rw-r--r--   0     1001      123     2396 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/top_k.rs
+-rw-r--r--   0     1001      123     7727 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/frame/join/merge_sorted.rs
+-rw-r--r--   0     1001      123    18232 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/frame/join/mod.rs
+-rw-r--r--   0     1001      123     4291 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/frame/mod.rs
+-rw-r--r--   0     1001      123    10257 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/frame/pivot/mod.rs
+-rw-r--r--   0     1001      123    13586 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/frame/pivot/positioning.rs
+-rw-r--r--   0     1001      123      237 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/lib.rs
+-rw-r--r--   0     1001      123      290 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/prelude.rs
+-rw-r--r--   0     1001      123       25 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/mod.rs
+-rw-r--r--   0     1001      123     9623 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/approx_algo/hyperloglogplus.rs
+-rw-r--r--   0     1001      123      118 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/approx_algo/mod.rs
+-rw-r--r--   0     1001      123     2016 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/approx_unique.rs
+-rw-r--r--   0     1001      123    11866 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/arg_min_max.rs
+-rw-r--r--   0     1001      123     5129 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/cut.rs
+-rw-r--r--   0     1001      123     3676 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/floor_divide.rs
+-rw-r--r--   0     1001      123     5245 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/fused.rs
+-rw-r--r--   0     1001      123     3423 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/is_first.rs
+-rw-r--r--   0     1001      123     2975 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/is_unique.rs
+-rw-r--r--   0     1001      123     3626 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/log.rs
+-rw-r--r--   0     1001      123     1341 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/mod.rs
+-rw-r--r--   0     1001      123     1342 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/rle.rs
+-rw-r--r--   0     1001      123     1769 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/rolling.rs
+-rw-r--r--   0     1001      123     7642 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/search_sorted.rs
+-rw-r--r--   0     1001      123     2603 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/to_dummies.rs
+-rw-r--r--   0     1001      123     3495 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/various.rs
+-rw-r--r--   0        0        0      651 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/LICENSE
+-rw-r--r--   0     1001      123      141 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/README.md
+-rw-r--r--   0     1001      123      151 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/aliases.rs
+-rw-r--r--   0     1001      123     2879 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/arena.rs
+-rw-r--r--   0     1001      123     1379 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/atomic.rs
+-rw-r--r--   0     1001      123     2659 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/cell.rs
+-rw-r--r--   0     1001      123     1015 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/contention_pool.rs
+-rw-r--r--   0     1001      123      509 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/error.rs
+-rw-r--r--   0     1001      123      271 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/fmt.rs
+-rw-r--r--   0     1001      123      763 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/functions.rs
+-rw-r--r--   0     1001      123      532 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/io.rs
+-rw-r--r--   0     1001      123     2709 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/iter/enumerate_idx.rs
+-rw-r--r--   0     1001      123       61 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/iter/mod.rs
+-rw-r--r--   0     1001      123      539 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/lib.rs
+-rw-r--r--   0     1001      123      573 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/macros.rs
+-rw-r--r--   0     1001      123      282 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/mem.rs
+-rw-r--r--   0     1001      123     2642 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/slice.rs
+-rw-r--r--   0     1001      123     2467 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/sort.rs
+-rw-r--r--   0     1001      123     1115 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/sync.rs
+-rw-r--r--   0     1001      123      504 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/sys.rs
+-rw-r--r--   0     1001      123      697 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/unwrap.rs
+-rw-r--r--   0     1001      123     2343 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/vec.rs
+-rw-r--r--   0     1001      123      616 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/wasm.rs
+-rw-r--r--   0        0        0     6330 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/LICENSE
+-rw-r--r--   0     1001      123      358 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/README.md
+-rw-r--r--   0     1001      123     1796 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/dot.rs
+-rw-r--r--   0     1001      123     4479 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/dsl/eval.rs
+-rw-r--r--   0     1001      123     7166 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/dsl/functions.rs
+-rw-r--r--   0     1001      123      164 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/dsl/into.rs
+-rw-r--r--   0     1001      123     6756 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/dsl/list.rs
+-rw-r--r--   0     1001      123     2899 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/dsl/mod.rs
+-rw-r--r--   0     1001      123     1182 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/frame/anonymous_scan.rs
+-rw-r--r--   0     1001      123     9293 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/frame/csv.rs
+-rw-r--r--   0     1001      123      476 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/frame/err.rs
+-rw-r--r--   0     1001      123     4368 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/frame/file_list_reader.rs
+-rw-r--r--   0     1001      123     2231 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/frame/ipc.rs
+-rw-r--r--   0     1001      123    49813 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/frame/mod.rs
+-rw-r--r--   0     1001      123     3382 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/frame/ndjson.rs
+-rw-r--r--   0     1001      123     2734 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/frame/parquet.rs
+-rw-r--r--   0     1001      123     2892 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/frame/pivot.rs
+-rw-r--r--   0     1001      123      459 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/frame/python.rs
+-rw-r--r--   0     1001      123     6410 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/lib.rs
+-rw-r--r--   0     1001      123     1049 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/cache.rs
+-rw-r--r--   0     1001      123      776 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/executor.rs
+-rw-r--r--   0     1001      123      670 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/ext_context.rs
+-rw-r--r--   0     1001      123     1555 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/filter.rs
+-rw-r--r--   0     1001      123     4204 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/groupby.rs
+-rw-r--r--   0     1001      123     3688 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_dynamic.rs
+-rw-r--r--   0     1001      123    13795 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_partitioned.rs
+-rw-r--r--   0     1001      123     4445 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_rolling.rs
+-rw-r--r--   0     1001      123     5859 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/join.rs
+-rw-r--r--   0     1001      123     7413 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/mod.rs
+-rw-r--r--   0     1001      123     2428 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/projection.rs
+-rw-r--r--   0     1001      123     1761 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/python_scan.rs
+-rw-r--r--   0     1001      123     2971 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/scan/csv.rs
+-rw-r--r--   0     1001      123     2085 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/scan/ipc.rs
+-rw-r--r--   0     1001      123     4353 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/scan/mod.rs
+-rw-r--r--   0     1001      123     1212 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/scan/ndjson.rs
+-rw-r--r--   0     1001      123     2650 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/scan/parquet.rs
+-rw-r--r--   0     1001      123      548 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/slice.rs
+-rw-r--r--   0     1001      123     2231 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/sort.rs
+-rw-r--r--   0     1001      123     1861 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/stack.rs
+-rw-r--r--   0     1001      123      663 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/udf.rs
+-rw-r--r--   0     1001      123     4041 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/union.rs
+-rw-r--r--   0     1001      123      838 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/unique.rs
+-rw-r--r--   0     1001      123     1335 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/exotic.rs
+-rw-r--r--   0     1001      123    21959 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/aggregation.rs
+-rw-r--r--   0     1001      123     2689 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/alias.rs
+-rw-r--r--   0     1001      123    18796 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/apply.rs
+-rw-r--r--   0     1001      123    17674 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/binary.rs
+-rw-r--r--   0     1001      123     3153 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/cast.rs
+-rw-r--r--   0     1001      123     6326 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/column.rs
+-rw-r--r--   0     1001      123     1996 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/count.rs
+-rw-r--r--   0     1001      123     5809 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/filter.rs
+-rw-r--r--   0     1001      123     4643 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/group_iter.rs
+-rw-r--r--   0     1001      123     5304 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/literal.rs
+-rw-r--r--   0     1001      123    23533 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/mod.rs
+-rw-r--r--   0     1001      123    10091 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/slice.rs
+-rw-r--r--   0     1001      123     4332 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/sort.rs
+-rw-r--r--   0     1001      123    13549 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/sortby.rs
+-rw-r--r--   0     1001      123     7553 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/take.rs
+-rw-r--r--   0     1001      123    14312 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/ternary.rs
+-rw-r--r--   0     1001      123    31968 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/window.rs
+-rw-r--r--   0     1001      123     2039 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/file_cache.rs
+-rw-r--r--   0     1001      123      414 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/mod.rs
+-rw-r--r--   0     1001      123     2046 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/node_timer.rs
+-rw-r--r--   0     1001      123    23855 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/planner/expr.rs
+-rw-r--r--   0     1001      123    20831 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/planner/lp.rs
+-rw-r--r--   0     1001      123       87 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/planner/mod.rs
+-rw-r--r--   0     1001      123     9583 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/state.rs
+-rw-r--r--   0     1001      123     2901 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/streaming/checks.rs
+-rw-r--r--   0     1001      123     9183 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/streaming/construct_pipeline.rs
+-rw-r--r--   0     1001      123    17050 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/streaming/convert_alp.rs
+-rw-r--r--   0     1001      123      116 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/streaming/mod.rs
+-rw-r--r--   0     1001      123     5827 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/streaming/tree.rs
+-rw-r--r--   0     1001      123      722 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/prelude.rs
+-rw-r--r--   0     1001      123    15189 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/aggregations.rs
+-rw-r--r--   0     1001      123     2339 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/arity.rs
+-rw-r--r--   0     1001      123     7188 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/cse.rs
+-rw-r--r--   0     1001      123    12736 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/io.rs
+-rw-r--r--   0     1001      123     4166 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/logical.rs
+-rw-r--r--   0     1001      123     4273 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/mod.rs
+-rw-r--r--   0     1001      123    15018 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/optimization_checks.rs
+-rw-r--r--   0     1001      123     6728 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/predicate_queries.rs
+-rw-r--r--   0     1001      123     3144 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/projection_queries.rs
+-rw-r--r--   0     1001      123    48167 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/queries.rs
+-rw-r--r--   0     1001      123     9970 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/streaming.rs
+-rw-r--r--   0     1001      123     2895 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/tpch.rs
+-rw-r--r--   0     1001      123      717 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/utils.rs
+-rw-r--r--   0        0        0     5501 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/LICENSE
+-rw-r--r--   0     1001      123      144 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/README.md
+-rw-r--r--   0     1001      123     5158 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/arithmetic/decimal.rs
+-rw-r--r--   0     1001      123     8275 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/arithmetic/mod.rs
+-rw-r--r--   0     1001      123     9417 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/arithmetic/numeric.rs
+-rw-r--r--   0     1001      123     3588 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/array/iterator.rs
+-rw-r--r--   0     1001      123     2551 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/array/mod.rs
+-rw-r--r--   0     1001      123     6448 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/bitwise.rs
+-rw-r--r--   0     1001      123     2298 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/binary.rs
+-rw-r--r--   0     1001      123     1258 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/boolean.rs
+-rw-r--r--   0     1001      123     4311 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/fixed_size_list.rs
+-rw-r--r--   0     1001      123     1556 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/from.rs
+-rw-r--r--   0     1001      123     5762 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/list/anonymous.rs
+-rw-r--r--   0     1001      123     4418 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/list/binary.rs
+-rw-r--r--   0     1001      123     2374 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/list/boolean.rs
+-rw-r--r--   0     1001      123     1433 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/list/categorical.rs
+-rw-r--r--   0     1001      123     1611 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/list/dtypes.rs
+-rw-r--r--   0     1001      123     4953 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/list/mod.rs
+-rw-r--r--   0     1001      123     3506 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/list/primitive.rs
+-rw-r--r--   0     1001      123     8996 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/mod.rs
+-rw-r--r--   0     1001      123     1461 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/primitive.rs
+-rw-r--r--   0     1001      123     2342 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/utf8.rs
+-rw-r--r--   0     1001      123    17014 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/cast.rs
+-rw-r--r--   0     1001      123    50941 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/comparison/mod.rs
+-rw-r--r--   0     1001      123    10096 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/comparison/scalar.rs
+-rw-r--r--   0     1001      123      551 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/drop.rs
+-rw-r--r--   0     1001      123      963 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/float.rs
+-rw-r--r--   0     1001      123     7945 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/from.rs
+-rw-r--r--   0     1001      123    42339 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/iterator/mod.rs
+-rw-r--r--   0     1001      123     1453 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/iterator/par/list.rs
+-rw-r--r--   0     1001      123       28 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/iterator/par/mod.rs
+-rw-r--r--   0     1001      123     1129 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/iterator/par/utf8.rs
+-rw-r--r--   0     1001      123       21 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/kernels/mod.rs
+-rw-r--r--   0     1001      123     2347 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/kernels/take.rs
+-rw-r--r--   0     1001      123     8147 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/list/iterator.rs
+-rw-r--r--   0     1001      123     3242 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/list/mod.rs
+-rw-r--r--   0     1001      123    19939 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/categorical/builder.rs
+-rw-r--r--   0     1001      123     3688 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/categorical/from.rs
+-rw-r--r--   0     1001      123     5753 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/categorical/merge.rs
+-rw-r--r--   0     1001      123    10219 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/categorical/mod.rs
+-rw-r--r--   0     1001      123     1263 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/append.rs
+-rw-r--r--   0     1001      123      358 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/full.rs
+-rw-r--r--   0     1001      123      192 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/mod.rs
+-rw-r--r--   0     1001      123     2731 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/take_random.rs
+-rw-r--r--   0     1001      123     2179 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/unique.rs
+-rw-r--r--   0     1001      123      925 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/zip.rs
+-rw-r--r--   0     1001      123     6805 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/categorical/stringcache.rs
+-rw-r--r--   0     1001      123     1604 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/date.rs
+-rw-r--r--   0     1001      123     4105 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/datetime.rs
+-rw-r--r--   0     1001      123     4443 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/decimal.rs
+-rw-r--r--   0     1001      123     2434 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/duration.rs
+-rw-r--r--   0     1001      123     2556 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/mod.rs
+-rw-r--r--   0     1001      123      476 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/struct_/from.rs
+-rw-r--r--   0     1001      123    15983 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/struct_/mod.rs
+-rw-r--r--   0     1001      123     1182 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/time.rs
+-rw-r--r--   0     1001      123    23398 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/mod.rs
+-rw-r--r--   0     1001      123     9064 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ndarray.rs
+-rw-r--r--   0     1001      123     4484 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/object/builder.rs
+-rw-r--r--   0     1001      123     1543 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/object/extension/drop.rs
+-rw-r--r--   0     1001      123     3097 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/object/extension/list.rs
+-rw-r--r--   0     1001      123     7039 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/object/extension/mod.rs
+-rw-r--r--   0     1001      123     3410 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/object/extension/polars_extension.rs
+-rw-r--r--   0     1001      123      137 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/object/is_valid.rs
+-rw-r--r--   0     1001      123     4419 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/object/iterator.rs
+-rw-r--r--   0     1001      123     4806 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/object/mod.rs
+-rw-r--r--   0     1001      123     2956 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/object/registry.rs
+-rw-r--r--   0     1001      123      272 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/abs.rs
+-rw-r--r--   0     1001      123    32843 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/aggregate/mod.rs
+-rw-r--r--   0     1001      123    10025 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/aggregate/quantile.rs
+-rw-r--r--   0     1001      123     2880 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/aggregate/var.rs
+-rw-r--r--   0     1001      123    10584 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/any_value.rs
+-rw-r--r--   0     1001      123     4526 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/append.rs
+-rw-r--r--   0     1001      123    30392 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/apply.rs
+-rw-r--r--   0     1001      123    12799 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/bit_repr.rs
+-rw-r--r--   0     1001      123     6332 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/chunkops.rs
+-rw-r--r--   0     1001      123    11537 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/compare_inner.rs
+-rw-r--r--   0     1001      123     1737 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/concat_str.rs
+-rw-r--r--   0     1001      123     4801 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/cum_agg.rs
+-rw-r--r--   0     1001      123      908 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/decimal.rs
+-rw-r--r--   0     1001      123     7056 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/downcast.rs
+-rw-r--r--   0     1001      123    20007 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/explode.rs
+-rw-r--r--   0     1001      123     8691 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/explode_and_offsets.rs
+-rw-r--r--   0     1001      123     9103 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/extend.rs
+-rw-r--r--   0     1001      123    13777 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/fill_null.rs
+-rw-r--r--   0     1001      123     6356 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/filter.rs
+-rw-r--r--   0     1001      123     5886 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/full.rs
+-rw-r--r--   0     1001      123        1 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/interpolate.rs
+-rw-r--r--   0     1001      123    16992 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/is_in.rs
+-rw-r--r--   0     1001      123        1 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/len.rs
+-rw-r--r--   0     1001      123     2658 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/min_max_binary.rs
+-rw-r--r--   0     1001      123    23364 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/mod.rs
+-rw-r--r--   0     1001      123     2414 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/nulls.rs
+-rw-r--r--   0     1001      123      593 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/peaks.rs
+-rw-r--r--   0     1001      123     4327 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/repeat_by.rs
+-rw-r--r--   0     1001      123     2771 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/reverse.rs
+-rw-r--r--   0     1001      123    10267 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/rolling_window.rs
+-rw-r--r--   0     1001      123    12458 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/set.rs
+-rw-r--r--   0     1001      123     7391 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/shift.rs
+-rw-r--r--   0     1001      123     2299 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/sort/arg_sort.rs
+-rw-r--r--   0     1001      123     5522 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/sort/arg_sort_multiple.rs
+-rw-r--r--   0     1001      123     7592 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/sort/categorical.rs
+-rw-r--r--   0     1001      123    28481 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/sort/mod.rs
+-rw-r--r--   0     1001      123      380 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/sort/slice.rs
+-rw-r--r--   0     1001      123    22089 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/take/mod.rs
+-rw-r--r--   0     1001      123     7848 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/take/take_chunked.rs
+-rw-r--r--   0     1001      123      301 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/take/take_every.rs
+-rw-r--r--   0     1001      123    16256 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/take/take_random.rs
+-rw-r--r--   0     1001      123     6275 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/take/take_single.rs
+-rw-r--r--   0     1001      123     6072 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/take/traits.rs
+-rw-r--r--   0     1001      123      459 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/tile.rs
+-rw-r--r--   0     1001      123    12658 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/unique/mod.rs
+-rw-r--r--   0     1001      123    14620 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/unique/rank.rs
+-rw-r--r--   0     1001      123     5840 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/zip.rs
+-rw-r--r--   0     1001      123     9093 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/random.rs
+-rw-r--r--   0     1001      123     1875 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/temporal/conversion.rs
+-rw-r--r--   0     1001      123     2826 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/temporal/date.rs
+-rw-r--r--   0     1001      123     9382 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/temporal/datetime.rs
+-rw-r--r--   0     1001      123     3201 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/temporal/duration.rs
+-rw-r--r--   0     1001      123     1061 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/temporal/mod.rs
+-rw-r--r--   0     1001      123     3042 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/temporal/time.rs
+-rw-r--r--   0     1001      123      872 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/to_vec.rs
+-rw-r--r--   0     1001      123     8114 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/trusted_len.rs
+-rw-r--r--   0     1001      123    25856 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/upstream_traits.rs
+-rw-r--r--   0     1001      123     7955 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/cloud.rs
+-rw-r--r--   0     1001      123     1549 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/config.rs
+-rw-r--r--   0     1001      123     4497 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/datatypes/_serde.rs
+-rw-r--r--   0     1001      123     2509 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/datatypes/aliases.rs
+-rw-r--r--   0     1001      123    42788 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/datatypes/any_value.rs
+-rw-r--r--   0     1001      123    13376 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/datatypes/dtype.rs
+-rw-r--r--   0     1001      123     5609 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/datatypes/field.rs
+-rw-r--r--   0     1001      123     8059 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/datatypes/mod.rs
+-rw-r--r--   0     1001      123     2016 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/datatypes/time_unit.rs
+-rw-r--r--   0     1001      123      118 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/doc/changelog/mod.rs
+-rw-r--r--   0     1001      123      898 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/doc/changelog/v0_10_0_11.rs
+-rw-r--r--   0     1001      123      481 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/doc/changelog/v0_3.rs
+-rw-r--r--   0     1001      123      293 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/doc/changelog/v0_4.rs
+-rw-r--r--   0     1001      123      499 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/doc/changelog/v0_5.rs
+-rw-r--r--   0     1001      123      288 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/doc/changelog/v0_6.rs
+-rw-r--r--   0     1001      123     1071 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/doc/changelog/v0_7.rs
+-rw-r--r--   0     1001      123      819 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/doc/changelog/v0_8.rs
+-rw-r--r--   0     1001      123      596 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/doc/changelog/v0_9.rs
+-rw-r--r--   0     1001      123       43 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/doc/mod.rs
+-rw-r--r--   0     1001      123       25 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/error.rs
+-rw-r--r--   0     1001      123      263 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/export.rs
+-rw-r--r--   0     1001      123    38812 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/fmt.rs
+-rw-r--r--   0     1001      123     5111 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/arithmetic.rs
+-rw-r--r--   0     1001      123     9916 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/asof_join/asof.rs
+-rw-r--r--   0     1001      123    35734 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/asof_join/groups.rs
+-rw-r--r--   0     1001      123     7168 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/asof_join/mod.rs
+-rw-r--r--   0     1001      123      559 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/chunks.rs
+-rw-r--r--   0     1001      123     5181 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/cross_join.rs
+-rw-r--r--   0     1001      123    16841 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/explode.rs
+-rw-r--r--   0     1001      123     1019 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/from.rs
+-rw-r--r--   0     1001      123    19239 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/groupby/aggregations/agg_list.rs
+-rw-r--r--   0     1001      123     4113 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/groupby/aggregations/boolean.rs
+-rw-r--r--   0     1001      123     7749 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/groupby/aggregations/dispatch.rs
+-rw-r--r--   0     1001      123    41956 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/groupby/aggregations/mod.rs
+-rw-r--r--   0     1001      123     5634 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/groupby/aggregations/utf8.rs
+-rw-r--r--   0     1001      123      218 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/groupby/expr.rs
+-rw-r--r--   0     1001      123    22841 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/groupby/hashing.rs
+-rw-r--r--   0     1001      123    14380 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/groupby/into_groups.rs
+-rw-r--r--   0     1001      123    39618 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/groupby/mod.rs
+-rw-r--r--   0     1001      123    10658 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/groupby/perfect.rs
+-rw-r--r--   0     1001      123    19771 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/groupby/proxy.rs
+-rw-r--r--   0     1001      123     5416 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/hash_join/args.rs
+-rw-r--r--   0     1001      123    13204 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/hash_join/mod.rs
+-rw-r--r--   0     1001      123    22364 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/hash_join/multiple_keys.rs
+-rw-r--r--   0     1001      123     2400 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/hash_join/single_keys.rs
+-rw-r--r--   0     1001      123    17372 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/hash_join/single_keys_dispatch.rs
+-rw-r--r--   0     1001      123     4677 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/hash_join/single_keys_inner.rs
+-rw-r--r--   0     1001      123     6502 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/hash_join/single_keys_left.rs
+-rw-r--r--   0     1001      123     4665 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/hash_join/single_keys_outer.rs
+-rw-r--r--   0     1001      123     3913 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/hash_join/single_keys_semi_anti.rs
+-rw-r--r--   0     1001      123    12430 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/hash_join/sort_merge.rs
+-rw-r--r--   0     1001      123     3865 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/hash_join/zip_outer.rs
+-rw-r--r--   0     1001      123   126958 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/mod.rs
+-rw-r--r--   0     1001      123    28256 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/row/av_buffer.rs
+-rw-r--r--   0     1001      123     5183 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/row/dataframe.rs
+-rw-r--r--   0     1001      123     6036 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/row/mod.rs
+-rw-r--r--   0     1001      123    12329 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/row/transpose.rs
+-rw-r--r--   0     1001      123     3115 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/top_k.rs
+-rw-r--r--   0     1001      123     1388 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/upstream_traits.rs
+-rw-r--r--   0     1001      123    10198 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/functions.rs
+-rw-r--r--   0     1001      123     2149 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/hashing/fx.rs
+-rw-r--r--   0     1001      123     1503 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/hashing/identity.rs
+-rw-r--r--   0     1001      123      457 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/hashing/mod.rs
+-rw-r--r--   0     1001      123     2684 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/hashing/partition.rs
+-rw-r--r--   0     1001      123    17704 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/hashing/vector_hasher.rs
+-rw-r--r--   0     1001      123     2017 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/lib.rs
+-rw-r--r--   0     1001      123    15763 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/named_from.rs
+-rw-r--r--   0     1001      123     2522 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/prelude.rs
+-rw-r--r--   0     1001      123    18589 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/schema.rs
+-rw-r--r--   0     1001      123     3983 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/serde/chunked_array.rs
+-rw-r--r--   0     1001      123     1094 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/serde/df.rs
+-rw-r--r--   0     1001      123     4734 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/serde/mod.rs
+-rw-r--r--   0     1001      123     9938 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/serde/series.rs
+-rw-r--r--   0     1001      123    18517 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/any_value.rs
+-rw-r--r--   0     1001      123    28755 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/arithmetic/borrowed.rs
+-rw-r--r--   0     1001      123      222 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/arithmetic/mod.rs
+-rw-r--r--   0     1001      123     3546 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/arithmetic/owned.rs
+-rw-r--r--   0     1001      123    18961 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/comparison.rs
+-rw-r--r--   0     1001      123    29853 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/from.rs
+-rw-r--r--   0     1001      123     6172 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/array.rs
+-rw-r--r--   0     1001      123     9163 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/binary.rs
+-rw-r--r--   0     1001      123    10909 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/boolean.rs
+-rw-r--r--   0     1001      123    12888 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/categorical.rs
+-rw-r--r--   0     1001      123    18312 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/dates_time.rs
+-rw-r--r--   0     1001      123    15108 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/datetime.rs
+-rw-r--r--   0     1001      123     8088 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/decimal.rs
+-rw-r--r--   0     1001      123    14808 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/duration.rs
+-rw-r--r--   0     1001      123    14161 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/floats.rs
+-rw-r--r--   0     1001      123     6152 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/list.rs
+-rw-r--r--   0     1001      123    18495 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/mod.rs
+-rw-r--r--   0     1001      123     5581 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/null.rs
+-rw-r--r--   0     1001      123     8013 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/object.rs
+-rw-r--r--   0     1001      123    11887 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/struct_.rs
+-rw-r--r--   0     1001      123     9681 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/utf8.rs
+-rw-r--r--   0     1001      123     4471 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/into.rs
+-rw-r--r--   0     1001      123     6581 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/iterator.rs
+-rw-r--r--   0     1001      123    39202 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/mod.rs
+-rw-r--r--   0     1001      123      853 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/ops/diff.rs
+-rw-r--r--   0     1001      123     5814 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/ops/downcast.rs
+-rw-r--r--   0     1001      123     3601 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/ops/ewm.rs
+-rw-r--r--   0     1001      123      413 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/ops/extend.rs
+-rw-r--r--   0     1001      123      562 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/ops/mod.rs
+-rw-r--r--   0     1001      123     5992 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/ops/moment.rs
+-rw-r--r--   0     1001      123     3390 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/ops/null.rs
+-rw-r--r--   0     1001      123     1347 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/ops/pct_change.rs
+-rw-r--r--   0     1001      123     4620 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/ops/round.rs
+-rw-r--r--   0     1001      123     5091 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/ops/to_list.rs
+-rw-r--r--   0     1001      123     1476 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/ops/unique.rs
+-rw-r--r--   0     1001      123    18574 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/series_trait.rs
+-rw-r--r--   0     1001      123     2912 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/unstable.rs
+-rw-r--r--   0     1001      123     7046 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/testing.rs
+-rw-r--r--   0     1001      123      508 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/tests.rs
+-rw-r--r--   0     1001      123     2492 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/utils/flatten.rs
+-rw-r--r--   0     1001      123    31194 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/utils/mod.rs
+-rw-r--r--   0     1001      123     1600 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/utils/series.rs
+-rw-r--r--   0     1001      123    13201 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/utils/supertype.rs
+-rw-r--r--   0        0        0     1998 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/LICENSE
+-rw-r--r--   0     1001      123      165 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/README.md
+-rw-r--r--   0     1001      123       98 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/mod.rs
+-rw-r--r--   0     1001      123     1219 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/operators/filter.rs
+-rw-r--r--   0     1001      123     4103 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/operators/function.rs
+-rw-r--r--   0     1001      123      266 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/operators/mod.rs
+-rw-r--r--   0     1001      123      682 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/operators/pass.rs
+-rw-r--r--   0     1001      123      548 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/operators/placeholder.rs
+-rw-r--r--   0     1001      123     5454 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/operators/projection.rs
+-rw-r--r--   0     1001      123     3559 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/operators/reproject.rs
+-rw-r--r--   0     1001      123     6479 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/file_sink.rs
+-rw-r--r--   0     1001      123    11288 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/convert.rs
+-rw-r--r--   0     1001      123     1207 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/count.rs
+-rw-r--r--   0     1001      123     1888 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/first.rs
+-rw-r--r--   0     1001      123     4554 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/interface.rs
+-rw-r--r--   0     1001      123     1746 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/last.rs
+-rw-r--r--   0     1001      123     5413 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/mean.rs
+-rw-r--r--   0     1001      123     4951 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/min_max.rs
+-rw-r--r--   0     1001      123      211 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/mod.rs
+-rw-r--r--   0     1001      123      856 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/null.rs
+-rw-r--r--   0     1001      123     4294 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/sum.rs
+-rw-r--r--   0     1001      123     4109 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/eval.rs
+-rw-r--r--   0     1001      123     7400 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/global.rs
+-rw-r--r--   0     1001      123    10542 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/hash_table.rs
+-rw-r--r--   0     1001      123     3589 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/mod.rs
+-rw-r--r--   0     1001      123     2767 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/ooc_state.rs
+-rw-r--r--   0     1001      123     6326 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/sink.rs
+-rw-r--r--   0     1001      123     3120 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/source.rs
+-rw-r--r--   0     1001      123    10103 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/thread_local.rs
+-rw-r--r--   0     1001      123     2119 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/mod.rs
+-rw-r--r--   0     1001      123     4695 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/ooc.rs
+-rw-r--r--   0     1001      123     1887 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/ooc_state.rs
+-rw-r--r--   0     1001      123    20783 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/primitive/mod.rs
+-rw-r--r--   0     1001      123    23825 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/string.rs
+-rw-r--r--   0     1001      123     2457 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/utils.rs
+-rw-r--r--   0     1001      123     9239 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/io.rs
+-rw-r--r--   0     1001      123     5439 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/joins/cross.rs
+-rw-r--r--   0     1001      123    12056 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/joins/generic_build.rs
+-rw-r--r--   0     1001      123    11845 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/joins/inner_left.rs
+-rw-r--r--   0     1001      123      178 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/joins/mod.rs
+-rw-r--r--   0     1001      123     2241 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/memory.rs
+-rw-r--r--   0     1001      123      589 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/mod.rs
+-rw-r--r--   0     1001      123     1492 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/ordered.rs
+-rw-r--r--   0     1001      123     1824 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/reproject.rs
+-rw-r--r--   0     1001      123     3108 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/slice.rs
+-rw-r--r--   0     1001      123      130 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/sort/mod.rs
+-rw-r--r--   0     1001      123     6852 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/sort/ooc.rs
+-rw-r--r--   0     1001      123     7404 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/sort/sink.rs
+-rw-r--r--   0     1001      123    11718 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/sort/sink_multiple.rs
+-rw-r--r--   0     1001      123     3908 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/sort/source.rs
+-rw-r--r--   0     1001      123      526 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/utils.rs
+-rw-r--r--   0     1001      123     6208 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sources/csv.rs
+-rw-r--r--   0     1001      123     1231 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sources/frame.rs
+-rw-r--r--   0     1001      123     1000 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sources/ipc_one_shot.rs
+-rw-r--r--   0     1001      123      366 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sources/mod.rs
+-rw-r--r--   0     1001      123     4569 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sources/parquet.rs
+-rw-r--r--   0     1001      123     1146 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sources/reproject.rs
+-rw-r--r--   0     1001      123     1022 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sources/union.rs
+-rw-r--r--   0     1001      123      448 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/expressions.rs
+-rw-r--r--   0     1001      123      272 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/lib.rs
+-rw-r--r--   0     1001      123      719 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/operators/chunks.rs
+-rw-r--r--   0     1001      123      474 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/operators/context.rs
+-rw-r--r--   0     1001      123      223 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/operators/mod.rs
+-rw-r--r--   0     1001      123      514 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/operators/operator.rs
+-rw-r--r--   0     1001      123      626 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/operators/sink.rs
+-rw-r--r--   0     1001      123      241 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/operators/source.rs
+-rw-r--r--   0     1001      123        1 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/pipeline/config.rs
+-rw-r--r--   0     1001      123    22618 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/pipeline/convert.rs
+-rw-r--r--   0     1001      123    20362 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/pipeline/dispatcher.rs
+-rw-r--r--   0     1001      123     1155 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/pipeline/mod.rs
+-rw-r--r--   0        0        0    10781 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/LICENSE
+-rw-r--r--   0     1001      123     3741 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/Makefile
+-rw-r--r--   0     1001      123      215 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/build.rs
+-rw-r--r--   0     1001      123       78 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/clippy.toml
+-rw-r--r--   0     1001      123    17620 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/src/docs/eager.rs
+-rw-r--r--   0     1001      123     8822 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/src/docs/lazy.rs
+-rw-r--r--   0     1001      123       50 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/src/docs/mod.rs
+-rw-r--r--   0     1001      123     3806 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/src/docs/performance.rs
+-rw-r--r--   0     1001      123       59 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/src/export.rs
+-rw-r--r--   0     1001      123    19848 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/src/lib.rs
+-rw-r--r--   0     1001      123      387 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/src/prelude.rs
+-rw-r--r--   0     1001      123       54 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/src/sql.rs
+-rw-r--r--   0     1001      123     4243 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/core/date_like.rs
+-rw-r--r--   0     1001      123     2401 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/core/groupby.rs
+-rw-r--r--   0     1001      123    17838 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/core/joins.rs
+-rw-r--r--   0     1001      123      545 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/core/list.rs
+-rw-r--r--   0     1001      123      198 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/core/mod.rs
+-rw-r--r--   0     1001      123       24 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/core/ops/mod.rs
+-rw-r--r--   0     1001      123      449 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/core/ops/take.rs
+-rw-r--r--   0     1001      123     6259 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/core/pivot.rs
+-rw-r--r--   0     1001      123     1102 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/core/random.rs
+-rw-r--r--   0     1001      123    10952 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/core/rolling_window.rs
+-rw-r--r--   0     1001      123     1093 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/core/series.rs
+-rw-r--r--   0     1001      123      370 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/core/utils.rs
+-rw-r--r--   0     1001      123    30377 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/io/csv.rs
+-rw-r--r--   0     1001      123     4500 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/io/ipc_stream.rs
+-rw-r--r--   0     1001      123     6972 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/io/json.rs
+-rw-r--r--   0     1001      123      378 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/io/mod.rs
+-rw-r--r--   0     1001      123      531 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/io/parquet.rs
+-rw-r--r--   0     1001      123     1530 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/joins.rs
+-rw-r--r--   0     1001      123     2452 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/aggregation.rs
+-rw-r--r--   0     1001      123      830 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/cse.rs
+-rw-r--r--   0     1001      123      500 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/explodes.rs
+-rw-r--r--   0     1001      123     2281 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/expressions/apply.rs
+-rw-r--r--   0     1001      123    10351 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/expressions/arity.rs
+-rw-r--r--   0     1001      123     1065 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/expressions/expand.rs
+-rw-r--r--   0     1001      123     1008 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/expressions/filter.rs
+-rw-r--r--   0     1001      123      428 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/expressions/is_in.rs
+-rw-r--r--   0     1001      123      121 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/expressions/mod.rs
+-rw-r--r--   0     1001      123      659 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/expressions/slice.rs
+-rw-r--r--   0     1001      123    10655 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/expressions/window.rs
+-rw-r--r--   0     1001      123      584 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/folds.rs
+-rw-r--r--   0     1001      123      557 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/functions.rs
+-rw-r--r--   0     1001      123     4485 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/groupby.rs
+-rw-r--r--   0     1001      123     1681 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/groupby_dynamic.rs
+-rw-r--r--   0     1001      123      703 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/mod.rs
+-rw-r--r--   0     1001      123     6091 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/predicate_queries.rs
+-rw-r--r--   0     1001      123     4482 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/projection_queries.rs
+-rw-r--r--   0     1001      123     6585 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/queries.rs
+-rw-r--r--   0     1001      123      860 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/schema.rs
+-rw-r--r--   0     1001      123      151 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/main.rs
+-rw-r--r--   0     1001      123    12591 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/schema.rs
+-rw-r--r--   0     1001      123     1899 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/time/date_range.rs
+-rw-r--r--   0     1001      123       16 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/time/mod.rs
+-rw-r--r--   0        0        0     5470 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/LICENSE
+-rw-r--r--   0     1001      123       95 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/constants.rs
+-rw-r--r--   0     1001      123    16258 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dot.rs
+-rw-r--r--   0     1001      123     5595 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/arithmetic.rs
+-rw-r--r--   0     1001      123     4800 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/arity.rs
+-rw-r--r--   0     1001      123     1278 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/array.rs
+-rw-r--r--   0     1001      123      935 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/binary.rs
+-rw-r--r--   0     1001      123      782 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/cat.rs
+-rw-r--r--   0     1001      123    10131 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/dt.rs
+-rw-r--r--   0     1001      123     9478 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/expr.rs
+-rw-r--r--   0     1001      123     8359 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/expr_dyn_fn.rs
+-rw-r--r--   0     1001      123      753 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/from.rs
+-rw-r--r--   0     1001      123       85 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/abs.rs
+-rw-r--r--   0     1001      123     1431 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/arg_where.rs
+-rw-r--r--   0     1001      123     1074 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/array.rs
+-rw-r--r--   0     1001      123     1327 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/binary.rs
+-rw-r--r--   0     1001      123     4263 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/boolean.rs
+-rw-r--r--   0     1001      123     1910 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/bounds.rs
+-rw-r--r--   0     1001      123     1784 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/cat.rs
+-rw-r--r--   0     1001      123      344 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/clip.rs
+-rw-r--r--   0     1001      123      257 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/concat.rs
+-rw-r--r--   0     1001      123     6125 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/correlation.rs
+-rw-r--r--   0     1001      123     1593 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/cum.rs
+-rw-r--r--   0     1001      123    10894 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/datetime.rs
+-rw-r--r--   0     1001      123     1237 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/dispatch.rs
+-rw-r--r--   0     1001      123     2567 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/fill_null.rs
+-rw-r--r--   0     1001      123      992 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/fused.rs
+-rw-r--r--   0     1001      123     8976 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/list.rs
+-rw-r--r--   0     1001      123      581 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/log.rs
+-rw-r--r--   0     1001      123    26960 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/mod.rs
+-rw-r--r--   0     1001      123      462 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/nan.rs
+-rw-r--r--   0     1001      123     5017 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/pow.rs
+-rw-r--r--   0     1001      123     1410 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/random.rs
+-rw-r--r--   0     1001      123     5138 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/range.rs
+-rw-r--r--   0     1001      123      152 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/rolling.rs
+-rw-r--r--   0     1001      123      260 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/round.rs
+-rw-r--r--   0     1001      123      200 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/row_hash.rs
+-rw-r--r--   0     1001      123    20944 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/schema.rs
+-rw-r--r--   0     1001      123      306 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/search_sorted.rs
+-rw-r--r--   0     1001      123     3812 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/shift_and_fill.rs
+-rw-r--r--   0     1001      123     1517 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/shrink_type.rs
+-rw-r--r--   0     1001      123      972 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/sign.rs
+-rw-r--r--   0     1001      123    22698 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/strings.rs
+-rw-r--r--   0     1001      123     1017 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/struct_.rs
+-rw-r--r--   0     1001      123     8951 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/temporal.rs
+-rw-r--r--   0     1001      123     8253 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/trigonometry.rs
+-rw-r--r--   0     1001      123      170 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/unique.rs
+-rw-r--r--   0     1001      123     1155 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/functions/arity.rs
+-rw-r--r--   0     1001      123      611 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/functions/coerce.rs
+-rw-r--r--   0     1001      123     2717 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/functions/concat.rs
+-rw-r--r--   0     1001      123     4399 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/functions/correlation.rs
+-rw-r--r--   0     1001      123     8987 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/functions/horizontal.rs
+-rw-r--r--   0     1001      123     1045 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/functions/index.rs
+-rw-r--r--   0     1001      123      968 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/functions/mod.rs
+-rw-r--r--   0     1001      123     5417 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/functions/range.rs
+-rw-r--r--   0     1001      123     1308 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/functions/selectors.rs
+-rw-r--r--   0     1001      123     1973 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/functions/syntactic_sugar.rs
+-rw-r--r--   0     1001      123    11285 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/functions/temporal.rs
+-rw-r--r--   0     1001      123    12280 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/list.rs
+-rw-r--r--   0     1001      123     4501 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/meta.rs
+-rw-r--r--   0     1001      123    61459 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/mod.rs
+-rw-r--r--   0     1001      123       40 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/names.rs
+-rw-r--r--   0     1001      123     2658 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/options.rs
+-rw-r--r--   0     1001      123     7426 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/python_udf.rs
+-rw-r--r--   0     1001      123     1432 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/random.rs
+-rw-r--r--   0     1001      123     1068 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/selector.rs
+-rw-r--r--   0     1001      123    17989 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/string.rs
+-rw-r--r--   0     1001      123     2715 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/struct_.rs
+-rw-r--r--   0     1001      123       38 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/frame/mod.rs
+-rw-r--r--   0     1001      123     1057 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/frame/opt_state.rs
+-rw-r--r--   0     1001      123      466 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/global.rs
+-rw-r--r--   0     1001      123      272 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/lib.rs
+-rw-r--r--   0     1001      123    13304 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/aexpr/mod.rs
+-rw-r--r--   0     1001      123    11836 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/aexpr/schema.rs
+-rw-r--r--   0     1001      123    16469 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/alp.rs
+-rw-r--r--   0     1001      123     1622 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/anonymous_scan.rs
+-rw-r--r--   0     1001      123     1428 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/apply.rs
+-rw-r--r--   0     1001      123    26297 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/builder.rs
+-rw-r--r--   0     1001      123     7016 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/builder_alp.rs
+-rw-r--r--   0     1001      123     2145 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/builder_functions.rs
+-rw-r--r--   0     1001      123    28111 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/conversion.rs
+-rw-r--r--   0     1001      123      301 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/debug.rs
+-rw-r--r--   0     1001      123     1518 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/file_scan.rs
+-rw-r--r--   0     1001      123    14337 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/format.rs
+-rw-r--r--   0     1001      123      895 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/functions/drop.rs
+-rw-r--r--   0     1001      123      137 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/functions/explode.rs
+-rw-r--r--   0     1001      123     1169 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/functions/merge_sorted.rs
+-rw-r--r--   0     1001      123    14110 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/functions/mod.rs
+-rw-r--r--   0     1001      123     1031 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/functions/python_udf.rs
+-rw-r--r--   0     1001      123     1330 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/functions/rename.rs
+-rw-r--r--   0     1001      123     7011 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/iterator.rs
+-rw-r--r--   0     1001      123    10559 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/lit.rs
+-rw-r--r--   0     1001      123     8100 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/mod.rs
+-rw-r--r--   0     1001      123     7478 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/cache_states.rs
+-rw-r--r--   0     1001      123    13553 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/cse.rs
+-rw-r--r--   0     1001      123    22707 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/cse_expr.rs
+-rw-r--r--   0     1001      123     2100 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/delay_rechunk.rs
+-rw-r--r--   0     1001      123     3236 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/drop_nulls.rs
+-rw-r--r--   0     1001      123     4659 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/fast_projection.rs
+-rw-r--r--   0     1001      123     9013 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/file_caching.rs
+-rw-r--r--   0     1001      123     1556 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/flatten_union.rs
+-rw-r--r--   0     1001      123     6433 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/fused.rs
+-rw-r--r--   0     1001      123     7446 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/mod.rs
+-rw-r--r--   0     1001      123     4695 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/join.rs
+-rw-r--r--   0     1001      123     1222 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/keys.rs
+-rw-r--r--   0     1001      123    22053 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/mod.rs
+-rw-r--r--   0     1001      123     2571 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/rename.rs
+-rw-r--r--   0     1001      123    16310 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/utils.rs
+-rw-r--r--   0     1001      123     1941 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/functions/melt.rs
+-rw-r--r--   0     1001      123     4402 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/functions/mod.rs
+-rw-r--r--   0     1001      123     1799 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/generic.rs
+-rw-r--r--   0     1001      123     3274 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/groupby.rs
+-rw-r--r--   0     1001      123     2638 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/hstack.rs
+-rw-r--r--   0     1001      123    15903 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/joins.rs
+-rw-r--r--   0     1001      123    25419 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/mod.rs
+-rw-r--r--   0     1001      123     3707 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/projection.rs
+-rw-r--r--   0     1001      123     2639 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/rename.rs
+-rw-r--r--   0     1001      123     3514 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/semi_anti_join.rs
+-rw-r--r--   0     1001      123    29027 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/simplify_expr.rs
+-rw-r--r--   0     1001      123     3590 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/slice_pushdown_expr.rs
+-rw-r--r--   0     1001      123    12889 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/slice_pushdown_lp.rs
+-rw-r--r--   0     1001      123     4189 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/stack_opt.rs
+-rw-r--r--   0     1001      123     9796 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/type_coercion/binary.rs
+-rw-r--r--   0     1001      123    20348 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/type_coercion/mod.rs
+-rw-r--r--   0     1001      123     9748 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/options.rs
+-rw-r--r--   0     1001      123    20318 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/projection.rs
+-rw-r--r--   0     1001      123     2118 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/projection_expr.rs
+-rw-r--r--   0     1001      123     6178 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/pyarrow.rs
+-rw-r--r--   0     1001      123    12397 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/schema.rs
+-rw-r--r--   0     1001      123     6607 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/tree_format.rs
+-rw-r--r--   0     1001      123     7965 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/visitor/expr.rs
+-rw-r--r--   0     1001      123     4175 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/visitor/lp.rs
+-rw-r--r--   0     1001      123      977 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/visitor/mod.rs
+-rw-r--r--   0     1001      123     2923 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/visitor/visitors.rs
+-rw-r--r--   0     1001      123      788 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/prelude.rs
+-rw-r--r--   0     1001      123    12868 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/utils.rs
+-rw-r--r--   0        0        0     1351 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-json/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-json/LICENSE
+-rw-r--r--   0     1001      123    16461 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-json/src/json/deserialize.rs
+-rw-r--r--   0     1001      123     6564 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-json/src/json/infer_schema.rs
+-rw-r--r--   0     1001      123      189 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-json/src/json/mod.rs
+-rw-r--r--   0     1001      123       30 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-json/src/lib.rs
+-rw-r--r--   0     1001      123     1198 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-json/src/ndjson/deserialize.rs
+-rw-r--r--   0     1001      123     4808 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-json/src/ndjson/file.rs
+-rw-r--r--   0     1001      123      143 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-json/src/ndjson/mod.rs
+-rw-r--r--   0        0        0      891 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-error/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-error/LICENSE
+-rw-r--r--   0     1001      123      145 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-error/README.md
+-rw-r--r--   0     1001      123     7602 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-error/src/lib.rs
+-rw-r--r--   0     1001      123      877 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-error/src/warning.rs
+-rw-r--r--   0        0        0     2059 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/LICENSE
+-rw-r--r--   0     1001      123      143 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/README.md
+-rw-r--r--   0     1001      123     1018 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/base_utc_offset.rs
+-rw-r--r--   0     1001      123     3569 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/date.rs
+-rw-r--r--   0     1001      123     6465 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/datetime.rs
+-rw-r--r--   0     1001      123     3305 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/duration.rs
+-rw-r--r--   0     1001      123     6016 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/kernels.rs
+-rw-r--r--   0     1001      123     1062 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/mod.rs
+-rw-r--r--   0     1001      123     6289 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/rolling_window/floats.rs
+-rw-r--r--   0     1001      123     2437 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/rolling_window/ints.rs
+-rw-r--r--   0     1001      123    10941 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/rolling_window/mod.rs
+-rw-r--r--   0     1001      123      413 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/rolling_window/rolling_kernels/mod.rs
+-rw-r--r--   0     1001      123     5502 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/rolling_window/rolling_kernels/no_nulls.rs
+-rw-r--r--   0     1001      123     2372 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/time.rs
+-rw-r--r--   0     1001      123    21380 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/utf8/infer.rs
+-rw-r--r--   0     1001      123    19153 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/utf8/mod.rs
+-rw-r--r--   0     1001      123     3975 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/utf8/patterns.rs
+-rw-r--r--   0     1001      123    11229 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/utf8/strptime.rs
+-rw-r--r--   0     1001      123     3340 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/date_range.rs
+-rw-r--r--   0     1001      123      994 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/dst_offset.rs
+-rw-r--r--   0     1001      123    34816 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/groupby/dynamic.rs
+-rw-r--r--   0     1001      123       88 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/groupby/mod.rs
+-rw-r--r--   0     1001      123      769 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/lib.rs
+-rw-r--r--   0     1001      123     2976 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/month_end.rs
+-rw-r--r--   0     1001      123     3371 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/month_start.rs
+-rw-r--r--   0     1001      123      274 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/prelude.rs
+-rw-r--r--   0     1001      123     1381 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/round.rs
+-rw-r--r--   0     1001      123     3763 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/series/_trait.rs
+-rw-r--r--   0     1001      123      136 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/series/implementations/boolean.rs
+-rw-r--r--   0     1001      123      140 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/series/implementations/categoricals.rs
+-rw-r--r--   0     1001      123      133 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/series/implementations/date.rs
+-rw-r--r--   0     1001      123      137 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/series/implementations/datetime.rs
+-rw-r--r--   0     1001      123      137 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/series/implementations/duration.rs
+-rw-r--r--   0     1001      123     1744 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/series/implementations/floats.rs
+-rw-r--r--   0     1001      123     1673 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/series/implementations/integers.rs
+-rw-r--r--   0     1001      123      133 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/series/implementations/list.rs
+-rw-r--r--   0     1001      123      486 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/series/implementations/mod.rs
+-rw-r--r--   0     1001      123      155 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/series/implementations/object.rs
+-rw-r--r--   0     1001      123      135 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/series/implementations/struct_.rs
+-rw-r--r--   0     1001      123      133 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/series/implementations/time.rs
+-rw-r--r--   0     1001      123      133 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/series/implementations/utf8.rs
+-rw-r--r--   0     1001      123    12791 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/series/mod.rs
+-rw-r--r--   0     1001      123     2044 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/truncate.rs
+-rw-r--r--   0     1001      123     7619 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/upsample.rs
+-rw-r--r--   0     1001      123     3113 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/utils.rs
+-rw-r--r--   0     1001      123     1524 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/windows/bounds.rs
+-rw-r--r--   0     1001      123     2672 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/windows/calendar.rs
+-rw-r--r--   0     1001      123    26093 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/windows/duration.rs
+-rw-r--r--   0     1001      123    20201 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/windows/groupby.rs
+-rw-r--r--   0     1001      123      503 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/windows/mod.rs
+-rw-r--r--   0     1001      123    23627 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/windows/test.rs
+-rw-r--r--   0     1001      123    10954 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/windows/window.rs
+-rw-r--r--   0        0        0     4430 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/LICENSE
+-rw-r--r--   0     1001      123      138 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/README.md
+-rw-r--r--   0     1001      123     2383 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/avro/mod.rs
+-rw-r--r--   0     1001      123     3608 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/avro/read.rs
+-rw-r--r--   0     1001      123     2622 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/avro/write.rs
+-rw-r--r--   0     1001      123     4505 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/cloud/adaptors.rs
+-rw-r--r--   0     1001      123     9506 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/cloud/glob.rs
+-rw-r--r--   0     1001      123     3089 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/cloud/mod.rs
+-rw-r--r--   0     1001      123    28829 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/csv/buffer.rs
+-rw-r--r--   0     1001      123     1815 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/csv/mod.rs
+-rw-r--r--   0     1001      123    19446 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/csv/parser.rs
+-rw-r--r--   0     1001      123    22232 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/csv/read.rs
+-rw-r--r--   0     1001      123    10847 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/csv/read_impl/batched_mmap.rs
+-rw-r--r--   0     1001      123    13959 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/csv/read_impl/batched_read.rs
+-rw-r--r--   0     1001      123    30724 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/csv/read_impl/mod.rs
+-rw-r--r--   0     1001      123    11466 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/csv/splitfields.rs
+-rw-r--r--   0     1001      123    25561 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/csv/utils.rs
+-rw-r--r--   0     1001      123     2796 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/csv/write.rs
+-rw-r--r--   0     1001      123    14759 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/csv/write_impl.rs
+-rw-r--r--   0     1001      123      184 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/export.rs
+-rw-r--r--   0     1001      123     7586 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/ipc/ipc_file.rs
+-rw-r--r--   0     1001      123     9227 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/ipc/ipc_stream.rs
+-rw-r--r--   0     1001      123     3253 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/ipc/mmap.rs
+-rw-r--r--   0     1001      123      401 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/ipc/mod.rs
+-rw-r--r--   0     1001      123     8287 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/ipc/write.rs
+-rw-r--r--   0     1001      123     1471 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/ipc/write_async.rs
+-rw-r--r--   0     1001      123    13375 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/json/mod.rs
+-rw-r--r--   0     1001      123     4771 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/lib.rs
+-rw-r--r--   0     1001      123     1969 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/mmap.rs
+-rw-r--r--   0     1001      123     7744 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/ndjson/buffer.rs
+-rw-r--r--   0     1001      123    12799 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/ndjson/core.rs
+-rw-r--r--   0     1001      123       37 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/ndjson/mod.rs
+-rw-r--r--   0     1001      123      273 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/options.rs
+-rw-r--r--   0     1001      123     7360 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/parquet/async_impl.rs
+-rw-r--r--   0     1001      123     3093 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/parquet/mmap.rs
+-rw-r--r--   0     1001      123     3122 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/parquet/mod.rs
+-rw-r--r--   0     1001      123     4784 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/parquet/predicates.rs
+-rw-r--r--   0     1001      123     9623 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/parquet/read.rs
+-rw-r--r--   0     1001      123    17309 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/parquet/read_impl.rs
+-rw-r--r--   0     1001      123    10129 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/parquet/write.rs
+-rw-r--r--   0     1001      123     5491 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/partition.rs
+-rw-r--r--   0     1001      123     1455 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/predicates.rs
+-rw-r--r--   0     1001      123      621 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/prelude.rs
+-rw-r--r--   0     1001      123      417 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/tests.rs
+-rw-r--r--   0     1001      123     4632 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/utils.rs
+-rw-r--r--   0        0        0     1590 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/LICENSE
+-rw-r--r--   0     1001      123      144 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/README.md
+-rw-r--r--   0     1001      123     1975 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/array/default_arrays.rs
+-rw-r--r--   0     1001      123     1791 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/array/fixed_size_list.rs
+-rw-r--r--   0     1001      123     3773 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/array/get.rs
+-rw-r--r--   0     1001      123     6664 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/array/list.rs
+-rw-r--r--   0     1001      123     8165 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/array/mod.rs
+-rw-r--r--   0     1001      123      878 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/array/null.rs
+-rw-r--r--   0     1001      123     1125 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/array/slice.rs
+-rw-r--r--   0     1001      123     2253 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/array/utf8.rs
+-rw-r--r--   0     1001      123     2294 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/bit_util.rs
+-rw-r--r--   0     1001      123      924 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/bitmap/arity.rs
+-rw-r--r--   0     1001      123       47 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/bitmap/mod.rs
+-rw-r--r--   0     1001      123      819 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/bitmap/mutable.rs
+-rw-r--r--   0     1001      123      370 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/add.rs
+-rw-r--r--   0     1001      123     2181 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/commutative.rs
+-rw-r--r--   0     1001      123     1482 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/div.rs
+-rw-r--r--   0     1001      123     1028 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/mod.rs
+-rw-r--r--   0     1001      123     1177 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/mul.rs
+-rw-r--r--   0     1001      123      508 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/sub.rs
+-rw-r--r--   0     1001      123       51 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/arithmetics/mod.rs
+-rw-r--r--   0     1001      123        1 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/arity.rs
+-rw-r--r--   0     1001      123      727 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/bitwise.rs
+-rw-r--r--   0     1001      123     1206 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/cast.rs
+-rw-r--r--   0     1001      123     3964 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/decimal.rs
+-rw-r--r--   0     1001      123     1250 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/mod.rs
+-rw-r--r--   0     1001      123      391 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/take/bitmap.rs
+-rw-r--r--   0     1001      123     2767 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/take/boolean.rs
+-rw-r--r--   0     1001      123     3511 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/take/fixed_size_list.rs
+-rw-r--r--   0     1001      123    25290 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/take/mod.rs
+-rw-r--r--   0     1001      123      797 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/tile.rs
+-rw-r--r--   0     1001      123     1102 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/conversion.rs
+-rw-r--r--   0     1001      123     1609 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/data_types.rs
+-rw-r--r--   0     1001      123       25 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/error.rs
+-rw-r--r--   0     1001      123       28 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/export.rs
+-rw-r--r--   0     1001      123       26 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/floats/mod.rs
+-rw-r--r--   0     1001      123     2066 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/floats/ord.rs
+-rw-r--r--   0     1001      123     1273 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/index.rs
+-rw-r--r--   0     1001      123      984 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/is_valid.rs
+-rw-r--r--   0     1001      123     5702 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/agg_mean.rs
+-rw-r--r--   0     1001      123     1074 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/comparison.rs
+-rw-r--r--   0     1001      123     1068 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/concatenate.rs
+-rw-r--r--   0     1001      123     5153 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/ewm/average.rs
+-rw-r--r--   0     1001      123     1808 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/ewm/mod.rs
+-rw-r--r--   0     1001      123    25053 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/ewm/variance.rs
+-rw-r--r--   0     1001      123     1406 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/float.rs
+-rw-r--r--   0     1001      123     4908 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/list.rs
+-rw-r--r--   0     1001      123     1885 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/list_bytes_iter.rs
+-rw-r--r--   0     1001      123     9784 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/mod.rs
+-rw-r--r--   0     1001      123     4040 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/mod.rs
+-rw-r--r--   0     1001      123     2019 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/mean.rs
+-rw-r--r--   0     1001      123    13019 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/min_max.rs
+-rw-r--r--   0     1001      123     3848 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/mod.rs
+-rw-r--r--   0     1001      123    11589 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/quantile.rs
+-rw-r--r--   0     1001      123     5684 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/sum.rs
+-rw-r--r--   0     1001      123     7807 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/variance.rs
+-rw-r--r--   0     1001      123     1879 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/nulls/mean.rs
+-rw-r--r--   0     1001      123    14722 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/nulls/min_max.rs
+-rw-r--r--   0     1001      123    10055 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/nulls/mod.rs
+-rw-r--r--   0     1001      123     8128 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/nulls/quantile.rs
+-rw-r--r--   0     1001      123     4821 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/nulls/sum.rs
+-rw-r--r--   0     1001      123     6856 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/nulls/variance.rs
+-rw-r--r--   0     1001      123     8244 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/window.rs
+-rw-r--r--   0     1001      123     4753 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/set.rs
+-rw-r--r--   0     1001      123     4529 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/sort_partition.rs
+-rw-r--r--   0     1001      123     2948 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/sorted_join/inner.rs
+-rw-r--r--   0     1001      123     5974 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/sorted_join/left.rs
+-rw-r--r--   0     1001      123      231 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/sorted_join/mod.rs
+-rw-r--r--   0     1001      123      842 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/string.rs
+-rw-r--r--   0     1001      123     2310 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/take_agg/boolean.rs
+-rw-r--r--   0     1001      123     4315 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/take_agg/mod.rs
+-rw-r--r--   0     1001      123     2606 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/take_agg/var.rs
+-rw-r--r--   0     1001      123     3659 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/time.rs
+-rw-r--r--   0     1001      123      466 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/lib.rs
+-rw-r--r--   0     1001      123      519 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/prelude.rs
+-rw-r--r--   0     1001      123      534 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/slice.rs
+-rw-r--r--   0     1001      123      183 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/time_zone.rs
+-rw-r--r--   0     1001      123      998 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/trusted_len/boolean.rs
+-rw-r--r--   0     1001      123     2821 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/trusted_len/mod.rs
+-rw-r--r--   0     1001      123     2054 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/trusted_len/push_unchecked.rs
+-rw-r--r--   0     1001      123      158 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/trusted_len/rev.rs
+-rw-r--r--   0     1001      123     5233 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/utils.rs
+-rw-r--r--   0        0        0      827 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-algo/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-algo/LICENSE
+-rw-r--r--   0     1001      123      142 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-algo/README.md
+-rw-r--r--   0     1001      123     3503 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-algo/src/algo.rs
+-rw-r--r--   0     1001      123       88 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-algo/src/lib.rs
+-rw-r--r--   0     1001      123       21 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-algo/src/prelude.rs
+-rw-r--r--   0        0        0     1106 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-sql/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-sql/LICENSE
+-rw-r--r--   0     1001      123      466 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-sql/README.md
+-rw-r--r--   0     1001      123    23380 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-sql/src/context.rs
+-rw-r--r--   0     1001      123    30036 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-sql/src/functions.rs
+-rw-r--r--   0     1001      123     2122 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-sql/src/keywords.rs
+-rw-r--r--   0     1001      123      239 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-sql/src/lib.rs
+-rw-r--r--   0     1001      123    22727 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-sql/src/sql_expr.rs
+-rw-r--r--   0     1001      123     4572 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-sql/src/table_functions.rs
+-rw-r--r--   0     1001      123     1682 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/functions_cumulative.rs
+-rw-r--r--   0     1001      123     3063 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/functions_io.rs
+-rw-r--r--   0     1001      123     1843 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/functions_math.rs
+-rw-r--r--   0     1001      123      860 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/functions_meta.rs
+-rw-r--r--   0     1001      123     2982 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/functions_string.rs
+-rw-r--r--   0     1001      123     1056 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/iss_7436.rs
+-rw-r--r--   0     1001      123      902 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/iss_7437.rs
+-rw-r--r--   0     1001      123      652 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/iss_7440.rs
+-rw-r--r--   0     1001      123      700 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/iss_8395.rs
+-rw-r--r--   0     1001      123     1062 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/iss_8419.rs
+-rw-r--r--   0     1001      123     1001 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/ops_distinct_on.rs
+-rw-r--r--   0     1001      123    16683 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/simple_exprs.rs
+-rw-r--r--   0     1001      123     3976 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/statements.rs
+-rw-r--r--   0        0        0      952 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-row/Cargo.toml
+-rw-r--r--   0     1001      123     1055 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-row/LICENSE
+-rw-r--r--   0     1001      123      137 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-row/README.md
+-rw-r--r--   0     1001      123     2377 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-row/src/decode.rs
+-rw-r--r--   0     1001      123    14130 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-row/src/encode.rs
+-rw-r--r--   0     1001      123     7767 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-row/src/fixed.rs
+-rw-r--r--   0     1001      123    13846 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-row/src/lib.rs
+-rw-r--r--   0     1001      123     3019 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-row/src/row.rs
+-rw-r--r--   0     1001      123      682 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-row/src/utils.rs
+-rw-r--r--   0     1001      123     8702 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/local_dependencies/polars-row/src/variable.rs
+-rw-r--r--   0        0        0     4648 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.9/Cargo.toml
+-rw-r--r--   0     1001      123       76 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/.gitignore
+-rw-r--r--   0     1001      123     1055 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/LICENSE
+-rw-r--r--   0     1001      123     2412 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/Makefile
+-rw-r--r--   0     1001      123    11696 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/README.md
+-rw-r--r--   0     1001      123      651 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/build.rs
+-rw-r--r--   0     1001      123       32 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/.gitignore
+-rw-r--r--   0     1001      123      754 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/Makefile
+-rw-r--r--   0     1001      123      318 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/_templates/api_redirect.html
+-rw-r--r--   0     1001      123      151 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/_templates/autosummary/accessor.rst
+-rw-r--r--   0     1001      123      160 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/_templates/autosummary/accessor_attribute.rst
+-rw-r--r--   0     1001      123      168 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/_templates/autosummary/accessor_callable.rst
+-rw-r--r--   0     1001      123      157 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/_templates/autosummary/accessor_method.rst
+-rw-r--r--   0     1001      123      836 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/_templates/autosummary/class.rst
+-rw-r--r--   0     1001      123       94 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/_templates/autosummary/class_without_autosummary.rst
+-rw-r--r--   0     1001      123      406 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/_templates/sidebar-nav-bs.html
+-rw-r--r--   0     1001      123      559 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/requirements-docs.txt
+-rw-r--r--   0     1001      123     1164 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/run_live_docs_server.py
+-rw-r--r--   0     1001      123     1567 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/_static/css/custom.css
+-rw-r--r--   0     1001      123     7414 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/conf.py
+-rw-r--r--   0     1001      123       51 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/index.rst
+-rw-r--r--   0     1001      123     6767 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/api.rst
+-rw-r--r--   0     1001      123     2069 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/config.rst
+-rw-r--r--   0     1001      123      274 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/dataframe/aggregation.rst
+-rw-r--r--   0     1001      123      241 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/dataframe/attributes.rst
+-rw-r--r--   0     1001      123      142 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/dataframe/computation.rst
+-rw-r--r--   0     1001      123      319 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/dataframe/descriptive.rst
+-rw-r--r--   0     1001      123      319 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/dataframe/export.rst
+-rw-r--r--   0     1001      123      464 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/dataframe/groupby.rst
+-rw-r--r--   0     1001      123      379 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/dataframe/index.rst
+-rw-r--r--   0     1001      123      189 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/dataframe/miscellaneous.rst
+-rw-r--r--   0     1001      123     1564 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/dataframe/modify_select.rst
+-rw-r--r--   0     1001      123      673 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/datatypes.rst
+-rw-r--r--   0     1001      123      421 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/exceptions.rst
+-rw-r--r--   0     1001      123      391 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/expressions/aggregation.rst
+-rw-r--r--   0     1001      123      267 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/expressions/array.rst
+-rw-r--r--   0     1001      123      309 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/expressions/binary.rst
+-rw-r--r--   0     1001      123      338 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/expressions/boolean.rst
+-rw-r--r--   0     1001      123      265 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/expressions/categories.rst
+-rw-r--r--   0     1001      123      221 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/expressions/columns.rst
+-rw-r--r--   0     1001      123     1109 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/expressions/computation.rst
+-rw-r--r--   0     1001      123     1387 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/expressions/functions.rst
+-rw-r--r--   0     1001      123      470 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/expressions/index.rst
+-rw-r--r--   0     1001      123      830 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/expressions/list.rst
+-rw-r--r--   0     1001      123      458 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/expressions/meta.rst
+-rw-r--r--   0     1001      123      159 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/expressions/miscellaneous.rst
+-rw-r--r--   0     1001      123     1033 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/expressions/modify_select.rst
+-rw-r--r--   0     1001      123      679 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/expressions/operators.rst
+-rw-r--r--   0     1001      123      977 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/expressions/string.rst
+-rw-r--r--   0     1001      123      254 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/expressions/struct.rst
+-rw-r--r--   0     1001      123     1087 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/expressions/temporal.rst
+-rw-r--r--   0     1001      123       98 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/expressions/window.rst
+-rw-r--r--   0     1001      123      694 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/functions.rst
+-rw-r--r--   0     1001      123      405 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/index.rst
+-rw-r--r--   0     1001      123     1342 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/io.rst
+-rw-r--r--   0     1001      123      277 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/lazyframe/aggregation.rst
+-rw-r--r--   0     1001      123      179 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/lazyframe/attributes.rst
+-rw-r--r--   0     1001      123      146 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/lazyframe/descriptive.rst
+-rw-r--r--   0     1001      123      497 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/lazyframe/groupby.rst
+-rw-r--r--   0     1001      123      354 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/lazyframe/index.rst
+-rw-r--r--   0     1001      123      404 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/lazyframe/miscellaneous.rst
+-rw-r--r--   0     1001      123     1013 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/lazyframe/modify_select.rst
+-rw-r--r--   0     1001      123     3279 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/selectors.rst
+-rw-r--r--   0     1001      123      358 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/series/aggregation.rst
+-rw-r--r--   0     1001      123      277 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/series/array.rst
+-rw-r--r--   0     1001      123      257 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/series/attributes.rst
+-rw-r--r--   0     1001      123      321 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/series/binary.rst
+-rw-r--r--   0     1001      123      117 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/series/boolean.rst
+-rw-r--r--   0     1001      123      271 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/series/categories.rst
+-rw-r--r--   0     1001      123     1119 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/series/computation.rst
+-rw-r--r--   0     1001      123      744 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/series/descriptive.rst
+-rw-r--r--   0     1001      123      240 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/series/export.rst
+-rw-r--r--   0     1001      123      437 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/series/index.rst
+-rw-r--r--   0     1001      123      894 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/series/list.rst
+-rw-r--r--   0     1001      123      236 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/series/miscellaneous.rst
+-rw-r--r--   0     1001      123     1128 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/series/modify_select.rst
+-rw-r--r--   0     1001      123     1049 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/series/string.rst
+-rw-r--r--   0     1001      123      421 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/series/struct.rst
+-rw-r--r--   0     1001      123     1247 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/series/temporal.rst
+-rw-r--r--   0     1001      123      503 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/sql.rst
+-rw-r--r--   0     1001      123     8067 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/testing.rst
+-rw-r--r--   0     1001      123      168 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/docs/source/reference/utils.rst
+-rw-r--r--   0     1001      123     6793 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/__init__.py
+-rw-r--r--   0     1001      123      298 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/_reexport.py
+-rw-r--r--   0     1001      123    13229 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/api.py
+-rw-r--r--   0     1001      123    29719 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/config.py
+-rw-r--r--   0     1001      123    28002 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/convert.py
+-rw-r--r--   0     1001      123       77 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/dataframe/__init__.py
+-rw-r--r--   0     1001      123     5227 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/dataframe/_html.py
+-rw-r--r--   0     1001      123   330849 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/dataframe/frame.py
+-rw-r--r--   0     1001      123    42605 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/dataframe/groupby.py
+-rw-r--r--   0     1001      123     2692 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/datatypes/__init__.py
+-rw-r--r--   0     1001      123    18791 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/datatypes/classes.py
+-rw-r--r--   0     1001      123     1690 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/datatypes/constants.py
+-rw-r--r--   0     1001      123     4962 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/datatypes/constructor.py
+-rw-r--r--   0     1001      123    15527 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/datatypes/convert.py
+-rw-r--r--   0     1001      123     7373 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/dependencies.py
+-rw-r--r--   0     1001      123     4041 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/exceptions.py
+-rw-r--r--   0     1001      123      111 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/expr/__init__.py
+-rw-r--r--   0     1001      123     3020 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/expr/array.py
+-rw-r--r--   0     1001      123    10524 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/expr/binary.py
+-rw-r--r--   0     1001      123     2351 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/expr/categorical.py
+-rw-r--r--   0     1001      123    86560 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/expr/datetime.py
+-rw-r--r--   0     1001      123   326339 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/expr/expr.py
+-rw-r--r--   0     1001      123    32168 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/expr/list.py
+-rw-r--r--   0     1001      123     4716 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/expr/meta.py
+-rw-r--r--   0     1001      123    60655 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/expr/string.py
+-rw-r--r--   0     1001      123     5426 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/expr/struct.py
+-rw-r--r--   0     1001      123     6101 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/expr/whenthen.py
+-rw-r--r--   0     1001      123     2619 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/functions/__init__.py
+-rw-r--r--   0     1001      123      480 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/functions/aggregation/__init__.py
+-rw-r--r--   0     1001      123     8369 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/functions/aggregation/horizontal.py
+-rw-r--r--   0     1001      123    15214 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/functions/aggregation/vertical.py
+-rw-r--r--   0     1001      123    16550 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/functions/as_datatype.py
+-rw-r--r--   0     1001      123    19285 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/functions/eager.py
+-rw-r--r--   0     1001      123    61356 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/functions/lazy.py
+-rw-r--r--   0     1001      123    27082 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/functions/range.py
+-rw-r--r--   0     1001      123     5874 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/functions/repeat.py
+-rw-r--r--   0     1001      123     3715 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/functions/whenthen.py
+-rw-r--r--   0     1001      123      952 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/__init__.py
+-rw-r--r--   0     1001      123     6976 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/_utils.py
+-rw-r--r--   0     1001      123      861 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/avro.py
+-rw-r--r--   0     1001      123      144 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/csv/__init__.py
+-rw-r--r--   0     1001      123     1072 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/csv/_utils.py
+-rw-r--r--   0     1001      123     4716 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/csv/batched_reader.py
+-rw-r--r--   0     1001      123    35482 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/csv/functions.py
+-rw-r--r--   0     1001      123     6439 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/database.py
+-rw-r--r--   0     1001      123    11012 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/delta.py
+-rw-r--r--   0     1001      123       75 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/excel/__init__.py
+-rw-r--r--   0     1001      123    18344 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/excel/_write_utils.py
+-rw-r--r--   0     1001      123     6355 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/excel/functions.py
+-rw-r--r--   0     1001      123      142 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/ipc/__init__.py
+-rw-r--r--   0     1001      123     1227 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/ipc/anonymous_scan.py
+-rw-r--r--   0     1001      123     5817 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/ipc/functions.py
+-rw-r--r--   0     1001      123     1637 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/json.py
+-rw-r--r--   0     1001      123     3516 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/ndjson.py
+-rw-r--r--   0     1001      123      170 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/parquet/__init__.py
+-rw-r--r--   0     1001      123     1259 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/parquet/anonymous_scan.py
+-rw-r--r--   0     1001      123     7190 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/parquet/functions.py
+-rw-r--r--   0     1001      123      136 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/pyarrow_dataset/__init__.py
+-rw-r--r--   0     1001      123     2186 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/pyarrow_dataset/anonymous_scan.py
+-rw-r--r--   0     1001      123     3601 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/io/pyarrow_dataset/functions.py
+-rw-r--r--   0     1001      123       77 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/lazyframe/__init__.py
+-rw-r--r--   0     1001      123   174215 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/lazyframe/frame.py
+-rw-r--r--   0     1001      123    25258 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/lazyframe/groupby.py
+-rw-r--r--   0     1001      123        0 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/py.typed
+-rw-r--r--   0     1001      123    42936 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/selectors.py
+-rw-r--r--   0     1001      123       69 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/series/__init__.py
+-rw-r--r--   0     1001      123     1594 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/series/_numpy.py
+-rw-r--r--   0     1001      123     2515 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/series/array.py
+-rw-r--r--   0     1001      123     1957 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/series/binary.py
+-rw-r--r--   0     1001      123     2085 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/series/categorical.py
+-rw-r--r--   0     1001      123    57574 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/series/datetime.py
+-rw-r--r--   0     1001      123    17142 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/series/list.py
+-rw-r--r--   0     1001      123   178771 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/series/series.py
+-rw-r--r--   0     1001      123    39559 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/series/string.py
+-rw-r--r--   0     1001      123     2542 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/series/struct.py
+-rw-r--r--   0     1001      123     5387 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/series/utils.py
+-rw-r--r--   0     1001      123     7559 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/slice.py
+-rw-r--r--   0     1001      123       75 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/sql/__init__.py
+-rw-r--r--   0     1001      123    17286 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/sql/context.py
+-rw-r--r--   0     1001      123     4793 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/string_cache.py
+-rw-r--r--   0     1001      123      362 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/testing/__init__.py
+-rw-r--r--   0     1001      123     1060 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/testing/_private.py
+-rw-r--r--   0     1001      123    16964 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/testing/asserts.py
+-rw-r--r--   0     1001      123      898 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/testing/parametric/__init__.py
+-rw-r--r--   0     1001      123    28167 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/testing/parametric/primitives.py
+-rw-r--r--   0     1001      123     3371 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/testing/parametric/profiles.py
+-rw-r--r--   0     1001      123    13165 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/testing/parametric/strategies.py
+-rw-r--r--   0     1001      123     6235 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/type_aliases.py
+-rw-r--r--   0     1001      123     1191 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/utils/__init__.py
+-rw-r--r--   0     1001      123    56941 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/utils/_construction.py
+-rw-r--r--   0     1001      123     4789 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/utils/_parse_expr_input.py
+-rw-r--r--   0     1001      123      647 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/utils/_scan.py
+-rw-r--r--   0     1001      123      579 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/utils/_wrap.py
+-rw-r--r--   0     1001      123      683 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/utils/build_info.py
+-rw-r--r--   0     1001      123     8730 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/utils/convert.py
+-rw-r--r--   0     1001      123     7883 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/utils/decorators.py
+-rw-r--r--   0     1001      123     1695 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/utils/meta.py
+-rw-r--r--   0     1001      123      514 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/utils/polars_version.py
+-rw-r--r--   0     1001      123     2552 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/utils/show_versions.py
+-rw-r--r--   0     1001      123    29167 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/utils/udfs.py
+-rw-r--r--   0     1001      123    14667 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/polars/utils/various.py
+-rw-r--r--   0     1001      123     5559 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/pyproject.toml
+-rw-r--r--   0     1001      123      778 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/requirements-dev.txt
+-rw-r--r--   0     1001      123       70 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/requirements-lint.txt
+-rw-r--r--   0     1001      123     1643 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/scripts/check_stacklevels.py
+-rw-r--r--   0     1001      123    10980 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/apply/dataframe.rs
+-rw-r--r--   0     1001      123     6424 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/apply/lazy.rs
+-rw-r--r--   0     1001      123     8535 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/apply/mod.rs
+-rw-r--r--   0     1001      123    90654 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/apply/series.rs
+-rw-r--r--   0     1001      123       32 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/arrow_interop/mod.rs
+-rw-r--r--   0     1001      123     1306 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/arrow_interop/to_py.rs
+-rw-r--r--   0     1001      123     3902 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/arrow_interop/to_rust.rs
+-rw-r--r--   0     1001      123     5250 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/batched_csv.rs
+-rw-r--r--   0     1001      123    55234 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/conversion.rs
+-rw-r--r--   0     1001      123    46869 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/dataframe.rs
+-rw-r--r--   0     1001      123     3950 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/datatypes.rs
+-rw-r--r--   0     1001      123     3506 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/error.rs
+-rw-r--r--   0     1001      123      570 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/expr/array.rs
+-rw-r--r--   0     1001      123     2080 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/expr/binary.rs
+-rw-r--r--   0     1001      123      381 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/expr/categorical.rs
+-rw-r--r--   0     1001      123     6199 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/expr/datetime.rs
+-rw-r--r--   0     1001      123    36673 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/expr/general.rs
+-rw-r--r--   0     1001      123     4693 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/expr/list.rs
+-rw-r--r--   0     1001      123     3152 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/expr/meta.rs
+-rw-r--r--   0     1001      123      870 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/expr/mod.rs
+-rw-r--r--   0     1001      123     7904 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/expr/string.rs
+-rw-r--r--   0     1001      123      467 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/expr/struct.rs
+-rw-r--r--   0     1001      123     9482 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/file.rs
+-rw-r--r--   0     1001      123      806 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/functions/aggregation.rs
+-rw-r--r--   0     1001      123     2393 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/functions/eager.rs
+-rw-r--r--   0     1001      123     1657 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/functions/io.rs
+-rw-r--r--   0     1001      123    10573 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/functions/lazy.rs
+-rw-r--r--   0     1001      123     1312 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/functions/meta.rs
+-rw-r--r--   0     1001      123      217 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/functions/misc.rs
+-rw-r--r--   0     1001      123      123 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/functions/mod.rs
+-rw-r--r--   0     1001      123     2327 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/functions/range.rs
+-rw-r--r--   0     1001      123     1505 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/functions/whenthen.rs
+-rw-r--r--   0     1001      123     1597 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/gil_once_cell.rs
+-rw-r--r--   0     1001      123    28554 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/lazyframe.rs
+-rw-r--r--   0     1001      123     2670 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/lazygroupby.rs
+-rw-r--r--   0     1001      123     9077 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/lib.rs
+-rw-r--r--   0     1001      123       47 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/object.rs
+-rw-r--r--   0     1001      123     3685 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/on_startup.rs
+-rw-r--r--   0     1001      123      122 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/prelude.rs
+-rw-r--r--   0     1001      123      435 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/py_modules.rs
+-rw-r--r--   0     1001      123     1964 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/series/aggregation.rs
+-rw-r--r--   0     1001      123     5406 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/series/arithmetic.rs
+-rw-r--r--   0     1001      123     5138 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/series/comparison.rs
+-rw-r--r--   0     1001      123     9352 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/series/construction.rs
+-rw-r--r--   0     1001      123     8971 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/series/export.rs
+-rw-r--r--   0     1001      123    25167 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/series/mod.rs
+-rw-r--r--   0     1001      123     4569 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/series/numpy_ufunc.rs
+-rw-r--r--   0     1001      123     3926 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/series/set_at_idx.rs
+-rw-r--r--   0     1001      123     1036 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/sql.rs
+-rw-r--r--   0     1001      123     2335 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/src/utils.rs
+-rw-r--r--   0     1001      123     6165 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/README.md
+-rw-r--r--   0     1001      123        0 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/__init__.py
+-rw-r--r--   0     1001      123     2189 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/benchmark/groupby-datagen.R
+-rw-r--r--   0     1001      123     7963 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/benchmark/run_h2oai_benchmark.py
+-rw-r--r--   0     1001      123     6500 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/benchmark/test_release.py
+-rw-r--r--   0     1001      123     4766 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/docs/run_doctest.py
+-rw-r--r--   0     1001      123        0 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/parametric/__init__.py
+-rw-r--r--   0     1001      123      179 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/parametric/conftest.py
+-rw-r--r--   0     1001      123     3856 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/parametric/test_dataframe.py
+-rw-r--r--   0     1001      123     2398 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/parametric/test_groupby_rolling.py
+-rw-r--r--   0     1001      123     1692 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/parametric/test_lazyframe.py
+-rw-r--r--   0     1001      123      976 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/parametric/test_lit.py
+-rw-r--r--   0     1001      123     6856 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/parametric/test_series.py
+-rw-r--r--   0     1001      123     8467 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/parametric/test_testing.py
+-rw-r--r--   0     1001      123     1554 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/parametric/time_series/test_to_datetime.py
+-rw-r--r--   0     1001      123     6070 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/test_udfs.py
+-rw-r--r--   0     1001      123        0 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/__init__.py
+-rw-r--r--   0     1001      123     3382 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/conftest.py
+-rw-r--r--   0     1001      123        0 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/dataframe/__init__.py
+-rw-r--r--   0     1001      123   114890 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/dataframe/test_df.py
+-rw-r--r--   0     1001      123     2306 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/dataframe/test_extend.py
+-rw-r--r--   0     1001      123     1666 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/dataframe/test_vstack.py
+-rw-r--r--   0     1001      123       86 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/datatypes/__init__.py
+-rw-r--r--   0     1001      123     2027 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/datatypes/test_array.py
+-rw-r--r--   0     1001      123      847 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/datatypes/test_binary.py
+-rw-r--r--   0     1001      123     1420 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/datatypes/test_bool.py
+-rw-r--r--   0     1001      123    13583 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/datatypes/test_categorical.py
+-rw-r--r--   0     1001      123     5222 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/datatypes/test_decimal.py
+-rw-r--r--   0     1001      123      549 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/datatypes/test_duration.py
+-rw-r--r--   0     1001      123      423 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/datatypes/test_integer.py
+-rw-r--r--   0     1001      123    14425 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/datatypes/test_list.py
+-rw-r--r--   0     1001      123      284 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/datatypes/test_null.py
+-rw-r--r--   0     1001      123     2551 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/datatypes/test_object.py
+-rw-r--r--   0     1001      123    26595 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/datatypes/test_struct.py
+-rw-r--r--   0     1001      123    89719 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/datatypes/test_temporal.py
+-rw-r--r--   0     1001      123      418 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/datatypes/test_time.py
+-rw-r--r--   0     1001      123        0 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/functions/__init__.py
+-rw-r--r--   0     1001      123        0 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/functions/aggregation/__init__.py
+-rw-r--r--   0     1001      123     6783 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/functions/aggregation/test_horizontal.py
+-rw-r--r--   0     1001      123     3008 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/functions/aggregation/test_vertical.py
+-rw-r--r--   0     1001      123    13970 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/functions/test_as_datatype.py
+-rw-r--r--   0     1001      123      480 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/functions/test_concat.py
+-rw-r--r--   0     1001      123    15544 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/functions/test_functions.py
+-rw-r--r--   0     1001      123    33921 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/functions/test_range.py
+-rw-r--r--   0     1001      123     3847 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/functions/test_repeat.py
+-rw-r--r--   0     1001      123     7387 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/functions/test_whenthen.py
+-rw-r--r--   0     1001      123      168 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/conftest.py
+-rw-r--r--   0     1001      123       16 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/delta-table/.part-00000-e42312d7-60e5-454d-acbc-db192d220e73-c000.snappy.parquet.crc
+-rw-r--r--   0     1001      123       16 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/delta-table/.part-00000-e4a999da-df45-4fb0-bdc4-d999fc0f58aa-c000.snappy.parquet.crc
+-rw-r--r--   0     1001      123       16 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/delta-table/_delta_log/.00000000000000000000.json.crc
+-rw-r--r--   0     1001      123       16 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/delta-table/_delta_log/.00000000000000000001.json.crc
+-rw-r--r--   0     1001      123      905 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/delta-table/_delta_log/00000000000000000000.json
+-rw-r--r--   0     1001      123      936 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/delta-table/_delta_log/00000000000000000001.json
+-rw-r--r--   0     1001      123      972 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/delta-table/part-00000-e42312d7-60e5-454d-acbc-db192d220e73-c000.snappy.parquet
+-rw-r--r--   0     1001      123      690 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/delta-table/part-00000-e4a999da-df45-4fb0-bdc4-d999fc0f58aa-c000.snappy.parquet
+-rw-r--r--   0     1001      123        0 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/empty.csv
+-rw-r--r--   0     1001      123     5959 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/example.xlsx
+-rw-r--r--   0     1001      123      457 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/foods1.csv
+-rw-r--r--   0     1001      123     2351 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/foods1.ipc
+-rw-r--r--   0     1001      123     1713 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/foods1.ndjson
+-rw-r--r--   0     1001      123     1427 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/foods1.parquet
+-rw-r--r--   0     1001      123      455 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/foods2.csv
+-rw-r--r--   0     1001      123     2351 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/foods2.ipc
+-rw-r--r--   0     1001      123     1711 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/foods2.ndjson
+-rw-r--r--   0     1001      123     1916 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/foods2.parquet
+-rw-r--r--   0     1001      123      455 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/foods3.csv
+-rw-r--r--   0     1001      123      457 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/foods4.csv
+-rw-r--r--   0     1001      123      452 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/foods5.csv
+-rw-r--r--   0     1001      123       49 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/gzipped.csv
+-rw-r--r--   0     1001      123       57 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/small.csv
+-rw-r--r--   0     1001      123      756 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/small.parquet
+-rwxr-xr-x   0     1001      123      420 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/files/tz_aware.parquet
+-rw-r--r--   0     1001      123     1884 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/test_avro.py
+-rw-r--r--   0     1001      123      323 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/test_cloud.py
+-rw-r--r--   0     1001      123    41288 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/test_csv.py
+-rw-r--r--   0     1001      123     7102 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/test_database.py
+-rw-r--r--   0     1001      123     6172 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/test_delta.py
+-rw-r--r--   0     1001      123    12215 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/test_excel.py
+-rw-r--r--   0     1001      123     5483 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/test_ipc.py
+-rw-r--r--   0     1001      123     6568 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/test_json.py
+-rw-r--r--   0     1001      123     7305 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/test_lazy_csv.py
+-rw-r--r--   0     1001      123     2060 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/test_lazy_ipc.py
+-rw-r--r--   0     1001      123     2841 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/test_lazy_json.py
+-rw-r--r--   0     1001      123    11614 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/test_lazy_parquet.py
+-rw-r--r--   0     1001      123     1996 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/test_other.py
+-rw-r--r--   0     1001      123    14862 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/test_parquet.py
+-rw-r--r--   0     1001      123      612 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/test_pickle.py
+-rw-r--r--   0     1001      123     3706 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/io/test_pyarrow_dataset.py
+-rw-r--r--   0     1001      123      509 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/namespaces/__init__.py
+-rw-r--r--   0     1001      123      940 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/namespaces/test_array.py
+-rw-r--r--   0     1001      123     3218 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/namespaces/test_binary.py
+-rw-r--r--   0     1001      123     2696 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/namespaces/test_categorical.py
+-rw-r--r--   0     1001      123    24151 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/namespaces/test_datetime.py
+-rw-r--r--   0     1001      123    15851 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/namespaces/test_list.py
+-rw-r--r--   0     1001      123     2472 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/namespaces/test_meta.py
+-rw-r--r--   0     1001      123    24561 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/namespaces/test_string.py
+-rw-r--r--   0     1001      123    20819 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/namespaces/test_strptime.py
+-rw-r--r--   0     1001      123     1084 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/namespaces/test_struct.py
+-rw-r--r--   0     1001      123       85 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/__init__.py
+-rw-r--r--   0     1001      123     8185 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_aggregations.py
+-rw-r--r--   0     1001      123    11492 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_apply.py
+-rw-r--r--   0     1001      123     7367 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_arithmetic.py
+-rw-r--r--   0     1001      123     4940 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_comparison.py
+-rw-r--r--   0     1001      123     3275 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_drop.py
+-rw-r--r--   0     1001      123     8813 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_explode.py
+-rw-r--r--   0     1001      123     3732 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_filter.py
+-rw-r--r--   0     1001      123     1096 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_folds.py
+-rw-r--r--   0     1001      123    25037 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_groupby.py
+-rw-r--r--   0     1001      123     8580 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_groupby_rolling.py
+-rw-r--r--   0     1001      123     7132 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_inefficient_apply.py
+-rw-r--r--   0     1001      123     3230 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_is_in.py
+-rw-r--r--   0     1001      123    19313 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_join.py
+-rw-r--r--   0     1001      123    15633 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_join_asof.py
+-rw-r--r--   0     1001      123      643 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_melt.py
+-rw-r--r--   0     1001      123    10253 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_pivot.py
+-rw-r--r--   0     1001      123     3187 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_random.py
+-rw-r--r--   0     1001      123    25057 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_rolling.py
+-rw-r--r--   0     1001      123     2389 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_select.py
+-rw-r--r--   0     1001      123    21311 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_sort.py
+-rw-r--r--   0     1001      123     6619 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_statistics.py
+-rw-r--r--   0     1001      123     4312 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_transpose.py
+-rw-r--r--   0     1001      123      771 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_unique.py
+-rw-r--r--   0     1001      123    11641 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_window.py
+-rw-r--r--   0     1001      123     5480 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/operations/test_with_columns.py
+-rw-r--r--   0     1001      123        0 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/series/__init__.py
+-rw-r--r--   0     1001      123     2307 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/series/test_append.py
+-rw-r--r--   0     1001      123      735 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/series/test_extend.py
+-rw-r--r--   0     1001      123    83085 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/series/test_series.py
+-rw-r--r--   0     1001      123        0 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/streaming/__init__.py
+-rw-r--r--   0     1001      123      146 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/streaming/conftest.py
+-rw-r--r--   0     1001      123      908 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/streaming/test_ooc.py
+-rw-r--r--   0     1001      123    21889 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/streaming/test_streaming.py
+-rw-r--r--   0     1001      123     5492 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_api.py
+-rw-r--r--   0     1001      123      297 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_arity.py
+-rw-r--r--   0     1001      123    22128 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_cfg.py
+-rw-r--r--   0     1001      123    43560 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_constructors.py
+-rw-r--r--   0     1001      123      454 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_context.py
+-rw-r--r--   0     1001      123     6423 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_cse.py
+-rw-r--r--   0     1001      123     5191 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_datatypes.py
+-rw-r--r--   0     1001      123     2741 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_empty.py
+-rw-r--r--   0     1001      123    19296 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_errors.py
+-rw-r--r--   0     1001      123     1391 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_expansion.py
+-rw-r--r--   0     1001      123     2435 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_expr_multi_cols.py
+-rw-r--r--   0     1001      123    32008 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_exprs.py
+-rw-r--r--   0     1001      123     3516 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_fmt.py
+-rw-r--r--   0     1001      123     3512 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_interchange.py
+-rw-r--r--   0     1001      123    38530 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_interop.py
+-rw-r--r--   0     1001      123    48249 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_lazy.py
+-rw-r--r--   0     1001      123     2463 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_polars_import.py
+-rw-r--r--   0     1001      123     4568 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_predicates.py
+-rw-r--r--   0     1001      123     8323 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_projections.py
+-rw-r--r--   0     1001      123     9886 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_queries.py
+-rw-r--r--   0     1001      123     8100 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_rows.py
+-rw-r--r--   0     1001      123    15615 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_schema.py
+-rw-r--r--   0     1001      123    13535 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_selectors.py
+-rw-r--r--   0     1001      123     4509 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_serde.py
+-rw-r--r--   0     1001      123      452 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_show_graph.py
+-rw-r--r--   0     1001      123      657 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_single.py
+-rw-r--r--   0     1001      123    23207 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_sql.py
+-rw-r--r--   0     1001      123    35314 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/test_testing.py
+-rw-r--r--   0     1001      123       41 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/utils/__init__.py
+-rw-r--r--   0     1001      123      306 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/utils/test_build_info.py
+-rw-r--r--   0     1001      123     3182 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/utils/test_parse_expr_input.py
+-rw-r--r--   0     1001      123      247 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/utils/test_show_versions.py
+-rw-r--r--   0     1001      123     5380 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/tests/unit/utils/test_utils.py
+-rw-r--r--   0     1001      123    64659 2023-07-28 13:05:10.000000 polars_lts_cpu-0.18.9/Cargo.lock
+-rw-r--r--   0        0        0    14378 1970-01-01 00:00:00.000000 polars_lts_cpu-0.18.9/PKG-INFO
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/Cargo.toml` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/Cargo.toml`

 * *Files 4% similar despite different names*

```diff
@@ -32,19 +32,19 @@
 performant = []
 like = ["arrow/compute_like"]
 timezones = ["chrono-tz", "chrono"]
 simd = []
 
 [dependencies.arrow]
 package = "arrow2"
-# git = "https://github.com/jorgecarleitao/arrow2"
+git = "https://github.com/jorgecarleitao/arrow2"
 # git = "https://github.com/ritchie46/arrow2"
-# rev = "2d2e7053f9a50810bfe9cecff25ab39089aef98e"
+rev = "d5c78e7ba45fcebfbafd55a82ba2601ee3ea9617"
 # path = "../arrow2"
-# branch = "polars_2023-06-26"
+# branch = "duration_json"
 version = "0.17.2"
 default-features = false
 features = [
   "compute_aggregate",
   "compute_arithmetics",
   "compute_boolean",
   "compute_boolean_kleene",
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/LICENSE` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/array/default_arrays.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/array/default_arrays.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/array/fixed_size_list.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/array/fixed_size_list.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/array/get.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/array/get.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/array/list.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/array/list.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/array/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/array/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/array/null.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/array/null.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/array/slice.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/array/slice.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/array/utf8.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/array/utf8.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/bit_util.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/bit_util.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/bitmap/mutable.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/bitmap/mutable.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/commutative.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/commutative.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/div.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/div.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/mul.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/arithmetics/decimal/mul.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/bitwise.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/bitwise.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/cast.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/cast.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/decimal.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/decimal.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/take/boolean.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/take/boolean.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/take/fixed_size_list.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/take/fixed_size_list.rs`

 * *Files 0% similar despite different names*

```diff
@@ -11,15 +11,17 @@
 pub unsafe fn take_unchecked(values: &FixedSizeListArray, indices: &IdxArr) -> FixedSizeListArray {
     if let (PhysicalType::Primitive(primitive), 0) = (
         values.values().data_type().to_physical_type(),
         indices.null_count(),
     ) {
         let idx = indices.values().as_slice();
         let child_values = values.values();
-        let DataType::FixedSizeList(_, width) = values.data_type() else {unreachable!()};
+        let DataType::FixedSizeList(_, width) = values.data_type() else {
+            unreachable!()
+        };
 
         with_match_primitive_type!(primitive, |$T| {
             let arr: &PrimitiveArray<$T> = child_values.as_any().downcast_ref().unwrap();
             return take_unchecked_primitive(values, arr, idx, *width)
         })
     }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/take/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/take/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/compute/tile.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/compute/tile.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/conversion.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/conversion.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/data_types.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/data_types.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/floats/ord.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/floats/ord.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/index.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/index.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/is_valid.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/is_valid.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/agg_mean.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/agg_mean.rs`

 * *Files 18% similar despite different names*

```diff
@@ -1,32 +1,68 @@
-use std::simd::{Mask, Simd, SimdCast, SimdElement, SimdFloat, StdFloat, ToBitMask};
+use std::simd::{
+    LaneCount, Mask, Simd, SimdCast, SimdElement, SimdFloat, SimdInt, SimdUint, StdFloat,
+    SupportedLaneCount, ToBitMask,
+};
 
 use arrow::array::{Array, PrimitiveArray};
 use arrow::bitmap::utils::{BitChunkIterExact, BitChunksExact};
 use arrow::bitmap::Bitmap;
 use arrow::datatypes::PhysicalType::Primitive;
 use arrow::types::NativeType;
 use multiversion::multiversion;
 use num_traits::ToPrimitive;
 
 use crate::data_types::IsFloat;
 use crate::utils::with_match_primitive_type;
 
+// TODO! try to remove this if we can cast again directly
+pub trait SimdCastPl<const N: usize>
+where
+    LaneCount<N>: SupportedLaneCount,
+{
+    fn cast_custom<U: SimdCast>(self) -> Simd<U, N>;
+}
+
+macro_rules! impl_cast_custom {
+    ($_type:ty) => {
+        impl<const N: usize> SimdCastPl<N> for Simd<$_type, N>
+        where
+            LaneCount<N>: SupportedLaneCount,
+        {
+            fn cast_custom<U: SimdCast>(self) -> Simd<U, N> {
+                self.cast::<U>()
+            }
+        }
+    };
+}
+
+impl_cast_custom!(u8);
+impl_cast_custom!(u16);
+impl_cast_custom!(u32);
+impl_cast_custom!(u64);
+impl_cast_custom!(i8);
+impl_cast_custom!(i16);
+impl_cast_custom!(i32);
+impl_cast_custom!(i64);
+impl_cast_custom!(f32);
+impl_cast_custom!(f64);
+
 #[multiversion(targets = "simd")]
 fn nonnull_sum_as_f64<T>(values: &[T]) -> f64
 where
     T: NativeType + SimdElement + ToPrimitive + SimdCast,
+    Simd<T, 8>: SimdCastPl<8>,
 {
     // we choose 8 as that the maximum size of f64x8 -> 512bit wide
     const LANES: usize = 8;
     let (head, simd_vals, tail) = unsafe { values.align_to::<Simd<T, LANES>>() };
 
     let mut reduced: Simd<f64, LANES> = Simd::splat(0.0);
     for chunk in simd_vals {
-        reduced += chunk.cast::<f64>();
+        reduced += chunk.cast_custom::<f64>();
     }
 
     unsafe {
         reduced.reduce_sum()
             + head
                 .iter()
                 .map(|v| v.to_f64().unwrap_unchecked())
@@ -39,26 +75,27 @@
 }
 
 #[multiversion(targets = "simd")]
 fn null_sum_as_f64_impl<T, I>(values: &[T], mut validity_masks: I) -> f64
 where
     T: NativeType + SimdElement + ToPrimitive + IsFloat + SimdCast,
     I: BitChunkIterExact<u8>,
+    Simd<T, 8>: SimdCastPl<8>,
 {
     const LANES: usize = 8;
     let mut chunks = values.chunks_exact(LANES);
     let min_one = Simd::<f64, LANES>::splat(-1.0);
     let min_one_i64 = Simd::<i64, LANES>::splat(-1);
 
     let sum = chunks.by_ref().zip(validity_masks.by_ref()).fold(
         Simd::<f64, LANES>::splat(0.0),
         |acc, (chunk, validity_chunk)| {
             // safety: exact size chunks
             let chunk: [T; LANES] = unsafe { chunk.try_into().unwrap_unchecked() };
-            let chunk = Simd::from(chunk).cast::<f64>();
+            let chunk = Simd::from(chunk).cast_custom::<f64>();
 
             // construct [bools]
             let mask = Mask::<i8, LANES>::from_bitmask(validity_chunk);
             // let's say we have mask
             //      [true, false, true, true]
             // a cast to int gives:
             //      [-1, 0, -1, -1]
@@ -103,14 +140,15 @@
     }
     sum
 }
 
 fn null_sum_as_f64<T>(values: &[T], bitmap: &Bitmap) -> f64
 where
     T: NativeType + SimdElement + ToPrimitive + IsFloat + SimdCast,
+    Simd<T, 8>: SimdCastPl<8>,
 {
     let (slice, offset, length) = bitmap.as_slice();
     if offset == 0 {
         let validity_masks = BitChunksExact::<u8>::new(slice, length);
         null_sum_as_f64_impl(values, validity_masks)
     } else {
         let validity_masks = bitmap.chunks::<u8>();
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/comparison.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/comparison.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/concatenate.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/concatenate.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/ewm/average.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/ewm/average.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/ewm/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/ewm/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/ewm/variance.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/ewm/variance.rs`

 * *Files 0% similar despite different names*

```diff
@@ -33,15 +33,15 @@
     let mut opt_mean_y = None;
     let mut cov = T::zero();
     let mut non_na_cnt = 0usize;
     let min_periods_fixed = if min_periods == 0 { 1 } else { min_periods };
 
     let res = xs
         .into_iter()
-        .zip(ys.into_iter())
+        .zip(ys)
         .enumerate()
         .map(|(i, (opt_x, opt_y))| {
             let is_observation = opt_x.is_some() && opt_y.is_some();
             if is_observation {
                 non_na_cnt += 1;
             }
             match (i, opt_mean_x, opt_mean_y) {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/float.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/float.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/list.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/list.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/list_bytes_iter.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/list_bytes_iter.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/mod.rs`

 * *Files 0% similar despite different names*

```diff
@@ -19,15 +19,15 @@
 #[cfg(feature = "strings")]
 pub mod string;
 pub mod take_agg;
 #[cfg(feature = "timezones")]
 mod time;
 
 #[cfg(feature = "timezones")]
-pub use time::replace_timezone;
+pub use time::replace_time_zone;
 
 /// Internal state of [SlicesIterator]
 #[derive(Debug, PartialEq)]
 enum State {
     // it is iterating over bits of a mask (`u64`, steps of size of 1 slot)
     Bits(u64),
     // it is iterating over chunks (steps of size of 64 slots)
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/mean.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/mean.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/min_max.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/min_max.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/quantile.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/quantile.rs`

 * *Files 5% similar despite different names*

```diff
@@ -165,15 +165,15 @@
     // This is mostly taken from the Julia implementation which was readable and reasonable
     // https://juliastats.org/StatsBase.jl/stable/scalarstats/#Quantile-and-Related-Functions-1
     let (mut s, mut s_old, mut vk, mut v_old) = (0.0, 0.0, T::zero(), T::zero());
 
     // Once the cumulative weight crosses h, we've found our ind{ex/ices}. The definition may look
     // odd but it's the equivalent of taking h = p * (n - 1) + 1 if your data is indexed from 1.
     let h: f64 = p * (wsum - buf[0].1) + buf[0].1;
-    for &(v, w) in buf.iter().filter(|(_, w)| *w != 0.0) {
+    for &(v, w) in buf.iter() {
         if s > h {
             break;
         }
         (s_old, v_old, vk) = (s, vk, v);
         s += w;
     }
     match (h == s_old, interp) {
@@ -215,25 +215,29 @@
         + NumCast
         + ToPrimitive
         + Zero
         + IsFloat
         + PartialOrd,
 {
     assert_eq!(weights.len(), window_size);
-    let mut buf = vec![(T::zero(), 0.0); window_size];
+    // Keep nonzero weights and their indices to know which values we need each iteration.
+    let nz_idx_wts: Vec<_> = weights.iter().enumerate().filter(|x| x.1 != &0.0).collect();
+    let mut buf = vec![(T::zero(), 0.0); nz_idx_wts.len()];
     let len = values.len();
     let out = (0..len)
         .map(|idx| {
-            let (start, end) = det_offsets_fn(idx, window_size, len);
-            let vals = unsafe { values.get_unchecked(start..end) };
+            // Don't need end. Window size is constant and we computed offsets from start above.
+            let (start, _) = det_offsets_fn(idx, window_size, len);
 
             // Sorting is not ideal, see https://github.com/tobiasschoch/wquantile for something faster
-            buf.iter_mut()
-                .zip(vals.iter().zip(weights))
-                .for_each(|(b, (v, w))| *b = (*v, *w));
+            unsafe {
+                buf.iter_mut()
+                    .zip(nz_idx_wts.iter())
+                    .for_each(|(b, (i, w))| *b = (*values.get_unchecked(i + start), **w));
+            }
             buf.sort_unstable_by(|&a, &b| compare_fn_nan_max(&a.0, &b.0));
             compute_wq(&buf, p, wsum, interpolation)
         })
         .collect_trusted::<Vec<T>>();
 
     let validity = create_validity(min_periods, len, window_size, det_offsets_fn);
     Box::new(PrimitiveArray::new(
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/sum.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/sum.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/variance.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/no_nulls/variance.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/nulls/mean.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/nulls/mean.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/nulls/min_max.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/nulls/min_max.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/nulls/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/nulls/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/nulls/quantile.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/nulls/quantile.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/nulls/sum.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/nulls/sum.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/nulls/variance.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/nulls/variance.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/rolling/window.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/rolling/window.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/set.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/set.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/sort_partition.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/sort_partition.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/sorted_join/inner.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/sorted_join/inner.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/sorted_join/left.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/sorted_join/left.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/string.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/string.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/take_agg/boolean.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/take_agg/boolean.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/take_agg/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/take_agg/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/take_agg/var.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/take_agg/var.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/kernels/time.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/kernels/time.rs`

 * *Files 0% similar despite different names*

```diff
@@ -87,15 +87,15 @@
             Ok(Box::new(data))
         }
         _ => unreachable!(),
     }
 }
 
 #[cfg(feature = "timezones")]
-pub fn replace_timezone(
+pub fn replace_time_zone(
     arr: &PrimitiveArray<i64>,
     tu: TimeUnit,
     from: &str,
     to: &str,
     use_earliest: Option<bool>,
 ) -> PolarsResult<ArrayRef> {
     Ok(match from.parse::<chrono_tz::Tz>() {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/prelude.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/prelude.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/slice.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/slice.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/trusted_len/boolean.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/trusted_len/boolean.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/trusted_len/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/trusted_len/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/trusted_len/push_unchecked.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/trusted_len/push_unchecked.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-arrow/src/utils.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/src/utils.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/Cargo.toml` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/Cargo.toml`

 * *Files 4% similar despite different names*

```diff
@@ -26,27 +26,27 @@
 [features]
 dtype-date = ["polars-core/dtype-date", "polars-core/temporal"]
 dtype-datetime = ["polars-core/dtype-date", "polars-core/temporal"]
 dtype-time = ["polars-core/dtype-time", "polars-core/temporal"]
 dtype-duration = ["polars-core/dtype-duration", "polars-core/temporal"]
 rolling_window = ["polars-core/rolling_window", "dtype-duration"]
 fmt = ["polars-core/fmt"]
-timezones = ["chrono-tz", "dtype-datetime", "polars-core/timezones", "polars-arrow/timezones"]
+timezones = ["chrono-tz", "dtype-datetime", "polars-core/timezones", "polars-arrow/timezones", "polars-ops/timezones"]
 
 test = ["dtype-date", "dtype-datetime", "polars-core/fmt"]
 
 default = []
 
 [dependencies.arrow]
 package = "arrow2"
-# git = "https://github.com/jorgecarleitao/arrow2"
+git = "https://github.com/jorgecarleitao/arrow2"
 # git = "https://github.com/ritchie46/arrow2"
-# rev = "2d2e7053f9a50810bfe9cecff25ab39089aef98e"
+rev = "d5c78e7ba45fcebfbafd55a82ba2601ee3ea9617"
 # path = "../arrow2"
-# branch = "polars_2023-06-26"
+# branch = "duration_json"
 version = "0.17.2"
 default-features = false
 features = [
   "compute_aggregate",
   "compute_arithmetics",
   "compute_boolean",
   "compute_boolean_kleene",
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/LICENSE` & `polars_lts_cpu-0.18.9/local_dependencies/polars-utils/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/base_utc_offset.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/base_utc_offset.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/date.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/date.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/datetime.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/datetime.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/duration.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/duration.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/kernels.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/kernels.rs`

 * *Files 8% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 //! macros that define kernels for extracting
 //! `week`, `weekday`, `year`, `hour` etc. from primitive arrays.
 use chrono::{Datelike, NaiveDate, NaiveDateTime, Timelike};
 use polars_arrow::export::arrow::array::{BooleanArray, PrimitiveArray};
 use polars_arrow::export::arrow::compute::arity::unary;
 #[cfg(feature = "dtype-time")]
-use polars_arrow::export::arrow::temporal_conversions::time64ns_to_time;
+use polars_arrow::export::arrow::temporal_conversions::time64ns_to_time_opt;
 use polars_arrow::export::arrow::temporal_conversions::{
-    date32_to_datetime, timestamp_ms_to_datetime, timestamp_ns_to_datetime,
-    timestamp_us_to_datetime,
+    date32_to_datetime_opt, timestamp_ms_to_datetime_opt, timestamp_ns_to_datetime_opt,
+    timestamp_us_to_datetime_opt,
 };
 
 use super::super::windows::calendar::*;
 use super::*;
 
 trait PolarsIso {
     fn p_weekday(&self) -> u32;
@@ -40,37 +40,42 @@
     }
     fn iso_year(&self) -> i32 {
         self.iso_week().year()
     }
 }
 
 macro_rules! to_temporal_unit {
-    ($name: ident, $chrono_method: ident, $to_datetime_fn: expr, $dtype_in: ty, $dtype_out:expr) => {
-        pub(crate) fn $name(arr: &PrimitiveArray<$dtype_in>) -> ArrayRef {
+    ($name: ident, $chrono_method: ident, $to_datetime_fn: expr,
+    $primitive_in: ty,
+    $primitive_out: ty,
+    $dtype_out:expr) => {
+        pub(crate) fn $name(arr: &PrimitiveArray<$primitive_in>) -> ArrayRef {
             Box::new(unary(
                 arr,
                 |value| {
-                    let dt = $to_datetime_fn(value);
-                    dt.$chrono_method()
+                    $to_datetime_fn(value)
+                        .map(|dt| dt.$chrono_method())
+                        .unwrap_or(value as $primitive_out)
                 },
                 $dtype_out,
             )) as ArrayRef
         }
     };
 }
 
 macro_rules! to_boolean_temporal_unit {
     ($name: ident, $chrono_method: ident, $boolean_method: ident, $to_datetime_fn: expr, $dtype_in: ty) => {
         pub(crate) fn $name(arr: &PrimitiveArray<$dtype_in>) -> ArrayRef {
             let values = arr
                 .values()
                 .iter()
                 .map(|value| {
-                    let dt = $to_datetime_fn(*value);
-                    $boolean_method(dt.$chrono_method())
+                    $to_datetime_fn(*value)
+                        .map(|dt| $boolean_method(dt.$chrono_method()))
+                        .unwrap_or(false)
                 })
                 .collect::<Vec<_>>();
             Box::new(BooleanArray::new(
                 ArrowDataType::Boolean,
                 values.into(),
                 arr.validity().cloned(),
             ))
@@ -79,178 +84,195 @@
 }
 
 // Dates
 #[cfg(feature = "dtype-date")]
 to_temporal_unit!(
     date_to_iso_week,
     week,
-    date32_to_datetime,
+    date32_to_datetime_opt,
     i32,
+    u32,
     ArrowDataType::UInt32
 );
 #[cfg(feature = "dtype-date")]
 to_temporal_unit!(
     date_to_iso_year,
     iso_year,
-    date32_to_datetime,
+    date32_to_datetime_opt,
+    i32,
     i32,
     ArrowDataType::Int32
 );
 #[cfg(feature = "dtype-date")]
 to_temporal_unit!(
     date_to_iso_weekday,
     p_weekday,
-    date32_to_datetime,
+    date32_to_datetime_opt,
     i32,
+    u32,
     ArrowDataType::UInt32
 );
 #[cfg(feature = "dtype-date")]
 to_temporal_unit!(
     date_to_year,
     year,
-    date32_to_datetime,
+    date32_to_datetime_opt,
+    i32,
     i32,
     ArrowDataType::Int32
 );
 #[cfg(feature = "dtype-date")]
 to_boolean_temporal_unit!(
     date_to_is_leap_year,
     year,
     is_leap_year,
-    date32_to_datetime,
+    date32_to_datetime_opt,
     i32
 );
 #[cfg(feature = "dtype-date")]
 to_temporal_unit!(
     date_to_month,
     month,
-    date32_to_datetime,
+    date32_to_datetime_opt,
     i32,
+    u32,
     ArrowDataType::UInt32
 );
 #[cfg(feature = "dtype-date")]
 to_temporal_unit!(
     date_to_day,
     day,
-    date32_to_datetime,
+    date32_to_datetime_opt,
     i32,
+    u32,
     ArrowDataType::UInt32
 );
 #[cfg(feature = "dtype-date")]
 to_temporal_unit!(
     date_to_ordinal,
     ordinal,
-    date32_to_datetime,
+    date32_to_datetime_opt,
     i32,
+    u32,
     ArrowDataType::UInt32
 );
 
 // Times
 #[cfg(feature = "dtype-time")]
 to_temporal_unit!(
     time_to_hour,
     hour,
-    time64ns_to_time,
+    time64ns_to_time_opt,
     i64,
+    u32,
     ArrowDataType::UInt32
 );
 #[cfg(feature = "dtype-time")]
 to_temporal_unit!(
     time_to_minute,
     minute,
-    time64ns_to_time,
+    time64ns_to_time_opt,
     i64,
+    u32,
     ArrowDataType::UInt32
 );
 #[cfg(feature = "dtype-time")]
 to_temporal_unit!(
     time_to_second,
     second,
-    time64ns_to_time,
+    time64ns_to_time_opt,
     i64,
+    u32,
     ArrowDataType::UInt32
 );
 #[cfg(feature = "dtype-time")]
 to_temporal_unit!(
     time_to_nanosecond,
     nanosecond,
-    time64ns_to_time,
+    time64ns_to_time_opt,
     i64,
+    u32,
     ArrowDataType::UInt32
 );
 
 #[cfg(feature = "dtype-datetime")]
 to_temporal_unit!(
     datetime_to_ordinal_ns,
     ordinal,
-    timestamp_ns_to_datetime,
+    timestamp_ns_to_datetime_opt,
     i64,
+    u32,
     ArrowDataType::UInt32
 );
 
 #[cfg(feature = "dtype-datetime")]
 to_temporal_unit!(
     datetime_to_ordinal_ms,
     ordinal,
-    timestamp_ms_to_datetime,
+    timestamp_ms_to_datetime_opt,
     i64,
+    u32,
     ArrowDataType::UInt32
 );
 #[cfg(feature = "dtype-datetime")]
 to_temporal_unit!(
     datetime_to_ordinal_us,
     ordinal,
-    timestamp_us_to_datetime,
+    timestamp_us_to_datetime_opt,
     i64,
+    u32,
     ArrowDataType::UInt32
 );
 
 #[cfg(feature = "dtype-datetime")]
 to_temporal_unit!(
     datetime_to_iso_year_ns,
     iso_year,
-    timestamp_ns_to_datetime,
+    timestamp_ns_to_datetime_opt,
     i64,
+    i32,
     ArrowDataType::Int32
 );
 
 #[cfg(feature = "dtype-datetime")]
 to_temporal_unit!(
     datetime_to_iso_year_us,
     iso_year,
-    timestamp_us_to_datetime,
+    timestamp_us_to_datetime_opt,
     i64,
+    i32,
     ArrowDataType::Int32
 );
 
 #[cfg(feature = "dtype-datetime")]
 to_temporal_unit!(
     datetime_to_iso_year_ms,
     iso_year,
-    timestamp_ms_to_datetime,
+    timestamp_ms_to_datetime_opt,
     i64,
+    i32,
     ArrowDataType::Int32
 );
 #[cfg(feature = "dtype-datetime")]
 to_boolean_temporal_unit!(
     datetime_to_is_leap_year_ns,
     year,
     is_leap_year,
-    timestamp_ns_to_datetime,
+    timestamp_ns_to_datetime_opt,
     i64
 );
 #[cfg(feature = "dtype-datetime")]
 to_boolean_temporal_unit!(
     datetime_to_is_leap_year_us,
     year,
     is_leap_year,
-    timestamp_us_to_datetime,
+    timestamp_us_to_datetime_opt,
     i64
 );
 #[cfg(feature = "dtype-datetime")]
 to_boolean_temporal_unit!(
     datetime_to_is_leap_year_ms,
     year,
     is_leap_year,
-    timestamp_ms_to_datetime,
+    timestamp_ms_to_datetime_opt,
     i64
 );
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/rolling_window/floats.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/rolling_window/floats.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/rolling_window/ints.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/rolling_window/ints.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/rolling_window/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/rolling_window/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/rolling_window/rolling_kernels/no_nulls.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/rolling_window/rolling_kernels/no_nulls.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/time.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/time.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/utf8/infer.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/utf8/infer.rs`

 * *Files 0% similar despite different names*

```diff
@@ -519,22 +519,22 @@
                     To convert to a different time zone, please use `convert_time_zone`.")
             }
             match pattern {
                 #[cfg(feature = "timezones")]
                 Pattern::DatetimeYMDZ => infer.coerce_utf8(ca).datetime().map(|ca| {
                     let mut ca = ca.clone();
                     ca.set_time_unit(tu);
-                    ca.replace_time_zone(Some("UTC"), None)
+                    polars_ops::prelude::replace_time_zone(&ca, Some("UTC"), None)
                 })?,
                 _ => infer.coerce_utf8(ca).datetime().map(|ca| {
                     let mut ca = ca.clone();
                     ca.set_time_unit(tu);
                     match tz {
                         #[cfg(feature = "timezones")]
-                        Some(tz) => ca.replace_time_zone(Some(tz), None),
+                        Some(tz) => polars_ops::prelude::replace_time_zone(&ca, Some(tz), None),
                         _ => Ok(ca),
                     }
                 })?,
             }
         }
     }
 }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/utf8/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/utf8/mod.rs`

 * *Files 1% similar despite different names*

```diff
@@ -299,15 +299,17 @@
                     None
                 }
             })
             .collect_trusted();
         ca.rename(utf8_ca.name());
         match (tz_aware, tz) {
             #[cfg(feature = "timezones")]
-            (false, Some(tz)) => ca.into_datetime(tu, None).replace_time_zone(Some(tz), None),
+            (false, Some(tz)) => {
+                polars_ops::prelude::replace_time_zone(&ca.into_datetime(tu, None), Some(tz), None)
+            }
             #[cfg(feature = "timezones")]
             (true, _) => Ok(ca.into_datetime(tu, Some("UTC".to_string()))),
             _ => Ok(ca.into_datetime(tu, None)),
         }
     }
 
     #[cfg(feature = "dtype-date")]
@@ -512,15 +514,19 @@
                         })
                     })
                     .collect_trusted()
             };
             ca.rename(utf8_ca.name());
             match tz {
                 #[cfg(feature = "timezones")]
-                Some(tz) => ca.into_datetime(tu, None).replace_time_zone(Some(tz), None),
+                Some(tz) => polars_ops::prelude::replace_time_zone(
+                    &ca.into_datetime(tu, None),
+                    Some(tz),
+                    None,
+                ),
                 _ => Ok(ca.into_datetime(tu, None)),
             }
         }
     }
 }
 
 pub trait AsUtf8 {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/utf8/patterns.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/utf8/patterns.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/chunkedarray/utf8/strptime.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/chunkedarray/utf8/strptime.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/date_range.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/date_range.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/dst_offset.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/dst_offset.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/groupby/dynamic.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/groupby/dynamic.rs`

 * *Files 1% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 use polars_core::export::rayon::prelude::*;
 use polars_core::frame::groupby::GroupsProxy;
 use polars_core::prelude::*;
 use polars_core::series::IsSorted;
 use polars_core::utils::ensure_sorted_arg;
 use polars_core::utils::flatten::flatten_par;
 use polars_core::POOL;
-use polars_utils::slice::SortedSlice;
+use polars_utils::slice::{GetSaferUnchecked, SortedSlice};
 #[cfg(feature = "serde")]
 use serde::{Deserialize, Serialize};
 use smartstring::alias::String as SmartString;
 
 use crate::prelude::*;
 
 #[repr(transparent)]
@@ -634,23 +634,27 @@
 fn update_subgroups_idx(
     sub_groups: &[[IdxSize; 2]],
     base_g: (IdxSize, &Vec<IdxSize>),
 ) -> Vec<(IdxSize, Vec<IdxSize>)> {
     sub_groups
         .iter()
         .map(|&[first, len]| {
-            let new_first = unsafe { *base_g.1.get_unchecked(first as usize) };
+            let new_first = if len == 0 {
+                // in case the group is empty
+                // keep the original first so that the
+                // groupby keys still point to the original group
+                base_g.0
+            } else {
+                unsafe { *base_g.1.get_unchecked_release(first as usize) }
+            };
 
             let first = first as usize;
             let len = len as usize;
             let idx = (first..first + len)
-                .map(|i| {
-                    debug_assert!(i < base_g.1.len());
-                    unsafe { *base_g.1.get_unchecked(i) }
-                })
+                .map(|i| unsafe { *base_g.1.get_unchecked_release(i) })
                 .collect_trusted::<Vec<_>>();
             (new_first, idx)
         })
         .collect_trusted::<Vec<_>>()
 }
 
 #[cfg(test)]
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/lib.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/lib.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/month_end.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/month_end.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/month_start.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/month_start.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/round.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/round.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/series/_trait.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/series/_trait.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/series/implementations/floats.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/series/implementations/floats.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/series/implementations/integers.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/series/implementations/integers.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/series/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/series/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/truncate.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/truncate.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/upsample.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/upsample.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/utils.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/utils.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/windows/bounds.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/windows/bounds.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/windows/calendar.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/windows/calendar.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/windows/duration.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/windows/duration.rs`

 * *Files 1% similar despite different names*

```diff
@@ -41,15 +41,15 @@
     // indicates if an offset to a non-existent date (e.g. 2022-02-29)
     // should saturate (to 2022-02-28) as opposed to erroring
     pub(crate) saturating: bool,
 }
 
 impl PartialOrd<Self> for Duration {
     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
-        self.duration_ns().partial_cmp(&other.duration_ns())
+        Some(self.cmp(other))
     }
 }
 
 impl Ord for Duration {
     fn cmp(&self, other: &Self) -> Ordering {
         self.duration_ns().cmp(&other.duration_ns())
     }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/windows/groupby.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/windows/groupby.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/windows/test.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/windows/test.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-time/src/windows/window.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/src/windows/window.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-error/Cargo.toml` & `polars_lts_cpu-0.18.9/local_dependencies/polars-row/Cargo.toml`

 * *Files 20% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 [package]
-name = "polars-error"
+name = "polars-row"
 version= "0.31.1"
 edition = "2021"
 license = "MIT"
 repository = "https://github.com/pola-rs/polars"
-description = "Error definitions for the Polars DataFrame library"
+description = "Row encodings for the Polars DataFrame library"
 resolver = "2"
 
 # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
 
 [dependencies]
-regex = { version = "1.6", optional = true }
-thiserror= "^1"
+polars-error = { version = "0.31.1", path = "../polars-error" }
+polars-utils = { version = "0.31.1", path = "../polars-utils" }
 
 [dependencies.arrow]
 package = "arrow2"
-# git = "https://github.com/jorgecarleitao/arrow2"
+git = "https://github.com/jorgecarleitao/arrow2"
 # git = "https://github.com/ritchie46/arrow2"
-# rev = "2d2e7053f9a50810bfe9cecff25ab39089aef98e"
+rev = "d5c78e7ba45fcebfbafd55a82ba2601ee3ea9617"
 # path = "../arrow2"
-# branch = "polars_2023-06-26"
+# branch = "duration_json"
 version = "0.17.2"
 default-features = false
 features = [
   "compute_aggregate",
   "compute_arithmetics",
   "compute_boolean",
   "compute_boolean_kleene",
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-error/LICENSE` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-error/src/lib.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-error/src/lib.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-error/src/warning.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-error/src/warning.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/Cargo.toml` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/Cargo.toml`

 * *Files 2% similar despite different names*

```diff
@@ -89,19 +89,19 @@
 simd-json = { version = "0.10", optional = true, features = ["allow-non-simd", "known-key"] }
 simdutf8 = { version = "0.1", optional = true }
 tokio = { version = "1.26.0", features = ["net"], optional = true }
 url = { version = "2.3.1", optional = true }
 
 [dependencies.arrow]
 package = "arrow2"
-# git = "https://github.com/jorgecarleitao/arrow2"
+git = "https://github.com/jorgecarleitao/arrow2"
 # git = "https://github.com/ritchie46/arrow2"
-# rev = "2d2e7053f9a50810bfe9cecff25ab39089aef98e"
+rev = "d5c78e7ba45fcebfbafd55a82ba2601ee3ea9617"
 # path = "../arrow2"
-# branch = "polars_2023-06-26"
+# branch = "duration_json"
 version = "0.17.2"
 default-features = false
 features = [
   "compute_aggregate",
   "compute_arithmetics",
   "compute_boolean",
   "compute_boolean_kleene",
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/LICENSE` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/avro/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/avro/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/avro/read.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/avro/read.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/avro/write.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/avro/write.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/cloud/adaptors.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/cloud/adaptors.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/cloud/glob.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/cloud/glob.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/cloud/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/cloud/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/csv/buffer.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/csv/buffer.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/csv/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/csv/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/csv/parser.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/csv/parser.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/csv/read.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/csv/read.rs`

 * *Files 1% similar despite different names*

```diff
@@ -319,15 +319,15 @@
     }
 }
 
 impl<'a> CsvReader<'a, File> {
     /// This is the recommended way to create a csv reader as this allows for fastest parsing.
     pub fn from_path<P: Into<PathBuf>>(path: P) -> PolarsResult<Self> {
         let path = resolve_homedir(&path.into());
-        let f = std::fs::File::open(&path)?;
+        let f = polars_utils::open_file(&path)?;
         Ok(Self::new(f).with_path(Some(path)))
     }
 }
 
 impl<'a, R: MmapBytesReader + 'a> CsvReader<'a, R> {
     fn core_reader<'b>(
         &'b mut self,
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/csv/read_impl/batched_mmap.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/csv/read_impl/batched_mmap.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/csv/read_impl/batched_read.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/csv/read_impl/batched_read.rs`

 * *Files 1% similar despite different names*

```diff
@@ -188,15 +188,17 @@
 }
 
 impl<'a> CoreReader<'a> {
     /// Create a batched csv reader that uses read calls to load data.
     pub fn batched_read(mut self, _has_cat: bool) -> PolarsResult<BatchedCsvReaderRead<'a>> {
         let reader_bytes = self.reader_bytes.take().unwrap();
 
-        let ReaderBytes::Mapped(bytes, mut file) = &reader_bytes else { unreachable!() };
+        let ReaderBytes::Mapped(bytes, mut file) = &reader_bytes else {
+            unreachable!()
+        };
         let (_, starting_point_offset) =
             self.find_starting_point(bytes, self.quote_char, self.eol_char)?;
         if let Some(starting_point_offset) = starting_point_offset {
             file.seek(SeekFrom::Current(starting_point_offset as i64))
                 .unwrap();
         }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/csv/read_impl/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/csv/read_impl/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/csv/splitfields.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/csv/splitfields.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/csv/utils.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/csv/utils.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/csv/write.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/csv/write.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/csv/write_impl.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/csv/write_impl.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/ipc/ipc_file.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/ipc/ipc_file.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/ipc/ipc_stream.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/ipc/ipc_stream.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/ipc/mmap.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/ipc/mmap.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/ipc/write.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/ipc/write.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/ipc/write_async.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/ipc/write_async.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/json/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/json/mod.rs`

 * *Files 0% similar despite different names*

```diff
@@ -239,16 +239,16 @@
                             .unwrap()?;
                         let dtype = DataType::List(Box::new(dtype));
                         dtype.to_arrow()
                     } else {
                         let dtype = infer(&json_value)?;
                         if let Some(overwrite) = self.schema_overwrite {
                             let ArrowDataType::Struct(fields) = dtype else {
-                                    polars_bail!(ComputeError: "can only deserialize json objects")
-                                };
+                                polars_bail!(ComputeError: "can only deserialize json objects")
+                            };
 
                             let mut schema = Schema::from_iter(fields.iter());
                             overwrite_schema(&mut schema, overwrite)?;
 
                             DataType::Struct(
                                 schema
                                     .into_iter()
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/lib.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/lib.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/mmap.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/mmap.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/ndjson/buffer.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/ndjson/buffer.rs`

 * *Files 1% similar despite different names*

```diff
@@ -186,15 +186,15 @@
         Value::Static(StaticNode::U64(u)) => AnyValue::UInt64(*u),
         Value::Static(StaticNode::F64(f)) => AnyValue::Float64(*f),
         Value::Static(StaticNode::Null) => AnyValue::Null,
         Value::String(s) => AnyValue::Utf8Owned(s.as_ref().into()),
         Value::Array(arr) => {
             let Some(inner_dtype) = dtype.inner_dtype() else {
                 if ignore_errors {
-                    return Ok(AnyValue::Null)
+                    return Ok(AnyValue::Null);
                 }
                 polars_bail!(ComputeError: "expected list/array in json value, got {}", dtype);
             };
             let vals: Vec<AnyValue> = arr
                 .iter()
                 .map(|val| deserialize_all(val, inner_dtype, ignore_errors))
                 .collect::<PolarsResult<_>>()?;
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/ndjson/core.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/ndjson/core.rs`

 * *Files 2% similar despite different names*

```diff
@@ -88,15 +88,15 @@
     }
 }
 
 impl<'a> JsonLineReader<'a, File> {
     /// This is the recommended way to create a json reader as this allows for fastest parsing.
     pub fn from_path<P: Into<PathBuf>>(path: P) -> PolarsResult<Self> {
         let path = resolve_homedir(&path.into());
-        let f = std::fs::File::open(&path)?;
+        let f = polars_utils::open_file(&path)?;
         Ok(Self::new(f).with_path(Some(path)))
     }
 }
 impl<'a, R> SerReader<R> for JsonLineReader<'a, R>
 where
     R: MmapBytesReader,
 {
@@ -301,19 +301,26 @@
 }
 
 fn parse_lines(bytes: &[u8], buffers: &mut PlIndexMap<BufferKey, Buffer>) -> PolarsResult<()> {
     let mut buf = vec![];
 
     // The `RawValue` is a pointer to the original JSON string and does not perform any deserialization.
     // It is used to properly iterate over the lines without re-implementing the splitlines logic when this does the same thing.
-    let mut iter =
+    let iter =
         serde_json::Deserializer::from_slice(bytes).into_iter::<Box<serde_json::value::RawValue>>();
-    while let Some(Ok(value)) = iter.next() {
-        let bytes = value.get().as_bytes();
-        parse_impl(bytes, buffers, &mut buf)?;
+    for value_result in iter {
+        match value_result {
+            Ok(value) => {
+                let bytes = value.get().as_bytes();
+                parse_impl(bytes, buffers, &mut buf)?;
+            }
+            Err(e) => {
+                polars_bail!(ComputeError: "error parsing ndjson {}", e)
+            }
+        }
     }
     Ok(())
 }
 
 /// Find the nearest next line position.
 /// Does not check for new line characters embedded in String fields.
 /// This just looks for `}\n`
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/parquet/async_impl.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/parquet/async_impl.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/parquet/mmap.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/parquet/mmap.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/parquet/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/parquet/mod.rs`

 * *Files 2% similar despite different names*

```diff
@@ -25,26 +25,25 @@
 pub use read::*;
 pub use write::{BrotliLevel, GzipLevel, ZstdLevel, *};
 
 use super::*;
 
 #[cfg(test)]
 mod test {
-    use std::fs::File;
     use std::io::Cursor;
 
     use polars_core::df;
     use polars_core::prelude::*;
 
     use crate::prelude::*;
 
     #[test]
     fn test_parquet() {
         // In CI: This test will be skipped because the file does not exist.
-        if let Ok(r) = File::open("data/simple.parquet") {
+        if let Ok(r) = polars_utils::open_file("data/simple.parquet") {
             let reader = ParquetReader::new(r);
             let df = reader.finish().unwrap();
             assert_eq!(df.get_column_names(), ["a", "b"]);
             assert_eq!(df.shape(), (3, 2));
         }
     }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/parquet/predicates.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/parquet/predicates.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/parquet/read.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/parquet/read.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/parquet/read_impl.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/parquet/read_impl.rs`

 * *Files 0% similar despite different names*

```diff
@@ -320,15 +320,15 @@
         let schema = if let Cow::Borrowed(_) = projection {
             Cow::Owned(apply_projection(schema, &projection))
         } else {
             Cow::Borrowed(schema)
         };
         Ok(arrow_schema_to_empty_df(&schema))
     } else {
-        accumulate_dataframes_vertical(dfs.into_iter())
+        accumulate_dataframes_vertical(dfs)
     }
 }
 
 /// Provide RowGroup content to the BatchedReader.
 /// This allows us to share the code to do in-memory processing for different use cases.
 pub trait FetchRowGroups: Sync + Send {
     /// Fetch the row groups in the given range and package them in a ColumnStore.
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/parquet/write.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/parquet/write.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/partition.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/partition.rs`

 * *Files 2% similar despite different names*

```diff
@@ -156,30 +156,30 @@
             df!("a" => [1, 1], "b" => [2, 2], "c" => [2, 3])?,
             df!("a" => [2], "b" => [3], "c" => [4])?,
             df!("a" => [3], "b" => [4], "c" => [5])?,
         ];
 
         let expected: Vec<(PathBuf, DataFrame)> = ["a=1/b=2", "a=2/b=3", "a=3/b=4"]
             .into_iter()
-            .zip(expected_dfs.into_iter())
+            .zip(expected_dfs)
             .map(|(p, df)| (rootdir.join(p), df))
             .collect();
 
         for (expected_dir, expected_df) in expected.iter() {
             assert!(expected_dir.exists());
 
             let ipc_paths = std::fs::read_dir(expected_dir)?
                 .map(|e| {
                     let entry = e?;
                     Ok(entry.path())
                 })
                 .collect::<PolarsResult<Vec<_>>>()?;
 
             assert_eq!(ipc_paths.len(), 1);
-            let reader = BufReader::new(std::fs::File::open(&ipc_paths[0])?);
+            let reader = BufReader::new(polars_utils::open_file(&ipc_paths[0])?);
             let df = IpcReader::new(reader).finish()?;
             assert!(expected_df.frame_equal(&df));
         }
 
         Ok(())
     }
 }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/predicates.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/predicates.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/prelude.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/prelude.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-io/src/utils.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/src/utils.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-json/Cargo.toml` & `polars_lts_cpu-0.18.9/local_dependencies/polars-json/Cargo.toml`

 * *Files 21% similar despite different names*

```diff
@@ -19,19 +19,19 @@
 polars-arrow = { version = "0.31.1", path = "../polars-arrow", default-features = false }
 polars-error = { version = "0.31.1", path = "../polars-error" }
 polars-utils = { version = "0.31.1", path = "../polars-utils" }
 simd-json = { version = "0.10", features = ["allow-non-simd", "known-key"] }
 
 [dependencies.arrow]
 package = "arrow2"
-# git = "https://github.com/jorgecarleitao/arrow2"
+git = "https://github.com/jorgecarleitao/arrow2"
 # git = "https://github.com/ritchie46/arrow2"
-# rev = "2d2e7053f9a50810bfe9cecff25ab39089aef98e"
+rev = "d5c78e7ba45fcebfbafd55a82ba2601ee3ea9617"
 # path = "../arrow2"
-# branch = "polars_2023-06-26"
+# branch = "duration_json"
 version = "0.17.2"
 default-features = false
 features = [
   "compute_aggregate",
   "compute_arithmetics",
   "compute_boolean",
   "compute_boolean_kleene",
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-json/LICENSE` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-json/src/json/deserialize.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-json/src/json/deserialize.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-json/src/json/infer_schema.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-json/src/json/infer_schema.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-json/src/ndjson/deserialize.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-json/src/ndjson/deserialize.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-json/src/ndjson/file.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-json/src/ndjson/file.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-row/Cargo.toml` & `polars_lts_cpu-0.18.9/local_dependencies/polars-error/Cargo.toml`

 * *Files 15% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 [package]
-name = "polars-row"
+name = "polars-error"
 version= "0.31.1"
 edition = "2021"
 license = "MIT"
 repository = "https://github.com/pola-rs/polars"
-description = "Row encodings for the Polars DataFrame library"
+description = "Error definitions for the Polars DataFrame library"
 resolver = "2"
 
 # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
 
 [dependencies]
-polars-error = { version = "0.31.1", path = "../polars-error" }
-polars-utils = { version = "0.31.1", path = "../polars-utils" }
+regex = { version = "1.6", optional = true }
+thiserror= "^1"
 
 [dependencies.arrow]
 package = "arrow2"
-# git = "https://github.com/jorgecarleitao/arrow2"
+git = "https://github.com/jorgecarleitao/arrow2"
 # git = "https://github.com/ritchie46/arrow2"
-# rev = "2d2e7053f9a50810bfe9cecff25ab39089aef98e"
+rev = "d5c78e7ba45fcebfbafd55a82ba2601ee3ea9617"
 # path = "../arrow2"
-# branch = "polars_2023-06-26"
+# branch = "duration_json"
 version = "0.17.2"
 default-features = false
 features = [
   "compute_aggregate",
   "compute_arithmetics",
   "compute_boolean",
   "compute_boolean_kleene",
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-row/LICENSE` & `polars_lts_cpu-0.18.9/local_dependencies/polars/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-row/src/decode.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-row/src/decode.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-row/src/encode.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-row/src/encode.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-row/src/fixed.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-row/src/fixed.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-row/src/lib.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-row/src/lib.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-row/src/row.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-row/src/row.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-row/src/utils.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-row/src/utils.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-row/src/variable.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-row/src/variable.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-sql/Cargo.toml` & `polars_lts_cpu-0.18.9/local_dependencies/polars-sql/Cargo.toml`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-sql/LICENSE` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-sql/src/context.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-sql/src/context.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-sql/src/functions.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-sql/src/functions.rs`

 * *Files 2% similar despite different names*

```diff
@@ -77,14 +77,19 @@
     /// ```
     Asin,
     /// SQL 'atan' function
     /// ```sql
     /// SELECT ATAN(column_1) from df;
     /// ```
     Atan,
+    /// SQL 'atan2' function
+    /// ```sql
+    /// SELECT ATAN2(column_1) from df;
+    /// ```
+    Atan2,
     /// SQL 'acosd' function
     /// ```sql
     /// SELECT ACOSD(column_1) from df;
     /// ```
     AcosD,
     /// SQL 'asind' function
     /// ```sql
@@ -92,14 +97,19 @@
     /// ```
     AsinD,
     /// SQL 'atand' function
     /// ```sql
     /// SELECT ATAND(column_1) from df;
     /// ```
     AtanD,
+    /// SQL 'atan2d' function
+    /// ```sql
+    /// SELECT ATAN2D(column_1) from df;
+    /// ```
+    Atan2D,
     /// SQL 'ceil' function
     /// ```sql
     /// SELECT CEIL(column_1) from df;
     /// ```
     Ceil,
     /// SQL 'exp' function
     /// ```sql
@@ -363,14 +373,16 @@
             "array_reverse",
             "array_sum",
             "array_unique",
             "array_upper",
             "asin",
             "asind",
             "atan",
+            "atan2",
+            "atan2d",
             "atand",
             "avg",
             "cbrt",
             "ceil",
             "ceiling",
             "cos",
             "cosd",
@@ -434,17 +446,19 @@
             "cosd" => Self::CosD,
             "cotd" => Self::CotD,
             "sind" => Self::SinD,
             "tand" => Self::TanD,
             "acos" => Self::Acos,
             "asin" => Self::Asin,
             "atan" => Self::Atan,
+            "atan2" => Self::Atan2,
             "acosd" => Self::AcosD,
             "asind" => Self::AsinD,
             "atand" => Self::AtanD,
+            "atan2d" => Self::Atan2D,
             "degrees" => Self::Degrees,
             "radians" => Self::Radians,
             "ceil" | "ceiling" => Self::Ceil,
             "exp" => Self::Exp,
             "floor" => Self::Floor,
             "pi" => Self::Pi,
             "ln" => Self::Ln,
@@ -523,17 +537,19 @@
             CosD => self.visit_unary(|e| e.radians().cos()),
             CotD => self.visit_unary(|e| e.radians().cot()),
             SinD => self.visit_unary(|e| e.radians().sin()),
             TanD => self.visit_unary(|e| e.radians().tan()),
             Acos => self.visit_unary(Expr::arccos),
             Asin => self.visit_unary(Expr::arcsin),
             Atan => self.visit_unary(Expr::arctan),
+            Atan2 => self.visit_binary(Expr::arctan2),
             AcosD => self.visit_unary(|e| e.arccos().degrees()),
             AsinD => self.visit_unary(|e| e.arcsin().degrees()),
             AtanD => self.visit_unary(|e| e.arctan().degrees()),
+            Atan2D => self.visit_binary(|e, s| e.arctan2(s).degrees()),
             Degrees => self.visit_unary(Expr::degrees),
             Radians => self.visit_unary(Expr::radians),
             Ceil => self.visit_unary(Expr::ceil),
             Exp => self.visit_unary(Expr::exp),
             Floor => self.visit_unary(Expr::floor),
             Pi => self.visit_nullary(Expr::pi),
             Ln => self.visit_unary(|e| e.log(std::f64::consts::E)),
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-sql/src/keywords.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-sql/src/keywords.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-sql/src/sql_expr.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-sql/src/sql_expr.rs`

 * *Files 7% similar despite different names*

```diff
@@ -402,18 +402,14 @@
         if let SqlExpr::Case {
             operand,
             conditions,
             results,
             else_result,
         } = expr
         {
-            if operand.is_some() {
-                polars_bail!(ComputeError: "CASE operand is not yet supported");
-            }
-
             polars_ensure!(
                 conditions.len() == results.len(),
                 ComputeError: "WHEN and THEN expressions must have the same length"
             );
 
             polars_ensure!(
                 !conditions.is_empty(),
@@ -428,14 +424,42 @@
             }
 
             let else_res = match else_result {
                 Some(else_res) => self.visit_expr(else_res)?,
                 None => polars_bail!(ComputeError: "ELSE expression is required"),
             };
 
+            if let Some(operand_expr) = operand {
+                let first_operand_expr = self.visit_expr(operand_expr)?;
+
+                let first = first.unwrap();
+                let first_cond = first_operand_expr.eq(self.visit_expr(first.0)?);
+                let first_then = self.visit_expr(first.1)?;
+                let expr = when(first_cond).then(first_then);
+                let next = when_thens.next();
+
+                let mut when_then = if let Some((cond, res)) = next {
+                    let second_operand_expr = self.visit_expr(operand_expr)?;
+                    let cond = second_operand_expr.eq(self.visit_expr(cond)?);
+                    let res = self.visit_expr(res)?;
+                    expr.when(cond).then(res)
+                } else {
+                    return Ok(expr.otherwise(else_res));
+                };
+
+                for (cond, res) in when_thens {
+                    let new_operand_expr = self.visit_expr(operand_expr)?;
+                    let cond = new_operand_expr.eq(self.visit_expr(cond)?);
+                    let res = self.visit_expr(res)?;
+                    when_then = when_then.when(cond).then(res);
+                }
+
+                return Ok(when_then.otherwise(else_res));
+            }
+
             let first = first.unwrap();
             let first_cond = self.visit_expr(first.0)?;
             let first_then = self.visit_expr(first.1)?;
             let expr = when(first_cond).then(first_then);
             let next = when_thens.next();
 
             let mut when_then = if let Some((cond, res)) = next {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-sql/src/table_functions.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-sql/src/table_functions.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/functions_cumulative.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/functions_cumulative.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/functions_io.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/functions_io.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/functions_math.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/functions_math.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/functions_meta.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/functions_meta.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/functions_string.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/functions_string.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/iss_7436.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/iss_7436.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/iss_7437.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/iss_7437.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/iss_7440.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/iss_7440.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/iss_8395.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/iss_8395.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/iss_8419.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/iss_8419.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/ops_distinct_on.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/ops_distinct_on.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/simple_exprs.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/simple_exprs.rs`

 * *Files 1% similar despite different names*

```diff
@@ -525,14 +525,38 @@
         .otherwise(lit("no match"))
         .alias("sign");
     let df_pl = df.lazy().select(&[case_expr]).collect().unwrap();
     assert!(df_sql.frame_equal(&df_pl));
 }
 
 #[test]
+fn test_case_expr_with_expression() {
+    let df = create_sample_df().unwrap();
+    let mut context = SQLContext::new();
+    context.register("df", df.clone().lazy());
+    let sql = r#"
+        SELECT
+            CASE b%2
+                WHEN 0 THEN 'even'
+                WHEN 1 THEN 'odd'
+                ELSE 'No?'
+            END AS parity
+        FROM df"#;
+    let df_sql = context.execute(sql).unwrap().collect().unwrap();
+    let case_expr = when((col("b") % lit(2)).eq(lit(0)))
+        .then(lit("even"))
+        .when((col("b") % lit(2)).eq(lit(1)))
+        .then(lit("odd"))
+        .otherwise(lit("No?"))
+        .alias("parity");
+    let df_pl = df.lazy().select(&[case_expr]).collect().unwrap();
+    assert!(df_sql.frame_equal(&df_pl));
+}
+
+#[test]
 fn test_sql_expr() {
     let df = create_sample_df().unwrap();
     let expr = sql_expr("MIN(a)").unwrap();
     let actual = df.clone().lazy().select(&[expr]).collect().unwrap();
     let expected = df.lazy().select(&[col("a").min()]).collect().unwrap();
     assert!(actual.frame_equal(&expected));
 }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-sql/tests/statements.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-sql/tests/statements.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/Cargo.toml` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/Cargo.toml`

 * *Files 1% similar despite different names*

```diff
@@ -177,19 +177,19 @@
 smartstring= { version = "1" }
 thiserror= "^1"
 url = { version = "2.3.1", optional = true }
 xxhash-rust= { version = "0.8.6", features = ["xxh3"] }
 
 [dependencies.arrow]
 package = "arrow2"
-# git = "https://github.com/jorgecarleitao/arrow2"
+git = "https://github.com/jorgecarleitao/arrow2"
 # git = "https://github.com/ritchie46/arrow2"
-# rev = "2d2e7053f9a50810bfe9cecff25ab39089aef98e"
+rev = "d5c78e7ba45fcebfbafd55a82ba2601ee3ea9617"
 # path = "../arrow2"
-# branch = "polars_2023-06-26"
+# branch = "duration_json"
 version = "0.17.2"
 default-features = false
 features = [
   "compute_aggregate",
   "compute_arithmetics",
   "compute_boolean",
   "compute_boolean_kleene",
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/LICENSE` & `polars_lts_cpu-0.18.9/local_dependencies/polars-json/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/arithmetic/decimal.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/arithmetic/decimal.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/arithmetic/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/arithmetic/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/arithmetic/numeric.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/arithmetic/numeric.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/array/iterator.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/array/iterator.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/array/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/array/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/bitwise.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/bitwise.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/binary.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/binary.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/boolean.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/boolean.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/fixed_size_list.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/fixed_size_list.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/from.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/from.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/list/anonymous.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/list/anonymous.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/list/binary.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/list/binary.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/list/boolean.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/list/boolean.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/list/categorical.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/list/categorical.rs`

 * *Files 6% similar despite different names*

```diff
@@ -10,25 +10,29 @@
         name: &str,
         capacity: usize,
         values_capacity: usize,
         logical_type: DataType,
     ) -> Self {
         let inner =
             ListPrimitiveChunkedBuilder::new(name, capacity, values_capacity, logical_type.clone());
-        let DataType::Categorical(Some(rev_map)) = logical_type else { panic!("expected categorical type") };
+        let DataType::Categorical(Some(rev_map)) = logical_type else {
+            panic!("expected categorical type")
+        };
         Self {
             inner,
             inner_dtype: RevMapMerger::new(rev_map),
         }
     }
 }
 
 impl ListBuilderTrait for ListCategoricalChunkedBuilder {
     fn append_series(&mut self, s: &Series) -> PolarsResult<()> {
-        let DataType::Categorical(Some(rev_map)) = s.dtype() else { polars_bail!(ComputeError: "expected categorical type")};
+        let DataType::Categorical(Some(rev_map)) = s.dtype() else {
+            polars_bail!(ComputeError: "expected categorical type")
+        };
         self.inner_dtype.merge_map(rev_map)?;
         self.inner.append_series(s)
     }
 
     fn append_null(&mut self) {
         self.inner.append_null()
     }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/list/dtypes.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/list/dtypes.rs`

 * *Files 1% similar despite different names*

```diff
@@ -24,15 +24,17 @@
     }
 
     #[inline]
     pub(super) fn update(&mut self, dtype: &DataType) -> PolarsResult<()> {
         match self {
             #[cfg(feature = "dtype-categorical")]
             DtypeMerger::Categorical(merger) => {
-                let DataType::Categorical(Some(rev_map)) = dtype else { polars_bail!(ComputeError: "expected categorical rev-map") };
+                let DataType::Categorical(Some(rev_map)) = dtype else {
+                    polars_bail!(ComputeError: "expected categorical rev-map")
+                };
                 return merger.merge_map(rev_map);
             }
             DtypeMerger::Other(Some(set_dtype)) => {
                 polars_ensure!(set_dtype == dtype, ComputeError: "dtypes don't match, got {}, expected: {}", dtype, set_dtype)
             }
             _ => {}
         }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/list/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/list/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/list/primitive.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/list/primitive.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/primitive.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/primitive.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/builder/utf8.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/builder/utf8.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/cast.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/cast.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/comparison/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/comparison/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/comparison/scalar.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/comparison/scalar.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/drop.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/drop.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/float.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/float.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/from.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/from.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/iterator/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/iterator/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/iterator/par/list.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/iterator/par/list.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/iterator/par/utf8.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/iterator/par/utf8.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/kernels/take.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/kernels/take.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/list/iterator.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/list/iterator.rs`

 * *Files 3% similar despite different names*

```diff
@@ -64,14 +64,16 @@
                         );
                     }
                 }
 
                 // update the inner state
                 unsafe { *self.inner.as_mut() = array_ref };
 
+                // last iteration could have set the sorted flag (e.g. in compute_len)
+                self.series_container.clear_settings();
                 // make sure that the length is correct
                 self.series_container._get_inner_mut().compute_len();
 
                 // Safety
                 // we cannot control the lifetime of an iterators `next` method.
                 // but as long as self is alive the reference to the series container is valid
                 let refer = &mut *self.series_container;
@@ -131,19 +133,21 @@
             // physical nested need more
             _ => inner_dtype.clone(),
         };
 
         // Safety:
         // inner type passed as physical type
         let series_container = unsafe {
-            Box::new(Series::from_chunks_and_dtype_unchecked(
+            let mut s = Series::from_chunks_and_dtype_unchecked(
                 name,
                 vec![inner_values.clone()],
                 &iter_dtype,
-            ))
+            );
+            s.clear_settings();
+            Box::new(s)
         };
 
         let ptr = series_container.array_ref(0) as *const ArrayRef as *mut ArrayRef;
 
         AmortizedListIter::new(
             self.len(),
             series_container,
@@ -224,14 +228,12 @@
     fn test_iter_list() {
         let mut builder = get_list_builder(&DataType::Int32, 10, 10, "").unwrap();
         builder.append_series(&Series::new("", &[1, 2, 3])).unwrap();
         builder.append_series(&Series::new("", &[3, 2, 1])).unwrap();
         builder.append_series(&Series::new("", &[1, 1])).unwrap();
         let ca = builder.finish();
 
-        ca.amortized_iter()
-            .zip(ca.into_iter())
-            .for_each(|(s1, s2)| {
-                assert!(s1.unwrap().as_ref().series_equal(&s2.unwrap()));
-            });
+        ca.amortized_iter().zip(&ca).for_each(|(s1, s2)| {
+            assert!(s1.unwrap().as_ref().series_equal(&s2.unwrap()));
+        });
     }
 }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/list/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/list/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/categorical/builder.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/categorical/builder.rs`

 * *Files 1% similar despite different names*

```diff
@@ -376,15 +376,15 @@
             };
 
         // in a separate scope so that we drop the global cache as soon as we are finished
         {
             let cache = &mut crate::STRING_CACHE.lock_map();
             id = cache.uuid;
 
-            for (s, h) in values.values_iter().zip(hashes.into_iter()) {
+            for (s, h) in values.values_iter().zip(hashes) {
                 let global_idx = cache.insert_from_hash(h, s);
                 // safety:
                 // we allocated enough
                 unsafe { local_to_global.push_unchecked(global_idx) }
             }
             if cache.len() > u32::MAX as usize {
                 panic!("not more than {} categories supported", u32::MAX)
@@ -459,15 +459,15 @@
     /// probe the global string cache.
     pub(crate) fn from_global_indices(cats: UInt32Chunked) -> PolarsResult<CategoricalChunked> {
         let len = crate::STRING_CACHE.read_map().len() as u32;
         let oob = cats.into_iter().flatten().any(|cat| cat >= len);
         polars_ensure!(
             !oob,
             ComputeError:
-            "cannot construct Categorical from these categories, at least on of them is out of bounds"
+            "cannot construct Categorical from these categories; at least one of them is out of bounds"
         );
         Ok(unsafe { Self::from_global_indices_unchecked(cats) })
     }
 
     /// Create a [`CategoricalChunked`] from a categorical indices. The indices will
     /// probe the global string cache.
     ///
@@ -554,15 +554,15 @@
             enable_string_cache(*b);
 
             // Use 2 builders to check if the global string cache
             // does not interfere with the index mapping
             let mut builder1 = CategoricalChunkedBuilder::new("foo", 10);
             let mut builder2 = CategoricalChunkedBuilder::new("foo", 10);
             builder1.drain_iter(vec![None, Some("hello"), Some("vietnam")]);
-            builder2.drain_iter(vec![Some("hello"), None, Some("world")].into_iter());
+            builder2.drain_iter(vec![Some("hello"), None, Some("world")]);
 
             let s = builder1.finish().into_series();
             assert_eq!(s.str_value(0).unwrap(), "null");
             assert_eq!(s.str_value(1).unwrap(), "hello");
             assert_eq!(s.str_value(2).unwrap(), "vietnam");
 
             let s = builder2.finish().into_series();
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/categorical/from.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/categorical/from.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/categorical/merge.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/categorical/merge.rs`

 * *Files 2% similar despite different names*

```diff
@@ -44,37 +44,43 @@
     // we encounter a rev-map from a different source,
     // but from the same string cache
     state: Option<State>,
 }
 
 impl RevMapMerger {
     pub(crate) fn new(rev_map: Arc<RevMapping>) -> Self {
-        let RevMapping::Global(_, _, id) = rev_map.as_ref() else { panic!("impl error") };
+        let RevMapping::Global(_, _, id) = rev_map.as_ref() else {
+            panic!("impl error")
+        };
         RevMapMerger {
             state: None,
             id: *id,
             original: rev_map,
         }
     }
 
     fn init_state(&mut self) {
-        let RevMapping::Global(map, slots, _) = self.original.as_ref() else { unreachable!() };
+        let RevMapping::Global(map, slots, _) = self.original.as_ref() else {
+            unreachable!()
+        };
         self.state = Some(State {
             map: (*map).clone(),
             slots: slots_to_mut(slots),
         })
     }
 
     pub(crate) fn merge_map(&mut self, rev_map: &Arc<RevMapping>) -> PolarsResult<()> {
         // happy path
         // they come from the same source
         if Arc::ptr_eq(&self.original, rev_map) {
             return Ok(());
         }
-        let RevMapping::Global(map, slots, id) = rev_map.as_ref() else { polars_bail!(ComputeError: "expected global rev-map") };
+        let RevMapping::Global(map, slots, id) = rev_map.as_ref() else {
+            polars_bail!(ComputeError: "expected global rev-map")
+        };
         polars_ensure!(*id == self.id, ComputeError: "categoricals don't originate from the same string cache\n\
     try setting a global string cache or increase the scope of the local string cache");
 
         if self.state.is_none() {
             self.init_state()
         }
         let state = self.state.as_mut().unwrap();
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/categorical/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/categorical/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/append.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/append.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/take_random.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/take_random.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/unique.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/unique.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/zip.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/categorical/ops/zip.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/categorical/stringcache.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/categorical/stringcache.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/date.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/date.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/datetime.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/datetime.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/decimal.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/decimal.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/duration.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/duration.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/struct_/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/struct_/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/logical/time.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/logical/time.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/mod.rs`

 * *Files 1% similar despite different names*

```diff
@@ -170,14 +170,18 @@
         self.bit_settings.contains(Settings::SORTED_DSC)
     }
 
     pub fn unset_fast_explode_list(&mut self) {
         self.bit_settings.remove(Settings::FAST_EXPLODE_LIST)
     }
 
+    pub(crate) fn clear_settings(&mut self) {
+        self.bit_settings.bits = 0;
+    }
+
     pub fn is_sorted_flag(&self) -> IsSorted {
         if self.is_sorted_ascending_flag() {
             IsSorted::Ascending
         } else if self.is_sorted_descending_flag() {
             IsSorted::Descending
         } else {
             IsSorted::Not
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ndarray.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ndarray.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/object/builder.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/object/builder.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/object/extension/drop.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/object/extension/drop.rs`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 use crate::chunked_array::object::extension::PolarsExtension;
 use crate::prelude::*;
 
 /// This will dereference a raw ptr when dropping the PolarsExtension, make sure that it's valid.
-pub(crate) unsafe fn drop_list(ca: &mut ListChunked) {
+pub(crate) unsafe fn drop_list(ca: &ListChunked) {
     let mut inner = ca.inner_dtype();
     let mut nested_count = 0;
 
     while let Some(a) = inner.inner_dtype() {
         nested_count += 1;
         inner = a.clone()
     }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/object/extension/list.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/object/extension/list.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/object/extension/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/object/extension/mod.rs`

 * *Files 0% similar despite different names*

```diff
@@ -46,18 +46,15 @@
 // not entirely sure if padding bytes in T are initialized or not.
 unsafe fn any_as_u8_slice<T: Sized>(p: &T) -> &[u8] {
     std::slice::from_raw_parts((p as *const T) as *const u8, std::mem::size_of::<T>())
 }
 
 /// Create an extension Array that can be sent to arrow and (once wrapped in `[PolarsExtension]` will
 /// also call drop on `T`, when the array is dropped.
-pub(crate) fn create_extension<
-    I: IntoIterator<Item = Option<T>> + TrustedLen,
-    T: Sized + Default,
->(
+pub(crate) fn create_extension<I: Iterator<Item = Option<T>> + TrustedLen, T: Sized + Default>(
     iter: I,
 ) -> PolarsExtension {
     let env = "POLARS_ALLOW_EXTENSION";
     std::env::var(env).unwrap_or_else(|_| {
         panic!("env var: {env} must be set to allow extension types to be created",)
     });
     let t_size = std::mem::size_of::<T>();
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/object/extension/polars_extension.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/object/extension/polars_extension.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/object/iterator.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/object/iterator.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/object/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/object/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/object/registry.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/object/registry.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/aggregate/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/aggregate/mod.rs`

 * *Files 1% similar despite different names*

```diff
@@ -219,15 +219,14 @@
             }
         }
     }
 }
 
 /// Booleans are casted to 1 or 0.
 impl BooleanChunked {
-    /// Returns `None` if the array is empty or only contains null values.
     pub fn sum(&self) -> Option<IdxSize> {
         Some(if self.is_empty() {
             0
         } else {
             self.downcast_iter()
                 .map(|arr| match arr.validity() {
                     Some(validity) => {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/aggregate/quantile.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/aggregate/quantile.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/aggregate/var.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/aggregate/var.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/any_value.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/any_value.rs`

 * *Files 1% similar despite different names*

```diff
@@ -130,32 +130,32 @@
                 let idx = *idx;
                 unsafe {
                     arr.values().iter().zip(*flds).map(move |(arr, fld)| {
                         // The dictionary arrays categories don't have to map to the rev-map in the dtype
                         // so we set the array pointer with values of the dictionary array.
                         #[cfg(feature = "dtype-categorical")]
                         {
-                            use polars_arrow::is_valid::{IsValid as _};
+                            use polars_arrow::is_valid::IsValid as _;
                             if let Some(arr) = arr.as_any().downcast_ref::<DictionaryArray<u32>>() {
                                 let keys = arr.keys();
                                 let values = arr.values();
                                 let values =
                                     values.as_any().downcast_ref::<Utf8Array<i64>>().unwrap();
                                 let arr = &*(keys as *const dyn Array as *const UInt32Array);
 
                                 if arr.is_valid_unchecked(idx) {
                                     let v = arr.value_unchecked(idx);
-                                    let DataType::Categorical(Some(rev_map)) = fld.data_type() else {
+                                    let DataType::Categorical(Some(rev_map)) = fld.data_type()
+                                    else {
                                         unimplemented!()
                                     };
                                     AnyValue::Categorical(v, rev_map, SyncPtr::from_const(values))
                                 } else {
                                     AnyValue::Null
                                 }
-
                             } else {
                                 arr_to_any_value(&**arr, idx, fld.data_type())
                             }
                         }
 
                         #[cfg(not(feature = "dtype-categorical"))]
                         {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/append.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/append.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/apply.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/apply.rs`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,15 @@
 //! Implementations of the ChunkApply Trait.
 use std::borrow::Cow;
 use std::convert::TryFrom;
 
 use arrow::array::{BooleanArray, PrimitiveArray};
+use arrow::bitmap::utils::{get_bit_unchecked, set_bit_unchecked};
 use polars_arrow::array::PolarsArray;
+use polars_arrow::bitmap::unary_mut;
 use polars_arrow::trusted_len::TrustedLenPush;
 
 use crate::prelude::*;
 use crate::series::IsSorted;
 use crate::utils::{CustomIterTools, NoNull};
 
 macro_rules! try_apply {
@@ -315,22 +317,72 @@
         })
     }
 
     fn apply<F>(&self, f: F) -> Self
     where
         F: Fn(bool) -> bool + Copy,
     {
-        apply!(self, f)
+        self.apply_kernel(&|arr| {
+            let values = arrow::bitmap::unary(arr.values(), |chunk| {
+                let bytes = chunk.to_ne_bytes();
+
+                // different output as that might lead
+                // to better internal parallelism
+                let mut out = 0u64.to_ne_bytes();
+                for i in 0..64 {
+                    unsafe {
+                        let val = get_bit_unchecked(&bytes, i);
+                        let res = f(val);
+                        set_bit_unchecked(&mut out, i, res)
+                    };
+                }
+                u64::from_ne_bytes(out)
+            });
+            BooleanArray::from_data_default(values, arr.validity().cloned()).boxed()
+        })
     }
 
     fn try_apply<F>(&self, f: F) -> PolarsResult<Self>
     where
         F: Fn(bool) -> PolarsResult<bool> + Copy,
     {
-        try_apply!(self, f)
+        let mut failed: Option<PolarsError> = None;
+        let chunks = self
+            .downcast_iter()
+            .map(|arr| {
+                let values = unary_mut(arr.values(), |chunk| {
+                    let bytes = chunk.to_ne_bytes();
+
+                    // different output as that might lead
+                    // to better internal parallelism
+                    let mut out = 0u64.to_ne_bytes();
+                    for i in 0..64 {
+                        unsafe {
+                            let val = get_bit_unchecked(&bytes, i);
+                            match f(val) {
+                                Ok(res) => set_bit_unchecked(&mut out, i, res),
+                                Err(e) => {
+                                    if failed.is_none() {
+                                        failed = Some(e)
+                                    }
+                                }
+                            }
+                        };
+                    }
+                    u64::from_ne_bytes(out)
+                });
+                Ok(BooleanArray::from_data_default(values, arr.validity().cloned()).boxed())
+            })
+            .collect::<PolarsResult<Vec<_>>>()?;
+
+        if let Some(e) = failed {
+            return Err(e);
+        }
+
+        Ok(unsafe { BooleanChunked::from_chunks(self.name(), chunks) })
     }
 
     fn apply_on_opt<F>(&'a self, f: F) -> Self
     where
         F: Fn(Option<bool>) -> Option<bool> + Copy,
     {
         self.into_iter().map(f).collect_trusted()
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/bit_repr.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/bit_repr.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/chunkops.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/chunkops.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/compare_inner.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/compare_inner.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/concat_str.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/concat_str.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/cum_agg.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/cum_agg.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/decimal.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/decimal.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/downcast.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/downcast.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/explode.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/explode.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/explode_and_offsets.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/explode_and_offsets.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/extend.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/extend.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/fill_null.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/fill_null.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/filter.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/filter.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/full.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/full.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/is_in.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/is_in.rs`

 * *Files 2% similar despite different names*

```diff
@@ -265,15 +265,21 @@
                 };
                 ca.rename(self.name());
                 Ok(ca)
             }
             DataType::Boolean => {
                 let other = other.bool().unwrap();
                 let has_true = other.any();
-                let has_false = !other.all();
+                let nc = other.null_count();
+
+                let has_false = if nc == 0 {
+                    !other.all()
+                } else {
+                    !(other.sum().unwrap() as usize + nc) == other.len()
+                };
                 Ok(self.apply(|v| if v { has_true } else { has_false }))
             }
             _ => polars_bail!(opq = is_in, self.dtype(), other.dtype()),
         }
         .map(|mut ca| {
             ca.rename(self.name());
             ca
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/min_max_binary.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/min_max_binary.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/nulls.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/nulls.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/peaks.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/peaks.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/repeat_by.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/repeat_by.rs`

 * *Files 2% similar despite different names*

```diff
@@ -28,15 +28,15 @@
                 std::iter::repeat(by.get(0).unwrap())
                     .take(self.len())
                     .collect::<Vec<IdxSize>>(),
             ));
         }
         let iter = self
             .into_iter()
-            .zip(by.into_iter())
+            .zip(by)
             .map(|(opt_v, opt_by)| opt_by.map(|by| std::iter::repeat(opt_v).take(by as usize)));
 
         // Safety:
         // Length of iter is trusted
         unsafe {
             Ok(ListChunked::from_chunks(
                 self.name(),
@@ -60,15 +60,15 @@
                     .take(self.len())
                     .collect::<Vec<IdxSize>>(),
             ));
         }
 
         let iter = self
             .into_iter()
-            .zip(by.into_iter())
+            .zip(by)
             .map(|(opt_v, opt_by)| opt_by.map(|by| std::iter::repeat(opt_v).take(by as usize)));
 
         // Safety:
         // Length of iter is trusted
         unsafe {
             Ok(ListChunked::from_chunks(
                 self.name(),
@@ -89,15 +89,15 @@
                     .take(self.len())
                     .collect::<Vec<IdxSize>>(),
             ));
         }
 
         let iter = self
             .into_iter()
-            .zip(by.into_iter())
+            .zip(by)
             .map(|(opt_v, opt_by)| opt_by.map(|by| std::iter::repeat(opt_v).take(by as usize)));
 
         // Safety:
         // Length of iter is trusted
         unsafe {
             Ok(ListChunked::from_chunks(
                 self.name(),
@@ -120,15 +120,15 @@
                 std::iter::repeat(by.get(0).unwrap())
                     .take(self.len())
                     .collect::<Vec<IdxSize>>(),
             ));
         }
         let iter = self
             .into_iter()
-            .zip(by.into_iter())
+            .zip(by)
             .map(|(opt_v, opt_by)| opt_by.map(|by| std::iter::repeat(opt_v).take(by as usize)));
 
         // Safety:
         // Length of iter is trusted
         unsafe {
             Ok(ListChunked::from_chunks(
                 self.name(),
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/reverse.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/reverse.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/rolling_window.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/rolling_window.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/set.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/set.rs`

 * *Files 6% similar despite different names*

```diff
@@ -51,15 +51,15 @@
     ) -> PolarsResult<Self> {
         if !self.has_validity() {
             if let Some(value) = value {
                 // fast path uses kernel
                 if self.chunks.len() == 1 {
                     let arr = set_at_idx_no_null(
                         self.downcast_iter().next().unwrap(),
-                        idx.into_iter(),
+                        idx,
                         value,
                         T::get_dtype().to_arrow(),
                     )?;
                     return unsafe { Ok(Self::from_chunks(self.name(), vec![Box::new(arr)])) };
                 }
                 // Other fast path. Slightly slower as it does not do a memcpy
                 else {
@@ -109,15 +109,15 @@
                 })
                 .collect();
             Ok(unsafe { ChunkedArray::from_chunks(self.name(), chunks) })
         } else {
             // slow path, could be optimized.
             let ca = mask
                 .into_iter()
-                .zip(self.into_iter())
+                .zip(self)
                 .map(|(mask_val, opt_val)| match mask_val {
                     Some(true) => value,
                     _ => opt_val,
                 })
                 .collect_trusted();
             Ok(ca)
         }
@@ -162,15 +162,15 @@
         Ok(unsafe { BooleanChunked::from_chunks(self.name(), vec![Box::new(arr)]) })
     }
 
     fn set(&'a self, mask: &BooleanChunked, value: Option<bool>) -> PolarsResult<Self> {
         check_bounds!(self, mask);
         let ca = mask
             .into_iter()
-            .zip(self.into_iter())
+            .zip(self)
             .map(|(mask_val, opt_val)| match mask_val {
                 Some(true) => value,
                 _ => opt_val,
             })
             .collect_trusted();
         Ok(ca)
     }
@@ -225,15 +225,15 @@
     fn set(&'a self, mask: &BooleanChunked, value: Option<&'a str>) -> PolarsResult<Self>
     where
         Self: Sized,
     {
         check_bounds!(self, mask);
         let ca = mask
             .into_iter()
-            .zip(self.into_iter())
+            .zip(self)
             .map(|(mask_val, opt_val)| match mask_val {
                 Some(true) => value,
                 _ => opt_val,
             })
             .collect_trusted();
         Ok(ca)
     }
@@ -289,15 +289,15 @@
     fn set(&'a self, mask: &BooleanChunked, value: Option<&'a [u8]>) -> PolarsResult<Self>
     where
         Self: Sized,
     {
         check_bounds!(self, mask);
         let ca = mask
             .into_iter()
-            .zip(self.into_iter())
+            .zip(self)
             .map(|(mask_val, opt_val)| match mask_val {
                 Some(true) => value,
                 _ => opt_val,
             })
             .collect_trusted();
         Ok(ca)
     }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/shift.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/shift.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/sort/arg_sort.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/sort/arg_sort.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/sort/arg_sort_multiple.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/sort/arg_sort_multiple.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/sort/categorical.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/sort/categorical.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/sort/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/sort/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/take/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/take/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/take/take_chunked.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/take/take_chunked.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/take/take_random.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/take/take_random.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/take/take_single.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/take/take_single.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/take/traits.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/take/traits.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/unique/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/unique/mod.rs`

 * *Files 3% similar despite different names*

```diff
@@ -74,44 +74,59 @@
             unique.push(idx as IdxSize)
         }
     });
     unique
 }
 
 #[cfg(feature = "mode")]
-#[allow(clippy::needless_collect)]
+fn mode_indices(groups: GroupsProxy) -> Vec<IdxSize> {
+    match groups {
+        GroupsProxy::Idx(groups) => {
+            let mut groups = groups.into_iter().collect_trusted::<Vec<_>>();
+            groups.sort_unstable_by_key(|k| k.1.len());
+            let last = &groups.last().unwrap();
+            let max_occur = last.1.len();
+            groups
+                .iter()
+                .rev()
+                .take_while(|v| v.1.len() == max_occur)
+                .map(|v| v.0)
+                .collect()
+        }
+        GroupsProxy::Slice { groups, .. } => {
+            let last = groups.last().unwrap();
+            let max_occur = last[1];
+
+            groups
+                .iter()
+                .rev()
+                .take_while(|v| {
+                    let len = v[1];
+                    len == max_occur
+                })
+                .map(|v| v[0])
+                .collect()
+        }
+    }
+}
+
+#[cfg(feature = "mode")]
 fn mode<T: PolarsDataType>(ca: &ChunkedArray<T>) -> ChunkedArray<T>
 where
     ChunkedArray<T>: IntoGroupsProxy + ChunkTake,
 {
     if ca.is_empty() {
         return ca.clone();
     }
-    let mut groups = ca
-        .group_tuples(true, false)
-        .unwrap()
-        .into_idx()
-        .into_iter()
-        .collect_trusted::<Vec<_>>();
-    groups.sort_unstable_by_key(|k| k.1.len());
-    let last = &groups.last().unwrap();
-
-    let max_occur = last.1.len();
+    let groups = ca.group_tuples(true, false).unwrap();
+    let idx = mode_indices(groups);
 
-    // collect until we don't take with trusted len anymore
-    // TODO! take directly from iter, but first remove standard trusted-length collect.
-    let idx = groups
-        .iter()
-        .rev()
-        .take_while(|v| v.1.len() == max_occur)
-        .map(|v| v.0)
-        .collect::<Vec<_>>();
     // Safety:
     // group indices are in bounds
-    unsafe { ca.take_unchecked(idx.into_iter().map(|i| i as usize).into()) }
+    unsafe { ca.take_unchecked(idx.as_slice().into()) }
 }
 
 macro_rules! arg_unique_ca {
     ($ca:expr) => {{
         match $ca.has_validity() {
             false => arg_unique($ca.into_no_null_iter(), $ca.len()),
             _ => arg_unique($ca.into_iter(), $ca.len()),
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/unique/rank.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/unique/rank.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/ops/zip.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/ops/zip.rs`

 * *Files 1% similar despite different names*

```diff
@@ -163,16 +163,16 @@
         mask: &BooleanChunked,
         other: &ChunkedArray<ObjectType<T>>,
     ) -> PolarsResult<ChunkedArray<ObjectType<T>>> {
         let (left, right, mask) = align_chunks_ternary(self, other, mask);
         let mut ca: Self = left
             .as_ref()
             .into_iter()
-            .zip(right.into_iter())
-            .zip(mask.into_iter())
+            .zip(right.as_ref())
+            .zip(mask.as_ref())
             .map(|((left_c, right_c), mask_c)| match mask_c {
                 Some(true) => left_c.cloned(),
                 Some(false) => right_c.cloned(),
                 None => None,
             })
             .collect();
         ca.rename(self.name());
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/random.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/random.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/temporal/conversion.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/temporal/conversion.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/temporal/date.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/temporal/date.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/temporal/datetime.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/temporal/datetime.rs`

 * *Files 3% similar despite different names*

```diff
@@ -4,16 +4,14 @@
     timestamp_ms_to_datetime, timestamp_ns_to_datetime, timestamp_us_to_datetime,
 };
 use chrono::format::{DelayedFormat, StrftimeItems};
 #[cfg(feature = "timezones")]
 use chrono::TimeZone as TimeZoneTrait;
 #[cfg(feature = "timezones")]
 use chrono_tz::Tz;
-#[cfg(feature = "timezones")]
-use polars_arrow::kernels::replace_timezone;
 
 use super::conversion::{datetime_to_timestamp_ms, datetime_to_timestamp_ns};
 use super::*;
 #[cfg(feature = "timezones")]
 use crate::chunked_array::temporal::validate_time_zone;
 use crate::prelude::DataType::Datetime;
 use crate::prelude::*;
@@ -90,37 +88,14 @@
     pub fn time_zone(&self) -> &Option<TimeZone> {
         match self.2.as_ref().unwrap() {
             DataType::Datetime(_, tz) => tz,
             _ => unreachable!(),
         }
     }
 
-    #[cfg(feature = "timezones")]
-    pub fn replace_time_zone(
-        &self,
-        time_zone: Option<&str>,
-        use_earliest: Option<bool>,
-    ) -> PolarsResult<DatetimeChunked> {
-        let out: PolarsResult<_> = {
-            let from = self.time_zone().as_deref().unwrap_or("UTC");
-            let to = time_zone.unwrap_or("UTC");
-            let chunks = self
-                .downcast_iter()
-                .map(|arr| {
-                    replace_timezone(arr, self.time_unit().to_arrow(), from, to, use_earliest)
-                })
-                .collect::<PolarsResult<_>>()?;
-            let out = unsafe { ChunkedArray::from_chunks(self.name(), chunks) };
-            Ok(out.into_datetime(self.time_unit(), time_zone.map(|x| x.to_string())))
-        };
-        let mut out = out?;
-        out.set_sorted_flag(self.is_sorted_flag());
-        Ok(out)
-    }
-
     /// Convert from Datetime into Utf8 with the given format.
     /// See [chrono strftime/strptime](https://docs.rs/chrono/0.4.19/chrono/format/strftime/index.html).
     pub fn to_string(&self, format: &str) -> PolarsResult<Utf8Chunked> {
         #[cfg(feature = "timezones")]
         use chrono::Utc;
         let conversion_f = match self.time_unit() {
             TimeUnit::Nanoseconds => timestamp_ns_to_datetime,
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/temporal/duration.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/temporal/duration.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/temporal/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/temporal/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/temporal/time.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/temporal/time.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/to_vec.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/to_vec.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/trusted_len.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/trusted_len.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/chunked_array/upstream_traits.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/chunked_array/upstream_traits.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/cloud.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/cloud.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/config.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/config.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/datatypes/_serde.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/datatypes/_serde.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/datatypes/aliases.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/datatypes/aliases.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/datatypes/any_value.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/datatypes/any_value.rs`

 * *Files 0% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 use arrow::temporal_conversions::{
     timestamp_ms_to_datetime, timestamp_ns_to_datetime, timestamp_us_to_datetime,
 };
 use arrow::types::PrimitiveType;
 #[cfg(feature = "dtype-struct")]
 use polars_arrow::trusted_len::TrustedLenPush;
+use polars_utils::format_smartstring;
 #[cfg(feature = "dtype-struct")]
 use polars_utils::slice::GetSaferUnchecked;
 #[cfg(feature = "dtype-categorical")]
 use polars_utils::sync::SyncPtr;
 use polars_utils::unwrap::UnwrapUncheckedRelease;
 
 use super::*;
@@ -452,14 +453,15 @@
                     DataType::Date => AnyValue::Date($av as i32),
                     #[cfg(feature="dtype-datetime")]
                     DataType::Datetime(tu, tz) => AnyValue::Datetime($av as i64, *tu, tz),
                     #[cfg(feature="dtype-duration")]
                     DataType::Duration(tu) => AnyValue::Duration($av as i64, *tu),
                     #[cfg(feature="dtype-time")]
                     DataType::Time => AnyValue::Time($av as i64),
+                    DataType::Utf8 => AnyValue::Utf8Owned(format_smartstring!("{}", $av)),
                     _ => polars_bail!(
                         ComputeError: "cannot cast any-value {:?} to dtype '{}'", self, dtype,
                     ),
                 }
 
             }
         );
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/datatypes/dtype.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/datatypes/dtype.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/datatypes/field.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/datatypes/field.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/datatypes/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/datatypes/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/datatypes/time_unit.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/datatypes/time_unit.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/doc/changelog/v0_10_0_11.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/doc/changelog/v0_10_0_11.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/doc/changelog/v0_7.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/doc/changelog/v0_7.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/doc/changelog/v0_8.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/doc/changelog/v0_8.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/doc/changelog/v0_9.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/doc/changelog/v0_9.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/fmt.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/fmt.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/arithmetic.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/arithmetic.rs`

 * *Files 10% similar despite different names*

```diff
@@ -4,20 +4,17 @@
 
 use crate::prelude::*;
 use crate::utils::try_get_supertype;
 
 /// Get the supertype that is valid for all columns in the DataFrame.
 /// This reduces casting of the rhs in arithmetic.
 fn get_supertype_all(df: &DataFrame, rhs: &Series) -> PolarsResult<DataType> {
-    df.columns
-        .iter()
-        .fold(Ok(rhs.dtype().clone()), |dt, s| match dt {
-            Ok(dt) => try_get_supertype(s.dtype(), &dt),
-            e => e,
-        })
+    df.columns.iter().try_fold(rhs.dtype().clone(), |dt, s| {
+        try_get_supertype(s.dtype(), &dt)
+    })
 }
 
 macro_rules! impl_arithmetic {
     ($self:expr, $rhs:expr, $operand: tt) => {{
         let st = get_supertype_all($self, $rhs)?;
         let rhs = $rhs.cast(&st)?;
         let cols = $self.columns.par_iter().map(|s| {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/asof_join/asof.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/asof_join/asof.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/asof_join/groups.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/asof_join/groups.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/asof_join/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/asof_join/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/chunks.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/chunks.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/cross_join.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/cross_join.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/explode.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/explode.rs`

 * *Files 1% similar despite different names*

```diff
@@ -33,14 +33,15 @@
     /// in the streaming engine
     /// This will not have a stable ordering
     pub streamable: bool,
 }
 
 impl DataFrame {
     pub fn explode_impl(&self, mut columns: Vec<Series>) -> PolarsResult<DataFrame> {
+        polars_ensure!(!columns.is_empty(), InvalidOperation: "no columns provided in explode");
         let mut df = self.clone();
         if self.height() == 0 {
             for s in &columns {
                 df.with_column(s.explode()?)?;
             }
             return Ok(df);
         }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/from.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/from.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/groupby/aggregations/agg_list.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/groupby/aggregations/agg_list.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/groupby/aggregations/boolean.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/groupby/aggregations/boolean.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/groupby/aggregations/dispatch.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/groupby/aggregations/dispatch.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/groupby/aggregations/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/groupby/aggregations/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/groupby/aggregations/utf8.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/groupby/aggregations/utf8.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/groupby/hashing.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/groupby/hashing.rs`

 * *Files 1% similar despite different names*

```diff
@@ -64,15 +64,15 @@
             });
             unsafe {
                 items.set_len(cap);
             }
             items
         };
         out.sort_unstable_by_key(|g| g.0);
-        let mut idx = GroupsIdx::from_iter(out.into_iter());
+        let mut idx = GroupsIdx::from_iter(out);
         idx.sorted = true;
         GroupsProxy::Idx(idx)
     } else {
         // we can just take the first value, no need to flatten
         if out.len() == 1 {
             GroupsProxy::Idx(GroupsIdx::from(out.pop().unwrap()))
         } else {
@@ -119,28 +119,27 @@
                     unsafe {
                         let mut items_ptr: *mut (IdxSize, Vec<IdxSize>) = items_ptr.get();
                         items_ptr = items_ptr.add(offset);
 
                         // give the compiler some info
                         // maybe it may elide some loop counters
                         assert_eq!(first.len(), all.len());
-                        for (i, (first, all)) in first.into_iter().zip(all.into_iter()).enumerate()
-                        {
+                        for (i, (first, all)) in first.into_iter().zip(all).enumerate() {
                             std::ptr::write(items_ptr.add(i), (first, all))
                         }
                     }
                 });
         });
         unsafe {
             items.set_len(cap);
         }
         // sort again
         items.sort_unstable_by_key(|g| g.0);
 
-        let mut idx = GroupsIdx::from_iter(items.into_iter());
+        let mut idx = GroupsIdx::from_iter(items);
         idx.sorted = true;
         GroupsProxy::Idx(idx)
     } else {
         // this materialization is parallel in the from impl.
         GroupsProxy::Idx(GroupsIdx::from(vecs))
     }
 }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/groupby/into_groups.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/groupby/into_groups.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/groupby/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/groupby/mod.rs`

 * *Files 0% similar despite different names*

```diff
@@ -778,15 +778,15 @@
         if let Some(agg) = &self.selected_agg {
             if agg.is_empty() {
                 Ok(self.df.clone())
             } else {
                 let mut new_cols = Vec::with_capacity(self.selected_keys.len() + agg.len());
                 new_cols.extend_from_slice(&self.selected_keys);
                 let cols = self.df.select_series(agg)?;
-                new_cols.extend(cols.into_iter());
+                new_cols.extend(cols);
                 Ok(DataFrame::new_no_checks(new_cols))
             }
         } else {
             Ok(self.df.clone())
         }
     }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/groupby/perfect.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/groupby/perfect.rs`

 * *Files 1% similar despite different names*

```diff
@@ -186,15 +186,17 @@
 }
 
 #[cfg(all(feature = "dtype-categorical", feature = "performant"))]
 // Special implementation so that cats can be processed in a single pass
 impl CategoricalChunked {
     // Use the indexes as perfect groups
     pub fn group_tuples_perfect(&self, multithreaded: bool, sorted: bool) -> GroupsProxy {
-        let DataType::Categorical(Some(rev_map)) = self.dtype() else { unreachable!()};
+        let DataType::Categorical(Some(rev_map)) = self.dtype() else {
+            unreachable!()
+        };
         if self.is_empty() {
             return GroupsProxy::Idx(GroupsIdx::new(vec![], vec![], true));
         }
         let cats = self.logical();
 
         let mut out = match &**rev_map {
             RevMapping::Local(cached) => {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/groupby/proxy.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/groupby/proxy.rs`

 * *Files 0% similar despite different names*

```diff
@@ -236,15 +236,15 @@
 impl IntoIterator for GroupsIdx {
     type Item = IdxItem;
     type IntoIter = std::iter::Zip<std::vec::IntoIter<IdxSize>, std::vec::IntoIter<Vec<IdxSize>>>;
 
     fn into_iter(mut self) -> Self::IntoIter {
         let first = std::mem::take(&mut self.first);
         let all = std::mem::take(&mut self.all);
-        first.into_iter().zip(all.into_iter())
+        first.into_iter().zip(all)
     }
 }
 
 impl FromParallelIterator<IdxItem> for GroupsIdx {
     fn from_par_iter<I>(par_iter: I) -> Self
     where
         I: IntoParallelIterator<Item = IdxItem>,
@@ -308,15 +308,15 @@
 }
 
 impl GroupsProxy {
     pub fn into_idx(self) -> GroupsIdx {
         match self {
             GroupsProxy::Idx(groups) => groups,
             GroupsProxy::Slice { groups, .. } => {
-                eprintln!("Had to reallocate groups, missed an optimization opportunity. Please open an issue.");
+                polars_warn!("Had to reallocate groups, missed an optimization opportunity. Please open an issue.");
                 groups
                     .iter()
                     .map(|&[first, len]| (first, (first..first + len).collect_trusted::<Vec<_>>()))
                     .collect()
             }
         }
     }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/hash_join/args.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/hash_join/args.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/hash_join/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/hash_join/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/hash_join/multiple_keys.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/hash_join/multiple_keys.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/hash_join/single_keys.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/hash_join/single_keys.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/hash_join/single_keys_dispatch.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/hash_join/single_keys_dispatch.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/hash_join/single_keys_inner.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/hash_join/single_keys_inner.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/hash_join/single_keys_left.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/hash_join/single_keys_left.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/hash_join/single_keys_outer.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/hash_join/single_keys_outer.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/hash_join/single_keys_semi_anti.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/hash_join/single_keys_semi_anti.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/hash_join/sort_merge.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/hash_join/sort_merge.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/hash_join/zip_outer.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/hash_join/zip_outer.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/row/av_buffer.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/row/av_buffer.rs`

 * *Files 5% similar despite different names*

```diff
@@ -354,59 +354,81 @@
     }
 
     #[inline]
     unsafe fn add_physical(&mut self, val: &AnyValue<'_>) {
         use AnyValueBufferTrusted::*;
         match self {
             Boolean(builder) => {
-                let AnyValue::Boolean(v) = val else { unreachable_unchecked_release!() };
+                let AnyValue::Boolean(v) = val else {
+                    unreachable_unchecked_release!()
+                };
                 builder.append_value(*v)
             }
             #[cfg(feature = "dtype-i8")]
             Int8(builder) => {
-                let AnyValue::Int8(v) = val else { unreachable_unchecked_release!() };
+                let AnyValue::Int8(v) = val else {
+                    unreachable_unchecked_release!()
+                };
                 builder.append_value(*v)
             }
             #[cfg(feature = "dtype-i16")]
             Int16(builder) => {
-                let AnyValue::Int16(v) = val else { unreachable_unchecked_release!() };
+                let AnyValue::Int16(v) = val else {
+                    unreachable_unchecked_release!()
+                };
                 builder.append_value(*v)
             }
             Int32(builder) => {
-                let AnyValue::Int32(v) = val else { unreachable_unchecked_release!() };
+                let AnyValue::Int32(v) = val else {
+                    unreachable_unchecked_release!()
+                };
                 builder.append_value(*v)
             }
             Int64(builder) => {
-                let AnyValue::Int64(v) = val else { unreachable_unchecked_release!() };
+                let AnyValue::Int64(v) = val else {
+                    unreachable_unchecked_release!()
+                };
                 builder.append_value(*v)
             }
             #[cfg(feature = "dtype-u8")]
             UInt8(builder) => {
-                let AnyValue::UInt8(v) = val else { unreachable_unchecked_release!() };
+                let AnyValue::UInt8(v) = val else {
+                    unreachable_unchecked_release!()
+                };
                 builder.append_value(*v)
             }
             #[cfg(feature = "dtype-u16")]
             UInt16(builder) => {
-                let AnyValue::UInt16(v) = val else { unreachable_unchecked_release!() };
+                let AnyValue::UInt16(v) = val else {
+                    unreachable_unchecked_release!()
+                };
                 builder.append_value(*v)
             }
             UInt32(builder) => {
-                let AnyValue::UInt32(v) = val else { unreachable_unchecked_release!() };
+                let AnyValue::UInt32(v) = val else {
+                    unreachable_unchecked_release!()
+                };
                 builder.append_value(*v)
             }
             UInt64(builder) => {
-                let AnyValue::UInt64(v) = val else { unreachable_unchecked_release!() };
+                let AnyValue::UInt64(v) = val else {
+                    unreachable_unchecked_release!()
+                };
                 builder.append_value(*v)
             }
             Float32(builder) => {
-                let AnyValue::Float32(v) = val else { unreachable_unchecked_release!() };
+                let AnyValue::Float32(v) = val else {
+                    unreachable_unchecked_release!()
+                };
                 builder.append_value(*v)
             }
             Float64(builder) => {
-                let AnyValue::Float64(v) = val else { unreachable_unchecked_release!() };
+                let AnyValue::Float64(v) = val else {
+                    unreachable_unchecked_release!()
+                };
                 builder.append_value(*v)
             }
             _ => {
                 unreachable_unchecked_release!()
             }
         }
     }
@@ -422,20 +444,24 @@
     pub unsafe fn add_unchecked_owned_physical(&mut self, val: &AnyValue<'_>) {
         use AnyValueBufferTrusted::*;
         match val {
             AnyValue::Null => self.add_null(),
             _ => {
                 match self {
                     Utf8(builder) => {
-                        let AnyValue::Utf8Owned(v) = val else { unreachable_unchecked_release!() };
+                        let AnyValue::Utf8Owned(v) = val else {
+                            unreachable_unchecked_release!()
+                        };
                         builder.append_value(v)
                     }
                     #[cfg(feature = "dtype-struct")]
                     Struct(builders) => {
-                        let AnyValue::StructOwned(payload) = val else { unreachable_unchecked_release!() };
+                        let AnyValue::StructOwned(payload) = val else {
+                            unreachable_unchecked_release!()
+                        };
                         let avs = &*payload.0;
                         // amortize loop counter
                         for i in 0..avs.len() {
                             unsafe {
                                 let (builder, _) = builders.get_unchecked_release_mut(i);
                                 let av = avs.get_unchecked_release(i).clone();
                                 // lifetime is bound to 'a
@@ -457,20 +483,24 @@
     pub unsafe fn add_unchecked_borrowed_physical(&mut self, val: &AnyValue<'_>) {
         use AnyValueBufferTrusted::*;
         match val {
             AnyValue::Null => self.add_null(),
             _ => {
                 match self {
                     Utf8(builder) => {
-                        let AnyValue::Utf8(v) = val else { unreachable_unchecked_release!() };
+                        let AnyValue::Utf8(v) = val else {
+                            unreachable_unchecked_release!()
+                        };
                         builder.append_value(v)
                     }
                     #[cfg(feature = "dtype-struct")]
                     Struct(builders) => {
-                        let AnyValue::Struct(idx, arr, fields) = val else { unreachable_unchecked_release!() };
+                        let AnyValue::Struct(idx, arr, fields) = val else {
+                            unreachable_unchecked_release!()
+                        };
                         let arrays = arr.values();
                         // amortize loop counter
                         for i in 0..fields.len() {
                             unsafe {
                                 let array = arrays.get_unchecked_release(i);
                                 let field = fields.get_unchecked_release(i);
                                 let (builder, _) = builders.get_unchecked_release_mut(i);
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/row/dataframe.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/row/dataframe.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/row/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/row/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/row/transpose.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/arg_min_max.rs`

 * *Files 24% similar despite different names*

```diff
@@ -1,267 +1,351 @@
+use argminmax::ArgMinMax;
+use arrow::array::Array;
+use arrow::bitmap::utils::{BitChunkIterExact, BitChunksExact};
+use arrow::bitmap::Bitmap;
+use polars_core::series::IsSorted;
+use polars_core::with_match_physical_numeric_polars_type;
+
 use super::*;
 
-impl DataFrame {
-    pub(crate) fn transpose_from_dtype(&self, dtype: &DataType) -> PolarsResult<DataFrame> {
-        let new_width = self.height();
-        let new_height = self.width();
-
-        match dtype {
-            #[cfg(feature = "dtype-i8")]
-            DataType::Int8 => numeric_transpose::<Int8Type>(&self.columns),
-            #[cfg(feature = "dtype-i16")]
-            DataType::Int16 => numeric_transpose::<Int16Type>(&self.columns),
-            DataType::Int32 => numeric_transpose::<Int32Type>(&self.columns),
-            DataType::Int64 => numeric_transpose::<Int64Type>(&self.columns),
-            #[cfg(feature = "dtype-u8")]
-            DataType::UInt8 => numeric_transpose::<UInt8Type>(&self.columns),
-            #[cfg(feature = "dtype-u16")]
-            DataType::UInt16 => numeric_transpose::<UInt16Type>(&self.columns),
-            DataType::UInt32 => numeric_transpose::<UInt32Type>(&self.columns),
-            DataType::UInt64 => numeric_transpose::<UInt64Type>(&self.columns),
-            DataType::Float32 => numeric_transpose::<Float32Type>(&self.columns),
-            DataType::Float64 => numeric_transpose::<Float64Type>(&self.columns),
-            #[cfg(feature = "object")]
-            DataType::Object(_) => {
-                // this requires to support `Object` in Series::iter which we don't yet
-                polars_bail!(InvalidOperation: "Object dtype not supported in 'transpose'")
+/// Argmin/ Argmax
+pub trait ArgAgg {
+    /// Get the index of the minimal value
+    fn arg_min(&self) -> Option<usize>;
+    /// Get the index of the maximal value
+    fn arg_max(&self) -> Option<usize>;
+}
+
+impl ArgAgg for Series {
+    fn arg_min(&self) -> Option<usize> {
+        use DataType::*;
+        let s = self.to_physical_repr();
+        match s.dtype() {
+            Utf8 => {
+                let ca = s.utf8().unwrap();
+                arg_min_str(ca)
             }
-            _ => {
-                let phys_dtype = dtype.to_physical();
-                let mut buffers = (0..new_width)
-                    .map(|_| {
-                        let buf: AnyValueBufferTrusted = (&phys_dtype, new_height).into();
-                        buf
-                    })
-                    .collect::<Vec<_>>();
-
-                let columns = self
-                    .columns
-                    .iter()
-                    // first cast to supertype before casting to physical to ensure units are correct
-                    .map(|s| s.cast(dtype).unwrap().cast(&phys_dtype).unwrap())
-                    .collect::<Vec<_>>();
-
-                // this is very expensive. A lot of cache misses here.
-                // This is the part that is performance critical.
-                for s in columns {
-                    polars_ensure!(s.dtype() == &phys_dtype, ComputeError: "cannot transpose with supertype: {}", dtype);
-                    s.iter().zip(buffers.iter_mut()).for_each(|(av, buf)| {
-                        // safety: we checked the type and we borrow
-                        unsafe {
-                            buf.add_unchecked_borrowed_physical(&av);
-                        }
-                    });
-                }
-                let cols = buffers
-                    .into_iter()
-                    .enumerate()
-                    .map(|(i, buf)| {
-                        let mut s = buf.into_series().cast(dtype).unwrap();
-                        s.rename(&format!("column_{i}"));
-                        s
-                    })
-                    .collect::<Vec<_>>();
-                Ok(DataFrame::new_no_checks(cols))
+            Boolean => {
+                let ca = s.bool().unwrap();
+                arg_min_bool(ca)
             }
+            dt if dt.is_numeric() => {
+                with_match_physical_numeric_polars_type!(s.dtype(), |$T| {
+                    let ca: &ChunkedArray<$T> = s.as_ref().as_ref().as_ref();
+                    if ca.is_empty() { // because argminmax assumes not empty
+                        None
+                    } else if let Ok(vals) = ca.cont_slice() {
+                        arg_min_numeric_slice(vals, ca.is_sorted_flag())
+                    } else {
+                        arg_min_numeric(ca)
+                    }
+                })
+            }
+            _ => None,
         }
     }
 
-    /// Transpose a DataFrame. This is a very expensive operation.
-    pub fn transpose(&self) -> PolarsResult<DataFrame> {
-        polars_ensure!(
-            self.height() != 0 && self.width() != 0,
-            NoData: "unable to transpose an empty dataframe"
-        );
-        let dtype = self.get_supertype().unwrap()?;
-        match dtype {
-            #[cfg(feature = "dtype-categorical")]
-            DataType::Categorical(_) => {
-                let mut valid = true;
-                let mut cache_id = None;
-                for s in self.columns.iter() {
-                    if let DataType::Categorical(Some(rev_map)) = &s.dtype() {
-                        match &**rev_map {
-                            RevMapping::Local(_) => valid = false,
-                            RevMapping::Global(_, _, id) => {
-                                if let Some(cache_id) = cache_id {
-                                    if cache_id != *id {
-                                        valid = false;
-                                    }
-                                }
-                                cache_id = Some(*id);
-                            }
-                        }
+    fn arg_max(&self) -> Option<usize> {
+        use DataType::*;
+        let s = self.to_physical_repr();
+        match s.dtype() {
+            Utf8 => {
+                let ca = s.utf8().unwrap();
+                arg_max_str(ca)
+            }
+            Boolean => {
+                let ca = s.bool().unwrap();
+                arg_max_bool(ca)
+            }
+            dt if dt.is_numeric() => {
+                with_match_physical_numeric_polars_type!(s.dtype(), |$T| {
+                    let ca: &ChunkedArray<$T> = s.as_ref().as_ref().as_ref();
+                    if ca.is_empty() { // because argminmax assumes not empty
+                        None
+                    } else if let Ok(vals) = ca.cont_slice() {
+                        arg_max_numeric_slice(vals, ca.is_sorted_flag())
+                    } else {
+                        arg_max_numeric(ca)
                     }
-                }
-                polars_ensure!(valid, ComputeError: "'transpose' of categorical can only be done if all are from the same global string cache")
+                })
             }
-            _ => {}
+            _ => None,
         }
-        self.transpose_from_dtype(&dtype)
+    }
+}
+
+pub(crate) fn arg_max_bool(ca: &BooleanChunked) -> Option<usize> {
+    if ca.is_empty() {
+        None
+    } else if ca.null_count() == ca.len() {
+        Some(0)
+    }
+    // don't check for any, that on itself is already an argmax search
+    else if ca.null_count() == 0 && ca.chunks().len() == 1 {
+        let arr = ca.downcast_iter().next().unwrap();
+        let mask = arr.values();
+        Some(first_set_bit(mask))
+    } else {
+        ca.into_iter()
+            .position(|opt_val| matches!(opt_val, Some(true)))
+    }
+}
+
+fn arg_min_bool(ca: &BooleanChunked) -> Option<usize> {
+    if ca.is_empty() || ca.null_count() == ca.len() || ca.all() {
+        Some(0)
+    } else if ca.null_count() == 0 && ca.chunks().len() == 1 {
+        let arr = ca.downcast_iter().next().unwrap();
+        let mask = arr.values();
+        Some(first_unset_bit(mask))
+    } else {
+        // also null as we see that as lower in ordering than a set value
+        ca.into_iter()
+            .position(|opt_val| matches!(opt_val, Some(false) | None))
     }
 }
 
 #[inline]
-unsafe fn add_value<T: NumericNative>(
-    values_buf_ptr: usize,
-    col_idx: usize,
-    row_idx: usize,
-    value: T,
-) {
-    let column = (*(values_buf_ptr as *mut Vec<Vec<T>>)).get_unchecked_mut(col_idx);
-    let el_ptr = column.as_mut_ptr();
-    *el_ptr.add(row_idx) = value;
+fn get_leading_zeroes(chunk: u64) -> u32 {
+    if cfg!(target_endian = "little") {
+        chunk.trailing_zeros()
+    } else {
+        chunk.leading_zeros()
+    }
+}
+
+#[inline]
+fn get_leading_ones(chunk: u64) -> u32 {
+    if cfg!(target_endian = "little") {
+        chunk.trailing_ones()
+    } else {
+        chunk.leading_ones()
+    }
 }
 
-pub(super) fn numeric_transpose<T>(cols: &[Series]) -> PolarsResult<DataFrame>
+fn first_set_bit_impl<I>(mut mask_chunks: I) -> usize
 where
-    T: PolarsNumericType,
-    ChunkedArray<T>: IntoSeries,
+    I: BitChunkIterExact<u64>,
 {
-    let new_width = cols[0].len();
-    let new_height = cols.len();
+    let mut total = 0usize;
+    let size = 64;
+    for chunk in &mut mask_chunks {
+        let pos = get_leading_zeroes(chunk);
+        if pos != size {
+            return total + pos as usize;
+        } else {
+            total += size as usize
+        }
+    }
+    if let Some(pos) = mask_chunks.remainder_iter().position(|v| v) {
+        total += pos;
+        return total;
+    }
+    // all null, return the first
+    0
+}
+
+fn first_set_bit(mask: &Bitmap) -> usize {
+    if mask.unset_bits() == 0 || mask.unset_bits() == mask.len() {
+        return 0;
+    }
+    let (slice, offset, length) = mask.as_slice();
+    if offset == 0 {
+        let mask_chunks = BitChunksExact::<u64>::new(slice, length);
+        first_set_bit_impl(mask_chunks)
+    } else {
+        let mask_chunks = mask.chunks::<u64>();
+        first_set_bit_impl(mask_chunks)
+    }
+}
 
-    let has_nulls = cols.iter().any(|s| s.null_count() > 0);
+fn first_unset_bit_impl<I>(mut mask_chunks: I) -> usize
+where
+    I: BitChunkIterExact<u64>,
+{
+    let mut total = 0usize;
+    let size = 64;
+    for chunk in &mut mask_chunks {
+        let pos = get_leading_ones(chunk);
+        if pos != size {
+            return total + pos as usize;
+        } else {
+            total += size as usize
+        }
+    }
+    if let Some(pos) = mask_chunks.remainder_iter().position(|v| !v) {
+        total += pos;
+        return total;
+    }
+    // all null, return the first
+    0
+}
 
-    let mut values_buf: Vec<Vec<T::Native>> = (0..new_width)
-        .map(|_| Vec::with_capacity(new_height))
-        .collect();
-    let mut validity_buf: Vec<_> = if has_nulls {
-        // we first use bools instead of bits, because we can access these in parallel without aliasing
-        (0..new_width).map(|_| vec![true; new_height]).collect()
+fn first_unset_bit(mask: &Bitmap) -> usize {
+    if mask.unset_bits() == 0 || mask.unset_bits() == mask.len() {
+        return 0;
+    }
+    let (slice, offset, length) = mask.as_slice();
+    if offset == 0 {
+        let mask_chunks = BitChunksExact::<u64>::new(slice, length);
+        first_unset_bit_impl(mask_chunks)
     } else {
-        (0..new_width).map(|_| vec![]).collect()
-    };
+        let mask_chunks = mask.chunks::<u64>();
+        first_unset_bit_impl(mask_chunks)
+    }
+}
 
-    // work with *mut pointers because we it is UB write to &refs.
-    let values_buf_ptr = &mut values_buf as *mut Vec<Vec<T::Native>> as usize;
-    let validity_buf_ptr = &mut validity_buf as *mut Vec<Vec<bool>> as usize;
-
-    POOL.install(|| {
-        cols.iter().enumerate().for_each(|(row_idx, s)| {
-            let s = s.cast(&T::get_dtype()).unwrap();
-            let ca = s.unpack::<T>().unwrap();
-
-            // Safety
-            // we access in parallel, but every access is unique, so we don't break aliasing rules
-            // we also ensured we allocated enough memory, so we never reallocate and thus
-            // the pointers remain valid.
-            if has_nulls {
-                for (col_idx, opt_v) in ca.into_iter().enumerate() {
-                    match opt_v {
-                        None => unsafe {
-                            let column = (*(validity_buf_ptr as *mut Vec<Vec<bool>>))
-                                .get_unchecked_mut(col_idx);
-                            let el_ptr = column.as_mut_ptr();
-                            *el_ptr.add(row_idx) = false;
-                            // we must initialize this memory otherwise downstream code
-                            // might access uninitialized memory when the masked out values
-                            // are changed.
-                            add_value(values_buf_ptr, col_idx, row_idx, T::Native::default());
-                        },
-                        Some(v) => unsafe {
-                            add_value(values_buf_ptr, col_idx, row_idx, v);
-                        },
+fn arg_min_str(ca: &Utf8Chunked) -> Option<usize> {
+    match ca.is_sorted_flag() {
+        IsSorted::Ascending => Some(0),
+        IsSorted::Descending => Some(ca.len() - 1),
+        IsSorted::Not => ca
+            .into_iter()
+            .enumerate()
+            .reduce(|acc, (idx, val)| if acc.1 > val { (idx, val) } else { acc })
+            .map(|tpl| tpl.0),
+    }
+}
+
+fn arg_max_str(ca: &Utf8Chunked) -> Option<usize> {
+    match ca.is_sorted_flag() {
+        IsSorted::Ascending => Some(ca.len() - 1),
+        IsSorted::Descending => Some(0),
+        IsSorted::Not => ca
+            .into_iter()
+            .enumerate()
+            .reduce(|acc, (idx, val)| if acc.1 < val { (idx, val) } else { acc })
+            .map(|tpl| tpl.0),
+    }
+}
+
+fn arg_min_numeric<'a, T>(ca: &'a ChunkedArray<T>) -> Option<usize>
+where
+    T: PolarsNumericType,
+    for<'b> &'b [T::Native]: ArgMinMax,
+{
+    match ca.is_sorted_flag() {
+        IsSorted::Ascending => Some(0),
+        IsSorted::Descending => Some(ca.len() - 1),
+        IsSorted::Not => {
+            ca.downcast_iter()
+                .fold((None, None, 0), |acc, arr| {
+                    if arr.len() == 0 {
+                        return acc;
                     }
-                }
-            } else {
-                for (col_idx, v) in ca.into_no_null_iter().enumerate() {
-                    unsafe {
-                        let column = (*(values_buf_ptr as *mut Vec<Vec<T::Native>>))
-                            .get_unchecked_mut(col_idx);
-                        let el_ptr = column.as_mut_ptr();
-                        *el_ptr.add(row_idx) = v;
+                    let chunk_min_idx: Option<usize>;
+                    let chunk_min_val: Option<T::Native>;
+                    if arr.null_count() > 0 {
+                        // When there are nulls, we should compare Option<T::Native>
+                        chunk_min_val = None; // because None < Some(_)
+                        chunk_min_idx = arr
+                            .into_iter()
+                            .enumerate()
+                            .reduce(|acc, (idx, val)| if acc.1 > val { (idx, val) } else { acc })
+                            .map(|tpl| tpl.0);
+                    } else {
+                        // When no nulls & array not empty => we can use fast argminmax
+                        let min_idx: usize = arr.values().as_slice().argmin();
+                        chunk_min_idx = Some(min_idx);
+                        chunk_min_val = Some(arr.value(min_idx));
                     }
-                }
-            }
-        })
-    });
 
-    let series = POOL.install(|| {
-        values_buf
-            .into_par_iter()
-            .zip(validity_buf)
-            .enumerate()
-            .map(|(i, (mut values, validity))| {
-                // Safety:
-                // all values are written we can now set len
-                unsafe {
-                    values.set_len(new_height);
-                }
-
-                let validity = if has_nulls {
-                    let validity = Bitmap::from_trusted_len_iter(validity.iter().copied());
-                    if validity.unset_bits() > 0 {
-                        Some(validity)
+                    let new_offset: usize = acc.2 + arr.len();
+                    match acc {
+                        (Some(_), Some(_), offset) => {
+                            if chunk_min_val < acc.1 {
+                                match chunk_min_idx {
+                                    Some(idx) => (Some(idx + offset), chunk_min_val, new_offset),
+                                    None => (acc.0, acc.1, new_offset),
+                                }
+                            } else {
+                                (acc.0, acc.1, new_offset)
+                            }
+                        }
+                        (None, None, offset) => match chunk_min_idx {
+                            Some(idx) => (Some(idx + offset), chunk_min_val, new_offset),
+                            None => (None, None, new_offset),
+                        },
+                        _ => unreachable!(),
+                    }
+                })
+                .0
+        }
+    }
+}
+
+fn arg_max_numeric<'a, T>(ca: &'a ChunkedArray<T>) -> Option<usize>
+where
+    T: PolarsNumericType,
+    for<'b> &'b [T::Native]: ArgMinMax,
+{
+    match ca.is_sorted_flag() {
+        IsSorted::Ascending => Some(ca.len() - 1),
+        IsSorted::Descending => Some(0),
+        IsSorted::Not => {
+            ca.downcast_iter()
+                .fold((None, None, 0), |acc, arr| {
+                    if arr.len() == 0 {
+                        return acc;
+                    }
+                    let chunk_max_idx: Option<usize>;
+                    let chunk_max_val: Option<T::Native>;
+                    if arr.null_count() > 0 {
+                        // When there are nulls, we should compare Option<T::Native>
+                        chunk_max_idx = arr
+                            .into_iter()
+                            .enumerate()
+                            .reduce(|acc, (idx, val)| if acc.1 < val { (idx, val) } else { acc })
+                            .map(|tpl| tpl.0);
+                        chunk_max_val = chunk_max_idx.map(|idx| arr.value(idx));
                     } else {
-                        None
+                        // When no nulls & array not empty => we can use fast argminmax
+                        let max_idx: usize = arr.values().as_slice().argmax();
+                        chunk_max_idx = Some(max_idx);
+                        chunk_max_val = Some(arr.value(max_idx));
+                    }
+
+                    let new_offset: usize = acc.2 + arr.len();
+                    match acc {
+                        (Some(_), Some(_), offset) => {
+                            if chunk_max_val > acc.1 {
+                                match chunk_max_idx {
+                                    Some(idx) => (Some(idx + offset), chunk_max_val, new_offset),
+                                    _ => unreachable!(), // because None < Some(_)
+                                }
+                            } else {
+                                (acc.0, acc.1, new_offset)
+                            }
+                        }
+                        (None, None, offset) => match chunk_max_idx {
+                            Some(idx) => (Some(idx + offset), chunk_max_val, new_offset),
+                            None => (None, None, new_offset),
+                        },
+                        _ => unreachable!(),
                     }
-                } else {
-                    None
-                };
-
-                let arr = PrimitiveArray::<T::Native>::new(
-                    T::get_dtype().to_arrow(),
-                    values.into(),
-                    validity,
-                );
-                let name = format!("column_{i}");
-                unsafe {
-                    ChunkedArray::<T>::from_chunks(&name, vec![Box::new(arr) as ArrayRef])
-                        .into_series()
-                }
-            })
-            .collect()
-    });
-
-    Ok(DataFrame::new_no_checks(series))
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-
-    #[test]
-    fn test_transpose() -> PolarsResult<()> {
-        let df = df![
-            "a" => [1, 2, 3],
-            "b" => [10, 20, 30],
-        ]?;
-
-        let out = df.transpose()?;
-        let expected = df![
-            "column_0" => [1, 10],
-            "column_1" => [2, 20],
-            "column_2" => [3, 30],
-
-        ]?;
-        assert!(out.frame_equal_missing(&expected));
-
-        let df = df![
-            "a" => [Some(1), None, Some(3)],
-            "b" => [Some(10), Some(20), None],
-        ]?;
-        let out = df.transpose()?;
-        let expected = df![
-            "column_0" => [1, 10],
-            "column_1" => [None, Some(20)],
-            "column_2" => [Some(3), None],
-
-        ]?;
-        assert!(out.frame_equal_missing(&expected));
-
-        let df = df![
-            "a" => ["a", "b", "c"],
-            "b" => [Some(10), Some(20), None],
-        ]?;
-        let out = df.transpose()?;
-        let expected = df![
-            "column_0" => ["a", "10"],
-            "column_1" => ["b", "20"],
-            "column_2" => [Some("c"), None],
-
-        ]?;
-        assert!(out.frame_equal_missing(&expected));
-        Ok(())
+                })
+                .0
+        }
+    }
+}
+
+fn arg_min_numeric_slice<T>(vals: &[T], is_sorted: IsSorted) -> Option<usize>
+where
+    for<'a> &'a [T]: ArgMinMax,
+{
+    match is_sorted {
+        IsSorted::Ascending => Some(0),
+        IsSorted::Descending => Some(vals.len() - 1),
+        IsSorted::Not => Some(vals.argmin()), // assumes not empty
+    }
+}
+
+fn arg_max_numeric_slice<T>(vals: &[T], is_sorted: IsSorted) -> Option<usize>
+where
+    for<'a> &'a [T]: ArgMinMax,
+{
+    match is_sorted {
+        IsSorted::Ascending => Some(vals.len() - 1),
+        IsSorted::Descending => Some(0),
+        IsSorted::Not => Some(vals.argmax()), // assumes not empty
     }
 }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/top_k.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/top_k.rs`

 * *Files 2% similar despite different names*

```diff
@@ -29,15 +29,15 @@
     fn cmp(&self, other: &Self) -> Ordering {
         self.bytes.cmp(other.bytes)
     }
 }
 
 impl PartialOrd for CompareRow<'_> {
     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
-        self.bytes.partial_cmp(other.bytes)
+        Some(self.cmp(other))
     }
 }
 
 impl DataFrame {
     pub fn top_k(
         &self,
         k: usize,
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/frame/upstream_traits.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/frame/upstream_traits.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/functions.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/functions.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/hashing/fx.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/hashing/fx.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/hashing/identity.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/hashing/identity.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/hashing/partition.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/hashing/partition.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/hashing/vector_hasher.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/hashing/vector_hasher.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/lib.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/lib.rs`

 * *Files 15% similar despite different names*

```diff
@@ -1,10 +1,14 @@
 #![cfg_attr(docsrs, feature(doc_auto_cfg))]
 #![cfg_attr(feature = "simd", feature(portable_simd))]
 #![allow(ambiguous_glob_reexports)]
+#![cfg_attr(
+    feature = "nightly",
+    allow(clippy::incorrect_partial_ord_impl_on_ord_type)
+)] // remove once stable
 extern crate core;
 
 #[macro_use]
 pub mod utils;
 pub mod chunked_array;
 pub mod cloud;
 pub mod config;
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/named_from.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/named_from.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/prelude.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/prelude.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/schema.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/schema.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/serde/chunked_array.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/serde/chunked_array.rs`

 * *Files 1% similar despite different names*

```diff
@@ -34,15 +34,15 @@
         &self,
         serializer: S,
     ) -> std::result::Result<<S as Serializer>::Ok, <S as Serializer>::Error>
     where
         S: Serializer,
     {
         let iter: I = self.iter.borrow_mut().take().unwrap();
-        serializer.collect_seq(iter.into_iter())
+        serializer.collect_seq(iter)
     }
 }
 
 fn serialize_impl<T, S>(
     serializer: S,
     name: &str,
     dtype: &DataType,
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/serde/df.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/serde/df.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/serde/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/serde/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/serde/series.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/serde/series.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/any_value.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/any_value.rs`

 * *Files 0% similar despite different names*

```diff
@@ -61,18 +61,16 @@
         scale_range = match scale_range {
             None => Some((s_av, s_av)),
             Some((s_min, s_max)) => Some((s_min.min(s_av), s_max.max(s_av))),
         };
     }
     let Some((s_min, s_max)) = scale_range else {
         // empty array or all nulls, return a decimal array with given scale (or 0 if inferring)
-        return Ok(
-            Int128Chunked::full_null("", avs.len())
-                .into_decimal_unchecked(precision, scale.unwrap_or(0))
-        );
+        return Ok(Int128Chunked::full_null("", avs.len())
+            .into_decimal_unchecked(precision, scale.unwrap_or(0)));
     };
     let scale = scale.unwrap_or(s_max);
     if s_max > scale {
         // scale is provided but is lower than actual
         // TODO: do we want lossy conversions here or not?
         polars_bail!(
             ComputeError:
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/arithmetic/borrowed.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/arithmetic/borrowed.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/arithmetic/owned.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/arithmetic/owned.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/comparison.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/comparison.rs`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,10 @@
 //! Comparison operations on Series.
 
-#[cfg(any(
-    feature = "dtype-duration",
-    feature = "dtype-datetime",
-    feature = "dtype-date",
-    feature = "dtype-time",
-    feature = "dtype-struct"
-))]
+#[cfg(feature = "dtype-struct")]
 use std::ops::Deref;
 
 use super::Series;
 use crate::apply_method_physical_numeric;
 use crate::prelude::*;
 use crate::series::arithmetic::coerce_lhs_rhs;
 
@@ -29,19 +23,14 @@
             DataType::UInt64 => lhs.u64().unwrap().$method(rhs.u64().unwrap()),
             DataType::Int8 => lhs.i8().unwrap().$method(rhs.i8().unwrap()),
             DataType::Int16 => lhs.i16().unwrap().$method(rhs.i16().unwrap()),
             DataType::Int32 => lhs.i32().unwrap().$method(rhs.i32().unwrap()),
             DataType::Int64 => lhs.i64().unwrap().$method(rhs.i64().unwrap()),
             DataType::Float32 => lhs.f32().unwrap().$method(rhs.f32().unwrap()),
             DataType::Float64 => lhs.f64().unwrap().$method(rhs.f64().unwrap()),
-            #[cfg(feature = "dtype-duration")]
-            DataType::Duration(_) => lhs
-                .duration()
-                .unwrap()
-                .$method(rhs.duration().unwrap().deref()),
             DataType::List(_) => lhs.list().unwrap().$method(rhs.list().unwrap()),
             #[cfg(feature = "dtype-struct")]
             DataType::Struct(_) => lhs
                 .struct_()
                 .unwrap()
                 .$method(rhs.struct_().unwrap().deref()),
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/from.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/from.rs`

 * *Files 0% similar despite different names*

```diff
@@ -599,15 +599,15 @@
                 let arrow_array = Box::new(StructArray::new(
                     ArrowDataType::Struct(arrow_fields),
                     values,
                     arr.validity().cloned(),
                 )) as ArrayRef;
                 let polars_fields = _fields
                     .iter()
-                    .zip(dtypes.into_iter())
+                    .zip(dtypes)
                     .map(|(field, dtype)| Field::new(&field.name, dtype))
                     .collect();
                 (vec![arrow_array], DataType::Struct(polars_fields))
             })
         }
         dt => {
             let dtype = dt.into();
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/array.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/array.rs`

 * *Files 2% similar despite different names*

```diff
@@ -16,14 +16,17 @@
     }
     fn _field(&self) -> Cow<Field> {
         Cow::Borrowed(self.0.ref_field())
     }
     fn _dtype(&self) -> &DataType {
         self.0.ref_field().data_type()
     }
+    fn _clear_settings(&mut self) {
+        self.0.clear_settings()
+    }
     fn explode_by_offsets(&self, offsets: &[i64]) -> Series {
         self.0.explode_by_offsets(offsets)
     }
 
     fn _set_sorted_flag(&mut self, is_sorted: IsSorted) {
         self.0.set_sorted_flag(is_sorted)
     }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/binary.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/binary.rs`

 * *Files 1% similar despite different names*

```diff
@@ -20,14 +20,17 @@
     }
     fn _field(&self) -> Cow<Field> {
         Cow::Borrowed(self.0.ref_field())
     }
     fn _dtype(&self) -> &DataType {
         self.0.ref_field().data_type()
     }
+    fn _clear_settings(&mut self) {
+        self.0.clear_settings()
+    }
     fn explode_by_offsets(&self, offsets: &[i64]) -> Series {
         self.0.explode_by_offsets(offsets)
     }
 
     fn _set_sorted_flag(&mut self, is_sorted: IsSorted) {
         self.0.set_sorted_flag(is_sorted)
     }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/boolean.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/boolean.rs`

 * *Files 4% similar despite different names*

```diff
@@ -21,14 +21,17 @@
     }
     fn _field(&self) -> Cow<Field> {
         Cow::Borrowed(self.0.ref_field())
     }
     fn _dtype(&self) -> &DataType {
         self.0.ref_field().data_type()
     }
+    fn _clear_settings(&mut self) {
+        self.0.clear_settings()
+    }
 
     fn explode_by_offsets(&self, offsets: &[i64]) -> Series {
         self.0.explode_by_offsets(offsets)
     }
 
     fn _set_sorted_flag(&mut self, is_sorted: IsSorted) {
         self.0.set_sorted_flag(is_sorted)
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/categorical.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/categorical.rs`

 * *Files 2% similar despite different names*

```diff
@@ -60,14 +60,17 @@
     }
     fn _field(&self) -> Cow<Field> {
         Cow::Owned(self.0.field())
     }
     fn _dtype(&self) -> &DataType {
         self.0.dtype()
     }
+    fn _clear_settings(&mut self) {
+        self.0.logical_mut().clear_settings()
+    }
 
     fn explode_by_offsets(&self, offsets: &[i64]) -> Series {
         // TODO! explode by offset should return concrete type
         self.with_state(true, |cats| {
             cats.explode_by_offsets(offsets).u32().unwrap().clone()
         })
         .into_series()
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/dates_time.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/dates_time.rs`

 * *Files 2% similar despite different names*

```diff
@@ -35,14 +35,17 @@
             }
             fn _field(&self) -> Cow<Field> {
                 Cow::Owned(self.0.field())
             }
             fn _dtype(&self) -> &DataType {
                 self.0.dtype()
             }
+            fn _clear_settings(&mut self) {
+                self.0.clear_settings()
+            }
 
             fn explode_by_offsets(&self, offsets: &[i64]) -> Series {
                 self.0
                     .explode_by_offsets(offsets)
                     .$into_logical()
                     .into_series()
             }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/datetime.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/datetime.rs`

 * *Files 1% similar despite different names*

```diff
@@ -31,14 +31,17 @@
     }
     fn _field(&self) -> Cow<Field> {
         Cow::Owned(self.0.field())
     }
     fn _dtype(&self) -> &DataType {
         self.0.dtype()
     }
+    fn _clear_settings(&mut self) {
+        self.0.clear_settings()
+    }
 
     fn explode_by_offsets(&self, offsets: &[i64]) -> Series {
         self.0
             .explode_by_offsets(offsets)
             .into_datetime(self.0.time_unit(), self.0.time_zone().clone())
             .into_series()
     }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/decimal.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/decimal.rs`

 * *Files 2% similar despite different names*

```diff
@@ -47,14 +47,17 @@
     fn _field(&self) -> Cow<Field> {
         Cow::Owned(self.0.field())
     }
 
     fn _dtype(&self) -> &DataType {
         self.0.dtype()
     }
+    fn _clear_settings(&mut self) {
+        self.0.clear_settings()
+    }
 
     #[cfg(feature = "zip_with")]
     fn zip_with_same_type(&self, mask: &BooleanChunked, other: &Series) -> PolarsResult<Series> {
         Ok(self
             .0
             .zip_with(mask, other.as_ref().as_ref())?
             .into_decimal_unchecked(self.0.precision(), self.0.scale())
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/duration.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/duration.rs`

 * *Files 1% similar despite different names*

```diff
@@ -32,14 +32,17 @@
     }
     fn _field(&self) -> Cow<Field> {
         Cow::Owned(self.0.field())
     }
     fn _dtype(&self) -> &DataType {
         self.0.dtype()
     }
+    fn _clear_settings(&mut self) {
+        self.0.clear_settings()
+    }
 
     fn explode_by_offsets(&self, offsets: &[i64]) -> Series {
         self.0
             .explode_by_offsets(offsets)
             .into_duration(self.0.time_unit())
             .into_series()
     }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/floats.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/floats.rs`

 * *Files 0% similar despite different names*

```diff
@@ -25,14 +25,17 @@
             }
             fn _field(&self) -> Cow<Field> {
                 Cow::Borrowed(self.0.ref_field())
             }
             fn _dtype(&self) -> &DataType {
                 self.0.ref_field().data_type()
             }
+            fn _clear_settings(&mut self) {
+                self.0.clear_settings()
+            }
 
             fn explode_by_offsets(&self, offsets: &[i64]) -> Series {
                 self.0.explode_by_offsets(offsets)
             }
 
             #[cfg(feature = "cum_agg")]
             fn _cummax(&self, reverse: bool) -> Series {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/list.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/list.rs`

 * *Files 8% similar despite different names*

```diff
@@ -16,14 +16,17 @@
     }
     fn _field(&self) -> Cow<Field> {
         Cow::Borrowed(self.0.ref_field())
     }
     fn _dtype(&self) -> &DataType {
         self.0.ref_field().data_type()
     }
+    fn _clear_settings(&mut self) {
+        self.0.clear_settings()
+    }
     fn explode_by_offsets(&self, offsets: &[i64]) -> Series {
         self.0.explode_by_offsets(offsets)
     }
 
     fn _set_sorted_flag(&mut self, is_sorted: IsSorted) {
         self.0.set_sorted_flag(is_sorted)
     }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/mod.rs`

 * *Files 1% similar despite different names*

```diff
@@ -87,14 +87,18 @@
                 Cow::Borrowed(self.0.ref_field())
             }
 
             fn _dtype(&self) -> &DataType {
                 self.0.ref_field().data_type()
             }
 
+            fn _clear_settings(&mut self) {
+                self.0.clear_settings()
+            }
+
             fn explode_by_offsets(&self, offsets: &[i64]) -> Series {
                 self.0.explode_by_offsets(offsets)
             }
 
             #[cfg(feature = "cum_agg")]
             fn _cummax(&self, reverse: bool) -> Series {
                 self.0.cummax(reverse).into_series()
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/null.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/null.rs`

 * *Files 1% similar despite different names*

```diff
@@ -44,14 +44,17 @@
 impl PrivateSeries for NullChunked {
     fn compute_len(&mut self) {
         // no-op
     }
     fn _field(&self) -> Cow<Field> {
         Cow::Owned(Field::new(self.name(), DataType::Null))
     }
+    fn _clear_settings(&mut self) {
+        // no-op
+    }
 
     fn _dtype(&self) -> &DataType {
         &DataType::Null
     }
 
     #[cfg(feature = "zip_with")]
     fn zip_with_same_type(&self, _mask: &BooleanChunked, _other: &Series) -> PolarsResult<Series> {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/object.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/object.rs`

 * *Files 2% similar despite different names*

```diff
@@ -34,14 +34,17 @@
     fn _field(&self) -> Cow<Field> {
         Cow::Borrowed(self.0.ref_field())
     }
 
     fn _dtype(&self) -> &DataType {
         self.0.dtype()
     }
+    fn _clear_settings(&mut self) {
+        self.0.clear_settings()
+    }
 
     unsafe fn agg_list(&self, groups: &GroupsProxy) -> Series {
         self.0.agg_list(groups)
     }
 
     fn into_partial_eq_inner<'a>(&'a self) -> Box<dyn PartialEqInner + 'a> {
         (&self.0).into_partial_eq_inner()
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/struct_.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/struct_.rs`

 * *Files 1% similar despite different names*

```diff
@@ -21,14 +21,17 @@
     }
     fn _field(&self) -> Cow<Field> {
         Cow::Borrowed(self.0.ref_field())
     }
     fn _dtype(&self) -> &DataType {
         self.0.ref_field().data_type()
     }
+    fn _clear_settings(&mut self) {
+        // no-op
+    }
     fn explode_by_offsets(&self, offsets: &[i64]) -> Series {
         self.0
             .apply_fields(|s| s.explode_by_offsets(offsets))
             .into_series()
     }
 
     unsafe fn equal_element(&self, idx_self: usize, idx_other: usize, other: &Series) -> bool {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/implementations/utf8.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/implementations/utf8.rs`

 * *Files 1% similar despite different names*

```diff
@@ -20,14 +20,17 @@
     }
     fn _field(&self) -> Cow<Field> {
         Cow::Borrowed(self.0.ref_field())
     }
     fn _dtype(&self) -> &DataType {
         self.0.ref_field().data_type()
     }
+    fn _clear_settings(&mut self) {
+        self.0.clear_settings()
+    }
     fn explode_by_offsets(&self, offsets: &[i64]) -> Series {
         self.0.explode_by_offsets(offsets)
     }
 
     fn _set_sorted_flag(&mut self, is_sorted: IsSorted) {
         self.0.set_sorted_flag(is_sorted)
     }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/into.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/into.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/iterator.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/iterator.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/mod.rs`

 * *Files 0% similar despite different names*

```diff
@@ -193,14 +193,19 @@
     }
 
     pub fn set_sorted_flag(&mut self, sorted: IsSorted) {
         let inner = self._get_inner_mut();
         inner._set_sorted_flag(sorted)
     }
 
+    pub(crate) fn clear_settings(&mut self) {
+        let inner = self._get_inner_mut();
+        inner._clear_settings()
+    }
+
     pub fn into_frame(self) -> DataFrame {
         DataFrame::new_no_checks(vec![self])
     }
 
     /// Rename series.
     pub fn rename(&mut self, name: &str) -> &mut Series {
         self._get_inner_mut().rename(name);
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/ops/diff.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/ops/diff.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/ops/downcast.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/ops/downcast.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/ops/ewm.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/ops/ewm.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/ops/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/ops/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/ops/moment.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/ops/moment.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/ops/null.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/ops/null.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/ops/pct_change.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/ops/pct_change.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/ops/round.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/ops/round.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/ops/to_list.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/ops/to_list.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/ops/unique.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/ops/unique.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/series_trait.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/series_trait.rs`

 * *Files 0% similar despite different names*

```diff
@@ -73,14 +73,16 @@
         }
 
         /// Get field (used in schema)
         fn _field(&self) -> Cow<Field>;
 
         fn _dtype(&self) -> &DataType;
 
+        fn _clear_settings(&mut self);
+
         fn compute_len(&mut self);
 
         fn explode_by_offsets(&self, _offsets: &[i64]) -> Series {
             invalid_operation_panic!(explode_by_offsets, self)
         }
 
         /// Get an array with the cumulative max computed at every element
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/series/unstable.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/series/unstable.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/testing.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/testing.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/utils/flatten.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/utils/flatten.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/utils/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/utils/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/utils/series.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/utils/series.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-core/src/utils/supertype.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-core/src/utils/supertype.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/Cargo.toml` & `polars_lts_cpu-0.18.9/local_dependencies/polars/Cargo.toml`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/LICENSE` & `polars_lts_cpu-0.18.9/local_dependencies/polars-error/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/Makefile` & `polars_lts_cpu-0.18.9/local_dependencies/polars/Makefile`

 * *Files 2% similar despite different names*

```diff
@@ -47,14 +47,15 @@
 		-p polars-io \
 		-p polars-core \
 		-p polars-arrow \
 		-p polars-time \
 		-p polars-utils \
 		-p polars-row \
 		-p polars-sql \
+		-p polars-plan \
 		-- \
 		--test-threads=2
 
 .PHONY: integration-tests
 integration-tests:  ## Run integration tests
 	cargo test --all-features --test it
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/src/docs/eager.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/src/docs/eager.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/src/docs/lazy.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/src/docs/lazy.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/src/docs/performance.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/src/docs/performance.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/src/lib.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/src/lib.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/core/date_like.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/core/date_like.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/core/groupby.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/core/groupby.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/core/joins.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/core/joins.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/core/list.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/core/list.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/core/pivot.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/core/pivot.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/core/random.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/core/random.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/core/rolling_window.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/core/rolling_window.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/core/series.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/core/series.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/io/csv.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/io/csv.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/io/ipc_stream.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/io/ipc_stream.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/io/json.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/io/json.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/io/parquet.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/io/parquet.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/joins.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/joins.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/aggregation.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/aggregation.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/cse.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/cse.rs`

 * *Files 2% similar despite different names*

```diff
@@ -24,15 +24,15 @@
         UnionArgs {
             rechunk: false,
             parallel: false,
             ..Default::default()
         },
     )
     .unwrap()
-    .with_common_subplan_elimination(true)
+    .with_comm_subplan_elim(true)
     .collect()?;
     let expected = df![
         "a" => [1, 0],
         "b" => [2, 1],
     ]?;
     assert!(out.frame_equal(&expected));
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/expressions/apply.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/expressions/apply.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/expressions/arity.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/expressions/arity.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/expressions/expand.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/expressions/expand.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/expressions/filter.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/expressions/filter.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/expressions/slice.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/expressions/slice.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/expressions/window.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/expressions/window.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/folds.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/folds.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/functions.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/functions.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/groupby.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/groupby.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/groupby_dynamic.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/groupby_dynamic.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/mod.rs`

 * *Files 1% similar despite different names*

```diff
@@ -6,14 +6,15 @@
 mod folds;
 mod functions;
 mod groupby;
 mod groupby_dynamic;
 mod predicate_queries;
 mod projection_queries;
 mod queries;
+mod schema;
 
 use polars::prelude::*;
 
 pub(crate) fn fruits_cars() -> DataFrame {
     df!(
             "A"=> [1, 2, 3, 4, 5],
             "fruits"=> ["banana", "banana", "apple", "apple", "banana"],
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/predicate_queries.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/predicate_queries.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/projection_queries.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/projection_queries.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/lazy/queries.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/lazy/queries.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/schema.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/schema.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars/tests/it/time/date_range.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars/tests/it/time/date_range.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/Cargo.toml` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/Cargo.toml`

 * *Files 10% similar despite different names*

```diff
@@ -9,14 +9,16 @@
 resolver = "2"
 
 # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
 
 [dependencies]
 argminmax = { version = "0.6.1", default-features = false, features = ["float"] }
 base64 = { version = "0.21", optional = true }
+chrono = { version = "0.4", default-features = false, features = ["std"], optional = true }
+chrono-tz = { version = "0.8", optional = true }
 either= "1.8"
 hex = { version = "0.4", optional = true }
 indexmap= { version = "2", features = ["std"] }
 jsonpath_lib = { version = "0.3.0", optional = true, git = "https://github.com/ritchie46/jsonpath", branch = "improve_compiled" }
 memchr= "2"
 polars-arrow = { version = "0.31.1", path = "../polars-arrow", default-features = false }
 polars-core = { version = "0.31.1", path = "../polars-core", features = [], default-features = false }
@@ -48,14 +50,15 @@
 round_series = []
 is_first = []
 is_unique = []
 approx_unique = []
 fused = []
 cutqcut = ["dtype-categorical", "dtype-struct"]
 rle = ["dtype-struct"]
+timezones = ["chrono-tz", "chrono"]
 
 # extra utilities for BinaryChunked
 binary_encoding = ["base64", "hex"]
 string_encoding = ["base64", "hex"]
 
 # ops
 to_dummies = []
@@ -81,19 +84,19 @@
 semi_anti_join = ["polars-core/semi_anti_join"]
 list_take = []
 list_sets = []
 list_any_all = []
 
 [dependencies.arrow]
 package = "arrow2"
-# git = "https://github.com/jorgecarleitao/arrow2"
+git = "https://github.com/jorgecarleitao/arrow2"
 # git = "https://github.com/ritchie46/arrow2"
-# rev = "2d2e7053f9a50810bfe9cecff25ab39089aef98e"
+rev = "d5c78e7ba45fcebfbafd55a82ba2601ee3ea9617"
 # path = "../arrow2"
-# branch = "polars_2023-06-26"
+# branch = "duration_json"
 version = "0.17.2"
 default-features = false
 features = [
   "compute_aggregate",
   "compute_arithmetics",
   "compute_boolean",
   "compute_boolean_kleene",
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/LICENSE` & `polars_lts_cpu-0.18.9/local_dependencies/polars-time/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/array/min_max.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/array/min_max.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/array/namespace.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/array/namespace.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/array/sum_mean.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/array/sum_mean.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/binary/namespace.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/binary/namespace.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/interpolate.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/interpolate.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/list/any_all.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/list/any_all.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/list/count.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/list/count.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/list/hash.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/list/hash.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/list/min_max.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/list/min_max.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/list/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/list/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/list/namespace.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/list/namespace.rs`

 * *Files 0% similar despite different names*

```diff
@@ -286,15 +286,15 @@
 
         use DataType::*;
         match idx.dtype() {
             List(_) => {
                 let idx_ca = idx.list().unwrap();
                 let mut out = list_ca
                     .amortized_iter()
-                    .zip(idx_ca.into_iter())
+                    .zip(idx_ca)
                     .map(|(opt_s, opt_idx)| {
                         {
                             match (opt_s, opt_idx) {
                                 (Some(s), Some(idx)) => {
                                     Some(take_series(s.as_ref(), idx, null_on_oob))
                                 }
                                 _ => None,
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/list/sets.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/list/sets.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/list/sum_mean.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/list/sum_mean.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/list/to_struct.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/list/to_struct.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/nan_propagating_aggregate.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/nan_propagating_aggregate.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/set.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/set.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/strings/case.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/strings/case.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/strings/json_path.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/strings/json_path.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/strings/justify.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/strings/justify.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/strings/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/strings/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/strings/namespace.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/strings/namespace.rs`

 * *Files 1% similar despite different names*

```diff
@@ -332,15 +332,15 @@
             ca.len() == pat.len(),
             ComputeError: "pattern's length: {} does not match that of the argument series: {}",
             pat.len(), ca.len(),
         );
 
         let mut builder = ListUtf8ChunkedBuilder::new(ca.name(), ca.len(), ca.get_values_size());
 
-        for (opt_s, opt_pat) in ca.into_iter().zip(pat.into_iter()) {
+        for (opt_s, opt_pat) in ca.into_iter().zip(pat) {
             match (opt_s, opt_pat) {
                 (_, None) | (None, _) => builder.append_null(),
                 (Some(s), Some(pat)) => {
                     let reg = Regex::new(pat)?;
                     let mut iter = reg.find_iter(s).map(|m| m.as_str()).peekable();
                     if iter.peek().is_some() {
                         builder.append_values_iter(iter);
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/strings/replace.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/strings/replace.rs`

 * *Files 5% similar despite different names*

```diff
@@ -57,16 +57,22 @@
         };
         if i == end {
             // reset the count as we entered a new string region
             count = 0;
 
             // set the end of this string region
             // safety: invariant of Utf8Array tells us that there is a next offset.
-            if let Some(next) = offsets_iter.next() {
-                end = *next as usize - 1;
+
+            // must loop to skip null values, as they have the same offsets
+            for next in offsets_iter.by_ref() {
+                let new_end = *next as usize - 1;
+                if new_end != end {
+                    end = new_end;
+                    break;
+                }
             }
         }
     }
     unsafe { Utf8Array::new_unchecked(arr.data_type().clone(), offsets, values.into(), validity) }
 }
 
 pub(super) fn replace_lit_n_str(
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/chunked_array/top_k.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/chunked_array/top_k.rs`

 * *Files 7% similar despite different names*

```diff
@@ -13,25 +13,23 @@
     fn eq(&self, other: &Self) -> bool {
         matches!(self.cmp(other), Ordering::Equal)
     }
 }
 
 impl<T: PartialOrd + IsFloat> PartialOrd for Compare<T> {
     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
-        Some(compare_fn_nan_max(&self.0, &other.0))
+        Some(self.cmp(other))
     }
 }
 
 impl<T: PartialOrd + IsFloat> Eq for Compare<T> {}
 
 impl<T: PartialOrd + IsFloat> Ord for Compare<T> {
     fn cmp(&self, other: &Self) -> Ordering {
-        // Safety:
-        // we always return Some
-        unsafe { self.partial_cmp(other).unwrap_unchecked() }
+        compare_fn_nan_max(&self.0, &other.0)
     }
 }
 
 fn arg_partition<T: IsFloat + PartialOrd>(v: &mut [T], k: usize, descending: bool) -> &[T] {
     let (lower, _el, upper) = v.select_nth_unstable_by(k, |a, b| compare_fn_nan_max(a, b));
     if descending {
         sort_slice_ascending(lower);
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/frame/join/merge_sorted.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/frame/join/merge_sorted.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/frame/join/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/frame/join/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/frame/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/frame/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/frame/pivot/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/frame/pivot/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/frame/pivot/positioning.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/frame/pivot/positioning.rs`

 * *Files 1% similar despite different names*

```diff
@@ -127,14 +127,16 @@
             .enumerate()
             .for_each(|(i, (offset, len))| {
                 let start_ptr = start_ptr as *mut Option<T::Native>;
                 let row_locations = &row_locations[offset..offset + len];
                 let col_locations = &col_locations[offset..offset + len];
                 let value_agg_phys = value_agg_phys.slice(offset as i64, len);
 
+                // todo! remove lint silencing
+                #[allow(clippy::useless_conversion)]
                 for ((row_idx, col_idx), val) in row_locations
                     .iter()
                     .zip(col_locations)
                     .zip(value_agg_phys.into_iter())
                 {
                     // Safety:
                     // in bounds
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/approx_algo/hyperloglogplus.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/approx_algo/hyperloglogplus.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/approx_unique.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/approx_unique.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/arg_min_max.rs` & `polars_lts_cpu-0.18.9/src/apply/dataframe.rs`

 * *Files 26% similar despite different names*

```diff
@@ -1,351 +1,318 @@
-use argminmax::ArgMinMax;
-use arrow::array::Array;
-use arrow::bitmap::utils::{BitChunkIterExact, BitChunksExact};
-use arrow::bitmap::Bitmap;
-use polars_core::series::IsSorted;
-use polars_core::with_match_physical_numeric_polars_type;
+use polars::prelude::*;
+use polars_core::frame::row::{rows_to_schema_first_non_null, Row};
+use polars_core::series::SeriesIter;
+use pyo3::conversion::{FromPyObject, IntoPy};
+use pyo3::prelude::*;
+use pyo3::types::{PyBool, PyFloat, PyInt, PyList, PyString, PyTuple};
 
 use super::*;
-
-/// Argmin/ Argmax
-pub trait ArgAgg {
-    /// Get the index of the minimal value
-    fn arg_min(&self) -> Option<usize>;
-    /// Get the index of the maximal value
-    fn arg_max(&self) -> Option<usize>;
-}
-
-impl ArgAgg for Series {
-    fn arg_min(&self) -> Option<usize> {
-        use DataType::*;
-        let s = self.to_physical_repr();
-        match s.dtype() {
-            Utf8 => {
-                let ca = s.utf8().unwrap();
-                arg_min_str(ca)
-            }
-            Boolean => {
-                let ca = s.bool().unwrap();
-                arg_min_bool(ca)
-            }
-            dt if dt.is_numeric() => {
-                with_match_physical_numeric_polars_type!(s.dtype(), |$T| {
-                    let ca: &ChunkedArray<$T> = s.as_ref().as_ref().as_ref();
-                    if ca.is_empty() { // because argminmax assumes not empty
-                        None
-                    } else if let Ok(vals) = ca.cont_slice() {
-                        arg_min_numeric_slice(vals, ca.is_sorted_flag())
-                    } else {
-                        arg_min_numeric(ca)
-                    }
-                })
-            }
-            _ => None,
-        }
-    }
-
-    fn arg_max(&self) -> Option<usize> {
-        use DataType::*;
-        let s = self.to_physical_repr();
-        match s.dtype() {
-            Utf8 => {
-                let ca = s.utf8().unwrap();
-                arg_max_str(ca)
-            }
-            Boolean => {
-                let ca = s.bool().unwrap();
-                arg_max_bool(ca)
-            }
-            dt if dt.is_numeric() => {
-                with_match_physical_numeric_polars_type!(s.dtype(), |$T| {
-                    let ca: &ChunkedArray<$T> = s.as_ref().as_ref().as_ref();
-                    if ca.is_empty() { // because argminmax assumes not empty
-                        None
-                    } else if let Ok(vals) = ca.cont_slice() {
-                        arg_max_numeric_slice(vals, ca.is_sorted_flag())
-                    } else {
-                        arg_max_numeric(ca)
-                    }
-                })
-            }
-            _ => None,
+use crate::conversion::Wrap;
+use crate::error::PyPolarsErr;
+use crate::series::PySeries;
+use crate::PyDataFrame;
+
+fn get_iters(df: &DataFrame) -> Vec<SeriesIter> {
+    df.get_columns().iter().map(|s| s.iter()).collect()
+}
+
+fn get_iters_skip(df: &DataFrame, skip: usize) -> Vec<std::iter::Skip<SeriesIter>> {
+    df.get_columns()
+        .iter()
+        .map(|s| s.iter().skip(skip))
+        .collect()
+}
+
+// the return type is Union[PySeries, PyDataFrame] and a boolean indicating if it is a dataframe or not
+pub fn apply_lambda_unknown<'a>(
+    df: &'a DataFrame,
+    py: Python,
+    lambda: &'a PyAny,
+    inference_size: usize,
+) -> PyResult<(PyObject, bool)> {
+    let mut null_count = 0;
+    let mut iters = get_iters(df);
+
+    for _ in 0..df.height() {
+        let iter = iters.iter_mut().map(|it| Wrap(it.next().unwrap()));
+        let arg = (PyTuple::new(py, iter),);
+        let out = lambda.call1(arg)?;
+
+        if out.is_none() {
+            null_count += 1;
+            continue;
+        } else if out.is_instance_of::<PyBool>() {
+            let first_value = out.extract::<bool>().ok();
+            return Ok((
+                PySeries::new(
+                    apply_lambda_with_bool_out_type(df, py, lambda, null_count, first_value)
+                        .into_series(),
+                )
+                .into_py(py),
+                false,
+            ));
+        } else if out.is_instance_of::<PyFloat>() {
+            let first_value = out.extract::<f64>().ok();
+
+            return Ok((
+                PySeries::new(
+                    apply_lambda_with_primitive_out_type::<Float64Type>(
+                        df,
+                        py,
+                        lambda,
+                        null_count,
+                        first_value,
+                    )
+                    .into_series(),
+                )
+                .into_py(py),
+                false,
+            ));
+        } else if out.is_instance_of::<PyInt>() {
+            let first_value = out.extract::<i64>().ok();
+            return Ok((
+                PySeries::new(
+                    apply_lambda_with_primitive_out_type::<Int64Type>(
+                        df,
+                        py,
+                        lambda,
+                        null_count,
+                        first_value,
+                    )
+                    .into_series(),
+                )
+                .into_py(py),
+                false,
+            ));
+        } else if out.is_instance_of::<PyString>() {
+            let first_value = out.extract::<&str>().ok();
+            return Ok((
+                PySeries::new(
+                    apply_lambda_with_utf8_out_type(df, py, lambda, null_count, first_value)
+                        .into_series(),
+                )
+                .into_py(py),
+                false,
+            ));
+        } else if out.hasattr("_s")? {
+            let py_pyseries = out.getattr("_s").unwrap();
+            let series = py_pyseries.extract::<PySeries>().unwrap().series;
+            let dt = series.dtype();
+            return Ok((
+                PySeries::new(
+                    apply_lambda_with_list_out_type(df, py, lambda, null_count, Some(&series), dt)?
+                        .into_series(),
+                )
+                .into_py(py),
+                false,
+            ));
+        } else if out.extract::<Wrap<Row<'a>>>().is_ok() {
+            let first_value = out.extract::<Wrap<Row<'a>>>().unwrap().0;
+            return Ok((
+                PyDataFrame::from(
+                    apply_lambda_with_rows_output(
+                        df,
+                        py,
+                        lambda,
+                        null_count,
+                        first_value,
+                        inference_size,
+                    )
+                    .map_err(PyPolarsErr::from)?,
+                )
+                .into_py(py),
+                true,
+            ));
+        } else if out.is_instance_of::<PyList>() || out.is_instance_of::<PyTuple>() {
+            return Err(PyPolarsErr::Other(
+                "A list output type is invalid. Do you mean to create polars List Series?\
+Then return a Series object."
+                    .into(),
+            )
+            .into());
+        } else {
+            return Err(PyPolarsErr::Other("Could not determine output type".into()).into());
         }
     }
+    Err(PyPolarsErr::Other("Could not determine output type".into()).into())
 }
 
-pub(crate) fn arg_max_bool(ca: &BooleanChunked) -> Option<usize> {
-    if ca.is_empty() {
-        None
-    } else if ca.null_count() == ca.len() {
-        Some(0)
-    }
-    // don't check for any, that on itself is already an argmax search
-    else if ca.null_count() == 0 && ca.chunks().len() == 1 {
-        let arr = ca.downcast_iter().next().unwrap();
-        let mask = arr.values();
-        Some(first_set_bit(mask))
-    } else {
-        ca.into_iter()
-            .position(|opt_val| matches!(opt_val, Some(true)))
-    }
-}
-
-fn arg_min_bool(ca: &BooleanChunked) -> Option<usize> {
-    if ca.is_empty() || ca.null_count() == ca.len() || ca.all() {
-        Some(0)
-    } else if ca.null_count() == 0 && ca.chunks().len() == 1 {
-        let arr = ca.downcast_iter().next().unwrap();
-        let mask = arr.values();
-        Some(first_unset_bit(mask))
-    } else {
-        // also null as we see that as lower in ordering than a set value
-        ca.into_iter()
-            .position(|opt_val| matches!(opt_val, Some(false) | None))
-    }
-}
-
-#[inline]
-fn get_leading_zeroes(chunk: u64) -> u32 {
-    if cfg!(target_endian = "little") {
-        chunk.trailing_zeros()
-    } else {
-        chunk.leading_zeros()
-    }
-}
-
-#[inline]
-fn get_leading_ones(chunk: u64) -> u32 {
-    if cfg!(target_endian = "little") {
-        chunk.trailing_ones()
-    } else {
-        chunk.leading_ones()
-    }
-}
-
-fn first_set_bit_impl<I>(mut mask_chunks: I) -> usize
+fn apply_iter<'a, T>(
+    df: &'a DataFrame,
+    py: Python<'a>,
+    lambda: &'a PyAny,
+    init_null_count: usize,
+    skip: usize,
+) -> impl Iterator<Item = Option<T>> + 'a
 where
-    I: BitChunkIterExact<u64>,
+    T: FromPyObject<'a>,
 {
-    let mut total = 0usize;
-    let size = 64;
-    for chunk in &mut mask_chunks {
-        let pos = get_leading_zeroes(chunk);
-        if pos != size {
-            return total + pos as usize;
-        } else {
-            total += size as usize
+    let mut iters = get_iters_skip(df, init_null_count + skip);
+    ((init_null_count + skip)..df.height()).map(move |_| {
+        let iter = iters.iter_mut().map(|it| Wrap(it.next().unwrap()));
+        let tpl = (PyTuple::new(py, iter),);
+        match lambda.call1(tpl) {
+            Ok(val) => val.extract::<T>().ok(),
+            Err(e) => panic!("python function failed {e}"),
         }
-    }
-    if let Some(pos) = mask_chunks.remainder_iter().position(|v| v) {
-        total += pos;
-        return total;
-    }
-    // all null, return the first
-    0
-}
-
-fn first_set_bit(mask: &Bitmap) -> usize {
-    if mask.unset_bits() == 0 || mask.unset_bits() == mask.len() {
-        return 0;
-    }
-    let (slice, offset, length) = mask.as_slice();
-    if offset == 0 {
-        let mask_chunks = BitChunksExact::<u64>::new(slice, length);
-        first_set_bit_impl(mask_chunks)
-    } else {
-        let mask_chunks = mask.chunks::<u64>();
-        first_set_bit_impl(mask_chunks)
-    }
+    })
 }
 
-fn first_unset_bit_impl<I>(mut mask_chunks: I) -> usize
+/// Apply a lambda with a primitive output type
+pub fn apply_lambda_with_primitive_out_type<'a, D>(
+    df: &'a DataFrame,
+    py: Python<'a>,
+    lambda: &'a PyAny,
+    init_null_count: usize,
+    first_value: Option<D::Native>,
+) -> ChunkedArray<D>
 where
-    I: BitChunkIterExact<u64>,
+    D: PyArrowPrimitiveType,
+    D::Native: ToPyObject + FromPyObject<'a>,
 {
-    let mut total = 0usize;
-    let size = 64;
-    for chunk in &mut mask_chunks {
-        let pos = get_leading_ones(chunk);
-        if pos != size {
-            return total + pos as usize;
-        } else {
-            total += size as usize
-        }
-    }
-    if let Some(pos) = mask_chunks.remainder_iter().position(|v| !v) {
-        total += pos;
-        return total;
-    }
-    // all null, return the first
-    0
-}
-
-fn first_unset_bit(mask: &Bitmap) -> usize {
-    if mask.unset_bits() == 0 || mask.unset_bits() == mask.len() {
-        return 0;
-    }
-    let (slice, offset, length) = mask.as_slice();
-    if offset == 0 {
-        let mask_chunks = BitChunksExact::<u64>::new(slice, length);
-        first_unset_bit_impl(mask_chunks)
+    let skip = usize::from(first_value.is_some());
+    if init_null_count == df.height() {
+        ChunkedArray::full_null("apply", df.height())
     } else {
-        let mask_chunks = mask.chunks::<u64>();
-        first_unset_bit_impl(mask_chunks)
+        let iter = apply_iter(df, py, lambda, init_null_count, skip);
+        iterator_to_primitive(iter, init_null_count, first_value, "apply", df.height())
     }
 }
 
-fn arg_min_str(ca: &Utf8Chunked) -> Option<usize> {
-    match ca.is_sorted_flag() {
-        IsSorted::Ascending => Some(0),
-        IsSorted::Descending => Some(ca.len() - 1),
-        IsSorted::Not => ca
-            .into_iter()
-            .enumerate()
-            .reduce(|acc, (idx, val)| if acc.1 > val { (idx, val) } else { acc })
-            .map(|tpl| tpl.0),
+/// Apply a lambda with a boolean output type
+pub fn apply_lambda_with_bool_out_type<'a>(
+    df: &'a DataFrame,
+    py: Python,
+    lambda: &'a PyAny,
+    init_null_count: usize,
+    first_value: Option<bool>,
+) -> ChunkedArray<BooleanType> {
+    let skip = usize::from(first_value.is_some());
+    if init_null_count == df.height() {
+        ChunkedArray::full_null("apply", df.height())
+    } else {
+        let iter = apply_iter(df, py, lambda, init_null_count, skip);
+        iterator_to_bool(iter, init_null_count, first_value, "apply", df.height())
     }
 }
 
-fn arg_max_str(ca: &Utf8Chunked) -> Option<usize> {
-    match ca.is_sorted_flag() {
-        IsSorted::Ascending => Some(ca.len() - 1),
-        IsSorted::Descending => Some(0),
-        IsSorted::Not => ca
-            .into_iter()
-            .enumerate()
-            .reduce(|acc, (idx, val)| if acc.1 < val { (idx, val) } else { acc })
-            .map(|tpl| tpl.0),
+/// Apply a lambda with utf8 output type
+pub fn apply_lambda_with_utf8_out_type<'a>(
+    df: &'a DataFrame,
+    py: Python,
+    lambda: &'a PyAny,
+    init_null_count: usize,
+    first_value: Option<&str>,
+) -> Utf8Chunked {
+    let skip = usize::from(first_value.is_some());
+    if init_null_count == df.height() {
+        ChunkedArray::full_null("apply", df.height())
+    } else {
+        let iter = apply_iter::<&str>(df, py, lambda, init_null_count, skip);
+        iterator_to_utf8(iter, init_null_count, first_value, "apply", df.height())
     }
 }
 
-fn arg_min_numeric<'a, T>(ca: &'a ChunkedArray<T>) -> Option<usize>
-where
-    T: PolarsNumericType,
-    for<'b> &'b [T::Native]: ArgMinMax,
-{
-    match ca.is_sorted_flag() {
-        IsSorted::Ascending => Some(0),
-        IsSorted::Descending => Some(ca.len() - 1),
-        IsSorted::Not => {
-            ca.downcast_iter()
-                .fold((None, None, 0), |acc, arr| {
-                    if arr.len() == 0 {
-                        return acc;
-                    }
-                    let chunk_min_idx: Option<usize>;
-                    let chunk_min_val: Option<T::Native>;
-                    if arr.null_count() > 0 {
-                        // When there are nulls, we should compare Option<T::Native>
-                        chunk_min_val = None; // because None < Some(_)
-                        chunk_min_idx = arr
-                            .into_iter()
-                            .enumerate()
-                            .reduce(|acc, (idx, val)| if acc.1 > val { (idx, val) } else { acc })
-                            .map(|tpl| tpl.0);
-                    } else {
-                        // When no nulls & array not empty => we can use fast argminmax
-                        let min_idx: usize = arr.values().as_slice().argmin();
-                        chunk_min_idx = Some(min_idx);
-                        chunk_min_val = Some(arr.value(min_idx));
-                    }
-
-                    let new_offset: usize = acc.2 + arr.len();
-                    match acc {
-                        (Some(_), Some(_), offset) => {
-                            if chunk_min_val < acc.1 {
-                                match chunk_min_idx {
-                                    Some(idx) => (Some(idx + offset), chunk_min_val, new_offset),
-                                    None => (acc.0, acc.1, new_offset),
-                                }
-                            } else {
-                                (acc.0, acc.1, new_offset)
-                            }
+/// Apply a lambda with list output type
+pub fn apply_lambda_with_list_out_type<'a>(
+    df: &'a DataFrame,
+    py: Python,
+    lambda: &'a PyAny,
+    init_null_count: usize,
+    first_value: Option<&Series>,
+    dt: &DataType,
+) -> PyResult<ListChunked> {
+    let skip = usize::from(first_value.is_some());
+    if init_null_count == df.height() {
+        Ok(ChunkedArray::full_null("apply", df.height()))
+    } else {
+        let mut iters = get_iters_skip(df, init_null_count + skip);
+        let iter = ((init_null_count + skip)..df.height()).map(|_| {
+            let iter = iters.iter_mut().map(|it| Wrap(it.next().unwrap()));
+            let tpl = (PyTuple::new(py, iter),);
+            match lambda.call1(tpl) {
+                Ok(val) => match val.getattr("_s") {
+                    Ok(val) => val.extract::<PySeries>().ok().map(|ps| ps.series),
+                    Err(_) => {
+                        if val.is_none() {
+                            None
+                        } else {
+                            panic!("should return a Series, got a {val:?}")
                         }
-                        (None, None, offset) => match chunk_min_idx {
-                            Some(idx) => (Some(idx + offset), chunk_min_val, new_offset),
-                            None => (None, None, new_offset),
-                        },
-                        _ => unreachable!(),
                     }
-                })
-                .0
-        }
+                },
+                Err(e) => panic!("python function failed {e}"),
+            }
+        });
+        iterator_to_list(dt, iter, init_null_count, first_value, "apply", df.height())
     }
 }
 
-fn arg_max_numeric<'a, T>(ca: &'a ChunkedArray<T>) -> Option<usize>
-where
-    T: PolarsNumericType,
-    for<'b> &'b [T::Native]: ArgMinMax,
-{
-    match ca.is_sorted_flag() {
-        IsSorted::Ascending => Some(ca.len() - 1),
-        IsSorted::Descending => Some(0),
-        IsSorted::Not => {
-            ca.downcast_iter()
-                .fold((None, None, 0), |acc, arr| {
-                    if arr.len() == 0 {
-                        return acc;
-                    }
-                    let chunk_max_idx: Option<usize>;
-                    let chunk_max_val: Option<T::Native>;
-                    if arr.null_count() > 0 {
-                        // When there are nulls, we should compare Option<T::Native>
-                        chunk_max_idx = arr
-                            .into_iter()
-                            .enumerate()
-                            .reduce(|acc, (idx, val)| if acc.1 < val { (idx, val) } else { acc })
-                            .map(|tpl| tpl.0);
-                        chunk_max_val = chunk_max_idx.map(|idx| arr.value(idx));
-                    } else {
-                        // When no nulls & array not empty => we can use fast argminmax
-                        let max_idx: usize = arr.values().as_slice().argmax();
-                        chunk_max_idx = Some(max_idx);
-                        chunk_max_val = Some(arr.value(max_idx));
-                    }
-
-                    let new_offset: usize = acc.2 + arr.len();
-                    match acc {
-                        (Some(_), Some(_), offset) => {
-                            if chunk_max_val > acc.1 {
-                                match chunk_max_idx {
-                                    Some(idx) => (Some(idx + offset), chunk_max_val, new_offset),
-                                    _ => unreachable!(), // because None < Some(_)
-                                }
-                            } else {
-                                (acc.0, acc.1, new_offset)
-                            }
-                        }
-                        (None, None, offset) => match chunk_max_idx {
-                            Some(idx) => (Some(idx + offset), chunk_max_val, new_offset),
-                            None => (None, None, new_offset),
-                        },
-                        _ => unreachable!(),
-                    }
-                })
-                .0
+pub fn apply_lambda_with_rows_output<'a>(
+    df: &'a DataFrame,
+    py: Python,
+    lambda: &'a PyAny,
+    init_null_count: usize,
+    first_value: Row<'a>,
+    inference_size: usize,
+) -> PolarsResult<DataFrame> {
+    let width = first_value.0.len();
+    let null_row = Row::new(vec![AnyValue::Null; width]);
+
+    let mut row_buf = Row::default();
+
+    let skip = 1;
+    let mut iters = get_iters_skip(df, init_null_count + skip);
+    let mut row_iter = ((init_null_count + skip)..df.height()).map(|_| {
+        let iter = iters.iter_mut().map(|it| Wrap(it.next().unwrap()));
+        let tpl = (PyTuple::new(py, iter),);
+
+        let return_val = lambda.call1(tpl).map_err(|e| polars_err!(ComputeError: format!("{e}")))?;
+        if return_val.is_none() {
+            Ok(&null_row)
+        } else {
+            let tuple = return_val.downcast::<PyTuple>().map_err(|_| polars_err!(ComputeError: format!("expected tuple, got {}", return_val.get_type().name().unwrap())))?;
+            row_buf.0.clear();
+            for v in tuple {
+                let v = v.extract::<Wrap<AnyValue>>().unwrap().0;
+                row_buf.0.push(v);
+            }
+            let ptr = &row_buf as *const Row;
+            // Safety:
+            // we know that row constructor of polars dataframe does not keep a reference
+            // to the row. Before we mutate the row buf again, the reference is dropped.
+            // we only cannot prove it to the compiler.
+            // we still to this because it save a Vec allocation in a hot loop.
+            Ok(unsafe { &*ptr })
         }
-    }
-}
+    });
 
-fn arg_min_numeric_slice<T>(vals: &[T], is_sorted: IsSorted) -> Option<usize>
-where
-    for<'a> &'a [T]: ArgMinMax,
-{
-    match is_sorted {
-        IsSorted::Ascending => Some(0),
-        IsSorted::Descending => Some(vals.len() - 1),
-        IsSorted::Not => Some(vals.argmin()), // assumes not empty
-    }
-}
-
-fn arg_max_numeric_slice<T>(vals: &[T], is_sorted: IsSorted) -> Option<usize>
-where
-    for<'a> &'a [T]: ArgMinMax,
-{
-    match is_sorted {
-        IsSorted::Ascending => Some(vals.len() - 1),
-        IsSorted::Descending => Some(0),
-        IsSorted::Not => Some(vals.argmax()), // assumes not empty
+    // first rows for schema inference
+    let mut buf = Vec::with_capacity(inference_size);
+    buf.push(first_value);
+    for v in (&mut row_iter).take(inference_size) {
+        buf.push(v?.clone());
+    }
+
+    let schema = rows_to_schema_first_non_null(&buf, Some(50));
+
+    if init_null_count > 0 {
+        // Safety: we know the iterators size
+        let iter = unsafe {
+            (0..init_null_count)
+                .map(|_| Ok(&null_row))
+                .chain(buf.iter().map(Ok))
+                .chain(row_iter)
+                .trust_my_length(df.height())
+        };
+        DataFrame::try_from_rows_iter_and_schema(iter, &schema)
+    } else {
+        // Safety: we know the iterators size
+        let iter = unsafe {
+            buf.iter()
+                .map(Ok)
+                .chain(row_iter)
+                .trust_my_length(df.height())
+        };
+        DataFrame::try_from_rows_iter_and_schema(iter, &schema)
     }
 }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/cut.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/cut.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/floor_divide.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/floor_divide.rs`

 * *Files 1% similar despite different names*

```diff
@@ -41,15 +41,15 @@
 
         let validity = combine_validities_and(a.validity(), b.validity());
 
         PrimitiveArray::new(a.data_type().clone(), values.into(), validity)
     } else {
         let iter = a
             .into_iter()
-            .zip(b.into_iter())
+            .zip(b)
             .map(|(opt_a, opt_b)| match (opt_a, opt_b) {
                 (Some(&a), Some(&b)) => Some(floor_div_element(a, b)),
                 _ => None,
             });
         PrimitiveArray::from_trusted_len_iter(iter)
     }
 }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/fused.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/fused.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/is_first.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/is_first.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/is_unique.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/is_unique.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/log.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/log.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/rle.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/rle.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/rolling.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/rolling.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/search_sorted.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/search_sorted.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/to_dummies.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/to_dummies.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-ops/src/series/ops/various.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-ops/src/series/ops/various.rs`

 * *Files 23% similar despite different names*

```diff
@@ -1,9 +1,11 @@
 #[cfg(feature = "hash")]
 use polars_core::export::ahash;
+#[cfg(feature = "dtype-struct")]
+use polars_core::prelude::sort::arg_sort_multiple::_get_rows_encoded_ca;
 use polars_core::prelude::*;
 use polars_core::series::IsSorted;
 
 use crate::series::ops::SeriesSealed;
 
 pub trait SeriesMethods: SeriesSealed {
     /// Create a [`DataFrame`] with the unique `values` of this [`Series`] and a column `"counts"`
@@ -38,14 +40,22 @@
             }
         }
     }
 
     fn is_sorted(&self, options: SortOptions) -> PolarsResult<bool> {
         let s = self.as_series();
 
+        // for struct types we row-encode and recurse
+        #[cfg(feature = "dtype-struct")]
+        if matches!(s.dtype(), DataType::Struct(_)) {
+            let encoded =
+                _get_rows_encoded_ca("", &[s.clone()], &[options.descending], options.nulls_last)?;
+            return encoded.into_series().is_sorted(options);
+        }
+
         // fast paths
         if (options.descending
             && options.nulls_last
             && matches!(s.is_sorted_flag(), IsSorted::Descending))
             || (!options.descending
                 && !options.nulls_last
                 && matches!(s.is_sorted_flag(), IsSorted::Ascending))
@@ -66,15 +76,17 @@
             {
                 return Ok(false);
             }
         }
         // Compare adjacent elements with no-copy slices that don't include any nulls
         let offset = !options.nulls_last as i64 * nc as i64;
         let (s1, s2) = (s.slice(offset, slen), s.slice(offset + 1, slen));
-        match options.descending {
-            true => Ok(Series::gt_eq(&s1, &s2)?.all()),
-            false => Ok(Series::lt_eq(&s1, &s2)?.all()),
-        }
+        let cmp_op = if options.descending {
+            Series::gt_eq
+        } else {
+            Series::lt_eq
+        };
+        Ok(cmp_op(&s1, &s2)?.all())
     }
 }
 
 impl SeriesMethods for Series {}
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-algo/Cargo.toml` & `polars_lts_cpu-0.18.9/local_dependencies/polars-algo/Cargo.toml`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-algo/LICENSE` & `polars_lts_cpu-0.18.9/local_dependencies/polars-io/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-algo/src/algo.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-algo/src/algo.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/Cargo.toml` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/Cargo.toml`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/LICENSE` & `polars_lts_cpu-0.18.9/local_dependencies/polars-arrow/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/dot.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/dot.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/dsl/eval.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/dsl/eval.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/dsl/functions.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/dsl/functions.rs`

 * *Files 2% similar despite different names*

```diff
@@ -64,15 +64,21 @@
             lf.opt_state = opt_state;
 
             lf
         }
     };
 
     if convert_supertypes {
-        let LogicalPlan::Union {mut inputs, options} = lf.logical_plan else { unreachable!()} ;
+        let LogicalPlan::Union {
+            mut inputs,
+            options,
+        } = lf.logical_plan
+        else {
+            unreachable!()
+        };
         let mut schema = inputs[0].schema()?.as_ref().as_ref().clone();
 
         let mut changed = false;
         for input in inputs[1..].iter() {
             changed |= schema.to_supertype(input.schema()?.as_ref().as_ref())?;
         }
 
@@ -137,15 +143,15 @@
             }
         });
     }
 
     let lfs_with_all_columns = lfs
         .into_iter()
         // Zip Frames with their Schemas
-        .zip(schemas.into_iter())
+        .zip(schemas)
         .map(|(mut lf, lf_schema)| {
             for (name, dtype) in total_schema.iter() {
                 // If a name from Total Schema is not present - append
                 if lf_schema.get_field(name).is_none() {
                     lf = lf.with_column(NULL.lit().cast(dtype.clone()).alias(name))
                 }
             }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/dsl/list.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/dsl/list.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/dsl/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/dsl/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/frame/anonymous_scan.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/frame/anonymous_scan.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/frame/csv.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/frame/csv.rs`

 * *Files 1% similar despite different names*

```diff
@@ -206,17 +206,17 @@
         F: Fn(Schema) -> PolarsResult<Schema>,
     {
         let mut file = if let Some(mut paths) = self.glob()? {
             let path = match paths.next() {
                 Some(globresult) => globresult?,
                 None => polars_bail!(ComputeError: "globbing pattern did not match any files"),
             };
-            std::fs::File::open(&path)
+            polars_utils::open_file(&path)
         } else {
-            std::fs::File::open(&self.path)
+            polars_utils::open_file(&self.path)
         }?;
         let reader_bytes = get_reader_bytes(&mut file).expect("could not mmap file");
         let mut skip_rows = self.skip_rows;
 
         let (schema, _, _) = infer_file_schema(
             &reader_bytes,
             self.delimiter,
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/frame/file_list_reader.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/frame/file_list_reader.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/frame/ipc.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/frame/ipc.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/frame/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/frame/mod.rs`

 * *Files 2% similar despite different names*

```diff
@@ -128,15 +128,17 @@
             predicate_pushdown: false,
             type_coercion: true,
             simplify_expr: false,
             slice_pushdown: false,
             // will be toggled by a scan operation such as csv scan or parquet scan
             file_caching: false,
             #[cfg(feature = "cse")]
-            common_subplan_elimination: false,
+            comm_subplan_elim: false,
+            #[cfg(feature = "cse")]
+            comm_subexpr_elim: false,
             streaming: false,
         })
     }
 
     /// Toggle projection pushdown optimization.
     pub fn with_projection_pushdown(mut self, toggle: bool) -> Self {
         self.opt_state.projection_pushdown = toggle;
@@ -159,16 +161,23 @@
     pub fn with_simplify_expr(mut self, toggle: bool) -> Self {
         self.opt_state.simplify_expr = toggle;
         self
     }
 
     /// Toggle common subplan elimination optimization on or off
     #[cfg(feature = "cse")]
-    pub fn with_common_subplan_elimination(mut self, toggle: bool) -> Self {
-        self.opt_state.common_subplan_elimination = toggle;
+    pub fn with_comm_subplan_elim(mut self, toggle: bool) -> Self {
+        self.opt_state.comm_subplan_elim = toggle;
+        self
+    }
+
+    /// Toggle common subexpression elimination optimization on or off
+    #[cfg(feature = "cse")]
+    pub fn with_comm_subexpr_elim(mut self, toggle: bool) -> Self {
+        self.opt_state.comm_subexpr_elim = toggle;
         self
     }
 
     /// Toggle slice pushdown optimization
     pub fn with_slice_pushdown(mut self, toggle: bool) -> Self {
         self.opt_state.slice_pushdown = toggle;
         self
@@ -361,15 +370,15 @@
         S: AsRef<str>,
     {
         let iter = existing.into_iter();
         let cap = iter.size_hint().0;
         let mut existing_vec: Vec<SmartString> = Vec::with_capacity(cap);
         let mut new_vec: Vec<SmartString> = Vec::with_capacity(cap);
 
-        for (existing, new) in iter.zip(new.into_iter()) {
+        for (existing, new) in iter.zip(new) {
             let existing = existing.as_ref();
             let new = new.as_ref();
 
             if new != existing {
                 existing_vec.push(existing.into());
                 new_vec.push(new.into());
             }
@@ -471,28 +480,42 @@
         self,
         lp_arena: &mut Arena<ALogicalPlan>,
         expr_arena: &mut Arena<AExpr>,
     ) -> PolarsResult<Node> {
         self.optimize_with_scratch(lp_arena, expr_arena, &mut vec![], false)
     }
 
+    pub fn to_alp_optimized(self) -> PolarsResult<(Node, Arena<ALogicalPlan>, Arena<AExpr>)> {
+        let mut lp_arena = Arena::with_capacity(16);
+        let mut expr_arena = Arena::with_capacity(16);
+        let node =
+            self.optimize_with_scratch(&mut lp_arena, &mut expr_arena, &mut vec![], false)?;
+        Ok((node, lp_arena, expr_arena))
+    }
+
+    pub fn to_alp(self) -> PolarsResult<(Node, Arena<ALogicalPlan>, Arena<AExpr>)> {
+        self.logical_plan.to_alp()
+    }
+
     pub(crate) fn optimize_with_scratch(
         self,
         lp_arena: &mut Arena<ALogicalPlan>,
         expr_arena: &mut Arena<AExpr>,
         scratch: &mut Vec<Node>,
         _fmt: bool,
     ) -> PolarsResult<Node> {
         #[allow(unused_mut)]
         let mut opt_state = self.opt_state;
         let streaming = self.opt_state.streaming;
         #[cfg(feature = "cse")]
-        if streaming && self.opt_state.common_subplan_elimination {
-            polars_warn!("Cannot combine 'streaming' with 'common_subplan_elimination'. CSE will be turned off.");
-            opt_state.common_subplan_elimination = false;
+        if streaming && self.opt_state.comm_subplan_elim {
+            polars_warn!(
+                "Cannot combine 'streaming' with 'comm_subplan_elim'. CSE will be turned off."
+            );
+            opt_state.comm_subplan_elim = false;
         }
         let lp_top = optimize(self.logical_plan, opt_state, lp_arena, expr_arena, scratch)?;
 
         if streaming {
             #[cfg(feature = "streaming")]
             {
                 insert_streaming_nodes(lp_top, lp_arena, expr_arena, scratch, _fmt, true)?;
@@ -1381,15 +1404,15 @@
         let lp = LogicalPlan::Aggregate {
             input: Box::new(self.logical_plan),
             keys: Arc::new(self.keys),
             aggs: vec![],
             schema,
             apply: Some(Arc::new(f)),
             maintain_order: self.maintain_order,
-            options,
+            options: Arc::new(options),
         };
         LazyFrame::from_logical_plan(lp, self.opt_state)
     }
 }
 
 #[must_use]
 pub struct JoinBuilder {
@@ -1496,13 +1519,14 @@
                 self.left_on,
                 self.right_on,
                 JoinOptions {
                     allow_parallel: self.allow_parallel,
                     force_parallel: self.force_parallel,
                     args,
                     ..Default::default()
-                },
+                }
+                .into(),
             )
             .build();
         LazyFrame::from_logical_plan(lp, opt_state)
     }
 }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/frame/ndjson.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/frame/ndjson.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/frame/parquet.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/frame/parquet.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/frame/pivot.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/frame/pivot.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/lib.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/lib.rs`

 * *Files 2% similar despite different names*

```diff
@@ -97,16 +97,16 @@
 //!     "temp" => [20, 10, 7, 9, 1],
 //!     "rain" => [0.2, 0.1, 0.3, 0.1, 0.01]
 //!     )?;
 //!
 //!     df.lazy()
 //!     .groupby([col("date")])
 //!     .agg([
-//!         col("rain").min(),
-//!         col("rain").sum(),
+//!         col("rain").min().alias("min_rain"),
+//!         col("rain").sum().alias("sum_rain"),
 //!         col("rain").quantile(lit(0.5), QuantileInterpolOptions::Nearest).alias("median_rain"),
 //!     ])
 //!     .sort("date", Default::default())
 //!     .collect()
 //!
 //! }
 //! ```
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/cache.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/cache.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/executor.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/executor.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/ext_context.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/ext_context.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/filter.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/filter.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/groupby.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/groupby.rs`

 * *Files 23% similar despite different names*

```diff
@@ -1,23 +1,43 @@
 use rayon::prelude::*;
 
 use super::*;
 
+pub(super) fn evaluate_aggs(
+    df: &DataFrame,
+    aggs: &[Arc<dyn PhysicalExpr>],
+    groups: &GroupsProxy,
+    state: &ExecutionState,
+) -> PolarsResult<Vec<Series>> {
+    POOL.install(|| {
+        aggs.par_iter()
+            .map(|expr| {
+                let mut agg = expr.evaluate_on_groups(df, groups, state)?.finalize();
+                polars_ensure!(agg.len() == groups.len(), agg_len = agg.len(), groups.len());
+
+                rename_cse_tmp_series(&mut agg);
+                Ok(agg)
+            })
+            .collect::<PolarsResult<Vec<_>>>()
+    })
+}
+
 /// Take an input Executor and a multiple expressions
 pub struct GroupByExec {
     input: Box<dyn Executor>,
     keys: Vec<Arc<dyn PhysicalExpr>>,
     aggs: Vec<Arc<dyn PhysicalExpr>>,
     apply: Option<Arc<dyn DataFrameUdf>>,
     maintain_order: bool,
     input_schema: SchemaRef,
     slice: Option<(i64, usize)>,
 }
 
 impl GroupByExec {
+    #[allow(clippy::too_many_arguments)]
     pub(crate) fn new(
         input: Box<dyn Executor>,
         keys: Vec<Arc<dyn PhysicalExpr>>,
         aggs: Vec<Arc<dyn PhysicalExpr>>,
         apply: Option<Arc<dyn DataFrameUdf>>,
         maintain_order: bool,
         input_schema: SchemaRef,
@@ -31,20 +51,21 @@
             maintain_order,
             input_schema,
             slice,
         }
     }
 }
 
+#[allow(clippy::too_many_arguments)]
 pub(super) fn groupby_helper(
     mut df: DataFrame,
     keys: Vec<Series>,
     aggs: &[Arc<dyn PhysicalExpr>],
     apply: Option<Arc<dyn DataFrameUdf>>,
-    state: &mut ExecutionState,
+    state: &ExecutionState,
     maintain_order: bool,
     slice: Option<(i64, usize)>,
 ) -> PolarsResult<DataFrame> {
     df.as_single_chunk_par();
     let gb = df.groupby_with_series(keys, true, maintain_order)?;
 
     if let Some(f) = apply {
@@ -58,43 +79,29 @@
     let mut sliced_groups = None;
 
     if let Some((offset, len)) = slice {
         sliced_groups = Some(groups.slice(offset, len));
         groups = sliced_groups.as_deref().unwrap();
     }
 
-    state.expr_cache = Some(Default::default());
     let (mut columns, agg_columns) = POOL.install(|| {
         let get_columns = || gb.keys_sliced(slice);
 
-        let get_agg = || {
-            aggs.par_iter()
-                .map(|expr| {
-                    let agg = expr.evaluate_on_groups(&df, groups, state)?.finalize();
-                    polars_ensure!(agg.len() == groups.len(), agg_len = agg.len(), groups.len());
-                    Ok(agg)
-                })
-                .collect::<PolarsResult<Vec<_>>>()
-        };
+        let get_agg = || evaluate_aggs(&df, aggs, groups, state);
 
         rayon::join(get_columns, get_agg)
     });
     let agg_columns = agg_columns?;
-    state.expr_cache = None;
 
     columns.extend_from_slice(&agg_columns);
     DataFrame::new(columns)
 }
 
 impl GroupByExec {
-    fn execute_impl(
-        &mut self,
-        state: &mut ExecutionState,
-        df: DataFrame,
-    ) -> PolarsResult<DataFrame> {
+    fn execute_impl(&mut self, state: &ExecutionState, df: DataFrame) -> PolarsResult<DataFrame> {
         let keys = self
             .keys
             .iter()
             .map(|e| e.evaluate(&df, state))
             .collect::<PolarsResult<_>>()?;
         groupby_helper(
             df,
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_dynamic.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_dynamic.rs`

 * *Files 7% similar despite different names*

```diff
@@ -19,19 +19,18 @@
     pub(crate) apply: Option<Arc<dyn DataFrameUdf>>,
 }
 
 impl GroupByDynamicExec {
     #[cfg(feature = "dynamic_groupby")]
     fn execute_impl(
         &mut self,
-        state: &mut ExecutionState,
+        state: &ExecutionState,
         mut df: DataFrame,
     ) -> PolarsResult<DataFrame> {
         df.as_single_chunk_par();
-
         let keys = self
             .keys
             .iter()
             .map(|e| e.evaluate(&df, state))
             .collect::<PolarsResult<Vec<_>>>()?;
 
         let (mut time_key, mut keys, groups) = df.groupby_dynamic(keys, &self.options)?;
@@ -60,26 +59,15 @@
             // todo! optimize this, we can prevent an agg_first aggregation upstream
             // the ordering has changed due to the groupby
             for key in keys.iter_mut() {
                 *key = key.slice(offset, len)
             }
         }
 
-        state.expr_cache = Some(Default::default());
-        let agg_columns = POOL.install(|| {
-            self.aggs
-                .par_iter()
-                .map(|expr| {
-                    let agg = expr.evaluate_on_groups(&df, groups, state)?.finalize();
-                    polars_ensure!(agg.len() == groups.len(), agg_len = agg.len(), groups.len());
-                    Ok(agg)
-                })
-                .collect::<PolarsResult<Vec<_>>>()
-        })?;
-        state.expr_cache = None;
+        let agg_columns = evaluate_aggs(&df, &self.aggs, groups, state)?;
 
         let mut columns = Vec::with_capacity(agg_columns.len() + 1 + keys.len());
         columns.extend_from_slice(&keys);
         columns.push(time_key);
         columns.extend_from_slice(&agg_columns);
 
         DataFrame::new(columns)
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_partitioned.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_partitioned.rs`

 * *Files 1% similar despite different names*

```diff
@@ -229,15 +229,16 @@
         state: &mut ExecutionState,
         original_df: DataFrame,
     ) -> Option<PolarsResult<DataFrame>> {
         #[allow(clippy::needless_update)]
         let groupby_options = GroupbyOptions {
             slice: self.slice,
             ..Default::default()
-        };
+        }
+        .into();
         let lp = LogicalPlan::Aggregate {
             input: Box::new(original_df.lazy().logical_plan),
             keys: Arc::new(std::mem::take(&mut self.keys)),
             aggs: std::mem::take(&mut self.aggs),
             schema: self.output_schema.clone(),
             apply: None,
             maintain_order: false,
@@ -341,15 +342,20 @@
             let out: PolarsResult<Vec<_>> = self
                 .phys_aggs
                 .par_iter()
                 // we slice the keys off and finalize every aggregation
                 .zip(&df.get_columns()[self.phys_keys.len()..])
                 .map(|(expr, partitioned_s)| {
                     let agg_expr = expr.as_partitioned_aggregator().unwrap();
-                    agg_expr.finalize(partitioned_s.clone(), groups, state)
+                    agg_expr
+                        .finalize(partitioned_s.clone(), groups, state)
+                        .map(|mut s| {
+                            rename_cse_tmp_series(&mut s);
+                            s
+                        })
                 })
                 .collect();
 
             out
         };
         let (mut columns, agg_columns): (Vec<_>, _) =
             POOL.install(|| rayon::join(get_columns, get_agg));
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_rolling.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/groupby_rolling.rs`

 * *Files 8% similar despite different names*

```diff
@@ -17,15 +17,15 @@
     pub(crate) apply: Option<Arc<dyn DataFrameUdf>>,
 }
 
 impl GroupByRollingExec {
     #[cfg(feature = "dynamic_groupby")]
     fn execute_impl(
         &mut self,
-        state: &mut ExecutionState,
+        state: &ExecutionState,
         mut df: DataFrame,
     ) -> PolarsResult<DataFrame> {
         df.as_single_chunk_par();
 
         let keys = self
             .keys
             .iter()
@@ -76,26 +76,15 @@
                             *key = key.take_iter_unchecked(iter);
                         }
                     }
                 }
             }
         };
 
-        state.expr_cache = Some(Default::default());
-        let agg_columns = POOL.install(|| {
-            self.aggs
-                .par_iter()
-                .map(|expr| {
-                    let agg = expr.evaluate_on_groups(&df, groups, state)?.aggregated();
-                    polars_ensure!(agg.len() == groups.len(), agg_len = agg.len(), groups.len());
-                    Ok(agg)
-                })
-                .collect::<PolarsResult<Vec<_>>>()
-        })?;
-        state.expr_cache = None;
+        let agg_columns = evaluate_aggs(&df, &self.aggs, groups, state)?;
 
         let mut columns = Vec::with_capacity(agg_columns.len() + 1 + keys.len());
         columns.extend_from_slice(&keys);
         columns.push(time_key);
         columns.extend_from_slice(&agg_columns);
 
         DataFrame::new(columns)
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/join.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/join.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/mod.rs`

 * *Files 8% similar despite different names*

```diff
@@ -133,39 +133,67 @@
     }
 
     selected_columns.sort_unstable_by_key(|tpl| tpl.0);
     let selected_columns = selected_columns.into_iter().map(|tpl| tpl.1).collect();
     Ok(selected_columns)
 }
 
-pub(crate) fn evaluate_physical_expressions(
+fn run_exprs_par(
     df: &DataFrame,
     exprs: &[Arc<dyn PhysicalExpr>],
-    state: &mut ExecutionState,
+    state: &ExecutionState,
+) -> PolarsResult<Vec<Series>> {
+    POOL.install(|| {
+        exprs
+            .par_iter()
+            .map(|expr| expr.evaluate(df, state))
+            .collect()
+    })
+}
+
+pub(super) fn evaluate_physical_expressions(
+    df: &mut DataFrame,
+    cse_exprs: &[Arc<dyn PhysicalExpr>],
+    exprs: &[Arc<dyn PhysicalExpr>],
+    state: &ExecutionState,
     has_windows: bool,
-) -> PolarsResult<DataFrame> {
-    state.expr_cache = Some(Default::default());
-    let zero_length = df.height() == 0;
-    let selected_columns = if has_windows {
+) -> PolarsResult<Vec<Series>> {
+    let selected_columns = if !cse_exprs.is_empty() {
+        let tmp_cols = run_exprs_par(df, cse_exprs, state)?;
+        let width = df.width();
+
+        // put the cse expressions at the end
+        unsafe {
+            df.hstack_mut_unchecked(&tmp_cols);
+        }
+        let mut result = run_exprs_par(df, exprs, state)?;
+        // restore original df
+        unsafe {
+            df.get_columns_mut().truncate(width);
+        }
+
+        // the replace CSE has a temporary name
+        // we don't want this name in the result
+        for s in result.iter_mut() {
+            rename_cse_tmp_series(s);
+        }
+
+        result
+    } else if has_windows {
         execute_projection_cached_window_fns(df, exprs, state)?
     } else {
-        POOL.install(|| {
-            exprs
-                .par_iter()
-                .map(|expr| expr.evaluate(df, state))
-                .collect::<PolarsResult<_>>()
-        })?
+        run_exprs_par(df, exprs, state)?
     };
+
     state.clear_window_expr_cache();
-    state.expr_cache = None;
 
-    check_expand_literals(selected_columns, zero_length)
+    Ok(selected_columns)
 }
 
-fn check_expand_literals(
+pub(super) fn check_expand_literals(
     mut selected_columns: Vec<Series>,
     zero_length: bool,
 ) -> PolarsResult<DataFrame> {
     let first_len = selected_columns[0].len();
     let mut df_height = 0;
     let mut all_equal_len = true;
     {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/projection.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/stack.rs`

 * *Files 16% similar despite different names*

```diff
@@ -1,62 +1,60 @@
 use super::*;
 
-/// Take an input Executor (creates the input DataFrame)
-/// and a multiple PhysicalExpressions (create the output Series)
-pub struct ProjectionExec {
+pub struct StackExec {
     pub(crate) input: Box<dyn Executor>,
-    pub(crate) expr: Vec<Arc<dyn PhysicalExpr>>,
     pub(crate) has_windows: bool,
+    pub(crate) cse_exprs: Vec<Arc<dyn PhysicalExpr>>,
+    pub(crate) exprs: Vec<Arc<dyn PhysicalExpr>>,
     pub(crate) input_schema: SchemaRef,
-    #[cfg(test)]
-    pub(crate) schema: SchemaRef,
 }
 
-impl ProjectionExec {
+impl StackExec {
     fn execute_impl(
         &mut self,
-        state: &mut ExecutionState,
-        df: DataFrame,
+        state: &ExecutionState,
+        mut df: DataFrame,
     ) -> PolarsResult<DataFrame> {
-        #[allow(clippy::let_and_return)]
-        let df = evaluate_physical_expressions(&df, &self.expr, state, self.has_windows);
+        let res = evaluate_physical_expressions(
+            &mut df,
+            &self.cse_exprs,
+            &self.exprs,
+            state,
+            self.has_windows,
+        )?;
+        state.clear_window_expr_cache();
 
-        // this only runs during testing and check if the runtime type matches the predicted schema
-        #[cfg(test)]
-        #[allow(unused_must_use)]
-        {
-            // TODO: also check the types.
-            if let Ok(df) = df.as_ref() {
-                for (l, r) in df.iter().zip(self.schema.iter_names()) {
-                    assert_eq!(l.name(), r);
-                }
-            }
-        }
+        let schema = &*self.input_schema;
+        df._add_columns(res, schema)?;
 
-        df
+        Ok(df)
     }
 }
 
-impl Executor for ProjectionExec {
+impl Executor for StackExec {
     fn execute(&mut self, state: &mut ExecutionState) -> PolarsResult<DataFrame> {
         #[cfg(debug_assertions)]
         {
             if state.verbose() {
-                println!("run ProjectionExec")
+                if self.cse_exprs.is_empty() {
+                    println!("run StackExec");
+                } else {
+                    println!("run StackExec with {} CSE", self.cse_exprs.len());
+                };
             }
         }
         let df = self.input.execute(state)?;
 
         let profile_name = if state.has_node_timer() {
             let by = self
-                .expr
+                .exprs
                 .iter()
                 .map(|s| Ok(s.to_field(&self.input_schema)?.name))
                 .collect::<PolarsResult<Vec<_>>>()?;
-            let name = comma_delimited("projection".to_string(), &by);
+            let name = comma_delimited("with_column".to_string(), &by);
             Cow::Owned(name)
         } else {
             Cow::Borrowed("")
         };
 
         if state.has_node_timer() {
             let new_state = state.clone();
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/python_scan.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/python_scan.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/scan/csv.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/scan/csv.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/scan/ipc.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/scan/ipc.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/scan/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/scan/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/scan/ndjson.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/scan/ndjson.rs`

 * *Files 22% similar despite different names*

```diff
@@ -16,15 +16,15 @@
             .low_memory(self.low_memory)
             .with_n_rows(scan_opts.n_rows)
             .with_chunk_size(self.batch_size)
             .finish()
     }
 
     fn schema(&self, infer_schema_length: Option<usize>) -> PolarsResult<Schema> {
-        let f = std::fs::File::open(&self.path)?;
+        let f = polars_utils::open_file(&self.path)?;
         let mut reader = std::io::BufReader::new(f);
 
         let data_type =
             polars_json::ndjson::infer(&mut reader, infer_schema_length).map_err(to_compute_err)?;
         let schema = Schema::from_iter(StructArray::get_fields(&data_type));
 
         Ok(schema)
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/scan/parquet.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/scan/parquet.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/slice.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/slice.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/sort.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/sort.rs`

 * *Files 1% similar despite different names*

```diff
@@ -5,15 +5,15 @@
     pub(crate) by_column: Vec<Arc<dyn PhysicalExpr>>,
     pub(crate) args: SortArguments,
 }
 
 impl SortExec {
     fn execute_impl(
         &mut self,
-        state: &mut ExecutionState,
+        state: &ExecutionState,
         mut df: DataFrame,
     ) -> PolarsResult<DataFrame> {
         df.as_single_chunk_par();
 
         let by_columns = self
             .by_column
             .iter()
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/udf.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/udf.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/union.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/union.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/executors/unique.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/executors/unique.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/exotic.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/exotic.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/aggregation.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/aggregation.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/alias.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/alias.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/apply.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/apply.rs`

 * *Files 2% similar despite different names*

```diff
@@ -439,14 +439,19 @@
     fn should_read_impl(&self, stats: &BatchStats) -> PolarsResult<bool> {
         let (function, input) = match &self.expr {
             Expr::Function {
                 function, input, ..
             } => (function, input),
             _ => return Ok(true),
         };
+        // ensure the input of the function is only a `col(..)`
+        // if it does any arithmetic the code below is flawed
+        if !matches!(input[0], Expr::Column(_)) {
+            return Ok(true);
+        }
 
         match function {
             FunctionExpr::Boolean(BooleanFunction::IsNull) => {
                 let root = expr_to_leaf_column_name(&self.expr)?;
 
                 match stats.get_stats(&root).ok() {
                     Some(st) => match st.null_count() {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/binary.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/binary.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/cast.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/cast.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/column.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/column.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/count.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/count.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/filter.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/filter.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/group_iter.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/group_iter.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/literal.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/literal.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/mod.rs`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,11 @@
 mod aggregation;
 mod alias;
 mod apply;
 mod binary;
-mod cache;
 mod cast;
 mod column;
 mod count;
 mod filter;
 mod group_iter;
 mod literal;
 mod slice;
@@ -19,15 +18,14 @@
 use std::borrow::Cow;
 use std::fmt::{Display, Formatter};
 
 pub(crate) use aggregation::*;
 pub(crate) use alias::*;
 pub(crate) use apply::*;
 pub(crate) use binary::*;
-pub(crate) use cache::*;
 pub(crate) use cast::*;
 pub(crate) use column::*;
 pub(crate) use count::*;
 pub(crate) use filter::*;
 pub(crate) use literal::*;
 use polars_arrow::utils::CustomIterTools;
 use polars_core::frame::groupby::GroupsProxy;
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/slice.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/slice.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/sort.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/sort.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/sortby.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/sortby.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/take.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/take.rs`

 * *Files 2% similar despite different names*

```diff
@@ -54,129 +54,121 @@
         df: &DataFrame,
         groups: &'a GroupsProxy,
         state: &ExecutionState,
     ) -> PolarsResult<AggregationContext<'a>> {
         let mut ac = self.phys_expr.evaluate_on_groups(df, groups, state)?;
         let mut idx = self.idx.evaluate_on_groups(df, groups, state)?;
 
-        let idx =
-            match idx.state {
-                AggState::AggregatedFlat(s) => {
-                    let idx = s.cast(&IDX_DTYPE)?;
-                    let idx = idx.idx().unwrap();
-
-                    // The indexes are AggregatedFlat, meaning they are a single values pointing into
-                    // a group.
-                    // If we zip this with the first of each group -> `idx + firs` then we can
-                    // simply use a take operation on the whole array instead of per group.
-
-                    // The groups maybe scattered all over the place, so we sort by group
-                    ac.sort_by_groups();
-
-                    // A previous aggregation may have updated the groups
-                    let groups = ac.groups();
-
-                    // Determine the take indices
-                    let idx: IdxCa =
-                        match groups.as_ref() {
-                            GroupsProxy::Idx(groups) => {
-                                if groups.all().iter().zip(idx.into_iter()).any(
-                                    |(g, idx)| match idx {
-                                        None => true,
-                                        Some(idx) => idx >= g.len() as IdxSize,
-                                    },
-                                ) {
-                                    self.oob_err()?;
-                                }
+        let idx = match idx.state {
+            AggState::AggregatedFlat(s) => {
+                let idx = s.cast(&IDX_DTYPE)?;
+                let idx = idx.idx().unwrap();
+
+                // The indexes are AggregatedFlat, meaning they are a single values pointing into
+                // a group.
+                // If we zip this with the first of each group -> `idx + firs` then we can
+                // simply use a take operation on the whole array instead of per group.
+
+                // The groups maybe scattered all over the place, so we sort by group
+                ac.sort_by_groups();
+
+                // A previous aggregation may have updated the groups
+                let groups = ac.groups();
+
+                // Determine the take indices
+                let idx: IdxCa = match groups.as_ref() {
+                    GroupsProxy::Idx(groups) => {
+                        if groups.all().iter().zip(idx).any(|(g, idx)| match idx {
+                            None => true,
+                            Some(idx) => idx >= g.len() as IdxSize,
+                        }) {
+                            self.oob_err()?;
+                        }
 
-                                idx.into_iter()
-                                    .zip(groups.first().iter())
-                                    .map(|(idx, first)| idx.map(|idx| idx + first))
-                                    .collect_trusted()
-                            }
-                            GroupsProxy::Slice { groups, .. } => {
-                                if groups
-                                    .iter()
-                                    .zip(idx.into_iter())
-                                    .any(|(g, idx)| match idx {
-                                        None => true,
-                                        Some(idx) => idx >= g[1],
-                                    })
-                                {
-                                    self.oob_err()?;
-                                }
+                        idx.into_iter()
+                            .zip(groups.first().iter())
+                            .map(|(idx, first)| idx.map(|idx| idx + first))
+                            .collect_trusted()
+                    }
+                    GroupsProxy::Slice { groups, .. } => {
+                        if groups.iter().zip(idx).any(|(g, idx)| match idx {
+                            None => true,
+                            Some(idx) => idx >= g[1],
+                        }) {
+                            self.oob_err()?;
+                        }
 
-                                idx.into_iter()
-                                    .zip(groups.iter())
-                                    .map(|(idx, g)| idx.map(|idx| idx + g[0]))
-                                    .collect_trusted()
+                        idx.into_iter()
+                            .zip(groups.iter())
+                            .map(|(idx, g)| idx.map(|idx| idx + g[0]))
+                            .collect_trusted()
+                    }
+                };
+                let taken = ac.flat_naive().take(&idx)?;
+                ac.with_series(taken, true, Some(&self.expr))?;
+                return Ok(ac);
+            }
+            AggState::AggregatedList(s) => s.list().unwrap().clone(),
+            // Maybe a literal as well, this needs a different path
+            AggState::NotAggregated(_) => {
+                let s = idx.aggregated();
+                s.list().unwrap().clone()
+            }
+            AggState::Literal(s) => {
+                let idx = s.cast(&IDX_DTYPE)?;
+                let idx = idx.idx().unwrap();
+
+                return if idx.len() == 1 {
+                    match idx.get(0) {
+                        None => polars_bail!(ComputeError: "cannot take by a null"),
+                        Some(idx) => {
+                            if idx != 0 {
+                                // We must make sure that the column we take from is sorted by
+                                // groups otherwise we might point into the wrong group
+                                ac.sort_by_groups()
                             }
-                        };
-                    let taken = ac.flat_naive().take(&idx)?;
-                    ac.with_series(taken, true, Some(&self.expr))?;
-                    return Ok(ac);
-                }
-                AggState::AggregatedList(s) => s.list().unwrap().clone(),
-                // Maybe a literal as well, this needs a different path
-                AggState::NotAggregated(_) => {
-                    let s = idx.aggregated();
-                    s.list().unwrap().clone()
-                }
-                AggState::Literal(s) => {
-                    let idx = s.cast(&IDX_DTYPE)?;
-                    let idx = idx.idx().unwrap();
-
-                    return if idx.len() == 1 {
-                        match idx.get(0) {
-                            None => polars_bail!(ComputeError: "cannot take by a null"),
-                            Some(idx) => {
-                                if idx != 0 {
-                                    // We must make sure that the column we take from is sorted by
-                                    // groups otherwise we might point into the wrong group
-                                    ac.sort_by_groups()
-                                }
-                                // Make sure that we look at the updated groups.
-                                let groups = ac.groups();
+                            // Make sure that we look at the updated groups.
+                            let groups = ac.groups();
 
-                                // we offset the groups first by idx;
-                                let idx: NoNull<IdxCa> = match groups.as_ref() {
-                                    GroupsProxy::Idx(groups) => {
-                                        if groups.all().iter().any(|g| idx >= g.len() as IdxSize) {
-                                            self.oob_err()?;
-                                        }
-
-                                        groups.first().iter().map(|f| *f + idx).collect_trusted()
+                            // we offset the groups first by idx;
+                            let idx: NoNull<IdxCa> = match groups.as_ref() {
+                                GroupsProxy::Idx(groups) => {
+                                    if groups.all().iter().any(|g| idx >= g.len() as IdxSize) {
+                                        self.oob_err()?;
                                     }
-                                    GroupsProxy::Slice { groups, .. } => {
-                                        if groups.iter().any(|g| idx >= g[1]) {
-                                            self.oob_err()?;
-                                        }
 
-                                        groups.iter().map(|g| g[0] + idx).collect_trusted()
+                                    groups.first().iter().map(|f| *f + idx).collect_trusted()
+                                }
+                                GroupsProxy::Slice { groups, .. } => {
+                                    if groups.iter().any(|g| idx >= g[1]) {
+                                        self.oob_err()?;
                                     }
-                                };
-                                let taken = ac.flat_naive().take(&idx.into_inner())?;
-                                ac.with_series(taken, true, Some(&self.expr))?;
-                                ac.with_update_groups(UpdateGroups::WithGroupsLen);
-                                Ok(ac)
-                            }
+
+                                    groups.iter().map(|g| g[0] + idx).collect_trusted()
+                                }
+                            };
+                            let taken = ac.flat_naive().take(&idx.into_inner())?;
+                            ac.with_series(taken, true, Some(&self.expr))?;
+                            ac.with_update_groups(UpdateGroups::WithGroupsLen);
+                            Ok(ac)
                         }
-                    } else {
-                        let out = ac
-                            .aggregated()
-                            .list()
-                            .unwrap()
-                            .try_apply_amortized(|s| s.as_ref().take(idx))?;
-
-                        ac.with_series(out.into_series(), true, Some(&self.expr))?;
-                        ac.with_update_groups(UpdateGroups::WithGroupsLen);
-                        Ok(ac)
-                    };
-                }
-            };
+                    }
+                } else {
+                    let out = ac
+                        .aggregated()
+                        .list()
+                        .unwrap()
+                        .try_apply_amortized(|s| s.as_ref().take(idx))?;
+
+                    ac.with_series(out.into_series(), true, Some(&self.expr))?;
+                    ac.with_update_groups(UpdateGroups::WithGroupsLen);
+                    Ok(ac)
+                };
+            }
+        };
 
         let s = idx.cast(&DataType::List(Box::new(IDX_DTYPE)))?;
         let idx = s.list().unwrap();
 
         let mut taken = ac
             .aggregated()
             .list()
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/ternary.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/ternary.rs`

 * *Files 1% similar despite different names*

```diff
@@ -195,15 +195,15 @@
 
                 if ac_falsy.is_literal() && self.falsy.as_expression().map(has_null) == Some(true) {
                     let s = ac_truthy.aggregated();
                     let ca = s.list().unwrap();
                     check_length(ca, mask)?;
                     let mut out: ListChunked = ca
                         .into_iter()
-                        .zip(mask.into_iter())
+                        .zip(mask)
                         .map(|(truthy, take)| match (truthy, take) {
                             (Some(v), Some(true)) => Some(v),
                             (Some(_), Some(false)) => None,
                             _ => None,
                         })
                         .collect_trusted();
                     out.rename(ac_truthy.series().name());
@@ -213,15 +213,15 @@
                     && self.truthy.as_expression().map(has_null) == Some(true)
                 {
                     let s = ac_falsy.aggregated();
                     let ca = s.list().unwrap();
                     check_length(ca, mask)?;
                     let mut out: ListChunked = ca
                         .into_iter()
-                        .zip(mask.into_iter())
+                        .zip(mask)
                         .map(|(falsy, take)| match (falsy, take) {
                             (Some(_), Some(true)) => None,
                             (Some(v), Some(false)) => Some(v),
                             _ => None,
                         })
                         .collect_trusted();
                     out.rename(ac_truthy.series().name());
@@ -235,15 +235,15 @@
                 else if ac_truthy.is_literal() {
                     let literal = ac_truthy.series();
                     let s = ac_falsy.aggregated();
                     let ca = s.list().unwrap();
                     check_length(ca, mask)?;
                     let mut out: ListChunked = ca
                         .into_iter()
-                        .zip(mask.into_iter())
+                        .zip(mask)
                         .map(|(falsy, take)| match (falsy, take) {
                             (Some(_), Some(true)) => Some(literal.clone()),
                             (Some(v), Some(false)) => Some(v),
                             _ => None,
                         })
                         .collect_trusted();
                     out.rename(ac_truthy.series().name());
@@ -252,15 +252,15 @@
                 } else {
                     let literal = ac_falsy.series();
                     let s = ac_truthy.aggregated();
                     let ca = s.list().unwrap();
                     check_length(ca, mask)?;
                     let mut out: ListChunked = ca
                         .into_iter()
-                        .zip(mask.into_iter())
+                        .zip(mask)
                         .map(|(truthy, take)| match (truthy, take) {
                             (Some(v), Some(true)) => Some(v),
                             (Some(_), Some(false)) => Some(literal.clone()),
                             _ => None,
                         })
                         .collect_trusted();
                     out.rename(ac_truthy.series().name());
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/expressions/window.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/expressions/window.rs`

 * *Files 0% similar despite different names*

```diff
@@ -700,15 +700,15 @@
         GroupsProxy::Slice { groups, .. } => {
             for &[first, len] in groups {
                 idx_mapping.extend((&mut iter).take(len as usize).zip(first..first + len));
             }
         }
     }
     let mut values = Vec::with_capacity(len);
-    let ptr = values.as_mut_ptr() as *mut T::Native;
+    let ptr: *mut T::Native = values.as_mut_ptr();
     // safety:
     // we will write from different threads but we will never alias.
     let sync_ptr_values = unsafe { SyncPtr::new(ptr) };
 
     if ca.null_count() == 0 {
         match groups {
             GroupsProxy::Idx(groups) => {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/file_cache.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/file_cache.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/node_timer.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/node_timer.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/planner/expr.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/planner/expr.rs`

 * *Files 2% similar despite different names*

```diff
@@ -527,23 +527,14 @@
             Ok(Arc::new(ApplyExpr::new_minimal(
                 vec![input],
                 function,
                 node_to_expr(expression, expr_arena),
                 ApplyOptions::ApplyGroups,
             )))
         }
-        Cache { input, id } => {
-            state.has_cache = true;
-            let input = create_physical_expr(input, ctxt, expr_arena, schema, state)?;
-            Ok(Arc::new(CacheExpr::new(
-                input,
-                node_to_expr(expression, expr_arena),
-                id,
-            )))
-        }
         Wildcard => panic!("should be no wildcard at this point"),
         Nth(_) => panic!("should be no nth at this point"),
     }
 }
 
 /// Simple wrapper to parallelize functions that can be divided over threads aggregated and
 /// finally aggregated in the main thread. This can be done for sum, min, max, etc.
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/planner/lp.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/planner/lp.rs`

 * *Files 3% similar despite different names*

```diff
@@ -234,22 +234,30 @@
             schema: _schema,
             ..
         } => {
             let input_schema = lp_arena.get(input).schema(lp_arena).into_owned();
             let input = create_physical_plan(input, lp_arena, expr_arena)?;
             let mut state = ExpressionConversionState::new(POOL.current_num_threads() > expr.len());
             let phys_expr = create_physical_expressions(
-                &expr,
+                expr.default_exprs(),
+                Context::Default,
+                expr_arena,
+                Some(&input_schema),
+                &mut state,
+            )?;
+            let cse_expr = create_physical_expressions(
+                expr.cse_exprs(),
                 Context::Default,
                 expr_arena,
                 Some(&input_schema),
                 &mut state,
             )?;
             Ok(Box::new(executors::ProjectionExec {
                 input,
+                cse_expr,
                 expr: phys_expr,
                 has_windows: state.has_windows,
                 input_schema,
                 #[cfg(test)]
                 schema: _schema,
             }))
         }
@@ -268,14 +276,15 @@
                 Context::Default,
                 expr_arena,
                 Some(&input_schema),
                 &mut state,
             )?;
             Ok(Box::new(executors::ProjectionExec {
                 input,
+                cse_expr: vec![],
                 expr: phys_expr,
                 has_windows: state.has_windows,
                 input_schema,
                 #[cfg(test)]
                 schema: _schema,
             }))
         }
@@ -308,14 +317,15 @@
         AnonymousScan {
             function,
             predicate,
             options,
             output_schema,
             ..
         } => {
+            let options = Arc::try_unwrap(options).unwrap_or_else(|options| (*options).clone());
             let predicate = predicate
                 .map(|pred| {
                     create_physical_expr(
                         pred,
                         Context::Default,
                         expr_arena,
                         output_schema.as_ref(),
@@ -363,14 +373,15 @@
             aggs,
             apply,
             schema,
             maintain_order,
             options,
         } => {
             let input_schema = lp_arena.get(input).schema(lp_arena).into_owned();
+            let options = Arc::try_unwrap(options).unwrap_or_else(|options| (*options).clone());
             let phys_keys = create_physical_expressions(
                 &keys,
                 Context::Default,
                 expr_arena,
                 Some(&input_schema),
                 &mut Default::default(),
             )?;
@@ -490,40 +501,55 @@
             let right_on = create_physical_expressions(
                 &right_on,
                 Context::Default,
                 expr_arena,
                 None,
                 &mut Default::default(),
             )?;
+            let options = Arc::try_unwrap(options).unwrap_or_else(|options| (*options).clone());
             Ok(Box::new(executors::JoinExec::new(
                 input_left,
                 input_right,
                 left_on,
                 right_on,
                 parallel,
                 options.args,
             )))
         }
-        HStack { input, exprs, .. } => {
+        HStack {
+            input,
+            exprs,
+            schema: _schema,
+        } => {
             let input_schema = lp_arena.get(input).schema(lp_arena).into_owned();
             let input = create_physical_plan(input, lp_arena, expr_arena)?;
 
             let mut state =
                 ExpressionConversionState::new(POOL.current_num_threads() > exprs.len());
-            let phys_expr = create_physical_expressions(
-                &exprs,
+
+            let cse_exprs = create_physical_expressions(
+                exprs.cse_exprs(),
+                Context::Default,
+                expr_arena,
+                Some(&input_schema),
+                &mut state,
+            )?;
+
+            let phys_exprs = create_physical_expressions(
+                exprs.default_exprs(),
                 Context::Default,
                 expr_arena,
                 Some(&input_schema),
                 &mut state,
             )?;
             Ok(Box::new(executors::StackExec {
                 input,
                 has_windows: state.has_windows,
-                expr: phys_expr,
+                cse_exprs,
+                exprs: phys_exprs,
                 input_schema,
             }))
         }
         MapFunction {
             input, function, ..
         } => {
             let input = create_physical_plan(input, lp_arena, expr_arena)?;
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/state.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/state.rs`

 * *Files 2% similar despite different names*

```diff
@@ -59,16 +59,14 @@
     }
 }
 
 /// State/ cache that is maintained during the Execution of the physical plan.
 pub struct ExecutionState {
     // cached by a `.cache` call and kept in memory for the duration of the plan.
     df_cache: Arc<Mutex<PlHashMap<usize, Arc<OnceCell<DataFrame>>>>>,
-    #[allow(clippy::type_complexity)]
-    pub(crate) expr_cache: Option<Arc<Mutex<PlHashMap<usize, Arc<OnceCell<Series>>>>>>,
     // cache file reads until all branches got there file, then we delete it
     #[cfg(any(feature = "ipc", feature = "parquet", feature = "csv"))]
     pub(crate) file_cache: FileCache,
     pub(super) schema_cache: RwLock<Option<SchemaRef>>,
     /// Used by Window Expression to prevent redundant grouping
     pub(super) group_tuples: GroupsProxyCache,
     /// Used by Window Expression to prevent redundant joins
@@ -107,15 +105,14 @@
         }
     }
 
     /// Partially clones and partially clears state
     pub(super) fn split(&self) -> Self {
         Self {
             df_cache: self.df_cache.clone(),
-            expr_cache: self.expr_cache.clone(),
             #[cfg(any(feature = "ipc", feature = "parquet", feature = "csv"))]
             file_cache: self.file_cache.clone(),
             schema_cache: Default::default(),
             group_tuples: Default::default(),
             join_tuples: Default::default(),
             branch_idx: self.branch_idx,
             flags: AtomicU8::new(self.flags.load(Ordering::Relaxed)),
@@ -124,15 +121,14 @@
         }
     }
 
     /// clones and partially clears state
     pub(super) fn clone(&self) -> Self {
         Self {
             df_cache: self.df_cache.clone(),
-            expr_cache: self.expr_cache.clone(),
             #[cfg(any(feature = "ipc", feature = "parquet", feature = "csv"))]
             file_cache: self.file_cache.clone(),
             schema_cache: self.schema_cache.read().unwrap().clone().into(),
             group_tuples: self.group_tuples.clone(),
             join_tuples: self.join_tuples.clone(),
             branch_idx: self.branch_idx,
             flags: AtomicU8::new(self.flags.load(Ordering::Relaxed)),
@@ -145,15 +141,14 @@
     pub(crate) fn with_finger_prints(_finger_prints: Option<usize>) -> Self {
         Self::new()
     }
     #[cfg(any(feature = "parquet", feature = "csv", feature = "ipc"))]
     pub(crate) fn with_finger_prints(finger_prints: Option<Vec<FileFingerPrint>>) -> Self {
         Self {
             df_cache: Arc::new(Mutex::new(PlHashMap::default())),
-            expr_cache: None,
             schema_cache: Default::default(),
             #[cfg(any(feature = "ipc", feature = "parquet", feature = "csv"))]
             file_cache: FileCache::new(finger_prints),
             group_tuples: Arc::new(Mutex::new(PlHashMap::default())),
             join_tuples: Arc::new(Mutex::new(PlHashMap::default())),
             branch_idx: 0,
             flags: AtomicU8::new(StateFlags::init().as_u8()),
@@ -165,15 +160,14 @@
     pub fn new() -> Self {
         let mut flags: StateFlags = Default::default();
         if verbose() {
             flags |= StateFlags::VERBOSE;
         }
         Self {
             df_cache: Default::default(),
-            expr_cache: None,
             schema_cache: Default::default(),
             #[cfg(any(feature = "ipc", feature = "parquet", feature = "csv"))]
             file_cache: FileCache::new(None),
             group_tuples: Default::default(),
             join_tuples: Default::default(),
             branch_idx: 0,
             flags: AtomicU8::new(StateFlags::init().as_u8()),
@@ -202,24 +196,14 @@
         let mut guard = self.df_cache.lock().unwrap();
         guard
             .entry(key)
             .or_insert_with(|| Arc::new(OnceCell::new()))
             .clone()
     }
 
-    pub(crate) fn get_expr_cache(&self, key: usize) -> Option<Arc<OnceCell<Series>>> {
-        self.expr_cache.as_ref().map(|cache| {
-            let mut guard = cache.lock().unwrap();
-            guard
-                .entry(key)
-                .or_insert_with(|| Arc::new(OnceCell::new()))
-                .clone()
-        })
-    }
-
     /// Clear the cache used by the Window expressions
     pub(crate) fn clear_window_expr_cache(&self) {
         {
             let mut lock = self.group_tuples.lock().unwrap();
             lock.clear();
         }
         let mut lock = self.join_tuples.lock().unwrap();
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/streaming/checks.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/streaming/checks.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/streaming/construct_pipeline.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/streaming/construct_pipeline.rs`

 * *Files 2% similar despite different names*

```diff
@@ -55,44 +55,38 @@
     operator_offset: usize,
 ) {
     // if the join/union has a slice, we add a new slice node
     // note that we take the offset + 1, because we want to
     // slice AFTER the join has happened and the join will be an
     // operator
     use ALogicalPlan::*;
-    match lp_arena.get(node) {
-        Join {
-            options:
-                JoinOptions {
-                    args:
-                        JoinArgs {
-                            slice: Some((offset, len)),
-                            ..
-                        },
-                    ..
-                },
-            ..
+    let (offset, len) = match lp_arena.get(node) {
+        Join { options, .. } if options.args.slice.is_some() => {
+            let Some((offset, len)) = options.args.slice else {
+                unreachable!()
+            };
+            (offset, len)
         }
-        | Union {
+        Union {
             options:
                 UnionOptions {
                     slice: Some((offset, len)),
                     ..
                 },
             ..
-        } => {
-            let slice_node = lp_arena.add(Slice {
-                input: Node::default(),
-                offset: *offset,
-                len: *len as IdxSize,
-            });
-            sink_nodes.push((operator_offset + 1, slice_node, Rc::new(RefCell::new(1))));
-        }
-        _ => {}
-    }
+        } => (*offset, *len),
+        _ => return,
+    };
+
+    let slice_node = lp_arena.add(Slice {
+        input: Node::default(),
+        offset,
+        len: len as IdxSize,
+    });
+    sink_nodes.push((operator_offset + 1, slice_node, Rc::new(RefCell::new(1))));
 }
 
 pub(super) fn construct(
     tree: Tree,
     lp_arena: &mut Arena<ALogicalPlan>,
     expr_arena: &mut Arena<AExpr>,
     fmt: bool,
@@ -189,15 +183,17 @@
     }
 
     // We sort to ensure we execute in the stack traversal order.
     // this is important to make unions and joins work as expected
     // also pipelines are not ready to receive inputs otherwise
     pipelines.sort_by(|a, b| a.0.cmp(&b.0));
 
-    let Some(final_sink) = final_sink else { return Ok(None) };
+    let Some(final_sink) = final_sink else {
+        return Ok(None);
+    };
     let insertion_location = match lp_arena.get(final_sink) {
         FileSink {
             input,
             payload: FileSinkOptions { file_type, .. },
         } => {
             // this was inserted only during conversion and does not exist
             // in the original tree, so we take the input, as that's where
@@ -215,15 +211,17 @@
     let original_lp = if fmt {
         let original_lp = node_to_lp_cloned(insertion_location, expr_arena, lp_arena);
         Some(original_lp)
     } else {
         None
     };
 
-    let Some((_, mut most_left)) = pipelines.pop() else {unreachable!()};
+    let Some((_, mut most_left)) = pipelines.pop() else {
+        unreachable!()
+    };
     while let Some((_, rhs)) = pipelines.pop() {
         most_left = most_left.with_other_branch(rhs)
     }
     // replace the part of the logical plan with a `MapFunction` that will execute the pipeline.
     let schema = lp_arena
         .get(insertion_location)
         .schema(lp_arena)
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/streaming/convert_alp.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/streaming/convert_alp.rs`

 * *Files 0% similar despite different names*

```diff
@@ -283,15 +283,17 @@
                         slice: Some((offset, len)),
                         ..
                     },
                 ..
             } if *offset >= 0 => {
                 insert_slice(root, *offset, *len as IdxSize, lp_arena, &mut state);
                 state.streamable = true;
-                let Union {inputs, ..} =  lp_arena.get(root) else {unreachable!()};
+                let Union { inputs, .. } = lp_arena.get(root) else {
+                    unreachable!()
+                };
                 for (i, input) in inputs.iter().enumerate() {
                     let mut state = if i == 0 {
                         // note the clone!
                         let mut state = state.clone();
                         state.join_count += inputs.len() as u32 - 1;
                         state
                     } else {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/physical_plan/streaming/tree.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/physical_plan/streaming/tree.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/prelude.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/prelude.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/aggregations.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/aggregations.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/arity.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/arity.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/cse.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/cse.rs`

 * *Files 2% similar despite different names*

```diff
@@ -15,15 +15,15 @@
     let lf = scan_foods_ipc();
 
     let lf = lf.with_column(col("category").str().to_uppercase());
 
     let lf = lf
         .clone()
         .left_join(lf, col("fats_g"), col("fats_g"))
-        .with_common_subplan_elimination(true);
+        .with_comm_subplan_elim(true);
 
     cached_before_root(lf);
 
     Ok(())
 }
 
 #[test]
@@ -37,15 +37,15 @@
         UnionArgs {
             rechunk: false,
             parallel: false,
             ..Default::default()
         },
     )?
     .select([col("category"), col("fats_g")])
-    .with_common_subplan_elimination(true);
+    .with_comm_subplan_elim(true);
 
     let (mut expr_arena, mut lp_arena) = get_arenas();
     let lp = lf.clone().optimize(&mut lp_arena, &mut expr_arena).unwrap();
     assert!((&lp_arena).iter(lp).all(|(_, lp)| {
         use ALogicalPlan::*;
         match lp {
             Scan { file_options, .. } => {
@@ -73,15 +73,15 @@
     ]?
     .lazy();
 
     let q1 = q.clone().filter(col("a").eq(lit(1))).select([col("a")]);
     let q2 = q.filter(col("a").eq(lit(1))).select([col("a"), col("b")]);
     let q = q1
         .left_join(q2, col("a"), col("a"))
-        .with_common_subplan_elimination(true);
+        .with_comm_subplan_elim(true);
 
     // check that the projection of a is not done before the cache
     let (mut expr_arena, mut lp_arena) = get_arenas();
     let lp = q.optimize(&mut lp_arena, &mut expr_arena).unwrap();
     assert!((&lp_arena).iter(lp).all(|(_, lp)| {
         use ALogicalPlan::*;
         match lp {
@@ -238,15 +238,15 @@
         .join(
             lf1.filter(col("x").neq(lit(8))),
             [col("id")],
             [col("id")],
             JoinType::Semi.into(),
         );
 
-    let q = q.with_common_subplan_elimination(true);
+    let q = q.with_comm_subplan_elim(true);
 
     let (mut expr_arena, mut lp_arena) = get_arenas();
     let lp = q.optimize(&mut lp_arena, &mut expr_arena).unwrap();
 
     // ensure we get two different caches
     // and ensure that every cache only has 1 hit.
     let cache_ids = (&lp_arena)
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/io.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/io.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/logical.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/logical.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/optimization_checks.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/optimization_checks.rs`

 * *Files 0% similar despite different names*

```diff
@@ -177,15 +177,15 @@
             q2,
             [col("category")],
             [col("category")],
             JoinType::Left.into(),
         )
         .slice(1, 3)
         // this inserts a cache and blocks slice pushdown
-        .with_common_subplan_elimination(false);
+        .with_comm_subplan_elim(false);
     // test if optimization continued beyond the join node
     assert!(slice_at_scan(q.clone()));
 
     let (mut expr_arena, mut lp_arena) = get_arenas();
     let lp = q.clone().optimize(&mut lp_arena, &mut expr_arena).unwrap();
     assert!((&lp_arena).iter(lp).all(|(_, lp)| {
         use ALogicalPlan::*;
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/predicate_queries.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/predicate_queries.rs`

 * *Files 2% similar despite different names*

```diff
@@ -40,15 +40,15 @@
     let base = df
         .lazy()
         .with_column(col("group").cast(DataType::Categorical(None)));
 
     let extract = col("group")
         .cast(DataType::Utf8)
         .str()
-        .extract(r#"(\d+-){4}(\w+)-"#, 2)
+        .extract(r"(\d+-){4}(\w+)-", 2)
         .cast(DataType::Int32)
         .alias("age");
     let predicate = col("age").is_in(lit(Series::new("", [2i32])));
 
     let out = base
         .clone()
         .with_column(extract.clone())
@@ -250,15 +250,15 @@
 
     let q = (lf.clone().join_builder().with(lf))
         .left_on([col("y")])
         .right_on([col("y")])
         .suffix("_")
         .finish()
         .filter(col("x").eq(1))
-        .with_common_subplan_elimination(false);
+        .with_comm_subplan_elim(false);
 
     // the left hand side should have a predicate
     assert!(predicate_at_scan(q.clone()));
 
     let expected = df![
         "x" => [1, 1],
         "y" => [1, 1],
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/projection_queries.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/projection_queries.rs`

 * *Files 2% similar despite different names*

```diff
@@ -98,15 +98,15 @@
             .clone()
             .join(
                 partial,
                 [col("category")],
                 [col("category")],
                 JoinType::Inner.into(),
             )
-            .with_common_subplan_elimination(cse);
+            .with_comm_subplan_elim(cse);
         let out = q.collect()?;
         assert_eq!(
             out.get_column_names(),
             &["category", "calories", "fats_g", "sugars_g"]
         );
     }
     Ok(())
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/queries.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/queries.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/streaming.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/streaming.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/tests/tpch.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/tests/tpch.rs`

 * *Files 1% similar despite different names*

```diff
@@ -79,15 +79,15 @@
         .sort_by_exprs(
             [cols(["s_acctbal", "n_name", "s_name", "p_partkey"])],
             [true, false, false, false],
             false,
             false,
         )
         .limit(100)
-        .with_common_subplan_elimination(true);
+        .with_comm_subplan_elim(true);
 
     let out = q.collect()?;
     let schema = Schema::from_iter([
         Field::new("s_acctbal", DataType::Float64),
         Field::new("s_name", DataType::Utf8),
         Field::new("n_name", DataType::Utf8),
         Field::new("p_partkey", DataType::Int64),
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-lazy/src/utils.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-lazy/src/utils.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/Cargo.toml` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/Cargo.toml`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/LICENSE` & `polars_lts_cpu-0.18.9/local_dependencies/polars-algo/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/operators/filter.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/operators/filter.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/operators/function.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/operators/function.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/operators/pass.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/operators/pass.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/operators/placeholder.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/operators/placeholder.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/operators/projection.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/operators/reproject.rs`

 * *Files 18% similar despite different names*

```diff
@@ -1,130 +1,120 @@
-use std::sync::Arc;
-
-use polars_core::error::PolarsResult;
 use polars_core::frame::DataFrame;
-use polars_core::schema::SchemaRef;
-
-use crate::expressions::PhysicalPipedExpr;
-use crate::operators::{DataChunk, Operator, OperatorResult, PExecutionContext};
+use polars_core::prelude::SchemaRef;
+use polars_core::schema::Schema;
 
-#[derive(Clone)]
-pub(crate) struct FastProjectionOperator {
-    columns: Arc<[Arc<str>]>,
-    input_schema: SchemaRef,
-}
+use crate::operators::{DataChunk, Operator, OperatorResult, PExecutionContext, PolarsResult};
 
-impl FastProjectionOperator {
-    pub(crate) fn new(columns: Arc<[Arc<str>]>, input_schema: SchemaRef) -> Self {
-        Self {
-            columns,
-            input_schema,
+/// An operator that will ensure we keep the schema order
+pub(crate) struct ReProjectOperator {
+    schema: SchemaRef,
+    operator: Box<dyn Operator>,
+    // cache the positions
+    positions: Vec<usize>,
+}
+
+impl ReProjectOperator {
+    pub(crate) fn new(schema: SchemaRef, operator: Box<dyn Operator>) -> Self {
+        ReProjectOperator {
+            schema,
+            operator,
+            positions: vec![],
         }
     }
 }
 
-impl Operator for FastProjectionOperator {
-    fn execute(
-        &mut self,
-        _context: &PExecutionContext,
-        chunk: &DataChunk,
-    ) -> PolarsResult<OperatorResult> {
-        let chunk = chunk.with_data(
-            chunk
-                .data
-                .select_with_schema_unchecked(self.columns.as_ref(), &self.input_schema)?,
-        );
-        Ok(OperatorResult::Finished(chunk))
-    }
-    fn split(&self, _thread_no: usize) -> Box<dyn Operator> {
-        Box::new(self.clone())
-    }
-    fn fmt(&self) -> &str {
-        "fast_projection"
-    }
-}
+pub(crate) fn reproject_chunk(
+    chunk: &mut DataChunk,
+    positions: &mut Vec<usize>,
+    schema: &Schema,
+) -> PolarsResult<()> {
+    let out = if positions.is_empty() {
+        // use the chunk schema to cache
+        // the positions for subsequent calls
+        let chunk_schema = chunk.data.schema();
+
+        let out = chunk
+            .data
+            .select_with_schema_unchecked(schema.iter_names(), &chunk_schema)?;
 
-#[derive(Clone)]
-pub(crate) struct ProjectionOperator {
-    pub(crate) exprs: Vec<Arc<dyn PhysicalPipedExpr>>,
+        *positions = out
+            .get_columns()
+            .iter()
+            .map(|s| chunk_schema.get_full(s.name()).unwrap().0)
+            .collect();
+        out
+    } else {
+        let columns = chunk.data.get_columns();
+        let cols = positions.iter().map(|i| columns[*i].clone()).collect();
+        DataFrame::new_no_checks(cols)
+    };
+    *chunk = chunk.with_data(out);
+    Ok(())
 }
 
-impl Operator for ProjectionOperator {
+impl Operator for ReProjectOperator {
     fn execute(
         &mut self,
         context: &PExecutionContext,
         chunk: &DataChunk,
     ) -> PolarsResult<OperatorResult> {
-        let mut has_literals = false;
-        let mut has_empty = false;
-        let mut projected = self
-            .exprs
-            .iter()
-            .map(|e| {
-                let s = e.evaluate(chunk, context.execution_state.as_any())?;
-                if s.len() == 1 {
-                    has_literals = true;
-                }
-                if s.len() == 0 {
-                    has_empty = true;
-                }
-                Ok(s)
-            })
-            .collect::<PolarsResult<Vec<_>>>()?;
-
-        if has_empty {
-            for s in &mut projected {
-                *s = s.clear();
-            }
-        } else if has_literals {
-            let height = projected.iter().map(|s| s.len()).max().unwrap();
-            for s in &mut projected {
-                let len = s.len();
-                if len == 1 && len != height {
-                    *s = s.new_from_index(0, height)
-                }
-            }
-        }
-
-        let chunk = chunk.with_data(DataFrame::new_no_checks(projected));
-        Ok(OperatorResult::Finished(chunk))
-    }
-    fn split(&self, _thread_no: usize) -> Box<dyn Operator> {
-        Box::new(self.clone())
+        let (mut chunk, finished) = match self.operator.execute(context, chunk)? {
+            OperatorResult::Finished(chunk) => (chunk, true),
+            OperatorResult::HaveMoreOutPut(chunk) => (chunk, false),
+            OperatorResult::NeedsNewData => return Ok(OperatorResult::NeedsNewData),
+        };
+        reproject_chunk(&mut chunk, &mut self.positions, self.schema.as_ref())?;
+        Ok(if finished {
+            OperatorResult::Finished(chunk)
+        } else {
+            OperatorResult::HaveMoreOutPut(chunk)
+        })
+    }
+
+    fn split(&self, thread_no: usize) -> Box<dyn Operator> {
+        let operator = self.operator.split(thread_no);
+        Box::new(Self {
+            schema: self.schema.clone(),
+            positions: self.positions.clone(),
+            operator,
+        })
     }
+
     fn fmt(&self) -> &str {
-        "projection"
+        "re-project-operator"
     }
 }
 
-#[derive(Clone)]
-pub(crate) struct HstackOperator {
-    pub(crate) exprs: Vec<Arc<dyn PhysicalPipedExpr>>,
-    pub(crate) input_schema: SchemaRef,
-}
-
-impl Operator for HstackOperator {
-    fn execute(
-        &mut self,
-        context: &PExecutionContext,
-        chunk: &DataChunk,
-    ) -> PolarsResult<OperatorResult> {
-        let projected = self
-            .exprs
-            .iter()
-            .map(|e| e.evaluate(chunk, context.execution_state.as_any()))
-            .collect::<PolarsResult<Vec<_>>>()?;
-
-        let mut df = chunk.data.clone();
-        let schema = &*self.input_schema;
-        df._add_columns(projected, schema)?;
-
-        let chunk = chunk.with_data(df);
-        Ok(OperatorResult::Finished(chunk))
-    }
-    fn split(&self, _thread_no: usize) -> Box<dyn Operator> {
-        Box::new(self.clone())
-    }
-    fn fmt(&self) -> &str {
-        "hstack"
+#[cfg(test)]
+mod test {
+    use polars_core::prelude::*;
+
+    use super::*;
+
+    #[test]
+    fn test_reproject_chunk() {
+        let df = df![
+            "a" => [1, 2],
+            "b" => [1, 2],
+            "c" => [1, 2],
+            "d" => [1, 2],
+        ]
+        .unwrap();
+
+        let mut chunk1 = DataChunk::new(0, df.clone());
+        let mut chunk2 = DataChunk::new(1, df);
+
+        let mut positions = vec![];
+
+        let mut out_schema = Schema::new();
+        out_schema.with_column("c".into(), DataType::Int32);
+        out_schema.with_column("b".into(), DataType::Int32);
+        out_schema.with_column("d".into(), DataType::Int32);
+        out_schema.with_column("a".into(), DataType::Int32);
+
+        reproject_chunk(&mut chunk1, &mut positions, &out_schema).unwrap();
+        // second call cached the positions
+        reproject_chunk(&mut chunk2, &mut positions, &out_schema).unwrap();
+        assert_eq!(&chunk1.data.schema(), &out_schema);
+        assert_eq!(&chunk2.data.schema(), &out_schema);
     }
 }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/file_sink.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/file_sink.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/convert.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/convert.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/count.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/count.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/first.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/first.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/interface.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/interface.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/last.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/last.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/mean.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/mean.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/min_max.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/min_max.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/null.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/null.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/sum.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/aggregates/sum.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/eval.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/eval.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/global.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/global.rs`

 * *Files 1% similar despite different names*

```diff
@@ -170,15 +170,15 @@
                 let chunk_indexes = payload.chunk_index();
                 let agg_cols = payload.cols();
                 self.process_partition_impl(&mut hash_map, hashes, chunk_indexes, keys, agg_cols);
             }
         }
     }
 
-    pub(super) fn merge_local_map(&self, finalized_local_map: &mut AggHashTable<true>) {
+    pub(super) fn merge_local_map(&self, finalized_local_map: &AggHashTable<true>) {
         // TODO! maybe parallelize?
         // needs unsafe, first benchmark.
         for (partition_i, pt_map) in self.inner_maps.iter().enumerate() {
             let mut pt_map = pt_map.lock().unwrap();
             pt_map.combine_on_partition(partition_i, finalized_local_map)
         }
     }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/hash_table.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/hash_table.rs`

 * *Files 2% similar despite different names*

```diff
@@ -148,32 +148,32 @@
 
             agg_fn.pre_agg(chunk_index, agg_iter.as_mut())
         }
         // no overflow
         false
     }
 
-    pub(super) fn combine(&mut self, other: &mut Self) {
+    pub(super) fn combine(&mut self, other: &Self) {
         self.combine_impl(other, |_hash| true)
     }
 
     pub(super) fn combine_on_partition<const FIXED_OTHER: bool>(
         &mut self,
         partition: usize,
-        other: &mut AggHashTable<FIXED_OTHER>,
+        other: &AggHashTable<FIXED_OTHER>,
     ) {
         let partition = partition as u64;
         self.combine_impl(other, |hash| {
             this_partition(hash, partition, PARTITION_SIZE as u64)
         })
     }
 
     pub(super) fn combine_impl<const FIXED_OTHER: bool, C>(
         &mut self,
-        other: &mut AggHashTable<FIXED_OTHER>,
+        other: &AggHashTable<FIXED_OTHER>,
         on_condition: C,
     )
     // takes a hash and if true, this keys will be combined
     where
         C: Fn(u64) -> bool,
     {
         let spill_size = self.spill_size;
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/ooc_state.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/ooc_state.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/sink.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/sink.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/source.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/source.rs`

 * *Files 8% similar despite different names*

```diff
@@ -60,15 +60,15 @@
 
         // merge the dumped tables
         // if no tables are spilled we simply skip
         // this and finalize the in memory state
         if partition_dir.exists() {
             for file in std::fs::read_dir(partition_dir).expect("should be there") {
                 let spilled = file.unwrap().path();
-                let file = std::fs::File::open(spilled)?;
+                let file = polars_utils::open_file(spilled)?;
                 let reader = IpcReader::new(file);
                 let spilled = reader.finish().unwrap();
                 if spilled.n_chunks() > 1 {
                     for spilled in flatten_df_iter(&spilled) {
                         self.global_table
                             .process_partition_from_dumped(partition, &spilled)
                     }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/thread_local.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/generic/thread_local.rs`

 * *Files 2% similar despite different names*

```diff
@@ -167,18 +167,15 @@
             (true, false) => {}
             (false, false) => {}
             (true, true) => {
                 self.finish();
                 other.finish();
                 let other_payloads = std::mem::take(&mut other.finished_payloads);
 
-                for (part_self, part_other) in self
-                    .finished_payloads
-                    .iter_mut()
-                    .zip(other_payloads.into_iter())
+                for (part_self, part_other) in self.finished_payloads.iter_mut().zip(other_payloads)
                 {
                     part_self.extend(part_other)
                 }
             }
         }
     }
 
@@ -210,15 +207,15 @@
                         hashes,
                         chunk_idx,
                         keys: keys_builder.into(),
                         aggs: spilled_aggs.iter_mut().map(|b| b.reset(0)).collect(),
                     },
                 )
             })
-            .chain(flattened.into_iter())
+            .chain(flattened)
     }
 }
 
 pub(super) struct ThreadLocalTable {
     inner_map: AggHashTable<true>,
     spill_partitions: SpillPartitions,
 }
@@ -276,15 +273,15 @@
                 .insert(hash, chunk_index, keys_row, agg_iters)
         } else {
             None
         }
     }
 
     pub(super) fn combine(&mut self, other: &mut Self) {
-        self.inner_map.combine(&mut other.inner_map);
+        self.inner_map.combine(&other.inner_map);
         self.spill_partitions.combine(&mut other.spill_partitions);
     }
 
     pub(super) fn finalize(&mut self, slice: &mut Option<(i64, usize)>) -> Option<DataFrame> {
         if !self.spill_partitions.spilled {
             Some(self.inner_map.finalize(slice))
         } else {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/ooc.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/ooc.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/ooc_state.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/ooc_state.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/primitive/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/primitive/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/string.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/string.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/groupby/utils.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/groupby/utils.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/io.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/io.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/joins/cross.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/joins/cross.rs`

 * *Files 4% similar despite different names*

```diff
@@ -33,15 +33,15 @@
         self.chunks.push(chunk);
         Ok(SinkResult::CanHaveMoreInput)
     }
 
     fn combine(&mut self, other: &mut dyn Sink) {
         let other = other.as_any().downcast_mut::<Self>().unwrap();
         let other_chunks = std::mem::take(&mut other.chunks);
-        self.chunks.extend(other_chunks.into_iter());
+        self.chunks.extend(other_chunks);
     }
 
     fn split(&self, _thread_no: usize) -> Box<dyn Sink> {
         Box::new(Self {
             suffix: self.suffix.clone(),
             ..Default::default()
         })
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/joins/generic_build.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/joins/generic_build.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/joins/inner_left.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/joins/inner_left.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/memory.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/memory.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/ordered.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/ordered.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/reproject.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/reproject.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/slice.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/slice.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/sort/ooc.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/sort/ooc.rs`

 * *Files 2% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 use rayon::prelude::*;
 
 use crate::executors::sinks::io::{DfIter, IOThread};
 use crate::executors::sinks::sort::source::SortSource;
 use crate::operators::FinalizedSink;
 
 pub(super) fn read_df(path: &Path) -> PolarsResult<DataFrame> {
-    let file = std::fs::File::open(path)?;
+    let file = polars_utils::open_file(path)?;
     IpcReader::new(file).set_rechunk(false).finish()
 }
 
 // Utility to buffer partitioned dataframes
 // this ensures we don't write really small dataframes
 // and amortize IO cost
 #[derive(Default)]
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/sort/sink.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/sort/sink.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/sort/sink_multiple.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/sort/sink_multiple.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/sort/source.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/sort/source.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sinks/utils.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sinks/utils.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sources/csv.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sources/csv.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sources/frame.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sources/frame.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sources/ipc_one_shot.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sources/ipc_one_shot.rs`

 * *Files 4% similar despite different names*

```diff
@@ -11,15 +11,15 @@
 pub struct IpcSourceOneShot {
     reader: Option<IpcReader<File>>,
 }
 
 impl IpcSourceOneShot {
     #[allow(unused_variables)]
     pub(crate) fn new(path: &Path) -> PolarsResult<Self> {
-        let file = File::open(path)?;
+        let file = polars_utils::open_file(path)?;
         let reader = Some(IpcReader::new(file));
 
         Ok(IpcSourceOneShot { reader })
     }
 }
 
 impl Source for IpcSourceOneShot {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sources/parquet.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sources/parquet.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sources/reproject.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sources/reproject.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/executors/sources/union.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/executors/sources/union.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/operators/chunks.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/operators/chunks.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/operators/operator.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/operators/operator.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/operators/sink.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/operators/sink.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/pipeline/convert.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/pipeline/convert.rs`

 * *Files 4% similar despite different names*

```diff
@@ -3,25 +3,26 @@
 use std::sync::Arc;
 
 use hashbrown::hash_map::Entry;
 use polars_core::prelude::*;
 use polars_core::with_match_physical_integer_polars_type;
 use polars_plan::prelude::*;
 
+use crate::executors::operators::HstackOperator;
 use crate::executors::sinks::groupby::aggregates::convert_to_hash_agg;
 use crate::executors::sinks::groupby::GenericGroupby2;
 use crate::executors::sinks::*;
 use crate::executors::{operators, sources};
 use crate::expressions::PhysicalPipedExpr;
 use crate::operators::{Operator, Sink, Source};
 use crate::pipeline::PipeLine;
 
 fn exprs_to_physical<F>(
     exprs: &[Node],
-    expr_arena: &mut Arena<AExpr>,
+    expr_arena: &Arena<AExpr>,
     to_physical: &F,
     schema: Option<&SchemaRef>,
 ) -> PolarsResult<Vec<Arc<dyn PhysicalPipedExpr>>>
 where
     F: Fn(Node, &Arena<AExpr>, Option<&SchemaRef>) -> PolarsResult<Arc<dyn PhysicalPipedExpr>>,
 {
     exprs
@@ -114,15 +115,15 @@
         }
         _ => unreachable!(),
     }
 }
 
 pub fn get_sink<F>(
     node: Node,
-    lp_arena: &mut Arena<ALogicalPlan>,
+    lp_arena: &Arena<ALogicalPlan>,
     expr_arena: &mut Arena<AExpr>,
     to_physical: &F,
 ) -> PolarsResult<Box<dyn Sink>>
 where
     F: Fn(Node, &Arena<AExpr>, Option<&SchemaRef>) -> PolarsResult<Arc<dyn PhysicalPipedExpr>>,
 {
     use ALogicalPlan::*;
@@ -391,38 +392,97 @@
     Ok(out)
 }
 
 pub fn get_dummy_operator() -> Box<dyn Operator> {
     Box::new(operators::PlaceHolder {})
 }
 
+fn get_hstack<F>(
+    exprs: &[Node],
+    expr_arena: &Arena<AExpr>,
+    to_physical: &F,
+    input_schema: SchemaRef,
+    cse_exprs: Option<Box<HstackOperator>>,
+    unchecked: bool,
+) -> PolarsResult<HstackOperator>
+where
+    F: Fn(Node, &Arena<AExpr>, Option<&SchemaRef>) -> PolarsResult<Arc<dyn PhysicalPipedExpr>>,
+{
+    Ok(operators::HstackOperator {
+        exprs: exprs_to_physical(exprs, expr_arena, &to_physical, Some(&input_schema))?,
+        input_schema,
+        cse_exprs,
+        unchecked,
+    })
+}
+
 pub fn get_operator<F>(
     node: Node,
-    lp_arena: &mut Arena<ALogicalPlan>,
-    expr_arena: &mut Arena<AExpr>,
+    lp_arena: &Arena<ALogicalPlan>,
+    expr_arena: &Arena<AExpr>,
     to_physical: &F,
 ) -> PolarsResult<Box<dyn Operator>>
 where
     F: Fn(Node, &Arena<AExpr>, Option<&SchemaRef>) -> PolarsResult<Arc<dyn PhysicalPipedExpr>>,
 {
     use ALogicalPlan::*;
     let op = match lp_arena.get(node) {
         Projection { expr, input, .. } => {
             let input_schema = lp_arena.get(*input).schema(lp_arena);
+
+            let cse_exprs = expr.cse_exprs();
+            let cse_exprs = if cse_exprs.is_empty() {
+                None
+            } else {
+                Some(get_hstack(
+                    cse_exprs,
+                    expr_arena,
+                    to_physical,
+                    (*input_schema).clone(),
+                    None,
+                    true,
+                )?)
+            };
+
             let op = operators::ProjectionOperator {
-                exprs: exprs_to_physical(expr, expr_arena, &to_physical, Some(&input_schema))?,
+                exprs: exprs_to_physical(
+                    expr.default_exprs(),
+                    expr_arena,
+                    &to_physical,
+                    Some(&input_schema),
+                )?,
+                cse_exprs,
             };
             Box::new(op) as Box<dyn Operator>
         }
         HStack { exprs, input, .. } => {
-            let input_schema = (*lp_arena.get(*input).schema(lp_arena)).clone();
-            let op = operators::HstackOperator {
-                exprs: exprs_to_physical(exprs, expr_arena, &to_physical, Some(&input_schema))?,
-                input_schema,
+            let input_schema = lp_arena.get(*input).schema(lp_arena);
+
+            let cse_exprs = exprs.cse_exprs();
+            let cse_exprs = if cse_exprs.is_empty() {
+                None
+            } else {
+                Some(Box::new(get_hstack(
+                    cse_exprs,
+                    expr_arena,
+                    to_physical,
+                    (*input_schema).clone(),
+                    None,
+                    true,
+                )?))
             };
+            let op = get_hstack(
+                exprs.default_exprs(),
+                expr_arena,
+                to_physical,
+                (*input_schema).clone(),
+                cse_exprs,
+                false,
+            )?;
+
             Box::new(op) as Box<dyn Operator>
         }
         Selection { predicate, input } => {
             let input_schema = lp_arena.get(*input).schema(lp_arena);
             let predicate = to_physical(*predicate, expr_arena, Some(input_schema.as_ref()))?;
             let op = operators::FilterOperator { predicate };
             Box::new(op) as Box<dyn Operator>
@@ -454,15 +514,15 @@
 
 #[allow(clippy::too_many_arguments)]
 pub fn create_pipeline<F>(
     sources: &[Node],
     operators: Vec<Box<dyn Operator>>,
     operator_nodes: Vec<Node>,
     sink_nodes: Vec<(usize, Node, Rc<RefCell<u32>>)>,
-    lp_arena: &mut Arena<ALogicalPlan>,
+    lp_arena: &Arena<ALogicalPlan>,
     expr_arena: &mut Arena<AExpr>,
     to_physical: F,
     verbose: bool,
     sink_cache: &mut PlHashMap<usize, Box<dyn Sink>>,
 ) -> PolarsResult<PipeLine>
 where
     F: Fn(Node, &Arena<AExpr>, Option<&SchemaRef>) -> PolarsResult<Arc<dyn PhysicalPipedExpr>>,
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/pipeline/dispatcher.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/pipeline/dispatcher.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-pipe/src/pipeline/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-pipe/src/pipeline/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/Cargo.toml` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/Cargo.toml`

 * *Files 5% similar despite different names*

```diff
@@ -3,14 +3,17 @@
 version= "0.31.1"
 edition = "2021"
 license = "MIT"
 repository = "https://github.com/pola-rs/polars"
 description = "Lazy query engine for the Polars DataFrame library"
 resolver = "2"
 
+[lib]
+doctest = false
+
 # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
 
 [dependencies]
 ahash= "0.8"
 chrono = { version = "0.4", optional = true }
 chrono-tz = { version = "0.8", optional = true }
 ciborium = { version = "0.2", optional = true }
@@ -25,14 +28,35 @@
 pyo3 = { version = "0.19", optional = true }
 rayon= "1.6"
 regex = { version = "1.6", optional = true }
 serde = { version = "1", features = ["derive", "rc"], optional = true }
 smartstring= { version = "1" }
 strum_macros= "0.25"
 
+[dependencies.arrow]
+package = "arrow2"
+git = "https://github.com/jorgecarleitao/arrow2"
+# git = "https://github.com/ritchie46/arrow2"
+rev = "d5c78e7ba45fcebfbafd55a82ba2601ee3ea9617"
+# path = "../arrow2"
+# branch = "duration_json"
+version = "0.17.2"
+default-features = false
+features = [
+  "compute_aggregate",
+  "compute_arithmetics",
+  "compute_boolean",
+  "compute_boolean_kleene",
+  "compute_cast",
+  "compute_comparison",
+  "compute_concatenate",
+  "compute_filter",
+  "compute_if_then_else",
+]
+
 [features]
 # debugging utility
 debugging = []
 python = ["pyo3", "ciborium"]
 # make sure we don't compile unneeded things even though
 # this dependency gets activated
 compile = []
@@ -128,28 +152,7 @@
 
 panic_on_schema = []
 
 [package.metadata.docs.rs]
 all-features = true
 # defines the configuration attribute `docsrs`
 rustdoc-args = ["--cfg", "docsrs"]
-
-[dependencies.arrow]
-package = "arrow2"
-# git = "https://github.com/jorgecarleitao/arrow2"
-# git = "https://github.com/ritchie46/arrow2"
-# rev = "2d2e7053f9a50810bfe9cecff25ab39089aef98e"
-# path = "../arrow2"
-# branch = "polars_2023-06-26"
-version = "0.17.2"
-default-features = false
-features = [
-  "compute_aggregate",
-  "compute_arithmetics",
-  "compute_boolean",
-  "compute_boolean_kleene",
-  "compute_cast",
-  "compute_comparison",
-  "compute_concatenate",
-  "compute_filter",
-  "compute_if_then_else",
-]
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/LICENSE` & `polars_lts_cpu-0.18.9/local_dependencies/polars-sql/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dot.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dot.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/arithmetic.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/arithmetic.rs`

 * *Files 6% similar despite different names*

```diff
@@ -109,14 +109,27 @@
 
     /// Compute the inverse tangent of the given expression
     #[cfg(feature = "trigonometry")]
     pub fn arctan(self) -> Self {
         self.map_private(FunctionExpr::Trigonometry(TrigonometricFunction::ArcTan))
     }
 
+    /// Compute the inverse tangent of the given expression, with the angle expressed as the argument of a complex number
+    #[cfg(feature = "trigonometry")]
+    pub fn arctan2(self, x: Self) -> Self {
+        Expr::Function {
+            input: vec![self, x],
+            function: FunctionExpr::Atan2,
+            options: FunctionOptions {
+                collect_groups: ApplyOptions::ApplyFlat,
+                ..Default::default()
+            },
+        }
+    }
+
     /// Compute the hyperbolic cosine of the given expression
     #[cfg(feature = "trigonometry")]
     pub fn cosh(self) -> Self {
         self.map_private(FunctionExpr::Trigonometry(TrigonometricFunction::Cosh))
     }
 
     /// Compute the hyperbolic sine of the given expression
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/array.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/array.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/binary.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/binary.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/cat.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/cat.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/dt.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/dt.rs`

 * *Files 2% similar despite different names*

```diff
@@ -89,25 +89,14 @@
             GetOutput::map_dtype(move |dtype| match dtype {
                 DataType::Datetime(tu, _) => DataType::Datetime(*tu, Some(time_zone_clone.clone())),
                 _ => panic!("expected datetime"),
             }),
         )
     }
 
-    /// Localize tz-naive Datetime Series to tz-aware Datetime Series.
-    //
-    // This method takes a naive Datetime Series and makes this time zone aware.
-    // It does not move the time to another time zone.
-    #[cfg(feature = "timezones")]
-    #[deprecated(note = "use replace_time_zone")]
-    pub fn tz_localize(self, tz: TimeZone) -> Expr {
-        self.0
-            .map_private(FunctionExpr::TemporalExpr(TemporalFunction::TzLocalize(tz)))
-    }
-
     /// Get the year of a Date/Datetime
     pub fn year(self) -> Expr {
         self.0
             .map_private(FunctionExpr::TemporalExpr(TemporalFunction::Year))
     }
 
     // Compute whether the year of a Date/Datetime is a leap year.
@@ -279,19 +268,17 @@
 
     #[cfg(feature = "timezones")]
     pub fn replace_time_zone(
         self,
         time_zone: Option<TimeZone>,
         use_earliest: Option<bool>,
     ) -> Expr {
-        self.0
-            .map_private(FunctionExpr::TemporalExpr(TemporalFunction::CastTimezone(
-                time_zone,
-                use_earliest,
-            )))
+        self.0.map_private(FunctionExpr::TemporalExpr(
+            TemporalFunction::ReplaceTimeZone(time_zone, use_earliest),
+        ))
     }
 
     pub fn combine(self, time: Expr, tu: TimeUnit) -> Expr {
         self.0.map_many_private(
             FunctionExpr::TemporalExpr(TemporalFunction::Combine(tu)),
             &[time],
             false,
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/expr.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/expr.rs`

 * *Files 2% similar despite different names*

```diff
@@ -150,18 +150,14 @@
         /// function to apply
         function: SpecialEq<Arc<dyn SeriesUdf>>,
         /// output dtype of the function
         #[cfg_attr(feature = "serde", serde(skip))]
         output_type: GetOutput,
         options: FunctionOptions,
     },
-    Cache {
-        input: Box<Expr>,
-        id: usize,
-    },
     /// Expressions in this node should only be expanding
     /// e.g.
     /// `Expr::Columns`
     /// `Expr::Dtypes`
     /// `Expr::Wildcard`
     /// `Expr::Exclude`
     Selector(super::selector::Selector),
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/expr_dyn_fn.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/expr_dyn_fn.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/from.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/from.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/arg_where.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/arg_where.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/array.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/array.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/binary.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/binary.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/boolean.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/boolean.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/bounds.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/bounds.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/cat.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/cat.rs`

 * *Files 1% similar despite different names*

```diff
@@ -50,11 +50,13 @@
     ca.set_lexical_sorted(lexical);
     Ok(ca.into_series())
 }
 
 fn get_categories(s: &Series) -> PolarsResult<Series> {
     // categorical check
     let ca = s.categorical()?;
-    let DataType::Categorical(Some(rev_map)) = ca.dtype() else { unreachable!()  };
+    let DataType::Categorical(Some(rev_map)) = ca.dtype() else {
+        unreachable!()
+    };
     let arr = rev_map.get_categories().clone().boxed();
     Series::try_from((ca.name(), arr))
 }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/correlation.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/correlation.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/cum.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/cum.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/datetime.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/datetime.rs`

 * *Files 4% similar despite different names*

```diff
@@ -38,27 +38,35 @@
     MonthEnd,
     #[cfg(feature = "timezones")]
     BaseUtcOffset,
     #[cfg(feature = "timezones")]
     DSTOffset,
     Round(String, String),
     #[cfg(feature = "timezones")]
-    CastTimezone(Option<TimeZone>, Option<bool>),
-    #[cfg(feature = "timezones")]
-    TzLocalize(TimeZone),
+    ReplaceTimeZone(Option<TimeZone>, Option<bool>),
     DateRange {
         every: Duration,
         closed: ClosedWindow,
         time_unit: Option<TimeUnit>,
-        tz: Option<TimeZone>,
+        time_zone: Option<TimeZone>,
+    },
+    DateRanges {
+        every: Duration,
+        closed: ClosedWindow,
+        time_unit: Option<TimeUnit>,
+        time_zone: Option<TimeZone>,
     },
     TimeRange {
         every: Duration,
         closed: ClosedWindow,
     },
+    TimeRanges {
+        every: Duration,
+        closed: ClosedWindow,
+    },
     Combine(TimeUnit),
 }
 
 impl Display for TemporalFunction {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         use TemporalFunction::*;
         let s = match self {
@@ -88,19 +96,19 @@
             MonthEnd => "month_end",
             #[cfg(feature = "timezones")]
             BaseUtcOffset => "base_utc_offset",
             #[cfg(feature = "timezones")]
             DSTOffset => "dst_offset",
             Round(..) => "round",
             #[cfg(feature = "timezones")]
-            CastTimezone(_, _) => "replace_timezone",
-            #[cfg(feature = "timezones")]
-            TzLocalize(_) => "tz_localize",
+            ReplaceTimeZone(_, _) => "replace_time_zone",
             DateRange { .. } => return write!(f, "date_range"),
+            DateRanges { .. } => return write!(f, "date_ranges"),
             TimeRange { .. } => return write!(f, "time_range"),
+            TimeRanges { .. } => return write!(f, "time_ranges"),
             Combine(_) => "combine",
         };
         write!(f, "dt.{s}")
     }
 }
 
 pub(super) fn year(s: &Series) -> PolarsResult<Series> {
@@ -129,34 +137,32 @@
 }
 pub(super) fn ordinal_day(s: &Series) -> PolarsResult<Series> {
     s.ordinal_day().map(|ca| ca.into_series())
 }
 pub(super) fn time(s: &Series) -> PolarsResult<Series> {
     match s.dtype() {
         #[cfg(feature = "timezones")]
-        DataType::Datetime(_, Some(_)) => s
-            .datetime()
-            .unwrap()
-            .replace_time_zone(None, None)?
-            .cast(&DataType::Time),
+        DataType::Datetime(_, Some(_)) => {
+            polars_ops::prelude::replace_time_zone(s.datetime().unwrap(), None, None)?
+                .cast(&DataType::Time)
+        }
         DataType::Datetime(_, _) => s.datetime().unwrap().cast(&DataType::Time),
         DataType::Date => s.datetime().unwrap().cast(&DataType::Time),
         DataType::Time => Ok(s.clone()),
         dtype => polars_bail!(ComputeError: "expected Datetime, Date, or Time, got {}", dtype),
     }
 }
 pub(super) fn date(s: &Series) -> PolarsResult<Series> {
     match s.dtype() {
         #[cfg(feature = "timezones")]
         DataType::Datetime(_, Some(tz)) => {
-            let mut out = s
-                .datetime()
-                .unwrap()
-                .replace_time_zone(None, None)?
-                .cast(&DataType::Date)?;
+            let mut out = {
+                polars_ops::chunked_array::replace_time_zone(s.datetime().unwrap(), None, None)?
+                    .cast(&DataType::Date)?
+            };
             if tz != "UTC" {
                 // DST transitions may not preserve sortedness.
                 out.set_sorted_flag(IsSorted::Not);
             }
             Ok(out)
         }
         DataType::Datetime(_, _) => s.datetime().unwrap().cast(&DataType::Date),
@@ -164,19 +170,18 @@
         dtype => polars_bail!(ComputeError: "expected Datetime or Date, got {}", dtype),
     }
 }
 pub(super) fn datetime(s: &Series) -> PolarsResult<Series> {
     match s.dtype() {
         #[cfg(feature = "timezones")]
         DataType::Datetime(tu, Some(tz)) => {
-            let mut out = s
-                .datetime()
-                .unwrap()
-                .replace_time_zone(None, None)?
-                .cast(&DataType::Datetime(*tu, None))?;
+            let mut out = {
+                polars_ops::chunked_array::replace_time_zone(s.datetime().unwrap(), None, None)?
+                    .cast(&DataType::Datetime(*tu, None))?
+            };
             if tz != "UTC" {
                 // DST transitions may not preserve sortedness.
                 out.set_sorted_flag(IsSorted::Not);
             }
             Ok(out)
         }
         DataType::Datetime(tu, _) => s.datetime().unwrap().cast(&DataType::Datetime(*tu, None)),
@@ -307,31 +312,7 @@
                 .round(every, offset, None)?
                 .into_series(),
         },
         DataType::Date => s.date().unwrap().round(every, offset, None)?.into_series(),
         dt => polars_bail!(opq = round, got = dt, expected = "date/datetime"),
     })
 }
-
-#[cfg(feature = "timezones")]
-pub(super) fn replace_timezone(
-    s: &Series,
-    time_zone: Option<&str>,
-    use_earliest: Option<bool>,
-) -> PolarsResult<Series> {
-    let ca = s.datetime()?;
-    ca.replace_time_zone(time_zone, use_earliest)
-        .map(|ca| ca.into_series())
-}
-
-#[cfg(feature = "timezones")]
-#[deprecated(note = "use replace_time_zone")]
-pub(super) fn tz_localize(s: &Series, tz: &str) -> PolarsResult<Series> {
-    let ca = s.datetime()?.clone();
-    polars_ensure!(
-        ca.time_zone().as_ref().map_or(true, |tz| tz.is_empty()),
-        ComputeError:
-        "cannot localize a tz-aware datetime \
-        (consider using 'dt.convert_time_zone' or 'dt.replace_time_zone')"
-    );
-    Ok(ca.replace_time_zone(Some(tz), None)?.into_series())
-}
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/fill_null.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/fill_null.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/fused.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/fused.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/list.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/list.rs`

 * *Files 1% similar despite different names*

```diff
@@ -93,15 +93,15 @@
             // cast to i64 as it is more likely that it is that dtype
             // instead of usize/u64 (we never need that max length)
             let length_ca = length_s.cast(&DataType::Int64)?;
             let length_ca = length_ca.i64().unwrap();
 
             list_ca
                 .amortized_iter()
-                .zip(length_ca.into_iter())
+                .zip(length_ca)
                 .map(|(opt_s, opt_length)| match (opt_s, opt_length) {
                     (Some(s), Some(length)) => Some(s.as_ref().slice(offset, length as usize)),
                     _ => None,
                 })
                 .collect_trusted()
         }
         (offset_len, 1) => {
@@ -130,16 +130,16 @@
             // cast to i64 as it is more likely that it is that dtype
             // instead of usize/u64 (we never need that max length)
             let length_ca = length_s.cast(&DataType::Int64)?;
             let length_ca = length_ca.i64().unwrap();
 
             list_ca
                 .amortized_iter()
-                .zip(offset_ca.into_iter())
-                .zip(length_ca.into_iter())
+                .zip(offset_ca)
+                .zip(length_ca)
                 .map(
                     |((opt_s, opt_offset), opt_length)| match (opt_s, opt_offset, opt_length) {
                         (Some(s), Some(offset), Some(length)) => {
                             Some(s.as_ref().slice(offset, length as usize))
                         }
                         _ => None,
                     },
@@ -222,15 +222,15 @@
 
 #[cfg(feature = "list_take")]
 pub(super) fn take(args: &[Series], null_on_oob: bool) -> PolarsResult<Series> {
     let ca = &args[0];
     let idx = &args[1];
     let ca = ca.list()?;
 
-    if idx.len() == 1 {
+    if idx.len() == 1 && null_on_oob {
         // fast path
         let idx = idx.get(0)?.try_extract::<i64>()?;
         let out = ca.lst_get(idx)?;
         // make sure we return a list
         out.reshape(&[-1, 1])
     } else {
         ca.lst_take(idx, null_on_oob)
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/log.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/log.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/mod.rs`

 * *Files 0% similar despite different names*

```diff
@@ -110,14 +110,16 @@
     TemporalExpr(TemporalFunction),
     #[cfg(feature = "range")]
     Range(RangeFunction),
     #[cfg(feature = "date_offset")]
     DateOffset(polars_time::Duration),
     #[cfg(feature = "trigonometry")]
     Trigonometry(TrigonometricFunction),
+    #[cfg(feature = "trigonometry")]
+    Atan2,
     #[cfg(feature = "sign")]
     Sign,
     FillNull {
         super_type: DataType,
     },
     #[cfg(all(feature = "rolling_window", feature = "moment"))]
     // if we add more, make a sub enum
@@ -256,14 +258,16 @@
             TemporalExpr(fun) => return write!(f, "{fun}"),
             #[cfg(feature = "range")]
             Range(func) => return write!(f, "{func}"),
             #[cfg(feature = "date_offset")]
             DateOffset(_) => "dt.offset_by",
             #[cfg(feature = "trigonometry")]
             Trigonometry(func) => return write!(f, "{func}"),
+            #[cfg(feature = "trigonometry")]
+            Atan2 => return write!(f, "arctan2"),
             #[cfg(feature = "sign")]
             Sign => "sign",
             FillNull { .. } => "fill_null",
             #[cfg(all(feature = "rolling_window", feature = "moment"))]
             RollingSkew { .. } => "rolling_skew",
             ShiftAndFill { .. } => "shift_and_fill",
             DropNans => "drop_nans",
@@ -454,18 +458,24 @@
             #[cfg(feature = "range")]
             Range(func) => func.into(),
 
             #[cfg(feature = "date_offset")]
             DateOffset(offset) => {
                 map_owned!(temporal::date_offset, offset)
             }
+
             #[cfg(feature = "trigonometry")]
             Trigonometry(trig_function) => {
                 map!(trigonometry::apply_trigonometric_function, trig_function)
             }
+            #[cfg(feature = "trigonometry")]
+            Atan2 => {
+                wrap!(trigonometry::apply_arctan2)
+            }
+
             #[cfg(feature = "sign")]
             Sign => {
                 map!(sign::sign)
             }
             FillNull { super_type } => {
                 map_as_slice!(fill_null::fill_null, &super_type)
             }
@@ -695,15 +705,14 @@
                 map!(binary::starts_with, &sub)
             }
         }
     }
 }
 
 #[cfg(feature = "temporal")]
-#[allow(deprecated)] // tz_localize
 impl From<TemporalFunction> for SpecialEq<Arc<dyn SeriesUdf>> {
     fn from(func: TemporalFunction) -> Self {
         use TemporalFunction::*;
         match func {
             Year => map!(datetime::year),
             IsLeapYear => map!(datetime::is_leap_year),
             IsoYear => map!(datetime::iso_year),
@@ -732,45 +741,68 @@
             MonthEnd => map!(datetime::month_end),
             #[cfg(feature = "timezones")]
             BaseUtcOffset => map!(datetime::base_utc_offset),
             #[cfg(feature = "timezones")]
             DSTOffset => map!(datetime::dst_offset),
             Round(every, offset) => map!(datetime::round, &every, &offset),
             #[cfg(feature = "timezones")]
-            CastTimezone(tz, use_earliest) => {
-                map!(datetime::replace_timezone, tz.as_deref(), use_earliest)
+            ReplaceTimeZone(tz, use_earliest) => {
+                map!(dispatch::replace_time_zone, tz.as_deref(), use_earliest)
             }
-            #[cfg(feature = "timezones")]
-            TzLocalize(tz) => map!(datetime::tz_localize, &tz),
             Combine(tu) => map_as_slice!(temporal::combine, tu),
             DateRange {
                 every,
                 closed,
                 time_unit,
-                tz,
+                time_zone,
             } => {
                 map_as_slice!(
                     temporal::temporal_range_dispatch,
                     "date",
                     every,
                     closed,
                     time_unit,
-                    tz.clone()
+                    time_zone.clone()
+                )
+            }
+            DateRanges {
+                every,
+                closed,
+                time_unit,
+                time_zone,
+            } => {
+                map_as_slice!(
+                    temporal::temporal_range_dispatch,
+                    "date_range",
+                    every,
+                    closed,
+                    time_unit,
+                    time_zone.clone()
                 )
             }
             TimeRange { every, closed } => {
                 map_as_slice!(
                     temporal::temporal_range_dispatch,
                     "time",
                     every,
                     closed,
                     None,
                     None
                 )
             }
+            TimeRanges { every, closed } => {
+                map_as_slice!(
+                    temporal::temporal_range_dispatch,
+                    "time_range",
+                    every,
+                    closed,
+                    None,
+                    None
+                )
+            }
         }
     }
 }
 
 #[cfg(feature = "range")]
 impl From<RangeFunction> for SpecialEq<Arc<dyn SeriesUdf>> {
     fn from(func: RangeFunction) -> Self {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/pow.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/pow.rs`

 * *Files 0% similar despite different names*

```diff
@@ -32,15 +32,15 @@
 {
     let dtype = T::get_dtype();
     let exponent = exponent.strict_cast(&dtype)?;
     let exponent = base.unpack_series_matching_type(&exponent).unwrap();
 
     if exponent.len() == 1 {
         let Some(exponent_value) = exponent.get(0) else {
-            return Ok(Some(Series::full_null(base.name(), base.len(), &dtype)))
+            return Ok(Some(Series::full_null(base.name(), base.len(), &dtype)));
         };
         let s = match exponent_value.to_f64().unwrap() {
             a if a == 1.0 => base.clone().into_series(),
             // specialized sqrt will ensure (-inf)^0.5 = NaN
             // and will likely be faster as well.
             a if a == 0.5 => base.apply(|v| v.sqrt()).into_series(),
             a if a.fract() == 0.0 && a < 10.0 && a > 1.0 => {
@@ -61,15 +61,15 @@
 
         Ok(Some(
             exponent.apply(|exp| Pow::pow(base, exp)).into_series(),
         ))
     } else {
         Ok(Some(
             base.into_iter()
-                .zip(exponent.into_iter())
+                .zip(exponent)
                 .map(|(opt_base, opt_exponent)| match (opt_base, opt_exponent) {
                     (Some(base), Some(exponent)) => Some(num::pow::Pow::pow(base, exponent)),
                     _ => None,
                 })
                 .collect_trusted::<ChunkedArray<T>>()
                 .into_series(),
         ))
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/random.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/random.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/range.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/range.rs`

 * *Files 0% similar despite different names*

```diff
@@ -132,15 +132,15 @@
     let mut builder = ListPrimitiveChunkedBuilder::<Int64Type>::new(
         output_name,
         start.len(),
         start.len() * 3,
         DataType::Int64,
     );
 
-    for (opt_start, opt_end) in start.into_iter().zip(end.into_iter()) {
+    for (opt_start, opt_end) in start.into_iter().zip(end) {
         match (opt_start, opt_end) {
             (Some(start_v), Some(end_v)) => match step {
                 1 => {
                     builder.append_iter_values(start_v..end_v);
                 }
                 2.. => {
                     builder.append_iter_values((start_v..end_v).step_by(step as usize));
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/schema.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/schema.rs`

 * *Files 1% similar despite different names*

```diff
@@ -54,31 +54,52 @@
                     MonthEnd => mapper.with_same_dtype().unwrap().dtype,
                     #[cfg(feature = "timezones")]
                     BaseUtcOffset => DataType::Duration(TimeUnit::Milliseconds),
                     #[cfg(feature = "timezones")]
                     DSTOffset => DataType::Duration(TimeUnit::Milliseconds),
                     Round(..) => mapper.with_same_dtype().unwrap().dtype,
                     #[cfg(feature = "timezones")]
-                    CastTimezone(tz, _use_earliest) => {
+                    ReplaceTimeZone(tz, _use_earliest) => {
                         return mapper.map_datetime_dtype_timezone(tz.as_ref())
                     }
-                    #[cfg(feature = "timezones")]
-                    TzLocalize(tz) => return mapper.map_datetime_dtype_timezone(Some(tz)),
                     DateRange {
                         every,
                         closed: _,
                         time_unit,
-                        tz,
+                        time_zone,
                     } => {
-                        // output dtype may change based on `every`, `tz`, and `time_unit`
-                        return mapper.map_to_date_range_dtype(every, time_unit, tz);
+                        // output dtype may change based on `every`, `time_unit`, and `time_zone`
+                        let inner_dtype =
+                            mapper.map_to_date_range_dtype(every, time_unit, time_zone)?;
+                        return Ok(Field::new("date", DataType::List(Box::new(inner_dtype))));
                     }
+                    DateRanges {
+                        every,
+                        closed: _,
+                        time_unit,
+                        time_zone,
+                    } => {
+                        // output dtype may change based on `every`, `time_unit`, and `time_zone`
+                        let inner_dtype =
+                            mapper.map_to_date_range_dtype(every, time_unit, time_zone)?;
+                        return Ok(Field::new(
+                            "date_range",
+                            DataType::List(Box::new(inner_dtype)),
+                        ));
+                    }
+
                     TimeRange { .. } => {
                         return Ok(Field::new("time", DataType::List(Box::new(DataType::Time))));
                     }
+                    TimeRanges { .. } => {
+                        return Ok(Field::new(
+                            "time_range",
+                            DataType::List(Box::new(DataType::Time)),
+                        ));
+                    }
                     Combine(tu) => match mapper.with_same_dtype().unwrap().dtype {
                         DataType::Datetime(_, tz) => DataType::Datetime(*tu, tz),
                         DataType::Date => DataType::Datetime(*tu, None),
                         dtype => {
                             polars_bail!(ComputeError: "expected Date or Datetime, got {}", dtype)
                         }
                     },
@@ -98,14 +119,16 @@
                 };
                 Ok(field)
             }
             #[cfg(feature = "date_offset")]
             DateOffset(_) => mapper.with_same_dtype(),
             #[cfg(feature = "trigonometry")]
             Trigonometry(_) => mapper.map_to_float_dtype(),
+            #[cfg(feature = "trigonometry")]
+            Atan2 => mapper.map_to_float_dtype(),
             #[cfg(feature = "sign")]
             Sign => mapper.with_dtype(DataType::Int64),
             FillNull { super_type, .. } => mapper.with_dtype(super_type.clone()),
             #[cfg(all(feature = "rolling_window", feature = "moment"))]
             RollingSkew { .. } => mapper.map_to_float_dtype(),
             ShiftAndFill { .. } => mapper.with_same_dtype(),
             DropNans => mapper.with_same_dtype(),
@@ -150,17 +173,23 @@
             #[cfg(feature = "dtype-struct")]
             StructExpr(s) => {
                 use polars_core::utils::slice_offsets;
                 use StructFunction::*;
                 match s {
                     FieldByIndex(index) => {
                         let (index, _) = slice_offsets(*index, 0, fields.len());
-                        fields.get(index).cloned().ok_or_else(
-                            || polars_err!(ComputeError: "index out of bounds in `struct.field`"),
-                        )
+                        if let DataType::Struct(flds) = &fields[0].dtype {
+                            flds.get(index).cloned().ok_or_else(
+                                || polars_err!(ComputeError: "index out of bounds in `struct.field`")
+                            )
+                        } else {
+                            polars_bail!(
+                                ComputeError: "expected struct dtype, got: `{}`", &fields[0].dtype
+                            )
+                        }
                     }
                     FieldByName(name) => {
                         if let DataType::Struct(flds) = &fields[0].dtype {
                             let fld = flds
                                 .iter()
                                 .find(|fld| fld.name() == name.as_ref())
                                 .ok_or_else(
@@ -340,15 +369,15 @@
 
     #[cfg(feature = "temporal")]
     pub(super) fn map_to_date_range_dtype(
         &self,
         every: &Duration,
         time_unit: &Option<TimeUnit>,
         tz: &Option<String>,
-    ) -> PolarsResult<Field> {
+    ) -> PolarsResult<DataType> {
         let inner_dtype = match (&self.map_to_supertype()?.dtype, time_unit, tz, every) {
             #[cfg(feature = "timezones")]
             (DataType::Datetime(tu, Some(field_tz)), time_unit, Some(tz), _) => {
                 if field_tz != tz {
                     polars_bail!(ComputeError: format!("Given time_zone is different from that of timezone aware datetimes. \
                     Given: '{}', got: '{}'.", tz, field_tz))
                 }
@@ -390,15 +419,15 @@
                     DataType::Datetime(TimeUnit::Microseconds, time_zone.clone())
                 }
             }
             (dtype, _, _, _) => {
                 polars_bail!(ComputeError: "expected Date or Datetime, got {}", dtype)
             }
         };
-        Ok(Field::new("date", DataType::List(Box::new(inner_dtype))))
+        Ok(inner_dtype)
     }
 
     /// Map the dtypes to the "supertype" of a list of lists.
     pub(super) fn map_to_list_supertype(&self) -> PolarsResult<Field> {
         self.try_map_dtypes(|dts| {
             let mut super_type_inner = None;
 
@@ -425,15 +454,15 @@
     /// Set the timezone of a datetime dtype.
     #[cfg(feature = "timezones")]
     pub(super) fn map_datetime_dtype_timezone(&self, tz: Option<&TimeZone>) -> PolarsResult<Field> {
         self.try_map_dtype(|dt| {
             if let DataType::Datetime(tu, _) = dt {
                 Ok(DataType::Datetime(*tu, tz.cloned()))
             } else {
-                polars_bail!(op = "cast-timezone", got = dt, expected = "Datetime");
+                polars_bail!(op = "replace-time-zone", got = dt, expected = "Datetime");
             }
         })
     }
 
     fn nested_sum_type(&self) -> PolarsResult<Field> {
         let mut first = self.fields[0].clone();
         use DataType::*;
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/shift_and_fill.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/shift_and_fill.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/shrink_type.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/shrink_type.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/sign.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/sign.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/strings.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/strings.rs`

 * *Files 1% similar despite different names*

```diff
@@ -183,16 +183,17 @@
 pub(super) fn lengths(s: &Series) -> PolarsResult<Series> {
     let ca = s.utf8()?;
     Ok(ca.str_lengths().into_series())
 }
 
 #[cfg(feature = "regex")]
 pub(super) fn contains(s: &[Series], literal: bool, strict: bool) -> PolarsResult<Series> {
-    let ca = &s[0].utf8()?;
-    let pat = &s[1].utf8()?;
+    // TODO! move to polars-ops
+    let ca = s[0].utf8()?;
+    let pat = s[1].utf8()?;
 
     let mut out: BooleanChunked = match pat.len() {
         1 => match pat.get(0) {
             Some(pat) => {
                 if literal {
                     ca.contains_literal(pat)?
                 } else {
@@ -200,82 +201,82 @@
                 }
             }
             None => BooleanChunked::full(ca.name(), false, ca.len()),
         },
         _ => {
             if literal {
                 ca.into_iter()
-                    .zip(pat.into_iter())
+                    .zip(pat)
                     .map(|(opt_src, opt_val)| match (opt_src, opt_val) {
                         (Some(src), Some(pat)) => src.contains(pat),
                         _ => false,
                     })
                     .collect_trusted()
             } else if strict {
                 ca.into_iter()
-                    .zip(pat.into_iter())
+                    .zip(pat)
                     .map(|(opt_src, opt_val)| match (opt_src, opt_val) {
                         (Some(src), Some(pat)) => {
                             let re = Regex::new(pat)?;
                             Ok(re.is_match(src))
                         }
                         _ => Ok(false),
                     })
                     .collect::<PolarsResult<_>>()?
             } else {
                 ca.into_iter()
-                    .zip(pat.into_iter())
+                    .zip(pat)
                     .map(|(opt_src, opt_val)| match (opt_src, opt_val) {
                         (Some(src), Some(pat)) => Regex::new(pat).ok().map(|re| re.is_match(src)),
                         _ => Some(false),
                     })
                     .collect_trusted()
             }
         }
     };
 
     out.rename(ca.name());
     Ok(out.into_series())
 }
 
 pub(super) fn ends_with(s: &[Series]) -> PolarsResult<Series> {
-    let ca = &s[0].utf8()?;
-    let sub = &s[1].utf8()?;
+    let ca = s[0].utf8()?;
+    let sub = s[1].utf8()?;
 
     let mut out: BooleanChunked = match sub.len() {
         1 => match sub.get(0) {
             Some(s) => ca.ends_with(s),
             None => BooleanChunked::full(ca.name(), false, ca.len()),
         },
         _ => ca
             .into_iter()
-            .zip(sub.into_iter())
+            .zip(sub)
             .map(|(opt_src, opt_val)| match (opt_src, opt_val) {
                 (Some(src), Some(val)) => src.ends_with(val),
                 _ => false,
             })
             .collect_trusted(),
     };
 
     out.rename(ca.name());
     Ok(out.into_series())
 }
 
 pub(super) fn starts_with(s: &[Series]) -> PolarsResult<Series> {
-    let ca = &s[0].utf8()?;
-    let sub = &s[1].utf8()?;
+    let ca = s[0].utf8()?;
+    let sub = s[1].utf8()?;
 
     let mut out: BooleanChunked = match sub.len() {
         1 => match sub.get(0) {
             Some(s) => ca.starts_with(s),
             None => BooleanChunked::full(ca.name(), false, ca.len()),
         },
         _ => ca
             .into_iter()
-            .zip(sub.into_iter())
+            .zip(sub)
             .map(|(opt_src, opt_val)| match (opt_src, opt_val) {
                 (Some(src), Some(val)) => src.starts_with(val),
                 _ => false,
             })
             .collect_trusted(),
     };
 
@@ -533,15 +534,15 @@
 #[allow(dead_code)]
 fn iter_and_replace<'a, F>(ca: &'a Utf8Chunked, val: &'a Utf8Chunked, f: F) -> Utf8Chunked
 where
     F: Fn(&'a str, &'a str) -> Cow<'a, str>,
 {
     let mut out: Utf8Chunked = ca
         .into_iter()
-        .zip(val.into_iter())
+        .zip(val)
         .map(|(opt_src, opt_val)| match (opt_src, opt_val) {
             (Some(src), Some(val)) => Some(f(src, val)),
             _ => None,
         })
         .collect_trusted();
 
     out.rename(ca.name());
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/struct_.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/struct_.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/function_expr/temporal.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/function_expr/temporal.rs`

 * *Files 6% similar despite different names*

```diff
@@ -75,19 +75,20 @@
     let date = date.cast(&DataType::Date)?;
     let datetime = date.cast(&DataType::Datetime(tu, None)).unwrap();
 
     let duration = time.cast(&DataType::Duration(tu))?;
     let result_naive = datetime + duration;
     match tz {
         #[cfg(feature = "timezones")]
-        Some(tz) => Ok(result_naive
-            .datetime()
-            .unwrap()
-            .replace_time_zone(Some(tz), None)?
-            .into()),
+        Some(tz) => Ok(polars_ops::prelude::replace_time_zone(
+            result_naive.datetime().unwrap(),
+            Some(tz),
+            None,
+        )?
+        .into()),
         _ => Ok(result_naive),
     }
 }
 
 pub(super) fn temporal_range_dispatch(
     s: &[Series],
     name: &str,
@@ -128,29 +129,30 @@
         (DataType::Datetime(_, tz), Some(tu)) => DataType::Datetime(tu, tz.clone()),
         _ => unreachable!(),
     };
 
     let (mut start, mut stop) = match dtype {
         #[cfg(feature = "timezones")]
         DataType::Datetime(_, Some(_)) => (
-            start
-                .cast(&dtype)?
-                .datetime()
-                .unwrap()
-                .replace_time_zone(None, None)?
-                .into_series()
-                .to_physical_repr()
-                .cast(&DataType::Int64)?,
-            stop.cast(&dtype)?
-                .datetime()
-                .unwrap()
-                .replace_time_zone(None, None)?
-                .into_series()
-                .to_physical_repr()
-                .cast(&DataType::Int64)?,
+            polars_ops::prelude::replace_time_zone(
+                start.cast(&dtype)?.datetime().unwrap(),
+                None,
+                None,
+            )?
+            .into_series()
+            .to_physical_repr()
+            .cast(&DataType::Int64)?,
+            polars_ops::prelude::replace_time_zone(
+                stop.cast(&dtype)?.datetime().unwrap(),
+                None,
+                None,
+            )?
+            .into_series()
+            .to_physical_repr()
+            .cast(&DataType::Int64)?,
         ),
         _ => (
             start
                 .cast(&dtype)?
                 .to_physical_repr()
                 .cast(&DataType::Int64)?,
             stop.cast(&dtype)?
@@ -180,15 +182,15 @@
         DataType::Date => {
             let mut builder = ListPrimitiveChunkedBuilder::<Int32Type>::new(
                 name,
                 start.len(),
                 start.len() * 5,
                 DataType::Int32,
             );
-            for (start, stop) in start.into_iter().zip(stop.into_iter()) {
+            for (start, stop) in start.into_iter().zip(stop) {
                 match (start, stop) {
                     (Some(start), Some(stop)) => {
                         let rng = date_range_impl(
                             "",
                             start,
                             stop,
                             every,
@@ -209,15 +211,15 @@
         DataType::Datetime(tu, ref tz) => {
             let mut builder = ListPrimitiveChunkedBuilder::<Int64Type>::new(
                 name,
                 start.len(),
                 start.len() * 5,
                 DataType::Int64,
             );
-            for (start, stop) in start.into_iter().zip(stop.into_iter()) {
+            for (start, stop) in start.into_iter().zip(stop) {
                 match (start, stop) {
                     (Some(start), Some(stop)) => {
                         let rng = date_range_impl("", start, stop, every, closed, tu, tz.as_ref())?;
                         builder.append_slice(rng.cont_slice().unwrap())
                     }
                     _ => builder.append_null(),
                 }
@@ -227,15 +229,15 @@
         DataType::Time => {
             let mut builder = ListPrimitiveChunkedBuilder::<Int64Type>::new(
                 name,
                 start.len(),
                 start.len() * 5,
                 DataType::Int64,
             );
-            for (start, stop) in start.into_iter().zip(stop.into_iter()) {
+            for (start, stop) in start.into_iter().zip(stop) {
                 match (start, stop) {
                     (Some(start), Some(stop)) => {
                         let rng = date_range_impl(
                             "",
                             start,
                             stop,
                             every,
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/functions/arity.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/functions/arity.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/functions/coerce.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/functions/coerce.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/functions/concat.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/functions/concat.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/functions/correlation.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/functions/correlation.rs`

 * *Files 4% similar despite different names*

```diff
@@ -68,16 +68,14 @@
             ..Default::default()
         },
     }
 }
 
 #[cfg(feature = "rolling_window")]
 pub fn rolling_corr(x: Expr, y: Expr, options: RollingCovOptions) -> Expr {
-    let x = x.cache();
-    let y = y.cache();
     // see: https://github.com/pandas-dev/pandas/blob/v1.5.1/pandas/core/window/rolling.py#L1780-L1804
     let rolling_options = RollingOptions {
         window_size: Duration::new(options.window_size as i64),
         min_periods: options.min_periods as usize,
         ..Default::default()
     };
 
@@ -92,26 +90,23 @@
         min_periods: 0,
         ..Default::default()
     };
     let ddof = options.ddof as f64;
     let count_x_y = (x + y)
         .is_not_null()
         .cast(DataType::Float64)
-        .rolling_sum(rolling_options_count)
-        .cache();
+        .rolling_sum(rolling_options_count);
     let numerator = (mean_x_y - mean_x * mean_y) * (count_x_y.clone() / (count_x_y - lit(ddof)));
     let denominator = (var_x * var_y).pow(lit(0.5));
 
     numerator / denominator
 }
 
 #[cfg(feature = "rolling_window")]
 pub fn rolling_cov(x: Expr, y: Expr, options: RollingCovOptions) -> Expr {
-    let x = x.cache();
-    let y = y.cache();
     // see: https://github.com/pandas-dev/pandas/blob/91111fd99898d9dcaa6bf6bedb662db4108da6e6/pandas/core/window/rolling.py#L1700
     let rolling_options = RollingOptions {
         window_size: Duration::new(options.window_size as i64),
         min_periods: options.min_periods as usize,
         ..Default::default()
     };
 
@@ -122,14 +117,13 @@
         window_size: Duration::new(options.window_size as i64),
         min_periods: 0,
         ..Default::default()
     };
     let count_x_y = (x + y)
         .is_not_null()
         .cast(DataType::Float64)
-        .rolling_sum(rolling_options_count)
-        .cache();
+        .rolling_sum(rolling_options_count);
 
     let ddof = options.ddof as f64;
 
     (mean_x_y - mean_x * mean_y) * (count_x_y.clone() / (count_x_y - lit(ddof)))
 }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/functions/horizontal.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/functions/horizontal.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/functions/index.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/functions/index.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/functions/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/functions/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/functions/range.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/functions/range.rs`

 * *Files 16% similar despite different names*

```diff
@@ -78,50 +78,96 @@
 #[cfg(feature = "temporal")]
 pub fn date_range(
     start: Expr,
     end: Expr,
     every: Duration,
     closed: ClosedWindow,
     time_unit: Option<TimeUnit>,
-    tz: Option<TimeZone>,
+    time_zone: Option<TimeZone>,
 ) -> Expr {
     let input = vec![start, end];
 
     Expr::Function {
         input,
         function: FunctionExpr::TemporalExpr(TemporalFunction::DateRange {
             every,
             closed,
             time_unit,
-            tz,
+            time_zone,
         }),
         options: FunctionOptions {
             collect_groups: ApplyOptions::ApplyGroups,
             cast_to_supertypes: true,
             allow_rename: true,
             ..Default::default()
         },
     }
 }
 
-/// Create a time range from a `start` and `stop` expression.
+/// Create a column of date ranges from a `start` and `stop` expression.
+#[cfg(feature = "temporal")]
+pub fn date_ranges(
+    start: Expr,
+    end: Expr,
+    every: Duration,
+    closed: ClosedWindow,
+    time_unit: Option<TimeUnit>,
+    time_zone: Option<TimeZone>,
+) -> Expr {
+    let input = vec![start, end];
+
+    Expr::Function {
+        input,
+        function: FunctionExpr::TemporalExpr(TemporalFunction::DateRanges {
+            every,
+            closed,
+            time_unit,
+            time_zone,
+        }),
+        options: FunctionOptions {
+            collect_groups: ApplyOptions::ApplyGroups,
+            cast_to_supertypes: true,
+            allow_rename: true,
+            ..Default::default()
+        },
+    }
+}
+
+/// Generate a time range.
 #[cfg(feature = "temporal")]
 pub fn time_range(start: Expr, end: Expr, every: Duration, closed: ClosedWindow) -> Expr {
     let input = vec![start, end];
 
     Expr::Function {
         input,
         function: FunctionExpr::TemporalExpr(TemporalFunction::TimeRange { every, closed }),
         options: FunctionOptions {
             collect_groups: ApplyOptions::ApplyGroups,
             cast_to_supertypes: false,
             allow_rename: true,
             ..Default::default()
         },
     }
+}
+
+/// Create a column of time ranges from a `start` and `stop` expression.
+#[cfg(feature = "temporal")]
+pub fn time_ranges(start: Expr, end: Expr, every: Duration, closed: ClosedWindow) -> Expr {
+    let input = vec![start, end];
+
+    Expr::Function {
+        input,
+        function: FunctionExpr::TemporalExpr(TemporalFunction::TimeRanges { every, closed }),
+        options: FunctionOptions {
+            collect_groups: ApplyOptions::ApplyGroups,
+            cast_to_supertypes: false,
+            allow_rename: true,
+            ..Default::default()
+        },
+    }
 }
 
 /// Create a column of length `n` containing `n` copies of the literal `value`. Generally you won't need this function,
 /// as `lit(value)` already represents a column containing only `value` whose length is automatically set to the correct
 /// number of rows.
 pub fn repeat<E: Into<Expr>>(value: E, n: Expr) -> Expr {
     let function = |s: Series, n: Series| {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/functions/selectors.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/functions/selectors.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/functions/syntactic_sugar.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/functions/syntactic_sugar.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/functions/temporal.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/functions/temporal.rs`

 * *Files 2% similar despite different names*

```diff
@@ -14,14 +14,15 @@
 ///
 /// Construct a `DatetimeArgs` with `DatetimeArgs::new(y, m, d)`. This will set the other time units to `lit(0)`. You
 /// can then set the other fields with the `with_*` methods, or use `with_hms` to set `hour`, `minute`, and `second` all
 /// at once.
 ///
 /// # Examples
 /// ```
+/// use polars_plan::prelude::*;
 /// // construct a DatetimeArgs set to July 20, 1969 at 20:17
 /// let args = DatetimeArgs::new(lit(1969), lit(7), lit(20)).with_hms(lit(20), lit(17), lit(0));
 /// // or
 /// let args = DatetimeArgs::new(lit(1969), lit(7), lit(20)).with_hour(lit(20)).with_minute(lit(17));
 ///
 /// // construct a DatetimeArgs using existing columns
 /// let args = DatetimeArgs::new(lit(2023), col("month"), col("day"));
@@ -133,20 +134,20 @@
         if microsecond.len() < max_len {
             microsecond = microsecond.new_from_index(0, max_len);
         }
         let microsecond = microsecond.u32()?;
 
         let ca: Int64Chunked = year
             .into_iter()
-            .zip(month.into_iter())
-            .zip(day.into_iter())
-            .zip(hour.into_iter())
-            .zip(minute.into_iter())
-            .zip(second.into_iter())
-            .zip(microsecond.into_iter())
+            .zip(month)
+            .zip(day)
+            .zip(hour)
+            .zip(minute)
+            .zip(second)
+            .zip(microsecond)
             .map(|((((((y, m), d), h), mnt), s), us)| {
                 if let (Some(y), Some(m), Some(d), Some(h), Some(mnt), Some(s), Some(us)) =
                     (y, m, d, h, mnt, s, us)
                 {
                     NaiveDate::from_ymd_opt(y, m, d)
                         .and_then(|nd| nd.and_hms_micro_opt(h, mnt, s, us))
                         .map(|ndt| ndt.timestamp_micros())
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/list.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/list.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/meta.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/meta.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/mod.rs`

 * *Files 1% similar despite different names*

```diff
@@ -1128,18 +1128,16 @@
             GetOutput::same_type(),
         )
         .with_fmt("mode")
     }
 
     /// Keep the original root name
     ///
-    /// ```
-    /// use polars_core::prelude::*;
-    /// use polars_lazy::prelude::*;
-    ///
+    /// ```rust,no_run
+    /// # use polars_plan::prelude::*;
     /// fn example(df: LazyFrame) -> LazyFrame {
     ///     df.select([
     /// // even thought the alias yields a different column name,
     /// // `keep_name` will make sure that the original column name is used
     ///         col("*").alias("foo").keep_name()
     /// ])
     /// }
@@ -1765,28 +1763,14 @@
     /// # Warning
     /// This can lead to incorrect results if this `Series` is not sorted!!
     /// Use with care!
     pub fn set_sorted_flag(self, sorted: IsSorted) -> Expr {
         self.apply_private(FunctionExpr::SetSortedFlag(sorted))
     }
 
-    /// Cache this expression, so that it is executed only once per context.
-    pub fn cache(self) -> Expr {
-        match &self {
-            // don't cache cheap no-ops
-            Expr::Column(_) => self,
-            Expr::Alias(input, _) if matches!(**input, Expr::Column(_)) => self,
-            _ => {
-                let input = Box::new(self);
-                let id = input.as_ref() as *const Expr as usize;
-                Self::Cache { input, id }
-            }
-        }
-    }
-
     #[cfg(feature = "row_hash")]
     /// Compute the hash of every element
     pub fn hash(self, k0: u64, k1: u64, k2: u64, k3: u64) -> Expr {
         self.map_private(FunctionExpr::Hash(k0, k1, k2, k3))
     }
 
     pub fn to_physical(self) -> Expr {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/options.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/options.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/python_udf.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/python_udf.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/random.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/random.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/selector.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/selector.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/string.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/string.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/dsl/struct_.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/dsl/struct_.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/frame/opt_state.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/frame/opt_state.rs`

 * *Files 10% similar despite different names*

```diff
@@ -4,30 +4,34 @@
     pub projection_pushdown: bool,
     pub predicate_pushdown: bool,
     pub type_coercion: bool,
     pub simplify_expr: bool,
     pub file_caching: bool,
     pub slice_pushdown: bool,
     #[cfg(feature = "cse")]
-    pub common_subplan_elimination: bool,
+    pub comm_subplan_elim: bool,
+    #[cfg(feature = "cse")]
+    pub comm_subexpr_elim: bool,
     pub streaming: bool,
 }
 
 impl Default for OptState {
     fn default() -> Self {
         OptState {
             projection_pushdown: true,
             predicate_pushdown: true,
             type_coercion: true,
             simplify_expr: true,
             slice_pushdown: true,
             // will be toggled by a scan operation such as csv scan or parquet scan
             file_caching: false,
             #[cfg(feature = "cse")]
-            common_subplan_elimination: true,
+            comm_subplan_elim: true,
+            #[cfg(feature = "cse")]
+            comm_subexpr_elim: false,
             streaming: false,
         }
     }
 }
 
 /// AllowedOptimizations
 pub type AllowedOptimizations = OptState;
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/aexpr/schema.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/aexpr/schema.rs`

 * *Files 1% similar despite different names*

```diff
@@ -203,15 +203,14 @@
                     .iter()
                     // default context because `col()` would return a list in aggregation context
                     .map(|node| arena.get(*node).to_field(schema, Context::Default, arena))
                     .collect::<PolarsResult<Vec<_>>>()?;
                 function.get_field(schema, ctxt, &fields)
             }
             Slice { input, .. } => arena.get(*input).to_field(schema, ctxt, arena),
-            Cache { input, .. } => arena.get(*input).to_field(schema, ctxt, arena),
             Wildcard => panic!("should be no wildcard at this point"),
             Nth(_) => panic!("should be no nth at this point"),
         }
     }
 }
 
 fn get_arithmetic_field(
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/alp.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/builder.rs`

 * *Files 23% similar despite different names*

```diff
@@ -1,694 +1,833 @@
-use std::borrow::Cow;
-use std::path::PathBuf;
-use std::sync::Arc;
+#[cfg(feature = "csv")]
+use std::io::{Read, Seek};
 
+#[cfg(feature = "parquet")]
+use polars_core::cloud::CloudOptions;
+use polars_core::frame::explode::MeltArgs;
 use polars_core::prelude::*;
-use polars_utils::arena::{Arena, Node};
+#[cfg(feature = "ipc")]
+use polars_io::ipc::IpcReader;
+#[cfg(all(feature = "parquet", feature = "async"))]
+use polars_io::parquet::ParquetAsyncReader;
+#[cfg(feature = "parquet")]
+use polars_io::parquet::ParquetReader;
+#[cfg(any(
+    feature = "parquet",
+    feature = "parquet_async",
+    feature = "csv",
+    feature = "ipc"
+))]
+use polars_io::RowCount;
+#[cfg(feature = "csv")]
+use polars_io::{
+    csv::utils::{get_reader_bytes, infer_file_schema, is_compressed},
+    csv::CsvEncoding,
+    csv::NullValues,
+};
 
+use super::builder_functions::*;
 use crate::logical_plan::functions::FunctionNode;
+use crate::logical_plan::projection::{is_regex_projection, rewrite_projections};
 use crate::logical_plan::schema::{det_join_schema, FileInfo};
-use crate::logical_plan::FileScan;
+#[cfg(feature = "python")]
+use crate::prelude::python_udf::PythonFunction;
 use crate::prelude::*;
-use crate::utils::{aexprs_to_schema, PushNode};
+use crate::utils;
 
-/// ALogicalPlan is a representation of LogicalPlan with Nodes which are allocated in an Arena
-#[derive(Clone, Debug)]
-pub enum ALogicalPlan {
-    AnonymousScan {
-        function: Arc<dyn AnonymousScan>,
-        file_info: FileInfo,
-        output_schema: Option<SchemaRef>,
-        predicate: Option<Node>,
-        options: AnonymousScanOptions,
-    },
-    #[cfg(feature = "python")]
-    PythonScan {
-        options: PythonOptions,
-        predicate: Option<Node>,
-    },
-    Slice {
-        input: Node,
-        offset: i64,
-        len: IdxSize,
-    },
-    Selection {
-        input: Node,
-        predicate: Node,
-    },
-    Scan {
-        path: PathBuf,
-        file_info: FileInfo,
-        predicate: Option<Node>,
-        /// schema of the projected file
-        output_schema: Option<SchemaRef>,
-        scan_type: FileScan,
-        /// generic options that can be used for all file types.
-        file_options: FileScanOptions,
-    },
-    DataFrameScan {
-        df: Arc<DataFrame>,
-        schema: SchemaRef,
-        // schema of the projected file
-        output_schema: Option<SchemaRef>,
-        projection: Option<Arc<Vec<String>>>,
-        selection: Option<Node>,
-    },
-    Projection {
-        input: Node,
-        expr: Vec<Node>,
-        schema: SchemaRef,
-    },
-    LocalProjection {
-        expr: Vec<Node>,
-        input: Node,
-        schema: SchemaRef,
-    },
-    Sort {
-        input: Node,
-        by_column: Vec<Node>,
-        args: SortArguments,
-    },
-    Cache {
-        input: Node,
-        id: usize,
-        count: usize,
-    },
-    Aggregate {
-        input: Node,
-        keys: Vec<Node>,
-        aggs: Vec<Node>,
-        schema: SchemaRef,
-        apply: Option<Arc<dyn DataFrameUdf>>,
-        maintain_order: bool,
-        options: GroupbyOptions,
-    },
-    Join {
-        input_left: Node,
-        input_right: Node,
-        schema: SchemaRef,
-        left_on: Vec<Node>,
-        right_on: Vec<Node>,
-        options: JoinOptions,
-    },
-    HStack {
-        input: Node,
-        exprs: Vec<Node>,
-        schema: SchemaRef,
-    },
-    Distinct {
-        input: Node,
-        options: DistinctOptions,
-    },
-    MapFunction {
-        input: Node,
-        function: FunctionNode,
-    },
-    Union {
-        inputs: Vec<Node>,
-        options: UnionOptions,
-    },
-    ExtContext {
-        input: Node,
-        contexts: Vec<Node>,
-        schema: SchemaRef,
-    },
-    FileSink {
-        input: Node,
-        payload: FileSinkOptions,
-    },
+pub(crate) fn prepare_projection(
+    exprs: Vec<Expr>,
+    schema: &Schema,
+) -> PolarsResult<(Vec<Expr>, Schema)> {
+    let exprs = rewrite_projections(exprs, schema, &[])?;
+    let schema = utils::expressions_to_schema(&exprs, schema, Context::Default)?;
+    Ok((exprs, schema))
 }
 
-impl Default for ALogicalPlan {
-    fn default() -> Self {
-        // the lp is should not be valid. By choosing a max value we'll likely panic indicating
-        // a programming error early.
-        ALogicalPlan::Selection {
-            input: Node(usize::MAX),
-            predicate: Node(usize::MAX),
-        }
+pub struct LogicalPlanBuilder(pub LogicalPlan);
+
+impl From<LogicalPlan> for LogicalPlanBuilder {
+    fn from(lp: LogicalPlan) -> Self {
+        LogicalPlanBuilder(lp)
     }
 }
 
-impl ALogicalPlan {
-    /// Get the schema of the logical plan node but don't take projections into account at the scan
-    /// level. This ensures we can apply the predicate
-    pub(crate) fn scan_schema(&self) -> &SchemaRef {
-        use ALogicalPlan::*;
-        match self {
-            Scan { file_info, .. } => &file_info.schema,
-            #[cfg(feature = "python")]
-            PythonScan { options, .. } => &options.schema,
-            AnonymousScan { file_info, .. } => &file_info.schema,
-            _ => unreachable!(),
+fn format_err(msg: &str, input: &LogicalPlan) -> String {
+    format!("{msg}\n\nError originated just after this operation:\n{input:?}")
+}
+
+/// Returns every error or msg: &str as `ComputeError`.
+/// It also shows the logical plan node where the error
+/// originated.
+macro_rules! raise_err {
+    ($err:expr, $input:expr, $convert:ident) => {{
+        let format_err_outer = |msg: &str| format_err(msg, &$input);
+
+        let err = $err.wrap_msg(&format_err_outer);
+
+        LogicalPlan::Error {
+            input: Box::new($input.clone()),
+            err: err.into(),
         }
-    }
+        .$convert()
+    }};
+}
 
-    pub fn name(&self) -> &'static str {
-        use ALogicalPlan::*;
-        match self {
-            Scan { scan_type, .. } => scan_type.into(),
-            AnonymousScan { .. } => "anonymous_scan",
-            #[cfg(feature = "python")]
-            PythonScan { .. } => "python_scan",
-            Slice { .. } => "slice",
-            Selection { .. } => "selection",
-            DataFrameScan { .. } => "df",
-            Projection { .. } => "projection",
-            LocalProjection { .. } => "local_projection",
-            Sort { .. } => "sort",
-            Cache { .. } => "cache",
-            Aggregate { .. } => "aggregate",
-            Join { .. } => "join",
-            HStack { .. } => "hstack",
-            Distinct { .. } => "distinct",
-            MapFunction { .. } => "map_function",
-            Union { .. } => "union",
-            ExtContext { .. } => "ext_context",
-            FileSink { .. } => "file_sink",
+macro_rules! try_delayed {
+    ($fallible:expr, $input:expr, $convert:ident) => {
+        match $fallible {
+            Ok(success) => success,
+            Err(err) => return raise_err!(err, $input, $convert),
         }
-    }
+    };
+}
 
-    /// Get the schema of the logical plan node.
-    pub fn schema<'a>(&'a self, arena: &'a Arena<ALogicalPlan>) -> Cow<'a, SchemaRef> {
-        use ALogicalPlan::*;
-        let schema = match self {
-            #[cfg(feature = "python")]
-            PythonScan { options, .. } => &options.schema,
-            Union { inputs, .. } => return arena.get(inputs[0]).schema(arena),
-            Cache { input, .. } => return arena.get(*input).schema(arena),
-            Sort { input, .. } => return arena.get(*input).schema(arena),
-            Scan {
-                output_schema,
-                file_info,
-                ..
-            } => output_schema.as_ref().unwrap_or(&file_info.schema),
-            DataFrameScan {
+impl LogicalPlanBuilder {
+    pub fn anonymous_scan(
+        function: Arc<dyn AnonymousScan>,
+        schema: Option<Schema>,
+        infer_schema_length: Option<usize>,
+        skip_rows: Option<usize>,
+        n_rows: Option<usize>,
+        name: &'static str,
+    ) -> PolarsResult<Self> {
+        let schema = Arc::new(match schema {
+            Some(s) => s,
+            None => function.schema(infer_schema_length)?,
+        });
+
+        let file_info = FileInfo {
+            schema: schema.clone(),
+            row_estimation: (n_rows, n_rows.unwrap_or(usize::MAX)),
+        };
+        Ok(LogicalPlan::AnonymousScan {
+            function,
+            file_info,
+            predicate: None,
+            options: Arc::new(AnonymousScanOptions {
+                fmt_str: name,
                 schema,
-                output_schema,
-                ..
-            } => output_schema.as_ref().unwrap_or(schema),
-            AnonymousScan {
-                file_info,
-                output_schema,
-                ..
-            } => output_schema.as_ref().unwrap_or(&file_info.schema),
-            Selection { input, .. } => return arena.get(*input).schema(arena),
-            Projection { schema, .. } => schema,
-            LocalProjection { schema, .. } => schema,
-            Aggregate { schema, .. } => schema,
-            Join { schema, .. } => schema,
-            HStack { schema, .. } => schema,
-            Distinct { input, .. } | FileSink { input, .. } => {
-                return arena.get(*input).schema(arena)
-            }
-            Slice { input, .. } => return arena.get(*input).schema(arena),
-            MapFunction { input, function } => {
-                let input_schema = arena.get(*input).schema(arena);
-
-                return match input_schema {
-                    Cow::Owned(schema) => {
-                        Cow::Owned(function.schema(&schema).unwrap().into_owned())
-                    }
-                    Cow::Borrowed(schema) => function.schema(schema).unwrap(),
-                };
+                skip_rows,
+                n_rows,
+                output_schema: None,
+                with_columns: None,
+                predicate: None,
+            }),
+        }
+        .into())
+    }
+
+    #[cfg(any(feature = "parquet", feature = "parquet_async"))]
+    #[allow(clippy::too_many_arguments)]
+    pub fn scan_parquet<P: Into<std::path::PathBuf>>(
+        path: P,
+        n_rows: Option<usize>,
+        cache: bool,
+        parallel: polars_io::parquet::ParallelStrategy,
+        row_count: Option<RowCount>,
+        rechunk: bool,
+        low_memory: bool,
+        cloud_options: Option<CloudOptions>,
+        use_statistics: bool,
+    ) -> PolarsResult<Self> {
+        use polars_io::{is_cloud_url, SerReader as _};
+
+        let path = path.into();
+        let (mut schema, num_rows) = if is_cloud_url(&path) {
+            #[cfg(not(feature = "async"))]
+            panic!(
+                "One or more of the cloud storage features ('aws', 'gcp', ...) must be enabled."
+            );
+
+            #[cfg(feature = "async")]
+            {
+                let uri = path.to_string_lossy();
+                ParquetAsyncReader::file_info(&uri, cloud_options.as_ref())?
             }
-            ExtContext { schema, .. } => schema,
+        } else {
+            let file = polars_utils::open_file(&path)?;
+            let mut reader = ParquetReader::new(file);
+            (reader.schema()?, reader.num_rows()?)
         };
-        Cow::Borrowed(schema)
-    }
-}
 
-impl ALogicalPlan {
-    /// Takes the expressions of an LP node and the inputs of that node and reconstruct
-    pub fn with_exprs_and_input(
-        &self,
-        mut exprs: Vec<Node>,
-        mut inputs: Vec<Node>,
-    ) -> ALogicalPlan {
-        use ALogicalPlan::*;
-
-        match self {
-            #[cfg(feature = "python")]
-            PythonScan { options, predicate } => PythonScan {
-                options: options.clone(),
-                predicate: *predicate,
-            },
-            Union { options, .. } => Union {
-                inputs,
-                options: *options,
-            },
-            Slice { offset, len, .. } => Slice {
-                input: inputs[0],
-                offset: *offset,
-                len: *len,
-            },
-            Selection { .. } => Selection {
-                input: inputs[0],
-                predicate: exprs[0],
-            },
-            LocalProjection { schema, .. } => LocalProjection {
-                input: inputs[0],
-                expr: exprs,
-                schema: schema.clone(),
-            },
-            Projection { schema, .. } => Projection {
-                input: inputs[0],
-                expr: exprs,
-                schema: schema.clone(),
-            },
-            Aggregate {
-                keys,
-                schema,
-                apply,
-                maintain_order,
-                options: dynamic_options,
-                ..
-            } => Aggregate {
-                input: inputs[0],
-                keys: exprs[..keys.len()].to_vec(),
-                aggs: exprs[keys.len()..].to_vec(),
-                schema: schema.clone(),
-                apply: apply.clone(),
-                maintain_order: *maintain_order,
-                options: dynamic_options.clone(),
-            },
-            Join {
-                schema,
-                left_on,
-                options,
-                ..
-            } => Join {
-                input_left: inputs[0],
-                input_right: inputs[1],
-                schema: schema.clone(),
-                left_on: exprs[..left_on.len()].to_vec(),
-                right_on: exprs[left_on.len()..].to_vec(),
-                options: options.clone(),
-            },
-            Sort {
-                by_column, args, ..
-            } => Sort {
-                input: inputs[0],
-                by_column: by_column.clone(),
-                args: args.clone(),
-            },
-            Cache { id, count, .. } => Cache {
-                input: inputs[0],
-                id: *id,
-                count: *count,
-            },
-            Distinct { options, .. } => Distinct {
-                input: inputs[0],
-                options: options.clone(),
-            },
-            HStack { schema, .. } => HStack {
-                input: inputs[0],
-                exprs,
-                schema: schema.clone(),
-            },
-            Scan {
-                path,
-                file_info,
-                output_schema,
-                predicate,
-                file_options: options,
-                scan_type,
-            } => {
-                let mut new_predicate = None;
-                if predicate.is_some() {
-                    new_predicate = exprs.pop()
-                }
-                Scan {
-                    path: path.clone(),
-                    file_info: file_info.clone(),
-                    output_schema: output_schema.clone(),
-                    file_options: options.clone(),
-                    predicate: new_predicate,
-                    scan_type: scan_type.clone(),
-                }
-            }
-            DataFrameScan {
-                df,
-                schema,
-                output_schema,
-                projection,
-                selection,
-            } => {
-                let mut new_selection = None;
-                if selection.is_some() {
-                    new_selection = exprs.pop()
-                }
+        if let Some(rc) = &row_count {
+            let _ = schema.insert_at_index(0, rc.name.as_str().into(), IDX_DTYPE);
+        }
 
-                DataFrameScan {
-                    df: df.clone(),
-                    schema: schema.clone(),
-                    output_schema: output_schema.clone(),
-                    projection: projection.clone(),
-                    selection: new_selection,
-                }
-            }
-            AnonymousScan {
-                function,
-                file_info,
-                output_schema,
-                predicate,
-                options,
-            } => {
-                let mut new_predicate = None;
-                if predicate.is_some() {
-                    new_predicate = exprs.pop()
-                }
+        let file_info = FileInfo {
+            schema: Arc::new(schema),
+            row_estimation: (Some(num_rows), num_rows),
+        };
 
-                AnonymousScan {
-                    function: function.clone(),
-                    file_info: file_info.clone(),
-                    output_schema: output_schema.clone(),
-                    predicate: new_predicate,
-                    options: options.clone(),
-                }
-            }
-            MapFunction { function, .. } => MapFunction {
-                input: inputs[0],
-                function: function.clone(),
-            },
-            ExtContext { schema, .. } => ExtContext {
-                input: inputs.pop().unwrap(),
-                contexts: inputs,
-                schema: schema.clone(),
-            },
-            FileSink { payload, .. } => FileSink {
-                input: inputs.pop().unwrap(),
-                payload: payload.clone(),
-            },
+        let options = FileScanOptions {
+            with_columns: None,
+            cache,
+            n_rows,
+            rechunk,
+            row_count,
+            file_counter: Default::default(),
+        };
+        Ok(LogicalPlan::Scan {
+            path,
+            file_info,
+            file_options: options,
+            predicate: None,
+            scan_type: FileScan::Parquet {
+                options: ParquetOptions {
+                    parallel,
+                    low_memory,
+                    use_statistics,
+                },
+                cloud_options,
+            },
+        }
+        .into())
+    }
+
+    #[cfg(feature = "ipc")]
+    pub fn scan_ipc<P: Into<std::path::PathBuf>>(
+        path: P,
+        options: IpcScanOptions,
+        n_rows: Option<usize>,
+        cache: bool,
+        row_count: Option<RowCount>,
+        rechunk: bool,
+    ) -> PolarsResult<Self> {
+        use polars_io::SerReader as _;
+
+        let path = path.into();
+        let file = polars_utils::open_file(&path)?;
+        let mut reader = IpcReader::new(file);
+
+        let mut schema = reader.schema()?;
+        if let Some(rc) = &row_count {
+            let _ = schema.insert_at_index(0, rc.name.as_str().into(), IDX_DTYPE);
         }
-    }
+        let schema = Arc::new(schema);
 
-    /// Copy the exprs in this LP node to an existing container.
-    pub fn copy_exprs(&self, container: &mut Vec<Node>) {
-        use ALogicalPlan::*;
-        match self {
-            Slice { .. } | Cache { .. } | Distinct { .. } | Union { .. } | MapFunction { .. } => {}
-            Sort { by_column, .. } => container.extend_from_slice(by_column),
-            Selection { predicate, .. } => container.push(*predicate),
-            Projection { expr, .. } => container.extend_from_slice(expr),
-            LocalProjection { expr, .. } => container.extend_from_slice(expr),
-            Aggregate { keys, aggs, .. } => {
-                let iter = keys.iter().copied().chain(aggs.iter().copied());
-                container.extend(iter)
-            }
-            Join {
-                left_on, right_on, ..
-            } => {
-                let iter = left_on.iter().copied().chain(right_on.iter().copied());
-                container.extend(iter)
-            }
-            HStack { exprs, .. } => container.extend_from_slice(exprs),
-            Scan { predicate, .. } => {
-                if let Some(node) = predicate {
-                    container.push(*node)
-                }
-            }
-            DataFrameScan { selection, .. } => {
-                if let Some(expr) = selection {
-                    container.push(*expr)
-                }
-            }
-            #[cfg(feature = "python")]
-            PythonScan { .. } => {}
-            AnonymousScan { predicate, .. } => {
-                if let Some(node) = predicate {
-                    container.push(*node)
-                }
-            }
-            ExtContext { .. } | FileSink { .. } => {}
-        }
-    }
+        let num_rows = reader._num_rows()?;
+        let file_info = FileInfo {
+            schema,
+            row_estimation: (None, num_rows),
+        };
 
-    /// Get expressions in this node.
-    pub fn get_exprs(&self) -> Vec<Node> {
-        let mut exprs = Vec::new();
-        self.copy_exprs(&mut exprs);
-        exprs
-    }
+        let file_options = FileScanOptions {
+            with_columns: None,
+            cache,
+            n_rows,
+            rechunk,
+            row_count,
+            file_counter: Default::default(),
+        };
+        Ok(LogicalPlan::Scan {
+            path,
+            file_info,
+            file_options,
+            predicate: None,
+            scan_type: FileScan::Ipc { options },
+        }
+        .into())
+    }
+
+    #[allow(clippy::too_many_arguments)]
+    #[cfg(feature = "csv")]
+    pub fn scan_csv<P: Into<std::path::PathBuf>>(
+        path: P,
+        delimiter: u8,
+        has_header: bool,
+        ignore_errors: bool,
+        mut skip_rows: usize,
+        n_rows: Option<usize>,
+        cache: bool,
+        mut schema: Option<Arc<Schema>>,
+        schema_overwrite: Option<&Schema>,
+        low_memory: bool,
+        comment_char: Option<u8>,
+        quote_char: Option<u8>,
+        eol_char: u8,
+        null_values: Option<NullValues>,
+        infer_schema_length: Option<usize>,
+        rechunk: bool,
+        skip_rows_after_header: usize,
+        encoding: CsvEncoding,
+        row_count: Option<RowCount>,
+        try_parse_dates: bool,
+    ) -> PolarsResult<Self> {
+        let path = path.into();
+        let mut file = polars_utils::open_file(&path).map_err(|e| {
+            let path = path.to_string_lossy();
+            if path.len() > 88 {
+                let path: String = path.chars().skip(path.len() - 88).collect();
+                polars_err!(ComputeError: "error open file: ...{}, {}", path, e)
+            } else {
+                polars_err!(ComputeError: "error open file: {}, {}", path, e)
+            }
+        })?;
+        let mut magic_nr = [0u8; 2];
+        file.read_exact(&mut magic_nr)
+            .map_err(|_| polars_err!(NoData: "empty csv"))?;
+        polars_ensure!(
+            !is_compressed(&magic_nr),
+            ComputeError: "cannot scan compressed csv; use `read_csv` for compressed data",
+        );
+        file.rewind()?;
+        let reader_bytes = get_reader_bytes(&mut file).expect("could not mmap file");
 
-    /// Push inputs of the LP in of this node to an existing container.
-    /// Most plans have typically one input. A join has two and a scan (CsvScan)
-    /// or an in-memory DataFrame has none. A Union has multiple.
-    pub fn copy_inputs<T>(&self, container: &mut T)
-    where
-        T: PushNode,
-    {
-        use ALogicalPlan::*;
-        let input = match self {
-            Union { inputs, .. } => {
-                for node in inputs {
-                    container.push_node(*node);
+        // TODO! delay inferring schema until absolutely necessary
+        // this needs a way to estimated bytes/rows.
+        let (mut inferred_schema, rows_read, bytes_read) = infer_file_schema(
+            &reader_bytes,
+            delimiter,
+            infer_schema_length,
+            has_header,
+            schema_overwrite,
+            &mut skip_rows,
+            skip_rows_after_header,
+            comment_char,
+            quote_char,
+            eol_char,
+            null_values.as_ref(),
+            try_parse_dates,
+        )?;
+
+        if let Some(rc) = &row_count {
+            match schema {
+                None => {
+                    let _ = inferred_schema.insert_at_index(0, rc.name.as_str().into(), IDX_DTYPE);
+                }
+                Some(inner) => {
+                    schema = Some(Arc::new(
+                        inner
+                            .new_inserting_at_index(0, rc.name.as_str().into(), IDX_DTYPE)
+                            .unwrap(),
+                    ));
                 }
-                return;
             }
-            Slice { input, .. } => *input,
-            Selection { input, .. } => *input,
-            Projection { input, .. } => *input,
-            LocalProjection { input, .. } => *input,
-            Sort { input, .. } => *input,
-            Cache { input, .. } => *input,
-            Aggregate { input, .. } => *input,
-            Join {
-                input_left,
-                input_right,
-                ..
-            } => {
-                container.push_node(*input_left);
-                container.push_node(*input_right);
-                return;
-            }
-            HStack { input, .. } => *input,
-            Distinct { input, .. } => *input,
-            MapFunction { input, .. } => *input,
-            FileSink { input, .. } => *input,
-            ExtContext {
-                input, contexts, ..
-            } => {
-                for n in contexts {
-                    container.push_node(*n)
-                }
-                *input
-            }
-            Scan { .. } => return,
-            DataFrameScan { .. } => return,
-            AnonymousScan { .. } => return,
-            #[cfg(feature = "python")]
-            PythonScan { .. } => return,
-        };
-        container.push_node(input)
-    }
-
-    pub fn get_inputs(&self) -> Vec<Node> {
-        let mut inputs = Vec::new();
-        self.copy_inputs(&mut inputs);
-        inputs
-    }
-    /// panics if more than one input
-    #[cfg(any(
-        all(feature = "strings", feature = "concat_str"),
-        feature = "streaming",
-        feature = "fused"
-    ))]
-    pub(crate) fn get_input(&self) -> Option<Node> {
-        let mut inputs = [None, None];
-        self.copy_inputs(&mut inputs);
-        inputs[0]
-    }
-}
-
-pub struct ALogicalPlanBuilder<'a> {
-    root: Node,
-    expr_arena: &'a mut Arena<AExpr>,
-    lp_arena: &'a mut Arena<ALogicalPlan>,
-}
-
-impl<'a> ALogicalPlanBuilder<'a> {
-    pub(crate) fn new(
-        root: Node,
-        expr_arena: &'a mut Arena<AExpr>,
-        lp_arena: &'a mut Arena<ALogicalPlan>,
-    ) -> Self {
-        ALogicalPlanBuilder {
-            root,
-            expr_arena,
-            lp_arena,
         }
-    }
 
-    pub(crate) fn from_lp(
-        lp: ALogicalPlan,
-        expr_arena: &'a mut Arena<AExpr>,
-        lp_arena: &'a mut Arena<ALogicalPlan>,
-    ) -> Self {
-        let root = lp_arena.add(lp);
-        ALogicalPlanBuilder {
-            root,
-            expr_arena,
-            lp_arena,
-        }
-    }
+        let schema = schema.unwrap_or_else(|| Arc::new(inferred_schema));
+        let n_bytes = reader_bytes.len();
+        let estimated_n_rows = (rows_read as f64 / bytes_read as f64 * n_bytes as f64) as usize;
 
-    pub fn project_local(self, exprs: Vec<Node>) -> Self {
-        let input_schema = self.lp_arena.get(self.root).schema(self.lp_arena);
-        let schema = aexprs_to_schema(&exprs, &input_schema, Context::Default, self.expr_arena);
-        let lp = ALogicalPlan::LocalProjection {
-            expr: exprs,
-            input: self.root,
-            schema: Arc::new(schema),
+        skip_rows += skip_rows_after_header;
+        let file_info = FileInfo {
+            schema,
+            row_estimation: (None, estimated_n_rows),
         };
-        let node = self.lp_arena.add(lp);
-        ALogicalPlanBuilder::new(node, self.expr_arena, self.lp_arena)
-    }
-
-    pub fn project(self, exprs: Vec<Node>) -> Self {
-        let input_schema = self.lp_arena.get(self.root).schema(self.lp_arena);
-        let schema = aexprs_to_schema(&exprs, &input_schema, Context::Default, self.expr_arena);
 
-        // if len == 0, no projection has to be done. This is a select all operation.
-        if !exprs.is_empty() {
-            let lp = ALogicalPlan::Projection {
+        let options = FileScanOptions {
+            with_columns: None,
+            cache,
+            n_rows,
+            rechunk,
+            row_count,
+            file_counter: Default::default(),
+        };
+        Ok(LogicalPlan::Scan {
+            path,
+            file_info,
+            file_options: options,
+            predicate: None,
+            scan_type: FileScan::Csv {
+                options: CsvParserOptions {
+                    has_header,
+                    delimiter,
+                    ignore_errors,
+                    skip_rows,
+                    low_memory,
+                    comment_char,
+                    quote_char,
+                    eol_char,
+                    null_values,
+                    encoding,
+                    try_parse_dates,
+                },
+            },
+        }
+        .into())
+    }
+
+    pub fn cache(self) -> Self {
+        let input = Box::new(self.0);
+        let id = input.as_ref() as *const LogicalPlan as usize;
+        LogicalPlan::Cache {
+            input,
+            id,
+            count: usize::MAX,
+        }
+        .into()
+    }
+
+    pub fn project(self, exprs: Vec<Expr>) -> Self {
+        let schema = try_delayed!(self.0.schema(), &self.0, into);
+        let (exprs, schema) = try_delayed!(prepare_projection(exprs, &schema), &self.0, into);
+
+        if exprs.is_empty() {
+            self.map(
+                |_| Ok(DataFrame::new_no_checks(vec![])),
+                AllowedOptimizations::default(),
+                Some(Arc::new(|_: &Schema| Ok(Arc::new(Schema::default())))),
+                "EMPTY PROJECTION",
+            )
+        } else {
+            LogicalPlan::Projection {
                 expr: exprs,
-                input: self.root,
+                input: Box::new(self.0),
                 schema: Arc::new(schema),
-            };
-            let node = self.lp_arena.add(lp);
-            ALogicalPlanBuilder::new(node, self.expr_arena, self.lp_arena)
-        } else {
-            self
+            }
+            .into()
         }
     }
 
-    pub fn build(self) -> ALogicalPlan {
-        if self.root.0 == self.lp_arena.len() {
-            self.lp_arena.pop().unwrap()
-        } else {
-            self.lp_arena.take(self.root)
+    pub fn project_local(self, exprs: Vec<Expr>) -> Self {
+        let schema = try_delayed!(self.0.schema(), &self.0, into);
+        let (exprs, schema) = try_delayed!(prepare_projection(exprs, &schema), &self.0, into);
+        LogicalPlan::LocalProjection {
+            expr: exprs,
+            input: Box::new(self.0),
+            schema: Arc::new(schema),
         }
+        .into()
     }
 
-    pub(crate) fn schema(&'a self) -> Cow<'a, SchemaRef> {
-        self.lp_arena.get(self.root).schema(self.lp_arena)
+    pub fn fill_null(self, fill_value: Expr) -> Self {
+        let schema = try_delayed!(self.0.schema(), &self.0, into);
+        let exprs = schema
+            .iter_names()
+            .map(|name| col(name).fill_null(fill_value.clone()))
+            .collect();
+        self.project_local(exprs)
+    }
+
+    pub fn fill_nan(self, fill_value: Expr) -> Self {
+        let schema = try_delayed!(self.0.schema(), &self.0, into);
+
+        let exprs = schema
+            .iter()
+            .filter_map(|(name, dtype)| match dtype {
+                DataType::Float32 | DataType::Float64 => {
+                    Some(col(name).fill_nan(fill_value.clone()).alias(name))
+                }
+                _ => None,
+            })
+            .collect();
+        self.with_columns(exprs)
     }
 
-    pub(crate) fn with_columns(self, exprs: Vec<Node>) -> Self {
-        let schema = self.schema();
+    pub fn with_columns(self, exprs: Vec<Expr>) -> Self {
+        // current schema
+        let schema = try_delayed!(self.0.schema(), &self.0, into);
         let mut new_schema = (**schema).clone();
+        let (exprs, _) = try_delayed!(prepare_projection(exprs, &schema), &self.0, into);
+
+        let mut output_names = PlHashSet::with_capacity(exprs.len());
 
+        let mut arena = Arena::with_capacity(8);
         for e in &exprs {
-            let field = self
-                .expr_arena
-                .get(*e)
-                .to_field(&schema, Context::Default, self.expr_arena)
+            let field = e
+                .to_field_amortized(&schema, Context::Default, &mut arena)
                 .unwrap();
-
+            if !output_names.insert(field.name().clone()) {
+                let msg = format!(
+                    "The name: '{}' passed to `LazyFrame.with_columns` is duplicate",
+                    field.name()
+                );
+                return raise_err!(polars_err!(ComputeError: msg), &self.0, into);
+            }
             new_schema.with_column(field.name().clone(), field.data_type().clone());
+            arena.clear();
         }
 
-        let lp = ALogicalPlan::HStack {
-            input: self.root,
+        LogicalPlan::HStack {
+            input: Box::new(self.0),
             exprs,
             schema: Arc::new(new_schema),
+        }
+        .into()
+    }
+
+    pub fn add_err(self, err: PolarsError) -> Self {
+        LogicalPlan::Error {
+            input: Box::new(self.0),
+            err: err.into(),
+        }
+        .into()
+    }
+
+    pub fn with_context(self, contexts: Vec<LogicalPlan>) -> Self {
+        let mut schema = try_delayed!(self.0.schema(), &self.0, into)
+            .as_ref()
+            .as_ref()
+            .clone();
+
+        for lp in &contexts {
+            let other_schema = try_delayed!(lp.schema(), lp, into);
+
+            for fld in other_schema.iter_fields() {
+                if schema.get(fld.name()).is_none() {
+                    schema.with_column(fld.name, fld.dtype);
+                }
+            }
+        }
+        LogicalPlan::ExtContext {
+            input: Box::new(self.0),
+            contexts,
+            schema: Arc::new(schema),
+        }
+        .into()
+    }
+
+    /// Apply a filter
+    pub fn filter(self, predicate: Expr) -> Self {
+        let predicate = if has_expr(&predicate, |e| match e {
+            Expr::Column(name) => is_regex_projection(name),
+            Expr::Wildcard | Expr::RenameAlias { .. } | Expr::Columns(_) | Expr::DtypeColumn(_) => {
+                true
+            }
+            _ => false,
+        }) {
+            let schema = try_delayed!(self.0.schema(), &self.0, into);
+            let mut rewritten = try_delayed!(
+                rewrite_projections(vec![predicate], &schema, &[]),
+                &self.0,
+                into
+            );
+            match rewritten.len() {
+                1 => {
+                    // all good
+                    rewritten.pop().unwrap()
+                }
+                0 => {
+                    let msg = "The predicate expanded to zero expressions. \
+                        This may for example be caused by a regex not matching column names or \
+                        a column dtype match not hitting any dtypes in the DataFrame";
+                    return raise_err!(polars_err!(ComputeError: msg), &self.0, into);
+                }
+                _ => {
+                    let mut expanded = String::new();
+                    for e in rewritten.iter().take(5) {
+                        expanded.push_str(&format!("\t{e},\n"))
+                    }
+                    // pop latest comma
+                    expanded.pop();
+                    if rewritten.len() > 5 {
+                        expanded.push_str("\t...\n")
+                    }
+
+                    let msg = if cfg!(feature = "python") {
+                        format!("The predicate passed to 'LazyFrame.filter' expanded to multiple expressions: \n\n{expanded}\n\
+                            This is ambiguous. Try to combine the predicates with the 'all' or `any' expression.")
+                    } else {
+                        format!("The predicate passed to 'LazyFrame.filter' expanded to multiple expressions: \n\n{expanded}\n\
+                            This is ambiguous. Try to combine the predicates with the 'all_horizontal' or `any_horizontal' expression.")
+                    };
+                    return raise_err!(polars_err!(ComputeError: msg), &self.0, into);
+                }
+            }
+        } else {
+            predicate
         };
-        let root = self.lp_arena.add(lp);
-        Self::new(root, self.expr_arena, self.lp_arena)
+        LogicalPlan::Selection {
+            predicate,
+            input: Box::new(self.0),
+        }
+        .into()
     }
 
-    pub fn groupby(
+    pub fn groupby<E: AsRef<[Expr]>>(
         self,
-        keys: Vec<Node>,
-        aggs: Vec<Node>,
+        keys: Vec<Expr>,
+        aggs: E,
         apply: Option<Arc<dyn DataFrameUdf>>,
         maintain_order: bool,
-        options: GroupbyOptions,
+        #[cfg(feature = "dynamic_groupby")] dynamic_options: Option<DynamicGroupOptions>,
+        #[cfg(feature = "dynamic_groupby")] rolling_options: Option<RollingGroupOptions>,
     ) -> Self {
-        let current_schema = self.schema();
-        // TODO! add this line if LogicalPlan is dropped in favor of ALogicalPlan
-        // let aggs = rewrite_projections(aggs, current_schema);
-
-        let mut schema =
-            aexprs_to_schema(&keys, &current_schema, Context::Default, self.expr_arena);
-        let other = aexprs_to_schema(
-            &aggs,
-            &current_schema,
-            Context::Aggregation,
-            self.expr_arena,
+        let current_schema = try_delayed!(self.0.schema(), &self.0, into);
+        let current_schema = current_schema.as_ref();
+        let keys = try_delayed!(
+            rewrite_projections(keys, current_schema, &[]),
+            &self.0,
+            into
+        );
+        let aggs = try_delayed!(
+            rewrite_projections(aggs.as_ref().to_vec(), current_schema, keys.as_ref()),
+            &self.0,
+            into
+        );
+
+        let mut schema = try_delayed!(
+            utils::expressions_to_schema(&keys, current_schema, Context::Default),
+            &self.0,
+            into
+        );
+        let other = try_delayed!(
+            utils::expressions_to_schema(&aggs, current_schema, Context::Aggregation),
+            &self.0,
+            into
         );
         schema.merge(other);
 
+        if schema.len() < keys.len() + aggs.len() {
+            let check_names = || {
+                let mut names = PlHashSet::with_capacity(schema.len());
+                for expr in aggs.iter().chain(keys.iter()) {
+                    let name = expr_output_name(expr)?;
+                    if !names.insert(name.clone()) {
+                        polars_bail!(duplicate = name);
+                    }
+                }
+                Ok(())
+            };
+            try_delayed!(check_names(), &self.0, into)
+        }
+
         #[cfg(feature = "dynamic_groupby")]
         {
             let index_columns = &[
-                options
-                    .rolling
+                rolling_options
                     .as_ref()
                     .map(|options| &options.index_column),
-                options
-                    .dynamic
+                dynamic_options
                     .as_ref()
                     .map(|options| &options.index_column),
             ];
             for &name in index_columns.iter().flatten() {
-                let dtype = current_schema.get(name).unwrap();
+                let dtype = try_delayed!(
+                    current_schema
+                        .get(name)
+                        .ok_or_else(|| polars_err!(ColumnNotFound: "{}", name)),
+                    self.0,
+                    into
+                );
                 schema.with_column(name.clone(), dtype.clone());
             }
         }
 
-        let lp = ALogicalPlan::Aggregate {
-            input: self.root,
-            keys,
+        #[cfg(feature = "dynamic_groupby")]
+        let options = GroupbyOptions {
+            dynamic: dynamic_options,
+            rolling: rolling_options,
+            slice: None,
+        };
+
+        #[cfg(not(feature = "dynamic_groupby"))]
+        let options = GroupbyOptions { slice: None };
+
+        LogicalPlan::Aggregate {
+            input: Box::new(self.0),
+            keys: Arc::new(keys),
             aggs,
             schema: Arc::new(schema),
             apply,
             maintain_order,
+            options: Arc::new(options),
+        }
+        .into()
+    }
+
+    pub fn build(self) -> LogicalPlan {
+        self.0
+    }
+
+    pub fn from_existing_df(df: DataFrame) -> Self {
+        let schema = Arc::new(df.schema());
+        LogicalPlan::DataFrameScan {
+            df: Arc::new(df),
+            schema,
+            output_schema: None,
+            projection: None,
+            selection: None,
+        }
+        .into()
+    }
+
+    pub fn sort(
+        self,
+        by_column: Vec<Expr>,
+        descending: Vec<bool>,
+        null_last: bool,
+        maintain_order: bool,
+    ) -> Self {
+        let schema = try_delayed!(self.0.schema(), &self.0, into);
+        let by_column = try_delayed!(rewrite_projections(by_column, &schema, &[]), &self.0, into);
+        LogicalPlan::Sort {
+            input: Box::new(self.0),
+            by_column,
+            args: SortArguments {
+                descending,
+                nulls_last: null_last,
+                slice: None,
+                maintain_order,
+            },
+        }
+        .into()
+    }
+
+    pub fn explode(self, columns: Vec<Expr>) -> Self {
+        let schema = try_delayed!(self.0.schema(), &self.0, into);
+        let columns = try_delayed!(rewrite_projections(columns, &schema, &[]), &self.0, into);
+
+        // columns to string
+        let columns = columns
+            .iter()
+            .map(|e| {
+                if let Expr::Column(name) = e {
+                    name.clone()
+                } else {
+                    panic!("expected column expression")
+                }
+            })
+            .collect::<Arc<[Arc<str>]>>();
+
+        let mut schema = (**schema).clone();
+        try_delayed!(explode_schema(&mut schema, &columns), &self.0, into);
+
+        LogicalPlan::MapFunction {
+            input: Box::new(self.0),
+            function: FunctionNode::Explode {
+                columns,
+                schema: Arc::new(schema),
+            },
+        }
+        .into()
+    }
+
+    pub fn melt(self, args: Arc<MeltArgs>) -> Self {
+        let schema = try_delayed!(self.0.schema(), &self.0, into);
+        let schema = det_melt_schema(&args, &schema);
+        LogicalPlan::MapFunction {
+            input: Box::new(self.0),
+            function: FunctionNode::Melt { args, schema },
+        }
+        .into()
+    }
+
+    pub fn row_count(self, name: &str, offset: Option<IdxSize>) -> Self {
+        let mut schema = try_delayed!(self.0.schema(), &self.0, into).into_owned();
+        let schema_mut = Arc::make_mut(&mut schema);
+        row_count_schema(schema_mut, name);
+
+        LogicalPlan::MapFunction {
+            input: Box::new(self.0),
+            function: FunctionNode::RowCount {
+                name: Arc::from(name),
+                offset,
+                schema,
+            },
+        }
+        .into()
+    }
+
+    pub fn distinct(self, options: DistinctOptions) -> Self {
+        LogicalPlan::Distinct {
+            input: Box::new(self.0),
             options,
-        };
-        let root = self.lp_arena.add(lp);
-        Self::new(root, self.expr_arena, self.lp_arena)
+        }
+        .into()
+    }
+
+    pub fn slice(self, offset: i64, len: IdxSize) -> Self {
+        LogicalPlan::Slice {
+            input: Box::new(self.0),
+            offset,
+            len,
+        }
+        .into()
     }
 
     pub fn join(
         self,
-        other: Node,
-        left_on: Vec<Node>,
-        right_on: Vec<Node>,
-        options: JoinOptions,
+        other: LogicalPlan,
+        left_on: Vec<Expr>,
+        right_on: Vec<Expr>,
+        options: Arc<JoinOptions>,
     ) -> Self {
-        let schema_left = self.schema();
-        let schema_right = self.lp_arena.get(other).schema(self.lp_arena);
+        for e in left_on.iter().chain(right_on.iter()) {
+            if has_expr(e, |e| matches!(e, Expr::Alias(_, _))) {
+                return LogicalPlan::Error {
+                    input: Box::new(self.0),
+                    err: polars_err!(
+                        ComputeError:
+                        "'alias' is not allowed in a join key, use 'with_columns' first",
+                    )
+                    .into(),
+                }
+                .into();
+            }
+        }
 
-        let left_on_exprs = left_on
-            .iter()
-            .map(|node| node_to_expr(*node, self.expr_arena))
-            .collect::<Vec<_>>();
-        let right_on_exprs = right_on
-            .iter()
-            .map(|node| node_to_expr(*node, self.expr_arena))
-            .collect::<Vec<_>>();
+        let schema_left = try_delayed!(self.0.schema(), &self.0, into);
+        let schema_right = try_delayed!(other.schema(), &self.0, into);
+
+        let schema = try_delayed!(
+            det_join_schema(&schema_left, &schema_right, &left_on, &right_on, &options),
+            self.0,
+            into
+        );
 
-        let schema = det_join_schema(
-            &schema_left,
-            &schema_right,
-            &left_on_exprs,
-            &right_on_exprs,
-            &options,
-        )
-        .unwrap();
-
-        let lp = ALogicalPlan::Join {
-            input_left: self.root,
-            input_right: other,
+        LogicalPlan::Join {
+            input_left: Box::new(self.0),
+            input_right: Box::new(other),
             schema,
             left_on,
             right_on,
             options,
-        };
+        }
+        .into()
+    }
+    pub fn map_private(self, function: FunctionNode) -> Self {
+        LogicalPlan::MapFunction {
+            input: Box::new(self.0),
+            function,
+        }
+        .into()
+    }
+
+    #[cfg(feature = "python")]
+    pub fn map_python(
+        self,
+        function: PythonFunction,
+        optimizations: AllowedOptimizations,
+        schema: Option<SchemaRef>,
+        validate_output: bool,
+    ) -> Self {
+        LogicalPlan::MapFunction {
+            input: Box::new(self.0),
+            function: FunctionNode::OpaquePython {
+                function,
+                schema,
+                predicate_pd: optimizations.predicate_pushdown,
+                projection_pd: optimizations.projection_pushdown,
+                streamable: optimizations.streaming,
+                validate_output,
+            },
+        }
+        .into()
+    }
 
-        let root = self.lp_arena.add(lp);
-        Self::new(root, self.expr_arena, self.lp_arena)
+    pub fn map<F>(
+        self,
+        function: F,
+        optimizations: AllowedOptimizations,
+        schema: Option<Arc<dyn UdfSchema>>,
+        name: &'static str,
+    ) -> Self
+    where
+        F: DataFrameUdf + 'static,
+    {
+        let function = Arc::new(function);
+
+        LogicalPlan::MapFunction {
+            input: Box::new(self.0),
+            function: FunctionNode::Opaque {
+                function,
+                schema,
+                predicate_pd: optimizations.predicate_pushdown,
+                projection_pd: optimizations.projection_pushdown,
+                streamable: optimizations.streaming,
+                fmt_str: name,
+            },
+        }
+        .into()
     }
 }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/anonymous_scan.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/anonymous_scan.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/apply.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/apply.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/builder.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/mod.rs`

 * *Files 20% similar despite different names*

```diff
@@ -1,858 +1,749 @@
-#[cfg(feature = "csv")]
-use std::io::{Read, Seek};
+mod functions;
+mod generic;
+mod groupby;
+mod hstack;
+mod joins;
+mod projection;
+mod rename;
+#[cfg(feature = "semi_anti_join")]
+mod semi_anti_join;
 
-#[cfg(feature = "parquet")]
-use polars_core::cloud::CloudOptions;
-use polars_core::frame::explode::MeltArgs;
+use polars_core::datatypes::PlHashSet;
 use polars_core::prelude::*;
-use polars_core::utils::try_get_supertype;
-#[cfg(feature = "ipc")]
-use polars_io::ipc::IpcReader;
-#[cfg(all(feature = "parquet", feature = "async"))]
-use polars_io::parquet::ParquetAsyncReader;
-#[cfg(feature = "parquet")]
-use polars_io::parquet::ParquetReader;
-#[cfg(any(
-    feature = "parquet",
-    feature = "parquet_async",
-    feature = "csv",
-    feature = "ipc"
-))]
 use polars_io::RowCount;
-#[cfg(feature = "csv")]
-use polars_io::{
-    csv::utils::{get_reader_bytes, infer_file_schema, is_compressed},
-    csv::CsvEncoding,
-    csv::NullValues,
-};
+#[cfg(feature = "semi_anti_join")]
+use semi_anti_join::process_semi_anti_join;
 
-use crate::logical_plan::functions::FunctionNode;
-use crate::logical_plan::projection::{is_regex_projection, rewrite_projections};
-use crate::logical_plan::schema::{det_join_schema, FileInfo};
-#[cfg(feature = "python")]
-use crate::prelude::python_udf::PythonFunction;
+use crate::logical_plan::Context;
+use crate::prelude::iterator::ArenaExprIter;
+use crate::prelude::optimizer::projection_pushdown::generic::process_generic;
+use crate::prelude::optimizer::projection_pushdown::groupby::process_groupby;
+use crate::prelude::optimizer::projection_pushdown::hstack::process_hstack;
+use crate::prelude::optimizer::projection_pushdown::joins::process_join;
+use crate::prelude::optimizer::projection_pushdown::projection::process_projection;
+use crate::prelude::optimizer::projection_pushdown::rename::process_rename;
 use crate::prelude::*;
-use crate::utils;
-
-pub(crate) fn prepare_projection(
-    exprs: Vec<Expr>,
-    schema: &Schema,
-) -> PolarsResult<(Vec<Expr>, Schema)> {
-    let exprs = rewrite_projections(exprs, schema, &[])?;
-    let schema = utils::expressions_to_schema(&exprs, schema, Context::Default)?;
-    Ok((exprs, schema))
-}
-
-pub struct LogicalPlanBuilder(pub LogicalPlan);
-
-impl From<LogicalPlan> for LogicalPlanBuilder {
-    fn from(lp: LogicalPlan) -> Self {
-        LogicalPlanBuilder(lp)
-    }
-}
+use crate::utils::{
+    aexpr_assign_renamed_leaf, aexpr_to_column_nodes, aexpr_to_leaf_names, check_input_node,
+    expr_is_projected_upstream,
+};
 
-fn format_err(msg: &str, input: &LogicalPlan) -> String {
-    format!("{msg}\n\nError originated just after this operation:\n{input:?}")
+fn init_vec() -> Vec<Node> {
+    Vec::with_capacity(16)
 }
-
-/// Returns every error or msg: &str as `ComputeError`.
-/// It also shows the logical plan node where the error
-/// originated.
-macro_rules! raise_err {
-    ($err:expr, $input:expr, $convert:ident) => {{
-        let format_err_outer = |msg: &str| format_err(msg, &$input);
-
-        let err = $err.wrap_msg(&format_err_outer);
-
-        LogicalPlan::Error {
-            input: Box::new($input.clone()),
-            err: err.into(),
-        }
-        .$convert()
-    }};
+fn init_set() -> PlHashSet<Arc<str>> {
+    PlHashSet::with_capacity(32)
 }
 
-macro_rules! try_delayed {
-    ($fallible:expr, $input:expr, $convert:ident) => {
-        match $fallible {
-            Ok(success) => success,
-            Err(err) => return raise_err!(err, $input, $convert),
+/// utility function to get names of the columns needed in projection at scan level
+fn get_scan_columns(
+    acc_projections: &mut Vec<Node>,
+    expr_arena: &Arena<AExpr>,
+    row_count: Option<&RowCount>,
+) -> Option<Arc<Vec<String>>> {
+    let mut with_columns = None;
+    if !acc_projections.is_empty() {
+        let mut columns = Vec::with_capacity(acc_projections.len());
+        for expr in acc_projections {
+            for name in aexpr_to_leaf_names(*expr, expr_arena) {
+                // we shouldn't project the row-count column, as that is generated
+                // in the scan
+                let push = match row_count {
+                    Some(rc) if name.as_ref() != rc.name.as_str() => true,
+                    None => true,
+                    _ => false,
+                };
+                if push {
+                    columns.push((*name).to_owned())
+                }
+            }
         }
-    };
+        with_columns = Some(Arc::new(columns));
+    }
+    with_columns
 }
 
-impl LogicalPlanBuilder {
-    pub fn anonymous_scan(
-        function: Arc<dyn AnonymousScan>,
-        schema: Option<Schema>,
-        infer_schema_length: Option<usize>,
-        skip_rows: Option<usize>,
-        n_rows: Option<usize>,
-        name: &'static str,
-    ) -> PolarsResult<Self> {
-        let schema = Arc::new(match schema {
-            Some(s) => s,
-            None => function.schema(infer_schema_length)?,
-        });
-
-        let file_info = FileInfo {
-            schema: schema.clone(),
-            row_estimation: (n_rows, n_rows.unwrap_or(usize::MAX)),
-        };
-        Ok(LogicalPlan::AnonymousScan {
-            function,
-            file_info,
-            predicate: None,
-            options: AnonymousScanOptions {
-                fmt_str: name,
-                schema,
-                skip_rows,
-                n_rows,
-                output_schema: None,
-                with_columns: None,
-                predicate: None,
-            },
+/// split in a projection vec that can be pushed down and a projection vec that should be used
+/// in this node
+///
+/// # Returns
+/// accumulated_projections, local_projections, accumulated_names
+///
+/// - `expands_schema`. An unnest adds more columns to a schema, so we cannot use fast path
+fn split_acc_projections(
+    acc_projections: Vec<Node>,
+    down_schema: &Schema,
+    expr_arena: &Arena<AExpr>,
+    expands_schema: bool,
+) -> (Vec<Node>, Vec<Node>, PlHashSet<Arc<str>>) {
+    // If node above has as many columns as the projection there is nothing to pushdown.
+    if !expands_schema && down_schema.len() == acc_projections.len() {
+        let local_projections = acc_projections;
+        (vec![], local_projections, PlHashSet::new())
+    } else {
+        let (acc_projections, local_projections): (Vec<Node>, Vec<Node>) = acc_projections
+            .into_iter()
+            .partition(|expr| check_input_node(*expr, down_schema, expr_arena));
+        let mut names = init_set();
+        for proj in &acc_projections {
+            for name in aexpr_to_leaf_names(*proj, expr_arena) {
+                names.insert(name);
+            }
         }
-        .into())
+        (acc_projections, local_projections, names)
     }
+}
 
-    #[cfg(any(feature = "parquet", feature = "parquet_async"))]
-    #[allow(clippy::too_many_arguments)]
-    pub fn scan_parquet<P: Into<std::path::PathBuf>>(
-        path: P,
-        n_rows: Option<usize>,
-        cache: bool,
-        parallel: polars_io::parquet::ParallelStrategy,
-        row_count: Option<RowCount>,
-        rechunk: bool,
-        low_memory: bool,
-        cloud_options: Option<CloudOptions>,
-        use_statistics: bool,
-    ) -> PolarsResult<Self> {
-        use polars_io::{is_cloud_url, SerReader as _};
-
-        let path = path.into();
-        let (mut schema, num_rows) = if is_cloud_url(&path) {
-            #[cfg(not(feature = "async"))]
-            panic!(
-                "One or more of the cloud storage features ('aws', 'gcp', ...) must be enabled."
-            );
-
-            #[cfg(feature = "async")]
-            {
-                let uri = path.to_string_lossy();
-                ParquetAsyncReader::file_info(&uri, cloud_options.as_ref())?
+/// utility function such that we can recurse all binary expressions in the expression tree
+fn add_expr_to_accumulated(
+    expr: Node,
+    acc_projections: &mut Vec<Node>,
+    projected_names: &mut PlHashSet<Arc<str>>,
+    expr_arena: &Arena<AExpr>,
+) {
+    for root_node in aexpr_to_column_nodes_iter(expr, expr_arena) {
+        for name in aexpr_to_leaf_names_iter(root_node, expr_arena) {
+            if projected_names.insert(name) {
+                acc_projections.push(root_node)
             }
-        } else {
-            let file = std::fs::File::open(&path)?;
-            let mut reader = ParquetReader::new(file);
-            (reader.schema()?, reader.num_rows()?)
-        };
-
-        if let Some(rc) = &row_count {
-            let _ = schema.insert_at_index(0, rc.name.as_str().into(), IDX_DTYPE);
-        }
-
-        let file_info = FileInfo {
-            schema: Arc::new(schema),
-            row_estimation: (Some(num_rows), num_rows),
-        };
-
-        let options = FileScanOptions {
-            with_columns: None,
-            cache,
-            n_rows,
-            rechunk,
-            row_count,
-            file_counter: Default::default(),
-        };
-        Ok(LogicalPlan::Scan {
-            path,
-            file_info,
-            file_options: options,
-            predicate: None,
-            scan_type: FileScan::Parquet {
-                options: ParquetOptions {
-                    parallel,
-                    low_memory,
-                    use_statistics,
-                },
-                cloud_options,
-            },
         }
-        .into())
     }
+}
 
-    #[cfg(feature = "ipc")]
-    pub fn scan_ipc<P: Into<std::path::PathBuf>>(
-        path: P,
-        options: IpcScanOptions,
-        n_rows: Option<usize>,
-        cache: bool,
-        row_count: Option<RowCount>,
-        rechunk: bool,
-    ) -> PolarsResult<Self> {
-        use polars_io::SerReader as _;
-
-        let path = path.into();
-        let file = std::fs::File::open(&path)?;
-        let mut reader = IpcReader::new(file);
-
-        let mut schema = reader.schema()?;
-        if let Some(rc) = &row_count {
-            let _ = schema.insert_at_index(0, rc.name.as_str().into(), IDX_DTYPE);
-        }
-        let schema = Arc::new(schema);
-
-        let num_rows = reader._num_rows()?;
-        let file_info = FileInfo {
-            schema,
-            row_estimation: (None, num_rows),
-        };
-
-        let file_options = FileScanOptions {
-            with_columns: None,
-            cache,
-            n_rows,
-            rechunk,
-            row_count,
-            file_counter: Default::default(),
-        };
-        Ok(LogicalPlan::Scan {
-            path,
-            file_info,
-            file_options,
-            predicate: None,
-            scan_type: FileScan::Ipc { options },
-        }
-        .into())
+fn add_str_to_accumulated(
+    name: &str,
+    acc_projections: &mut Vec<Node>,
+    projected_names: &mut PlHashSet<Arc<str>>,
+    expr_arena: &mut Arena<AExpr>,
+) {
+    // if empty: all columns are already projected.
+    if !acc_projections.is_empty() && !projected_names.contains(name) {
+        let node = expr_arena.add(AExpr::Column(Arc::from(name)));
+        add_expr_to_accumulated(node, acc_projections, projected_names, expr_arena);
     }
+}
 
-    #[allow(clippy::too_many_arguments)]
-    #[cfg(feature = "csv")]
-    pub fn scan_csv<P: Into<std::path::PathBuf>>(
-        path: P,
-        delimiter: u8,
-        has_header: bool,
-        ignore_errors: bool,
-        mut skip_rows: usize,
-        n_rows: Option<usize>,
-        cache: bool,
-        mut schema: Option<Arc<Schema>>,
-        schema_overwrite: Option<&Schema>,
-        low_memory: bool,
-        comment_char: Option<u8>,
-        quote_char: Option<u8>,
-        eol_char: u8,
-        null_values: Option<NullValues>,
-        infer_schema_length: Option<usize>,
-        rechunk: bool,
-        skip_rows_after_header: usize,
-        encoding: CsvEncoding,
-        row_count: Option<RowCount>,
-        try_parse_dates: bool,
-    ) -> PolarsResult<Self> {
-        let path = path.into();
-        let mut file = std::fs::File::open(&path)?;
-        let mut magic_nr = [0u8; 2];
-        file.read_exact(&mut magic_nr)
-            .map_err(|_| polars_err!(NoData: "empty csv"))?;
-        polars_ensure!(
-            !is_compressed(&magic_nr),
-            ComputeError: "cannot scan compressed csv; use `read_csv` for compressed data",
-        );
-        file.rewind()?;
-        let reader_bytes = get_reader_bytes(&mut file).expect("could not mmap file");
-
-        // TODO! delay inferring schema until absolutely necessary
-        // this needs a way to estimated bytes/rows.
-        let (mut inferred_schema, rows_read, bytes_read) = infer_file_schema(
-            &reader_bytes,
-            delimiter,
-            infer_schema_length,
-            has_header,
-            schema_overwrite,
-            &mut skip_rows,
-            skip_rows_after_header,
-            comment_char,
-            quote_char,
-            eol_char,
-            null_values.as_ref(),
-            try_parse_dates,
-        )?;
-
-        if let Some(rc) = &row_count {
-            match schema {
-                None => {
-                    let _ = inferred_schema.insert_at_index(0, rc.name.as_str().into(), IDX_DTYPE);
-                }
-                Some(inner) => {
-                    schema = Some(Arc::new(
-                        inner
-                            .new_inserting_at_index(0, rc.name.as_str().into(), IDX_DTYPE)
-                            .unwrap(),
-                    ));
-                }
-            }
-        }
-
-        let schema = schema.unwrap_or_else(|| Arc::new(inferred_schema));
-        let n_bytes = reader_bytes.len();
-        let estimated_n_rows = (rows_read as f64 / bytes_read as f64 * n_bytes as f64) as usize;
-
-        skip_rows += skip_rows_after_header;
-        let file_info = FileInfo {
-            schema,
-            row_estimation: (None, estimated_n_rows),
-        };
-
-        let options = FileScanOptions {
-            with_columns: None,
-            cache,
-            n_rows,
-            rechunk,
-            row_count,
-            file_counter: Default::default(),
-        };
-        Ok(LogicalPlan::Scan {
-            path,
-            file_info,
-            file_options: options,
-            predicate: None,
-            scan_type: FileScan::Csv {
-                options: CsvParserOptions {
-                    has_header,
-                    delimiter,
-                    ignore_errors,
-                    skip_rows,
-                    low_memory,
-                    comment_char,
-                    quote_char,
-                    eol_char,
-                    null_values,
-                    encoding,
-                    try_parse_dates,
-                },
-            },
-        }
-        .into())
+fn update_scan_schema(
+    acc_projections: &[Node],
+    expr_arena: &Arena<AExpr>,
+    schema: &Schema,
+    sort_projections: bool,
+) -> PolarsResult<Schema> {
+    let mut new_schema = Schema::with_capacity(acc_projections.len());
+    let mut new_cols = Vec::with_capacity(acc_projections.len());
+    for node in acc_projections.iter() {
+        for name in aexpr_to_leaf_names(*node, expr_arena) {
+            let item = schema.get_full(&name).ok_or_else(|| {
+                polars_err!(ComputeError: "column '{}' not available in schema {:?}", name, schema)
+            })?;
+            new_cols.push(item);
+        }
+    }
+    // make sure that the projections are sorted by the schema.
+    if sort_projections {
+        new_cols.sort_unstable_by_key(|item| item.0);
     }
-
-    pub fn cache(self) -> Self {
-        let input = Box::new(self.0);
-        let id = input.as_ref() as *const LogicalPlan as usize;
-        LogicalPlan::Cache {
-            input,
-            id,
-            count: usize::MAX,
-        }
-        .into()
+    for item in new_cols {
+        new_schema.with_column(item.1.clone(), item.2.clone());
     }
+    Ok(new_schema)
+}
 
-    pub fn project(self, exprs: Vec<Expr>) -> Self {
-        let schema = try_delayed!(self.0.schema(), &self.0, into);
-        let (exprs, schema) = try_delayed!(prepare_projection(exprs, &schema), &self.0, into);
-
-        if exprs.is_empty() {
-            self.map(
-                |_| Ok(DataFrame::new_no_checks(vec![])),
-                AllowedOptimizations::default(),
-                Some(Arc::new(|_: &Schema| Ok(Arc::new(Schema::default())))),
-                "EMPTY PROJECTION",
-            )
-        } else {
-            LogicalPlan::Projection {
-                expr: exprs,
-                input: Box::new(self.0),
-                schema: Arc::new(schema),
-            }
-            .into()
-        }
-    }
+pub struct ProjectionPushDown {
+    pub(crate) has_joins_or_unions: bool,
+    pub(crate) has_cache: bool,
+}
 
-    pub fn project_local(self, exprs: Vec<Expr>) -> Self {
-        let schema = try_delayed!(self.0.schema(), &self.0, into);
-        let (exprs, schema) = try_delayed!(prepare_projection(exprs, &schema), &self.0, into);
-        LogicalPlan::LocalProjection {
-            expr: exprs,
-            input: Box::new(self.0),
-            schema: Arc::new(schema),
+impl ProjectionPushDown {
+    pub(super) fn new() -> Self {
+        Self {
+            has_joins_or_unions: false,
+            has_cache: false,
         }
-        .into()
     }
 
-    pub fn fill_null(self, fill_value: Expr) -> Self {
-        let schema = try_delayed!(self.0.schema(), &self.0, into);
-        let exprs = schema
-            .iter_names()
-            .map(|name| col(name).fill_null(fill_value.clone()))
-            .collect();
-        self.project_local(exprs)
-    }
-
-    pub fn fill_nan(self, fill_value: Expr) -> Self {
-        let schema = try_delayed!(self.0.schema(), &self.0, into);
+    /// Projection will be done at this node, but we continue optimization
+    fn no_pushdown_restart_opt(
+        &mut self,
+        lp: ALogicalPlan,
+        acc_projections: Vec<Node>,
+        projections_seen: usize,
+        lp_arena: &mut Arena<ALogicalPlan>,
+        expr_arena: &mut Arena<AExpr>,
+    ) -> PolarsResult<ALogicalPlan> {
+        let inputs = lp.get_inputs();
+        let exprs = lp.get_exprs();
 
-        let exprs = schema
+        let new_inputs = inputs
             .iter()
-            .filter_map(|(name, dtype)| match dtype {
-                DataType::Float32 | DataType::Float64 => {
-                    Some(col(name).fill_nan(fill_value.clone()).alias(name))
-                }
-                _ => None,
+            .map(|&node| {
+                let alp = lp_arena.take(node);
+                let alp = self.push_down(
+                    alp,
+                    Default::default(),
+                    Default::default(),
+                    projections_seen,
+                    lp_arena,
+                    expr_arena,
+                )?;
+                lp_arena.replace(node, alp);
+                Ok(node)
             })
-            .collect();
-        self.with_columns(exprs)
-    }
+            .collect::<PolarsResult<Vec<_>>>()?;
+        let lp = lp.with_exprs_and_input(exprs, new_inputs);
 
-    pub fn with_columns(self, exprs: Vec<Expr>) -> Self {
-        // current schema
-        let schema = try_delayed!(self.0.schema(), &self.0, into);
-        let mut new_schema = (**schema).clone();
-        let (exprs, _) = try_delayed!(prepare_projection(exprs, &schema), &self.0, into);
-
-        let mut output_names = PlHashSet::with_capacity(exprs.len());
-
-        let mut arena = Arena::with_capacity(8);
-        for e in &exprs {
-            let field = e
-                .to_field_amortized(&schema, Context::Default, &mut arena)
-                .unwrap();
-            if !output_names.insert(field.name().clone()) {
-                let msg = format!(
-                    "The name: '{}' passed to `LazyFrame.with_columns` is duplicate",
-                    field.name()
-                );
-                return raise_err!(polars_err!(ComputeError: msg), &self.0, into);
-            }
-            new_schema.with_column(field.name().clone(), field.data_type().clone());
-            arena.clear();
-        }
-
-        LogicalPlan::HStack {
-            input: Box::new(self.0),
-            exprs,
-            schema: Arc::new(new_schema),
-        }
-        .into()
+        let builder = ALogicalPlanBuilder::from_lp(lp, expr_arena, lp_arena);
+        Ok(self.finish_node(acc_projections, builder))
     }
 
-    pub fn add_err(self, err: PolarsError) -> Self {
-        LogicalPlan::Error {
-            input: Box::new(self.0),
-            err: err.into(),
+    fn finish_node(
+        &mut self,
+        local_projections: Vec<Node>,
+        builder: ALogicalPlanBuilder,
+    ) -> ALogicalPlan {
+        if !local_projections.is_empty() {
+            builder.project(local_projections).build()
+        } else {
+            builder.build()
         }
-        .into()
     }
 
-    pub fn with_context(self, contexts: Vec<LogicalPlan>) -> Self {
-        let mut schema = try_delayed!(self.0.schema(), &self.0, into)
-            .as_ref()
-            .as_ref()
-            .clone();
-
-        for lp in &contexts {
-            let other_schema = try_delayed!(lp.schema(), lp, into);
-
-            for fld in other_schema.iter_fields() {
-                if schema.get(fld.name()).is_none() {
-                    schema.with_column(fld.name, fld.dtype);
-                }
+    #[allow(clippy::too_many_arguments)]
+    fn join_push_down(
+        &mut self,
+        schema_left: &Schema,
+        schema_right: &Schema,
+        proj: Node,
+        pushdown_left: &mut Vec<Node>,
+        pushdown_right: &mut Vec<Node>,
+        names_left: &mut PlHashSet<Arc<str>>,
+        names_right: &mut PlHashSet<Arc<str>>,
+        expr_arena: &Arena<AExpr>,
+    ) -> (bool, bool) {
+        let mut pushed_at_least_one = false;
+        let mut already_projected = false;
+        let names = aexpr_to_leaf_names(proj, expr_arena);
+        let root_projections = aexpr_to_column_nodes(proj, expr_arena);
+
+        for (name, root_projection) in names.into_iter().zip(root_projections) {
+            let is_in_left = names_left.contains(&name);
+            let is_in_right = names_right.contains(&name);
+            already_projected |= is_in_left;
+            already_projected |= is_in_right;
+
+            if check_input_node(root_projection, schema_left, expr_arena) && !is_in_left {
+                names_left.insert(name.clone());
+                pushdown_left.push(proj);
+                pushed_at_least_one = true;
+            }
+            if check_input_node(root_projection, schema_right, expr_arena) && !is_in_right {
+                names_right.insert(name.clone());
+                pushdown_right.push(proj);
+                pushed_at_least_one = true;
             }
         }
-        LogicalPlan::ExtContext {
-            input: Box::new(self.0),
-            contexts,
-            schema: Arc::new(schema),
-        }
-        .into()
+
+        (pushed_at_least_one, already_projected)
+    }
+
+    /// This pushes down current node and assigns the result to this node.
+    fn pushdown_and_assign(
+        &mut self,
+        input: Node,
+        acc_projections: Vec<Node>,
+        names: PlHashSet<Arc<str>>,
+        projections_seen: usize,
+        lp_arena: &mut Arena<ALogicalPlan>,
+        expr_arena: &mut Arena<AExpr>,
+    ) -> PolarsResult<()> {
+        let alp = lp_arena.take(input);
+        let lp = self.push_down(
+            alp,
+            acc_projections,
+            names,
+            projections_seen,
+            lp_arena,
+            expr_arena,
+        )?;
+        lp_arena.replace(input, lp);
+        Ok(())
     }
 
-    /// Apply a filter
-    pub fn filter(self, predicate: Expr) -> Self {
-        let predicate = if has_expr(&predicate, |e| match e {
-            Expr::Column(name) => is_regex_projection(name),
-            Expr::Wildcard | Expr::RenameAlias { .. } | Expr::Columns(_) | Expr::DtypeColumn(_) => {
-                true
-            }
-            _ => false,
-        }) {
-            let schema = try_delayed!(self.0.schema(), &self.0, into);
-            let mut rewritten = try_delayed!(
-                rewrite_projections(vec![predicate], &schema, &[]),
-                &self.0,
-                into
-            );
-            match rewritten.len() {
-                1 => {
-                    // all good
-                    rewritten.pop().unwrap()
-                }
-                0 => {
-                    let msg = "The predicate expanded to zero expressions. \
-                        This may for example be caused by a regex not matching column names or \
-                        a column dtype match not hitting any dtypes in the DataFrame";
-                    return raise_err!(polars_err!(ComputeError: msg), &self.0, into);
-                }
-                _ => {
-                    let mut expanded = String::new();
-                    for e in rewritten.iter().take(5) {
-                        expanded.push_str(&format!("\t{e},\n"))
-                    }
-                    // pop latest comma
-                    expanded.pop();
-                    if rewritten.len() > 5 {
-                        expanded.push_str("\t...\n")
-                    }
+    /// This pushes down the projection that are validated
+    /// that they can be done successful at the schema above
+    /// The result is assigned to this node.
+    ///
+    /// The local projections are return and still have to be applied
+    fn pushdown_and_assign_check_schema(
+        &mut self,
+        input: Node,
+        acc_projections: Vec<Node>,
+        projections_seen: usize,
+        lp_arena: &mut Arena<ALogicalPlan>,
+        expr_arena: &mut Arena<AExpr>,
+        // an unnest changes/expands the schema
+        expands_schema: bool,
+    ) -> PolarsResult<Vec<Node>> {
+        let alp = lp_arena.take(input);
+        let down_schema = alp.schema(lp_arena);
+
+        let (acc_projections, local_projections, names) =
+            split_acc_projections(acc_projections, &down_schema, expr_arena, expands_schema);
+
+        let lp = self.push_down(
+            alp,
+            acc_projections,
+            names,
+            projections_seen,
+            lp_arena,
+            expr_arena,
+        )?;
+        lp_arena.replace(input, lp);
+        Ok(local_projections)
+    }
 
-                    let msg = if cfg!(feature = "python") {
-                        format!("The predicate passed to 'LazyFrame.filter' expanded to multiple expressions: \n\n{expanded}\n\
-                            This is ambiguous. Try to combine the predicates with the 'all' or `any' expression.")
+    /// Projection pushdown optimizer
+    ///
+    /// # Arguments
+    ///
+    /// * `AlogicalPlan` - Arena based logical plan tree representing the query.
+    /// * `acc_projections` - The projections we accumulate during tree traversal.
+    /// * `names` - We keep track of the names to ensure we don't do duplicate projections.
+    /// * `projections_seen` - Count the number of projection operations during tree traversal.
+    /// * `lp_arena` - The local memory arena for the logical plan.
+    /// * `expr_arena` - The local memory arena for the expressions.
+    ///
+    fn push_down(
+        &mut self,
+        logical_plan: ALogicalPlan,
+        mut acc_projections: Vec<Node>,
+        mut projected_names: PlHashSet<Arc<str>>,
+        projections_seen: usize,
+        lp_arena: &mut Arena<ALogicalPlan>,
+        expr_arena: &mut Arena<AExpr>,
+    ) -> PolarsResult<ALogicalPlan> {
+        use ALogicalPlan::*;
+
+        match logical_plan {
+            Projection { expr, input, .. } => process_projection(
+                self,
+                input,
+                expr.exprs(),
+                acc_projections,
+                projected_names,
+                projections_seen,
+                lp_arena,
+                expr_arena,
+            ),
+            LocalProjection { expr, input, .. } => {
+                self.pushdown_and_assign(
+                    input,
+                    acc_projections,
+                    projected_names,
+                    projections_seen,
+                    lp_arena,
+                    expr_arena,
+                )?;
+                let lp = lp_arena.get(input);
+                let schema = lp.schema(lp_arena);
+
+                // projection from a wildcard may be dropped if the schema changes due to the optimization
+                let proj = expr
+                    .into_iter()
+                    .filter(|e| check_input_node(*e, &schema, expr_arena))
+                    .collect();
+                Ok(ALogicalPlanBuilder::new(input, expr_arena, lp_arena)
+                    .project_local(proj)
+                    .build())
+            }
+            AnonymousScan {
+                function,
+                file_info,
+                predicate,
+                mut options,
+                output_schema,
+            } => {
+                if function.allows_projection_pushdown() {
+                    let mut_options = Arc::make_mut(&mut options);
+                    mut_options.with_columns =
+                        get_scan_columns(&mut acc_projections, expr_arena, None);
+
+                    let output_schema = if mut_options.with_columns.is_none() {
+                        None
                     } else {
-                        format!("The predicate passed to 'LazyFrame.filter' expanded to multiple expressions: \n\n{expanded}\n\
-                            This is ambiguous. Try to combine the predicates with the 'all_horizontal' or `any_horizontal' expression.")
+                        Some(Arc::new(update_scan_schema(
+                            &acc_projections,
+                            expr_arena,
+                            &file_info.schema,
+                            true,
+                        )?))
                     };
-                    return raise_err!(polars_err!(ComputeError: msg), &self.0, into);
-                }
-            }
-        } else {
-            predicate
-        };
-        LogicalPlan::Selection {
-            predicate,
-            input: Box::new(self.0),
-        }
-        .into()
-    }
+                    mut_options.output_schema = output_schema.clone();
 
-    pub fn groupby<E: AsRef<[Expr]>>(
-        self,
-        keys: Vec<Expr>,
-        aggs: E,
-        apply: Option<Arc<dyn DataFrameUdf>>,
-        maintain_order: bool,
-        #[cfg(feature = "dynamic_groupby")] dynamic_options: Option<DynamicGroupOptions>,
-        #[cfg(feature = "dynamic_groupby")] rolling_options: Option<RollingGroupOptions>,
-    ) -> Self {
-        let current_schema = try_delayed!(self.0.schema(), &self.0, into);
-        let current_schema = current_schema.as_ref();
-        let keys = try_delayed!(
-            rewrite_projections(keys, current_schema, &[]),
-            &self.0,
-            into
-        );
-        let aggs = try_delayed!(
-            rewrite_projections(aggs.as_ref().to_vec(), current_schema, keys.as_ref()),
-            &self.0,
-            into
-        );
-
-        let mut schema = try_delayed!(
-            utils::expressions_to_schema(&keys, current_schema, Context::Default),
-            &self.0,
-            into
-        );
-        let other = try_delayed!(
-            utils::expressions_to_schema(&aggs, current_schema, Context::Aggregation),
-            &self.0,
-            into
-        );
-        schema.merge(other);
-
-        if schema.len() < keys.len() + aggs.len() {
-            let check_names = || {
-                let mut names = PlHashSet::with_capacity(schema.len());
-                for expr in aggs.iter().chain(keys.iter()) {
-                    let name = expr_output_name(expr)?;
-                    if !names.insert(name.clone()) {
-                        polars_bail!(duplicate = name);
-                    }
+                    let lp = AnonymousScan {
+                        function,
+                        file_info,
+                        output_schema,
+                        options,
+                        predicate,
+                    };
+                    Ok(lp)
+                } else {
+                    let lp = AnonymousScan {
+                        function,
+                        file_info,
+                        predicate,
+                        options,
+                        output_schema,
+                    };
+                    Ok(lp)
                 }
-                Ok(())
-            };
-            try_delayed!(check_names(), &self.0, into)
-        }
-
-        #[cfg(feature = "dynamic_groupby")]
-        {
-            let index_columns = &[
-                rolling_options
-                    .as_ref()
-                    .map(|options| &options.index_column),
-                dynamic_options
-                    .as_ref()
-                    .map(|options| &options.index_column),
-            ];
-            for &name in index_columns.iter().flatten() {
-                let dtype = try_delayed!(
-                    current_schema
-                        .get(name)
-                        .ok_or_else(|| polars_err!(ColumnNotFound: "{}", name)),
-                    self.0,
-                    into
-                );
-                schema.with_column(name.clone(), dtype.clone());
             }
-        }
-
-        #[cfg(feature = "dynamic_groupby")]
-        let options = GroupbyOptions {
-            dynamic: dynamic_options,
-            rolling: rolling_options,
-            slice: None,
-        };
-
-        #[cfg(not(feature = "dynamic_groupby"))]
-        let options = GroupbyOptions { slice: None };
-
-        LogicalPlan::Aggregate {
-            input: Box::new(self.0),
-            keys: Arc::new(keys),
-            aggs,
-            schema: Arc::new(schema),
-            apply,
-            maintain_order,
-            options,
-        }
-        .into()
-    }
+            DataFrameScan {
+                df,
+                schema,
+                mut output_schema,
+                selection,
+                ..
+            } => {
+                let mut projection = None;
+                if !acc_projections.is_empty() {
+                    output_schema = Some(Arc::new(update_scan_schema(
+                        &acc_projections,
+                        expr_arena,
+                        &schema,
+                        false,
+                    )?));
+                    projection = get_scan_columns(&mut acc_projections, expr_arena, None);
+                }
+                let lp = DataFrameScan {
+                    df,
+                    schema,
+                    output_schema,
+                    projection,
+                    selection,
+                };
+                Ok(lp)
+            }
+            #[cfg(feature = "python")]
+            PythonScan {
+                mut options,
+                predicate,
+            } => {
+                options.with_columns = get_scan_columns(&mut acc_projections, expr_arena, None);
 
-    pub fn build(self) -> LogicalPlan {
-        self.0
-    }
+                options.output_schema = if options.with_columns.is_none() {
+                    None
+                } else {
+                    Some(Arc::new(update_scan_schema(
+                        &acc_projections,
+                        expr_arena,
+                        &options.schema,
+                        true,
+                    )?))
+                };
+                Ok(PythonScan { options, predicate })
+            }
+            Scan {
+                path,
+                file_info,
+                scan_type,
+                predicate,
+                mut file_options,
+                ..
+            } => {
+                file_options.with_columns = get_scan_columns(
+                    &mut acc_projections,
+                    expr_arena,
+                    file_options.row_count.as_ref(),
+                );
 
-    pub fn from_existing_df(df: DataFrame) -> Self {
-        let schema = Arc::new(df.schema());
-        LogicalPlan::DataFrameScan {
-            df: Arc::new(df),
-            schema,
-            output_schema: None,
-            projection: None,
-            selection: None,
-        }
-        .into()
-    }
+                let output_schema = if file_options.with_columns.is_none() {
+                    None
+                } else {
+                    Some(Arc::new(update_scan_schema(
+                        &acc_projections,
+                        expr_arena,
+                        &file_info.schema,
+                        scan_type.sort_projection(&file_options),
+                    )?))
+                };
+
+                let lp = Scan {
+                    path,
+                    file_info,
+                    output_schema,
+                    scan_type,
+                    predicate,
+                    file_options,
+                };
+                Ok(lp)
+            }
+            Sort {
+                input,
+                by_column,
+                args,
+            } => {
+                if !acc_projections.is_empty() {
+                    // Make sure that the column(s) used for the sort is projected
+                    by_column.iter().for_each(|node| {
+                        aexpr_to_column_nodes(*node, expr_arena)
+                            .iter()
+                            .for_each(|root| {
+                                add_expr_to_accumulated(
+                                    *root,
+                                    &mut acc_projections,
+                                    &mut projected_names,
+                                    expr_arena,
+                                );
+                            })
+                    });
+                }
+
+                self.pushdown_and_assign(
+                    input,
+                    acc_projections,
+                    projected_names,
+                    projections_seen,
+                    lp_arena,
+                    expr_arena,
+                )?;
+                Ok(Sort {
+                    input,
+                    by_column,
+                    args,
+                })
+            }
+            Distinct { input, options } => {
+                // make sure that the set of unique columns is projected
+                if !acc_projections.is_empty() {
+                    if let Some(subset) = options.subset.as_ref() {
+                        subset.iter().for_each(|name| {
+                            add_str_to_accumulated(
+                                name,
+                                &mut acc_projections,
+                                &mut projected_names,
+                                expr_arena,
+                            )
+                        })
+                    } else {
+                        // distinct needs all columns
+                        let input_schema = lp_arena.get(input).schema(lp_arena);
+                        for name in input_schema.iter_names() {
+                            add_str_to_accumulated(
+                                name.as_str(),
+                                &mut acc_projections,
+                                &mut projected_names,
+                                expr_arena,
+                            )
+                        }
+                    }
+                }
 
-    pub fn sort(
-        self,
-        by_column: Vec<Expr>,
-        descending: Vec<bool>,
-        null_last: bool,
-        maintain_order: bool,
-    ) -> Self {
-        let schema = try_delayed!(self.0.schema(), &self.0, into);
-        let by_column = try_delayed!(rewrite_projections(by_column, &schema, &[]), &self.0, into);
-        LogicalPlan::Sort {
-            input: Box::new(self.0),
-            by_column,
-            args: SortArguments {
-                descending,
-                nulls_last: null_last,
-                slice: None,
+                self.pushdown_and_assign(
+                    input,
+                    acc_projections,
+                    projected_names,
+                    projections_seen,
+                    lp_arena,
+                    expr_arena,
+                )?;
+                Ok(Distinct { input, options })
+            }
+            Selection { predicate, input } => {
+                if !acc_projections.is_empty() {
+                    // make sure that the filter column is projected
+                    add_expr_to_accumulated(
+                        predicate,
+                        &mut acc_projections,
+                        &mut projected_names,
+                        expr_arena,
+                    );
+                };
+                self.pushdown_and_assign(
+                    input,
+                    acc_projections,
+                    projected_names,
+                    projections_seen,
+                    lp_arena,
+                    expr_arena,
+                )?;
+                Ok(Selection { predicate, input })
+            }
+            Aggregate {
+                input,
+                keys,
+                aggs,
+                apply,
+                schema,
                 maintain_order,
+                options,
+            } => process_groupby(
+                self,
+                input,
+                keys,
+                aggs,
+                apply,
+                schema,
+                maintain_order,
+                options,
+                acc_projections,
+                projected_names,
+                projections_seen,
+                lp_arena,
+                expr_arena,
+            ),
+            Join {
+                input_left,
+                input_right,
+                left_on,
+                right_on,
+                options,
+                ..
+            } => match options.args.how {
+                #[cfg(feature = "semi_anti_join")]
+                JoinType::Semi | JoinType::Anti => process_semi_anti_join(
+                    self,
+                    input_left,
+                    input_right,
+                    left_on,
+                    right_on,
+                    options,
+                    acc_projections,
+                    projected_names,
+                    projections_seen,
+                    lp_arena,
+                    expr_arena,
+                ),
+                _ => process_join(
+                    self,
+                    input_left,
+                    input_right,
+                    left_on,
+                    right_on,
+                    options,
+                    acc_projections,
+                    projected_names,
+                    projections_seen,
+                    lp_arena,
+                    expr_arena,
+                ),
             },
-        }
-        .into()
-    }
-
-    pub fn explode(self, columns: Vec<Expr>) -> Self {
-        let schema = try_delayed!(self.0.schema(), &self.0, into);
-        let columns = try_delayed!(rewrite_projections(columns, &schema, &[]), &self.0, into);
-
-        let mut schema = (**schema).clone();
+            HStack { input, exprs, .. } => process_hstack(
+                self,
+                input,
+                exprs.exprs(),
+                acc_projections,
+                projected_names,
+                projections_seen,
+                lp_arena,
+                expr_arena,
+            ),
+            ExtContext {
+                input, contexts, ..
+            } => {
+                // local projections are ignored. These are just root nodes
+                // complex expression will still be done later
+                let _local_projections = self.pushdown_and_assign_check_schema(
+                    input,
+                    acc_projections,
+                    projections_seen,
+                    lp_arena,
+                    expr_arena,
+                    false,
+                )?;
+
+                let mut new_schema = lp_arena
+                    .get(input)
+                    .schema(lp_arena)
+                    .as_ref()
+                    .as_ref()
+                    .clone();
 
-        // columns to string
-        let columns = columns
-            .iter()
-            .map(|e| {
-                if let Expr::Column(name) = e {
-                    if let Some(DataType::List(inner)) = schema.get(name) {
-                        let inner = *inner.clone();
-                        schema.with_column(name.as_ref().into(), inner);
+                for node in &contexts {
+                    let other_schema = lp_arena.get(*node).schema(lp_arena);
+                    for fld in other_schema.iter_fields() {
+                        if new_schema.get(fld.name()).is_none() {
+                            new_schema.with_column(fld.name, fld.dtype);
+                        }
                     }
-                    name.clone()
-                } else {
-                    panic!("expected column expression")
                 }
-            })
-            .collect();
 
-        LogicalPlan::MapFunction {
-            input: Box::new(self.0),
-            function: FunctionNode::Explode {
-                columns,
-                schema: Arc::new(schema),
-            },
-        }
-        .into()
-    }
-
-    pub fn melt(self, args: Arc<MeltArgs>) -> Self {
-        let schema = try_delayed!(self.0.schema(), &self.0, into);
-        let schema = det_melt_schema(&args, &schema);
-        LogicalPlan::MapFunction {
-            input: Box::new(self.0),
-            function: FunctionNode::Melt { args, schema },
-        }
-        .into()
-    }
-
-    pub fn distinct(self, options: DistinctOptions) -> Self {
-        LogicalPlan::Distinct {
-            input: Box::new(self.0),
-            options,
-        }
-        .into()
-    }
-
-    pub fn slice(self, offset: i64, len: IdxSize) -> Self {
-        LogicalPlan::Slice {
-            input: Box::new(self.0),
-            offset,
-            len,
-        }
-        .into()
-    }
-
-    pub fn join(
-        self,
-        other: LogicalPlan,
-        left_on: Vec<Expr>,
-        right_on: Vec<Expr>,
-        options: JoinOptions,
-    ) -> Self {
-        for e in left_on.iter().chain(right_on.iter()) {
-            if has_expr(e, |e| matches!(e, Expr::Alias(_, _))) {
-                return LogicalPlan::Error {
-                    input: Box::new(self.0),
-                    err: polars_err!(
-                        ComputeError:
-                        "'alias' is not allowed in a join key, use 'with_columns' first",
+                Ok(ExtContext {
+                    input,
+                    contexts,
+                    schema: Arc::new(new_schema),
+                })
+            }
+            MapFunction {
+                input,
+                ref function,
+            } => functions::process_functions(
+                self,
+                input,
+                function,
+                acc_projections,
+                projected_names,
+                projections_seen,
+                lp_arena,
+                expr_arena,
+            ),
+            lp @ Union { .. } => {
+                self.has_joins_or_unions = true;
+                process_generic(
+                    self,
+                    lp,
+                    acc_projections,
+                    projected_names,
+                    projections_seen,
+                    lp_arena,
+                    expr_arena,
+                )
+            }
+            // These nodes only have inputs and exprs, so we can use same logic.
+            lp @ Slice { .. } | lp @ FileSink { .. } => process_generic(
+                self,
+                lp,
+                acc_projections,
+                projected_names,
+                projections_seen,
+                lp_arena,
+                expr_arena,
+            ),
+            Cache { .. } => {
+                self.has_cache = true;
+                // projections above this cache will be accumulated and pushed down
+                // later
+                // the redundant projection will be cleaned in the fast projection optimization
+                // phase.
+                if acc_projections.is_empty() {
+                    Ok(logical_plan)
+                } else {
+                    Ok(
+                        ALogicalPlanBuilder::from_lp(logical_plan, expr_arena, lp_arena)
+                            .project(acc_projections)
+                            .build(),
                     )
-                    .into(),
                 }
-                .into();
             }
         }
-
-        let schema_left = try_delayed!(self.0.schema(), &self.0, into);
-        let schema_right = try_delayed!(other.schema(), &self.0, into);
-
-        let schema = try_delayed!(
-            det_join_schema(&schema_left, &schema_right, &left_on, &right_on, &options),
-            self.0,
-            into
-        );
-
-        LogicalPlan::Join {
-            input_left: Box::new(self.0),
-            input_right: Box::new(other),
-            schema,
-            left_on,
-            right_on,
-            options,
-        }
-        .into()
-    }
-    pub fn map_private(self, function: FunctionNode) -> Self {
-        LogicalPlan::MapFunction {
-            input: Box::new(self.0),
-            function,
-        }
-        .into()
     }
 
-    #[cfg(feature = "python")]
-    pub fn map_python(
-        self,
-        function: PythonFunction,
-        optimizations: AllowedOptimizations,
-        schema: Option<SchemaRef>,
-        validate_output: bool,
-    ) -> Self {
-        LogicalPlan::MapFunction {
-            input: Box::new(self.0),
-            function: FunctionNode::OpaquePython {
-                function,
-                schema,
-                predicate_pd: optimizations.predicate_pushdown,
-                projection_pd: optimizations.projection_pushdown,
-                streamable: optimizations.streaming,
-                validate_output,
-            },
-        }
-        .into()
-    }
-
-    pub fn map<F>(
-        self,
-        function: F,
-        optimizations: AllowedOptimizations,
-        schema: Option<Arc<dyn UdfSchema>>,
-        name: &'static str,
-    ) -> Self
-    where
-        F: DataFrameUdf + 'static,
-    {
-        let function = Arc::new(function);
-
-        LogicalPlan::MapFunction {
-            input: Box::new(self.0),
-            function: FunctionNode::Opaque {
-                function,
-                schema,
-                predicate_pd: optimizations.predicate_pushdown,
-                projection_pd: optimizations.projection_pushdown,
-                streamable: optimizations.streaming,
-                fmt_str: name,
-            },
-        }
-        .into()
-    }
-}
-
-pub(crate) fn det_melt_schema(args: &MeltArgs, input_schema: &Schema) -> SchemaRef {
-    let mut new_schema = args
-        .id_vars
-        .iter()
-        .map(|id| Field::new(id, input_schema.get(id).unwrap().clone()))
-        .collect::<Schema>();
-    let variable_name = args
-        .variable_name
-        .as_ref()
-        .cloned()
-        .unwrap_or_else(|| "variable".into());
-    let value_name = args
-        .value_name
-        .as_ref()
-        .cloned()
-        .unwrap_or_else(|| "value".into());
-
-    new_schema.with_column(variable_name, DataType::Utf8);
-
-    // We need to determine the supertype of all value columns.
-    let mut st = None;
-
-    // take all columns that are not in `id_vars` as `value_var`
-    if args.value_vars.is_empty() {
-        let id_vars = PlHashSet::from_iter(&args.id_vars);
-        for (name, dtype) in input_schema.iter() {
-            if !id_vars.contains(name) {
-                match &st {
-                    None => st = Some(dtype.clone()),
-                    Some(st_) => st = Some(try_get_supertype(st_, dtype).unwrap()),
-                }
-            }
-        }
-    } else {
-        for name in &args.value_vars {
-            let dtype = input_schema.get(name).unwrap();
-            match &st {
-                None => st = Some(dtype.clone()),
-                Some(st_) => st = Some(try_get_supertype(st_, dtype).unwrap()),
-            }
-        }
+    pub fn optimize(
+        &mut self,
+        logical_plan: ALogicalPlan,
+        lp_arena: &mut Arena<ALogicalPlan>,
+        expr_arena: &mut Arena<AExpr>,
+    ) -> PolarsResult<ALogicalPlan> {
+        let acc_projections = init_vec();
+        let names = init_set();
+        self.push_down(
+            logical_plan,
+            acc_projections,
+            names,
+            0,
+            lp_arena,
+            expr_arena,
+        )
     }
-    new_schema.with_column(value_name, st.unwrap());
-    Arc::new(new_schema)
 }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/conversion.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/conversion.rs`

 * *Files 1% similar despite different names*

```diff
@@ -141,18 +141,14 @@
             offset,
             length,
         } => AExpr::Slice {
             input: to_aexpr(*input, arena),
             offset: to_aexpr(*offset, arena),
             length: to_aexpr(*length, arena),
         },
-        Expr::Cache { input, id } => AExpr::Cache {
-            input: to_aexpr(*input, arena),
-            id,
-        },
         Expr::Wildcard => AExpr::Wildcard,
         Expr::Count => AExpr::Count,
         Expr::Nth(i) => AExpr::Nth(i),
         Expr::KeepName(_) => panic!("no keep_name expected at this point"),
         Expr::Exclude(_, _) => panic!("no exclude expected at this point"),
         Expr::RenameAlias { .. } => panic!("no `rename_alias` expected at this point"),
         Expr::Columns { .. } => panic!("no `columns` expected at this point"),
@@ -235,18 +231,18 @@
             selection: selection.map(|expr| to_aexpr(expr, expr_arena)),
         },
         LogicalPlan::Projection {
             expr,
             input,
             schema,
         } => {
-            let exp = expr.into_iter().map(|x| to_aexpr(x, expr_arena)).collect();
+            let expr = expr.into_iter().map(|x| to_aexpr(x, expr_arena)).collect();
             let i = to_alp(*input, expr_arena, lp_arena)?;
             ALogicalPlan::Projection {
-                expr: exp,
+                expr,
                 input: i,
                 schema,
             }
         }
         LogicalPlan::LocalProjection {
             expr,
             input,
@@ -596,18 +592,14 @@
             offset,
             length,
         } => Expr::Slice {
             input: Box::new(node_to_expr(input, expr_arena)),
             offset: Box::new(node_to_expr(offset, expr_arena)),
             length: Box::new(node_to_expr(length, expr_arena)),
         },
-        AExpr::Cache { input, id } => Expr::Cache {
-            input: Box::new(node_to_expr(input, expr_arena)),
-            id,
-        },
         AExpr::Count => Expr::Count,
         AExpr::Nth(i) => Expr::Nth(i),
         AExpr::Wildcard => Expr::Wildcard,
     }
 }
 
 fn nodes_to_exprs(nodes: &[Node], expr_arena: &Arena<AExpr>) -> Vec<Expr> {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/file_scan.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/file_scan.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/format.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/format.rs`

 * *Files 1% similar despite different names*

```diff
@@ -370,15 +370,14 @@
             } => write!(f, "{input:?}.slice(offset={offset:?}, length={length:?})",),
             Wildcard => write!(f, "*"),
             Exclude(column, names) => write!(f, "{column:?}.exclude({names:?})"),
             KeepName(e) => write!(f, "{e:?}.keep_name()"),
             RenameAlias { expr, .. } => write!(f, ".rename_alias({expr:?})"),
             Columns(names) => write!(f, "cols({names:?})"),
             DtypeColumn(dt) => write!(f, "dtype_columns({dt:?})"),
-            Cache { input, .. } => write!(f, "{input:?}.cache()"),
             Selector(_) => write!(f, "SELECTOR"),
         }
     }
 }
 
 impl Debug for Operator {
     fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/functions/drop.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/functions/drop.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/functions/merge_sorted.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/functions/merge_sorted.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/functions/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/functions/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/functions/python_udf.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/functions/python_udf.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/functions/rename.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/functions/rename.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/iterator.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/iterator.rs`

 * *Files 26% similar despite different names*

```diff
@@ -1,12 +1,11 @@
 use polars_arrow::error::PolarsResult;
 
 use crate::prelude::*;
 
-#[macro_export]
 macro_rules! push_expr {
     ($current_expr:expr, $push:ident, $iter:ident) => {{
         use Expr::*;
         match $current_expr {
             Nth(_) | Column(_) | Literal(_) | Wildcard | Columns(_) | DtypeColumn(_) | Count => {}
             Alias(e, _) => $push(e),
             BinaryExpr { left, op: _, right } => {
@@ -89,15 +88,14 @@
                 $push(length);
                 $push(offset);
                 // latest, so that it is popped first
                 $push(input);
             }
             Exclude(e, _) => $push(e),
             KeepName(e) => $push(e),
-            Cache { input, .. } => $push(input),
             RenameAlias { expr, .. } => $push(expr),
             // pass
             Selector(_) => {}
         }
     }};
 }
 
@@ -133,148 +131,58 @@
         while let Some(current_expr) = self.stack.pop() {
             // the order is important, we first modify the Expr
             // before we push its children on the stack.
             // The modification can make the children invalid.
             if !f(current_expr)? {
                 break;
             }
-            let mut push = |e: &'a mut Expr| self.stack.push(e);
-            push_expr!(current_expr, push, iter_mut);
+            current_expr.nodes_mut(&mut self.stack)
         }
         Ok(())
     }
 }
 
 pub struct ExprIter<'a> {
     stack: Vec<&'a Expr>,
 }
 
 impl<'a> Iterator for ExprIter<'a> {
     type Item = &'a Expr;
 
     fn next(&mut self) -> Option<Self::Item> {
         self.stack.pop().map(|current_expr| {
-            let mut push = |e: &'a Expr| self.stack.push(e);
-
-            push_expr!(current_expr, push, iter);
+            current_expr.nodes(&mut self.stack);
             current_expr
         })
     }
 }
 
+impl Expr {
+    pub fn nodes<'a>(&'a self, container: &mut Vec<&'a Expr>) {
+        let mut push = |e: &'a Expr| container.push(e);
+        push_expr!(self, push, iter);
+    }
+
+    pub fn nodes_mut<'a>(&'a mut self, container: &mut Vec<&'a mut Expr>) {
+        let mut push = |e: &'a mut Expr| container.push(e);
+        push_expr!(self, push, iter_mut);
+    }
+}
+
 impl<'a> IntoIterator for &'a Expr {
     type Item = &'a Expr;
     type IntoIter = ExprIter<'a>;
 
     fn into_iter(self) -> Self::IntoIter {
         let mut stack = Vec::with_capacity(4);
         stack.push(self);
         ExprIter { stack }
     }
 }
 
-impl AExpr {
-    /// Push nodes at this level to a pre-allocated stack
-    pub(crate) fn nodes<'a>(&'a self, container: &mut Vec<Node>) {
-        let mut push = |e: &'a Node| container.push(*e);
-        use AExpr::*;
-
-        match self {
-            Nth(_) | Column(_) | Literal(_) | Wildcard | Count => {}
-            Alias(e, _) => push(e),
-            BinaryExpr { left, op: _, right } => {
-                // reverse order so that left is popped first
-                push(right);
-                push(left);
-            }
-            Cast { expr, .. } => push(expr),
-            Cache { input, .. } => push(input),
-            Sort { expr, .. } => push(expr),
-            Take { expr, idx } => {
-                push(idx);
-                // latest, so that it is popped first
-                push(expr);
-            }
-            SortBy { expr, by, .. } => {
-                for node in by {
-                    push(node)
-                }
-                // latest, so that it is popped first
-                push(expr);
-            }
-            Filter { input, by } => {
-                push(by);
-                // latest, so that it is popped first
-                push(input);
-            }
-            Agg(agg_e) => {
-                use AAggExpr::*;
-                match agg_e {
-                    Max { input, .. } => push(input),
-                    Min { input, .. } => push(input),
-                    Mean(e) => push(e),
-                    Median(e) => push(e),
-                    NUnique(e) => push(e),
-                    First(e) => push(e),
-                    Last(e) => push(e),
-                    Implode(e) => push(e),
-                    Count(e) => push(e),
-                    Quantile { expr, .. } => push(expr),
-                    Sum(e) => push(e),
-                    AggGroups(e) => push(e),
-                    Std(e, _) => push(e),
-                    Var(e, _) => push(e),
-                }
-            }
-            Ternary {
-                truthy,
-                falsy,
-                predicate,
-            } => {
-                push(predicate);
-                push(falsy);
-                // latest, so that it is popped first
-                push(truthy);
-            }
-            AnonymousFunction { input, .. } | Function { input, .. } =>
-            // we iterate in reverse order, so that the lhs is popped first and will be found
-            // as the root columns/ input columns by `_suffix` and `_keep_name` etc.
-            {
-                input.iter().rev().for_each(push)
-            }
-            Explode(e) => push(e),
-            Window {
-                function,
-                partition_by,
-                order_by,
-                options: _,
-            } => {
-                for e in partition_by.iter().rev() {
-                    push(e);
-                }
-                if let Some(e) = order_by {
-                    push(e);
-                }
-                // latest so that it is popped first
-                push(function);
-            }
-            Slice {
-                input,
-                offset,
-                length,
-            } => {
-                push(length);
-                push(offset);
-                // latest so that it is popped first
-                push(input);
-            }
-        }
-    }
-}
-
 pub struct AExprIter<'a> {
     stack: Vec<Node>,
     arena: Option<&'a Arena<AExpr>>,
 }
 
 impl<'a> Iterator for AExprIter<'a> {
     type Item = (Node, &'a AExpr);
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/lit.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/lit.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/mod.rs`

 * *Files 4% similar despite different names*

```diff
@@ -12,37 +12,41 @@
 
 pub(crate) mod aexpr;
 pub(crate) mod alp;
 pub(crate) mod anonymous_scan;
 
 mod apply;
 mod builder;
+mod builder_alp;
+pub mod builder_functions;
 pub(crate) mod conversion;
 #[cfg(feature = "debugging")]
 pub(crate) mod debug;
 mod file_scan;
 mod format;
 mod functions;
 pub(crate) mod iterator;
 mod lit;
 pub(crate) mod optimizer;
 pub(crate) mod options;
 pub(crate) mod projection;
+mod projection_expr;
 #[cfg(feature = "python")]
 mod pyarrow;
 mod schema;
-#[cfg(feature = "meta")]
+#[cfg(any(feature = "meta", feature = "cse"))]
 pub(crate) mod tree_format;
 pub mod visitor;
 
 pub use aexpr::*;
 pub use alp::*;
 pub use anonymous_scan::*;
 pub use apply::*;
 pub use builder::*;
+pub use builder_alp::*;
 pub use conversion::*;
 pub use file_scan::*;
 pub use functions::*;
 pub use iterator::*;
 pub use lit::*;
 pub use optimizer::*;
 pub use schema::*;
@@ -138,15 +142,15 @@
 #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
 pub enum LogicalPlan {
     #[cfg_attr(feature = "serde", serde(skip))]
     AnonymousScan {
         function: Arc<dyn AnonymousScan>,
         file_info: FileInfo,
         predicate: Option<Expr>,
-        options: AnonymousScanOptions,
+        options: Arc<AnonymousScanOptions>,
     },
     #[cfg(feature = "python")]
     PythonScan { options: PythonOptions },
     /// Filter on a boolean mask
     Selection {
         input: Box<LogicalPlan>,
         predicate: Expr,
@@ -192,24 +196,24 @@
         input: Box<LogicalPlan>,
         keys: Arc<Vec<Expr>>,
         aggs: Vec<Expr>,
         schema: SchemaRef,
         #[cfg_attr(feature = "serde", serde(skip))]
         apply: Option<Arc<dyn DataFrameUdf>>,
         maintain_order: bool,
-        options: GroupbyOptions,
+        options: Arc<GroupbyOptions>,
     },
     /// Join operation
     Join {
         input_left: Box<LogicalPlan>,
         input_right: Box<LogicalPlan>,
         schema: SchemaRef,
         left_on: Vec<Expr>,
         right_on: Vec<Expr>,
-        options: JoinOptions,
+        options: Arc<JoinOptions>,
     },
     /// Adding columns to the table without a Join
     HStack {
         input: Box<LogicalPlan>,
         exprs: Vec<Expr>,
         schema: SchemaRef,
     },
@@ -271,8 +275,17 @@
     }
 }
 
 impl LogicalPlan {
     pub fn describe(&self) -> String {
         format!("{self:#?}")
     }
+
+    pub fn to_alp(self) -> PolarsResult<(Node, Arena<ALogicalPlan>, Arena<AExpr>)> {
+        let mut lp_arena = Arena::with_capacity(16);
+        let mut expr_arena = Arena::with_capacity(16);
+
+        let node = to_alp(self, &mut expr_arena, &mut lp_arena)?;
+
+        Ok((node, lp_arena, expr_arena))
+    }
 }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/cache_states.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/cache_states.rs`

 * *Files 2% similar despite different names*

```diff
@@ -70,14 +70,15 @@
 
             use ALogicalPlan::*;
             match lp {
                 // don't allow parallelism as caches need each others work
                 // also self-referencing plans can deadlock on the files they lock
                 Join { options, .. } if has_caches && options.allow_parallel => {
                     if let Join { options, .. } = lp_arena.get_mut(current_node) {
+                        let options = Arc::make_mut(options);
                         options.allow_parallel = false;
                     }
                 }
                 // don't allow parallelism as caches need each others work
                 // also self-referencing plans can deadlock on the files they lock
                 Union { options, .. } if has_caches && options.parallel => {
                     if let Union { options, .. } = lp_arena.get_mut(current_node) {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/cse.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/cse.rs`

 * *Files 6% similar despite different names*

```diff
@@ -84,20 +84,20 @@
     Some(())
 }
 
 fn expr_nodes_equal(a: &[Node], b: &[Node], expr_arena: &Arena<AExpr>) -> bool {
     a.len() == b.len()
         && a.iter()
             .zip(b)
-            .all(|(a, b)| node_to_expr(*a, expr_arena) == node_to_expr(*b, expr_arena))
+            .all(|(a, b)| AExpr::is_equal(*a, *b, expr_arena))
 }
 
 fn predicate_equal(a: Option<Node>, b: Option<Node>, expr_arena: &Arena<AExpr>) -> bool {
     match (a, b) {
-        (Some(l), Some(r)) => node_to_expr(l, expr_arena) == node_to_expr(r, expr_arena),
+        (Some(l), Some(r)) => AExpr::is_equal(l, r, expr_arena),
         (None, None) => true,
         _ => false,
     }
 }
 
 fn lp_node_equal(a: &ALogicalPlan, b: &ALogicalPlan, expr_arena: &Arena<AExpr>) -> bool {
     use ALogicalPlan::*;
@@ -131,15 +131,15 @@
             },
         ) => {
             path_left == path_right
                 && scan_type_left == scan_type_right
                 && predicate_equal(*predicate_left, *predicate_right, expr_arena)
         }
         (Selection { predicate: l, .. }, Selection { predicate: r, .. }) => {
-            node_to_expr(*l, expr_arena) == node_to_expr(*r, expr_arena)
+            AExpr::is_equal(*l, *r, expr_arena)
         }
         (Projection { expr: l, .. }, Projection { expr: r, .. })
         | (HStack { exprs: l, .. }, HStack { exprs: r, .. }) => expr_nodes_equal(l, r, expr_arena),
         (
             Slice {
                 offset: offset_l,
                 len: len_l,
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/delay_rechunk.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/delay_rechunk.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/drop_nulls.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/drop_nulls.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/fast_projection.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/fast_projection.rs`

 * *Files 1% similar despite different names*

```diff
@@ -28,15 +28,15 @@
         }
     }
 }
 
 fn impl_fast_projection(
     input: Node,
     expr: &[Node],
-    expr_arena: &mut Arena<AExpr>,
+    expr_arena: &Arena<AExpr>,
 ) -> Option<ALogicalPlan> {
     let mut columns = Vec::with_capacity(expr.len());
     for node in expr.iter() {
         if let AExpr::Column(name) = expr_arena.get(*node) {
             columns.push(name.clone())
         } else {
             break;
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/file_caching.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/file_caching.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/flatten_union.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/flatten_union.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/fused.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/fused.rs`

 * *Files 4% similar despite different names*

```diff
@@ -22,34 +22,43 @@
 fn check_eligible(
     left: &Node,
     right: &Node,
     lp_node: Node,
     expr_arena: &Arena<AExpr>,
     lp_arena: &Arena<ALogicalPlan>,
 ) -> PolarsResult<(Option<bool>, Option<Field>)> {
-    let Some(input_node) = lp_arena.get(lp_node).get_input() else {return Ok((None, None))};
+    let Some(input_node) = lp_arena.get(lp_node).get_input() else {
+        return Ok((None, None));
+    };
     let schema = lp_arena.get(input_node).schema(lp_arena);
     let field_left = expr_arena
         .get(*left)
         .to_field(&schema, Context::Default, expr_arena)?;
     let type_right = expr_arena
         .get(*right)
         .get_type(&schema, Context::Default, expr_arena)?;
     let type_left = &field_left.dtype;
-    if type_left.is_numeric() && type_right.is_numeric() {
+    // Exclude literals for now as these will not benefit from fused operations downstream #9857
+    // This optimization would also interfere with the `col -> lit` type-coercion rules
+    // And it might also interfere with constant folding which is a more suitable optimizations here
+    if type_left.is_numeric()
+        && type_right.is_numeric()
+        && !has_aexpr_literal(*left, expr_arena)
+        && !has_aexpr_literal(*right, expr_arena)
+    {
         Ok((Some(true), Some(field_left)))
     } else {
         Ok((Some(false), None))
     }
 }
 
 impl OptimizationRule for FusedArithmetic {
     #[allow(clippy::float_cmp)]
     fn optimize_expr(
-        &self,
+        &mut self,
         expr_arena: &mut Arena<AExpr>,
         expr_node: Node,
         lp_arena: &Arena<ALogicalPlan>,
         lp_node: Node,
     ) -> PolarsResult<Option<AExpr>> {
         let expr = expr_arena.get(expr_node);
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/mod.rs`

 * *Files 11% similar despite different names*

```diff
@@ -5,14 +5,16 @@
 
 mod cache_states;
 #[cfg(feature = "cse")]
 mod cse;
 mod delay_rechunk;
 mod drop_nulls;
 
+#[cfg(feature = "cse")]
+mod cse_expr;
 mod fast_projection;
 #[cfg(any(feature = "ipc", feature = "parquet", feature = "csv", feature = "cse"))]
 pub(crate) mod file_caching;
 mod flatten_union;
 #[cfg(feature = "fused")]
 mod fused;
 mod predicate_pushdown;
@@ -33,14 +35,18 @@
 pub use simplify_expr::{SimplifyBooleanRule, SimplifyExprRule};
 use slice_pushdown_lp::SlicePushDown;
 pub use stack_opt::{OptimizationRule, StackOptimizer};
 pub use type_coercion::TypeCoercionRule;
 
 use self::flatten_union::FlattenUnionRule;
 pub use crate::frame::{AllowedOptimizations, OptState};
+#[cfg(feature = "cse")]
+use crate::logical_plan::optimizer::cse_expr::CommonSubExprOptimizer;
+#[cfg(feature = "cse")]
+use crate::logical_plan::visitor::*;
 
 pub trait Optimize {
     fn optimize(&self, logical_plan: LogicalPlan) -> PolarsResult<LogicalPlan>;
 }
 
 // arbitrary constant to reduce reallocation.
 const HASHMAP_SIZE: usize = 16;
@@ -60,31 +66,33 @@
     let predicate_pushdown = opt_state.predicate_pushdown;
     let projection_pushdown = opt_state.projection_pushdown;
     let type_coercion = opt_state.type_coercion;
     let simplify_expr = opt_state.simplify_expr;
     let slice_pushdown = opt_state.slice_pushdown;
     let streaming = opt_state.streaming;
     #[cfg(feature = "cse")]
-    let cse = opt_state.common_subplan_elimination;
+    let comm_subplan_elim = opt_state.comm_subplan_elim;
+    #[cfg(feature = "cse")]
+    let comm_subexpr_elim = opt_state.comm_subexpr_elim;
 
     #[allow(unused_variables)]
-    let agg_scan_projection = opt_state.file_caching;
+    let agg_scan_projection = opt_state.file_caching && !streaming;
 
     // gradually fill the rules passed to the optimizer
     let opt = StackOptimizer {};
     let mut rules: Vec<Box<dyn OptimizationRule>> = Vec::with_capacity(8);
 
     // during debug we check if the optimizations have not modified the final schema
     #[cfg(debug_assertions)]
     let prev_schema = logical_plan.schema()?.into_owned();
 
     let mut lp_top = to_alp(logical_plan, expr_arena, lp_arena)?;
 
     #[cfg(feature = "cse")]
-    let cse_changed = if cse {
+    let cse_changed = if comm_subplan_elim {
         let (lp, changed) = cse::elim_cmn_subplans(lp_top, lp_arena, expr_arena);
         lp_top = lp;
         changed
     } else {
         false
     };
     #[cfg(not(feature = "cse"))]
@@ -173,14 +181,24 @@
     }
 
     rules.push(Box::new(ReplaceDropNulls {}));
     rules.push(Box::new(FlattenUnionRule {}));
 
     lp_top = opt.optimize_loop(&mut rules, expr_arena, lp_arena, lp_top)?;
 
+    // This one should run (nearly) last as this modifies the projections
+    #[cfg(feature = "cse")]
+    if comm_subexpr_elim {
+        let mut optimizer = CommonSubExprOptimizer::new(expr_arena);
+        lp_top = ALogicalPlanNode::with_context(lp_top, lp_arena, |alp_node| {
+            alp_node.rewrite(&mut optimizer)
+        })?
+        .node()
+    }
+
     // during debug we check if the optimizations have not modified the final schema
     #[cfg(debug_assertions)]
     {
         // only check by names because we may supercast types.
         assert_eq!(
             prev_schema.iter_names().collect::<Vec<_>>(),
             lp_arena
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/keys.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/keys.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/mod.rs`

 * *Files 12% similar despite different names*

```diff
@@ -1,38 +1,26 @@
+mod join;
 mod keys;
 mod rename;
 mod utils;
 
 use polars_core::datatypes::PlHashMap;
 use polars_core::prelude::*;
 use utils::*;
 
 use super::*;
 use crate::dsl::function_expr::FunctionExpr;
 use crate::logical_plan::{optimizer, Context};
+use crate::prelude::optimizer::predicate_pushdown::join::process_join;
 use crate::prelude::optimizer::predicate_pushdown::rename::process_rename;
 use crate::utils::{aexprs_to_schema, check_input_node, has_aexpr};
 
 #[derive(Default)]
 pub struct PredicatePushDown {}
 
-fn join_produces_null(how: &JoinType) -> bool {
-    #[cfg(feature = "asof_join")]
-    {
-        matches!(
-            how,
-            JoinType::Left | JoinType::Outer | JoinType::Cross | JoinType::AsOf(_)
-        )
-    }
-    #[cfg(not(feature = "asof_join"))]
-    {
-        matches!(how, JoinType::Left | JoinType::Outer | JoinType::Cross)
-    }
-}
-
 impl PredicatePushDown {
     fn optional_apply_predicate(
         &self,
         lp: ALogicalPlan,
         local_predicates: Vec<Node>,
         lp_arena: &mut Arena<ALogicalPlan>,
         expr_arena: &mut Arena<AExpr>,
@@ -357,112 +345,24 @@
                 input_left,
                 input_right,
                 left_on,
                 right_on,
                 schema,
                 options,
             } => {
-                let schema_left = lp_arena.get(input_left).schema(lp_arena);
-                let schema_right = lp_arena.get(input_right).schema(lp_arena);
-
-                let mut pushdown_left = optimizer::init_hashmap(Some(acc_predicates.len()));
-                let mut pushdown_right = optimizer::init_hashmap(Some(acc_predicates.len()));
-                let mut local_predicates = Vec::with_capacity(acc_predicates.len());
-
-                for (_, predicate) in acc_predicates {
-                    // unique and duplicated can be caused by joins
-                    #[cfg(feature = "is_unique")]
-                    let matches = {
-                        |e: &AExpr| matches!(e, AExpr::Function{
-                            function: FunctionExpr::Boolean(BooleanFunction::IsDuplicated)
-                                | FunctionExpr::Boolean(BooleanFunction::IsUnique),
-                            ..
-                        })
-                    };
-                    #[cfg(not(feature = "is_unique"))]
-                        let matches = {
-                        |_e: &AExpr| false
-                    };
-
-
-                    let checks_nulls =
-                        |e: &AExpr| matches!(e, AExpr::Function{
-                            function: FunctionExpr::Boolean(BooleanFunction::IsNotNull)
-                                | FunctionExpr::Boolean(BooleanFunction::IsNull),
-                            ..
-                        }) ||
-                            // any operation that checks for equality or ordering can be wrong because
-                            // the join can produce null values
-                            matches!(e, AExpr::BinaryExpr {op, ..} if !matches!(op, Operator::NotEq));
-                    if has_aexpr(predicate, expr_arena, matches)
-                        // join might create null values.
-                        || has_aexpr(predicate, expr_arena, checks_nulls)
-                        // only these join types produce null values
-                        && join_produces_null(&options.args.how) {
-                        local_predicates.push(predicate);
-                        continue;
-                    }
-                    // these indicate to which tables we are going to push down the predicate
-                    let mut filter_left = false;
-                    let mut filter_right = false;
-
-                    // predicate should not have an aggregation or window function as that would
-                    // be influenced by join
-                    #[allow(clippy::suspicious_else_formatting)]
-                    if !predicate_is_pushdown_boundary(predicate, expr_arena) {
-                        if check_input_node(predicate, &schema_left, expr_arena) {
-                            insert_and_combine_predicate(
-                                &mut pushdown_left,
-                                predicate,
-                                expr_arena,
-                            );
-                            filter_left = true;
-                        }
-                        // this is `else if` because if the predicate is in the left hand side
-                        // the right hand side should be renamed with the suffix.
-                        // in that case we should not push down as the user wants to filter on `x`
-                        // not on `x_rhs`.
-                        else if check_input_node(predicate, &schema_right, expr_arena)  {
-                            insert_and_combine_predicate(
-                                &mut pushdown_right,
-                                predicate,
-                                expr_arena,
-                            );
-                            filter_right = true;
-                        }
-                    }
-                    match (filter_left, filter_right, &options.args.how) {
-                        // if not pushed down on one of the tables we have to do it locally.
-                        (false, false, _) |
-                        // if left join and predicate only available in right table,
-                        // 'we should not filter right, because that would lead to
-                        // invalid results.
-                        // see: #2057
-                        (false, true, JoinType::Left)
-                        => {
-                            local_predicates.push(predicate);
-                            continue;
-                        },
-                        // business as usual
-                        _ => {}
-                    }
-                }
-
-                self.pushdown_and_assign(input_left, pushdown_left, lp_arena, expr_arena)?;
-                self.pushdown_and_assign(input_right, pushdown_right, lp_arena, expr_arena)?;
-
-                let lp = Join {
-                    input_left,
-                    input_right,
-                    left_on,
-                    right_on,
-                    schema,
-                    options,
-                };
-                Ok(self.optional_apply_predicate(lp, local_predicates, lp_arena, expr_arena))
+                process_join(self, lp_arena,
+                expr_arena,
+                input_left,
+                         input_right,
+                         left_on,
+                         right_on,
+                         schema,
+                         options,
+                    acc_predicates
+                )
             }
             MapFunction { ref function, .. } => {
                 if function.allow_predicate_pd()
                 {
                     match function {
                         FunctionNode::Rename {
                             existing,
@@ -613,25 +513,7 @@
         lp_arena: &mut Arena<ALogicalPlan>,
         expr_arena: &mut Arena<AExpr>,
     ) -> PolarsResult<ALogicalPlan> {
         let acc_predicates = PlHashMap::new();
         self.push_down(logical_plan, acc_predicates, lp_arena, expr_arena)
     }
 }
-
-#[cfg(test)]
-mod test {
-    use super::*;
-
-    #[test]
-    fn test_insert_and_combine_predicate() {
-        let mut acc_predicates = PlHashMap::with_capacity(32);
-        let mut expr_arena = Arena::new();
-
-        let predicate_expr = col("foo").gt(col("bar"));
-        let predicate = to_aexpr(predicate_expr.clone(), &mut expr_arena);
-        insert_and_combine_predicate(&mut acc_predicates, predicate, &mut expr_arena);
-        let root = *acc_predicates.get("foo").unwrap();
-        let expr = node_to_expr(root, &expr_arena);
-        assert_eq!(format!("{:?}", &expr), format!("{:?}", predicate_expr));
-    }
-}
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/rename.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/rename.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/utils.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/predicate_pushdown/utils.rs`

 * *Files 0% similar despite different names*

```diff
@@ -261,15 +261,15 @@
     }
     LoopBehavior::Nothing
 }
 
 /// Implementation for both Hstack and Projection
 pub(super) fn rewrite_projection_node(
     expr_arena: &mut Arena<AExpr>,
-    lp_arena: &mut Arena<ALogicalPlan>,
+    lp_arena: &Arena<ALogicalPlan>,
     acc_predicates: &mut PlHashMap<Arc<str>, Node>,
     projections: Vec<Node>,
     input: Node,
 ) -> (Vec<Node>, Vec<Node>)
 where
 {
     let mut local_predicates = Vec::with_capacity(acc_predicates.len());
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/functions/melt.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/functions/melt.rs`

 * *Files 12% similar despite different names*

```diff
@@ -39,14 +39,20 @@
             input,
             acc_projections,
             projected_names,
             projections_seen,
             lp_arena,
             expr_arena,
         )?;
+
+        // re-make melt node so that the schema is updated
+        let lp = ALogicalPlanBuilder::new(input, expr_arena, lp_arena)
+            .melt(args.clone())
+            .build();
+
         if local_projections.is_empty() {
             Ok(lp)
         } else {
             Ok(ALogicalPlanBuilder::from_lp(lp, expr_arena, lp_arena)
                 .project(local_projections)
                 .build())
         }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/functions/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/functions/mod.rs`

 * *Files 11% similar despite different names*

```diff
@@ -11,19 +11,14 @@
     function: &FunctionNode,
     mut acc_projections: Vec<Node>,
     mut projected_names: PlHashSet<Arc<str>>,
     projections_seen: usize,
     lp_arena: &mut Arena<ALogicalPlan>,
     expr_arena: &mut Arena<AExpr>,
 ) -> PolarsResult<ALogicalPlan> {
-    let lp = ALogicalPlan::MapFunction {
-        input,
-        function: function.clone(),
-    };
-
     use FunctionNode::*;
     match function {
         Rename {
             existing,
             new,
             swapping,
         } => {
@@ -39,41 +34,59 @@
                 input,
                 acc_projections,
                 projected_names,
                 projections_seen,
                 lp_arena,
                 expr_arena,
             )?;
+
+            let lp = ALogicalPlan::MapFunction {
+                input,
+                function: function.clone(),
+            };
             Ok(lp)
         }
         Explode { columns, .. } => {
             columns.iter().for_each(|name| {
                 add_str_to_accumulated(name, &mut acc_projections, &mut projected_names, expr_arena)
             });
             proj_pd.pushdown_and_assign(
                 input,
                 acc_projections,
                 projected_names,
                 projections_seen,
                 lp_arena,
                 expr_arena,
             )?;
-            Ok(lp)
+            Ok(ALogicalPlanBuilder::new(input, expr_arena, lp_arena)
+                .explode(columns.clone())
+                .build())
+        }
+        Melt { args, .. } => {
+            let lp = ALogicalPlan::MapFunction {
+                input,
+                function: function.clone(),
+            };
+
+            process_melt(
+                proj_pd,
+                lp,
+                args,
+                input,
+                acc_projections,
+                projections_seen,
+                lp_arena,
+                expr_arena,
+            )
         }
-        Melt { args, .. } => process_melt(
-            proj_pd,
-            lp,
-            args,
-            input,
-            acc_projections,
-            projections_seen,
-            lp_arena,
-            expr_arena,
-        ),
         _ => {
+            let lp = ALogicalPlan::MapFunction {
+                input,
+                function: function.clone(),
+            };
             if function.allow_projection_pd() && !acc_projections.is_empty() {
                 let original_acc_projection_len = acc_projections.len();
 
                 // add columns needed for the function.
                 for name in function.additional_projection_pd_columns().as_ref() {
                     let node = expr_arena.add(AExpr::Column(name.clone()));
                     add_expr_to_accumulated(
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/generic.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/generic.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/groupby.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/groupby.rs`

 * *Files 2% similar despite different names*

```diff
@@ -5,15 +5,15 @@
     proj_pd: &mut ProjectionPushDown,
     input: Node,
     keys: Vec<Node>,
     aggs: Vec<Node>,
     apply: Option<Arc<dyn DataFrameUdf>>,
     schema: SchemaRef,
     maintain_order: bool,
-    options: GroupbyOptions,
+    options: Arc<GroupbyOptions>,
     acc_projections: Vec<Node>,
     projected_names: PlHashSet<Arc<str>>,
     projections_seen: usize,
     lp_arena: &mut Arena<ALogicalPlan>,
     expr_arena: &mut Arena<AExpr>,
 ) -> PolarsResult<ALogicalPlan> {
     use ALogicalPlan::*;
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/hstack.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/hstack.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/joins.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/joins.rs`

 * *Files 1% similar despite different names*

```diff
@@ -31,15 +31,15 @@
 #[cfg(feature = "asof_join")]
 pub(super) fn process_asof_join(
     proj_pd: &mut ProjectionPushDown,
     input_left: Node,
     input_right: Node,
     left_on: Vec<Node>,
     right_on: Vec<Node>,
-    options: JoinOptions,
+    options: Arc<JoinOptions>,
     acc_projections: Vec<Node>,
     _projected_names: PlHashSet<Arc<str>>,
     projections_seen: usize,
     lp_arena: &mut Arena<ALogicalPlan>,
     expr_arena: &mut Arena<AExpr>,
 ) -> PolarsResult<ALogicalPlan> {
     proj_pd.has_joins_or_unions = true;
@@ -47,15 +47,17 @@
     let n = acc_projections.len() * 2;
     let mut pushdown_left = Vec::with_capacity(n);
     let mut pushdown_right = Vec::with_capacity(n);
     let mut names_left = PlHashSet::with_capacity(n);
     let mut names_right = PlHashSet::with_capacity(n);
     let mut local_projection = Vec::with_capacity(n);
 
-    let JoinType::AsOf(asof_options) = &options.args.how else {unreachable!()};
+    let JoinType::AsOf(asof_options) = &options.args.how else {
+        unreachable!()
+    };
 
     // if there are no projections we don't have to do anything (all columns are projected)
     // otherwise we build local projections to sort out proper column names due to the
     // join operation
     //
     // Joins on columns with different names, for example
     // left_on = "a", right_on = "b
@@ -192,15 +194,15 @@
 #[allow(clippy::too_many_arguments)]
 pub(super) fn process_join(
     proj_pd: &mut ProjectionPushDown,
     input_left: Node,
     input_right: Node,
     left_on: Vec<Node>,
     right_on: Vec<Node>,
-    options: JoinOptions,
+    options: Arc<JoinOptions>,
     acc_projections: Vec<Node>,
     _projected_names: PlHashSet<Arc<str>>,
     projections_seen: usize,
     lp_arena: &mut Arena<ALogicalPlan>,
     expr_arena: &mut Arena<AExpr>,
 ) -> PolarsResult<ALogicalPlan> {
     #[cfg(feature = "asof_join")]
@@ -432,15 +434,15 @@
 //
 // col("foo_right")  to col("foo").alias("foo_right")
 fn resolve_join_suffixes(
     input_left: Node,
     input_right: Node,
     left_on: Vec<Node>,
     right_on: Vec<Node>,
-    options: JoinOptions,
+    options: Arc<JoinOptions>,
     lp_arena: &mut Arena<ALogicalPlan>,
     expr_arena: &mut Arena<AExpr>,
     local_projection: &mut [Node],
 ) -> ALogicalPlan {
     let suffix = options.args.suffix();
     let alp = ALogicalPlanBuilder::new(input_left, expr_arena, lp_arena)
         .join(input_right, left_on, right_on, options.clone())
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/projection.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/projection.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/rename.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/rename.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/semi_anti_join.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/projection_pushdown/semi_anti_join.rs`

 * *Files 1% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 #[allow(clippy::too_many_arguments)]
 pub(super) fn process_semi_anti_join(
     proj_pd: &mut ProjectionPushDown,
     input_left: Node,
     input_right: Node,
     left_on: Vec<Node>,
     right_on: Vec<Node>,
-    options: JoinOptions,
+    options: Arc<JoinOptions>,
     acc_projections: Vec<Node>,
     _projected_names: PlHashSet<Arc<str>>,
     projections_seen: usize,
     lp_arena: &mut Arena<ALogicalPlan>,
     expr_arena: &mut Arena<AExpr>,
 ) -> PolarsResult<ALogicalPlan> {
     proj_pd.has_joins_or_unions = true;
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/simplify_expr.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/simplify_expr.rs`

 * *Files 4% similar despite different names*

```diff
@@ -103,15 +103,15 @@
     }}
 }
 
 pub struct SimplifyBooleanRule {}
 
 impl OptimizationRule for SimplifyBooleanRule {
     fn optimize_expr(
-        &self,
+        &mut self,
         expr_arena: &mut Arena<AExpr>,
         expr_node: Node,
         _: &Arena<ALogicalPlan>,
         _: Node,
     ) -> PolarsResult<Option<AExpr>> {
         let expr = expr_arena.get(expr_node);
         let out = match expr {
@@ -436,15 +436,15 @@
 }
 
 pub struct SimplifyExprRule {}
 
 impl OptimizationRule for SimplifyExprRule {
     #[allow(clippy::float_cmp)]
     fn optimize_expr(
-        &self,
+        &mut self,
         expr_arena: &mut Arena<AExpr>,
         expr_node: Node,
         _lp_arena: &Arena<ALogicalPlan>,
         _lp_node: Node,
     ) -> PolarsResult<Option<AExpr>> {
         let expr = expr_arena.get(expr_node);
 
@@ -619,19 +619,20 @@
                         descending: descending.iter().map(|r| !*r).collect(),
                     }),
                     // TODO: add support for cumsum and other operation that allow reversing.
                     _ => None,
                 }
             }
             AExpr::Cast {
-                expr, data_type, ..
+                expr,
+                data_type,
+                strict,
             } => {
                 let input = expr_arena.get(*expr);
-                // faster casts (we only do strict casts)
-                inline_cast(input, data_type)
+                inline_cast(input, data_type, *strict)?
             }
             // flatten nested concat_str calls
             #[cfg(all(feature = "strings", feature = "concat_str"))]
             AExpr::Function {
                 input,
                 function:
                     ref function @ FunctionExpr::StringExpr(StringFunction::ConcatHorizontal(sep)),
@@ -661,25 +662,63 @@
 
             _ => None,
         };
         Ok(out)
     }
 }
 
-fn inline_cast(input: &AExpr, dtype: &DataType) -> Option<AExpr> {
-    match (input, dtype) {
-        #[cfg(feature = "dtype-duration")]
-        (AExpr::Literal(lv), _) if !matches!(dtype, DataType::Unknown) => {
-            let av = lv.to_anyvalue()?;
-            let out = av.cast(dtype).ok()?;
-            let lv: LiteralValue = out.try_into().ok()?;
-            Some(AExpr::Literal(lv))
-        }
-        _ => None,
-    }
+fn inline_cast(input: &AExpr, dtype: &DataType, strict: bool) -> PolarsResult<Option<AExpr>> {
+    let lv = match (input, dtype) {
+        (AExpr::Literal(lv), _) if !matches!(dtype, DataType::Unknown) => match lv {
+            LiteralValue::Series(s) => {
+                let s = if strict {
+                    s.strict_cast(dtype)
+                } else {
+                    s.cast(dtype)
+                }?;
+                LiteralValue::Series(SpecialEq::new(s))
+            }
+            _ => {
+                let Some(av) = lv.to_anyvalue() else {
+                    return Ok(None);
+                };
+                match (av, dtype) {
+                    // casting null always remains null
+                    (AnyValue::Null, _) => return Ok(None),
+                    // series cast should do this one
+                    #[cfg(feature = "dtype-datetime")]
+                    (AnyValue::Datetime(_, _, _), DataType::Datetime(_, _)) => return Ok(None),
+                    #[cfg(feature = "dtype-duration")]
+                    (AnyValue::Duration(_, _), _) => return Ok(None),
+                    #[cfg(feature = "dtype-categorical")]
+                    (AnyValue::Categorical(_, _, _), _) | (_, DataType::Categorical(_)) => {
+                        return Ok(None)
+                    }
+                    #[cfg(feature = "dtype-struct")]
+                    (_, DataType::Struct(_)) => return Ok(None),
+                    (av, _) => {
+                        // raise in debug builds so we can fix them
+                        // in release we continue and apply the cast later
+                        #[cfg(debug_assertions)]
+                        let out = { av.cast(dtype)? };
+                        #[cfg(not(debug_assertions))]
+                        let out = {
+                            match av.cast(&dtype) {
+                                Ok(out) => out,
+                                Err(_) => return Ok(None),
+                            }
+                        };
+                        out.try_into()?
+                    }
+                }
+            }
+        },
+        _ => return Ok(None),
+    };
+    Ok(Some(AExpr::Literal(lv)))
 }
 
 #[test]
 #[cfg(feature = "dtype-i8")]
 fn test_expr_to_aexp() {
     use super::*;
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/slice_pushdown_expr.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/slice_pushdown_expr.rs`

 * *Files 7% similar despite different names*

```diff
@@ -6,15 +6,15 @@
         offset,
         length,
     })
 }
 
 impl OptimizationRule for SlicePushDown {
     fn optimize_expr(
-        &self,
+        &mut self,
         expr_arena: &mut Arena<AExpr>,
         expr_node: Node,
         _lp_arena: &Arena<ALogicalPlan>,
         _lp_node: Node,
     ) -> PolarsResult<Option<AExpr>> {
         if let AExpr::Slice {
             input,
@@ -23,19 +23,21 @@
         } = expr_arena.get(expr_node)
         {
             let offset = *offset;
             let length = *length;
 
             use AExpr::*;
             let out = match expr_arena.get(*input) {
-                m @ Alias(..) | m @ Cast { .. } => {
-                    let m = m.clone();
-                    let input = m.get_input().first();
+                ae @ Alias(..) | ae @ Cast { .. } => {
+                    let ae = ae.clone();
+                    self.scratch.clear();
+                    ae.nodes(&mut self.scratch);
+                    let input = self.scratch[0];
                     let new_input = pushdown(input, offset, length, expr_arena);
-                    Some(m.replace_inputs(&[new_input]))
+                    Some(ae.replace_inputs(&[new_input]))
                 }
                 Literal(lv) => {
                     match lv {
                         LiteralValue::Series(_) => None,
                         LiteralValue::Range { .. } => None,
                         // no need to slice a literal value of unit length
                         lv => Some(Literal(lv.clone())),
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/slice_pushdown_lp.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/slice_pushdown_lp.rs`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,28 @@
 use polars_core::prelude::*;
 
 use crate::prelude::*;
 
 pub(super) struct SlicePushDown {
     streaming: bool,
+    pub scratch: Vec<Node>,
 }
 
 #[derive(Copy, Clone)]
 struct State {
     offset: i64,
     len: IdxSize,
 }
 
 impl SlicePushDown {
     pub(super) fn new(streaming: bool) -> Self {
-        Self { streaming }
+        Self {
+            streaming,
+            scratch: vec![],
+        }
     }
 
     // slice will be done at this node if we found any
     // we also stop optimization
     fn no_pushdown_finish_opt(
         &self,
         lp: ALogicalPlan,
@@ -106,15 +110,16 @@
                 output_schema,
                 predicate,
                 mut options,
             },
                 // TODO! we currently skip slice pushdown if there is a predicate.
                 // we can modify the readers to only limit after predicates have been applied
                 Some(state)) if state.offset == 0 && predicate.is_none() => {
-                options.n_rows = Some(state.len as usize);
+                let mut_options = Arc::make_mut(&mut options);
+                mut_options.n_rows = Some(state.len as usize);
                 let lp = AnonymousScan {
                     function,
                     file_info,
                     output_schema,
                     predicate,
                     options,
                 };
@@ -198,15 +203,16 @@
 
                 let lp_right = lp_arena.take(input_right);
                 let lp_right = self.pushdown(lp_right, None, lp_arena, expr_arena)?;
                 let input_right = lp_arena.add(lp_right);
 
                 // then assign the slice state to the join operation
 
-                options.args.slice = Some((state.offset, state.len as usize));
+                let mut_options = Arc::make_mut(&mut options);
+                mut_options.args.slice = Some((state.offset, state.len as usize));
 
                 Ok(Join {
                     input_left,
                     input_right,
                     schema,
                     left_on,
                     right_on,
@@ -215,15 +221,16 @@
             }
             (Aggregate { input, keys, aggs, schema, apply, maintain_order, mut options }, Some(state)) => {
                 // first restart optimization in inputs and get the updated LP
                 let input_lp = lp_arena.take(input);
                 let input_lp = self.pushdown(input_lp, None, lp_arena, expr_arena)?;
                 let input= lp_arena.add(input_lp);
 
-                options.slice = Some((state.offset, state.len as usize));
+                let mut_options= Arc::make_mut(&mut options);
+                mut_options.slice = Some((state.offset, state.len as usize));
 
                 Ok(Aggregate {
                     input,
                     keys,
                     aggs,
                     schema,
                     apply,
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/stack_opt.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/stack_opt.rs`

 * *Files 2% similar despite different names*

```diff
@@ -62,15 +62,15 @@
                     {
                         let expr = unsafe { expr_arena.get_unchecked(current_expr_node) };
                         // don't apply rules to `col`, `lit` etc.
                         if expr.is_leaf() {
                             continue;
                         }
                     }
-                    for rule in rules.iter() {
+                    for rule in rules.iter_mut() {
                         // keep iterating over same rule
                         while let Some(x) = rule.optimize_expr(
                             expr_arena,
                             current_expr_node,
                             lp_arena,
                             current_node,
                         )? {
@@ -100,15 +100,15 @@
         _lp_arena: &mut Arena<ALogicalPlan>,
         _expr_arena: &mut Arena<AExpr>,
         _node: Node,
     ) -> Option<ALogicalPlan> {
         None
     }
     fn optimize_expr(
-        &self,
+        &mut self,
         _expr_arena: &mut Arena<AExpr>,
         _expr_node: Node,
         _lp_arena: &Arena<ALogicalPlan>,
         _lp_node: Node,
     ) -> PolarsResult<Option<AExpr>> {
         Ok(None)
     }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/type_coercion/binary.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/type_coercion/binary.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/optimizer/type_coercion/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/optimizer/type_coercion/mod.rs`

 * *Files 0% similar despite different names*

```diff
@@ -269,15 +269,15 @@
         ae.get_type(input_schema, Context::Default, expr_arena)
             .ok()?,
     ))
 }
 
 impl OptimizationRule for TypeCoercionRule {
     fn optimize_expr(
-        &self,
+        &mut self,
         expr_arena: &mut Arena<AExpr>,
         expr_node: Node,
         lp_arena: &Arena<ALogicalPlan>,
         lp_node: Node,
     ) -> PolarsResult<Option<AExpr>> {
         let expr = expr_arena.get(expr_node);
         let out = match *expr {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/options.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/options.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/projection.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/projection.rs`

 * *Files 2% similar despite different names*

```diff
@@ -20,14 +20,25 @@
         }
         // always keep iterating all inputs
         true
     });
     expr
 }
 
+pub fn remove_exclude(mut expr: Expr) -> Expr {
+    expr.mutate().apply(|e| {
+        if let Expr::Exclude(input, _) = e {
+            *e = remove_exclude(std::mem::take(input));
+        }
+        // always keep iterating all inputs
+        true
+    });
+    expr
+}
+
 fn rewrite_special_aliases(expr: Expr) -> PolarsResult<Expr> {
     // the blocks are added by cargo fmt
     #[allow(clippy::blocks_in_if_conditions)]
     if has_expr(&expr, |e| {
         matches!(e, Expr::KeepName(_) | Expr::RenameAlias { .. })
     }) {
         match expr {
@@ -98,26 +109,26 @@
     pattern: &str,
     exclude: &PlHashSet<Arc<str>>,
 ) -> PolarsResult<()> {
     let re =
         regex::Regex::new(pattern).map_err(|e| polars_err!(ComputeError: "invalid regex {}", e))?;
     for name in schema.iter_names() {
         if re.is_match(name) && !exclude.contains(name.as_str()) {
-            let mut new_expr = expr.clone();
+            let mut new_expr = remove_exclude(expr.clone());
 
             new_expr.mutate().apply(|e| match &e {
                 Expr::Column(pat) if pat.as_ref() == pattern => {
                     *e = Expr::Column(Arc::from(name.as_str()));
                     true
                 }
                 _ => true,
             });
 
             let new_expr = rewrite_special_aliases(new_expr)?;
-            result.push(new_expr)
+            result.push(new_expr);
         }
     }
     Ok(())
 }
 
 pub(crate) fn is_regex_projection(name: &str) -> bool {
     name.starts_with('^') && name.ends_with('$')
@@ -127,36 +138,23 @@
 /// This function searches for a regex expression in `col("..")` and expands the columns
 /// that are selected by that regex in `result`. The regex should start with `^` and end with `$`.
 fn replace_regex(
     expr: &Expr,
     result: &mut Vec<Expr>,
     schema: &Schema,
     exclude: &PlHashSet<Arc<str>>,
-    has_exclude: bool,
 ) -> PolarsResult<()> {
     let roots = expr_to_leaf_column_names(expr);
     let mut regex = None;
     for name in &roots {
         if is_regex_projection(name) {
             match regex {
                 None => {
                     regex = Some(name);
-                    if has_exclude {
-                        // iterate until we find the Exclude node
-                        // we remove that node from the expression
-                        // the `exclude` set is already filled
-                        // by prepare exclude
-                        for e in expr.into_iter() {
-                            if let Expr::Exclude(e, _) = e {
-                                expand_regex(e, result, schema, name, exclude)?;
-                                return Ok(());
-                            }
-                        }
-                    }
-                    expand_regex(expr, result, schema, name, exclude)?
+                    expand_regex(expr, result, schema, name, exclude)?;
                 }
                 Some(r) => {
                     polars_ensure!(
                         r == name,
                         ComputeError:
                         "an expression is not allowed to have different regexes"
                     )
@@ -272,21 +270,15 @@
                     // expanding the matches in the schema we reuse the
                     // `replace_regex` func; this is a bit slower but DRY.
                     let mut buf = vec![];
                     for to_exclude_single in to_exclude {
                         match to_exclude_single {
                             Excluded::Name(name) => {
                                 let e = Expr::Column(name.clone());
-                                replace_regex(
-                                    &e,
-                                    &mut buf,
-                                    schema,
-                                    &Default::default(),
-                                    has_exclude,
-                                )?;
+                                replace_regex(&e, &mut buf, schema, &Default::default())?;
                                 // we cannot loop because of bchck
                                 while let Some(col) = buf.pop() {
                                     if let Expr::Column(name) = col {
                                         exclude.insert(name);
                                     }
                                 }
                             }
@@ -516,15 +508,15 @@
     // can have multiple column names due to a regex
     else {
         #[allow(clippy::collapsible_else_if)]
         #[cfg(feature = "regex")]
         {
             // keep track of column excluded from the dtypes
             let exclude = prepare_excluded(&expr, schema, keys, flags.has_exclude)?;
-            replace_regex(&expr, result, schema, &exclude, flags.has_exclude)?;
+            replace_regex(&expr, result, schema, &exclude)?;
         }
         #[cfg(not(feature = "regex"))]
         {
             let expr = rewrite_special_aliases(expr)?;
             result.push(expr)
         }
     }
@@ -592,15 +584,17 @@
             let mut members = PlIndexSet::new();
             replace_selector_inner(swapped, &mut members, &mut vec![], schema, keys)?;
 
             *e = Expr::Columns(
                 members
                     .into_iter()
                     .map(|e| {
-                        let Expr::Column(name) = e else {unreachable!()};
+                        let Expr::Column(name) = e else {
+                            unreachable!()
+                        };
                         name.to_string()
                     })
                     .collect(),
             );
 
             Ok(true)
         }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/pyarrow.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/pyarrow.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/schema.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/schema.rs`

 * *Files 2% similar despite different names*

```diff
@@ -127,20 +127,23 @@
                 input_right,
                 mut options,
                 schema,
                 left_on,
                 right_on,
             } = lp_arena.take(root)
             {
+                let mut_options = Arc::make_mut(&mut options);
                 let (known_size, estimated_size, filter_count_left) =
                     set_estimated_row_counts(input_left, lp_arena, expr_arena, 0);
-                options.rows_left = estimate_sizes(known_size, estimated_size, filter_count_left);
+                mut_options.rows_left =
+                    estimate_sizes(known_size, estimated_size, filter_count_left);
                 let (known_size, estimated_size, filter_count_right) =
                     set_estimated_row_counts(input_right, lp_arena, expr_arena, 0);
-                options.rows_right = estimate_sizes(known_size, estimated_size, filter_count_right);
+                mut_options.rows_right =
+                    estimate_sizes(known_size, estimated_size, filter_count_right);
 
                 let mut out = match options.args.how {
                     JoinType::Left => {
                         let (known_size, estimated_size) = options.rows_left;
                         (known_size, estimated_size, filter_count_left)
                     }
                     JoinType::Cross | JoinType::Outer => {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/tree_format.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/tree_format.rs`

 * *Files 1% similar despite different names*

```diff
@@ -51,15 +51,14 @@
             }
             AExpr::Function { function, .. } => return write!(f, "function: {function}"),
             AExpr::Window { .. } => "window",
             AExpr::Wildcard => "*",
             AExpr::Slice { .. } => "slice",
             AExpr::Count => "count",
             AExpr::Nth(v) => return write!(f, "nth({})", v),
-            AExpr::Cache { id, .. } => return write!(f, "cache({id:x})"),
         };
 
         write!(f, "{s}")
     }
 }
 
 pub(crate) struct TreeFmtVisitor {
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/logical_plan/visitor/mod.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/logical_plan/visitor/mod.rs`

 * *Files 14% similar despite different names*

```diff
@@ -1,14 +1,16 @@
 //! Defines different visitor patterns and for any tree.
 
 use polars_arrow::error::PolarsResult;
 mod expr;
+mod lp;
 mod visitors;
 
 pub use expr::*;
+pub use lp::*;
 pub use visitors::*;
 
 /// Controls how the [`TreeWalker`] recursion should proceed for [`TreeWalker::visit`].
 #[derive(Debug)]
 pub enum VisitRecursion {
     /// Continue the visit to this node tree.
     Continue,
@@ -18,17 +20,17 @@
     Stop,
 }
 
 /// Controls how the [`TreeWalker`] recursion should proceed for [`TreeWalker::rewrite`].
 #[derive(Debug)]
 pub enum RewriteRecursion {
     /// Continue the visit to this node and children.
-    Continue,
+    MutateAndContinue,
     /// Don't mutate this node, continue visiting the children
-    Skip,
+    NoMutateAndContinue,
     /// Stop and return.
     /// This doesn't visit the children
     Stop,
     /// Call `op` immediately and return
     /// This doesn't visit the children
     MutateAndStop,
 }
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/prelude.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/prelude.rs`

 * *Files 14% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 pub(crate) use polars_time::{
     chunkedarray::{RollingOptions, RollingOptionsImpl},
     Duration,
 };
 pub use polars_utils::arena::{Arena, Node};
 
 pub use crate::dsl::*;
-pub(crate) use crate::logical_plan::alp::*;
 pub(crate) use crate::logical_plan::conversion::*;
 #[cfg(feature = "debugging")]
 pub use crate::logical_plan::debug::*;
 pub(crate) use crate::logical_plan::iterator::*;
 pub use crate::logical_plan::options::*;
 pub use crate::logical_plan::*;
 pub use crate::utils::*;
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-plan/src/utils.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-plan/src/utils.rs`

 * *Files 3% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 use std::fmt::Formatter;
 use std::iter::FlatMap;
 use std::sync::Arc;
 
 use polars_core::prelude::*;
 use smartstring::alias::String as SmartString;
 
+use crate::constants::CSE_REPLACED;
 use crate::logical_plan::iterator::ArenaExprIter;
 use crate::logical_plan::Context;
 use crate::prelude::names::COUNT;
 use crate::prelude::*;
 
 /// Utility to write comma delimited strings
 pub fn comma_delimited(mut s: String, items: &[SmartString]) -> String {
@@ -120,14 +121,18 @@
     arena.iter(current_node).any(|(_node, e)| matches(e))
 }
 
 pub fn has_aexpr_window(current_node: Node, arena: &Arena<AExpr>) -> bool {
     has_aexpr(current_node, arena, |e| matches!(e, AExpr::Window { .. }))
 }
 
+pub fn has_aexpr_literal(current_node: Node, arena: &Arena<AExpr>) -> bool {
+    has_aexpr(current_node, arena, |e| matches!(e, AExpr::Literal(_)))
+}
+
 /// Can check if an expression tree has a matching_expr. This
 /// requires a dummy expression to be created that will be used to patter match against.
 pub(crate) fn has_expr<F>(current_expr: &Expr, matches: F) -> bool
 where
     F: Fn(&Expr) -> bool,
 {
     current_expr.into_iter().any(matches)
@@ -215,36 +220,34 @@
         Some(_) => unreachable!(),
         None => polars_bail!(
             ComputeError: "no root column name found",
         ),
     }
 }
 
-fn is_leaf_aexpr(ae: &AExpr) -> bool {
+fn is_column_aexpr(ae: &AExpr) -> bool {
     matches!(ae, AExpr::Column(_) | AExpr::Wildcard)
 }
 
 #[allow(clippy::type_complexity)]
-pub(crate) fn aexpr_to_leaf_nodes_iter<'a>(
+pub(crate) fn aexpr_to_column_nodes_iter<'a>(
     root: Node,
     arena: &'a Arena<AExpr>,
 ) -> FlatMap<AExprIter<'a>, Option<Node>, fn((Node, &'a AExpr)) -> Option<Node>> {
-    arena.iter(root).flat_map(
-        |(node, ae)| {
-            if is_leaf_aexpr(ae) {
-                Some(node)
-            } else {
-                None
-            }
-        },
-    )
+    arena.iter(root).flat_map(|(node, ae)| {
+        if is_column_aexpr(ae) {
+            Some(node)
+        } else {
+            None
+        }
+    })
 }
 
-pub(crate) fn aexpr_to_leaf_nodes(root: Node, arena: &Arena<AExpr>) -> Vec<Node> {
-    aexpr_to_leaf_nodes_iter(root, arena).collect()
+pub(crate) fn aexpr_to_column_nodes(root: Node, arena: &Arena<AExpr>) -> Vec<Node> {
+    aexpr_to_column_nodes_iter(root, arena).collect()
 }
 
 /// Rename the roots of the expression to a single name.
 /// Most of the times used with columns that have a single root.
 /// In some cases we can have multiple roots.
 /// For instance in predicate pushdown the predicates are combined by their root column
 /// When combined they may be a binary expression with the same root columns
@@ -268,15 +271,15 @@
 /// with a renamed expression.
 pub(crate) fn rename_matching_aexpr_leaf_names(
     node: Node,
     arena: &mut Arena<AExpr>,
     current: &str,
     new_name: &str,
 ) -> Node {
-    let mut leaves = aexpr_to_leaf_nodes_iter(node, arena);
+    let mut leaves = aexpr_to_column_nodes_iter(node, arena);
 
     if leaves.any(|node| matches!(arena.get(node), AExpr::Column(name) if &**name == current)) {
         // we convert to expression as we cannot easily copy the aexpr.
         let mut new_expr = node_to_expr(node, arena);
         new_expr.mutate().apply(|e| match e {
             Expr::Column(name) if &**name == current => {
                 *name = Arc::from(new_name);
@@ -294,15 +297,15 @@
 /// Returns `Node` on first successful rename.
 pub(crate) fn aexpr_assign_renamed_leaf(
     node: Node,
     arena: &mut Arena<AExpr>,
     current: &str,
     new_name: &str,
 ) -> Node {
-    let leafs = aexpr_to_leaf_nodes_iter(node, arena);
+    let leafs = aexpr_to_column_nodes_iter(node, arena);
 
     for node in leafs {
         match arena.get(node) {
             AExpr::Column(name) if &**name == current => {
                 return arena.add(AExpr::Column(Arc::from(new_name)))
             }
             _ => {}
@@ -335,15 +338,15 @@
         .collect()
 }
 
 pub fn aexpr_to_leaf_names_iter(
     node: Node,
     arena: &Arena<AExpr>,
 ) -> impl Iterator<Item = Arc<str>> + '_ {
-    aexpr_to_leaf_nodes_iter(node, arena).map(|node| match arena.get(node) {
+    aexpr_to_column_nodes_iter(node, arena).map(|node| match arena.get(node) {
         // expecting only columns here, wildcards and dtypes should already be replaced
         AExpr::Column(name) => name.clone(),
         e => {
             panic!("{e:?} not expected")
         }
     })
 }
@@ -390,20 +393,32 @@
     }
     single_pred.expect("an empty iterator was passed")
 }
 
 pub fn expr_is_projected_upstream(
     e: &Node,
     input: Node,
-    lp_arena: &mut Arena<ALogicalPlan>,
+    lp_arena: &Arena<ALogicalPlan>,
     expr_arena: &Arena<AExpr>,
     projected_names: &PlHashSet<Arc<str>>,
 ) -> bool {
     let input_schema = lp_arena.get(input).schema(lp_arena);
     // don't do projection that is not used in upstream selection
     let output_field = expr_arena
         .get(*e)
         .to_field(input_schema.as_ref(), Context::Default, expr_arena)
         .unwrap();
     let output_name = output_field.name();
     projected_names.contains(output_name.as_str())
 }
+
+pub fn rename_cse_tmp_series(s: &mut Series) {
+    if s.name().starts_with(CSE_REPLACED) {
+        let field = s.field().into_owned();
+        let name = &field.name;
+        let pat = r#"col("#;
+        let offset = name.rfind(pat).unwrap() + pat.len();
+        // -1 is `)` of `col(foo)`
+        let name = &name[offset..name.len() - 1];
+        s.rename(name);
+    }
+}
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-utils/Cargo.toml` & `polars_lts_cpu-0.18.9/local_dependencies/polars-utils/Cargo.toml`

 * *Files 12% similar despite different names*

```diff
@@ -10,14 +10,15 @@
 # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
 
 [dependencies]
 ahash= "0.8"
 hashbrown= { version = "0.14.0", features = ["rayon", "ahash"] }
 num-traits= "0.2"
 once_cell= "1"
+polars-error = { version = "0.31.1", path = "../polars-error" }
 rayon= "1.6"
 smartstring= { version = "1" }
 sysinfo = { version = "0.29", default-features = false, optional = true }
 
 [features]
 bigidx = []
 nightly = []
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-utils/LICENSE` & `polars_lts_cpu-0.18.9/local_dependencies/polars-row/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/arena.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/arena.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/atomic.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/atomic.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/cell.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/cell.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/contention_pool.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/contention_pool.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/functions.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/functions.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/iter/enumerate_idx.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/iter/enumerate_idx.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/macros.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/macros.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/slice.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/slice.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/sort.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/sort.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/sync.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/sync.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/unwrap.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/unwrap.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/vec.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/vec.rs`

 * *Files 5% similar despite different names*

```diff
@@ -59,7 +59,18 @@
     unsafe fn push_unchecked(&mut self, value: T) {
         debug_assert!(self.capacity() > self.len());
         let end = self.as_mut_ptr().add(self.len());
         std::ptr::write(end, value);
         self.set_len(self.len() + 1);
     }
 }
+
+pub trait CapacityByFactor {
+    fn with_capacity_by_factor(original_len: usize, factor: f64) -> Self;
+}
+
+impl<T> CapacityByFactor for Vec<T> {
+    fn with_capacity_by_factor(original_len: usize, factor: f64) -> Self {
+        let cap = (original_len as f64 * factor) as usize;
+        Vec::with_capacity(cap)
+    }
+}
```

### Comparing `polars_lts_cpu-0.18.8/local_dependencies/polars-utils/src/wasm.rs` & `polars_lts_cpu-0.18.9/local_dependencies/polars-utils/src/wasm.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/Cargo.toml` & `polars_lts_cpu-0.18.9/Cargo.toml`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 [package]
 name = "py-polars"
-version = "0.18.8"
+version = "0.18.9"
 edition = "2021"
 
 # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
 
 [workspace]
 # prevents package from thinking it's in the workspace
 [target.'cfg(any(not(target_os = "linux"), use_mimalloc))'.dependencies]
@@ -12,14 +12,15 @@
 
 [target.'cfg(all(target_os = "linux", not(use_mimalloc)))'.dependencies]
 jemallocator = { version = "0.5", features = ["disable_initial_exec_tls"] }
 
 [dependencies]
 ahash = "0.8"
 ciborium = "0.2.0"
+either = "1.8"
 lexical-core = "0.8"
 # todo: unfix when compilation problem is solved
 libc = "0.2"
 ndarray = "0.15"
 numpy = "0.19"
 once_cell = "1"
 polars-algo = { path = "local_dependencies/polars-algo", default-features = false }
@@ -188,8 +189,8 @@
 # Should not be used when packaging
 # target-cpu = "native"
 
 [build-dependencies]
 built = { version = "0.6", features = ["chrono", "git2"], optional = true }
 
 [patch.crates-io]
-# simd-json = { git = "https://github.com/ritchie46/simd-json", branch = "alignment" }
+simd-json = { git = "https://github.com/ritchie46/simd-json", branch = "initialize" }
```

### Comparing `polars_lts_cpu-0.18.8/LICENSE` & `polars_lts_cpu-0.18.9/LICENSE`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/Makefile` & `polars_lts_cpu-0.18.9/Makefile`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/README.md` & `polars_lts_cpu-0.18.9/README.md`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/build.rs` & `polars_lts_cpu-0.18.9/build.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/Makefile` & `polars_lts_cpu-0.18.9/docs/Makefile`

 * *Files 11% similar despite different names*

```diff
@@ -12,11 +12,15 @@
 
 # Put it first so that "make" without argument is like "make help".
 help:
 	@$(SPHINXBUILD) -M help "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)
 
 .PHONY: help Makefile
 
+clean:
+	@rm -rf source/reference/*/api/
+	@rm -rf source/reference/api/
+
 # Catch-all target: route all unknown targets to Sphinx using the new
 # "make mode" option.  $(O) is meant as a shortcut for $(SPHINXOPTS).
 %: Makefile
 	@$(SPHINXBUILD) -M $@ "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)
```

### Comparing `polars_lts_cpu-0.18.8/docs/_templates/autosummary/class.rst` & `polars_lts_cpu-0.18.9/docs/_templates/autosummary/class.rst`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/requirements-docs.txt` & `polars_lts_cpu-0.18.9/docs/requirements-docs.txt`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/run_live_docs_server.py` & `polars_lts_cpu-0.18.9/docs/run_live_docs_server.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/_static/css/custom.css` & `polars_lts_cpu-0.18.9/docs/source/_static/css/custom.css`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/conf.py` & `polars_lts_cpu-0.18.9/docs/source/conf.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/reference/api.rst` & `polars_lts_cpu-0.18.9/docs/source/reference/api.rst`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/reference/config.rst` & `polars_lts_cpu-0.18.9/docs/source/reference/config.rst`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/reference/dataframe/modify_select.rst` & `polars_lts_cpu-0.18.9/docs/source/reference/dataframe/modify_select.rst`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/reference/datatypes.rst` & `polars_lts_cpu-0.18.9/docs/source/reference/datatypes.rst`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/reference/expressions/computation.rst` & `polars_lts_cpu-0.18.9/docs/source/reference/expressions/computation.rst`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/reference/expressions/functions.rst` & `polars_lts_cpu-0.18.9/docs/source/reference/expressions/functions.rst`

 * *Files 6% similar despite different names*

```diff
@@ -15,14 +15,16 @@
    all
    all_horizontal
    any
    any_horizontal
    apply
    approx_unique
    arange
+   arctan2
+   arctan2d
    arg_sort_by
    arg_where
    avg
    coalesce
    concat_list
    concat_str
    corr
@@ -31,14 +33,15 @@
    cumfold
    cumreduce
    cumsum
    cumsum_horizontal
    date
    datetime
    date_range
+   date_ranges
    duration
    element
    exclude
    first
    fold
    format
    from_epoch
@@ -68,14 +71,15 @@
    struct
    sum
    sum_horizontal
    sql_expr
    tail
    time
    time_range
+   time_ranges
    var
    when
    zeros
 
 
 **Available in expression namespace:**
```

### Comparing `polars_lts_cpu-0.18.8/docs/source/reference/expressions/list.rst` & `polars_lts_cpu-0.18.9/docs/source/reference/expressions/list.rst`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/reference/expressions/modify_select.rst` & `polars_lts_cpu-0.18.9/docs/source/reference/expressions/modify_select.rst`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/reference/expressions/operators.rst` & `polars_lts_cpu-0.18.9/docs/source/reference/expressions/operators.rst`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/reference/expressions/string.rst` & `polars_lts_cpu-0.18.9/docs/source/reference/expressions/string.rst`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/reference/expressions/temporal.rst` & `polars_lts_cpu-0.18.9/docs/source/reference/expressions/temporal.rst`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/reference/functions.rst` & `polars_lts_cpu-0.18.9/docs/source/reference/functions.rst`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/reference/io.rst` & `polars_lts_cpu-0.18.9/docs/source/reference/io.rst`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/reference/lazyframe/modify_select.rst` & `polars_lts_cpu-0.18.9/docs/source/reference/lazyframe/modify_select.rst`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/reference/selectors.rst` & `polars_lts_cpu-0.18.9/docs/source/reference/selectors.rst`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/reference/series/computation.rst` & `polars_lts_cpu-0.18.9/docs/source/reference/series/computation.rst`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/reference/series/descriptive.rst` & `polars_lts_cpu-0.18.9/docs/source/reference/series/descriptive.rst`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/reference/series/list.rst` & `polars_lts_cpu-0.18.9/docs/source/reference/series/list.rst`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/reference/series/modify_select.rst` & `polars_lts_cpu-0.18.9/docs/source/reference/series/modify_select.rst`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/reference/series/string.rst` & `polars_lts_cpu-0.18.9/docs/source/reference/series/string.rst`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/reference/series/temporal.rst` & `polars_lts_cpu-0.18.9/docs/source/reference/series/temporal.rst`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/docs/source/reference/testing.rst` & `polars_lts_cpu-0.18.9/docs/source/reference/testing.rst`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/__init__.py` & `polars_lts_cpu-0.18.9/polars/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -80,14 +80,16 @@
     all,
     all_horizontal,
     any,
     any_horizontal,
     apply,
     approx_unique,
     arange,
+    arctan2,
+    arctan2d,
     arg_sort_by,
     arg_where,
     avg,
     coalesce,
     col,
     collect_all,
     concat,
@@ -98,14 +100,15 @@
     cov,
     cumfold,
     cumreduce,
     cumsum,
     cumsum_horizontal,
     date,
     date_range,
+    date_ranges,
     datetime,
     duration,
     element,
     exclude,
     first,
     fold,
     format,
@@ -136,14 +139,15 @@
     std,
     struct,
     sum,
     sum_horizontal,
     tail,
     time,
     time_range,
+    time_ranges,
     var,
     when,
     zeros,
 )
 from polars.io import (
     read_avro,
     read_csv,
@@ -278,18 +282,20 @@
     # polars.functions.whenthen
     "when",
     # polars.functions
     "align_frames",
     "arg_where",
     "concat",
     "date_range",
+    "date_ranges",
     "element",
     "ones",
     "repeat",
     "time_range",
+    "time_ranges",
     "zeros",
     # polars.functions.aggregation
     "all",
     "any",
     "cumsum",
     "max",
     "min",
@@ -299,14 +305,16 @@
     "cumsum_horizontal",
     "max_horizontal",
     "min_horizontal",
     "sum_horizontal",
     # polars.functions.lazy
     "apply",
     "arange",
+    "arctan2",
+    "arctan2d",
     "arg_sort_by",
     "avg",
     "coalesce",
     "col",
     "collect_all",
     "concat_list",
     "concat_str",
```

### Comparing `polars_lts_cpu-0.18.8/polars/api.py` & `polars_lts_cpu-0.18.9/polars/api.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/config.py` & `polars_lts_cpu-0.18.9/polars/config.py`

 * *Files 1% similar despite different names*

```diff
@@ -200,15 +200,17 @@
 
         Examples
         --------
         >>> cfg = pl.Config.save()
 
         Returns
         -------
-        str : json string containing current Config options, or filepath where saved.
+        str
+            JSON string containing current Config options, or the path to the file where
+            the options are saved.
 
         """
         environment_vars = {
             key: os.environ[key]
             for key in sorted(_POLARS_CFG_ENV_VARS)
             if (key in os.environ)
         }
```

### Comparing `polars_lts_cpu-0.18.8/polars/convert.py` & `polars_lts_cpu-0.18.9/polars/convert.py`

 * *Files 0% similar despite different names*

```diff
@@ -56,15 +56,15 @@
         of names given in the schema should match the underlying data dimensions.
     schema_overrides : dict, default None
         Support type specification or override of one or more columns; note that
         any dtypes inferred from the columns param will be overridden.
 
     Returns
     -------
-    :class:`DataFrame`
+    DataFrame
 
     Examples
     --------
     >>> df = pl.from_dict({"a": [1, 2], "b": [3, 4]})
     >>> df
     shape: (2, 2)
     ┌─────┬─────┐
@@ -116,15 +116,15 @@
         Support override of inferred types for one or more columns.
     infer_schema_length
         How many dictionaries/rows to scan to determine the data types
         if set to `None` then ALL dicts are scanned; this will be slow.
 
     Returns
     -------
-    :class:`DataFrame`
+    DataFrame
 
     Examples
     --------
     >>> data = [{"a": 1, "b": 4}, {"a": 2, "b": 5}, {"a": 3, "b": 6}]
     >>> df = pl.from_dicts(data)
     >>> df
     shape: (3, 2)
@@ -220,15 +220,15 @@
         this does not yield conclusive results, column orientation is used.
     infer_schema_length
         How many dictionaries/rows to scan to determine the data types
         if set to `None` all rows are scanned. This will be slow.
 
     Returns
     -------
-    :class:`DataFrame`
+    DataFrame
 
     Examples
     --------
     >>> data = [[1, 2, 3], [4, 5, 6]]
     >>> df = pl.from_records(data, schema=["a", "b"])
     >>> df
     shape: (3, 2)
@@ -484,15 +484,15 @@
     orient : {None, 'col', 'row'}
         Whether to interpret two-dimensional data as columns or as rows. If None,
         the orientation is inferred by matching the columns and data dimensions. If
         this does not yield conclusive results, column orientation is used.
 
     Returns
     -------
-    :class:`DataFrame`
+    DataFrame
 
     Examples
     --------
     >>> import numpy as np
     >>> data = np.array([[1, 2, 3], [4, 5, 6]])
     >>> df = pl.from_numpy(data, schema=["a", "b"], orient="col")
     >>> df
@@ -555,15 +555,15 @@
         Support type specification or override of one or more columns; note that
         any dtypes inferred from the schema param will be overridden.
     rechunk : bool, default True
         Make sure that all data is in contiguous memory.
 
     Returns
     -------
-    :class:`DataFrame` or :class:`Series`
+    DataFrame or Series
 
     Examples
     --------
     Constructing a DataFrame from an Arrow Table:
 
     >>> import pyarrow as pa
     >>> data = pa.table({"a": [1, 2, 3], "b": [4, 5, 6]})
@@ -675,15 +675,15 @@
     nan_to_null : bool, default True
         If data contains `NaN` values PyArrow will convert the ``NaN`` to ``None``
     include_index : bool, default False
         Load any non-default pandas indexes as columns.
 
     Returns
     -------
-    :class:`DataFrame`
+    DataFrame
 
     Examples
     --------
     Constructing a :class:`DataFrame` from a :class:`pandas.DataFrame`:
 
     >>> import pandas as pd
     >>> pd_df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], columns=["a", "b", "c"])
```

### Comparing `polars_lts_cpu-0.18.8/polars/dataframe/_html.py` & `polars_lts_cpu-0.18.9/polars/dataframe/_html.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/dataframe/frame.py` & `polars_lts_cpu-0.18.9/polars/dataframe/frame.py`

 * *Files 1% similar despite different names*

```diff
@@ -451,18 +451,14 @@
             If you supply a list of column names that does not match the names in the
             underlying data, the names given here will overwrite them. The number
             of names given in the schema should match the underlying data dimensions.
         schema_overrides : dict, default None
           Support type specification or override of one or more columns; note that
           any dtypes inferred from the columns param will be overridden.
 
-        Returns
-        -------
-        DataFrame
-
         """
         return cls._from_pydf(
             dict_to_pydf(data, schema=schema, schema_overrides=schema_overrides)
         )
 
     @classmethod
     def _from_records(
@@ -497,18 +493,14 @@
         orient : {'col', 'row'}, default None
             Whether to interpret two-dimensional data as columns or as rows. If None,
             the orientation is inferred by matching the columns and data dimensions. If
             this does not yield conclusive results, column orientation is used.
         infer_schema_length
             How many rows to scan to determine the column type.
 
-        Returns
-        -------
-        DataFrame
-
         """
         return cls._from_pydf(
             sequence_to_pydf(
                 data,
                 schema=schema,
                 schema_overrides=schema_overrides,
                 orient=orient,
@@ -546,18 +538,14 @@
             Support type specification or override of one or more columns; note that
             any dtypes inferred from the columns param will be overridden.
         orient : {'col', 'row'}, default None
             Whether to interpret two-dimensional data as columns or as rows. If None,
             the orientation is inferred by matching the columns and data dimensions. If
             this does not yield conclusive results, column orientation is used.
 
-        Returns
-        -------
-        DataFrame
-
         """
         return cls._from_pydf(
             numpy_to_pydf(
                 data, schema=schema, schema_overrides=schema_overrides, orient=orient
             )
         )
 
@@ -592,18 +580,14 @@
             of names given in the schema should match the underlying data dimensions.
         schema_overrides : dict, default None
             Support type specification or override of one or more columns; note that
             any dtypes inferred from the columns param will be overridden.
         rechunk : bool, default True
             Make sure that all data is in contiguous memory.
 
-        Returns
-        -------
-        DataFrame
-
         """
         return cls._from_pydf(
             arrow_to_pydf(
                 data,
                 schema=schema,
                 schema_overrides=schema_overrides,
                 rechunk=rechunk,
@@ -644,18 +628,14 @@
         rechunk : bool, default True
             Make sure that all data is in contiguous memory.
         nan_to_null : bool, default True
             If the data contains NaN values they will be converted to null/None.
         include_index : bool, default False
             Load any non-default pandas indexes as columns.
 
-        Returns
-        -------
-        DataFrame
-
         """
         return cls._from_pydf(
             pandas_to_pydf(
                 data,
                 schema=schema,
                 schema_overrides=schema_overrides,
                 rechunk=rechunk,
@@ -891,18 +871,14 @@
         source
             Path to a file or a file-like object.
         columns
             Columns.
         n_rows
             Stop reading from Apache Avro file after reading ``n_rows``.
 
-        Returns
-        -------
-        DataFrame
-
         """
         if isinstance(source, (str, Path)):
             source = normalise_filepath(source)
         projection, columns = handle_projection_columns(columns)
         self = cls.__new__(cls)
         self._df = PyDataFrame.read_avro(source, columns, projection, n_rows)
         return self
@@ -938,18 +914,14 @@
         row_count_offset
             Row count offset.
         rechunk
             Make sure that all data is contiguous.
         memory_map
             Memory map the file
 
-        Returns
-        -------
-        DataFrame
-
         """
         if isinstance(source, (str, Path)):
             source = normalise_filepath(source)
         if isinstance(columns, str):
             columns = [columns]
 
         if (
@@ -1177,14 +1149,26 @@
         --------
         schema : Returns a {colname:dtype} mapping.
 
         """
         return self._df.dtypes()
 
     @property
+    def flags(self) -> dict[str, dict[str, bool]]:
+        """
+        Get flags that are set on the columns of this DataFrame.
+
+        Returns
+        -------
+        dict
+            Mapping from column names to column flags.
+        """
+        return {name: self[name].flags for name in self.columns}
+
+    @property
     def schema(self) -> SchemaDict:
         """
         Get a dict[column name, DataType].
 
         Examples
         --------
         >>> df = pl.DataFrame(
@@ -2036,15 +2020,15 @@
         ----------
         use_pyarrow_extension_array
             Use PyArrow backed-extension arrays instead of numpy arrays for each column
             of the pandas DataFrame; this allows zero copy operations and preservation
             of null values. Subsequent operations on the resulting pandas DataFrame may
             trigger conversion to NumPy arrays if that operation is not supported by
             pyarrow compute functions.
-        kwargs
+        **kwargs
             Arguments will be sent to :meth:`pyarrow.Table.to_pandas`.
 
         Returns
         -------
         :class:`pandas.DataFrame`
 
         Examples
@@ -2545,19 +2529,21 @@
         float_precision: int = 3,
         has_header: bool = True,
         autofilter: bool = True,
         autofit: bool = False,
         hidden_columns: Sequence[str] | None = None,
         hide_gridlines: bool = False,
         sheet_zoom: int | None = None,
-        freeze_panes: str
-        | tuple[str, int, int]
-        | tuple[int, int]
-        | tuple[int, int, int, int]
-        | None = None,
+        freeze_panes: (
+            str
+            | tuple[int, int]
+            | tuple[str, int, int]
+            | tuple[int, int, int, int]
+            | None
+        ) = None,
     ) -> Workbook:
         """
         Write frame data to a table in an Excel workbook/worksheet.
 
         Parameters
         ----------
         workbook : Workbook
@@ -3156,32 +3142,33 @@
                 **(pyarrow_options or {}),
             )
         else:
             self._df.write_parquet(
                 file, compression, compression_level, statistics, row_group_size
             )
 
+    @deprecated_alias(connection_uri="connection")
     def write_database(
         self,
         table_name: str,
-        connection_uri: str,
+        connection: str,
         *,
         if_exists: DbWriteMode = "fail",
         engine: DbWriteEngine = "sqlalchemy",
     ) -> None:
         """
         Write a polars frame to a database.
 
         Parameters
         ----------
         table_name
             Name of the table to create or append to in the target SQL database.
             If your table name contains special characters, it should be quoted.
-        connection_uri
-            Connection URI, for example:
+        connection
+            Connection URI string, for example:
 
             * "postgresql://user:pass@server:port/database"
             * "sqlite:////path/to/database.db"
         if_exists : {'append', 'replace', 'fail'}
             The insert mode.
             'replace' will create a new database table, overwriting an existing one.
             'append' will append to an existing table.
@@ -3199,18 +3186,16 @@
             elif if_exists == "append":
                 mode = "append"
             else:
                 raise ValueError(
                     f"Value for 'if_exists'={if_exists} was unexpected. "
                     f"Choose one of: {'fail', 'replace', 'append'}."
                 )
-            with _open_adbc_connection(connection_uri) as conn:
-                cursor = conn.cursor()
+            with _open_adbc_connection(connection) as conn, conn.cursor() as cursor:
                 cursor.adbc_ingest(table_name, self.to_arrow(), mode)
-                cursor.close()
                 conn.commit()
 
         elif engine == "sqlalchemy":
             if parse_version(pd.__version__) < parse_version("1.5"):
                 raise ModuleNotFoundError(
                     f"Writing with engine 'sqlalchemy' requires Pandas 1.5.x or higher, found Pandas {pd.__version__}."
                 )
@@ -3233,15 +3218,15 @@
                 table_name = table_ident[1]
             else:
                 table_name = table_ident[0]
                 db_schema = None
 
             # ensure conversion to pandas uses the pyarrow extension array option
             # so that we can make use of the sql/db export without copying data
-            engine_sa = create_engine(connection_uri)
+            engine_sa = create_engine(connection)
             self.to_pandas(use_pyarrow_extension_array=True).to_sql(
                 name=table_name,
                 schema=db_schema,
                 con=engine_sa,
                 if_exists=if_exists,
                 index=False,
             )
@@ -3541,31 +3526,18 @@
         │ ---    ┆ --- ┆ --- ┆ --- │
         │ str    ┆ i64 ┆ i64 ┆ i64 │
         ╞════════╪═════╪═════╪═════╡
         │ col1   ┆ 1   ┆ 3   ┆ 2   │
         │ col2   ┆ 3   ┆ 4   ┆ 6   │
         └────────┴─────┴─────┴─────┘
         """
-        pydf = self._df
-        if isinstance(column_names, str):
-            pydf = self.drop(column_names)._df
-            column_names = self._df.column(column_names).to_list()
-        df = self._from_pydf(pydf.transpose(include_header, header_name))
-        if column_names is not None:
-            names = []
-            n = df.width
-            if include_header:
-                names.append(header_name)
-                n -= 1
-
-            column_names = iter(column_names)
-            for _ in range(n):
-                names.append(next(column_names))
-            df.columns = names
-        return df
+        keep_names_as = header_name if include_header else None
+        if isinstance(column_names, Generator):
+            column_names = [next(column_names) for _ in range(self.height)]
+        return self._from_pydf(self._df.transpose(keep_names_as, column_names))
 
     def reverse(self) -> DataFrame:
         """
         Reverse the DataFrame.
 
         Examples
         --------
@@ -4171,15 +4143,15 @@
                 descending=descending,
                 nulls_last=nulls_last,
                 maintain_order=maintain_order,
             )
             .collect(
                 projection_pushdown=False,
                 predicate_pushdown=False,
-                common_subplan_elimination=False,
+                comm_subplan_elim=False,
                 slice_pushdown=True,
             )
         )
 
     def bottom_k(
         self,
         k: int,
@@ -4263,15 +4235,15 @@
                 descending=descending,
                 nulls_last=nulls_last,
                 maintain_order=maintain_order,
             )
             .collect(
                 projection_pushdown=False,
                 predicate_pushdown=False,
-                common_subplan_elimination=False,
+                comm_subplan_elim=False,
                 slice_pushdown=True,
             )
         )
 
     def frame_equal(self, other: DataFrame, *, null_equal: bool = True) -> bool:
         """
         Check if DataFrame is equal to other.
@@ -5619,15 +5591,15 @@
             .. note::
 
                 - This is currently not supported the streaming engine.
                 - This is only supported when joined by single columns.
 
         Returns
         -------
-            Joined DataFrame
+        DataFrame
 
         See Also
         --------
         join_asof
 
         Examples
         --------
@@ -6066,15 +6038,16 @@
         Parameters
         ----------
         name
             Name of the column to drop.
 
         Returns
         -------
-        The dropped column.
+        Series
+            The dropped column.
 
         Examples
         --------
         >>> df = pl.DataFrame(
         ...     {
         ...         "foo": [1, 2, 3],
         ...         "bar": [6, 7, 8],
@@ -6294,14 +6267,15 @@
             Number of consecutive null values to fill when using the 'forward' or
             'backward' strategy.
         matches_supertype
             Fill all matching supertype of the fill ``value``.
 
         Returns
         -------
+        DataFrame
             DataFrame with None values replaced by the filling strategy.
 
         See Also
         --------
         fill_nan
 
         Examples
@@ -6373,19 +6347,20 @@
     def fill_nan(self, value: Expr | int | float | None) -> DataFrame:
         """
         Fill floating point NaN values by an Expression evaluation.
 
         Parameters
         ----------
         value
-            Value to fill NaN with.
+            Value with which to replace NaN values.
 
         Returns
         -------
-            DataFrame with NaN replaced with fill_value
+        DataFrame
+            DataFrame with NaN values replaced by the given value.
 
         Warnings
         --------
         Note that floating point NaNs (Not a Number) are not missing values!
         To replace missing values, use :func:`fill_null`.
 
         See Also
@@ -7318,15 +7293,16 @@
             non-expression inputs are parsed as literals.
         **named_exprs
             Additional columns to add, specified as keyword arguments.
             The columns will be renamed to the keyword used.
 
         Returns
         -------
-        A new DataFrame with the columns added.
+        DataFrame
+            A new DataFrame with the columns added.
 
         Notes
         -----
         Creating a new DataFrame using this method does not create a new copy of
         existing data.
 
         Examples
@@ -7980,15 +7956,16 @@
             Keep the same order as the original DataFrame. This is more expensive to
             compute.
             Settings this to ``True`` blocks the possibility
             to run on the streaming engine.
 
         Returns
         -------
-        DataFrame with unique rows.
+        DataFrame
+            DataFrame with unique rows.
 
         Warnings
         --------
         This method will fail if there is a column of type `List` in the DataFrame or
         subset.
 
         Examples
@@ -8342,15 +8319,15 @@
         named
             Return a dictionary instead of a tuple. The dictionary is a mapping of
             column name to row value. This is more expensive than returning a regular
             tuple, but allows for accessing values by column name.
 
         Returns
         -------
-        Tuple (default) or dictionary of row values.
+        tuple (default) or dictionary of row values
 
         Notes
         -----
         The ``index`` and ``by_predicate`` params are mutually exclusive. Additionally,
         to ensure clarity, the `by_predicate` parameter must be supplied by keyword.
 
         When using ``by_predicate`` it is an error condition if anything other than
@@ -8466,15 +8443,15 @@
         Row-iteration is not optimal as the underlying data is stored in columnar form;
         where possible, prefer export via one of the dedicated export/output methods.
         Where possible you should also consider using ``iter_rows`` instead to avoid
         materialising all the data at once.
 
         Returns
         -------
-        A list of tuples (default) or dictionaries of row values.
+        list of tuples (default) or dictionaries of row values
 
         Examples
         --------
         >>> df = pl.DataFrame(
         ...     {
         ...         "x": ["a", "b", "b", "a"],
         ...         "y": [1, 2, 3, 4],
@@ -8707,15 +8684,15 @@
         --------
         Row iteration is not optimal as the underlying data is stored in columnar form;
         where possible, prefer export via one of the dedicated export/output methods
         that deals with columnar data.
 
         Returns
         -------
-        An iterator of tuples (default) or dictionaries (if named) of python row values.
+        iterator of tuples (default) or dictionaries (if named) of python row values
 
         Examples
         --------
         >>> df = pl.DataFrame(
         ...     {
         ...         "a": [1, 3, 5],
         ...         "b": [2, 4, 6],
```

### Comparing `polars_lts_cpu-0.18.8/polars/dataframe/groupby.py` & `polars_lts_cpu-0.18.9/polars/dataframe/groupby.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,14 +1,13 @@
 from __future__ import annotations
 
 from typing import TYPE_CHECKING, Callable, Iterable, Iterator
 
 import polars._reexport as pl
 from polars import functions as F
-from polars.functions.whenthen import WhenThen, WhenThenThen
 from polars.utils.convert import _timedelta_to_pl_duration
 
 if TYPE_CHECKING:
     import sys
     from datetime import timedelta
 
     from polars import DataFrame
@@ -60,17 +59,15 @@
         self.more_by = more_by
         self.maintain_order = maintain_order
 
     def __iter__(self) -> Self:
         """
         Allows iteration over the groups of the groupby operation.
 
-        Returns
-        -------
-        Iterator returning tuples of (name, data) for each group.
+        Each group is represented by a tuple of (name, data).
 
         Examples
         --------
         >>> df = pl.DataFrame({"foo": ["a", "a", "b"], "bar": [1, 2, 3]})
         >>> for name, data in df.groupby("foo"):  # doctest: +SKIP
         ...     print(name)
         ...     print(data)
@@ -106,18 +103,15 @@
         )
 
         group_names = groups_df.select(F.all().exclude(temp_col))
 
         # When grouping by a single column, group name is a single value
         # When grouping by multiple columns, group name is a tuple of values
         self._group_names: Iterator[object] | Iterator[tuple[object, ...]]
-        if (
-            isinstance(self.by, (str, pl.Expr, WhenThen, WhenThenThen))
-            and not self.more_by
-        ):
+        if isinstance(self.by, (str, pl.Expr)) and not self.more_by:
             self._group_names = iter(group_names.to_series())
         else:
             self._group_names = group_names.iter_rows()
 
         self._group_indices = groups_df.select(temp_col).to_series()
         self._current_index = 0
 
@@ -324,15 +318,15 @@
         ... )  # doctest: +IGNORE_RESULT
 
         """
         by: list[str]
 
         if isinstance(self.by, str):
             by = [self.by]
-        elif isinstance(self.by, Iterable) and all(isinstance(c, str) for c in self.by):  # type: ignore[union-attr]
+        elif isinstance(self.by, Iterable) and all(isinstance(c, str) for c in self.by):
             by = list(self.by)  # type: ignore[arg-type]
         else:
             raise TypeError("Cannot call `apply` when grouping by an expression.")
 
         if all(isinstance(c, str) for c in self.more_by):
             by.extend(self.more_by)  # type: ignore[arg-type]
         else:
```

### Comparing `polars_lts_cpu-0.18.8/polars/datatypes/__init__.py` & `polars_lts_cpu-0.18.9/polars/datatypes/__init__.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/datatypes/classes.py` & `polars_lts_cpu-0.18.9/polars/datatypes/classes.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/datatypes/constants.py` & `polars_lts_cpu-0.18.9/polars/datatypes/constants.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/datatypes/constructor.py` & `polars_lts_cpu-0.18.9/polars/datatypes/constructor.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/datatypes/convert.py` & `polars_lts_cpu-0.18.9/polars/datatypes/convert.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/dependencies.py` & `polars_lts_cpu-0.18.9/polars/dependencies.py`

 * *Files 1% similar despite different names*

```diff
@@ -112,16 +112,17 @@
     module is created in its place, which raises an exception on any attribute
     access. This allows for import and use as normal, without requiring explicit
     guard conditions - if the module is never used, no exception occurs; if it
     is, then a helpful exception is raised.
 
     Returns
     -------
-    tuple[Module, bool]: a lazy-loading module and a boolean indicating if the
-    requested/underlying module exists (if not, the returned module is a proxy).
+    tuple of (Module, bool)
+        A lazy-loading module and a boolean indicating if the requested/underlying
+        module exists (if not, the returned module is a proxy).
 
     """
     # check if module is LOADED
     if module_name in sys.modules:
         return sys.modules[module_name], True
 
     # check if module is AVAILABLE
```

### Comparing `polars_lts_cpu-0.18.8/polars/exceptions.py` & `polars_lts_cpu-0.18.9/polars/exceptions.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/expr/array.py` & `polars_lts_cpu-0.18.9/polars/expr/array.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/expr/binary.py` & `polars_lts_cpu-0.18.9/polars/expr/binary.py`

 * *Files 2% similar despite different names*

```diff
@@ -24,15 +24,16 @@
         Parameters
         ----------
         literal
             The binary substring to look for
 
         Returns
         -------
-        Boolean mask
+        Expr
+            Expression of data type :class:`Boolean`.
 
         See Also
         --------
         starts_with : Check if the binary substring exists at the start
         ends_with : Check if the binary substring exists at the end
 
         Examples
@@ -70,15 +71,16 @@
         Parameters
         ----------
         suffix
             Suffix substring.
 
         Returns
         -------
-        Boolean mask
+        Expr
+            Expression of data type :class:`Boolean`.
 
         See Also
         --------
         starts_with : Check if the binary substring exists at the start
         contains : Check if the binary substring exists anywhere
 
         Examples
@@ -116,15 +118,16 @@
         Parameters
         ----------
         prefix
             Prefix substring.
 
         Returns
         -------
-        Boolean mask
+        Expr
+            Expression of data type :class:`Boolean`.
 
         See Also
         --------
         ends_with : Check if the binary substring exists at the end
         contains : Check if the binary substring exists anywhere
 
         Examples
@@ -184,15 +187,17 @@
         Parameters
         ----------
         encoding : {'hex', 'base64'}
             The encoding to use.
 
         Returns
         -------
-        Binary array with values encoded using provided encoding
+        Expr
+            Expression of data type :class:`Utf8` with values encoded using provided
+            encoding.
 
         Examples
         --------
         >>> colors = pl.DataFrame(
         ...     {
         ...         "name": ["black", "yellow", "blue"],
         ...         "code": [b"\x00\x00\x00", b"\xff\xff\x00", b"\x00\x00\xff"],
@@ -207,14 +212,15 @@
         │ ---    ┆ ---           ┆ ---              │
         │ str    ┆ binary        ┆ str              │
         ╞════════╪═══════════════╪══════════════════╡
         │ black  ┆ [binary data] ┆ 000000           │
         │ yellow ┆ [binary data] ┆ ffff00           │
         │ blue   ┆ [binary data] ┆ 0000ff           │
         └────────┴───────────────┴──────────────────┘
+
         """
         if encoding == "hex":
             return wrap_expr(self._pyexpr.bin_hex_encode())
         elif encoding == "base64":
             return wrap_expr(self._pyexpr.bin_base64_encode())
         else:
             raise ValueError(
```

### Comparing `polars_lts_cpu-0.18.8/polars/expr/categorical.py` & `polars_lts_cpu-0.18.9/polars/expr/categorical.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/expr/datetime.py` & `polars_lts_cpu-0.18.9/polars/expr/datetime.py`

 * *Files 4% similar despite different names*

```diff
@@ -78,15 +78,16 @@
 
         By "calendar day", we mean the corresponding time on the next day (which may
         not be 24 hours, due to daylight savings). Similarly for "calendar week",
         "calendar month", "calendar quarter", and "calendar year".
 
         Returns
         -------
-        Expression of data type `Date`/`Datetime`
+        Expr
+            Expression of data type :class:`Date` or :class:`Datetime`.
 
         Examples
         --------
         >>> from datetime import timedelta, datetime
         >>> start = datetime(2001, 1, 1)
         >>> stop = datetime(2001, 1, 2)
         >>> df = pl.date_range(
@@ -253,15 +254,16 @@
 
         By "calendar day", we mean the corresponding time on the next day (which may
         not be 24 hours, due to daylight savings). Similarly for "calendar week",
         "calendar month", "calendar quarter", and "calendar year".
 
         Returns
         -------
-        Expression of data type `Date`/`Datetime`
+        Expr
+            Expression of data type :class:`Date` or :class:`Datetime`.
 
         Warnings
         --------
         This functionality is currently experimental and may
         change without it being considered a breaking change.
 
         Examples
@@ -501,15 +503,16 @@
 
         Applies to Date and Datetime columns.
 
         Returns the year number in the calendar date.
 
         Returns
         -------
-        Year as Int32
+        Expr
+            Expression of data type :class:`Int32`.
 
         Examples
         --------
         >>> from datetime import timedelta, datetime
         >>> start = datetime(2001, 1, 1)
         >>> stop = datetime(2002, 7, 1)
         >>> df = pl.DataFrame(
@@ -547,15 +550,16 @@
         """
         Determine whether the year of the underlying date is a leap year.
 
         Applies to Date and Datetime columns.
 
         Returns
         -------
-        Leap year info as Boolean
+        Expr
+            Expression of data type :class:`Boolean`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> start = datetime(2000, 1, 1)
         >>> stop = datetime(2002, 1, 1)
         >>> df = pl.DataFrame(
@@ -594,15 +598,16 @@
         Applies to Date and Datetime columns.
 
         Returns the year number in the ISO standard.
         This may not correspond with the calendar year.
 
         Returns
         -------
-        ISO Year as Int32
+        Expr
+            Expression of data type :class:`Int32`.
 
         Examples
         --------
         >>> from datetime import timedelta, datetime
         >>> start = datetime(2001, 1, 1)
         >>> stop = datetime(2006, 1, 1)
         >>> df = pl.DataFrame(
@@ -640,15 +645,16 @@
 
         Applies to Date and Datetime columns.
 
         Returns the quarter ranging from 1 to 4.
 
         Returns
         -------
-        Quarter as UInt32
+        Expr
+            Expression of data type :class:`UInt32`.
 
         Examples
         --------
         >>> from datetime import timedelta, datetime
         >>> start = datetime(2001, 1, 1)
         >>> stop = datetime(2002, 6, 1)
         >>> df = pl.DataFrame(
@@ -687,15 +693,16 @@
         Applies to Date and Datetime columns.
 
         Returns the month number starting from 1.
         The return value ranges from 1 to 12.
 
         Returns
         -------
-        Month as UInt32
+        Expr
+            Expression of data type :class:`UInt32`.
 
         Examples
         --------
         >>> from datetime import timedelta, datetime
         >>> start = datetime(2001, 1, 1)
         >>> stop = datetime(2001, 4, 1)
         >>> df = pl.DataFrame(
@@ -734,15 +741,16 @@
         Applies to Date and Datetime columns.
 
         Returns the ISO week number starting from 1.
         The return value ranges from 1 to 53. (The last week of year differs by years.)
 
         Returns
         -------
-        Week number as UInt32
+        Expr
+            Expression of data type :class:`UInt32`.
 
         Examples
         --------
         >>> from datetime import timedelta, datetime
         >>> start = datetime(2001, 1, 1)
         >>> stop = datetime(2001, 4, 1)
         >>> df = pl.DataFrame(
@@ -780,15 +788,16 @@
 
         Applies to Date and Datetime columns.
 
         Returns the ISO weekday number where monday = 1 and sunday = 7
 
         Returns
         -------
-        Week day as UInt32
+        Expr
+            Expression of data type :class:`UInt32`.
 
         See Also
         --------
         day
         ordinal_day
 
         Examples
@@ -838,15 +847,16 @@
         Applies to Date and Datetime columns.
 
         Returns the day of month starting from 1.
         The return value ranges from 1 to 31. (The last day of month differs by months.)
 
         Returns
         -------
-        Day as UInt32
+        Expr
+            Expression of data type :class:`UInt32`.
 
         See Also
         --------
         weekday
         ordinal_day
 
         Examples
@@ -896,15 +906,16 @@
         Applies to Date and Datetime columns.
 
         Returns the day of year starting from 1.
         The return value ranges from 1 to 366. (The last day of year differs by years.)
 
         Returns
         -------
-        Day as UInt32
+        Expr
+            Expression of data type :class:`UInt32`.
 
         See Also
         --------
         weekday
         day
 
         Examples
@@ -951,53 +962,60 @@
         """
         Extract time.
 
         Applies to Datetime columns only; fails on Date.
 
         Returns
         -------
-        Expression of data type `Time`
+        Expr
+            Expression of data type :class:`Time`.
+
         """
         return wrap_expr(self._pyexpr.dt_time())
 
     def date(self) -> Expr:
         """
         Extract date from date(time).
 
         Applies to Date and Datetime columns.
 
         Returns
         -------
-        Expression of data type `Date`
+        Expr
+            Expression of data type :class:`Date`.
+
         """
         return wrap_expr(self._pyexpr.dt_date())
 
     def datetime(self) -> Expr:
         """
         Return datetime.
 
         Applies to Datetime columns.
 
         Returns
         -------
-        Expression of data type `Datetime`
+        Expr
+            Expression of data type :class:`Datetime`.
+
         """
         return wrap_expr(self._pyexpr.dt_datetime())
 
     def hour(self) -> Expr:
         """
         Extract hour from underlying DateTime representation.
 
         Applies to Datetime columns.
 
         Returns the hour number from 0 to 23.
 
         Returns
         -------
-        Hour as UInt32
+        Expr
+            Expression of data type :class:`UInt32`.
 
         Examples
         --------
         >>> from datetime import timedelta, datetime
         >>> start = datetime(2001, 1, 1)
         >>> stop = datetime(2001, 1, 2)
         >>> df = pl.DataFrame(
@@ -1035,15 +1053,16 @@
 
         Applies to Datetime columns.
 
         Returns the minute number from 0 to 59.
 
         Returns
         -------
-        Minute as UInt32
+        Expr
+            Expression of data type :class:`UInt32`.
 
         Examples
         --------
         >>> from datetime import timedelta, datetime
         >>> start = datetime(2001, 1, 1)
         >>> stop = datetime(2001, 1, 1, 0, 4, 0)
         >>> df = pl.DataFrame(
@@ -1088,15 +1107,16 @@
         Parameters
         ----------
         fractional
             Whether to include the fractional component of the second.
 
         Returns
         -------
-        Second as UInt32 (or Float64)
+        Expr
+            Expression of data type :class:`UInt32` or :class:`Float64`.
 
         Examples
         --------
         >>> from datetime import timedelta, datetime
         >>> df = pl.DataFrame(
         ...     data={
         ...         "date": pl.date_range(
@@ -1183,28 +1203,30 @@
         """
         Extract milliseconds from underlying DateTime representation.
 
         Applies to Datetime columns.
 
         Returns
         -------
-        Milliseconds as UInt32
+        Expr
+            Expression of data type :class:`UInt32`.
 
         """
         return wrap_expr(self._pyexpr.dt_millisecond())
 
     def microsecond(self) -> Expr:
         """
         Extract microseconds from underlying DateTime representation.
 
         Applies to Datetime columns.
 
         Returns
         -------
-        Microseconds as UInt32
+        Expr
+            Expression of data type :class:`UInt32`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> df = pl.DataFrame(
         ...     {
         ...         "date": pl.date_range(
@@ -1245,15 +1267,16 @@
         """
         Extract nanoseconds from underlying DateTime representation.
 
         Applies to Datetime columns.
 
         Returns
         -------
-        Nanoseconds as UInt32
+        Expr
+            Expression of data type :class:`UInt32`.
 
         """
         return wrap_expr(self._pyexpr.dt_nanosecond())
 
     def epoch(self, time_unit: EpochTimeUnit = "us") -> Expr:
         """
         Get the time passed since the Unix EPOCH in the give time unit.
@@ -1569,15 +1592,16 @@
 
     def days(self) -> Expr:
         """
         Extract the days from a Duration type.
 
         Returns
         -------
-        Expression of data type Int64
+        Expr
+            Expression of data type :class:`Int64`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> df = pl.DataFrame(
         ...     {
         ...         "date": pl.date_range(
@@ -1607,15 +1631,16 @@
 
     def hours(self) -> Expr:
         """
         Extract the hours from a Duration type.
 
         Returns
         -------
-        Expression of data type Int64
+        Expr
+            Expression of data type :class:`Int64`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> df = pl.DataFrame(
         ...     {
         ...         "date": pl.date_range(
@@ -1646,15 +1671,16 @@
 
     def minutes(self) -> Expr:
         """
         Extract the minutes from a Duration type.
 
         Returns
         -------
-        Expression of data type Int64
+        Expr
+            Expression of data type :class:`Int64`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> df = pl.DataFrame(
         ...     {
         ...         "date": pl.date_range(
@@ -1685,15 +1711,16 @@
 
     def seconds(self) -> Expr:
         """
         Extract the seconds from a Duration type.
 
         Returns
         -------
-        Expression of data type `Int64`
+        Expr
+            Expression of data type :class:`Int64`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> df = pl.DataFrame(
         ...     {
         ...         "date": pl.date_range(
@@ -1728,15 +1755,16 @@
 
     def milliseconds(self) -> Expr:
         """
         Extract the milliseconds from a Duration type.
 
         Returns
         -------
-        Expression of data type Int64
+        Expr
+            Expression of data type :class:`Int64`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> df = pl.DataFrame(
         ...     {
         ...         "date": pl.date_range(
@@ -1775,15 +1803,16 @@
 
     def microseconds(self) -> Expr:
         """
         Extract the microseconds from a Duration type.
 
         Returns
         -------
-        Expression of data type Int64
+        Expr
+            Expression of data type :class:`Int64`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> df = pl.DataFrame(
         ...     {
         ...         "date": pl.date_range(
@@ -1822,15 +1851,16 @@
 
     def nanoseconds(self) -> Expr:
         """
         Extract the nanoseconds from a Duration type.
 
         Returns
         -------
-        Expression of data type Int64
+        Expr
+            Expression of data type :class:`Int64`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> df = pl.DataFrame(
         ...     {
         ...         "date": pl.date_range(
@@ -1899,15 +1929,16 @@
 
         By "calendar day", we mean the corresponding time on the next day (which may
         not be 24 hours, due to daylight savings). Similarly for "calendar week",
         "calendar month", "calendar quarter", and "calendar year".
 
         Returns
         -------
-        Date/Datetime expression
+        Expr
+            Expression of data type :class:`Date` or :class:`Datetime`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> df = pl.DataFrame(
         ...     {
         ...         "dates": pl.date_range(
@@ -1961,15 +1992,16 @@
 
     def month_start(self) -> Expr:
         """
         Roll backward to the first day of the month.
 
         Returns
         -------
-        Date/Datetime expression
+        Expr
+            Expression of data type :class:`Date` or :class:`Datetime`.
 
         Notes
         -----
         If you're coming from pandas, you can think of this as a vectorised version
         of ``pandas.tseries.offsets.MonthBegin().rollback(datetime)``.
 
         Examples
@@ -2007,15 +2039,16 @@
 
     def month_end(self) -> Expr:
         """
         Roll forward to the last day of the month.
 
         Returns
         -------
-        Date/Datetime expression
+        Expr
+            Expression of data type :class:`Date` or :class:`Datetime`.
 
         Notes
         -----
         If you're coming from pandas, you can think of this as a vectorised version
         of ``pandas.tseries.offsets.MonthEnd().rollforward(datetime)``.
 
         Examples
@@ -2057,15 +2090,16 @@
 
         This is usually constant for all datetimes in a given time zone, but
         may vary in the rare case that a country switches time zone, like
         Samoa (Apia) did at the end of 2011.
 
         Returns
         -------
-        Duration expression
+        Expr
+            Expression of data type :class:`Duration`.
 
         See Also
         --------
         Expr.dt.dst_offset : Daylight savings offset from UTC.
 
         Examples
         --------
@@ -2091,15 +2125,16 @@
 
     def dst_offset(self) -> Expr:
         """
         Additional offset currently in effect (typically due to daylight saving time).
 
         Returns
         -------
-        Duration expression
+        Expr
+            Expression of data type :class:`Duration`.
 
         See Also
         --------
         Expr.dt.base_utc_offset : Base offset from UTC.
 
         Examples
         --------
```

### Comparing `polars_lts_cpu-0.18.8/polars/expr/expr.py` & `polars_lts_cpu-0.18.9/polars/expr/expr.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 from __future__ import annotations
 
 import contextlib
 import math
 import operator
 import os
 import random
+import warnings
 from datetime import timedelta
 from functools import partial, reduce
 from typing import (
     TYPE_CHECKING,
     Any,
     Callable,
     ClassVar,
@@ -31,29 +32,33 @@
     UInt32,
     Utf8,
     is_polars_dtype,
     py_type_to_dtype,
 )
 from polars.dependencies import _check_for_numpy
 from polars.dependencies import numpy as np
-from polars.exceptions import PolarsPanicError
+from polars.exceptions import PolarsInefficientApplyWarning, PolarsPanicError
 from polars.expr.array import ExprArrayNameSpace
 from polars.expr.binary import ExprBinaryNameSpace
 from polars.expr.categorical import ExprCatNameSpace
 from polars.expr.datetime import ExprDateTimeNameSpace
 from polars.expr.list import ExprListNameSpace
 from polars.expr.meta import ExprMetaNameSpace
 from polars.expr.string import ExprStringNameSpace
 from polars.expr.struct import ExprStructNameSpace
 from polars.utils._parse_expr_input import (
     parse_as_expression,
     parse_as_list_of_expressions,
 )
 from polars.utils.convert import _timedelta_to_pl_duration
-from polars.utils.decorators import deprecated_alias, warn_closed_future_change
+from polars.utils.decorators import (
+    deprecated,
+    deprecated_alias,
+    warn_closed_future_change,
+)
 from polars.utils.meta import threadpool_size
 from polars.utils.various import sphinx_accessor
 
 with contextlib.suppress(ImportError):  # Module not available when building docs
     from polars.polars import arg_where as py_arg_where
     from polars.polars import reduce as pyreduce
 
@@ -319,15 +324,16 @@
         Parameters
         ----------
         drop_nulls
             If False, return None if there are nulls but no Trues.
 
         Returns
         -------
-        Boolean literal
+        Expr
+            Expression of data type :class:`Boolean`.
 
         Examples
         --------
         >>> df = pl.DataFrame({"TF": [True, False], "FF": [False, False]})
         >>> df.select(pl.all().any())
         shape: (1, 2)
         ┌──────┬───────┐
@@ -371,15 +377,16 @@
         ----------
         drop_nulls
             If False, return None if there are any nulls.
 
 
         Returns
         -------
-        Boolean literal
+        Expr
+            Expression of data type :class:`Boolean`.
 
         Examples
         --------
         >>> df = pl.DataFrame(
         ...     {"TT": [True, True], "TF": [True, False], "FF": [False, False]}
         ... )
         >>> df.select(pl.col("*").all())
@@ -1042,16 +1049,16 @@
 
     def is_finite(self) -> Self:
         """
         Returns a boolean Series indicating which values are finite.
 
         Returns
         -------
-        out
-            Series of type Boolean
+        Expr
+            Expression of data type :class:`Boolean`.
 
         Examples
         --------
         >>> df = pl.DataFrame(
         ...     {
         ...         "A": [1.0, 2],
         ...         "B": [3.0, float("inf")],
@@ -1073,16 +1080,16 @@
 
     def is_infinite(self) -> Self:
         """
         Returns a boolean Series indicating which values are infinite.
 
         Returns
         -------
-        out
-            Series of type Boolean
+        Expr
+            Expression of data type :class:`Boolean`.
 
         Examples
         --------
         >>> df = pl.DataFrame(
         ...     {
         ...         "A": [1.0, 2],
         ...         "B": [3.0, float("inf")],
@@ -2014,15 +2021,15 @@
             Sort in descending (descending) order.
         nulls_last
             Place null values last instead of first.
 
         Returns
         -------
         Expr
-            Series of dtype UInt32.
+            Expression of data type :class:`UInt32`.
 
         Examples
         --------
         >>> df = pl.DataFrame(
         ...     {
         ...         "a": [20, 10, 30],
         ...     }
@@ -2276,15 +2283,16 @@
         Parameters
         ----------
         indices
             An expression that leads to a UInt32 dtyped Series.
 
         Returns
         -------
-        Values taken by index
+        Expr
+            Expression of the same data type.
 
         Examples
         --------
         >>> df = pl.DataFrame(
         ...     {
         ...         "group": [
         ...             "one",
@@ -3169,15 +3177,16 @@
 
     def is_first(self) -> Self:
         """
         Get a mask of the first unique value.
 
         Returns
         -------
-        Boolean Series
+        Expr
+            Expression of data type :class:`Boolean`.
 
         Examples
         --------
         >>> df = pl.DataFrame(
         ...     {
         ...         "num": [1, 2, 3, 1, 5],
         ...     }
@@ -3482,15 +3491,16 @@
 
     def rle(self) -> Self:
         """
         Get the lengths of runs of identical values.
 
         Returns
         -------
-            A Struct Series containing "lengths" and "values" Fields
+        Expr
+            Expression of data type :class:`Struct` with Fields "lengths" and "values".
 
         Examples
         --------
         >>> df = pl.DataFrame(pl.Series("s", [1, 1, 2, 1, None, 1, 3, 3]))
         >>> df.select(pl.col("s").rle()).unnest("s")
         shape: (6, 2)
         ┌─────────┬────────┐
@@ -3809,22 +3819,28 @@
 
         if pass_name:
 
             def wrap_f(x: Series) -> Series:  # pragma: no cover
                 def inner(s: Series) -> Series:  # pragma: no cover
                     return function(s.alias(x.name))
 
-                return x.apply(inner, return_dtype=return_dtype, skip_nulls=skip_nulls)
+                with warnings.catch_warnings():
+                    warnings.simplefilter("ignore", PolarsInefficientApplyWarning)
+                    return x.apply(
+                        inner, return_dtype=return_dtype, skip_nulls=skip_nulls
+                    )
 
         else:
 
             def wrap_f(x: Series) -> Series:  # pragma: no cover
-                return x.apply(
-                    function, return_dtype=return_dtype, skip_nulls=skip_nulls
-                )
+                with warnings.catch_warnings():
+                    warnings.simplefilter("ignore", PolarsInefficientApplyWarning)
+                    return x.apply(
+                        function, return_dtype=return_dtype, skip_nulls=skip_nulls
+                    )
 
         if strategy == "thread_local":
             return self.map(wrap_f, agg_list=True, return_dtype=return_dtype)
         elif strategy == "threading":
 
             def wrap_threading(x: Series) -> Series:
                 df = x.to_frame("x")
@@ -3888,21 +3904,22 @@
         └───────┴───────────┘
 
         """
         return self._from_pyexpr(self._pyexpr.explode())
 
     def explode(self) -> Self:
         """
-        Explode a list Series.
+        Explode a list expression.
 
         This means that every item is expanded to a new row.
 
         Returns
         -------
-        Exploded Series of same dtype
+        Expr
+            Expression with the data type of the list elements.
 
         See Also
         --------
         Expr.list.explode : Explode a list column.
         Expr.str.explode : Explode a string column.
 
         Examples
@@ -4751,15 +4768,16 @@
         Parameters
         ----------
         other
             Series or sequence of primitive type.
 
         Returns
         -------
-        Expr that evaluates to a Boolean Series.
+        Expr
+            Expression of data type :class:`Boolean`.
 
         Examples
         --------
         >>> df = pl.DataFrame(
         ...     {"sets": [[1, 2, 3], [1, 2], [9, 10]], "optional_members": [1, 2, 3]}
         ... )
         >>> df.select([pl.col("optional_members").is_in("sets").alias("contains")])
@@ -4795,15 +4813,17 @@
         by
             Numeric column that determines how often the values will be repeated.
             The column will be coerced to UInt32. Give this dtype to make the coercion a
             no-op.
 
         Returns
         -------
-        Series of type List
+        Expr
+            Expression of data type :class:`List`, where the inner data type is equal
+            to the original data type.
 
         Examples
         --------
         >>> df = pl.DataFrame(
         ...     {
         ...         "a": ["x", "y", "z"],
         ...         "n": [1, 2, 3],
@@ -4843,15 +4863,16 @@
             Upper bound value. Accepts expression input. Strings are parsed as column
             names, other non-expression inputs are parsed as literals.
         closed : {'both', 'left', 'right', 'none'}
             Define which sides of the interval are closed (inclusive).
 
         Returns
         -------
-        Expr that evaluates to a Boolean Series.
+        Expr
+            Expression of data type :class:`Boolean`.
 
         Examples
         --------
         >>> df = pl.DataFrame({"num": [1, 2, 3, 4, 5]})
         >>> df.with_columns(pl.col("num").is_between(2, 4).alias("is_between"))
         shape: (5, 2)
         ┌─────┬────────────┐
@@ -7445,15 +7466,16 @@
 
     def sin(self) -> Self:
         """
         Compute the element-wise value for the sine.
 
         Returns
         -------
-        Series of dtype Float64
+        Expr
+            Expression of data type :class:`Float64`.
 
         Examples
         --------
         >>> df = pl.DataFrame({"a": [0.0]})
         >>> df.select(pl.col("a").sin())
         shape: (1, 1)
         ┌─────┐
@@ -7469,15 +7491,16 @@
 
     def cos(self) -> Self:
         """
         Compute the element-wise value for the cosine.
 
         Returns
         -------
-        Series of dtype Float64
+        Expr
+            Expression of data type :class:`Float64`.
 
         Examples
         --------
         >>> df = pl.DataFrame({"a": [0.0]})
         >>> df.select(pl.col("a").cos())
         shape: (1, 1)
         ┌─────┐
@@ -7493,15 +7516,16 @@
 
     def tan(self) -> Self:
         """
         Compute the element-wise value for the tangent.
 
         Returns
         -------
-        Series of dtype Float64
+        Expr
+            Expression of data type :class:`Float64`.
 
         Examples
         --------
         >>> df = pl.DataFrame({"a": [1.0]})
         >>> df.select(pl.col("a").tan().round(2))
         shape: (1, 1)
         ┌──────┐
@@ -7517,15 +7541,16 @@
 
     def arcsin(self) -> Self:
         """
         Compute the element-wise value for the inverse sine.
 
         Returns
         -------
-        Series of dtype Float64
+        Expr
+            Expression of data type :class:`Float64`.
 
         Examples
         --------
         >>> df = pl.DataFrame({"a": [1.0]})
         >>> df.select(pl.col("a").arcsin())
         shape: (1, 1)
         ┌──────────┐
@@ -7541,15 +7566,16 @@
 
     def arccos(self) -> Self:
         """
         Compute the element-wise value for the inverse cosine.
 
         Returns
         -------
-        Series of dtype Float64
+        Expr
+            Expression of data type :class:`Float64`.
 
         Examples
         --------
         >>> df = pl.DataFrame({"a": [0.0]})
         >>> df.select(pl.col("a").arccos())
         shape: (1, 1)
         ┌──────────┐
@@ -7565,15 +7591,16 @@
 
     def arctan(self) -> Self:
         """
         Compute the element-wise value for the inverse tangent.
 
         Returns
         -------
-        Series of dtype Float64
+        Expr
+            Expression of data type :class:`Float64`.
 
         Examples
         --------
         >>> df = pl.DataFrame({"a": [1.0]})
         >>> df.select(pl.col("a").arctan())
         shape: (1, 1)
         ┌──────────┐
@@ -7589,15 +7616,16 @@
 
     def sinh(self) -> Self:
         """
         Compute the element-wise value for the hyperbolic sine.
 
         Returns
         -------
-        Series of dtype Float64
+        Expr
+            Expression of data type :class:`Float64`.
 
         Examples
         --------
         >>> df = pl.DataFrame({"a": [1.0]})
         >>> df.select(pl.col("a").sinh())
         shape: (1, 1)
         ┌──────────┐
@@ -7613,15 +7641,16 @@
 
     def cosh(self) -> Self:
         """
         Compute the element-wise value for the hyperbolic cosine.
 
         Returns
         -------
-        Series of dtype Float64
+        Expr
+            Expression of data type :class:`Float64`.
 
         Examples
         --------
         >>> df = pl.DataFrame({"a": [1.0]})
         >>> df.select(pl.col("a").cosh())
         shape: (1, 1)
         ┌──────────┐
@@ -7637,15 +7666,16 @@
 
     def tanh(self) -> Self:
         """
         Compute the element-wise value for the hyperbolic tangent.
 
         Returns
         -------
-        Series of dtype Float64
+        Expr
+            Expression of data type :class:`Float64`.
 
         Examples
         --------
         >>> df = pl.DataFrame({"a": [1.0]})
         >>> df.select(pl.col("a").tanh())
         shape: (1, 1)
         ┌──────────┐
@@ -7661,15 +7691,16 @@
 
     def arcsinh(self) -> Self:
         """
         Compute the element-wise value for the inverse hyperbolic sine.
 
         Returns
         -------
-        Series of dtype Float64
+        Expr
+            Expression of data type :class:`Float64`.
 
         Examples
         --------
         >>> df = pl.DataFrame({"a": [1.0]})
         >>> df.select(pl.col("a").arcsinh())
         shape: (1, 1)
         ┌──────────┐
@@ -7685,15 +7716,16 @@
 
     def arccosh(self) -> Self:
         """
         Compute the element-wise value for the inverse hyperbolic cosine.
 
         Returns
         -------
-        Series of dtype Float64
+        Expr
+            Expression of data type :class:`Float64`.
 
         Examples
         --------
         >>> df = pl.DataFrame({"a": [1.0]})
         >>> df.select(pl.col("a").arccosh())
         shape: (1, 1)
         ┌─────┐
@@ -7709,15 +7741,16 @@
 
     def arctanh(self) -> Self:
         """
         Compute the element-wise value for the inverse hyperbolic tangent.
 
         Returns
         -------
-        Series of dtype Float64
+        Expr
+            Expression of data type :class:`Float64`.
 
         Examples
         --------
         >>> df = pl.DataFrame({"a": [1.0]})
         >>> df.select(pl.col("a").arctanh())
         shape: (1, 1)
         ┌─────┐
@@ -7733,15 +7766,16 @@
 
     def degrees(self) -> Self:
         """
         Convert from radians to degrees.
 
         Returns
         -------
-        Series of dtype Float64
+        Expr
+            Expression of data type :class:`Float64`.
 
         Examples
         --------
         >>> import math
         >>> df = pl.DataFrame({"a": [x * math.pi for x in range(-4, 5)]})
         >>> df.select(pl.col("a").degrees())
         shape: (9, 1)
@@ -7765,15 +7799,16 @@
 
     def radians(self) -> Self:
         """
         Convert from degrees to radians.
 
         Returns
         -------
-        Series of dtype Float64
+        Expr
+            Expression of data type :class:`Float64`.
 
         Examples
         --------
         >>> df = pl.DataFrame({"a": [-720, -540, -360, -180, 0, 180, 360, 540, 720]})
         >>> df.select(pl.col("a").radians())
         shape: (9, 1)
         ┌────────────┐
@@ -7803,17 +7838,18 @@
         dimensions
             Tuple of the dimension sizes. If a -1 is used in any of the dimensions, that
             dimension is inferred.
 
         Returns
         -------
         Expr
-            If a single dimension is given, results in a flat Series of shape (len,).
-            If a multiple dimensions are given, results in a Series of Lists with shape
-            (rows, cols).
+            If a single dimension is given, results in an expression of the original
+            data type.
+            If a multiple dimensions are given, results in an expression of data type
+            :class:`List` with shape (rows, cols).
 
         Examples
         --------
         >>> df = pl.DataFrame({"foo": [1, 2, 3, 4, 5, 6, 7, 8, 9]})
         >>> df.select(pl.col("foo").reshape((3, 3)))
         shape: (3, 1)
         ┌───────────┐
@@ -8254,15 +8290,16 @@
             Better to turn this off in the aggregation context, as it can lead to
             contention.
         sort:
             Ensure the output is sorted from most values to least.
 
         Returns
         -------
-        Dtype Struct
+        Expr
+            Expression of data type :class:`Struct`.
 
         Examples
         --------
         >>> df = pl.DataFrame(
         ...     {
         ...         "id": ["a", "b", "b", "c", "c", "c"],
         ...     }
@@ -8524,23 +8561,27 @@
         │ 2   ┆ 2          ┆ 2          ┆ 2    ┆ 2    ┆ b   ┆ 1.32 ┆ null  │
         │ 3   ┆ 8589934592 ┆ 1073741824 ┆ 112  ┆ 129  ┆ c   ┆ 0.12 ┆ false │
         └─────┴────────────┴────────────┴──────┴──────┴─────┴──────┴───────┘
 
         """
         return self._from_pyexpr(self._pyexpr.shrink_dtype())
 
+    @deprecated("Since version 0.8.9 'cache' is a no-op")
     def cache(self) -> Self:
         """
-        Cache this expression so that it only is executed once per context.
+        A no-op.
 
-        This can actually hurt performance and can have a lot of contention.
-        It is advised not to use it until actually benchmarked on your problem.
+        Don't use this, it does nothing. Activate `comm_subexpr_elim` to automatically
+        cache expression that are equal.
+
+        .. deprecated:: 0.8.9
+            Since version this method doesn't do anything.
 
         """
-        return self._from_pyexpr(self._pyexpr.cache())
+        return self
 
     def map_dict(
         self,
         remapping: dict[Any, Any],
         *,
         default: Any = None,
         return_dtype: PolarsDataType | None = None,
@@ -8553,14 +8594,15 @@
 
         Parameters
         ----------
         remapping
             Dictionary containing the before/after values to map.
         default
             Value to use when the remapping dict does not contain the lookup value.
+            Accepts expression input. Non-expression inputs are parsed as literals.
             Use ``pl.first()``, to keep the original value.
         return_dtype
             Set return dtype to override automatic return dtype determination.
 
         See Also
         --------
         map
@@ -8878,14 +8920,17 @@
                     values=remapping.values(),
                     dtype=None,
                     dtype_if_empty=input_dtype,
                     dtype_keys=input_dtype,
                     is_keys=False,
                 )
 
+            default_parsed = self._from_pyexpr(
+                parse_as_expression(default, str_as_lit=True)
+            )
             return (
                 (
                     df.lazy()
                     .join(
                         pl.DataFrame(
                             [
                                 remap_key_s,
@@ -8897,15 +8942,15 @@
                         how="left",
                         left_on=column,
                         right_on=remap_key_column,
                     )
                     .select(
                         F.when(F.col(is_remapped_column).is_not_null())
                         .then(F.col(remap_value_column))
-                        .otherwise(default)
+                        .otherwise(default_parsed)
                         .alias(column)
                     )
                 )
                 .collect(no_optimization=True)
                 .to_series()
             )
```

### Comparing `polars_lts_cpu-0.18.8/polars/expr/list.py` & `polars_lts_cpu-0.18.9/polars/expr/list.py`

 * *Files 5% similar despite different names*

```diff
@@ -433,15 +433,16 @@
         Parameters
         ----------
         item
             Item that will be checked for membership
 
         Returns
         -------
-        Boolean mask
+        Expr
+            Expression of data type :class:`Boolean`.
 
         Examples
         --------
         >>> df = pl.DataFrame({"foo": [[3, 2, 1], [], [1, 2]]})
         >>> df.select(pl.col("foo").list.contains(1))
         shape: (3, 1)
         ┌───────┐
@@ -467,15 +468,16 @@
         Parameters
         ----------
         separator
             string to separate the items with
 
         Returns
         -------
-        Series of dtype Utf8
+        Expr
+            Expression of data type :class:`Utf8`.
 
         Examples
         --------
         >>> df = pl.DataFrame({"s": [["a", "b", "c"], ["x", "y"]]})
         >>> df.select(pl.col("s").list.join(" "))
         shape: (2, 1)
         ┌───────┐
@@ -492,15 +494,17 @@
 
     def arg_min(self) -> Expr:
         """
         Retrieve the index of the minimal value in every sublist.
 
         Returns
         -------
-        Series of dtype UInt32/UInt64 (depending on compilation)
+        Expr
+            Expression of data type :class:`UInt32` or :class:`UInt64`
+            (depending on compilation).
 
         Examples
         --------
         >>> df = pl.DataFrame(
         ...     {
         ...         "a": [[1, 2], [2, 1]],
         ...     }
@@ -521,15 +525,17 @@
 
     def arg_max(self) -> Expr:
         """
         Retrieve the index of the maximum value in every sublist.
 
         Returns
         -------
-        Series of dtype UInt32/UInt64 (depending on compilation)
+        Expr
+            Expression of data type :class:`UInt32` or :class:`UInt64`
+            (depending on compilation).
 
         Examples
         --------
         >>> df = pl.DataFrame(
         ...     {
         ...         "a": [[1, 2], [2, 1]],
         ...     }
@@ -700,15 +706,16 @@
 
     def explode(self) -> Expr:
         """
         Returns a column with a separate row for every list element.
 
         Returns
         -------
-        Exploded column with the datatype of the list elements.
+        Expr
+            Expression with the data type of the list elements.
 
         See Also
         --------
         ExprNameSpace.reshape: Reshape this Expr to a flat Series or a Series of Lists.
 
         Examples
         --------
```

### Comparing `polars_lts_cpu-0.18.8/polars/expr/meta.py` & `polars_lts_cpu-0.18.9/polars/expr/meta.py`

 * *Files 1% similar despite different names*

```diff
@@ -55,17 +55,18 @@
 
     def pop(self) -> list[Expr]:
         """
         Pop the latest expression and return the input(s) of the popped expression.
 
         Returns
         -------
-        A list of expressions which in most cases will have a unit length.
-        This is not the case when an expression has multiple inputs.
-        For instance in a ``fold`` expression.
+        list of Expr
+            A list of expressions which in most cases will have a unit length.
+            This is not the case when an expression has multiple inputs.
+            For instance in a ``fold`` expression.
 
         """
         return [wrap_expr(e) for e in self._pyexpr.meta_pop()]
 
     def root_names(self) -> list[str]:
         """Get a list with the root column name."""
         return self._pyexpr.meta_root_names()
```

### Comparing `polars_lts_cpu-0.18.8/polars/expr/string.py` & `polars_lts_cpu-0.18.9/polars/expr/string.py`

 * *Files 1% similar despite different names*

```diff
@@ -427,15 +427,16 @@
         Parameters
         ----------
         delimiter
             The delimiter to insert between consecutive string values.
 
         Returns
         -------
-        Series of dtype Utf8
+        Expr
+            Expression of data type :class:`Utf8`.
 
         Examples
         --------
         >>> df = pl.DataFrame({"foo": [1, None, 2]})
         >>> df.select(pl.col("foo").str.concat("-"))
         shape: (1, 1)
         ┌──────────┐
@@ -985,31 +986,33 @@
         """
         if dtype is not None:
             dtype = py_type_to_dtype(dtype)
         return wrap_expr(self._pyexpr.str_json_extract(dtype, infer_schema_length))
 
     def json_path_match(self, json_path: str) -> Expr:
         """
-        Extract the first match of json string with provided JSONPath expression.
+        Extract the first match of JSON string with the provided JSONPath expression.
 
-        Throw errors if encounter invalid json strings.
-        All return value will be casted to Utf8 regardless of the original value.
+        Throws errors if invalid JSON strings are encountered.
+        All return values will be cast to :class:`Utf8` regardless of the original
+        value.
 
         Documentation on JSONPath standard can be found
         `here <https://goessner.net/articles/JsonPath/>`_.
 
         Parameters
         ----------
         json_path
             A valid JSON path query string.
 
         Returns
         -------
-        Utf8 array. Contain null if original value is null or the json_path return
-        nothing.
+        Expr
+            Expression of data type :class:`Utf8`. Contains null values if original
+            value is null or the json_path returns nothing.
 
         Examples
         --------
         >>> df = pl.DataFrame(
         ...     {"json_val": ['{"a":"1"}', None, '{"a":2}', '{"a":2.1}', '{"a":true}']}
         ... )
         >>> df.select(pl.col("json_val").str.json_path_match("$.a"))
@@ -1058,15 +1061,16 @@
         Parameters
         ----------
         encoding : {'hex', 'base64'}
             The encoding to use.
 
         Returns
         -------
-        Utf8 array with values encoded using provided encoding
+        Expr
+            Expression of data type :class:`Utf8`.
 
         Examples
         --------
         >>> df = pl.DataFrame({"strings": ["foo", "bar", None]})
         >>> df.select(pl.col("strings").str.encode("hex"))
         shape: (3, 1)
         ┌─────────┐
@@ -1131,15 +1135,17 @@
 
         See the regex crate's section on `grouping and flags
         <https://docs.rs/regex/latest/regex/#grouping-and-flags>`_ for
         additional information about the use of inline expression modifiers.
 
         Returns
         -------
-        Utf8 array. Contain null if original value is null or regex capture nothing.
+        Expr
+            Expression of data type :class:`Utf8`. Contains null values if original
+            value is null or the regex captures nothing.
 
         Examples
         --------
         >>> df = pl.DataFrame(
         ...     {
         ...         "url": [
         ...             "http://vote.com/ballon_dor?error=404&ref=unknown",
@@ -1225,15 +1231,16 @@
 
         See the regex crate's section on `grouping and flags
         <https://docs.rs/regex/latest/regex/#grouping-and-flags>`_ for
         additional information about the use of inline expression modifiers.
 
         Returns
         -------
-        List[Utf8]
+        Expr
+            Expression of data type ``List(Utf8)``.
 
         Examples
         --------
         >>> df = pl.DataFrame({"foo": ["123 bla 45 asd", "xyz 678 910t"]})
         >>> df.select(
         ...     pl.col("foo").str.extract_all(r"\d+").alias("extracted_nrs"),
         ... )
@@ -1259,15 +1266,17 @@
         ----------
         pattern
             A valid regular expression pattern, compatible with the `regex crate
             <https://docs.rs/regex/latest/regex/>`_.
 
         Returns
         -------
-        UInt32 array. Contain null if original value is null or regex capture nothing.
+        Expr
+            Expression of data type :class:`UInt32`. Contains null values if the
+            original value is null or the regex captures nothing.
 
         Examples
         --------
         >>> df = pl.DataFrame({"foo": ["123 bla 45 asd", "xyz 678 910t"]})
         >>> df.select(
         ...     pl.col("foo").str.count_match(r"\d").alias("count_digits"),
         ... )
@@ -1308,15 +1317,16 @@
         │ ["foo", "bar"]        │
         │ ["foo-bar"]           │
         │ ["foo", "bar", "baz"] │
         └───────────────────────┘
 
         Returns
         -------
-        List of Utf8 type
+        Expr
+            Expression of data type :class:`Utf8`.
 
         """
         if inclusive:
             return wrap_expr(self._pyexpr.str_split_inclusive(by))
         return wrap_expr(self._pyexpr.str_split(by))
 
     def split_exact(self, by: str, n: int, *, inclusive: bool = False) -> Expr:
@@ -1332,14 +1342,20 @@
         by
             Substring to split by.
         n
             Number of splits to make.
         inclusive
             If True, include the split character/string in the results.
 
+        Returns
+        -------
+        Expr
+            Expression of data type :class:`Struct` with fields of data type
+            :class:`Utf8`.
+
         Examples
         --------
         >>> df = pl.DataFrame({"x": ["a_1", None, "c", "d_4"]})
         >>> df.select(
         ...     pl.col("x").str.split_exact("_", 1).alias("fields"),
         ... )
         shape: (4, 1)
@@ -1374,18 +1390,14 @@
         ╞══════╪════════════╪═════════════╡
         │ a_1  ┆ a          ┆ 1           │
         │ null ┆ null       ┆ null        │
         │ c    ┆ c          ┆ null        │
         │ d_4  ┆ d          ┆ 4           │
         └──────┴────────────┴─────────────┘
 
-        Returns
-        -------
-        Struct of Utf8 type
-
         """
         if inclusive:
             return wrap_expr(self._pyexpr.str_split_exact_inclusive(by, n))
         return wrap_expr(self._pyexpr.str_split_exact(by, n))
 
     def splitn(self, by: str, n: int) -> Expr:
         """
@@ -1398,14 +1410,20 @@
         Parameters
         ----------
         by
             Substring to split by.
         n
             Max number of items to return.
 
+        Returns
+        -------
+        Expr
+            Expression of data type :class:`Struct` with fields of data type
+            :class:`Utf8`.
+
         Examples
         --------
         >>> df = pl.DataFrame({"s": ["foo bar", None, "foo-bar", "foo bar baz"]})
         >>> df.select(pl.col("s").str.splitn(" ", 2).alias("fields"))
         shape: (4, 1)
         ┌───────────────────┐
         │ fields            │
@@ -1437,18 +1455,14 @@
         ╞═════════════╪════════════╪═════════════╡
         │ foo bar     ┆ foo        ┆ bar         │
         │ null        ┆ null       ┆ null        │
         │ foo-bar     ┆ foo-bar    ┆ null        │
         │ foo bar baz ┆ foo        ┆ bar baz     │
         └─────────────┴────────────┴─────────────┘
 
-        Returns
-        -------
-        Struct of Utf8 type
-
         """
         return wrap_expr(self._pyexpr.str_splitn(by, n))
 
     def replace(
         self,
         pattern: str | Expr,
         value: str | Expr,
@@ -1578,15 +1592,15 @@
         length
             Length of the slice. If set to ``None`` (default), the slice is taken to the
             end of the string.
 
         Returns
         -------
         Expr
-            Series of dtype Utf8.
+            Expression of data type :class:`Utf8`.
 
         Examples
         --------
         >>> df = pl.DataFrame({"s": ["pear", None, "papaya", "dragonfruit"]})
         >>> df.with_columns(
         ...     pl.col("s").str.slice(-3).alias("s_sliced"),
         ... )
@@ -1624,15 +1638,16 @@
 
     def explode(self) -> Expr:
         """
         Returns a column with a separate row for every string character.
 
         Returns
         -------
-        Exploded column with string datatype.
+        Expr
+            Expression of data type :class:`Utf8`.
 
         Examples
         --------
         >>> df = pl.DataFrame({"a": ["foo", "bar"]})
         >>> df.select(pl.col("a").str.explode())
         shape: (6, 1)
         ┌─────┐
@@ -1665,15 +1680,16 @@
 
         strict
             Bool, Default=True will raise any ParseError or overflow as ComputeError.
             False silently convert to Null.
 
         Returns
         -------
-        Expr : Series of parsed integers in i32 format
+        Expr
+            Expression of data type :class:`Int32`.
 
         Examples
         --------
         >>> df = pl.DataFrame({"bin": ["110", "101", "010", "invalid"]})
         >>> df.select(pl.col("bin").str.parse_int(2, strict=False))
         shape: (4, 1)
         ┌──────┐
```

### Comparing `polars_lts_cpu-0.18.8/polars/expr/struct.py` & `polars_lts_cpu-0.18.9/polars/expr/struct.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/functions/__init__.py` & `polars_lts_cpu-0.18.9/polars/functions/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -22,14 +22,16 @@
 from polars.functions.as_datatype import date_ as date
 from polars.functions.as_datatype import datetime_ as datetime
 from polars.functions.as_datatype import time_ as time
 from polars.functions.eager import align_frames, concat
 from polars.functions.lazy import (
     apply,
     approx_unique,
+    arctan2,
+    arctan2d,
     arg_sort_by,
     arg_where,
     avg,
     coalesce,
     col,
     collect_all,
     corr,
@@ -57,15 +59,23 @@
     rolling_cov,
     select,
     sql_expr,
     std,
     tail,
     var,
 )
-from polars.functions.range import arange, date_range, int_range, int_ranges, time_range
+from polars.functions.range import (
+    arange,
+    date_range,
+    date_ranges,
+    int_range,
+    int_ranges,
+    time_range,
+    time_ranges,
+)
 from polars.functions.repeat import ones, repeat, zeros
 from polars.functions.whenthen import when
 
 __all__ = [
     # polars.functions.aggregation
     "all",
     "any",
@@ -81,22 +91,26 @@
     "sum_horizontal",
     # polars.functions.eager
     "align_frames",
     "approx_unique",
     "arg_where",
     "concat",
     "date_range",
+    "date_ranges",
     "element",
     "ones",
     "repeat",
     "time_range",
+    "time_ranges",
     "zeros",
     # polars.functions.lazy
     "apply",
     "arange",
+    "arctan2",
+    "arctan2d",
     "arg_sort_by",
     "avg",
     "coalesce",
     "col",
     "collect_all",
     "concat_list",
     "concat_str",
```

### Comparing `polars_lts_cpu-0.18.8/polars/functions/aggregation/horizontal.py` & `polars_lts_cpu-0.18.9/polars/functions/aggregation/horizontal.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/functions/aggregation/vertical.py` & `polars_lts_cpu-0.18.9/polars/functions/aggregation/vertical.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/functions/as_datatype.py` & `polars_lts_cpu-0.18.9/polars/functions/as_datatype.py`

 * *Files 4% similar despite different names*

```diff
@@ -51,15 +51,16 @@
     second
         column or literal, ranging from 0-59.
     microsecond
         column or literal, ranging from 0-999999.
 
     Returns
     -------
-    Expr of type `pl.Datetime`
+    Expr
+        Expression of data type :class:`Datetime`.
 
     """
     year_expr = parse_as_expression(year)
     month_expr = parse_as_expression(month)
     day_expr = parse_as_expression(day)
 
     if hour is not None:
@@ -99,15 +100,16 @@
     month
         column or literal, ranging from 1-12.
     day
         column or literal, ranging from 1-31.
 
     Returns
     -------
-    Expr of type pl.Date
+    Expr
+        Expression of data type :class:`Date`.
 
     """
     return datetime_(year, month, day).cast(Date).alias("date")
 
 
 def time_(
     hour: Expr | str | int | None = None,
@@ -127,15 +129,16 @@
     second
         column or literal, ranging from 0-59.
     microsecond
         column or literal, ranging from 0-999999.
 
     Returns
     -------
-    Expr of type pl.Date
+    Expr
+        Expression of data type :class:`Date`.
 
     """
     epoch_start = (1970, 1, 1)
     return (
         datetime_(*epoch_start, hour, minute, second, microsecond)
         .cast(Time)
         .alias("time")
@@ -154,15 +157,16 @@
     weeks: Expr | str | int | None = None,
 ) -> Expr:
     """
     Create polars `Duration` from distinct time components.
 
     Returns
     -------
-    Expr of type `pl.Duration`
+    Expr
+        Expression of data type :class:`Duration`.
 
     Examples
     --------
     >>> from datetime import datetime
     >>> df = pl.DataFrame(
     ...     {
     ...         "dt": [datetime(2022, 1, 1), datetime(2022, 1, 2)],
```

### Comparing `polars_lts_cpu-0.18.8/polars/functions/eager.py` & `polars_lts_cpu-0.18.9/polars/functions/eager.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/functions/lazy.py` & `polars_lts_cpu-0.18.9/polars/functions/lazy.py`

 * *Files 2% similar despite different names*

```diff
@@ -23,14 +23,15 @@
 )
 from polars.utils._wrap import wrap_df, wrap_expr
 from polars.utils.convert import (
     _datetime_to_pl_timestamp,
     _time_to_pl_time,
     _timedelta_to_pl_timedelta,
 )
+from polars.utils.decorators import deprecated_alias
 from polars.utils.various import find_stacklevel
 
 with contextlib.suppress(ImportError):  # Module not available when building docs
     import polars.polars as plr
 
 
 if TYPE_CHECKING:
@@ -1110,14 +1111,15 @@
         Function to apply over the input
     return_dtype
         dtype of the output Series
 
     Returns
     -------
     Expr
+        Expression with the data type given by ``return_dtype``.
 
     Examples
     --------
     >>> def test_func(a, b, c):
     ...     return a + b + c
     ...
     >>> df = pl.DataFrame(
@@ -1186,14 +1188,15 @@
         dtype of the output Series
     returns_scalar
         If the function returns a single scalar as output.
 
     Returns
     -------
     Expr
+        Expression with the data type given by ``return_dtype``.
 
     Examples
     --------
     >>> df = pl.DataFrame(
     ...     {
     ...         "a": [7, 2, 3, 4],
     ...         "b": [2, 5, 6, 7],
@@ -1548,14 +1551,108 @@
     if isinstance(exprs, pl.Expr):
         exprs = [exprs]
 
     exprs = parse_as_list_of_expressions(exprs)
     return wrap_expr(plr.cumreduce(function, exprs))
 
 
+def arctan2(y: str | Expr, x: str | Expr) -> Expr:
+    """
+    Compute two argument arctan in radians.
+
+    Returns the angle (in radians) in the plane between the
+    positive x-axis and the ray from the origin to (x,y).
+
+    Parameters
+    ----------
+    y
+        Column name or Expression.
+    x
+        Column name or Expression.
+
+    Examples
+    --------
+    >>> import math
+    >>> twoRootTwo = math.sqrt(2) / 2
+    >>> df = pl.DataFrame(
+    ...     {
+    ...         "y": [twoRootTwo, -twoRootTwo, twoRootTwo, -twoRootTwo],
+    ...         "x": [twoRootTwo, twoRootTwo, -twoRootTwo, -twoRootTwo],
+    ...     }
+    ... )
+    >>> df.select(
+    ...     pl.arctan2d("y", "x").alias("atan2d"), pl.arctan2("y", "x").alias("atan2")
+    ... )
+    shape: (4, 2)
+    ┌────────┬───────────┐
+    │ atan2d ┆ atan2     │
+    │ ---    ┆ ---       │
+    │ f64    ┆ f64       │
+    ╞════════╪═══════════╡
+    │ 45.0   ┆ 0.785398  │
+    │ -45.0  ┆ -0.785398 │
+    │ 135.0  ┆ 2.356194  │
+    │ -135.0 ┆ -2.356194 │
+    └────────┴───────────┘
+
+    """
+    if isinstance(y, str):
+        y = col(y)
+    if isinstance(x, str):
+        x = col(x)
+    return wrap_expr(plr.arctan2(y._pyexpr, x._pyexpr))
+
+
+def arctan2d(y: str | Expr, x: str | Expr) -> Expr:
+    """
+    Compute two argument arctan in degrees.
+
+    Returns the angle (in degrees) in the plane between the positive x-axis
+    and the ray from the origin to (x,y).
+
+    Parameters
+    ----------
+    y
+        Column name or Expression.
+    x
+        Column name or Expression.
+
+    Examples
+    --------
+    >>> import math
+    >>> twoRootTwo = math.sqrt(2) / 2
+    >>> df = pl.DataFrame(
+    ...     {
+    ...         "y": [twoRootTwo, -twoRootTwo, twoRootTwo, -twoRootTwo],
+    ...         "x": [twoRootTwo, twoRootTwo, -twoRootTwo, -twoRootTwo],
+    ...     }
+    ... )
+    >>> df.select(
+    ...     pl.arctan2d("y", "x").alias("atan2d"), pl.arctan2("y", "x").alias("atan2")
+    ... )
+    shape: (4, 2)
+    ┌────────┬───────────┐
+    │ atan2d ┆ atan2     │
+    │ ---    ┆ ---       │
+    │ f64    ┆ f64       │
+    ╞════════╪═══════════╡
+    │ 45.0   ┆ 0.785398  │
+    │ -45.0  ┆ -0.785398 │
+    │ 135.0  ┆ 2.356194  │
+    │ -135.0 ┆ -2.356194 │
+    └────────┴───────────┘
+
+    """
+    if isinstance(y, str):
+        y = col(y)
+    if isinstance(x, str):
+        x = col(x)
+    return wrap_expr(plr.arctan2d(y._pyexpr, x._pyexpr))
+
+
 def exclude(
     columns: str | PolarsDataType | Iterable[str] | Iterable[PolarsDataType],
     *more_columns: str | PolarsDataType,
 ) -> Expr:
     """
     Represent all columns except for the given columns.
 
@@ -1717,24 +1814,26 @@
     elif len(exprs) != len(descending):
         raise ValueError(
             f"the length of `descending` ({len(descending)}) does not match the length of `exprs` ({len(exprs)})"
         )
     return wrap_expr(plr.arg_sort_by(exprs, descending))
 
 
+@deprecated_alias(common_subplan_elimination="comm_subplan_elim")
 def collect_all(
     lazy_frames: Sequence[LazyFrame],
     *,
     type_coercion: bool = True,
     predicate_pushdown: bool = True,
     projection_pushdown: bool = True,
     simplify_expression: bool = True,
     no_optimization: bool = False,
     slice_pushdown: bool = True,
-    common_subplan_elimination: bool = True,
+    comm_subplan_elim: bool = True,
+    comm_subexpr_elim: bool = True,
     streaming: bool = False,
 ) -> list[DataFrame]:
     """
     Collect multiple LazyFrames at the same time.
 
     This runs all the computation graphs in parallel on the Polars threadpool.
 
@@ -1750,41 +1849,45 @@
         Do projection pushdown optimization.
     simplify_expression
         Run simplify expressions optimization.
     no_optimization
         Turn off optimizations.
     slice_pushdown
         Slice pushdown optimization.
-    common_subplan_elimination
+    comm_subplan_elim
         Will try to cache branching subplans that occur on self-joins or unions.
+    comm_subexpr_elim
+        Common subexpressions will be cached and reused.
     streaming
         Run parts of the query in a streaming fashion (this is in an alpha state)
 
     Returns
     -------
-    List[DataFrame]
+    list of DataFrames
         The collected DataFrames, returned in the same order as the input LazyFrames.
 
     """
     if no_optimization:
         predicate_pushdown = False
         projection_pushdown = False
         slice_pushdown = False
-        common_subplan_elimination = False
+        comm_subplan_elim = False
+        comm_subexpr_elim = False
 
     prepared = []
 
     for lf in lazy_frames:
         ldf = lf._ldf.optimization_toggle(
             type_coercion,
             predicate_pushdown,
             projection_pushdown,
             simplify_expression,
             slice_pushdown,
-            common_subplan_elimination,
+            comm_subplan_elim,
+            comm_subexpr_elim,
             streaming,
         )
         prepared.append(ldf)
 
     out = plr.collect_all(prepared)
 
     # wrap the pydataframes into dataframe
```

### Comparing `polars_lts_cpu-0.18.8/polars/functions/range.py` & `polars_lts_cpu-0.18.9/polars/functions/range.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,21 +1,19 @@
 from __future__ import annotations
 
 import contextlib
 import warnings
 from datetime import time, timedelta
 from typing import TYPE_CHECKING, overload
 
-import polars._reexport as pl
 from polars import functions as F
 from polars.datatypes import Int64
 from polars.utils._parse_expr_input import parse_as_expression
-from polars.utils._wrap import wrap_expr, wrap_s
+from polars.utils._wrap import wrap_expr
 from polars.utils.convert import (
-    _time_to_pl_time,
     _timedelta_to_pl_duration,
 )
 from polars.utils.decorators import deprecated_alias
 from polars.utils.various import find_stacklevel
 
 with contextlib.suppress(ImportError):  # Module not available when building docs
     import polars.polars as plr
@@ -95,16 +93,16 @@
     end
         Upper bound of the range (exclusive).
     step
         Step size of the range.
     dtype
         Data type of the resulting column. Defaults to ``Int64``.
     eager
-        Evaluate immediately and return a ``Series``. If set to ``False`` (default),
-        return an expression instead.
+        Evaluate immediately and return a ``Series``.
+        If set to ``False`` (default), return an expression instead.
 
     See Also
     --------
     int_range : Generate a range of integers.
     int_ranges : Generate a range of integers for each row of the input columns.
 
     Examples
@@ -197,20 +195,21 @@
     end
         Upper bound of the range (exclusive).
     step
         Step size of the range.
     dtype
         Data type of the range. Defaults to ``Int64``.
     eager
-        Evaluate immediately and return a ``Series``. If set to ``False`` (default),
-        return an expression instead.
+        Evaluate immediately and return a ``Series``.
+        If set to ``False`` (default), return an expression instead.
 
     Returns
     -------
-    Column of data type ``Int64``.
+    Expr or Series
+        Column of data type :class:`Int64`.
 
     See Also
     --------
     int_ranges : Generate a range of integers for each row of the input columns.
 
     Examples
     --------
@@ -288,20 +287,21 @@
     end
         Upper bound of the range (exclusive).
     step
         Step size of the range.
     dtype
         Integer data type of the ranges. Defaults to ``Int64``.
     eager
-        Evaluate immediately and return a ``Series``. If set to ``False`` (default),
-        return an expression instead.
+        Evaluate immediately and return a ``Series``.
+        If set to ``False`` (default), return an expression instead.
 
     Returns
     -------
-    Column of data type ``List(dtype)``.
+    Expr or Series
+        Column of data type ``List(dtype)``.
 
     See Also
     --------
     int_range : Generate a single range of integers.
 
     Examples
     --------
@@ -326,103 +326,109 @@
         return F.select(result).to_series()
 
     return result
 
 
 @overload
 def date_range(
-    start: date | datetime | Expr | str,
-    end: date | datetime | Expr | str,
+    start: date | datetime | IntoExpr,
+    end: date | datetime | IntoExpr,
     interval: str | timedelta = ...,
     *,
     closed: ClosedInterval = ...,
     time_unit: TimeUnit | None = ...,
     time_zone: str | None = ...,
     eager: Literal[False] = ...,
     name: str | None = ...,
 ) -> Expr:
     ...
 
 
 @overload
 def date_range(
-    start: date | datetime | Expr | str,
-    end: date | datetime | Expr | str,
+    start: date | datetime | IntoExpr,
+    end: date | datetime | IntoExpr,
     interval: str | timedelta = ...,
     *,
     closed: ClosedInterval = ...,
     time_unit: TimeUnit | None = ...,
     time_zone: str | None = ...,
     eager: Literal[True],
     name: str | None = ...,
 ) -> Series:
     ...
 
 
 @overload
 def date_range(
-    start: date | datetime | Expr | str,
-    end: date | datetime | Expr | str,
+    start: date | datetime | IntoExpr,
+    end: date | datetime | IntoExpr,
     interval: str | timedelta = ...,
     *,
     closed: ClosedInterval = ...,
     time_unit: TimeUnit | None = ...,
     time_zone: str | None = ...,
     eager: bool,
     name: str | None = ...,
 ) -> Series | Expr:
     ...
 
 
 @deprecated_alias(low="start", high="end")
 def date_range(
-    start: date | datetime | Expr | str,
-    end: date | datetime | Expr | str,
+    start: date | datetime | IntoExpr,
+    end: date | datetime | IntoExpr,
     interval: str | timedelta = "1d",
     *,
     closed: ClosedInterval = "both",
     time_unit: TimeUnit | None = None,
     time_zone: str | None = None,
     eager: bool = False,
     name: str | None = None,
 ) -> Series | Expr:
     """
-    Create a range of type `Datetime` (or `Date`).
+    Generate a date range.
 
     Parameters
     ----------
     start
-        Lower bound of the date range, given as a date, datetime, Expr, or column name.
+        Lower bound of the date range.
     end
-        Upper bound of the date range, given as a date, datetime, Expr, or column name.
+        Upper bound of the date range.
     interval
-        Interval of the range periods; can be a python timedelta object like
-        ``timedelta(days=10)`` or a polars duration string, such as ``3d12h4m25s``
-        (representing 3 days, 12 hours, 4 minutes, and 25 seconds). Append
-        ``_saturating`` to the interval string to restrict resulting invalid dates to
-        valid ranges.
+        Interval of the range periods, specified as a Python ``timedelta`` object
+        or a Polars duration string like ``1h30m25s``.
+
+        Append ``_saturating`` to the interval string to restrict resulting invalid
+        dates to valid ranges.
 
         It is common to attempt to create a month-end date series by using the "1mo"
         offset string with a start date at the end of the month. This will not produce
         the desired results. See Note #2 below for further information.
     closed : {'both', 'left', 'right', 'none'}
-        Define whether the temporal window interval is closed or not.
+        Define which sides of the range are closed (inclusive).
     time_unit : {None, 'ns', 'us', 'ms'}
-        Set the time unit. Only takes effect if output is of ``Datetime`` type.
-    time_zone:
-        Optional timezone. Only takes effect if output is of ``Datetime`` type.
+        Time unit of the resulting ``Datetime`` data type.
+        Only takes effect if the output column is of type ``Datetime``.
+    time_zone
+        Time zone of the resulting ``Datetime`` data type.
+        Only takes effect if the output column is of type ``Datetime``.
     eager
-        Evaluate immediately and return a ``Series``. If set to ``False`` (default),
-        return an expression instead.
+        Evaluate immediately and return a ``Series``.
+        If set to ``False`` (default), return an expression instead.
     name
         Name of the output column.
 
         .. deprecated:: 0.18.0
             This argument is deprecated. Use the ``alias`` method instead.
 
+    Returns
+    -------
+    Expr or Series
+        Column of data type :class:`Date` or :class:`Datetime`.
 
     Notes
     -----
     1) If both ``start`` and ``end`` are passed as date types (not datetime), and the
     interval granularity is no finer than 1d, the returned range is also of
     type date. All other permutations return a datetime Series.
 
@@ -456,33 +462,29 @@
             2023-01-31
             2023-02-28
             2023-03-31
             2023-04-30
             2023-05-31
     ]
 
-    Returns
-    -------
-    A Series of type `Datetime` or `Date`.
-
     Examples
     --------
-    Using polars duration string to specify the interval:
+    Using Polars duration string to specify the interval:
 
     >>> from datetime import date
     >>> pl.date_range(date(2022, 1, 1), date(2022, 3, 1), "1mo", eager=True)
     shape: (3,)
     Series: 'date' [date]
     [
         2022-01-01
         2022-02-01
         2022-03-01
     ]
 
-    Using `timedelta` object to specify the interval:
+    Using ``timedelta`` object to specify the interval:
 
     >>> from datetime import datetime, timedelta
     >>> pl.date_range(
     ...     datetime(1985, 1, 1),
     ...     datetime(1985, 1, 10),
     ...     timedelta(days=1, hours=12),
     ...     time_unit="ms",
@@ -496,15 +498,15 @@
         1985-01-04 00:00:00
         1985-01-05 12:00:00
         1985-01-07 00:00:00
         1985-01-08 12:00:00
         1985-01-10 00:00:00
     ]
 
-    Specify a time zone
+    Specifying a time zone:
 
     >>> pl.date_range(
     ...     datetime(2022, 1, 1),
     ...     datetime(2022, 3, 1),
     ...     "1mo",
     ...     time_zone="America/New_York",
     ...     eager=True,
@@ -515,19 +517,17 @@
         2022-01-01 00:00:00 EST
         2022-02-01 00:00:00 EST
         2022-03-01 00:00:00 EST
     ]
 
     Combine with ``month_end`` to get the last day of the month:
 
-    >>> (
-    ...     pl.date_range(
-    ...         datetime(2022, 1, 1), datetime(2022, 3, 1), "1mo", eager=True
-    ...     ).dt.month_end()
-    ... )
+    >>> pl.date_range(
+    ...     datetime(2022, 1, 1), datetime(2022, 3, 1), "1mo", eager=True
+    ... ).dt.month_end()
     shape: (3,)
     Series: 'date' [datetime[μs]]
     [
         2022-01-31 00:00:00
         2022-02-28 00:00:00
         2022-03-31 00:00:00
     ]
@@ -536,127 +536,252 @@
     if name is not None:
         warnings.warn(
             "the `name` argument is deprecated. Use the `alias` method instead.",
             DeprecationWarning,
             stacklevel=find_stacklevel(),
         )
 
-    if isinstance(interval, timedelta):
-        interval = _timedelta_to_pl_duration(interval)
-    elif " " in interval:
-        interval = interval.replace(" ", "")
-
-    time_unit_: TimeUnit | None
-    if time_unit is not None:
-        time_unit_ = time_unit
-    elif "ns" in interval:
-        time_unit_ = "ns"
-    else:
-        time_unit_ = None
-
-    start_pl = parse_as_expression(start)
-    end_pl = parse_as_expression(end)
-    dt_range = wrap_expr(
-        plr.date_range_lazy(start_pl, end_pl, interval, closed, time_unit_, time_zone)
+    interval = _parse_interval_argument(interval)
+    if time_unit is None and "ns" in interval:
+        time_unit = "ns"
+
+    start_pyexpr = parse_as_expression(start)
+    end_pyexpr = parse_as_expression(end)
+    result = wrap_expr(
+        plr.date_range(start_pyexpr, end_pyexpr, interval, closed, time_unit, time_zone)
     )
+
     if name is not None:
-        dt_range = dt_range.alias(name)
+        result = result.alias(name)
+
+    if eager:
+        s = F.select(result).to_series()
+        if s.len() == 1:
+            s = s.explode().set_sorted()
+        else:
+            _warn_for_deprecation_date_range()
+        return s
+
+    _warn_for_deprecation_date_range()
+
+    return result
+
+
+@overload
+def date_ranges(
+    start: date | datetime | IntoExpr,
+    end: date | datetime | IntoExpr,
+    interval: str | timedelta = ...,
+    *,
+    closed: ClosedInterval = ...,
+    time_unit: TimeUnit | None = ...,
+    time_zone: str | None = ...,
+    eager: Literal[False] = ...,
+) -> Expr:
+    ...
+
+
+@overload
+def date_ranges(
+    start: date | datetime | IntoExpr,
+    end: date | datetime | IntoExpr,
+    interval: str | timedelta = ...,
+    *,
+    closed: ClosedInterval = ...,
+    time_unit: TimeUnit | None = ...,
+    time_zone: str | None = ...,
+    eager: Literal[True],
+) -> Series:
+    ...
+
+
+@overload
+def date_ranges(
+    start: date | datetime | IntoExpr,
+    end: date | datetime | IntoExpr,
+    interval: str | timedelta = ...,
+    *,
+    closed: ClosedInterval = ...,
+    time_unit: TimeUnit | None = ...,
+    time_zone: str | None = ...,
+    eager: bool,
+) -> Series | Expr:
+    ...
+
+
+def date_ranges(
+    start: date | datetime | IntoExpr,
+    end: date | datetime | IntoExpr,
+    interval: str | timedelta = "1d",
+    *,
+    closed: ClosedInterval = "both",
+    time_unit: TimeUnit | None = None,
+    time_zone: str | None = None,
+    eager: bool = False,
+) -> Series | Expr:
+    """
+    Create a column of date ranges.
+
+    Parameters
+    ----------
+    start
+        Lower bound of the date range.
+    end
+        Upper bound of the date range.
+    interval
+        Interval of the range periods, specified as a Python ``timedelta`` object
+        or a Polars duration string like ``1h30m25s``.
+
+        Append ``_saturating`` to the interval string to restrict resulting invalid
+        dates to valid ranges.
+
+        It is common to attempt to create a month-end date series by using the "1mo"
+        offset string with a start date at the end of the month. This will not produce
+        the desired results. See Note #2 below for further information.
+    closed : {'both', 'left', 'right', 'none'}
+        Define which sides of the range are closed (inclusive).
+    time_unit : {None, 'ns', 'us', 'ms'}
+        Time unit of the resulting ``Datetime`` data type.
+        Only takes effect if the output column is of type ``Datetime``.
+    time_zone
+        Time zone of the resulting ``Datetime`` data type.
+        Only takes effect if the output column is of type ``Datetime``.
+    eager
+        Evaluate immediately and return a ``Series``.
+        If set to ``False`` (default), return an expression instead.
 
-    if (
-        not eager
-        or isinstance(start_pl, (str, pl.Expr))
-        or isinstance(end_pl, (str, pl.Expr))
-    ):
-        return dt_range
-    res = F.select(dt_range).to_series().explode().set_sorted()
-    return res
+    Returns
+    -------
+    Expr or Series
+        Column of data type ``List(Date)`` or ``List(Datetime)``.
+
+    Examples
+    --------
+    >>> from datetime import date
+    >>> df = pl.DataFrame(
+    ...     {
+    ...         "start": [date(2022, 1, 1), date(2022, 1, 2)],
+    ...         "end": date(2022, 1, 3),
+    ...     }
+    ... )
+    >>> df.with_columns(pl.date_ranges("start", "end"))
+    shape: (2, 3)
+    ┌────────────┬────────────┬───────────────────────────────────┐
+    │ start      ┆ end        ┆ date_range                        │
+    │ ---        ┆ ---        ┆ ---                               │
+    │ date       ┆ date       ┆ list[date]                        │
+    ╞════════════╪════════════╪═══════════════════════════════════╡
+    │ 2022-01-01 ┆ 2022-01-03 ┆ [2022-01-01, 2022-01-02, 2022-01… │
+    │ 2022-01-02 ┆ 2022-01-03 ┆ [2022-01-02, 2022-01-03]          │
+    └────────────┴────────────┴───────────────────────────────────┘
+
+    """
+    interval = _parse_interval_argument(interval)
+    if time_unit is None and "ns" in interval:
+        time_unit = "ns"
+
+    start_pyexpr = parse_as_expression(start)
+    end_pyexpr = parse_as_expression(end)
+
+    result = wrap_expr(
+        plr.date_ranges(
+            start_pyexpr, end_pyexpr, interval, closed, time_unit, time_zone
+        )
+    )
+
+    if eager:
+        return F.select(result).to_series()
+
+    return result
 
 
 @overload
 def time_range(
-    start: time | Expr | str | None = ...,
-    end: time | Expr | str | None = ...,
+    start: time | IntoExpr | None = ...,
+    end: time | IntoExpr | None = ...,
     interval: str | timedelta = ...,
     *,
     closed: ClosedInterval = ...,
     eager: Literal[False] = ...,
     name: str | None = ...,
 ) -> Expr:
     ...
 
 
 @overload
 def time_range(
-    start: time | Expr | str | None = ...,
-    end: time | Expr | str | None = ...,
+    start: time | IntoExpr | None = ...,
+    end: time | IntoExpr | None = ...,
     interval: str | timedelta = ...,
     *,
     closed: ClosedInterval = ...,
     eager: Literal[True],
     name: str | None = ...,
 ) -> Series:
     ...
 
 
 @overload
 def time_range(
-    start: time | Expr | str | None = ...,
-    end: time | Expr | str | None = ...,
+    start: time | IntoExpr | None = ...,
+    end: time | IntoExpr | None = ...,
     interval: str | timedelta = ...,
     *,
     closed: ClosedInterval = ...,
     eager: bool,
     name: str | None = ...,
 ) -> Series | Expr:
     ...
 
 
 def time_range(
-    start: time | Expr | str | None = None,
-    end: time | Expr | str | None = None,
+    start: time | IntoExpr | None = None,
+    end: time | IntoExpr | None = None,
     interval: str | timedelta = "1h",
     *,
     closed: ClosedInterval = "both",
     eager: bool = False,
     name: str | None = None,
 ) -> Series | Expr:
     """
-    Create a range of type `Time`.
+    Generate a time range.
 
     Parameters
     ----------
     start
-        Lower bound of the time range, given as a time, Expr, or column name.
-        If omitted, will default to ``time(0,0,0,0)``.
+        Lower bound of the time range.
+        If omitted, defaults to ``time(0,0,0,0)``.
     end
-        Upper bound of the time range, given as a time, Expr, or column name.
-        If omitted, will default to ``time(23,59,59,999999)``.
+        Upper bound of the time range.
+        If omitted, defaults to ``time(23,59,59,999999)``.
     interval
-        Interval of the range periods; can be a python timedelta object like
-        ``timedelta(minutes=10)`` or a polars duration string, such as ``1h30m25s``
-        (representing 1 hour, 30 minutes, and 25 seconds).
+        Interval of the range periods, specified as a Python ``timedelta`` object
+        or a Polars duration string like ``1h30m25s``.
     closed : {'both', 'left', 'right', 'none'}
-        Define whether the temporal window interval is closed or not.
+        Define which sides of the range are closed (inclusive).
     eager
-        Evaluate immediately and return a ``Series``. If set to ``False`` (default),
-        return an expression instead.
+        Evaluate immediately and return a ``Series``.
+        If set to ``False`` (default), return an expression instead.
     name
         Name of the output column.
 
         .. deprecated:: 0.18.0
             This argument is deprecated. Use the ``alias`` method instead.
 
     Returns
     -------
-    A Series of type `Time`.
+    Expr or Series
+        Column of data type `:class:Time`.
 
-    Examples
+    See Also
     --------
-    Create a Series that starts at 14:00, with intervals of 3 hours and 15 mins:
+    time_ranges : Create a column of time ranges.
 
+    Examples
+    --------
     >>> from datetime import time
     >>> pl.time_range(
     ...     start=time(14, 0),
     ...     interval=timedelta(hours=3, minutes=15),
     ...     eager=True,
     ... )
     shape: (4,)
@@ -664,81 +789,189 @@
     [
         14:00:00
         17:15:00
         20:30:00
         23:45:00
     ]
 
-    Generate a DataFrame with two columns made of eager ``time_range`` Series,
-    and create a third column using ``time_range`` in expression context:
+    """
+    if name is not None:
+        warnings.warn(
+            "the `name` argument is deprecated. Use the `alias` method instead.",
+            DeprecationWarning,
+            stacklevel=find_stacklevel(),
+        )
+
+    interval = _parse_interval_argument(interval)
+    for unit in ("y", "mo", "w", "d"):
+        if unit in interval:
+            raise ValueError(f"invalid interval unit for time_range: found {unit!r}")
+
+    if start is None:
+        start = time(0, 0, 0)
+    if end is None:
+        end = time(23, 59, 59, 999999)
+
+    start_pyexpr = parse_as_expression(start)
+    end_pyexpr = parse_as_expression(end)
+
+    result = wrap_expr(plr.time_range(start_pyexpr, end_pyexpr, interval, closed))
+
+    if name is not None:
+        result = result.alias(name)
+
+    if eager:
+        s = F.select(result).to_series()
+        if s.len() == 1:
+            s = s.explode().set_sorted()
+        else:
+            _warn_for_deprecation_time_range()
+        return s
+
+    _warn_for_deprecation_time_range()
+
+    return result
+
+
+@overload
+def time_ranges(
+    start: time | IntoExpr | None = ...,
+    end: time | IntoExpr | None = ...,
+    interval: str | timedelta = ...,
+    *,
+    closed: ClosedInterval = ...,
+    eager: Literal[False] = ...,
+) -> Expr:
+    ...
+
+
+@overload
+def time_ranges(
+    start: time | IntoExpr | None = ...,
+    end: time | IntoExpr | None = ...,
+    interval: str | timedelta = ...,
+    *,
+    closed: ClosedInterval = ...,
+    eager: Literal[True],
+) -> Series:
+    ...
+
+
+@overload
+def time_ranges(
+    start: time | IntoExpr | None = ...,
+    end: time | IntoExpr | None = ...,
+    interval: str | timedelta = ...,
+    *,
+    closed: ClosedInterval = ...,
+    eager: bool,
+) -> Series | Expr:
+    ...
+
+
+def time_ranges(
+    start: time | IntoExpr | None = None,
+    end: time | IntoExpr | None = None,
+    interval: str | timedelta = "1h",
+    *,
+    closed: ClosedInterval = "both",
+    eager: bool = False,
+) -> Series | Expr:
+    """
+    Create a column of time ranges.
+
+    Parameters
+    ----------
+    start
+        Lower bound of the time range.
+        If omitted, defaults to ``time(0, 0, 0, 0)``.
+    end
+        Upper bound of the time range.
+        If omitted, defaults to ``time(23, 59, 59, 999999)``.
+    interval
+        Interval of the range periods, specified as a Python ``timedelta`` object
+        or a Polars duration string like ``1h30m25s``.
+    closed : {'both', 'left', 'right', 'none'}
+        Define which sides of the range are closed (inclusive).
+    eager
+        Evaluate immediately and return a ``Series``.
+        If set to ``False`` (default), return an expression instead.
 
-    >>> lf = pl.LazyFrame(
+    Returns
+    -------
+    Expr or Series
+        Column of data type ``List(Time)``.
+
+    See Also
+    --------
+    time_range : Generate a single time range.
+
+    Examples
+    --------
+    >>> from datetime import time
+    >>> df = pl.DataFrame(
     ...     {
-    ...         "start": pl.time_range(interval="6h", eager=True),
-    ...         "stop": pl.time_range(start=time(2, 59), interval="5h59m", eager=True),
+    ...         "start": [time(9, 0), time(10, 0)],
+    ...         "end": time(11, 0),
     ...     }
-    ... ).with_columns(
-    ...     intervals=pl.time_range("start", "stop", interval="1h29m", eager=False)
     ... )
-    >>> lf.collect()
-    shape: (4, 3)
+    >>> df.with_columns(pl.time_ranges("start", "end"))
+    shape: (2, 3)
     ┌──────────┬──────────┬────────────────────────────────┐
-    │ start    ┆ stop     ┆ intervals                      │
+    │ start    ┆ end      ┆ time_range                     │
     │ ---      ┆ ---      ┆ ---                            │
     │ time     ┆ time     ┆ list[time]                     │
     ╞══════════╪══════════╪════════════════════════════════╡
-    │ 00:00:00 ┆ 02:59:00 ┆ [00:00:00, 01:29:00, 02:58:00] │
-    │ 06:00:00 ┆ 08:58:00 ┆ [06:00:00, 07:29:00, 08:58:00] │
-    │ 12:00:00 ┆ 14:57:00 ┆ [12:00:00, 13:29:00]           │
-    │ 18:00:00 ┆ 20:56:00 ┆ [18:00:00, 19:29:00]           │
+    │ 09:00:00 ┆ 11:00:00 ┆ [09:00:00, 10:00:00, 11:00:00] │
+    │ 10:00:00 ┆ 11:00:00 ┆ [10:00:00, 11:00:00]           │
     └──────────┴──────────┴────────────────────────────────┘
 
     """
-    if name is not None:
-        warnings.warn(
-            "the `name` argument is deprecated. Use the `alias` method instead.",
-            DeprecationWarning,
-            stacklevel=find_stacklevel(),
-        )
-
-    if isinstance(interval, timedelta):
-        interval = _timedelta_to_pl_duration(interval)
-    elif " " in interval:
-        interval = interval.replace(" ", "").lower()
-
+    interval = _parse_interval_argument(interval)
     for unit in ("y", "mo", "w", "d"):
         if unit in interval:
             raise ValueError(f"invalid interval unit for time_range: found {unit!r}")
 
-    default_start = time(0, 0, 0)
-    default_end = time(23, 59, 59, 999999)
-    if (
-        not eager
-        or isinstance(start, (str, pl.Expr))
-        or isinstance(end, (str, pl.Expr))
-    ):
-        start_expr = (
-            F.lit(default_start)._pyexpr
-            if start is None
-            else parse_as_expression(start)
-        )
+    if start is None:
+        start = time(0, 0, 0)
+    if end is None:
+        end = time(23, 59, 59, 999999)
 
-        end_expr = (
-            F.lit(default_end)._pyexpr if end is None else parse_as_expression(end)
-        )
+    start_pyexpr = parse_as_expression(start)
+    end_pyexpr = parse_as_expression(end)
 
-        tm_expr = wrap_expr(plr.time_range_lazy(start_expr, end_expr, interval, closed))
-        if name is not None:
-            tm_expr = tm_expr.alias(name)
-        return tm_expr
-    else:
-        tm_srs = wrap_s(
-            plr.time_range_eager(
-                _time_to_pl_time(default_start if start is None else start),
-                _time_to_pl_time(default_end if end is None else end),
-                interval,
-                closed,
-            )
-        )
-        if name is not None:
-            tm_srs = tm_srs.alias(name)
-        return tm_srs
+    result = wrap_expr(plr.time_ranges(start_pyexpr, end_pyexpr, interval, closed))
+
+    if eager:
+        return F.select(result).to_series()
+
+    return result
+
+
+def _parse_interval_argument(interval: str | timedelta) -> str:
+    """Parse the interval argument as a Polars duration string."""
+    if isinstance(interval, timedelta):
+        return _timedelta_to_pl_duration(interval)
+
+    if " " in interval:
+        interval = interval.replace(" ", "")
+    return interval.lower()
+
+
+def _warn_for_deprecation_date_range() -> None:
+    warnings.warn(
+        "behavior of `date_range` will change in a future version."
+        " The result will be a single range of type Date or Datetime instead of List."
+        " Use the new `date_ranges` function to retain the old functionality and silence this warning.",
+        DeprecationWarning,
+        stacklevel=find_stacklevel(),
+    )
+
+
+def _warn_for_deprecation_time_range() -> None:
+    warnings.warn(
+        "behavior of `time_range` will change in a future version."
+        " The result will be a single range of type Time instead of List."
+        " Use the new `date_ranges` function to retain the old functionality and silence this warning.",
+        DeprecationWarning,
+        stacklevel=find_stacklevel(),
+    )
```

### Comparing `polars_lts_cpu-0.18.8/polars/functions/repeat.py` & `polars_lts_cpu-0.18.9/polars/functions/repeat.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,60 +14,56 @@
     import polars.polars as plr
 
 
 if TYPE_CHECKING:
     from typing import Literal
 
     from polars import Expr, Series
-    from polars.type_aliases import (
-        IntoExpr,
-        PolarsDataType,
-        PolarsExprType,
-    )
+    from polars.type_aliases import IntoExpr, PolarsDataType
 
 
 @overload
 def repeat(
     value: IntoExpr | None,
-    n: int | PolarsExprType,
+    n: int | Expr,
     *,
     dtype: PolarsDataType | None = ...,
     eager: Literal[False] = ...,
     name: str | None = ...,
 ) -> Expr:
     ...
 
 
 @overload
 def repeat(
     value: IntoExpr | None,
-    n: int | PolarsExprType,
+    n: int | Expr,
     *,
     dtype: PolarsDataType | None = ...,
     eager: Literal[True],
     name: str | None = ...,
 ) -> Series:
     ...
 
 
 @overload
 def repeat(
     value: IntoExpr | None,
-    n: int | PolarsExprType,
+    n: int | Expr,
     *,
     dtype: PolarsDataType | None = ...,
     eager: bool,
     name: str | None = ...,
 ) -> Expr | Series:
     ...
 
 
 def repeat(
     value: IntoExpr | None,
-    n: int | PolarsExprType,
+    n: int | Expr,
     *,
     dtype: PolarsDataType | None = None,
     eager: bool = False,
     name: str | None = None,
 ) -> Expr | Series:
     """
     Construct a column of length `n` filled with the given value.
@@ -141,44 +137,44 @@
     if eager:
         return F.select(expr).to_series()
     return expr
 
 
 @overload
 def ones(
-    n: int | PolarsExprType,
+    n: int | Expr,
     dtype: PolarsDataType = ...,
     *,
     eager: Literal[False] = ...,
 ) -> Expr:
     ...
 
 
 @overload
 def ones(
-    n: int | PolarsExprType,
+    n: int | Expr,
     dtype: PolarsDataType = ...,
     *,
     eager: Literal[True],
 ) -> Series:
     ...
 
 
 @overload
 def ones(
-    n: int | PolarsExprType,
+    n: int | Expr,
     dtype: PolarsDataType = ...,
     *,
     eager: bool,
 ) -> Expr | Series:
     ...
 
 
 def ones(
-    n: int | PolarsExprType,
+    n: int | Expr,
     dtype: PolarsDataType = Float64,
     *,
     eager: bool = False,
 ) -> Expr | Series:
     """
     Construct a column of length `n` filled with ones.
 
@@ -217,44 +213,44 @@
 
     """
     return repeat(1.0, n=n, dtype=dtype, eager=eager).alias("ones")
 
 
 @overload
 def zeros(
-    n: int | PolarsExprType,
+    n: int | Expr,
     dtype: PolarsDataType = ...,
     *,
     eager: Literal[False] = ...,
 ) -> Expr:
     ...
 
 
 @overload
 def zeros(
-    n: int | PolarsExprType,
+    n: int | Expr,
     dtype: PolarsDataType = ...,
     *,
     eager: Literal[True],
 ) -> Series:
     ...
 
 
 @overload
 def zeros(
-    n: int | PolarsExprType,
+    n: int | Expr,
     dtype: PolarsDataType = ...,
     *,
     eager: bool,
 ) -> Expr | Series:
     ...
 
 
 def zeros(
-    n: int | PolarsExprType,
+    n: int | Expr,
     dtype: PolarsDataType = Float64,
     *,
     eager: bool = False,
 ) -> Expr | Series:
     """
     Construct a column of length `n` filled with zeros.
```

### Comparing `polars_lts_cpu-0.18.8/polars/io/__init__.py` & `polars_lts_cpu-0.18.9/polars/io/__init__.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/io/_utils.py` & `polars_lts_cpu-0.18.9/polars/io/_utils.py`

 * *Files 9% similar despite different names*

```diff
@@ -84,25 +84,25 @@
     @contextmanager
     def managed_file(file: Any) -> Iterator[Any]:
         try:
             yield file
         finally:
             pass
 
-    has_non_utf8_non_utf8_lossy_encoding = (
-        encoding not in {"utf8", "utf8-lossy"} if encoding else False
+    has_utf8_utf8_lossy_encoding = (
+        encoding in {"utf8", "utf8-lossy"} if encoding else True
     )
     encoding_str = encoding if encoding else "utf8"
 
     # PyArrow allows directories, so we only check that something is not
     # a dir if we are not using PyArrow
     check_not_dir = not use_pyarrow
 
     if isinstance(file, bytes):
-        if has_non_utf8_non_utf8_lossy_encoding:
+        if not has_utf8_utf8_lossy_encoding:
             return _check_empty(
                 BytesIO(file.decode(encoding_str).encode("utf8")),
                 context="bytes",
             )
         if use_pyarrow:
             return _check_empty(BytesIO(file), context="bytes")
 
@@ -110,30 +110,30 @@
         return _check_empty(
             BytesIO(file.read().encode("utf8")),
             context="StringIO",
             read_position=file.tell(),
         )
 
     if isinstance(file, BytesIO):
-        if has_non_utf8_non_utf8_lossy_encoding:
+        if not has_utf8_utf8_lossy_encoding:
             return _check_empty(
                 BytesIO(file.read().decode(encoding_str).encode("utf8")),
                 context="BytesIO",
                 read_position=file.tell(),
             )
         return managed_file(
             _check_empty(
                 b=file,
                 context="BytesIO",
                 read_position=file.tell(),
             )
         )
 
     if isinstance(file, Path):
-        if has_non_utf8_non_utf8_lossy_encoding:
+        if not has_utf8_utf8_lossy_encoding:
             return _check_empty(
                 BytesIO(file.read_bytes().decode(encoding_str).encode("utf8")),
                 context=f"Path ({file!r})",
             )
         return managed_file(normalise_filepath(file, check_not_dir))
 
     if isinstance(file, str):
@@ -141,35 +141,51 @@
         # as fsspec needs requests to be installed
         # to read from http
         if file.startswith("http"):
             return _process_http_file(file, encoding_str)
         if _FSSPEC_AVAILABLE:
             from fsspec.utils import infer_storage_options
 
-            if not has_non_utf8_non_utf8_lossy_encoding:
-                if infer_storage_options(file)["protocol"] == "file":
+            # check if it is a local file
+            if infer_storage_options(file)["protocol"] == "file":
+                # (lossy) utf8
+                if has_utf8_utf8_lossy_encoding:
                     return managed_file(normalise_filepath(file, check_not_dir))
+                # decode first
+                with Path(file).open(encoding=encoding_str) as f:
+                    return _check_empty(
+                        BytesIO(f.read().encode("utf8")), context=f"{file!r}"
+                    )
+            # non-local file
+            if "*" in file:
+                raise ValueError(
+                    "globbing patterns not supported when scanning non-local files"
+                )
             kwargs["encoding"] = encoding
             return fsspec.open(file, **kwargs)
 
+        # todo! add azure/ gcp/ ?
+        if file.startswith("s3://"):
+            raise ImportError("fsspec needs to be installed to read files from s3")
+
     if isinstance(file, list) and bool(file) and all(isinstance(f, str) for f in file):
         if _FSSPEC_AVAILABLE:
             from fsspec.utils import infer_storage_options
 
-            if not has_non_utf8_non_utf8_lossy_encoding:
+            if has_utf8_utf8_lossy_encoding:
                 if all(infer_storage_options(f)["protocol"] == "file" for f in file):
                     return managed_file(
                         [normalise_filepath(f, check_not_dir) for f in file]
                     )
             kwargs["encoding"] = encoding
             return fsspec.open_files(file, **kwargs)
 
     if isinstance(file, str):
         file = normalise_filepath(file, check_not_dir)
-        if has_non_utf8_non_utf8_lossy_encoding:
+        if not has_utf8_utf8_lossy_encoding:
             with Path(file).open(encoding=encoding_str) as f:
                 return _check_empty(
                     BytesIO(f.read().encode("utf8")), context=f"{file!r}"
                 )
 
     return managed_file(file)
```

### Comparing `polars_lts_cpu-0.18.8/polars/io/avro.py` & `polars_lts_cpu-0.18.9/polars/io/avro.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/io/csv/_utils.py` & `polars_lts_cpu-0.18.9/polars/io/csv/_utils.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/io/csv/batched_reader.py` & `polars_lts_cpu-0.18.9/polars/io/csv/batched_reader.py`

 * *Files 2% similar despite different names*

```diff
@@ -124,15 +124,15 @@
         ...     separator="|",
         ...     try_parse_dates=True,
         ... )  # doctest: +SKIP
         >>> reader.next_batches(5)  # doctest: +SKIP
 
         Returns
         -------
-        Sequence of DataFrames
+        list of DataFrames
 
         """
         batches = self._reader.next_batches(n)
         if batches is not None:
             if self.new_columns:
                 return [
                     _update_columns(wrap_df(df), self.new_columns) for df in batches
```

### Comparing `polars_lts_cpu-0.18.8/polars/io/csv/functions.py` & `polars_lts_cpu-0.18.9/polars/io/csv/functions.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/io/database.py` & `polars_lts_cpu-0.18.9/polars/io/database.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,38 +2,40 @@
 
 import re
 import sys
 from importlib import import_module
 from typing import TYPE_CHECKING, Any
 
 from polars.convert import from_arrow
+from polars.utils.decorators import deprecated_alias
 
 if TYPE_CHECKING:
     from polars import DataFrame
     from polars.type_aliases import DbReadEngine
 
 
+@deprecated_alias(connection_uri="connection")
 def read_database(
     query: list[str] | str,
-    connection_uri: str,
+    connection: str,
     *,
     partition_on: str | None = None,
     partition_range: tuple[int, int] | None = None,
     partition_num: int | None = None,
     protocol: str | None = None,
     engine: DbReadEngine = "connectorx",
 ) -> DataFrame:
     """
     Read a SQL query into a DataFrame.
 
     Parameters
     ----------
     query
         Raw SQL query (or queries).
-    connection_uri
+    connection
         A connectorx or ADBC connection URI that starts with the backend's
         driver name, for example:
 
         * "postgresql://user:pass@server:port/database"
         * "snowflake://user:pass@account/database/schema?warehouse=warehouse&role=role"
     partition_on
         The column on which to partition the result (connectorx).
@@ -108,24 +110,24 @@
     ...     engine="adbc",
     ... )  # doctest: +SKIP
 
     """  # noqa: W505
     if engine == "connectorx":
         return _read_sql_connectorx(
             query,
-            connection_uri,
+            connection,
             partition_on=partition_on,
             partition_range=partition_range,
             partition_num=partition_num,
             protocol=protocol,
         )
     elif engine == "adbc":
         if not isinstance(query, str):
             raise ValueError("Only a single SQL query string is accepted for adbc.")
-        return _read_sql_adbc(query, connection_uri)
+        return _read_sql_adbc(query, connection)
     else:
         raise ValueError(f"Engine {engine!r} not implemented; use connectorx or adbc.")
 
 
 def _read_sql_connectorx(
     query: str | list[str],
     connection_uri: str,
@@ -150,28 +152,27 @@
         partition_num=partition_num,
         protocol=protocol,
     )
     return from_arrow(tbl)  # type: ignore[return-value]
 
 
 def _read_sql_adbc(query: str, connection_uri: str) -> DataFrame:
-    with _open_adbc_connection(connection_uri) as conn:
-        cursor = conn.cursor()
+    with _open_adbc_connection(connection_uri) as conn, conn.cursor() as cursor:
         cursor.execute(query)
         tbl = cursor.fetch_arrow_table()
-        cursor.close()
     return from_arrow(tbl)  # type: ignore[return-value]
 
 
 def _open_adbc_connection(connection_uri: str) -> Any:
     driver_name = connection_uri.split(":", 1)[0].lower()
 
-    # note: existing URI driver prefixes currently map 1:1 with
-    # the adbc module suffix; update this map if that changes.
-    module_suffix_map: dict[str, str] = {}
+    # map uri prefix to module when not 1:1
+    module_suffix_map: dict[str, str] = {
+        "postgres": "postgresql",
+    }
     try:
         module_suffix = module_suffix_map.get(driver_name, driver_name)
         module_name = f"adbc_driver_{module_suffix}.dbapi"
         import_module(module_name)
         adbc_driver = sys.modules[module_name]
     except ImportError:
         raise ImportError(
```

### Comparing `polars_lts_cpu-0.18.8/polars/io/delta.py` & `polars_lts_cpu-0.18.9/polars/io/delta.py`

 * *Files 1% similar despite different names*

```diff
@@ -281,25 +281,21 @@
 def _get_delta_lake_table(
     table_path: str,
     version: int | None = None,
     storage_options: dict[str, Any] | None = None,
     delta_table_options: dict[str, Any] | None = None,
 ) -> deltalake.DeltaTable:
     """
-    Initialise a Delta lake table for use in read and scan operations.
+    Initialize a Delta lake table for use in read and scan operations.
 
     Notes
     -----
     Make sure to install deltalake>=0.8.0. Read the documentation
     `here <https://delta-io.github.io/delta-rs/python/installation.html>`_.
 
-    Returns
-    -------
-    DeltaTable
-
     """
     _check_if_delta_available()
 
     if delta_table_options is None:
         delta_table_options = {}
 
     dl_tbl = deltalake.DeltaTable(
```

### Comparing `polars_lts_cpu-0.18.8/polars/io/excel/_write_utils.py` & `polars_lts_cpu-0.18.9/polars/io/excel/_write_utils.py`

 * *Files 2% similar despite different names*

```diff
@@ -108,27 +108,27 @@
     format_cache: _XLFormatCache,
 ) -> None:
     """Take all conditional formatting options and apply them to the table/range."""
     from xlsxwriter.format import Format
 
     for cols, formats in conditional_formats.items():
         if not isinstance(cols, str) and len(cols) == 1:
-            cols = list(cols)[0]
+            cols = next(iter(cols))
         if isinstance(formats, (str, dict)):
             formats = [formats]
 
         for fmt in formats:
             if not isinstance(fmt, dict):
                 fmt = {"type": fmt}
             if isinstance(cols, str):
                 col_range = _xl_column_range(df, table_start, cols, has_header)
             else:
                 col_range = _xl_column_multi_range(df, table_start, cols, has_header)
                 if " " in col_range:
-                    col = list(cols)[0]
+                    col = next(iter(cols))
                     fmt["multi_range"] = col_range
                     col_range = _xl_column_range(df, table_start, col, has_header)
 
             if "format" in fmt:
                 f = fmt["format"]
                 fmt["format"] = (
                     f  # already registered
```

### Comparing `polars_lts_cpu-0.18.8/polars/io/excel/functions.py` & `polars_lts_cpu-0.18.9/polars/io/excel/functions.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/io/ipc/anonymous_scan.py` & `polars_lts_cpu-0.18.9/polars/io/ipc/anonymous_scan.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/io/ipc/functions.py` & `polars_lts_cpu-0.18.9/polars/io/ipc/functions.py`

 * *Files 1% similar despite different names*

```diff
@@ -117,15 +117,16 @@
     Parameters
     ----------
     source
         Path to a file or a file-like object.
 
     Returns
     -------
-    Dictionary mapping column names to datatypes
+    dict
+        Dictionary mapping column names to datatypes
 
     """
     if isinstance(source, (str, Path)):
         source = normalise_filepath(source)
 
     return _read_ipc_schema(source)
```

### Comparing `polars_lts_cpu-0.18.8/polars/io/json.py` & `polars_lts_cpu-0.18.9/polars/io/json.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/io/ndjson.py` & `polars_lts_cpu-0.18.9/polars/io/ndjson.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/io/parquet/anonymous_scan.py` & `polars_lts_cpu-0.18.9/polars/io/parquet/anonymous_scan.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/io/parquet/functions.py` & `polars_lts_cpu-0.18.9/polars/io/parquet/functions.py`

 * *Files 0% similar despite different names*

```diff
@@ -142,15 +142,16 @@
     Parameters
     ----------
     source
         Path to a file or a file-like object.
 
     Returns
     -------
-    Dictionary mapping column names to datatypes
+    dict
+        Dictionary mapping column names to datatypes
 
     """
     if isinstance(source, (str, Path)):
         source = normalise_filepath(source)
 
     return _read_parquet_schema(source)
```

### Comparing `polars_lts_cpu-0.18.8/polars/io/pyarrow_dataset/anonymous_scan.py` & `polars_lts_cpu-0.18.9/polars/io/pyarrow_dataset/anonymous_scan.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/io/pyarrow_dataset/functions.py` & `polars_lts_cpu-0.18.9/polars/io/pyarrow_dataset/functions.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/lazyframe/frame.py` & `polars_lts_cpu-0.18.9/polars/lazyframe/frame.py`

 * *Files 1% similar despite different names*

```diff
@@ -51,14 +51,15 @@
 from polars.slice import LazyPolarsSlice
 from polars.utils._parse_expr_input import (
     parse_as_expression,
     parse_as_list_of_expressions,
 )
 from polars.utils._wrap import wrap_df, wrap_expr
 from polars.utils.convert import _timedelta_to_pl_duration
+from polars.utils.decorators import deprecated_alias
 from polars.utils.various import (
     _in_notebook,
     _prepare_row_count_args,
     _process_null_values,
     find_stacklevel,
     normalise_filepath,
 )
@@ -820,24 +821,26 @@
         │ 3   ┆ 1   │
         │ 4   ┆ 2   │
         └─────┴─────┘
 
         """
         return function(self, *args, **kwargs)
 
+    @deprecated_alias(common_subplan_elimination="comm_subplan_elim")
     def explain(
         self,
         *,
         optimized: bool = True,
         type_coercion: bool = True,
         predicate_pushdown: bool = True,
         projection_pushdown: bool = True,
         simplify_expression: bool = True,
         slice_pushdown: bool = True,
-        common_subplan_elimination: bool = True,
+        comm_subplan_elim: bool = True,
+        comm_subexpr_elim: bool = True,
         streaming: bool = False,
     ) -> str:
         """
         Create a string representation of the query plan.
 
         Different optimizations can be turned on or off.
 
@@ -854,16 +857,18 @@
             Do predicate pushdown optimization.
         projection_pushdown
             Do projection pushdown optimization.
         simplify_expression
             Run simplify expressions optimization.
         slice_pushdown
             Slice pushdown optimization.
-        common_subplan_elimination
+        comm_subplan_elim
             Will try to cache branching subplans that occur on self-joins or unions.
+        comm_subexpr_elim
+            Common subexpressions will be cached and reused.
         streaming
             Run parts of the query in a streaming fashion (this is in an alpha state)
 
         Examples
         --------
         >>> lf = pl.LazyFrame(
         ...     {
@@ -879,34 +884,37 @@
         if optimized:
             ldf = self._ldf.optimization_toggle(
                 type_coercion,
                 predicate_pushdown,
                 projection_pushdown,
                 simplify_expression,
                 slice_pushdown,
-                common_subplan_elimination,
+                comm_subplan_elim,
+                comm_subexpr_elim,
                 streaming,
             )
             return ldf.describe_optimized_plan()
         return self._ldf.describe_plan()
 
+    @deprecated_alias(common_subplan_elimination="comm_subplan_elim")
     def show_graph(
         self,
         *,
         optimized: bool = True,
         show: bool = True,
         output_path: str | Path | None = None,
         raw_output: bool = False,
         figsize: tuple[float, float] = (16.0, 12.0),
         type_coercion: bool = True,
         predicate_pushdown: bool = True,
         projection_pushdown: bool = True,
         simplify_expression: bool = True,
         slice_pushdown: bool = True,
-        common_subplan_elimination: bool = True,
+        comm_subplan_elim: bool = True,
+        comm_subexpr_elim: bool = True,
         streaming: bool = False,
     ) -> str | None:
         """
         Show a plot of the query plan. Note that you should have graphviz installed.
 
         Parameters
         ----------
@@ -926,16 +934,18 @@
             Do predicate pushdown optimization.
         projection_pushdown
             Do projection pushdown optimization.
         simplify_expression
             Run simplify expressions optimization.
         slice_pushdown
             Slice pushdown optimization.
-        common_subplan_elimination
+        comm_subplan_elim
             Will try to cache branching subplans that occur on self-joins or unions.
+        comm_subexpr_elim
+            Common subexpressions will be cached and reused.
         streaming
             Run parts of the query in a streaming fashion (this is in an alpha state)
 
         Examples
         --------
         >>> lf = pl.LazyFrame(
         ...     {
@@ -951,15 +961,16 @@
         """
         _ldf = self._ldf.optimization_toggle(
             type_coercion,
             predicate_pushdown,
             projection_pushdown,
             simplify_expression,
             slice_pushdown,
-            common_subplan_elimination,
+            comm_subplan_elim,
+            comm_subexpr_elim,
             streaming,
         )
 
         dot = _ldf.to_dot(optimized)
 
         if raw_output:
             # we do not show a graph, nor save a graph to disk
@@ -1299,24 +1310,26 @@
         by = parse_as_list_of_expressions(by)
         if isinstance(descending, bool):
             descending = [descending]
         return self._from_pyldf(
             self._ldf.bottom_k(k, by, descending, nulls_last, maintain_order)
         )
 
+    @deprecated_alias(common_subplan_elimination="comm_subplan_elim")
     def profile(
         self,
         *,
         type_coercion: bool = True,
         predicate_pushdown: bool = True,
         projection_pushdown: bool = True,
         simplify_expression: bool = True,
         no_optimization: bool = False,
         slice_pushdown: bool = True,
-        common_subplan_elimination: bool = True,
+        comm_subplan_elim: bool = True,
+        comm_subexpr_elim: bool = True,
         show_plot: bool = False,
         truncate_nodes: int = 0,
         figsize: tuple[int, int] = (18, 8),
         streaming: bool = False,
     ) -> tuple[DataFrame, DataFrame]:
         """
         Profile a LazyFrame.
@@ -1337,16 +1350,18 @@
             Do projection pushdown optimization.
         simplify_expression
             Run simplify expressions optimization.
         no_optimization
             Turn off (certain) optimizations.
         slice_pushdown
             Slice pushdown optimization.
-        common_subplan_elimination
+        comm_subplan_elim
             Will try to cache branching subplans that occur on self-joins or unions.
+        comm_subexpr_elim
+            Common subexpressions will be cached and reused.
         show_plot
             Show a gantt chart of the profiling result
         truncate_nodes
             Truncate the label lengths in the gantt chart to this number of
             characters.
         figsize
             matplotlib figsize of the profiling plot
@@ -1393,15 +1408,16 @@
 
         ldf = self._ldf.optimization_toggle(
             type_coercion,
             predicate_pushdown,
             projection_pushdown,
             simplify_expression,
             slice_pushdown,
-            common_subplan_elimination,
+            comm_subplan_elim,
+            comm_subexpr_elim,
             streaming,
         )
         df, timings = ldf.profile()
         (df, timings) = wrap_df(df), wrap_df(timings)
 
         if show_plot:
             try:
@@ -1442,24 +1458,26 @@
             except ImportError:
                 raise ImportError(
                     "matplotlib should be installed to show profiling plot."
                 ) from None
 
         return df, timings
 
+    @deprecated_alias(common_subplan_elimination="comm_subplan_elim")
     def collect(
         self,
         *,
         type_coercion: bool = True,
         predicate_pushdown: bool = True,
         projection_pushdown: bool = True,
         simplify_expression: bool = True,
         no_optimization: bool = False,
         slice_pushdown: bool = True,
-        common_subplan_elimination: bool = True,
+        comm_subplan_elim: bool = True,
+        comm_subexpr_elim: bool = True,
         streaming: bool = False,
     ) -> DataFrame:
         """
         Collect into a DataFrame.
 
         Note: use :func:`fetch` if you want to run your query on the first `n` rows
         only. This can be a huge time saver in debugging queries.
@@ -1474,16 +1492,18 @@
             Do projection pushdown optimization.
         simplify_expression
             Run simplify expressions optimization.
         no_optimization
             Turn off (certain) optimizations.
         slice_pushdown
             Slice pushdown optimization.
-        common_subplan_elimination
+        comm_subplan_elim
             Will try to cache branching subplans that occur on self-joins or unions.
+        comm_subexpr_elim
+            Common subexpressions will be cached and reused.
         streaming
             Run parts of the query in a streaming fashion (this is in an alpha state)
 
         Returns
         -------
         DataFrame
 
@@ -1509,26 +1529,28 @@
         └─────┴─────┴─────┘
 
         """
         if no_optimization:
             predicate_pushdown = False
             projection_pushdown = False
             slice_pushdown = False
-            common_subplan_elimination = False
+            comm_subplan_elim = False
+            comm_subexpr_elim = False
 
         if streaming:
-            common_subplan_elimination = False
+            comm_subplan_elim = False
 
         ldf = self._ldf.optimization_toggle(
             type_coercion,
             predicate_pushdown,
             projection_pushdown,
             simplify_expression,
             slice_pushdown,
-            common_subplan_elimination,
+            comm_subplan_elim,
+            comm_subexpr_elim,
             streaming,
         )
         return wrap_df(ldf.collect())
 
     def sink_parquet(
         self,
         path: str | Path,
@@ -1612,15 +1634,16 @@
 
         lf = self._ldf.optimization_toggle(
             type_coercion,
             predicate_pushdown,
             projection_pushdown,
             simplify_expression,
             slice_pushdown,
-            cse=False,
+            comm_subplan_elim=False,
+            comm_subexpr_elim=False,
             streaming=True,
         )
         return lf.sink_parquet(
             path=path,
             compression=compression,
             compression_level=compression_level,
             statistics=statistics,
@@ -1687,34 +1710,37 @@
 
         lf = self._ldf.optimization_toggle(
             type_coercion,
             predicate_pushdown,
             projection_pushdown,
             simplify_expression,
             slice_pushdown,
-            cse=False,
+            comm_subplan_elim=False,
+            comm_subexpr_elim=False,
             streaming=True,
         )
         return lf.sink_ipc(
             path=path,
             compression=compression,
             maintain_order=maintain_order,
         )
 
+    @deprecated_alias(common_subplan_elimination="comm_subplan_elim")
     def fetch(
         self,
         n_rows: int = 500,
         *,
         type_coercion: bool = True,
         predicate_pushdown: bool = True,
         projection_pushdown: bool = True,
         simplify_expression: bool = True,
         no_optimization: bool = False,
         slice_pushdown: bool = True,
-        common_subplan_elimination: bool = True,
+        comm_subplan_elim: bool = True,
+        comm_subexpr_elim: bool = True,
         streaming: bool = False,
     ) -> DataFrame:
         """
         Collect a small number of rows for debugging purposes.
 
         Fetch is like a :func:`collect` operation, but it overwrites the number of rows
         read by every scan operation. This is a utility that helps debug a query on a
@@ -1736,16 +1762,18 @@
             Run projection pushdown optimization.
         simplify_expression
             Run simplify expressions optimization.
         no_optimization
             Turn off optimizations.
         slice_pushdown
             Slice pushdown optimization
-        common_subplan_elimination
+        comm_subplan_elim
             Will try to cache branching subplans that occur on self-joins or unions.
+        comm_subexpr_elim
+            Common subexpressions will be cached and reused.
         streaming
             Run parts of the query in a streaming fashion (this is in an alpha state)
 
         Returns
         -------
         DataFrame
 
@@ -1770,23 +1798,25 @@
         └─────┴─────┴─────┘
 
         """
         if no_optimization:
             predicate_pushdown = False
             projection_pushdown = False
             slice_pushdown = False
-            common_subplan_elimination = False
+            comm_subplan_elim = False
+            comm_subexpr_elim = False
 
         lf = self._ldf.optimization_toggle(
             type_coercion,
             predicate_pushdown,
             projection_pushdown,
             simplify_expression,
             slice_pushdown,
-            common_subplan_elimination,
+            comm_subplan_elim,
+            comm_subexpr_elim,
             streaming,
         )
         return wrap_df(lf.fetch(n_rows))
 
     def lazy(self) -> Self:
         """
         Return lazy representation, i.e. itself.
@@ -3053,15 +3083,16 @@
             non-expression inputs are parsed as literals.
         **named_exprs
             Additional columns to add, specified as keyword arguments.
             The columns will be renamed to the keyword used.
 
         Returns
         -------
-        A new LazyFrame with the columns added.
+        LazyFrame
+            A new LazyFrame with the columns added.
 
         Notes
         -----
         Creating a new LazyFrame using this method does not create a new copy of
         existing data.
 
         Examples
@@ -4327,15 +4358,16 @@
             Keep the same order as the original DataFrame. This is more expensive to
             compute.
             Settings this to ``True`` blocks the possibility
             to run on the streaming engine.
 
         Returns
         -------
-        DataFrame with unique rows.
+        LazyFrame
+            LazyFrame with unique rows.
 
         Warnings
         --------
         This method will fail if there is a column of type `List` in the DataFrame or
         subset.
 
         Examples
```

### Comparing `polars_lts_cpu-0.18.8/polars/lazyframe/groupby.py` & `polars_lts_cpu-0.18.9/polars/lazyframe/groupby.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/selectors.py` & `polars_lts_cpu-0.18.9/polars/selectors.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/series/_numpy.py` & `polars_lts_cpu-0.18.9/polars/series/_numpy.py`

 * *Files 1% similar despite different names*

```diff
@@ -42,12 +42,13 @@
         Length of the array values.
     ptr_type
         Example:
             f32: ctypes.c_float)
 
     Returns
     -------
-    View of memory block as numpy array.
+    numpy.ndarray
+        View of memory block as numpy array.
 
     """
     ptr_ctype = ctypes.cast(ptr, ctypes.POINTER(ptr_type))
     return np.ctypeslib.as_array(ptr_ctype, (len,))
```

### Comparing `polars_lts_cpu-0.18.8/polars/series/array.py` & `polars_lts_cpu-0.18.9/polars/series/array.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/series/binary.py` & `polars_lts_cpu-0.18.9/polars/series/binary.py`

 * *Files 16% similar despite different names*

```diff
@@ -26,15 +26,16 @@
         Parameters
         ----------
         literal
             The binary substring to look for
 
         Returns
         -------
-        Boolean mask
+        Series
+            Series of data type :class:`Boolean`.
 
         """
 
     def ends_with(self, suffix: bytes) -> Series:
         """
         Check if string values end with a binary substring.
 
@@ -77,10 +78,11 @@
         Parameters
         ----------
         encoding : {'hex', 'base64'}
             The encoding to use.
 
         Returns
         -------
-        Binary array with values encoded using provided encoding
+        Series
+            Series of data type :class:`Boolean`.
 
         """
```

### Comparing `polars_lts_cpu-0.18.8/polars/series/categorical.py` & `polars_lts_cpu-0.18.9/polars/series/categorical.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/series/datetime.py` & `polars_lts_cpu-0.18.9/polars/series/datetime.py`

 * *Files 3% similar despite different names*

```diff
@@ -217,15 +217,16 @@
 
         Applies to Date and Datetime columns.
 
         Returns the year number in the calendar date.
 
         Returns
         -------
-        Year part as Int32
+        Series
+            Series of data type :class:`Int32`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> start = datetime(2001, 1, 1)
         >>> stop = datetime(2002, 1, 1)
         >>> date = pl.date_range(start, stop, interval="1y", eager=True)
@@ -250,15 +251,16 @@
         """
         Determine whether the year of the underlying date representation is a leap year.
 
         Applies to Date and Datetime columns.
 
         Returns
         -------
-        Leap year info as Boolean
+        Series
+            Series of data type :class:`Boolean`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> start = datetime(2000, 1, 1)
         >>> stop = datetime(2002, 1, 1)
         >>> date = pl.date_range(start, stop, interval="1y", eager=True)
@@ -288,15 +290,16 @@
         Applies to Date and Datetime columns.
 
         Returns the year number according to the ISO standard.
         This may not correspond with the calendar year.
 
         Returns
         -------
-        ISO year as Int32
+        Series
+            Series of data type :class:`Int32`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> dt = datetime(2022, 1, 1, 7, 8, 40)
         >>> pl.Series([dt]).dt.iso_year()
         shape: (1,)
@@ -313,15 +316,16 @@
 
         Applies to Date and Datetime columns.
 
         Returns the quarter ranging from 1 to 4.
 
         Returns
         -------
-        Quarter as UInt32
+        Series
+            Series of data type :class:`UInt32`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> start = datetime(2001, 1, 1)
         >>> stop = datetime(2001, 4, 1)
         >>> date = pl.date_range(start, stop, interval="1mo", eager=True)
@@ -353,15 +357,16 @@
         Applies to Date and Datetime columns.
 
         Returns the month number starting from 1.
         The return value ranges from 1 to 12.
 
         Returns
         -------
-        Month part as UInt32
+        Series
+            Series of data type :class:`UInt32`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> start = datetime(2001, 1, 1)
         >>> stop = datetime(2001, 4, 1)
         >>> date = pl.date_range(start, stop, interval="1mo", eager=True)
@@ -393,15 +398,16 @@
         Applies to Date and Datetime columns.
 
         Returns the ISO week number starting from 1.
         The return value ranges from 1 to 53. (The last week of year differs by years.)
 
         Returns
         -------
-        Week number as UInt32
+        Series
+            Series of data type :class:`UInt32`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> start = datetime(2001, 1, 1)
         >>> stop = datetime(2001, 4, 1)
         >>> date = pl.date_range(start, stop, interval="1mo", eager=True)
@@ -432,15 +438,16 @@
 
         Applies to Date and Datetime columns.
 
         Returns the ISO weekday number where monday = 1 and sunday = 7
 
         Returns
         -------
-        Weekday as UInt32
+        Series
+            Series of data type :class:`UInt32`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> start = datetime(2001, 1, 1)
         >>> stop = datetime(2001, 1, 7)
         >>> date = pl.date_range(start, stop, interval="1d", eager=True)
@@ -478,15 +485,16 @@
         Applies to Date and Datetime columns.
 
         Returns the day of month starting from 1.
         The return value ranges from 1 to 31. (The last day of month differs by months.)
 
         Returns
         -------
-        Day part as UInt32
+        Series
+            Series of data type :class:`UInt32`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> start = datetime(2001, 1, 1)
         >>> stop = datetime(2001, 1, 9)
         >>> date = pl.date_range(start, stop, interval="2d", eager=True)
@@ -520,15 +528,16 @@
         Applies to Date and Datetime columns.
 
         Returns the day of year starting from 1.
         The return value ranges from 1 to 366. (The last day of year differs by years.)
 
         Returns
         -------
-        Ordinal day as UInt32
+        Series
+            Series of data type :class:`UInt32`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> start = datetime(2001, 1, 1)
         >>> stop = datetime(2001, 3, 1)
         >>> date = pl.date_range(start, stop, interval="1mo", eager=True)
@@ -555,15 +564,16 @@
         """
         Extract (local) time.
 
         Applies to Date/Datetime/Time columns.
 
         Returns
         -------
-        Time Series
+        Series
+            Series of data type :class:`Time`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> ser = pl.Series([datetime(2021, 1, 2, 5)]).dt.replace_time_zone(
         ...     "Asia/Kathmandu"
         ... )
@@ -585,15 +595,16 @@
         """
         Extract (local) date.
 
         Applies to Date/Datetime columns.
 
         Returns
         -------
-        Date Series
+        Series
+            Series of data type :class:`Date`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> ser = pl.Series([datetime(2021, 1, 2, 5)]).dt.replace_time_zone(
         ...     "Asia/Kathmandu"
         ... )
@@ -615,15 +626,16 @@
         """
         Extract (local) datetime.
 
         Applies to Datetime columns.
 
         Returns
         -------
-        Datetime Series
+        Series
+            Series of data type :class:`Datetime`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> ser = pl.Series([datetime(2021, 1, 2, 5)]).dt.replace_time_zone(
         ...     "Asia/Kathmandu"
         ... )
@@ -647,15 +659,16 @@
 
         Applies to Datetime columns.
 
         Returns the hour number from 0 to 23.
 
         Returns
         -------
-        Hour part as UInt32
+        Series
+            Series of data type :class:`UInt32`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> start = datetime(2001, 1, 1)
         >>> stop = datetime(2001, 1, 1, 3)
         >>> date = pl.date_range(start, stop, interval="1h", eager=True)
@@ -686,15 +699,16 @@
 
         Applies to Datetime columns.
 
         Returns the minute number from 0 to 59.
 
         Returns
         -------
-        Minute part as UInt32
+        Series
+            Series of data type :class:`UInt32`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> start = datetime(2001, 1, 1)
         >>> stop = datetime(2001, 1, 1, 0, 4, 0)
         >>> date = pl.date_range(start, stop, interval="2m", eager=True)
@@ -730,15 +744,16 @@
         Parameters
         ----------
         fractional
             Whether to include the fractional component of the second.
 
         Returns
         -------
-        Second part as UInt32 (or Float64)
+        Series
+            Series of data type :class:`UInt32` or :class:`Float64`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> start = datetime(2001, 1, 1)
         >>> stop = datetime(2001, 1, 1, 0, 0, 4)
         >>> date = pl.date_range(start, stop, interval="500ms", eager=True)
@@ -791,15 +806,16 @@
         """
         Extract the milliseconds from the underlying DateTime representation.
 
         Applies to Datetime columns.
 
         Returns
         -------
-        Millisecond part as UInt32
+        Series
+            Series of data type :class:`UInt32`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> start = datetime(2001, 1, 1)
         >>> stop = datetime(2001, 1, 1, 0, 0, 4)
         >>> date = pl.date_range(start, stop, interval="500ms", eager=True)
@@ -838,15 +854,16 @@
         """
         Extract the microseconds from the underlying DateTime representation.
 
         Applies to Datetime columns.
 
         Returns
         -------
-        Microsecond part as UInt32
+        Series
+            Series of data type :class:`UInt32`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> start = datetime(2001, 1, 1)
         >>> stop = datetime(2001, 1, 1, 0, 0, 4)
         >>> date = pl.date_range(start, stop, interval="500ms", eager=True)
@@ -885,15 +902,16 @@
         """
         Extract the nanoseconds from the underlying DateTime representation.
 
         Applies to Datetime columns.
 
         Returns
         -------
-        Nanosecond part as UInt32
+        Series
+            Series of data type :class:`UInt32`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> start = datetime(2001, 1, 1)
         >>> stop = datetime(2001, 1, 1, 0, 0, 4)
         >>> date = pl.date_range(start, stop, interval="500ms", eager=True)
@@ -1224,15 +1242,16 @@
 
     def days(self) -> Series:
         """
         Extract the days from a Duration type.
 
         Returns
         -------
-        A series of dtype Int64
+        Series
+            Series of data type :class:`Int64`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> date = pl.date_range(
         ...     datetime(2020, 3, 1), datetime(2020, 5, 1), "1mo", eager=True
         ... )
@@ -1257,15 +1276,16 @@
 
     def hours(self) -> Series:
         """
         Extract the hours from a Duration type.
 
         Returns
         -------
-        A series of dtype Int64
+        Series
+            Series of data type :class:`Int64`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> date = pl.date_range(
         ...     datetime(2020, 1, 1), datetime(2020, 1, 4), "1d", eager=True
         ... )
@@ -1292,15 +1312,16 @@
 
     def minutes(self) -> Series:
         """
         Extract the minutes from a Duration type.
 
         Returns
         -------
-        A series of dtype Int64
+        Series
+            Series of data type :class:`Int64`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> date = pl.date_range(
         ...     datetime(2020, 1, 1), datetime(2020, 1, 4), "1d", eager=True
         ... )
@@ -1327,15 +1348,16 @@
 
     def seconds(self) -> Series:
         """
         Extract the seconds from a Duration type.
 
         Returns
         -------
-        A series of dtype Int64
+        Series
+            Series of data type :class:`Int64`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> date = pl.date_range(
         ...     datetime(2020, 1, 1), datetime(2020, 1, 1, 0, 4, 0), "1m", eager=True
         ... )
@@ -1364,15 +1386,16 @@
 
     def milliseconds(self) -> Series:
         """
         Extract the milliseconds from a Duration type.
 
         Returns
         -------
-        A series of dtype Int64
+        Series
+            Series of data type :class:`Int64`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> date = pl.date_range(
         ...     datetime(2020, 1, 1),
         ...     datetime(2020, 1, 1, 0, 0, 1, 0),
@@ -1400,15 +1423,16 @@
 
     def microseconds(self) -> Series:
         """
         Extract the microseconds from a Duration type.
 
         Returns
         -------
-        A series of dtype Int64
+        Series
+            Series of data type :class:`Int64`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> date = pl.date_range(
         ...     datetime(2020, 1, 1),
         ...     datetime(2020, 1, 1, 0, 0, 1, 0),
@@ -1436,15 +1460,16 @@
 
     def nanoseconds(self) -> Series:
         """
         Extract the nanoseconds from a Duration type.
 
         Returns
         -------
-        A series of dtype Int64
+        Series
+            Series of data type :class:`Int64`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> date = pl.date_range(
         ...     datetime(2020, 1, 1),
         ...     datetime(2020, 1, 1, 0, 0, 1, 0),
@@ -1503,15 +1528,16 @@
             By "calendar day", we mean the corresponding time on the next day
             (which may not be 24 hours, due to daylight savings). Similarly for
             "calendar week", "calendar month", "calendar quarter", and
             "calendar year".
 
         Returns
         -------
-        Date/Datetime expression
+        Series
+            Series of data type :class:`Date` or :class:`Datetime`.
 
         Examples
         --------
         >>> from datetime import datetime
         >>> dates = pl.date_range(
         ...     datetime(2000, 1, 1), datetime(2005, 1, 1), "1y", eager=True
         ... )
@@ -1616,15 +1642,16 @@
 
         By "calendar day", we mean the corresponding time on the next day (which may
         not be 24 hours, due to daylight savings). Similarly for "calendar week",
         "calendar month", "calendar quarter", and "calendar year".
 
         Returns
         -------
-        Date/Datetime series
+        Series
+            Series of data type :class:`Date` or :class:`Datetime`.
 
         Examples
         --------
         >>> from datetime import timedelta, datetime
         >>> start = datetime(2001, 1, 1)
         >>> stop = datetime(2001, 1, 2)
         >>> s = pl.date_range(start, stop, timedelta(minutes=165), eager=True)
@@ -1774,15 +1801,16 @@
         every
             Every interval start and period length
         offset
             Offset the window
 
         Returns
         -------
-        Date/Datetime series
+        Series
+            Series of data type :class:`Date` or :class:`Datetime`.
 
         Warnings
         --------
         This functionality is currently experimental and may
         change without it being considered a breaking change.
 
         Examples
@@ -1873,15 +1901,16 @@
 
     def month_start(self) -> Series:
         """
         Roll backward to the first day of the month.
 
         Returns
         -------
-        Date/Datetime series
+        Series
+            Series of data type :class:`Date` or :class:`Datetime`.
 
         Notes
         -----
         If you're coming from pandas, you can think of this as a vectorised version
         of ``pandas.tseries.offsets.MonthBegin().rollback(datetime)``.
 
         Examples
@@ -1903,15 +1932,16 @@
 
     def month_end(self) -> Series:
         """
         Roll forward to the last day of the month.
 
         Returns
         -------
-        Date/Datetime series.
+        Series
+            Series of data type :class:`Date` or :class:`Datetime`.
 
         Notes
         -----
         If you're coming from pandas, you can think of this as a vectorised version
         of ``pandas.tseries.offsets.MonthEnd().rollforward(datetime)``.
 
         Examples
@@ -1937,15 +1967,16 @@
 
         This is usually constant for all datetimes in a given time zone, but
         may vary in the rare case that a country switches time zone, like
         Samoa (Apia) did at the end of 2011.
 
         Returns
         -------
-        Duration Series
+        Series
+            Series of data type :class:`Duration`.
 
         See Also
         --------
         Series.dt.dst_offset : Additional offset currently in effect.
 
         Examples
         --------
@@ -1975,15 +2006,16 @@
 
     def dst_offset(self) -> Series:
         """
         Additional offset currently in effect (typically due to daylight saving time).
 
         Returns
         -------
-        Duration Series
+        Series
+            Series of data type :class:`Duration`.
 
         See Also
         --------
         Series.dt.base_utc_offset : Base offset from UTC.
 
         Examples
         --------
```

### Comparing `polars_lts_cpu-0.18.8/polars/series/list.py` & `polars_lts_cpu-0.18.9/polars/series/list.py`

 * *Files 2% similar despite different names*

```diff
@@ -207,15 +207,16 @@
         Parameters
         ----------
         separator
             string to separate the items with
 
         Returns
         -------
-        Series of dtype Utf8
+        Series
+            Series of data type :class:`Utf8`.
 
         Examples
         --------
         >>> s = pl.Series([["foo", "bar"], ["hello", "world"]])
         >>> s.list.join(separator="-")
         shape: (2,)
         Series: '' [str]
@@ -239,35 +240,40 @@
         Parameters
         ----------
         item
             Item that will be checked for membership
 
         Returns
         -------
-        Boolean mask
+        Series
+            Series of data type :class:`Boolean`.
 
         """
 
     def arg_min(self) -> Series:
         """
         Retrieve the index of the minimal value in every sublist.
 
         Returns
         -------
-        Series of dtype UInt32/UInt64 (depending on compilation)
+        Series
+            Series of data type :class:`UInt32` or :class:`UInt64`
+            (depending on compilation).
 
         """
 
     def arg_max(self) -> Series:
         """
         Retrieve the index of the maximum value in every sublist.
 
         Returns
         -------
-        Series of dtype UInt32/UInt64 (depending on compilation)
+        Series
+            Series of data type :class:`UInt32` or :class:`UInt64`
+            (depending on compilation).
 
         """
 
     def diff(self, n: int = 1, null_behavior: NullBehavior = "ignore") -> Series:
         """
         Calculate the n-th discrete difference of every sublist.
 
@@ -400,15 +406,16 @@
 
     def explode(self) -> Series:
         """
         Returns a column with a separate row for every list element.
 
         Returns
         -------
-        Exploded column with the datatype of the list elements.
+        Series
+            Series with the data type of the list elements.
 
         See Also
         --------
         Series.reshape : Reshape this Series to a flat Series or a Series of Lists.
 
         Examples
         --------
```

### Comparing `polars_lts_cpu-0.18.8/polars/series/series.py` & `polars_lts_cpu-0.18.9/polars/series/series.py`

 * *Files 2% similar despite different names*

```diff
@@ -371,15 +371,16 @@
     @property
     def flags(self) -> dict[str, bool]:
         """
         Get flags that are set on the Series.
 
         Returns
         -------
-        Dictionary containing the flag name and the value
+        dict
+            Dictionary containing the flag name and the value
 
         """
         out = {
             "SORTED_ASC": self._s.is_sorted_ascending_flag(),
             "SORTED_DESC": self._s.is_sorted_descending_flag(),
         }
         if self.dtype == List:
@@ -1214,26 +1215,28 @@
 
     def any(self, drop_nulls: bool = True) -> bool | None:
         """
         Check if any boolean value in the column is `True`.
 
         Returns
         -------
-        Boolean literal
+        Series
+            Series of data type :class:`Boolean`.
 
         """
         return self.to_frame().select(F.col(self.name).any(drop_nulls)).to_series()[0]
 
     def all(self, drop_nulls: bool = True) -> bool | None:
         """
         Check if all boolean values in the column are `True`.
 
         Returns
         -------
-        Boolean literal
+        Series
+            Series of data type :class:`Boolean`.
 
         """
         return self.to_frame().select(F.col(self.name).all(drop_nulls)).to_series()[0]
 
     def log(self, base: float = math.e) -> Series:
         """Compute the logarithm to a given base."""
 
@@ -1310,15 +1313,16 @@
         ----------
         percentiles
             One or more percentiles to include in the summary statistics (if the
             series has a numeric dtype). All values must be in the range `[0, 1]`.
 
         Returns
         -------
-        Dictionary with summary statistics of a Series.
+        DataFrame
+            Mapping with summary statistics of a Series.
 
         Examples
         --------
         >>> series_num = pl.Series([1, 2, 3, 4, 5])
         >>> series_num.describe()
         shape: (9, 2)
         ┌────────────┬──────────┐
@@ -1644,15 +1648,15 @@
             len(breaks) + 1.
         break_point_label
             Name given to the breakpoint column/field. Only used if series == False or
             include_breaks == True
         category_label
             Name given to the category column. Only used if series == False
         series
-            If True, return the a categorical series in the data's original order.
+            If True, return a categorical Series in the data's original order.
         left_closed
             Whether intervals should be [) instead of (]
         include_breaks
             Include the the right endpoint of the bin each observation falls in.
             If returning a DataFrame, it will be a column, and if returning a Series
             it will be a field in a Struct
 
@@ -1762,15 +1766,15 @@
             len(breaks) + 1.
         break_point_label
             Name given to the breakpoint column/field. Only used if series == False or
             include_breaks == True
         category_label
             Name given to the category column. Only used if series == False.
         series
-            If True, return a categorical series in the data's original order
+            If True, return a categorical Series in the data's original order
         left_closed
             Whether intervals should be [) instead of (]
         allow_duplicates
             If True, the resulting quantile breaks don't have to be unique. This can
             happen even with unique probs depending on the data. Duplicates will be
             dropped, resulting in fewer bins.
         include_breaks
@@ -1872,15 +1876,16 @@
 
     def rle(self) -> Series:
         """
         Get the lengths of runs of identical values.
 
         Returns
         -------
-            A Struct Series containing "lengths" and "values" Fields
+        Series
+            Series of data type :class:`Struct` with Fields "lengths" and "values".
 
         Examples
         --------
         >>> s = pl.Series("s", [1, 1, 2, 1, None, 1, 3, 3])
         >>> s.rle().struct.unnest()
         shape: (6, 2)
         ┌─────────┬────────┐
@@ -1904,16 +1909,19 @@
 
         Similar to RLE, but it maps each value to an ID corresponding to the run into
         which it falls. This is especially useful when you want to define groups by
         runs of identical values rather than the values themselves.
 
         Returns
         -------
-            Series
+        Series
 
+        See Also
+        --------
+        rle
 
         Examples
         --------
         >>> s = pl.Series("s", [1, 1, 2, 1, None, 1, 3, 3])
         >>> s.rle_id()
         shape: (8,)
         Series: 's' [u32]
@@ -2785,15 +2793,15 @@
 
     def arg_min(self) -> int | None:
         """
         Get the index of the minimal value.
 
         Returns
         -------
-        Integer
+        int
 
         Examples
         --------
         >>> s = pl.Series("a", [3, 2, 1])
         >>> s.arg_min()
         2
 
@@ -2802,15 +2810,15 @@
 
     def arg_max(self) -> int | None:
         """
         Get the index of the maximal value.
 
         Returns
         -------
-        Integer
+        int
 
         Examples
         --------
         >>> s = pl.Series("a", [3, 2, 1])
         >>> s.arg_max()
         0
 
@@ -2943,15 +2951,16 @@
 
     def is_null(self) -> Series:
         """
         Returns a boolean Series indicating which values are null.
 
         Returns
         -------
-        Boolean Series
+        Series
+            Series of data type :class:`Boolean`.
 
         Examples
         --------
         >>> s = pl.Series("a", [1.0, 2.0, 3.0, None])
         >>> s.is_null()
         shape: (4,)
         Series: 'a' [bool]
@@ -2966,15 +2975,16 @@
 
     def is_not_null(self) -> Series:
         """
         Returns a boolean Series indicating which values are not null.
 
         Returns
         -------
-        Boolean Series
+        Series
+            Series of data type :class:`Boolean`.
 
         Examples
         --------
         >>> s = pl.Series("a", [1.0, 2.0, 3.0, None])
         >>> s.is_not_null()
         shape: (4,)
         Series: 'a' [bool]
@@ -2989,15 +2999,16 @@
 
     def is_finite(self) -> Series:
         """
         Returns a boolean Series indicating which values are finite.
 
         Returns
         -------
-        Boolean Series
+        Series
+            Series of data type :class:`Boolean`.
 
         Examples
         --------
         >>> import numpy as np
         >>> s = pl.Series("a", [1.0, 2.0, np.inf])
         >>> s.is_finite()
         shape: (3,)
@@ -3012,15 +3023,16 @@
 
     def is_infinite(self) -> Series:
         """
         Returns a boolean Series indicating which values are infinite.
 
         Returns
         -------
-        Boolean Series
+        Series
+            Series of data type :class:`Boolean`.
 
         Examples
         --------
         >>> import numpy as np
         >>> s = pl.Series("a", [1.0, 2.0, np.inf])
         >>> s.is_infinite()
         shape: (3,)
@@ -3035,15 +3047,16 @@
 
     def is_nan(self) -> Series:
         """
         Returns a boolean Series indicating which values are not NaN.
 
         Returns
         -------
-        Boolean Series
+        Series
+            Series of data type :class:`Boolean`.
 
         Examples
         --------
         >>> import numpy as np
         >>> s = pl.Series("a", [1.0, 2.0, 3.0, np.NaN])
         >>> s.is_nan()
         shape: (4,)
@@ -3059,15 +3072,16 @@
 
     def is_not_nan(self) -> Series:
         """
         Returns a boolean Series indicating which values are not NaN.
 
         Returns
         -------
-        Boolean Series
+        Series
+            Series of data type :class:`Boolean`.
 
         Examples
         --------
         >>> import numpy as np
         >>> s = pl.Series("a", [1.0, 2.0, 3.0, np.NaN])
         >>> s.is_not_nan()
         shape: (4,)
@@ -3083,15 +3097,16 @@
 
     def is_in(self, other: Series | Collection[Any]) -> Series:
         """
         Check if elements of this Series are in the other Series.
 
         Returns
         -------
-        Boolean Series
+        Series
+            Series of data type :class:`Boolean`.
 
         Examples
         --------
         >>> s = pl.Series("a", [1, 2, 3])
         >>> s2 = pl.Series("b", [2, 4])
         >>> s2.is_in(s)
         shape: (2,)
@@ -3133,15 +3148,16 @@
 
     def arg_true(self) -> Series:
         """
         Get index values where Boolean Series evaluate True.
 
         Returns
         -------
-        UInt32 Series
+        Series
+            Series of data type :class:`UInt32`.
 
         Examples
         --------
         >>> s = pl.Series("a", [1, 2, 3])
         >>> (s == 2).arg_true()
         shape: (1,)
         Series: 'a' [u32]
@@ -3154,15 +3170,16 @@
 
     def is_unique(self) -> Series:
         """
         Get mask of all unique values.
 
         Returns
         -------
-        Boolean Series
+        Series
+            Series of data type :class:`Boolean`.
 
         Examples
         --------
         >>> s = pl.Series("a", [1, 2, 2, 3])
         >>> s.is_unique()
         shape: (4,)
         Series: 'a' [bool]
@@ -3177,25 +3194,27 @@
 
     def is_first(self) -> Series:
         """
         Get a mask of the first unique value.
 
         Returns
         -------
-        Boolean Series
+        Series
+            Series of data type :class:`Boolean`.
 
         """
 
     def is_duplicated(self) -> Series:
         """
         Get mask of all duplicated values.
 
         Returns
         -------
-        Boolean Series
+        Series
+            Series of data type :class:`Boolean`.
 
         Examples
         --------
         >>> s = pl.Series("a", [1, 2, 2, 3])
         >>> s.is_duplicated()
         shape: (4,)
         Series: 'a' [bool]
@@ -3212,15 +3231,16 @@
         """
         Explode a list Series.
 
         This means that every item is expanded to a new row.
 
         Returns
         -------
-        Exploded Series of same dtype
+        Series
+            Series with the data type of the list elements.
 
         See Also
         --------
         Series.list.explode : Explode a list column.
         Series.str.explode : Explode a string column.
 
         """
@@ -3611,17 +3631,26 @@
         self,
         *args: Any,
         zero_copy_only: bool = False,
         writable: bool = False,
         use_pyarrow: bool = True,
     ) -> np.ndarray[Any, Any]:
         """
-        Convert this Series to numpy. This operation clones data but is completely safe.
+        Convert this Series to numpy.
 
-        If you want a zero-copy view and know what you are doing, use `.view()`.
+        This operation may clone data but is completely safe. Note that:
+
+        - data which is purely numeric AND without null values is not cloned;
+        - floating point ``nan`` values can be zero-copied;
+        - booleans can't be zero-copied.
+
+        To ensure that no data is cloned, set ``zero_copy_only=True``.
+
+        Alternatively, if you want a zero-copy view and know what you are doing,
+        use `.view()`.
 
         Parameters
         ----------
         *args
             args will be sent to pyarrow.Array.to_numpy.
         zero_copy_only
             If True, an exception will be raised if the conversion to a numpy
@@ -3920,15 +3949,16 @@
         idx
             Integers representing the index locations.
         value
             replacement values.
 
         Returns
         -------
-        the series mutated
+        Series
+            The mutated series.
 
         Notes
         -----
         Use of this function is frequently an anti-pattern, as it can
         block optimisation (predicate pushdown, etc). Consider using
         `pl.when(predicate).then(value).otherwise(self)` instead.
 
@@ -4528,38 +4558,36 @@
         If your function is expensive and you don't want it to be called more than
         once for a given input, consider applying an ``@lru_cache`` decorator to it.
         With suitable data you may achieve order-of-magnitude speedups (or more).
 
         Examples
         --------
         >>> s = pl.Series("a", [1, 2, 3])
-        >>> s.apply(lambda x: x + 10)
+        >>> s.apply(lambda x: x + 10)  # doctest: +SKIP
         shape: (3,)
         Series: 'a' [i64]
         [
                 11
                 12
                 13
         ]
 
         Returns
         -------
         Series
 
         """
-        # TODO:
-        # from polars.utils.udfs import warn_on_inefficient_apply
-        # warn_on_inefficient_apply(
-        #     function, columns=[self.name], apply_target="series"
-        # )
+        from polars.utils.udfs import warn_on_inefficient_apply
 
         if return_dtype is None:
             pl_return_dtype = None
         else:
             pl_return_dtype = py_type_to_dtype(return_dtype)
+
+        warn_on_inefficient_apply(function, columns=[self.name], apply_target="series")
         return self._from_pyseries(
             self._s.apply_lambda(function, pl_return_dtype, skip_nulls)
         )
 
     def shift(self, periods: int = 1) -> Series:
         """
         Shift the values by a given period.
@@ -4621,15 +4649,15 @@
         mask
             Boolean Series.
         other
             Series of same type.
 
         Returns
         -------
-        New Series
+        Series
 
         Examples
         --------
         >>> s1 = pl.Series([1, 2, 3, 4, 5])
         >>> s2 = pl.Series([5, 4, 3, 2, 1])
         >>> s1.zip_with(s1 < s2, s2)
         shape: (5,)
@@ -5873,17 +5901,18 @@
         dimensions
             Tuple of the dimension sizes. If a -1 is used in any of the dimensions, that
             dimension is inferred.
 
         Returns
         -------
         Series
-            If a single dimension is given, results in a flat Series of shape (len,).
-            If a multiple dimensions are given, results in a Series of Lists with shape
-            (rows, cols).
+            If a single dimension is given, results in a Series of the original
+            data type.
+            If a multiple dimensions are given, results in a Series of data type
+            :class:`List` with shape (rows, cols).
 
         See Also
         --------
         Series.list.explode : Explode a list column.
 
         Examples
         --------
```

### Comparing `polars_lts_cpu-0.18.8/polars/series/string.py` & `polars_lts_cpu-0.18.9/polars/series/string.py`

 * *Files 7% similar despite different names*

```diff
@@ -327,15 +327,16 @@
         Notes
         -----
         The returned lengths are equal to the number of bytes in the UTF8 string. If you
         need the length in terms of the number of characters, use ``n_chars`` instead.
 
         Returns
         -------
-        Series[u32]
+        Series
+            Series of data type :class:`UInt32`.
 
         Examples
         --------
         >>> s = pl.Series(["Café", None, "345", "東京"])
         >>> s.str.lengths()
         shape: (4,)
         Series: '' [u32]
@@ -350,15 +351,16 @@
 
     def n_chars(self) -> Series:
         """
         Get length of the string values in the Series (as number of chars).
 
         Returns
         -------
-        Series[u32]
+        Series
+            Series of data type :class:`UInt32`.
 
         Notes
         -----
         If you know that you are working with ASCII text, ``lengths`` will be
         equivalent, and faster (returns length in terms of the number of bytes).
 
         Examples
@@ -383,15 +385,16 @@
         Parameters
         ----------
         delimiter
             The delimiter to insert between consecutive string values.
 
         Returns
         -------
-        Series of dtype Utf8
+        Series
+            Series of data type :class:`Utf8`.
 
         Examples
         --------
         >>> pl.Series([1, None, 2]).str.concat("-")[0]
         '1-null-2'
 
         """
@@ -432,15 +435,16 @@
 
         See the regex crate's section on `grouping and flags
         <https://docs.rs/regex/latest/regex/#grouping-and-flags>`_ for
         additional information about the use of inline expression modifiers.
 
         Returns
         -------
-        Boolean mask
+        Series
+            Series of data type :class:`Boolean`.
 
         Examples
         --------
         >>> s = pl.Series(["Crab", "cat and dog", "rab$bit", None])
         >>> s.str.contains("cat|bit")
         shape: (4,)
         Series: '' [bool]
@@ -539,15 +543,16 @@
         Parameters
         ----------
         encoding : {'hex', 'base64'}
             The encoding to use.
 
         Returns
         -------
-        Utf8 array with values encoded using provided encoding
+        Series
+            Series of data type :class:`Utf8`.
 
         Examples
         --------
         >>> s = pl.Series(["foo", "bar", None])
         >>> s.str.encode("hex")
         shape: (3,)
         Series: '' [str]
@@ -608,16 +613,17 @@
         Parameters
         ----------
         json_path
             A valid JSON path query string.
 
         Returns
         -------
-        Utf8 array. Contain null if original value is null or the json_path return
-        nothing.
+        Series
+            Series of data type :class:`Utf8`. Contains null values if the original
+            value is null or the json_path returns nothing.
 
         Examples
         --------
         >>> df = pl.DataFrame(
         ...     {"json_val": ['{"a":"1"}', None, '{"a":2}', '{"a":2.1}', '{"a":true}']}
         ... )
         >>> df.select(pl.col("json_val").str.json_path_match("$.a"))[:, 0]
@@ -643,14 +649,20 @@
             A valid regular expression pattern, compatible with the `regex crate
             <https://docs.rs/regex/latest/regex/>`_.
         group_index
             Index of the targeted capture group.
             Group 0 mean the whole pattern, first group begin at index 1
             Default to the first capture group
 
+        Returns
+        -------
+        Series
+            Series of data type :class:`Utf8`. Contains null values if the original
+            value is null or regex captures nothing.
+
         Notes
         -----
         To modify regular expression behaviour (such as multi-line matching)
         with flags, use the inline ``(?iLmsuxU)`` syntax. For example:
 
         >>> s = pl.Series(
         ...     name="lines",
@@ -667,18 +679,14 @@
             "This"
         ]
 
         See the regex crate's section on `grouping and flags
         <https://docs.rs/regex/latest/regex/#grouping-and-flags>`_ for
         additional information about the use of inline expression modifiers.
 
-        Returns
-        -------
-        Utf8 array. Contain null if original value is null or regex capture nothing.
-
         Examples
         --------
         >>> s = pl.Series(
         ...     name="url",
         ...     values=[
         ...         "http://vote.com/ballon_dor?ref=polars&candidate=messi",
         ...         "http://vote.com/ballon_dor?candidate=ronaldo&ref=polars",
@@ -745,15 +753,16 @@
 
         See the regex crate's section on `grouping and flags
         <https://docs.rs/regex/latest/regex/#grouping-and-flags>`_ for
         additional information about the use of inline expression modifiers.
 
         Returns
         -------
-        List[Utf8]
+        Series
+            Series of data type ``List(Utf8)``.
 
         Examples
         --------
         >>> s = pl.Series("foo", ["123 bla 45 asd", "xyz 678 910t"])
         >>> s.str.extract_all(r"\d+")
         shape: (2,)
         Series: 'foo' [list[str]]
@@ -772,15 +781,17 @@
         ----------
         pattern
             A valid regular expression pattern, compatible with the `regex crate
             <https://docs.rs/regex/latest/regex/>`_.
 
         Returns
         -------
-        UInt32 array. Contain null if original value is null or regex capture nothing.
+        Series
+            Series of data type :class:`UInt32`. Contains null values if the original
+            value is null or if the regex captures nothing.
 
         Examples
         --------
         >>> s = pl.Series("foo", ["123 bla 45 asd", "xyz 678 910t"])
         >>> # count digits
         >>> s.str.count_match(r"\d")
         shape: (2,)
@@ -801,15 +812,16 @@
         by
             Substring to split by.
         inclusive
             If True, include the split character/string in the results.
 
         Returns
         -------
-        List of Utf8 type
+        Series
+            Series of data type ``List(Utf8)``.
 
         """
 
     def split_exact(self, by: str, n: int, *, inclusive: bool = False) -> Series:
         """
         Split the string by a substring using ``n`` splits.
 
@@ -860,15 +872,16 @@
         │ null       ┆ null        │
         │ c          ┆ null        │
         │ d          ┆ 4           │
         └────────────┴─────────────┘
 
         Returns
         -------
-        Struct of Utf8 type
+        Series
+            Series of data type :class:`Struct` with fields of data type :class:`Utf8`.
 
         """
 
     def splitn(self, by: str, n: int) -> Series:
         """
         Split the string by a substring, restricted to returning at most ``n`` items.
 
@@ -917,15 +930,16 @@
         │ null       ┆ null        │
         │ foo-bar    ┆ null        │
         │ foo        ┆ bar baz     │
         └────────────┴─────────────┘
 
         Returns
         -------
-        Struct of Utf8 type
+        Series
+            Series of data type :class:`Struct` with fields of data type :class:`Utf8`.
 
         """
         s = wrap_s(self._s)
         return s.to_frame().select(F.col(s.name).str.splitn(by, n)).to_series()
 
     def replace(
         self, pattern: str, value: str, *, literal: bool = False, n: int = 1
@@ -1264,15 +1278,15 @@
         length
             Length of the slice. If set to ``None`` (default), the slice is taken to the
             end of the string.
 
         Returns
         -------
         Series
-            Series of dtype Utf8.
+            Series of data type :class:`Struct` with fields of data type :class:`Utf8`.
 
         Examples
         --------
         >>> s = pl.Series("s", ["pear", None, "papaya", "dragonfruit"])
         >>> s.str.slice(-3)
         shape: (4,)
         Series: 's' [str]
@@ -1299,15 +1313,16 @@
 
     def explode(self) -> Series:
         """
         Returns a column with a separate row for every string character.
 
         Returns
         -------
-        Exploded column with string datatype.
+        Series
+            Series of data type :class:`Utf8`.
 
         Examples
         --------
         >>> s = pl.Series("a", ["foo", "bar"])
         >>> s.str.explode()
         shape: (6,)
         Series: 'a' [str]
@@ -1336,15 +1351,16 @@
 
         strict
             Bool, Default=True will raise any ParseError or overflow as ComputeError.
             False silently convert to Null.
 
         Returns
         -------
-        Series of parsed integers in i32 format
+        Series
+            Series of data type :class:`Int32`.
 
         Examples
         --------
         >>> s = pl.Series("bin", ["110", "101", "010", "invalid"])
         >>> s.str.parse_int(2, strict=False)
         shape: (4,)
         Series: 'bin' [i32]
```

### Comparing `polars_lts_cpu-0.18.8/polars/series/struct.py` & `polars_lts_cpu-0.18.9/polars/series/struct.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/series/utils.py` & `polars_lts_cpu-0.18.9/polars/series/utils.py`

 * *Files 2% similar despite different names*

```diff
@@ -134,28 +134,29 @@
     return cls
 
 
 def get_ffi_func(
     name: str, dtype: PolarsDataType, obj: PySeries
 ) -> Callable[..., Any] | None:
     """
-    Dynamically obtain the proper ffi function/ method.
+    Dynamically obtain the proper FFI function/ method.
 
     Parameters
     ----------
     name
         function or method name where dtype is replaced by <>
         for example
             "call_foo_<>"
     dtype
         polars dtype.
     obj
         Object to find the method for.
 
     Returns
     -------
-    ffi function, or None if not found
+    callable or None
+        FFI function, or None if not found.
 
     """
     ffi_name = dtype_to_ffiname(dtype)
     fname = name.replace("<>", ffi_name)
     return getattr(obj, fname, None)
```

### Comparing `polars_lts_cpu-0.18.8/polars/slice.py` & `polars_lts_cpu-0.18.9/polars/slice.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/sql/context.py` & `polars_lts_cpu-0.18.9/polars/sql/context.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/string_cache.py` & `polars_lts_cpu-0.18.9/polars/string_cache.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/testing/_private.py` & `polars_lts_cpu-0.18.9/polars/testing/_private.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/testing/asserts.py` & `polars_lts_cpu-0.18.9/polars/testing/asserts.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/testing/parametric/__init__.py` & `polars_lts_cpu-0.18.9/polars/testing/parametric/__init__.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/testing/parametric/primitives.py` & `polars_lts_cpu-0.18.9/polars/testing/parametric/primitives.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/testing/parametric/profiles.py` & `polars_lts_cpu-0.18.9/polars/testing/parametric/profiles.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/testing/parametric/strategies.py` & `polars_lts_cpu-0.18.9/polars/testing/parametric/strategies.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/type_aliases.py` & `polars_lts_cpu-0.18.9/polars/type_aliases.py`

 * *Files 2% similar despite different names*

```diff
@@ -21,15 +21,14 @@
     import sys
 
     from polars import DataFrame, Expr, LazyFrame, Series
     from polars.datatypes import DataType, DataTypeClass, IntegralType, TemporalType
     from polars.dependencies import numpy as np
     from polars.dependencies import pandas as pd
     from polars.dependencies import pyarrow as pa
-    from polars.functions.whenthen import WhenThen, WhenThenThen
     from polars.selectors import _selector_proxy_
 
     if sys.version_info >= (3, 10):
         from typing import TypeAlias
     else:
         from typing_extensions import TypeAlias
 
@@ -57,23 +56,20 @@
 SchemaDefinition: TypeAlias = Union[
     Sequence[str],
     Mapping[str, Union[PolarsDataType, PythonDataType]],
     Sequence[Union[str, Tuple[str, Union[PolarsDataType, PythonDataType, None]]]],
 ]
 SchemaDict: TypeAlias = Mapping[str, PolarsDataType]
 
-# Types that qualify as expressions (eg: for use in 'select', 'with_columns'...)
-PolarsExprType: TypeAlias = Union["Expr", "WhenThen", "WhenThenThen"]
-
 # literal types that are allowed in expressions (auto-converted to pl.lit)
 PythonLiteral: TypeAlias = Union[
     str, int, float, bool, date, time, datetime, timedelta, bytes, Decimal, List[Any]
 ]
 
-IntoExpr: TypeAlias = Union[PolarsExprType, PythonLiteral, "Series", None]
+IntoExpr: TypeAlias = Union["Expr", PythonLiteral, "Series", None]
 ComparisonOperator: TypeAlias = Literal["eq", "neq", "gt", "lt", "gt_eq", "lt_eq"]
 
 # selector type
 SelectorType: TypeAlias = "_selector_proxy_"
 
 # User-facing string literal types
 # The following all have an equivalent Rust enum with the same name
```

### Comparing `polars_lts_cpu-0.18.8/polars/utils/__init__.py` & `polars_lts_cpu-0.18.9/polars/utils/__init__.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/utils/_construction.py` & `polars_lts_cpu-0.18.9/polars/utils/_construction.py`

 * *Files 0% similar despite different names*

```diff
@@ -150,16 +150,16 @@
 
 ################################
 # Series constructor interface #
 ################################
 
 
 def series_to_pyseries(name: str, values: Series) -> PySeries:
-    """Construct a PySeries from a Polars Series."""
-    py_s = values._s
+    """Construct a new PySeries from a Polars Series."""
+    py_s = values._s.clone()
     py_s.rename(name)
     return py_s
 
 
 def arrow_to_pyseries(name: str, values: pa.Array, rechunk: bool = True) -> PySeries:
     """Construct a PySeries from an Arrow array."""
     array = coerce_arrow(values)
@@ -1406,15 +1406,15 @@
     """Construct a PyDataFrame from a Polars Series."""
     data_series = [data._s]
     series_name = [s.name() for s in data_series]
     column_names, schema_overrides = _unpack_schema(
         schema or series_name, schema_overrides=schema_overrides, n_expected=1
     )
     if schema_overrides:
-        new_dtype = list(schema_overrides.values())[0]
+        new_dtype = next(iter(schema_overrides.values()))
         if new_dtype != data.dtype:
             data_series[0] = data_series[0].cast(new_dtype, True)
 
     data_series = _handle_columns_arg(data_series, columns=column_names)
     return PyDataFrame(data_series)
```

### Comparing `polars_lts_cpu-0.18.8/polars/utils/_parse_expr_input.py` & `polars_lts_cpu-0.18.9/polars/utils/_parse_expr_input.py`

 * *Files 5% similar despite different names*

```diff
@@ -128,16 +128,14 @@
         or input is None
     ):
         expr = F.lit(input)
         structify = False
     elif isinstance(input, list):
         expr = F.lit(pl.Series("", [input]))
         structify = False
-    elif isinstance(input, (F.whenthen.WhenThen, F.whenthen.WhenThenThen)):
-        expr = input.otherwise(None)  # implicitly add the null branch.
     else:
         raise TypeError(
             f"did not expect value {input!r} of type {type(input)}, maybe disambiguate with"
             " pl.lit or pl.col"
         )
 
     if structify:
```

### Comparing `polars_lts_cpu-0.18.8/polars/utils/_scan.py` & `polars_lts_cpu-0.18.9/polars/utils/_scan.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/utils/_wrap.py` & `polars_lts_cpu-0.18.9/polars/utils/_wrap.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/utils/build_info.py` & `polars_lts_cpu-0.18.9/polars/utils/build_info.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/utils/convert.py` & `polars_lts_cpu-0.18.9/polars/utils/convert.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/utils/decorators.py` & `polars_lts_cpu-0.18.9/polars/utils/decorators.py`

 * *Files 8% similar despite different names*

```diff
@@ -37,14 +37,37 @@
             return function(*args, **kwargs)
 
         return wrapper
 
     return deco
 
 
+def deprecated(reason: str) -> Callable[[Callable[P, T]], Callable[P, T]]:
+    """
+    Decorator which can be used to mark functions as deprecated.
+
+    It will result in a warning being emitted when the function is used.
+
+    """
+
+    def deco(function: Callable[P, T]) -> Callable[P, T]:
+        @wraps(function)
+        def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:
+            warnings.warn(
+                message=f"Call to deprecated function {function.__name__}. ({reason})",
+                category=DeprecationWarning,
+                stacklevel=find_stacklevel(),
+            )
+            return function(*args, **kwargs)
+
+        return wrapper
+
+    return deco
+
+
 def warn_closed_future_change() -> Callable[[Callable[P, T]], Callable[P, T]]:
     """
     Warn that user should pass in 'closed' as default value will change.
 
     Decorator for rolling function. Use as follows:
 
     @warn_closed_future_change()
```

### Comparing `polars_lts_cpu-0.18.8/polars/utils/meta.py` & `polars_lts_cpu-0.18.9/polars/utils/meta.py`

 * *Files 7% similar despite different names*

```diff
@@ -17,15 +17,16 @@
 
 def get_index_type() -> DataTypeClass:
     """
     Get the datatype used for Polars indexing.
 
     Returns
     -------
-    UInt32 in regular Polars, UInt64 in bigidx Polars.
+    DataType
+        :class:`UInt32` in regular Polars, :class:`UInt64` in bigidx Polars.
 
     """
     return _get_index_type()
 
 
 def get_idx_type() -> DataTypeClass:
     """Get the datatype used for Polars indexing."""
```

### Comparing `polars_lts_cpu-0.18.8/polars/utils/polars_version.py` & `polars_lts_cpu-0.18.9/polars/utils/polars_version.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/utils/show_versions.py` & `polars_lts_cpu-0.18.9/polars/utils/show_versions.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/polars/utils/various.py` & `polars_lts_cpu-0.18.9/polars/utils/various.py`

 * *Files 2% similar despite different names*

```diff
@@ -179,18 +179,23 @@
             (getattr(tp, "time_unit", None) == "ns") for tp in unpack_dtypes(*dtypes)
         )
     )
 
 
 def normalise_filepath(path: str | Path, check_not_directory: bool = True) -> str:
     """Create a string path, expanding the home directory if present."""
-    path = Path(path).expanduser()
-    if check_not_directory and path.exists() and path.is_dir():
+    # don't use pathlib here as it modifies slashes (s3:// -> s3:/)
+    path = os.path.expanduser(path)  # noqa: PTH111
+    if (
+        check_not_directory
+        and os.path.exists(path)  # noqa: PTH110
+        and os.path.isdir(path)  # noqa: PTH112
+    ):
         raise IsADirectoryError(f"Expected a file path; {path!r} is a directory")
-    return str(path)
+    return path
 
 
 def parse_version(version: Sequence[str | int]) -> tuple[int, ...]:
     """Simple version parser; split into a tuple of ints for comparison."""
     if isinstance(version, str):
         version = version.split(".")
     return tuple(int(re.sub(r"\D", "", str(v))) for v in version)
@@ -349,59 +354,79 @@
 # None, as otherwise we cannot determine if the caller has explicitly set that value.
 no_default = _NoDefault.no_default
 NoDefault = Literal[_NoDefault.no_default]
 
 
 def find_stacklevel() -> int:
     """
-    Find the first place in the stack that is not inside polars (tests notwithstanding).
+    Find the first place in the stack that is not inside polars.
 
     Taken from:
     https://github.com/pandas-dev/pandas/blob/ab89c53f48df67709a533b6a95ce3d911871a0a8/pandas/util/_exceptions.py#L30-L51
     """
     pkg_dir = Path(pl.__file__).parent
-    test_dir = pkg_dir / "tests"
 
     # https://stackoverflow.com/questions/17407119/python-inspect-stack-is-slow
     frame = inspect.currentframe()
     n = 0
     while frame:
         fname = inspect.getfile(frame)
-        if fname.startswith(str(pkg_dir)) and not fname.startswith(str(test_dir)):
+        if fname.startswith(str(pkg_dir)):
             frame = frame.f_back
             n += 1
         else:
             break
     return n
 
 
 def _get_stack_locals(
-    of_type: type | tuple[type, ...] | None = None, n_objects: int | None = None
+    of_type: type | tuple[type, ...] | None = None,
+    n_objects: int | None = None,
+    n_frames: int | None = None,
+    named: str | tuple[str, ...] | None = None,
 ) -> dict[str, Any]:
     """
-    Retrieve f_locals from all stack frames (starting from the current frame).
+    Retrieve f_locals from all (or the last 'n') stack frames from the calling location.
 
     Parameters
     ----------
     of_type
         Only return objects of this type.
     n_objects
         If specified, return only the most recent ``n`` matching objects.
+    n_frames
+        If specified, look at objects in the last ``n`` stack frames only.
+    named
+        If specified, only return objects matching the given name(s).
 
     """
+    if isinstance(named, str):
+        named = (named,)
+
     objects = {}
+    examined_frames = 0
+    if n_frames is None:
+        n_frames = sys.maxsize
     stack_frame = getattr(inspect.currentframe(), "f_back", None)
-    while stack_frame:
+
+    while stack_frame and examined_frames < n_frames:
         local_items = list(stack_frame.f_locals.items())
         for nm, obj in reversed(local_items):
-            if nm not in objects and (not of_type or isinstance(obj, of_type)):
+            if (
+                nm not in objects
+                and (named is None or (nm in named))
+                and (of_type is None or isinstance(obj, of_type))
+            ):
                 objects[nm] = obj
                 if n_objects is not None and len(objects) >= n_objects:
                     return objects
+
         stack_frame = stack_frame.f_back
+        examined_frames += 1
+
     return objects
 
 
 # this is called from rust
 def _polars_warn(msg: str) -> None:
     warnings.warn(
         msg,
```

### Comparing `polars_lts_cpu-0.18.8/pyproject.toml` & `polars_lts_cpu-0.18.9/pyproject.toml`

 * *Files 2% similar despite different names*

```diff
@@ -158,14 +158,15 @@
 [tool.ruff.flake8-type-checking]
 strict = true
 
 [tool.ruff.per-file-ignores]
 "polars/datatypes.py" = ["B019"]
 "tests/**/*.py" = ["D100", "D103", "B018"]
 "polars/utils/show_versions.py" = ["D301"]
+"polars/utils/udfs.py" = ["RUF012"]
 
 [tool.pytest.ini_options]
 addopts = [
   "--strict-config",
   "--strict-markers",
   "--import-mode=importlib",
   # Default to running fast tests only. To run ALL tests, run: pytest -m ""
```

### Comparing `polars_lts_cpu-0.18.8/scripts/check_stacklevels.py` & `polars_lts_cpu-0.18.9/scripts/check_stacklevels.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/apply/lazy.rs` & `polars_lts_cpu-0.18.9/src/apply/lazy.rs`

 * *Files 0% similar despite different names*

```diff
@@ -133,15 +133,15 @@
 
     let func = python_udf::PythonUdfExpression::new(lambda, output_type);
     pyexpr.inner.clone().map_python(func, agg_list).into()
 }
 
 pub(crate) fn call_lambda_with_series_slice(
     py: Python,
-    s: &mut [Series],
+    s: &[Series],
     lambda: &PyObject,
     polars_module: &PyObject,
 ) -> PyObject {
     let pypolars = polars_module.downcast::<PyModule>(py).unwrap();
 
     // create a PySeries struct/object for Python
     let iter = s.iter().map(|s| {
```

### Comparing `polars_lts_cpu-0.18.8/src/apply/mod.rs` & `polars_lts_cpu-0.18.9/src/apply/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/apply/series.rs` & `polars_lts_cpu-0.18.9/src/apply/series.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/arrow_interop/to_py.rs` & `polars_lts_cpu-0.18.9/src/arrow_interop/to_py.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/arrow_interop/to_rust.rs` & `polars_lts_cpu-0.18.9/src/arrow_interop/to_rust.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/batched_csv.rs` & `polars_lts_cpu-0.18.9/src/batched_csv.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/conversion.rs` & `polars_lts_cpu-0.18.9/src/conversion.rs`

 * *Files 1% similar despite different names*

```diff
@@ -800,17 +800,24 @@
             if sign > 0 {
                 v = -v; // won't overflow since -i128::MAX > i128::MIN
             }
             Ok(Wrap(AnyValue::Decimal(v, scale)))
         }
 
         fn get_object(ob: &PyAny) -> PyResult<Wrap<AnyValue>> {
-            // this is slow, but hey don't use objects
-            let v = &ObjectValue { inner: ob.into() };
-            Ok(Wrap(AnyValue::ObjectOwned(OwnedObject(v.to_boxed()))))
+            #[cfg(feature = "object")]
+            {
+                // this is slow, but hey don't use objects
+                let v = &ObjectValue { inner: ob.into() };
+                Ok(Wrap(AnyValue::ObjectOwned(OwnedObject(v.to_boxed()))))
+            }
+            #[cfg(not(feature = "object"))]
+            {
+                panic!("activate object")
+            }
         }
 
         // TYPE key
         let type_object_ptr = PyType::as_type_ptr(ob.get_type()) as usize;
 
         Python::with_gil(|py| {
             LUT.with_gil(py, |lut| {
@@ -1351,14 +1358,15 @@
                 )))
             }
         };
         Ok(Wrap(parsed))
     }
 }
 
+#[cfg(feature = "ipc")]
 impl FromPyObject<'_> for Wrap<IpcCompression> {
     fn extract(ob: &PyAny) -> PyResult<Self> {
         let parsed = match ob.extract::<&str>()? {
             "zstd" => IpcCompression::ZSTD,
             "lz4" => IpcCompression::LZ4,
             v => {
                 return Err(PyValueError::new_err(format!(
```

### Comparing `polars_lts_cpu-0.18.8/src/dataframe.rs` & `polars_lts_cpu-0.18.9/src/dataframe.rs`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,11 @@
 use std::io::BufWriter;
 use std::ops::Deref;
 
+use either::Either;
 use numpy::IntoPyArray;
 use polars::frame::row::{rows_to_schema_supertypes, Row};
 #[cfg(feature = "avro")]
 use polars::io::avro::AvroCompression;
 #[cfg(feature = "ipc")]
 use polars::io::ipc::IpcCompression;
 use polars::io::mmap::ReaderBytes;
@@ -1352,25 +1353,28 @@
 
     pub fn hash_rows(&mut self, k0: u64, k1: u64, k2: u64, k3: u64) -> PyResult<PySeries> {
         let hb = ahash::RandomState::with_seeds(k0, k1, k2, k3);
         let hash = self.df.hash_rows(Some(hb)).map_err(PyPolarsErr::from)?;
         Ok(hash.into_series().into())
     }
 
-    pub fn transpose(&self, include_header: bool, names: &str) -> PyResult<Self> {
-        let mut df = self.df.transpose().map_err(PyPolarsErr::from)?;
-        if include_header {
-            let s = Utf8Chunked::from_iter_values(
-                names,
-                self.df.get_columns().iter().map(|s| s.name()),
-            )
-            .into_series();
-            df.insert_at_idx(0, s).unwrap();
-        }
-        Ok(df.into())
+    #[pyo3(signature = (keep_names_as, column_names))]
+    pub fn transpose(&self, keep_names_as: Option<&str>, column_names: &PyAny) -> PyResult<Self> {
+        let new_col_names = if let Ok(name) = column_names.extract::<Vec<String>>() {
+            Some(Either::Right(name))
+        } else if let Ok(name) = column_names.extract::<String>() {
+            Some(Either::Left(name))
+        } else {
+            None
+        };
+        Ok(self
+            .df
+            .transpose(keep_names_as, new_col_names)
+            .map_err(PyPolarsErr::from)?
+            .into())
     }
     pub fn upsample(
         &self,
         by: Vec<String>,
         index_column: &str,
         every: &str,
         offset: &str,
```

### Comparing `polars_lts_cpu-0.18.8/src/datatypes.rs` & `polars_lts_cpu-0.18.9/src/datatypes.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/error.rs` & `polars_lts_cpu-0.18.9/src/error.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/expr/array.rs` & `polars_lts_cpu-0.18.9/src/expr/array.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/expr/binary.rs` & `polars_lts_cpu-0.18.9/src/expr/binary.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/expr/datetime.rs` & `polars_lts_cpu-0.18.9/src/expr/datetime.rs`

 * *Files 2% similar despite different names*

```diff
@@ -46,20 +46,14 @@
         self.inner
             .clone()
             .dt()
             .replace_time_zone(time_zone, use_earliest)
             .into()
     }
 
-    #[cfg(feature = "timezones")]
-    #[allow(deprecated)]
-    fn dt_tz_localize(&self, time_zone: String) -> Self {
-        self.inner.clone().dt().tz_localize(time_zone).into()
-    }
-
     fn dt_truncate(&self, every: String, offset: String, use_earliest: Option<bool>) -> Self {
         self.inner
             .clone()
             .dt()
             .truncate(TruncateOptions {
                 every,
                 offset,
```

### Comparing `polars_lts_cpu-0.18.8/src/expr/general.rs` & `polars_lts_cpu-0.18.9/src/expr/general.rs`

 * *Files 0% similar despite different names*

```diff
@@ -489,14 +489,19 @@
 
     #[cfg(feature = "trigonometry")]
     fn arctan(&self) -> Self {
         self.clone().inner.arctan().into()
     }
 
     #[cfg(feature = "trigonometry")]
+    fn arctan2(&self, y: Self) -> Self {
+        self.clone().inner.arctan2(y.inner).into()
+    }
+
+    #[cfg(feature = "trigonometry")]
     fn sinh(&self) -> Self {
         self.clone().inner.sinh().into()
     }
 
     #[cfg(feature = "trigonometry")]
     fn cosh(&self) -> Self {
         self.clone().inner.cosh().into()
@@ -1171,12 +1176,8 @@
         let is_sorted = if descending {
             IsSorted::Descending
         } else {
             IsSorted::Ascending
         };
         self.inner.clone().set_sorted_flag(is_sorted).into()
     }
-
-    fn cache(&self) -> Self {
-        self.inner.clone().cache().into()
-    }
 }
```

### Comparing `polars_lts_cpu-0.18.8/src/expr/list.rs` & `polars_lts_cpu-0.18.9/src/expr/list.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/expr/meta.rs` & `polars_lts_cpu-0.18.9/src/expr/meta.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/expr/mod.rs` & `polars_lts_cpu-0.18.9/src/expr/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/expr/string.rs` & `polars_lts_cpu-0.18.9/src/expr/string.rs`

 * *Files 1% similar despite different names*

```diff
@@ -80,14 +80,15 @@
         self.inner.clone().str().to_uppercase().into()
     }
 
     fn str_to_lowercase(&self) -> Self {
         self.inner.clone().str().to_lowercase().into()
     }
 
+    #[cfg(feature = "nightly")]
     fn str_to_titlecase(&self) -> Self {
         self.inner.clone().str().to_titlecase().into()
     }
 
     fn str_lengths(&self) -> Self {
         self.inner.clone().str().lengths().into()
     }
```

### Comparing `polars_lts_cpu-0.18.8/src/file.rs` & `polars_lts_cpu-0.18.9/src/file.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/functions/aggregation.rs` & `polars_lts_cpu-0.18.9/src/functions/aggregation.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/functions/eager.rs` & `polars_lts_cpu-0.18.9/src/functions/eager.rs`

 * *Files 22% similar despite different names*

```diff
@@ -1,14 +1,13 @@
-use polars::{functions, time};
+use polars::functions;
 use polars_core::prelude::*;
 use pyo3::prelude::*;
 
-use crate::conversion::{get_df, get_series, Wrap};
+use crate::conversion::{get_df, get_series};
 use crate::error::PyPolarsErr;
-use crate::prelude::{ClosedWindow, Duration};
 use crate::{PyDataFrame, PySeries};
 
 #[pyfunction]
 pub fn concat_df(dfs: &PyAny, py: Python) -> PyResult<PyDataFrame> {
     use polars_core::error::PolarsResult;
     use polars_core::utils::rayon::prelude::*;
 
@@ -88,19 +87,7 @@
             get_df(item)
         })
         .collect::<PyResult<Vec<_>>>()?;
 
     let df = functions::hor_concat_df(&dfs).map_err(PyPolarsErr::from)?;
     Ok(df.into())
 }
-
-#[pyfunction]
-pub fn time_range_eager(
-    start: i64,
-    stop: i64,
-    every: &str,
-    closed: Wrap<ClosedWindow>,
-) -> PyResult<PySeries> {
-    let time_range = time::time_range_impl("time", start, stop, Duration::parse(every), closed.0)
-        .map_err(PyPolarsErr::from)?;
-    Ok(time_range.into_series().into())
-}
```

### Comparing `polars_lts_cpu-0.18.8/src/functions/io.rs` & `polars_lts_cpu-0.18.9/src/functions/io.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/functions/lazy.rs` & `polars_lts_cpu-0.18.9/src/functions/lazy.rs`

 * *Files 4% similar despite different names*

```diff
@@ -1,21 +1,18 @@
 use polars::lazy::dsl;
 use polars::lazy::dsl::Expr;
 use polars::prelude::*;
-use polars_core::datatypes::TimeZone;
 use pyo3::exceptions::PyValueError;
 use pyo3::prelude::*;
 use pyo3::types::{PyBool, PyBytes, PyFloat, PyInt, PyString};
 
 use crate::apply::lazy::binary_lambda;
 use crate::conversion::{get_lf, Wrap};
 use crate::expr::ToExprs;
-use crate::prelude::{
-    vec_extract_wrapped, ClosedWindow, DataType, DatetimeArgs, Duration, DurationArgs, ObjectValue,
-};
+use crate::prelude::{vec_extract_wrapped, DataType, DatetimeArgs, DurationArgs, ObjectValue};
 use crate::{apply, PyDataFrame, PyExpr, PyLazyFrame, PyPolarsErr, PySeries};
 
 macro_rules! set_unwrapped_or_0 {
     ($($var:ident),+ $(,)?) => {
         $(let $var = $var.map(|e| e.inner).unwrap_or(dsl::lit(0));)+
     };
 }
@@ -160,14 +157,24 @@
 
 #[pyfunction]
 pub fn cov(a: PyExpr, b: PyExpr) -> PyExpr {
     dsl::cov(a.inner, b.inner).into()
 }
 
 #[pyfunction]
+pub fn arctan2(y: PyExpr, x: PyExpr) -> PyExpr {
+    y.inner.arctan2(x.inner).into()
+}
+
+#[pyfunction]
+pub fn arctan2d(y: PyExpr, x: PyExpr) -> PyExpr {
+    y.inner.arctan2(x.inner).degrees().into()
+}
+
+#[pyfunction]
 pub fn cumfold(acc: PyExpr, lambda: PyObject, exprs: Vec<PyExpr>, include_init: bool) -> PyExpr {
     let exprs = exprs.to_exprs();
 
     let func = move |a: Series, b: Series| binary_lambda(&lambda, a, b);
     dsl::cumfold_exprs(acc.inner, func, exprs, include_init).into()
 }
 
@@ -176,37 +183,14 @@
     let exprs = exprs.to_exprs();
 
     let func = move |a: Series, b: Series| binary_lambda(&lambda, a, b);
     dsl::cumreduce_exprs(func, exprs).into()
 }
 
 #[pyfunction]
-pub fn date_range_lazy(
-    start: PyExpr,
-    end: PyExpr,
-    every: &str,
-    closed: Wrap<ClosedWindow>,
-    time_unit: Option<Wrap<TimeUnit>>,
-    time_zone: Option<TimeZone>,
-) -> PyExpr {
-    let start = start.inner;
-    let end = end.inner;
-    let every = Duration::parse(every);
-    dsl::functions::date_range(
-        start,
-        end,
-        every,
-        closed.0,
-        time_unit.map(|x| x.0),
-        time_zone,
-    )
-    .into()
-}
-
-#[pyfunction]
 pub fn datetime(
     year: PyExpr,
     month: PyExpr,
     day: PyExpr,
     hour: Option<PyExpr>,
     minute: Option<PyExpr>,
     second: Option<PyExpr>,
@@ -423,25 +407,12 @@
     #[cfg(not(feature = "propagate_nans"))]
     {
         panic!("activate 'propagate_nans'")
     }
 }
 
 #[pyfunction]
-pub fn time_range_lazy(
-    start: PyExpr,
-    end: PyExpr,
-    every: &str,
-    closed: Wrap<ClosedWindow>,
-) -> PyExpr {
-    let start = start.inner;
-    let end = end.inner;
-    let every = Duration::parse(every);
-    dsl::functions::time_range(start, end, every, closed.0).into()
-}
-
-#[pyfunction]
 #[cfg(feature = "sql")]
 pub fn sql_expr(sql: &str) -> PyResult<PyExpr> {
     let expr = polars::sql::sql_expr(sql).map_err(PyPolarsErr::from)?;
     Ok(expr.into())
 }
```

### Comparing `polars_lts_cpu-0.18.8/src/functions/meta.rs` & `polars_lts_cpu-0.18.9/src/functions/meta.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/functions/whenthen.rs` & `polars_lts_cpu-0.18.9/src/functions/whenthen.rs`

 * *Files 26% similar despite different names*

```diff
@@ -1,74 +1,79 @@
 use polars::lazy::dsl;
 use pyo3::prelude::*;
 
 use crate::PyExpr;
 
 #[pyfunction]
-pub fn when(predicate: PyExpr) -> When {
-    When { predicate }
+pub fn when(condition: PyExpr) -> PyWhen {
+    PyWhen {
+        inner: dsl::when(condition.inner),
+    }
+}
+
+#[pyclass]
+#[derive(Clone)]
+pub struct PyWhen {
+    inner: dsl::When,
 }
 
 #[pyclass]
 #[derive(Clone)]
-pub struct When {
-    predicate: PyExpr,
+pub struct PyThen {
+    inner: dsl::Then,
 }
 
 #[pyclass]
 #[derive(Clone)]
-pub struct WhenThen {
-    predicate: PyExpr,
-    then: PyExpr,
+pub struct PyChainedWhen {
+    inner: dsl::ChainedWhen,
 }
 
 #[pyclass]
 #[derive(Clone)]
-pub struct WhenThenThen {
-    inner: dsl::WhenThenThen,
+pub struct PyChainedThen {
+    inner: dsl::ChainedThen,
 }
 
 #[pymethods]
-impl When {
-    fn then(&self, expr: PyExpr) -> WhenThen {
-        WhenThen {
-            predicate: self.predicate.clone(),
-            then: expr,
+impl PyWhen {
+    fn then(&self, statement: PyExpr) -> PyThen {
+        PyThen {
+            inner: self.inner.clone().then(statement.inner),
         }
     }
 }
 
 #[pymethods]
-impl WhenThen {
-    fn when(&self, predicate: PyExpr) -> WhenThenThen {
-        let e = dsl::when(self.predicate.inner.clone())
-            .then(self.then.inner.clone())
-            .when(predicate.inner);
-        WhenThenThen { inner: e }
+impl PyThen {
+    fn when(&self, condition: PyExpr) -> PyChainedWhen {
+        PyChainedWhen {
+            inner: self.inner.clone().when(condition.inner),
+        }
     }
 
-    fn otherwise(&self, expr: PyExpr) -> PyExpr {
-        dsl::ternary_expr(
-            self.predicate.inner.clone(),
-            self.then.inner.clone(),
-            expr.inner,
-        )
-        .into()
+    fn otherwise(&self, statement: PyExpr) -> PyExpr {
+        self.inner.clone().otherwise(statement.inner).into()
     }
 }
 
 #[pymethods]
-impl WhenThenThen {
-    fn when(&self, predicate: PyExpr) -> Self {
-        Self {
-            inner: self.inner.clone().when(predicate.inner),
+impl PyChainedWhen {
+    fn then(&self, statement: PyExpr) -> PyChainedThen {
+        PyChainedThen {
+            inner: self.inner.clone().then(statement.inner),
         }
     }
-    fn then(&self, expr: PyExpr) -> Self {
-        Self {
-            inner: self.inner.clone().then(expr.inner),
+}
+
+#[pymethods]
+impl PyChainedThen {
+    fn when(&self, condition: PyExpr) -> PyChainedWhen {
+        PyChainedWhen {
+            inner: self.inner.clone().when(condition.inner),
         }
     }
-    fn otherwise(&self, expr: PyExpr) -> PyExpr {
-        self.inner.clone().otherwise(expr.inner).into()
+
+    fn otherwise(&self, statement: PyExpr) -> PyExpr {
+        self.inner.clone().otherwise(statement.inner).into()
     }
 }
```

### Comparing `polars_lts_cpu-0.18.8/src/gil_once_cell.rs` & `polars_lts_cpu-0.18.9/src/gil_once_cell.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/lazyframe.rs` & `polars_lts_cpu-0.18.9/src/lazyframe.rs`

 * *Files 0% similar despite different names*

```diff
@@ -330,29 +330,31 @@
     fn optimization_toggle(
         &self,
         type_coercion: bool,
         predicate_pushdown: bool,
         projection_pushdown: bool,
         simplify_expr: bool,
         slice_pushdown: bool,
-        cse: bool,
+        comm_subplan_elim: bool,
+        comm_subexpr_elim: bool,
         streaming: bool,
     ) -> Self {
         let ldf = self.ldf.clone();
         let mut ldf = ldf
             .with_type_coercion(type_coercion)
             .with_predicate_pushdown(predicate_pushdown)
             .with_simplify_expr(simplify_expr)
             .with_slice_pushdown(slice_pushdown)
             .with_streaming(streaming)
             .with_projection_pushdown(projection_pushdown);
 
         #[cfg(feature = "cse")]
         {
-            ldf = ldf.with_common_subplan_elimination(cse);
+            ldf = ldf.with_comm_subplan_elim(comm_subplan_elim);
+            ldf = ldf.with_comm_subexpr_elim(comm_subexpr_elim);
         }
 
         ldf.into()
     }
 
     fn sort(
         &self,
```

### Comparing `polars_lts_cpu-0.18.8/src/lazygroupby.rs` & `polars_lts_cpu-0.18.9/src/lazygroupby.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/lib.rs` & `polars_lts_cpu-0.18.9/src/lib.rs`

 * *Files 5% similar despite different names*

```diff
@@ -84,24 +84,30 @@
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::eager::concat_series))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::eager::diag_concat_df))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::eager::hor_concat_df))
         .unwrap();
-    m.add_wrapped(wrap_pyfunction!(functions::eager::time_range_eager))
-        .unwrap();
 
     // Functions - range
     m.add_wrapped(wrap_pyfunction!(functions::range::arange))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::range::int_range))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::range::int_ranges))
         .unwrap();
+    m.add_wrapped(wrap_pyfunction!(functions::range::date_range))
+        .unwrap();
+    m.add_wrapped(wrap_pyfunction!(functions::range::date_ranges))
+        .unwrap();
+    m.add_wrapped(wrap_pyfunction!(functions::range::time_range))
+        .unwrap();
+    m.add_wrapped(wrap_pyfunction!(functions::range::time_ranges))
+        .unwrap();
 
     // Functions - aggregation
     m.add_wrapped(wrap_pyfunction!(functions::aggregation::all_horizontal))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::aggregation::any_horizontal))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::aggregation::max_horizontal))
@@ -136,15 +142,17 @@
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::lazy::cov))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::lazy::cumfold))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::lazy::cumreduce))
         .unwrap();
-    m.add_wrapped(wrap_pyfunction!(functions::lazy::date_range_lazy))
+    m.add_wrapped(wrap_pyfunction!(functions::lazy::arctan2))
+        .unwrap();
+    m.add_wrapped(wrap_pyfunction!(functions::lazy::arctan2d))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::lazy::datetime))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::lazy::diag_concat_lf))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::lazy::concat_expr))
         .unwrap();
@@ -170,16 +178,14 @@
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::lazy::reduce))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::lazy::repeat))
         .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::lazy::spearman_rank_corr))
         .unwrap();
-    m.add_wrapped(wrap_pyfunction!(functions::lazy::time_range_lazy))
-        .unwrap();
     m.add_wrapped(wrap_pyfunction!(functions::whenthen::when))
         .unwrap();
 
     #[cfg(feature = "sql")]
     m.add_wrapped(wrap_pyfunction!(functions::lazy::sql_expr))
         .unwrap();
```

### Comparing `polars_lts_cpu-0.18.8/src/on_startup.rs` & `polars_lts_cpu-0.18.9/src/on_startup.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/series/aggregation.rs` & `polars_lts_cpu-0.18.9/src/series/aggregation.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/series/arithmetic.rs` & `polars_lts_cpu-0.18.9/src/series/arithmetic.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/series/comparison.rs` & `polars_lts_cpu-0.18.9/src/series/comparison.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/series/construction.rs` & `polars_lts_cpu-0.18.9/src/series/construction.rs`

 * *Files 3% similar despite different names*

```diff
@@ -227,27 +227,33 @@
     fn new_array(
         width: usize,
         inner: Option<Wrap<DataType>>,
         name: &str,
         val: Vec<Wrap<AnyValue>>,
         _strict: bool,
     ) -> PyResult<Self> {
-        let val = vec_extract_wrapped(val);
-        let out = Series::new(name, &val);
-        match out.dtype() {
-            DataType::List(list_inner) => {
-                let out = out
-                    .cast(&DataType::Array(
-                        Box::new(inner.map(|dt| dt.0).unwrap_or(*list_inner.clone())),
-                        width,
-                    ))
-                    .map_err(PyPolarsErr::from)?;
-                Ok(out.into())
+        if val.is_empty() {
+            let series =
+                Series::new_empty(name, &DataType::Array(Box::new(inner.unwrap().0), width));
+            Ok(series.into())
+        } else {
+            let val = vec_extract_wrapped(val);
+            let series = Series::new(name, &val);
+            match series.dtype() {
+                DataType::List(list_inner) => {
+                    let series = series
+                        .cast(&DataType::Array(
+                            Box::new(inner.map(|dt| dt.0).unwrap_or(*list_inner.clone())),
+                            width,
+                        ))
+                        .map_err(PyPolarsErr::from)?;
+                    Ok(series.into())
+                }
+                _ => Err(PyValueError::new_err("could not create Array from input")),
             }
-            _ => Err(PyValueError::new_err("could not create Array from input")),
         }
     }
 
     #[staticmethod]
     fn new_decimal(name: &str, val: Vec<Wrap<AnyValue<'_>>>, strict: bool) -> PyResult<PySeries> {
         // TODO: do we have to respect 'strict' here? it's possible if we want to
         let avs = slice_extract_wrapped(&val);
```

### Comparing `polars_lts_cpu-0.18.8/src/series/export.rs` & `polars_lts_cpu-0.18.9/src/series/export.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/series/mod.rs` & `polars_lts_cpu-0.18.9/src/series/mod.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/series/numpy_ufunc.rs` & `polars_lts_cpu-0.18.9/src/series/numpy_ufunc.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/series/set_at_idx.rs` & `polars_lts_cpu-0.18.9/src/series/set_at_idx.rs`

 * *Files 23% similar despite different names*

```diff
@@ -43,60 +43,60 @@
     s = s.to_physical_repr().into_owned();
     let mutable_s = s._get_inner_mut();
 
     let s = match logical_dtype.to_physical() {
         DataType::Int8 => {
             let ca: &mut ChunkedArray<Int8Type> = mutable_s.as_mut();
             let values = values.i8()?;
-            std::mem::take(ca).set_at_idx2(idx, values.into_iter())
+            std::mem::take(ca).set_at_idx2(idx, values)
         }
         DataType::Int16 => {
             let ca: &mut ChunkedArray<Int16Type> = mutable_s.as_mut();
             let values = values.i16()?;
-            std::mem::take(ca).set_at_idx2(idx, values.into_iter())
+            std::mem::take(ca).set_at_idx2(idx, values)
         }
         DataType::Int32 => {
             let ca: &mut ChunkedArray<Int32Type> = mutable_s.as_mut();
             let values = values.i32()?;
-            std::mem::take(ca).set_at_idx2(idx, values.into_iter())
+            std::mem::take(ca).set_at_idx2(idx, values)
         }
         DataType::Int64 => {
             let ca: &mut ChunkedArray<Int64Type> = mutable_s.as_mut();
             let values = values.i64()?;
-            std::mem::take(ca).set_at_idx2(idx, values.into_iter())
+            std::mem::take(ca).set_at_idx2(idx, values)
         }
         DataType::UInt8 => {
             let ca: &mut ChunkedArray<UInt8Type> = mutable_s.as_mut();
             let values = values.u8()?;
-            std::mem::take(ca).set_at_idx2(idx, values.into_iter())
+            std::mem::take(ca).set_at_idx2(idx, values)
         }
         DataType::UInt16 => {
             let ca: &mut ChunkedArray<UInt16Type> = mutable_s.as_mut();
             let values = values.u16()?;
-            std::mem::take(ca).set_at_idx2(idx, values.into_iter())
+            std::mem::take(ca).set_at_idx2(idx, values)
         }
         DataType::UInt32 => {
             let ca: &mut ChunkedArray<UInt32Type> = mutable_s.as_mut();
             let values = values.u32()?;
-            std::mem::take(ca).set_at_idx2(idx, values.into_iter())
+            std::mem::take(ca).set_at_idx2(idx, values)
         }
         DataType::UInt64 => {
             let ca: &mut ChunkedArray<UInt64Type> = mutable_s.as_mut();
             let values = values.u64()?;
-            std::mem::take(ca).set_at_idx2(idx, values.into_iter())
+            std::mem::take(ca).set_at_idx2(idx, values)
         }
         DataType::Float32 => {
             let ca: &mut ChunkedArray<Float32Type> = mutable_s.as_mut();
             let values = values.f32()?;
-            std::mem::take(ca).set_at_idx2(idx, values.into_iter())
+            std::mem::take(ca).set_at_idx2(idx, values)
         }
         DataType::Float64 => {
             let ca: &mut ChunkedArray<Float64Type> = mutable_s.as_mut();
             let values = values.f64()?;
-            std::mem::take(ca).set_at_idx2(idx, values.into_iter())
+            std::mem::take(ca).set_at_idx2(idx, values)
         }
         DataType::Boolean => {
             let ca = s.bool()?;
             let values = values.bool()?;
             ca.set_at_idx2(idx, values)
         }
         DataType::Utf8 => {
```

### Comparing `polars_lts_cpu-0.18.8/src/sql.rs` & `polars_lts_cpu-0.18.9/src/sql.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/src/utils.rs` & `polars_lts_cpu-0.18.9/src/utils.rs`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/README.md` & `polars_lts_cpu-0.18.9/tests/README.md`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/benchmark/groupby-datagen.R` & `polars_lts_cpu-0.18.9/tests/benchmark/groupby-datagen.R`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/benchmark/run_h2oai_benchmark.py` & `polars_lts_cpu-0.18.9/tests/benchmark/run_h2oai_benchmark.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/benchmark/test_release.py` & `polars_lts_cpu-0.18.9/tests/benchmark/test_release.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/docs/run_doctest.py` & `polars_lts_cpu-0.18.9/tests/docs/run_doctest.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/parametric/test_dataframe.py` & `polars_lts_cpu-0.18.9/tests/parametric/test_dataframe.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/parametric/test_groupby_rolling.py` & `polars_lts_cpu-0.18.9/tests/parametric/test_groupby_rolling.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/parametric/test_lazyframe.py` & `polars_lts_cpu-0.18.9/tests/parametric/test_lazyframe.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/parametric/test_lit.py` & `polars_lts_cpu-0.18.9/tests/parametric/test_lit.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/parametric/test_series.py` & `polars_lts_cpu-0.18.9/tests/parametric/test_series.py`

 * *Files 1% similar despite different names*

```diff
@@ -14,15 +14,15 @@
 from polars.expr.expr import _prepare_alpha
 from polars.testing import assert_series_equal
 from polars.testing.parametric import series
 
 
 def alpha_guard(**decay_param: float) -> bool:
     """Protects against unnecessary noise in small number regime."""
-    if not list(decay_param.values())[0]:
+    if not next(iter(decay_param.values())):
         return True
     alpha = _prepare_alpha(**decay_param)
     return ((1 - alpha) if round(alpha) else alpha) > 1e-6
 
 
 @given(
     s=series(
```

### Comparing `polars_lts_cpu-0.18.8/tests/parametric/test_testing.py` & `polars_lts_cpu-0.18.9/tests/parametric/test_testing.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/parametric/time_series/test_to_datetime.py` & `polars_lts_cpu-0.18.9/tests/parametric/time_series/test_to_datetime.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/conftest.py` & `polars_lts_cpu-0.18.9/tests/unit/conftest.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/dataframe/test_df.py` & `polars_lts_cpu-0.18.9/tests/unit/dataframe/test_df.py`

 * *Files 0% similar despite different names*

```diff
@@ -3652,7 +3652,19 @@
 
 def test_sum_empty_column_names() -> None:
     df = pl.DataFrame({"x": [], "y": []}, schema={"x": pl.Boolean, "y": pl.Boolean})
     expected = pl.DataFrame(
         {"x": [0], "y": [0]}, schema={"x": pl.UInt32, "y": pl.UInt32}
     )
     assert_frame_equal(df.sum(), expected)
+
+
+def test_flags() -> None:
+    df = pl.DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
+    assert df.flags == {
+        "a": {"SORTED_ASC": False, "SORTED_DESC": False},
+        "b": {"SORTED_ASC": False, "SORTED_DESC": False},
+    }
+    assert df.set_sorted("a").flags == {
+        "a": {"SORTED_ASC": True, "SORTED_DESC": False},
+        "b": {"SORTED_ASC": False, "SORTED_DESC": False},
+    }
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/dataframe/test_extend.py` & `polars_lts_cpu-0.18.9/tests/unit/dataframe/test_extend.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/dataframe/test_vstack.py` & `polars_lts_cpu-0.18.9/tests/unit/dataframe/test_vstack.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/datatypes/test_array.py` & `polars_lts_cpu-0.18.9/tests/unit/datatypes/test_array.py`

 * *Files 11% similar despite different names*

```diff
@@ -33,14 +33,27 @@
     # inner type
     dtype = pl.Array(2, pl.UInt8)
     payload = [[1, 2], [3, 4]]
     s = pl.Series(payload, dtype=dtype)
     assert s.dtype == dtype
     assert s.to_list() == payload
 
+    # create using schema
+    df = pl.DataFrame(
+        schema={
+            "a": pl.Array(width=3, inner=pl.Float32),
+            "b": pl.Array(width=5, inner=pl.Datetime("ms")),
+        }
+    )
+    assert df.dtypes == [
+        pl.Array(width=3, inner=pl.Float32),
+        pl.Array(width=5, inner=pl.Datetime("ms")),
+    ]
+    assert df.rows() == []
+
 
 def test_array_in_groupby() -> None:
     df = pl.DataFrame(
         [
             pl.Series("id", [1, 2]),
             pl.Series("list", [[1, 2], [5, 5]], dtype=pl.Array(2, pl.UInt8)),
         ]
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/datatypes/test_binary.py` & `polars_lts_cpu-0.18.9/tests/unit/datatypes/test_binary.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/datatypes/test_bool.py` & `polars_lts_cpu-0.18.9/tests/unit/datatypes/test_bool.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/datatypes/test_categorical.py` & `polars_lts_cpu-0.18.9/tests/unit/datatypes/test_categorical.py`

 * *Files 1% similar despite different names*

```diff
@@ -73,28 +73,14 @@
         "foo_4": [0, 0, 0, 1],
         "bar_a": [1, 0, 1, 0],
         "bar_b": [0, 1, 0, 0],
         "bar_c": [0, 0, 0, 1],
     }
 
 
-def test_comp_categorical_lit_dtype() -> None:
-    df = pl.DataFrame(
-        data={"column": ["a", "b", "e"], "values": [1, 5, 9]},
-        schema=[("column", pl.Categorical), ("more", pl.Int32)],
-    )
-
-    assert df.with_columns(
-        pl.when(pl.col("column") == "e")
-        .then("d")
-        .otherwise(pl.col("column"))
-        .alias("column")
-    ).dtypes == [pl.Categorical, pl.Int32]
-
-
 def test_categorical_describe_3487() -> None:
     # test if we don't err
     df = pl.DataFrame({"cats": ["a", "b"]})
     df = df.with_columns(pl.col("cats").cast(pl.Categorical))
     df.describe()
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/datatypes/test_decimal.py` & `polars_lts_cpu-0.18.9/tests/unit/datatypes/test_decimal.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/datatypes/test_duration.py` & `polars_lts_cpu-0.18.9/tests/unit/datatypes/test_duration.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/datatypes/test_list.py` & `polars_lts_cpu-0.18.9/tests/unit/datatypes/test_list.py`

 * *Files 2% similar despite different names*

```diff
@@ -459,7 +459,20 @@
         "as_list": [
             [
                 {"a": 1, "b": 2, "c": None, "d": None},
                 {"a": None, "b": None, "c": 3, "d": None},
             ]
         ]
     }
+
+
+def test_list_amortized_iter_clear_settings_10126() -> None:
+    out = (
+        pl.DataFrame({"a": [[1], [1], [2]], "b": [[1, 2], [1, 3], [4]]})
+        .explode("a")
+        .groupby("a")
+        .agg(pl.col("b").flatten())
+        .with_columns(pl.col("b").list.unique())
+        .sort("a")
+    )
+
+    assert out.to_dict(False) == {"a": [1, 2], "b": [[1, 2, 3], [4]]}
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/datatypes/test_object.py` & `polars_lts_cpu-0.18.9/tests/unit/datatypes/test_object.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,30 +1,14 @@
 from uuid import uuid4
 
 import numpy as np
 
 import polars as pl
 
 
-def test_object_when_then_4702() -> None:
-    # please don't ever do this
-    x = pl.DataFrame({"Row": [1, 2], "Type": [pl.Date, pl.UInt8]})
-
-    assert x.with_columns(
-        pl.when(pl.col("Row") == 1)
-        .then(pl.lit(pl.UInt16, allow_object=True))
-        .otherwise(pl.lit(pl.UInt8, allow_object=True))
-        .alias("New_Type")
-    ).to_dict(False) == {
-        "Row": [1, 2],
-        "Type": [pl.Date, pl.UInt8],
-        "New_Type": [pl.UInt16, pl.UInt8],
-    }
-
-
 def test_object_empty_filter_5911() -> None:
     df = pl.DataFrame(
         data=[
             (1, "dog", {}),
         ],
         schema=[
             ("pet_id", pl.Int64),
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/datatypes/test_struct.py` & `polars_lts_cpu-0.18.9/tests/unit/datatypes/test_struct.py`

 * *Files 0% similar despite different names*

```diff
@@ -853,7 +853,13 @@
     }
 
 
 def test_struct_null_count_strict_cast() -> None:
     s = pl.Series([{"a": None}]).cast(pl.Struct({"a": pl.Categorical}))
     assert s.dtype == pl.Struct([pl.Field("a", pl.Categorical)])
     assert s.to_list() == [{"a": None}]
+
+
+def test_struct_get_field_by_index() -> None:
+    df = pl.DataFrame({"val": [{"a": 1, "b": 2}]})
+    expected = {"b": [2]}
+    assert df.select(pl.all().struct[1]).to_dict(as_series=False) == expected
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/datatypes/test_temporal.py` & `polars_lts_cpu-0.18.9/tests/unit/datatypes/test_temporal.py`

 * *Files 0% similar despite different names*

```diff
@@ -1887,15 +1887,15 @@
 
 
 def test_iso_year() -> None:
     assert pl.Series([datetime(2022, 1, 1, 7, 8, 40)]).dt.iso_year()[0] == 2021
     assert pl.Series([date(2022, 1, 1)]).dt.iso_year()[0] == 2021
 
 
-def test_replace_timezone() -> None:
+def test_replace_time_zone() -> None:
     ny = ZoneInfo("America/New_York")
     assert pl.DataFrame({"a": [datetime(2022, 9, 25, 14)]}).with_columns(
         pl.col("a").dt.replace_time_zone("America/New_York").alias("b")
     ).to_dict(False) == {
         "a": [datetime(2022, 9, 25, 14, 0)],
         "b": [datetime(2022, 9, 25, 14, 0, tzinfo=ny)],
     }
@@ -1906,15 +1906,15 @@
     [
         ("America/Barbados", ZoneInfo(key="America/Barbados")),
         (None, None),
     ],
 )
 @pytest.mark.parametrize("from_tz", ["Asia/Seoul", None])
 @pytest.mark.parametrize("time_unit", ["ms", "us", "ns"])
-def test_replace_timezone_from_to(
+def test_replace_time_zone_from_to(
     from_tz: str,
     to_tz: str,
     tzinfo: timezone | ZoneInfo,
     time_unit: TimeUnit,
 ) -> None:
     ts = pl.Series(["2020-01-01"]).str.strptime(pl.Datetime(time_unit))
     result = ts.dt.replace_time_zone(from_tz).dt.replace_time_zone(to_tz).item()
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/functions/aggregation/test_horizontal.py` & `polars_lts_cpu-0.18.9/tests/unit/functions/aggregation/test_horizontal.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/functions/aggregation/test_vertical.py` & `polars_lts_cpu-0.18.9/tests/unit/functions/aggregation/test_vertical.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/functions/test_as_datatype.py` & `polars_lts_cpu-0.18.9/tests/unit/functions/test_as_datatype.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/functions/test_functions.py` & `polars_lts_cpu-0.18.9/tests/unit/functions/test_functions.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/functions/test_range.py` & `polars_lts_cpu-0.18.9/tests/unit/functions/test_range.py`

 * *Files 8% similar despite different names*

```diff
@@ -230,26 +230,26 @@
     expected_start = start.replace(microsecond=expected_micros)
     expected_stop = stop.replace(microsecond=expected_micros)
     assert result[0] == expected_start
     assert result[1] == expected_stop
 
 
 def test_range_invalid_unit() -> None:
-    with pytest.raises(pl.PolarsPanicError, match="'D' not supported"):
+    with pytest.raises(pl.PolarsPanicError, match="'x' not supported"):
         pl.date_range(
             start=datetime(2021, 12, 16),
             end=datetime(2021, 12, 16, 3),
-            interval="1D",
+            interval="1X",
             eager=True,
         )
 
 
 def test_date_range_lazy_with_literals() -> None:
     df = pl.DataFrame({"misc": ["x"]}).with_columns(
-        pl.date_range(
+        pl.date_ranges(
             date(2000, 1, 1),
             date(2023, 8, 31),
             interval="987d",
             eager=False,
         ).alias("dts")
     )
     assert df.rows() == [
@@ -299,72 +299,67 @@
 
 
 @pytest.mark.parametrize("low", ["start", pl.col("start")])
 @pytest.mark.parametrize("high", ["stop", pl.col("stop")])
 def test_date_range_lazy_with_expressions(
     low: str | pl.Expr, high: str | pl.Expr
 ) -> None:
-    ldf = (
-        pl.DataFrame({"start": [date(2015, 6, 30)], "stop": [date(2022, 12, 31)]})
-        .with_columns(
-            pl.date_range(low, high, interval="678d", eager=False).alias("dts")
-        )
-        .lazy()
+    lf = pl.LazyFrame(
+        {
+            "start": [date(2015, 6, 30)],
+            "stop": [date(2022, 12, 31)],
+        }
     )
 
-    assert ldf.collect().rows() == [
+    result = lf.with_columns(
+        pl.date_ranges(low, high, interval="678d", eager=False).alias("dts")
+    )
+
+    assert result.collect().rows() == [
         (
             date(2015, 6, 30),
             date(2022, 12, 31),
             [
                 date(2015, 6, 30),
                 date(2017, 5, 8),
                 date(2019, 3, 17),
                 date(2021, 1, 23),
                 date(2022, 12, 2),
             ],
         )
     ]
 
-    assert pl.DataFrame(
+    df = pl.DataFrame(
         {
             "start": [date(2000, 1, 1), date(2022, 6, 1)],
             "stop": [date(2000, 1, 2), date(2022, 6, 2)],
         }
-    ).with_columns(
-        pl.date_range(
-            low,
-            high,
-            interval="1d",
-        ).alias("dts")
-    ).to_dict(
-        False
-    ) == {
+    )
+
+    result_df = df.with_columns(pl.date_ranges(low, high, interval="1d").alias("dts"))
+
+    assert result_df.to_dict(False) == {
         "start": [date(2000, 1, 1), date(2022, 6, 1)],
         "stop": [date(2000, 1, 2), date(2022, 6, 2)],
         "dts": [
             [date(2000, 1, 1), date(2000, 1, 2)],
             [date(2022, 6, 1), date(2022, 6, 2)],
         ],
     }
 
-    assert pl.DataFrame(
+    df = pl.DataFrame(
         {
             "start": [datetime(2000, 1, 1), datetime(2022, 6, 1)],
             "stop": [datetime(2000, 1, 2), datetime(2022, 6, 2)],
         }
-    ).with_columns(
-        pl.date_range(
-            low,
-            high,
-            interval="1d",
-        ).alias("dts")
-    ).to_dict(
-        False
-    ) == {
+    )
+
+    result_df = df.with_columns(pl.date_ranges(low, high, interval="1d").alias("dts"))
+
+    assert result_df.to_dict(False) == {
         "start": [datetime(2000, 1, 1, 0, 0), datetime(2022, 6, 1, 0, 0)],
         "stop": [datetime(2000, 1, 2, 0, 0), datetime(2022, 6, 2, 0, 0)],
         "dts": [
             [datetime(2000, 1, 1, 0, 0), datetime(2000, 1, 2, 0, 0)],
             [datetime(2022, 6, 1, 0, 0), datetime(2022, 6, 2, 0, 0)],
         ],
     }
@@ -375,15 +370,15 @@
         {
             "name": ["A"],
             "from": [date(2020, 1, 1)],
             "to": [date(2020, 1, 2)],
         }
     )
     result = df.with_columns(
-        pl.date_range(
+        pl.date_ranges(
             start=pl.col("from"),
             end=pl.col("to"),
             interval="1d",
             eager=False,
         ).alias("date_range")
     )
     expected = pl.DataFrame(
@@ -550,79 +545,163 @@
 
 
 def test_date_range_name() -> None:
     expected_name = "date"
     result_eager = pl.date_range(date(2020, 1, 1), date(2020, 1, 3), eager=True)
     assert result_eager.name == expected_name
 
-    result_lazy = pl.select(
-        pl.date_range(date(2020, 1, 1), date(2020, 1, 3), eager=False)
-    ).to_series()
+    with pytest.deprecated_call():
+        result_lazy = pl.select(
+            pl.date_range(date(2020, 1, 1), date(2020, 1, 3), eager=False)
+        ).to_series()
     assert result_lazy.name == expected_name
 
 
-def test_time_range_lit() -> None:
-    for eager in (True, False):
+def test_date_ranges_eager() -> None:
+    start = pl.Series([date(2022, 1, 1), date(2022, 1, 2)])
+    end = pl.Series([date(2022, 1, 4), date(2022, 1, 3)])
+
+    result = pl.date_ranges(start, end, eager=True)
+
+    expected = pl.Series(
+        "date_range",
+        [
+            [date(2022, 1, 1), date(2022, 1, 2), date(2022, 1, 3), date(2022, 1, 4)],
+            [date(2022, 1, 2), date(2022, 1, 3)],
+        ],
+    )
+    assert_series_equal(result, expected)
+
+
+def test_date_range_eager_explode() -> None:
+    start = pl.Series([date(2022, 1, 1)])
+    end = pl.Series([date(2022, 1, 3)])
+
+    result = pl.date_range(start, end, eager=True)
+
+    expected = pl.Series("date", [date(2022, 1, 1), date(2022, 1, 2), date(2022, 1, 3)])
+    assert_series_equal(result, expected)
+
+
+def test_date_range_deprecated_eager() -> None:
+    start = pl.Series([date(2022, 1, 1), date(2022, 1, 2)])
+    end = pl.Series([date(2022, 1, 4), date(2022, 1, 3)])
+
+    with pytest.deprecated_call():
+        result = pl.date_range(start, end, eager=True)
+
+    expected = pl.Series(
+        "date",
+        [
+            [date(2022, 1, 1), date(2022, 1, 2), date(2022, 1, 3), date(2022, 1, 4)],
+            [date(2022, 1, 2), date(2022, 1, 3)],
+        ],
+    )
+    assert_series_equal(result, expected)
+
+
+def test_time_range_lit_lazy() -> None:
+    with pytest.deprecated_call():
         tm = pl.select(
             pl.time_range(
                 start=time(1, 2, 3),
                 end=time(23, 59, 59),
                 interval="5h45m10s333ms",
                 closed="right",
-                eager=eager,
             ).alias("tm")
         )
-        if not eager:
-            tm = tm.select(pl.col("tm").explode())
-        assert tm["tm"].to_list() == [
-            time(6, 47, 13, 333000),
-            time(12, 32, 23, 666000),
-            time(18, 17, 33, 999000),
-        ]
+    tm = tm.select(pl.col("tm").explode())
+    assert tm["tm"].to_list() == [
+        time(6, 47, 13, 333000),
+        time(12, 32, 23, 666000),
+        time(18, 17, 33, 999000),
+    ]
 
-        # validate unset start/end
-        tm = pl.select(
-            pl.time_range(
-                interval="5h45m10s333ms",
-                eager=eager,
-            ).alias("tm")
-        )
-        if not eager:
-            tm = tm.select(pl.col("tm").explode())
-        assert tm["tm"].to_list() == [
-            time(0, 0),
-            time(5, 45, 10, 333000),
-            time(11, 30, 20, 666000),
-            time(17, 15, 30, 999000),
-            time(23, 0, 41, 332000),
-        ]
+    # validate unset start/end
+    with pytest.deprecated_call():
+        tm = pl.select(pl.time_range(interval="5h45m10s333ms").alias("tm"))
+    tm = tm.select(pl.col("tm").explode())
+    assert tm["tm"].to_list() == [
+        time(0, 0),
+        time(5, 45, 10, 333000),
+        time(11, 30, 20, 666000),
+        time(17, 15, 30, 999000),
+        time(23, 0, 41, 332000),
+    ]
 
+    with pytest.deprecated_call():
         tm = pl.select(
             pl.time_range(
-                start=pl.lit(time(23, 59, 59, 999980)),
-                interval="10000ns",
-                eager=eager,
+                start=pl.lit(time(23, 59, 59, 999980)), interval="10000ns"
             ).alias("tm")
         )
+    tm = tm.select(pl.col("tm").explode())
+    assert tm["tm"].to_list() == [
+        time(23, 59, 59, 999980),
+        time(23, 59, 59, 999990),
+    ]
+
+
+def test_time_range_lit_eager() -> None:
+    eager = True
+    tm = pl.select(
+        pl.time_range(
+            start=time(1, 2, 3),
+            end=time(23, 59, 59),
+            interval="5h45m10s333ms",
+            closed="right",
+            eager=eager,
+        ).alias("tm")
+    )
+    if not eager:
         tm = tm.select(pl.col("tm").explode())
-        assert tm["tm"].to_list() == [
-            time(23, 59, 59, 999980),
-            time(23, 59, 59, 999990),
-        ]
+    assert tm["tm"].to_list() == [
+        time(6, 47, 13, 333000),
+        time(12, 32, 23, 666000),
+        time(18, 17, 33, 999000),
+    ]
+
+    # validate unset start/end
+    tm = pl.select(
+        pl.time_range(
+            interval="5h45m10s333ms",
+            eager=eager,
+        ).alias("tm")
+    )
+    if not eager:
+        tm = tm.select(pl.col("tm").explode())
+    assert tm["tm"].to_list() == [
+        time(0, 0),
+        time(5, 45, 10, 333000),
+        time(11, 30, 20, 666000),
+        time(17, 15, 30, 999000),
+        time(23, 0, 41, 332000),
+    ]
+
+    tm = pl.select(
+        pl.time_range(
+            start=pl.lit(time(23, 59, 59, 999980)),
+            interval="10000ns",
+            eager=eager,
+        ).alias("tm")
+    )
+    tm = tm.select(pl.col("tm").explode())
+    assert tm["tm"].to_list() == [
+        time(23, 59, 59, 999980),
+        time(23, 59, 59, 999990),
+    ]
 
 
 def test_time_range_expr() -> None:
     df = pl.DataFrame(
         {
             "start": pl.time_range(interval="6h", eager=True),
             "stop": pl.time_range(start=time(2, 59), interval="5h59m", eager=True),
         }
-    ).with_columns(
-        intervals=pl.time_range("start", pl.col("stop"), interval="1h29m", eager=False)
-    )
+    ).with_columns(intervals=pl.time_ranges("start", pl.col("stop"), interval="1h29m"))
     # shape: (4, 3)
     # ┌──────────┬──────────┬────────────────────────────────┐
     # │ start    ┆ stop     ┆ intervals                      │
     # │ ---      ┆ ---      ┆ ---                            │
     # │ time     ┆ time     ┆ list[time]                     │
     # ╞══════════╪══════════╪════════════════════════════════╡
     # │ 00:00:00 ┆ 02:59:00 ┆ [00:00:00, 01:29:00, 02:58:00] │
@@ -639,15 +718,18 @@
 
 
 def test_time_range_name() -> None:
     expected_name = "time"
     result_eager = pl.time_range(time(10), time(12), eager=True)
     assert result_eager.name == expected_name
 
-    result_lazy = pl.select(pl.time_range(time(10), time(12), eager=False)).to_series()
+    with pytest.deprecated_call():
+        result_lazy = pl.select(
+            pl.time_range(time(10), time(12), eager=False)
+        ).to_series()
     assert result_lazy.name == expected_name
 
 
 def test_deprecated_name_arg() -> None:
     name = "x"
     with pytest.deprecated_call():
         result_lazy = pl.date_range(date(2023, 1, 1), date(2023, 1, 3), name=name)
@@ -708,15 +790,15 @@
             pl.col("*")
             .dt.replace_time_zone(values_time_zone)
             .dt.cast_time_unit(values_time_unit)
         )
         .lazy()
     )
     result = df.with_columns(
-        pl.date_range(
+        pl.date_ranges(
             pl.col("start"),
             pl.col("end"),
             time_zone=input_time_zone,
             time_unit=input_time_unit,
         ).alias("date_range")
     )
     expected_schema = {
@@ -783,15 +865,15 @@
     input_time_zone: str | None,
     output_dtype: PolarsDataType,
     interval: str,
     expected_date_range: list[str],
 ) -> None:
     df = pl.DataFrame({"start": [date(2020, 1, 1)], "end": [date(2020, 1, 3)]}).lazy()
     result = df.with_columns(
-        pl.date_range(
+        pl.date_ranges(
             pl.col("start"),
             pl.col("end"),
             interval=interval,
             time_unit=input_time_unit,
             time_zone=input_time_zone,
         ).alias("date_range")
     )
@@ -879,15 +961,15 @@
     input_time_zone: str | None,
     output_dtype: PolarsDataType,
     interval: str,
     expected_date_range: list[str],
 ) -> None:
     df = pl.DataFrame({"start": [date(2020, 1, 1)], "end": [date(2020, 1, 3)]}).lazy()
     result = df.with_columns(
-        pl.date_range(
+        pl.date_ranges(
             pl.col("start"),
             pl.col("end"),
             interval=interval,
             time_unit=input_time_unit,
             time_zone=input_time_zone,
         ).alias("date_range")
     )
@@ -917,33 +999,74 @@
     assert_frame_equal(result.collect(), expected)
 
 
 def test_date_range_no_alias_schema_9037() -> None:
     df = pl.DataFrame(
         {"start": [datetime(2020, 1, 1)], "end": [datetime(2020, 1, 2)]}
     ).lazy()
-    result = df.with_columns(pl.date_range(pl.col("start"), pl.col("end")))
+    result = df.with_columns(pl.date_ranges(pl.col("start"), pl.col("end")))
     expected_schema = {
         "start": pl.Datetime(time_unit="us", time_zone=None),
         "end": pl.Datetime(time_unit="us", time_zone=None),
-        "date": pl.List(pl.Datetime(time_unit="us", time_zone=None)),
+        "date_range": pl.List(pl.Datetime(time_unit="us", time_zone=None)),
     }
     assert result.schema == expected_schema
     assert result.collect().schema == expected_schema
 
 
 def test_time_range_schema() -> None:
     df = pl.DataFrame({"start": [time(1)], "end": [time(1, 30)]}).lazy()
-    result = df.with_columns(
-        pl.time_range(pl.col("start"), pl.col("end")).alias("time_range")
-    )
+    result = df.with_columns(pl.time_ranges(pl.col("start"), pl.col("end")))
     expected_schema = {"start": pl.Time, "end": pl.Time, "time_range": pl.List(pl.Time)}
     assert result.schema == expected_schema
     assert result.collect().schema == expected_schema
 
 
 def test_time_range_no_alias_schema_9037() -> None:
     df = pl.DataFrame({"start": [time(1)], "end": [time(1, 30)]}).lazy()
-    result = df.with_columns(pl.time_range(pl.col("start"), pl.col("end")))
-    expected_schema = {"start": pl.Time, "end": pl.Time, "time": pl.List(pl.Time)}
+    result = df.with_columns(pl.time_ranges(pl.col("start"), pl.col("end")))
+    expected_schema = {"start": pl.Time, "end": pl.Time, "time_range": pl.List(pl.Time)}
     assert result.schema == expected_schema
     assert result.collect().schema == expected_schema
+
+
+def test_time_ranges_eager() -> None:
+    start = pl.Series([time(9, 0), time(10, 0)])
+    end = pl.Series([time(12, 0), time(11, 0)])
+
+    result = pl.time_ranges(start, end, eager=True)
+
+    expected = pl.Series(
+        "time_range",
+        [
+            [time(9, 0), time(10, 0), time(11, 0), time(12, 0)],
+            [time(10, 0), time(11, 0)],
+        ],
+    )
+    assert_series_equal(result, expected)
+
+
+def test_time_range_eager_explode() -> None:
+    start = pl.Series([time(9, 0)])
+    end = pl.Series([time(11, 0)])
+
+    result = pl.time_range(start, end, eager=True)
+
+    expected = pl.Series("time", [time(9, 0), time(10, 0), time(11, 0)])
+    assert_series_equal(result, expected)
+
+
+def test_time_range_deprecated_eager() -> None:
+    start = pl.Series([time(9, 0), time(10, 0)])
+    end = pl.Series([time(12, 0), time(11, 0)])
+
+    with pytest.deprecated_call():
+        result = pl.time_range(start, end, eager=True)
+
+    expected = pl.Series(
+        "time",
+        [
+            [time(9, 0), time(10, 0), time(11, 0), time(12, 0)],
+            [time(10, 0), time(11, 0)],
+        ],
+    )
+    assert_series_equal(result, expected)
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/functions/test_repeat.py` & `polars_lts_cpu-0.18.9/tests/unit/functions/test_repeat.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/files/delta-table/_delta_log/00000000000000000000.json` & `polars_lts_cpu-0.18.9/tests/unit/io/files/delta-table/_delta_log/00000000000000000000.json`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/files/delta-table/_delta_log/00000000000000000001.json` & `polars_lts_cpu-0.18.9/tests/unit/io/files/delta-table/_delta_log/00000000000000000001.json`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/files/delta-table/part-00000-e42312d7-60e5-454d-acbc-db192d220e73-c000.snappy.parquet` & `polars_lts_cpu-0.18.9/tests/unit/io/files/delta-table/part-00000-e42312d7-60e5-454d-acbc-db192d220e73-c000.snappy.parquet`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/files/delta-table/part-00000-e4a999da-df45-4fb0-bdc4-d999fc0f58aa-c000.snappy.parquet` & `polars_lts_cpu-0.18.9/tests/unit/io/files/delta-table/part-00000-e4a999da-df45-4fb0-bdc4-d999fc0f58aa-c000.snappy.parquet`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/files/example.xlsx` & `polars_lts_cpu-0.18.9/tests/unit/io/files/example.xlsx`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/files/foods1.ipc` & `polars_lts_cpu-0.18.9/tests/unit/io/files/foods1.ipc`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/files/foods1.ndjson` & `polars_lts_cpu-0.18.9/tests/unit/io/files/foods1.ndjson`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/files/foods1.parquet` & `polars_lts_cpu-0.18.9/tests/unit/io/files/foods1.parquet`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/files/foods2.ipc` & `polars_lts_cpu-0.18.9/tests/unit/io/files/foods2.ipc`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/files/foods2.ndjson` & `polars_lts_cpu-0.18.9/tests/unit/io/files/foods2.ndjson`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/files/foods2.parquet` & `polars_lts_cpu-0.18.9/tests/unit/io/files/foods2.parquet`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/files/small.parquet` & `polars_lts_cpu-0.18.9/tests/unit/io/files/small.parquet`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/test_avro.py` & `polars_lts_cpu-0.18.9/tests/unit/io/test_avro.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/test_csv.py` & `polars_lts_cpu-0.18.9/tests/unit/io/test_csv.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/test_database.py` & `polars_lts_cpu-0.18.9/tests/unit/io/test_database.py`

 * *Files 2% similar despite different names*

```diff
@@ -102,15 +102,15 @@
 ) -> None:
     tmp_path.mkdir(exist_ok=True)
 
     test_db = str(tmp_path / "test.db")
     create_temp_sqlite_db(test_db)
 
     df = pl.read_database(
-        connection_uri=f"sqlite:///{test_db}",
+        connection=f"sqlite:///{test_db}",
         query="SELECT * FROM test_data",
         engine=engine,
     )
     assert df.schema == expected_dtypes
     assert df.shape == (2, 4)
     assert df["date"].to_list() == expected_dates
 
@@ -150,15 +150,15 @@
     database: str,
     errclass: type,
     err: str,
     tmp_path: Path,
 ) -> None:
     with pytest.raises(errclass, match=err):
         pl.read_database(
-            connection_uri=f"{database}://test",
+            connection=f"{database}://test",
             query=query,
             engine=engine,
         )
 
 
 @pytest.mark.write_disk()
 @pytest.mark.parametrize(
@@ -194,47 +194,44 @@
         ),
     ],
 )
 def test_write_database(
     engine: DbWriteEngine, mode: DbWriteMode, sample_df: pl.DataFrame, tmp_path: Path
 ) -> None:
     tmp_path.mkdir(exist_ok=True)
-
     tmp_db = f"test_{engine}.db"
     test_db = str(tmp_path / tmp_db)
 
     # note: test a table name that requires quotes to ensure that we handle
     # it correctly (also supply an explicit db schema with/without quotes)
     tbl_name = '"test-data"'
 
     sample_df.write_database(
         table_name=f"main.{tbl_name}",
-        connection_uri=f"sqlite:///{test_db}",
+        connection=f"sqlite:///{test_db}",
         if_exists="replace",
         engine=engine,
     )
-
     if mode == "append":
         sample_df.write_database(
             table_name=f'"main".{tbl_name}',
-            connection_uri=f"sqlite:///{test_db}",
+            connection=f"sqlite:///{test_db}",
             if_exists="append",
             engine=engine,
         )
         sample_df = pl.concat([sample_df, sample_df])
 
     result = pl.read_database(f"SELECT * FROM {tbl_name}", f"sqlite:///{test_db}")
-
     sample_df = sample_df.with_columns(pl.col("date").cast(pl.Utf8))
     assert_frame_equal(sample_df, result)
 
     # check that some invalid parameters raise errors
     for invalid_params in (
         {"table_name": "w.x.y.z"},
         {"if_exists": "crunk", "table_name": f"main.{tbl_name}"},
     ):
         with pytest.raises(ValueError):
             sample_df.write_database(
-                connection_uri=f"sqlite:///{test_db}",
+                connection=f"sqlite:///{test_db}",
                 engine=engine,
                 **invalid_params,  # type: ignore[arg-type]
             )
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/test_delta.py` & `polars_lts_cpu-0.18.9/tests/unit/io/test_delta.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/test_excel.py` & `polars_lts_cpu-0.18.9/tests/unit/io/test_excel.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/test_ipc.py` & `polars_lts_cpu-0.18.9/tests/unit/io/test_ipc.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/test_json.py` & `polars_lts_cpu-0.18.9/tests/unit/io/test_json.py`

 * *Files 5% similar despite different names*

```diff
@@ -195,7 +195,21 @@
         "SeqNo": [1, 1],
         "Timestamp": [1, 1],
         "Fields": [
             [{"Name": "added_id", "Value": 2}, {"Name": "body", "Value": None}],
             [{"Name": "added_id", "Value": 2}, {"Name": "body", "Value": None}],
         ],
     }
+
+
+def test_write_json_duration() -> None:
+    df = pl.DataFrame(
+        {
+            "a": pl.Series(
+                [91762939, 91762890, 6020836], dtype=pl.Duration(time_unit="ms")
+            )
+        }
+    )
+    assert (
+        df.write_json(row_oriented=True)
+        == '[{"a":"P1DT5362.939S"},{"a":"P1DT5362.890S"},{"a":"PT6020.836S"}]'
+    )
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/test_lazy_csv.py` & `polars_lts_cpu-0.18.9/tests/unit/io/test_lazy_csv.py`

 * *Files 1% similar despite different names*

```diff
@@ -21,15 +21,15 @@
 def test_scan_csv(io_files_path: Path) -> None:
     df = pl.scan_csv(io_files_path / "small.csv")
     assert df.collect().shape == (4, 3)
 
 
 def test_scan_csv_no_cse_deadlock(io_files_path: Path) -> None:
     dfs = [pl.scan_csv(io_files_path / "small.csv")] * (pl.threadpool_size() + 1)
-    pl.concat(dfs, parallel=True).collect(common_subplan_elimination=False)
+    pl.concat(dfs, parallel=True).collect(comm_subplan_elim=False)
 
 
 def test_scan_empty_csv(io_files_path: Path) -> None:
     with pytest.raises(Exception) as excinfo:
         pl.scan_csv(io_files_path / "empty.csv").collect()
     assert "empty csv" in str(excinfo.value)
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/test_lazy_ipc.py` & `polars_lts_cpu-0.18.9/tests/unit/io/test_lazy_ipc.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/test_lazy_json.py` & `polars_lts_cpu-0.18.9/tests/unit/io/test_lazy_json.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/test_lazy_parquet.py` & `polars_lts_cpu-0.18.9/tests/unit/io/test_lazy_parquet.py`

 * *Files 2% similar despite different names*

```diff
@@ -372,7 +372,20 @@
     # take first and last rows
     assert df[[0, 39]].to_dict(False) == {
         "category": ["vegetables", "seafood"],
         "calories": [45, 146],
         "fats_g": [0.5, 6.0],
         "sugars_g": [2, 2],
     }
+
+
+@pytest.mark.write_disk()
+def test_parquet_statistics_filter_9925(tmp_path: Path) -> None:
+    tmp_path.mkdir(exist_ok=True)
+    file_path = tmp_path / "codes.parquet"
+    df = pl.DataFrame({"code": [300964, 300972, 500_000, 26]})
+    df.write_parquet(file_path, statistics=True)
+
+    q = pl.scan_parquet(file_path).filter(
+        (pl.col("code").floordiv(100_000)).is_in([0, 3])
+    )
+    assert q.collect().to_dict(False) == {"code": [300964, 300972, 26]}
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/test_other.py` & `polars_lts_cpu-0.18.9/tests/unit/io/test_other.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/test_parquet.py` & `polars_lts_cpu-0.18.9/tests/unit/io/test_parquet.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/test_pickle.py` & `polars_lts_cpu-0.18.9/tests/unit/io/test_pickle.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/io/test_pyarrow_dataset.py` & `polars_lts_cpu-0.18.9/tests/unit/io/test_pyarrow_dataset.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/namespaces/test_array.py` & `polars_lts_cpu-0.18.9/tests/unit/namespaces/test_array.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/namespaces/test_binary.py` & `polars_lts_cpu-0.18.9/tests/unit/namespaces/test_binary.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/namespaces/test_categorical.py` & `polars_lts_cpu-0.18.9/tests/unit/namespaces/test_categorical.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/namespaces/test_datetime.py` & `polars_lts_cpu-0.18.9/tests/unit/namespaces/test_datetime.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/namespaces/test_list.py` & `polars_lts_cpu-0.18.9/tests/unit/namespaces/test_list.py`

 * *Files 1% similar despite different names*

```diff
@@ -504,7 +504,18 @@
         }
     )
     r1 = df.with_columns(pl.col("a").list.intersection("b"))["a"].to_list()
     r2 = df.with_columns(pl.col("b").list.intersection("a"))["b"].to_list()
     exp = [[2, 3], [3, 1], [3]]
     assert r1 == exp
     assert r2 == exp
+
+
+def test_list_take_oob_10079() -> None:
+    df = pl.DataFrame(
+        {
+            "a": [[1, 2, 3], [], [None, 3], [5, 6, 7]],
+            "b": [["2"], ["3"], [None], ["3", "Hi"]],
+        }
+    )
+    with pytest.raises(pl.ComputeError, match="take indices are out of bounds"):
+        df.select(pl.col("a").take(999))
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/namespaces/test_meta.py` & `polars_lts_cpu-0.18.9/tests/unit/namespaces/test_meta.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/namespaces/test_string.py` & `polars_lts_cpu-0.18.9/tests/unit/namespaces/test_string.py`

 * *Files 2% similar despite different names*

```diff
@@ -719,7 +719,21 @@
         "sing": [
             "Welcome To My World",
             "There's No Turning Back",
             "Double  Space",
             "And\tA\t Tab",
         ]
     }
+
+
+def test_string_replace_with_nulls_10124() -> None:
+    df = pl.DataFrame({"col1": ["S", "S", "S", None, "S", "S", "S", "S"]})
+
+    assert df.select(
+        pl.col("col1"),
+        pl.col("col1").str.replace("S", "O", n=1).alias("n_1"),
+        pl.col("col1").str.replace("S", "O", n=3).alias("n_3"),
+    ).to_dict(False) == {
+        "col1": ["S", "S", "S", None, "S", "S", "S", "S"],
+        "n_1": ["O", "O", "O", None, "O", "O", "O", "O"],
+        "n_3": ["O", "O", "O", None, "O", "O", "O", "O"],
+    }
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/namespaces/test_strptime.py` & `polars_lts_cpu-0.18.9/tests/unit/namespaces/test_strptime.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/namespaces/test_struct.py` & `polars_lts_cpu-0.18.9/tests/unit/namespaces/test_struct.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_aggregations.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_aggregations.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_apply.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_apply.py`

 * *Files 3% similar despite different names*

```diff
@@ -168,26 +168,36 @@
     ]:
         assert s.apply(lambda x: x).to_list() == s.to_list()
 
 
 def test_apply_list_anyvalue_fallback() -> None:
     import json
 
-    df = pl.DataFrame({"text": ['[{"x": 1, "y": 2}, {"x": 3, "y": 4}]']})
-    assert df.select(pl.col("text").apply(json.loads)).to_dict(False) == {
-        "text": [[{"x": 1, "y": 2}, {"x": 3, "y": 4}]]
-    }
+    with pytest.warns(
+        PolarsInefficientApplyWarning,
+        match=r'(?s)replace your `apply` with.*pl.col\("text"\).str.json_extract()',
+    ):
+        df = pl.DataFrame({"text": ['[{"x": 1, "y": 2}, {"x": 3, "y": 4}]']})
+        assert df.select(pl.col("text").apply(json.loads)).to_dict(False) == {
+            "text": [[{"x": 1, "y": 2}, {"x": 3, "y": 4}]]
+        }
 
-    # starts with empty list '[]'
-    df = pl.DataFrame(
-        {"text": ["[]", '[{"x": 1, "y": 2}, {"x": 3, "y": 4}]', '[{"x": 1, "y": 2}]']}
-    )
-    assert df.select(pl.col("text").apply(json.loads)).to_dict(False) == {
-        "text": [[], [{"x": 1, "y": 2}, {"x": 3, "y": 4}], [{"x": 1, "y": 2}]]
-    }
+        # starts with empty list '[]'
+        df = pl.DataFrame(
+            {
+                "text": [
+                    "[]",
+                    '[{"x": 1, "y": 2}, {"x": 3, "y": 4}]',
+                    '[{"x": 1, "y": 2}]',
+                ]
+            }
+        )
+        assert df.select(pl.col("text").apply(json.loads)).to_dict(False) == {
+            "text": [[], [{"x": 1, "y": 2}, {"x": 3, "y": 4}], [{"x": 1, "y": 2}]]
+        }
 
 
 def test_apply_all_types() -> None:
     dtypes = [
         pl.UInt8,
         pl.UInt16,
         pl.UInt32,
@@ -242,15 +252,16 @@
 
     assert s.apply(lambda x: some_map[x]).to_list() == [None, "b"]
     assert s.apply(lambda x: some_map[x], skip_nulls=False).to_list() == ["a", "b"]
 
 
 def test_apply_object_dtypes() -> None:
     with pytest.warns(
-        PolarsInefficientApplyWarning, match="In this case, you can replace"
+        PolarsInefficientApplyWarning,
+        match=r"(?s)replace your `apply` with.*lambda x:",
     ):
         assert pl.DataFrame(
             {"a": pl.Series([1, 2, "a", 4, 5], dtype=pl.Object)}
         ).with_columns(
             [
                 pl.col("a").apply(lambda x: x * 2, return_dtype=pl.Object),
                 pl.col("a")
@@ -279,23 +290,27 @@
     )
 
     assert out.dtypes == [pl.List(pl.Int64)]
     assert out.to_dict(False) == {"str": [[1, 2, 3], [1, 2, 3]]}
 
 
 def test_apply_dict() -> None:
-    df = pl.DataFrame({"Col": ['{"A":"Value1"}', '{"B":"Value2"}']})
-    assert df.select(pl.col("Col").apply(json.loads)).to_dict(False) == {
-        "Col": [{"A": "Value1", "B": None}, {"A": None, "B": "Value2"}]
-    }
-    assert pl.DataFrame(
-        {"Col": ['{"A":"Value1", "B":"Value2"}', '{"B":"Value3"}']}
-    ).select(pl.col("Col").apply(json.loads)).to_dict(False) == {
-        "Col": [{"A": "Value1", "B": "Value2"}, {"A": None, "B": "Value3"}]
-    }
+    with pytest.warns(
+        PolarsInefficientApplyWarning,
+        match=r'(?s)replace your `apply` with.*pl.col\("abc"\).str.json_extract()',
+    ):
+        df = pl.DataFrame({"abc": ['{"A":"Value1"}', '{"B":"Value2"}']})
+        assert df.select(pl.col("abc").apply(json.loads)).to_dict(False) == {
+            "abc": [{"A": "Value1", "B": None}, {"A": None, "B": "Value2"}]
+        }
+        assert pl.DataFrame(
+            {"abc": ['{"A":"Value1", "B":"Value2"}', '{"B":"Value3"}']}
+        ).select(pl.col("abc").apply(json.loads)).to_dict(False) == {
+            "abc": [{"A": "Value1", "B": "Value2"}, {"A": None, "B": "Value3"}]
+        }
 
 
 def test_apply_pass_name() -> None:
     df = pl.DataFrame(
         {
             "bar": [1, 1, 2],
             "foo": [1, 2, 3],
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_arithmetic.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_arithmetic.py`

 * *Files 6% similar despite different names*

```diff
@@ -166,27 +166,44 @@
     assert """col("a").fms([col("b"), col("c")])""" in q.explain()
     assert q.collect()["a"].to_list() == [5, 35, 85]
 
     # check if we constant fold instead of fma
     q = df.lazy().select(pl.lit(1) * pl.lit(2) - pl.col("c"))
     assert """(2) - (col("c")""" in q.explain()
 
-    # 8752
-    df = pl.DataFrame({"x": pl.Series(values=[0, 0])})
-    q = df.lazy().with_columns((0 + 2.5 * (0.5 + pl.col("x"))).alias("compute"))
-    assert q.collect()["compute"][0] == 1.25
-    assert "0.0.fma" in q.explain()
-
-
-def test_fused_arithm_9009() -> None:
-    q = pl.LazyFrame({"a": [1, 2], "b": [3, 4]})
-    q = q.select((pl.col("b") * 2 + 3).over("a"))
-
-    assert """3.fma([col("b"), 2]).alias("b")""" in q.explain()
-    assert q.collect()["b"].to_list() == [9, 11]
+    # Check if fused is turned off for literals see: #9857
+    for expr in [
+        pl.col("c") * 2 + 5,
+        pl.col("c") * 2 + pl.col("c"),
+        pl.col("c") * 2 - 5,
+        pl.col("c") * 2 - pl.col("c"),
+        5 - pl.col("c") * 2,
+        pl.col("c") - pl.col("c") * 2,
+    ]:
+        q = df.lazy().select(expr)
+        assert all(
+            el not in q.explain() for el in ["fms", "fsm", "fma"]
+        ), f"Fused Arithmetic applied on literal {expr}: {q.explain()}"
+
+
+def test_literal_no_upcast() -> None:
+    df = pl.DataFrame({"a": pl.Series([1, 2, 3], dtype=pl.Float32)})
+
+    q = (
+        df.lazy()
+        .select(
+            (pl.col("a") * -5 + 2).alias("fma"),
+            (2 - pl.col("a") * 5).alias("fsm"),
+            (pl.col("a") * 5 - 2).alias("fms"),
+        )
+        .collect()
+    )
+    assert set(q.schema.values()) == {
+        pl.Float32
+    }, "Literal * Column (Float32) should not lead upcast"
 
 
 def test_boolean_addition() -> None:
     s = pl.DataFrame({"a": [True, False, False], "b": [True, False, True]}).sum(axis=1)
 
     assert s.dtype == pl.utils.get_index_type()
     assert s.to_list() == [2, 0, 1]
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_comparison.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_comparison.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_drop.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_drop.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_explode.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_explode.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_filter.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_filter.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_folds.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_folds.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_groupby.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_groupby.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_groupby_rolling.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_groupby_rolling.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 from __future__ import annotations
 
-from datetime import datetime
+from datetime import date, datetime
 from typing import TYPE_CHECKING, Any
 
 import pytest
 
 import polars as pl
 from polars.testing import assert_frame_equal, assert_series_equal
 
@@ -254,7 +254,46 @@
 
     # no `by` argument
     with pytest.raises(
         pl.InvalidOperationError,
         match=r"argument in operation 'groupby_rolling' is not explicitly sorted",
     ):
         df.groupby_rolling("idx", period="2i").agg(pl.col("idx").alias("idx1"))
+
+
+def test_groupby_rolling_empty_groups_9973() -> None:
+    dt1 = date(2001, 1, 1)
+    dt2 = date(2001, 1, 2)
+
+    data = pl.DataFrame(
+        {
+            "id": ["A", "A", "B", "B", "C", "C"],
+            "date": [dt1, dt2, dt1, dt2, dt1, dt2],
+            "value": [1.0, 2.0, 3.0, 4.0, 5.0, 6.0],
+        }
+    ).sort(by=["id", "date"])
+
+    expected = pl.DataFrame(
+        {
+            "id": ["A", "A", "B", "B", "C", "C"],
+            "date": [
+                date(2001, 1, 1),
+                date(2001, 1, 2),
+                date(2001, 1, 1),
+                date(2001, 1, 2),
+                date(2001, 1, 1),
+                date(2001, 1, 2),
+            ],
+            "value": [[2.0], [], [4.0], [], [6.0], []],
+        }
+    )
+
+    out = data.groupby_rolling(
+        index_column="date",
+        by="id",
+        period="2d",
+        offset="1d",
+        closed="left",
+        check_sorted=True,
+    ).agg(pl.col("value"))
+
+    assert_frame_equal(out, expected)
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_is_in.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_is_in.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 from __future__ import annotations
 
 from datetime import date
 
 import pytest
 
 import polars as pl
+from polars.testing import assert_series_equal
 
 
 def test_struct_logical_is_in() -> None:
     df1 = pl.DataFrame(
         {
             "x": pl.date_range(date(2022, 1, 1), date(2022, 1, 7), eager=True),
             "y": [0, 4, 6, 2, 3, 4, 5],
@@ -24,18 +25,18 @@
     s1 = df1.select(pl.struct(["x", "y"])).to_series()
     s2 = df2.select(pl.struct(["x", "y"])).to_series()
 
     assert s1.is_in(s2).to_list() == [False, False, True, True, True, True, True]
 
 
 def test_is_in_bool() -> None:
-    bool_value_to_filter_on = {True, None}
+    vals = [True, None]
     df = pl.DataFrame({"A": [True, False, None]})
-    assert df.filter(pl.col("A").is_in(bool_value_to_filter_on)).to_dict(False) == {
-        "A": [True, False]
+    assert df.select(pl.col("A").is_in(vals)).to_dict(False) == {
+        "A": [True, False, None]
     }
 
 
 def test_is_in_empty_list_4559() -> None:
     assert pl.Series(["a"]).is_in([]).to_list() == [False]
 
 
@@ -97,7 +98,14 @@
         True,
         False,
     ]
     assert df.select(pl.col("b").is_in([])).to_series().to_list() == [False]
 
     with pytest.raises(pl.ComputeError, match=r"cannot compare"):
         df.select(pl.col("b").is_in(["x", "x"]))
+
+    # check we don't shallow-copy and accidentally modify 'a' (see: #10072)
+    a = pl.Series("a", [1, 2])
+    b = pl.Series("b", [1, 3]).is_in(a)
+
+    assert a.name == "a"
+    assert_series_equal(b, pl.Series("b", [True, False]))
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_join.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_join.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_join_asof.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_join_asof.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_melt.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_melt.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_pivot.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_pivot.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_random.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_random.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_rolling.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_rolling.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,15 @@
     from zoneinfo import ZoneInfo
 else:
     # Import from submodule due to typing issue with backports.zoneinfo package:
     # https://github.com/pganssle/zoneinfo/issues/125
     from backports.zoneinfo._zoneinfo import ZoneInfo
 
 import polars as pl
-from polars.testing import assert_frame_equal
+from polars.testing import assert_frame_equal, assert_series_equal
 
 if TYPE_CHECKING:
     from polars.type_aliases import ClosedInterval
 
 
 @pytest.fixture()
 def example_df() -> pl.DataFrame:
@@ -815,7 +815,26 @@
         df.select(
             [
                 pl.col("d"),
                 pl.col("x").rolling_min(by="d", window_size="3d", closed="left"),
             ]
         ),
     )
+
+
+def test_rolling_weighted_quantile_10031() -> None:
+    assert_series_equal(
+        pl.Series([1, 2]).rolling_median(window_size=2, weights=[0, 1]),
+        pl.Series([None, 2.0]),
+    )
+
+    assert_series_equal(
+        pl.Series([1, 2, 3, 5]).rolling_quantile(0.7, "linear", 3, [0.1, 0.3, 0.6]),
+        pl.Series([None, None, 2.55, 4.1]),
+    )
+
+    assert_series_equal(
+        pl.Series([1, 2, 3, 5, 8]).rolling_quantile(
+            0.7, "linear", 4, [0.1, 0.2, 0, 0.3]
+        ),
+        pl.Series([None, None, None, 3.5, 5.5]),
+    )
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_select.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_select.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_sort.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_sort.py`

 * *Files 1% similar despite different names*

```diff
@@ -509,15 +509,15 @@
     }
 
 
 def get_str_ints_df(n: int) -> pl.DataFrame:
     strs = pl.Series("strs", random.choices(string.ascii_lowercase, k=n))
     strs = pl.select(
         pl.when(strs == "a")
-        .then("")
+        .then(pl.lit(""))
         .when(strs == "b")
         .then(None)
         .otherwise(strs)
         .alias("strs")
     ).to_series()
 
     vals = pl.Series("vals", np.random.rand(n))
@@ -530,15 +530,15 @@
     # we sort nulls_last as this will always dispatch
     # to row_fmt and is the default in pandas
 
     df = get_str_ints_df(1000)
     df_pd = df.to_pandas()
 
     for descending in [True, False]:
-        pl.testing.assert_frame_equal(
+        assert_frame_equal(
             df.sort(["strs", "vals"], nulls_last=True, descending=descending),
             pl.from_pandas(
                 df_pd.sort_values(["strs", "vals"], ascending=not descending)
             ),
         )
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_statistics.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_statistics.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_transpose.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_transpose.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_unique.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_unique.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_window.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_window.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/operations/test_with_columns.py` & `polars_lts_cpu-0.18.9/tests/unit/operations/test_with_columns.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/series/test_append.py` & `polars_lts_cpu-0.18.9/tests/unit/series/test_append.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/series/test_extend.py` & `polars_lts_cpu-0.18.9/tests/unit/series/test_extend.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/series/test_series.py` & `polars_lts_cpu-0.18.9/tests/unit/series/test_series.py`

 * *Files 0% similar despite different names*

```diff
@@ -19,15 +19,15 @@
     Int32,
     Int64,
     Time,
     UInt32,
     UInt64,
     Unknown,
 )
-from polars.exceptions import ShapeError
+from polars.exceptions import PolarsInefficientApplyWarning, ShapeError
 from polars.testing import assert_frame_equal, assert_series_equal
 from polars.utils._construction import iterable_to_pyseries
 
 if TYPE_CHECKING:
     from polars.type_aliases import EpochTimeUnit, PolarsDataType, TimeUnit
 
 
@@ -976,21 +976,23 @@
     nan = float("nan")
     a = pl.Series("a", [1.0, nan, 2.0, nan, 3.0])
     assert_series_equal(a.fill_nan(None), pl.Series("a", [1.0, None, 2.0, None, 3.0]))
     assert_series_equal(a.fill_nan(0), pl.Series("a", [1.0, 0.0, 2.0, 0.0, 3.0]))
 
 
 def test_apply() -> None:
-    a = pl.Series("a", [1, 2, None])
-    b = a.apply(lambda x: x**2)
-    assert list(b) == [1, 4, None]
-
-    a = pl.Series("a", ["foo", "bar", None])
-    b = a.apply(lambda x: x + "py")
-    assert list(b) == ["foopy", "barpy", None]
+    with pytest.warns(PolarsInefficientApplyWarning):
+        a = pl.Series("a", [1, 2, None])
+        b = a.apply(lambda x: x**2)
+        assert list(b) == [1, 4, None]
+
+    with pytest.warns(PolarsInefficientApplyWarning):
+        a = pl.Series("a", ["foo", "bar", None])
+        b = a.apply(lambda x: x + "py")
+        assert list(b) == ["foopy", "barpy", None]
 
     b = a.apply(lambda x: len(x), return_dtype=pl.Int32)
     assert list(b) == [3, 3, None]
 
     b = a.apply(lambda x: len(x))
     assert list(b) == [3, 3, None]
 
@@ -1258,14 +1260,17 @@
     assert df.select([pl.col("a").mode()])["a"].to_list() == [1]
     assert (
         pl.Series(["foo", "bar", "buz", "bar"], dtype=pl.Categorical).mode().item()
         == "bar"
     )
     assert pl.Series([1.0, 2.0, 3.0, 2.0]).mode().item() == 2.0
 
+    # sorted data
+    assert pl.int_range(0, 3, eager=True).mode().to_list() == [2, 1, 0]
+
 
 def test_rank() -> None:
     s = pl.Series("a", [1, 2, 3, 2, 2, 3, 0])
 
     assert_series_equal(
         s.rank("dense"), pl.Series("a", [2, 3, 4, 3, 3, 4, 1], dtype=UInt32)
     )
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/streaming/test_ooc.py` & `polars_lts_cpu-0.18.9/tests/unit/streaming/test_ooc.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/streaming/test_streaming.py` & `polars_lts_cpu-0.18.9/tests/unit/streaming/test_streaming.py`

 * *Files 3% similar despite different names*

```diff
@@ -689,7 +689,32 @@
         pl.LazyFrame(payload)
         .groupby("a")
         .first()
         .collect(streaming=True)
         .to_dict(False)
         == payload
     )
+
+
+@pytest.mark.write_disk()
+def test_streaming_10115(tmp_path: Path) -> None:
+    in_path = tmp_path / "in.parquet"
+    out_path = tmp_path / "out.parquet"
+
+    # this fails if the schema will be incorrectly due to the projection
+    # pushdown
+    (pl.DataFrame([{"x": 1, "y": "foo"}]).write_parquet(in_path))
+
+    joiner = pl.LazyFrame([{"y": "foo", "z": "_"}])
+
+    (
+        pl.scan_parquet(in_path)
+        .join(joiner, how="left", on="y")
+        .select("x", "y", "z")
+        .sink_parquet(out_path)  #
+    )
+
+    assert pl.read_parquet(out_path).to_dict(False) == {
+        "x": [1],
+        "y": ["foo"],
+        "z": ["_"],
+    }
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_api.py` & `polars_lts_cpu-0.18.9/tests/unit/test_api.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_cfg.py` & `polars_lts_cpu-0.18.9/tests/unit/test_cfg.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_constructors.py` & `polars_lts_cpu-0.18.9/tests/unit/test_constructors.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_datatypes.py` & `polars_lts_cpu-0.18.9/tests/unit/test_datatypes.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_empty.py` & `polars_lts_cpu-0.18.9/tests/unit/test_empty.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_errors.py` & `polars_lts_cpu-0.18.9/tests/unit/test_errors.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_expansion.py` & `polars_lts_cpu-0.18.9/tests/unit/test_expansion.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_expr_multi_cols.py` & `polars_lts_cpu-0.18.9/tests/unit/test_expr_multi_cols.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_exprs.py` & `polars_lts_cpu-0.18.9/tests/unit/test_exprs.py`

 * *Files 2% similar despite different names*

```diff
@@ -972,31 +972,14 @@
     df = pl.DataFrame({"a": [1, 2, 3, 4, 5]})
     assert df.select(pl.col("a").tail(0)).to_dict(False) == {"a": []}
     assert df.select(pl.col("a").tail(3)).to_dict(False) == {"a": [3, 4, 5]}
     assert df.select(pl.col("a").tail(10)).to_dict(False) == {"a": [1, 2, 3, 4, 5]}
     assert df.select(pl.col("a").tail(pl.count() / 2)).to_dict(False) == {"a": [4, 5]}
 
 
-def test_cache_expr(monkeypatch: Any, capfd: Any) -> None:
-    monkeypatch.setenv("POLARS_VERBOSE", "1")
-    df = pl.DataFrame(
-        {
-            "x": [3, 3, 3, 5, 8],
-        }
-    )
-    x = (pl.col("x") * 10).cache()
-
-    assert (df.groupby(1).agg([x * x * x])).to_dict(False) == {
-        "literal": [1],
-        "x": [[27000, 27000, 27000, 125000, 512000]],
-    }
-    _, err = capfd.readouterr()
-    assert """cache hit: [(col("x")) * (10)].cache()""" in err
-
-
 @pytest.mark.parametrize(
     ("const", "dtype"),
     [
         (1, pl.Int8),
         (4, pl.UInt32),
         (4.5, pl.Float32),
         (None, pl.Float64),
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_fmt.py` & `polars_lts_cpu-0.18.9/tests/unit/test_fmt.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_interchange.py` & `polars_lts_cpu-0.18.9/tests/unit/test_interchange.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_interop.py` & `polars_lts_cpu-0.18.9/tests/unit/test_interop.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_lazy.py` & `polars_lts_cpu-0.18.9/tests/unit/test_lazy.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_polars_import.py` & `polars_lts_cpu-0.18.9/tests/unit/test_polars_import.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_predicates.py` & `polars_lts_cpu-0.18.9/tests/unit/test_predicates.py`

 * *Files 6% similar despite different names*

```diff
@@ -20,31 +20,14 @@
 
     assert ldf.filter(
         pl.min_horizontal((pl.col("dt") + one_day), date(2022, 9, 30))
         > date(2022, 9, 10)
     ).collect().to_dict(False) == {"dt": [date(2022, 9, 10), date(2022, 9, 20)]}
 
 
-def test_when_then_implicit_none() -> None:
-    df = pl.DataFrame(
-        {
-            "team": ["A", "A", "A", "B", "B", "C"],
-            "points": [11, 8, 10, 6, 6, 5],
-        }
-    )
-
-    assert df.select(
-        pl.when(pl.col("points") > 7).then("Foo"),
-        pl.when(pl.col("points") > 7).then("Foo").alias("bar"),
-    ).to_dict(False) == {
-        "literal": ["Foo", "Foo", "Foo", None, None, None],
-        "bar": ["Foo", "Foo", "Foo", None, None, None],
-    }
-
-
 def test_predicate_null_block_asof_join() -> None:
     left = (
         pl.DataFrame(
             {
                 "id": [1, 2, 3, 4],
                 "timestamp": [
                     datetime(2022, 1, 1, 10, 0),
@@ -104,20 +87,14 @@
         .filter(False)
         .collect(streaming=True)
     )
 
     assert result.to_dict(False) == {"a": [], "b": [], "b_right": []}
 
 
-def test_when_then_empty_list_5547() -> None:
-    out = pl.DataFrame({"a": []}).select([pl.when(pl.col("a") > 1).then([1])])
-    assert out.shape == (0, 1)
-    assert out.dtypes == [pl.List(pl.Int64)]
-
-
 def test_predicate_strptime_6558() -> None:
     assert (
         pl.DataFrame({"date": ["2022-01-03", "2020-01-04", "2021-02-03", "2019-01-04"]})
         .lazy()
         .select(pl.col("date").str.strptime(pl.Date, format="%F"))
         .filter((pl.col("date").dt.year() == 2022) & (pl.col("date").dt.month() == 1))
         .collect()
@@ -165,7 +142,19 @@
 
 def test_predicate_pushdown_cumsum_9566() -> None:
     df = pl.DataFrame({"A": range(10), "B": ["b"] * 5 + ["a"] * 5})
 
     q = df.lazy().sort(["B", "A"]).filter(pl.col("A").is_in([8, 2]).cumsum() == 1)
 
     assert q.collect()["A"].to_list() == [8, 9, 0, 1]
+
+
+def test_predicate_pushdown_join_fill_null_10058() -> None:
+    ids = pl.LazyFrame({"id": [0, 1, 2]})
+    filters = pl.LazyFrame({"id": [0, 1], "filter": [True, False]})
+
+    assert (
+        ids.join(filters, how="left", on="id")
+        .filter(pl.col("filter").fill_null(True))
+        .collect()
+        .to_dict(False)["id"]
+    ) == [0, 2]
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_projections.py` & `polars_lts_cpu-0.18.9/tests/unit/test_projections.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_queries.py` & `polars_lts_cpu-0.18.9/tests/unit/test_queries.py`

 * *Files 13% similar despite different names*

```diff
@@ -26,38 +26,14 @@
         (2, 7.0, "b", False),
         (1, 6.0, "a", True),
         (3, 8.0, "c", True),
     ]
     assert out.shape == (3, 4)
 
 
-def test_type_coercion_when_then_otherwise_2806() -> None:
-    out = (
-        pl.DataFrame({"names": ["foo", "spam", "spam"], "nrs": [1, 2, 3]})
-        .select(
-            [
-                pl.when(pl.col("names") == "spam")
-                .then(pl.col("nrs") * 2)
-                .otherwise(pl.lit("other"))
-                .alias("new_col"),
-            ]
-        )
-        .to_series()
-    )
-    expected = pl.Series("new_col", ["other", "4", "6"])
-    assert out.to_list() == expected.to_list()
-
-    # test it remains float32
-    assert (
-        pl.Series("a", [1.0, 2.0, 3.0], dtype=pl.Float32)
-        .to_frame()
-        .select(pl.when(pl.col("a") > 2.0).then(pl.col("a")).otherwise(0.0))
-    ).to_series().dtype == pl.Float32
-
-
 def test_repeat_expansion_in_groupby() -> None:
     out = (
         pl.DataFrame({"g": [1, 2, 2, 3, 3, 3]})
         .groupby("g", maintain_order=True)
         .agg(pl.repeat(1, pl.count()).cumsum())
         .to_dict(False)
     )
@@ -296,45 +272,14 @@
             {"sum": None, "count": None},
             {"sum": 1, "count": 1},
             {"sum": 2, "count": 1},
         ],
     }
 
 
-def test_when_then_edge_cases_3994() -> None:
-    df = pl.DataFrame(data={"id": [1, 1], "type": [2, 2]})
-
-    # this tests if lazy correctly assigns the list schema to the column aggregation
-    assert (
-        df.lazy()
-        .groupby(["id"])
-        .agg(pl.col("type"))
-        .with_columns(
-            pl.when(pl.col("type").list.lengths() == 0)
-            .then(pl.lit(None))
-            .otherwise(pl.col("type"))
-            .keep_name()
-        )
-        .collect()
-    ).to_dict(False) == {"id": [1], "type": [[2, 2]]}
-
-    # this tests ternary with an empty argument
-    assert (
-        df.filter(pl.col("id") == 42)
-        .groupby(["id"])
-        .agg(pl.col("type"))
-        .with_columns(
-            pl.when(pl.col("type").list.lengths() == 0)
-            .then(pl.lit(None))
-            .otherwise(pl.col("type"))
-            .keep_name()
-        )
-    ).to_dict(False) == {"id": [], "type": []}
-
-
 def test_edge_cast_string_duplicates_4259() -> None:
     # carefully constructed data.
     # note that row 2, 3 concatenated are the same string ('5461214484')
     df = pl.DataFrame(
         {
             "a": [99, 54612, 546121],
             "b": [1, 14484, 4484],
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_rows.py` & `polars_lts_cpu-0.18.9/tests/unit/test_rows.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_schema.py` & `polars_lts_cpu-0.18.9/tests/unit/test_schema.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_selectors.py` & `polars_lts_cpu-0.18.9/tests/unit/test_selectors.py`

 * *Files 2% similar despite different names*

```diff
@@ -428,7 +428,20 @@
             ).fill_null(0),
         )
 
 
 def test_regex_expansion_groupby_9947() -> None:
     df = pl.DataFrame({"g": [3], "abc": [1], "abcd": [3]})
     assert df.groupby("g").agg(pl.col("^ab.*$")).columns == ["g", "abc", "abcd"]
+
+
+def test_regex_expansion_exclude_10002() -> None:
+    df = pl.DataFrame({"col_1": [1, 2, 3], "col_2": [2, 4, 3]})
+    expected = {"col_1": [10, 20, 30], "col_2": [0.2, 0.4, 0.3]}
+
+    assert (
+        df.select(
+            pl.col("^col_.*$").exclude("col_2").mul(10),
+            pl.col("^col_.*$").exclude("col_1") / 10,
+        ).to_dict(as_series=False)
+        == expected
+    )
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_serde.py` & `polars_lts_cpu-0.18.9/tests/unit/test_serde.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_single.py` & `polars_lts_cpu-0.18.9/tests/unit/test_single.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_sql.py` & `polars_lts_cpu-0.18.9/tests/unit/test_sql.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,9 +1,10 @@
 from __future__ import annotations
 
+import math
 import warnings
 from pathlib import Path
 
 import pytest
 
 import polars as pl
 import polars.selectors as cs
@@ -162,14 +163,41 @@
         "3_neq_unaware": [False, None, False, True, None],
         "4_eq_aware": [True, True, True, False, False],
         "5_eq_aware": [True, True, True, False, False],
         "6_neq_aware": [False, False, False, True, True],
     }
 
 
+def test_sql_arctan2() -> None:
+    twoRootTwo = math.sqrt(2) / 2.0
+    df = pl.DataFrame(
+        {
+            "y": [twoRootTwo, -twoRootTwo, twoRootTwo, -twoRootTwo],
+            "x": [twoRootTwo, twoRootTwo, -twoRootTwo, -twoRootTwo],
+        }
+    )
+
+    sql = pl.SQLContext(df=df)
+    res = sql.execute(
+        """
+        SELECT
+        ATAN2D(y,x) as "atan2d",
+        ATAN2(y,x) as "atan2"
+        FROM df
+        """,
+        eager=True,
+    )
+
+    df_result = pl.DataFrame({"atan2d": [45.0, -45.0, 135.0, -135.0]})
+    df_result = df_result.with_columns(pl.col("atan2d").cast(pl.Float64))
+    df_result = df_result.with_columns(pl.col("atan2d").radians().alias("atan2"))
+
+    assert_frame_equal(df_result, res)
+
+
 def test_sql_trig() -> None:
     df = pl.DataFrame(
         {
             "a": [-4, -3, -2, -1.00001, 0, 1.00001, 2, 3, 4],
         }
     )
```

### Comparing `polars_lts_cpu-0.18.8/tests/unit/test_testing.py` & `polars_lts_cpu-0.18.9/tests/unit/test_testing.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/utils/test_parse_expr_input.py` & `polars_lts_cpu-0.18.9/tests/unit/utils/test_parse_expr_input.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/tests/unit/utils/test_utils.py` & `polars_lts_cpu-0.18.9/tests/unit/utils/test_utils.py`

 * *Files identical despite different names*

### Comparing `polars_lts_cpu-0.18.8/Cargo.lock` & `polars_lts_cpu-0.18.9/Cargo.lock`

 * *Files 3% similar despite different names*

```diff
@@ -1,12 +1,21 @@
 # This file is automatically @generated by Cargo.
 # It is not intended for manual editing.
 version = 3
 
 [[package]]
+name = "addr2line"
+version = "0.20.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f4fa78e18c64fce05e902adecd7a5eed15a5e0a3439f7b0e169f0252214865e3"
+dependencies = [
+ "gimli",
+]
+
+[[package]]
 name = "adler"
 version = "1.0.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe"
 
 [[package]]
 name = "adler32"
@@ -24,17 +33,17 @@
  "getrandom",
  "once_cell",
  "version_check",
 ]
 
 [[package]]
 name = "aho-corasick"
-version = "1.0.1"
+version = "1.0.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "67fc08ce920c31afb70f013dcce1bfc3a3195de6a228474e45e1f145b36f8d04"
+checksum = "43f6cb1bf222025340178f382c426f13757b2960e89779dfcb319c32542a5a41"
 dependencies = [
  "memchr",
 ]
 
 [[package]]
 name = "alloc-no-stdlib"
 version = "2.0.4"
@@ -48,17 +57,17 @@
 checksum = "94fb8275041c72129eb51b7d0322c29b8387a0386127718b096429201a5d6ece"
 dependencies = [
  "alloc-no-stdlib",
 ]
 
 [[package]]
 name = "allocator-api2"
-version = "0.2.15"
+version = "0.2.16"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "56fc6cf8dc8c4158eed8649f9b8b0ea1518eb62b544fe9490d66fa0b349eafe9"
+checksum = "0942ffc6dcaadf03badf6e6a2d0228460359d5e34b57ccdc720b7382dfbd5ec5"
 
 [[package]]
 name = "android-tzdata"
 version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"
 
@@ -95,16 +104,15 @@
  "planus",
  "serde",
 ]
 
 [[package]]
 name = "arrow2"
 version = "0.17.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e44f27e89e3edd8738a07c5e2c881efaa25e69be97a816d2df051685d460670c"
+source = "git+https://github.com/jorgecarleitao/arrow2?rev=d5c78e7ba45fcebfbafd55a82ba2601ee3ea9617#d5c78e7ba45fcebfbafd55a82ba2601ee3ea9617"
 dependencies = [
  "ahash",
  "arrow-format",
  "avro-schema",
  "base64",
  "bytemuck",
  "chrono",
@@ -146,26 +154,26 @@
 name = "async-stream-impl"
 version = "0.3.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "16e62a023e7c117e27523144c5d2459f4397fcc3cab0085af8e2224f643a0193"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.18",
+ "syn 2.0.27",
 ]
 
 [[package]]
 name = "async-trait"
-version = "0.1.68"
+version = "0.1.72"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b9ccdd8f2a161be9bd5c023df56f1b2a0bd1d83872ae53b71a84a12c9bf6e842"
+checksum = "cc6dde6e4ed435a4c1ee4e73592f5ba9da2151af10076cc04858746af9352d09"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.18",
+ "syn 2.0.27",
 ]
 
 [[package]]
 name = "atoi"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f28d99ec8bfea296261ca1af174f24225171fea9664ba9003cbebee704810528"
@@ -190,14 +198,29 @@
  "libflate",
  "serde",
  "serde_json",
  "snap",
 ]
 
 [[package]]
+name = "backtrace"
+version = "0.3.68"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4319208da049c43661739c5fade2ba182f09d1dc2299b32298d3a31692b17e12"
+dependencies = [
+ "addr2line",
+ "cc",
+ "cfg-if",
+ "libc",
+ "miniz_oxide",
+ "object",
+ "rustc-demangle",
+]
+
+[[package]]
 name = "base64"
 version = "0.21.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "604178f6c5c21f02dc555784810edfb88d34ac2c73b2eae109655649ee73ce3d"
 
 [[package]]
 name = "bitflags"
@@ -224,17 +247,17 @@
 dependencies = [
  "alloc-no-stdlib",
  "alloc-stdlib",
 ]
 
 [[package]]
 name = "built"
-version = "0.6.0"
+version = "0.6.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "96f9cdd34d6eb553f9ea20e5bf84abb7b13c729f113fc1d8e49dc00ad9fa8738"
+checksum = "b99c4cdc7b2c2364182331055623bdf45254fcb679fea565c40c3c11c101889a"
 dependencies = [
  "cargo-lock",
  "chrono",
  "git2",
 ]
 
 [[package]]
@@ -256,28 +279,28 @@
 name = "bytemuck_derive"
 version = "1.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "fdde5c9cd29ebd706ce1b35600920a33550e402fc998a2e53ad3b42c3c47a192"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.18",
+ "syn 2.0.27",
 ]
 
 [[package]]
 name = "bytes"
 version = "1.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "89b2fd2a0dcf38d7971e2194b6b6eebab45ae01067456a7fd93d5547a61b70be"
 
 [[package]]
 name = "cargo-lock"
-version = "8.0.3"
+version = "9.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "031718ddb8f78aa5def78a09e90defe30151d1f6c672f937af4dd916429ed996"
+checksum = "e11c675378efb449ed3ce8de78d75d0d80542fc98487c26aba28eb3b82feac72"
 dependencies = [
  "semver",
  "serde",
  "toml",
  "url",
 ]
 
@@ -310,28 +333,28 @@
  "time",
  "wasm-bindgen",
  "winapi",
 ]
 
 [[package]]
 name = "chrono-tz"
-version = "0.8.2"
+version = "0.8.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cf9cc2b23599e6d7479755f3594285efb3f74a1bdca7a7374948bc831e23a552"
+checksum = "f1369bc6b9e9a7dfdae2055f6ec151fe9c554a9d23d357c0237cee2e25eaabb7"
 dependencies = [
  "chrono",
  "chrono-tz-build",
  "phf",
 ]
 
 [[package]]
 name = "chrono-tz-build"
-version = "0.1.0"
+version = "0.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d9998fb9f7e9b2111641485bf8beb32f92945f97f92a3d061f744cfef335f751"
+checksum = "e2f5ebdc942f57ed96d560a6d1a459bae5851102a25d5bf89dc04ae453e31ecf"
 dependencies = [
  "parse-zoneinfo",
  "phf",
  "phf_codegen",
 ]
 
 [[package]]
@@ -422,22 +445,22 @@
  "cfg-if",
  "crossbeam-epoch",
  "crossbeam-utils",
 ]
 
 [[package]]
 name = "crossbeam-epoch"
-version = "0.9.14"
+version = "0.9.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "46bd5f3f85273295a9d14aedfb86f6aadbff6d8f5295c4a9edb08e819dcf5695"
+checksum = "ae211234986c545741a7dc064309f67ee1e5ad243d0e48335adc0484d960bcc7"
 dependencies = [
  "autocfg",
  "cfg-if",
  "crossbeam-utils",
- "memoffset 0.8.0",
+ "memoffset",
  "scopeguard",
 ]
 
 [[package]]
 name = "crossbeam-queue"
 version = "0.3.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -445,17 +468,17 @@
 dependencies = [
  "cfg-if",
  "crossbeam-utils",
 ]
 
 [[package]]
 name = "crossbeam-utils"
-version = "0.8.15"
+version = "0.8.16"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3c063cd8cc95f5c377ed0d4b49a4b21f632396ff690e8470c29b3359b346984b"
+checksum = "5a22b2d63d4d1dc0b7f1b6b2747dd0088008a9be28b6ddf0b1e7d335e3037294"
 dependencies = [
  "cfg-if",
 ]
 
 [[package]]
 name = "crossterm"
 version = "0.26.1"
@@ -470,50 +493,50 @@
  "signal-hook",
  "signal-hook-mio",
  "winapi",
 ]
 
 [[package]]
 name = "crossterm_winapi"
-version = "0.9.0"
+version = "0.9.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2ae1b35a484aa10e07fe0638d02301c5ad24de82d310ccbd2f3693da5f09bf1c"
+checksum = "acdd7c62a3665c7f6830a51635d9ac9b23ed385797f70a83bb8bafe9c572ab2b"
 dependencies = [
  "winapi",
 ]
 
 [[package]]
 name = "dyn-clone"
-version = "1.0.11"
+version = "1.0.12"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "68b0cf012f1230e43cd00ebb729c6bb58707ecfa8ad08b52ef3a4ccd2697fc30"
+checksum = "304e6508efa593091e97a9abbc10f90aa7ca635b6d2784feff3c89d41dd12272"
 
 [[package]]
 name = "either"
-version = "1.8.1"
+version = "1.9.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7fcaabb2fef8c910e7f4c7ce9f67a1283a1715879a7c230ca9d6d1ae31f16d91"
+checksum = "a26ae43d7bcc3b814de94796a5e736d4029efb0ee900c12e2d54c993ad1a1e07"
 
 [[package]]
 name = "enum_dispatch"
-version = "0.3.11"
+version = "0.3.12"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "11f36e95862220b211a6e2aa5eca09b4fa391b13cd52ceb8035a24bf65a79de2"
+checksum = "8f33313078bb8d4d05a2733a94ac4c2d8a0df9a2b84424ebf4f33bfc224a890e"
 dependencies = [
  "once_cell",
  "proc-macro2",
  "quote",
- "syn 1.0.109",
+ "syn 2.0.27",
 ]
 
 [[package]]
 name = "equivalent"
-version = "1.0.0"
+version = "1.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "88bffebc5d80432c9b140ee17875ff173a8ab62faad5b257da912bd2f6c1c0a1"
+checksum = "5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5"
 
 [[package]]
 name = "ethnum"
 version = "1.3.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "0198b9d0078e0f30dedc7acbb21c974e838fc8fae3ee170128658a98cb2c1c04"
 
@@ -552,17 +575,17 @@
 name = "foreign_vec"
 version = "0.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ee1b05cbd864bcaecbd3455d6d967862d446e4ebfc3c2e5e5b9841e53cba6673"
 
 [[package]]
 name = "form_urlencoded"
-version = "1.1.0"
+version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a9c384f161156f5260c24a097c56119f9be8c798586aecc13afbcbe7b7e26bf8"
+checksum = "a62bc1cf6f830c2ec14a513a9fb124d0a213a629668a4186f329db21fe045652"
 dependencies = [
  "percent-encoding",
 ]
 
 [[package]]
 name = "futures"
 version = "0.3.28"
@@ -615,15 +638,15 @@
 name = "futures-macro"
 version = "0.3.28"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "89ca545a94061b6365f2c7355b4b32bd20df3ff95f02da9329b34ccc3bd6ee72"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.18",
+ "syn 2.0.27",
 ]
 
 [[package]]
 name = "futures-sink"
 version = "0.3.28"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f43be4fe21a13b9781a69afa4985b0f6ee0e1afab2c6f454a8cf30e2b2237b6e"
@@ -650,41 +673,36 @@
  "pin-project-lite",
  "pin-utils",
  "slab",
 ]
 
 [[package]]
 name = "getrandom"
-version = "0.2.9"
+version = "0.2.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c85e1d9ab2eadba7e5040d4e09cbd6d072b76a557ad64e797c2cb9d4da21d7e4"
+checksum = "be4136b2a15dd319360be1c07d9933517ccf0be8f16bf62a3bee4f0d618df427"
 dependencies = [
  "cfg-if",
  "js-sys",
  "libc",
  "wasi 0.11.0+wasi-snapshot-preview1",
  "wasm-bindgen",
 ]
 
 [[package]]
-name = "ghost"
-version = "0.1.9"
+name = "gimli"
+version = "0.27.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e77ac7b51b8e6313251737fcef4b1c01a2ea102bde68415b62c0ee9268fec357"
-dependencies = [
- "proc-macro2",
- "quote",
- "syn 2.0.18",
-]
+checksum = "b6c80984affa11d98d1b88b66ac8853f143217b399d3c74116778ff8fdb4ed2e"
 
 [[package]]
 name = "git2"
-version = "0.16.1"
+version = "0.17.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ccf7f68c2995f392c49fffb4f95ae2c873297830eb25c6bc4c114ce8f4562acc"
+checksum = "7b989d6a7ca95a362cf2cfc5ad688b3a467be1f87e480b8dad07fee8c79b0044"
 dependencies = [
  "bitflags",
  "libc",
  "libgit2-sys",
  "log",
  "url",
 ]
@@ -699,36 +717,30 @@
 name = "half"
 version = "1.8.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "eabb4a44450da02c90444cf74558da904edde8fb4e9035a9a6a4e15445af0bd7"
 
 [[package]]
 name = "halfbrown"
-version = "0.2.2"
+version = "0.2.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f985624e90f861184145c13b736873a0f83cdb998a292dbb0653598ab03aecbf"
+checksum = "5681137554ddff44396e5f149892c769d45301dd9aa19c51602a89ee214cb0ec"
 dependencies = [
  "hashbrown 0.13.2",
  "serde",
 ]
 
 [[package]]
 name = "hash_hasher"
 version = "2.0.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "74721d007512d0cb3338cd20f0654ac913920061a4c4d0d8708edb3f2a698c0c"
 
 [[package]]
 name = "hashbrown"
-version = "0.12.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888"
-
-[[package]]
-name = "hashbrown"
 version = "0.13.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "43a3c133739dddd0d2990f9a4bdf8eb4b21ef50e4851ca85ab661199821d510e"
 dependencies = [
  "ahash",
 ]
 
@@ -747,41 +759,38 @@
 name = "heck"
 version = "0.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "95505c38b4572b2d910cecb0281560f54b440a19336cbbcb27bf6ce6adc6f5a8"
 
 [[package]]
 name = "hermit-abi"
-version = "0.2.6"
+version = "0.3.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ee512640fe35acbfb4bb779db6f0d80704c2cacfa2e39b601ef3e3f47d1ae4c7"
-dependencies = [
- "libc",
-]
+checksum = "443144c8cdadd93ebf52ddb4056d257f5b52c04d3c804e657d19eb73fc33668b"
 
 [[package]]
 name = "hex"
 version = "0.4.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"
 
 [[package]]
 name = "home"
 version = "0.5.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5444c27eef6923071f7ebcc33e3444508466a76f7a2b93da00ed6e19f30c1ddb"
 dependencies = [
- "windows-sys 0.48.0",
+ "windows-sys",
 ]
 
 [[package]]
 name = "iana-time-zone"
-version = "0.1.56"
+version = "0.1.57"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0722cd7114b7de04316e7ea5456a0bbb20e4adb46fd27a3697adb812cff0f37c"
+checksum = "2fad5b825842d2b38bd206f3e81d6957625fd7f0a361e345c30e01a0ae2dd613"
 dependencies = [
  "android_system_properties",
  "core-foundation-sys",
  "iana-time-zone-haiku",
  "js-sys",
  "wasm-bindgen",
  "windows",
@@ -794,34 +803,24 @@
 checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
 dependencies = [
  "cc",
 ]
 
 [[package]]
 name = "idna"
-version = "0.3.0"
+version = "0.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e14ddfc70884202db2244c223200c204c2bda1bc6e0998d11b5e024d657209e6"
+checksum = "7d20d6b07bfbc108882d88ed8e37d39636dcc260e15e30c45e6ba089610b917c"
 dependencies = [
  "unicode-bidi",
  "unicode-normalization",
 ]
 
 [[package]]
 name = "indexmap"
-version = "1.9.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99"
-dependencies = [
- "autocfg",
- "hashbrown 0.12.3",
-]
-
-[[package]]
-name = "indexmap"
 version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d5477fe2230a79769d8dc68e0eabf5437907c0457a5614a9e8dddb67f65eb65d"
 dependencies = [
  "equivalent",
  "hashbrown 0.14.0",
  "serde",
@@ -840,26 +839,23 @@
 checksum = "7a5bbe824c507c5da5956355e86a746d82e0e1464f65d862cc5e71da70e94b2c"
 dependencies = [
  "cfg-if",
 ]
 
 [[package]]
 name = "inventory"
-version = "0.3.6"
+version = "0.3.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e0539b5de9241582ce6bd6b0ba7399313560151e58c9aaf8b74b711b1bdce644"
-dependencies = [
- "ghost",
-]
+checksum = "a53088c87cf71c9d4f3372a2cb9eea1e7b8a0b1bf8b7f7d23fe5b76dbb07e63b"
 
 [[package]]
 name = "itoa"
-version = "1.0.6"
+version = "1.0.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "453ad9f582a441959e5f0d088b02ce04cfe8d51a8eaf077f12ac6d3e94164ca6"
+checksum = "af150ab688ff2122fcef229be89cb50dd66af9e01a4ff320cc137eecc9bacc38"
 
 [[package]]
 name = "itoap"
 version = "1.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9028f49264629065d057f340a86acb84867925865f73bbf8d47b4d149a7e88b8"
 
@@ -890,17 +886,17 @@
 checksum = "936cfd212a0155903bcbc060e316fb6cc7cbf2e1907329391ebadc1fe0ce77c2"
 dependencies = [
  "libc",
 ]
 
 [[package]]
 name = "js-sys"
-version = "0.3.63"
+version = "0.3.64"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2f37a4a5928311ac501dee68b3c7613a1037d0edb30c8e5427bd832d55d1b790"
+checksum = "c5f195fe497f702db0f318b07fdd68edb16955aed830df8363d837542f8f935a"
 dependencies = [
  "wasm-bindgen",
 ]
 
 [[package]]
 name = "jsonpath_lib"
 version = "0.3.0"
@@ -982,17 +978,17 @@
 dependencies = [
  "lexical-util",
  "static_assertions",
 ]
 
 [[package]]
 name = "libc"
-version = "0.2.144"
+version = "0.2.147"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2b00cc1c228a6782d0f076e7b232802e0c5689d41bb5df366f2a6b6621cfdfe1"
+checksum = "b4668fb0ea861c1df094127ac5f1da3409a82116a4ba74fca2e58ef927159bb3"
 
 [[package]]
 name = "libflate"
 version = "1.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5ff4ae71b685bbad2f2f391fe74f6b7659a34871c08b210fdc039e43bee07d18"
 dependencies = [
@@ -1008,17 +1004,17 @@
 checksum = "a52d3a8bfc85f250440e4424db7d857e241a3aebbbe301f3eb606ab15c39acbf"
 dependencies = [
  "rle-decode-fast",
 ]
 
 [[package]]
 name = "libgit2-sys"
-version = "0.14.2+1.5.1"
+version = "0.15.2+1.6.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7f3d95f6b51075fe9810a7ae22c7095f12b98005ab364d8544797a825ce946a4"
+checksum = "a80df2e11fb4a61f4ba2ab42dbe7f74468da143f1a75c74e11dee7c813f694fa"
 dependencies = [
  "cc",
  "libc",
  "libz-sys",
  "pkg-config",
 ]
 
@@ -1036,39 +1032,39 @@
 dependencies = [
  "cc",
  "libc",
 ]
 
 [[package]]
 name = "libz-sys"
-version = "1.1.9"
+version = "1.1.12"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "56ee889ecc9568871456d42f603d6a0ce59ff328d291063a45cbdf0036baf6db"
+checksum = "d97137b25e321a73eef1418d1d5d2eda4d77e12813f8e6dead84bc52c5870a7b"
 dependencies = [
  "cc",
  "libc",
  "pkg-config",
  "vcpkg",
 ]
 
 [[package]]
 name = "lock_api"
-version = "0.4.9"
+version = "0.4.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "435011366fe56583b16cf956f9df0095b405b82d76425bc8981c0e22e60ec4df"
+checksum = "c1cc9717a20b1bb222f333e6a92fd32f7d8a18ddc5a3191a11af45dcbf4dcd16"
 dependencies = [
  "autocfg",
  "scopeguard",
 ]
 
 [[package]]
 name = "log"
-version = "0.4.18"
+version = "0.4.19"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "518ef76f2f87365916b142844c16d8fefd85039bc5699050210a7778ee1cd1de"
+checksum = "b06a4cde4c0f271a446782e3eff8de789548ce57dbc8eca9292c27f4a42004b4"
 
 [[package]]
 name = "lz4"
 version = "1.24.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7e9e2dd86df36ce760a60f6ff6ad526f7ba1f14ba0356f8254fb6905e6494df1"
 dependencies = [
@@ -1109,23 +1105,14 @@
 checksum = "83faa42c0a078c393f6b29d5db232d8be22776a891f8f56e5284faee4a20b327"
 dependencies = [
  "libc",
 ]
 
 [[package]]
 name = "memoffset"
-version = "0.8.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d61c719bcfbcf5d62b3a09efa6088de8c54bc0bfcd3ea7ae39fcc186108b8de1"
-dependencies = [
- "autocfg",
-]
-
-[[package]]
-name = "memoffset"
 version = "0.9.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5a634b1c61a95585bd15607c6ab0c4e5b226e695ff2800ba0cdccddf208c406c"
 dependencies = [
  "autocfg",
 ]
 
@@ -1152,15 +1139,15 @@
 version = "0.8.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "927a765cd3fc26206e66b296465fa9d3e5ab003e651c1b3c060e7956d96b19d2"
 dependencies = [
  "libc",
  "log",
  "wasi 0.11.0+wasi-snapshot-preview1",
- "windows-sys 0.48.0",
+ "windows-sys",
 ]
 
 [[package]]
 name = "multiversion"
 version = "0.7.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8cda45dade5144c2c929bf2ed6c24bebbba784e9198df049ec87d722b9462bd1"
@@ -1229,27 +1216,27 @@
 dependencies = [
  "autocfg",
  "num-traits",
 ]
 
 [[package]]
 name = "num-traits"
-version = "0.2.15"
+version = "0.2.16"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "578ede34cf02f8924ab9447f50c28075b4d3e5b269972345e7e0372b38c6cdcd"
+checksum = "f30b0abd723be7e2ffca1272140fac1a2f084c77ec3e123c192b66af1ee9e6c2"
 dependencies = [
  "autocfg",
  "libm",
 ]
 
 [[package]]
 name = "num_cpus"
-version = "1.15.0"
+version = "1.16.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0fac9e2da13b5eb447a6ce3d392f23a29d8694bff781bf03a16cd9ac8697593b"
+checksum = "4161fcb6d602d4d2081af7c3a45852d875a03dd337a6bfdd6e06407b61342a43"
 dependencies = [
  "hermit-abi",
  "libc",
 ]
 
 [[package]]
 name = "numpy"
@@ -1263,18 +1250,27 @@
  "num-integer",
  "num-traits",
  "pyo3",
  "rustc-hash",
 ]
 
 [[package]]
+name = "object"
+version = "0.31.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8bda667d9f2b5051b8833f59f3bf748b28ef54f850f4fcb389a252aa383866d1"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
 name = "once_cell"
-version = "1.17.2"
+version = "1.18.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9670a07f94779e00908f3e686eab508878ebb390ba6e604d3a284c00e8d0487b"
+checksum = "dd8b5dd2ae5ed71462c540258bedcb51965123ad7e7ccf4b9a8cafaa4a63576d"
 
 [[package]]
 name = "parking_lot"
 version = "0.11.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7d17b78036a60663b797adeaee46f5c9dfebb86948d1255007a1d6be0271ff99"
 dependencies = [
@@ -1286,42 +1282,42 @@
 [[package]]
 name = "parking_lot"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3742b2c103b9f06bc9fff0a37ff4912935851bee6d36f3c02bcc755bcfec228f"
 dependencies = [
  "lock_api",
- "parking_lot_core 0.9.7",
+ "parking_lot_core 0.9.8",
 ]
 
 [[package]]
 name = "parking_lot_core"
 version = "0.8.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "60a2cfe6f0ad2bfc16aefa463b497d5c7a5ecd44a23efa72aa342d90177356dc"
 dependencies = [
  "cfg-if",
  "instant",
  "libc",
- "redox_syscall",
+ "redox_syscall 0.2.16",
  "smallvec",
  "winapi",
 ]
 
 [[package]]
 name = "parking_lot_core"
-version = "0.9.7"
+version = "0.9.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9069cbb9f99e3a5083476ccb29ceb1de18b9118cafa53e90c9551235de2b9521"
+checksum = "93f00c865fe7cabf650081affecd3871070f26767e7b2070a3ffae14c654b447"
 dependencies = [
  "cfg-if",
  "libc",
- "redox_syscall",
+ "redox_syscall 0.3.5",
  "smallvec",
- "windows-sys 0.45.0",
+ "windows-targets",
 ]
 
 [[package]]
 name = "parquet-format-safe"
 version = "0.2.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1131c54b167dd4e4799ce762e1ab01549ebb94d5bdd13e6ec1b467491c378e1f"
@@ -1355,61 +1351,61 @@
 checksum = "c705f256449c60da65e11ff6626e0c16a0a0b96aaa348de61376b249bc340f41"
 dependencies = [
  "regex",
 ]
 
 [[package]]
 name = "percent-encoding"
-version = "2.2.0"
+version = "2.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "478c572c3d73181ff3c2539045f6eb99e5491218eae919370993b890cdbdd98e"
+checksum = "9b2a4787296e9989611394c33f193f676704af1686e70b8f8033ab5ba9a35a94"
 
 [[package]]
 name = "phf"
-version = "0.11.1"
+version = "0.11.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "928c6535de93548188ef63bb7c4036bd415cd8f36ad25af44b9789b2ee72a48c"
+checksum = "ade2d8b8f33c7333b51bcf0428d37e217e9f32192ae4772156f65063b8ce03dc"
 dependencies = [
  "phf_shared",
 ]
 
 [[package]]
 name = "phf_codegen"
-version = "0.11.1"
+version = "0.11.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a56ac890c5e3ca598bbdeaa99964edb5b0258a583a9eb6ef4e89fc85d9224770"
+checksum = "e8d39688d359e6b34654d328e262234662d16cc0f60ec8dcbe5e718709342a5a"
 dependencies = [
  "phf_generator",
  "phf_shared",
 ]
 
 [[package]]
 name = "phf_generator"
-version = "0.11.1"
+version = "0.11.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b1181c94580fa345f50f19d738aaa39c0ed30a600d95cb2d3e23f94266f14fbf"
+checksum = "48e4cc64c2ad9ebe670cb8fd69dd50ae301650392e81c05f9bfcb2d5bdbc24b0"
 dependencies = [
  "phf_shared",
  "rand",
 ]
 
 [[package]]
 name = "phf_shared"
-version = "0.11.1"
+version = "0.11.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e1fb5f6f826b772a8d4c0394209441e7d37cbbb967ae9c7e0e8134365c9ee676"
+checksum = "90fcb95eef784c2ac79119d1dd819e162b5da872ce6f3c3abe1e8ca1c082f72b"
 dependencies = [
  "siphasher",
 ]
 
 [[package]]
 name = "pin-project-lite"
-version = "0.2.9"
+version = "0.2.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e0a7ae3ac2f1173085d398531c705756c94a4c56843785df85a60c1a0afac116"
+checksum = "4c40d25201921e5ff0c862a505c6557ea88568a4e3ace775ab55e93f2f4f9d57"
 
 [[package]]
 name = "pin-utils"
 version = "0.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"
 
@@ -1476,15 +1472,15 @@
  "arrow2",
  "bitflags",
  "chrono",
  "chrono-tz",
  "comfy-table",
  "either",
  "hashbrown 0.14.0",
- "indexmap 2.0.0",
+ "indexmap",
  "itoap",
  "ndarray",
  "num-traits",
  "once_cell",
  "polars-arrow",
  "polars-error",
  "polars-row",
@@ -1549,15 +1545,15 @@
 name = "polars-json"
 version = "0.31.1"
 dependencies = [
  "ahash",
  "arrow2",
  "fallible-streaming-iterator",
  "hashbrown 0.14.0",
- "indexmap 2.0.0",
+ "indexmap",
  "num-traits",
  "polars-arrow",
  "polars-error",
  "polars-utils",
  "simd-json",
 ]
 
@@ -1586,17 +1582,19 @@
 [[package]]
 name = "polars-ops"
 version = "0.31.1"
 dependencies = [
  "argminmax",
  "arrow2",
  "base64",
+ "chrono",
+ "chrono-tz",
  "either",
  "hex",
- "indexmap 2.0.0",
+ "indexmap",
  "jsonpath_lib",
  "memchr",
  "polars-arrow",
  "polars-core",
  "polars-json",
  "polars-utils",
  "serde",
@@ -1641,15 +1639,15 @@
  "polars-time",
  "polars-utils",
  "pyo3",
  "rayon",
  "regex",
  "serde",
  "smartstring",
- "strum_macros 0.25.0",
+ "strum_macros 0.25.1",
 ]
 
 [[package]]
 name = "polars-row"
 version = "0.31.1"
 dependencies = [
  "arrow2",
@@ -1693,41 +1691,43 @@
 name = "polars-utils"
 version = "0.31.1"
 dependencies = [
  "ahash",
  "hashbrown 0.14.0",
  "num-traits",
  "once_cell",
+ "polars-error",
  "rayon",
  "smartstring",
  "sysinfo",
 ]
 
 [[package]]
 name = "ppv-lite86"
 version = "0.2.17"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5b40af805b3121feab8a3c29f04d8ad262fa8e0561883e7653e024ae4479e6de"
 
 [[package]]
 name = "proc-macro2"
-version = "1.0.59"
+version = "1.0.66"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6aeca18b86b413c660b781aa319e4e2648a3e6f9eadc9b47e9038e6fe9f3451b"
+checksum = "18fb31db3f9bddb2ea821cde30a9f70117e3f119938b5ee630b7403aa6e2ead9"
 dependencies = [
  "unicode-ident",
 ]
 
 [[package]]
 name = "py-polars"
-version = "0.18.8"
+version = "0.18.9"
 dependencies = [
  "ahash",
  "built",
  "ciborium",
+ "either",
  "jemallocator",
  "lexical-core",
  "libc",
  "mimalloc",
  "ndarray",
  "numpy",
  "once_cell",
@@ -1741,84 +1741,84 @@
  "serde_json",
  "smartstring",
  "thiserror",
 ]
 
 [[package]]
 name = "pyo3"
-version = "0.19.0"
+version = "0.19.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cffef52f74ec3b1a1baf295d9b8fcc3070327aefc39a6d00656b13c1d0b8885c"
+checksum = "ffb88ae05f306b4bfcde40ac4a51dc0b05936a9207a4b75b798c7729c4258a59"
 dependencies = [
  "cfg-if",
  "indoc",
  "inventory",
  "libc",
- "memoffset 0.9.0",
+ "memoffset",
  "parking_lot 0.12.1",
  "pyo3-build-config",
  "pyo3-ffi",
  "pyo3-macros",
  "unindent",
 ]
 
 [[package]]
 name = "pyo3-build-config"
-version = "0.19.0"
+version = "0.19.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "713eccf888fb05f1a96eb78c0dbc51907fee42b3377272dc902eb38985f418d5"
+checksum = "554db24f0b3c180a9c0b1268f91287ab3f17c162e15b54caaae5a6b3773396b0"
 dependencies = [
  "once_cell",
  "target-lexicon",
 ]
 
 [[package]]
 name = "pyo3-built"
 version = "0.4.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "be6d574e0f8cab2cdd1eeeb640cbf845c974519fa9e9b62fa9c08ecece0ca5de"
 
 [[package]]
 name = "pyo3-ffi"
-version = "0.19.0"
+version = "0.19.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5b2ecbdcfb01cbbf56e179ce969a048fd7305a66d4cdf3303e0da09d69afe4c3"
+checksum = "922ede8759e8600ad4da3195ae41259654b9c55da4f7eec84a0ccc7d067a70a4"
 dependencies = [
  "libc",
  "pyo3-build-config",
 ]
 
 [[package]]
 name = "pyo3-macros"
-version = "0.19.0"
+version = "0.19.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b78fdc0899f2ea781c463679b20cb08af9247febc8d052de941951024cd8aea0"
+checksum = "8a5caec6a1dd355964a841fcbeeb1b89fe4146c87295573f94228911af3cc5a2"
 dependencies = [
  "proc-macro2",
  "pyo3-macros-backend",
  "quote",
  "syn 1.0.109",
 ]
 
 [[package]]
 name = "pyo3-macros-backend"
-version = "0.19.0"
+version = "0.19.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "60da7b84f1227c3e2fe7593505de274dcf4c8928b4e0a1c23d551a14e4e80a0f"
+checksum = "e0b78ccbb160db1556cdb6fd96c50334c5d4ec44dc5e0a968d0a1208fa0efa8b"
 dependencies = [
  "proc-macro2",
  "quote",
  "syn 1.0.109",
 ]
 
 [[package]]
 name = "quote"
-version = "1.0.28"
+version = "1.0.32"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1b9ab9c7eadfd8df19006f1cf1a4aed13540ed5cbc047010ece5826e10825488"
+checksum = "50f3b39ccfb720540debaa0164757101c08ecb8d326b15358ce76a62c7e85965"
 dependencies = [
  "proc-macro2",
 ]
 
 [[package]]
 name = "rand"
 version = "0.8.5"
@@ -1893,43 +1893,70 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "fb5a58c1855b4b6819d59012155603f0b22ad30cad752600aadfcb695265519a"
 dependencies = [
  "bitflags",
 ]
 
 [[package]]
+name = "redox_syscall"
+version = "0.3.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "567664f262709473930a4bf9e51bf2ebf3348f2e748ccc50dea20646858f8f29"
+dependencies = [
+ "bitflags",
+]
+
+[[package]]
 name = "regex"
-version = "1.8.3"
+version = "1.9.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "81ca098a9821bd52d6b24fd8b10bd081f47d39c22778cafaa75a2857a62c6390"
+checksum = "b2eae68fc220f7cf2532e4494aded17545fce192d59cd996e0fe7887f4ceb575"
 dependencies = [
  "aho-corasick",
  "memchr",
- "regex-syntax 0.7.2",
+ "regex-automata",
+ "regex-syntax 0.7.4",
+]
+
+[[package]]
+name = "regex-automata"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "39354c10dd07468c2e73926b23bb9c2caca74c5501e38a35da70406f1d923310"
+dependencies = [
+ "aho-corasick",
+ "memchr",
+ "regex-syntax 0.7.4",
 ]
 
 [[package]]
 name = "regex-syntax"
 version = "0.6.29"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f162c6dd7b008981e4d40210aca20b4bd0f9b60ca9271061b07f78537722f2e1"
 
 [[package]]
 name = "regex-syntax"
-version = "0.7.2"
+version = "0.7.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "436b050e76ed2903236f032a59761c1eb99e1b0aead2c257922771dab1fc8c78"
+checksum = "e5ea92a5b6195c6ef2a0295ea818b312502c6fc94dde986c5553242e18fd4ce2"
 
 [[package]]
 name = "rle-decode-fast"
 version = "1.0.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3582f63211428f83597b51b2ddb88e2a91a9d52d12831f9d08f5e624e8977422"
 
 [[package]]
+name = "rustc-demangle"
+version = "0.1.23"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d626bb9dae77e28219937af045c257c28bfd3f69333c512553507f5f9798cb76"
+
+[[package]]
 name = "rustc-hash"
 version = "1.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"
 
 [[package]]
 name = "rustc_version"
@@ -1938,82 +1965,91 @@
 checksum = "bfa0f585226d2e68097d4f95d113b15b83a82e819ab25717ec0590d9584ef366"
 dependencies = [
  "semver",
 ]
 
 [[package]]
 name = "rustversion"
-version = "1.0.12"
+version = "1.0.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4f3208ce4d8448b3f3e7d168a73f5e0c43a61e32930de3bceeccedb388b6bf06"
+checksum = "7ffc183a10b4478d04cbbbfc96d0873219d962dd5accaff2ffbd4ceb7df837f4"
 
 [[package]]
 name = "ryu"
-version = "1.0.13"
+version = "1.0.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f91339c0467de62360649f8d3e185ca8de4224ff281f66000de5eb2a77a79041"
+checksum = "1ad4cc8da4ef723ed60bced201181d83791ad433213d8c24efffda1eec85d741"
 
 [[package]]
 name = "scopeguard"
-version = "1.1.0"
+version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd"
+checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"
 
 [[package]]
 name = "semver"
-version = "1.0.17"
+version = "1.0.18"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bebd363326d05ec3e2f532ab7660680f3b02130d780c299bca73469d521bc0ed"
+checksum = "b0293b4b29daaf487284529cc2f5675b8e57c61f70167ba415a463651fd6a918"
 dependencies = [
  "serde",
 ]
 
 [[package]]
 name = "seq-macro"
-version = "0.3.3"
+version = "0.3.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e6b44e8fc93a14e66336d230954dda83d18b4605ccace8fe09bc7514a71ad0bc"
+checksum = "a3f0bf26fd526d2a95683cd0f87bf103b8539e2ca1ef48ce002d67aad59aa0b4"
 
 [[package]]
 name = "serde"
-version = "1.0.163"
+version = "1.0.176"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2113ab51b87a539ae008b5c6c02dc020ffa39afd2d83cffcb3f4eb2722cebec2"
+checksum = "76dc28c9523c5d70816e393136b86d48909cfb27cecaa902d338c19ed47164dc"
 dependencies = [
  "serde_derive",
 ]
 
 [[package]]
 name = "serde_derive"
-version = "1.0.163"
+version = "1.0.176"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8c805777e3930c8883389c602315a24224bcc738b63905ef87cd1420353ea93e"
+checksum = "a4e7b8c5dc823e3b90651ff1d3808419cd14e5ad76de04feaf37da114e7a306f"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.18",
+ "syn 2.0.27",
 ]
 
 [[package]]
 name = "serde_json"
-version = "1.0.96"
+version = "1.0.104"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "057d394a50403bcac12672b2b18fb387ab6d289d957dab67dd201875391e52f1"
+checksum = "076066c5f1078eac5b722a31827a8832fe108bed65dfa75e233c89f8206e976c"
 dependencies = [
- "indexmap 1.9.3",
+ "indexmap",
  "itoa",
  "ryu",
  "serde",
 ]
 
 [[package]]
+name = "serde_spanned"
+version = "0.6.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "96426c9936fd7a0124915f9185ea1d20aa9445cc9821142f0a73bc9207a2e186"
+dependencies = [
+ "serde",
+]
+
+[[package]]
 name = "signal-hook"
-version = "0.3.15"
+version = "0.3.17"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "732768f1176d21d09e076c23a93123d40bba92d50c4058da34d45c8de8e682b9"
+checksum = "8621587d4798caf8eb44879d42e56b9a93ea5dcd315a6487c357130095b62801"
 dependencies = [
  "libc",
  "signal-hook-registry",
 ]
 
 [[package]]
 name = "signal-hook-mio"
@@ -2033,17 +2069,16 @@
 checksum = "d8229b473baa5980ac72ef434c4415e70c4b5e71b423043adb4ba059f89c99a1"
 dependencies = [
  "libc",
 ]
 
 [[package]]
 name = "simd-json"
-version = "0.10.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a3d0815e7ff0f1f05e09d4b029f86d8a330f0ab15b35b28736f3758325f59e14"
+version = "0.10.0"
+source = "git+https://github.com/ritchie46/simd-json?branch=initialize#946b316f686c6ad3050f694ea434248c38aa321d"
 dependencies = [
  "ahash",
  "halfbrown",
  "lexical-core",
  "once_cell",
  "serde",
  "serde_json",
@@ -2070,17 +2105,17 @@
 checksum = "6528351c9bc8ab22353f9d776db39a20288e8d6c37ef8cfe3317cf875eecfc2d"
 dependencies = [
  "autocfg",
 ]
 
 [[package]]
 name = "smallvec"
-version = "1.10.0"
+version = "1.11.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a507befe795404456341dfab10cef66ead4c041f62b8b11bbb92bffe5d0953e0"
+checksum = "62bb4feee49fdd9f707ef802e22365a35de4b7b299de4763d44bfea899442ff9"
 
 [[package]]
 name = "smartstring"
 version = "1.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3fb72c633efbaa2dd666986505016c32c3044395ceaf881518399d2f4127ee29"
 dependencies = [
@@ -2159,23 +2194,23 @@
  "quote",
  "rustversion",
  "syn 1.0.109",
 ]
 
 [[package]]
 name = "strum_macros"
-version = "0.25.0"
+version = "0.25.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fe9f3bd7d2e45dcc5e265fbb88d6513e4747d8ef9444cf01a533119bce28a157"
+checksum = "6069ca09d878a33f883cc06aaa9718ede171841d3832450354410b718b097232"
 dependencies = [
  "heck",
  "proc-macro2",
  "quote",
  "rustversion",
- "syn 2.0.18",
+ "syn 2.0.27",
 ]
 
 [[package]]
 name = "syn"
 version = "1.0.109"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
@@ -2183,28 +2218,28 @@
  "proc-macro2",
  "quote",
  "unicode-ident",
 ]
 
 [[package]]
 name = "syn"
-version = "2.0.18"
+version = "2.0.27"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "32d41677bcbe24c20c52e7c70b0d8db04134c5d1066bf98662e2871ad200ea3e"
+checksum = "b60f673f44a8255b9c8c657daf66a596d435f2da81a555b06dc644d080ba45e0"
 dependencies = [
  "proc-macro2",
  "quote",
  "unicode-ident",
 ]
 
 [[package]]
 name = "sysinfo"
-version = "0.29.0"
+version = "0.29.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "02f1dc6930a439cc5d154221b5387d153f8183529b07c19aca24ea31e0a167e1"
+checksum = "165d6d8539689e3d3bc8b98ac59541e1f21c7de7c85d60dc80e43ae0ed2113db"
 dependencies = [
  "cfg-if",
  "core-foundation-sys",
  "libc",
  "ntapi",
  "once_cell",
  "winapi",
@@ -2214,36 +2249,36 @@
 name = "target-features"
 version = "0.1.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "06f6b473c37f9add4cf1df5b4d66a8ef58ab6c895f1a3b3f949cf3e21230140e"
 
 [[package]]
 name = "target-lexicon"
-version = "0.12.7"
+version = "0.12.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fd1ba337640d60c3e96bc6f0638a939b9c9a7f2c316a1598c279828b3d1dc8c5"
+checksum = "1d2faeef5759ab89935255b1a4cd98e0baf99d1085e37d36599c625dac49ae8e"
 
 [[package]]
 name = "thiserror"
-version = "1.0.40"
+version = "1.0.44"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "978c9a314bd8dc99be594bc3c175faaa9794be04a5a5e153caba6915336cebac"
+checksum = "611040a08a0439f8248d1990b111c95baa9c704c805fa1f62104b39655fd7f90"
 dependencies = [
  "thiserror-impl",
 ]
 
 [[package]]
 name = "thiserror-impl"
-version = "1.0.40"
+version = "1.0.44"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f9456a42c5b0d803c8cd86e73dd7cc9edd429499f37a3550d286d5e86720569f"
+checksum = "090198534930841fab3a5d1bb637cde49e339654e606195f8d9c76eeb081dc96"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.18",
+ "syn 2.0.27",
 ]
 
 [[package]]
 name = "time"
 version = "0.1.45"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1b797afad3f312d1c66a56d11d0316f916356d11bd158fbc6ca6389ff6bf805a"
@@ -2266,46 +2301,72 @@
 name = "tinyvec_macros"
 version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"
 
 [[package]]
 name = "tokio"
-version = "1.28.2"
+version = "1.29.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "94d7b1cfd2aa4011f2de74c2c4c63665e27a71006b0a192dcd2710272e73dfa2"
+checksum = "532826ff75199d5833b9d2c5fe410f29235e25704ee5f0ef599fb51c21f4a4da"
 dependencies = [
  "autocfg",
+ "backtrace",
  "libc",
  "mio",
  "pin-project-lite",
  "socket2",
- "windows-sys 0.48.0",
+ "windows-sys",
 ]
 
 [[package]]
 name = "toml"
-version = "0.5.11"
+version = "0.7.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f4f7f0dd8d50a853a531c426359045b1998f04219d88799810762cd4ad314234"
+checksum = "c17e963a819c331dcacd7ab957d80bc2b9a9c1e71c804826d2f283dd65306542"
 dependencies = [
  "serde",
+ "serde_spanned",
+ "toml_datetime",
+ "toml_edit",
+]
+
+[[package]]
+name = "toml_datetime"
+version = "0.6.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7cda73e2f1397b1262d6dfdcef8aafae14d1de7748d66822d3bfeeb6d03e5e4b"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "toml_edit"
+version = "0.19.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f8123f27e969974a3dfba720fdb560be359f57b44302d280ba72e76a74480e8a"
+dependencies = [
+ "indexmap",
+ "serde",
+ "serde_spanned",
+ "toml_datetime",
+ "winnow",
 ]
 
 [[package]]
 name = "unicode-bidi"
 version = "0.3.13"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "92888ba5573ff080736b3648696b70cafad7d250551175acbaa4e0385b3e1460"
 
 [[package]]
 name = "unicode-ident"
-version = "1.0.9"
+version = "1.0.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b15811caf2415fb889178633e7724bad2509101cde276048e013b9def5e51fa0"
+checksum = "301abaae475aa91687eb82514b328ab47a211a533026cb25fc3e519b86adfc3c"
 
 [[package]]
 name = "unicode-normalization"
 version = "0.1.22"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5c5713f0fc4b5db668a2ac63cdb7bb4469d8c9fed047b1d0292cc7b0ce2ba921"
 dependencies = [
@@ -2322,17 +2383,17 @@
 name = "unindent"
 version = "0.1.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e1766d682d402817b5ac4490b3c3002d91dfa0d22812f341609f97b08757359c"
 
 [[package]]
 name = "url"
-version = "2.3.1"
+version = "2.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0d68c799ae75762b8c3fe375feb6600ef5602c883c5d21eb51c09f22b83c4643"
+checksum = "50bff7831e19200a85b17131d085c25d7811bc4e186efdaf54bbd132994a88cb"
 dependencies = [
  "form_urlencoded",
  "idna",
  "percent-encoding",
 ]
 
 [[package]]
@@ -2369,77 +2430,77 @@
 name = "wasi"
 version = "0.11.0+wasi-snapshot-preview1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"
 
 [[package]]
 name = "wasm-bindgen"
-version = "0.2.86"
+version = "0.2.87"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5bba0e8cb82ba49ff4e229459ff22a191bbe9a1cb3a341610c9c33efc27ddf73"
+checksum = "7706a72ab36d8cb1f80ffbf0e071533974a60d0a308d01a5d0375bf60499a342"
 dependencies = [
  "cfg-if",
  "wasm-bindgen-macro",
 ]
 
 [[package]]
 name = "wasm-bindgen-backend"
-version = "0.2.86"
+version = "0.2.87"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "19b04bc93f9d6bdee709f6bd2118f57dd6679cf1176a1af464fca3ab0d66d8fb"
+checksum = "5ef2b6d3c510e9625e5fe6f509ab07d66a760f0885d858736483c32ed7809abd"
 dependencies = [
  "bumpalo",
  "log",
  "once_cell",
  "proc-macro2",
  "quote",
- "syn 2.0.18",
+ "syn 2.0.27",
  "wasm-bindgen-shared",
 ]
 
 [[package]]
 name = "wasm-bindgen-futures"
-version = "0.4.36"
+version = "0.4.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2d1985d03709c53167ce907ff394f5316aa22cb4e12761295c5dc57dacb6297e"
+checksum = "c02dbc21516f9f1f04f187958890d7e6026df8d16540b7ad9492bc34a67cea03"
 dependencies = [
  "cfg-if",
  "js-sys",
  "wasm-bindgen",
  "web-sys",
 ]
 
 [[package]]
 name = "wasm-bindgen-macro"
-version = "0.2.86"
+version = "0.2.87"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "14d6b024f1a526bb0234f52840389927257beb670610081360e5a03c5df9c258"
+checksum = "dee495e55982a3bd48105a7b947fd2a9b4a8ae3010041b9e0faab3f9cd028f1d"
 dependencies = [
  "quote",
  "wasm-bindgen-macro-support",
 ]
 
 [[package]]
 name = "wasm-bindgen-macro-support"
-version = "0.2.86"
+version = "0.2.87"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e128beba882dd1eb6200e1dc92ae6c5dbaa4311aa7bb211ca035779e5efc39f8"
+checksum = "54681b18a46765f095758388f2d0cf16eb8d4169b639ab575a8f5693af210c7b"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.18",
+ "syn 2.0.27",
  "wasm-bindgen-backend",
  "wasm-bindgen-shared",
 ]
 
 [[package]]
 name = "wasm-bindgen-shared"
-version = "0.2.86"
+version = "0.2.87"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ed9d5b4305409d1fc9482fee2d7f9bcbf24b3972bf59817ef757e23982242a93"
+checksum = "ca6ad05a4870b2bf5fe995117d3728437bd27d7cd5f06f13c17443ef369775a1"
 
 [[package]]
 name = "wasm-timer"
 version = "0.2.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "be0ecb0db480561e9a7642b5d3e4187c128914e58aa84330b9493e3eb68c5e7f"
 dependencies = [
@@ -2450,17 +2511,17 @@
  "wasm-bindgen",
  "wasm-bindgen-futures",
  "web-sys",
 ]
 
 [[package]]
 name = "web-sys"
-version = "0.3.63"
+version = "0.3.64"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3bdd9ef4e984da1187bf8110c5cf5b845fbc87a23602cdf912386a76fcd3a7c2"
+checksum = "9b85cbef8c220a6abc02aefd892dfc0fc23afb1c6a426316ec33253a3877249b"
 dependencies = [
  "js-sys",
  "wasm-bindgen",
 ]
 
 [[package]]
 name = "winapi"
@@ -2486,169 +2547,112 @@
 
 [[package]]
 name = "windows"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e686886bc078bc1b0b600cac0147aadb815089b6e4da64016cbd754b6342700f"
 dependencies = [
- "windows-targets 0.48.0",
-]
-
-[[package]]
-name = "windows-sys"
-version = "0.45.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "75283be5efb2831d37ea142365f009c02ec203cd29a3ebecbc093d52315b66d0"
-dependencies = [
- "windows-targets 0.42.2",
+ "windows-targets",
 ]
 
 [[package]]
 name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
 dependencies = [
- "windows-targets 0.48.0",
+ "windows-targets",
 ]
 
 [[package]]
 name = "windows-targets"
-version = "0.42.2"
+version = "0.48.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8e5180c00cd44c9b1c88adb3693291f1cd93605ded80c250a75d472756b4d071"
+checksum = "05d4b17490f70499f20b9e791dcf6a299785ce8af4d709018206dc5b4953e95f"
 dependencies = [
- "windows_aarch64_gnullvm 0.42.2",
- "windows_aarch64_msvc 0.42.2",
- "windows_i686_gnu 0.42.2",
- "windows_i686_msvc 0.42.2",
- "windows_x86_64_gnu 0.42.2",
- "windows_x86_64_gnullvm 0.42.2",
- "windows_x86_64_msvc 0.42.2",
+ "windows_aarch64_gnullvm",
+ "windows_aarch64_msvc",
+ "windows_i686_gnu",
+ "windows_i686_msvc",
+ "windows_x86_64_gnu",
+ "windows_x86_64_gnullvm",
+ "windows_x86_64_msvc",
 ]
 
 [[package]]
-name = "windows-targets"
-version = "0.48.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7b1eb6f0cd7c80c79759c929114ef071b87354ce476d9d94271031c0497adfd5"
-dependencies = [
- "windows_aarch64_gnullvm 0.48.0",
- "windows_aarch64_msvc 0.48.0",
- "windows_i686_gnu 0.48.0",
- "windows_i686_msvc 0.48.0",
- "windows_x86_64_gnu 0.48.0",
- "windows_x86_64_gnullvm 0.48.0",
- "windows_x86_64_msvc 0.48.0",
-]
-
-[[package]]
-name = "windows_aarch64_gnullvm"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "597a5118570b68bc08d8d59125332c54f1ba9d9adeedeef5b99b02ba2b0698f8"
-
-[[package]]
 name = "windows_aarch64_gnullvm"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "91ae572e1b79dba883e0d315474df7305d12f569b400fcf90581b06062f7e1bc"
 
 [[package]]
 name = "windows_aarch64_msvc"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e08e8864a60f06ef0d0ff4ba04124db8b0fb3be5776a5cd47641e942e58c4d43"
-
-[[package]]
-name = "windows_aarch64_msvc"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b2ef27e0d7bdfcfc7b868b317c1d32c641a6fe4629c171b8928c7b08d98d7cf3"
 
 [[package]]
 name = "windows_i686_gnu"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c61d927d8da41da96a81f029489353e68739737d3beca43145c8afec9a31a84f"
-
-[[package]]
-name = "windows_i686_gnu"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "622a1962a7db830d6fd0a69683c80a18fda201879f0f447f065a3b7467daa241"
 
 [[package]]
 name = "windows_i686_msvc"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "44d840b6ec649f480a41c8d80f9c65108b92d89345dd94027bfe06ac444d1060"
-
-[[package]]
-name = "windows_i686_msvc"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "4542c6e364ce21bf45d69fdd2a8e455fa38d316158cfd43b3ac1c5b1b19f8e00"
 
 [[package]]
 name = "windows_x86_64_gnu"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8de912b8b8feb55c064867cf047dda097f92d51efad5b491dfb98f6bbb70cb36"
-
-[[package]]
-name = "windows_x86_64_gnu"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ca2b8a661f7628cbd23440e50b05d705db3686f894fc9580820623656af974b1"
 
 [[package]]
 name = "windows_x86_64_gnullvm"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "26d41b46a36d453748aedef1486d5c7a85db22e56aff34643984ea85514e94a3"
-
-[[package]]
-name = "windows_x86_64_gnullvm"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7896dbc1f41e08872e9d5e8f8baa8fdd2677f29468c4e156210174edc7f7b953"
 
 [[package]]
 name = "windows_x86_64_msvc"
-version = "0.42.2"
+version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9aec5da331524158c6d1a4ac0ab1541149c0b9505fde06423b02f5ef0106b9f0"
+checksum = "1a515f5799fe4961cb532f983ce2b23082366b898e52ffbce459c86f67c8378a"
 
 [[package]]
-name = "windows_x86_64_msvc"
-version = "0.48.0"
+name = "winnow"
+version = "0.5.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1a515f5799fe4961cb532f983ce2b23082366b898e52ffbce459c86f67c8378a"
+checksum = "25b5872fa2e10bd067ae946f927e726d7d603eaeb6e02fa6a350e0722d2b8c11"
+dependencies = [
+ "memchr",
+]
 
 [[package]]
 name = "xxhash-rust"
 version = "0.8.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "735a71d46c4d68d71d4b24d03fdc2b98e38cea81730595801db779c04fe80d70"
 
 [[package]]
 name = "zstd"
-version = "0.12.3+zstd.1.5.2"
+version = "0.12.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "76eea132fb024e0e13fd9c2f5d5d595d8a967aa72382ac2f9d39fcc95afd0806"
+checksum = "1a27595e173641171fc74a1232b7b1c7a7cb6e18222c11e9dfb9888fa424c53c"
 dependencies = [
  "zstd-safe",
 ]
 
 [[package]]
 name = "zstd-safe"
-version = "6.0.5+zstd.1.5.4"
+version = "6.0.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d56d9e60b4b1758206c238a10165fbcae3ca37b01744e394c463463f6529d23b"
+checksum = "ee98ffd0b48ee95e6c5168188e44a54550b1564d9d530ee21d5f0eaed1069581"
 dependencies = [
  "libc",
  "zstd-sys",
 ]
 
 [[package]]
 name = "zstd-sys"
```

### Comparing `polars_lts_cpu-0.18.8/PKG-INFO` & `polars_lts_cpu-0.18.9/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: polars-lts-cpu
-Version: 0.18.8
+Version: 0.18.9
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Environment :: Console
 Classifier: Intended Audience :: Science/Research
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3
```

#### html2text {}

```diff
@@ -1,8 +1,8 @@
-Metadata-Version: 2.1 Name: polars-lts-cpu Version: 0.18.8 Classifier:
+Metadata-Version: 2.1 Name: polars-lts-cpu Version: 0.18.9 Classifier:
 Development Status :: 5 - Production/Stable Classifier: Environment :: Console
 Classifier: Intended Audience :: Science/Research Classifier: License :: OSI
 Approved :: MIT License Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python Classifier: Programming Language ::
 Python :: 3 Classifier: Programming Language :: Python :: 3 :: Only Classifier:
 Programming Language :: Python :: 3.8 Classifier: Programming Language ::
 Python :: 3.9 Classifier: Programming Language :: Python :: 3.10 Classifier:
```

