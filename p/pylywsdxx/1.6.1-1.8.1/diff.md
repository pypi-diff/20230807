# Comparing `tmp/pylywsdxx-1.6.1.tar.gz` & `tmp/pylywsdxx-1.8.1.tar.gz`

## Comparing `pylywsdxx-1.6.1.tar` & `pylywsdxx-1.8.1.tar`

### file list

```diff
@@ -1,16 +1,16 @@
--rwxr-xr-x   0        0        0      214 2020-02-02 00:00:00.000000 pylywsdxx-1.6.1/.editorconfig
--rw-r--r--   0        0        0     2579 2020-02-02 00:00:00.000000 pylywsdxx-1.6.1/BUILDING.md
--rwxr-xr-x   0        0        0     2223 2020-02-02 00:00:00.000000 pylywsdxx-1.6.1/build
--rw-r--r--   0        0        0      602 2020-02-02 00:00:00.000000 pylywsdxx-1.6.1/tox.ini
--rw-r--r--   0        0        0      645 2020-02-02 00:00:00.000000 pylywsdxx-1.6.1/.github/dependabot.yml
--rwxr-xr-x   0        0        0     1228 2020-02-02 00:00:00.000000 pylywsdxx-1.6.1/examples/pylywsd02.py
--rwxr-xr-x   0        0        0      644 2020-02-02 00:00:00.000000 pylywsdxx-1.6.1/examples/pylywsd03mmc.py
--rwxr-xr-x   0        0        0     1083 2020-02-02 00:00:00.000000 pylywsdxx-1.6.1/examples/pylywsd03mmc2csv.py
--rw-r--r--   0        0        0      201 2020-02-02 00:00:00.000000 pylywsdxx-1.6.1/src/pylywsdxx/__init__.py
--rw-r--r--   0        0        0      670 2020-02-02 00:00:00.000000 pylywsdxx-1.6.1/src/pylywsdxx/bt_hardware.py
--rw-r--r--   0        0        0    12712 2020-02-02 00:00:00.000000 pylywsdxx-1.6.1/src/pylywsdxx/client.py
--rwxr-xr-x   0        0        0     1906 2020-02-02 00:00:00.000000 pylywsdxx-1.6.1/.gitignore
--rw-r--r--   0        0        0     1084 2020-02-02 00:00:00.000000 pylywsdxx-1.6.1/LICENSE
--rw-r--r--   0        0        0     1630 2020-02-02 00:00:00.000000 pylywsdxx-1.6.1/README.md
--rw-r--r--   0        0        0      972 2020-02-02 00:00:00.000000 pylywsdxx-1.6.1/pyproject.toml
--rw-r--r--   0        0        0     2480 2020-02-02 00:00:00.000000 pylywsdxx-1.6.1/PKG-INFO
+-rwxr-xr-x   0        0        0      214 2020-02-02 00:00:00.000000 pylywsdxx-1.8.1/.editorconfig
+-rw-r--r--   0        0        0     2579 2020-02-02 00:00:00.000000 pylywsdxx-1.8.1/BUILDING.md
+-rwxr-xr-x   0        0        0     2223 2020-02-02 00:00:00.000000 pylywsdxx-1.8.1/build
+-rw-r--r--   0        0        0      602 2020-02-02 00:00:00.000000 pylywsdxx-1.8.1/tox.ini
+-rw-r--r--   0        0        0      645 2020-02-02 00:00:00.000000 pylywsdxx-1.8.1/.github/dependabot.yml
+-rwxr-xr-x   0        0        0     1228 2020-02-02 00:00:00.000000 pylywsdxx-1.8.1/examples/pylywsd02.py
+-rwxr-xr-x   0        0        0      644 2020-02-02 00:00:00.000000 pylywsdxx-1.8.1/examples/pylywsd03mmc.py
+-rwxr-xr-x   0        0        0     1083 2020-02-02 00:00:00.000000 pylywsdxx-1.8.1/examples/pylywsd03mmc2csv.py
+-rw-r--r--   0        0        0      425 2020-02-02 00:00:00.000000 pylywsdxx-1.8.1/src/pylywsdxx/__init__.py
+-rw-r--r--   0        0        0      670 2020-02-02 00:00:00.000000 pylywsdxx-1.8.1/src/pylywsdxx/bt_hardware.py
+-rw-r--r--   0        0        0    14464 2020-02-02 00:00:00.000000 pylywsdxx-1.8.1/src/pylywsdxx/client.py
+-rwxr-xr-x   0        0        0     1906 2020-02-02 00:00:00.000000 pylywsdxx-1.8.1/.gitignore
+-rw-r--r--   0        0        0     1084 2020-02-02 00:00:00.000000 pylywsdxx-1.8.1/LICENSE
+-rw-r--r--   0        0        0     1630 2020-02-02 00:00:00.000000 pylywsdxx-1.8.1/README.md
+-rw-r--r--   0        0        0     1010 2020-02-02 00:00:00.000000 pylywsdxx-1.8.1/pyproject.toml
+-rw-r--r--   0        0        0     2430 2020-02-02 00:00:00.000000 pylywsdxx-1.8.1/PKG-INFO
```

### Comparing `pylywsdxx-1.6.1/BUILDING.md` & `pylywsdxx-1.8.1/BUILDING.md`

 * *Files identical despite different names*

### Comparing `pylywsdxx-1.6.1/build` & `pylywsdxx-1.8.1/build`

 * *Files identical despite different names*

### Comparing `pylywsdxx-1.6.1/tox.ini` & `pylywsdxx-1.8.1/tox.ini`

 * *Files identical despite different names*

### Comparing `pylywsdxx-1.6.1/.github/dependabot.yml` & `pylywsdxx-1.8.1/.github/dependabot.yml`

 * *Files identical despite different names*

### Comparing `pylywsdxx-1.6.1/examples/pylywsd02.py` & `pylywsdxx-1.8.1/examples/pylywsd02.py`

 * *Files identical despite different names*

### Comparing `pylywsdxx-1.6.1/examples/pylywsd03mmc.py` & `pylywsdxx-1.8.1/examples/pylywsd03mmc.py`

 * *Files identical despite different names*

### Comparing `pylywsdxx-1.6.1/examples/pylywsd03mmc2csv.py` & `pylywsdxx-1.8.1/examples/pylywsd03mmc2csv.py`

 * *Files identical despite different names*

### Comparing `pylywsdxx-1.6.1/src/pylywsdxx/bt_hardware.py` & `pylywsdxx-1.8.1/src/pylywsdxx/bt_hardware.py`

 * *Files identical despite different names*

### Comparing `pylywsdxx-1.6.1/src/pylywsdxx/client.py` & `pylywsdxx-1.8.1/src/pylywsdxx/client.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,34 +1,58 @@
 #!/usr/bin/env python3
 
 import collections
 import contextlib
-import logging
+import warnings
 import struct
 import time
 from datetime import datetime, timedelta
 
 from bluepy3 import btle  # noqa
 
-_LOGGER = logging.getLogger(__name__)
-
 UUID_UNITS = "EBE0CCBE-7A0A-4B0C-8A1A-6FF2997DA3A6"  # _       0x00 - F, 0x01 - C    READ WRITE
 UUID_HISTORY = "EBE0CCBC-7A0A-4B0C-8A1A-6FF2997DA3A6"  # _     Last idx 152          READ NOTIFY
 UUID_HISTORY_3 = "EBE0CCBC-7A0A-4B0C-8A1A-6FF2997DA3A6"  # _   Last idx 152          READ NOTIFY
 UUID_TIME = "EBE0CCB7-7A0A-4B0C-8A1A-6FF2997DA3A6"  # _        5 or 4 bytes          READ WRITE
 UUID_DATA = "EBE0CCC1-7A0A-4B0C-8A1A-6FF2997DA3A6"  # _        3 bytes               READ NOTIFY
 UUID_BATTERY = "EBE0CCC4-7A0A-4B0C-8A1A-6FF2997DA3A6"  # _     1 byte                READ
 UUID_NUM_RECORDS = "EBE0CCB9-7A0A-4B0C-8A1A-6FF2997DA3A6"  # _ 8 bytes               READ
 UUID_RECORD_IDX = "EBE0CCBA-7A0A-4B0C-8A1A-6FF2997DA3A6"  # _  4 bytes               READ WRITE
 
 
+class PyLyException(Exception):
+    """Base class for all pylywsdxx exceptions"""
+
+    def __init__(self, message):
+        self.message = message
+
+    def __str__(self):
+        msg = f"(pylywsdxx) {self.message}"
+        return msg
+
+
+class PyLyTimeout(PyLyException):
+    def __init__(self, message):
+        PyLyException.__init__(self, message)
+
+
+class PyLyConnectError(PyLyException):
+    def __init__(self, message):
+        PyLyException.__init__(self, message)
+
+class PyLyValueError(PyLyException):
+    def __init__(self, message):
+        PyLyException.__init__(self, message)
+
+
 class SensorData(
     collections.namedtuple("SensorDataBase", ["temperature", "humidity", "battery", "voltage"])
 ):
-    """Class to store sensor data..
+    """Class to store sensor data.
+    For LYWSD02 devices temperature and humidity readings are available.
     For LYWSD03MMC devices also battery information is available.
     """
 
     __slots__ = ()
 
 
 class Lywsd02client:  # pylint: disable=R0902
@@ -51,71 +75,154 @@
         self._notification_timeout = notification_timeout
         self._handles = {}
         self._tz_offset = None
         self._data = SensorData(None, None, None, None)
         self._history_data = collections.OrderedDict()
         self._context_depth = 0
 
+    def _get_history_data(self):
+        with self.connect():
+            self._subscribe(UUID_HISTORY, self._process_history_data)
+
+            while True:
+                if not self._peripheral.waitForNotifications(self._notification_timeout):
+                    if self.debug:
+                        print(f"|-- Timeout waiting for {self._mac}")
+                    break
+
+    def _get_sensor_data(self):
+        with self.connect():
+            self._subscribe(UUID_DATA, self._process_sensor_data)
+
+            if not self._peripheral.waitForNotifications(self._notification_timeout):
+                raise TimeoutError(
+                    f"(pylywsdxx.client.py) No data from device for {self._notification_timeout} seconds"
+                )
+
+    def _process_history_data(self, data):
+        (idx, ts, max_temp, max_hum, min_temp, min_hum) = struct.unpack_from("<IIhBhB", data)
+
+        ts = datetime.fromtimestamp(ts)
+        min_temp /= 100
+        max_temp /= 100
+
+        self._history_data[idx] = [ts, min_temp, min_hum, max_temp, max_hum]
+
+    def _process_sensor_data(self, data):
+        temperature, humidity = struct.unpack_from("hB", data)
+        temperature /= 100
+        self._data = SensorData(
+            temperature=temperature, humidity=humidity, battery=None, voltage=None
+        )
+
+    def _subscribe(self, uuid, callback):
+        self._peripheral.setDelegate(self)
+        ch = self._peripheral.getCharacteristics(uuid=uuid)[0]
+        self._handles[ch.getHandle()] = callback
+        desc = ch.getDescriptors(forUUID=0x2902)[0]
+
+        desc.write(0x01.to_bytes(2, byteorder="little"), withResponse=True)
+
+    def handleNotification(self, handle, data):  # noqa - FIXME: why name of method can't be changed (?!)
+        func = self._handles.get(handle)
+        if func:
+            func(data)
+
     @contextlib.contextmanager
     def connect(self):
         """Handle device connecting and disconnecting"""
         if self._context_depth == 0:
             if self.debug:
                 print(f"|-> Connecting to {self._mac}")
-            self._peripheral.connect(addr=self._mac, timeout=self._notification_timeout)
-            # TO DO: consider to catch connection errors here
-            # kimnaty.kimnaty[1372]: *** While talking to room 1.1 (A4:C1:38:6F:E7:CA) an error occured on 2023-04-15 18:20:35
-            # kimnaty.kimnaty[1372]:      -btle- Timed out while trying to connect to peripheral A4:C1:38:6F:E7:CA, addr type: public, interface None, >
+            try:
+                self._peripheral.connect(addr=self._mac, timeout=self._notification_timeout)
+            except btle.BTLEConnectTimeout as her:
+                # Catch connection errors here
+                # warnings.warn(
+                #     f"(pylywsdxx.connect) An exception of type {type(her).__name__} occured ({self._mac}).",
+                #     RuntimeWarning,
+                #     stacklevel=2,
+                # )
+                # re-raise for now
+                raise PyLyTimeout(f"-- {her} --") from her
+            except btle.BTLEConnectError as her:
+                # warnings.warn(
+                #     f"(pylywsdxx.connect) An exception of type {type(her).__name__} occured ({self._mac}).",
+                #     RuntimeWarning,
+                #     stacklevel=2,
+                # )
+                # re-raise for now
+                raise PyLyConnectError(f"-- {her} --") from her
+            except Exception as her:
+                # warnings.warn(
+                #     f"(pylywsdxx.connect) An exception of type {type(her).__name__} occured ({self._mac}).",
+                #     RuntimeWarning,
+                #     stacklevel=2,
+                # )
+                raise PyLyException(f"-- {her} --") from her
+
         self._context_depth += 1
         try:
             yield self
         except Exception as her:
-            print(f"(pylywsdxx.client) An exception of type {type(her).__name__} occured")
+            # print(f"(pylywsdxx.client) An exception of type {type(her).__name__} occured")
+            warnings.warn(f"(pylywsdxx.client) An exception of type {type(her).__name__} occured", RuntimeWarning, stacklevel=2)
         finally:
             self._context_depth -= 1
             if self._context_depth == 0:
                 if self.debug:
                     print(f"|-< Disconnecting from {self._mac}")
                 self._peripheral.disconnect()
 
     @property
-    def temperature(self):
-        return self.data.temperature
-
-    @property
-    def humidity(self):
-        return self.data.humidity
+    def battery(self):
+        with self.connect():
+            ch = self._peripheral.getCharacteristics(uuid=UUID_BATTERY)[0]
+            value = ch.read()
+        return ord(value)
 
     @property
     def data(self):
         self._get_sensor_data()
         return self._data
 
     @property
-    def units(self):
-        with self.connect():
-            ch = self._peripheral.getCharacteristics(uuid=UUID_UNITS)[0]
-            value = ch.read()
-        return self.UNITS[value]
+    def history_data(self):
+        self._get_history_data()
+        return self._history_data
 
-    @units.setter
-    def units(self, value):
-        if value.upper() not in self.UNITS_CODES:
-            raise ValueError(f"(pylywsdxx.client.py) Units value must be one of {self.UNITS_CODES.keys()}")
+    @property
+    def humidity(self):
+        return self.data.humidity
 
+    @property
+    def num_stored_entries(self):
         with self.connect():
-            ch = self._peripheral.getCharacteristics(uuid=UUID_UNITS)[0]
-            ch.write(self.UNITS_CODES[value.upper()], withResponse=True)
+            ch = self._peripheral.getCharacteristics(uuid=UUID_NUM_RECORDS)[0]
+            value = ch.read()
+        total_records, current_records = struct.unpack_from("II", value)
+        return total_records, current_records
 
     @property
-    def battery(self):
+    def temperature(self):
+        return self.data.temperature
+
+    @property
+    def history_index(self):
         with self.connect():
-            ch = self._peripheral.getCharacteristics(uuid=UUID_BATTERY)[0]
+            ch = self._peripheral.getCharacteristics(uuid=UUID_RECORD_IDX)[0]
             value = ch.read()
-        return ord(value)
+        _idx = 0 if len(value) == 0 else struct.unpack_from("I", value)
+        return _idx
+
+    @history_index.setter
+    def history_index(self, value):
+        with self.connect():
+            ch = self._peripheral.getCharacteristics(uuid=UUID_RECORD_IDX)[0]
+            ch.write(struct.pack("I", value), withResponse=True)
 
     @property
     def time(self):
         with self.connect():
             ch = self._peripheral.getCharacteristics(uuid=UUID_TIME)[0]
             value = ch.read()
         if len(value) == 5:
@@ -141,140 +248,58 @@
         return -time.timezone // 3600
 
     @tz_offset.setter
     def tz_offset(self, tz_offset: int):
         self._tz_offset = tz_offset
 
     @property
-    def history_index(self):
-        with self.connect():
-            ch = self._peripheral.getCharacteristics(uuid=UUID_RECORD_IDX)[0]
-            value = ch.read()
-        _idx = 0 if len(value) == 0 else struct.unpack_from("I", value)
-        return _idx
-
-    @history_index.setter
-    def history_index(self, value):
-        with self.connect():
-            ch = self._peripheral.getCharacteristics(uuid=UUID_RECORD_IDX)[0]
-            ch.write(struct.pack("I", value), withResponse=True)
-
-    @property
-    def num_stored_entries(self):
+    def units(self):
         with self.connect():
-            ch = self._peripheral.getCharacteristics(uuid=UUID_NUM_RECORDS)[0]
+            ch = self._peripheral.getCharacteristics(uuid=UUID_UNITS)[0]
             value = ch.read()
-        total_records, current_records = struct.unpack_from("II", value)
-        return total_records, current_records
-
-    @property
-    def history_data(self):
-        self._get_history_data()
-        return self._history_data
-
-    def _get_sensor_data(self):
-        with self.connect():
-            self._subscribe(UUID_DATA, self._process_sensor_data)
+        return self.UNITS[value]
 
-            if not self._peripheral.waitForNotifications(self._notification_timeout):
-                raise TimeoutError(
-                    f"(pylywsdxx.client.py) No data from device for {self._notification_timeout} seconds"
-                )
+    @units.setter
+    def units(self, value):
+        if value.upper() not in self.UNITS_CODES:
+            raise PyLyValueError(f"Units value must be one of {self.UNITS_CODES.keys()}")
 
-    def _get_history_data(self):
         with self.connect():
-            self._subscribe(UUID_HISTORY, self._process_history_data)
-
-            while True:
-                if not self._peripheral.waitForNotifications(self._notification_timeout):
-                    if self.debug:
-                        print(f"|-- Timeout waiting for {self._mac}")
-                    break
-
-    def handleNotification(self, handle, data):
-        func = self._handles.get(handle)
-        if func:
-            func(data)
-
-    def _subscribe(self, uuid, callback):
-        self._peripheral.setDelegate(self)
-        ch = self._peripheral.getCharacteristics(uuid=uuid)[0]
-        self._handles[ch.getHandle()] = callback
-        desc = ch.getDescriptors(forUUID=0x2902)[0]
-
-        desc.write(0x01.to_bytes(2, byteorder="little"), withResponse=True)
-
-    def _process_sensor_data(self, data):
-        temperature, humidity = struct.unpack_from("hB", data)
-        temperature /= 100
-        self._data = SensorData(
-            temperature=temperature, humidity=humidity, battery=None, voltage=None
-        )
-
-    def _process_history_data(self, data):
-        (idx, ts, max_temp, max_hum, min_temp, min_hum) = struct.unpack_from("<IIhBhB", data)
-
-        ts = datetime.fromtimestamp(ts)
-        min_temp /= 100
-        max_temp /= 100
-
-        self._history_data[idx] = [ts, min_temp, min_hum, max_temp, max_hum]
+            ch = self._peripheral.getCharacteristics(uuid=UUID_UNITS)[0]
+            ch.write(self.UNITS_CODES[value.upper()], withResponse=True)
 
 
 class Lywsd03client(Lywsd02client):
     """Class to communicate with LYWSD03MMC devices."""
 
     # Temperature units specific to LYWSD03MMC devices
     UNITS = {b"\x01": "F", b"\x00": "C"}
     UNITS_CODES = {"F": b"\x01", "C": b"\x00"}
 
+    # CR2025 / CR2032 maximum theoretical voltage = 3.4 V
+    # ref. Table 1;
+    #  CR2025: https://www.farnell.com/datasheets/1496883.pdf
+    #  CR2032: https://www.farnell.com/datasheets/1496885.pdf
+    # Lowest voltage for these batteries is 2.0 V but the BT radio
+    # on most devices will stop working when below 2.3 V (YMMV).
+    BATTERY_FULL = 3.4
+    BATTERY_LOW = 2.1
+
     # Locally cache the start time of the device.
     # This value won't change, and caching improves the performance getting the history data
     _start_time = False
 
     # Getting history data is very slow, so don't output progress updates
     enable_history_progress = False
 
     # Call the parent init with a bigger notification timeout
     def __init__(self, mac, notification_timeout=12.3, debug=False):
         super().__init__(mac=mac, notification_timeout=notification_timeout, debug=debug)
         self._latest_record = None
 
-    def _process_sensor_data(self, data):
-        """Process the sensor data.
-
-        Args:
-            data (struct): struct containing sensor data
-        """
-        temperature, humidity, voltage = struct.unpack_from("<hBh", data)
-        temperature /= 100
-        voltage /= 1000
-        battery = round(((voltage - 2.1) / (3.4 - 2.1) * 100), 1)
-        """float: Estimate percentage of the battery charge remaining
-        CR2025 / CR2032 maximum theoretical voltage = 3.4 V
-        ref. Table 1;
-         CR2025: https://www.farnell.com/datasheets/1496883.pdf
-         CR2032: https://www.farnell.com/datasheets/1496885.pdf
-        Lowest voltage for these batteries is 2.0 V but the BT radio
-        on most devices will stop working when below 2.3 V (YMMV).
-        """
-        self._data = SensorData(
-            temperature=temperature, humidity=humidity, battery=battery, voltage=voltage
-        )
-
-    @property
-    def battery(self):
-        """
-        Battery data comes along with the temperature and humidity data, so just get it from there.
-
-        Returns:
-             guestimate of battery percentage
-        """
-        return self.data.battery
-
     def _get_history_data(self):
         # FIXME: Get the time the device was first run
         # self.start_time
 
         # Work out the expected last record we'll be sent from the device.
         # The current hour doesn't appear until the end of the hour, and the time is recorded as
         # the end of hour time
@@ -303,20 +328,45 @@
         min_temp /= 10
         max_temp /= 10
 
         self._latest_record = ts
         self._history_data[idx] = [ts, min_temp, min_hum, max_temp, max_hum]
         self.output_history_progress(ts, min_temp, max_temp)
 
+    def _process_sensor_data(self, data):
+        """Process the sensor data.
+
+        Args:
+            data (struct): struct containing sensor data
+        """
+        temperature, humidity, voltage = struct.unpack_from("<hBh", data)
+        temperature /= 100
+        voltage /= 1000
+        # battery (float): Estimate percentage of the battery charge remaining
+        battery = round(((voltage - self.BATTERY_LOW) / (self.BATTERY_FULL - self.BATTERY_LOW) * 100), 1)
+        self._data = SensorData(
+            temperature=temperature, humidity=humidity, battery=battery, voltage=voltage
+        )
+
     def output_history_progress(self, ts, min_temp, max_temp):
         if not self.enable_history_progress:
             return
         print(f"|-- {ts}: {min_temp} to {max_temp}")
 
     @property
+    def battery(self):
+        """
+        Battery data comes along with the temperature and humidity data, so just get it from there.
+
+        Returns:
+             guestimate of battery percentage
+        """
+        return self.data.battery
+
+    @property
     def start_time(self):
         """Work out the start time of the device.
         This is done by taking the current time, subtracting the time
         taken from the device (the run time), and adding the timezone offset.
 
         Returns:
             datetime: the start time of the device
@@ -327,24 +377,28 @@
             )
             self._start_time = datetime.now() - start_time_delta
         return self._start_time
 
     @property
     def time(self):
         """Fetch datetime and timezone of a LYWSD03MMC device
+
         Returns:
-           device's current datetime and timezone
+           Device's current datetime and timezone
         """
         return super().time
 
     @time.setter
     def time(self, dt: datetime):  # pylint: disable=W0613
         """Disable setting the time and timezone.
         LYWSD03MMCs don't have visible clocks.
 
+        Args:
+            dt (datetime): Does nothing
+
         Returns:
             Nothing
         """
         return
 
     @property
     def tz_offset(self):
```

### Comparing `pylywsdxx-1.6.1/.gitignore` & `pylywsdxx-1.8.1/.gitignore`

 * *Files identical despite different names*

### Comparing `pylywsdxx-1.6.1/LICENSE` & `pylywsdxx-1.8.1/LICENSE`

 * *Files identical despite different names*

### Comparing `pylywsdxx-1.6.1/README.md` & `pylywsdxx-1.8.1/README.md`

 * *Files identical despite different names*

### Comparing `pylywsdxx-1.6.1/pyproject.toml` & `pylywsdxx-1.8.1/pyproject.toml`

 * *Files 17% similar despite different names*

```diff
@@ -4,29 +4,29 @@
 [build-system]
 requires = ["hatchling"]
 build-backend = "hatchling.build"
 
 [project]
 name = "pylywsdxx"
 description = "A Python3 class to interrogate Xiaomi Mijia LYWSD* sensors."
-version = "1.6.1"
+version = "1.8.1"  # latest/current distribution version
+# version = "1.7.22"  # latest test version
 dependencies = [
     "bluepy3",
 ]
 license = "MIT"
 authors = [
   { name="Mausy5043" },
 ]
 readme = "README.md"
-requires-python = ">=3.7"
+requires-python = ">=3.8"
 classifiers = [
     "Development Status :: 5 - Production/Stable",
     "License :: OSI Approved :: MIT License",
     "Operating System :: OS Independent",
-    "Programming Language :: Python :: 3.7",
     "Programming Language :: Python :: 3.8",
     "Programming Language :: Python :: 3.9",
     "Programming Language :: Python :: 3.10",
     "Programming Language :: Python :: 3.11",
     "Topic :: Home Automation"
 ]
```

### Comparing `pylywsdxx-1.6.1/PKG-INFO` & `pylywsdxx-1.8.1/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,26 +1,25 @@
 Metadata-Version: 2.1
 Name: pylywsdxx
-Version: 1.6.1
+Version: 1.8.1
 Summary: A Python3 class to interrogate Xiaomi Mijia LYWSD* sensors.
 Project-URL: Homepage, https://github.com/Mausy5043/pylywsdxx
 Project-URL: Bug Tracker, https://github.com/Mausy5043/pylywsdxx/issues
 Author: Mausy5043
 License-Expression: MIT
 License-File: LICENSE
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
-Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
 Classifier: Topic :: Home Automation
-Requires-Python: >=3.7
+Requires-Python: >=3.8
 Requires-Dist: bluepy3
 Description-Content-Type: text/markdown
 
 # pylywsdxx
 
 
 [![PyPI version](https://img.shields.io/pypi/v/pylywsdxx.svg?logo=pypi&logoColor=FFE873)](https://pypi.org/project/pylywsdxx)
```

