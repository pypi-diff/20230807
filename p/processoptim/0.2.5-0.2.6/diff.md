# Comparing `tmp/processoptim-0.2.5-py3-none-any.whl.zip` & `tmp/processoptim-0.2.6-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,28 +1,28 @@
-Zip file size: 9722099 bytes, number of entries: 75
+Zip file size: 9722643 bytes, number of entries: 75
 -rw-rw-rw-  2.0 fat     2527 b- defN 22-Sep-12 06:37 processoptim/__colors__.py
 -rw-rw-rw-  2.0 fat      914 b- defN 22-Oct-27 09:50 processoptim/__disp__.py
 -rw-rw-rw-  2.0 fat      569 b- defN 23-Aug-04 07:30 processoptim/__init__.py
 -rw-rw-rw-  2.0 fat      185 b- defN 20-Sep-16 03:14 processoptim/__main__.py
--rw-rw-rw-  2.0 fat      112 b- defN 23-Aug-03 18:59 processoptim/__version__.py
--rw-rw-rw-  2.0 fat     1036 b- defN 23-Aug-04 10:59 processoptim/config.json
+-rw-rw-rw-  2.0 fat      112 b- defN 23-Aug-07 04:34 processoptim/__version__.py
+-rw-rw-rw-  2.0 fat     1124 b- defN 23-Aug-07 04:34 processoptim/config.json
 -rw-rw-rw-  2.0 fat      261 b- defN 22-Oct-04 14:48 processoptim/equilibrium.py
 -rw-rw-rw-  2.0 fat    18793 b- defN 23-Jun-17 20:48 processoptim/process_schema.json
 -rw-rw-rw-  2.0 fat    24709 b- defN 22-Nov-01 11:14 processoptim/processes.py
 -rw-rw-rw-  2.0 fat       91 b- defN 22-Oct-04 14:57 processoptim/test.py
 -rw-rw-rw-  2.0 fat     4112 b- defN 22-Sep-25 03:50 processoptim/thermo_properties.py
 -rw-rw-rw-  2.0 fat    25588 b- defN 23-Aug-03 10:57 processoptim/tomato_flowsheet.py
 -rw-rw-rw-  2.0 fat      275 b- defN 22-Oct-05 03:18 processoptim/data/ethanol_water_equilibrium_1bar.txt
 -rw-rw-rw-  2.0 fat       87 b- defN 22-Oct-12 18:54 processoptim/data/kineticA.txt
 -rw-rw-rw-  2.0 fat      115 b- defN 22-Oct-06 12:20 processoptim/data/soybean_hexane_equilibrium.txt
 -rw-rw-rw-  2.0 fat     7681 b- defN 23-Feb-20 11:03 processoptim/membrane/membrane.json
 -rw-rw-rw-  2.0 fat    15795 b- defN 23-Feb-21 03:47 processoptim/membrane/membrane.py
 -rw-rw-rw-  2.0 fat      944 b- defN 23-Jun-17 21:14 processoptim/membrane/solutes.json
 -rw-rw-rw-  2.0 fat     1089 b- defN 23-Aug-02 08:31 processoptim/pylca/demo1.py
--rw-rw-rw-  2.0 fat     6207 b- defN 23-Aug-04 16:53 processoptim/pylca/lca.py
+-rw-rw-rw-  2.0 fat     8479 b- defN 23-Aug-05 18:59 processoptim/pylca/lca.py
 -rw-rw-rw-  2.0 fat     3141 b- defN 23-Aug-04 13:52 processoptim/pylca/uiinv.py
 -rw-rw-rw-  2.0 fat   197199 b- defN 23-Aug-04 04:35 processoptim/pylca/lci/02022e70-bffc-4480-9eac-459f0bbe6e92.json
 -rw-rw-rw-  2.0 fat   197256 b- defN 23-Aug-04 04:35 processoptim/pylca/lci/05821736-211a-40a2-9f63-762548248989.json
 -rw-rw-rw-  2.0 fat   182580 b- defN 23-Aug-04 04:35 processoptim/pylca/lci/0d7ba7b3-7138-41ff-853e-1aaefc48e94a.json
 -rw-rw-rw-  2.0 fat   188657 b- defN 23-Aug-04 16:21 processoptim/pylca/lci/1c463da1-049a-4610-a332-f87712e4aa5f.json
 -rw-rw-rw-  2.0 fat   197242 b- defN 23-Aug-04 04:35 processoptim/pylca/lci/274e1bbe-ea78-45ea-9b11-b4653e2e3114.json
 -rw-rw-rw-  2.0 fat   182619 b- defN 23-Aug-04 04:35 processoptim/pylca/lci/2957be63-2bee-408f-aad2-a31c179876c9.json
@@ -65,13 +65,13 @@
 -rw-rw-rw-  2.0 fat   197262 b- defN 23-Aug-04 04:35 processoptim/pylca/lci/f6cdf632-5fd7-4ce6-a6a8-05160a986d3b.json
 -rw-rw-rw-  2.0 fat   182458 b- defN 23-Aug-04 04:35 processoptim/pylca/lci/fac6b14f-829d-4f83-aaed-9cbd9a1cae31.json
 -rw-rw-rw-  2.0 fat   199818 b- defN 23-Aug-04 16:21 processoptim/pylca/lci/fc1b5051-1bbc-4263-883c-1a6ffd768447.json
 -rw-rw-rw-  2.0 fat   197190 b- defN 23-Aug-04 04:35 processoptim/pylca/lci/fcb1767f-4a59-41d3-857f-1b6739212562.json
 -rw-rw-rw-  2.0 fat   197200 b- defN 23-Aug-04 04:35 processoptim/pylca/lci/fdf6e134-780e-4119-bbe5-998071b59704.json
 -rw-rw-rw-  2.0 fat  1466310 b- defN 23-Aug-02 15:03 processoptim/pylca/methods/CML-IA baseline.json
 -rw-rw-rw-  2.0 fat 17559064 b- defN 23-Aug-03 08:37 processoptim/pylca/methods/EF 3.0 Method (adapted).json
--rw-rw-rw-  2.0 fat     1093 b- defN 23-Aug-04 17:35 processoptim-0.2.5.dist-info/LICENSE.txt
--rw-rw-rw-  2.0 fat     1910 b- defN 23-Aug-04 17:35 processoptim-0.2.5.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Aug-04 17:35 processoptim-0.2.5.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       13 b- defN 23-Aug-04 17:35 processoptim-0.2.5.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     8237 b- defN 23-Aug-04 17:35 processoptim-0.2.5.dist-info/RECORD
-75 files, 28265344 bytes uncompressed, 9708523 bytes compressed:  65.7%
+-rw-rw-rw-  2.0 fat     1093 b- defN 23-Aug-07 04:35 processoptim-0.2.6.dist-info/LICENSE.txt
+-rw-rw-rw-  2.0 fat     1910 b- defN 23-Aug-07 04:35 processoptim-0.2.6.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Aug-07 04:35 processoptim-0.2.6.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       13 b- defN 23-Aug-07 04:35 processoptim-0.2.6.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     8237 b- defN 23-Aug-07 04:35 processoptim-0.2.6.dist-info/RECORD
+75 files, 28267704 bytes uncompressed, 9709067 bytes compressed:  65.7%
```

## zipnote {}

```diff
@@ -204,23 +204,23 @@
 
 Filename: processoptim/pylca/methods/CML-IA baseline.json
 Comment: 
 
 Filename: processoptim/pylca/methods/EF 3.0 Method (adapted).json
 Comment: 
 
-Filename: processoptim-0.2.5.dist-info/LICENSE.txt
+Filename: processoptim-0.2.6.dist-info/LICENSE.txt
 Comment: 
 
-Filename: processoptim-0.2.5.dist-info/METADATA
+Filename: processoptim-0.2.6.dist-info/METADATA
 Comment: 
 
-Filename: processoptim-0.2.5.dist-info/WHEEL
+Filename: processoptim-0.2.6.dist-info/WHEEL
 Comment: 
 
-Filename: processoptim-0.2.5.dist-info/top_level.txt
+Filename: processoptim-0.2.6.dist-info/top_level.txt
 Comment: 
 
-Filename: processoptim-0.2.5.dist-info/RECORD
+Filename: processoptim-0.2.6.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## processoptim/__version__.py

```diff
@@ -1,8 +1,8 @@
 # -*- coding: utf-8 -*-
 """
 Created on Mon Mar 23 08:58:58 2020
 
 @author: HEDI
 """
 
-__version__ = '0.2.5'
+__version__ = '0.2.6'
```

## processoptim/config.json

```diff
@@ -1 +1 @@
-gAAAAABkzNoTFEehZDUiTWfu4nUm5AchwnIHx85p69K1twVCdIaQr_StkbcuBHpflQtpY3RJsN-yafpSWvQqQwIlCSKAWl47fVmJ7I0WGEOCF14W-E0ViPnRps10YVg2Z85-tLb_iFHDJjvQ2jq7TswFLrVcXRdoliir6NW4-KOxOqXtFWz35tdEdVZd7duNfnn5bjH8dVJ8PiivpUPV7mhNT_j2j3YnoINjmsqyxcYBpJ1YcioffUi0y1TBwRZdy-M8nk8nQsIJZfP9MmbpNURyCuchwUX4gHP-6A0iAeW0FgStz1Jug4TpS2ZZKwPaCMCPGJEuGRocBl7OpGo6_-634cd52z3l5aMUMWmH2mLtErWNg8_BcSVwQ5cjP3q5En3AoZSQ6FPcA9ax5U0NdnZrNYumkXkBko3DFBJkcou3VWKR9OsPdWB-5tUD_WvRyvhllUsH3s3sHo0Z0uME8mWy7xhWSjtsDzGV1K04DjWkssHk2RLjIepOQxAYl94fdFkhLRh5Jq7MxYIZ_ipdolhOSQc13Z446Zm7dEnxF_rTCpXVONSAGEH3BB2wHk65B6bAWGkuXAr_m2Yie6IBZAJUEnWHl_LEriTX_4uoXqkkc1v0TnoEovArsP6_vLyNmPQQlwfnRcnYOxIQYqzKkKbTMmMJCOys_rRjcsv3PMJMpYJBKJlg7uUKOht0KDchyQECIu5NzQVy3YMs_uEer_lw4Ehsy6VVx1iJF_KqHXOqpErZUtJLjEVsR0DCINeD1QTKB7vK_fL6Y-1ZJthuUOjwpj4MC1kCk5mWe8ACz4-WcaBf_IkVSwgt_CvNQcEspk31x53-R7EFKkpLQGnfslHiZ7ORgMvvcKIXShZkjPTaZPth5x-4r0USPbzJhQEpv9mAbmz6-H9UErOMXH7IR4DvX8egGOWzs_I6glzpdZL4Y3gNb4svFSpayQKElL8mqIQEB1xap4YU9qHQ8teDcrsMQNciAUSA8vetv2qX_ESVx6PKCpezYNFFOfQ6TwOtJxavHQ6Lqgye
+gAAAAABk0HRbujMq2hJAYSyzzQ0AVmPGzAPKzeOSFQGx49JnAATNzciwj3NAov1uAb6loqZkCnmiFqVOAAAWkvw2g54feNejEqTURY_ep-ORGZR73ItpPec76C772U7jrvtN4x5cA_mU_P3VvCikeC1xSO9_n5fBi-ZbD8amZBh357rJDMMH0XbjbbQ2MBIlRFQCJpIQHDAHVuPakPayi-dmdFI8phHAqJ5mrBcLg7HwXMO9BEh0s8BrcI7M-SK5g1gYeSIlkwvjfpE1sWhAmC0G7TlAW2MOjTXDJ2h93eIvBjJ4KcwS-lXqT65cDT8D4YS42zgZhrwKecOPGwSAvtV7c6hpQHrQ3v_t3_E7lwQ_Ro3btyEFwJjCzM2kJT_8OVd5f9jNr4Q73pZgDE7kRFdMnxQaFaMhjEX2EG0EzdzPE2LU7s7GrkNVHMD34q7GE0OCJJRwH5oajyXZqux_jByNLW4m23L0p_wFkCT7poTwOR35FfQLiy7NmoTVVFih4jdiKWwjNlqxtwbWR9bkBdfU_ite9Rq2EgPvwDLvA9EBuOLKWi9iPnjsYUTUScS6TCk9AsI23C4okQy7knZX9_Ul6N8jmNxbiCPxfpVBzh1sxL5gwjaYV0dhXN6jCIdZ_SYzM-meSpFgBupXTRL2R90rTq9BQ62uVcr9pDkyBThj15LX_xz0EDBi3bN-dKOfdYjYE7GmXRLPjPCQLxLOXbmz6K3KqCcYVpYbjhB4LLIuJT-YskggMtSpw794HiAsKMeqtvaqGiF0_ElfOLOn9TqgHdSTdVJ8TZ-_zdv9wxzp4MeK7sFuV8zE1Df5W1C9Hz67ct2Q__Can_0ZL5hFK0lNQisQXjEtCWhVqbWyDtu5dNaYo5g7QPXSgM-eMSyBReACwHHCmOOQZG_F_sMyp4tkGq-S3cIRnR85UruTxqe0VdlrEs7x8k0zVws2Mz4MnxS84y31COOwSvisnLLv6SNn_-4gLI1ePWdgtBrBxcuo6gboJgeH0D8E1LZCWwdsGamorH9EjLa9K24U7xcZKDAV6B8RG84B0dW95AIyxZA7PHpDA4tkN-2_gz61XJ96nVyD6TKH_SCM6Cukl3kWZXCV0q7WnvWunw==
```

## processoptim/pylca/lca.py

```diff
@@ -6,171 +6,260 @@
 """
 import json
 import glob
 import os
 from tabulate import tabulate
 import warnings
 import inspect
+from ..__colors__ import __colors__
+from ..__disp__ import _set_color, _set_decimals
+
+script_directory = os.path.dirname(
+    os.path.abspath(inspect.getfile(inspect.currentframe())))
 
-script_directory = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
 
 
 class __exchange__(object):
-    def __init__(self,dict_):
+    def __init__(self, dict_):
         self.__dict__.update(dict_)
+
+
 class __lci__(object):
-     def __init__(self, dict_):
-         self.exchanges={}
-         for k,v in dict_.items():
-             if k=="exchanges":
-                 for k1,v1 in dict_["exchanges"].items():
-                     self.exchanges[k1]= __exchange__(v1)
-             else:
-                 setattr(self, k, v)
-     def __repr__(self):
-         return tabulate([[self.name, self.amount, self.unit]],headers=["Inventory","Amount","Unit"])
-         
+    def __init__(self, dict_):
+        self.exchanges = {}
+        for k, v in dict_.items():
+            if k == "exchanges":
+                for k1, v1 in dict_["exchanges"].items():
+                    self.exchanges[k1] = __exchange__(v1)
+            else:
+                setattr(self, k, v)
+
+    def __repr__(self):
+        return tabulate([[self.name, self.amount, self.unit]], headers=["Inventory", "Amount", "Unit"])
+
 
 class inventories(dict):
-    def __init__(self):
+    def __init__(self,lca):
+        self.lca = lca
         self.load()
-        
+
     def load(self):
         self.clear()
-        inv_=[]
+        inv_ = []
         for fname in glob.glob(script_directory+"\\lci\\*.json"):
             inv_.append(json.load(open(fname)))
-        for inv in sorted(inv_,key=lambda x:x["name"]):
-            self[inv["id"]]=__lci__(inv)
+        for inv in sorted(inv_, key=lambda x: x["name"]):
+            self[inv["id"]] = __lci__(inv)
+
     def __repr__(self):
         from .uiinv import InvApp
         app = InvApp(self)
         app.MainLoop()
         return ""
         # table = []
         # for inv in self.values():
         #     table.append([inv.name, inv.amount, inv.unit])
         # return tabulate(table,showindex="always", headers=["","Inventory","Amount","Unit"],colalign=("right",))
+
     def __getitem__(self, k):
-            if isinstance(k, int):
-                k=list(self.keys())[k]
-            return self.get(k)
+        if isinstance(k, int) and k < len(self):
+            return self.get(list(self.keys())[k])
+        else:
+            return self.get(next((x for x in self.items() if x[1].name == k or x[0] == k), (None,))[0])
+        return None
+
+    def search(self, *args):
+        list_ = []
+        table =[]
+        for k,v in self.items():
+            if all([x in v.name for x in args]):
+                list_.append(k)
+                table.append([self.lca.getInventoryLabel(k), v.amount, v.unit])
+        if list_:
+            print(tabulate(table))
+        return list_;
+
 
 class impactFactor:
-    def __init__(self,dict_):
+    def __init__(self, dict_):
         self.__dict__.update(dict_)
+
+
 class category:
-    def __init__(self,dict_):
-        self.impactFactors={}
-        for k,v in dict_.items():
-            if k=="impactFactors":
-                for k1,v1 in v.items():
-                    self.impactFactors[k1]=impactFactor(v1)
+    def __init__(self, dict_):
+        self.impactFactors = {}
+        for k, v in dict_.items():
+            if k == "impactFactors":
+                for k1, v1 in v.items():
+                    self.impactFactors[k1] = impactFactor(v1)
             else:
                 setattr(self, k, v)
+
     def __repr__(self):
-        return tabulate(map(lambda x: [x.name,x.value, x.unit],self.impactFactors.values()),headers=[self.name,"",""])
-                
+        return tabulate(map(lambda x: [x.name, x.value, x.unit], self.impactFactors.values()), headers=[self.name, "", ""])
+
+
 class categories(dict):
     def __init__(self, dict_):
         for c in dict_:
             cat = category(c)
             self[cat.name] = cat
+
     def __getitem__(self, k):
-            if isinstance(k, int):
-                k=list(self.keys())[k]
-            return self.get(k)
+        if isinstance(k, int):
+            k = list(self.keys())[k]
+        return self.get(k)
+
+
 class method:
-    def __init__(self,dict_):
-        for k,v in dict_.items():
+    def __init__(self, dict_):
+        for k, v in dict_.items():
             if k == "categories":
                 self.categories = categories(v)
             else:
                 setattr(self, k, v)
+
     def __repr__(self):
-        return tabulate(map(lambda x:[x.name,x.unit],self.categories.values()),headers=[self.name,""],showindex="always")
+        return tabulate(map(lambda x: [x.name, x.unit], self.categories.values()), headers=[self.name, ""], showindex="always")
+
     def __getitem__(self, k):
-            if k in self.__dict__:
-                return self.get(k)
-            else:
-                return self.categories[k]
+        if k in self.__dict__:
+            return self.get(k)
+        else:
+            return self.categories[k]
+
 
-        
 class methods(dict):
     def __init__(self):
         for fname in glob.glob(script_directory+"\\methods\\*.json"):
             m = method(json.load(open(fname)))
             self[m.name] = m
+
     def __repr__(self):
-        return tabulate(map(lambda x: [x.name],self.values()),showindex="always")
+        return tabulate(map(lambda x: [x.name], self.values()), showindex="always")
+
     def __getitem__(self, k):
-            if isinstance(k, int):
-                k=list(self.keys())[k]
-            return self.get(k)
-    
+        if isinstance(k, int):
+            k = list(self.keys())[k]
+        return self.get(k)
+
+
 class res(dict):
     def __init__(self, lca):
-        self.lca=lca
+        self.lca = lca
         self.__cumul__ = {}
-    
-    def cumul(self, cat):
+
+    def cumul(self, cat=None):
         cat = self.lca.methods[self.lca.method][cat]
         if cat:
             return self.__cumul__[cat.name]
+        else:
+            table=[]
+            for k, v in self.__cumul__.items():
+                table.append([k, "{:.3e}".format(v),self.lca.methods[self.lca.method][k].unit])
+            return print(tabulate(table))
+
     def __repr__(self):
-        table =[]
+        table = []
         for inv, v in self.items():
-            table.append([self.lca.inventories[inv].name,"",v["amount"],self.lca.inventories[inv].unit])
-            for k1,v1 in v["impacts"].items():
-                table.append(["",k1,"{:.3e}".format(v1),self.lca.methods[self.lca.method][k1].unit])
-        table.append(["Cumul","",""])
-        for k,v in self.__cumul__.items():
-            table.append(["",k,"{:.3e}".format(v)])
-        return tabulate(table,colalign=("right",))
-class lca:
-    def __init__(self):
-        self.inventories = inventories()
-        self.methods=methods()
-        self.__inv__ = {}
-        self.method = 0
-        self.categories=[]
-        self.res=res(self)
-    def loadLCI(self):
-        from .uiinv import InLoadInv
-        InLoadInv(self)
-    def clear(self):
-        self.__inv__ = {}
-        self.res=res(self)
-    def add(self, amount, inv):
-        #if isinstance(inv, int) and inv <len(self.inventories):
-        inv_ = next((x for x in self.inventories.items() if x[1].name == inv),None)
-        if inv_:
-            self.__inv__[inv_[0]]=amount
-            pass
+            table.append([self.lca.getInventoryLabel(inv), "",
+                         v["amount"], self.lca.inventories[inv].unit])
+            for k1, v1 in v["impacts"].items():
+                table.append(["", k1, "{:.3e}".format(
+                    v1), self.lca.methods[self.lca.method][k1].unit])
+        return tabulate(table, colalign=("right",))
+
+
+class productSystem(dict):
+    def __init__(self, lca, name):
+        self.lca = lca
+        self.res=res(self.lca)
+        self.name=name
+
+    def add(self, amount, inventory):
+        inv = self.lca.inventories[inventory]
+        if inv:
+            self[inv.id]=amount
         else:
-            warnings.warn("inventory {} does not exist".format(inv))
+            warnings.warn("inventory {} does not exist".format(inventory))
+            
+    def remove(self, inventory):
+        self.pop(inventory,None)
     def __repr__(self):
         table = []
-        for k,v in self.__inv__.items():
-            table.append([k,v,self.inventories[k].unit])
+        for k, v in self.items():
+            table.append([self.lca.getInventoryLabel(k), v, self.lca.inventories[k].unit])
         return tabulate(table)
-    def __calcul__(self,amount, inv,cat):
-        impact=0
-        for k,v in self.methods[self.method].categories[cat].impactFactors.items():
-            if k in self.inventories[inv].exchanges.keys():
-                impact+=self.inventories[inv].exchanges[k].amount*v.value
-        return impact*amount/self.inventories[inv].amount
+    
     def calcul(self):
-        self.res=res(self)
-        m = self.methods[self.method]
-        cat_ = self.categories
+        self.res = res(self.lca)
+        m = self.lca.methods[self.lca.method]
+        cat_ = self.lca.categories
         if not cat_:
             cat_ = range(len(m.categories))
-        for inv,amount in self.__inv__.items():
-            self.res[inv]={"amount":amount,"impacts":{}}
+        for inv, amount in self.items():
+            self.res[inv] = {"amount": amount, "impacts": {}}
             for cat in cat_:
                 cat = m[cat].name
-                self.res[inv]["impacts"][cat]=self.__calcul__(amount, inv, cat)
+                self.res[inv]["impacts"][cat] = self.lca.__calcul__(amount, inv, cat)
                 if not cat in self.res.__cumul__.keys():
-                    self.res.__cumul__[cat]=0
-                self.res.__cumul__[cat]+=self.res[inv]["impacts"][cat]
+                    self.res.__cumul__[cat] = 0
+                self.res.__cumul__[cat] += self.res[inv]["impacts"][cat]
+
+    
+class lca():
+    def __init__(self):
+        self.inventories = inventories(self)
+        self.methods = methods()
+        self.method = 0
+        self.categories = []
+        self.__product_systems = {}
+
+    def loadLCI(self):
+        from .uiinv import InLoadInv
+        InLoadInv(self)
+
+    def clear(self,reload=False):
+        self.__product_systems.clear()
+    
+    def get(self, productSystemName):
+        return self.__product_systems.get(productSystemName)
+
+    def add(self, productSystemName):
+        self.__product_systems[productSystemName]=productSystem(self,productSystemName)
+        return self.__product_systems[productSystemName]
+
+    def __repr__(self):
+        table = []
+        for k, v in self.__product_systems.items():
+            table.append([k])
+        return tabulate(table)
+
+    def __calcul__(self, amount, inv, cat):
+        impact = 0
+        for k, v in self.methods[self.method].categories[cat].impactFactors.items():
+            if k in self.inventories[inv].exchanges.keys():
+                impact += self.inventories[inv].exchanges[k].amount*v.value
+        return impact*amount/self.inventories[inv].amount
+    
+    def calcul(self,*args):
+        if len(args)==0:
+            args = self.__product_systems.keys()
+        for arg in args:
+            self.__product_systems[arg].calcul()
+    
+    def getImpact(self,cat):
+        table=[]
+        for k,v in self.__product_systems.items():
+            table.append([k,v.res.cumul(cat)])
+        print(tabulate(table,headers=[self.methods[self.method][cat].name,self.methods[self.method][cat].unit]))
+        
+            
+    def getInventoryLabel(self,inventoryID):
+                idx = _set_color(str([idx for idx, key in enumerate(self.inventories.items()) if key[0] == inventoryID]),__colors__.on_yellow)
+                name = self.inventories[inventoryID].name
+                if len(name)>60:
+                    name = name[0:60]+_set_color("...",__colors__.bgreen)
+                return (" ").join((idx,name))
+
+
```

## Comparing `processoptim-0.2.5.dist-info/LICENSE.txt` & `processoptim-0.2.6.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `processoptim-0.2.5.dist-info/METADATA` & `processoptim-0.2.6.dist-info/METADATA`

 * *Files 5% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: processoptim
-Version: 0.2.5
+Version: 0.2.6
 Summary: Food Process Design
 Author: Hedi ROMDHANA
 Author-email: hedi.romdhana@agroparistech.fr
 License: GPLv3
 Keywords: food process integration
 Classifier: Development Status :: 3 - Alpha
 Classifier: Intended Audience :: Developers
```

## Comparing `processoptim-0.2.5.dist-info/RECORD` & `processoptim-0.2.6.dist-info/RECORD`

 * *Files 3% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 processoptim/__colors__.py,sha256=-Ec_whHcMcRHDfIqX4MJ4TuNMEW2A4MHZbHZFYM7IXI,2527
 processoptim/__disp__.py,sha256=F92vmgqAdSQHojzKvcrRd7VTaN0WboVrrShCNBz_oLs,914
 processoptim/__init__.py,sha256=0suEt2EGjb1f7HJl5c1herqWvBsuo587nHzSIARyXhY,569
 processoptim/__main__.py,sha256=qVPcan5hLwlicebgRVamCK_4Ck05Iex081F8SM-7iu0,185
-processoptim/__version__.py,sha256=DdeK37UT5n5lXDmrgyLy7IpZd7gxXLpkHRJLylJeyOg,112
-processoptim/config.json,sha256=LFP1wqngpqBXxQ-ehNQe-nGa8Ese10IJ9R8vgC-EyuE,1036
+processoptim/__version__.py,sha256=nN-SPrnmeN9grfrg9fLJqNMXa-6VRMygiDkH1mklfAg,112
+processoptim/config.json,sha256=93_pZs-cr_rDMzy7TvzgfjMLlXjSXzUiEEChZ9S3Xqc,1124
 processoptim/equilibrium.py,sha256=D2vjZ1pr-PYYOICPYbpAepN_aBkBfaSiYMKr0PEzhEY,261
 processoptim/process_schema.json,sha256=5HfarSIH0Z7eesb6QSshleM_JT5XvHwO12aU-vUkSaE,18793
 processoptim/processes.py,sha256=0mHB8Qeim7nu-TPQy7UM0Qt9FBhnS5KrFNl394SzOLE,24709
 processoptim/test.py,sha256=U6ZvhkCSswrQSLBlhCEtabY-WZske4DponBgLd-AM-Y,91
 processoptim/thermo_properties.py,sha256=tP7hGAV2UmR7F9vUzxlREDZNxQ455s19r9FVyNSP928,4112
 processoptim/tomato_flowsheet.py,sha256=L4RlV51WVYRtuloAwLKKld58n-VjJoHc8DpvQ4-tBaU,25588
 processoptim/data/ethanol_water_equilibrium_1bar.txt,sha256=jIBdfKSbTcZoQuT_Ij1Jxtdc_TITquZ55WDGS1E8_iM,275
 processoptim/data/kineticA.txt,sha256=kMQPMyWWV1Krls2qSJMpBg33yPY0H4eG-A4iJV6ump0,87
 processoptim/data/soybean_hexane_equilibrium.txt,sha256=ZTjCoKhHM6bk7xqPgMi4isJKB1vVdPJ0J-Xg17D6tB0,115
 processoptim/membrane/membrane.json,sha256=guCMJjpvPrMfIcGJiA3HYWxwV0cYR0ictqxZsoCnxn8,7681
 processoptim/membrane/membrane.py,sha256=lGEnQraIR1Ldv3BBm23ZvTcQ7ehkY5qLZGcjART96NI,15795
 processoptim/membrane/solutes.json,sha256=lfIdqvXCsw8agl9WhdudiCm9j3yajK6scd2K5qGnA1s,944
 processoptim/pylca/demo1.py,sha256=UGezQ6U7AThLNIvlAu47uaa9-JzeQlA0vUrk1xObIuY,1089
-processoptim/pylca/lca.py,sha256=Y-QZhRcdY12a-ub8-siZw0UtQKWnCLYc-vrfecPh1Ow,6207
+processoptim/pylca/lca.py,sha256=HVljIySPs0YrmgGZgRRuY7aat_3K0i2vhKDMRogAqsg,8479
 processoptim/pylca/uiinv.py,sha256=ADUCZCFBXc0iJJAp9s0jKunzoJnyGKOcQbKKXxc4J9E,3141
 processoptim/pylca/lci/02022e70-bffc-4480-9eac-459f0bbe6e92.json,sha256=4J4159HtklFiv8Wa260FHlHxolkUAp-_Z1uJTmtegAI,197199
 processoptim/pylca/lci/05821736-211a-40a2-9f63-762548248989.json,sha256=j8J1g_ONY6KHUGk8HqUauFuTmDsUGOhdcFmPtRpxst8,197256
 processoptim/pylca/lci/0d7ba7b3-7138-41ff-853e-1aaefc48e94a.json,sha256=bd-FL0KzV623nSAGz2pRtbU_T2tXqgbiicfqmtDO3yI,182580
 processoptim/pylca/lci/1c463da1-049a-4610-a332-f87712e4aa5f.json,sha256=6bOZPlEWHEcrCEzR41eg7y6khq4GvdnXFE1W4bXdmV8,188657
 processoptim/pylca/lci/274e1bbe-ea78-45ea-9b11-b4653e2e3114.json,sha256=IDZE0Dk1K0em_qj3AH_O8G9HsvDKrVtBhvM8Z4NWbJw,197242
 processoptim/pylca/lci/2957be63-2bee-408f-aad2-a31c179876c9.json,sha256=BGTVbhXTLHZ8v3NZIL_sk0-1h_5SM1es62qyOV4yN20,182619
@@ -64,12 +64,12 @@
 processoptim/pylca/lci/f6cdf632-5fd7-4ce6-a6a8-05160a986d3b.json,sha256=m4vkxaMvcP8aWEJIiSVO_qYM2-D3nhhUp50D08_FISI,197262
 processoptim/pylca/lci/fac6b14f-829d-4f83-aaed-9cbd9a1cae31.json,sha256=w9uzHP59l6t9y7b6ZxceRGlP7KOXZ7xuQqfzOvCcKVU,182458
 processoptim/pylca/lci/fc1b5051-1bbc-4263-883c-1a6ffd768447.json,sha256=ppxkit2PUpmrd1mhmZfwsCcMfHfZu-Gxk0HOV9ceK_Q,199818
 processoptim/pylca/lci/fcb1767f-4a59-41d3-857f-1b6739212562.json,sha256=NbVR82Z2YB5BejBVMTjbWxDmQA-Bq7XX9Dx0GCgJ8IE,197190
 processoptim/pylca/lci/fdf6e134-780e-4119-bbe5-998071b59704.json,sha256=Q_uzgniU4P722EFAM-MT60ZKwY70XBoPyN50THUouyg,197200
 processoptim/pylca/methods/CML-IA baseline.json,sha256=SBbE54O3g6RFJ8dHNCvuo0c82hYnWzpCNmUUeQB-X1M,1466310
 processoptim/pylca/methods/EF 3.0 Method (adapted).json,sha256=FSf0y4GFMfsnA2MWXpUexI1FJ3XDFCJshLRGn5rOVB0,17559064
-processoptim-0.2.5.dist-info/LICENSE.txt,sha256=jK783yqjsDKrg9nddLLWL6WF2dJizdOGyb7j9IjXCDY,1093
-processoptim-0.2.5.dist-info/METADATA,sha256=NQbEUidFUFysjlirabQVFFKPwMEQwz-dBicuOq_p7a0,1910
-processoptim-0.2.5.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-processoptim-0.2.5.dist-info/top_level.txt,sha256=HCnCjsvYylvx_Em7mmr4E8dapJanQLMgF8LLAf_59Uw,13
-processoptim-0.2.5.dist-info/RECORD,,
+processoptim-0.2.6.dist-info/LICENSE.txt,sha256=jK783yqjsDKrg9nddLLWL6WF2dJizdOGyb7j9IjXCDY,1093
+processoptim-0.2.6.dist-info/METADATA,sha256=VjT4ksc37vJfXBx3IrXyLvMPfORWdHfHuS1aABFDHA0,1910
+processoptim-0.2.6.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+processoptim-0.2.6.dist-info/top_level.txt,sha256=HCnCjsvYylvx_Em7mmr4E8dapJanQLMgF8LLAf_59Uw,13
+processoptim-0.2.6.dist-info/RECORD,,
```

