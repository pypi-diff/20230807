# Comparing `tmp/finbourne-access-sdk-0.0.616.tar.gz` & `tmp/finbourne-access-sdk-0.0.815.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist/finbourne-access-sdk-0.0.616.tar", last modified: Wed Jul 15 09:47:04 2020, max compression
+gzip compressed data, was "dist\finbourne-access-sdk-0.0.815.tar", last modified: Fri Jan 22 15:08:00 2021, max compression
```

## Comparing `finbourne-access-sdk-0.0.616.tar` & `finbourne-access-sdk-0.0.815.tar`

### file list

```diff
@@ -1,101 +1,104 @@
-drwxr-xr-x   0 rizwansaeed   (501) staff       (20)        0 2020-07-15 09:47:04.000000 finbourne-access-sdk-0.0.616/
--rw-r--r--   0 rizwansaeed   (501) staff       (20)       51 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/MANIFEST.in
--rw-r--r--   0 rizwansaeed   (501) staff       (20)      355 2020-07-15 09:47:04.000000 finbourne-access-sdk-0.0.616/PKG-INFO
-drwxr-xr-x   0 rizwansaeed   (501) staff       (20)        0 2020-07-15 09:47:04.000000 finbourne-access-sdk-0.0.616/finbourne_access/
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     6505 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/__init__.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)       24 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/__version__.py
-drwxr-xr-x   0 rizwansaeed   (501) staff       (20)        0 2020-07-15 09:47:04.000000 finbourne-access-sdk-0.0.616/finbourne_access/api/
--rw-r--r--   0 rizwansaeed   (501) staff       (20)      336 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/api/__init__.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     5870 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/api/application_metadata_api.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)    44619 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/api/licences_api.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)    74103 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/api/policies_api.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)    31247 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/api/roles_api.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)    25516 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/api_client.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)    10575 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/configuration.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     3995 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/exceptions.py
-drwxr-xr-x   0 rizwansaeed   (501) staff       (20)        0 2020-07-15 09:47:04.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     5331 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/__init__.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     6819 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/access_controlled_action.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     8854 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/access_controlled_resource.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     6091 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/action_id.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     4368 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/as_at_predicate_contract.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     4229 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/as_at_range_for_spec.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     6074 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/as_at_relative.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)    12917 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/attached_policy_definition_response.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     3494 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/date_quality.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     3041 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/date_unit.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     3575 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/effective_date_has_quality.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     6245 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/effective_date_relative.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     4038 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/effective_range.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     4152 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/entitlement_metadata.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     4568 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/evaluation_request.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     4789 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/evaluation_response.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     2966 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/evaluation_result.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     8020 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/for_spec.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     2879 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/grant.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     4183 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/how_spec.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     5810 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/id_selector_definition.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     8916 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/identifier_part_schema.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     6644 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/if_expression.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     8316 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/if_identity_claim_expression.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     3889 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/if_identity_scope_expression.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     5554 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/if_request_header_expression.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     4141 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/key_value_pair_of_string_to_string.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)    10432 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/licence_creation_request.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     6711 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/licence_selector_definition.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     9005 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/licence_update_request.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     5728 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/link.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     5074 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/match_all_selector_definition.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     5569 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/metadata_expression.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     6003 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/metadata_selector_definition.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     3598 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/non_transitive_supervisor_role_resource.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     3140 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/operator.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     3290 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/point_in_time_specification.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     9376 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/policy_collection_creation_request.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     4840 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/policy_collection_id.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     7522 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/policy_collection_response.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     7731 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/policy_collection_update_request.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)    12082 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/policy_creation_request.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     4730 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/policy_id.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     4610 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/policy_id_role_resource.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)    10919 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/policy_response.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     7245 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/policy_selector_definition.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     2921 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/policy_type.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)    10508 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/policy_update_request.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     3071 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/relative_to_date_time.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     8614 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/request_details.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     7033 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/requested_action_key.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     4744 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/resource_details.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     5693 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/resource_list_of_access_controlled_resource.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     7034 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/role_creation_request.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     4708 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/role_id.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     5573 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/role_resource_request.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     9316 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/role_response.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     5651 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/role_update_request.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     7889 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/selector_definition.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     9508 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/shrine_problem_details.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)    10700 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/shrine_validation_problem_details.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     3392 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/text_operator.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     4316 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/models/when_spec.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)    12788 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/rest.py
-drwxr-xr-x   0 rizwansaeed   (501) staff       (20)        0 2020-07-15 09:47:04.000000 finbourne-access-sdk-0.0.616/finbourne_access/tcp/
--rw-r--r--   0 rizwansaeed   (501) staff       (20)      104 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/tcp/__init__.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     4970 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/tcp/tcp_keep_alive_probes.py
-drwxr-xr-x   0 rizwansaeed   (501) staff       (20)        0 2020-07-15 09:47:04.000000 finbourne-access-sdk-0.0.616/finbourne_access/utilities/
--rw-r--r--   0 rizwansaeed   (501) staff       (20)      531 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/utilities/__init__.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     7221 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/utilities/api_client_builder.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     4912 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/utilities/api_client_factory.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     2837 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/utilities/api_configuration.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     3529 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/utilities/api_configuration_loader.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)      940 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/utilities/config_keys.json
--rw-r--r--   0 rizwansaeed   (501) staff       (20)      876 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/utilities/finbourne_access_retry.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     1725 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/utilities/proxy_config.py
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     2970 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/finbourne_access/utilities/refreshing_token.py
-drwxr-xr-x   0 rizwansaeed   (501) staff       (20)        0 2020-07-15 09:47:04.000000 finbourne-access-sdk-0.0.616/finbourne_access_sdk.egg-info/
--rw-r--r--   0 rizwansaeed   (501) staff       (20)      355 2020-07-15 09:47:04.000000 finbourne-access-sdk-0.0.616/finbourne_access_sdk.egg-info/PKG-INFO
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     4155 2020-07-15 09:47:04.000000 finbourne-access-sdk-0.0.616/finbourne_access_sdk.egg-info/SOURCES.txt
--rw-r--r--   0 rizwansaeed   (501) staff       (20)        1 2020-07-15 09:47:04.000000 finbourne-access-sdk-0.0.616/finbourne_access_sdk.egg-info/dependency_links.txt
--rw-r--r--   0 rizwansaeed   (501) staff       (20)       84 2020-07-15 09:47:04.000000 finbourne-access-sdk-0.0.616/finbourne_access_sdk.egg-info/requires.txt
--rw-r--r--   0 rizwansaeed   (501) staff       (20)       17 2020-07-15 09:47:04.000000 finbourne-access-sdk-0.0.616/finbourne_access_sdk.egg-info/top_level.txt
--rw-r--r--   0 rizwansaeed   (501) staff       (20)       38 2020-07-15 09:47:04.000000 finbourne-access-sdk-0.0.616/setup.cfg
--rw-r--r--   0 rizwansaeed   (501) staff       (20)     2199 2020-07-15 09:32:05.000000 finbourne-access-sdk-0.0.616/setup.py
+drwxrwxrwx   0        0        0        0 2021-01-22 15:08:00.031738 finbourne-access-sdk-0.0.815/
+-rw-rw-rw-   0        0        0       51 2021-01-18 21:16:40.000000 finbourne-access-sdk-0.0.815/MANIFEST.in
+-rw-rw-rw-   0        0        0      366 2021-01-22 15:08:00.030718 finbourne-access-sdk-0.0.815/PKG-INFO
+-rw-rw-rw-   0        0        0     9681 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/README.md
+drwxrwxrwx   0        0        0        0 2021-01-22 15:07:59.120543 finbourne-access-sdk-0.0.815/finbourne_access/
+-rw-rw-rw-   0        0        0     6367 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/__init__.py
+-rw-rw-rw-   0        0        0       25 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/__version__.py
+drwxrwxrwx   0        0        0        0 2021-01-22 15:07:59.175897 finbourne-access-sdk-0.0.815/finbourne_access/api/
+-rw-rw-rw-   0        0        0      336 2021-01-18 21:16:40.000000 finbourne-access-sdk-0.0.815/finbourne_access/api/__init__.py
+-rw-rw-rw-   0        0        0     5774 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/api/application_metadata_api.py
+-rw-rw-rw-   0        0        0    45356 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/api/licences_api.py
+-rw-rw-rw-   0        0        0    75382 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/api/policies_api.py
+-rw-rw-rw-   0        0        0    31674 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/api/roles_api.py
+-rw-rw-rw-   0        0        0    25918 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/api_client.py
+-rw-rw-rw-   0        0        0    10658 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/configuration.py
+-rw-rw-rw-   0        0        0     3877 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/exceptions.py
+drwxrwxrwx   0        0        0        0 2021-01-22 15:07:59.855628 finbourne-access-sdk-0.0.815/finbourne_access/models/
+-rw-rw-rw-   0        0        0     5167 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/__init__.py
+-rw-rw-rw-   0        0        0     6795 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/access_controlled_action.py
+-rw-rw-rw-   0        0        0     8892 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/access_controlled_resource.py
+-rw-rw-rw-   0        0        0     6049 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/action_id.py
+-rw-rw-rw-   0        0        0     4615 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/as_at_predicate_contract.py
+-rw-rw-rw-   0        0        0     4332 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/as_at_range_for_spec.py
+-rw-rw-rw-   0        0        0     6046 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/as_at_relative.py
+-rw-rw-rw-   0        0        0    13116 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/attached_policy_definition_response.py
+-rw-rw-rw-   0        0        0     3364 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/date_quality.py
+-rw-rw-rw-   0        0        0     2909 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/date_unit.py
+-rw-rw-rw-   0        0        0     3460 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/effective_date_has_quality.py
+-rw-rw-rw-   0        0        0     6217 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/effective_date_relative.py
+-rw-rw-rw-   0        0        0     3951 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/effective_range.py
+-rw-rw-rw-   0        0        0     4064 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/entitlement_metadata.py
+-rw-rw-rw-   0        0        0     4484 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/evaluation_request.py
+-rw-rw-rw-   0        0        0     4705 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/evaluation_response.py
+-rw-rw-rw-   0        0        0     2829 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/evaluation_result.py
+-rw-rw-rw-   0        0        0     8021 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/for_spec.py
+-rw-rw-rw-   0        0        0     2742 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/grant.py
+-rw-rw-rw-   0        0        0     4095 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/how_spec.py
+-rw-rw-rw-   0        0        0     6760 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/id_selector_definition.py
+-rw-rw-rw-   0        0        0     8960 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/identifier_part_schema.py
+-rw-rw-rw-   0        0        0     6587 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/if_expression.py
+-rw-rw-rw-   0        0        0     8346 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/if_identity_claim_expression.py
+-rw-rw-rw-   0        0        0     3777 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/if_identity_scope_expression.py
+-rw-rw-rw-   0        0        0     6028 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/if_request_header_expression.py
+-rw-rw-rw-   0        0        0     4053 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/key_value_pair_of_string_to_string.py
+-rw-rw-rw-   0        0        0    10533 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/licence_creation_request.py
+-rw-rw-rw-   0        0        0     6689 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/licence_selector_definition.py
+-rw-rw-rw-   0        0        0     9070 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/licence_update_request.py
+-rw-rw-rw-   0        0        0     5702 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/link.py
+-rw-rw-rw-   0        0        0     9581 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/lusid_problem_details.py
+-rw-rw-rw-   0        0        0    10797 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/lusid_validation_problem_details.py
+-rw-rw-rw-   0        0        0     5855 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/match_all_selector_definition.py
+-rw-rw-rw-   0        0        0     5515 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/metadata_expression.py
+-rw-rw-rw-   0        0        0     6955 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/metadata_selector_definition.py
+-rw-rw-rw-   0        0        0     3613 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/non_transitive_supervisor_role_resource.py
+-rw-rw-rw-   0        0        0     3008 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/operator.py
+-rw-rw-rw-   0        0        0     3158 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/point_in_time_specification.py
+-rw-rw-rw-   0        0        0     9394 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/policy_collection_creation_request.py
+-rw-rw-rw-   0        0        0     4762 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/policy_collection_id.py
+-rw-rw-rw-   0        0        0     7525 2021-01-22 15:07:01.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/policy_collection_response.py
+-rw-rw-rw-   0        0        0     7711 2021-01-22 15:07:02.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/policy_collection_update_request.py
+-rw-rw-rw-   0        0        0    12221 2021-01-22 15:07:02.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/policy_creation_request.py
+-rw-rw-rw-   0        0        0     4652 2021-01-22 15:07:02.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/policy_id.py
+-rw-rw-rw-   0        0        0     4522 2021-01-22 15:07:02.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/policy_id_role_resource.py
+-rw-rw-rw-   0        0        0    11069 2021-01-22 15:07:02.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/policy_response.py
+-rw-rw-rw-   0        0        0     8082 2021-01-22 15:07:02.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/policy_selector_definition.py
+-rw-rw-rw-   0        0        0     2784 2021-01-22 15:07:02.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/policy_type.py
+-rw-rw-rw-   0        0        0    10609 2021-01-22 15:07:02.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/policy_update_request.py
+-rw-rw-rw-   0        0        0     2938 2021-01-22 15:07:02.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/relative_to_date_time.py
+-rw-rw-rw-   0        0        0     8620 2021-01-22 15:07:02.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/request_details.py
+-rw-rw-rw-   0        0        0     6997 2021-01-22 15:07:02.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/requested_action_key.py
+-rw-rw-rw-   0        0        0     4662 2021-01-22 15:07:02.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/resource_details.py
+-rw-rw-rw-   0        0        0     5637 2021-01-22 15:07:02.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/resource_list_of_access_controlled_resource.py
+-rw-rw-rw-   0        0        0     6687 2021-01-22 15:07:02.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/role_creation_request.py
+-rw-rw-rw-   0        0        0     4630 2021-01-22 15:07:02.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/role_id.py
+-rw-rw-rw-   0        0        0     5487 2021-01-22 15:07:02.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/role_resource_request.py
+-rw-rw-rw-   0        0        0     9406 2021-01-22 15:07:02.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/role_response.py
+-rw-rw-rw-   0        0        0     5599 2021-01-22 15:07:02.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/role_update_request.py
+-rw-rw-rw-   0        0        0     7861 2021-01-22 15:07:02.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/selector_definition.py
+-rw-rw-rw-   0        0        0     9859 2021-01-18 21:14:38.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/shrine_problem_details.py
+-rw-rw-rw-   0        0        0    11079 2021-01-18 21:14:38.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/shrine_validation_problem_details.py
+-rw-rw-rw-   0        0        0     3260 2021-01-22 15:07:02.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/text_operator.py
+-rw-rw-rw-   0        0        0     4230 2021-01-22 15:07:02.000000 finbourne-access-sdk-0.0.815/finbourne_access/models/when_spec.py
+-rw-rw-rw-   0        0        0    12664 2021-01-22 15:07:02.000000 finbourne-access-sdk-0.0.815/finbourne_access/rest.py
+drwxrwxrwx   0        0        0        0 2021-01-22 15:07:59.878533 finbourne-access-sdk-0.0.815/finbourne_access/tcp/
+-rw-rw-rw-   0        0        0      104 2021-01-18 21:16:40.000000 finbourne-access-sdk-0.0.815/finbourne_access/tcp/__init__.py
+-rw-rw-rw-   0        0        0     5077 2021-01-18 21:16:40.000000 finbourne-access-sdk-0.0.815/finbourne_access/tcp/tcp_keep_alive_probes.py
+drwxrwxrwx   0        0        0        0 2021-01-22 15:07:59.989504 finbourne-access-sdk-0.0.815/finbourne_access/utilities/
+-rw-rw-rw-   0        0        0      538 2021-01-18 21:16:40.000000 finbourne-access-sdk-0.0.815/finbourne_access/utilities/__init__.py
+-rw-rw-rw-   0        0        0     7391 2021-01-18 21:16:40.000000 finbourne-access-sdk-0.0.815/finbourne_access/utilities/api_client_builder.py
+-rw-rw-rw-   0        0        0     5045 2021-01-18 21:16:40.000000 finbourne-access-sdk-0.0.815/finbourne_access/utilities/api_client_factory.py
+-rw-rw-rw-   0        0        0     2962 2021-01-18 21:16:40.000000 finbourne-access-sdk-0.0.815/finbourne_access/utilities/api_configuration.py
+-rw-rw-rw-   0        0        0     3595 2021-01-18 21:16:40.000000 finbourne-access-sdk-0.0.815/finbourne_access/utilities/api_configuration_loader.py
+-rw-rw-rw-   0        0        0      994 2021-01-18 21:16:40.000000 finbourne-access-sdk-0.0.815/finbourne_access/utilities/config_keys.json
+-rw-rw-rw-   0        0        0      913 2021-01-18 21:16:40.000000 finbourne-access-sdk-0.0.815/finbourne_access/utilities/finbourne_access_retry.py
+-rw-rw-rw-   0        0        0     1779 2021-01-18 21:16:40.000000 finbourne-access-sdk-0.0.815/finbourne_access/utilities/proxy_config.py
+-rw-rw-rw-   0        0        0     3045 2021-01-18 21:16:40.000000 finbourne-access-sdk-0.0.815/finbourne_access/utilities/refreshing_token.py
+drwxrwxrwx   0        0        0        0 2021-01-22 15:08:00.028751 finbourne-access-sdk-0.0.815/finbourne_access_sdk.egg-info/
+-rw-rw-rw-   0        0        0      366 2021-01-22 15:07:58.000000 finbourne-access-sdk-0.0.815/finbourne_access_sdk.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0     4274 2021-01-22 15:07:58.000000 finbourne-access-sdk-0.0.815/finbourne_access_sdk.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2021-01-22 15:07:58.000000 finbourne-access-sdk-0.0.815/finbourne_access_sdk.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0       84 2021-01-22 15:07:58.000000 finbourne-access-sdk-0.0.815/finbourne_access_sdk.egg-info/requires.txt
+-rw-rw-rw-   0        0        0       17 2021-01-22 15:07:58.000000 finbourne-access-sdk-0.0.815/finbourne_access_sdk.egg-info/top_level.txt
+-rw-rw-rw-   0        0        0       42 2021-01-22 15:08:00.031738 finbourne-access-sdk-0.0.815/setup.cfg
+-rw-rw-rw-   0        0        0     2258 2021-01-18 21:16:40.000000 finbourne-access-sdk-0.0.815/setup.py
```

### filetype from file(1)

```diff
@@ -1 +1 @@
-POSIX tar archive (GNU)
+POSIX tar archive
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/__init__.py` & `finbourne-access-sdk-0.0.815/finbourne_access/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,105 +1,105 @@
-# coding: utf-8
-
-# flake8: noqa
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-from __future__ import absolute_import
-
-__version__ = "0.0.616"
-
-# import apis into sdk package
-from finbourne_access.api.application_metadata_api import ApplicationMetadataApi
-from finbourne_access.api.licences_api import LicencesApi
-from finbourne_access.api.policies_api import PoliciesApi
-from finbourne_access.api.roles_api import RolesApi
-
-# import ApiClient
-from finbourne_access.api_client import ApiClient
-from finbourne_access.configuration import Configuration
-from finbourne_access.exceptions import OpenApiException
-from finbourne_access.exceptions import ApiTypeError
-from finbourne_access.exceptions import ApiValueError
-from finbourne_access.exceptions import ApiKeyError
-from finbourne_access.exceptions import ApiException
-# import models into sdk package
-from finbourne_access.models.access_controlled_action import AccessControlledAction
-from finbourne_access.models.access_controlled_resource import AccessControlledResource
-from finbourne_access.models.action_id import ActionId
-from finbourne_access.models.as_at_predicate_contract import AsAtPredicateContract
-from finbourne_access.models.as_at_range_for_spec import AsAtRangeForSpec
-from finbourne_access.models.as_at_relative import AsAtRelative
-from finbourne_access.models.attached_policy_definition_response import AttachedPolicyDefinitionResponse
-from finbourne_access.models.date_quality import DateQuality
-from finbourne_access.models.date_unit import DateUnit
-from finbourne_access.models.effective_date_has_quality import EffectiveDateHasQuality
-from finbourne_access.models.effective_date_relative import EffectiveDateRelative
-from finbourne_access.models.effective_range import EffectiveRange
-from finbourne_access.models.entitlement_metadata import EntitlementMetadata
-from finbourne_access.models.evaluation_request import EvaluationRequest
-from finbourne_access.models.evaluation_response import EvaluationResponse
-from finbourne_access.models.evaluation_result import EvaluationResult
-from finbourne_access.models.for_spec import ForSpec
-from finbourne_access.models.grant import Grant
-from finbourne_access.models.how_spec import HowSpec
-from finbourne_access.models.id_selector_definition import IdSelectorDefinition
-from finbourne_access.models.identifier_part_schema import IdentifierPartSchema
-from finbourne_access.models.if_expression import IfExpression
-from finbourne_access.models.if_identity_claim_expression import IfIdentityClaimExpression
-from finbourne_access.models.if_identity_scope_expression import IfIdentityScopeExpression
-from finbourne_access.models.if_request_header_expression import IfRequestHeaderExpression
-from finbourne_access.models.key_value_pair_of_string_to_string import KeyValuePairOfStringToString
-from finbourne_access.models.licence_creation_request import LicenceCreationRequest
-from finbourne_access.models.licence_selector_definition import LicenceSelectorDefinition
-from finbourne_access.models.licence_update_request import LicenceUpdateRequest
-from finbourne_access.models.link import Link
-from finbourne_access.models.match_all_selector_definition import MatchAllSelectorDefinition
-from finbourne_access.models.metadata_expression import MetadataExpression
-from finbourne_access.models.metadata_selector_definition import MetadataSelectorDefinition
-from finbourne_access.models.non_transitive_supervisor_role_resource import NonTransitiveSupervisorRoleResource
-from finbourne_access.models.operator import Operator
-from finbourne_access.models.point_in_time_specification import PointInTimeSpecification
-from finbourne_access.models.policy_collection_creation_request import PolicyCollectionCreationRequest
-from finbourne_access.models.policy_collection_id import PolicyCollectionId
-from finbourne_access.models.policy_collection_response import PolicyCollectionResponse
-from finbourne_access.models.policy_collection_update_request import PolicyCollectionUpdateRequest
-from finbourne_access.models.policy_creation_request import PolicyCreationRequest
-from finbourne_access.models.policy_id import PolicyId
-from finbourne_access.models.policy_id_role_resource import PolicyIdRoleResource
-from finbourne_access.models.policy_response import PolicyResponse
-from finbourne_access.models.policy_selector_definition import PolicySelectorDefinition
-from finbourne_access.models.policy_type import PolicyType
-from finbourne_access.models.policy_update_request import PolicyUpdateRequest
-from finbourne_access.models.relative_to_date_time import RelativeToDateTime
-from finbourne_access.models.request_details import RequestDetails
-from finbourne_access.models.requested_action_key import RequestedActionKey
-from finbourne_access.models.resource_details import ResourceDetails
-from finbourne_access.models.resource_list_of_access_controlled_resource import ResourceListOfAccessControlledResource
-from finbourne_access.models.role_creation_request import RoleCreationRequest
-from finbourne_access.models.role_id import RoleId
-from finbourne_access.models.role_resource_request import RoleResourceRequest
-from finbourne_access.models.role_response import RoleResponse
-from finbourne_access.models.role_update_request import RoleUpdateRequest
-from finbourne_access.models.selector_definition import SelectorDefinition
-from finbourne_access.models.shrine_problem_details import ShrineProblemDetails
-from finbourne_access.models.shrine_validation_problem_details import ShrineValidationProblemDetails
-from finbourne_access.models.text_operator import TextOperator
-from finbourne_access.models.when_spec import WhenSpec
-
-# import utilities into sdk package
-from finbourne_access.utilities.api_client_builder import ApiClientBuilder
-from finbourne_access.utilities.api_configuration import ApiConfiguration
-from finbourne_access.utilities.api_configuration_loader import ApiConfigurationLoader
-from finbourne_access.utilities.refreshing_token import RefreshingToken
-
-# import tcp utilities
-from finbourne_access.tcp.tcp_keep_alive_probes import TCPKeepAlivePoolManager, TCPKeepAliveProxyManager
+# coding: utf-8
+
+# flake8: noqa
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+from __future__ import absolute_import
+
+__version__ = "0.0.815"
+
+# import apis into sdk package
+from finbourne_access.api.application_metadata_api import ApplicationMetadataApi
+from finbourne_access.api.licences_api import LicencesApi
+from finbourne_access.api.policies_api import PoliciesApi
+from finbourne_access.api.roles_api import RolesApi
+
+# import ApiClient
+from finbourne_access.api_client import ApiClient
+from finbourne_access.configuration import Configuration
+from finbourne_access.exceptions import OpenApiException
+from finbourne_access.exceptions import ApiTypeError
+from finbourne_access.exceptions import ApiValueError
+from finbourne_access.exceptions import ApiKeyError
+from finbourne_access.exceptions import ApiException
+# import models into sdk package
+from finbourne_access.models.access_controlled_action import AccessControlledAction
+from finbourne_access.models.access_controlled_resource import AccessControlledResource
+from finbourne_access.models.action_id import ActionId
+from finbourne_access.models.as_at_predicate_contract import AsAtPredicateContract
+from finbourne_access.models.as_at_range_for_spec import AsAtRangeForSpec
+from finbourne_access.models.as_at_relative import AsAtRelative
+from finbourne_access.models.attached_policy_definition_response import AttachedPolicyDefinitionResponse
+from finbourne_access.models.date_quality import DateQuality
+from finbourne_access.models.date_unit import DateUnit
+from finbourne_access.models.effective_date_has_quality import EffectiveDateHasQuality
+from finbourne_access.models.effective_date_relative import EffectiveDateRelative
+from finbourne_access.models.effective_range import EffectiveRange
+from finbourne_access.models.entitlement_metadata import EntitlementMetadata
+from finbourne_access.models.evaluation_request import EvaluationRequest
+from finbourne_access.models.evaluation_response import EvaluationResponse
+from finbourne_access.models.evaluation_result import EvaluationResult
+from finbourne_access.models.for_spec import ForSpec
+from finbourne_access.models.grant import Grant
+from finbourne_access.models.how_spec import HowSpec
+from finbourne_access.models.id_selector_definition import IdSelectorDefinition
+from finbourne_access.models.identifier_part_schema import IdentifierPartSchema
+from finbourne_access.models.if_expression import IfExpression
+from finbourne_access.models.if_identity_claim_expression import IfIdentityClaimExpression
+from finbourne_access.models.if_identity_scope_expression import IfIdentityScopeExpression
+from finbourne_access.models.if_request_header_expression import IfRequestHeaderExpression
+from finbourne_access.models.key_value_pair_of_string_to_string import KeyValuePairOfStringToString
+from finbourne_access.models.licence_creation_request import LicenceCreationRequest
+from finbourne_access.models.licence_selector_definition import LicenceSelectorDefinition
+from finbourne_access.models.licence_update_request import LicenceUpdateRequest
+from finbourne_access.models.link import Link
+from finbourne_access.models.lusid_problem_details import LusidProblemDetails
+from finbourne_access.models.lusid_validation_problem_details import LusidValidationProblemDetails
+from finbourne_access.models.match_all_selector_definition import MatchAllSelectorDefinition
+from finbourne_access.models.metadata_expression import MetadataExpression
+from finbourne_access.models.metadata_selector_definition import MetadataSelectorDefinition
+from finbourne_access.models.non_transitive_supervisor_role_resource import NonTransitiveSupervisorRoleResource
+from finbourne_access.models.operator import Operator
+from finbourne_access.models.point_in_time_specification import PointInTimeSpecification
+from finbourne_access.models.policy_collection_creation_request import PolicyCollectionCreationRequest
+from finbourne_access.models.policy_collection_id import PolicyCollectionId
+from finbourne_access.models.policy_collection_response import PolicyCollectionResponse
+from finbourne_access.models.policy_collection_update_request import PolicyCollectionUpdateRequest
+from finbourne_access.models.policy_creation_request import PolicyCreationRequest
+from finbourne_access.models.policy_id import PolicyId
+from finbourne_access.models.policy_id_role_resource import PolicyIdRoleResource
+from finbourne_access.models.policy_response import PolicyResponse
+from finbourne_access.models.policy_selector_definition import PolicySelectorDefinition
+from finbourne_access.models.policy_type import PolicyType
+from finbourne_access.models.policy_update_request import PolicyUpdateRequest
+from finbourne_access.models.relative_to_date_time import RelativeToDateTime
+from finbourne_access.models.request_details import RequestDetails
+from finbourne_access.models.requested_action_key import RequestedActionKey
+from finbourne_access.models.resource_details import ResourceDetails
+from finbourne_access.models.resource_list_of_access_controlled_resource import ResourceListOfAccessControlledResource
+from finbourne_access.models.role_creation_request import RoleCreationRequest
+from finbourne_access.models.role_id import RoleId
+from finbourne_access.models.role_resource_request import RoleResourceRequest
+from finbourne_access.models.role_response import RoleResponse
+from finbourne_access.models.role_update_request import RoleUpdateRequest
+from finbourne_access.models.selector_definition import SelectorDefinition
+from finbourne_access.models.text_operator import TextOperator
+from finbourne_access.models.when_spec import WhenSpec
+
+# import utilities into sdk package
+from finbourne_access.utilities.api_client_builder import ApiClientBuilder
+from finbourne_access.utilities.api_configuration import ApiConfiguration
+from finbourne_access.utilities.api_configuration_loader import ApiConfigurationLoader
+from finbourne_access.utilities.refreshing_token import RefreshingToken
+
+# import tcp utilities
+from finbourne_access.tcp.tcp_keep_alive_probes import TCPKeepAlivePoolManager, TCPKeepAliveProxyManager
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/api/licences_api.py` & `finbourne-access-sdk-0.0.815/finbourne_access/api/licences_api.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,976 +1,976 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-from __future__ import absolute_import
-
-import re  # noqa: F401
-
-# python 2 and python 3 compatibility library
-import six
-
-from finbourne_access.api_client import ApiClient
-from finbourne_access.exceptions import (
-    ApiTypeError,
-    ApiValueError
-)
-
-
-class LicencesApi(object):
-    """NOTE: This class is auto generated by OpenAPI Generator
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    def __init__(self, api_client=None):
-        if api_client is None:
-            api_client = ApiClient()
-        self.api_client = api_client
-
-    def create_licence(self, licence_creation_request, **kwargs):  # noqa: E501
-        """[EXPERIMENTAL] Create a Licence  # noqa: E501
-
-        Creates an unassigned Licence policy  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_licence(licence_creation_request, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param LicenceCreationRequest licence_creation_request: The Licence definition (required)
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: PolicyResponse
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        return self.create_licence_with_http_info(licence_creation_request, **kwargs)  # noqa: E501
-
-    def create_licence_with_http_info(self, licence_creation_request, **kwargs):  # noqa: E501
-        """[EXPERIMENTAL] Create a Licence  # noqa: E501
-
-        Creates an unassigned Licence policy  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_licence_with_http_info(licence_creation_request, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param LicenceCreationRequest licence_creation_request: The Licence definition (required)
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: tuple(PolicyResponse, status_code(int), headers(HTTPHeaderDict))
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        local_var_params = locals()
-
-        all_params = ['licence_creation_request']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        for key, val in six.iteritems(local_var_params['kwargs']):
-            if key not in all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_licence" % key
-                )
-            local_var_params[key] = val
-        del local_var_params['kwargs']
-        # verify the required parameter 'licence_creation_request' is set
-        if ('licence_creation_request' not in local_var_params or
-                local_var_params['licence_creation_request'] is None):
-            raise ApiValueError("Missing the required parameter `licence_creation_request` when calling `create_licence`")  # noqa: E501
-
-        collection_formats = {}
-
-        path_params = {}
-
-        query_params = []
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        if 'licence_creation_request' in local_var_params:
-            body_params = local_var_params['licence_creation_request']
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
-
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json'])  # noqa: E501
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        # set the LUSID header
-        header_params['X-LUSID-SDK-Language'] = 'Python'
-        header_params['X-LUSID-SDK-Version'] = '0.0.616'
-
-        return self.api_client.call_api(
-            '/api/licences', 'POST',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='PolicyResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def create_licence_assignment(self, code, tenant, **kwargs):  # noqa: E501
-        """[EXPERIMENTAL] Assign Licence  # noqa: E501
-
-        Create a licence assignment to another, authorised, tenant  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_licence_assignment(code, tenant, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param str code: Code of the Licence (required)
-        :param str tenant: Name of the tenant to be shared with (required)
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: PolicyResponse
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        return self.create_licence_assignment_with_http_info(code, tenant, **kwargs)  # noqa: E501
-
-    def create_licence_assignment_with_http_info(self, code, tenant, **kwargs):  # noqa: E501
-        """[EXPERIMENTAL] Assign Licence  # noqa: E501
-
-        Create a licence assignment to another, authorised, tenant  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_licence_assignment_with_http_info(code, tenant, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param str code: Code of the Licence (required)
-        :param str tenant: Name of the tenant to be shared with (required)
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: tuple(PolicyResponse, status_code(int), headers(HTTPHeaderDict))
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        local_var_params = locals()
-
-        all_params = ['code', 'tenant']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        for key, val in six.iteritems(local_var_params['kwargs']):
-            if key not in all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_licence_assignment" % key
-                )
-            local_var_params[key] = val
-        del local_var_params['kwargs']
-        # verify the required parameter 'code' is set
-        if ('code' not in local_var_params or
-                local_var_params['code'] is None):
-            raise ApiValueError("Missing the required parameter `code` when calling `create_licence_assignment`")  # noqa: E501
-        # verify the required parameter 'tenant' is set
-        if ('tenant' not in local_var_params or
-                local_var_params['tenant'] is None):
-            raise ApiValueError("Missing the required parameter `tenant` when calling `create_licence_assignment`")  # noqa: E501
-
-        collection_formats = {}
-
-        path_params = {}
-        if 'code' in local_var_params:
-            path_params['code'] = local_var_params['code']  # noqa: E501
-        if 'tenant' in local_var_params:
-            path_params['tenant'] = local_var_params['tenant']  # noqa: E501
-
-        query_params = []
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
-
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        # set the LUSID header
-        header_params['X-LUSID-SDK-Language'] = 'Python'
-        header_params['X-LUSID-SDK-Version'] = '0.0.616'
-
-        return self.api_client.call_api(
-            '/api/licences/{code}/assignments/{tenant}', 'PUT',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='PolicyResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def delete_licence(self, code, **kwargs):  # noqa: E501
-        """[EXPERIMENTAL] Delete Licence  # noqa: E501
-
-        Deletes an identified Licence  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_licence(code, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param str code: The code of the Licence (required)
-        :param str scope: Optional. Will use the client name if not provided. The scope of the Licence
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: None
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        return self.delete_licence_with_http_info(code, **kwargs)  # noqa: E501
-
-    def delete_licence_with_http_info(self, code, **kwargs):  # noqa: E501
-        """[EXPERIMENTAL] Delete Licence  # noqa: E501
-
-        Deletes an identified Licence  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_licence_with_http_info(code, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param str code: The code of the Licence (required)
-        :param str scope: Optional. Will use the client name if not provided. The scope of the Licence
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: None
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        local_var_params = locals()
-
-        all_params = ['code', 'scope']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        for key, val in six.iteritems(local_var_params['kwargs']):
-            if key not in all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_licence" % key
-                )
-            local_var_params[key] = val
-        del local_var_params['kwargs']
-        # verify the required parameter 'code' is set
-        if ('code' not in local_var_params or
-                local_var_params['code'] is None):
-            raise ApiValueError("Missing the required parameter `code` when calling `delete_licence`")  # noqa: E501
-
-        collection_formats = {}
-
-        path_params = {}
-        if 'code' in local_var_params:
-            path_params['code'] = local_var_params['code']  # noqa: E501
-
-        query_params = []
-        if 'scope' in local_var_params:
-            query_params.append(('scope', local_var_params['scope']))  # noqa: E501
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
-
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        # set the LUSID header
-        header_params['X-LUSID-SDK-Language'] = 'Python'
-        header_params['X-LUSID-SDK-Version'] = '0.0.616'
-
-        return self.api_client.call_api(
-            '/api/licences/{code}', 'DELETE',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type=None,  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def delete_licence_assignment(self, code, tenant, **kwargs):  # noqa: E501
-        """[EXPERIMENTAL] Unassign Licence  # noqa: E501
-
-        Remove a Licence assignment from a tenant  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_licence_assignment(code, tenant, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param str code: Code of the Licence (required)
-        :param str tenant: Name of the tenant to be shared with (required)
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: None
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        return self.delete_licence_assignment_with_http_info(code, tenant, **kwargs)  # noqa: E501
-
-    def delete_licence_assignment_with_http_info(self, code, tenant, **kwargs):  # noqa: E501
-        """[EXPERIMENTAL] Unassign Licence  # noqa: E501
-
-        Remove a Licence assignment from a tenant  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_licence_assignment_with_http_info(code, tenant, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param str code: Code of the Licence (required)
-        :param str tenant: Name of the tenant to be shared with (required)
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: None
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        local_var_params = locals()
-
-        all_params = ['code', 'tenant']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        for key, val in six.iteritems(local_var_params['kwargs']):
-            if key not in all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_licence_assignment" % key
-                )
-            local_var_params[key] = val
-        del local_var_params['kwargs']
-        # verify the required parameter 'code' is set
-        if ('code' not in local_var_params or
-                local_var_params['code'] is None):
-            raise ApiValueError("Missing the required parameter `code` when calling `delete_licence_assignment`")  # noqa: E501
-        # verify the required parameter 'tenant' is set
-        if ('tenant' not in local_var_params or
-                local_var_params['tenant'] is None):
-            raise ApiValueError("Missing the required parameter `tenant` when calling `delete_licence_assignment`")  # noqa: E501
-
-        collection_formats = {}
-
-        path_params = {}
-        if 'code' in local_var_params:
-            path_params['code'] = local_var_params['code']  # noqa: E501
-        if 'tenant' in local_var_params:
-            path_params['tenant'] = local_var_params['tenant']  # noqa: E501
-
-        query_params = []
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
-
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        # set the LUSID header
-        header_params['X-LUSID-SDK-Language'] = 'Python'
-        header_params['X-LUSID-SDK-Version'] = '0.0.616'
-
-        return self.api_client.call_api(
-            '/api/licences/{code}/assignments/{tenant}', 'DELETE',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type=None,  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def get_licence(self, code, **kwargs):  # noqa: E501
-        """[EXPERIMENTAL] Get Licence  # noqa: E501
-
-        Gets an identified Licence  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_licence(code, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param str code: The code of the Licence (required)
-        :param datetime as_at: Optional. The AsAt date time of the data
-        :param str scope: Optional. Will use the default client name if not provided. The scope of the Licence
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: PolicyResponse
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        return self.get_licence_with_http_info(code, **kwargs)  # noqa: E501
-
-    def get_licence_with_http_info(self, code, **kwargs):  # noqa: E501
-        """[EXPERIMENTAL] Get Licence  # noqa: E501
-
-        Gets an identified Licence  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_licence_with_http_info(code, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param str code: The code of the Licence (required)
-        :param datetime as_at: Optional. The AsAt date time of the data
-        :param str scope: Optional. Will use the default client name if not provided. The scope of the Licence
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: tuple(PolicyResponse, status_code(int), headers(HTTPHeaderDict))
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        local_var_params = locals()
-
-        all_params = ['code', 'as_at', 'scope']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        for key, val in six.iteritems(local_var_params['kwargs']):
-            if key not in all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_licence" % key
-                )
-            local_var_params[key] = val
-        del local_var_params['kwargs']
-        # verify the required parameter 'code' is set
-        if ('code' not in local_var_params or
-                local_var_params['code'] is None):
-            raise ApiValueError("Missing the required parameter `code` when calling `get_licence`")  # noqa: E501
-
-        collection_formats = {}
-
-        path_params = {}
-        if 'code' in local_var_params:
-            path_params['code'] = local_var_params['code']  # noqa: E501
-
-        query_params = []
-        if 'as_at' in local_var_params:
-            query_params.append(('asAt', local_var_params['as_at']))  # noqa: E501
-        if 'scope' in local_var_params:
-            query_params.append(('scope', local_var_params['scope']))  # noqa: E501
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
-
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        # set the LUSID header
-        header_params['X-LUSID-SDK-Language'] = 'Python'
-        header_params['X-LUSID-SDK-Version'] = '0.0.616'
-
-        return self.api_client.call_api(
-            '/api/licences/{code}', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='PolicyResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def list_assignments(self, code, **kwargs):  # noqa: E501
-        """[EXPERIMENTAL] List Assignments  # noqa: E501
-
-        List tenants the specified Licence is assigned to  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.list_assignments(code, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param str code: Code of the Licence (required)
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: list[str]
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        return self.list_assignments_with_http_info(code, **kwargs)  # noqa: E501
-
-    def list_assignments_with_http_info(self, code, **kwargs):  # noqa: E501
-        """[EXPERIMENTAL] List Assignments  # noqa: E501
-
-        List tenants the specified Licence is assigned to  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.list_assignments_with_http_info(code, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param str code: Code of the Licence (required)
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: tuple(list[str], status_code(int), headers(HTTPHeaderDict))
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        local_var_params = locals()
-
-        all_params = ['code']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        for key, val in six.iteritems(local_var_params['kwargs']):
-            if key not in all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_assignments" % key
-                )
-            local_var_params[key] = val
-        del local_var_params['kwargs']
-
-        collection_formats = {}
-
-        path_params = {}
-        if 'code' in local_var_params:
-            path_params['code'] = local_var_params['code']  # noqa: E501
-
-        query_params = []
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
-
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        # set the LUSID header
-        header_params['X-LUSID-SDK-Language'] = 'Python'
-        header_params['X-LUSID-SDK-Version'] = '0.0.616'
-
-        return self.api_client.call_api(
-            '/api/licences/{code}/assignments', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='list[str]',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def list_licences(self, **kwargs):  # noqa: E501
-        """[EXPERIMENTAL] List Licences  # noqa: E501
-
-        Gets all Licences in a scope  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.list_licences(async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param str assigned_to: Optional. If specified, applies a filter for only Licences that are assigned to the specified tenant
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: list[PolicyResponse]
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        return self.list_licences_with_http_info(**kwargs)  # noqa: E501
-
-    def list_licences_with_http_info(self, **kwargs):  # noqa: E501
-        """[EXPERIMENTAL] List Licences  # noqa: E501
-
-        Gets all Licences in a scope  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.list_licences_with_http_info(async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param str assigned_to: Optional. If specified, applies a filter for only Licences that are assigned to the specified tenant
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: tuple(list[PolicyResponse], status_code(int), headers(HTTPHeaderDict))
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        local_var_params = locals()
-
-        all_params = ['assigned_to']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        for key, val in six.iteritems(local_var_params['kwargs']):
-            if key not in all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_licences" % key
-                )
-            local_var_params[key] = val
-        del local_var_params['kwargs']
-
-        collection_formats = {}
-
-        path_params = {}
-
-        query_params = []
-        if 'assigned_to' in local_var_params:
-            query_params.append(('assignedTo', local_var_params['assigned_to']))  # noqa: E501
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
-
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        # set the LUSID header
-        header_params['X-LUSID-SDK-Language'] = 'Python'
-        header_params['X-LUSID-SDK-Version'] = '0.0.616'
-
-        return self.api_client.call_api(
-            '/api/licences', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='list[PolicyResponse]',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def update_licence(self, code, licence_update_request, **kwargs):  # noqa: E501
-        """[EXPERIMENTAL] Update Licence  # noqa: E501
-
-        Update an existing Licence policy  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_licence(code, licence_update_request, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param str code: The code of the Licence (required)
-        :param LicenceUpdateRequest licence_update_request: The Licence definition (required)
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: PolicyResponse
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        return self.update_licence_with_http_info(code, licence_update_request, **kwargs)  # noqa: E501
-
-    def update_licence_with_http_info(self, code, licence_update_request, **kwargs):  # noqa: E501
-        """[EXPERIMENTAL] Update Licence  # noqa: E501
-
-        Update an existing Licence policy  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_licence_with_http_info(code, licence_update_request, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param str code: The code of the Licence (required)
-        :param LicenceUpdateRequest licence_update_request: The Licence definition (required)
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: tuple(PolicyResponse, status_code(int), headers(HTTPHeaderDict))
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        local_var_params = locals()
-
-        all_params = ['code', 'licence_update_request']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        for key, val in six.iteritems(local_var_params['kwargs']):
-            if key not in all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_licence" % key
-                )
-            local_var_params[key] = val
-        del local_var_params['kwargs']
-        # verify the required parameter 'code' is set
-        if ('code' not in local_var_params or
-                local_var_params['code'] is None):
-            raise ApiValueError("Missing the required parameter `code` when calling `update_licence`")  # noqa: E501
-        # verify the required parameter 'licence_update_request' is set
-        if ('licence_update_request' not in local_var_params or
-                local_var_params['licence_update_request'] is None):
-            raise ApiValueError("Missing the required parameter `licence_update_request` when calling `update_licence`")  # noqa: E501
-
-        collection_formats = {}
-
-        path_params = {}
-        if 'code' in local_var_params:
-            path_params['code'] = local_var_params['code']  # noqa: E501
-
-        query_params = []
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        if 'licence_update_request' in local_var_params:
-            body_params = local_var_params['licence_update_request']
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
-
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json'])  # noqa: E501
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        # set the LUSID header
-        header_params['X-LUSID-SDK-Language'] = 'Python'
-        header_params['X-LUSID-SDK-Version'] = '0.0.616'
-
-        return self.api_client.call_api(
-            '/api/licences/{code}', 'PUT',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='PolicyResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            collection_formats=collection_formats)
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+from __future__ import absolute_import
+
+import re  # noqa: F401
+
+# python 2 and python 3 compatibility library
+import six
+
+from finbourne_access.api_client import ApiClient
+from finbourne_access.exceptions import (
+    ApiTypeError,
+    ApiValueError
+)
+
+
+class LicencesApi(object):
+    """NOTE: This class is auto generated by OpenAPI Generator
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    def __init__(self, api_client=None):
+        if api_client is None:
+            api_client = ApiClient()
+        self.api_client = api_client
+
+    def create_licence(self, licence_creation_request, **kwargs):  # noqa: E501
+        """[EXPERIMENTAL] Create a Licence  # noqa: E501
+
+        Creates an unassigned Licence policy  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create_licence(licence_creation_request, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param LicenceCreationRequest licence_creation_request: The Licence definition (required)
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: PolicyResponse
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.create_licence_with_http_info(licence_creation_request, **kwargs)  # noqa: E501
+
+    def create_licence_with_http_info(self, licence_creation_request, **kwargs):  # noqa: E501
+        """[EXPERIMENTAL] Create a Licence  # noqa: E501
+
+        Creates an unassigned Licence policy  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create_licence_with_http_info(licence_creation_request, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param LicenceCreationRequest licence_creation_request: The Licence definition (required)
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: tuple(PolicyResponse, status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = ['licence_creation_request']  # noqa: E501
+        all_params.append('async_req')
+        all_params.append('_return_http_data_only')
+        all_params.append('_preload_content')
+        all_params.append('_request_timeout')
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method create_licence" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'licence_creation_request' is set
+        if ('licence_creation_request' not in local_var_params or
+                local_var_params['licence_creation_request'] is None):
+            raise ApiValueError("Missing the required parameter `licence_creation_request` when calling `create_licence`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+
+        query_params = []
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        if 'licence_creation_request' in local_var_params:
+            body_params = local_var_params['licence_creation_request']
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
+            ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json'])  # noqa: E501
+
+        # Authentication setting
+        auth_settings = ['oauth2']  # noqa: E501
+
+        # set the LUSID header
+        header_params['X-LUSID-SDK-Language'] = 'Python'
+        header_params['X-LUSID-SDK-Version'] = '0.0.815'
+
+        return self.api_client.call_api(
+            '/api/licences', 'POST',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='PolicyResponse',  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout'),
+            collection_formats=collection_formats)
+
+    def create_licence_assignment(self, code, tenant, **kwargs):  # noqa: E501
+        """[EXPERIMENTAL] Assign Licence  # noqa: E501
+
+        Create a licence assignment to another, authorised, tenant  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create_licence_assignment(code, tenant, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param str code: Code of the Licence (required)
+        :param str tenant: Name of the tenant to be shared with (required)
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: PolicyResponse
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.create_licence_assignment_with_http_info(code, tenant, **kwargs)  # noqa: E501
+
+    def create_licence_assignment_with_http_info(self, code, tenant, **kwargs):  # noqa: E501
+        """[EXPERIMENTAL] Assign Licence  # noqa: E501
+
+        Create a licence assignment to another, authorised, tenant  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create_licence_assignment_with_http_info(code, tenant, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param str code: Code of the Licence (required)
+        :param str tenant: Name of the tenant to be shared with (required)
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: tuple(PolicyResponse, status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = ['code', 'tenant']  # noqa: E501
+        all_params.append('async_req')
+        all_params.append('_return_http_data_only')
+        all_params.append('_preload_content')
+        all_params.append('_request_timeout')
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method create_licence_assignment" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'code' is set
+        if ('code' not in local_var_params or
+                local_var_params['code'] is None):
+            raise ApiValueError("Missing the required parameter `code` when calling `create_licence_assignment`")  # noqa: E501
+        # verify the required parameter 'tenant' is set
+        if ('tenant' not in local_var_params or
+                local_var_params['tenant'] is None):
+            raise ApiValueError("Missing the required parameter `tenant` when calling `create_licence_assignment`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+        if 'code' in local_var_params:
+            path_params['code'] = local_var_params['code']  # noqa: E501
+        if 'tenant' in local_var_params:
+            path_params['tenant'] = local_var_params['tenant']  # noqa: E501
+
+        query_params = []
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
+
+
+        # Authentication setting
+        auth_settings = ['oauth2']  # noqa: E501
+
+        # set the LUSID header
+        header_params['X-LUSID-SDK-Language'] = 'Python'
+        header_params['X-LUSID-SDK-Version'] = '0.0.815'
+
+        return self.api_client.call_api(
+            '/api/licences/{code}/assignments/{tenant}', 'PUT',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='PolicyResponse',  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout'),
+            collection_formats=collection_formats)
+
+    def delete_licence(self, code, **kwargs):  # noqa: E501
+        """[EXPERIMENTAL] Delete Licence  # noqa: E501
+
+        Deletes an identified Licence  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.delete_licence(code, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param str code: The code of the Licence (required)
+        :param str scope: Optional. Will use the client name if not provided. The scope of the Licence
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: None
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.delete_licence_with_http_info(code, **kwargs)  # noqa: E501
+
+    def delete_licence_with_http_info(self, code, **kwargs):  # noqa: E501
+        """[EXPERIMENTAL] Delete Licence  # noqa: E501
+
+        Deletes an identified Licence  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.delete_licence_with_http_info(code, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param str code: The code of the Licence (required)
+        :param str scope: Optional. Will use the client name if not provided. The scope of the Licence
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: None
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = ['code', 'scope']  # noqa: E501
+        all_params.append('async_req')
+        all_params.append('_return_http_data_only')
+        all_params.append('_preload_content')
+        all_params.append('_request_timeout')
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method delete_licence" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'code' is set
+        if ('code' not in local_var_params or
+                local_var_params['code'] is None):
+            raise ApiValueError("Missing the required parameter `code` when calling `delete_licence`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+        if 'code' in local_var_params:
+            path_params['code'] = local_var_params['code']  # noqa: E501
+
+        query_params = []
+        if 'scope' in local_var_params:
+            query_params.append(('scope', local_var_params['scope']))  # noqa: E501
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
+
+
+        # Authentication setting
+        auth_settings = ['oauth2']  # noqa: E501
+
+        # set the LUSID header
+        header_params['X-LUSID-SDK-Language'] = 'Python'
+        header_params['X-LUSID-SDK-Version'] = '0.0.815'
+
+        return self.api_client.call_api(
+            '/api/licences/{code}', 'DELETE',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type=None,  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout'),
+            collection_formats=collection_formats)
+
+    def delete_licence_assignment(self, code, tenant, **kwargs):  # noqa: E501
+        """[EXPERIMENTAL] Unassign Licence  # noqa: E501
+
+        Remove a Licence assignment from a tenant  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.delete_licence_assignment(code, tenant, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param str code: Code of the Licence (required)
+        :param str tenant: Name of the tenant to be shared with (required)
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: None
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.delete_licence_assignment_with_http_info(code, tenant, **kwargs)  # noqa: E501
+
+    def delete_licence_assignment_with_http_info(self, code, tenant, **kwargs):  # noqa: E501
+        """[EXPERIMENTAL] Unassign Licence  # noqa: E501
+
+        Remove a Licence assignment from a tenant  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.delete_licence_assignment_with_http_info(code, tenant, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param str code: Code of the Licence (required)
+        :param str tenant: Name of the tenant to be shared with (required)
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: None
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = ['code', 'tenant']  # noqa: E501
+        all_params.append('async_req')
+        all_params.append('_return_http_data_only')
+        all_params.append('_preload_content')
+        all_params.append('_request_timeout')
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method delete_licence_assignment" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'code' is set
+        if ('code' not in local_var_params or
+                local_var_params['code'] is None):
+            raise ApiValueError("Missing the required parameter `code` when calling `delete_licence_assignment`")  # noqa: E501
+        # verify the required parameter 'tenant' is set
+        if ('tenant' not in local_var_params or
+                local_var_params['tenant'] is None):
+            raise ApiValueError("Missing the required parameter `tenant` when calling `delete_licence_assignment`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+        if 'code' in local_var_params:
+            path_params['code'] = local_var_params['code']  # noqa: E501
+        if 'tenant' in local_var_params:
+            path_params['tenant'] = local_var_params['tenant']  # noqa: E501
+
+        query_params = []
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
+
+
+        # Authentication setting
+        auth_settings = ['oauth2']  # noqa: E501
+
+        # set the LUSID header
+        header_params['X-LUSID-SDK-Language'] = 'Python'
+        header_params['X-LUSID-SDK-Version'] = '0.0.815'
+
+        return self.api_client.call_api(
+            '/api/licences/{code}/assignments/{tenant}', 'DELETE',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type=None,  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout'),
+            collection_formats=collection_formats)
+
+    def get_licence(self, code, **kwargs):  # noqa: E501
+        """[EXPERIMENTAL] Get Licence  # noqa: E501
+
+        Gets an identified Licence  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.get_licence(code, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param str code: The code of the Licence (required)
+        :param datetime as_at: Optional. The AsAt date time of the data
+        :param str scope: Optional. Will use the default client name if not provided. The scope of the Licence
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: PolicyResponse
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.get_licence_with_http_info(code, **kwargs)  # noqa: E501
+
+    def get_licence_with_http_info(self, code, **kwargs):  # noqa: E501
+        """[EXPERIMENTAL] Get Licence  # noqa: E501
+
+        Gets an identified Licence  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.get_licence_with_http_info(code, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param str code: The code of the Licence (required)
+        :param datetime as_at: Optional. The AsAt date time of the data
+        :param str scope: Optional. Will use the default client name if not provided. The scope of the Licence
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: tuple(PolicyResponse, status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = ['code', 'as_at', 'scope']  # noqa: E501
+        all_params.append('async_req')
+        all_params.append('_return_http_data_only')
+        all_params.append('_preload_content')
+        all_params.append('_request_timeout')
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method get_licence" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'code' is set
+        if ('code' not in local_var_params or
+                local_var_params['code'] is None):
+            raise ApiValueError("Missing the required parameter `code` when calling `get_licence`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+        if 'code' in local_var_params:
+            path_params['code'] = local_var_params['code']  # noqa: E501
+
+        query_params = []
+        if 'as_at' in local_var_params:
+            query_params.append(('asAt', local_var_params['as_at']))  # noqa: E501
+        if 'scope' in local_var_params:
+            query_params.append(('scope', local_var_params['scope']))  # noqa: E501
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
+
+
+        # Authentication setting
+        auth_settings = ['oauth2']  # noqa: E501
+
+        # set the LUSID header
+        header_params['X-LUSID-SDK-Language'] = 'Python'
+        header_params['X-LUSID-SDK-Version'] = '0.0.815'
+
+        return self.api_client.call_api(
+            '/api/licences/{code}', 'GET',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='PolicyResponse',  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout'),
+            collection_formats=collection_formats)
+
+    def list_assignments(self, code, **kwargs):  # noqa: E501
+        """[EXPERIMENTAL] List Assignments  # noqa: E501
+
+        List tenants the specified Licence is assigned to  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.list_assignments(code, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param str code: Code of the Licence (required)
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: list[str]
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.list_assignments_with_http_info(code, **kwargs)  # noqa: E501
+
+    def list_assignments_with_http_info(self, code, **kwargs):  # noqa: E501
+        """[EXPERIMENTAL] List Assignments  # noqa: E501
+
+        List tenants the specified Licence is assigned to  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.list_assignments_with_http_info(code, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param str code: Code of the Licence (required)
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: tuple(list[str], status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = ['code']  # noqa: E501
+        all_params.append('async_req')
+        all_params.append('_return_http_data_only')
+        all_params.append('_preload_content')
+        all_params.append('_request_timeout')
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method list_assignments" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+
+        collection_formats = {}
+
+        path_params = {}
+        if 'code' in local_var_params:
+            path_params['code'] = local_var_params['code']  # noqa: E501
+
+        query_params = []
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
+
+
+        # Authentication setting
+        auth_settings = ['oauth2']  # noqa: E501
+
+        # set the LUSID header
+        header_params['X-LUSID-SDK-Language'] = 'Python'
+        header_params['X-LUSID-SDK-Version'] = '0.0.815'
+
+        return self.api_client.call_api(
+            '/api/licences/{code}/assignments', 'GET',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='list[str]',  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout'),
+            collection_formats=collection_formats)
+
+    def list_licences(self, **kwargs):  # noqa: E501
+        """[EXPERIMENTAL] List Licences  # noqa: E501
+
+        Gets all Licences in a scope  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.list_licences(async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param str assigned_to: Optional. If specified, applies a filter for only Licences that are assigned to the specified tenant
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: list[PolicyResponse]
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.list_licences_with_http_info(**kwargs)  # noqa: E501
+
+    def list_licences_with_http_info(self, **kwargs):  # noqa: E501
+        """[EXPERIMENTAL] List Licences  # noqa: E501
+
+        Gets all Licences in a scope  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.list_licences_with_http_info(async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param str assigned_to: Optional. If specified, applies a filter for only Licences that are assigned to the specified tenant
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: tuple(list[PolicyResponse], status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = ['assigned_to']  # noqa: E501
+        all_params.append('async_req')
+        all_params.append('_return_http_data_only')
+        all_params.append('_preload_content')
+        all_params.append('_request_timeout')
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method list_licences" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+
+        collection_formats = {}
+
+        path_params = {}
+
+        query_params = []
+        if 'assigned_to' in local_var_params:
+            query_params.append(('assignedTo', local_var_params['assigned_to']))  # noqa: E501
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
+
+
+        # Authentication setting
+        auth_settings = ['oauth2']  # noqa: E501
+
+        # set the LUSID header
+        header_params['X-LUSID-SDK-Language'] = 'Python'
+        header_params['X-LUSID-SDK-Version'] = '0.0.815'
+
+        return self.api_client.call_api(
+            '/api/licences', 'GET',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='list[PolicyResponse]',  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout'),
+            collection_formats=collection_formats)
+
+    def update_licence(self, code, licence_update_request, **kwargs):  # noqa: E501
+        """[EXPERIMENTAL] Update Licence  # noqa: E501
+
+        Update an existing Licence policy  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.update_licence(code, licence_update_request, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param str code: The code of the Licence (required)
+        :param LicenceUpdateRequest licence_update_request: The Licence definition (required)
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: PolicyResponse
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.update_licence_with_http_info(code, licence_update_request, **kwargs)  # noqa: E501
+
+    def update_licence_with_http_info(self, code, licence_update_request, **kwargs):  # noqa: E501
+        """[EXPERIMENTAL] Update Licence  # noqa: E501
+
+        Update an existing Licence policy  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.update_licence_with_http_info(code, licence_update_request, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param str code: The code of the Licence (required)
+        :param LicenceUpdateRequest licence_update_request: The Licence definition (required)
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: tuple(PolicyResponse, status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = ['code', 'licence_update_request']  # noqa: E501
+        all_params.append('async_req')
+        all_params.append('_return_http_data_only')
+        all_params.append('_preload_content')
+        all_params.append('_request_timeout')
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method update_licence" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'code' is set
+        if ('code' not in local_var_params or
+                local_var_params['code'] is None):
+            raise ApiValueError("Missing the required parameter `code` when calling `update_licence`")  # noqa: E501
+        # verify the required parameter 'licence_update_request' is set
+        if ('licence_update_request' not in local_var_params or
+                local_var_params['licence_update_request'] is None):
+            raise ApiValueError("Missing the required parameter `licence_update_request` when calling `update_licence`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+        if 'code' in local_var_params:
+            path_params['code'] = local_var_params['code']  # noqa: E501
+
+        query_params = []
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        if 'licence_update_request' in local_var_params:
+            body_params = local_var_params['licence_update_request']
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
+            ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json'])  # noqa: E501
+
+        # Authentication setting
+        auth_settings = ['oauth2']  # noqa: E501
+
+        # set the LUSID header
+        header_params['X-LUSID-SDK-Language'] = 'Python'
+        header_params['X-LUSID-SDK-Version'] = '0.0.815'
+
+        return self.api_client.call_api(
+            '/api/licences/{code}', 'PUT',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='PolicyResponse',  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout'),
+            collection_formats=collection_formats)
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/api/roles_api.py` & `finbourne-access-sdk-0.0.815/finbourne_access/api/roles_api.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,666 +1,666 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-from __future__ import absolute_import
-
-import re  # noqa: F401
-
-# python 2 and python 3 compatibility library
-import six
-
-from finbourne_access.api_client import ApiClient
-from finbourne_access.exceptions import (
-    ApiTypeError,
-    ApiValueError
-)
-
-
-class RolesApi(object):
-    """NOTE: This class is auto generated by OpenAPI Generator
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    def __init__(self, api_client=None):
-        if api_client is None:
-            api_client = ApiClient()
-        self.api_client = api_client
-
-    def create_role(self, role_creation_request, **kwargs):  # noqa: E501
-        """[EARLY ACCESS] Create Role  # noqa: E501
-
-        Creates a Role  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_role(role_creation_request, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param RoleCreationRequest role_creation_request: The definition of the Role (required)
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: RoleResponse
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        return self.create_role_with_http_info(role_creation_request, **kwargs)  # noqa: E501
-
-    def create_role_with_http_info(self, role_creation_request, **kwargs):  # noqa: E501
-        """[EARLY ACCESS] Create Role  # noqa: E501
-
-        Creates a Role  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_role_with_http_info(role_creation_request, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param RoleCreationRequest role_creation_request: The definition of the Role (required)
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: tuple(RoleResponse, status_code(int), headers(HTTPHeaderDict))
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        local_var_params = locals()
-
-        all_params = ['role_creation_request']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        for key, val in six.iteritems(local_var_params['kwargs']):
-            if key not in all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_role" % key
-                )
-            local_var_params[key] = val
-        del local_var_params['kwargs']
-        # verify the required parameter 'role_creation_request' is set
-        if ('role_creation_request' not in local_var_params or
-                local_var_params['role_creation_request'] is None):
-            raise ApiValueError("Missing the required parameter `role_creation_request` when calling `create_role`")  # noqa: E501
-
-        collection_formats = {}
-
-        path_params = {}
-
-        query_params = []
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        if 'role_creation_request' in local_var_params:
-            body_params = local_var_params['role_creation_request']
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
-
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json'])  # noqa: E501
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        # set the LUSID header
-        header_params['X-LUSID-SDK-Language'] = 'Python'
-        header_params['X-LUSID-SDK-Version'] = '0.0.616'
-
-        return self.api_client.call_api(
-            '/api/roles', 'POST',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='RoleResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def delete_role(self, code, **kwargs):  # noqa: E501
-        """[EARLY ACCESS] Delete Role  # noqa: E501
-
-        Deletes an identified Role  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_role(code, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param str code: The code of the Role (required)
-        :param str scope: >Optional. Will use default scope if not supplied. The scope of the Role
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: None
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        return self.delete_role_with_http_info(code, **kwargs)  # noqa: E501
-
-    def delete_role_with_http_info(self, code, **kwargs):  # noqa: E501
-        """[EARLY ACCESS] Delete Role  # noqa: E501
-
-        Deletes an identified Role  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_role_with_http_info(code, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param str code: The code of the Role (required)
-        :param str scope: >Optional. Will use default scope if not supplied. The scope of the Role
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: None
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        local_var_params = locals()
-
-        all_params = ['code', 'scope']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        for key, val in six.iteritems(local_var_params['kwargs']):
-            if key not in all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_role" % key
-                )
-            local_var_params[key] = val
-        del local_var_params['kwargs']
-        # verify the required parameter 'code' is set
-        if ('code' not in local_var_params or
-                local_var_params['code'] is None):
-            raise ApiValueError("Missing the required parameter `code` when calling `delete_role`")  # noqa: E501
-
-        collection_formats = {}
-
-        path_params = {}
-        if 'code' in local_var_params:
-            path_params['code'] = local_var_params['code']  # noqa: E501
-
-        query_params = []
-        if 'scope' in local_var_params:
-            query_params.append(('scope', local_var_params['scope']))  # noqa: E501
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
-
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        # set the LUSID header
-        header_params['X-LUSID-SDK-Language'] = 'Python'
-        header_params['X-LUSID-SDK-Version'] = '0.0.616'
-
-        return self.api_client.call_api(
-            '/api/roles/{code}', 'DELETE',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type=None,  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def get_role(self, code, **kwargs):  # noqa: E501
-        """[EARLY ACCESS] Get Role  # noqa: E501
-
-        Gets an identified Role  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_role(code, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param str code: The code of the Role (required)
-        :param datetime as_at: Optional. The AsAt date time of the data
-        :param str scope: Optional. Will use default scope if not supplied. The scope of the Role
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: RoleResponse
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        return self.get_role_with_http_info(code, **kwargs)  # noqa: E501
-
-    def get_role_with_http_info(self, code, **kwargs):  # noqa: E501
-        """[EARLY ACCESS] Get Role  # noqa: E501
-
-        Gets an identified Role  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_role_with_http_info(code, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param str code: The code of the Role (required)
-        :param datetime as_at: Optional. The AsAt date time of the data
-        :param str scope: Optional. Will use default scope if not supplied. The scope of the Role
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: tuple(RoleResponse, status_code(int), headers(HTTPHeaderDict))
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        local_var_params = locals()
-
-        all_params = ['code', 'as_at', 'scope']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        for key, val in six.iteritems(local_var_params['kwargs']):
-            if key not in all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_role" % key
-                )
-            local_var_params[key] = val
-        del local_var_params['kwargs']
-        # verify the required parameter 'code' is set
-        if ('code' not in local_var_params or
-                local_var_params['code'] is None):
-            raise ApiValueError("Missing the required parameter `code` when calling `get_role`")  # noqa: E501
-
-        collection_formats = {}
-
-        path_params = {}
-        if 'code' in local_var_params:
-            path_params['code'] = local_var_params['code']  # noqa: E501
-
-        query_params = []
-        if 'as_at' in local_var_params:
-            query_params.append(('asAt', local_var_params['as_at']))  # noqa: E501
-        if 'scope' in local_var_params:
-            query_params.append(('scope', local_var_params['scope']))  # noqa: E501
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
-
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        # set the LUSID header
-        header_params['X-LUSID-SDK-Language'] = 'Python'
-        header_params['X-LUSID-SDK-Version'] = '0.0.616'
-
-        return self.api_client.call_api(
-            '/api/roles/{code}', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='RoleResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def list_roles(self, **kwargs):  # noqa: E501
-        """[EARLY ACCESS] List Roles  # noqa: E501
-
-        Gets all Roles in a scope  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.list_roles(async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param str scope: Optional. Will use all scopes if not supplied. The requested scope
-        :param datetime as_at: Optional. The AsAt date time of the data
-        :param list[str] sort_by: Optional. Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName
-        :param int start: Optional. When paginating, skip this number of results
-        :param int limit: Optional. When paginating, limit the number of returned results to this many.
-        :param str filter: Optional. Expression to filter the result set
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: list[RoleResponse]
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        return self.list_roles_with_http_info(**kwargs)  # noqa: E501
-
-    def list_roles_with_http_info(self, **kwargs):  # noqa: E501
-        """[EARLY ACCESS] List Roles  # noqa: E501
-
-        Gets all Roles in a scope  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.list_roles_with_http_info(async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param str scope: Optional. Will use all scopes if not supplied. The requested scope
-        :param datetime as_at: Optional. The AsAt date time of the data
-        :param list[str] sort_by: Optional. Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName
-        :param int start: Optional. When paginating, skip this number of results
-        :param int limit: Optional. When paginating, limit the number of returned results to this many.
-        :param str filter: Optional. Expression to filter the result set
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: tuple(list[RoleResponse], status_code(int), headers(HTTPHeaderDict))
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        local_var_params = locals()
-
-        all_params = ['scope', 'as_at', 'sort_by', 'start', 'limit', 'filter']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        for key, val in six.iteritems(local_var_params['kwargs']):
-            if key not in all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method list_roles" % key
-                )
-            local_var_params[key] = val
-        del local_var_params['kwargs']
-
-        collection_formats = {}
-
-        path_params = {}
-
-        query_params = []
-        if 'scope' in local_var_params:
-            query_params.append(('scope', local_var_params['scope']))  # noqa: E501
-        if 'as_at' in local_var_params:
-            query_params.append(('asAt', local_var_params['as_at']))  # noqa: E501
-        if 'sort_by' in local_var_params:
-            query_params.append(('sortBy', local_var_params['sort_by']))  # noqa: E501
-            collection_formats['sortBy'] = 'multi'  # noqa: E501
-        if 'start' in local_var_params:
-            query_params.append(('start', local_var_params['start']))  # noqa: E501
-        if 'limit' in local_var_params:
-            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
-        if 'filter' in local_var_params:
-            query_params.append(('filter', local_var_params['filter']))  # noqa: E501
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
-
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        # set the LUSID header
-        header_params['X-LUSID-SDK-Language'] = 'Python'
-        header_params['X-LUSID-SDK-Version'] = '0.0.616'
-
-        return self.api_client.call_api(
-            '/api/roles', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='list[RoleResponse]',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def update_role(self, code, role_update_request, **kwargs):  # noqa: E501
-        """[EARLY ACCESS] Update Role  # noqa: E501
-
-        Updates a Role  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_role(code, role_update_request, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param str code: The code of the Role (required)
-        :param RoleUpdateRequest role_update_request: The updated definition of the Role (required)
-        :param str scope: >Optional. Will use default scope if not supplied. The scope of the Role
-        :param str before_scope: Optional. The scope of the Role. Will use default scope if not supplied.
-        :param str before_code: Optional. The code of the Role
-        :param str after_scope: Optional. The scope of the Role. Will use default scope if not supplied.
-        :param str after_code: Optional. The code of the Role
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: RoleResponse
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        return self.update_role_with_http_info(code, role_update_request, **kwargs)  # noqa: E501
-
-    def update_role_with_http_info(self, code, role_update_request, **kwargs):  # noqa: E501
-        """[EARLY ACCESS] Update Role  # noqa: E501
-
-        Updates a Role  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_role_with_http_info(code, role_update_request, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool: execute request asynchronously
-        :param str code: The code of the Role (required)
-        :param RoleUpdateRequest role_update_request: The updated definition of the Role (required)
-        :param str scope: >Optional. Will use default scope if not supplied. The scope of the Role
-        :param str before_scope: Optional. The scope of the Role. Will use default scope if not supplied.
-        :param str before_code: Optional. The code of the Role
-        :param str after_scope: Optional. The scope of the Role. Will use default scope if not supplied.
-        :param str after_code: Optional. The code of the Role
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return: tuple(RoleResponse, status_code(int), headers(HTTPHeaderDict))
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        local_var_params = locals()
-
-        all_params = ['code', 'role_update_request', 'scope', 'before_scope', 'before_code', 'after_scope', 'after_code']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        for key, val in six.iteritems(local_var_params['kwargs']):
-            if key not in all_params:
-                raise ApiTypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_role" % key
-                )
-            local_var_params[key] = val
-        del local_var_params['kwargs']
-        # verify the required parameter 'code' is set
-        if ('code' not in local_var_params or
-                local_var_params['code'] is None):
-            raise ApiValueError("Missing the required parameter `code` when calling `update_role`")  # noqa: E501
-        # verify the required parameter 'role_update_request' is set
-        if ('role_update_request' not in local_var_params or
-                local_var_params['role_update_request'] is None):
-            raise ApiValueError("Missing the required parameter `role_update_request` when calling `update_role`")  # noqa: E501
-
-        collection_formats = {}
-
-        path_params = {}
-        if 'code' in local_var_params:
-            path_params['code'] = local_var_params['code']  # noqa: E501
-
-        query_params = []
-        if 'scope' in local_var_params:
-            query_params.append(('scope', local_var_params['scope']))  # noqa: E501
-        if 'before_scope' in local_var_params:
-            query_params.append(('beforeScope', local_var_params['before_scope']))  # noqa: E501
-        if 'before_code' in local_var_params:
-            query_params.append(('beforeCode', local_var_params['before_code']))  # noqa: E501
-        if 'after_scope' in local_var_params:
-            query_params.append(('afterScope', local_var_params['after_scope']))  # noqa: E501
-        if 'after_code' in local_var_params:
-            query_params.append(('afterCode', local_var_params['after_code']))  # noqa: E501
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        if 'role_update_request' in local_var_params:
-            body_params = local_var_params['role_update_request']
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
-
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json'])  # noqa: E501
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        # set the LUSID header
-        header_params['X-LUSID-SDK-Language'] = 'Python'
-        header_params['X-LUSID-SDK-Version'] = '0.0.616'
-
-        return self.api_client.call_api(
-            '/api/roles/{code}', 'PUT',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='RoleResponse',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=local_var_params.get('async_req'),
-            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
-            _preload_content=local_var_params.get('_preload_content', True),
-            _request_timeout=local_var_params.get('_request_timeout'),
-            collection_formats=collection_formats)
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+from __future__ import absolute_import
+
+import re  # noqa: F401
+
+# python 2 and python 3 compatibility library
+import six
+
+from finbourne_access.api_client import ApiClient
+from finbourne_access.exceptions import (
+    ApiTypeError,
+    ApiValueError
+)
+
+
+class RolesApi(object):
+    """NOTE: This class is auto generated by OpenAPI Generator
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    def __init__(self, api_client=None):
+        if api_client is None:
+            api_client = ApiClient()
+        self.api_client = api_client
+
+    def create_role(self, role_creation_request, **kwargs):  # noqa: E501
+        """[EARLY ACCESS] Create Role  # noqa: E501
+
+        Creates a Role  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create_role(role_creation_request, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param RoleCreationRequest role_creation_request: The definition of the Role (required)
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: RoleResponse
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.create_role_with_http_info(role_creation_request, **kwargs)  # noqa: E501
+
+    def create_role_with_http_info(self, role_creation_request, **kwargs):  # noqa: E501
+        """[EARLY ACCESS] Create Role  # noqa: E501
+
+        Creates a Role  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.create_role_with_http_info(role_creation_request, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param RoleCreationRequest role_creation_request: The definition of the Role (required)
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: tuple(RoleResponse, status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = ['role_creation_request']  # noqa: E501
+        all_params.append('async_req')
+        all_params.append('_return_http_data_only')
+        all_params.append('_preload_content')
+        all_params.append('_request_timeout')
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method create_role" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'role_creation_request' is set
+        if ('role_creation_request' not in local_var_params or
+                local_var_params['role_creation_request'] is None):
+            raise ApiValueError("Missing the required parameter `role_creation_request` when calling `create_role`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+
+        query_params = []
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        if 'role_creation_request' in local_var_params:
+            body_params = local_var_params['role_creation_request']
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
+            ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json'])  # noqa: E501
+
+        # Authentication setting
+        auth_settings = ['oauth2']  # noqa: E501
+
+        # set the LUSID header
+        header_params['X-LUSID-SDK-Language'] = 'Python'
+        header_params['X-LUSID-SDK-Version'] = '0.0.815'
+
+        return self.api_client.call_api(
+            '/api/roles', 'POST',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='RoleResponse',  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout'),
+            collection_formats=collection_formats)
+
+    def delete_role(self, code, **kwargs):  # noqa: E501
+        """[EARLY ACCESS] Delete Role  # noqa: E501
+
+        Deletes an identified Role  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.delete_role(code, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param str code: The code of the Role (required)
+        :param str scope: >Optional. Will use default scope if not supplied. The scope of the Role
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: None
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.delete_role_with_http_info(code, **kwargs)  # noqa: E501
+
+    def delete_role_with_http_info(self, code, **kwargs):  # noqa: E501
+        """[EARLY ACCESS] Delete Role  # noqa: E501
+
+        Deletes an identified Role  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.delete_role_with_http_info(code, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param str code: The code of the Role (required)
+        :param str scope: >Optional. Will use default scope if not supplied. The scope of the Role
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: None
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = ['code', 'scope']  # noqa: E501
+        all_params.append('async_req')
+        all_params.append('_return_http_data_only')
+        all_params.append('_preload_content')
+        all_params.append('_request_timeout')
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method delete_role" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'code' is set
+        if ('code' not in local_var_params or
+                local_var_params['code'] is None):
+            raise ApiValueError("Missing the required parameter `code` when calling `delete_role`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+        if 'code' in local_var_params:
+            path_params['code'] = local_var_params['code']  # noqa: E501
+
+        query_params = []
+        if 'scope' in local_var_params:
+            query_params.append(('scope', local_var_params['scope']))  # noqa: E501
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
+
+
+        # Authentication setting
+        auth_settings = ['oauth2']  # noqa: E501
+
+        # set the LUSID header
+        header_params['X-LUSID-SDK-Language'] = 'Python'
+        header_params['X-LUSID-SDK-Version'] = '0.0.815'
+
+        return self.api_client.call_api(
+            '/api/roles/{code}', 'DELETE',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type=None,  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout'),
+            collection_formats=collection_formats)
+
+    def get_role(self, code, **kwargs):  # noqa: E501
+        """[EARLY ACCESS] Get Role  # noqa: E501
+
+        Gets an identified Role  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.get_role(code, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param str code: The code of the Role (required)
+        :param datetime as_at: Optional. The AsAt date time of the data
+        :param str scope: Optional. Will use default scope if not supplied. The scope of the Role
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: RoleResponse
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.get_role_with_http_info(code, **kwargs)  # noqa: E501
+
+    def get_role_with_http_info(self, code, **kwargs):  # noqa: E501
+        """[EARLY ACCESS] Get Role  # noqa: E501
+
+        Gets an identified Role  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.get_role_with_http_info(code, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param str code: The code of the Role (required)
+        :param datetime as_at: Optional. The AsAt date time of the data
+        :param str scope: Optional. Will use default scope if not supplied. The scope of the Role
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: tuple(RoleResponse, status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = ['code', 'as_at', 'scope']  # noqa: E501
+        all_params.append('async_req')
+        all_params.append('_return_http_data_only')
+        all_params.append('_preload_content')
+        all_params.append('_request_timeout')
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method get_role" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'code' is set
+        if ('code' not in local_var_params or
+                local_var_params['code'] is None):
+            raise ApiValueError("Missing the required parameter `code` when calling `get_role`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+        if 'code' in local_var_params:
+            path_params['code'] = local_var_params['code']  # noqa: E501
+
+        query_params = []
+        if 'as_at' in local_var_params:
+            query_params.append(('asAt', local_var_params['as_at']))  # noqa: E501
+        if 'scope' in local_var_params:
+            query_params.append(('scope', local_var_params['scope']))  # noqa: E501
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
+
+
+        # Authentication setting
+        auth_settings = ['oauth2']  # noqa: E501
+
+        # set the LUSID header
+        header_params['X-LUSID-SDK-Language'] = 'Python'
+        header_params['X-LUSID-SDK-Version'] = '0.0.815'
+
+        return self.api_client.call_api(
+            '/api/roles/{code}', 'GET',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='RoleResponse',  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout'),
+            collection_formats=collection_formats)
+
+    def list_roles(self, **kwargs):  # noqa: E501
+        """[EARLY ACCESS] List Roles  # noqa: E501
+
+        Gets all Roles in a scope  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.list_roles(async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param str scope: Optional. Will use all scopes if not supplied. The requested scope
+        :param datetime as_at: Optional. The AsAt date time of the data
+        :param list[str] sort_by: Optional. Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName
+        :param int start: Optional. When paginating, skip this number of results
+        :param int limit: Optional. When paginating, limit the number of returned results to this many.
+        :param str filter: Optional. Expression to filter the result set
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: list[RoleResponse]
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.list_roles_with_http_info(**kwargs)  # noqa: E501
+
+    def list_roles_with_http_info(self, **kwargs):  # noqa: E501
+        """[EARLY ACCESS] List Roles  # noqa: E501
+
+        Gets all Roles in a scope  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.list_roles_with_http_info(async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param str scope: Optional. Will use all scopes if not supplied. The requested scope
+        :param datetime as_at: Optional. The AsAt date time of the data
+        :param list[str] sort_by: Optional. Order the results by these fields. Use use the '-' sign to denote descending order e.g. -MyFieldName
+        :param int start: Optional. When paginating, skip this number of results
+        :param int limit: Optional. When paginating, limit the number of returned results to this many.
+        :param str filter: Optional. Expression to filter the result set
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: tuple(list[RoleResponse], status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = ['scope', 'as_at', 'sort_by', 'start', 'limit', 'filter']  # noqa: E501
+        all_params.append('async_req')
+        all_params.append('_return_http_data_only')
+        all_params.append('_preload_content')
+        all_params.append('_request_timeout')
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method list_roles" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+
+        collection_formats = {}
+
+        path_params = {}
+
+        query_params = []
+        if 'scope' in local_var_params:
+            query_params.append(('scope', local_var_params['scope']))  # noqa: E501
+        if 'as_at' in local_var_params:
+            query_params.append(('asAt', local_var_params['as_at']))  # noqa: E501
+        if 'sort_by' in local_var_params:
+            query_params.append(('sortBy', local_var_params['sort_by']))  # noqa: E501
+            collection_formats['sortBy'] = 'multi'  # noqa: E501
+        if 'start' in local_var_params:
+            query_params.append(('start', local_var_params['start']))  # noqa: E501
+        if 'limit' in local_var_params:
+            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
+        if 'filter' in local_var_params:
+            query_params.append(('filter', local_var_params['filter']))  # noqa: E501
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
+
+
+        # Authentication setting
+        auth_settings = ['oauth2']  # noqa: E501
+
+        # set the LUSID header
+        header_params['X-LUSID-SDK-Language'] = 'Python'
+        header_params['X-LUSID-SDK-Version'] = '0.0.815'
+
+        return self.api_client.call_api(
+            '/api/roles', 'GET',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='list[RoleResponse]',  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout'),
+            collection_formats=collection_formats)
+
+    def update_role(self, code, role_update_request, **kwargs):  # noqa: E501
+        """[EARLY ACCESS] Update Role  # noqa: E501
+
+        Updates a Role  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.update_role(code, role_update_request, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param str code: The code of the Role (required)
+        :param RoleUpdateRequest role_update_request: The updated definition of the Role (required)
+        :param str scope: >Optional. Will use default scope if not supplied. The scope of the Role
+        :param str before_scope: Optional. The scope of the Role. Will use default scope if not supplied.
+        :param str before_code: Optional. The code of the Role
+        :param str after_scope: Optional. The scope of the Role. Will use default scope if not supplied.
+        :param str after_code: Optional. The code of the Role
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: RoleResponse
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.update_role_with_http_info(code, role_update_request, **kwargs)  # noqa: E501
+
+    def update_role_with_http_info(self, code, role_update_request, **kwargs):  # noqa: E501
+        """[EARLY ACCESS] Update Role  # noqa: E501
+
+        Updates a Role  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.update_role_with_http_info(code, role_update_request, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param str code: The code of the Role (required)
+        :param RoleUpdateRequest role_update_request: The updated definition of the Role (required)
+        :param str scope: >Optional. Will use default scope if not supplied. The scope of the Role
+        :param str before_scope: Optional. The scope of the Role. Will use default scope if not supplied.
+        :param str before_code: Optional. The code of the Role
+        :param str after_scope: Optional. The scope of the Role. Will use default scope if not supplied.
+        :param str after_code: Optional. The code of the Role
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: tuple(RoleResponse, status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = ['code', 'role_update_request', 'scope', 'before_scope', 'before_code', 'after_scope', 'after_code']  # noqa: E501
+        all_params.append('async_req')
+        all_params.append('_return_http_data_only')
+        all_params.append('_preload_content')
+        all_params.append('_request_timeout')
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method update_role" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+        # verify the required parameter 'code' is set
+        if ('code' not in local_var_params or
+                local_var_params['code'] is None):
+            raise ApiValueError("Missing the required parameter `code` when calling `update_role`")  # noqa: E501
+        # verify the required parameter 'role_update_request' is set
+        if ('role_update_request' not in local_var_params or
+                local_var_params['role_update_request'] is None):
+            raise ApiValueError("Missing the required parameter `role_update_request` when calling `update_role`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+        if 'code' in local_var_params:
+            path_params['code'] = local_var_params['code']  # noqa: E501
+
+        query_params = []
+        if 'scope' in local_var_params:
+            query_params.append(('scope', local_var_params['scope']))  # noqa: E501
+        if 'before_scope' in local_var_params:
+            query_params.append(('beforeScope', local_var_params['before_scope']))  # noqa: E501
+        if 'before_code' in local_var_params:
+            query_params.append(('beforeCode', local_var_params['before_code']))  # noqa: E501
+        if 'after_scope' in local_var_params:
+            query_params.append(('afterScope', local_var_params['after_scope']))  # noqa: E501
+        if 'after_code' in local_var_params:
+            query_params.append(('afterCode', local_var_params['after_code']))  # noqa: E501
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        if 'role_update_request' in local_var_params:
+            body_params = local_var_params['role_update_request']
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['text/plain', 'application/json', 'text/json'])  # noqa: E501
+
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
+            ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json'])  # noqa: E501
+
+        # Authentication setting
+        auth_settings = ['oauth2']  # noqa: E501
+
+        # set the LUSID header
+        header_params['X-LUSID-SDK-Language'] = 'Python'
+        header_params['X-LUSID-SDK-Version'] = '0.0.815'
+
+        return self.api_client.call_api(
+            '/api/roles/{code}', 'PUT',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='RoleResponse',  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout'),
+            collection_formats=collection_formats)
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/api_client.py` & `finbourne-access-sdk-0.0.815/finbourne_access/api_client.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,641 +1,641 @@
-# coding: utf-8
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-from __future__ import absolute_import
-
-import datetime
-import json
-import mimetypes
-from multiprocessing.pool import ThreadPool
-import os
-import re
-import tempfile
-
-# python 2 and python 3 compatibility library
-import six
-from six.moves.urllib.parse import quote
-
-from finbourne_access.configuration import Configuration
-import finbourne_access.models
-from finbourne_access import rest
-from finbourne_access.exceptions import ApiValueError
-
-
-class ApiClient(object):
-    """Generic API client for OpenAPI client library builds.
-
-    OpenAPI generic API client. This client handles the client-
-    server communication, and is invariant across implementations. Specifics of
-    the methods and models for each application are generated from the OpenAPI
-    templates.
-
-    NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-    Do not edit the class manually.
-
-    :param configuration: .Configuration object for this client
-    :param header_name: a header to pass when making calls to the API.
-    :param header_value: a header value to pass when making calls to
-        the API.
-    :param cookie: a cookie to include in the header when making calls
-        to the API
-    :param pool_threads: The number of threads to use for async requests
-        to the API. More threads means more concurrent API requests.
-    """
-
-    PRIMITIVE_TYPES = (float, bool, bytes, six.text_type) + six.integer_types
-    NATIVE_TYPES_MAPPING = {
-        'int': int,
-        'long': int if six.PY3 else long,  # noqa: F821
-        'float': float,
-        'str': str,
-        'bool': bool,
-        'date': datetime.date,
-        'datetime': datetime.datetime,
-        'object': object,
-    }
-    _pool = None
-
-    def __init__(self, configuration=None, header_name=None, header_value=None,
-                 cookie=None, pool_threads=1):
-        if configuration is None:
-            configuration = Configuration()
-        self.configuration = configuration
-        self.pool_threads = pool_threads
-
-        self.rest_client = rest.RESTClientObject(configuration)
-        self.default_headers = {}
-        if header_name is not None:
-            self.default_headers[header_name] = header_value
-        self.cookie = cookie
-        # Set default User-Agent.
-        self.user_agent = 'OpenAPI-Generator/0.0.616/python'
-
-    def __del__(self):
-        if self._pool:
-            self._pool.close()
-            self._pool.join()
-            self._pool = None
-
-    @property
-    def pool(self):
-        """Create thread pool on first request
-         avoids instantiating unused threadpool for blocking clients.
-        """
-        if self._pool is None:
-            self._pool = ThreadPool(self.pool_threads)
-        return self._pool
-
-    @property
-    def user_agent(self):
-        """User agent for this API client"""
-        return self.default_headers['User-Agent']
-
-    @user_agent.setter
-    def user_agent(self, value):
-        self.default_headers['User-Agent'] = value
-
-    def set_default_header(self, header_name, header_value):
-        self.default_headers[header_name] = header_value
-
-    def __call_api(
-            self, resource_path, method, path_params=None,
-            query_params=None, header_params=None, body=None, post_params=None,
-            files=None, response_type=None, auth_settings=None,
-            _return_http_data_only=None, collection_formats=None,
-            _preload_content=True, _request_timeout=None, _host=None):
-
-        config = self.configuration
-
-        # header parameters
-        header_params = header_params or {}
-        header_params.update(self.default_headers)
-        if self.cookie:
-            header_params['Cookie'] = self.cookie
-        if header_params:
-            header_params = self.sanitize_for_serialization(header_params)
-            header_params = dict(self.parameters_to_tuples(header_params,
-                                                           collection_formats))
-
-        # path parameters
-        if path_params:
-            path_params = self.sanitize_for_serialization(path_params)
-            path_params = self.parameters_to_tuples(path_params,
-                                                    collection_formats)
-            for k, v in path_params:
-                # specified safe chars, encode everything
-                resource_path = resource_path.replace(
-                    '{%s}' % k,
-                    quote(str(v), safe=config.safe_chars_for_path_param)
-                )
-
-        # query parameters
-        if query_params:
-            query_params = self.sanitize_for_serialization(query_params)
-            query_params = self.parameters_to_tuples(query_params,
-                                                     collection_formats)
-
-        # post parameters
-        if post_params or files:
-            post_params = post_params if post_params else []
-            post_params = self.sanitize_for_serialization(post_params)
-            post_params = self.parameters_to_tuples(post_params,
-                                                    collection_formats)
-            post_params.extend(self.files_parameters(files))
-
-        # auth setting
-        self.update_params_for_auth(header_params, query_params, auth_settings)
-
-        # body
-        if body:
-            body = self.sanitize_for_serialization(body)
-
-        # request url
-        if _host is None:
-            url = self.configuration.host + resource_path
-        else:
-            # use server/host defined in path or operation instead
-            url = _host + resource_path
-
-        # perform request and return response
-        response_data = self.request(
-            method, url, query_params=query_params, headers=header_params,
-            post_params=post_params, body=body,
-            _preload_content=_preload_content,
-            _request_timeout=_request_timeout)
-
-        self.last_response = response_data
-
-        return_data = response_data
-        if _preload_content:
-            # deserialize response data
-            if response_type:
-                return_data = self.deserialize(response_data, response_type)
-            else:
-                return_data = None
-
-        if _return_http_data_only:
-            return (return_data)
-        else:
-            return (return_data, response_data.status,
-                    response_data.getheaders())
-
-    def sanitize_for_serialization(self, obj):
-        """Builds a JSON POST object.
-
-        If obj is None, return None.
-        If obj is str, int, long, float, bool, return directly.
-        If obj is datetime.datetime, datetime.date
-            convert to string in iso8601 format.
-        If obj is list, sanitize each element in the list.
-        If obj is dict, return the dict.
-        If obj is OpenAPI model, return the properties dict.
-
-        :param obj: The data to serialize.
-        :return: The serialized form of data.
-        """
-        if obj is None:
-            return None
-        elif isinstance(obj, self.PRIMITIVE_TYPES):
-            return obj
-        elif isinstance(obj, list):
-            return [self.sanitize_for_serialization(sub_obj)
-                    for sub_obj in obj]
-        elif isinstance(obj, tuple):
-            return tuple(self.sanitize_for_serialization(sub_obj)
-                         for sub_obj in obj)
-        elif isinstance(obj, (datetime.datetime, datetime.date)):
-            return obj.isoformat()
-
-        if isinstance(obj, dict):
-            obj_dict = obj
-        else:
-            # Convert model obj to dict except
-            # attributes `openapi_types`, `attribute_map`
-            # and attributes which value is not None.
-            # Convert attribute name to json key in
-            # model definition for request.
-            obj_dict = {obj.attribute_map[attr]: getattr(obj, attr)
-                        for attr, _ in six.iteritems(obj.openapi_types)
-                        if getattr(obj, attr) is not None}
-
-        return {key: self.sanitize_for_serialization(val)
-                for key, val in six.iteritems(obj_dict)}
-
-    def deserialize(self, response, response_type):
-        """Deserializes response into an object.
-
-        :param response: RESTResponse object to be deserialized.
-        :param response_type: class literal for
-            deserialized object, or string of class name.
-
-        :return: deserialized object.
-        """
-        # handle file downloading
-        # save response body into a tmp file and return the instance
-        if response_type == "file":
-            return self.__deserialize_file(response)
-
-        # fetch data from response object
-        try:
-            data = json.loads(response.data)
-        except ValueError:
-            data = response.data
-
-        return self.__deserialize(data, response_type)
-
-    def __deserialize(self, data, klass):
-        """Deserializes dict, list, str into an object.
-
-        :param data: dict, list or str.
-        :param klass: class literal, or string of class name.
-
-        :return: object.
-        """
-        if data is None:
-            return None
-
-        if type(klass) == str:
-            if klass.startswith('list['):
-                sub_kls = re.match(r'list\[(.*)\]', klass).group(1)
-                return [self.__deserialize(sub_data, sub_kls)
-                        for sub_data in data]
-
-            if klass.startswith('dict('):
-                sub_kls = re.match(r'dict\(([^,]*), (.*)\)', klass).group(2)
-                return {k: self.__deserialize(v, sub_kls)
-                        for k, v in six.iteritems(data)}
-
-            # convert str to class
-            if klass in self.NATIVE_TYPES_MAPPING:
-                klass = self.NATIVE_TYPES_MAPPING[klass]
-            else:
-                klass = getattr(finbourne_access.models, klass)
-
-        if klass in self.PRIMITIVE_TYPES:
-            return self.__deserialize_primitive(data, klass)
-        elif klass == object:
-            return self.__deserialize_object(data)
-        elif klass == datetime.date:
-            return self.__deserialize_date(data)
-        elif klass == datetime.datetime:
-            return self.__deserialize_datatime(data)
-        else:
-            return self.__deserialize_model(data, klass)
-
-    def call_api(self, resource_path, method,
-                 path_params=None, query_params=None, header_params=None,
-                 body=None, post_params=None, files=None,
-                 response_type=None, auth_settings=None, async_req=None,
-                 _return_http_data_only=None, collection_formats=None,
-                 _preload_content=True, _request_timeout=None, _host=None):
-        """Makes the HTTP request (synchronous) and returns deserialized data.
-
-        To make an async_req request, set the async_req parameter.
-
-        :param resource_path: Path to method endpoint.
-        :param method: Method to call.
-        :param path_params: Path parameters in the url.
-        :param query_params: Query parameters in the url.
-        :param header_params: Header parameters to be
-            placed in the request header.
-        :param body: Request body.
-        :param post_params dict: Request post form parameters,
-            for `application/x-www-form-urlencoded`, `multipart/form-data`.
-        :param auth_settings list: Auth Settings names for the request.
-        :param response: Response data type.
-        :param files dict: key -> filename, value -> filepath,
-            for `multipart/form-data`.
-        :param async_req bool: execute request asynchronously
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :param collection_formats: dict of collection formats for path, query,
-            header, and post parameters.
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :return:
-            If async_req parameter is True,
-            the request will be called asynchronously.
-            The method will return the request thread.
-            If parameter async_req is False or missing,
-            then the method will return the response directly.
-        """
-        if not async_req:
-            return self.__call_api(resource_path, method,
-                                   path_params, query_params, header_params,
-                                   body, post_params, files,
-                                   response_type, auth_settings,
-                                   _return_http_data_only, collection_formats,
-                                   _preload_content, _request_timeout, _host)
-        else:
-            thread = self.pool.apply_async(self.__call_api, (resource_path,
-                                           method, path_params, query_params,
-                                           header_params, body,
-                                           post_params, files,
-                                           response_type, auth_settings,
-                                           _return_http_data_only,
-                                           collection_formats,
-                                           _preload_content,
-                                           _request_timeout,
-                                           _host))
-        return thread
-
-    def request(self, method, url, query_params=None, headers=None,
-                post_params=None, body=None, _preload_content=True,
-                _request_timeout=None):
-        """Makes the HTTP request using RESTClient."""
-        if method == "GET":
-            return self.rest_client.GET(url,
-                                        query_params=query_params,
-                                        _preload_content=_preload_content,
-                                        _request_timeout=_request_timeout,
-                                        headers=headers)
-        elif method == "HEAD":
-            return self.rest_client.HEAD(url,
-                                         query_params=query_params,
-                                         _preload_content=_preload_content,
-                                         _request_timeout=_request_timeout,
-                                         headers=headers)
-        elif method == "OPTIONS":
-            return self.rest_client.OPTIONS(url,
-                                            query_params=query_params,
-                                            headers=headers,
-                                            post_params=post_params,
-                                            _preload_content=_preload_content,
-                                            _request_timeout=_request_timeout,
-                                            body=body)
-        elif method == "POST":
-            return self.rest_client.POST(url,
-                                         query_params=query_params,
-                                         headers=headers,
-                                         post_params=post_params,
-                                         _preload_content=_preload_content,
-                                         _request_timeout=_request_timeout,
-                                         body=body)
-        elif method == "PUT":
-            return self.rest_client.PUT(url,
-                                        query_params=query_params,
-                                        headers=headers,
-                                        post_params=post_params,
-                                        _preload_content=_preload_content,
-                                        _request_timeout=_request_timeout,
-                                        body=body)
-        elif method == "PATCH":
-            return self.rest_client.PATCH(url,
-                                          query_params=query_params,
-                                          headers=headers,
-                                          post_params=post_params,
-                                          _preload_content=_preload_content,
-                                          _request_timeout=_request_timeout,
-                                          body=body)
-        elif method == "DELETE":
-            return self.rest_client.DELETE(url,
-                                           query_params=query_params,
-                                           headers=headers,
-                                           _preload_content=_preload_content,
-                                           _request_timeout=_request_timeout,
-                                           body=body)
-        else:
-            raise ApiValueError(
-                "http method must be `GET`, `HEAD`, `OPTIONS`,"
-                " `POST`, `PATCH`, `PUT` or `DELETE`."
-            )
-
-    def parameters_to_tuples(self, params, collection_formats):
-        """Get parameters as list of tuples, formatting collections.
-
-        :param params: Parameters as dict or list of two-tuples
-        :param dict collection_formats: Parameter collection formats
-        :return: Parameters as list of tuples, collections formatted
-        """
-        new_params = []
-        if collection_formats is None:
-            collection_formats = {}
-        for k, v in six.iteritems(params) if isinstance(params, dict) else params:  # noqa: E501
-            if k in collection_formats:
-                collection_format = collection_formats[k]
-                if collection_format == 'multi':
-                    new_params.extend((k, value) for value in v)
-                else:
-                    if collection_format == 'ssv':
-                        delimiter = ' '
-                    elif collection_format == 'tsv':
-                        delimiter = '\t'
-                    elif collection_format == 'pipes':
-                        delimiter = '|'
-                    else:  # csv is the default
-                        delimiter = ','
-                    new_params.append(
-                        (k, delimiter.join(str(value) for value in v)))
-            else:
-                new_params.append((k, v))
-        return new_params
-
-    def files_parameters(self, files=None):
-        """Builds form parameters.
-
-        :param files: File parameters.
-        :return: Form parameters with files.
-        """
-        params = []
-
-        if files:
-            for k, v in six.iteritems(files):
-                if not v:
-                    continue
-                file_names = v if type(v) is list else [v]
-                for n in file_names:
-                    with open(n, 'rb') as f:
-                        filename = os.path.basename(f.name)
-                        filedata = f.read()
-                        mimetype = (mimetypes.guess_type(filename)[0] or
-                                    'application/octet-stream')
-                        params.append(
-                            tuple([k, tuple([filename, filedata, mimetype])]))
-
-        return params
-
-    def select_header_accept(self, accepts):
-        """Returns `Accept` based on an array of accepts provided.
-
-        :param accepts: List of headers.
-        :return: Accept (e.g. application/json).
-        """
-        if not accepts:
-            return
-
-        accepts = [x.lower() for x in accepts]
-
-        if 'application/json' in accepts:
-            return 'application/json'
-        else:
-            return ', '.join(accepts)
-
-    def select_header_content_type(self, content_types):
-        """Returns `Content-Type` based on an array of content_types provided.
-
-        :param content_types: List of content-types.
-        :return: Content-Type (e.g. application/json).
-        """
-        if not content_types:
-            return 'application/json'
-
-        content_types = [x.lower() for x in content_types]
-
-        if 'application/json' in content_types or '*/*' in content_types:
-            return 'application/json'
-        else:
-            return content_types[0]
-
-    def update_params_for_auth(self, headers, querys, auth_settings):
-        """Updates header and query params based on authentication setting.
-
-        :param headers: Header parameters dict to be updated.
-        :param querys: Query parameters tuple list to be updated.
-        :param auth_settings: Authentication setting identifiers list.
-        """
-        if not auth_settings:
-            return
-
-        for auth in auth_settings:
-            auth_setting = self.configuration.auth_settings().get(auth)
-            if auth_setting:
-                if not auth_setting['value']:
-                    continue
-                elif auth_setting['in'] == 'cookie':
-                    headers['Cookie'] = auth_setting['value']
-                elif auth_setting['in'] == 'header':
-                    headers[auth_setting['key']] = auth_setting['value']
-                elif auth_setting['in'] == 'query':
-                    querys.append((auth_setting['key'], auth_setting['value']))
-                else:
-                    raise ApiValueError(
-                        'Authentication token must be in `query` or `header`'
-                    )
-
-    def __deserialize_file(self, response):
-        """Deserializes body to file
-
-        Saves response body into a file in a temporary folder,
-        using the filename from the `Content-Disposition` header if provided.
-
-        :param response:  RESTResponse.
-        :return: file path.
-        """
-        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
-        os.close(fd)
-        os.remove(path)
-
-        content_disposition = response.getheader("Content-Disposition")
-        if content_disposition:
-            filename = re.search(r'filename=[\'"]?([^\'"\s]+)[\'"]?',
-                                 content_disposition).group(1)
-            path = os.path.join(os.path.dirname(path), filename)
-
-        with open(path, "wb") as f:
-            f.write(response.data)
-
-        return path
-
-    def __deserialize_primitive(self, data, klass):
-        """Deserializes string to primitive type.
-
-        :param data: str.
-        :param klass: class literal.
-
-        :return: int, long, float, str, bool.
-        """
-        try:
-            return klass(data)
-        except UnicodeEncodeError:
-            return six.text_type(data)
-        except TypeError:
-            return data
-
-    def __deserialize_object(self, value):
-        """Return an original value.
-
-        :return: object.
-        """
-        return value
-
-    def __deserialize_date(self, string):
-        """Deserializes string to date.
-
-        :param string: str.
-        :return: date.
-        """
-        try:
-            from dateutil.parser import parse
-            return parse(string).date()
-        except ImportError:
-            return string
-        except ValueError:
-            raise rest.ApiException(
-                status=0,
-                reason="Failed to parse `{0}` as date object".format(string)
-            )
-
-    def __deserialize_datatime(self, string):
-        """Deserializes string to datetime.
-
-        The string should be in iso8601 datetime format.
-
-        :param string: str.
-        :return: datetime.
-        """
-        try:
-            from dateutil.parser import parse
-            return parse(string)
-        except ImportError:
-            return string
-        except ValueError:
-            raise rest.ApiException(
-                status=0,
-                reason=(
-                    "Failed to parse `{0}` as datetime object"
-                    .format(string)
-                )
-            )
-
-    def __deserialize_model(self, data, klass):
-        """Deserializes list or dict to model.
-
-        :param data: dict, list.
-        :param klass: class literal.
-        :return: model object.
-        """
-
-        if not klass.openapi_types and not hasattr(klass,
-                                                   'get_real_child_model'):
-            return data
-
-        kwargs = {}
-        if klass.openapi_types is not None:
-            for attr, attr_type in six.iteritems(klass.openapi_types):
-                if (data is not None and
-                        klass.attribute_map[attr] in data and
-                        isinstance(data, (list, dict))):
-                    value = data[klass.attribute_map[attr]]
-                    kwargs[attr] = self.__deserialize(value, attr_type)
-
-        instance = klass(**kwargs)
-
-        if hasattr(instance, 'get_real_child_model'):
-            klass_name = instance.get_real_child_model(data)
-            if klass_name:
-                instance = self.__deserialize(data, klass_name)
-        return instance
+# coding: utf-8
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+from __future__ import absolute_import
+
+import datetime
+import json
+import mimetypes
+from multiprocessing.pool import ThreadPool
+import os
+import re
+import tempfile
+
+# python 2 and python 3 compatibility library
+import six
+from six.moves.urllib.parse import quote
+
+from finbourne_access.configuration import Configuration
+import finbourne_access.models
+from finbourne_access import rest
+from finbourne_access.exceptions import ApiValueError
+
+
+class ApiClient(object):
+    """Generic API client for OpenAPI client library builds.
+
+    OpenAPI generic API client. This client handles the client-
+    server communication, and is invariant across implementations. Specifics of
+    the methods and models for each application are generated from the OpenAPI
+    templates.
+
+    NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+    Do not edit the class manually.
+
+    :param configuration: .Configuration object for this client
+    :param header_name: a header to pass when making calls to the API.
+    :param header_value: a header value to pass when making calls to
+        the API.
+    :param cookie: a cookie to include in the header when making calls
+        to the API
+    :param pool_threads: The number of threads to use for async requests
+        to the API. More threads means more concurrent API requests.
+    """
+
+    PRIMITIVE_TYPES = (float, bool, bytes, six.text_type) + six.integer_types
+    NATIVE_TYPES_MAPPING = {
+        'int': int,
+        'long': int if six.PY3 else long,  # noqa: F821
+        'float': float,
+        'str': str,
+        'bool': bool,
+        'date': datetime.date,
+        'datetime': datetime.datetime,
+        'object': object,
+    }
+    _pool = None
+
+    def __init__(self, configuration=None, header_name=None, header_value=None,
+                 cookie=None, pool_threads=1):
+        if configuration is None:
+            configuration = Configuration()
+        self.configuration = configuration
+        self.pool_threads = pool_threads
+
+        self.rest_client = rest.RESTClientObject(configuration)
+        self.default_headers = {}
+        if header_name is not None:
+            self.default_headers[header_name] = header_value
+        self.cookie = cookie
+        # Set default User-Agent.
+        self.user_agent = 'OpenAPI-Generator/0.0.815/python'
+
+    def __del__(self):
+        if self._pool:
+            self._pool.close()
+            self._pool.join()
+            self._pool = None
+
+    @property
+    def pool(self):
+        """Create thread pool on first request
+         avoids instantiating unused threadpool for blocking clients.
+        """
+        if self._pool is None:
+            self._pool = ThreadPool(self.pool_threads)
+        return self._pool
+
+    @property
+    def user_agent(self):
+        """User agent for this API client"""
+        return self.default_headers['User-Agent']
+
+    @user_agent.setter
+    def user_agent(self, value):
+        self.default_headers['User-Agent'] = value
+
+    def set_default_header(self, header_name, header_value):
+        self.default_headers[header_name] = header_value
+
+    def __call_api(
+            self, resource_path, method, path_params=None,
+            query_params=None, header_params=None, body=None, post_params=None,
+            files=None, response_type=None, auth_settings=None,
+            _return_http_data_only=None, collection_formats=None,
+            _preload_content=True, _request_timeout=None, _host=None):
+
+        config = self.configuration
+
+        # header parameters
+        header_params = header_params or {}
+        header_params.update(self.default_headers)
+        if self.cookie:
+            header_params['Cookie'] = self.cookie
+        if header_params:
+            header_params = self.sanitize_for_serialization(header_params)
+            header_params = dict(self.parameters_to_tuples(header_params,
+                                                           collection_formats))
+
+        # path parameters
+        if path_params:
+            path_params = self.sanitize_for_serialization(path_params)
+            path_params = self.parameters_to_tuples(path_params,
+                                                    collection_formats)
+            for k, v in path_params:
+                # specified safe chars, encode everything
+                resource_path = resource_path.replace(
+                    '{%s}' % k,
+                    quote(str(v), safe=config.safe_chars_for_path_param)
+                )
+
+        # query parameters
+        if query_params:
+            query_params = self.sanitize_for_serialization(query_params)
+            query_params = self.parameters_to_tuples(query_params,
+                                                     collection_formats)
+
+        # post parameters
+        if post_params or files:
+            post_params = post_params if post_params else []
+            post_params = self.sanitize_for_serialization(post_params)
+            post_params = self.parameters_to_tuples(post_params,
+                                                    collection_formats)
+            post_params.extend(self.files_parameters(files))
+
+        # auth setting
+        self.update_params_for_auth(header_params, query_params, auth_settings)
+
+        # body
+        if body:
+            body = self.sanitize_for_serialization(body)
+
+        # request url
+        if _host is None:
+            url = self.configuration.host + resource_path
+        else:
+            # use server/host defined in path or operation instead
+            url = _host + resource_path
+
+        # perform request and return response
+        response_data = self.request(
+            method, url, query_params=query_params, headers=header_params,
+            post_params=post_params, body=body,
+            _preload_content=_preload_content,
+            _request_timeout=_request_timeout)
+
+        self.last_response = response_data
+
+        return_data = response_data
+        if _preload_content:
+            # deserialize response data
+            if response_type:
+                return_data = self.deserialize(response_data, response_type)
+            else:
+                return_data = None
+
+        if _return_http_data_only:
+            return (return_data)
+        else:
+            return (return_data, response_data.status,
+                    response_data.getheaders())
+
+    def sanitize_for_serialization(self, obj):
+        """Builds a JSON POST object.
+
+        If obj is None, return None.
+        If obj is str, int, long, float, bool, return directly.
+        If obj is datetime.datetime, datetime.date
+            convert to string in iso8601 format.
+        If obj is list, sanitize each element in the list.
+        If obj is dict, return the dict.
+        If obj is OpenAPI model, return the properties dict.
+
+        :param obj: The data to serialize.
+        :return: The serialized form of data.
+        """
+        if obj is None:
+            return None
+        elif isinstance(obj, self.PRIMITIVE_TYPES):
+            return obj
+        elif isinstance(obj, list):
+            return [self.sanitize_for_serialization(sub_obj)
+                    for sub_obj in obj]
+        elif isinstance(obj, tuple):
+            return tuple(self.sanitize_for_serialization(sub_obj)
+                         for sub_obj in obj)
+        elif isinstance(obj, (datetime.datetime, datetime.date)):
+            return obj.isoformat()
+
+        if isinstance(obj, dict):
+            obj_dict = obj
+        else:
+            # Convert model obj to dict except
+            # attributes `openapi_types`, `attribute_map`
+            # and attributes which value is not None.
+            # Convert attribute name to json key in
+            # model definition for request.
+            obj_dict = {obj.attribute_map[attr]: getattr(obj, attr)
+                        for attr, _ in six.iteritems(obj.openapi_types)
+                        if getattr(obj, attr) is not None}
+
+        return {key: self.sanitize_for_serialization(val)
+                for key, val in six.iteritems(obj_dict)}
+
+    def deserialize(self, response, response_type):
+        """Deserializes response into an object.
+
+        :param response: RESTResponse object to be deserialized.
+        :param response_type: class literal for
+            deserialized object, or string of class name.
+
+        :return: deserialized object.
+        """
+        # handle file downloading
+        # save response body into a tmp file and return the instance
+        if response_type == "file":
+            return self.__deserialize_file(response)
+
+        # fetch data from response object
+        try:
+            data = json.loads(response.data)
+        except ValueError:
+            data = response.data
+
+        return self.__deserialize(data, response_type)
+
+    def __deserialize(self, data, klass):
+        """Deserializes dict, list, str into an object.
+
+        :param data: dict, list or str.
+        :param klass: class literal, or string of class name.
+
+        :return: object.
+        """
+        if data is None:
+            return None
+
+        if type(klass) == str:
+            if klass.startswith('list['):
+                sub_kls = re.match(r'list\[(.*)\]', klass).group(1)
+                return [self.__deserialize(sub_data, sub_kls)
+                        for sub_data in data]
+
+            if klass.startswith('dict('):
+                sub_kls = re.match(r'dict\(([^,]*), (.*)\)', klass).group(2)
+                return {k: self.__deserialize(v, sub_kls)
+                        for k, v in six.iteritems(data)}
+
+            # convert str to class
+            if klass in self.NATIVE_TYPES_MAPPING:
+                klass = self.NATIVE_TYPES_MAPPING[klass]
+            else:
+                klass = getattr(finbourne_access.models, klass)
+
+        if klass in self.PRIMITIVE_TYPES:
+            return self.__deserialize_primitive(data, klass)
+        elif klass == object:
+            return self.__deserialize_object(data)
+        elif klass == datetime.date:
+            return self.__deserialize_date(data)
+        elif klass == datetime.datetime:
+            return self.__deserialize_datatime(data)
+        else:
+            return self.__deserialize_model(data, klass)
+
+    def call_api(self, resource_path, method,
+                 path_params=None, query_params=None, header_params=None,
+                 body=None, post_params=None, files=None,
+                 response_type=None, auth_settings=None, async_req=None,
+                 _return_http_data_only=None, collection_formats=None,
+                 _preload_content=True, _request_timeout=None, _host=None):
+        """Makes the HTTP request (synchronous) and returns deserialized data.
+
+        To make an async_req request, set the async_req parameter.
+
+        :param resource_path: Path to method endpoint.
+        :param method: Method to call.
+        :param path_params: Path parameters in the url.
+        :param query_params: Query parameters in the url.
+        :param header_params: Header parameters to be
+            placed in the request header.
+        :param body: Request body.
+        :param post_params dict: Request post form parameters,
+            for `application/x-www-form-urlencoded`, `multipart/form-data`.
+        :param auth_settings list: Auth Settings names for the request.
+        :param response: Response data type.
+        :param files dict: key -> filename, value -> filepath,
+            for `multipart/form-data`.
+        :param async_req bool: execute request asynchronously
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param collection_formats: dict of collection formats for path, query,
+            header, and post parameters.
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return:
+            If async_req parameter is True,
+            the request will be called asynchronously.
+            The method will return the request thread.
+            If parameter async_req is False or missing,
+            then the method will return the response directly.
+        """
+        if not async_req:
+            return self.__call_api(resource_path, method,
+                                   path_params, query_params, header_params,
+                                   body, post_params, files,
+                                   response_type, auth_settings,
+                                   _return_http_data_only, collection_formats,
+                                   _preload_content, _request_timeout, _host)
+        else:
+            thread = self.pool.apply_async(self.__call_api, (resource_path,
+                                           method, path_params, query_params,
+                                           header_params, body,
+                                           post_params, files,
+                                           response_type, auth_settings,
+                                           _return_http_data_only,
+                                           collection_formats,
+                                           _preload_content,
+                                           _request_timeout,
+                                           _host))
+        return thread
+
+    def request(self, method, url, query_params=None, headers=None,
+                post_params=None, body=None, _preload_content=True,
+                _request_timeout=None):
+        """Makes the HTTP request using RESTClient."""
+        if method == "GET":
+            return self.rest_client.GET(url,
+                                        query_params=query_params,
+                                        _preload_content=_preload_content,
+                                        _request_timeout=_request_timeout,
+                                        headers=headers)
+        elif method == "HEAD":
+            return self.rest_client.HEAD(url,
+                                         query_params=query_params,
+                                         _preload_content=_preload_content,
+                                         _request_timeout=_request_timeout,
+                                         headers=headers)
+        elif method == "OPTIONS":
+            return self.rest_client.OPTIONS(url,
+                                            query_params=query_params,
+                                            headers=headers,
+                                            post_params=post_params,
+                                            _preload_content=_preload_content,
+                                            _request_timeout=_request_timeout,
+                                            body=body)
+        elif method == "POST":
+            return self.rest_client.POST(url,
+                                         query_params=query_params,
+                                         headers=headers,
+                                         post_params=post_params,
+                                         _preload_content=_preload_content,
+                                         _request_timeout=_request_timeout,
+                                         body=body)
+        elif method == "PUT":
+            return self.rest_client.PUT(url,
+                                        query_params=query_params,
+                                        headers=headers,
+                                        post_params=post_params,
+                                        _preload_content=_preload_content,
+                                        _request_timeout=_request_timeout,
+                                        body=body)
+        elif method == "PATCH":
+            return self.rest_client.PATCH(url,
+                                          query_params=query_params,
+                                          headers=headers,
+                                          post_params=post_params,
+                                          _preload_content=_preload_content,
+                                          _request_timeout=_request_timeout,
+                                          body=body)
+        elif method == "DELETE":
+            return self.rest_client.DELETE(url,
+                                           query_params=query_params,
+                                           headers=headers,
+                                           _preload_content=_preload_content,
+                                           _request_timeout=_request_timeout,
+                                           body=body)
+        else:
+            raise ApiValueError(
+                "http method must be `GET`, `HEAD`, `OPTIONS`,"
+                " `POST`, `PATCH`, `PUT` or `DELETE`."
+            )
+
+    def parameters_to_tuples(self, params, collection_formats):
+        """Get parameters as list of tuples, formatting collections.
+
+        :param params: Parameters as dict or list of two-tuples
+        :param dict collection_formats: Parameter collection formats
+        :return: Parameters as list of tuples, collections formatted
+        """
+        new_params = []
+        if collection_formats is None:
+            collection_formats = {}
+        for k, v in six.iteritems(params) if isinstance(params, dict) else params:  # noqa: E501
+            if k in collection_formats:
+                collection_format = collection_formats[k]
+                if collection_format == 'multi':
+                    new_params.extend((k, value) for value in v)
+                else:
+                    if collection_format == 'ssv':
+                        delimiter = ' '
+                    elif collection_format == 'tsv':
+                        delimiter = '\t'
+                    elif collection_format == 'pipes':
+                        delimiter = '|'
+                    else:  # csv is the default
+                        delimiter = ','
+                    new_params.append(
+                        (k, delimiter.join(str(value) for value in v)))
+            else:
+                new_params.append((k, v))
+        return new_params
+
+    def files_parameters(self, files=None):
+        """Builds form parameters.
+
+        :param files: File parameters.
+        :return: Form parameters with files.
+        """
+        params = []
+
+        if files:
+            for k, v in six.iteritems(files):
+                if not v:
+                    continue
+                file_names = v if type(v) is list else [v]
+                for n in file_names:
+                    with open(n, 'rb') as f:
+                        filename = os.path.basename(f.name)
+                        filedata = f.read()
+                        mimetype = (mimetypes.guess_type(filename)[0] or
+                                    'application/octet-stream')
+                        params.append(
+                            tuple([k, tuple([filename, filedata, mimetype])]))
+
+        return params
+
+    def select_header_accept(self, accepts):
+        """Returns `Accept` based on an array of accepts provided.
+
+        :param accepts: List of headers.
+        :return: Accept (e.g. application/json).
+        """
+        if not accepts:
+            return
+
+        accepts = [x.lower() for x in accepts]
+
+        if 'application/json' in accepts:
+            return 'application/json'
+        else:
+            return ', '.join(accepts)
+
+    def select_header_content_type(self, content_types):
+        """Returns `Content-Type` based on an array of content_types provided.
+
+        :param content_types: List of content-types.
+        :return: Content-Type (e.g. application/json).
+        """
+        if not content_types:
+            return 'application/json'
+
+        content_types = [x.lower() for x in content_types]
+
+        if 'application/json' in content_types or '*/*' in content_types:
+            return 'application/json'
+        else:
+            return content_types[0]
+
+    def update_params_for_auth(self, headers, querys, auth_settings):
+        """Updates header and query params based on authentication setting.
+
+        :param headers: Header parameters dict to be updated.
+        :param querys: Query parameters tuple list to be updated.
+        :param auth_settings: Authentication setting identifiers list.
+        """
+        if not auth_settings:
+            return
+
+        for auth in auth_settings:
+            auth_setting = self.configuration.auth_settings().get(auth)
+            if auth_setting:
+                if not auth_setting['value']:
+                    continue
+                elif auth_setting['in'] == 'cookie':
+                    headers['Cookie'] = auth_setting['value']
+                elif auth_setting['in'] == 'header':
+                    headers[auth_setting['key']] = auth_setting['value']
+                elif auth_setting['in'] == 'query':
+                    querys.append((auth_setting['key'], auth_setting['value']))
+                else:
+                    raise ApiValueError(
+                        'Authentication token must be in `query` or `header`'
+                    )
+
+    def __deserialize_file(self, response):
+        """Deserializes body to file
+
+        Saves response body into a file in a temporary folder,
+        using the filename from the `Content-Disposition` header if provided.
+
+        :param response:  RESTResponse.
+        :return: file path.
+        """
+        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
+        os.close(fd)
+        os.remove(path)
+
+        content_disposition = response.getheader("Content-Disposition")
+        if content_disposition:
+            filename = re.search(r'filename=[\'"]?([^\'"\s]+)[\'"]?',
+                                 content_disposition).group(1)
+            path = os.path.join(os.path.dirname(path), filename)
+
+        with open(path, "wb") as f:
+            f.write(response.data)
+
+        return path
+
+    def __deserialize_primitive(self, data, klass):
+        """Deserializes string to primitive type.
+
+        :param data: str.
+        :param klass: class literal.
+
+        :return: int, long, float, str, bool.
+        """
+        try:
+            return klass(data)
+        except UnicodeEncodeError:
+            return six.text_type(data)
+        except TypeError:
+            return data
+
+    def __deserialize_object(self, value):
+        """Return an original value.
+
+        :return: object.
+        """
+        return value
+
+    def __deserialize_date(self, string):
+        """Deserializes string to date.
+
+        :param string: str.
+        :return: date.
+        """
+        try:
+            from dateutil.parser import parse
+            return parse(string).date()
+        except ImportError:
+            return string
+        except ValueError:
+            raise rest.ApiException(
+                status=0,
+                reason="Failed to parse `{0}` as date object".format(string)
+            )
+
+    def __deserialize_datatime(self, string):
+        """Deserializes string to datetime.
+
+        The string should be in iso8601 datetime format.
+
+        :param string: str.
+        :return: datetime.
+        """
+        try:
+            from dateutil.parser import parse
+            return parse(string)
+        except ImportError:
+            return string
+        except ValueError:
+            raise rest.ApiException(
+                status=0,
+                reason=(
+                    "Failed to parse `{0}` as datetime object"
+                    .format(string)
+                )
+            )
+
+    def __deserialize_model(self, data, klass):
+        """Deserializes list or dict to model.
+
+        :param data: dict, list.
+        :param klass: class literal.
+        :return: model object.
+        """
+
+        if not klass.openapi_types and not hasattr(klass,
+                                                   'get_real_child_model'):
+            return data
+
+        kwargs = {}
+        if klass.openapi_types is not None:
+            for attr, attr_type in six.iteritems(klass.openapi_types):
+                if (data is not None and
+                        klass.attribute_map[attr] in data and
+                        isinstance(data, (list, dict))):
+                    value = data[klass.attribute_map[attr]]
+                    kwargs[attr] = self.__deserialize(value, attr_type)
+
+        instance = klass(**kwargs)
+
+        if hasattr(instance, 'get_real_child_model'):
+            klass_name = instance.get_real_child_model(data)
+            if klass_name:
+                instance = self.__deserialize(data, klass_name)
+        return instance
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/configuration.py` & `finbourne-access-sdk-0.0.815/finbourne_access/configuration.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,322 +1,322 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-from __future__ import absolute_import
-
-import copy
-import logging
-import multiprocessing
-import sys
-import urllib3
-
-import six
-from six.moves import http_client as httplib
-
-
-class TypeWithDefault(type):
-    def __init__(cls, name, bases, dct):
-        super(TypeWithDefault, cls).__init__(name, bases, dct)
-        cls._default = None
-
-    def __call__(cls, **kwargs):
-        if cls._default is None:
-            cls._default = type.__call__(cls, **kwargs)
-        return copy.copy(cls._default)
-
-    def set_default(cls, default):
-        cls._default = copy.copy(default)
-
-
-class Configuration(six.with_metaclass(TypeWithDefault, object)):
-    """NOTE: This class is auto generated by OpenAPI Generator
-
-    Ref: https://openapi-generator.tech
-    Do not edit the class manually.
-
-    :param host: Base url
-    :param api_key: Dict to store API key(s)
-    :param api_key_prefix: Dict to store API prefix (e.g. Bearer)
-    :param username: Username for HTTP basic authentication
-    :param password: Password for HTTP basic authentication
-    """
-
-    def __init__(self, host="https://www.lusid.com/access",
-                 api_key={}, api_key_prefix={},
-                 username="", password=""):
-        """Constructor
-        """
-        self.host = host
-        """Default Base url
-        """
-        self.temp_folder_path = None
-        """Temp file folder for downloading files
-        """
-        # Authentication Settings
-        self.api_key = api_key
-        """dict to store API key(s)
-        """
-        self.api_key_prefix = api_key_prefix
-        """dict to store API prefix (e.g. Bearer)
-        """
-        self.username = username
-        """Username for HTTP basic authentication
-        """
-        self.password = password
-        """Password for HTTP basic authentication
-        """
-        self.access_token = ""
-        """access token for OAuth/Bearer
-        """
-        self.logger = {}
-        """Logging Settings
-        """
-        self.logger["package_logger"] = logging.getLogger("finbourne_access")
-        self.logger["urllib3_logger"] = logging.getLogger("urllib3")
-        self.logger_format = '%(asctime)s %(levelname)s %(message)s'
-        """Log format
-        """
-        self.logger_stream_handler = None
-        """Log stream handler
-        """
-        self.logger_file_handler = None
-        """Log file handler
-        """
-        self.logger_file = None
-        """Debug file location
-        """
-        self.debug = False
-        """Debug switch
-        """
-
-        self.verify_ssl = True
-        """SSL/TLS verification
-           Set this to false to skip verifying SSL certificate when calling API
-           from https server.
-        """
-        self.ssl_ca_cert = None
-        """Set this to customize the certificate file to verify the peer.
-        """
-        self.cert_file = None
-        """client certificate file
-        """
-        self.key_file = None
-        """client key file
-        """
-        self.assert_hostname = None
-        """Set this to True/False to enable/disable SSL hostname verification.
-        """
-
-        self.connection_pool_maxsize = multiprocessing.cpu_count() * 5
-        """urllib3 connection pool's maximum number of connections saved
-           per pool. urllib3 uses 1 connection as default value, but this is
-           not the best value when you are making a lot of possibly parallel
-           requests to the same host, which is often the case here.
-           cpu_count * 5 is used as default value to increase performance.
-        """
-
-        self.proxy = None
-        """Proxy URL
-        """
-        self.proxy_headers = None
-        """Proxy headers
-        """
-        self.safe_chars_for_path_param = ''
-        """Safe chars for path_param
-        """
-        self.retries = None
-        """Adding retries to override urllib3 default value 3
-        """
-
-    @property
-    def logger_file(self):
-        """The logger file.
-
-        If the logger_file is None, then add stream handler and remove file
-        handler. Otherwise, add file handler and remove stream handler.
-
-        :param value: The logger_file path.
-        :type: str
-        """
-        return self.__logger_file
-
-    @logger_file.setter
-    def logger_file(self, value):
-        """The logger file.
-
-        If the logger_file is None, then add stream handler and remove file
-        handler. Otherwise, add file handler and remove stream handler.
-
-        :param value: The logger_file path.
-        :type: str
-        """
-        self.__logger_file = value
-        if self.__logger_file:
-            # If set logging file,
-            # then add file handler and remove stream handler.
-            self.logger_file_handler = logging.FileHandler(self.__logger_file)
-            self.logger_file_handler.setFormatter(self.logger_formatter)
-            for _, logger in six.iteritems(self.logger):
-                logger.addHandler(self.logger_file_handler)
-
-    @property
-    def debug(self):
-        """Debug status
-
-        :param value: The debug status, True or False.
-        :type: bool
-        """
-        return self.__debug
-
-    @debug.setter
-    def debug(self, value):
-        """Debug status
-
-        :param value: The debug status, True or False.
-        :type: bool
-        """
-        self.__debug = value
-        if self.__debug:
-            # if debug status is True, turn on debug logging
-            for _, logger in six.iteritems(self.logger):
-                logger.setLevel(logging.DEBUG)
-            # turn on httplib debug
-            httplib.HTTPConnection.debuglevel = 1
-        else:
-            # if debug status is False, turn off debug logging,
-            # setting log level to default `logging.WARNING`
-            for _, logger in six.iteritems(self.logger):
-                logger.setLevel(logging.WARNING)
-            # turn off httplib debug
-            httplib.HTTPConnection.debuglevel = 0
-
-    @property
-    def logger_format(self):
-        """The logger format.
-
-        The logger_formatter will be updated when sets logger_format.
-
-        :param value: The format string.
-        :type: str
-        """
-        return self.__logger_format
-
-    @logger_format.setter
-    def logger_format(self, value):
-        """The logger format.
-
-        The logger_formatter will be updated when sets logger_format.
-
-        :param value: The format string.
-        :type: str
-        """
-        self.__logger_format = value
-        self.logger_formatter = logging.Formatter(self.__logger_format)
-
-    def get_api_key_with_prefix(self, identifier):
-        """Gets API key (with prefix if set).
-
-        :param identifier: The identifier of apiKey.
-        :return: The token for api key authentication.
-        """
-        if (self.api_key.get(identifier) and
-                self.api_key_prefix.get(identifier)):
-            return self.api_key_prefix[identifier] + ' ' + self.api_key[identifier]  # noqa: E501
-        elif self.api_key.get(identifier):
-            return self.api_key[identifier]
-
-    def get_basic_auth_token(self):
-        """Gets HTTP basic authentication header (string).
-
-        :return: The token for basic HTTP authentication.
-        """
-        return urllib3.util.make_headers(
-            basic_auth=self.username + ':' + self.password
-        ).get('authorization')
-
-    def auth_settings(self):
-        """Gets Auth Settings dict for api client.
-
-        :return: The Auth Settings information dict.
-        """
-        return {
-            'oauth2':
-                {
-                    'type': 'oauth2',
-                    'in': 'header',
-                    'key': 'Authorization',
-                    'value': 'Bearer ' + self.access_token
-                },
-        }
-
-    def to_debug_report(self):
-        """Gets the essential information for debugging.
-
-        :return: The report for debugging.
-        """
-        return "Python SDK Debug Report:\n"\
-               "OS: {env}\n"\
-               "Python Version: {pyversion}\n"\
-               "Version of the API: 0.0.616\n"\
-               "SDK Package Version: 0.0.616".\
-               format(env=sys.platform, pyversion=sys.version)
-
-    def get_host_settings(self):
-        """Gets an array of host settings
-
-        :return: An array of host settings
-        """
-        return [
-            {
-                'url': "https://www.lusid.com/access",
-                'description': "No description provided",
-            }
-        ]
-
-    def get_host_from_settings(self, index, variables={}):
-        """Gets host URL based on the index and variables
-        :param index: array index of the host settings
-        :param variables: hash of variable and the corresponding value
-        :return: URL based on host settings
-        """
-
-        servers = self.get_host_settings()
-
-        # check array index out of bound
-        if index < 0 or index >= len(servers):
-            raise ValueError(
-                "Invalid index {} when selecting the host settings. Must be less than {}"  # noqa: E501
-                .format(index, len(servers)))
-
-        server = servers[index]
-        url = server['url']
-
-        # go through variable and assign a value
-        for variable_name in server['variables']:
-            if variable_name in variables:
-                if variables[variable_name] in server['variables'][
-                        variable_name]['enum_values']:
-                    url = url.replace("{" + variable_name + "}",
-                                      variables[variable_name])
-                else:
-                    raise ValueError(
-                        "The variable `{}` in the host URL has invalid value {}. Must be {}."  # noqa: E501
-                        .format(
-                            variable_name, variables[variable_name],
-                            server['variables'][variable_name]['enum_values']))
-            else:
-                # use default value
-                url = url.replace(
-                    "{" + variable_name + "}",
-                    server['variables'][variable_name]['default_value'])
-
-        return url
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+from __future__ import absolute_import
+
+import copy
+import logging
+import multiprocessing
+import sys
+import urllib3
+
+import six
+from six.moves import http_client as httplib
+
+
+class TypeWithDefault(type):
+    def __init__(cls, name, bases, dct):
+        super(TypeWithDefault, cls).__init__(name, bases, dct)
+        cls._default = None
+
+    def __call__(cls, **kwargs):
+        if cls._default is None:
+            cls._default = type.__call__(cls, **kwargs)
+        return copy.copy(cls._default)
+
+    def set_default(cls, default):
+        cls._default = copy.copy(default)
+
+
+class Configuration(six.with_metaclass(TypeWithDefault, object)):
+    """NOTE: This class is auto generated by OpenAPI Generator
+
+    Ref: https://openapi-generator.tech
+    Do not edit the class manually.
+
+    :param host: Base url
+    :param api_key: Dict to store API key(s)
+    :param api_key_prefix: Dict to store API prefix (e.g. Bearer)
+    :param username: Username for HTTP basic authentication
+    :param password: Password for HTTP basic authentication
+    """
+
+    def __init__(self, host="https://www.lusid.com/access",
+                 api_key={}, api_key_prefix={},
+                 username="", password=""):
+        """Constructor
+        """
+        self.host = host
+        """Default Base url
+        """
+        self.temp_folder_path = None
+        """Temp file folder for downloading files
+        """
+        # Authentication Settings
+        self.api_key = api_key
+        """dict to store API key(s)
+        """
+        self.api_key_prefix = api_key_prefix
+        """dict to store API prefix (e.g. Bearer)
+        """
+        self.username = username
+        """Username for HTTP basic authentication
+        """
+        self.password = password
+        """Password for HTTP basic authentication
+        """
+        self.access_token = ""
+        """access token for OAuth/Bearer
+        """
+        self.logger = {}
+        """Logging Settings
+        """
+        self.logger["package_logger"] = logging.getLogger("finbourne_access")
+        self.logger["urllib3_logger"] = logging.getLogger("urllib3")
+        self.logger_format = '%(asctime)s %(levelname)s %(message)s'
+        """Log format
+        """
+        self.logger_stream_handler = None
+        """Log stream handler
+        """
+        self.logger_file_handler = None
+        """Log file handler
+        """
+        self.logger_file = None
+        """Debug file location
+        """
+        self.debug = False
+        """Debug switch
+        """
+
+        self.verify_ssl = True
+        """SSL/TLS verification
+           Set this to false to skip verifying SSL certificate when calling API
+           from https server.
+        """
+        self.ssl_ca_cert = None
+        """Set this to customize the certificate file to verify the peer.
+        """
+        self.cert_file = None
+        """client certificate file
+        """
+        self.key_file = None
+        """client key file
+        """
+        self.assert_hostname = None
+        """Set this to True/False to enable/disable SSL hostname verification.
+        """
+
+        self.connection_pool_maxsize = multiprocessing.cpu_count() * 5
+        """urllib3 connection pool's maximum number of connections saved
+           per pool. urllib3 uses 1 connection as default value, but this is
+           not the best value when you are making a lot of possibly parallel
+           requests to the same host, which is often the case here.
+           cpu_count * 5 is used as default value to increase performance.
+        """
+
+        self.proxy = None
+        """Proxy URL
+        """
+        self.proxy_headers = None
+        """Proxy headers
+        """
+        self.safe_chars_for_path_param = ''
+        """Safe chars for path_param
+        """
+        self.retries = None
+        """Adding retries to override urllib3 default value 3
+        """
+
+    @property
+    def logger_file(self):
+        """The logger file.
+
+        If the logger_file is None, then add stream handler and remove file
+        handler. Otherwise, add file handler and remove stream handler.
+
+        :param value: The logger_file path.
+        :type: str
+        """
+        return self.__logger_file
+
+    @logger_file.setter
+    def logger_file(self, value):
+        """The logger file.
+
+        If the logger_file is None, then add stream handler and remove file
+        handler. Otherwise, add file handler and remove stream handler.
+
+        :param value: The logger_file path.
+        :type: str
+        """
+        self.__logger_file = value
+        if self.__logger_file:
+            # If set logging file,
+            # then add file handler and remove stream handler.
+            self.logger_file_handler = logging.FileHandler(self.__logger_file)
+            self.logger_file_handler.setFormatter(self.logger_formatter)
+            for _, logger in six.iteritems(self.logger):
+                logger.addHandler(self.logger_file_handler)
+
+    @property
+    def debug(self):
+        """Debug status
+
+        :param value: The debug status, True or False.
+        :type: bool
+        """
+        return self.__debug
+
+    @debug.setter
+    def debug(self, value):
+        """Debug status
+
+        :param value: The debug status, True or False.
+        :type: bool
+        """
+        self.__debug = value
+        if self.__debug:
+            # if debug status is True, turn on debug logging
+            for _, logger in six.iteritems(self.logger):
+                logger.setLevel(logging.DEBUG)
+            # turn on httplib debug
+            httplib.HTTPConnection.debuglevel = 1
+        else:
+            # if debug status is False, turn off debug logging,
+            # setting log level to default `logging.WARNING`
+            for _, logger in six.iteritems(self.logger):
+                logger.setLevel(logging.WARNING)
+            # turn off httplib debug
+            httplib.HTTPConnection.debuglevel = 0
+
+    @property
+    def logger_format(self):
+        """The logger format.
+
+        The logger_formatter will be updated when sets logger_format.
+
+        :param value: The format string.
+        :type: str
+        """
+        return self.__logger_format
+
+    @logger_format.setter
+    def logger_format(self, value):
+        """The logger format.
+
+        The logger_formatter will be updated when sets logger_format.
+
+        :param value: The format string.
+        :type: str
+        """
+        self.__logger_format = value
+        self.logger_formatter = logging.Formatter(self.__logger_format)
+
+    def get_api_key_with_prefix(self, identifier):
+        """Gets API key (with prefix if set).
+
+        :param identifier: The identifier of apiKey.
+        :return: The token for api key authentication.
+        """
+        if (self.api_key.get(identifier) and
+                self.api_key_prefix.get(identifier)):
+            return self.api_key_prefix[identifier] + ' ' + self.api_key[identifier]  # noqa: E501
+        elif self.api_key.get(identifier):
+            return self.api_key[identifier]
+
+    def get_basic_auth_token(self):
+        """Gets HTTP basic authentication header (string).
+
+        :return: The token for basic HTTP authentication.
+        """
+        return urllib3.util.make_headers(
+            basic_auth=self.username + ':' + self.password
+        ).get('authorization')
+
+    def auth_settings(self):
+        """Gets Auth Settings dict for api client.
+
+        :return: The Auth Settings information dict.
+        """
+        return {
+            'oauth2':
+                {
+                    'type': 'oauth2',
+                    'in': 'header',
+                    'key': 'Authorization',
+                    'value': 'Bearer ' + self.access_token
+                },
+        }
+
+    def to_debug_report(self):
+        """Gets the essential information for debugging.
+
+        :return: The report for debugging.
+        """
+        return "Python SDK Debug Report:\n"\
+               "OS: {env}\n"\
+               "Python Version: {pyversion}\n"\
+               "Version of the API: 0.0.815\n"\
+               "SDK Package Version: 0.0.815".\
+               format(env=sys.platform, pyversion=sys.version)
+
+    def get_host_settings(self):
+        """Gets an array of host settings
+
+        :return: An array of host settings
+        """
+        return [
+            {
+                'url': "https://www.lusid.com/access",
+                'description': "No description provided",
+            }
+        ]
+
+    def get_host_from_settings(self, index, variables={}):
+        """Gets host URL based on the index and variables
+        :param index: array index of the host settings
+        :param variables: hash of variable and the corresponding value
+        :return: URL based on host settings
+        """
+
+        servers = self.get_host_settings()
+
+        # check array index out of bound
+        if index < 0 or index >= len(servers):
+            raise ValueError(
+                "Invalid index {} when selecting the host settings. Must be less than {}"  # noqa: E501
+                .format(index, len(servers)))
+
+        server = servers[index]
+        url = server['url']
+
+        # go through variable and assign a value
+        for variable_name in server['variables']:
+            if variable_name in variables:
+                if variables[variable_name] in server['variables'][
+                        variable_name]['enum_values']:
+                    url = url.replace("{" + variable_name + "}",
+                                      variables[variable_name])
+                else:
+                    raise ValueError(
+                        "The variable `{}` in the host URL has invalid value {}. Must be {}."  # noqa: E501
+                        .format(
+                            variable_name, variables[variable_name],
+                            server['variables'][variable_name]['enum_values']))
+            else:
+                # use default value
+                url = url.replace(
+                    "{" + variable_name + "}",
+                    server['variables'][variable_name]['default_value'])
+
+        return url
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/access_controlled_resource.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/access_controlled_resource.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,277 +1,277 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class AccessControlledResource(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'application': 'str',
-        'name': 'str',
-        'description': 'str',
-        'actions': 'list[AccessControlledAction]',
-        'identifier_parts': 'list[IdentifierPartSchema]',
-        'links': 'list[Link]'
-    }
-
-    attribute_map = {
-        'application': 'application',
-        'name': 'name',
-        'description': 'description',
-        'actions': 'actions',
-        'identifier_parts': 'identifierParts',
-        'links': 'links'
-    }
-
-    required_map = {
-        'application': 'optional',
-        'name': 'optional',
-        'description': 'required',
-        'actions': 'required',
-        'identifier_parts': 'optional',
-        'links': 'optional'
-    }
-
-    def __init__(self, application=None, name=None, description=None, actions=None, identifier_parts=None, links=None):  # noqa: E501
-        """
-        AccessControlledResource - a model defined in OpenAPI
-
-        :param application:  The application to which this resource belongs
-        :type application: str
-        :param name:  The display name of the resource
-        :type name: str
-        :param description:  The description of the resource (required)
-        :type description: str
-        :param actions:  The actions acceptable for this type of resource (required)
-        :type actions: list[finbourne_access.AccessControlledAction]
-        :param identifier_parts:  The constituent parts of a valid identifier for this resource
-        :type identifier_parts: list[finbourne_access.IdentifierPartSchema]
-        :param links: 
-        :type links: list[finbourne_access.Link]
-
-        """  # noqa: E501
-
-        self._application = None
-        self._name = None
-        self._description = None
-        self._actions = None
-        self._identifier_parts = None
-        self._links = None
-        self.discriminator = None
-
-        self.application = application
-        self.name = name
-        self.description = description
-        self.actions = actions
-        self.identifier_parts = identifier_parts
-        self.links = links
-
-    @property
-    def application(self):
-        """Gets the application of this AccessControlledResource.  # noqa: E501
-
-        The application to which this resource belongs  # noqa: E501
-
-        :return: The application of this AccessControlledResource.  # noqa: E501
-        :rtype: str
-        """
-        return self._application
-
-    @application.setter
-    def application(self, application):
-        """Sets the application of this AccessControlledResource.
-
-        The application to which this resource belongs  # noqa: E501
-
-        :param application: The application of this AccessControlledResource.  # noqa: E501
-        :type: str
-        """
-
-        self._application = application
-
-    @property
-    def name(self):
-        """Gets the name of this AccessControlledResource.  # noqa: E501
-
-        The display name of the resource  # noqa: E501
-
-        :return: The name of this AccessControlledResource.  # noqa: E501
-        :rtype: str
-        """
-        return self._name
-
-    @name.setter
-    def name(self, name):
-        """Sets the name of this AccessControlledResource.
-
-        The display name of the resource  # noqa: E501
-
-        :param name: The name of this AccessControlledResource.  # noqa: E501
-        :type: str
-        """
-
-        self._name = name
-
-    @property
-    def description(self):
-        """Gets the description of this AccessControlledResource.  # noqa: E501
-
-        The description of the resource  # noqa: E501
-
-        :return: The description of this AccessControlledResource.  # noqa: E501
-        :rtype: str
-        """
-        return self._description
-
-    @description.setter
-    def description(self, description):
-        """Sets the description of this AccessControlledResource.
-
-        The description of the resource  # noqa: E501
-
-        :param description: The description of this AccessControlledResource.  # noqa: E501
-        :type: str
-        """
-        if description is None:
-            raise ValueError("Invalid value for `description`, must not be `None`")  # noqa: E501
-
-        self._description = description
-
-    @property
-    def actions(self):
-        """Gets the actions of this AccessControlledResource.  # noqa: E501
-
-        The actions acceptable for this type of resource  # noqa: E501
-
-        :return: The actions of this AccessControlledResource.  # noqa: E501
-        :rtype: list[AccessControlledAction]
-        """
-        return self._actions
-
-    @actions.setter
-    def actions(self, actions):
-        """Sets the actions of this AccessControlledResource.
-
-        The actions acceptable for this type of resource  # noqa: E501
-
-        :param actions: The actions of this AccessControlledResource.  # noqa: E501
-        :type: list[AccessControlledAction]
-        """
-        if actions is None:
-            raise ValueError("Invalid value for `actions`, must not be `None`")  # noqa: E501
-
-        self._actions = actions
-
-    @property
-    def identifier_parts(self):
-        """Gets the identifier_parts of this AccessControlledResource.  # noqa: E501
-
-        The constituent parts of a valid identifier for this resource  # noqa: E501
-
-        :return: The identifier_parts of this AccessControlledResource.  # noqa: E501
-        :rtype: list[IdentifierPartSchema]
-        """
-        return self._identifier_parts
-
-    @identifier_parts.setter
-    def identifier_parts(self, identifier_parts):
-        """Sets the identifier_parts of this AccessControlledResource.
-
-        The constituent parts of a valid identifier for this resource  # noqa: E501
-
-        :param identifier_parts: The identifier_parts of this AccessControlledResource.  # noqa: E501
-        :type: list[IdentifierPartSchema]
-        """
-
-        self._identifier_parts = identifier_parts
-
-    @property
-    def links(self):
-        """Gets the links of this AccessControlledResource.  # noqa: E501
-
-
-        :return: The links of this AccessControlledResource.  # noqa: E501
-        :rtype: list[Link]
-        """
-        return self._links
-
-    @links.setter
-    def links(self, links):
-        """Sets the links of this AccessControlledResource.
-
-
-        :param links: The links of this AccessControlledResource.  # noqa: E501
-        :type: list[Link]
-        """
-
-        self._links = links
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, AccessControlledResource):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class AccessControlledResource(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'application': 'str',
+        'name': 'str',
+        'description': 'str',
+        'actions': 'list[AccessControlledAction]',
+        'identifier_parts': 'list[IdentifierPartSchema]',
+        'links': 'list[Link]'
+    }
+
+    attribute_map = {
+        'application': 'application',
+        'name': 'name',
+        'description': 'description',
+        'actions': 'actions',
+        'identifier_parts': 'identifierParts',
+        'links': 'links'
+    }
+
+    required_map = {
+        'application': 'optional',
+        'name': 'optional',
+        'description': 'required',
+        'actions': 'required',
+        'identifier_parts': 'optional',
+        'links': 'optional'
+    }
+
+    def __init__(self, application=None, name=None, description=None, actions=None, identifier_parts=None, links=None):  # noqa: E501
+        """
+        AccessControlledResource - a model defined in OpenAPI
+
+        :param application:  The application to which this resource belongs
+        :type application: str
+        :param name:  The display name of the resource
+        :type name: str
+        :param description:  The description of the resource (required)
+        :type description: str
+        :param actions:  The actions acceptable for this type of resource (required)
+        :type actions: list[finbourne_access.AccessControlledAction]
+        :param identifier_parts:  The constituent parts of a valid identifier for this resource
+        :type identifier_parts: list[finbourne_access.IdentifierPartSchema]
+        :param links: 
+        :type links: list[finbourne_access.Link]
+
+        """  # noqa: E501
+
+        self._application = None
+        self._name = None
+        self._description = None
+        self._actions = None
+        self._identifier_parts = None
+        self._links = None
+        self.discriminator = None
+
+        self.application = application
+        self.name = name
+        self.description = description
+        self.actions = actions
+        self.identifier_parts = identifier_parts
+        self.links = links
+
+    @property
+    def application(self):
+        """Gets the application of this AccessControlledResource.  # noqa: E501
+
+        The application to which this resource belongs  # noqa: E501
+
+        :return: The application of this AccessControlledResource.  # noqa: E501
+        :rtype: str
+        """
+        return self._application
+
+    @application.setter
+    def application(self, application):
+        """Sets the application of this AccessControlledResource.
+
+        The application to which this resource belongs  # noqa: E501
+
+        :param application: The application of this AccessControlledResource.  # noqa: E501
+        :type: str
+        """
+
+        self._application = application
+
+    @property
+    def name(self):
+        """Gets the name of this AccessControlledResource.  # noqa: E501
+
+        The display name of the resource  # noqa: E501
+
+        :return: The name of this AccessControlledResource.  # noqa: E501
+        :rtype: str
+        """
+        return self._name
+
+    @name.setter
+    def name(self, name):
+        """Sets the name of this AccessControlledResource.
+
+        The display name of the resource  # noqa: E501
+
+        :param name: The name of this AccessControlledResource.  # noqa: E501
+        :type: str
+        """
+
+        self._name = name
+
+    @property
+    def description(self):
+        """Gets the description of this AccessControlledResource.  # noqa: E501
+
+        The description of the resource  # noqa: E501
+
+        :return: The description of this AccessControlledResource.  # noqa: E501
+        :rtype: str
+        """
+        return self._description
+
+    @description.setter
+    def description(self, description):
+        """Sets the description of this AccessControlledResource.
+
+        The description of the resource  # noqa: E501
+
+        :param description: The description of this AccessControlledResource.  # noqa: E501
+        :type: str
+        """
+        if description is None:
+            raise ValueError("Invalid value for `description`, must not be `None`")  # noqa: E501
+
+        self._description = description
+
+    @property
+    def actions(self):
+        """Gets the actions of this AccessControlledResource.  # noqa: E501
+
+        The actions acceptable for this type of resource  # noqa: E501
+
+        :return: The actions of this AccessControlledResource.  # noqa: E501
+        :rtype: list[AccessControlledAction]
+        """
+        return self._actions
+
+    @actions.setter
+    def actions(self, actions):
+        """Sets the actions of this AccessControlledResource.
+
+        The actions acceptable for this type of resource  # noqa: E501
+
+        :param actions: The actions of this AccessControlledResource.  # noqa: E501
+        :type: list[AccessControlledAction]
+        """
+        if actions is None:
+            raise ValueError("Invalid value for `actions`, must not be `None`")  # noqa: E501
+
+        self._actions = actions
+
+    @property
+    def identifier_parts(self):
+        """Gets the identifier_parts of this AccessControlledResource.  # noqa: E501
+
+        The constituent parts of a valid identifier for this resource  # noqa: E501
+
+        :return: The identifier_parts of this AccessControlledResource.  # noqa: E501
+        :rtype: list[IdentifierPartSchema]
+        """
+        return self._identifier_parts
+
+    @identifier_parts.setter
+    def identifier_parts(self, identifier_parts):
+        """Sets the identifier_parts of this AccessControlledResource.
+
+        The constituent parts of a valid identifier for this resource  # noqa: E501
+
+        :param identifier_parts: The identifier_parts of this AccessControlledResource.  # noqa: E501
+        :type: list[IdentifierPartSchema]
+        """
+
+        self._identifier_parts = identifier_parts
+
+    @property
+    def links(self):
+        """Gets the links of this AccessControlledResource.  # noqa: E501
+
+
+        :return: The links of this AccessControlledResource.  # noqa: E501
+        :rtype: list[Link]
+        """
+        return self._links
+
+    @links.setter
+    def links(self, links):
+        """Sets the links of this AccessControlledResource.
+
+
+        :param links: The links of this AccessControlledResource.  # noqa: E501
+        :type: list[Link]
+        """
+
+        self._links = links
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, AccessControlledResource):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/action_id.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/action_id.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,197 +1,197 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class ActionId(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'scope': 'str',
-        'activity': 'str',
-        'entity': 'str'
-    }
-
-    attribute_map = {
-        'scope': 'scope',
-        'activity': 'activity',
-        'entity': 'entity'
-    }
-
-    required_map = {
-        'scope': 'required',
-        'activity': 'required',
-        'entity': 'required'
-    }
-
-    def __init__(self, scope=None, activity=None, entity=None):  # noqa: E501
-        """
-        ActionId - a model defined in OpenAPI
-
-        :param scope:  (required)
-        :type scope: str
-        :param activity:  (required)
-        :type activity: str
-        :param entity:  (required)
-        :type entity: str
-
-        """  # noqa: E501
-
-        self._scope = None
-        self._activity = None
-        self._entity = None
-        self.discriminator = None
-
-        self.scope = scope
-        self.activity = activity
-        self.entity = entity
-
-    @property
-    def scope(self):
-        """Gets the scope of this ActionId.  # noqa: E501
-
-
-        :return: The scope of this ActionId.  # noqa: E501
-        :rtype: str
-        """
-        return self._scope
-
-    @scope.setter
-    def scope(self, scope):
-        """Sets the scope of this ActionId.
-
-
-        :param scope: The scope of this ActionId.  # noqa: E501
-        :type: str
-        """
-        if scope is None:
-            raise ValueError("Invalid value for `scope`, must not be `None`")  # noqa: E501
-        if scope is not None and len(scope) > 100:
-            raise ValueError("Invalid value for `scope`, length must be less than or equal to `100`")  # noqa: E501
-        if scope is not None and len(scope) < 3:
-            raise ValueError("Invalid value for `scope`, length must be greater than or equal to `3`")  # noqa: E501
-
-        self._scope = scope
-
-    @property
-    def activity(self):
-        """Gets the activity of this ActionId.  # noqa: E501
-
-
-        :return: The activity of this ActionId.  # noqa: E501
-        :rtype: str
-        """
-        return self._activity
-
-    @activity.setter
-    def activity(self, activity):
-        """Sets the activity of this ActionId.
-
-
-        :param activity: The activity of this ActionId.  # noqa: E501
-        :type: str
-        """
-        if activity is None:
-            raise ValueError("Invalid value for `activity`, must not be `None`")  # noqa: E501
-        if activity is not None and len(activity) > 25:
-            raise ValueError("Invalid value for `activity`, length must be less than or equal to `25`")  # noqa: E501
-        if activity is not None and len(activity) < 3:
-            raise ValueError("Invalid value for `activity`, length must be greater than or equal to `3`")  # noqa: E501
-
-        self._activity = activity
-
-    @property
-    def entity(self):
-        """Gets the entity of this ActionId.  # noqa: E501
-
-
-        :return: The entity of this ActionId.  # noqa: E501
-        :rtype: str
-        """
-        return self._entity
-
-    @entity.setter
-    def entity(self, entity):
-        """Sets the entity of this ActionId.
-
-
-        :param entity: The entity of this ActionId.  # noqa: E501
-        :type: str
-        """
-        if entity is None:
-            raise ValueError("Invalid value for `entity`, must not be `None`")  # noqa: E501
-        if entity is not None and len(entity) > 25:
-            raise ValueError("Invalid value for `entity`, length must be less than or equal to `25`")  # noqa: E501
-        if entity is not None and len(entity) < 3:
-            raise ValueError("Invalid value for `entity`, length must be greater than or equal to `3`")  # noqa: E501
-
-        self._entity = entity
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, ActionId):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class ActionId(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'scope': 'str',
+        'activity': 'str',
+        'entity': 'str'
+    }
+
+    attribute_map = {
+        'scope': 'scope',
+        'activity': 'activity',
+        'entity': 'entity'
+    }
+
+    required_map = {
+        'scope': 'required',
+        'activity': 'required',
+        'entity': 'required'
+    }
+
+    def __init__(self, scope=None, activity=None, entity=None):  # noqa: E501
+        """
+        ActionId - a model defined in OpenAPI
+
+        :param scope:  (required)
+        :type scope: str
+        :param activity:  (required)
+        :type activity: str
+        :param entity:  (required)
+        :type entity: str
+
+        """  # noqa: E501
+
+        self._scope = None
+        self._activity = None
+        self._entity = None
+        self.discriminator = None
+
+        self.scope = scope
+        self.activity = activity
+        self.entity = entity
+
+    @property
+    def scope(self):
+        """Gets the scope of this ActionId.  # noqa: E501
+
+
+        :return: The scope of this ActionId.  # noqa: E501
+        :rtype: str
+        """
+        return self._scope
+
+    @scope.setter
+    def scope(self, scope):
+        """Sets the scope of this ActionId.
+
+
+        :param scope: The scope of this ActionId.  # noqa: E501
+        :type: str
+        """
+        if scope is None:
+            raise ValueError("Invalid value for `scope`, must not be `None`")  # noqa: E501
+        if scope is not None and len(scope) > 100:
+            raise ValueError("Invalid value for `scope`, length must be less than or equal to `100`")  # noqa: E501
+        if scope is not None and len(scope) < 3:
+            raise ValueError("Invalid value for `scope`, length must be greater than or equal to `3`")  # noqa: E501
+
+        self._scope = scope
+
+    @property
+    def activity(self):
+        """Gets the activity of this ActionId.  # noqa: E501
+
+
+        :return: The activity of this ActionId.  # noqa: E501
+        :rtype: str
+        """
+        return self._activity
+
+    @activity.setter
+    def activity(self, activity):
+        """Sets the activity of this ActionId.
+
+
+        :param activity: The activity of this ActionId.  # noqa: E501
+        :type: str
+        """
+        if activity is None:
+            raise ValueError("Invalid value for `activity`, must not be `None`")  # noqa: E501
+        if activity is not None and len(activity) > 25:
+            raise ValueError("Invalid value for `activity`, length must be less than or equal to `25`")  # noqa: E501
+        if activity is not None and len(activity) < 3:
+            raise ValueError("Invalid value for `activity`, length must be greater than or equal to `3`")  # noqa: E501
+
+        self._activity = activity
+
+    @property
+    def entity(self):
+        """Gets the entity of this ActionId.  # noqa: E501
+
+
+        :return: The entity of this ActionId.  # noqa: E501
+        :rtype: str
+        """
+        return self._entity
+
+    @entity.setter
+    def entity(self, entity):
+        """Sets the entity of this ActionId.
+
+
+        :param entity: The entity of this ActionId.  # noqa: E501
+        :type: str
+        """
+        if entity is None:
+            raise ValueError("Invalid value for `entity`, must not be `None`")  # noqa: E501
+        if entity is not None and len(entity) > 25:
+            raise ValueError("Invalid value for `entity`, length must be less than or equal to `25`")  # noqa: E501
+        if entity is not None and len(entity) < 3:
+            raise ValueError("Invalid value for `entity`, length must be greater than or equal to `3`")  # noqa: E501
+
+        self._entity = entity
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, ActionId):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/as_at_predicate_contract.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/as_at_range_for_spec.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,151 +1,155 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class AsAtPredicateContract(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'value': 'str',
-        'date_time_offset': 'datetime'
-    }
-
-    attribute_map = {
-        'value': 'value',
-        'date_time_offset': 'dateTimeOffset'
-    }
-
-    required_map = {
-        'value': 'optional',
-        'date_time_offset': 'optional'
-    }
-
-    def __init__(self, value=None, date_time_offset=None):  # noqa: E501
-        """
-        AsAtPredicateContract - a model defined in OpenAPI
-
-        :param value: 
-        :type value: str
-        :param date_time_offset: 
-        :type date_time_offset: datetime
-
-        """  # noqa: E501
-
-        self._value = None
-        self._date_time_offset = None
-        self.discriminator = None
-
-        self.value = value
-        self.date_time_offset = date_time_offset
-
-    @property
-    def value(self):
-        """Gets the value of this AsAtPredicateContract.  # noqa: E501
-
-
-        :return: The value of this AsAtPredicateContract.  # noqa: E501
-        :rtype: str
-        """
-        return self._value
-
-    @value.setter
-    def value(self, value):
-        """Sets the value of this AsAtPredicateContract.
-
-
-        :param value: The value of this AsAtPredicateContract.  # noqa: E501
-        :type: str
-        """
-
-        self._value = value
-
-    @property
-    def date_time_offset(self):
-        """Gets the date_time_offset of this AsAtPredicateContract.  # noqa: E501
-
-
-        :return: The date_time_offset of this AsAtPredicateContract.  # noqa: E501
-        :rtype: datetime
-        """
-        return self._date_time_offset
-
-    @date_time_offset.setter
-    def date_time_offset(self, date_time_offset):
-        """Sets the date_time_offset of this AsAtPredicateContract.
-
-
-        :param date_time_offset: The date_time_offset of this AsAtPredicateContract.  # noqa: E501
-        :type: datetime
-        """
-
-        self._date_time_offset = date_time_offset
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, AsAtPredicateContract):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class AsAtRangeForSpec(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        '_from': 'AsAtPredicateContract',
+        'to': 'AsAtPredicateContract'
+    }
+
+    attribute_map = {
+        '_from': 'from',
+        'to': 'to'
+    }
+
+    required_map = {
+        '_from': 'required',
+        'to': 'required'
+    }
+
+    def __init__(self, _from=None, to=None):  # noqa: E501
+        """
+        AsAtRangeForSpec - a model defined in OpenAPI
+
+        :param _from:  (required)
+        :type _from: finbourne_access.AsAtPredicateContract
+        :param to:  (required)
+        :type to: finbourne_access.AsAtPredicateContract
+
+        """  # noqa: E501
+
+        self.__from = None
+        self._to = None
+        self.discriminator = None
+
+        self._from = _from
+        self.to = to
+
+    @property
+    def _from(self):
+        """Gets the _from of this AsAtRangeForSpec.  # noqa: E501
+
+
+        :return: The _from of this AsAtRangeForSpec.  # noqa: E501
+        :rtype: AsAtPredicateContract
+        """
+        return self.__from
+
+    @_from.setter
+    def _from(self, _from):
+        """Sets the _from of this AsAtRangeForSpec.
+
+
+        :param _from: The _from of this AsAtRangeForSpec.  # noqa: E501
+        :type: AsAtPredicateContract
+        """
+        if _from is None:
+            raise ValueError("Invalid value for `_from`, must not be `None`")  # noqa: E501
+
+        self.__from = _from
+
+    @property
+    def to(self):
+        """Gets the to of this AsAtRangeForSpec.  # noqa: E501
+
+
+        :return: The to of this AsAtRangeForSpec.  # noqa: E501
+        :rtype: AsAtPredicateContract
+        """
+        return self._to
+
+    @to.setter
+    def to(self, to):
+        """Sets the to of this AsAtRangeForSpec.
+
+
+        :param to: The to of this AsAtRangeForSpec.  # noqa: E501
+        :type: AsAtPredicateContract
+        """
+        if to is None:
+            raise ValueError("Invalid value for `to`, must not be `None`")  # noqa: E501
+
+        self._to = to
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, AsAtRangeForSpec):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/as_at_range_for_spec.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/as_at_predicate_contract.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,153 +1,155 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class AsAtRangeForSpec(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        '_from': 'AsAtPredicateContract',
-        'to': 'AsAtPredicateContract'
-    }
-
-    attribute_map = {
-        '_from': 'from',
-        'to': 'to'
-    }
-
-    required_map = {
-        '_from': 'optional',
-        'to': 'optional'
-    }
-
-    def __init__(self, _from=None, to=None):  # noqa: E501
-        """
-        AsAtRangeForSpec - a model defined in OpenAPI
-
-        :param _from: 
-        :type _from: finbourne_access.AsAtPredicateContract
-        :param to: 
-        :type to: finbourne_access.AsAtPredicateContract
-
-        """  # noqa: E501
-
-        self.__from = None
-        self._to = None
-        self.discriminator = None
-
-        if _from is not None:
-            self._from = _from
-        if to is not None:
-            self.to = to
-
-    @property
-    def _from(self):
-        """Gets the _from of this AsAtRangeForSpec.  # noqa: E501
-
-
-        :return: The _from of this AsAtRangeForSpec.  # noqa: E501
-        :rtype: AsAtPredicateContract
-        """
-        return self.__from
-
-    @_from.setter
-    def _from(self, _from):
-        """Sets the _from of this AsAtRangeForSpec.
-
-
-        :param _from: The _from of this AsAtRangeForSpec.  # noqa: E501
-        :type: AsAtPredicateContract
-        """
-
-        self.__from = _from
-
-    @property
-    def to(self):
-        """Gets the to of this AsAtRangeForSpec.  # noqa: E501
-
-
-        :return: The to of this AsAtRangeForSpec.  # noqa: E501
-        :rtype: AsAtPredicateContract
-        """
-        return self._to
-
-    @to.setter
-    def to(self, to):
-        """Sets the to of this AsAtRangeForSpec.
-
-
-        :param to: The to of this AsAtRangeForSpec.  # noqa: E501
-        :type: AsAtPredicateContract
-        """
-
-        self._to = to
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, AsAtRangeForSpec):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class AsAtPredicateContract(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'value': 'str',
+        'date_time_offset': 'datetime'
+    }
+
+    attribute_map = {
+        'value': 'value',
+        'date_time_offset': 'dateTimeOffset'
+    }
+
+    required_map = {
+        'value': 'optional',
+        'date_time_offset': 'optional'
+    }
+
+    def __init__(self, value=None, date_time_offset=None):  # noqa: E501
+        """
+        AsAtPredicateContract - a model defined in OpenAPI
+
+        :param value: 
+        :type value: str
+        :param date_time_offset: 
+        :type date_time_offset: datetime
+
+        """  # noqa: E501
+
+        self._value = None
+        self._date_time_offset = None
+        self.discriminator = None
+
+        self.value = value
+        self.date_time_offset = date_time_offset
+
+    @property
+    def value(self):
+        """Gets the value of this AsAtPredicateContract.  # noqa: E501
+
+
+        :return: The value of this AsAtPredicateContract.  # noqa: E501
+        :rtype: str
+        """
+        return self._value
+
+    @value.setter
+    def value(self, value):
+        """Sets the value of this AsAtPredicateContract.
+
+
+        :param value: The value of this AsAtPredicateContract.  # noqa: E501
+        :type: str
+        """
+        if value is not None and len(value) > 25:
+            raise ValueError("Invalid value for `value`, length must be less than or equal to `25`")  # noqa: E501
+        if value is not None and len(value) < 5:
+            raise ValueError("Invalid value for `value`, length must be greater than or equal to `5`")  # noqa: E501
+
+        self._value = value
+
+    @property
+    def date_time_offset(self):
+        """Gets the date_time_offset of this AsAtPredicateContract.  # noqa: E501
+
+
+        :return: The date_time_offset of this AsAtPredicateContract.  # noqa: E501
+        :rtype: datetime
+        """
+        return self._date_time_offset
+
+    @date_time_offset.setter
+    def date_time_offset(self, date_time_offset):
+        """Sets the date_time_offset of this AsAtPredicateContract.
+
+
+        :param date_time_offset: The date_time_offset of this AsAtPredicateContract.  # noqa: E501
+        :type: datetime
+        """
+
+        self._date_time_offset = date_time_offset
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, AsAtPredicateContract):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/as_at_relative.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/as_at_relative.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,211 +1,211 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class AsAtRelative(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'date': 'PointInTimeSpecification',
-        'adjustment': 'int',
-        'unit': 'DateUnit',
-        'relative_to_date_time': 'RelativeToDateTime'
-    }
-
-    attribute_map = {
-        'date': 'date',
-        'adjustment': 'adjustment',
-        'unit': 'unit',
-        'relative_to_date_time': 'relativeToDateTime'
-    }
-
-    required_map = {
-        'date': 'optional',
-        'adjustment': 'optional',
-        'unit': 'optional',
-        'relative_to_date_time': 'optional'
-    }
-
-    def __init__(self, date=None, adjustment=None, unit=None, relative_to_date_time=None):  # noqa: E501
-        """
-        AsAtRelative - a model defined in OpenAPI
-
-        :param date: 
-        :type date: finbourne_access.PointInTimeSpecification
-        :param adjustment: 
-        :type adjustment: int
-        :param unit: 
-        :type unit: finbourne_access.DateUnit
-        :param relative_to_date_time: 
-        :type relative_to_date_time: finbourne_access.RelativeToDateTime
-
-        """  # noqa: E501
-
-        self._date = None
-        self._adjustment = None
-        self._unit = None
-        self._relative_to_date_time = None
-        self.discriminator = None
-
-        if date is not None:
-            self.date = date
-        if adjustment is not None:
-            self.adjustment = adjustment
-        if unit is not None:
-            self.unit = unit
-        if relative_to_date_time is not None:
-            self.relative_to_date_time = relative_to_date_time
-
-    @property
-    def date(self):
-        """Gets the date of this AsAtRelative.  # noqa: E501
-
-
-        :return: The date of this AsAtRelative.  # noqa: E501
-        :rtype: PointInTimeSpecification
-        """
-        return self._date
-
-    @date.setter
-    def date(self, date):
-        """Sets the date of this AsAtRelative.
-
-
-        :param date: The date of this AsAtRelative.  # noqa: E501
-        :type: PointInTimeSpecification
-        """
-
-        self._date = date
-
-    @property
-    def adjustment(self):
-        """Gets the adjustment of this AsAtRelative.  # noqa: E501
-
-
-        :return: The adjustment of this AsAtRelative.  # noqa: E501
-        :rtype: int
-        """
-        return self._adjustment
-
-    @adjustment.setter
-    def adjustment(self, adjustment):
-        """Sets the adjustment of this AsAtRelative.
-
-
-        :param adjustment: The adjustment of this AsAtRelative.  # noqa: E501
-        :type: int
-        """
-
-        self._adjustment = adjustment
-
-    @property
-    def unit(self):
-        """Gets the unit of this AsAtRelative.  # noqa: E501
-
-
-        :return: The unit of this AsAtRelative.  # noqa: E501
-        :rtype: DateUnit
-        """
-        return self._unit
-
-    @unit.setter
-    def unit(self, unit):
-        """Sets the unit of this AsAtRelative.
-
-
-        :param unit: The unit of this AsAtRelative.  # noqa: E501
-        :type: DateUnit
-        """
-
-        self._unit = unit
-
-    @property
-    def relative_to_date_time(self):
-        """Gets the relative_to_date_time of this AsAtRelative.  # noqa: E501
-
-
-        :return: The relative_to_date_time of this AsAtRelative.  # noqa: E501
-        :rtype: RelativeToDateTime
-        """
-        return self._relative_to_date_time
-
-    @relative_to_date_time.setter
-    def relative_to_date_time(self, relative_to_date_time):
-        """Sets the relative_to_date_time of this AsAtRelative.
-
-
-        :param relative_to_date_time: The relative_to_date_time of this AsAtRelative.  # noqa: E501
-        :type: RelativeToDateTime
-        """
-
-        self._relative_to_date_time = relative_to_date_time
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, AsAtRelative):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class AsAtRelative(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'date': 'PointInTimeSpecification',
+        'adjustment': 'int',
+        'unit': 'DateUnit',
+        'relative_to_date_time': 'RelativeToDateTime'
+    }
+
+    attribute_map = {
+        'date': 'date',
+        'adjustment': 'adjustment',
+        'unit': 'unit',
+        'relative_to_date_time': 'relativeToDateTime'
+    }
+
+    required_map = {
+        'date': 'optional',
+        'adjustment': 'optional',
+        'unit': 'optional',
+        'relative_to_date_time': 'optional'
+    }
+
+    def __init__(self, date=None, adjustment=None, unit=None, relative_to_date_time=None):  # noqa: E501
+        """
+        AsAtRelative - a model defined in OpenAPI
+
+        :param date: 
+        :type date: finbourne_access.PointInTimeSpecification
+        :param adjustment: 
+        :type adjustment: int
+        :param unit: 
+        :type unit: finbourne_access.DateUnit
+        :param relative_to_date_time: 
+        :type relative_to_date_time: finbourne_access.RelativeToDateTime
+
+        """  # noqa: E501
+
+        self._date = None
+        self._adjustment = None
+        self._unit = None
+        self._relative_to_date_time = None
+        self.discriminator = None
+
+        if date is not None:
+            self.date = date
+        if adjustment is not None:
+            self.adjustment = adjustment
+        if unit is not None:
+            self.unit = unit
+        if relative_to_date_time is not None:
+            self.relative_to_date_time = relative_to_date_time
+
+    @property
+    def date(self):
+        """Gets the date of this AsAtRelative.  # noqa: E501
+
+
+        :return: The date of this AsAtRelative.  # noqa: E501
+        :rtype: PointInTimeSpecification
+        """
+        return self._date
+
+    @date.setter
+    def date(self, date):
+        """Sets the date of this AsAtRelative.
+
+
+        :param date: The date of this AsAtRelative.  # noqa: E501
+        :type: PointInTimeSpecification
+        """
+
+        self._date = date
+
+    @property
+    def adjustment(self):
+        """Gets the adjustment of this AsAtRelative.  # noqa: E501
+
+
+        :return: The adjustment of this AsAtRelative.  # noqa: E501
+        :rtype: int
+        """
+        return self._adjustment
+
+    @adjustment.setter
+    def adjustment(self, adjustment):
+        """Sets the adjustment of this AsAtRelative.
+
+
+        :param adjustment: The adjustment of this AsAtRelative.  # noqa: E501
+        :type: int
+        """
+
+        self._adjustment = adjustment
+
+    @property
+    def unit(self):
+        """Gets the unit of this AsAtRelative.  # noqa: E501
+
+
+        :return: The unit of this AsAtRelative.  # noqa: E501
+        :rtype: DateUnit
+        """
+        return self._unit
+
+    @unit.setter
+    def unit(self, unit):
+        """Sets the unit of this AsAtRelative.
+
+
+        :param unit: The unit of this AsAtRelative.  # noqa: E501
+        :type: DateUnit
+        """
+
+        self._unit = unit
+
+    @property
+    def relative_to_date_time(self):
+        """Gets the relative_to_date_time of this AsAtRelative.  # noqa: E501
+
+
+        :return: The relative_to_date_time of this AsAtRelative.  # noqa: E501
+        :rtype: RelativeToDateTime
+        """
+        return self._relative_to_date_time
+
+    @relative_to_date_time.setter
+    def relative_to_date_time(self, relative_to_date_time):
+        """Sets the relative_to_date_time of this AsAtRelative.
+
+
+        :param relative_to_date_time: The relative_to_date_time of this AsAtRelative.  # noqa: E501
+        :type: RelativeToDateTime
+        """
+
+        self._relative_to_date_time = relative_to_date_time
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, AsAtRelative):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/attached_policy_definition_response.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/attached_policy_definition_response.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,438 +1,438 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class AttachedPolicyDefinitionResponse(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'source_role': 'RoleId',
-        'role_hierarchy_index': 'int',
-        'description': 'str',
-        'applications': 'list[str]',
-        'policy_type': 'PolicyType',
-        'id': 'PolicyId',
-        'grant': 'Grant',
-        'selectors': 'list[SelectorDefinition]',
-        '_for': 'list[ForSpec]',
-        '_if': 'list[IfExpression]',
-        'when': 'WhenSpec',
-        'how': 'HowSpec'
-    }
-
-    attribute_map = {
-        'source_role': 'sourceRole',
-        'role_hierarchy_index': 'roleHierarchyIndex',
-        'description': 'description',
-        'applications': 'applications',
-        'policy_type': 'policyType',
-        'id': 'id',
-        'grant': 'grant',
-        'selectors': 'selectors',
-        '_for': 'for',
-        '_if': 'if',
-        'when': 'when',
-        'how': 'how'
-    }
-
-    required_map = {
-        'source_role': 'optional',
-        'role_hierarchy_index': 'optional',
-        'description': 'optional',
-        'applications': 'optional',
-        'policy_type': 'optional',
-        'id': 'optional',
-        'grant': 'optional',
-        'selectors': 'optional',
-        '_for': 'optional',
-        '_if': 'optional',
-        'when': 'optional',
-        'how': 'optional'
-    }
-
-    def __init__(self, source_role=None, role_hierarchy_index=None, description=None, applications=None, policy_type=None, id=None, grant=None, selectors=None, _for=None, _if=None, when=None, how=None):  # noqa: E501
-        """
-        AttachedPolicyDefinitionResponse - a model defined in OpenAPI
-
-        :param source_role: 
-        :type source_role: finbourne_access.RoleId
-        :param role_hierarchy_index: 
-        :type role_hierarchy_index: int
-        :param description: 
-        :type description: str
-        :param applications: 
-        :type applications: list[str]
-        :param policy_type: 
-        :type policy_type: finbourne_access.PolicyType
-        :param id: 
-        :type id: finbourne_access.PolicyId
-        :param grant: 
-        :type grant: finbourne_access.Grant
-        :param selectors: 
-        :type selectors: list[finbourne_access.SelectorDefinition]
-        :param _for: 
-        :type _for: list[finbourne_access.ForSpec]
-        :param _if: 
-        :type _if: list[finbourne_access.IfExpression]
-        :param when: 
-        :type when: finbourne_access.WhenSpec
-        :param how: 
-        :type how: finbourne_access.HowSpec
-
-        """  # noqa: E501
-
-        self._source_role = None
-        self._role_hierarchy_index = None
-        self._description = None
-        self._applications = None
-        self._policy_type = None
-        self._id = None
-        self._grant = None
-        self._selectors = None
-        self.__for = None
-        self.__if = None
-        self._when = None
-        self._how = None
-        self.discriminator = None
-
-        if source_role is not None:
-            self.source_role = source_role
-        if role_hierarchy_index is not None:
-            self.role_hierarchy_index = role_hierarchy_index
-        self.description = description
-        self.applications = applications
-        if policy_type is not None:
-            self.policy_type = policy_type
-        if id is not None:
-            self.id = id
-        if grant is not None:
-            self.grant = grant
-        self.selectors = selectors
-        self._for = _for
-        self._if = _if
-        if when is not None:
-            self.when = when
-        if how is not None:
-            self.how = how
-
-    @property
-    def source_role(self):
-        """Gets the source_role of this AttachedPolicyDefinitionResponse.  # noqa: E501
-
-
-        :return: The source_role of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :rtype: RoleId
-        """
-        return self._source_role
-
-    @source_role.setter
-    def source_role(self, source_role):
-        """Sets the source_role of this AttachedPolicyDefinitionResponse.
-
-
-        :param source_role: The source_role of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :type: RoleId
-        """
-
-        self._source_role = source_role
-
-    @property
-    def role_hierarchy_index(self):
-        """Gets the role_hierarchy_index of this AttachedPolicyDefinitionResponse.  # noqa: E501
-
-
-        :return: The role_hierarchy_index of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :rtype: int
-        """
-        return self._role_hierarchy_index
-
-    @role_hierarchy_index.setter
-    def role_hierarchy_index(self, role_hierarchy_index):
-        """Sets the role_hierarchy_index of this AttachedPolicyDefinitionResponse.
-
-
-        :param role_hierarchy_index: The role_hierarchy_index of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :type: int
-        """
-
-        self._role_hierarchy_index = role_hierarchy_index
-
-    @property
-    def description(self):
-        """Gets the description of this AttachedPolicyDefinitionResponse.  # noqa: E501
-
-
-        :return: The description of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :rtype: str
-        """
-        return self._description
-
-    @description.setter
-    def description(self, description):
-        """Sets the description of this AttachedPolicyDefinitionResponse.
-
-
-        :param description: The description of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :type: str
-        """
-
-        self._description = description
-
-    @property
-    def applications(self):
-        """Gets the applications of this AttachedPolicyDefinitionResponse.  # noqa: E501
-
-
-        :return: The applications of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :rtype: list[str]
-        """
-        return self._applications
-
-    @applications.setter
-    def applications(self, applications):
-        """Sets the applications of this AttachedPolicyDefinitionResponse.
-
-
-        :param applications: The applications of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :type: list[str]
-        """
-
-        self._applications = applications
-
-    @property
-    def policy_type(self):
-        """Gets the policy_type of this AttachedPolicyDefinitionResponse.  # noqa: E501
-
-
-        :return: The policy_type of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :rtype: PolicyType
-        """
-        return self._policy_type
-
-    @policy_type.setter
-    def policy_type(self, policy_type):
-        """Sets the policy_type of this AttachedPolicyDefinitionResponse.
-
-
-        :param policy_type: The policy_type of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :type: PolicyType
-        """
-
-        self._policy_type = policy_type
-
-    @property
-    def id(self):
-        """Gets the id of this AttachedPolicyDefinitionResponse.  # noqa: E501
-
-
-        :return: The id of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :rtype: PolicyId
-        """
-        return self._id
-
-    @id.setter
-    def id(self, id):
-        """Sets the id of this AttachedPolicyDefinitionResponse.
-
-
-        :param id: The id of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :type: PolicyId
-        """
-
-        self._id = id
-
-    @property
-    def grant(self):
-        """Gets the grant of this AttachedPolicyDefinitionResponse.  # noqa: E501
-
-
-        :return: The grant of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :rtype: Grant
-        """
-        return self._grant
-
-    @grant.setter
-    def grant(self, grant):
-        """Sets the grant of this AttachedPolicyDefinitionResponse.
-
-
-        :param grant: The grant of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :type: Grant
-        """
-
-        self._grant = grant
-
-    @property
-    def selectors(self):
-        """Gets the selectors of this AttachedPolicyDefinitionResponse.  # noqa: E501
-
-
-        :return: The selectors of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :rtype: list[SelectorDefinition]
-        """
-        return self._selectors
-
-    @selectors.setter
-    def selectors(self, selectors):
-        """Sets the selectors of this AttachedPolicyDefinitionResponse.
-
-
-        :param selectors: The selectors of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :type: list[SelectorDefinition]
-        """
-
-        self._selectors = selectors
-
-    @property
-    def _for(self):
-        """Gets the _for of this AttachedPolicyDefinitionResponse.  # noqa: E501
-
-
-        :return: The _for of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :rtype: list[ForSpec]
-        """
-        return self.__for
-
-    @_for.setter
-    def _for(self, _for):
-        """Sets the _for of this AttachedPolicyDefinitionResponse.
-
-
-        :param _for: The _for of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :type: list[ForSpec]
-        """
-
-        self.__for = _for
-
-    @property
-    def _if(self):
-        """Gets the _if of this AttachedPolicyDefinitionResponse.  # noqa: E501
-
-
-        :return: The _if of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :rtype: list[IfExpression]
-        """
-        return self.__if
-
-    @_if.setter
-    def _if(self, _if):
-        """Sets the _if of this AttachedPolicyDefinitionResponse.
-
-
-        :param _if: The _if of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :type: list[IfExpression]
-        """
-
-        self.__if = _if
-
-    @property
-    def when(self):
-        """Gets the when of this AttachedPolicyDefinitionResponse.  # noqa: E501
-
-
-        :return: The when of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :rtype: WhenSpec
-        """
-        return self._when
-
-    @when.setter
-    def when(self, when):
-        """Sets the when of this AttachedPolicyDefinitionResponse.
-
-
-        :param when: The when of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :type: WhenSpec
-        """
-
-        self._when = when
-
-    @property
-    def how(self):
-        """Gets the how of this AttachedPolicyDefinitionResponse.  # noqa: E501
-
-
-        :return: The how of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :rtype: HowSpec
-        """
-        return self._how
-
-    @how.setter
-    def how(self, how):
-        """Sets the how of this AttachedPolicyDefinitionResponse.
-
-
-        :param how: The how of this AttachedPolicyDefinitionResponse.  # noqa: E501
-        :type: HowSpec
-        """
-
-        self._how = how
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, AttachedPolicyDefinitionResponse):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class AttachedPolicyDefinitionResponse(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'source_role': 'RoleId',
+        'role_hierarchy_index': 'int',
+        'description': 'str',
+        'applications': 'list[str]',
+        'policy_type': 'PolicyType',
+        'id': 'PolicyId',
+        'grant': 'Grant',
+        'selectors': 'list[SelectorDefinition]',
+        '_for': 'list[ForSpec]',
+        '_if': 'list[IfExpression]',
+        'when': 'WhenSpec',
+        'how': 'HowSpec'
+    }
+
+    attribute_map = {
+        'source_role': 'sourceRole',
+        'role_hierarchy_index': 'roleHierarchyIndex',
+        'description': 'description',
+        'applications': 'applications',
+        'policy_type': 'policyType',
+        'id': 'id',
+        'grant': 'grant',
+        'selectors': 'selectors',
+        '_for': 'for',
+        '_if': 'if',
+        'when': 'when',
+        'how': 'how'
+    }
+
+    required_map = {
+        'source_role': 'optional',
+        'role_hierarchy_index': 'optional',
+        'description': 'optional',
+        'applications': 'optional',
+        'policy_type': 'optional',
+        'id': 'optional',
+        'grant': 'optional',
+        'selectors': 'optional',
+        '_for': 'optional',
+        '_if': 'optional',
+        'when': 'optional',
+        'how': 'optional'
+    }
+
+    def __init__(self, source_role=None, role_hierarchy_index=None, description=None, applications=None, policy_type=None, id=None, grant=None, selectors=None, _for=None, _if=None, when=None, how=None):  # noqa: E501
+        """
+        AttachedPolicyDefinitionResponse - a model defined in OpenAPI
+
+        :param source_role: 
+        :type source_role: finbourne_access.RoleId
+        :param role_hierarchy_index: 
+        :type role_hierarchy_index: int
+        :param description: 
+        :type description: str
+        :param applications: 
+        :type applications: list[str]
+        :param policy_type: 
+        :type policy_type: finbourne_access.PolicyType
+        :param id: 
+        :type id: finbourne_access.PolicyId
+        :param grant: 
+        :type grant: finbourne_access.Grant
+        :param selectors: 
+        :type selectors: list[finbourne_access.SelectorDefinition]
+        :param _for: 
+        :type _for: list[finbourne_access.ForSpec]
+        :param _if: 
+        :type _if: list[finbourne_access.IfExpression]
+        :param when: 
+        :type when: finbourne_access.WhenSpec
+        :param how: 
+        :type how: finbourne_access.HowSpec
+
+        """  # noqa: E501
+
+        self._source_role = None
+        self._role_hierarchy_index = None
+        self._description = None
+        self._applications = None
+        self._policy_type = None
+        self._id = None
+        self._grant = None
+        self._selectors = None
+        self.__for = None
+        self.__if = None
+        self._when = None
+        self._how = None
+        self.discriminator = None
+
+        if source_role is not None:
+            self.source_role = source_role
+        if role_hierarchy_index is not None:
+            self.role_hierarchy_index = role_hierarchy_index
+        self.description = description
+        self.applications = applications
+        if policy_type is not None:
+            self.policy_type = policy_type
+        if id is not None:
+            self.id = id
+        if grant is not None:
+            self.grant = grant
+        self.selectors = selectors
+        self._for = _for
+        self._if = _if
+        if when is not None:
+            self.when = when
+        if how is not None:
+            self.how = how
+
+    @property
+    def source_role(self):
+        """Gets the source_role of this AttachedPolicyDefinitionResponse.  # noqa: E501
+
+
+        :return: The source_role of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :rtype: RoleId
+        """
+        return self._source_role
+
+    @source_role.setter
+    def source_role(self, source_role):
+        """Sets the source_role of this AttachedPolicyDefinitionResponse.
+
+
+        :param source_role: The source_role of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :type: RoleId
+        """
+
+        self._source_role = source_role
+
+    @property
+    def role_hierarchy_index(self):
+        """Gets the role_hierarchy_index of this AttachedPolicyDefinitionResponse.  # noqa: E501
+
+
+        :return: The role_hierarchy_index of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :rtype: int
+        """
+        return self._role_hierarchy_index
+
+    @role_hierarchy_index.setter
+    def role_hierarchy_index(self, role_hierarchy_index):
+        """Sets the role_hierarchy_index of this AttachedPolicyDefinitionResponse.
+
+
+        :param role_hierarchy_index: The role_hierarchy_index of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :type: int
+        """
+
+        self._role_hierarchy_index = role_hierarchy_index
+
+    @property
+    def description(self):
+        """Gets the description of this AttachedPolicyDefinitionResponse.  # noqa: E501
+
+
+        :return: The description of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :rtype: str
+        """
+        return self._description
+
+    @description.setter
+    def description(self, description):
+        """Sets the description of this AttachedPolicyDefinitionResponse.
+
+
+        :param description: The description of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :type: str
+        """
+
+        self._description = description
+
+    @property
+    def applications(self):
+        """Gets the applications of this AttachedPolicyDefinitionResponse.  # noqa: E501
+
+
+        :return: The applications of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :rtype: list[str]
+        """
+        return self._applications
+
+    @applications.setter
+    def applications(self, applications):
+        """Sets the applications of this AttachedPolicyDefinitionResponse.
+
+
+        :param applications: The applications of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :type: list[str]
+        """
+
+        self._applications = applications
+
+    @property
+    def policy_type(self):
+        """Gets the policy_type of this AttachedPolicyDefinitionResponse.  # noqa: E501
+
+
+        :return: The policy_type of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :rtype: PolicyType
+        """
+        return self._policy_type
+
+    @policy_type.setter
+    def policy_type(self, policy_type):
+        """Sets the policy_type of this AttachedPolicyDefinitionResponse.
+
+
+        :param policy_type: The policy_type of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :type: PolicyType
+        """
+
+        self._policy_type = policy_type
+
+    @property
+    def id(self):
+        """Gets the id of this AttachedPolicyDefinitionResponse.  # noqa: E501
+
+
+        :return: The id of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :rtype: PolicyId
+        """
+        return self._id
+
+    @id.setter
+    def id(self, id):
+        """Sets the id of this AttachedPolicyDefinitionResponse.
+
+
+        :param id: The id of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :type: PolicyId
+        """
+
+        self._id = id
+
+    @property
+    def grant(self):
+        """Gets the grant of this AttachedPolicyDefinitionResponse.  # noqa: E501
+
+
+        :return: The grant of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :rtype: Grant
+        """
+        return self._grant
+
+    @grant.setter
+    def grant(self, grant):
+        """Sets the grant of this AttachedPolicyDefinitionResponse.
+
+
+        :param grant: The grant of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :type: Grant
+        """
+
+        self._grant = grant
+
+    @property
+    def selectors(self):
+        """Gets the selectors of this AttachedPolicyDefinitionResponse.  # noqa: E501
+
+
+        :return: The selectors of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :rtype: list[SelectorDefinition]
+        """
+        return self._selectors
+
+    @selectors.setter
+    def selectors(self, selectors):
+        """Sets the selectors of this AttachedPolicyDefinitionResponse.
+
+
+        :param selectors: The selectors of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :type: list[SelectorDefinition]
+        """
+
+        self._selectors = selectors
+
+    @property
+    def _for(self):
+        """Gets the _for of this AttachedPolicyDefinitionResponse.  # noqa: E501
+
+
+        :return: The _for of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :rtype: list[ForSpec]
+        """
+        return self.__for
+
+    @_for.setter
+    def _for(self, _for):
+        """Sets the _for of this AttachedPolicyDefinitionResponse.
+
+
+        :param _for: The _for of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :type: list[ForSpec]
+        """
+
+        self.__for = _for
+
+    @property
+    def _if(self):
+        """Gets the _if of this AttachedPolicyDefinitionResponse.  # noqa: E501
+
+
+        :return: The _if of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :rtype: list[IfExpression]
+        """
+        return self.__if
+
+    @_if.setter
+    def _if(self, _if):
+        """Sets the _if of this AttachedPolicyDefinitionResponse.
+
+
+        :param _if: The _if of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :type: list[IfExpression]
+        """
+
+        self.__if = _if
+
+    @property
+    def when(self):
+        """Gets the when of this AttachedPolicyDefinitionResponse.  # noqa: E501
+
+
+        :return: The when of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :rtype: WhenSpec
+        """
+        return self._when
+
+    @when.setter
+    def when(self, when):
+        """Sets the when of this AttachedPolicyDefinitionResponse.
+
+
+        :param when: The when of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :type: WhenSpec
+        """
+
+        self._when = when
+
+    @property
+    def how(self):
+        """Gets the how of this AttachedPolicyDefinitionResponse.  # noqa: E501
+
+
+        :return: The how of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :rtype: HowSpec
+        """
+        return self._how
+
+    @how.setter
+    def how(self, how):
+        """Sets the how of this AttachedPolicyDefinitionResponse.
+
+
+        :param how: The how of this AttachedPolicyDefinitionResponse.  # noqa: E501
+        :type: HowSpec
+        """
+
+        self._how = how
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, AttachedPolicyDefinitionResponse):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/date_quality.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/date_quality.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,109 +1,109 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class DateQuality(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    allowed enum values
-    """
-    UNDEFINED = "Undefined"
-    ISFIRSTDAYOFANYMONTH = "IsFirstDayOfAnyMonth"
-    ISLASTDAYOFANYMONTH = "IsLastDayOfAnyMonth"
-    ISBUSINESSDAYOFANYMONTH = "IsBusinessDayOfAnyMonth"
-    ISFIRSTDAYOFTHECURRENTMONTH = "IsFirstDayOfTheCurrentMonth"
-    ISLASTDAYOFTHECURRENTMONTH = "IsLastDayOfTheCurrentMonth"
-    ISBUSINESSDAYOFTHECURRENTMONTH = "IsBusinessDayOfTheCurrentMonth"
-    ISBEFOREMIDDAY = "IsBeforeMidday"
-    ISBEFORE5PM = "IsBefore5pm"
-    ISAFTER5PM = "IsAfter5pm"
-
-    allowable_values = [UNDEFINED, ISFIRSTDAYOFANYMONTH, ISLASTDAYOFANYMONTH, ISBUSINESSDAYOFANYMONTH, ISFIRSTDAYOFTHECURRENTMONTH, ISLASTDAYOFTHECURRENTMONTH, ISBUSINESSDAYOFTHECURRENTMONTH, ISBEFOREMIDDAY, ISBEFORE5PM, ISAFTER5PM]  # noqa: E501
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-    }
-
-    attribute_map = {
-    }
-
-    required_map = {
-    }
-
-    def __init__(self):  # noqa: E501
-        """
-        DateQuality - a model defined in OpenAPI
-
-
-        """  # noqa: E501
-        self.discriminator = None
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, DateQuality):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class DateQuality(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    allowed enum values
+    """
+    UNDEFINED = "Undefined"
+    ISFIRSTDAYOFANYMONTH = "IsFirstDayOfAnyMonth"
+    ISLASTDAYOFANYMONTH = "IsLastDayOfAnyMonth"
+    ISBUSINESSDAYOFANYMONTH = "IsBusinessDayOfAnyMonth"
+    ISFIRSTDAYOFTHECURRENTMONTH = "IsFirstDayOfTheCurrentMonth"
+    ISLASTDAYOFTHECURRENTMONTH = "IsLastDayOfTheCurrentMonth"
+    ISBUSINESSDAYOFTHECURRENTMONTH = "IsBusinessDayOfTheCurrentMonth"
+    ISBEFOREMIDDAY = "IsBeforeMidday"
+    ISBEFORE5PM = "IsBefore5pm"
+    ISAFTER5PM = "IsAfter5pm"
+
+    allowable_values = [UNDEFINED, ISFIRSTDAYOFANYMONTH, ISLASTDAYOFANYMONTH, ISBUSINESSDAYOFANYMONTH, ISFIRSTDAYOFTHECURRENTMONTH, ISLASTDAYOFTHECURRENTMONTH, ISBUSINESSDAYOFTHECURRENTMONTH, ISBEFOREMIDDAY, ISBEFORE5PM, ISAFTER5PM]  # noqa: E501
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+    }
+
+    attribute_map = {
+    }
+
+    required_map = {
+    }
+
+    def __init__(self):  # noqa: E501
+        """
+        DateQuality - a model defined in OpenAPI
+
+
+        """  # noqa: E501
+        self.discriminator = None
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, DateQuality):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/date_unit.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/point_in_time_specification.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,107 +1,107 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class DateUnit(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    allowed enum values
-    """
-    UNDEFINED = "Undefined"
-    MINUTE = "Minute"
-    HOUR = "Hour"
-    DAY = "Day"
-    BUSINESSDAY = "BusinessDay"
-    WEEKS = "Weeks"
-    MONTHS = "Months"
-    YEARS = "Years"
-
-    allowable_values = [UNDEFINED, MINUTE, HOUR, DAY, BUSINESSDAY, WEEKS, MONTHS, YEARS]  # noqa: E501
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-    }
-
-    attribute_map = {
-    }
-
-    required_map = {
-    }
-
-    def __init__(self):  # noqa: E501
-        """
-        DateUnit - a model defined in OpenAPI
-
-
-        """  # noqa: E501
-        self.discriminator = None
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, DateUnit):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class PointInTimeSpecification(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    allowed enum values
+    """
+    UNDEFINED = "Undefined"
+    NOW = "Now"
+    FIRSTOFMONTH = "FirstOfMonth"
+    FIRSTBUSINESSDAYOFTHEMONTH = "FirstBusinessDayOfTheMonth"
+    LASTDAYOFTHEMONTH = "LastDayOfTheMonth"
+    LASTBUSINESSDAYOFMONTH = "LastBusinessDayOfMonth"
+    FIRSTDAYOFYEAR = "FirstDayOfYear"
+    LASTDAYOFYEAR = "LastDayOfYear"
+
+    allowable_values = [UNDEFINED, NOW, FIRSTOFMONTH, FIRSTBUSINESSDAYOFTHEMONTH, LASTDAYOFTHEMONTH, LASTBUSINESSDAYOFMONTH, FIRSTDAYOFYEAR, LASTDAYOFYEAR]  # noqa: E501
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+    }
+
+    attribute_map = {
+    }
+
+    required_map = {
+    }
+
+    def __init__(self):  # noqa: E501
+        """
+        PointInTimeSpecification - a model defined in OpenAPI
+
+
+        """  # noqa: E501
+        self.discriminator = None
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, PointInTimeSpecification):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/effective_date_has_quality.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/effective_date_has_quality.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,124 +1,124 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class EffectiveDateHasQuality(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'quality': 'DateQuality'
-    }
-
-    attribute_map = {
-        'quality': 'quality'
-    }
-
-    required_map = {
-        'quality': 'optional'
-    }
-
-    def __init__(self, quality=None):  # noqa: E501
-        """
-        EffectiveDateHasQuality - a model defined in OpenAPI
-
-        :param quality: 
-        :type quality: finbourne_access.DateQuality
-
-        """  # noqa: E501
-
-        self._quality = None
-        self.discriminator = None
-
-        if quality is not None:
-            self.quality = quality
-
-    @property
-    def quality(self):
-        """Gets the quality of this EffectiveDateHasQuality.  # noqa: E501
-
-
-        :return: The quality of this EffectiveDateHasQuality.  # noqa: E501
-        :rtype: DateQuality
-        """
-        return self._quality
-
-    @quality.setter
-    def quality(self, quality):
-        """Sets the quality of this EffectiveDateHasQuality.
-
-
-        :param quality: The quality of this EffectiveDateHasQuality.  # noqa: E501
-        :type: DateQuality
-        """
-
-        self._quality = quality
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, EffectiveDateHasQuality):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class EffectiveDateHasQuality(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'quality': 'DateQuality'
+    }
+
+    attribute_map = {
+        'quality': 'quality'
+    }
+
+    required_map = {
+        'quality': 'optional'
+    }
+
+    def __init__(self, quality=None):  # noqa: E501
+        """
+        EffectiveDateHasQuality - a model defined in OpenAPI
+
+        :param quality: 
+        :type quality: finbourne_access.DateQuality
+
+        """  # noqa: E501
+
+        self._quality = None
+        self.discriminator = None
+
+        if quality is not None:
+            self.quality = quality
+
+    @property
+    def quality(self):
+        """Gets the quality of this EffectiveDateHasQuality.  # noqa: E501
+
+
+        :return: The quality of this EffectiveDateHasQuality.  # noqa: E501
+        :rtype: DateQuality
+        """
+        return self._quality
+
+    @quality.setter
+    def quality(self, quality):
+        """Sets the quality of this EffectiveDateHasQuality.
+
+
+        :param quality: The quality of this EffectiveDateHasQuality.  # noqa: E501
+        :type: DateQuality
+        """
+
+        self._quality = quality
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, EffectiveDateHasQuality):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/effective_range.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/effective_range.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,152 +1,152 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class EffectiveRange(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        '_from': 'datetime',
-        'to': 'datetime'
-    }
-
-    attribute_map = {
-        '_from': 'from',
-        'to': 'to'
-    }
-
-    required_map = {
-        '_from': 'optional',
-        'to': 'optional'
-    }
-
-    def __init__(self, _from=None, to=None):  # noqa: E501
-        """
-        EffectiveRange - a model defined in OpenAPI
-
-        :param _from: 
-        :type _from: datetime
-        :param to: 
-        :type to: datetime
-
-        """  # noqa: E501
-
-        self.__from = None
-        self._to = None
-        self.discriminator = None
-
-        if _from is not None:
-            self._from = _from
-        self.to = to
-
-    @property
-    def _from(self):
-        """Gets the _from of this EffectiveRange.  # noqa: E501
-
-
-        :return: The _from of this EffectiveRange.  # noqa: E501
-        :rtype: datetime
-        """
-        return self.__from
-
-    @_from.setter
-    def _from(self, _from):
-        """Sets the _from of this EffectiveRange.
-
-
-        :param _from: The _from of this EffectiveRange.  # noqa: E501
-        :type: datetime
-        """
-
-        self.__from = _from
-
-    @property
-    def to(self):
-        """Gets the to of this EffectiveRange.  # noqa: E501
-
-
-        :return: The to of this EffectiveRange.  # noqa: E501
-        :rtype: datetime
-        """
-        return self._to
-
-    @to.setter
-    def to(self, to):
-        """Sets the to of this EffectiveRange.
-
-
-        :param to: The to of this EffectiveRange.  # noqa: E501
-        :type: datetime
-        """
-
-        self._to = to
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, EffectiveRange):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class EffectiveRange(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        '_from': 'datetime',
+        'to': 'datetime'
+    }
+
+    attribute_map = {
+        '_from': 'from',
+        'to': 'to'
+    }
+
+    required_map = {
+        '_from': 'optional',
+        'to': 'optional'
+    }
+
+    def __init__(self, _from=None, to=None):  # noqa: E501
+        """
+        EffectiveRange - a model defined in OpenAPI
+
+        :param _from: 
+        :type _from: datetime
+        :param to: 
+        :type to: datetime
+
+        """  # noqa: E501
+
+        self.__from = None
+        self._to = None
+        self.discriminator = None
+
+        if _from is not None:
+            self._from = _from
+        self.to = to
+
+    @property
+    def _from(self):
+        """Gets the _from of this EffectiveRange.  # noqa: E501
+
+
+        :return: The _from of this EffectiveRange.  # noqa: E501
+        :rtype: datetime
+        """
+        return self.__from
+
+    @_from.setter
+    def _from(self, _from):
+        """Sets the _from of this EffectiveRange.
+
+
+        :param _from: The _from of this EffectiveRange.  # noqa: E501
+        :type: datetime
+        """
+
+        self.__from = _from
+
+    @property
+    def to(self):
+        """Gets the to of this EffectiveRange.  # noqa: E501
+
+
+        :return: The to of this EffectiveRange.  # noqa: E501
+        :rtype: datetime
+        """
+        return self._to
+
+    @to.setter
+    def to(self, to):
+        """Sets the to of this EffectiveRange.
+
+
+        :param to: The to of this EffectiveRange.  # noqa: E501
+        :type: datetime
+        """
+
+        self._to = to
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, EffectiveRange):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/entitlement_metadata.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/entitlement_metadata.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,151 +1,151 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class EntitlementMetadata(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'provider': 'str',
-        'value': 'str'
-    }
-
-    attribute_map = {
-        'provider': 'provider',
-        'value': 'value'
-    }
-
-    required_map = {
-        'provider': 'optional',
-        'value': 'optional'
-    }
-
-    def __init__(self, provider=None, value=None):  # noqa: E501
-        """
-        EntitlementMetadata - a model defined in OpenAPI
-
-        :param provider: 
-        :type provider: str
-        :param value: 
-        :type value: str
-
-        """  # noqa: E501
-
-        self._provider = None
-        self._value = None
-        self.discriminator = None
-
-        self.provider = provider
-        self.value = value
-
-    @property
-    def provider(self):
-        """Gets the provider of this EntitlementMetadata.  # noqa: E501
-
-
-        :return: The provider of this EntitlementMetadata.  # noqa: E501
-        :rtype: str
-        """
-        return self._provider
-
-    @provider.setter
-    def provider(self, provider):
-        """Sets the provider of this EntitlementMetadata.
-
-
-        :param provider: The provider of this EntitlementMetadata.  # noqa: E501
-        :type: str
-        """
-
-        self._provider = provider
-
-    @property
-    def value(self):
-        """Gets the value of this EntitlementMetadata.  # noqa: E501
-
-
-        :return: The value of this EntitlementMetadata.  # noqa: E501
-        :rtype: str
-        """
-        return self._value
-
-    @value.setter
-    def value(self, value):
-        """Sets the value of this EntitlementMetadata.
-
-
-        :param value: The value of this EntitlementMetadata.  # noqa: E501
-        :type: str
-        """
-
-        self._value = value
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, EntitlementMetadata):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class EntitlementMetadata(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'provider': 'str',
+        'value': 'str'
+    }
+
+    attribute_map = {
+        'provider': 'provider',
+        'value': 'value'
+    }
+
+    required_map = {
+        'provider': 'optional',
+        'value': 'optional'
+    }
+
+    def __init__(self, provider=None, value=None):  # noqa: E501
+        """
+        EntitlementMetadata - a model defined in OpenAPI
+
+        :param provider: 
+        :type provider: str
+        :param value: 
+        :type value: str
+
+        """  # noqa: E501
+
+        self._provider = None
+        self._value = None
+        self.discriminator = None
+
+        self.provider = provider
+        self.value = value
+
+    @property
+    def provider(self):
+        """Gets the provider of this EntitlementMetadata.  # noqa: E501
+
+
+        :return: The provider of this EntitlementMetadata.  # noqa: E501
+        :rtype: str
+        """
+        return self._provider
+
+    @provider.setter
+    def provider(self, provider):
+        """Sets the provider of this EntitlementMetadata.
+
+
+        :param provider: The provider of this EntitlementMetadata.  # noqa: E501
+        :type: str
+        """
+
+        self._provider = provider
+
+    @property
+    def value(self):
+        """Gets the value of this EntitlementMetadata.  # noqa: E501
+
+
+        :return: The value of this EntitlementMetadata.  # noqa: E501
+        :rtype: str
+        """
+        return self._value
+
+    @value.setter
+    def value(self, value):
+        """Sets the value of this EntitlementMetadata.
+
+
+        :param value: The value of this EntitlementMetadata.  # noqa: E501
+        :type: str
+        """
+
+        self._value = value
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, EntitlementMetadata):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/evaluation_response.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/evaluation_response.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,155 +1,155 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class EvaluationResponse(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'result': 'EvaluationResult',
-        'detailed_message': 'str'
-    }
-
-    attribute_map = {
-        'result': 'result',
-        'detailed_message': 'detailedMessage'
-    }
-
-    required_map = {
-        'result': 'required',
-        'detailed_message': 'optional'
-    }
-
-    def __init__(self, result=None, detailed_message=None):  # noqa: E501
-        """
-        EvaluationResponse - a model defined in OpenAPI
-
-        :param result:  (required)
-        :type result: finbourne_access.EvaluationResult
-        :param detailed_message:  In the case of the evaluation being denied a message may be returned
-        :type detailed_message: str
-
-        """  # noqa: E501
-
-        self._result = None
-        self._detailed_message = None
-        self.discriminator = None
-
-        self.result = result
-        self.detailed_message = detailed_message
-
-    @property
-    def result(self):
-        """Gets the result of this EvaluationResponse.  # noqa: E501
-
-
-        :return: The result of this EvaluationResponse.  # noqa: E501
-        :rtype: EvaluationResult
-        """
-        return self._result
-
-    @result.setter
-    def result(self, result):
-        """Sets the result of this EvaluationResponse.
-
-
-        :param result: The result of this EvaluationResponse.  # noqa: E501
-        :type: EvaluationResult
-        """
-        if result is None:
-            raise ValueError("Invalid value for `result`, must not be `None`")  # noqa: E501
-
-        self._result = result
-
-    @property
-    def detailed_message(self):
-        """Gets the detailed_message of this EvaluationResponse.  # noqa: E501
-
-        In the case of the evaluation being denied a message may be returned  # noqa: E501
-
-        :return: The detailed_message of this EvaluationResponse.  # noqa: E501
-        :rtype: str
-        """
-        return self._detailed_message
-
-    @detailed_message.setter
-    def detailed_message(self, detailed_message):
-        """Sets the detailed_message of this EvaluationResponse.
-
-        In the case of the evaluation being denied a message may be returned  # noqa: E501
-
-        :param detailed_message: The detailed_message of this EvaluationResponse.  # noqa: E501
-        :type: str
-        """
-
-        self._detailed_message = detailed_message
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, EvaluationResponse):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class EvaluationResponse(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'result': 'EvaluationResult',
+        'detailed_message': 'str'
+    }
+
+    attribute_map = {
+        'result': 'result',
+        'detailed_message': 'detailedMessage'
+    }
+
+    required_map = {
+        'result': 'required',
+        'detailed_message': 'optional'
+    }
+
+    def __init__(self, result=None, detailed_message=None):  # noqa: E501
+        """
+        EvaluationResponse - a model defined in OpenAPI
+
+        :param result:  (required)
+        :type result: finbourne_access.EvaluationResult
+        :param detailed_message:  In the case of the evaluation being denied a message may be returned
+        :type detailed_message: str
+
+        """  # noqa: E501
+
+        self._result = None
+        self._detailed_message = None
+        self.discriminator = None
+
+        self.result = result
+        self.detailed_message = detailed_message
+
+    @property
+    def result(self):
+        """Gets the result of this EvaluationResponse.  # noqa: E501
+
+
+        :return: The result of this EvaluationResponse.  # noqa: E501
+        :rtype: EvaluationResult
+        """
+        return self._result
+
+    @result.setter
+    def result(self, result):
+        """Sets the result of this EvaluationResponse.
+
+
+        :param result: The result of this EvaluationResponse.  # noqa: E501
+        :type: EvaluationResult
+        """
+        if result is None:
+            raise ValueError("Invalid value for `result`, must not be `None`")  # noqa: E501
+
+        self._result = result
+
+    @property
+    def detailed_message(self):
+        """Gets the detailed_message of this EvaluationResponse.  # noqa: E501
+
+        In the case of the evaluation being denied a message may be returned  # noqa: E501
+
+        :return: The detailed_message of this EvaluationResponse.  # noqa: E501
+        :rtype: str
+        """
+        return self._detailed_message
+
+    @detailed_message.setter
+    def detailed_message(self, detailed_message):
+        """Sets the detailed_message of this EvaluationResponse.
+
+        In the case of the evaluation being denied a message may be returned  # noqa: E501
+
+        :param detailed_message: The detailed_message of this EvaluationResponse.  # noqa: E501
+        :type: str
+        """
+
+        self._detailed_message = detailed_message
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, EvaluationResponse):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/for_spec.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/for_spec.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,240 +1,240 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class ForSpec(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'as_at_range_for_spec': 'AsAtRangeForSpec',
-        'as_at_relative': 'AsAtRelative',
-        'effective_date_has_quality': 'EffectiveDateHasQuality',
-        'effective_date_relative': 'EffectiveDateRelative',
-        'effective_range': 'EffectiveRange'
-    }
-
-    attribute_map = {
-        'as_at_range_for_spec': 'asAtRangeForSpec',
-        'as_at_relative': 'asAtRelative',
-        'effective_date_has_quality': 'effectiveDateHasQuality',
-        'effective_date_relative': 'effectiveDateRelative',
-        'effective_range': 'effectiveRange'
-    }
-
-    required_map = {
-        'as_at_range_for_spec': 'optional',
-        'as_at_relative': 'optional',
-        'effective_date_has_quality': 'optional',
-        'effective_date_relative': 'optional',
-        'effective_range': 'optional'
-    }
-
-    def __init__(self, as_at_range_for_spec=None, as_at_relative=None, effective_date_has_quality=None, effective_date_relative=None, effective_range=None):  # noqa: E501
-        """
-        ForSpec - a model defined in OpenAPI
-
-        :param as_at_range_for_spec: 
-        :type as_at_range_for_spec: finbourne_access.AsAtRangeForSpec
-        :param as_at_relative: 
-        :type as_at_relative: finbourne_access.AsAtRelative
-        :param effective_date_has_quality: 
-        :type effective_date_has_quality: finbourne_access.EffectiveDateHasQuality
-        :param effective_date_relative: 
-        :type effective_date_relative: finbourne_access.EffectiveDateRelative
-        :param effective_range: 
-        :type effective_range: finbourne_access.EffectiveRange
-
-        """  # noqa: E501
-
-        self._as_at_range_for_spec = None
-        self._as_at_relative = None
-        self._effective_date_has_quality = None
-        self._effective_date_relative = None
-        self._effective_range = None
-        self.discriminator = None
-
-        if as_at_range_for_spec is not None:
-            self.as_at_range_for_spec = as_at_range_for_spec
-        if as_at_relative is not None:
-            self.as_at_relative = as_at_relative
-        if effective_date_has_quality is not None:
-            self.effective_date_has_quality = effective_date_has_quality
-        if effective_date_relative is not None:
-            self.effective_date_relative = effective_date_relative
-        if effective_range is not None:
-            self.effective_range = effective_range
-
-    @property
-    def as_at_range_for_spec(self):
-        """Gets the as_at_range_for_spec of this ForSpec.  # noqa: E501
-
-
-        :return: The as_at_range_for_spec of this ForSpec.  # noqa: E501
-        :rtype: AsAtRangeForSpec
-        """
-        return self._as_at_range_for_spec
-
-    @as_at_range_for_spec.setter
-    def as_at_range_for_spec(self, as_at_range_for_spec):
-        """Sets the as_at_range_for_spec of this ForSpec.
-
-
-        :param as_at_range_for_spec: The as_at_range_for_spec of this ForSpec.  # noqa: E501
-        :type: AsAtRangeForSpec
-        """
-
-        self._as_at_range_for_spec = as_at_range_for_spec
-
-    @property
-    def as_at_relative(self):
-        """Gets the as_at_relative of this ForSpec.  # noqa: E501
-
-
-        :return: The as_at_relative of this ForSpec.  # noqa: E501
-        :rtype: AsAtRelative
-        """
-        return self._as_at_relative
-
-    @as_at_relative.setter
-    def as_at_relative(self, as_at_relative):
-        """Sets the as_at_relative of this ForSpec.
-
-
-        :param as_at_relative: The as_at_relative of this ForSpec.  # noqa: E501
-        :type: AsAtRelative
-        """
-
-        self._as_at_relative = as_at_relative
-
-    @property
-    def effective_date_has_quality(self):
-        """Gets the effective_date_has_quality of this ForSpec.  # noqa: E501
-
-
-        :return: The effective_date_has_quality of this ForSpec.  # noqa: E501
-        :rtype: EffectiveDateHasQuality
-        """
-        return self._effective_date_has_quality
-
-    @effective_date_has_quality.setter
-    def effective_date_has_quality(self, effective_date_has_quality):
-        """Sets the effective_date_has_quality of this ForSpec.
-
-
-        :param effective_date_has_quality: The effective_date_has_quality of this ForSpec.  # noqa: E501
-        :type: EffectiveDateHasQuality
-        """
-
-        self._effective_date_has_quality = effective_date_has_quality
-
-    @property
-    def effective_date_relative(self):
-        """Gets the effective_date_relative of this ForSpec.  # noqa: E501
-
-
-        :return: The effective_date_relative of this ForSpec.  # noqa: E501
-        :rtype: EffectiveDateRelative
-        """
-        return self._effective_date_relative
-
-    @effective_date_relative.setter
-    def effective_date_relative(self, effective_date_relative):
-        """Sets the effective_date_relative of this ForSpec.
-
-
-        :param effective_date_relative: The effective_date_relative of this ForSpec.  # noqa: E501
-        :type: EffectiveDateRelative
-        """
-
-        self._effective_date_relative = effective_date_relative
-
-    @property
-    def effective_range(self):
-        """Gets the effective_range of this ForSpec.  # noqa: E501
-
-
-        :return: The effective_range of this ForSpec.  # noqa: E501
-        :rtype: EffectiveRange
-        """
-        return self._effective_range
-
-    @effective_range.setter
-    def effective_range(self, effective_range):
-        """Sets the effective_range of this ForSpec.
-
-
-        :param effective_range: The effective_range of this ForSpec.  # noqa: E501
-        :type: EffectiveRange
-        """
-
-        self._effective_range = effective_range
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, ForSpec):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class ForSpec(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'as_at_range_for_spec': 'AsAtRangeForSpec',
+        'as_at_relative': 'AsAtRelative',
+        'effective_date_has_quality': 'EffectiveDateHasQuality',
+        'effective_date_relative': 'EffectiveDateRelative',
+        'effective_range': 'EffectiveRange'
+    }
+
+    attribute_map = {
+        'as_at_range_for_spec': 'asAtRangeForSpec',
+        'as_at_relative': 'asAtRelative',
+        'effective_date_has_quality': 'effectiveDateHasQuality',
+        'effective_date_relative': 'effectiveDateRelative',
+        'effective_range': 'effectiveRange'
+    }
+
+    required_map = {
+        'as_at_range_for_spec': 'optional',
+        'as_at_relative': 'optional',
+        'effective_date_has_quality': 'optional',
+        'effective_date_relative': 'optional',
+        'effective_range': 'optional'
+    }
+
+    def __init__(self, as_at_range_for_spec=None, as_at_relative=None, effective_date_has_quality=None, effective_date_relative=None, effective_range=None):  # noqa: E501
+        """
+        ForSpec - a model defined in OpenAPI
+
+        :param as_at_range_for_spec: 
+        :type as_at_range_for_spec: finbourne_access.AsAtRangeForSpec
+        :param as_at_relative: 
+        :type as_at_relative: finbourne_access.AsAtRelative
+        :param effective_date_has_quality: 
+        :type effective_date_has_quality: finbourne_access.EffectiveDateHasQuality
+        :param effective_date_relative: 
+        :type effective_date_relative: finbourne_access.EffectiveDateRelative
+        :param effective_range: 
+        :type effective_range: finbourne_access.EffectiveRange
+
+        """  # noqa: E501
+
+        self._as_at_range_for_spec = None
+        self._as_at_relative = None
+        self._effective_date_has_quality = None
+        self._effective_date_relative = None
+        self._effective_range = None
+        self.discriminator = None
+
+        if as_at_range_for_spec is not None:
+            self.as_at_range_for_spec = as_at_range_for_spec
+        if as_at_relative is not None:
+            self.as_at_relative = as_at_relative
+        if effective_date_has_quality is not None:
+            self.effective_date_has_quality = effective_date_has_quality
+        if effective_date_relative is not None:
+            self.effective_date_relative = effective_date_relative
+        if effective_range is not None:
+            self.effective_range = effective_range
+
+    @property
+    def as_at_range_for_spec(self):
+        """Gets the as_at_range_for_spec of this ForSpec.  # noqa: E501
+
+
+        :return: The as_at_range_for_spec of this ForSpec.  # noqa: E501
+        :rtype: AsAtRangeForSpec
+        """
+        return self._as_at_range_for_spec
+
+    @as_at_range_for_spec.setter
+    def as_at_range_for_spec(self, as_at_range_for_spec):
+        """Sets the as_at_range_for_spec of this ForSpec.
+
+
+        :param as_at_range_for_spec: The as_at_range_for_spec of this ForSpec.  # noqa: E501
+        :type: AsAtRangeForSpec
+        """
+
+        self._as_at_range_for_spec = as_at_range_for_spec
+
+    @property
+    def as_at_relative(self):
+        """Gets the as_at_relative of this ForSpec.  # noqa: E501
+
+
+        :return: The as_at_relative of this ForSpec.  # noqa: E501
+        :rtype: AsAtRelative
+        """
+        return self._as_at_relative
+
+    @as_at_relative.setter
+    def as_at_relative(self, as_at_relative):
+        """Sets the as_at_relative of this ForSpec.
+
+
+        :param as_at_relative: The as_at_relative of this ForSpec.  # noqa: E501
+        :type: AsAtRelative
+        """
+
+        self._as_at_relative = as_at_relative
+
+    @property
+    def effective_date_has_quality(self):
+        """Gets the effective_date_has_quality of this ForSpec.  # noqa: E501
+
+
+        :return: The effective_date_has_quality of this ForSpec.  # noqa: E501
+        :rtype: EffectiveDateHasQuality
+        """
+        return self._effective_date_has_quality
+
+    @effective_date_has_quality.setter
+    def effective_date_has_quality(self, effective_date_has_quality):
+        """Sets the effective_date_has_quality of this ForSpec.
+
+
+        :param effective_date_has_quality: The effective_date_has_quality of this ForSpec.  # noqa: E501
+        :type: EffectiveDateHasQuality
+        """
+
+        self._effective_date_has_quality = effective_date_has_quality
+
+    @property
+    def effective_date_relative(self):
+        """Gets the effective_date_relative of this ForSpec.  # noqa: E501
+
+
+        :return: The effective_date_relative of this ForSpec.  # noqa: E501
+        :rtype: EffectiveDateRelative
+        """
+        return self._effective_date_relative
+
+    @effective_date_relative.setter
+    def effective_date_relative(self, effective_date_relative):
+        """Sets the effective_date_relative of this ForSpec.
+
+
+        :param effective_date_relative: The effective_date_relative of this ForSpec.  # noqa: E501
+        :type: EffectiveDateRelative
+        """
+
+        self._effective_date_relative = effective_date_relative
+
+    @property
+    def effective_range(self):
+        """Gets the effective_range of this ForSpec.  # noqa: E501
+
+
+        :return: The effective_range of this ForSpec.  # noqa: E501
+        :rtype: EffectiveRange
+        """
+        return self._effective_range
+
+    @effective_range.setter
+    def effective_range(self, effective_range):
+        """Sets the effective_range of this ForSpec.
+
+
+        :param effective_range: The effective_range of this ForSpec.  # noqa: E501
+        :type: EffectiveRange
+        """
+
+        self._effective_range = effective_range
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, ForSpec):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/grant.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/policy_type.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,102 +1,102 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class Grant(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    allowed enum values
-    """
-    UNDEFINED = "Undefined"
-    ALLOW = "Allow"
-    DENY = "Deny"
-
-    allowable_values = [UNDEFINED, ALLOW, DENY]  # noqa: E501
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-    }
-
-    attribute_map = {
-    }
-
-    required_map = {
-    }
-
-    def __init__(self):  # noqa: E501
-        """
-        Grant - a model defined in OpenAPI
-
-
-        """  # noqa: E501
-        self.discriminator = None
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, Grant):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class PolicyType(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    allowed enum values
+    """
+    UNDEFINED = "Undefined"
+    ENTITLEMENT = "Entitlement"
+    LICENCE = "Licence"
+
+    allowable_values = [UNDEFINED, ENTITLEMENT, LICENCE]  # noqa: E501
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+    }
+
+    attribute_map = {
+    }
+
+    required_map = {
+    }
+
+    def __init__(self):  # noqa: E501
+        """
+        PolicyType - a model defined in OpenAPI
+
+
+        """  # noqa: E501
+        self.discriminator = None
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, PolicyType):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/how_spec.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/how_spec.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,151 +1,151 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class HowSpec(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'type': 'str',
-        'parameters': 'list[KeyValuePairOfStringToString]'
-    }
-
-    attribute_map = {
-        'type': 'type',
-        'parameters': 'parameters'
-    }
-
-    required_map = {
-        'type': 'optional',
-        'parameters': 'optional'
-    }
-
-    def __init__(self, type=None, parameters=None):  # noqa: E501
-        """
-        HowSpec - a model defined in OpenAPI
-
-        :param type: 
-        :type type: str
-        :param parameters: 
-        :type parameters: list[finbourne_access.KeyValuePairOfStringToString]
-
-        """  # noqa: E501
-
-        self._type = None
-        self._parameters = None
-        self.discriminator = None
-
-        self.type = type
-        self.parameters = parameters
-
-    @property
-    def type(self):
-        """Gets the type of this HowSpec.  # noqa: E501
-
-
-        :return: The type of this HowSpec.  # noqa: E501
-        :rtype: str
-        """
-        return self._type
-
-    @type.setter
-    def type(self, type):
-        """Sets the type of this HowSpec.
-
-
-        :param type: The type of this HowSpec.  # noqa: E501
-        :type: str
-        """
-
-        self._type = type
-
-    @property
-    def parameters(self):
-        """Gets the parameters of this HowSpec.  # noqa: E501
-
-
-        :return: The parameters of this HowSpec.  # noqa: E501
-        :rtype: list[KeyValuePairOfStringToString]
-        """
-        return self._parameters
-
-    @parameters.setter
-    def parameters(self, parameters):
-        """Sets the parameters of this HowSpec.
-
-
-        :param parameters: The parameters of this HowSpec.  # noqa: E501
-        :type: list[KeyValuePairOfStringToString]
-        """
-
-        self._parameters = parameters
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, HowSpec):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class HowSpec(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'type': 'str',
+        'parameters': 'list[KeyValuePairOfStringToString]'
+    }
+
+    attribute_map = {
+        'type': 'type',
+        'parameters': 'parameters'
+    }
+
+    required_map = {
+        'type': 'optional',
+        'parameters': 'optional'
+    }
+
+    def __init__(self, type=None, parameters=None):  # noqa: E501
+        """
+        HowSpec - a model defined in OpenAPI
+
+        :param type: 
+        :type type: str
+        :param parameters: 
+        :type parameters: list[finbourne_access.KeyValuePairOfStringToString]
+
+        """  # noqa: E501
+
+        self._type = None
+        self._parameters = None
+        self.discriminator = None
+
+        self.type = type
+        self.parameters = parameters
+
+    @property
+    def type(self):
+        """Gets the type of this HowSpec.  # noqa: E501
+
+
+        :return: The type of this HowSpec.  # noqa: E501
+        :rtype: str
+        """
+        return self._type
+
+    @type.setter
+    def type(self, type):
+        """Sets the type of this HowSpec.
+
+
+        :param type: The type of this HowSpec.  # noqa: E501
+        :type: str
+        """
+
+        self._type = type
+
+    @property
+    def parameters(self):
+        """Gets the parameters of this HowSpec.  # noqa: E501
+
+
+        :return: The parameters of this HowSpec.  # noqa: E501
+        :rtype: list[KeyValuePairOfStringToString]
+        """
+        return self._parameters
+
+    @parameters.setter
+    def parameters(self, parameters):
+        """Sets the parameters of this HowSpec.
+
+
+        :param parameters: The parameters of this HowSpec.  # noqa: E501
+        :type: list[KeyValuePairOfStringToString]
+        """
+
+        self._parameters = parameters
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, HowSpec):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/id_selector_definition.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/id_selector_definition.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,207 +1,219 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class IdSelectorDefinition(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'identifier': 'dict(str, str)',
-        'actions': 'list[ActionId]',
-        'name': 'str',
-        'description': 'str'
-    }
-
-    attribute_map = {
-        'identifier': 'identifier',
-        'actions': 'actions',
-        'name': 'name',
-        'description': 'description'
-    }
-
-    required_map = {
-        'identifier': 'optional',
-        'actions': 'optional',
-        'name': 'optional',
-        'description': 'optional'
-    }
-
-    def __init__(self, identifier=None, actions=None, name=None, description=None):  # noqa: E501
-        """
-        IdSelectorDefinition - a model defined in OpenAPI
-
-        :param identifier: 
-        :type identifier: dict(str, str)
-        :param actions: 
-        :type actions: list[finbourne_access.ActionId]
-        :param name: 
-        :type name: str
-        :param description: 
-        :type description: str
-
-        """  # noqa: E501
-
-        self._identifier = None
-        self._actions = None
-        self._name = None
-        self._description = None
-        self.discriminator = None
-
-        self.identifier = identifier
-        self.actions = actions
-        self.name = name
-        self.description = description
-
-    @property
-    def identifier(self):
-        """Gets the identifier of this IdSelectorDefinition.  # noqa: E501
-
-
-        :return: The identifier of this IdSelectorDefinition.  # noqa: E501
-        :rtype: dict(str, str)
-        """
-        return self._identifier
-
-    @identifier.setter
-    def identifier(self, identifier):
-        """Sets the identifier of this IdSelectorDefinition.
-
-
-        :param identifier: The identifier of this IdSelectorDefinition.  # noqa: E501
-        :type: dict(str, str)
-        """
-
-        self._identifier = identifier
-
-    @property
-    def actions(self):
-        """Gets the actions of this IdSelectorDefinition.  # noqa: E501
-
-
-        :return: The actions of this IdSelectorDefinition.  # noqa: E501
-        :rtype: list[ActionId]
-        """
-        return self._actions
-
-    @actions.setter
-    def actions(self, actions):
-        """Sets the actions of this IdSelectorDefinition.
-
-
-        :param actions: The actions of this IdSelectorDefinition.  # noqa: E501
-        :type: list[ActionId]
-        """
-
-        self._actions = actions
-
-    @property
-    def name(self):
-        """Gets the name of this IdSelectorDefinition.  # noqa: E501
-
-
-        :return: The name of this IdSelectorDefinition.  # noqa: E501
-        :rtype: str
-        """
-        return self._name
-
-    @name.setter
-    def name(self, name):
-        """Sets the name of this IdSelectorDefinition.
-
-
-        :param name: The name of this IdSelectorDefinition.  # noqa: E501
-        :type: str
-        """
-
-        self._name = name
-
-    @property
-    def description(self):
-        """Gets the description of this IdSelectorDefinition.  # noqa: E501
-
-
-        :return: The description of this IdSelectorDefinition.  # noqa: E501
-        :rtype: str
-        """
-        return self._description
-
-    @description.setter
-    def description(self, description):
-        """Sets the description of this IdSelectorDefinition.
-
-
-        :param description: The description of this IdSelectorDefinition.  # noqa: E501
-        :type: str
-        """
-
-        self._description = description
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, IdSelectorDefinition):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class IdSelectorDefinition(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'identifier': 'dict(str, str)',
+        'actions': 'list[ActionId]',
+        'name': 'str',
+        'description': 'str'
+    }
+
+    attribute_map = {
+        'identifier': 'identifier',
+        'actions': 'actions',
+        'name': 'name',
+        'description': 'description'
+    }
+
+    required_map = {
+        'identifier': 'required',
+        'actions': 'required',
+        'name': 'optional',
+        'description': 'optional'
+    }
+
+    def __init__(self, identifier=None, actions=None, name=None, description=None):  # noqa: E501
+        """
+        IdSelectorDefinition - a model defined in OpenAPI
+
+        :param identifier:  (required)
+        :type identifier: dict(str, str)
+        :param actions:  (required)
+        :type actions: list[finbourne_access.ActionId]
+        :param name: 
+        :type name: str
+        :param description: 
+        :type description: str
+
+        """  # noqa: E501
+
+        self._identifier = None
+        self._actions = None
+        self._name = None
+        self._description = None
+        self.discriminator = None
+
+        self.identifier = identifier
+        self.actions = actions
+        self.name = name
+        self.description = description
+
+    @property
+    def identifier(self):
+        """Gets the identifier of this IdSelectorDefinition.  # noqa: E501
+
+
+        :return: The identifier of this IdSelectorDefinition.  # noqa: E501
+        :rtype: dict(str, str)
+        """
+        return self._identifier
+
+    @identifier.setter
+    def identifier(self, identifier):
+        """Sets the identifier of this IdSelectorDefinition.
+
+
+        :param identifier: The identifier of this IdSelectorDefinition.  # noqa: E501
+        :type: dict(str, str)
+        """
+        if identifier is None:
+            raise ValueError("Invalid value for `identifier`, must not be `None`")  # noqa: E501
+
+        self._identifier = identifier
+
+    @property
+    def actions(self):
+        """Gets the actions of this IdSelectorDefinition.  # noqa: E501
+
+
+        :return: The actions of this IdSelectorDefinition.  # noqa: E501
+        :rtype: list[ActionId]
+        """
+        return self._actions
+
+    @actions.setter
+    def actions(self, actions):
+        """Sets the actions of this IdSelectorDefinition.
+
+
+        :param actions: The actions of this IdSelectorDefinition.  # noqa: E501
+        :type: list[ActionId]
+        """
+        if actions is None:
+            raise ValueError("Invalid value for `actions`, must not be `None`")  # noqa: E501
+
+        self._actions = actions
+
+    @property
+    def name(self):
+        """Gets the name of this IdSelectorDefinition.  # noqa: E501
+
+
+        :return: The name of this IdSelectorDefinition.  # noqa: E501
+        :rtype: str
+        """
+        return self._name
+
+    @name.setter
+    def name(self, name):
+        """Sets the name of this IdSelectorDefinition.
+
+
+        :param name: The name of this IdSelectorDefinition.  # noqa: E501
+        :type: str
+        """
+        if name is not None and len(name) > 100:
+            raise ValueError("Invalid value for `name`, length must be less than or equal to `100`")  # noqa: E501
+        if name is not None and len(name) < 0:
+            raise ValueError("Invalid value for `name`, length must be greater than or equal to `0`")  # noqa: E501
+
+        self._name = name
+
+    @property
+    def description(self):
+        """Gets the description of this IdSelectorDefinition.  # noqa: E501
+
+
+        :return: The description of this IdSelectorDefinition.  # noqa: E501
+        :rtype: str
+        """
+        return self._description
+
+    @description.setter
+    def description(self, description):
+        """Sets the description of this IdSelectorDefinition.
+
+
+        :param description: The description of this IdSelectorDefinition.  # noqa: E501
+        :type: str
+        """
+        if description is not None and len(description) > 1024:
+            raise ValueError("Invalid value for `description`, length must be less than or equal to `1024`")  # noqa: E501
+        if description is not None and len(description) < 0:
+            raise ValueError("Invalid value for `description`, length must be greater than or equal to `0`")  # noqa: E501
+
+        self._description = description
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, IdSelectorDefinition):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/identifier_part_schema.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/identifier_part_schema.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,283 +1,283 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class IdentifierPartSchema(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'index': 'int',
-        'name': 'str',
-        'display_name': 'str',
-        'description': 'str',
-        'required': 'bool',
-        'links': 'list[Link]'
-    }
-
-    attribute_map = {
-        'index': 'index',
-        'name': 'name',
-        'display_name': 'displayName',
-        'description': 'description',
-        'required': 'required',
-        'links': 'links'
-    }
-
-    required_map = {
-        'index': 'required',
-        'name': 'required',
-        'display_name': 'required',
-        'description': 'required',
-        'required': 'required',
-        'links': 'optional'
-    }
-
-    def __init__(self, index=None, name=None, display_name=None, description=None, required=None, links=None):  # noqa: E501
-        """
-        IdentifierPartSchema - a model defined in OpenAPI
-
-        :param index:  The typical index in the identifier in which this part appears (required)
-        :type index: int
-        :param name:  The name of the identifier part that can/should be provided for this resource type (required)
-        :type name: str
-        :param display_name:  The display name of the identifier part (required)
-        :type display_name: str
-        :param description:  A brief description of the point of this identifier part (required)
-        :type description: str
-        :param required:  Whether a value is required to be provided (required)
-        :type required: bool
-        :param links: 
-        :type links: list[finbourne_access.Link]
-
-        """  # noqa: E501
-
-        self._index = None
-        self._name = None
-        self._display_name = None
-        self._description = None
-        self._required = None
-        self._links = None
-        self.discriminator = None
-
-        self.index = index
-        self.name = name
-        self.display_name = display_name
-        self.description = description
-        self.required = required
-        self.links = links
-
-    @property
-    def index(self):
-        """Gets the index of this IdentifierPartSchema.  # noqa: E501
-
-        The typical index in the identifier in which this part appears  # noqa: E501
-
-        :return: The index of this IdentifierPartSchema.  # noqa: E501
-        :rtype: int
-        """
-        return self._index
-
-    @index.setter
-    def index(self, index):
-        """Sets the index of this IdentifierPartSchema.
-
-        The typical index in the identifier in which this part appears  # noqa: E501
-
-        :param index: The index of this IdentifierPartSchema.  # noqa: E501
-        :type: int
-        """
-        if index is None:
-            raise ValueError("Invalid value for `index`, must not be `None`")  # noqa: E501
-
-        self._index = index
-
-    @property
-    def name(self):
-        """Gets the name of this IdentifierPartSchema.  # noqa: E501
-
-        The name of the identifier part that can/should be provided for this resource type  # noqa: E501
-
-        :return: The name of this IdentifierPartSchema.  # noqa: E501
-        :rtype: str
-        """
-        return self._name
-
-    @name.setter
-    def name(self, name):
-        """Sets the name of this IdentifierPartSchema.
-
-        The name of the identifier part that can/should be provided for this resource type  # noqa: E501
-
-        :param name: The name of this IdentifierPartSchema.  # noqa: E501
-        :type: str
-        """
-        if name is None:
-            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
-
-        self._name = name
-
-    @property
-    def display_name(self):
-        """Gets the display_name of this IdentifierPartSchema.  # noqa: E501
-
-        The display name of the identifier part  # noqa: E501
-
-        :return: The display_name of this IdentifierPartSchema.  # noqa: E501
-        :rtype: str
-        """
-        return self._display_name
-
-    @display_name.setter
-    def display_name(self, display_name):
-        """Sets the display_name of this IdentifierPartSchema.
-
-        The display name of the identifier part  # noqa: E501
-
-        :param display_name: The display_name of this IdentifierPartSchema.  # noqa: E501
-        :type: str
-        """
-        if display_name is None:
-            raise ValueError("Invalid value for `display_name`, must not be `None`")  # noqa: E501
-
-        self._display_name = display_name
-
-    @property
-    def description(self):
-        """Gets the description of this IdentifierPartSchema.  # noqa: E501
-
-        A brief description of the point of this identifier part  # noqa: E501
-
-        :return: The description of this IdentifierPartSchema.  # noqa: E501
-        :rtype: str
-        """
-        return self._description
-
-    @description.setter
-    def description(self, description):
-        """Sets the description of this IdentifierPartSchema.
-
-        A brief description of the point of this identifier part  # noqa: E501
-
-        :param description: The description of this IdentifierPartSchema.  # noqa: E501
-        :type: str
-        """
-        if description is None:
-            raise ValueError("Invalid value for `description`, must not be `None`")  # noqa: E501
-
-        self._description = description
-
-    @property
-    def required(self):
-        """Gets the required of this IdentifierPartSchema.  # noqa: E501
-
-        Whether a value is required to be provided  # noqa: E501
-
-        :return: The required of this IdentifierPartSchema.  # noqa: E501
-        :rtype: bool
-        """
-        return self._required
-
-    @required.setter
-    def required(self, required):
-        """Sets the required of this IdentifierPartSchema.
-
-        Whether a value is required to be provided  # noqa: E501
-
-        :param required: The required of this IdentifierPartSchema.  # noqa: E501
-        :type: bool
-        """
-        if required is None:
-            raise ValueError("Invalid value for `required`, must not be `None`")  # noqa: E501
-
-        self._required = required
-
-    @property
-    def links(self):
-        """Gets the links of this IdentifierPartSchema.  # noqa: E501
-
-
-        :return: The links of this IdentifierPartSchema.  # noqa: E501
-        :rtype: list[Link]
-        """
-        return self._links
-
-    @links.setter
-    def links(self, links):
-        """Sets the links of this IdentifierPartSchema.
-
-
-        :param links: The links of this IdentifierPartSchema.  # noqa: E501
-        :type: list[Link]
-        """
-
-        self._links = links
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, IdentifierPartSchema):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class IdentifierPartSchema(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'index': 'int',
+        'name': 'str',
+        'display_name': 'str',
+        'description': 'str',
+        'required': 'bool',
+        'links': 'list[Link]'
+    }
+
+    attribute_map = {
+        'index': 'index',
+        'name': 'name',
+        'display_name': 'displayName',
+        'description': 'description',
+        'required': 'required',
+        'links': 'links'
+    }
+
+    required_map = {
+        'index': 'required',
+        'name': 'required',
+        'display_name': 'required',
+        'description': 'required',
+        'required': 'required',
+        'links': 'optional'
+    }
+
+    def __init__(self, index=None, name=None, display_name=None, description=None, required=None, links=None):  # noqa: E501
+        """
+        IdentifierPartSchema - a model defined in OpenAPI
+
+        :param index:  The typical index in the identifier in which this part appears (required)
+        :type index: int
+        :param name:  The name of the identifier part that can/should be provided for this resource type (required)
+        :type name: str
+        :param display_name:  The display name of the identifier part (required)
+        :type display_name: str
+        :param description:  A brief description of the point of this identifier part (required)
+        :type description: str
+        :param required:  Whether a value is required to be provided (required)
+        :type required: bool
+        :param links: 
+        :type links: list[finbourne_access.Link]
+
+        """  # noqa: E501
+
+        self._index = None
+        self._name = None
+        self._display_name = None
+        self._description = None
+        self._required = None
+        self._links = None
+        self.discriminator = None
+
+        self.index = index
+        self.name = name
+        self.display_name = display_name
+        self.description = description
+        self.required = required
+        self.links = links
+
+    @property
+    def index(self):
+        """Gets the index of this IdentifierPartSchema.  # noqa: E501
+
+        The typical index in the identifier in which this part appears  # noqa: E501
+
+        :return: The index of this IdentifierPartSchema.  # noqa: E501
+        :rtype: int
+        """
+        return self._index
+
+    @index.setter
+    def index(self, index):
+        """Sets the index of this IdentifierPartSchema.
+
+        The typical index in the identifier in which this part appears  # noqa: E501
+
+        :param index: The index of this IdentifierPartSchema.  # noqa: E501
+        :type: int
+        """
+        if index is None:
+            raise ValueError("Invalid value for `index`, must not be `None`")  # noqa: E501
+
+        self._index = index
+
+    @property
+    def name(self):
+        """Gets the name of this IdentifierPartSchema.  # noqa: E501
+
+        The name of the identifier part that can/should be provided for this resource type  # noqa: E501
+
+        :return: The name of this IdentifierPartSchema.  # noqa: E501
+        :rtype: str
+        """
+        return self._name
+
+    @name.setter
+    def name(self, name):
+        """Sets the name of this IdentifierPartSchema.
+
+        The name of the identifier part that can/should be provided for this resource type  # noqa: E501
+
+        :param name: The name of this IdentifierPartSchema.  # noqa: E501
+        :type: str
+        """
+        if name is None:
+            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
+
+        self._name = name
+
+    @property
+    def display_name(self):
+        """Gets the display_name of this IdentifierPartSchema.  # noqa: E501
+
+        The display name of the identifier part  # noqa: E501
+
+        :return: The display_name of this IdentifierPartSchema.  # noqa: E501
+        :rtype: str
+        """
+        return self._display_name
+
+    @display_name.setter
+    def display_name(self, display_name):
+        """Sets the display_name of this IdentifierPartSchema.
+
+        The display name of the identifier part  # noqa: E501
+
+        :param display_name: The display_name of this IdentifierPartSchema.  # noqa: E501
+        :type: str
+        """
+        if display_name is None:
+            raise ValueError("Invalid value for `display_name`, must not be `None`")  # noqa: E501
+
+        self._display_name = display_name
+
+    @property
+    def description(self):
+        """Gets the description of this IdentifierPartSchema.  # noqa: E501
+
+        A brief description of the point of this identifier part  # noqa: E501
+
+        :return: The description of this IdentifierPartSchema.  # noqa: E501
+        :rtype: str
+        """
+        return self._description
+
+    @description.setter
+    def description(self, description):
+        """Sets the description of this IdentifierPartSchema.
+
+        A brief description of the point of this identifier part  # noqa: E501
+
+        :param description: The description of this IdentifierPartSchema.  # noqa: E501
+        :type: str
+        """
+        if description is None:
+            raise ValueError("Invalid value for `description`, must not be `None`")  # noqa: E501
+
+        self._description = description
+
+    @property
+    def required(self):
+        """Gets the required of this IdentifierPartSchema.  # noqa: E501
+
+        Whether a value is required to be provided  # noqa: E501
+
+        :return: The required of this IdentifierPartSchema.  # noqa: E501
+        :rtype: bool
+        """
+        return self._required
+
+    @required.setter
+    def required(self, required):
+        """Sets the required of this IdentifierPartSchema.
+
+        Whether a value is required to be provided  # noqa: E501
+
+        :param required: The required of this IdentifierPartSchema.  # noqa: E501
+        :type: bool
+        """
+        if required is None:
+            raise ValueError("Invalid value for `required`, must not be `None`")  # noqa: E501
+
+        self._required = required
+
+    @property
+    def links(self):
+        """Gets the links of this IdentifierPartSchema.  # noqa: E501
+
+
+        :return: The links of this IdentifierPartSchema.  # noqa: E501
+        :rtype: list[Link]
+        """
+        return self._links
+
+    @links.setter
+    def links(self, links):
+        """Sets the links of this IdentifierPartSchema.
+
+
+        :param links: The links of this IdentifierPartSchema.  # noqa: E501
+        :type: list[Link]
+        """
+
+        self._links = links
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, IdentifierPartSchema):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/if_expression.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/if_expression.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,182 +1,182 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class IfExpression(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'if_request_header_expression': 'IfRequestHeaderExpression',
-        'if_identity_claim_expression': 'IfIdentityClaimExpression',
-        'if_identity_scope_expression': 'IfIdentityScopeExpression'
-    }
-
-    attribute_map = {
-        'if_request_header_expression': 'ifRequestHeaderExpression',
-        'if_identity_claim_expression': 'ifIdentityClaimExpression',
-        'if_identity_scope_expression': 'ifIdentityScopeExpression'
-    }
-
-    required_map = {
-        'if_request_header_expression': 'optional',
-        'if_identity_claim_expression': 'optional',
-        'if_identity_scope_expression': 'optional'
-    }
-
-    def __init__(self, if_request_header_expression=None, if_identity_claim_expression=None, if_identity_scope_expression=None):  # noqa: E501
-        """
-        IfExpression - a model defined in OpenAPI
-
-        :param if_request_header_expression: 
-        :type if_request_header_expression: finbourne_access.IfRequestHeaderExpression
-        :param if_identity_claim_expression: 
-        :type if_identity_claim_expression: finbourne_access.IfIdentityClaimExpression
-        :param if_identity_scope_expression: 
-        :type if_identity_scope_expression: finbourne_access.IfIdentityScopeExpression
-
-        """  # noqa: E501
-
-        self._if_request_header_expression = None
-        self._if_identity_claim_expression = None
-        self._if_identity_scope_expression = None
-        self.discriminator = None
-
-        if if_request_header_expression is not None:
-            self.if_request_header_expression = if_request_header_expression
-        if if_identity_claim_expression is not None:
-            self.if_identity_claim_expression = if_identity_claim_expression
-        if if_identity_scope_expression is not None:
-            self.if_identity_scope_expression = if_identity_scope_expression
-
-    @property
-    def if_request_header_expression(self):
-        """Gets the if_request_header_expression of this IfExpression.  # noqa: E501
-
-
-        :return: The if_request_header_expression of this IfExpression.  # noqa: E501
-        :rtype: IfRequestHeaderExpression
-        """
-        return self._if_request_header_expression
-
-    @if_request_header_expression.setter
-    def if_request_header_expression(self, if_request_header_expression):
-        """Sets the if_request_header_expression of this IfExpression.
-
-
-        :param if_request_header_expression: The if_request_header_expression of this IfExpression.  # noqa: E501
-        :type: IfRequestHeaderExpression
-        """
-
-        self._if_request_header_expression = if_request_header_expression
-
-    @property
-    def if_identity_claim_expression(self):
-        """Gets the if_identity_claim_expression of this IfExpression.  # noqa: E501
-
-
-        :return: The if_identity_claim_expression of this IfExpression.  # noqa: E501
-        :rtype: IfIdentityClaimExpression
-        """
-        return self._if_identity_claim_expression
-
-    @if_identity_claim_expression.setter
-    def if_identity_claim_expression(self, if_identity_claim_expression):
-        """Sets the if_identity_claim_expression of this IfExpression.
-
-
-        :param if_identity_claim_expression: The if_identity_claim_expression of this IfExpression.  # noqa: E501
-        :type: IfIdentityClaimExpression
-        """
-
-        self._if_identity_claim_expression = if_identity_claim_expression
-
-    @property
-    def if_identity_scope_expression(self):
-        """Gets the if_identity_scope_expression of this IfExpression.  # noqa: E501
-
-
-        :return: The if_identity_scope_expression of this IfExpression.  # noqa: E501
-        :rtype: IfIdentityScopeExpression
-        """
-        return self._if_identity_scope_expression
-
-    @if_identity_scope_expression.setter
-    def if_identity_scope_expression(self, if_identity_scope_expression):
-        """Sets the if_identity_scope_expression of this IfExpression.
-
-
-        :param if_identity_scope_expression: The if_identity_scope_expression of this IfExpression.  # noqa: E501
-        :type: IfIdentityScopeExpression
-        """
-
-        self._if_identity_scope_expression = if_identity_scope_expression
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, IfExpression):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class IfExpression(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'if_request_header_expression': 'IfRequestHeaderExpression',
+        'if_identity_claim_expression': 'IfIdentityClaimExpression',
+        'if_identity_scope_expression': 'IfIdentityScopeExpression'
+    }
+
+    attribute_map = {
+        'if_request_header_expression': 'ifRequestHeaderExpression',
+        'if_identity_claim_expression': 'ifIdentityClaimExpression',
+        'if_identity_scope_expression': 'ifIdentityScopeExpression'
+    }
+
+    required_map = {
+        'if_request_header_expression': 'optional',
+        'if_identity_claim_expression': 'optional',
+        'if_identity_scope_expression': 'optional'
+    }
+
+    def __init__(self, if_request_header_expression=None, if_identity_claim_expression=None, if_identity_scope_expression=None):  # noqa: E501
+        """
+        IfExpression - a model defined in OpenAPI
+
+        :param if_request_header_expression: 
+        :type if_request_header_expression: finbourne_access.IfRequestHeaderExpression
+        :param if_identity_claim_expression: 
+        :type if_identity_claim_expression: finbourne_access.IfIdentityClaimExpression
+        :param if_identity_scope_expression: 
+        :type if_identity_scope_expression: finbourne_access.IfIdentityScopeExpression
+
+        """  # noqa: E501
+
+        self._if_request_header_expression = None
+        self._if_identity_claim_expression = None
+        self._if_identity_scope_expression = None
+        self.discriminator = None
+
+        if if_request_header_expression is not None:
+            self.if_request_header_expression = if_request_header_expression
+        if if_identity_claim_expression is not None:
+            self.if_identity_claim_expression = if_identity_claim_expression
+        if if_identity_scope_expression is not None:
+            self.if_identity_scope_expression = if_identity_scope_expression
+
+    @property
+    def if_request_header_expression(self):
+        """Gets the if_request_header_expression of this IfExpression.  # noqa: E501
+
+
+        :return: The if_request_header_expression of this IfExpression.  # noqa: E501
+        :rtype: IfRequestHeaderExpression
+        """
+        return self._if_request_header_expression
+
+    @if_request_header_expression.setter
+    def if_request_header_expression(self, if_request_header_expression):
+        """Sets the if_request_header_expression of this IfExpression.
+
+
+        :param if_request_header_expression: The if_request_header_expression of this IfExpression.  # noqa: E501
+        :type: IfRequestHeaderExpression
+        """
+
+        self._if_request_header_expression = if_request_header_expression
+
+    @property
+    def if_identity_claim_expression(self):
+        """Gets the if_identity_claim_expression of this IfExpression.  # noqa: E501
+
+
+        :return: The if_identity_claim_expression of this IfExpression.  # noqa: E501
+        :rtype: IfIdentityClaimExpression
+        """
+        return self._if_identity_claim_expression
+
+    @if_identity_claim_expression.setter
+    def if_identity_claim_expression(self, if_identity_claim_expression):
+        """Sets the if_identity_claim_expression of this IfExpression.
+
+
+        :param if_identity_claim_expression: The if_identity_claim_expression of this IfExpression.  # noqa: E501
+        :type: IfIdentityClaimExpression
+        """
+
+        self._if_identity_claim_expression = if_identity_claim_expression
+
+    @property
+    def if_identity_scope_expression(self):
+        """Gets the if_identity_scope_expression of this IfExpression.  # noqa: E501
+
+
+        :return: The if_identity_scope_expression of this IfExpression.  # noqa: E501
+        :rtype: IfIdentityScopeExpression
+        """
+        return self._if_identity_scope_expression
+
+    @if_identity_scope_expression.setter
+    def if_identity_scope_expression(self, if_identity_scope_expression):
+        """Sets the if_identity_scope_expression of this IfExpression.
+
+
+        :param if_identity_scope_expression: The if_identity_scope_expression of this IfExpression.  # noqa: E501
+        :type: IfIdentityScopeExpression
+        """
+
+        self._if_identity_scope_expression = if_identity_scope_expression
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, IfExpression):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/if_identity_claim_expression.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/if_identity_claim_expression.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,269 +1,269 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class IfIdentityClaimExpression(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'claim_type': 'str',
-        'claim_value_type': 'str',
-        'claim_issuer': 'str',
-        'claim_original_issuer': 'str',
-        'operator': 'TextOperator',
-        'value': 'str'
-    }
-
-    attribute_map = {
-        'claim_type': 'claimType',
-        'claim_value_type': 'claimValueType',
-        'claim_issuer': 'claimIssuer',
-        'claim_original_issuer': 'claimOriginalIssuer',
-        'operator': 'operator',
-        'value': 'value'
-    }
-
-    required_map = {
-        'claim_type': 'required',
-        'claim_value_type': 'required',
-        'claim_issuer': 'optional',
-        'claim_original_issuer': 'optional',
-        'operator': 'required',
-        'value': 'optional'
-    }
-
-    def __init__(self, claim_type=None, claim_value_type=None, claim_issuer=None, claim_original_issuer=None, operator=None, value=None):  # noqa: E501
-        """
-        IfIdentityClaimExpression - a model defined in OpenAPI
-
-        :param claim_type:  (required)
-        :type claim_type: str
-        :param claim_value_type:  (required)
-        :type claim_value_type: str
-        :param claim_issuer: 
-        :type claim_issuer: str
-        :param claim_original_issuer: 
-        :type claim_original_issuer: str
-        :param operator:  (required)
-        :type operator: finbourne_access.TextOperator
-        :param value: 
-        :type value: str
-
-        """  # noqa: E501
-
-        self._claim_type = None
-        self._claim_value_type = None
-        self._claim_issuer = None
-        self._claim_original_issuer = None
-        self._operator = None
-        self._value = None
-        self.discriminator = None
-
-        self.claim_type = claim_type
-        self.claim_value_type = claim_value_type
-        self.claim_issuer = claim_issuer
-        self.claim_original_issuer = claim_original_issuer
-        self.operator = operator
-        self.value = value
-
-    @property
-    def claim_type(self):
-        """Gets the claim_type of this IfIdentityClaimExpression.  # noqa: E501
-
-
-        :return: The claim_type of this IfIdentityClaimExpression.  # noqa: E501
-        :rtype: str
-        """
-        return self._claim_type
-
-    @claim_type.setter
-    def claim_type(self, claim_type):
-        """Sets the claim_type of this IfIdentityClaimExpression.
-
-
-        :param claim_type: The claim_type of this IfIdentityClaimExpression.  # noqa: E501
-        :type: str
-        """
-        if claim_type is None:
-            raise ValueError("Invalid value for `claim_type`, must not be `None`")  # noqa: E501
-
-        self._claim_type = claim_type
-
-    @property
-    def claim_value_type(self):
-        """Gets the claim_value_type of this IfIdentityClaimExpression.  # noqa: E501
-
-
-        :return: The claim_value_type of this IfIdentityClaimExpression.  # noqa: E501
-        :rtype: str
-        """
-        return self._claim_value_type
-
-    @claim_value_type.setter
-    def claim_value_type(self, claim_value_type):
-        """Sets the claim_value_type of this IfIdentityClaimExpression.
-
-
-        :param claim_value_type: The claim_value_type of this IfIdentityClaimExpression.  # noqa: E501
-        :type: str
-        """
-        if claim_value_type is None:
-            raise ValueError("Invalid value for `claim_value_type`, must not be `None`")  # noqa: E501
-
-        self._claim_value_type = claim_value_type
-
-    @property
-    def claim_issuer(self):
-        """Gets the claim_issuer of this IfIdentityClaimExpression.  # noqa: E501
-
-
-        :return: The claim_issuer of this IfIdentityClaimExpression.  # noqa: E501
-        :rtype: str
-        """
-        return self._claim_issuer
-
-    @claim_issuer.setter
-    def claim_issuer(self, claim_issuer):
-        """Sets the claim_issuer of this IfIdentityClaimExpression.
-
-
-        :param claim_issuer: The claim_issuer of this IfIdentityClaimExpression.  # noqa: E501
-        :type: str
-        """
-
-        self._claim_issuer = claim_issuer
-
-    @property
-    def claim_original_issuer(self):
-        """Gets the claim_original_issuer of this IfIdentityClaimExpression.  # noqa: E501
-
-
-        :return: The claim_original_issuer of this IfIdentityClaimExpression.  # noqa: E501
-        :rtype: str
-        """
-        return self._claim_original_issuer
-
-    @claim_original_issuer.setter
-    def claim_original_issuer(self, claim_original_issuer):
-        """Sets the claim_original_issuer of this IfIdentityClaimExpression.
-
-
-        :param claim_original_issuer: The claim_original_issuer of this IfIdentityClaimExpression.  # noqa: E501
-        :type: str
-        """
-
-        self._claim_original_issuer = claim_original_issuer
-
-    @property
-    def operator(self):
-        """Gets the operator of this IfIdentityClaimExpression.  # noqa: E501
-
-
-        :return: The operator of this IfIdentityClaimExpression.  # noqa: E501
-        :rtype: TextOperator
-        """
-        return self._operator
-
-    @operator.setter
-    def operator(self, operator):
-        """Sets the operator of this IfIdentityClaimExpression.
-
-
-        :param operator: The operator of this IfIdentityClaimExpression.  # noqa: E501
-        :type: TextOperator
-        """
-        if operator is None:
-            raise ValueError("Invalid value for `operator`, must not be `None`")  # noqa: E501
-
-        self._operator = operator
-
-    @property
-    def value(self):
-        """Gets the value of this IfIdentityClaimExpression.  # noqa: E501
-
-
-        :return: The value of this IfIdentityClaimExpression.  # noqa: E501
-        :rtype: str
-        """
-        return self._value
-
-    @value.setter
-    def value(self, value):
-        """Sets the value of this IfIdentityClaimExpression.
-
-
-        :param value: The value of this IfIdentityClaimExpression.  # noqa: E501
-        :type: str
-        """
-
-        self._value = value
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, IfIdentityClaimExpression):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class IfIdentityClaimExpression(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'claim_type': 'str',
+        'claim_value_type': 'str',
+        'claim_issuer': 'str',
+        'claim_original_issuer': 'str',
+        'operator': 'TextOperator',
+        'value': 'str'
+    }
+
+    attribute_map = {
+        'claim_type': 'claimType',
+        'claim_value_type': 'claimValueType',
+        'claim_issuer': 'claimIssuer',
+        'claim_original_issuer': 'claimOriginalIssuer',
+        'operator': 'operator',
+        'value': 'value'
+    }
+
+    required_map = {
+        'claim_type': 'required',
+        'claim_value_type': 'required',
+        'claim_issuer': 'optional',
+        'claim_original_issuer': 'optional',
+        'operator': 'required',
+        'value': 'optional'
+    }
+
+    def __init__(self, claim_type=None, claim_value_type=None, claim_issuer=None, claim_original_issuer=None, operator=None, value=None):  # noqa: E501
+        """
+        IfIdentityClaimExpression - a model defined in OpenAPI
+
+        :param claim_type:  (required)
+        :type claim_type: str
+        :param claim_value_type:  (required)
+        :type claim_value_type: str
+        :param claim_issuer: 
+        :type claim_issuer: str
+        :param claim_original_issuer: 
+        :type claim_original_issuer: str
+        :param operator:  (required)
+        :type operator: finbourne_access.TextOperator
+        :param value: 
+        :type value: str
+
+        """  # noqa: E501
+
+        self._claim_type = None
+        self._claim_value_type = None
+        self._claim_issuer = None
+        self._claim_original_issuer = None
+        self._operator = None
+        self._value = None
+        self.discriminator = None
+
+        self.claim_type = claim_type
+        self.claim_value_type = claim_value_type
+        self.claim_issuer = claim_issuer
+        self.claim_original_issuer = claim_original_issuer
+        self.operator = operator
+        self.value = value
+
+    @property
+    def claim_type(self):
+        """Gets the claim_type of this IfIdentityClaimExpression.  # noqa: E501
+
+
+        :return: The claim_type of this IfIdentityClaimExpression.  # noqa: E501
+        :rtype: str
+        """
+        return self._claim_type
+
+    @claim_type.setter
+    def claim_type(self, claim_type):
+        """Sets the claim_type of this IfIdentityClaimExpression.
+
+
+        :param claim_type: The claim_type of this IfIdentityClaimExpression.  # noqa: E501
+        :type: str
+        """
+        if claim_type is None:
+            raise ValueError("Invalid value for `claim_type`, must not be `None`")  # noqa: E501
+
+        self._claim_type = claim_type
+
+    @property
+    def claim_value_type(self):
+        """Gets the claim_value_type of this IfIdentityClaimExpression.  # noqa: E501
+
+
+        :return: The claim_value_type of this IfIdentityClaimExpression.  # noqa: E501
+        :rtype: str
+        """
+        return self._claim_value_type
+
+    @claim_value_type.setter
+    def claim_value_type(self, claim_value_type):
+        """Sets the claim_value_type of this IfIdentityClaimExpression.
+
+
+        :param claim_value_type: The claim_value_type of this IfIdentityClaimExpression.  # noqa: E501
+        :type: str
+        """
+        if claim_value_type is None:
+            raise ValueError("Invalid value for `claim_value_type`, must not be `None`")  # noqa: E501
+
+        self._claim_value_type = claim_value_type
+
+    @property
+    def claim_issuer(self):
+        """Gets the claim_issuer of this IfIdentityClaimExpression.  # noqa: E501
+
+
+        :return: The claim_issuer of this IfIdentityClaimExpression.  # noqa: E501
+        :rtype: str
+        """
+        return self._claim_issuer
+
+    @claim_issuer.setter
+    def claim_issuer(self, claim_issuer):
+        """Sets the claim_issuer of this IfIdentityClaimExpression.
+
+
+        :param claim_issuer: The claim_issuer of this IfIdentityClaimExpression.  # noqa: E501
+        :type: str
+        """
+
+        self._claim_issuer = claim_issuer
+
+    @property
+    def claim_original_issuer(self):
+        """Gets the claim_original_issuer of this IfIdentityClaimExpression.  # noqa: E501
+
+
+        :return: The claim_original_issuer of this IfIdentityClaimExpression.  # noqa: E501
+        :rtype: str
+        """
+        return self._claim_original_issuer
+
+    @claim_original_issuer.setter
+    def claim_original_issuer(self, claim_original_issuer):
+        """Sets the claim_original_issuer of this IfIdentityClaimExpression.
+
+
+        :param claim_original_issuer: The claim_original_issuer of this IfIdentityClaimExpression.  # noqa: E501
+        :type: str
+        """
+
+        self._claim_original_issuer = claim_original_issuer
+
+    @property
+    def operator(self):
+        """Gets the operator of this IfIdentityClaimExpression.  # noqa: E501
+
+
+        :return: The operator of this IfIdentityClaimExpression.  # noqa: E501
+        :rtype: TextOperator
+        """
+        return self._operator
+
+    @operator.setter
+    def operator(self, operator):
+        """Sets the operator of this IfIdentityClaimExpression.
+
+
+        :param operator: The operator of this IfIdentityClaimExpression.  # noqa: E501
+        :type: TextOperator
+        """
+        if operator is None:
+            raise ValueError("Invalid value for `operator`, must not be `None`")  # noqa: E501
+
+        self._operator = operator
+
+    @property
+    def value(self):
+        """Gets the value of this IfIdentityClaimExpression.  # noqa: E501
+
+
+        :return: The value of this IfIdentityClaimExpression.  # noqa: E501
+        :rtype: str
+        """
+        return self._value
+
+    @value.setter
+    def value(self, value):
+        """Sets the value of this IfIdentityClaimExpression.
+
+
+        :param value: The value of this IfIdentityClaimExpression.  # noqa: E501
+        :type: str
+        """
+
+        self._value = value
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, IfIdentityClaimExpression):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/if_identity_scope_expression.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/if_identity_scope_expression.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,127 +1,127 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class IfIdentityScopeExpression(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'scope_name': 'str'
-    }
-
-    attribute_map = {
-        'scope_name': 'scopeName'
-    }
-
-    required_map = {
-        'scope_name': 'required'
-    }
-
-    def __init__(self, scope_name=None):  # noqa: E501
-        """
-        IfIdentityScopeExpression - a model defined in OpenAPI
-
-        :param scope_name:  (required)
-        :type scope_name: str
-
-        """  # noqa: E501
-
-        self._scope_name = None
-        self.discriminator = None
-
-        self.scope_name = scope_name
-
-    @property
-    def scope_name(self):
-        """Gets the scope_name of this IfIdentityScopeExpression.  # noqa: E501
-
-
-        :return: The scope_name of this IfIdentityScopeExpression.  # noqa: E501
-        :rtype: str
-        """
-        return self._scope_name
-
-    @scope_name.setter
-    def scope_name(self, scope_name):
-        """Sets the scope_name of this IfIdentityScopeExpression.
-
-
-        :param scope_name: The scope_name of this IfIdentityScopeExpression.  # noqa: E501
-        :type: str
-        """
-        if scope_name is None:
-            raise ValueError("Invalid value for `scope_name`, must not be `None`")  # noqa: E501
-        if scope_name is not None and len(scope_name) < 1:
-            raise ValueError("Invalid value for `scope_name`, length must be greater than or equal to `1`")  # noqa: E501
-
-        self._scope_name = scope_name
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, IfIdentityScopeExpression):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class IfIdentityScopeExpression(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'scope_name': 'str'
+    }
+
+    attribute_map = {
+        'scope_name': 'scopeName'
+    }
+
+    required_map = {
+        'scope_name': 'required'
+    }
+
+    def __init__(self, scope_name=None):  # noqa: E501
+        """
+        IfIdentityScopeExpression - a model defined in OpenAPI
+
+        :param scope_name:  (required)
+        :type scope_name: str
+
+        """  # noqa: E501
+
+        self._scope_name = None
+        self.discriminator = None
+
+        self.scope_name = scope_name
+
+    @property
+    def scope_name(self):
+        """Gets the scope_name of this IfIdentityScopeExpression.  # noqa: E501
+
+
+        :return: The scope_name of this IfIdentityScopeExpression.  # noqa: E501
+        :rtype: str
+        """
+        return self._scope_name
+
+    @scope_name.setter
+    def scope_name(self, scope_name):
+        """Sets the scope_name of this IfIdentityScopeExpression.
+
+
+        :param scope_name: The scope_name of this IfIdentityScopeExpression.  # noqa: E501
+        :type: str
+        """
+        if scope_name is None:
+            raise ValueError("Invalid value for `scope_name`, must not be `None`")  # noqa: E501
+        if scope_name is not None and len(scope_name) < 1:
+            raise ValueError("Invalid value for `scope_name`, length must be greater than or equal to `1`")  # noqa: E501
+
+        self._scope_name = scope_name
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, IfIdentityScopeExpression):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/if_request_header_expression.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/if_request_header_expression.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,185 +1,191 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class IfRequestHeaderExpression(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'header_name': 'str',
-        'operator': 'TextOperator',
-        'value': 'str'
-    }
-
-    attribute_map = {
-        'header_name': 'headerName',
-        'operator': 'operator',
-        'value': 'value'
-    }
-
-    required_map = {
-        'header_name': 'required',
-        'operator': 'required',
-        'value': 'optional'
-    }
-
-    def __init__(self, header_name=None, operator=None, value=None):  # noqa: E501
-        """
-        IfRequestHeaderExpression - a model defined in OpenAPI
-
-        :param header_name:  (required)
-        :type header_name: str
-        :param operator:  (required)
-        :type operator: finbourne_access.TextOperator
-        :param value: 
-        :type value: str
-
-        """  # noqa: E501
-
-        self._header_name = None
-        self._operator = None
-        self._value = None
-        self.discriminator = None
-
-        self.header_name = header_name
-        self.operator = operator
-        self.value = value
-
-    @property
-    def header_name(self):
-        """Gets the header_name of this IfRequestHeaderExpression.  # noqa: E501
-
-
-        :return: The header_name of this IfRequestHeaderExpression.  # noqa: E501
-        :rtype: str
-        """
-        return self._header_name
-
-    @header_name.setter
-    def header_name(self, header_name):
-        """Sets the header_name of this IfRequestHeaderExpression.
-
-
-        :param header_name: The header_name of this IfRequestHeaderExpression.  # noqa: E501
-        :type: str
-        """
-        if header_name is None:
-            raise ValueError("Invalid value for `header_name`, must not be `None`")  # noqa: E501
-        if header_name is not None and len(header_name) < 1:
-            raise ValueError("Invalid value for `header_name`, length must be greater than or equal to `1`")  # noqa: E501
-
-        self._header_name = header_name
-
-    @property
-    def operator(self):
-        """Gets the operator of this IfRequestHeaderExpression.  # noqa: E501
-
-
-        :return: The operator of this IfRequestHeaderExpression.  # noqa: E501
-        :rtype: TextOperator
-        """
-        return self._operator
-
-    @operator.setter
-    def operator(self, operator):
-        """Sets the operator of this IfRequestHeaderExpression.
-
-
-        :param operator: The operator of this IfRequestHeaderExpression.  # noqa: E501
-        :type: TextOperator
-        """
-        if operator is None:
-            raise ValueError("Invalid value for `operator`, must not be `None`")  # noqa: E501
-
-        self._operator = operator
-
-    @property
-    def value(self):
-        """Gets the value of this IfRequestHeaderExpression.  # noqa: E501
-
-
-        :return: The value of this IfRequestHeaderExpression.  # noqa: E501
-        :rtype: str
-        """
-        return self._value
-
-    @value.setter
-    def value(self, value):
-        """Sets the value of this IfRequestHeaderExpression.
-
-
-        :param value: The value of this IfRequestHeaderExpression.  # noqa: E501
-        :type: str
-        """
-
-        self._value = value
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, IfRequestHeaderExpression):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class IfRequestHeaderExpression(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'header_name': 'str',
+        'operator': 'TextOperator',
+        'value': 'str'
+    }
+
+    attribute_map = {
+        'header_name': 'headerName',
+        'operator': 'operator',
+        'value': 'value'
+    }
+
+    required_map = {
+        'header_name': 'required',
+        'operator': 'required',
+        'value': 'optional'
+    }
+
+    def __init__(self, header_name=None, operator=None, value=None):  # noqa: E501
+        """
+        IfRequestHeaderExpression - a model defined in OpenAPI
+
+        :param header_name:  (required)
+        :type header_name: str
+        :param operator:  (required)
+        :type operator: finbourne_access.TextOperator
+        :param value: 
+        :type value: str
+
+        """  # noqa: E501
+
+        self._header_name = None
+        self._operator = None
+        self._value = None
+        self.discriminator = None
+
+        self.header_name = header_name
+        self.operator = operator
+        self.value = value
+
+    @property
+    def header_name(self):
+        """Gets the header_name of this IfRequestHeaderExpression.  # noqa: E501
+
+
+        :return: The header_name of this IfRequestHeaderExpression.  # noqa: E501
+        :rtype: str
+        """
+        return self._header_name
+
+    @header_name.setter
+    def header_name(self, header_name):
+        """Sets the header_name of this IfRequestHeaderExpression.
+
+
+        :param header_name: The header_name of this IfRequestHeaderExpression.  # noqa: E501
+        :type: str
+        """
+        if header_name is None:
+            raise ValueError("Invalid value for `header_name`, must not be `None`")  # noqa: E501
+        if header_name is not None and len(header_name) > 1024:
+            raise ValueError("Invalid value for `header_name`, length must be less than or equal to `1024`")  # noqa: E501
+        if header_name is not None and len(header_name) < 1:
+            raise ValueError("Invalid value for `header_name`, length must be greater than or equal to `1`")  # noqa: E501
+
+        self._header_name = header_name
+
+    @property
+    def operator(self):
+        """Gets the operator of this IfRequestHeaderExpression.  # noqa: E501
+
+
+        :return: The operator of this IfRequestHeaderExpression.  # noqa: E501
+        :rtype: TextOperator
+        """
+        return self._operator
+
+    @operator.setter
+    def operator(self, operator):
+        """Sets the operator of this IfRequestHeaderExpression.
+
+
+        :param operator: The operator of this IfRequestHeaderExpression.  # noqa: E501
+        :type: TextOperator
+        """
+        if operator is None:
+            raise ValueError("Invalid value for `operator`, must not be `None`")  # noqa: E501
+
+        self._operator = operator
+
+    @property
+    def value(self):
+        """Gets the value of this IfRequestHeaderExpression.  # noqa: E501
+
+
+        :return: The value of this IfRequestHeaderExpression.  # noqa: E501
+        :rtype: str
+        """
+        return self._value
+
+    @value.setter
+    def value(self, value):
+        """Sets the value of this IfRequestHeaderExpression.
+
+
+        :param value: The value of this IfRequestHeaderExpression.  # noqa: E501
+        :type: str
+        """
+        if value is not None and len(value) > 4096:
+            raise ValueError("Invalid value for `value`, length must be less than or equal to `4096`")  # noqa: E501
+        if value is not None and len(value) < 0:
+            raise ValueError("Invalid value for `value`, length must be greater than or equal to `0`")  # noqa: E501
+
+        self._value = value
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, IfRequestHeaderExpression):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/key_value_pair_of_string_to_string.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/key_value_pair_of_string_to_string.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,151 +1,151 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class KeyValuePairOfStringToString(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'key': 'str',
-        'value': 'str'
-    }
-
-    attribute_map = {
-        'key': 'key',
-        'value': 'value'
-    }
-
-    required_map = {
-        'key': 'optional',
-        'value': 'optional'
-    }
-
-    def __init__(self, key=None, value=None):  # noqa: E501
-        """
-        KeyValuePairOfStringToString - a model defined in OpenAPI
-
-        :param key: 
-        :type key: str
-        :param value: 
-        :type value: str
-
-        """  # noqa: E501
-
-        self._key = None
-        self._value = None
-        self.discriminator = None
-
-        self.key = key
-        self.value = value
-
-    @property
-    def key(self):
-        """Gets the key of this KeyValuePairOfStringToString.  # noqa: E501
-
-
-        :return: The key of this KeyValuePairOfStringToString.  # noqa: E501
-        :rtype: str
-        """
-        return self._key
-
-    @key.setter
-    def key(self, key):
-        """Sets the key of this KeyValuePairOfStringToString.
-
-
-        :param key: The key of this KeyValuePairOfStringToString.  # noqa: E501
-        :type: str
-        """
-
-        self._key = key
-
-    @property
-    def value(self):
-        """Gets the value of this KeyValuePairOfStringToString.  # noqa: E501
-
-
-        :return: The value of this KeyValuePairOfStringToString.  # noqa: E501
-        :rtype: str
-        """
-        return self._value
-
-    @value.setter
-    def value(self, value):
-        """Sets the value of this KeyValuePairOfStringToString.
-
-
-        :param value: The value of this KeyValuePairOfStringToString.  # noqa: E501
-        :type: str
-        """
-
-        self._value = value
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, KeyValuePairOfStringToString):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class KeyValuePairOfStringToString(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'key': 'str',
+        'value': 'str'
+    }
+
+    attribute_map = {
+        'key': 'key',
+        'value': 'value'
+    }
+
+    required_map = {
+        'key': 'optional',
+        'value': 'optional'
+    }
+
+    def __init__(self, key=None, value=None):  # noqa: E501
+        """
+        KeyValuePairOfStringToString - a model defined in OpenAPI
+
+        :param key: 
+        :type key: str
+        :param value: 
+        :type value: str
+
+        """  # noqa: E501
+
+        self._key = None
+        self._value = None
+        self.discriminator = None
+
+        self.key = key
+        self.value = value
+
+    @property
+    def key(self):
+        """Gets the key of this KeyValuePairOfStringToString.  # noqa: E501
+
+
+        :return: The key of this KeyValuePairOfStringToString.  # noqa: E501
+        :rtype: str
+        """
+        return self._key
+
+    @key.setter
+    def key(self, key):
+        """Sets the key of this KeyValuePairOfStringToString.
+
+
+        :param key: The key of this KeyValuePairOfStringToString.  # noqa: E501
+        :type: str
+        """
+
+        self._key = key
+
+    @property
+    def value(self):
+        """Gets the value of this KeyValuePairOfStringToString.  # noqa: E501
+
+
+        :return: The value of this KeyValuePairOfStringToString.  # noqa: E501
+        :rtype: str
+        """
+        return self._value
+
+    @value.setter
+    def value(self, value):
+        """Sets the value of this KeyValuePairOfStringToString.
+
+
+        :param value: The value of this KeyValuePairOfStringToString.  # noqa: E501
+        :type: str
+        """
+
+        self._value = value
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, KeyValuePairOfStringToString):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/licence_creation_request.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/policy_update_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,340 +1,340 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class LicenceCreationRequest(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'code': 'str',
-        'description': 'str',
-        'applications': 'list[str]',
-        'selectors': 'list[LicenceSelectorDefinition]',
-        'when': 'WhenSpec',
-        '_for': 'list[ForSpec]',
-        'how': 'HowSpec',
-        '_if': 'list[IfExpression]'
-    }
-
-    attribute_map = {
-        'code': 'code',
-        'description': 'description',
-        'applications': 'applications',
-        'selectors': 'selectors',
-        'when': 'when',
-        '_for': 'for',
-        'how': 'how',
-        '_if': 'if'
-    }
-
-    required_map = {
-        'code': 'required',
-        'description': 'required',
-        'applications': 'required',
-        'selectors': 'required',
-        'when': 'required',
-        '_for': 'optional',
-        'how': 'optional',
-        '_if': 'optional'
-    }
-
-    def __init__(self, code=None, description=None, applications=None, selectors=None, when=None, _for=None, how=None, _if=None):  # noqa: E501
-        """
-        LicenceCreationRequest - a model defined in OpenAPI
-
-        :param code:  (required)
-        :type code: str
-        :param description:  (required)
-        :type description: str
-        :param applications:  (required)
-        :type applications: list[str]
-        :param selectors:  (required)
-        :type selectors: list[finbourne_access.LicenceSelectorDefinition]
-        :param when:  (required)
-        :type when: finbourne_access.WhenSpec
-        :param _for: 
-        :type _for: list[finbourne_access.ForSpec]
-        :param how: 
-        :type how: finbourne_access.HowSpec
-        :param _if: 
-        :type _if: list[finbourne_access.IfExpression]
-
-        """  # noqa: E501
-
-        self._code = None
-        self._description = None
-        self._applications = None
-        self._selectors = None
-        self._when = None
-        self.__for = None
-        self._how = None
-        self.__if = None
-        self.discriminator = None
-
-        self.code = code
-        self.description = description
-        self.applications = applications
-        self.selectors = selectors
-        self.when = when
-        self._for = _for
-        if how is not None:
-            self.how = how
-        self._if = _if
-
-    @property
-    def code(self):
-        """Gets the code of this LicenceCreationRequest.  # noqa: E501
-
-
-        :return: The code of this LicenceCreationRequest.  # noqa: E501
-        :rtype: str
-        """
-        return self._code
-
-    @code.setter
-    def code(self, code):
-        """Sets the code of this LicenceCreationRequest.
-
-
-        :param code: The code of this LicenceCreationRequest.  # noqa: E501
-        :type: str
-        """
-        if code is None:
-            raise ValueError("Invalid value for `code`, must not be `None`")  # noqa: E501
-        if code is not None and len(code) > 100:
-            raise ValueError("Invalid value for `code`, length must be less than or equal to `100`")  # noqa: E501
-        if code is not None and len(code) < 3:
-            raise ValueError("Invalid value for `code`, length must be greater than or equal to `3`")  # noqa: E501
-        if (code is not None and not re.search(r'^[a-zA-Z][a-zA-Z0-9-_ +]{2,100}$', code)):  # noqa: E501
-            raise ValueError(r"Invalid value for `code`, must be a follow pattern or equal to `/^[a-zA-Z][a-zA-Z0-9-_ +]{2,100}$/`")  # noqa: E501
-
-        self._code = code
-
-    @property
-    def description(self):
-        """Gets the description of this LicenceCreationRequest.  # noqa: E501
-
-
-        :return: The description of this LicenceCreationRequest.  # noqa: E501
-        :rtype: str
-        """
-        return self._description
-
-    @description.setter
-    def description(self, description):
-        """Sets the description of this LicenceCreationRequest.
-
-
-        :param description: The description of this LicenceCreationRequest.  # noqa: E501
-        :type: str
-        """
-        if description is None:
-            raise ValueError("Invalid value for `description`, must not be `None`")  # noqa: E501
-        if description is not None and len(description) > 1024:
-            raise ValueError("Invalid value for `description`, length must be less than or equal to `1024`")  # noqa: E501
-        if description is not None and len(description) < 0:
-            raise ValueError("Invalid value for `description`, length must be greater than or equal to `0`")  # noqa: E501
-
-        self._description = description
-
-    @property
-    def applications(self):
-        """Gets the applications of this LicenceCreationRequest.  # noqa: E501
-
-
-        :return: The applications of this LicenceCreationRequest.  # noqa: E501
-        :rtype: list[str]
-        """
-        return self._applications
-
-    @applications.setter
-    def applications(self, applications):
-        """Sets the applications of this LicenceCreationRequest.
-
-
-        :param applications: The applications of this LicenceCreationRequest.  # noqa: E501
-        :type: list[str]
-        """
-        if applications is None:
-            raise ValueError("Invalid value for `applications`, must not be `None`")  # noqa: E501
-
-        self._applications = applications
-
-    @property
-    def selectors(self):
-        """Gets the selectors of this LicenceCreationRequest.  # noqa: E501
-
-
-        :return: The selectors of this LicenceCreationRequest.  # noqa: E501
-        :rtype: list[LicenceSelectorDefinition]
-        """
-        return self._selectors
-
-    @selectors.setter
-    def selectors(self, selectors):
-        """Sets the selectors of this LicenceCreationRequest.
-
-
-        :param selectors: The selectors of this LicenceCreationRequest.  # noqa: E501
-        :type: list[LicenceSelectorDefinition]
-        """
-        if selectors is None:
-            raise ValueError("Invalid value for `selectors`, must not be `None`")  # noqa: E501
-
-        self._selectors = selectors
-
-    @property
-    def when(self):
-        """Gets the when of this LicenceCreationRequest.  # noqa: E501
-
-
-        :return: The when of this LicenceCreationRequest.  # noqa: E501
-        :rtype: WhenSpec
-        """
-        return self._when
-
-    @when.setter
-    def when(self, when):
-        """Sets the when of this LicenceCreationRequest.
-
-
-        :param when: The when of this LicenceCreationRequest.  # noqa: E501
-        :type: WhenSpec
-        """
-        if when is None:
-            raise ValueError("Invalid value for `when`, must not be `None`")  # noqa: E501
-
-        self._when = when
-
-    @property
-    def _for(self):
-        """Gets the _for of this LicenceCreationRequest.  # noqa: E501
-
-
-        :return: The _for of this LicenceCreationRequest.  # noqa: E501
-        :rtype: list[ForSpec]
-        """
-        return self.__for
-
-    @_for.setter
-    def _for(self, _for):
-        """Sets the _for of this LicenceCreationRequest.
-
-
-        :param _for: The _for of this LicenceCreationRequest.  # noqa: E501
-        :type: list[ForSpec]
-        """
-
-        self.__for = _for
-
-    @property
-    def how(self):
-        """Gets the how of this LicenceCreationRequest.  # noqa: E501
-
-
-        :return: The how of this LicenceCreationRequest.  # noqa: E501
-        :rtype: HowSpec
-        """
-        return self._how
-
-    @how.setter
-    def how(self, how):
-        """Sets the how of this LicenceCreationRequest.
-
-
-        :param how: The how of this LicenceCreationRequest.  # noqa: E501
-        :type: HowSpec
-        """
-
-        self._how = how
-
-    @property
-    def _if(self):
-        """Gets the _if of this LicenceCreationRequest.  # noqa: E501
-
-
-        :return: The _if of this LicenceCreationRequest.  # noqa: E501
-        :rtype: list[IfExpression]
-        """
-        return self.__if
-
-    @_if.setter
-    def _if(self, _if):
-        """Sets the _if of this LicenceCreationRequest.
-
-
-        :param _if: The _if of this LicenceCreationRequest.  # noqa: E501
-        :type: list[IfExpression]
-        """
-
-        self.__if = _if
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, LicenceCreationRequest):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class PolicyUpdateRequest(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'description': 'str',
+        'applications': 'list[str]',
+        'grant': 'Grant',
+        'selectors': 'list[SelectorDefinition]',
+        '_for': 'list[ForSpec]',
+        '_if': 'list[IfExpression]',
+        'when': 'WhenSpec',
+        'how': 'HowSpec'
+    }
+
+    attribute_map = {
+        'description': 'description',
+        'applications': 'applications',
+        'grant': 'grant',
+        'selectors': 'selectors',
+        '_for': 'for',
+        '_if': 'if',
+        'when': 'when',
+        'how': 'how'
+    }
+
+    required_map = {
+        'description': 'optional',
+        'applications': 'optional',
+        'grant': 'required',
+        'selectors': 'required',
+        '_for': 'optional',
+        '_if': 'optional',
+        'when': 'required',
+        'how': 'optional'
+    }
+
+    def __init__(self, description=None, applications=None, grant=None, selectors=None, _for=None, _if=None, when=None, how=None):  # noqa: E501
+        """
+        PolicyUpdateRequest - a model defined in OpenAPI
+
+        :param description:  Description of what the policy will be used for
+        :type description: str
+        :param applications:  Applications this policy is used with
+        :type applications: list[str]
+        :param grant:  (required)
+        :type grant: finbourne_access.Grant
+        :param selectors:  Selectors that identify what resources this policy qualifies for (required)
+        :type selectors: list[finbourne_access.SelectorDefinition]
+        :param _for:  \"For Specification\" for when the policy is to be applied
+        :type _for: list[finbourne_access.ForSpec]
+        :param _if:  \"If Specification\" for when the policy is to be applied
+        :type _if: list[finbourne_access.IfExpression]
+        :param when:  (required)
+        :type when: finbourne_access.WhenSpec
+        :param how: 
+        :type how: finbourne_access.HowSpec
+
+        """  # noqa: E501
+
+        self._description = None
+        self._applications = None
+        self._grant = None
+        self._selectors = None
+        self.__for = None
+        self.__if = None
+        self._when = None
+        self._how = None
+        self.discriminator = None
+
+        self.description = description
+        self.applications = applications
+        self.grant = grant
+        self.selectors = selectors
+        self._for = _for
+        self._if = _if
+        self.when = when
+        if how is not None:
+            self.how = how
+
+    @property
+    def description(self):
+        """Gets the description of this PolicyUpdateRequest.  # noqa: E501
+
+        Description of what the policy will be used for  # noqa: E501
+
+        :return: The description of this PolicyUpdateRequest.  # noqa: E501
+        :rtype: str
+        """
+        return self._description
+
+    @description.setter
+    def description(self, description):
+        """Sets the description of this PolicyUpdateRequest.
+
+        Description of what the policy will be used for  # noqa: E501
+
+        :param description: The description of this PolicyUpdateRequest.  # noqa: E501
+        :type: str
+        """
+        if description is not None and len(description) > 1024:
+            raise ValueError("Invalid value for `description`, length must be less than or equal to `1024`")  # noqa: E501
+        if description is not None and len(description) < 0:
+            raise ValueError("Invalid value for `description`, length must be greater than or equal to `0`")  # noqa: E501
+
+        self._description = description
+
+    @property
+    def applications(self):
+        """Gets the applications of this PolicyUpdateRequest.  # noqa: E501
+
+        Applications this policy is used with  # noqa: E501
+
+        :return: The applications of this PolicyUpdateRequest.  # noqa: E501
+        :rtype: list[str]
+        """
+        return self._applications
+
+    @applications.setter
+    def applications(self, applications):
+        """Sets the applications of this PolicyUpdateRequest.
+
+        Applications this policy is used with  # noqa: E501
+
+        :param applications: The applications of this PolicyUpdateRequest.  # noqa: E501
+        :type: list[str]
+        """
+
+        self._applications = applications
+
+    @property
+    def grant(self):
+        """Gets the grant of this PolicyUpdateRequest.  # noqa: E501
+
+
+        :return: The grant of this PolicyUpdateRequest.  # noqa: E501
+        :rtype: Grant
+        """
+        return self._grant
+
+    @grant.setter
+    def grant(self, grant):
+        """Sets the grant of this PolicyUpdateRequest.
+
+
+        :param grant: The grant of this PolicyUpdateRequest.  # noqa: E501
+        :type: Grant
+        """
+        if grant is None:
+            raise ValueError("Invalid value for `grant`, must not be `None`")  # noqa: E501
+
+        self._grant = grant
+
+    @property
+    def selectors(self):
+        """Gets the selectors of this PolicyUpdateRequest.  # noqa: E501
+
+        Selectors that identify what resources this policy qualifies for  # noqa: E501
+
+        :return: The selectors of this PolicyUpdateRequest.  # noqa: E501
+        :rtype: list[SelectorDefinition]
+        """
+        return self._selectors
+
+    @selectors.setter
+    def selectors(self, selectors):
+        """Sets the selectors of this PolicyUpdateRequest.
+
+        Selectors that identify what resources this policy qualifies for  # noqa: E501
+
+        :param selectors: The selectors of this PolicyUpdateRequest.  # noqa: E501
+        :type: list[SelectorDefinition]
+        """
+        if selectors is None:
+            raise ValueError("Invalid value for `selectors`, must not be `None`")  # noqa: E501
+
+        self._selectors = selectors
+
+    @property
+    def _for(self):
+        """Gets the _for of this PolicyUpdateRequest.  # noqa: E501
+
+        \"For Specification\" for when the policy is to be applied  # noqa: E501
+
+        :return: The _for of this PolicyUpdateRequest.  # noqa: E501
+        :rtype: list[ForSpec]
+        """
+        return self.__for
+
+    @_for.setter
+    def _for(self, _for):
+        """Sets the _for of this PolicyUpdateRequest.
+
+        \"For Specification\" for when the policy is to be applied  # noqa: E501
+
+        :param _for: The _for of this PolicyUpdateRequest.  # noqa: E501
+        :type: list[ForSpec]
+        """
+
+        self.__for = _for
+
+    @property
+    def _if(self):
+        """Gets the _if of this PolicyUpdateRequest.  # noqa: E501
+
+        \"If Specification\" for when the policy is to be applied  # noqa: E501
+
+        :return: The _if of this PolicyUpdateRequest.  # noqa: E501
+        :rtype: list[IfExpression]
+        """
+        return self.__if
+
+    @_if.setter
+    def _if(self, _if):
+        """Sets the _if of this PolicyUpdateRequest.
+
+        \"If Specification\" for when the policy is to be applied  # noqa: E501
+
+        :param _if: The _if of this PolicyUpdateRequest.  # noqa: E501
+        :type: list[IfExpression]
+        """
+
+        self.__if = _if
+
+    @property
+    def when(self):
+        """Gets the when of this PolicyUpdateRequest.  # noqa: E501
+
+
+        :return: The when of this PolicyUpdateRequest.  # noqa: E501
+        :rtype: WhenSpec
+        """
+        return self._when
+
+    @when.setter
+    def when(self, when):
+        """Sets the when of this PolicyUpdateRequest.
+
+
+        :param when: The when of this PolicyUpdateRequest.  # noqa: E501
+        :type: WhenSpec
+        """
+        if when is None:
+            raise ValueError("Invalid value for `when`, must not be `None`")  # noqa: E501
+
+        self._when = when
+
+    @property
+    def how(self):
+        """Gets the how of this PolicyUpdateRequest.  # noqa: E501
+
+
+        :return: The how of this PolicyUpdateRequest.  # noqa: E501
+        :rtype: HowSpec
+        """
+        return self._how
+
+    @how.setter
+    def how(self, how):
+        """Sets the how of this PolicyUpdateRequest.
+
+
+        :param how: The how of this PolicyUpdateRequest.  # noqa: E501
+        :type: HowSpec
+        """
+
+        self._how = how
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, PolicyUpdateRequest):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/licence_selector_definition.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/metadata_selector_definition.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,217 +1,219 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class LicenceSelectorDefinition(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'code': 'str',
-        'action_ids': 'list[ActionId]',
-        'name': 'str',
-        'description': 'str'
-    }
-
-    attribute_map = {
-        'code': 'code',
-        'action_ids': 'actionIds',
-        'name': 'name',
-        'description': 'description'
-    }
-
-    required_map = {
-        'code': 'required',
-        'action_ids': 'required',
-        'name': 'optional',
-        'description': 'optional'
-    }
-
-    def __init__(self, code=None, action_ids=None, name=None, description=None):  # noqa: E501
-        """
-        LicenceSelectorDefinition - a model defined in OpenAPI
-
-        :param code:  The code of the licence (required)
-        :type code: str
-        :param action_ids:  (required)
-        :type action_ids: list[finbourne_access.ActionId]
-        :param name:  The name of this selector within the licence (for reporting and diagnostic purposes)
-        :type name: str
-        :param description:  A description of the point of this selector within this licence
-        :type description: str
-
-        """  # noqa: E501
-
-        self._code = None
-        self._action_ids = None
-        self._name = None
-        self._description = None
-        self.discriminator = None
-
-        self.code = code
-        self.action_ids = action_ids
-        self.name = name
-        self.description = description
-
-    @property
-    def code(self):
-        """Gets the code of this LicenceSelectorDefinition.  # noqa: E501
-
-        The code of the licence  # noqa: E501
-
-        :return: The code of this LicenceSelectorDefinition.  # noqa: E501
-        :rtype: str
-        """
-        return self._code
-
-    @code.setter
-    def code(self, code):
-        """Sets the code of this LicenceSelectorDefinition.
-
-        The code of the licence  # noqa: E501
-
-        :param code: The code of this LicenceSelectorDefinition.  # noqa: E501
-        :type: str
-        """
-        if code is None:
-            raise ValueError("Invalid value for `code`, must not be `None`")  # noqa: E501
-
-        self._code = code
-
-    @property
-    def action_ids(self):
-        """Gets the action_ids of this LicenceSelectorDefinition.  # noqa: E501
-
-
-        :return: The action_ids of this LicenceSelectorDefinition.  # noqa: E501
-        :rtype: list[ActionId]
-        """
-        return self._action_ids
-
-    @action_ids.setter
-    def action_ids(self, action_ids):
-        """Sets the action_ids of this LicenceSelectorDefinition.
-
-
-        :param action_ids: The action_ids of this LicenceSelectorDefinition.  # noqa: E501
-        :type: list[ActionId]
-        """
-        if action_ids is None:
-            raise ValueError("Invalid value for `action_ids`, must not be `None`")  # noqa: E501
-
-        self._action_ids = action_ids
-
-    @property
-    def name(self):
-        """Gets the name of this LicenceSelectorDefinition.  # noqa: E501
-
-        The name of this selector within the licence (for reporting and diagnostic purposes)  # noqa: E501
-
-        :return: The name of this LicenceSelectorDefinition.  # noqa: E501
-        :rtype: str
-        """
-        return self._name
-
-    @name.setter
-    def name(self, name):
-        """Sets the name of this LicenceSelectorDefinition.
-
-        The name of this selector within the licence (for reporting and diagnostic purposes)  # noqa: E501
-
-        :param name: The name of this LicenceSelectorDefinition.  # noqa: E501
-        :type: str
-        """
-
-        self._name = name
-
-    @property
-    def description(self):
-        """Gets the description of this LicenceSelectorDefinition.  # noqa: E501
-
-        A description of the point of this selector within this licence  # noqa: E501
-
-        :return: The description of this LicenceSelectorDefinition.  # noqa: E501
-        :rtype: str
-        """
-        return self._description
-
-    @description.setter
-    def description(self, description):
-        """Sets the description of this LicenceSelectorDefinition.
-
-        A description of the point of this selector within this licence  # noqa: E501
-
-        :param description: The description of this LicenceSelectorDefinition.  # noqa: E501
-        :type: str
-        """
-
-        self._description = description
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, LicenceSelectorDefinition):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class MetadataSelectorDefinition(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'expressions': 'list[MetadataExpression]',
+        'actions': 'list[ActionId]',
+        'name': 'str',
+        'description': 'str'
+    }
+
+    attribute_map = {
+        'expressions': 'expressions',
+        'actions': 'actions',
+        'name': 'name',
+        'description': 'description'
+    }
+
+    required_map = {
+        'expressions': 'required',
+        'actions': 'required',
+        'name': 'optional',
+        'description': 'optional'
+    }
+
+    def __init__(self, expressions=None, actions=None, name=None, description=None):  # noqa: E501
+        """
+        MetadataSelectorDefinition - a model defined in OpenAPI
+
+        :param expressions:  (required)
+        :type expressions: list[finbourne_access.MetadataExpression]
+        :param actions:  (required)
+        :type actions: list[finbourne_access.ActionId]
+        :param name: 
+        :type name: str
+        :param description: 
+        :type description: str
+
+        """  # noqa: E501
+
+        self._expressions = None
+        self._actions = None
+        self._name = None
+        self._description = None
+        self.discriminator = None
+
+        self.expressions = expressions
+        self.actions = actions
+        self.name = name
+        self.description = description
+
+    @property
+    def expressions(self):
+        """Gets the expressions of this MetadataSelectorDefinition.  # noqa: E501
+
+
+        :return: The expressions of this MetadataSelectorDefinition.  # noqa: E501
+        :rtype: list[MetadataExpression]
+        """
+        return self._expressions
+
+    @expressions.setter
+    def expressions(self, expressions):
+        """Sets the expressions of this MetadataSelectorDefinition.
+
+
+        :param expressions: The expressions of this MetadataSelectorDefinition.  # noqa: E501
+        :type: list[MetadataExpression]
+        """
+        if expressions is None:
+            raise ValueError("Invalid value for `expressions`, must not be `None`")  # noqa: E501
+
+        self._expressions = expressions
+
+    @property
+    def actions(self):
+        """Gets the actions of this MetadataSelectorDefinition.  # noqa: E501
+
+
+        :return: The actions of this MetadataSelectorDefinition.  # noqa: E501
+        :rtype: list[ActionId]
+        """
+        return self._actions
+
+    @actions.setter
+    def actions(self, actions):
+        """Sets the actions of this MetadataSelectorDefinition.
+
+
+        :param actions: The actions of this MetadataSelectorDefinition.  # noqa: E501
+        :type: list[ActionId]
+        """
+        if actions is None:
+            raise ValueError("Invalid value for `actions`, must not be `None`")  # noqa: E501
+
+        self._actions = actions
+
+    @property
+    def name(self):
+        """Gets the name of this MetadataSelectorDefinition.  # noqa: E501
+
+
+        :return: The name of this MetadataSelectorDefinition.  # noqa: E501
+        :rtype: str
+        """
+        return self._name
+
+    @name.setter
+    def name(self, name):
+        """Sets the name of this MetadataSelectorDefinition.
+
+
+        :param name: The name of this MetadataSelectorDefinition.  # noqa: E501
+        :type: str
+        """
+        if name is not None and len(name) > 100:
+            raise ValueError("Invalid value for `name`, length must be less than or equal to `100`")  # noqa: E501
+        if name is not None and len(name) < 0:
+            raise ValueError("Invalid value for `name`, length must be greater than or equal to `0`")  # noqa: E501
+
+        self._name = name
+
+    @property
+    def description(self):
+        """Gets the description of this MetadataSelectorDefinition.  # noqa: E501
+
+
+        :return: The description of this MetadataSelectorDefinition.  # noqa: E501
+        :rtype: str
+        """
+        return self._description
+
+    @description.setter
+    def description(self, description):
+        """Sets the description of this MetadataSelectorDefinition.
+
+
+        :param description: The description of this MetadataSelectorDefinition.  # noqa: E501
+        :type: str
+        """
+        if description is not None and len(description) > 1024:
+            raise ValueError("Invalid value for `description`, length must be less than or equal to `1024`")  # noqa: E501
+        if description is not None and len(description) < 0:
+            raise ValueError("Invalid value for `description`, length must be greater than or equal to `0`")  # noqa: E501
+
+        self._description = description
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, MetadataSelectorDefinition):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/link.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/role_update_request.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,213 +1,187 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class Link(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'relation': 'str',
-        'href': 'str',
-        'description': 'str',
-        'method': 'str'
-    }
-
-    attribute_map = {
-        'relation': 'relation',
-        'href': 'href',
-        'description': 'description',
-        'method': 'method'
-    }
-
-    required_map = {
-        'relation': 'required',
-        'href': 'required',
-        'description': 'optional',
-        'method': 'required'
-    }
-
-    def __init__(self, relation=None, href=None, description=None, method=None):  # noqa: E501
-        """
-        Link - a model defined in OpenAPI
-
-        :param relation:  (required)
-        :type relation: str
-        :param href:  (required)
-        :type href: str
-        :param description: 
-        :type description: str
-        :param method:  (required)
-        :type method: str
-
-        """  # noqa: E501
-
-        self._relation = None
-        self._href = None
-        self._description = None
-        self._method = None
-        self.discriminator = None
-
-        self.relation = relation
-        self.href = href
-        self.description = description
-        self.method = method
-
-    @property
-    def relation(self):
-        """Gets the relation of this Link.  # noqa: E501
-
-
-        :return: The relation of this Link.  # noqa: E501
-        :rtype: str
-        """
-        return self._relation
-
-    @relation.setter
-    def relation(self, relation):
-        """Sets the relation of this Link.
-
-
-        :param relation: The relation of this Link.  # noqa: E501
-        :type: str
-        """
-        if relation is None:
-            raise ValueError("Invalid value for `relation`, must not be `None`")  # noqa: E501
-
-        self._relation = relation
-
-    @property
-    def href(self):
-        """Gets the href of this Link.  # noqa: E501
-
-
-        :return: The href of this Link.  # noqa: E501
-        :rtype: str
-        """
-        return self._href
-
-    @href.setter
-    def href(self, href):
-        """Sets the href of this Link.
-
-
-        :param href: The href of this Link.  # noqa: E501
-        :type: str
-        """
-        if href is None:
-            raise ValueError("Invalid value for `href`, must not be `None`")  # noqa: E501
-
-        self._href = href
-
-    @property
-    def description(self):
-        """Gets the description of this Link.  # noqa: E501
-
-
-        :return: The description of this Link.  # noqa: E501
-        :rtype: str
-        """
-        return self._description
-
-    @description.setter
-    def description(self, description):
-        """Sets the description of this Link.
-
-
-        :param description: The description of this Link.  # noqa: E501
-        :type: str
-        """
-
-        self._description = description
-
-    @property
-    def method(self):
-        """Gets the method of this Link.  # noqa: E501
-
-
-        :return: The method of this Link.  # noqa: E501
-        :rtype: str
-        """
-        return self._method
-
-    @method.setter
-    def method(self, method):
-        """Sets the method of this Link.
-
-
-        :param method: The method of this Link.  # noqa: E501
-        :type: str
-        """
-        if method is None:
-            raise ValueError("Invalid value for `method`, must not be `None`")  # noqa: E501
-
-        self._method = method
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, Link):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class RoleUpdateRequest(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'description': 'str',
+        'resource': 'RoleResourceRequest',
+        'when': 'WhenSpec'
+    }
+
+    attribute_map = {
+        'description': 'description',
+        'resource': 'resource',
+        'when': 'when'
+    }
+
+    required_map = {
+        'description': 'optional',
+        'resource': 'required',
+        'when': 'required'
+    }
+
+    def __init__(self, description=None, resource=None, when=None):  # noqa: E501
+        """
+        RoleUpdateRequest - a model defined in OpenAPI
+
+        :param description: 
+        :type description: str
+        :param resource:  (required)
+        :type resource: finbourne_access.RoleResourceRequest
+        :param when:  (required)
+        :type when: finbourne_access.WhenSpec
+
+        """  # noqa: E501
+
+        self._description = None
+        self._resource = None
+        self._when = None
+        self.discriminator = None
+
+        self.description = description
+        self.resource = resource
+        self.when = when
+
+    @property
+    def description(self):
+        """Gets the description of this RoleUpdateRequest.  # noqa: E501
+
+
+        :return: The description of this RoleUpdateRequest.  # noqa: E501
+        :rtype: str
+        """
+        return self._description
+
+    @description.setter
+    def description(self, description):
+        """Sets the description of this RoleUpdateRequest.
+
+
+        :param description: The description of this RoleUpdateRequest.  # noqa: E501
+        :type: str
+        """
+        if description is not None and len(description) > 1024:
+            raise ValueError("Invalid value for `description`, length must be less than or equal to `1024`")  # noqa: E501
+        if description is not None and len(description) < 0:
+            raise ValueError("Invalid value for `description`, length must be greater than or equal to `0`")  # noqa: E501
+
+        self._description = description
+
+    @property
+    def resource(self):
+        """Gets the resource of this RoleUpdateRequest.  # noqa: E501
+
+
+        :return: The resource of this RoleUpdateRequest.  # noqa: E501
+        :rtype: RoleResourceRequest
+        """
+        return self._resource
+
+    @resource.setter
+    def resource(self, resource):
+        """Sets the resource of this RoleUpdateRequest.
+
+
+        :param resource: The resource of this RoleUpdateRequest.  # noqa: E501
+        :type: RoleResourceRequest
+        """
+        if resource is None:
+            raise ValueError("Invalid value for `resource`, must not be `None`")  # noqa: E501
+
+        self._resource = resource
+
+    @property
+    def when(self):
+        """Gets the when of this RoleUpdateRequest.  # noqa: E501
+
+
+        :return: The when of this RoleUpdateRequest.  # noqa: E501
+        :rtype: WhenSpec
+        """
+        return self._when
+
+    @when.setter
+    def when(self, when):
+        """Sets the when of this RoleUpdateRequest.
+
+
+        :param when: The when of this RoleUpdateRequest.  # noqa: E501
+        :type: WhenSpec
+        """
+        if when is None:
+            raise ValueError("Invalid value for `when`, must not be `None`")  # noqa: E501
+
+        self._when = when
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, RoleUpdateRequest):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/match_all_selector_definition.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/policy_collection_id.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,179 +1,161 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class MatchAllSelectorDefinition(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'actions': 'list[ActionId]',
-        'name': 'str',
-        'description': 'str'
-    }
-
-    attribute_map = {
-        'actions': 'actions',
-        'name': 'name',
-        'description': 'description'
-    }
-
-    required_map = {
-        'actions': 'optional',
-        'name': 'optional',
-        'description': 'optional'
-    }
-
-    def __init__(self, actions=None, name=None, description=None):  # noqa: E501
-        """
-        MatchAllSelectorDefinition - a model defined in OpenAPI
-
-        :param actions: 
-        :type actions: list[finbourne_access.ActionId]
-        :param name: 
-        :type name: str
-        :param description: 
-        :type description: str
-
-        """  # noqa: E501
-
-        self._actions = None
-        self._name = None
-        self._description = None
-        self.discriminator = None
-
-        self.actions = actions
-        self.name = name
-        self.description = description
-
-    @property
-    def actions(self):
-        """Gets the actions of this MatchAllSelectorDefinition.  # noqa: E501
-
-
-        :return: The actions of this MatchAllSelectorDefinition.  # noqa: E501
-        :rtype: list[ActionId]
-        """
-        return self._actions
-
-    @actions.setter
-    def actions(self, actions):
-        """Sets the actions of this MatchAllSelectorDefinition.
-
-
-        :param actions: The actions of this MatchAllSelectorDefinition.  # noqa: E501
-        :type: list[ActionId]
-        """
-
-        self._actions = actions
-
-    @property
-    def name(self):
-        """Gets the name of this MatchAllSelectorDefinition.  # noqa: E501
-
-
-        :return: The name of this MatchAllSelectorDefinition.  # noqa: E501
-        :rtype: str
-        """
-        return self._name
-
-    @name.setter
-    def name(self, name):
-        """Sets the name of this MatchAllSelectorDefinition.
-
-
-        :param name: The name of this MatchAllSelectorDefinition.  # noqa: E501
-        :type: str
-        """
-
-        self._name = name
-
-    @property
-    def description(self):
-        """Gets the description of this MatchAllSelectorDefinition.  # noqa: E501
-
-
-        :return: The description of this MatchAllSelectorDefinition.  # noqa: E501
-        :rtype: str
-        """
-        return self._description
-
-    @description.setter
-    def description(self, description):
-        """Sets the description of this MatchAllSelectorDefinition.
-
-
-        :param description: The description of this MatchAllSelectorDefinition.  # noqa: E501
-        :type: str
-        """
-
-        self._description = description
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, MatchAllSelectorDefinition):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class PolicyCollectionId(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'scope': 'str',
+        'code': 'str'
+    }
+
+    attribute_map = {
+        'scope': 'scope',
+        'code': 'code'
+    }
+
+    required_map = {
+        'scope': 'optional',
+        'code': 'required'
+    }
+
+    def __init__(self, scope=None, code=None):  # noqa: E501
+        """
+        PolicyCollectionId - a model defined in OpenAPI
+
+        :param scope: 
+        :type scope: str
+        :param code:  (required)
+        :type code: str
+
+        """  # noqa: E501
+
+        self._scope = None
+        self._code = None
+        self.discriminator = None
+
+        self.scope = scope
+        self.code = code
+
+    @property
+    def scope(self):
+        """Gets the scope of this PolicyCollectionId.  # noqa: E501
+
+
+        :return: The scope of this PolicyCollectionId.  # noqa: E501
+        :rtype: str
+        """
+        return self._scope
+
+    @scope.setter
+    def scope(self, scope):
+        """Sets the scope of this PolicyCollectionId.
+
+
+        :param scope: The scope of this PolicyCollectionId.  # noqa: E501
+        :type: str
+        """
+        if scope is not None and len(scope) > 100:
+            raise ValueError("Invalid value for `scope`, length must be less than or equal to `100`")  # noqa: E501
+        if scope is not None and len(scope) < 3:
+            raise ValueError("Invalid value for `scope`, length must be greater than or equal to `3`")  # noqa: E501
+
+        self._scope = scope
+
+    @property
+    def code(self):
+        """Gets the code of this PolicyCollectionId.  # noqa: E501
+
+
+        :return: The code of this PolicyCollectionId.  # noqa: E501
+        :rtype: str
+        """
+        return self._code
+
+    @code.setter
+    def code(self, code):
+        """Sets the code of this PolicyCollectionId.
+
+
+        :param code: The code of this PolicyCollectionId.  # noqa: E501
+        :type: str
+        """
+        if code is None:
+            raise ValueError("Invalid value for `code`, must not be `None`")  # noqa: E501
+        if code is not None and len(code) > 100:
+            raise ValueError("Invalid value for `code`, length must be less than or equal to `100`")  # noqa: E501
+        if code is not None and len(code) < 3:
+            raise ValueError("Invalid value for `code`, length must be greater than or equal to `3`")  # noqa: E501
+
+        self._code = code
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, PolicyCollectionId):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/metadata_expression.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/metadata_expression.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,185 +1,185 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class MetadataExpression(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'metadata_key': 'str',
-        'operator': 'Operator',
-        'text_value': 'str'
-    }
-
-    attribute_map = {
-        'metadata_key': 'metadataKey',
-        'operator': 'operator',
-        'text_value': 'textValue'
-    }
-
-    required_map = {
-        'metadata_key': 'required',
-        'operator': 'required',
-        'text_value': 'optional'
-    }
-
-    def __init__(self, metadata_key=None, operator=None, text_value=None):  # noqa: E501
-        """
-        MetadataExpression - a model defined in OpenAPI
-
-        :param metadata_key:  (required)
-        :type metadata_key: str
-        :param operator:  (required)
-        :type operator: finbourne_access.Operator
-        :param text_value: 
-        :type text_value: str
-
-        """  # noqa: E501
-
-        self._metadata_key = None
-        self._operator = None
-        self._text_value = None
-        self.discriminator = None
-
-        self.metadata_key = metadata_key
-        self.operator = operator
-        self.text_value = text_value
-
-    @property
-    def metadata_key(self):
-        """Gets the metadata_key of this MetadataExpression.  # noqa: E501
-
-
-        :return: The metadata_key of this MetadataExpression.  # noqa: E501
-        :rtype: str
-        """
-        return self._metadata_key
-
-    @metadata_key.setter
-    def metadata_key(self, metadata_key):
-        """Sets the metadata_key of this MetadataExpression.
-
-
-        :param metadata_key: The metadata_key of this MetadataExpression.  # noqa: E501
-        :type: str
-        """
-        if metadata_key is None:
-            raise ValueError("Invalid value for `metadata_key`, must not be `None`")  # noqa: E501
-        if metadata_key is not None and len(metadata_key) < 1:
-            raise ValueError("Invalid value for `metadata_key`, length must be greater than or equal to `1`")  # noqa: E501
-
-        self._metadata_key = metadata_key
-
-    @property
-    def operator(self):
-        """Gets the operator of this MetadataExpression.  # noqa: E501
-
-
-        :return: The operator of this MetadataExpression.  # noqa: E501
-        :rtype: Operator
-        """
-        return self._operator
-
-    @operator.setter
-    def operator(self, operator):
-        """Sets the operator of this MetadataExpression.
-
-
-        :param operator: The operator of this MetadataExpression.  # noqa: E501
-        :type: Operator
-        """
-        if operator is None:
-            raise ValueError("Invalid value for `operator`, must not be `None`")  # noqa: E501
-
-        self._operator = operator
-
-    @property
-    def text_value(self):
-        """Gets the text_value of this MetadataExpression.  # noqa: E501
-
-
-        :return: The text_value of this MetadataExpression.  # noqa: E501
-        :rtype: str
-        """
-        return self._text_value
-
-    @text_value.setter
-    def text_value(self, text_value):
-        """Sets the text_value of this MetadataExpression.
-
-
-        :param text_value: The text_value of this MetadataExpression.  # noqa: E501
-        :type: str
-        """
-
-        self._text_value = text_value
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, MetadataExpression):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class MetadataExpression(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'metadata_key': 'str',
+        'operator': 'Operator',
+        'text_value': 'str'
+    }
+
+    attribute_map = {
+        'metadata_key': 'metadataKey',
+        'operator': 'operator',
+        'text_value': 'textValue'
+    }
+
+    required_map = {
+        'metadata_key': 'required',
+        'operator': 'required',
+        'text_value': 'optional'
+    }
+
+    def __init__(self, metadata_key=None, operator=None, text_value=None):  # noqa: E501
+        """
+        MetadataExpression - a model defined in OpenAPI
+
+        :param metadata_key:  (required)
+        :type metadata_key: str
+        :param operator:  (required)
+        :type operator: finbourne_access.Operator
+        :param text_value: 
+        :type text_value: str
+
+        """  # noqa: E501
+
+        self._metadata_key = None
+        self._operator = None
+        self._text_value = None
+        self.discriminator = None
+
+        self.metadata_key = metadata_key
+        self.operator = operator
+        self.text_value = text_value
+
+    @property
+    def metadata_key(self):
+        """Gets the metadata_key of this MetadataExpression.  # noqa: E501
+
+
+        :return: The metadata_key of this MetadataExpression.  # noqa: E501
+        :rtype: str
+        """
+        return self._metadata_key
+
+    @metadata_key.setter
+    def metadata_key(self, metadata_key):
+        """Sets the metadata_key of this MetadataExpression.
+
+
+        :param metadata_key: The metadata_key of this MetadataExpression.  # noqa: E501
+        :type: str
+        """
+        if metadata_key is None:
+            raise ValueError("Invalid value for `metadata_key`, must not be `None`")  # noqa: E501
+        if metadata_key is not None and len(metadata_key) < 1:
+            raise ValueError("Invalid value for `metadata_key`, length must be greater than or equal to `1`")  # noqa: E501
+
+        self._metadata_key = metadata_key
+
+    @property
+    def operator(self):
+        """Gets the operator of this MetadataExpression.  # noqa: E501
+
+
+        :return: The operator of this MetadataExpression.  # noqa: E501
+        :rtype: Operator
+        """
+        return self._operator
+
+    @operator.setter
+    def operator(self, operator):
+        """Sets the operator of this MetadataExpression.
+
+
+        :param operator: The operator of this MetadataExpression.  # noqa: E501
+        :type: Operator
+        """
+        if operator is None:
+            raise ValueError("Invalid value for `operator`, must not be `None`")  # noqa: E501
+
+        self._operator = operator
+
+    @property
+    def text_value(self):
+        """Gets the text_value of this MetadataExpression.  # noqa: E501
+
+
+        :return: The text_value of this MetadataExpression.  # noqa: E501
+        :rtype: str
+        """
+        return self._text_value
+
+    @text_value.setter
+    def text_value(self, text_value):
+        """Sets the text_value of this MetadataExpression.
+
+
+        :param text_value: The text_value of this MetadataExpression.  # noqa: E501
+        :type: str
+        """
+
+        self._text_value = text_value
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, MetadataExpression):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/metadata_selector_definition.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/match_all_selector_definition.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,207 +1,189 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class MetadataSelectorDefinition(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'expressions': 'list[MetadataExpression]',
-        'actions': 'list[ActionId]',
-        'name': 'str',
-        'description': 'str'
-    }
-
-    attribute_map = {
-        'expressions': 'expressions',
-        'actions': 'actions',
-        'name': 'name',
-        'description': 'description'
-    }
-
-    required_map = {
-        'expressions': 'optional',
-        'actions': 'optional',
-        'name': 'optional',
-        'description': 'optional'
-    }
-
-    def __init__(self, expressions=None, actions=None, name=None, description=None):  # noqa: E501
-        """
-        MetadataSelectorDefinition - a model defined in OpenAPI
-
-        :param expressions: 
-        :type expressions: list[finbourne_access.MetadataExpression]
-        :param actions: 
-        :type actions: list[finbourne_access.ActionId]
-        :param name: 
-        :type name: str
-        :param description: 
-        :type description: str
-
-        """  # noqa: E501
-
-        self._expressions = None
-        self._actions = None
-        self._name = None
-        self._description = None
-        self.discriminator = None
-
-        self.expressions = expressions
-        self.actions = actions
-        self.name = name
-        self.description = description
-
-    @property
-    def expressions(self):
-        """Gets the expressions of this MetadataSelectorDefinition.  # noqa: E501
-
-
-        :return: The expressions of this MetadataSelectorDefinition.  # noqa: E501
-        :rtype: list[MetadataExpression]
-        """
-        return self._expressions
-
-    @expressions.setter
-    def expressions(self, expressions):
-        """Sets the expressions of this MetadataSelectorDefinition.
-
-
-        :param expressions: The expressions of this MetadataSelectorDefinition.  # noqa: E501
-        :type: list[MetadataExpression]
-        """
-
-        self._expressions = expressions
-
-    @property
-    def actions(self):
-        """Gets the actions of this MetadataSelectorDefinition.  # noqa: E501
-
-
-        :return: The actions of this MetadataSelectorDefinition.  # noqa: E501
-        :rtype: list[ActionId]
-        """
-        return self._actions
-
-    @actions.setter
-    def actions(self, actions):
-        """Sets the actions of this MetadataSelectorDefinition.
-
-
-        :param actions: The actions of this MetadataSelectorDefinition.  # noqa: E501
-        :type: list[ActionId]
-        """
-
-        self._actions = actions
-
-    @property
-    def name(self):
-        """Gets the name of this MetadataSelectorDefinition.  # noqa: E501
-
-
-        :return: The name of this MetadataSelectorDefinition.  # noqa: E501
-        :rtype: str
-        """
-        return self._name
-
-    @name.setter
-    def name(self, name):
-        """Sets the name of this MetadataSelectorDefinition.
-
-
-        :param name: The name of this MetadataSelectorDefinition.  # noqa: E501
-        :type: str
-        """
-
-        self._name = name
-
-    @property
-    def description(self):
-        """Gets the description of this MetadataSelectorDefinition.  # noqa: E501
-
-
-        :return: The description of this MetadataSelectorDefinition.  # noqa: E501
-        :rtype: str
-        """
-        return self._description
-
-    @description.setter
-    def description(self, description):
-        """Sets the description of this MetadataSelectorDefinition.
-
-
-        :param description: The description of this MetadataSelectorDefinition.  # noqa: E501
-        :type: str
-        """
-
-        self._description = description
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, MetadataSelectorDefinition):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class MatchAllSelectorDefinition(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'actions': 'list[ActionId]',
+        'name': 'str',
+        'description': 'str'
+    }
+
+    attribute_map = {
+        'actions': 'actions',
+        'name': 'name',
+        'description': 'description'
+    }
+
+    required_map = {
+        'actions': 'required',
+        'name': 'optional',
+        'description': 'optional'
+    }
+
+    def __init__(self, actions=None, name=None, description=None):  # noqa: E501
+        """
+        MatchAllSelectorDefinition - a model defined in OpenAPI
+
+        :param actions:  (required)
+        :type actions: list[finbourne_access.ActionId]
+        :param name: 
+        :type name: str
+        :param description: 
+        :type description: str
+
+        """  # noqa: E501
+
+        self._actions = None
+        self._name = None
+        self._description = None
+        self.discriminator = None
+
+        self.actions = actions
+        self.name = name
+        self.description = description
+
+    @property
+    def actions(self):
+        """Gets the actions of this MatchAllSelectorDefinition.  # noqa: E501
+
+
+        :return: The actions of this MatchAllSelectorDefinition.  # noqa: E501
+        :rtype: list[ActionId]
+        """
+        return self._actions
+
+    @actions.setter
+    def actions(self, actions):
+        """Sets the actions of this MatchAllSelectorDefinition.
+
+
+        :param actions: The actions of this MatchAllSelectorDefinition.  # noqa: E501
+        :type: list[ActionId]
+        """
+        if actions is None:
+            raise ValueError("Invalid value for `actions`, must not be `None`")  # noqa: E501
+
+        self._actions = actions
+
+    @property
+    def name(self):
+        """Gets the name of this MatchAllSelectorDefinition.  # noqa: E501
+
+
+        :return: The name of this MatchAllSelectorDefinition.  # noqa: E501
+        :rtype: str
+        """
+        return self._name
+
+    @name.setter
+    def name(self, name):
+        """Sets the name of this MatchAllSelectorDefinition.
+
+
+        :param name: The name of this MatchAllSelectorDefinition.  # noqa: E501
+        :type: str
+        """
+        if name is not None and len(name) > 100:
+            raise ValueError("Invalid value for `name`, length must be less than or equal to `100`")  # noqa: E501
+        if name is not None and len(name) < 0:
+            raise ValueError("Invalid value for `name`, length must be greater than or equal to `0`")  # noqa: E501
+
+        self._name = name
+
+    @property
+    def description(self):
+        """Gets the description of this MatchAllSelectorDefinition.  # noqa: E501
+
+
+        :return: The description of this MatchAllSelectorDefinition.  # noqa: E501
+        :rtype: str
+        """
+        return self._description
+
+    @description.setter
+    def description(self, description):
+        """Sets the description of this MatchAllSelectorDefinition.
+
+
+        :param description: The description of this MatchAllSelectorDefinition.  # noqa: E501
+        :type: str
+        """
+        if description is not None and len(description) > 1024:
+            raise ValueError("Invalid value for `description`, length must be less than or equal to `1024`")  # noqa: E501
+        if description is not None and len(description) < 0:
+            raise ValueError("Invalid value for `description`, length must be greater than or equal to `0`")  # noqa: E501
+
+        self._description = description
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, MatchAllSelectorDefinition):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/non_transitive_supervisor_role_resource.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/non_transitive_supervisor_role_resource.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,123 +1,125 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class NonTransitiveSupervisorRoleResource(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'roles': 'list[dict(str, str)]'
-    }
-
-    attribute_map = {
-        'roles': 'roles'
-    }
-
-    required_map = {
-        'roles': 'optional'
-    }
-
-    def __init__(self, roles=None):  # noqa: E501
-        """
-        NonTransitiveSupervisorRoleResource - a model defined in OpenAPI
-
-        :param roles: 
-        :type roles: list[dict(str, str)]
-
-        """  # noqa: E501
-
-        self._roles = None
-        self.discriminator = None
-
-        self.roles = roles
-
-    @property
-    def roles(self):
-        """Gets the roles of this NonTransitiveSupervisorRoleResource.  # noqa: E501
-
-
-        :return: The roles of this NonTransitiveSupervisorRoleResource.  # noqa: E501
-        :rtype: list[dict(str, str)]
-        """
-        return self._roles
-
-    @roles.setter
-    def roles(self, roles):
-        """Sets the roles of this NonTransitiveSupervisorRoleResource.
-
-
-        :param roles: The roles of this NonTransitiveSupervisorRoleResource.  # noqa: E501
-        :type: list[dict(str, str)]
-        """
-
-        self._roles = roles
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, NonTransitiveSupervisorRoleResource):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class NonTransitiveSupervisorRoleResource(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'roles': 'list[dict(str, str)]'
+    }
+
+    attribute_map = {
+        'roles': 'roles'
+    }
+
+    required_map = {
+        'roles': 'required'
+    }
+
+    def __init__(self, roles=None):  # noqa: E501
+        """
+        NonTransitiveSupervisorRoleResource - a model defined in OpenAPI
+
+        :param roles:  (required)
+        :type roles: list[dict(str, str)]
+
+        """  # noqa: E501
+
+        self._roles = None
+        self.discriminator = None
+
+        self.roles = roles
+
+    @property
+    def roles(self):
+        """Gets the roles of this NonTransitiveSupervisorRoleResource.  # noqa: E501
+
+
+        :return: The roles of this NonTransitiveSupervisorRoleResource.  # noqa: E501
+        :rtype: list[dict(str, str)]
+        """
+        return self._roles
+
+    @roles.setter
+    def roles(self, roles):
+        """Sets the roles of this NonTransitiveSupervisorRoleResource.
+
+
+        :param roles: The roles of this NonTransitiveSupervisorRoleResource.  # noqa: E501
+        :type: list[dict(str, str)]
+        """
+        if roles is None:
+            raise ValueError("Invalid value for `roles`, must not be `None`")  # noqa: E501
+
+        self._roles = roles
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, NonTransitiveSupervisorRoleResource):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/operator.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/relative_to_date_time.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,107 +1,106 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class Operator(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    allowed enum values
-    """
-    UNDEFINED = "Undefined"
-    EQUALS = "Equals"
-    NOTEQUALS = "NotEquals"
-    GREATERTHAN = "GreaterThan"
-    GREATERTHANOREQUALTO = "GreaterThanOrEqualTo"
-    LESSTHAN = "LessThan"
-    LESSTHANOREQUALTO = "LessThanOrEqualTo"
-    IN = "In"
-
-    allowable_values = [UNDEFINED, EQUALS, NOTEQUALS, GREATERTHAN, GREATERTHANOREQUALTO, LESSTHAN, LESSTHANOREQUALTO, IN]  # noqa: E501
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-    }
-
-    attribute_map = {
-    }
-
-    required_map = {
-    }
-
-    def __init__(self):  # noqa: E501
-        """
-        Operator - a model defined in OpenAPI
-
-
-        """  # noqa: E501
-        self.discriminator = None
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, Operator):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class RelativeToDateTime(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    allowed enum values
+    """
+    UNDEFINED = "Undefined"
+    BEFOREORON = "BeforeOrOn"
+    BEFORE = "Before"
+    ONDAYOF = "OnDayOf"
+    AFTERORON = "AfterOrOn"
+    AFTER = "After"
+    EXACTLY = "Exactly"
+
+    allowable_values = [UNDEFINED, BEFOREORON, BEFORE, ONDAYOF, AFTERORON, AFTER, EXACTLY]  # noqa: E501
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+    }
+
+    attribute_map = {
+    }
+
+    required_map = {
+    }
+
+    def __init__(self):  # noqa: E501
+        """
+        RelativeToDateTime - a model defined in OpenAPI
+
+
+        """  # noqa: E501
+        self.discriminator = None
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, RelativeToDateTime):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/policy_collection_creation_request.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/policy_collection_creation_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,257 +1,257 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class PolicyCollectionCreationRequest(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'code': 'str',
-        'policies': 'list[PolicyId]',
-        'metadata': 'dict(str, list[EntitlementMetadata])',
-        'policy_collections': 'list[PolicyCollectionId]',
-        'description': 'str'
-    }
-
-    attribute_map = {
-        'code': 'code',
-        'policies': 'policies',
-        'metadata': 'metadata',
-        'policy_collections': 'policyCollections',
-        'description': 'description'
-    }
-
-    required_map = {
-        'code': 'required',
-        'policies': 'optional',
-        'metadata': 'optional',
-        'policy_collections': 'optional',
-        'description': 'optional'
-    }
-
-    def __init__(self, code=None, policies=None, metadata=None, policy_collections=None, description=None):  # noqa: E501
-        """
-        PolicyCollectionCreationRequest - a model defined in OpenAPI
-
-        :param code:  The identifier for the PolicyCollection being created (required)
-        :type code: str
-        :param policies:  The identifiers of the Policies in this collection
-        :type policies: list[finbourne_access.PolicyId]
-        :param metadata:  Any relevant metadata associated with this resource for controlling access to this resource
-        :type metadata: dict(str, list[EntitlementMetadata])
-        :param policy_collections:  The identifiers of the PolicyCollections in this collection
-        :type policy_collections: list[finbourne_access.PolicyCollectionId]
-        :param description:  A description of this policy collection
-        :type description: str
-
-        """  # noqa: E501
-
-        self._code = None
-        self._policies = None
-        self._metadata = None
-        self._policy_collections = None
-        self._description = None
-        self.discriminator = None
-
-        self.code = code
-        self.policies = policies
-        self.metadata = metadata
-        self.policy_collections = policy_collections
-        self.description = description
-
-    @property
-    def code(self):
-        """Gets the code of this PolicyCollectionCreationRequest.  # noqa: E501
-
-        The identifier for the PolicyCollection being created  # noqa: E501
-
-        :return: The code of this PolicyCollectionCreationRequest.  # noqa: E501
-        :rtype: str
-        """
-        return self._code
-
-    @code.setter
-    def code(self, code):
-        """Sets the code of this PolicyCollectionCreationRequest.
-
-        The identifier for the PolicyCollection being created  # noqa: E501
-
-        :param code: The code of this PolicyCollectionCreationRequest.  # noqa: E501
-        :type: str
-        """
-        if code is None:
-            raise ValueError("Invalid value for `code`, must not be `None`")  # noqa: E501
-        if code is not None and len(code) > 100:
-            raise ValueError("Invalid value for `code`, length must be less than or equal to `100`")  # noqa: E501
-        if code is not None and len(code) < 3:
-            raise ValueError("Invalid value for `code`, length must be greater than or equal to `3`")  # noqa: E501
-        if (code is not None and not re.search(r'^[a-zA-Z][a-zA-Z0-9-_ +]{2,100}$', code)):  # noqa: E501
-            raise ValueError(r"Invalid value for `code`, must be a follow pattern or equal to `/^[a-zA-Z][a-zA-Z0-9-_ +]{2,100}$/`")  # noqa: E501
-
-        self._code = code
-
-    @property
-    def policies(self):
-        """Gets the policies of this PolicyCollectionCreationRequest.  # noqa: E501
-
-        The identifiers of the Policies in this collection  # noqa: E501
-
-        :return: The policies of this PolicyCollectionCreationRequest.  # noqa: E501
-        :rtype: list[PolicyId]
-        """
-        return self._policies
-
-    @policies.setter
-    def policies(self, policies):
-        """Sets the policies of this PolicyCollectionCreationRequest.
-
-        The identifiers of the Policies in this collection  # noqa: E501
-
-        :param policies: The policies of this PolicyCollectionCreationRequest.  # noqa: E501
-        :type: list[PolicyId]
-        """
-
-        self._policies = policies
-
-    @property
-    def metadata(self):
-        """Gets the metadata of this PolicyCollectionCreationRequest.  # noqa: E501
-
-        Any relevant metadata associated with this resource for controlling access to this resource  # noqa: E501
-
-        :return: The metadata of this PolicyCollectionCreationRequest.  # noqa: E501
-        :rtype: dict(str, list[EntitlementMetadata])
-        """
-        return self._metadata
-
-    @metadata.setter
-    def metadata(self, metadata):
-        """Sets the metadata of this PolicyCollectionCreationRequest.
-
-        Any relevant metadata associated with this resource for controlling access to this resource  # noqa: E501
-
-        :param metadata: The metadata of this PolicyCollectionCreationRequest.  # noqa: E501
-        :type: dict(str, list[EntitlementMetadata])
-        """
-
-        self._metadata = metadata
-
-    @property
-    def policy_collections(self):
-        """Gets the policy_collections of this PolicyCollectionCreationRequest.  # noqa: E501
-
-        The identifiers of the PolicyCollections in this collection  # noqa: E501
-
-        :return: The policy_collections of this PolicyCollectionCreationRequest.  # noqa: E501
-        :rtype: list[PolicyCollectionId]
-        """
-        return self._policy_collections
-
-    @policy_collections.setter
-    def policy_collections(self, policy_collections):
-        """Sets the policy_collections of this PolicyCollectionCreationRequest.
-
-        The identifiers of the PolicyCollections in this collection  # noqa: E501
-
-        :param policy_collections: The policy_collections of this PolicyCollectionCreationRequest.  # noqa: E501
-        :type: list[PolicyCollectionId]
-        """
-
-        self._policy_collections = policy_collections
-
-    @property
-    def description(self):
-        """Gets the description of this PolicyCollectionCreationRequest.  # noqa: E501
-
-        A description of this policy collection  # noqa: E501
-
-        :return: The description of this PolicyCollectionCreationRequest.  # noqa: E501
-        :rtype: str
-        """
-        return self._description
-
-    @description.setter
-    def description(self, description):
-        """Sets the description of this PolicyCollectionCreationRequest.
-
-        A description of this policy collection  # noqa: E501
-
-        :param description: The description of this PolicyCollectionCreationRequest.  # noqa: E501
-        :type: str
-        """
-        if description is not None and len(description) > 1024:
-            raise ValueError("Invalid value for `description`, length must be less than or equal to `1024`")  # noqa: E501
-        if description is not None and len(description) < 0:
-            raise ValueError("Invalid value for `description`, length must be greater than or equal to `0`")  # noqa: E501
-
-        self._description = description
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, PolicyCollectionCreationRequest):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class PolicyCollectionCreationRequest(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'code': 'str',
+        'policies': 'list[PolicyId]',
+        'metadata': 'dict(str, list[EntitlementMetadata])',
+        'policy_collections': 'list[PolicyCollectionId]',
+        'description': 'str'
+    }
+
+    attribute_map = {
+        'code': 'code',
+        'policies': 'policies',
+        'metadata': 'metadata',
+        'policy_collections': 'policyCollections',
+        'description': 'description'
+    }
+
+    required_map = {
+        'code': 'required',
+        'policies': 'optional',
+        'metadata': 'optional',
+        'policy_collections': 'optional',
+        'description': 'optional'
+    }
+
+    def __init__(self, code=None, policies=None, metadata=None, policy_collections=None, description=None):  # noqa: E501
+        """
+        PolicyCollectionCreationRequest - a model defined in OpenAPI
+
+        :param code:  The identifier for the PolicyCollection being created (required)
+        :type code: str
+        :param policies:  The identifiers of the Policies in this collection
+        :type policies: list[finbourne_access.PolicyId]
+        :param metadata:  Any relevant metadata associated with this resource for controlling access to this resource
+        :type metadata: dict(str, list[EntitlementMetadata])
+        :param policy_collections:  The identifiers of the PolicyCollections in this collection
+        :type policy_collections: list[finbourne_access.PolicyCollectionId]
+        :param description:  A description of this policy collection
+        :type description: str
+
+        """  # noqa: E501
+
+        self._code = None
+        self._policies = None
+        self._metadata = None
+        self._policy_collections = None
+        self._description = None
+        self.discriminator = None
+
+        self.code = code
+        self.policies = policies
+        self.metadata = metadata
+        self.policy_collections = policy_collections
+        self.description = description
+
+    @property
+    def code(self):
+        """Gets the code of this PolicyCollectionCreationRequest.  # noqa: E501
+
+        The identifier for the PolicyCollection being created  # noqa: E501
+
+        :return: The code of this PolicyCollectionCreationRequest.  # noqa: E501
+        :rtype: str
+        """
+        return self._code
+
+    @code.setter
+    def code(self, code):
+        """Sets the code of this PolicyCollectionCreationRequest.
+
+        The identifier for the PolicyCollection being created  # noqa: E501
+
+        :param code: The code of this PolicyCollectionCreationRequest.  # noqa: E501
+        :type: str
+        """
+        if code is None:
+            raise ValueError("Invalid value for `code`, must not be `None`")  # noqa: E501
+        if code is not None and len(code) > 100:
+            raise ValueError("Invalid value for `code`, length must be less than or equal to `100`")  # noqa: E501
+        if code is not None and len(code) < 3:
+            raise ValueError("Invalid value for `code`, length must be greater than or equal to `3`")  # noqa: E501
+        if (code is not None and not re.search(r'^[a-zA-Z][a-zA-Z0-9-_ +]{2,100}$', code)):  # noqa: E501
+            raise ValueError(r"Invalid value for `code`, must be a follow pattern or equal to `/^[a-zA-Z][a-zA-Z0-9-_ +]{2,100}$/`")  # noqa: E501
+
+        self._code = code
+
+    @property
+    def policies(self):
+        """Gets the policies of this PolicyCollectionCreationRequest.  # noqa: E501
+
+        The identifiers of the Policies in this collection  # noqa: E501
+
+        :return: The policies of this PolicyCollectionCreationRequest.  # noqa: E501
+        :rtype: list[PolicyId]
+        """
+        return self._policies
+
+    @policies.setter
+    def policies(self, policies):
+        """Sets the policies of this PolicyCollectionCreationRequest.
+
+        The identifiers of the Policies in this collection  # noqa: E501
+
+        :param policies: The policies of this PolicyCollectionCreationRequest.  # noqa: E501
+        :type: list[PolicyId]
+        """
+
+        self._policies = policies
+
+    @property
+    def metadata(self):
+        """Gets the metadata of this PolicyCollectionCreationRequest.  # noqa: E501
+
+        Any relevant metadata associated with this resource for controlling access to this resource  # noqa: E501
+
+        :return: The metadata of this PolicyCollectionCreationRequest.  # noqa: E501
+        :rtype: dict(str, list[EntitlementMetadata])
+        """
+        return self._metadata
+
+    @metadata.setter
+    def metadata(self, metadata):
+        """Sets the metadata of this PolicyCollectionCreationRequest.
+
+        Any relevant metadata associated with this resource for controlling access to this resource  # noqa: E501
+
+        :param metadata: The metadata of this PolicyCollectionCreationRequest.  # noqa: E501
+        :type: dict(str, list[EntitlementMetadata])
+        """
+
+        self._metadata = metadata
+
+    @property
+    def policy_collections(self):
+        """Gets the policy_collections of this PolicyCollectionCreationRequest.  # noqa: E501
+
+        The identifiers of the PolicyCollections in this collection  # noqa: E501
+
+        :return: The policy_collections of this PolicyCollectionCreationRequest.  # noqa: E501
+        :rtype: list[PolicyCollectionId]
+        """
+        return self._policy_collections
+
+    @policy_collections.setter
+    def policy_collections(self, policy_collections):
+        """Sets the policy_collections of this PolicyCollectionCreationRequest.
+
+        The identifiers of the PolicyCollections in this collection  # noqa: E501
+
+        :param policy_collections: The policy_collections of this PolicyCollectionCreationRequest.  # noqa: E501
+        :type: list[PolicyCollectionId]
+        """
+
+        self._policy_collections = policy_collections
+
+    @property
+    def description(self):
+        """Gets the description of this PolicyCollectionCreationRequest.  # noqa: E501
+
+        A description of this policy collection  # noqa: E501
+
+        :return: The description of this PolicyCollectionCreationRequest.  # noqa: E501
+        :rtype: str
+        """
+        return self._description
+
+    @description.setter
+    def description(self, description):
+        """Sets the description of this PolicyCollectionCreationRequest.
+
+        A description of this policy collection  # noqa: E501
+
+        :param description: The description of this PolicyCollectionCreationRequest.  # noqa: E501
+        :type: str
+        """
+        if description is not None and len(description) > 1024:
+            raise ValueError("Invalid value for `description`, length must be less than or equal to `1024`")  # noqa: E501
+        if description is not None and len(description) < 0:
+            raise ValueError("Invalid value for `description`, length must be greater than or equal to `0`")  # noqa: E501
+
+        self._description = description
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, PolicyCollectionCreationRequest):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/policy_collection_id.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/role_id.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,161 +1,161 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class PolicyCollectionId(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'scope': 'str',
-        'code': 'str'
-    }
-
-    attribute_map = {
-        'scope': 'scope',
-        'code': 'code'
-    }
-
-    required_map = {
-        'scope': 'optional',
-        'code': 'required'
-    }
-
-    def __init__(self, scope=None, code=None):  # noqa: E501
-        """
-        PolicyCollectionId - a model defined in OpenAPI
-
-        :param scope: 
-        :type scope: str
-        :param code:  (required)
-        :type code: str
-
-        """  # noqa: E501
-
-        self._scope = None
-        self._code = None
-        self.discriminator = None
-
-        self.scope = scope
-        self.code = code
-
-    @property
-    def scope(self):
-        """Gets the scope of this PolicyCollectionId.  # noqa: E501
-
-
-        :return: The scope of this PolicyCollectionId.  # noqa: E501
-        :rtype: str
-        """
-        return self._scope
-
-    @scope.setter
-    def scope(self, scope):
-        """Sets the scope of this PolicyCollectionId.
-
-
-        :param scope: The scope of this PolicyCollectionId.  # noqa: E501
-        :type: str
-        """
-        if scope is not None and len(scope) > 100:
-            raise ValueError("Invalid value for `scope`, length must be less than or equal to `100`")  # noqa: E501
-        if scope is not None and len(scope) < 3:
-            raise ValueError("Invalid value for `scope`, length must be greater than or equal to `3`")  # noqa: E501
-
-        self._scope = scope
-
-    @property
-    def code(self):
-        """Gets the code of this PolicyCollectionId.  # noqa: E501
-
-
-        :return: The code of this PolicyCollectionId.  # noqa: E501
-        :rtype: str
-        """
-        return self._code
-
-    @code.setter
-    def code(self, code):
-        """Sets the code of this PolicyCollectionId.
-
-
-        :param code: The code of this PolicyCollectionId.  # noqa: E501
-        :type: str
-        """
-        if code is None:
-            raise ValueError("Invalid value for `code`, must not be `None`")  # noqa: E501
-        if code is not None and len(code) > 100:
-            raise ValueError("Invalid value for `code`, length must be less than or equal to `100`")  # noqa: E501
-        if code is not None and len(code) < 3:
-            raise ValueError("Invalid value for `code`, length must be greater than or equal to `3`")  # noqa: E501
-
-        self._code = code
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, PolicyCollectionId):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class RoleId(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'scope': 'str',
+        'code': 'str'
+    }
+
+    attribute_map = {
+        'scope': 'scope',
+        'code': 'code'
+    }
+
+    required_map = {
+        'scope': 'optional',
+        'code': 'required'
+    }
+
+    def __init__(self, scope=None, code=None):  # noqa: E501
+        """
+        RoleId - a model defined in OpenAPI
+
+        :param scope: 
+        :type scope: str
+        :param code:  (required)
+        :type code: str
+
+        """  # noqa: E501
+
+        self._scope = None
+        self._code = None
+        self.discriminator = None
+
+        self.scope = scope
+        self.code = code
+
+    @property
+    def scope(self):
+        """Gets the scope of this RoleId.  # noqa: E501
+
+
+        :return: The scope of this RoleId.  # noqa: E501
+        :rtype: str
+        """
+        return self._scope
+
+    @scope.setter
+    def scope(self, scope):
+        """Sets the scope of this RoleId.
+
+
+        :param scope: The scope of this RoleId.  # noqa: E501
+        :type: str
+        """
+        if scope is not None and len(scope) > 100:
+            raise ValueError("Invalid value for `scope`, length must be less than or equal to `100`")  # noqa: E501
+        if scope is not None and len(scope) < 3:
+            raise ValueError("Invalid value for `scope`, length must be greater than or equal to `3`")  # noqa: E501
+
+        self._scope = scope
+
+    @property
+    def code(self):
+        """Gets the code of this RoleId.  # noqa: E501
+
+
+        :return: The code of this RoleId.  # noqa: E501
+        :rtype: str
+        """
+        return self._code
+
+    @code.setter
+    def code(self, code):
+        """Sets the code of this RoleId.
+
+
+        :param code: The code of this RoleId.  # noqa: E501
+        :type: str
+        """
+        if code is None:
+            raise ValueError("Invalid value for `code`, must not be `None`")  # noqa: E501
+        if code is not None and len(code) > 100:
+            raise ValueError("Invalid value for `code`, length must be less than or equal to `100`")  # noqa: E501
+        if code is not None and len(code) < 3:
+            raise ValueError("Invalid value for `code`, length must be greater than or equal to `3`")  # noqa: E501
+
+        self._code = code
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, RoleId):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/policy_collection_response.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/policy_collection_response.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,242 +1,242 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class PolicyCollectionResponse(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'id': 'PolicyCollectionId',
-        'policies': 'list[PolicyId]',
-        'policy_collections': 'list[PolicyCollectionId]',
-        'description': 'str',
-        'links': 'list[Link]'
-    }
-
-    attribute_map = {
-        'id': 'id',
-        'policies': 'policies',
-        'policy_collections': 'policyCollections',
-        'description': 'description',
-        'links': 'links'
-    }
-
-    required_map = {
-        'id': 'optional',
-        'policies': 'optional',
-        'policy_collections': 'optional',
-        'description': 'optional',
-        'links': 'optional'
-    }
-
-    def __init__(self, id=None, policies=None, policy_collections=None, description=None, links=None):  # noqa: E501
-        """
-        PolicyCollectionResponse - a model defined in OpenAPI
-
-        :param id: 
-        :type id: finbourne_access.PolicyCollectionId
-        :param policies:  The identifiers of the Policies in this collection
-        :type policies: list[finbourne_access.PolicyId]
-        :param policy_collections:  The identifiers of the PolicyCollections in this collection
-        :type policy_collections: list[finbourne_access.PolicyCollectionId]
-        :param description:  A description of this policy collection
-        :type description: str
-        :param links: 
-        :type links: list[finbourne_access.Link]
-
-        """  # noqa: E501
-
-        self._id = None
-        self._policies = None
-        self._policy_collections = None
-        self._description = None
-        self._links = None
-        self.discriminator = None
-
-        if id is not None:
-            self.id = id
-        self.policies = policies
-        self.policy_collections = policy_collections
-        self.description = description
-        self.links = links
-
-    @property
-    def id(self):
-        """Gets the id of this PolicyCollectionResponse.  # noqa: E501
-
-
-        :return: The id of this PolicyCollectionResponse.  # noqa: E501
-        :rtype: PolicyCollectionId
-        """
-        return self._id
-
-    @id.setter
-    def id(self, id):
-        """Sets the id of this PolicyCollectionResponse.
-
-
-        :param id: The id of this PolicyCollectionResponse.  # noqa: E501
-        :type: PolicyCollectionId
-        """
-
-        self._id = id
-
-    @property
-    def policies(self):
-        """Gets the policies of this PolicyCollectionResponse.  # noqa: E501
-
-        The identifiers of the Policies in this collection  # noqa: E501
-
-        :return: The policies of this PolicyCollectionResponse.  # noqa: E501
-        :rtype: list[PolicyId]
-        """
-        return self._policies
-
-    @policies.setter
-    def policies(self, policies):
-        """Sets the policies of this PolicyCollectionResponse.
-
-        The identifiers of the Policies in this collection  # noqa: E501
-
-        :param policies: The policies of this PolicyCollectionResponse.  # noqa: E501
-        :type: list[PolicyId]
-        """
-
-        self._policies = policies
-
-    @property
-    def policy_collections(self):
-        """Gets the policy_collections of this PolicyCollectionResponse.  # noqa: E501
-
-        The identifiers of the PolicyCollections in this collection  # noqa: E501
-
-        :return: The policy_collections of this PolicyCollectionResponse.  # noqa: E501
-        :rtype: list[PolicyCollectionId]
-        """
-        return self._policy_collections
-
-    @policy_collections.setter
-    def policy_collections(self, policy_collections):
-        """Sets the policy_collections of this PolicyCollectionResponse.
-
-        The identifiers of the PolicyCollections in this collection  # noqa: E501
-
-        :param policy_collections: The policy_collections of this PolicyCollectionResponse.  # noqa: E501
-        :type: list[PolicyCollectionId]
-        """
-
-        self._policy_collections = policy_collections
-
-    @property
-    def description(self):
-        """Gets the description of this PolicyCollectionResponse.  # noqa: E501
-
-        A description of this policy collection  # noqa: E501
-
-        :return: The description of this PolicyCollectionResponse.  # noqa: E501
-        :rtype: str
-        """
-        return self._description
-
-    @description.setter
-    def description(self, description):
-        """Sets the description of this PolicyCollectionResponse.
-
-        A description of this policy collection  # noqa: E501
-
-        :param description: The description of this PolicyCollectionResponse.  # noqa: E501
-        :type: str
-        """
-
-        self._description = description
-
-    @property
-    def links(self):
-        """Gets the links of this PolicyCollectionResponse.  # noqa: E501
-
-
-        :return: The links of this PolicyCollectionResponse.  # noqa: E501
-        :rtype: list[Link]
-        """
-        return self._links
-
-    @links.setter
-    def links(self, links):
-        """Sets the links of this PolicyCollectionResponse.
-
-
-        :param links: The links of this PolicyCollectionResponse.  # noqa: E501
-        :type: list[Link]
-        """
-
-        self._links = links
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, PolicyCollectionResponse):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class PolicyCollectionResponse(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'id': 'PolicyCollectionId',
+        'policies': 'list[PolicyId]',
+        'policy_collections': 'list[PolicyCollectionId]',
+        'description': 'str',
+        'links': 'list[Link]'
+    }
+
+    attribute_map = {
+        'id': 'id',
+        'policies': 'policies',
+        'policy_collections': 'policyCollections',
+        'description': 'description',
+        'links': 'links'
+    }
+
+    required_map = {
+        'id': 'optional',
+        'policies': 'optional',
+        'policy_collections': 'optional',
+        'description': 'optional',
+        'links': 'optional'
+    }
+
+    def __init__(self, id=None, policies=None, policy_collections=None, description=None, links=None):  # noqa: E501
+        """
+        PolicyCollectionResponse - a model defined in OpenAPI
+
+        :param id: 
+        :type id: finbourne_access.PolicyCollectionId
+        :param policies:  The identifiers of the Policies in this collection
+        :type policies: list[finbourne_access.PolicyId]
+        :param policy_collections:  The identifiers of the PolicyCollections in this collection
+        :type policy_collections: list[finbourne_access.PolicyCollectionId]
+        :param description:  A description of this policy collection
+        :type description: str
+        :param links: 
+        :type links: list[finbourne_access.Link]
+
+        """  # noqa: E501
+
+        self._id = None
+        self._policies = None
+        self._policy_collections = None
+        self._description = None
+        self._links = None
+        self.discriminator = None
+
+        if id is not None:
+            self.id = id
+        self.policies = policies
+        self.policy_collections = policy_collections
+        self.description = description
+        self.links = links
+
+    @property
+    def id(self):
+        """Gets the id of this PolicyCollectionResponse.  # noqa: E501
+
+
+        :return: The id of this PolicyCollectionResponse.  # noqa: E501
+        :rtype: PolicyCollectionId
+        """
+        return self._id
+
+    @id.setter
+    def id(self, id):
+        """Sets the id of this PolicyCollectionResponse.
+
+
+        :param id: The id of this PolicyCollectionResponse.  # noqa: E501
+        :type: PolicyCollectionId
+        """
+
+        self._id = id
+
+    @property
+    def policies(self):
+        """Gets the policies of this PolicyCollectionResponse.  # noqa: E501
+
+        The identifiers of the Policies in this collection  # noqa: E501
+
+        :return: The policies of this PolicyCollectionResponse.  # noqa: E501
+        :rtype: list[PolicyId]
+        """
+        return self._policies
+
+    @policies.setter
+    def policies(self, policies):
+        """Sets the policies of this PolicyCollectionResponse.
+
+        The identifiers of the Policies in this collection  # noqa: E501
+
+        :param policies: The policies of this PolicyCollectionResponse.  # noqa: E501
+        :type: list[PolicyId]
+        """
+
+        self._policies = policies
+
+    @property
+    def policy_collections(self):
+        """Gets the policy_collections of this PolicyCollectionResponse.  # noqa: E501
+
+        The identifiers of the PolicyCollections in this collection  # noqa: E501
+
+        :return: The policy_collections of this PolicyCollectionResponse.  # noqa: E501
+        :rtype: list[PolicyCollectionId]
+        """
+        return self._policy_collections
+
+    @policy_collections.setter
+    def policy_collections(self, policy_collections):
+        """Sets the policy_collections of this PolicyCollectionResponse.
+
+        The identifiers of the PolicyCollections in this collection  # noqa: E501
+
+        :param policy_collections: The policy_collections of this PolicyCollectionResponse.  # noqa: E501
+        :type: list[PolicyCollectionId]
+        """
+
+        self._policy_collections = policy_collections
+
+    @property
+    def description(self):
+        """Gets the description of this PolicyCollectionResponse.  # noqa: E501
+
+        A description of this policy collection  # noqa: E501
+
+        :return: The description of this PolicyCollectionResponse.  # noqa: E501
+        :rtype: str
+        """
+        return self._description
+
+    @description.setter
+    def description(self, description):
+        """Sets the description of this PolicyCollectionResponse.
+
+        A description of this policy collection  # noqa: E501
+
+        :param description: The description of this PolicyCollectionResponse.  # noqa: E501
+        :type: str
+        """
+
+        self._description = description
+
+    @property
+    def links(self):
+        """Gets the links of this PolicyCollectionResponse.  # noqa: E501
+
+
+        :return: The links of this PolicyCollectionResponse.  # noqa: E501
+        :rtype: list[Link]
+        """
+        return self._links
+
+    @links.setter
+    def links(self, links):
+        """Sets the links of this PolicyCollectionResponse.
+
+
+        :param links: The links of this PolicyCollectionResponse.  # noqa: E501
+        :type: list[Link]
+        """
+
+        self._links = links
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, PolicyCollectionResponse):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/policy_collection_update_request.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/policy_collection_update_request.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,219 +1,219 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class PolicyCollectionUpdateRequest(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'policies': 'list[PolicyId]',
-        'metadata': 'dict(str, list[EntitlementMetadata])',
-        'policy_collections': 'list[PolicyCollectionId]',
-        'description': 'str'
-    }
-
-    attribute_map = {
-        'policies': 'policies',
-        'metadata': 'metadata',
-        'policy_collections': 'policyCollections',
-        'description': 'description'
-    }
-
-    required_map = {
-        'policies': 'optional',
-        'metadata': 'optional',
-        'policy_collections': 'optional',
-        'description': 'optional'
-    }
-
-    def __init__(self, policies=None, metadata=None, policy_collections=None, description=None):  # noqa: E501
-        """
-        PolicyCollectionUpdateRequest - a model defined in OpenAPI
-
-        :param policies:  The identifiers of the Policies in this collection
-        :type policies: list[finbourne_access.PolicyId]
-        :param metadata:  Any relevant metadata associated with this resource for controlling access to this resource
-        :type metadata: dict(str, list[EntitlementMetadata])
-        :param policy_collections:  The identifiers of the PolicyCollections in this collection
-        :type policy_collections: list[finbourne_access.PolicyCollectionId]
-        :param description:  A description of this policy collection
-        :type description: str
-
-        """  # noqa: E501
-
-        self._policies = None
-        self._metadata = None
-        self._policy_collections = None
-        self._description = None
-        self.discriminator = None
-
-        self.policies = policies
-        self.metadata = metadata
-        self.policy_collections = policy_collections
-        self.description = description
-
-    @property
-    def policies(self):
-        """Gets the policies of this PolicyCollectionUpdateRequest.  # noqa: E501
-
-        The identifiers of the Policies in this collection  # noqa: E501
-
-        :return: The policies of this PolicyCollectionUpdateRequest.  # noqa: E501
-        :rtype: list[PolicyId]
-        """
-        return self._policies
-
-    @policies.setter
-    def policies(self, policies):
-        """Sets the policies of this PolicyCollectionUpdateRequest.
-
-        The identifiers of the Policies in this collection  # noqa: E501
-
-        :param policies: The policies of this PolicyCollectionUpdateRequest.  # noqa: E501
-        :type: list[PolicyId]
-        """
-
-        self._policies = policies
-
-    @property
-    def metadata(self):
-        """Gets the metadata of this PolicyCollectionUpdateRequest.  # noqa: E501
-
-        Any relevant metadata associated with this resource for controlling access to this resource  # noqa: E501
-
-        :return: The metadata of this PolicyCollectionUpdateRequest.  # noqa: E501
-        :rtype: dict(str, list[EntitlementMetadata])
-        """
-        return self._metadata
-
-    @metadata.setter
-    def metadata(self, metadata):
-        """Sets the metadata of this PolicyCollectionUpdateRequest.
-
-        Any relevant metadata associated with this resource for controlling access to this resource  # noqa: E501
-
-        :param metadata: The metadata of this PolicyCollectionUpdateRequest.  # noqa: E501
-        :type: dict(str, list[EntitlementMetadata])
-        """
-
-        self._metadata = metadata
-
-    @property
-    def policy_collections(self):
-        """Gets the policy_collections of this PolicyCollectionUpdateRequest.  # noqa: E501
-
-        The identifiers of the PolicyCollections in this collection  # noqa: E501
-
-        :return: The policy_collections of this PolicyCollectionUpdateRequest.  # noqa: E501
-        :rtype: list[PolicyCollectionId]
-        """
-        return self._policy_collections
-
-    @policy_collections.setter
-    def policy_collections(self, policy_collections):
-        """Sets the policy_collections of this PolicyCollectionUpdateRequest.
-
-        The identifiers of the PolicyCollections in this collection  # noqa: E501
-
-        :param policy_collections: The policy_collections of this PolicyCollectionUpdateRequest.  # noqa: E501
-        :type: list[PolicyCollectionId]
-        """
-
-        self._policy_collections = policy_collections
-
-    @property
-    def description(self):
-        """Gets the description of this PolicyCollectionUpdateRequest.  # noqa: E501
-
-        A description of this policy collection  # noqa: E501
-
-        :return: The description of this PolicyCollectionUpdateRequest.  # noqa: E501
-        :rtype: str
-        """
-        return self._description
-
-    @description.setter
-    def description(self, description):
-        """Sets the description of this PolicyCollectionUpdateRequest.
-
-        A description of this policy collection  # noqa: E501
-
-        :param description: The description of this PolicyCollectionUpdateRequest.  # noqa: E501
-        :type: str
-        """
-        if description is not None and len(description) > 1024:
-            raise ValueError("Invalid value for `description`, length must be less than or equal to `1024`")  # noqa: E501
-        if description is not None and len(description) < 0:
-            raise ValueError("Invalid value for `description`, length must be greater than or equal to `0`")  # noqa: E501
-
-        self._description = description
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, PolicyCollectionUpdateRequest):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class PolicyCollectionUpdateRequest(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'policies': 'list[PolicyId]',
+        'metadata': 'dict(str, list[EntitlementMetadata])',
+        'policy_collections': 'list[PolicyCollectionId]',
+        'description': 'str'
+    }
+
+    attribute_map = {
+        'policies': 'policies',
+        'metadata': 'metadata',
+        'policy_collections': 'policyCollections',
+        'description': 'description'
+    }
+
+    required_map = {
+        'policies': 'optional',
+        'metadata': 'optional',
+        'policy_collections': 'optional',
+        'description': 'optional'
+    }
+
+    def __init__(self, policies=None, metadata=None, policy_collections=None, description=None):  # noqa: E501
+        """
+        PolicyCollectionUpdateRequest - a model defined in OpenAPI
+
+        :param policies:  The identifiers of the Policies in this collection
+        :type policies: list[finbourne_access.PolicyId]
+        :param metadata:  Any relevant metadata associated with this resource for controlling access to this resource
+        :type metadata: dict(str, list[EntitlementMetadata])
+        :param policy_collections:  The identifiers of the PolicyCollections in this collection
+        :type policy_collections: list[finbourne_access.PolicyCollectionId]
+        :param description:  A description of this policy collection
+        :type description: str
+
+        """  # noqa: E501
+
+        self._policies = None
+        self._metadata = None
+        self._policy_collections = None
+        self._description = None
+        self.discriminator = None
+
+        self.policies = policies
+        self.metadata = metadata
+        self.policy_collections = policy_collections
+        self.description = description
+
+    @property
+    def policies(self):
+        """Gets the policies of this PolicyCollectionUpdateRequest.  # noqa: E501
+
+        The identifiers of the Policies in this collection  # noqa: E501
+
+        :return: The policies of this PolicyCollectionUpdateRequest.  # noqa: E501
+        :rtype: list[PolicyId]
+        """
+        return self._policies
+
+    @policies.setter
+    def policies(self, policies):
+        """Sets the policies of this PolicyCollectionUpdateRequest.
+
+        The identifiers of the Policies in this collection  # noqa: E501
+
+        :param policies: The policies of this PolicyCollectionUpdateRequest.  # noqa: E501
+        :type: list[PolicyId]
+        """
+
+        self._policies = policies
+
+    @property
+    def metadata(self):
+        """Gets the metadata of this PolicyCollectionUpdateRequest.  # noqa: E501
+
+        Any relevant metadata associated with this resource for controlling access to this resource  # noqa: E501
+
+        :return: The metadata of this PolicyCollectionUpdateRequest.  # noqa: E501
+        :rtype: dict(str, list[EntitlementMetadata])
+        """
+        return self._metadata
+
+    @metadata.setter
+    def metadata(self, metadata):
+        """Sets the metadata of this PolicyCollectionUpdateRequest.
+
+        Any relevant metadata associated with this resource for controlling access to this resource  # noqa: E501
+
+        :param metadata: The metadata of this PolicyCollectionUpdateRequest.  # noqa: E501
+        :type: dict(str, list[EntitlementMetadata])
+        """
+
+        self._metadata = metadata
+
+    @property
+    def policy_collections(self):
+        """Gets the policy_collections of this PolicyCollectionUpdateRequest.  # noqa: E501
+
+        The identifiers of the PolicyCollections in this collection  # noqa: E501
+
+        :return: The policy_collections of this PolicyCollectionUpdateRequest.  # noqa: E501
+        :rtype: list[PolicyCollectionId]
+        """
+        return self._policy_collections
+
+    @policy_collections.setter
+    def policy_collections(self, policy_collections):
+        """Sets the policy_collections of this PolicyCollectionUpdateRequest.
+
+        The identifiers of the PolicyCollections in this collection  # noqa: E501
+
+        :param policy_collections: The policy_collections of this PolicyCollectionUpdateRequest.  # noqa: E501
+        :type: list[PolicyCollectionId]
+        """
+
+        self._policy_collections = policy_collections
+
+    @property
+    def description(self):
+        """Gets the description of this PolicyCollectionUpdateRequest.  # noqa: E501
+
+        A description of this policy collection  # noqa: E501
+
+        :return: The description of this PolicyCollectionUpdateRequest.  # noqa: E501
+        :rtype: str
+        """
+        return self._description
+
+    @description.setter
+    def description(self, description):
+        """Sets the description of this PolicyCollectionUpdateRequest.
+
+        A description of this policy collection  # noqa: E501
+
+        :param description: The description of this PolicyCollectionUpdateRequest.  # noqa: E501
+        :type: str
+        """
+        if description is not None and len(description) > 1024:
+            raise ValueError("Invalid value for `description`, length must be less than or equal to `1024`")  # noqa: E501
+        if description is not None and len(description) < 0:
+            raise ValueError("Invalid value for `description`, length must be greater than or equal to `0`")  # noqa: E501
+
+        self._description = description
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, PolicyCollectionUpdateRequest):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/policy_creation_request.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/policy_creation_request.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,378 +1,378 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class PolicyCreationRequest(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'code': 'str',
-        'description': 'str',
-        'applications': 'list[str]',
-        'grant': 'Grant',
-        'selectors': 'list[SelectorDefinition]',
-        '_for': 'list[ForSpec]',
-        '_if': 'list[IfExpression]',
-        'when': 'WhenSpec',
-        'how': 'HowSpec'
-    }
-
-    attribute_map = {
-        'code': 'code',
-        'description': 'description',
-        'applications': 'applications',
-        'grant': 'grant',
-        'selectors': 'selectors',
-        '_for': 'for',
-        '_if': 'if',
-        'when': 'when',
-        'how': 'how'
-    }
-
-    required_map = {
-        'code': 'required',
-        'description': 'optional',
-        'applications': 'optional',
-        'grant': 'required',
-        'selectors': 'required',
-        '_for': 'optional',
-        '_if': 'optional',
-        'when': 'required',
-        'how': 'optional'
-    }
-
-    def __init__(self, code=None, description=None, applications=None, grant=None, selectors=None, _for=None, _if=None, when=None, how=None):  # noqa: E501
-        """
-        PolicyCreationRequest - a model defined in OpenAPI
-
-        :param code:  Code of the policy being created (required)
-        :type code: str
-        :param description:  Description of what the policy will be used for
-        :type description: str
-        :param applications:  Applications this policy is used with
-        :type applications: list[str]
-        :param grant:  (required)
-        :type grant: finbourne_access.Grant
-        :param selectors:  Selectors that identify what resources this policy qualifies for (required)
-        :type selectors: list[finbourne_access.SelectorDefinition]
-        :param _for:  \"For Specification\" for when the policy is to be applied
-        :type _for: list[finbourne_access.ForSpec]
-        :param _if:  \"If Specification\" for when the policy is to be applied
-        :type _if: list[finbourne_access.IfExpression]
-        :param when:  (required)
-        :type when: finbourne_access.WhenSpec
-        :param how: 
-        :type how: finbourne_access.HowSpec
-
-        """  # noqa: E501
-
-        self._code = None
-        self._description = None
-        self._applications = None
-        self._grant = None
-        self._selectors = None
-        self.__for = None
-        self.__if = None
-        self._when = None
-        self._how = None
-        self.discriminator = None
-
-        self.code = code
-        self.description = description
-        self.applications = applications
-        self.grant = grant
-        self.selectors = selectors
-        self._for = _for
-        self._if = _if
-        self.when = when
-        if how is not None:
-            self.how = how
-
-    @property
-    def code(self):
-        """Gets the code of this PolicyCreationRequest.  # noqa: E501
-
-        Code of the policy being created  # noqa: E501
-
-        :return: The code of this PolicyCreationRequest.  # noqa: E501
-        :rtype: str
-        """
-        return self._code
-
-    @code.setter
-    def code(self, code):
-        """Sets the code of this PolicyCreationRequest.
-
-        Code of the policy being created  # noqa: E501
-
-        :param code: The code of this PolicyCreationRequest.  # noqa: E501
-        :type: str
-        """
-        if code is None:
-            raise ValueError("Invalid value for `code`, must not be `None`")  # noqa: E501
-        if code is not None and len(code) > 100:
-            raise ValueError("Invalid value for `code`, length must be less than or equal to `100`")  # noqa: E501
-        if code is not None and len(code) < 3:
-            raise ValueError("Invalid value for `code`, length must be greater than or equal to `3`")  # noqa: E501
-        if (code is not None and not re.search(r'^[a-zA-Z][a-zA-Z0-9-_ +]{2,100}$', code)):  # noqa: E501
-            raise ValueError(r"Invalid value for `code`, must be a follow pattern or equal to `/^[a-zA-Z][a-zA-Z0-9-_ +]{2,100}$/`")  # noqa: E501
-
-        self._code = code
-
-    @property
-    def description(self):
-        """Gets the description of this PolicyCreationRequest.  # noqa: E501
-
-        Description of what the policy will be used for  # noqa: E501
-
-        :return: The description of this PolicyCreationRequest.  # noqa: E501
-        :rtype: str
-        """
-        return self._description
-
-    @description.setter
-    def description(self, description):
-        """Sets the description of this PolicyCreationRequest.
-
-        Description of what the policy will be used for  # noqa: E501
-
-        :param description: The description of this PolicyCreationRequest.  # noqa: E501
-        :type: str
-        """
-        if description is not None and len(description) > 1024:
-            raise ValueError("Invalid value for `description`, length must be less than or equal to `1024`")  # noqa: E501
-        if description is not None and len(description) < 0:
-            raise ValueError("Invalid value for `description`, length must be greater than or equal to `0`")  # noqa: E501
-
-        self._description = description
-
-    @property
-    def applications(self):
-        """Gets the applications of this PolicyCreationRequest.  # noqa: E501
-
-        Applications this policy is used with  # noqa: E501
-
-        :return: The applications of this PolicyCreationRequest.  # noqa: E501
-        :rtype: list[str]
-        """
-        return self._applications
-
-    @applications.setter
-    def applications(self, applications):
-        """Sets the applications of this PolicyCreationRequest.
-
-        Applications this policy is used with  # noqa: E501
-
-        :param applications: The applications of this PolicyCreationRequest.  # noqa: E501
-        :type: list[str]
-        """
-
-        self._applications = applications
-
-    @property
-    def grant(self):
-        """Gets the grant of this PolicyCreationRequest.  # noqa: E501
-
-
-        :return: The grant of this PolicyCreationRequest.  # noqa: E501
-        :rtype: Grant
-        """
-        return self._grant
-
-    @grant.setter
-    def grant(self, grant):
-        """Sets the grant of this PolicyCreationRequest.
-
-
-        :param grant: The grant of this PolicyCreationRequest.  # noqa: E501
-        :type: Grant
-        """
-        if grant is None:
-            raise ValueError("Invalid value for `grant`, must not be `None`")  # noqa: E501
-
-        self._grant = grant
-
-    @property
-    def selectors(self):
-        """Gets the selectors of this PolicyCreationRequest.  # noqa: E501
-
-        Selectors that identify what resources this policy qualifies for  # noqa: E501
-
-        :return: The selectors of this PolicyCreationRequest.  # noqa: E501
-        :rtype: list[SelectorDefinition]
-        """
-        return self._selectors
-
-    @selectors.setter
-    def selectors(self, selectors):
-        """Sets the selectors of this PolicyCreationRequest.
-
-        Selectors that identify what resources this policy qualifies for  # noqa: E501
-
-        :param selectors: The selectors of this PolicyCreationRequest.  # noqa: E501
-        :type: list[SelectorDefinition]
-        """
-        if selectors is None:
-            raise ValueError("Invalid value for `selectors`, must not be `None`")  # noqa: E501
-
-        self._selectors = selectors
-
-    @property
-    def _for(self):
-        """Gets the _for of this PolicyCreationRequest.  # noqa: E501
-
-        \"For Specification\" for when the policy is to be applied  # noqa: E501
-
-        :return: The _for of this PolicyCreationRequest.  # noqa: E501
-        :rtype: list[ForSpec]
-        """
-        return self.__for
-
-    @_for.setter
-    def _for(self, _for):
-        """Sets the _for of this PolicyCreationRequest.
-
-        \"For Specification\" for when the policy is to be applied  # noqa: E501
-
-        :param _for: The _for of this PolicyCreationRequest.  # noqa: E501
-        :type: list[ForSpec]
-        """
-
-        self.__for = _for
-
-    @property
-    def _if(self):
-        """Gets the _if of this PolicyCreationRequest.  # noqa: E501
-
-        \"If Specification\" for when the policy is to be applied  # noqa: E501
-
-        :return: The _if of this PolicyCreationRequest.  # noqa: E501
-        :rtype: list[IfExpression]
-        """
-        return self.__if
-
-    @_if.setter
-    def _if(self, _if):
-        """Sets the _if of this PolicyCreationRequest.
-
-        \"If Specification\" for when the policy is to be applied  # noqa: E501
-
-        :param _if: The _if of this PolicyCreationRequest.  # noqa: E501
-        :type: list[IfExpression]
-        """
-
-        self.__if = _if
-
-    @property
-    def when(self):
-        """Gets the when of this PolicyCreationRequest.  # noqa: E501
-
-
-        :return: The when of this PolicyCreationRequest.  # noqa: E501
-        :rtype: WhenSpec
-        """
-        return self._when
-
-    @when.setter
-    def when(self, when):
-        """Sets the when of this PolicyCreationRequest.
-
-
-        :param when: The when of this PolicyCreationRequest.  # noqa: E501
-        :type: WhenSpec
-        """
-        if when is None:
-            raise ValueError("Invalid value for `when`, must not be `None`")  # noqa: E501
-
-        self._when = when
-
-    @property
-    def how(self):
-        """Gets the how of this PolicyCreationRequest.  # noqa: E501
-
-
-        :return: The how of this PolicyCreationRequest.  # noqa: E501
-        :rtype: HowSpec
-        """
-        return self._how
-
-    @how.setter
-    def how(self, how):
-        """Sets the how of this PolicyCreationRequest.
-
-
-        :param how: The how of this PolicyCreationRequest.  # noqa: E501
-        :type: HowSpec
-        """
-
-        self._how = how
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, PolicyCreationRequest):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class PolicyCreationRequest(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'code': 'str',
+        'description': 'str',
+        'applications': 'list[str]',
+        'grant': 'Grant',
+        'selectors': 'list[SelectorDefinition]',
+        '_for': 'list[ForSpec]',
+        '_if': 'list[IfExpression]',
+        'when': 'WhenSpec',
+        'how': 'HowSpec'
+    }
+
+    attribute_map = {
+        'code': 'code',
+        'description': 'description',
+        'applications': 'applications',
+        'grant': 'grant',
+        'selectors': 'selectors',
+        '_for': 'for',
+        '_if': 'if',
+        'when': 'when',
+        'how': 'how'
+    }
+
+    required_map = {
+        'code': 'required',
+        'description': 'optional',
+        'applications': 'optional',
+        'grant': 'required',
+        'selectors': 'required',
+        '_for': 'optional',
+        '_if': 'optional',
+        'when': 'required',
+        'how': 'optional'
+    }
+
+    def __init__(self, code=None, description=None, applications=None, grant=None, selectors=None, _for=None, _if=None, when=None, how=None):  # noqa: E501
+        """
+        PolicyCreationRequest - a model defined in OpenAPI
+
+        :param code:  Code of the policy being created (required)
+        :type code: str
+        :param description:  Description of what the policy will be used for
+        :type description: str
+        :param applications:  Applications this policy is used with
+        :type applications: list[str]
+        :param grant:  (required)
+        :type grant: finbourne_access.Grant
+        :param selectors:  Selectors that identify what resources this policy qualifies for (required)
+        :type selectors: list[finbourne_access.SelectorDefinition]
+        :param _for:  \"For Specification\" for when the policy is to be applied
+        :type _for: list[finbourne_access.ForSpec]
+        :param _if:  \"If Specification\" for when the policy is to be applied
+        :type _if: list[finbourne_access.IfExpression]
+        :param when:  (required)
+        :type when: finbourne_access.WhenSpec
+        :param how: 
+        :type how: finbourne_access.HowSpec
+
+        """  # noqa: E501
+
+        self._code = None
+        self._description = None
+        self._applications = None
+        self._grant = None
+        self._selectors = None
+        self.__for = None
+        self.__if = None
+        self._when = None
+        self._how = None
+        self.discriminator = None
+
+        self.code = code
+        self.description = description
+        self.applications = applications
+        self.grant = grant
+        self.selectors = selectors
+        self._for = _for
+        self._if = _if
+        self.when = when
+        if how is not None:
+            self.how = how
+
+    @property
+    def code(self):
+        """Gets the code of this PolicyCreationRequest.  # noqa: E501
+
+        Code of the policy being created  # noqa: E501
+
+        :return: The code of this PolicyCreationRequest.  # noqa: E501
+        :rtype: str
+        """
+        return self._code
+
+    @code.setter
+    def code(self, code):
+        """Sets the code of this PolicyCreationRequest.
+
+        Code of the policy being created  # noqa: E501
+
+        :param code: The code of this PolicyCreationRequest.  # noqa: E501
+        :type: str
+        """
+        if code is None:
+            raise ValueError("Invalid value for `code`, must not be `None`")  # noqa: E501
+        if code is not None and len(code) > 100:
+            raise ValueError("Invalid value for `code`, length must be less than or equal to `100`")  # noqa: E501
+        if code is not None and len(code) < 3:
+            raise ValueError("Invalid value for `code`, length must be greater than or equal to `3`")  # noqa: E501
+        if (code is not None and not re.search(r'^[a-zA-Z][a-zA-Z0-9-_ +]{2,100}$', code)):  # noqa: E501
+            raise ValueError(r"Invalid value for `code`, must be a follow pattern or equal to `/^[a-zA-Z][a-zA-Z0-9-_ +]{2,100}$/`")  # noqa: E501
+
+        self._code = code
+
+    @property
+    def description(self):
+        """Gets the description of this PolicyCreationRequest.  # noqa: E501
+
+        Description of what the policy will be used for  # noqa: E501
+
+        :return: The description of this PolicyCreationRequest.  # noqa: E501
+        :rtype: str
+        """
+        return self._description
+
+    @description.setter
+    def description(self, description):
+        """Sets the description of this PolicyCreationRequest.
+
+        Description of what the policy will be used for  # noqa: E501
+
+        :param description: The description of this PolicyCreationRequest.  # noqa: E501
+        :type: str
+        """
+        if description is not None and len(description) > 1024:
+            raise ValueError("Invalid value for `description`, length must be less than or equal to `1024`")  # noqa: E501
+        if description is not None and len(description) < 0:
+            raise ValueError("Invalid value for `description`, length must be greater than or equal to `0`")  # noqa: E501
+
+        self._description = description
+
+    @property
+    def applications(self):
+        """Gets the applications of this PolicyCreationRequest.  # noqa: E501
+
+        Applications this policy is used with  # noqa: E501
+
+        :return: The applications of this PolicyCreationRequest.  # noqa: E501
+        :rtype: list[str]
+        """
+        return self._applications
+
+    @applications.setter
+    def applications(self, applications):
+        """Sets the applications of this PolicyCreationRequest.
+
+        Applications this policy is used with  # noqa: E501
+
+        :param applications: The applications of this PolicyCreationRequest.  # noqa: E501
+        :type: list[str]
+        """
+
+        self._applications = applications
+
+    @property
+    def grant(self):
+        """Gets the grant of this PolicyCreationRequest.  # noqa: E501
+
+
+        :return: The grant of this PolicyCreationRequest.  # noqa: E501
+        :rtype: Grant
+        """
+        return self._grant
+
+    @grant.setter
+    def grant(self, grant):
+        """Sets the grant of this PolicyCreationRequest.
+
+
+        :param grant: The grant of this PolicyCreationRequest.  # noqa: E501
+        :type: Grant
+        """
+        if grant is None:
+            raise ValueError("Invalid value for `grant`, must not be `None`")  # noqa: E501
+
+        self._grant = grant
+
+    @property
+    def selectors(self):
+        """Gets the selectors of this PolicyCreationRequest.  # noqa: E501
+
+        Selectors that identify what resources this policy qualifies for  # noqa: E501
+
+        :return: The selectors of this PolicyCreationRequest.  # noqa: E501
+        :rtype: list[SelectorDefinition]
+        """
+        return self._selectors
+
+    @selectors.setter
+    def selectors(self, selectors):
+        """Sets the selectors of this PolicyCreationRequest.
+
+        Selectors that identify what resources this policy qualifies for  # noqa: E501
+
+        :param selectors: The selectors of this PolicyCreationRequest.  # noqa: E501
+        :type: list[SelectorDefinition]
+        """
+        if selectors is None:
+            raise ValueError("Invalid value for `selectors`, must not be `None`")  # noqa: E501
+
+        self._selectors = selectors
+
+    @property
+    def _for(self):
+        """Gets the _for of this PolicyCreationRequest.  # noqa: E501
+
+        \"For Specification\" for when the policy is to be applied  # noqa: E501
+
+        :return: The _for of this PolicyCreationRequest.  # noqa: E501
+        :rtype: list[ForSpec]
+        """
+        return self.__for
+
+    @_for.setter
+    def _for(self, _for):
+        """Sets the _for of this PolicyCreationRequest.
+
+        \"For Specification\" for when the policy is to be applied  # noqa: E501
+
+        :param _for: The _for of this PolicyCreationRequest.  # noqa: E501
+        :type: list[ForSpec]
+        """
+
+        self.__for = _for
+
+    @property
+    def _if(self):
+        """Gets the _if of this PolicyCreationRequest.  # noqa: E501
+
+        \"If Specification\" for when the policy is to be applied  # noqa: E501
+
+        :return: The _if of this PolicyCreationRequest.  # noqa: E501
+        :rtype: list[IfExpression]
+        """
+        return self.__if
+
+    @_if.setter
+    def _if(self, _if):
+        """Sets the _if of this PolicyCreationRequest.
+
+        \"If Specification\" for when the policy is to be applied  # noqa: E501
+
+        :param _if: The _if of this PolicyCreationRequest.  # noqa: E501
+        :type: list[IfExpression]
+        """
+
+        self.__if = _if
+
+    @property
+    def when(self):
+        """Gets the when of this PolicyCreationRequest.  # noqa: E501
+
+
+        :return: The when of this PolicyCreationRequest.  # noqa: E501
+        :rtype: WhenSpec
+        """
+        return self._when
+
+    @when.setter
+    def when(self, when):
+        """Sets the when of this PolicyCreationRequest.
+
+
+        :param when: The when of this PolicyCreationRequest.  # noqa: E501
+        :type: WhenSpec
+        """
+        if when is None:
+            raise ValueError("Invalid value for `when`, must not be `None`")  # noqa: E501
+
+        self._when = when
+
+    @property
+    def how(self):
+        """Gets the how of this PolicyCreationRequest.  # noqa: E501
+
+
+        :return: The how of this PolicyCreationRequest.  # noqa: E501
+        :rtype: HowSpec
+        """
+        return self._how
+
+    @how.setter
+    def how(self, how):
+        """Sets the how of this PolicyCreationRequest.
+
+
+        :param how: The how of this PolicyCreationRequest.  # noqa: E501
+        :type: HowSpec
+        """
+
+        self._how = how
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, PolicyCreationRequest):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/policy_id.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/policy_id.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,161 +1,161 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class PolicyId(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'scope': 'str',
-        'code': 'str'
-    }
-
-    attribute_map = {
-        'scope': 'scope',
-        'code': 'code'
-    }
-
-    required_map = {
-        'scope': 'optional',
-        'code': 'required'
-    }
-
-    def __init__(self, scope=None, code=None):  # noqa: E501
-        """
-        PolicyId - a model defined in OpenAPI
-
-        :param scope: 
-        :type scope: str
-        :param code:  (required)
-        :type code: str
-
-        """  # noqa: E501
-
-        self._scope = None
-        self._code = None
-        self.discriminator = None
-
-        self.scope = scope
-        self.code = code
-
-    @property
-    def scope(self):
-        """Gets the scope of this PolicyId.  # noqa: E501
-
-
-        :return: The scope of this PolicyId.  # noqa: E501
-        :rtype: str
-        """
-        return self._scope
-
-    @scope.setter
-    def scope(self, scope):
-        """Sets the scope of this PolicyId.
-
-
-        :param scope: The scope of this PolicyId.  # noqa: E501
-        :type: str
-        """
-        if scope is not None and len(scope) > 100:
-            raise ValueError("Invalid value for `scope`, length must be less than or equal to `100`")  # noqa: E501
-        if scope is not None and len(scope) < 3:
-            raise ValueError("Invalid value for `scope`, length must be greater than or equal to `3`")  # noqa: E501
-
-        self._scope = scope
-
-    @property
-    def code(self):
-        """Gets the code of this PolicyId.  # noqa: E501
-
-
-        :return: The code of this PolicyId.  # noqa: E501
-        :rtype: str
-        """
-        return self._code
-
-    @code.setter
-    def code(self, code):
-        """Sets the code of this PolicyId.
-
-
-        :param code: The code of this PolicyId.  # noqa: E501
-        :type: str
-        """
-        if code is None:
-            raise ValueError("Invalid value for `code`, must not be `None`")  # noqa: E501
-        if code is not None and len(code) > 100:
-            raise ValueError("Invalid value for `code`, length must be less than or equal to `100`")  # noqa: E501
-        if code is not None and len(code) < 3:
-            raise ValueError("Invalid value for `code`, length must be greater than or equal to `3`")  # noqa: E501
-
-        self._code = code
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, PolicyId):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class PolicyId(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'scope': 'str',
+        'code': 'str'
+    }
+
+    attribute_map = {
+        'scope': 'scope',
+        'code': 'code'
+    }
+
+    required_map = {
+        'scope': 'optional',
+        'code': 'required'
+    }
+
+    def __init__(self, scope=None, code=None):  # noqa: E501
+        """
+        PolicyId - a model defined in OpenAPI
+
+        :param scope: 
+        :type scope: str
+        :param code:  (required)
+        :type code: str
+
+        """  # noqa: E501
+
+        self._scope = None
+        self._code = None
+        self.discriminator = None
+
+        self.scope = scope
+        self.code = code
+
+    @property
+    def scope(self):
+        """Gets the scope of this PolicyId.  # noqa: E501
+
+
+        :return: The scope of this PolicyId.  # noqa: E501
+        :rtype: str
+        """
+        return self._scope
+
+    @scope.setter
+    def scope(self, scope):
+        """Sets the scope of this PolicyId.
+
+
+        :param scope: The scope of this PolicyId.  # noqa: E501
+        :type: str
+        """
+        if scope is not None and len(scope) > 100:
+            raise ValueError("Invalid value for `scope`, length must be less than or equal to `100`")  # noqa: E501
+        if scope is not None and len(scope) < 3:
+            raise ValueError("Invalid value for `scope`, length must be greater than or equal to `3`")  # noqa: E501
+
+        self._scope = scope
+
+    @property
+    def code(self):
+        """Gets the code of this PolicyId.  # noqa: E501
+
+
+        :return: The code of this PolicyId.  # noqa: E501
+        :rtype: str
+        """
+        return self._code
+
+    @code.setter
+    def code(self, code):
+        """Sets the code of this PolicyId.
+
+
+        :param code: The code of this PolicyId.  # noqa: E501
+        :type: str
+        """
+        if code is None:
+            raise ValueError("Invalid value for `code`, must not be `None`")  # noqa: E501
+        if code is not None and len(code) > 100:
+            raise ValueError("Invalid value for `code`, length must be less than or equal to `100`")  # noqa: E501
+        if code is not None and len(code) < 3:
+            raise ValueError("Invalid value for `code`, length must be greater than or equal to `3`")  # noqa: E501
+
+        self._code = code
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, PolicyId):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/policy_response.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/policy_response.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,389 +1,389 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class PolicyResponse(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'id': 'PolicyId',
-        'description': 'str',
-        'applications': 'list[str]',
-        'grant': 'Grant',
-        'selectors': 'list[SelectorDefinition]',
-        '_for': 'list[ForSpec]',
-        '_if': 'list[IfExpression]',
-        'when': 'WhenSpec',
-        'how': 'HowSpec',
-        'links': 'list[Link]'
-    }
-
-    attribute_map = {
-        'id': 'id',
-        'description': 'description',
-        'applications': 'applications',
-        'grant': 'grant',
-        'selectors': 'selectors',
-        '_for': 'for',
-        '_if': 'if',
-        'when': 'when',
-        'how': 'how',
-        'links': 'links'
-    }
-
-    required_map = {
-        'id': 'optional',
-        'description': 'optional',
-        'applications': 'optional',
-        'grant': 'optional',
-        'selectors': 'optional',
-        '_for': 'optional',
-        '_if': 'optional',
-        'when': 'optional',
-        'how': 'optional',
-        'links': 'optional'
-    }
-
-    def __init__(self, id=None, description=None, applications=None, grant=None, selectors=None, _for=None, _if=None, when=None, how=None, links=None):  # noqa: E501
-        """
-        PolicyResponse - a model defined in OpenAPI
-
-        :param id: 
-        :type id: finbourne_access.PolicyId
-        :param description:  Description of what the policy is entitling
-        :type description: str
-        :param applications:  Applications to which the policy applies
-        :type applications: list[str]
-        :param grant: 
-        :type grant: finbourne_access.Grant
-        :param selectors:  Selectors that this policy will be applied to
-        :type selectors: list[finbourne_access.SelectorDefinition]
-        :param _for:  \"For Specification\" for when the policy is to be applied
-        :type _for: list[finbourne_access.ForSpec]
-        :param _if:  \"If Specification\" for when the policy is to be applied
-        :type _if: list[finbourne_access.IfExpression]
-        :param when: 
-        :type when: finbourne_access.WhenSpec
-        :param how: 
-        :type how: finbourne_access.HowSpec
-        :param links: 
-        :type links: list[finbourne_access.Link]
-
-        """  # noqa: E501
-
-        self._id = None
-        self._description = None
-        self._applications = None
-        self._grant = None
-        self._selectors = None
-        self.__for = None
-        self.__if = None
-        self._when = None
-        self._how = None
-        self._links = None
-        self.discriminator = None
-
-        if id is not None:
-            self.id = id
-        self.description = description
-        self.applications = applications
-        if grant is not None:
-            self.grant = grant
-        self.selectors = selectors
-        self._for = _for
-        self._if = _if
-        if when is not None:
-            self.when = when
-        if how is not None:
-            self.how = how
-        self.links = links
-
-    @property
-    def id(self):
-        """Gets the id of this PolicyResponse.  # noqa: E501
-
-
-        :return: The id of this PolicyResponse.  # noqa: E501
-        :rtype: PolicyId
-        """
-        return self._id
-
-    @id.setter
-    def id(self, id):
-        """Sets the id of this PolicyResponse.
-
-
-        :param id: The id of this PolicyResponse.  # noqa: E501
-        :type: PolicyId
-        """
-
-        self._id = id
-
-    @property
-    def description(self):
-        """Gets the description of this PolicyResponse.  # noqa: E501
-
-        Description of what the policy is entitling  # noqa: E501
-
-        :return: The description of this PolicyResponse.  # noqa: E501
-        :rtype: str
-        """
-        return self._description
-
-    @description.setter
-    def description(self, description):
-        """Sets the description of this PolicyResponse.
-
-        Description of what the policy is entitling  # noqa: E501
-
-        :param description: The description of this PolicyResponse.  # noqa: E501
-        :type: str
-        """
-
-        self._description = description
-
-    @property
-    def applications(self):
-        """Gets the applications of this PolicyResponse.  # noqa: E501
-
-        Applications to which the policy applies  # noqa: E501
-
-        :return: The applications of this PolicyResponse.  # noqa: E501
-        :rtype: list[str]
-        """
-        return self._applications
-
-    @applications.setter
-    def applications(self, applications):
-        """Sets the applications of this PolicyResponse.
-
-        Applications to which the policy applies  # noqa: E501
-
-        :param applications: The applications of this PolicyResponse.  # noqa: E501
-        :type: list[str]
-        """
-
-        self._applications = applications
-
-    @property
-    def grant(self):
-        """Gets the grant of this PolicyResponse.  # noqa: E501
-
-
-        :return: The grant of this PolicyResponse.  # noqa: E501
-        :rtype: Grant
-        """
-        return self._grant
-
-    @grant.setter
-    def grant(self, grant):
-        """Sets the grant of this PolicyResponse.
-
-
-        :param grant: The grant of this PolicyResponse.  # noqa: E501
-        :type: Grant
-        """
-
-        self._grant = grant
-
-    @property
-    def selectors(self):
-        """Gets the selectors of this PolicyResponse.  # noqa: E501
-
-        Selectors that this policy will be applied to  # noqa: E501
-
-        :return: The selectors of this PolicyResponse.  # noqa: E501
-        :rtype: list[SelectorDefinition]
-        """
-        return self._selectors
-
-    @selectors.setter
-    def selectors(self, selectors):
-        """Sets the selectors of this PolicyResponse.
-
-        Selectors that this policy will be applied to  # noqa: E501
-
-        :param selectors: The selectors of this PolicyResponse.  # noqa: E501
-        :type: list[SelectorDefinition]
-        """
-
-        self._selectors = selectors
-
-    @property
-    def _for(self):
-        """Gets the _for of this PolicyResponse.  # noqa: E501
-
-        \"For Specification\" for when the policy is to be applied  # noqa: E501
-
-        :return: The _for of this PolicyResponse.  # noqa: E501
-        :rtype: list[ForSpec]
-        """
-        return self.__for
-
-    @_for.setter
-    def _for(self, _for):
-        """Sets the _for of this PolicyResponse.
-
-        \"For Specification\" for when the policy is to be applied  # noqa: E501
-
-        :param _for: The _for of this PolicyResponse.  # noqa: E501
-        :type: list[ForSpec]
-        """
-
-        self.__for = _for
-
-    @property
-    def _if(self):
-        """Gets the _if of this PolicyResponse.  # noqa: E501
-
-        \"If Specification\" for when the policy is to be applied  # noqa: E501
-
-        :return: The _if of this PolicyResponse.  # noqa: E501
-        :rtype: list[IfExpression]
-        """
-        return self.__if
-
-    @_if.setter
-    def _if(self, _if):
-        """Sets the _if of this PolicyResponse.
-
-        \"If Specification\" for when the policy is to be applied  # noqa: E501
-
-        :param _if: The _if of this PolicyResponse.  # noqa: E501
-        :type: list[IfExpression]
-        """
-
-        self.__if = _if
-
-    @property
-    def when(self):
-        """Gets the when of this PolicyResponse.  # noqa: E501
-
-
-        :return: The when of this PolicyResponse.  # noqa: E501
-        :rtype: WhenSpec
-        """
-        return self._when
-
-    @when.setter
-    def when(self, when):
-        """Sets the when of this PolicyResponse.
-
-
-        :param when: The when of this PolicyResponse.  # noqa: E501
-        :type: WhenSpec
-        """
-
-        self._when = when
-
-    @property
-    def how(self):
-        """Gets the how of this PolicyResponse.  # noqa: E501
-
-
-        :return: The how of this PolicyResponse.  # noqa: E501
-        :rtype: HowSpec
-        """
-        return self._how
-
-    @how.setter
-    def how(self, how):
-        """Sets the how of this PolicyResponse.
-
-
-        :param how: The how of this PolicyResponse.  # noqa: E501
-        :type: HowSpec
-        """
-
-        self._how = how
-
-    @property
-    def links(self):
-        """Gets the links of this PolicyResponse.  # noqa: E501
-
-
-        :return: The links of this PolicyResponse.  # noqa: E501
-        :rtype: list[Link]
-        """
-        return self._links
-
-    @links.setter
-    def links(self, links):
-        """Sets the links of this PolicyResponse.
-
-
-        :param links: The links of this PolicyResponse.  # noqa: E501
-        :type: list[Link]
-        """
-
-        self._links = links
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, PolicyResponse):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class PolicyResponse(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'id': 'PolicyId',
+        'description': 'str',
+        'applications': 'list[str]',
+        'grant': 'Grant',
+        'selectors': 'list[SelectorDefinition]',
+        '_for': 'list[ForSpec]',
+        '_if': 'list[IfExpression]',
+        'when': 'WhenSpec',
+        'how': 'HowSpec',
+        'links': 'list[Link]'
+    }
+
+    attribute_map = {
+        'id': 'id',
+        'description': 'description',
+        'applications': 'applications',
+        'grant': 'grant',
+        'selectors': 'selectors',
+        '_for': 'for',
+        '_if': 'if',
+        'when': 'when',
+        'how': 'how',
+        'links': 'links'
+    }
+
+    required_map = {
+        'id': 'optional',
+        'description': 'optional',
+        'applications': 'optional',
+        'grant': 'optional',
+        'selectors': 'optional',
+        '_for': 'optional',
+        '_if': 'optional',
+        'when': 'optional',
+        'how': 'optional',
+        'links': 'optional'
+    }
+
+    def __init__(self, id=None, description=None, applications=None, grant=None, selectors=None, _for=None, _if=None, when=None, how=None, links=None):  # noqa: E501
+        """
+        PolicyResponse - a model defined in OpenAPI
+
+        :param id: 
+        :type id: finbourne_access.PolicyId
+        :param description:  Description of what the policy is entitling
+        :type description: str
+        :param applications:  Applications to which the policy applies
+        :type applications: list[str]
+        :param grant: 
+        :type grant: finbourne_access.Grant
+        :param selectors:  Selectors that this policy will be applied to
+        :type selectors: list[finbourne_access.SelectorDefinition]
+        :param _for:  \"For Specification\" for when the policy is to be applied
+        :type _for: list[finbourne_access.ForSpec]
+        :param _if:  \"If Specification\" for when the policy is to be applied
+        :type _if: list[finbourne_access.IfExpression]
+        :param when: 
+        :type when: finbourne_access.WhenSpec
+        :param how: 
+        :type how: finbourne_access.HowSpec
+        :param links: 
+        :type links: list[finbourne_access.Link]
+
+        """  # noqa: E501
+
+        self._id = None
+        self._description = None
+        self._applications = None
+        self._grant = None
+        self._selectors = None
+        self.__for = None
+        self.__if = None
+        self._when = None
+        self._how = None
+        self._links = None
+        self.discriminator = None
+
+        if id is not None:
+            self.id = id
+        self.description = description
+        self.applications = applications
+        if grant is not None:
+            self.grant = grant
+        self.selectors = selectors
+        self._for = _for
+        self._if = _if
+        if when is not None:
+            self.when = when
+        if how is not None:
+            self.how = how
+        self.links = links
+
+    @property
+    def id(self):
+        """Gets the id of this PolicyResponse.  # noqa: E501
+
+
+        :return: The id of this PolicyResponse.  # noqa: E501
+        :rtype: PolicyId
+        """
+        return self._id
+
+    @id.setter
+    def id(self, id):
+        """Sets the id of this PolicyResponse.
+
+
+        :param id: The id of this PolicyResponse.  # noqa: E501
+        :type: PolicyId
+        """
+
+        self._id = id
+
+    @property
+    def description(self):
+        """Gets the description of this PolicyResponse.  # noqa: E501
+
+        Description of what the policy is entitling  # noqa: E501
+
+        :return: The description of this PolicyResponse.  # noqa: E501
+        :rtype: str
+        """
+        return self._description
+
+    @description.setter
+    def description(self, description):
+        """Sets the description of this PolicyResponse.
+
+        Description of what the policy is entitling  # noqa: E501
+
+        :param description: The description of this PolicyResponse.  # noqa: E501
+        :type: str
+        """
+
+        self._description = description
+
+    @property
+    def applications(self):
+        """Gets the applications of this PolicyResponse.  # noqa: E501
+
+        Applications to which the policy applies  # noqa: E501
+
+        :return: The applications of this PolicyResponse.  # noqa: E501
+        :rtype: list[str]
+        """
+        return self._applications
+
+    @applications.setter
+    def applications(self, applications):
+        """Sets the applications of this PolicyResponse.
+
+        Applications to which the policy applies  # noqa: E501
+
+        :param applications: The applications of this PolicyResponse.  # noqa: E501
+        :type: list[str]
+        """
+
+        self._applications = applications
+
+    @property
+    def grant(self):
+        """Gets the grant of this PolicyResponse.  # noqa: E501
+
+
+        :return: The grant of this PolicyResponse.  # noqa: E501
+        :rtype: Grant
+        """
+        return self._grant
+
+    @grant.setter
+    def grant(self, grant):
+        """Sets the grant of this PolicyResponse.
+
+
+        :param grant: The grant of this PolicyResponse.  # noqa: E501
+        :type: Grant
+        """
+
+        self._grant = grant
+
+    @property
+    def selectors(self):
+        """Gets the selectors of this PolicyResponse.  # noqa: E501
+
+        Selectors that this policy will be applied to  # noqa: E501
+
+        :return: The selectors of this PolicyResponse.  # noqa: E501
+        :rtype: list[SelectorDefinition]
+        """
+        return self._selectors
+
+    @selectors.setter
+    def selectors(self, selectors):
+        """Sets the selectors of this PolicyResponse.
+
+        Selectors that this policy will be applied to  # noqa: E501
+
+        :param selectors: The selectors of this PolicyResponse.  # noqa: E501
+        :type: list[SelectorDefinition]
+        """
+
+        self._selectors = selectors
+
+    @property
+    def _for(self):
+        """Gets the _for of this PolicyResponse.  # noqa: E501
+
+        \"For Specification\" for when the policy is to be applied  # noqa: E501
+
+        :return: The _for of this PolicyResponse.  # noqa: E501
+        :rtype: list[ForSpec]
+        """
+        return self.__for
+
+    @_for.setter
+    def _for(self, _for):
+        """Sets the _for of this PolicyResponse.
+
+        \"For Specification\" for when the policy is to be applied  # noqa: E501
+
+        :param _for: The _for of this PolicyResponse.  # noqa: E501
+        :type: list[ForSpec]
+        """
+
+        self.__for = _for
+
+    @property
+    def _if(self):
+        """Gets the _if of this PolicyResponse.  # noqa: E501
+
+        \"If Specification\" for when the policy is to be applied  # noqa: E501
+
+        :return: The _if of this PolicyResponse.  # noqa: E501
+        :rtype: list[IfExpression]
+        """
+        return self.__if
+
+    @_if.setter
+    def _if(self, _if):
+        """Sets the _if of this PolicyResponse.
+
+        \"If Specification\" for when the policy is to be applied  # noqa: E501
+
+        :param _if: The _if of this PolicyResponse.  # noqa: E501
+        :type: list[IfExpression]
+        """
+
+        self.__if = _if
+
+    @property
+    def when(self):
+        """Gets the when of this PolicyResponse.  # noqa: E501
+
+
+        :return: The when of this PolicyResponse.  # noqa: E501
+        :rtype: WhenSpec
+        """
+        return self._when
+
+    @when.setter
+    def when(self, when):
+        """Sets the when of this PolicyResponse.
+
+
+        :param when: The when of this PolicyResponse.  # noqa: E501
+        :type: WhenSpec
+        """
+
+        self._when = when
+
+    @property
+    def how(self):
+        """Gets the how of this PolicyResponse.  # noqa: E501
+
+
+        :return: The how of this PolicyResponse.  # noqa: E501
+        :rtype: HowSpec
+        """
+        return self._how
+
+    @how.setter
+    def how(self, how):
+        """Sets the how of this PolicyResponse.
+
+
+        :param how: The how of this PolicyResponse.  # noqa: E501
+        :type: HowSpec
+        """
+
+        self._how = how
+
+    @property
+    def links(self):
+        """Gets the links of this PolicyResponse.  # noqa: E501
+
+
+        :return: The links of this PolicyResponse.  # noqa: E501
+        :rtype: list[Link]
+        """
+        return self._links
+
+    @links.setter
+    def links(self, links):
+        """Sets the links of this PolicyResponse.
+
+
+        :param links: The links of this PolicyResponse.  # noqa: E501
+        :type: list[Link]
+        """
+
+        self._links = links
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, PolicyResponse):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/policy_selector_definition.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/policy_selector_definition.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,235 +1,245 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class PolicySelectorDefinition(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'identity_restriction': 'dict(str, str)',
-        'restriction_selectors': 'list[SelectorDefinition]',
-        'actions': 'list[ActionId]',
-        'name': 'str',
-        'description': 'str'
-    }
-
-    attribute_map = {
-        'identity_restriction': 'identityRestriction',
-        'restriction_selectors': 'restrictionSelectors',
-        'actions': 'actions',
-        'name': 'name',
-        'description': 'description'
-    }
-
-    required_map = {
-        'identity_restriction': 'optional',
-        'restriction_selectors': 'optional',
-        'actions': 'optional',
-        'name': 'optional',
-        'description': 'optional'
-    }
-
-    def __init__(self, identity_restriction=None, restriction_selectors=None, actions=None, name=None, description=None):  # noqa: E501
-        """
-        PolicySelectorDefinition - a model defined in OpenAPI
-
-        :param identity_restriction: 
-        :type identity_restriction: dict(str, str)
-        :param restriction_selectors: 
-        :type restriction_selectors: list[finbourne_access.SelectorDefinition]
-        :param actions: 
-        :type actions: list[finbourne_access.ActionId]
-        :param name: 
-        :type name: str
-        :param description: 
-        :type description: str
-
-        """  # noqa: E501
-
-        self._identity_restriction = None
-        self._restriction_selectors = None
-        self._actions = None
-        self._name = None
-        self._description = None
-        self.discriminator = None
-
-        self.identity_restriction = identity_restriction
-        self.restriction_selectors = restriction_selectors
-        self.actions = actions
-        self.name = name
-        self.description = description
-
-    @property
-    def identity_restriction(self):
-        """Gets the identity_restriction of this PolicySelectorDefinition.  # noqa: E501
-
-
-        :return: The identity_restriction of this PolicySelectorDefinition.  # noqa: E501
-        :rtype: dict(str, str)
-        """
-        return self._identity_restriction
-
-    @identity_restriction.setter
-    def identity_restriction(self, identity_restriction):
-        """Sets the identity_restriction of this PolicySelectorDefinition.
-
-
-        :param identity_restriction: The identity_restriction of this PolicySelectorDefinition.  # noqa: E501
-        :type: dict(str, str)
-        """
-
-        self._identity_restriction = identity_restriction
-
-    @property
-    def restriction_selectors(self):
-        """Gets the restriction_selectors of this PolicySelectorDefinition.  # noqa: E501
-
-
-        :return: The restriction_selectors of this PolicySelectorDefinition.  # noqa: E501
-        :rtype: list[SelectorDefinition]
-        """
-        return self._restriction_selectors
-
-    @restriction_selectors.setter
-    def restriction_selectors(self, restriction_selectors):
-        """Sets the restriction_selectors of this PolicySelectorDefinition.
-
-
-        :param restriction_selectors: The restriction_selectors of this PolicySelectorDefinition.  # noqa: E501
-        :type: list[SelectorDefinition]
-        """
-
-        self._restriction_selectors = restriction_selectors
-
-    @property
-    def actions(self):
-        """Gets the actions of this PolicySelectorDefinition.  # noqa: E501
-
-
-        :return: The actions of this PolicySelectorDefinition.  # noqa: E501
-        :rtype: list[ActionId]
-        """
-        return self._actions
-
-    @actions.setter
-    def actions(self, actions):
-        """Sets the actions of this PolicySelectorDefinition.
-
-
-        :param actions: The actions of this PolicySelectorDefinition.  # noqa: E501
-        :type: list[ActionId]
-        """
-
-        self._actions = actions
-
-    @property
-    def name(self):
-        """Gets the name of this PolicySelectorDefinition.  # noqa: E501
-
-
-        :return: The name of this PolicySelectorDefinition.  # noqa: E501
-        :rtype: str
-        """
-        return self._name
-
-    @name.setter
-    def name(self, name):
-        """Sets the name of this PolicySelectorDefinition.
-
-
-        :param name: The name of this PolicySelectorDefinition.  # noqa: E501
-        :type: str
-        """
-
-        self._name = name
-
-    @property
-    def description(self):
-        """Gets the description of this PolicySelectorDefinition.  # noqa: E501
-
-
-        :return: The description of this PolicySelectorDefinition.  # noqa: E501
-        :rtype: str
-        """
-        return self._description
-
-    @description.setter
-    def description(self, description):
-        """Sets the description of this PolicySelectorDefinition.
-
-
-        :param description: The description of this PolicySelectorDefinition.  # noqa: E501
-        :type: str
-        """
-
-        self._description = description
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, PolicySelectorDefinition):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class PolicySelectorDefinition(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'identity_restriction': 'dict(str, str)',
+        'restriction_selectors': 'list[SelectorDefinition]',
+        'actions': 'list[ActionId]',
+        'name': 'str',
+        'description': 'str'
+    }
+
+    attribute_map = {
+        'identity_restriction': 'identityRestriction',
+        'restriction_selectors': 'restrictionSelectors',
+        'actions': 'actions',
+        'name': 'name',
+        'description': 'description'
+    }
+
+    required_map = {
+        'identity_restriction': 'optional',
+        'restriction_selectors': 'optional',
+        'actions': 'required',
+        'name': 'optional',
+        'description': 'optional'
+    }
+
+    def __init__(self, identity_restriction=None, restriction_selectors=None, actions=None, name=None, description=None):  # noqa: E501
+        """
+        PolicySelectorDefinition - a model defined in OpenAPI
+
+        :param identity_restriction: 
+        :type identity_restriction: dict(str, str)
+        :param restriction_selectors: 
+        :type restriction_selectors: list[finbourne_access.SelectorDefinition]
+        :param actions:  (required)
+        :type actions: list[finbourne_access.ActionId]
+        :param name: 
+        :type name: str
+        :param description: 
+        :type description: str
+
+        """  # noqa: E501
+
+        self._identity_restriction = None
+        self._restriction_selectors = None
+        self._actions = None
+        self._name = None
+        self._description = None
+        self.discriminator = None
+
+        self.identity_restriction = identity_restriction
+        self.restriction_selectors = restriction_selectors
+        self.actions = actions
+        self.name = name
+        self.description = description
+
+    @property
+    def identity_restriction(self):
+        """Gets the identity_restriction of this PolicySelectorDefinition.  # noqa: E501
+
+
+        :return: The identity_restriction of this PolicySelectorDefinition.  # noqa: E501
+        :rtype: dict(str, str)
+        """
+        return self._identity_restriction
+
+    @identity_restriction.setter
+    def identity_restriction(self, identity_restriction):
+        """Sets the identity_restriction of this PolicySelectorDefinition.
+
+
+        :param identity_restriction: The identity_restriction of this PolicySelectorDefinition.  # noqa: E501
+        :type: dict(str, str)
+        """
+
+        self._identity_restriction = identity_restriction
+
+    @property
+    def restriction_selectors(self):
+        """Gets the restriction_selectors of this PolicySelectorDefinition.  # noqa: E501
+
+
+        :return: The restriction_selectors of this PolicySelectorDefinition.  # noqa: E501
+        :rtype: list[SelectorDefinition]
+        """
+        return self._restriction_selectors
+
+    @restriction_selectors.setter
+    def restriction_selectors(self, restriction_selectors):
+        """Sets the restriction_selectors of this PolicySelectorDefinition.
+
+
+        :param restriction_selectors: The restriction_selectors of this PolicySelectorDefinition.  # noqa: E501
+        :type: list[SelectorDefinition]
+        """
+
+        self._restriction_selectors = restriction_selectors
+
+    @property
+    def actions(self):
+        """Gets the actions of this PolicySelectorDefinition.  # noqa: E501
+
+
+        :return: The actions of this PolicySelectorDefinition.  # noqa: E501
+        :rtype: list[ActionId]
+        """
+        return self._actions
+
+    @actions.setter
+    def actions(self, actions):
+        """Sets the actions of this PolicySelectorDefinition.
+
+
+        :param actions: The actions of this PolicySelectorDefinition.  # noqa: E501
+        :type: list[ActionId]
+        """
+        if actions is None:
+            raise ValueError("Invalid value for `actions`, must not be `None`")  # noqa: E501
+
+        self._actions = actions
+
+    @property
+    def name(self):
+        """Gets the name of this PolicySelectorDefinition.  # noqa: E501
+
+
+        :return: The name of this PolicySelectorDefinition.  # noqa: E501
+        :rtype: str
+        """
+        return self._name
+
+    @name.setter
+    def name(self, name):
+        """Sets the name of this PolicySelectorDefinition.
+
+
+        :param name: The name of this PolicySelectorDefinition.  # noqa: E501
+        :type: str
+        """
+        if name is not None and len(name) > 100:
+            raise ValueError("Invalid value for `name`, length must be less than or equal to `100`")  # noqa: E501
+        if name is not None and len(name) < 0:
+            raise ValueError("Invalid value for `name`, length must be greater than or equal to `0`")  # noqa: E501
+
+        self._name = name
+
+    @property
+    def description(self):
+        """Gets the description of this PolicySelectorDefinition.  # noqa: E501
+
+
+        :return: The description of this PolicySelectorDefinition.  # noqa: E501
+        :rtype: str
+        """
+        return self._description
+
+    @description.setter
+    def description(self, description):
+        """Sets the description of this PolicySelectorDefinition.
+
+
+        :param description: The description of this PolicySelectorDefinition.  # noqa: E501
+        :type: str
+        """
+        if description is not None and len(description) > 1024:
+            raise ValueError("Invalid value for `description`, length must be less than or equal to `1024`")  # noqa: E501
+        if description is not None and len(description) < 0:
+            raise ValueError("Invalid value for `description`, length must be greater than or equal to `0`")  # noqa: E501
+
+        self._description = description
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, PolicySelectorDefinition):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/policy_update_request.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/role_response.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,340 +1,329 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class PolicyUpdateRequest(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'description': 'str',
-        'applications': 'list[str]',
-        'grant': 'Grant',
-        'selectors': 'list[SelectorDefinition]',
-        '_for': 'list[ForSpec]',
-        '_if': 'list[IfExpression]',
-        'when': 'WhenSpec',
-        'how': 'HowSpec'
-    }
-
-    attribute_map = {
-        'description': 'description',
-        'applications': 'applications',
-        'grant': 'grant',
-        'selectors': 'selectors',
-        '_for': 'for',
-        '_if': 'if',
-        'when': 'when',
-        'how': 'how'
-    }
-
-    required_map = {
-        'description': 'optional',
-        'applications': 'optional',
-        'grant': 'required',
-        'selectors': 'required',
-        '_for': 'optional',
-        '_if': 'optional',
-        'when': 'required',
-        'how': 'optional'
-    }
-
-    def __init__(self, description=None, applications=None, grant=None, selectors=None, _for=None, _if=None, when=None, how=None):  # noqa: E501
-        """
-        PolicyUpdateRequest - a model defined in OpenAPI
-
-        :param description:  Description of what the policy will be used for
-        :type description: str
-        :param applications:  Applications this policy is used with
-        :type applications: list[str]
-        :param grant:  (required)
-        :type grant: finbourne_access.Grant
-        :param selectors:  Selectors that identify what resources this policy qualifies for (required)
-        :type selectors: list[finbourne_access.SelectorDefinition]
-        :param _for:  \"For Specification\" for when the policy is to be applied
-        :type _for: list[finbourne_access.ForSpec]
-        :param _if:  \"If Specification\" for when the policy is to be applied
-        :type _if: list[finbourne_access.IfExpression]
-        :param when:  (required)
-        :type when: finbourne_access.WhenSpec
-        :param how: 
-        :type how: finbourne_access.HowSpec
-
-        """  # noqa: E501
-
-        self._description = None
-        self._applications = None
-        self._grant = None
-        self._selectors = None
-        self.__for = None
-        self.__if = None
-        self._when = None
-        self._how = None
-        self.discriminator = None
-
-        self.description = description
-        self.applications = applications
-        self.grant = grant
-        self.selectors = selectors
-        self._for = _for
-        self._if = _if
-        self.when = when
-        if how is not None:
-            self.how = how
-
-    @property
-    def description(self):
-        """Gets the description of this PolicyUpdateRequest.  # noqa: E501
-
-        Description of what the policy will be used for  # noqa: E501
-
-        :return: The description of this PolicyUpdateRequest.  # noqa: E501
-        :rtype: str
-        """
-        return self._description
-
-    @description.setter
-    def description(self, description):
-        """Sets the description of this PolicyUpdateRequest.
-
-        Description of what the policy will be used for  # noqa: E501
-
-        :param description: The description of this PolicyUpdateRequest.  # noqa: E501
-        :type: str
-        """
-        if description is not None and len(description) > 1024:
-            raise ValueError("Invalid value for `description`, length must be less than or equal to `1024`")  # noqa: E501
-        if description is not None and len(description) < 0:
-            raise ValueError("Invalid value for `description`, length must be greater than or equal to `0`")  # noqa: E501
-
-        self._description = description
-
-    @property
-    def applications(self):
-        """Gets the applications of this PolicyUpdateRequest.  # noqa: E501
-
-        Applications this policy is used with  # noqa: E501
-
-        :return: The applications of this PolicyUpdateRequest.  # noqa: E501
-        :rtype: list[str]
-        """
-        return self._applications
-
-    @applications.setter
-    def applications(self, applications):
-        """Sets the applications of this PolicyUpdateRequest.
-
-        Applications this policy is used with  # noqa: E501
-
-        :param applications: The applications of this PolicyUpdateRequest.  # noqa: E501
-        :type: list[str]
-        """
-
-        self._applications = applications
-
-    @property
-    def grant(self):
-        """Gets the grant of this PolicyUpdateRequest.  # noqa: E501
-
-
-        :return: The grant of this PolicyUpdateRequest.  # noqa: E501
-        :rtype: Grant
-        """
-        return self._grant
-
-    @grant.setter
-    def grant(self, grant):
-        """Sets the grant of this PolicyUpdateRequest.
-
-
-        :param grant: The grant of this PolicyUpdateRequest.  # noqa: E501
-        :type: Grant
-        """
-        if grant is None:
-            raise ValueError("Invalid value for `grant`, must not be `None`")  # noqa: E501
-
-        self._grant = grant
-
-    @property
-    def selectors(self):
-        """Gets the selectors of this PolicyUpdateRequest.  # noqa: E501
-
-        Selectors that identify what resources this policy qualifies for  # noqa: E501
-
-        :return: The selectors of this PolicyUpdateRequest.  # noqa: E501
-        :rtype: list[SelectorDefinition]
-        """
-        return self._selectors
-
-    @selectors.setter
-    def selectors(self, selectors):
-        """Sets the selectors of this PolicyUpdateRequest.
-
-        Selectors that identify what resources this policy qualifies for  # noqa: E501
-
-        :param selectors: The selectors of this PolicyUpdateRequest.  # noqa: E501
-        :type: list[SelectorDefinition]
-        """
-        if selectors is None:
-            raise ValueError("Invalid value for `selectors`, must not be `None`")  # noqa: E501
-
-        self._selectors = selectors
-
-    @property
-    def _for(self):
-        """Gets the _for of this PolicyUpdateRequest.  # noqa: E501
-
-        \"For Specification\" for when the policy is to be applied  # noqa: E501
-
-        :return: The _for of this PolicyUpdateRequest.  # noqa: E501
-        :rtype: list[ForSpec]
-        """
-        return self.__for
-
-    @_for.setter
-    def _for(self, _for):
-        """Sets the _for of this PolicyUpdateRequest.
-
-        \"For Specification\" for when the policy is to be applied  # noqa: E501
-
-        :param _for: The _for of this PolicyUpdateRequest.  # noqa: E501
-        :type: list[ForSpec]
-        """
-
-        self.__for = _for
-
-    @property
-    def _if(self):
-        """Gets the _if of this PolicyUpdateRequest.  # noqa: E501
-
-        \"If Specification\" for when the policy is to be applied  # noqa: E501
-
-        :return: The _if of this PolicyUpdateRequest.  # noqa: E501
-        :rtype: list[IfExpression]
-        """
-        return self.__if
-
-    @_if.setter
-    def _if(self, _if):
-        """Sets the _if of this PolicyUpdateRequest.
-
-        \"If Specification\" for when the policy is to be applied  # noqa: E501
-
-        :param _if: The _if of this PolicyUpdateRequest.  # noqa: E501
-        :type: list[IfExpression]
-        """
-
-        self.__if = _if
-
-    @property
-    def when(self):
-        """Gets the when of this PolicyUpdateRequest.  # noqa: E501
-
-
-        :return: The when of this PolicyUpdateRequest.  # noqa: E501
-        :rtype: WhenSpec
-        """
-        return self._when
-
-    @when.setter
-    def when(self, when):
-        """Sets the when of this PolicyUpdateRequest.
-
-
-        :param when: The when of this PolicyUpdateRequest.  # noqa: E501
-        :type: WhenSpec
-        """
-        if when is None:
-            raise ValueError("Invalid value for `when`, must not be `None`")  # noqa: E501
-
-        self._when = when
-
-    @property
-    def how(self):
-        """Gets the how of this PolicyUpdateRequest.  # noqa: E501
-
-
-        :return: The how of this PolicyUpdateRequest.  # noqa: E501
-        :rtype: HowSpec
-        """
-        return self._how
-
-    @how.setter
-    def how(self, how):
-        """Sets the how of this PolicyUpdateRequest.
-
-
-        :param how: The how of this PolicyUpdateRequest.  # noqa: E501
-        :type: HowSpec
-        """
-
-        self._how = how
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, PolicyUpdateRequest):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class RoleResponse(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'id': 'RoleId',
+        'role_hierarchy_index': 'int',
+        'description': 'str',
+        'resource': 'RoleResourceRequest',
+        'when': 'WhenSpec',
+        'permission': 'str',
+        'limit': 'dict(str, str)',
+        'links': 'list[Link]'
+    }
+
+    attribute_map = {
+        'id': 'id',
+        'role_hierarchy_index': 'roleHierarchyIndex',
+        'description': 'description',
+        'resource': 'resource',
+        'when': 'when',
+        'permission': 'permission',
+        'limit': 'limit',
+        'links': 'links'
+    }
+
+    required_map = {
+        'id': 'required',
+        'role_hierarchy_index': 'required',
+        'description': 'optional',
+        'resource': 'required',
+        'when': 'required',
+        'permission': 'required',
+        'limit': 'optional',
+        'links': 'optional'
+    }
+
+    def __init__(self, id=None, role_hierarchy_index=None, description=None, resource=None, when=None, permission=None, limit=None, links=None):  # noqa: E501
+        """
+        RoleResponse - a model defined in OpenAPI
+
+        :param id:  (required)
+        :type id: finbourne_access.RoleId
+        :param role_hierarchy_index:  (required)
+        :type role_hierarchy_index: int
+        :param description: 
+        :type description: str
+        :param resource:  (required)
+        :type resource: finbourne_access.RoleResourceRequest
+        :param when:  (required)
+        :type when: finbourne_access.WhenSpec
+        :param permission:  (required)
+        :type permission: str
+        :param limit: 
+        :type limit: dict(str, str)
+        :param links: 
+        :type links: list[finbourne_access.Link]
+
+        """  # noqa: E501
+
+        self._id = None
+        self._role_hierarchy_index = None
+        self._description = None
+        self._resource = None
+        self._when = None
+        self._permission = None
+        self._limit = None
+        self._links = None
+        self.discriminator = None
+
+        self.id = id
+        self.role_hierarchy_index = role_hierarchy_index
+        self.description = description
+        self.resource = resource
+        self.when = when
+        self.permission = permission
+        self.limit = limit
+        self.links = links
+
+    @property
+    def id(self):
+        """Gets the id of this RoleResponse.  # noqa: E501
+
+
+        :return: The id of this RoleResponse.  # noqa: E501
+        :rtype: RoleId
+        """
+        return self._id
+
+    @id.setter
+    def id(self, id):
+        """Sets the id of this RoleResponse.
+
+
+        :param id: The id of this RoleResponse.  # noqa: E501
+        :type: RoleId
+        """
+        if id is None:
+            raise ValueError("Invalid value for `id`, must not be `None`")  # noqa: E501
+
+        self._id = id
+
+    @property
+    def role_hierarchy_index(self):
+        """Gets the role_hierarchy_index of this RoleResponse.  # noqa: E501
+
+
+        :return: The role_hierarchy_index of this RoleResponse.  # noqa: E501
+        :rtype: int
+        """
+        return self._role_hierarchy_index
+
+    @role_hierarchy_index.setter
+    def role_hierarchy_index(self, role_hierarchy_index):
+        """Sets the role_hierarchy_index of this RoleResponse.
+
+
+        :param role_hierarchy_index: The role_hierarchy_index of this RoleResponse.  # noqa: E501
+        :type: int
+        """
+        if role_hierarchy_index is None:
+            raise ValueError("Invalid value for `role_hierarchy_index`, must not be `None`")  # noqa: E501
+
+        self._role_hierarchy_index = role_hierarchy_index
+
+    @property
+    def description(self):
+        """Gets the description of this RoleResponse.  # noqa: E501
+
+
+        :return: The description of this RoleResponse.  # noqa: E501
+        :rtype: str
+        """
+        return self._description
+
+    @description.setter
+    def description(self, description):
+        """Sets the description of this RoleResponse.
+
+
+        :param description: The description of this RoleResponse.  # noqa: E501
+        :type: str
+        """
+
+        self._description = description
+
+    @property
+    def resource(self):
+        """Gets the resource of this RoleResponse.  # noqa: E501
+
+
+        :return: The resource of this RoleResponse.  # noqa: E501
+        :rtype: RoleResourceRequest
+        """
+        return self._resource
+
+    @resource.setter
+    def resource(self, resource):
+        """Sets the resource of this RoleResponse.
+
+
+        :param resource: The resource of this RoleResponse.  # noqa: E501
+        :type: RoleResourceRequest
+        """
+        if resource is None:
+            raise ValueError("Invalid value for `resource`, must not be `None`")  # noqa: E501
+
+        self._resource = resource
+
+    @property
+    def when(self):
+        """Gets the when of this RoleResponse.  # noqa: E501
+
+
+        :return: The when of this RoleResponse.  # noqa: E501
+        :rtype: WhenSpec
+        """
+        return self._when
+
+    @when.setter
+    def when(self, when):
+        """Sets the when of this RoleResponse.
+
+
+        :param when: The when of this RoleResponse.  # noqa: E501
+        :type: WhenSpec
+        """
+        if when is None:
+            raise ValueError("Invalid value for `when`, must not be `None`")  # noqa: E501
+
+        self._when = when
+
+    @property
+    def permission(self):
+        """Gets the permission of this RoleResponse.  # noqa: E501
+
+
+        :return: The permission of this RoleResponse.  # noqa: E501
+        :rtype: str
+        """
+        return self._permission
+
+    @permission.setter
+    def permission(self, permission):
+        """Sets the permission of this RoleResponse.
+
+
+        :param permission: The permission of this RoleResponse.  # noqa: E501
+        :type: str
+        """
+        if permission is None:
+            raise ValueError("Invalid value for `permission`, must not be `None`")  # noqa: E501
+
+        self._permission = permission
+
+    @property
+    def limit(self):
+        """Gets the limit of this RoleResponse.  # noqa: E501
+
+
+        :return: The limit of this RoleResponse.  # noqa: E501
+        :rtype: dict(str, str)
+        """
+        return self._limit
+
+    @limit.setter
+    def limit(self, limit):
+        """Sets the limit of this RoleResponse.
+
+
+        :param limit: The limit of this RoleResponse.  # noqa: E501
+        :type: dict(str, str)
+        """
+
+        self._limit = limit
+
+    @property
+    def links(self):
+        """Gets the links of this RoleResponse.  # noqa: E501
+
+
+        :return: The links of this RoleResponse.  # noqa: E501
+        :rtype: list[Link]
+        """
+        return self._links
+
+    @links.setter
+    def links(self, links):
+        """Sets the links of this RoleResponse.
+
+
+        :param links: The links of this RoleResponse.  # noqa: E501
+        :type: list[Link]
+        """
+
+        self._links = links
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, RoleResponse):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/request_details.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/request_details.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,245 +1,245 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class RequestDetails(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'action': 'RequestedActionKey',
-        'from_effective_date': 'datetime',
-        'to_effective_date': 'datetime',
-        'from_as_at': 'datetime',
-        'to_as_at': 'datetime'
-    }
-
-    attribute_map = {
-        'action': 'action',
-        'from_effective_date': 'fromEffectiveDate',
-        'to_effective_date': 'toEffectiveDate',
-        'from_as_at': 'fromAsAt',
-        'to_as_at': 'toAsAt'
-    }
-
-    required_map = {
-        'action': 'required',
-        'from_effective_date': 'optional',
-        'to_effective_date': 'optional',
-        'from_as_at': 'optional',
-        'to_as_at': 'optional'
-    }
-
-    def __init__(self, action=None, from_effective_date=None, to_effective_date=None, from_as_at=None, to_as_at=None):  # noqa: E501
-        """
-        RequestDetails - a model defined in OpenAPI
-
-        :param action:  (required)
-        :type action: finbourne_access.RequestedActionKey
-        :param from_effective_date:  The start date for the requested effective date range for the resource (if null, UtcNow)
-        :type from_effective_date: datetime
-        :param to_effective_date:  The end date for the requested effective date range for the resource (if null, same as from date)
-        :type to_effective_date: datetime
-        :param from_as_at:  The requested AsAt date for the resource (if null, Latest). If specifying a range of AsAt dates, this is the lower bounds.
-        :type from_as_at: datetime
-        :param to_as_at:  Upper bound if specifying a request that requires a range of AsAt dates. This is used if specifying the desire to grant access for a user between an AsAt range.
-        :type to_as_at: datetime
-
-        """  # noqa: E501
-
-        self._action = None
-        self._from_effective_date = None
-        self._to_effective_date = None
-        self._from_as_at = None
-        self._to_as_at = None
-        self.discriminator = None
-
-        self.action = action
-        self.from_effective_date = from_effective_date
-        self.to_effective_date = to_effective_date
-        self.from_as_at = from_as_at
-        self.to_as_at = to_as_at
-
-    @property
-    def action(self):
-        """Gets the action of this RequestDetails.  # noqa: E501
-
-
-        :return: The action of this RequestDetails.  # noqa: E501
-        :rtype: RequestedActionKey
-        """
-        return self._action
-
-    @action.setter
-    def action(self, action):
-        """Sets the action of this RequestDetails.
-
-
-        :param action: The action of this RequestDetails.  # noqa: E501
-        :type: RequestedActionKey
-        """
-        if action is None:
-            raise ValueError("Invalid value for `action`, must not be `None`")  # noqa: E501
-
-        self._action = action
-
-    @property
-    def from_effective_date(self):
-        """Gets the from_effective_date of this RequestDetails.  # noqa: E501
-
-        The start date for the requested effective date range for the resource (if null, UtcNow)  # noqa: E501
-
-        :return: The from_effective_date of this RequestDetails.  # noqa: E501
-        :rtype: datetime
-        """
-        return self._from_effective_date
-
-    @from_effective_date.setter
-    def from_effective_date(self, from_effective_date):
-        """Sets the from_effective_date of this RequestDetails.
-
-        The start date for the requested effective date range for the resource (if null, UtcNow)  # noqa: E501
-
-        :param from_effective_date: The from_effective_date of this RequestDetails.  # noqa: E501
-        :type: datetime
-        """
-
-        self._from_effective_date = from_effective_date
-
-    @property
-    def to_effective_date(self):
-        """Gets the to_effective_date of this RequestDetails.  # noqa: E501
-
-        The end date for the requested effective date range for the resource (if null, same as from date)  # noqa: E501
-
-        :return: The to_effective_date of this RequestDetails.  # noqa: E501
-        :rtype: datetime
-        """
-        return self._to_effective_date
-
-    @to_effective_date.setter
-    def to_effective_date(self, to_effective_date):
-        """Sets the to_effective_date of this RequestDetails.
-
-        The end date for the requested effective date range for the resource (if null, same as from date)  # noqa: E501
-
-        :param to_effective_date: The to_effective_date of this RequestDetails.  # noqa: E501
-        :type: datetime
-        """
-
-        self._to_effective_date = to_effective_date
-
-    @property
-    def from_as_at(self):
-        """Gets the from_as_at of this RequestDetails.  # noqa: E501
-
-        The requested AsAt date for the resource (if null, Latest). If specifying a range of AsAt dates, this is the lower bounds.  # noqa: E501
-
-        :return: The from_as_at of this RequestDetails.  # noqa: E501
-        :rtype: datetime
-        """
-        return self._from_as_at
-
-    @from_as_at.setter
-    def from_as_at(self, from_as_at):
-        """Sets the from_as_at of this RequestDetails.
-
-        The requested AsAt date for the resource (if null, Latest). If specifying a range of AsAt dates, this is the lower bounds.  # noqa: E501
-
-        :param from_as_at: The from_as_at of this RequestDetails.  # noqa: E501
-        :type: datetime
-        """
-
-        self._from_as_at = from_as_at
-
-    @property
-    def to_as_at(self):
-        """Gets the to_as_at of this RequestDetails.  # noqa: E501
-
-        Upper bound if specifying a request that requires a range of AsAt dates. This is used if specifying the desire to grant access for a user between an AsAt range.  # noqa: E501
-
-        :return: The to_as_at of this RequestDetails.  # noqa: E501
-        :rtype: datetime
-        """
-        return self._to_as_at
-
-    @to_as_at.setter
-    def to_as_at(self, to_as_at):
-        """Sets the to_as_at of this RequestDetails.
-
-        Upper bound if specifying a request that requires a range of AsAt dates. This is used if specifying the desire to grant access for a user between an AsAt range.  # noqa: E501
-
-        :param to_as_at: The to_as_at of this RequestDetails.  # noqa: E501
-        :type: datetime
-        """
-
-        self._to_as_at = to_as_at
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, RequestDetails):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class RequestDetails(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'action': 'RequestedActionKey',
+        'from_effective_date': 'datetime',
+        'to_effective_date': 'datetime',
+        'from_as_at': 'datetime',
+        'to_as_at': 'datetime'
+    }
+
+    attribute_map = {
+        'action': 'action',
+        'from_effective_date': 'fromEffectiveDate',
+        'to_effective_date': 'toEffectiveDate',
+        'from_as_at': 'fromAsAt',
+        'to_as_at': 'toAsAt'
+    }
+
+    required_map = {
+        'action': 'required',
+        'from_effective_date': 'optional',
+        'to_effective_date': 'optional',
+        'from_as_at': 'optional',
+        'to_as_at': 'optional'
+    }
+
+    def __init__(self, action=None, from_effective_date=None, to_effective_date=None, from_as_at=None, to_as_at=None):  # noqa: E501
+        """
+        RequestDetails - a model defined in OpenAPI
+
+        :param action:  (required)
+        :type action: finbourne_access.RequestedActionKey
+        :param from_effective_date:  The start date for the requested effective date range for the resource (if null, UtcNow)
+        :type from_effective_date: datetime
+        :param to_effective_date:  The end date for the requested effective date range for the resource (if null, same as from date)
+        :type to_effective_date: datetime
+        :param from_as_at:  The requested AsAt date for the resource (if null, Latest). If specifying a range of AsAt dates, this is the lower bounds.
+        :type from_as_at: datetime
+        :param to_as_at:  Upper bound if specifying a request that requires a range of AsAt dates. This is used if specifying the desire to grant access for a user between an AsAt range.
+        :type to_as_at: datetime
+
+        """  # noqa: E501
+
+        self._action = None
+        self._from_effective_date = None
+        self._to_effective_date = None
+        self._from_as_at = None
+        self._to_as_at = None
+        self.discriminator = None
+
+        self.action = action
+        self.from_effective_date = from_effective_date
+        self.to_effective_date = to_effective_date
+        self.from_as_at = from_as_at
+        self.to_as_at = to_as_at
+
+    @property
+    def action(self):
+        """Gets the action of this RequestDetails.  # noqa: E501
+
+
+        :return: The action of this RequestDetails.  # noqa: E501
+        :rtype: RequestedActionKey
+        """
+        return self._action
+
+    @action.setter
+    def action(self, action):
+        """Sets the action of this RequestDetails.
+
+
+        :param action: The action of this RequestDetails.  # noqa: E501
+        :type: RequestedActionKey
+        """
+        if action is None:
+            raise ValueError("Invalid value for `action`, must not be `None`")  # noqa: E501
+
+        self._action = action
+
+    @property
+    def from_effective_date(self):
+        """Gets the from_effective_date of this RequestDetails.  # noqa: E501
+
+        The start date for the requested effective date range for the resource (if null, UtcNow)  # noqa: E501
+
+        :return: The from_effective_date of this RequestDetails.  # noqa: E501
+        :rtype: datetime
+        """
+        return self._from_effective_date
+
+    @from_effective_date.setter
+    def from_effective_date(self, from_effective_date):
+        """Sets the from_effective_date of this RequestDetails.
+
+        The start date for the requested effective date range for the resource (if null, UtcNow)  # noqa: E501
+
+        :param from_effective_date: The from_effective_date of this RequestDetails.  # noqa: E501
+        :type: datetime
+        """
+
+        self._from_effective_date = from_effective_date
+
+    @property
+    def to_effective_date(self):
+        """Gets the to_effective_date of this RequestDetails.  # noqa: E501
+
+        The end date for the requested effective date range for the resource (if null, same as from date)  # noqa: E501
+
+        :return: The to_effective_date of this RequestDetails.  # noqa: E501
+        :rtype: datetime
+        """
+        return self._to_effective_date
+
+    @to_effective_date.setter
+    def to_effective_date(self, to_effective_date):
+        """Sets the to_effective_date of this RequestDetails.
+
+        The end date for the requested effective date range for the resource (if null, same as from date)  # noqa: E501
+
+        :param to_effective_date: The to_effective_date of this RequestDetails.  # noqa: E501
+        :type: datetime
+        """
+
+        self._to_effective_date = to_effective_date
+
+    @property
+    def from_as_at(self):
+        """Gets the from_as_at of this RequestDetails.  # noqa: E501
+
+        The requested AsAt date for the resource (if null, Latest). If specifying a range of AsAt dates, this is the lower bounds.  # noqa: E501
+
+        :return: The from_as_at of this RequestDetails.  # noqa: E501
+        :rtype: datetime
+        """
+        return self._from_as_at
+
+    @from_as_at.setter
+    def from_as_at(self, from_as_at):
+        """Sets the from_as_at of this RequestDetails.
+
+        The requested AsAt date for the resource (if null, Latest). If specifying a range of AsAt dates, this is the lower bounds.  # noqa: E501
+
+        :param from_as_at: The from_as_at of this RequestDetails.  # noqa: E501
+        :type: datetime
+        """
+
+        self._from_as_at = from_as_at
+
+    @property
+    def to_as_at(self):
+        """Gets the to_as_at of this RequestDetails.  # noqa: E501
+
+        Upper bound if specifying a request that requires a range of AsAt dates. This is used if specifying the desire to grant access for a user between an AsAt range.  # noqa: E501
+
+        :return: The to_as_at of this RequestDetails.  # noqa: E501
+        :rtype: datetime
+        """
+        return self._to_as_at
+
+    @to_as_at.setter
+    def to_as_at(self, to_as_at):
+        """Sets the to_as_at of this RequestDetails.
+
+        Upper bound if specifying a request that requires a range of AsAt dates. This is used if specifying the desire to grant access for a user between an AsAt range.  # noqa: E501
+
+        :param to_as_at: The to_as_at of this RequestDetails.  # noqa: E501
+        :type: datetime
+        """
+
+        self._to_as_at = to_as_at
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, RequestDetails):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/requested_action_key.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/requested_action_key.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,203 +1,203 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class RequestedActionKey(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'entity_code': 'str',
-        'scope': 'str',
-        'activity': 'str'
-    }
-
-    attribute_map = {
-        'entity_code': 'entityCode',
-        'scope': 'scope',
-        'activity': 'activity'
-    }
-
-    required_map = {
-        'entity_code': 'required',
-        'scope': 'required',
-        'activity': 'required'
-    }
-
-    def __init__(self, entity_code=None, scope=None, activity=None):  # noqa: E501
-        """
-        RequestedActionKey - a model defined in OpenAPI
-
-        :param entity_code:  The type of the resource on which the activity would be performed (required)
-        :type entity_code: str
-        :param scope:  The scope/provider/vendor of the activity (required)
-        :type scope: str
-        :param activity:  The identifier of the action to be performed on the resource (required)
-        :type activity: str
-
-        """  # noqa: E501
-
-        self._entity_code = None
-        self._scope = None
-        self._activity = None
-        self.discriminator = None
-
-        self.entity_code = entity_code
-        self.scope = scope
-        self.activity = activity
-
-    @property
-    def entity_code(self):
-        """Gets the entity_code of this RequestedActionKey.  # noqa: E501
-
-        The type of the resource on which the activity would be performed  # noqa: E501
-
-        :return: The entity_code of this RequestedActionKey.  # noqa: E501
-        :rtype: str
-        """
-        return self._entity_code
-
-    @entity_code.setter
-    def entity_code(self, entity_code):
-        """Sets the entity_code of this RequestedActionKey.
-
-        The type of the resource on which the activity would be performed  # noqa: E501
-
-        :param entity_code: The entity_code of this RequestedActionKey.  # noqa: E501
-        :type: str
-        """
-        if entity_code is None:
-            raise ValueError("Invalid value for `entity_code`, must not be `None`")  # noqa: E501
-        if entity_code is not None and len(entity_code) > 100:
-            raise ValueError("Invalid value for `entity_code`, length must be less than or equal to `100`")  # noqa: E501
-        if entity_code is not None and len(entity_code) < 3:
-            raise ValueError("Invalid value for `entity_code`, length must be greater than or equal to `3`")  # noqa: E501
-
-        self._entity_code = entity_code
-
-    @property
-    def scope(self):
-        """Gets the scope of this RequestedActionKey.  # noqa: E501
-
-        The scope/provider/vendor of the activity  # noqa: E501
-
-        :return: The scope of this RequestedActionKey.  # noqa: E501
-        :rtype: str
-        """
-        return self._scope
-
-    @scope.setter
-    def scope(self, scope):
-        """Sets the scope of this RequestedActionKey.
-
-        The scope/provider/vendor of the activity  # noqa: E501
-
-        :param scope: The scope of this RequestedActionKey.  # noqa: E501
-        :type: str
-        """
-        if scope is None:
-            raise ValueError("Invalid value for `scope`, must not be `None`")  # noqa: E501
-        if scope is not None and len(scope) > 100:
-            raise ValueError("Invalid value for `scope`, length must be less than or equal to `100`")  # noqa: E501
-        if scope is not None and len(scope) < 3:
-            raise ValueError("Invalid value for `scope`, length must be greater than or equal to `3`")  # noqa: E501
-
-        self._scope = scope
-
-    @property
-    def activity(self):
-        """Gets the activity of this RequestedActionKey.  # noqa: E501
-
-        The identifier of the action to be performed on the resource  # noqa: E501
-
-        :return: The activity of this RequestedActionKey.  # noqa: E501
-        :rtype: str
-        """
-        return self._activity
-
-    @activity.setter
-    def activity(self, activity):
-        """Sets the activity of this RequestedActionKey.
-
-        The identifier of the action to be performed on the resource  # noqa: E501
-
-        :param activity: The activity of this RequestedActionKey.  # noqa: E501
-        :type: str
-        """
-        if activity is None:
-            raise ValueError("Invalid value for `activity`, must not be `None`")  # noqa: E501
-        if activity is not None and len(activity) > 100:
-            raise ValueError("Invalid value for `activity`, length must be less than or equal to `100`")  # noqa: E501
-        if activity is not None and len(activity) < 3:
-            raise ValueError("Invalid value for `activity`, length must be greater than or equal to `3`")  # noqa: E501
-
-        self._activity = activity
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, RequestedActionKey):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class RequestedActionKey(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'entity_code': 'str',
+        'scope': 'str',
+        'activity': 'str'
+    }
+
+    attribute_map = {
+        'entity_code': 'entityCode',
+        'scope': 'scope',
+        'activity': 'activity'
+    }
+
+    required_map = {
+        'entity_code': 'required',
+        'scope': 'required',
+        'activity': 'required'
+    }
+
+    def __init__(self, entity_code=None, scope=None, activity=None):  # noqa: E501
+        """
+        RequestedActionKey - a model defined in OpenAPI
+
+        :param entity_code:  The type of the resource on which the activity would be performed (required)
+        :type entity_code: str
+        :param scope:  The scope/provider/vendor of the activity (required)
+        :type scope: str
+        :param activity:  The identifier of the action to be performed on the resource (required)
+        :type activity: str
+
+        """  # noqa: E501
+
+        self._entity_code = None
+        self._scope = None
+        self._activity = None
+        self.discriminator = None
+
+        self.entity_code = entity_code
+        self.scope = scope
+        self.activity = activity
+
+    @property
+    def entity_code(self):
+        """Gets the entity_code of this RequestedActionKey.  # noqa: E501
+
+        The type of the resource on which the activity would be performed  # noqa: E501
+
+        :return: The entity_code of this RequestedActionKey.  # noqa: E501
+        :rtype: str
+        """
+        return self._entity_code
+
+    @entity_code.setter
+    def entity_code(self, entity_code):
+        """Sets the entity_code of this RequestedActionKey.
+
+        The type of the resource on which the activity would be performed  # noqa: E501
+
+        :param entity_code: The entity_code of this RequestedActionKey.  # noqa: E501
+        :type: str
+        """
+        if entity_code is None:
+            raise ValueError("Invalid value for `entity_code`, must not be `None`")  # noqa: E501
+        if entity_code is not None and len(entity_code) > 100:
+            raise ValueError("Invalid value for `entity_code`, length must be less than or equal to `100`")  # noqa: E501
+        if entity_code is not None and len(entity_code) < 3:
+            raise ValueError("Invalid value for `entity_code`, length must be greater than or equal to `3`")  # noqa: E501
+
+        self._entity_code = entity_code
+
+    @property
+    def scope(self):
+        """Gets the scope of this RequestedActionKey.  # noqa: E501
+
+        The scope/provider/vendor of the activity  # noqa: E501
+
+        :return: The scope of this RequestedActionKey.  # noqa: E501
+        :rtype: str
+        """
+        return self._scope
+
+    @scope.setter
+    def scope(self, scope):
+        """Sets the scope of this RequestedActionKey.
+
+        The scope/provider/vendor of the activity  # noqa: E501
+
+        :param scope: The scope of this RequestedActionKey.  # noqa: E501
+        :type: str
+        """
+        if scope is None:
+            raise ValueError("Invalid value for `scope`, must not be `None`")  # noqa: E501
+        if scope is not None and len(scope) > 100:
+            raise ValueError("Invalid value for `scope`, length must be less than or equal to `100`")  # noqa: E501
+        if scope is not None and len(scope) < 3:
+            raise ValueError("Invalid value for `scope`, length must be greater than or equal to `3`")  # noqa: E501
+
+        self._scope = scope
+
+    @property
+    def activity(self):
+        """Gets the activity of this RequestedActionKey.  # noqa: E501
+
+        The identifier of the action to be performed on the resource  # noqa: E501
+
+        :return: The activity of this RequestedActionKey.  # noqa: E501
+        :rtype: str
+        """
+        return self._activity
+
+    @activity.setter
+    def activity(self, activity):
+        """Sets the activity of this RequestedActionKey.
+
+        The identifier of the action to be performed on the resource  # noqa: E501
+
+        :param activity: The activity of this RequestedActionKey.  # noqa: E501
+        :type: str
+        """
+        if activity is None:
+            raise ValueError("Invalid value for `activity`, must not be `None`")  # noqa: E501
+        if activity is not None and len(activity) > 100:
+            raise ValueError("Invalid value for `activity`, length must be less than or equal to `100`")  # noqa: E501
+        if activity is not None and len(activity) < 3:
+            raise ValueError("Invalid value for `activity`, length must be greater than or equal to `3`")  # noqa: E501
+
+        self._activity = activity
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, RequestedActionKey):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/resource_list_of_access_controlled_resource.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/resource_list_of_access_controlled_resource.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,183 +1,183 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class ResourceListOfAccessControlledResource(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'values': 'list[AccessControlledResource]',
-        'href': 'str',
-        'links': 'list[Link]'
-    }
-
-    attribute_map = {
-        'values': 'values',
-        'href': 'href',
-        'links': 'links'
-    }
-
-    required_map = {
-        'values': 'required',
-        'href': 'optional',
-        'links': 'optional'
-    }
-
-    def __init__(self, values=None, href=None, links=None):  # noqa: E501
-        """
-        ResourceListOfAccessControlledResource - a model defined in OpenAPI
-
-        :param values:  (required)
-        :type values: list[finbourne_access.AccessControlledResource]
-        :param href:  The Uri that returns the same result as the original request,  but may include resolved as at time(s).
-        :type href: str
-        :param links: 
-        :type links: list[finbourne_access.Link]
-
-        """  # noqa: E501
-
-        self._values = None
-        self._href = None
-        self._links = None
-        self.discriminator = None
-
-        self.values = values
-        self.href = href
-        self.links = links
-
-    @property
-    def values(self):
-        """Gets the values of this ResourceListOfAccessControlledResource.  # noqa: E501
-
-
-        :return: The values of this ResourceListOfAccessControlledResource.  # noqa: E501
-        :rtype: list[AccessControlledResource]
-        """
-        return self._values
-
-    @values.setter
-    def values(self, values):
-        """Sets the values of this ResourceListOfAccessControlledResource.
-
-
-        :param values: The values of this ResourceListOfAccessControlledResource.  # noqa: E501
-        :type: list[AccessControlledResource]
-        """
-        if values is None:
-            raise ValueError("Invalid value for `values`, must not be `None`")  # noqa: E501
-
-        self._values = values
-
-    @property
-    def href(self):
-        """Gets the href of this ResourceListOfAccessControlledResource.  # noqa: E501
-
-        The Uri that returns the same result as the original request,  but may include resolved as at time(s).  # noqa: E501
-
-        :return: The href of this ResourceListOfAccessControlledResource.  # noqa: E501
-        :rtype: str
-        """
-        return self._href
-
-    @href.setter
-    def href(self, href):
-        """Sets the href of this ResourceListOfAccessControlledResource.
-
-        The Uri that returns the same result as the original request,  but may include resolved as at time(s).  # noqa: E501
-
-        :param href: The href of this ResourceListOfAccessControlledResource.  # noqa: E501
-        :type: str
-        """
-
-        self._href = href
-
-    @property
-    def links(self):
-        """Gets the links of this ResourceListOfAccessControlledResource.  # noqa: E501
-
-
-        :return: The links of this ResourceListOfAccessControlledResource.  # noqa: E501
-        :rtype: list[Link]
-        """
-        return self._links
-
-    @links.setter
-    def links(self, links):
-        """Sets the links of this ResourceListOfAccessControlledResource.
-
-
-        :param links: The links of this ResourceListOfAccessControlledResource.  # noqa: E501
-        :type: list[Link]
-        """
-
-        self._links = links
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, ResourceListOfAccessControlledResource):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class ResourceListOfAccessControlledResource(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'values': 'list[AccessControlledResource]',
+        'href': 'str',
+        'links': 'list[Link]'
+    }
+
+    attribute_map = {
+        'values': 'values',
+        'href': 'href',
+        'links': 'links'
+    }
+
+    required_map = {
+        'values': 'required',
+        'href': 'optional',
+        'links': 'optional'
+    }
+
+    def __init__(self, values=None, href=None, links=None):  # noqa: E501
+        """
+        ResourceListOfAccessControlledResource - a model defined in OpenAPI
+
+        :param values:  (required)
+        :type values: list[finbourne_access.AccessControlledResource]
+        :param href:  The Uri that returns the same result as the original request,  but may include resolved as at time(s).
+        :type href: str
+        :param links: 
+        :type links: list[finbourne_access.Link]
+
+        """  # noqa: E501
+
+        self._values = None
+        self._href = None
+        self._links = None
+        self.discriminator = None
+
+        self.values = values
+        self.href = href
+        self.links = links
+
+    @property
+    def values(self):
+        """Gets the values of this ResourceListOfAccessControlledResource.  # noqa: E501
+
+
+        :return: The values of this ResourceListOfAccessControlledResource.  # noqa: E501
+        :rtype: list[AccessControlledResource]
+        """
+        return self._values
+
+    @values.setter
+    def values(self, values):
+        """Sets the values of this ResourceListOfAccessControlledResource.
+
+
+        :param values: The values of this ResourceListOfAccessControlledResource.  # noqa: E501
+        :type: list[AccessControlledResource]
+        """
+        if values is None:
+            raise ValueError("Invalid value for `values`, must not be `None`")  # noqa: E501
+
+        self._values = values
+
+    @property
+    def href(self):
+        """Gets the href of this ResourceListOfAccessControlledResource.  # noqa: E501
+
+        The Uri that returns the same result as the original request,  but may include resolved as at time(s).  # noqa: E501
+
+        :return: The href of this ResourceListOfAccessControlledResource.  # noqa: E501
+        :rtype: str
+        """
+        return self._href
+
+    @href.setter
+    def href(self, href):
+        """Sets the href of this ResourceListOfAccessControlledResource.
+
+        The Uri that returns the same result as the original request,  but may include resolved as at time(s).  # noqa: E501
+
+        :param href: The href of this ResourceListOfAccessControlledResource.  # noqa: E501
+        :type: str
+        """
+
+        self._href = href
+
+    @property
+    def links(self):
+        """Gets the links of this ResourceListOfAccessControlledResource.  # noqa: E501
+
+
+        :return: The links of this ResourceListOfAccessControlledResource.  # noqa: E501
+        :rtype: list[Link]
+        """
+        return self._links
+
+    @links.setter
+    def links(self, links):
+        """Sets the links of this ResourceListOfAccessControlledResource.
+
+
+        :param links: The links of this ResourceListOfAccessControlledResource.  # noqa: E501
+        :type: list[Link]
+        """
+
+        self._links = links
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, ResourceListOfAccessControlledResource):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/role_resource_request.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/role_resource_request.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,153 +1,153 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class RoleResourceRequest(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'non_transitive_supervisor_role_resource': 'NonTransitiveSupervisorRoleResource',
-        'policy_id_role_resource': 'PolicyIdRoleResource'
-    }
-
-    attribute_map = {
-        'non_transitive_supervisor_role_resource': 'nonTransitiveSupervisorRoleResource',
-        'policy_id_role_resource': 'policyIdRoleResource'
-    }
-
-    required_map = {
-        'non_transitive_supervisor_role_resource': 'optional',
-        'policy_id_role_resource': 'optional'
-    }
-
-    def __init__(self, non_transitive_supervisor_role_resource=None, policy_id_role_resource=None):  # noqa: E501
-        """
-        RoleResourceRequest - a model defined in OpenAPI
-
-        :param non_transitive_supervisor_role_resource: 
-        :type non_transitive_supervisor_role_resource: finbourne_access.NonTransitiveSupervisorRoleResource
-        :param policy_id_role_resource: 
-        :type policy_id_role_resource: finbourne_access.PolicyIdRoleResource
-
-        """  # noqa: E501
-
-        self._non_transitive_supervisor_role_resource = None
-        self._policy_id_role_resource = None
-        self.discriminator = None
-
-        if non_transitive_supervisor_role_resource is not None:
-            self.non_transitive_supervisor_role_resource = non_transitive_supervisor_role_resource
-        if policy_id_role_resource is not None:
-            self.policy_id_role_resource = policy_id_role_resource
-
-    @property
-    def non_transitive_supervisor_role_resource(self):
-        """Gets the non_transitive_supervisor_role_resource of this RoleResourceRequest.  # noqa: E501
-
-
-        :return: The non_transitive_supervisor_role_resource of this RoleResourceRequest.  # noqa: E501
-        :rtype: NonTransitiveSupervisorRoleResource
-        """
-        return self._non_transitive_supervisor_role_resource
-
-    @non_transitive_supervisor_role_resource.setter
-    def non_transitive_supervisor_role_resource(self, non_transitive_supervisor_role_resource):
-        """Sets the non_transitive_supervisor_role_resource of this RoleResourceRequest.
-
-
-        :param non_transitive_supervisor_role_resource: The non_transitive_supervisor_role_resource of this RoleResourceRequest.  # noqa: E501
-        :type: NonTransitiveSupervisorRoleResource
-        """
-
-        self._non_transitive_supervisor_role_resource = non_transitive_supervisor_role_resource
-
-    @property
-    def policy_id_role_resource(self):
-        """Gets the policy_id_role_resource of this RoleResourceRequest.  # noqa: E501
-
-
-        :return: The policy_id_role_resource of this RoleResourceRequest.  # noqa: E501
-        :rtype: PolicyIdRoleResource
-        """
-        return self._policy_id_role_resource
-
-    @policy_id_role_resource.setter
-    def policy_id_role_resource(self, policy_id_role_resource):
-        """Sets the policy_id_role_resource of this RoleResourceRequest.
-
-
-        :param policy_id_role_resource: The policy_id_role_resource of this RoleResourceRequest.  # noqa: E501
-        :type: PolicyIdRoleResource
-        """
-
-        self._policy_id_role_resource = policy_id_role_resource
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, RoleResourceRequest):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class RoleResourceRequest(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'non_transitive_supervisor_role_resource': 'NonTransitiveSupervisorRoleResource',
+        'policy_id_role_resource': 'PolicyIdRoleResource'
+    }
+
+    attribute_map = {
+        'non_transitive_supervisor_role_resource': 'nonTransitiveSupervisorRoleResource',
+        'policy_id_role_resource': 'policyIdRoleResource'
+    }
+
+    required_map = {
+        'non_transitive_supervisor_role_resource': 'optional',
+        'policy_id_role_resource': 'optional'
+    }
+
+    def __init__(self, non_transitive_supervisor_role_resource=None, policy_id_role_resource=None):  # noqa: E501
+        """
+        RoleResourceRequest - a model defined in OpenAPI
+
+        :param non_transitive_supervisor_role_resource: 
+        :type non_transitive_supervisor_role_resource: finbourne_access.NonTransitiveSupervisorRoleResource
+        :param policy_id_role_resource: 
+        :type policy_id_role_resource: finbourne_access.PolicyIdRoleResource
+
+        """  # noqa: E501
+
+        self._non_transitive_supervisor_role_resource = None
+        self._policy_id_role_resource = None
+        self.discriminator = None
+
+        if non_transitive_supervisor_role_resource is not None:
+            self.non_transitive_supervisor_role_resource = non_transitive_supervisor_role_resource
+        if policy_id_role_resource is not None:
+            self.policy_id_role_resource = policy_id_role_resource
+
+    @property
+    def non_transitive_supervisor_role_resource(self):
+        """Gets the non_transitive_supervisor_role_resource of this RoleResourceRequest.  # noqa: E501
+
+
+        :return: The non_transitive_supervisor_role_resource of this RoleResourceRequest.  # noqa: E501
+        :rtype: NonTransitiveSupervisorRoleResource
+        """
+        return self._non_transitive_supervisor_role_resource
+
+    @non_transitive_supervisor_role_resource.setter
+    def non_transitive_supervisor_role_resource(self, non_transitive_supervisor_role_resource):
+        """Sets the non_transitive_supervisor_role_resource of this RoleResourceRequest.
+
+
+        :param non_transitive_supervisor_role_resource: The non_transitive_supervisor_role_resource of this RoleResourceRequest.  # noqa: E501
+        :type: NonTransitiveSupervisorRoleResource
+        """
+
+        self._non_transitive_supervisor_role_resource = non_transitive_supervisor_role_resource
+
+    @property
+    def policy_id_role_resource(self):
+        """Gets the policy_id_role_resource of this RoleResourceRequest.  # noqa: E501
+
+
+        :return: The policy_id_role_resource of this RoleResourceRequest.  # noqa: E501
+        :rtype: PolicyIdRoleResource
+        """
+        return self._policy_id_role_resource
+
+    @policy_id_role_resource.setter
+    def policy_id_role_resource(self, policy_id_role_resource):
+        """Sets the policy_id_role_resource of this RoleResourceRequest.
+
+
+        :param policy_id_role_resource: The policy_id_role_resource of this RoleResourceRequest.  # noqa: E501
+        :type: PolicyIdRoleResource
+        """
+
+        self._policy_id_role_resource = policy_id_role_resource
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, RoleResourceRequest):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/role_update_request.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/role_creation_request.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,187 +1,219 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class RoleUpdateRequest(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'description': 'str',
-        'resource': 'RoleResourceRequest',
-        'when': 'WhenSpec'
-    }
-
-    attribute_map = {
-        'description': 'description',
-        'resource': 'resource',
-        'when': 'when'
-    }
-
-    required_map = {
-        'description': 'optional',
-        'resource': 'required',
-        'when': 'required'
-    }
-
-    def __init__(self, description=None, resource=None, when=None):  # noqa: E501
-        """
-        RoleUpdateRequest - a model defined in OpenAPI
-
-        :param description: 
-        :type description: str
-        :param resource:  (required)
-        :type resource: finbourne_access.RoleResourceRequest
-        :param when:  (required)
-        :type when: finbourne_access.WhenSpec
-
-        """  # noqa: E501
-
-        self._description = None
-        self._resource = None
-        self._when = None
-        self.discriminator = None
-
-        self.description = description
-        self.resource = resource
-        self.when = when
-
-    @property
-    def description(self):
-        """Gets the description of this RoleUpdateRequest.  # noqa: E501
-
-
-        :return: The description of this RoleUpdateRequest.  # noqa: E501
-        :rtype: str
-        """
-        return self._description
-
-    @description.setter
-    def description(self, description):
-        """Sets the description of this RoleUpdateRequest.
-
-
-        :param description: The description of this RoleUpdateRequest.  # noqa: E501
-        :type: str
-        """
-        if description is not None and len(description) > 1024:
-            raise ValueError("Invalid value for `description`, length must be less than or equal to `1024`")  # noqa: E501
-        if description is not None and len(description) < 0:
-            raise ValueError("Invalid value for `description`, length must be greater than or equal to `0`")  # noqa: E501
-
-        self._description = description
-
-    @property
-    def resource(self):
-        """Gets the resource of this RoleUpdateRequest.  # noqa: E501
-
-
-        :return: The resource of this RoleUpdateRequest.  # noqa: E501
-        :rtype: RoleResourceRequest
-        """
-        return self._resource
-
-    @resource.setter
-    def resource(self, resource):
-        """Sets the resource of this RoleUpdateRequest.
-
-
-        :param resource: The resource of this RoleUpdateRequest.  # noqa: E501
-        :type: RoleResourceRequest
-        """
-        if resource is None:
-            raise ValueError("Invalid value for `resource`, must not be `None`")  # noqa: E501
-
-        self._resource = resource
-
-    @property
-    def when(self):
-        """Gets the when of this RoleUpdateRequest.  # noqa: E501
-
-
-        :return: The when of this RoleUpdateRequest.  # noqa: E501
-        :rtype: WhenSpec
-        """
-        return self._when
-
-    @when.setter
-    def when(self, when):
-        """Sets the when of this RoleUpdateRequest.
-
-
-        :param when: The when of this RoleUpdateRequest.  # noqa: E501
-        :type: WhenSpec
-        """
-        if when is None:
-            raise ValueError("Invalid value for `when`, must not be `None`")  # noqa: E501
-
-        self._when = when
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, RoleUpdateRequest):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class RoleCreationRequest(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'code': 'str',
+        'description': 'str',
+        'resource': 'RoleResourceRequest',
+        'when': 'WhenSpec'
+    }
+
+    attribute_map = {
+        'code': 'code',
+        'description': 'description',
+        'resource': 'resource',
+        'when': 'when'
+    }
+
+    required_map = {
+        'code': 'required',
+        'description': 'optional',
+        'resource': 'required',
+        'when': 'required'
+    }
+
+    def __init__(self, code=None, description=None, resource=None, when=None):  # noqa: E501
+        """
+        RoleCreationRequest - a model defined in OpenAPI
+
+        :param code:  (required)
+        :type code: str
+        :param description: 
+        :type description: str
+        :param resource:  (required)
+        :type resource: finbourne_access.RoleResourceRequest
+        :param when:  (required)
+        :type when: finbourne_access.WhenSpec
+
+        """  # noqa: E501
+
+        self._code = None
+        self._description = None
+        self._resource = None
+        self._when = None
+        self.discriminator = None
+
+        self.code = code
+        self.description = description
+        self.resource = resource
+        self.when = when
+
+    @property
+    def code(self):
+        """Gets the code of this RoleCreationRequest.  # noqa: E501
+
+
+        :return: The code of this RoleCreationRequest.  # noqa: E501
+        :rtype: str
+        """
+        return self._code
+
+    @code.setter
+    def code(self, code):
+        """Sets the code of this RoleCreationRequest.
+
+
+        :param code: The code of this RoleCreationRequest.  # noqa: E501
+        :type: str
+        """
+        if code is None:
+            raise ValueError("Invalid value for `code`, must not be `None`")  # noqa: E501
+        if (code is not None and not re.search(r'^[a-zA-Z][a-zA-Z0-9-_ +]{2,100}$', code)):  # noqa: E501
+            raise ValueError(r"Invalid value for `code`, must be a follow pattern or equal to `/^[a-zA-Z][a-zA-Z0-9-_ +]{2,100}$/`")  # noqa: E501
+
+        self._code = code
+
+    @property
+    def description(self):
+        """Gets the description of this RoleCreationRequest.  # noqa: E501
+
+
+        :return: The description of this RoleCreationRequest.  # noqa: E501
+        :rtype: str
+        """
+        return self._description
+
+    @description.setter
+    def description(self, description):
+        """Sets the description of this RoleCreationRequest.
+
+
+        :param description: The description of this RoleCreationRequest.  # noqa: E501
+        :type: str
+        """
+        if description is not None and len(description) > 1024:
+            raise ValueError("Invalid value for `description`, length must be less than or equal to `1024`")  # noqa: E501
+        if description is not None and len(description) < 0:
+            raise ValueError("Invalid value for `description`, length must be greater than or equal to `0`")  # noqa: E501
+
+        self._description = description
+
+    @property
+    def resource(self):
+        """Gets the resource of this RoleCreationRequest.  # noqa: E501
+
+
+        :return: The resource of this RoleCreationRequest.  # noqa: E501
+        :rtype: RoleResourceRequest
+        """
+        return self._resource
+
+    @resource.setter
+    def resource(self, resource):
+        """Sets the resource of this RoleCreationRequest.
+
+
+        :param resource: The resource of this RoleCreationRequest.  # noqa: E501
+        :type: RoleResourceRequest
+        """
+        if resource is None:
+            raise ValueError("Invalid value for `resource`, must not be `None`")  # noqa: E501
+
+        self._resource = resource
+
+    @property
+    def when(self):
+        """Gets the when of this RoleCreationRequest.  # noqa: E501
+
+
+        :return: The when of this RoleCreationRequest.  # noqa: E501
+        :rtype: WhenSpec
+        """
+        return self._when
+
+    @when.setter
+    def when(self, when):
+        """Sets the when of this RoleCreationRequest.
+
+
+        :param when: The when of this RoleCreationRequest.  # noqa: E501
+        :type: WhenSpec
+        """
+        if when is None:
+            raise ValueError("Invalid value for `when`, must not be `None`")  # noqa: E501
+
+        self._when = when
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, RoleCreationRequest):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/selector_definition.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/selector_definition.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,211 +1,211 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class SelectorDefinition(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'metadata_selector_definition': 'MetadataSelectorDefinition',
-        'id_selector_definition': 'IdSelectorDefinition',
-        'match_all_selector_definition': 'MatchAllSelectorDefinition',
-        'policy_selector_definition': 'PolicySelectorDefinition'
-    }
-
-    attribute_map = {
-        'metadata_selector_definition': 'metadataSelectorDefinition',
-        'id_selector_definition': 'idSelectorDefinition',
-        'match_all_selector_definition': 'matchAllSelectorDefinition',
-        'policy_selector_definition': 'policySelectorDefinition'
-    }
-
-    required_map = {
-        'metadata_selector_definition': 'optional',
-        'id_selector_definition': 'optional',
-        'match_all_selector_definition': 'optional',
-        'policy_selector_definition': 'optional'
-    }
-
-    def __init__(self, metadata_selector_definition=None, id_selector_definition=None, match_all_selector_definition=None, policy_selector_definition=None):  # noqa: E501
-        """
-        SelectorDefinition - a model defined in OpenAPI
-
-        :param metadata_selector_definition: 
-        :type metadata_selector_definition: finbourne_access.MetadataSelectorDefinition
-        :param id_selector_definition: 
-        :type id_selector_definition: finbourne_access.IdSelectorDefinition
-        :param match_all_selector_definition: 
-        :type match_all_selector_definition: finbourne_access.MatchAllSelectorDefinition
-        :param policy_selector_definition: 
-        :type policy_selector_definition: finbourne_access.PolicySelectorDefinition
-
-        """  # noqa: E501
-
-        self._metadata_selector_definition = None
-        self._id_selector_definition = None
-        self._match_all_selector_definition = None
-        self._policy_selector_definition = None
-        self.discriminator = None
-
-        if metadata_selector_definition is not None:
-            self.metadata_selector_definition = metadata_selector_definition
-        if id_selector_definition is not None:
-            self.id_selector_definition = id_selector_definition
-        if match_all_selector_definition is not None:
-            self.match_all_selector_definition = match_all_selector_definition
-        if policy_selector_definition is not None:
-            self.policy_selector_definition = policy_selector_definition
-
-    @property
-    def metadata_selector_definition(self):
-        """Gets the metadata_selector_definition of this SelectorDefinition.  # noqa: E501
-
-
-        :return: The metadata_selector_definition of this SelectorDefinition.  # noqa: E501
-        :rtype: MetadataSelectorDefinition
-        """
-        return self._metadata_selector_definition
-
-    @metadata_selector_definition.setter
-    def metadata_selector_definition(self, metadata_selector_definition):
-        """Sets the metadata_selector_definition of this SelectorDefinition.
-
-
-        :param metadata_selector_definition: The metadata_selector_definition of this SelectorDefinition.  # noqa: E501
-        :type: MetadataSelectorDefinition
-        """
-
-        self._metadata_selector_definition = metadata_selector_definition
-
-    @property
-    def id_selector_definition(self):
-        """Gets the id_selector_definition of this SelectorDefinition.  # noqa: E501
-
-
-        :return: The id_selector_definition of this SelectorDefinition.  # noqa: E501
-        :rtype: IdSelectorDefinition
-        """
-        return self._id_selector_definition
-
-    @id_selector_definition.setter
-    def id_selector_definition(self, id_selector_definition):
-        """Sets the id_selector_definition of this SelectorDefinition.
-
-
-        :param id_selector_definition: The id_selector_definition of this SelectorDefinition.  # noqa: E501
-        :type: IdSelectorDefinition
-        """
-
-        self._id_selector_definition = id_selector_definition
-
-    @property
-    def match_all_selector_definition(self):
-        """Gets the match_all_selector_definition of this SelectorDefinition.  # noqa: E501
-
-
-        :return: The match_all_selector_definition of this SelectorDefinition.  # noqa: E501
-        :rtype: MatchAllSelectorDefinition
-        """
-        return self._match_all_selector_definition
-
-    @match_all_selector_definition.setter
-    def match_all_selector_definition(self, match_all_selector_definition):
-        """Sets the match_all_selector_definition of this SelectorDefinition.
-
-
-        :param match_all_selector_definition: The match_all_selector_definition of this SelectorDefinition.  # noqa: E501
-        :type: MatchAllSelectorDefinition
-        """
-
-        self._match_all_selector_definition = match_all_selector_definition
-
-    @property
-    def policy_selector_definition(self):
-        """Gets the policy_selector_definition of this SelectorDefinition.  # noqa: E501
-
-
-        :return: The policy_selector_definition of this SelectorDefinition.  # noqa: E501
-        :rtype: PolicySelectorDefinition
-        """
-        return self._policy_selector_definition
-
-    @policy_selector_definition.setter
-    def policy_selector_definition(self, policy_selector_definition):
-        """Sets the policy_selector_definition of this SelectorDefinition.
-
-
-        :param policy_selector_definition: The policy_selector_definition of this SelectorDefinition.  # noqa: E501
-        :type: PolicySelectorDefinition
-        """
-
-        self._policy_selector_definition = policy_selector_definition
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, SelectorDefinition):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class SelectorDefinition(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'metadata_selector_definition': 'MetadataSelectorDefinition',
+        'id_selector_definition': 'IdSelectorDefinition',
+        'match_all_selector_definition': 'MatchAllSelectorDefinition',
+        'policy_selector_definition': 'PolicySelectorDefinition'
+    }
+
+    attribute_map = {
+        'metadata_selector_definition': 'metadataSelectorDefinition',
+        'id_selector_definition': 'idSelectorDefinition',
+        'match_all_selector_definition': 'matchAllSelectorDefinition',
+        'policy_selector_definition': 'policySelectorDefinition'
+    }
+
+    required_map = {
+        'metadata_selector_definition': 'optional',
+        'id_selector_definition': 'optional',
+        'match_all_selector_definition': 'optional',
+        'policy_selector_definition': 'optional'
+    }
+
+    def __init__(self, metadata_selector_definition=None, id_selector_definition=None, match_all_selector_definition=None, policy_selector_definition=None):  # noqa: E501
+        """
+        SelectorDefinition - a model defined in OpenAPI
+
+        :param metadata_selector_definition: 
+        :type metadata_selector_definition: finbourne_access.MetadataSelectorDefinition
+        :param id_selector_definition: 
+        :type id_selector_definition: finbourne_access.IdSelectorDefinition
+        :param match_all_selector_definition: 
+        :type match_all_selector_definition: finbourne_access.MatchAllSelectorDefinition
+        :param policy_selector_definition: 
+        :type policy_selector_definition: finbourne_access.PolicySelectorDefinition
+
+        """  # noqa: E501
+
+        self._metadata_selector_definition = None
+        self._id_selector_definition = None
+        self._match_all_selector_definition = None
+        self._policy_selector_definition = None
+        self.discriminator = None
+
+        if metadata_selector_definition is not None:
+            self.metadata_selector_definition = metadata_selector_definition
+        if id_selector_definition is not None:
+            self.id_selector_definition = id_selector_definition
+        if match_all_selector_definition is not None:
+            self.match_all_selector_definition = match_all_selector_definition
+        if policy_selector_definition is not None:
+            self.policy_selector_definition = policy_selector_definition
+
+    @property
+    def metadata_selector_definition(self):
+        """Gets the metadata_selector_definition of this SelectorDefinition.  # noqa: E501
+
+
+        :return: The metadata_selector_definition of this SelectorDefinition.  # noqa: E501
+        :rtype: MetadataSelectorDefinition
+        """
+        return self._metadata_selector_definition
+
+    @metadata_selector_definition.setter
+    def metadata_selector_definition(self, metadata_selector_definition):
+        """Sets the metadata_selector_definition of this SelectorDefinition.
+
+
+        :param metadata_selector_definition: The metadata_selector_definition of this SelectorDefinition.  # noqa: E501
+        :type: MetadataSelectorDefinition
+        """
+
+        self._metadata_selector_definition = metadata_selector_definition
+
+    @property
+    def id_selector_definition(self):
+        """Gets the id_selector_definition of this SelectorDefinition.  # noqa: E501
+
+
+        :return: The id_selector_definition of this SelectorDefinition.  # noqa: E501
+        :rtype: IdSelectorDefinition
+        """
+        return self._id_selector_definition
+
+    @id_selector_definition.setter
+    def id_selector_definition(self, id_selector_definition):
+        """Sets the id_selector_definition of this SelectorDefinition.
+
+
+        :param id_selector_definition: The id_selector_definition of this SelectorDefinition.  # noqa: E501
+        :type: IdSelectorDefinition
+        """
+
+        self._id_selector_definition = id_selector_definition
+
+    @property
+    def match_all_selector_definition(self):
+        """Gets the match_all_selector_definition of this SelectorDefinition.  # noqa: E501
+
+
+        :return: The match_all_selector_definition of this SelectorDefinition.  # noqa: E501
+        :rtype: MatchAllSelectorDefinition
+        """
+        return self._match_all_selector_definition
+
+    @match_all_selector_definition.setter
+    def match_all_selector_definition(self, match_all_selector_definition):
+        """Sets the match_all_selector_definition of this SelectorDefinition.
+
+
+        :param match_all_selector_definition: The match_all_selector_definition of this SelectorDefinition.  # noqa: E501
+        :type: MatchAllSelectorDefinition
+        """
+
+        self._match_all_selector_definition = match_all_selector_definition
+
+    @property
+    def policy_selector_definition(self):
+        """Gets the policy_selector_definition of this SelectorDefinition.  # noqa: E501
+
+
+        :return: The policy_selector_definition of this SelectorDefinition.  # noqa: E501
+        :rtype: PolicySelectorDefinition
+        """
+        return self._policy_selector_definition
+
+    @policy_selector_definition.setter
+    def policy_selector_definition(self, policy_selector_definition):
+        """Sets the policy_selector_definition of this SelectorDefinition.
+
+
+        :param policy_selector_definition: The policy_selector_definition of this SelectorDefinition.  # noqa: E501
+        :type: PolicySelectorDefinition
+        """
+
+        self._policy_selector_definition = policy_selector_definition
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, SelectorDefinition):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/shrine_problem_details.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/shrine_problem_details.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,351 +1,351 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class ShrineProblemDetails(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'name': 'str',
-        'error_details': 'list[dict(str, str)]',
-        'code': 'int',
-        'type': 'str',
-        'title': 'str',
-        'status': 'int',
-        'detail': 'str',
-        'instance': 'str',
-        'extensions': 'dict(str, object)'
-    }
-
-    attribute_map = {
-        'name': 'name',
-        'error_details': 'errorDetails',
-        'code': 'code',
-        'type': 'type',
-        'title': 'title',
-        'status': 'status',
-        'detail': 'detail',
-        'instance': 'instance',
-        'extensions': 'extensions'
-    }
-
-    required_map = {
-        'name': 'required',
-        'error_details': 'optional',
-        'code': 'required',
-        'type': 'optional',
-        'title': 'optional',
-        'status': 'optional',
-        'detail': 'optional',
-        'instance': 'optional',
-        'extensions': 'optional'
-    }
-
-    def __init__(self, name=None, error_details=None, code=None, type=None, title=None, status=None, detail=None, instance=None, extensions=None):  # noqa: E501
-        """
-        ShrineProblemDetails - a model defined in OpenAPI
-
-        :param name:  (required)
-        :type name: str
-        :param error_details: 
-        :type error_details: list[dict(str, str)]
-        :param code:  (required)
-        :type code: int
-        :param type: 
-        :type type: str
-        :param title: 
-        :type title: str
-        :param status: 
-        :type status: int
-        :param detail: 
-        :type detail: str
-        :param instance: 
-        :type instance: str
-        :param extensions: 
-        :type extensions: dict(str, object)
-
-        """  # noqa: E501
-
-        self._name = None
-        self._error_details = None
-        self._code = None
-        self._type = None
-        self._title = None
-        self._status = None
-        self._detail = None
-        self._instance = None
-        self._extensions = None
-        self.discriminator = None
-
-        self.name = name
-        self.error_details = error_details
-        self.code = code
-        self.type = type
-        self.title = title
-        self.status = status
-        self.detail = detail
-        self.instance = instance
-        self.extensions = extensions
-
-    @property
-    def name(self):
-        """Gets the name of this ShrineProblemDetails.  # noqa: E501
-
-
-        :return: The name of this ShrineProblemDetails.  # noqa: E501
-        :rtype: str
-        """
-        return self._name
-
-    @name.setter
-    def name(self, name):
-        """Sets the name of this ShrineProblemDetails.
-
-
-        :param name: The name of this ShrineProblemDetails.  # noqa: E501
-        :type: str
-        """
-        if name is None:
-            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
-
-        self._name = name
-
-    @property
-    def error_details(self):
-        """Gets the error_details of this ShrineProblemDetails.  # noqa: E501
-
-
-        :return: The error_details of this ShrineProblemDetails.  # noqa: E501
-        :rtype: list[dict(str, str)]
-        """
-        return self._error_details
-
-    @error_details.setter
-    def error_details(self, error_details):
-        """Sets the error_details of this ShrineProblemDetails.
-
-
-        :param error_details: The error_details of this ShrineProblemDetails.  # noqa: E501
-        :type: list[dict(str, str)]
-        """
-
-        self._error_details = error_details
-
-    @property
-    def code(self):
-        """Gets the code of this ShrineProblemDetails.  # noqa: E501
-
-
-        :return: The code of this ShrineProblemDetails.  # noqa: E501
-        :rtype: int
-        """
-        return self._code
-
-    @code.setter
-    def code(self, code):
-        """Sets the code of this ShrineProblemDetails.
-
-
-        :param code: The code of this ShrineProblemDetails.  # noqa: E501
-        :type: int
-        """
-        if code is None:
-            raise ValueError("Invalid value for `code`, must not be `None`")  # noqa: E501
-
-        self._code = code
-
-    @property
-    def type(self):
-        """Gets the type of this ShrineProblemDetails.  # noqa: E501
-
-
-        :return: The type of this ShrineProblemDetails.  # noqa: E501
-        :rtype: str
-        """
-        return self._type
-
-    @type.setter
-    def type(self, type):
-        """Sets the type of this ShrineProblemDetails.
-
-
-        :param type: The type of this ShrineProblemDetails.  # noqa: E501
-        :type: str
-        """
-
-        self._type = type
-
-    @property
-    def title(self):
-        """Gets the title of this ShrineProblemDetails.  # noqa: E501
-
-
-        :return: The title of this ShrineProblemDetails.  # noqa: E501
-        :rtype: str
-        """
-        return self._title
-
-    @title.setter
-    def title(self, title):
-        """Sets the title of this ShrineProblemDetails.
-
-
-        :param title: The title of this ShrineProblemDetails.  # noqa: E501
-        :type: str
-        """
-
-        self._title = title
-
-    @property
-    def status(self):
-        """Gets the status of this ShrineProblemDetails.  # noqa: E501
-
-
-        :return: The status of this ShrineProblemDetails.  # noqa: E501
-        :rtype: int
-        """
-        return self._status
-
-    @status.setter
-    def status(self, status):
-        """Sets the status of this ShrineProblemDetails.
-
-
-        :param status: The status of this ShrineProblemDetails.  # noqa: E501
-        :type: int
-        """
-
-        self._status = status
-
-    @property
-    def detail(self):
-        """Gets the detail of this ShrineProblemDetails.  # noqa: E501
-
-
-        :return: The detail of this ShrineProblemDetails.  # noqa: E501
-        :rtype: str
-        """
-        return self._detail
-
-    @detail.setter
-    def detail(self, detail):
-        """Sets the detail of this ShrineProblemDetails.
-
-
-        :param detail: The detail of this ShrineProblemDetails.  # noqa: E501
-        :type: str
-        """
-
-        self._detail = detail
-
-    @property
-    def instance(self):
-        """Gets the instance of this ShrineProblemDetails.  # noqa: E501
-
-
-        :return: The instance of this ShrineProblemDetails.  # noqa: E501
-        :rtype: str
-        """
-        return self._instance
-
-    @instance.setter
-    def instance(self, instance):
-        """Sets the instance of this ShrineProblemDetails.
-
-
-        :param instance: The instance of this ShrineProblemDetails.  # noqa: E501
-        :type: str
-        """
-
-        self._instance = instance
-
-    @property
-    def extensions(self):
-        """Gets the extensions of this ShrineProblemDetails.  # noqa: E501
-
-
-        :return: The extensions of this ShrineProblemDetails.  # noqa: E501
-        :rtype: dict(str, object)
-        """
-        return self._extensions
-
-    @extensions.setter
-    def extensions(self, extensions):
-        """Sets the extensions of this ShrineProblemDetails.
-
-
-        :param extensions: The extensions of this ShrineProblemDetails.  # noqa: E501
-        :type: dict(str, object)
-        """
-
-        self._extensions = extensions
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, ShrineProblemDetails):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
+
+    The version of the OpenAPI document: 0.0.616
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class ShrineProblemDetails(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'name': 'str',
+        'error_details': 'list[dict(str, str)]',
+        'code': 'int',
+        'type': 'str',
+        'title': 'str',
+        'status': 'int',
+        'detail': 'str',
+        'instance': 'str',
+        'extensions': 'dict(str, object)'
+    }
+
+    attribute_map = {
+        'name': 'name',
+        'error_details': 'errorDetails',
+        'code': 'code',
+        'type': 'type',
+        'title': 'title',
+        'status': 'status',
+        'detail': 'detail',
+        'instance': 'instance',
+        'extensions': 'extensions'
+    }
+
+    required_map = {
+        'name': 'required',
+        'error_details': 'optional',
+        'code': 'required',
+        'type': 'optional',
+        'title': 'optional',
+        'status': 'optional',
+        'detail': 'optional',
+        'instance': 'optional',
+        'extensions': 'optional'
+    }
+
+    def __init__(self, name=None, error_details=None, code=None, type=None, title=None, status=None, detail=None, instance=None, extensions=None):  # noqa: E501
+        """
+        ShrineProblemDetails - a model defined in OpenAPI
+
+        :param name:  (required)
+        :type name: str
+        :param error_details: 
+        :type error_details: list[dict(str, str)]
+        :param code:  (required)
+        :type code: int
+        :param type: 
+        :type type: str
+        :param title: 
+        :type title: str
+        :param status: 
+        :type status: int
+        :param detail: 
+        :type detail: str
+        :param instance: 
+        :type instance: str
+        :param extensions: 
+        :type extensions: dict(str, object)
+
+        """  # noqa: E501
+
+        self._name = None
+        self._error_details = None
+        self._code = None
+        self._type = None
+        self._title = None
+        self._status = None
+        self._detail = None
+        self._instance = None
+        self._extensions = None
+        self.discriminator = None
+
+        self.name = name
+        self.error_details = error_details
+        self.code = code
+        self.type = type
+        self.title = title
+        self.status = status
+        self.detail = detail
+        self.instance = instance
+        self.extensions = extensions
+
+    @property
+    def name(self):
+        """Gets the name of this ShrineProblemDetails.  # noqa: E501
+
+
+        :return: The name of this ShrineProblemDetails.  # noqa: E501
+        :rtype: str
+        """
+        return self._name
+
+    @name.setter
+    def name(self, name):
+        """Sets the name of this ShrineProblemDetails.
+
+
+        :param name: The name of this ShrineProblemDetails.  # noqa: E501
+        :type: str
+        """
+        if name is None:
+            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
+
+        self._name = name
+
+    @property
+    def error_details(self):
+        """Gets the error_details of this ShrineProblemDetails.  # noqa: E501
+
+
+        :return: The error_details of this ShrineProblemDetails.  # noqa: E501
+        :rtype: list[dict(str, str)]
+        """
+        return self._error_details
+
+    @error_details.setter
+    def error_details(self, error_details):
+        """Sets the error_details of this ShrineProblemDetails.
+
+
+        :param error_details: The error_details of this ShrineProblemDetails.  # noqa: E501
+        :type: list[dict(str, str)]
+        """
+
+        self._error_details = error_details
+
+    @property
+    def code(self):
+        """Gets the code of this ShrineProblemDetails.  # noqa: E501
+
+
+        :return: The code of this ShrineProblemDetails.  # noqa: E501
+        :rtype: int
+        """
+        return self._code
+
+    @code.setter
+    def code(self, code):
+        """Sets the code of this ShrineProblemDetails.
+
+
+        :param code: The code of this ShrineProblemDetails.  # noqa: E501
+        :type: int
+        """
+        if code is None:
+            raise ValueError("Invalid value for `code`, must not be `None`")  # noqa: E501
+
+        self._code = code
+
+    @property
+    def type(self):
+        """Gets the type of this ShrineProblemDetails.  # noqa: E501
+
+
+        :return: The type of this ShrineProblemDetails.  # noqa: E501
+        :rtype: str
+        """
+        return self._type
+
+    @type.setter
+    def type(self, type):
+        """Sets the type of this ShrineProblemDetails.
+
+
+        :param type: The type of this ShrineProblemDetails.  # noqa: E501
+        :type: str
+        """
+
+        self._type = type
+
+    @property
+    def title(self):
+        """Gets the title of this ShrineProblemDetails.  # noqa: E501
+
+
+        :return: The title of this ShrineProblemDetails.  # noqa: E501
+        :rtype: str
+        """
+        return self._title
+
+    @title.setter
+    def title(self, title):
+        """Sets the title of this ShrineProblemDetails.
+
+
+        :param title: The title of this ShrineProblemDetails.  # noqa: E501
+        :type: str
+        """
+
+        self._title = title
+
+    @property
+    def status(self):
+        """Gets the status of this ShrineProblemDetails.  # noqa: E501
+
+
+        :return: The status of this ShrineProblemDetails.  # noqa: E501
+        :rtype: int
+        """
+        return self._status
+
+    @status.setter
+    def status(self, status):
+        """Sets the status of this ShrineProblemDetails.
+
+
+        :param status: The status of this ShrineProblemDetails.  # noqa: E501
+        :type: int
+        """
+
+        self._status = status
+
+    @property
+    def detail(self):
+        """Gets the detail of this ShrineProblemDetails.  # noqa: E501
+
+
+        :return: The detail of this ShrineProblemDetails.  # noqa: E501
+        :rtype: str
+        """
+        return self._detail
+
+    @detail.setter
+    def detail(self, detail):
+        """Sets the detail of this ShrineProblemDetails.
+
+
+        :param detail: The detail of this ShrineProblemDetails.  # noqa: E501
+        :type: str
+        """
+
+        self._detail = detail
+
+    @property
+    def instance(self):
+        """Gets the instance of this ShrineProblemDetails.  # noqa: E501
+
+
+        :return: The instance of this ShrineProblemDetails.  # noqa: E501
+        :rtype: str
+        """
+        return self._instance
+
+    @instance.setter
+    def instance(self, instance):
+        """Sets the instance of this ShrineProblemDetails.
+
+
+        :param instance: The instance of this ShrineProblemDetails.  # noqa: E501
+        :type: str
+        """
+
+        self._instance = instance
+
+    @property
+    def extensions(self):
+        """Gets the extensions of this ShrineProblemDetails.  # noqa: E501
+
+
+        :return: The extensions of this ShrineProblemDetails.  # noqa: E501
+        :rtype: dict(str, object)
+        """
+        return self._extensions
+
+    @extensions.setter
+    def extensions(self, extensions):
+        """Sets the extensions of this ShrineProblemDetails.
+
+
+        :param extensions: The extensions of this ShrineProblemDetails.  # noqa: E501
+        :type: dict(str, object)
+        """
+
+        self._extensions = extensions
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, ShrineProblemDetails):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/shrine_validation_problem_details.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/shrine_validation_problem_details.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,379 +1,379 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class ShrineValidationProblemDetails(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'name': 'str',
-        'error_details': 'list[dict(str, str)]',
-        'code': 'int',
-        'errors': 'dict(str, list[str])',
-        'type': 'str',
-        'title': 'str',
-        'status': 'int',
-        'detail': 'str',
-        'instance': 'str',
-        'extensions': 'dict(str, object)'
-    }
-
-    attribute_map = {
-        'name': 'name',
-        'error_details': 'errorDetails',
-        'code': 'code',
-        'errors': 'errors',
-        'type': 'type',
-        'title': 'title',
-        'status': 'status',
-        'detail': 'detail',
-        'instance': 'instance',
-        'extensions': 'extensions'
-    }
-
-    required_map = {
-        'name': 'required',
-        'error_details': 'optional',
-        'code': 'required',
-        'errors': 'optional',
-        'type': 'optional',
-        'title': 'optional',
-        'status': 'optional',
-        'detail': 'optional',
-        'instance': 'optional',
-        'extensions': 'optional'
-    }
-
-    def __init__(self, name=None, error_details=None, code=None, errors=None, type=None, title=None, status=None, detail=None, instance=None, extensions=None):  # noqa: E501
-        """
-        ShrineValidationProblemDetails - a model defined in OpenAPI
-
-        :param name:  (required)
-        :type name: str
-        :param error_details: 
-        :type error_details: list[dict(str, str)]
-        :param code:  (required)
-        :type code: int
-        :param errors: 
-        :type errors: dict(str, list[str])
-        :param type: 
-        :type type: str
-        :param title: 
-        :type title: str
-        :param status: 
-        :type status: int
-        :param detail: 
-        :type detail: str
-        :param instance: 
-        :type instance: str
-        :param extensions: 
-        :type extensions: dict(str, object)
-
-        """  # noqa: E501
-
-        self._name = None
-        self._error_details = None
-        self._code = None
-        self._errors = None
-        self._type = None
-        self._title = None
-        self._status = None
-        self._detail = None
-        self._instance = None
-        self._extensions = None
-        self.discriminator = None
-
-        self.name = name
-        self.error_details = error_details
-        self.code = code
-        self.errors = errors
-        self.type = type
-        self.title = title
-        self.status = status
-        self.detail = detail
-        self.instance = instance
-        self.extensions = extensions
-
-    @property
-    def name(self):
-        """Gets the name of this ShrineValidationProblemDetails.  # noqa: E501
-
-
-        :return: The name of this ShrineValidationProblemDetails.  # noqa: E501
-        :rtype: str
-        """
-        return self._name
-
-    @name.setter
-    def name(self, name):
-        """Sets the name of this ShrineValidationProblemDetails.
-
-
-        :param name: The name of this ShrineValidationProblemDetails.  # noqa: E501
-        :type: str
-        """
-        if name is None:
-            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
-
-        self._name = name
-
-    @property
-    def error_details(self):
-        """Gets the error_details of this ShrineValidationProblemDetails.  # noqa: E501
-
-
-        :return: The error_details of this ShrineValidationProblemDetails.  # noqa: E501
-        :rtype: list[dict(str, str)]
-        """
-        return self._error_details
-
-    @error_details.setter
-    def error_details(self, error_details):
-        """Sets the error_details of this ShrineValidationProblemDetails.
-
-
-        :param error_details: The error_details of this ShrineValidationProblemDetails.  # noqa: E501
-        :type: list[dict(str, str)]
-        """
-
-        self._error_details = error_details
-
-    @property
-    def code(self):
-        """Gets the code of this ShrineValidationProblemDetails.  # noqa: E501
-
-
-        :return: The code of this ShrineValidationProblemDetails.  # noqa: E501
-        :rtype: int
-        """
-        return self._code
-
-    @code.setter
-    def code(self, code):
-        """Sets the code of this ShrineValidationProblemDetails.
-
-
-        :param code: The code of this ShrineValidationProblemDetails.  # noqa: E501
-        :type: int
-        """
-        if code is None:
-            raise ValueError("Invalid value for `code`, must not be `None`")  # noqa: E501
-
-        self._code = code
-
-    @property
-    def errors(self):
-        """Gets the errors of this ShrineValidationProblemDetails.  # noqa: E501
-
-
-        :return: The errors of this ShrineValidationProblemDetails.  # noqa: E501
-        :rtype: dict(str, list[str])
-        """
-        return self._errors
-
-    @errors.setter
-    def errors(self, errors):
-        """Sets the errors of this ShrineValidationProblemDetails.
-
-
-        :param errors: The errors of this ShrineValidationProblemDetails.  # noqa: E501
-        :type: dict(str, list[str])
-        """
-
-        self._errors = errors
-
-    @property
-    def type(self):
-        """Gets the type of this ShrineValidationProblemDetails.  # noqa: E501
-
-
-        :return: The type of this ShrineValidationProblemDetails.  # noqa: E501
-        :rtype: str
-        """
-        return self._type
-
-    @type.setter
-    def type(self, type):
-        """Sets the type of this ShrineValidationProblemDetails.
-
-
-        :param type: The type of this ShrineValidationProblemDetails.  # noqa: E501
-        :type: str
-        """
-
-        self._type = type
-
-    @property
-    def title(self):
-        """Gets the title of this ShrineValidationProblemDetails.  # noqa: E501
-
-
-        :return: The title of this ShrineValidationProblemDetails.  # noqa: E501
-        :rtype: str
-        """
-        return self._title
-
-    @title.setter
-    def title(self, title):
-        """Sets the title of this ShrineValidationProblemDetails.
-
-
-        :param title: The title of this ShrineValidationProblemDetails.  # noqa: E501
-        :type: str
-        """
-
-        self._title = title
-
-    @property
-    def status(self):
-        """Gets the status of this ShrineValidationProblemDetails.  # noqa: E501
-
-
-        :return: The status of this ShrineValidationProblemDetails.  # noqa: E501
-        :rtype: int
-        """
-        return self._status
-
-    @status.setter
-    def status(self, status):
-        """Sets the status of this ShrineValidationProblemDetails.
-
-
-        :param status: The status of this ShrineValidationProblemDetails.  # noqa: E501
-        :type: int
-        """
-
-        self._status = status
-
-    @property
-    def detail(self):
-        """Gets the detail of this ShrineValidationProblemDetails.  # noqa: E501
-
-
-        :return: The detail of this ShrineValidationProblemDetails.  # noqa: E501
-        :rtype: str
-        """
-        return self._detail
-
-    @detail.setter
-    def detail(self, detail):
-        """Sets the detail of this ShrineValidationProblemDetails.
-
-
-        :param detail: The detail of this ShrineValidationProblemDetails.  # noqa: E501
-        :type: str
-        """
-
-        self._detail = detail
-
-    @property
-    def instance(self):
-        """Gets the instance of this ShrineValidationProblemDetails.  # noqa: E501
-
-
-        :return: The instance of this ShrineValidationProblemDetails.  # noqa: E501
-        :rtype: str
-        """
-        return self._instance
-
-    @instance.setter
-    def instance(self, instance):
-        """Sets the instance of this ShrineValidationProblemDetails.
-
-
-        :param instance: The instance of this ShrineValidationProblemDetails.  # noqa: E501
-        :type: str
-        """
-
-        self._instance = instance
-
-    @property
-    def extensions(self):
-        """Gets the extensions of this ShrineValidationProblemDetails.  # noqa: E501
-
-
-        :return: The extensions of this ShrineValidationProblemDetails.  # noqa: E501
-        :rtype: dict(str, object)
-        """
-        return self._extensions
-
-    @extensions.setter
-    def extensions(self, extensions):
-        """Sets the extensions of this ShrineValidationProblemDetails.
-
-
-        :param extensions: The extensions of this ShrineValidationProblemDetails.  # noqa: E501
-        :type: dict(str, object)
-        """
-
-        self._extensions = extensions
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, ShrineValidationProblemDetails):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
+
+    The version of the OpenAPI document: 0.0.616
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class ShrineValidationProblemDetails(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'name': 'str',
+        'error_details': 'list[dict(str, str)]',
+        'code': 'int',
+        'errors': 'dict(str, list[str])',
+        'type': 'str',
+        'title': 'str',
+        'status': 'int',
+        'detail': 'str',
+        'instance': 'str',
+        'extensions': 'dict(str, object)'
+    }
+
+    attribute_map = {
+        'name': 'name',
+        'error_details': 'errorDetails',
+        'code': 'code',
+        'errors': 'errors',
+        'type': 'type',
+        'title': 'title',
+        'status': 'status',
+        'detail': 'detail',
+        'instance': 'instance',
+        'extensions': 'extensions'
+    }
+
+    required_map = {
+        'name': 'required',
+        'error_details': 'optional',
+        'code': 'required',
+        'errors': 'optional',
+        'type': 'optional',
+        'title': 'optional',
+        'status': 'optional',
+        'detail': 'optional',
+        'instance': 'optional',
+        'extensions': 'optional'
+    }
+
+    def __init__(self, name=None, error_details=None, code=None, errors=None, type=None, title=None, status=None, detail=None, instance=None, extensions=None):  # noqa: E501
+        """
+        ShrineValidationProblemDetails - a model defined in OpenAPI
+
+        :param name:  (required)
+        :type name: str
+        :param error_details: 
+        :type error_details: list[dict(str, str)]
+        :param code:  (required)
+        :type code: int
+        :param errors: 
+        :type errors: dict(str, list[str])
+        :param type: 
+        :type type: str
+        :param title: 
+        :type title: str
+        :param status: 
+        :type status: int
+        :param detail: 
+        :type detail: str
+        :param instance: 
+        :type instance: str
+        :param extensions: 
+        :type extensions: dict(str, object)
+
+        """  # noqa: E501
+
+        self._name = None
+        self._error_details = None
+        self._code = None
+        self._errors = None
+        self._type = None
+        self._title = None
+        self._status = None
+        self._detail = None
+        self._instance = None
+        self._extensions = None
+        self.discriminator = None
+
+        self.name = name
+        self.error_details = error_details
+        self.code = code
+        self.errors = errors
+        self.type = type
+        self.title = title
+        self.status = status
+        self.detail = detail
+        self.instance = instance
+        self.extensions = extensions
+
+    @property
+    def name(self):
+        """Gets the name of this ShrineValidationProblemDetails.  # noqa: E501
+
+
+        :return: The name of this ShrineValidationProblemDetails.  # noqa: E501
+        :rtype: str
+        """
+        return self._name
+
+    @name.setter
+    def name(self, name):
+        """Sets the name of this ShrineValidationProblemDetails.
+
+
+        :param name: The name of this ShrineValidationProblemDetails.  # noqa: E501
+        :type: str
+        """
+        if name is None:
+            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
+
+        self._name = name
+
+    @property
+    def error_details(self):
+        """Gets the error_details of this ShrineValidationProblemDetails.  # noqa: E501
+
+
+        :return: The error_details of this ShrineValidationProblemDetails.  # noqa: E501
+        :rtype: list[dict(str, str)]
+        """
+        return self._error_details
+
+    @error_details.setter
+    def error_details(self, error_details):
+        """Sets the error_details of this ShrineValidationProblemDetails.
+
+
+        :param error_details: The error_details of this ShrineValidationProblemDetails.  # noqa: E501
+        :type: list[dict(str, str)]
+        """
+
+        self._error_details = error_details
+
+    @property
+    def code(self):
+        """Gets the code of this ShrineValidationProblemDetails.  # noqa: E501
+
+
+        :return: The code of this ShrineValidationProblemDetails.  # noqa: E501
+        :rtype: int
+        """
+        return self._code
+
+    @code.setter
+    def code(self, code):
+        """Sets the code of this ShrineValidationProblemDetails.
+
+
+        :param code: The code of this ShrineValidationProblemDetails.  # noqa: E501
+        :type: int
+        """
+        if code is None:
+            raise ValueError("Invalid value for `code`, must not be `None`")  # noqa: E501
+
+        self._code = code
+
+    @property
+    def errors(self):
+        """Gets the errors of this ShrineValidationProblemDetails.  # noqa: E501
+
+
+        :return: The errors of this ShrineValidationProblemDetails.  # noqa: E501
+        :rtype: dict(str, list[str])
+        """
+        return self._errors
+
+    @errors.setter
+    def errors(self, errors):
+        """Sets the errors of this ShrineValidationProblemDetails.
+
+
+        :param errors: The errors of this ShrineValidationProblemDetails.  # noqa: E501
+        :type: dict(str, list[str])
+        """
+
+        self._errors = errors
+
+    @property
+    def type(self):
+        """Gets the type of this ShrineValidationProblemDetails.  # noqa: E501
+
+
+        :return: The type of this ShrineValidationProblemDetails.  # noqa: E501
+        :rtype: str
+        """
+        return self._type
+
+    @type.setter
+    def type(self, type):
+        """Sets the type of this ShrineValidationProblemDetails.
+
+
+        :param type: The type of this ShrineValidationProblemDetails.  # noqa: E501
+        :type: str
+        """
+
+        self._type = type
+
+    @property
+    def title(self):
+        """Gets the title of this ShrineValidationProblemDetails.  # noqa: E501
+
+
+        :return: The title of this ShrineValidationProblemDetails.  # noqa: E501
+        :rtype: str
+        """
+        return self._title
+
+    @title.setter
+    def title(self, title):
+        """Sets the title of this ShrineValidationProblemDetails.
+
+
+        :param title: The title of this ShrineValidationProblemDetails.  # noqa: E501
+        :type: str
+        """
+
+        self._title = title
+
+    @property
+    def status(self):
+        """Gets the status of this ShrineValidationProblemDetails.  # noqa: E501
+
+
+        :return: The status of this ShrineValidationProblemDetails.  # noqa: E501
+        :rtype: int
+        """
+        return self._status
+
+    @status.setter
+    def status(self, status):
+        """Sets the status of this ShrineValidationProblemDetails.
+
+
+        :param status: The status of this ShrineValidationProblemDetails.  # noqa: E501
+        :type: int
+        """
+
+        self._status = status
+
+    @property
+    def detail(self):
+        """Gets the detail of this ShrineValidationProblemDetails.  # noqa: E501
+
+
+        :return: The detail of this ShrineValidationProblemDetails.  # noqa: E501
+        :rtype: str
+        """
+        return self._detail
+
+    @detail.setter
+    def detail(self, detail):
+        """Sets the detail of this ShrineValidationProblemDetails.
+
+
+        :param detail: The detail of this ShrineValidationProblemDetails.  # noqa: E501
+        :type: str
+        """
+
+        self._detail = detail
+
+    @property
+    def instance(self):
+        """Gets the instance of this ShrineValidationProblemDetails.  # noqa: E501
+
+
+        :return: The instance of this ShrineValidationProblemDetails.  # noqa: E501
+        :rtype: str
+        """
+        return self._instance
+
+    @instance.setter
+    def instance(self, instance):
+        """Sets the instance of this ShrineValidationProblemDetails.
+
+
+        :param instance: The instance of this ShrineValidationProblemDetails.  # noqa: E501
+        :type: str
+        """
+
+        self._instance = instance
+
+    @property
+    def extensions(self):
+        """Gets the extensions of this ShrineValidationProblemDetails.  # noqa: E501
+
+
+        :return: The extensions of this ShrineValidationProblemDetails.  # noqa: E501
+        :rtype: dict(str, object)
+        """
+        return self._extensions
+
+    @extensions.setter
+    def extensions(self, extensions):
+        """Sets the extensions of this ShrineValidationProblemDetails.
+
+
+        :param extensions: The extensions of this ShrineValidationProblemDetails.  # noqa: E501
+        :type: dict(str, object)
+        """
+
+        self._extensions = extensions
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, ShrineValidationProblemDetails):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/text_operator.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/text_operator.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,107 +1,107 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class TextOperator(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    allowed enum values
-    """
-    UNDEFINED = "Undefined"
-    EQUALSCASESENSITIVE = "EqualsCaseSensitive"
-    EQUALSCASEINSENSITIVE = "EqualsCaseInsensitive"
-    NOTEQUALSCASESENSITIVE = "NotEqualsCaseSensitive"
-    NOTEQUALSCASEINSENSITIVE = "NotEqualsCaseInsensitive"
-    CONTAINSCASESENSITIVE = "ContainsCaseSensitive"
-    NOTPRESENTORNOTCONTAINSCASESENSITIVE = "NotPresentOrNotContainsCaseSensitive"
-    NOTPRESENT = "NotPresent"
-
-    allowable_values = [UNDEFINED, EQUALSCASESENSITIVE, EQUALSCASEINSENSITIVE, NOTEQUALSCASESENSITIVE, NOTEQUALSCASEINSENSITIVE, CONTAINSCASESENSITIVE, NOTPRESENTORNOTCONTAINSCASESENSITIVE, NOTPRESENT]  # noqa: E501
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-    }
-
-    attribute_map = {
-    }
-
-    required_map = {
-    }
-
-    def __init__(self):  # noqa: E501
-        """
-        TextOperator - a model defined in OpenAPI
-
-
-        """  # noqa: E501
-        self.discriminator = None
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, TextOperator):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class TextOperator(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    allowed enum values
+    """
+    UNDEFINED = "Undefined"
+    EQUALSCASESENSITIVE = "EqualsCaseSensitive"
+    EQUALSCASEINSENSITIVE = "EqualsCaseInsensitive"
+    NOTEQUALSCASESENSITIVE = "NotEqualsCaseSensitive"
+    NOTEQUALSCASEINSENSITIVE = "NotEqualsCaseInsensitive"
+    CONTAINSCASESENSITIVE = "ContainsCaseSensitive"
+    NOTPRESENTORNOTCONTAINSCASESENSITIVE = "NotPresentOrNotContainsCaseSensitive"
+    NOTPRESENT = "NotPresent"
+
+    allowable_values = [UNDEFINED, EQUALSCASESENSITIVE, EQUALSCASEINSENSITIVE, NOTEQUALSCASESENSITIVE, NOTEQUALSCASEINSENSITIVE, CONTAINSCASESENSITIVE, NOTPRESENTORNOTCONTAINSCASESENSITIVE, NOTPRESENT]  # noqa: E501
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+    }
+
+    attribute_map = {
+    }
+
+    required_map = {
+    }
+
+    def __init__(self):  # noqa: E501
+        """
+        TextOperator - a model defined in OpenAPI
+
+
+        """  # noqa: E501
+        self.discriminator = None
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, TextOperator):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/models/when_spec.py` & `finbourne-access-sdk-0.0.815/finbourne_access/models/when_spec.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,153 +1,153 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-import pprint
-import re  # noqa: F401
-
-import six
-
-class WhenSpec(object):
-    """NOTE: This class is auto generated by OpenAPI Generator.
-    Ref: https://openapi-generator.tech
-
-    Do not edit the class manually.
-    """
-
-    """
-    Attributes:
-      openapi_types (dict): The key is attribute name
-                            and the value is attribute type.
-      attribute_map (dict): The key is attribute name
-                            and the value is json key in definition.
-      required_map (dict): The key is attribute name
-                           and the value is whether it is 'required' or 'optional'.
-    """
-    openapi_types = {
-        'activate': 'datetime',
-        'deactivate': 'datetime'
-    }
-
-    attribute_map = {
-        'activate': 'activate',
-        'deactivate': 'deactivate'
-    }
-
-    required_map = {
-        'activate': 'required',
-        'deactivate': 'optional'
-    }
-
-    def __init__(self, activate=None, deactivate=None):  # noqa: E501
-        """
-        WhenSpec - a model defined in OpenAPI
-
-        :param activate:  (required)
-        :type activate: datetime
-        :param deactivate: 
-        :type deactivate: datetime
-
-        """  # noqa: E501
-
-        self._activate = None
-        self._deactivate = None
-        self.discriminator = None
-
-        self.activate = activate
-        self.deactivate = deactivate
-
-    @property
-    def activate(self):
-        """Gets the activate of this WhenSpec.  # noqa: E501
-
-
-        :return: The activate of this WhenSpec.  # noqa: E501
-        :rtype: datetime
-        """
-        return self._activate
-
-    @activate.setter
-    def activate(self, activate):
-        """Sets the activate of this WhenSpec.
-
-
-        :param activate: The activate of this WhenSpec.  # noqa: E501
-        :type: datetime
-        """
-        if activate is None:
-            raise ValueError("Invalid value for `activate`, must not be `None`")  # noqa: E501
-
-        self._activate = activate
-
-    @property
-    def deactivate(self):
-        """Gets the deactivate of this WhenSpec.  # noqa: E501
-
-
-        :return: The deactivate of this WhenSpec.  # noqa: E501
-        :rtype: datetime
-        """
-        return self._deactivate
-
-    @deactivate.setter
-    def deactivate(self, deactivate):
-        """Sets the deactivate of this WhenSpec.
-
-
-        :param deactivate: The deactivate of this WhenSpec.  # noqa: E501
-        :type: datetime
-        """
-
-        self._deactivate = deactivate
-
-    def to_dict(self):
-        """Returns the model properties as a dict"""
-        result = {}
-
-        for attr, _ in six.iteritems(self.openapi_types):
-            value = getattr(self, attr)
-            if isinstance(value, list):
-                result[attr] = list(map(
-                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
-                    value
-                ))
-            elif hasattr(value, "to_dict"):
-                result[attr] = value.to_dict()
-            elif isinstance(value, dict):
-                result[attr] = dict(map(
-                    lambda item: (item[0], item[1].to_dict())
-                    if hasattr(item[1], "to_dict") else item,
-                    value.items()
-                ))
-            else:
-                result[attr] = value
-
-        return result
-
-    def to_str(self):
-        """Returns the string representation of the model"""
-        return pprint.pformat(self.to_dict())
-
-    def __repr__(self):
-        """For `print` and `pprint`"""
-        return self.to_str()
-
-    def __eq__(self, other):
-        """Returns true if both objects are equal"""
-        if not isinstance(other, WhenSpec):
-            return False
-
-        return self.__dict__ == other.__dict__
-
-    def __ne__(self, other):
-        """Returns true if both objects are not equal"""
-        return not self == other
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+import pprint
+import re  # noqa: F401
+
+import six
+
+class WhenSpec(object):
+    """NOTE: This class is auto generated by OpenAPI Generator.
+    Ref: https://openapi-generator.tech
+
+    Do not edit the class manually.
+    """
+
+    """
+    Attributes:
+      openapi_types (dict): The key is attribute name
+                            and the value is attribute type.
+      attribute_map (dict): The key is attribute name
+                            and the value is json key in definition.
+      required_map (dict): The key is attribute name
+                           and the value is whether it is 'required' or 'optional'.
+    """
+    openapi_types = {
+        'activate': 'datetime',
+        'deactivate': 'datetime'
+    }
+
+    attribute_map = {
+        'activate': 'activate',
+        'deactivate': 'deactivate'
+    }
+
+    required_map = {
+        'activate': 'required',
+        'deactivate': 'optional'
+    }
+
+    def __init__(self, activate=None, deactivate=None):  # noqa: E501
+        """
+        WhenSpec - a model defined in OpenAPI
+
+        :param activate:  (required)
+        :type activate: datetime
+        :param deactivate: 
+        :type deactivate: datetime
+
+        """  # noqa: E501
+
+        self._activate = None
+        self._deactivate = None
+        self.discriminator = None
+
+        self.activate = activate
+        self.deactivate = deactivate
+
+    @property
+    def activate(self):
+        """Gets the activate of this WhenSpec.  # noqa: E501
+
+
+        :return: The activate of this WhenSpec.  # noqa: E501
+        :rtype: datetime
+        """
+        return self._activate
+
+    @activate.setter
+    def activate(self, activate):
+        """Sets the activate of this WhenSpec.
+
+
+        :param activate: The activate of this WhenSpec.  # noqa: E501
+        :type: datetime
+        """
+        if activate is None:
+            raise ValueError("Invalid value for `activate`, must not be `None`")  # noqa: E501
+
+        self._activate = activate
+
+    @property
+    def deactivate(self):
+        """Gets the deactivate of this WhenSpec.  # noqa: E501
+
+
+        :return: The deactivate of this WhenSpec.  # noqa: E501
+        :rtype: datetime
+        """
+        return self._deactivate
+
+    @deactivate.setter
+    def deactivate(self, deactivate):
+        """Sets the deactivate of this WhenSpec.
+
+
+        :param deactivate: The deactivate of this WhenSpec.  # noqa: E501
+        :type: datetime
+        """
+
+        self._deactivate = deactivate
+
+    def to_dict(self):
+        """Returns the model properties as a dict"""
+        result = {}
+
+        for attr, _ in six.iteritems(self.openapi_types):
+            value = getattr(self, attr)
+            if isinstance(value, list):
+                result[attr] = list(map(
+                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
+                    value
+                ))
+            elif hasattr(value, "to_dict"):
+                result[attr] = value.to_dict()
+            elif isinstance(value, dict):
+                result[attr] = dict(map(
+                    lambda item: (item[0], item[1].to_dict())
+                    if hasattr(item[1], "to_dict") else item,
+                    value.items()
+                ))
+            else:
+                result[attr] = value
+
+        return result
+
+    def to_str(self):
+        """Returns the string representation of the model"""
+        return pprint.pformat(self.to_dict())
+
+    def __repr__(self):
+        """For `print` and `pprint`"""
+        return self.to_str()
+
+    def __eq__(self, other):
+        """Returns true if both objects are equal"""
+        if not isinstance(other, WhenSpec):
+            return False
+
+        return self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        """Returns true if both objects are not equal"""
+        return not self == other
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/rest.py` & `finbourne-access-sdk-0.0.815/finbourne_access/rest.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,296 +1,292 @@
-# coding: utf-8
-
-"""
-    FINBOURNE Access Management API
-
-    ### Introduction    This page documents the LUSID Access Management APIs from FINBOURNE Technology, which allow authorised users to query and update their access control policies and roles within the LUSID platform's Identity and Access Management system.      # noqa: E501
-
-    The version of the OpenAPI document: 0.0.616
-    Contact: info@finbourne.com
-    Generated by: https://openapi-generator.tech
-"""
-
-
-from __future__ import absolute_import
-
-import io
-import json
-import logging
-import re
-import ssl
-
-import certifi
-# python 2 and python 3 compatibility library
-import six
-from six.moves.urllib.parse import urlencode
-import urllib3
-
-from finbourne_access.exceptions import ApiException, ApiValueError
-from finbourne_access.tcp.tcp_keep_alive_probes import TCPKeepAlivePoolManager, TCPKeepAliveProxyManager
-
-logger = logging.getLogger(__name__)
-
-
-class RESTResponse(io.IOBase):
-
-    def __init__(self, resp):
-        self.urllib3_response = resp
-        self.status = resp.status
-        self.reason = resp.reason
-        self.data = resp.data
-
-    def getheaders(self):
-        """Returns a dictionary of the response headers."""
-        return self.urllib3_response.getheaders()
-
-    def getheader(self, name, default=None):
-        """Returns a given response header."""
-        return self.urllib3_response.getheader(name, default)
-
-
-class RESTClientObject(object):
-
-    def __init__(self, configuration, pools_size=4, maxsize=None):
-        # urllib3.PoolManager will pass all kw parameters to connectionpool
-        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501
-        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501
-        # maxsize is the number of requests to host that are allowed in parallel  # noqa: E501
-        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501
-
-        # cert_reqs
-        if configuration.verify_ssl:
-            cert_reqs = ssl.CERT_REQUIRED
-        else:
-            cert_reqs = ssl.CERT_NONE
-
-        # ca_certs
-        if configuration.ssl_ca_cert:
-            ca_certs = configuration.ssl_ca_cert
-        else:
-            # if not set certificate file, use Mozilla's root certificates.
-            ca_certs = certifi.where()
-
-        addition_pool_args = {}
-        if configuration.assert_hostname is not None:
-            addition_pool_args['assert_hostname'] = configuration.assert_hostname  # noqa: E501
-
-        if configuration.retries is not None:
-            addition_pool_args['retries'] = configuration.retries
-
-        if maxsize is None:
-            if configuration.connection_pool_maxsize is not None:
-                maxsize = configuration.connection_pool_maxsize
-            else:
-                maxsize = 4
-
-        if configuration.proxy:
-            self.pool_manager = TCPKeepAliveProxyManager(
-                num_pools=pools_size,
-                maxsize=maxsize,
-                cert_reqs=cert_reqs,
-                ca_certs=ca_certs,
-                cert_file=configuration.cert_file,
-                key_file=configuration.key_file,
-                proxy_url=configuration.proxy,
-                proxy_headers=configuration.proxy_headers,
-                **addition_pool_args
-            )
-        else:
-            self.pool_manager = TCPKeepAlivePoolManager(
-                num_pools=pools_size,
-                maxsize=maxsize,
-                cert_reqs=cert_reqs,
-                ca_certs=ca_certs,
-                cert_file=configuration.cert_file,
-                key_file=configuration.key_file,
-                **addition_pool_args
-            )
-
-    def request(self, method, url, query_params=None, headers=None,
-                body=None, post_params=None, _preload_content=True,
-                _request_timeout=None):
-        """Perform requests.
-
-        :param method: http request method
-        :param url: http request url
-        :param query_params: query parameters in the url
-        :param headers: http request headers
-        :param body: request json body, for `application/json`
-        :param post_params: request post parameters,
-                            `application/x-www-form-urlencoded`
-                            and `multipart/form-data`
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        """
-        method = method.upper()
-        assert method in ['GET', 'HEAD', 'DELETE', 'POST', 'PUT',
-                          'PATCH', 'OPTIONS']
-
-        if post_params and body:
-            raise ApiValueError(
-                "body parameter cannot be used with post_params parameter."
-            )
-
-        post_params = post_params or {}
-        headers = headers or {}
-
-        timeout = None
-        if _request_timeout:
-            if isinstance(_request_timeout, (int, ) if six.PY3 else (int, long)):  # noqa: E501,F821
-                timeout = urllib3.Timeout(total=_request_timeout)
-            elif (isinstance(_request_timeout, tuple) and
-                  len(_request_timeout) == 2):
-                timeout = urllib3.Timeout(
-                    connect=_request_timeout[0], read=_request_timeout[1])
-
-        if 'Content-Type' not in headers:
-            headers['Content-Type'] = 'application/json'
-
-        try:
-            # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`
-            if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:
-                if query_params:
-                    url += '?' + urlencode(query_params)
-                if re.search('json', headers['Content-Type'], re.IGNORECASE):
-                    request_body = None
-                    if body is not None:
-                        request_body = json.dumps(body)
-                    r = self.pool_manager.request(
-                        method, url,
-                        body=request_body,
-                        preload_content=_preload_content,
-                        timeout=timeout,
-                        headers=headers)
-                elif headers['Content-Type'] == 'application/x-www-form-urlencoded':  # noqa: E501
-                    r = self.pool_manager.request(
-                        method, url,
-                        fields=post_params,
-                        encode_multipart=False,
-                        preload_content=_preload_content,
-                        timeout=timeout,
-                        headers=headers)
-                elif headers['Content-Type'] == 'multipart/form-data':
-                    # must del headers['Content-Type'], or the correct
-                    # Content-Type which generated by urllib3 will be
-                    # overwritten.
-                    del headers['Content-Type']
-                    r = self.pool_manager.request(
-                        method, url,
-                        fields=post_params,
-                        encode_multipart=True,
-                        preload_content=_preload_content,
-                        timeout=timeout,
-                        headers=headers)
-                # Pass a `string` parameter directly in the body to support
-                # other content types than Json when `body` argument is
-                # provided in serialized form
-                elif isinstance(body, str) or isinstance(body, bytes):
-                    request_body = body
-                    r = self.pool_manager.request(
-                        method, url,
-                        body=request_body,
-                        preload_content=_preload_content,
-                        timeout=timeout,
-                        headers=headers)
-                else:
-                    # Cannot generate the request from given parameters
-                    msg = """Cannot prepare a request message for provided
-                             arguments. Please check that your arguments match
-                             declared content type."""
-                    raise ApiException(status=0, reason=msg)
-            # For `GET`, `HEAD`
-            else:
-                r = self.pool_manager.request(method, url,
-                                              fields=query_params,
-                                              preload_content=_preload_content,
-                                              timeout=timeout,
-                                              headers=headers)
-        except urllib3.exceptions.SSLError as e:
-            msg = "{0}\n{1}".format(type(e).__name__, str(e))
-            raise ApiException(status=0, reason=msg)
-
-        if _preload_content:
-            r = RESTResponse(r)
-
-            # In the python 3, the response.data is bytes.
-            # we need to decode it to string.
-            if six.PY3:
-                r.data = r.data.decode('utf8')
-
-            # log response body
-            logger.debug("response body: %s", r.data)
-
-        if not 200 <= r.status <= 299:
-            raise ApiException(http_resp=r)
-
-        return r
-
-    def GET(self, url, headers=None, query_params=None, _preload_content=True,
-            _request_timeout=None):
-        return self.request("GET", url,
-                            headers=headers,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            query_params=query_params)
-
-    def HEAD(self, url, headers=None, query_params=None, _preload_content=True,
-             _request_timeout=None):
-        return self.request("HEAD", url,
-                            headers=headers,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            query_params=query_params)
-
-    def OPTIONS(self, url, headers=None, query_params=None, post_params=None,
-                body=None, _preload_content=True, _request_timeout=None):
-        return self.request("OPTIONS", url,
-                            headers=headers,
-                            query_params=query_params,
-                            post_params=post_params,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            body=body)
-
-    def DELETE(self, url, headers=None, query_params=None, body=None,
-               _preload_content=True, _request_timeout=None):
-        return self.request("DELETE", url,
-                            headers=headers,
-                            query_params=query_params,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            body=body)
-
-    def POST(self, url, headers=None, query_params=None, post_params=None,
-             body=None, _preload_content=True, _request_timeout=None):
-        return self.request("POST", url,
-                            headers=headers,
-                            query_params=query_params,
-                            post_params=post_params,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            body=body)
-
-    def PUT(self, url, headers=None, query_params=None, post_params=None,
-            body=None, _preload_content=True, _request_timeout=None):
-        return self.request("PUT", url,
-                            headers=headers,
-                            query_params=query_params,
-                            post_params=post_params,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
-                            body=body)
-
-    def PATCH(self, url, headers=None, query_params=None, post_params=None,
-              body=None, _preload_content=True, _request_timeout=None):
-        return self.request("PATCH", url,
-                            headers=headers,
-                            query_params=query_params,
-                            post_params=post_params,
-                            _preload_content=_preload_content,
-                            _request_timeout=_request_timeout,
+# coding: utf-8
+
+"""
+    FINBOURNE Access Management API
+
+    FINBOURNE Technology  # noqa: E501
+
+    The version of the OpenAPI document: 0.0.815
+    Contact: info@finbourne.com
+    Generated by: https://openapi-generator.tech
+"""
+
+
+from __future__ import absolute_import
+
+import io
+import json
+import logging
+import re
+import ssl
+
+import certifi
+# python 2 and python 3 compatibility library
+import six
+from six.moves.urllib.parse import urlencode
+import urllib3
+
+from finbourne_access.exceptions import ApiException, ApiValueError
+from finbourne_access.tcp.tcp_keep_alive_probes import TCPKeepAlivePoolManager, TCPKeepAliveProxyManager
+
+logger = logging.getLogger(__name__)
+
+
+class RESTResponse(io.IOBase):
+
+    def __init__(self, resp):
+        self.urllib3_response = resp
+        self.status = resp.status
+        self.reason = resp.reason
+        self.data = resp.data
+
+    def getheaders(self):
+        """Returns a dictionary of the response headers."""
+        return self.urllib3_response.getheaders()
+
+    def getheader(self, name, default=None):
+        """Returns a given response header."""
+        return self.urllib3_response.getheader(name, default)
+
+
+class RESTClientObject(object):
+
+    def __init__(self, configuration, pools_size=4, maxsize=None):
+        # urllib3.PoolManager will pass all kw parameters to connectionpool
+        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501
+        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501
+        # maxsize is the number of requests to host that are allowed in parallel  # noqa: E501
+        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501
+
+        # cert_reqs
+        if configuration.verify_ssl:
+            cert_reqs = ssl.CERT_REQUIRED
+        else:
+            cert_reqs = ssl.CERT_NONE
+
+        # ca_certs
+        if configuration.ssl_ca_cert:
+            ca_certs = configuration.ssl_ca_cert
+        else:
+            # if not set certificate file, use Mozilla's root certificates.
+            ca_certs = certifi.where()
+
+        addition_pool_args = {}
+        if configuration.assert_hostname is not None:
+            addition_pool_args['assert_hostname'] = configuration.assert_hostname  # noqa: E501
+
+        if configuration.retries is not None:
+            addition_pool_args['retries'] = configuration.retries
+
+        if maxsize is None:
+            if configuration.connection_pool_maxsize is not None:
+                maxsize = configuration.connection_pool_maxsize
+            else:
+                maxsize = 4
+
+        if configuration.proxy:
+            self.pool_manager = TCPKeepAliveProxyManager(
+                num_pools=pools_size,
+                maxsize=maxsize,
+                cert_reqs=cert_reqs,
+                ca_certs=ca_certs,
+                cert_file=configuration.cert_file,
+                key_file=configuration.key_file,
+                proxy_url=configuration.proxy,
+                proxy_headers=configuration.proxy_headers,
+                **addition_pool_args
+            )
+        else:
+            self.pool_manager = TCPKeepAlivePoolManager(
+                num_pools=pools_size,
+                maxsize=maxsize,
+                cert_reqs=cert_reqs,
+                ca_certs=ca_certs,
+                cert_file=configuration.cert_file,
+                key_file=configuration.key_file,
+                **addition_pool_args
+            )
+
+    def request(self, method, url, query_params=None, headers=None,
+                body=None, post_params=None, _preload_content=True,
+                _request_timeout=None):
+        """Perform requests.
+
+        :param method: http request method
+        :param url: http request url
+        :param query_params: query parameters in the url
+        :param headers: http request headers
+        :param body: request json body, for `application/json`
+        :param post_params: request post parameters,
+                            `application/x-www-form-urlencoded`
+                            and `multipart/form-data`
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        """
+        method = method.upper()
+        assert method in ['GET', 'HEAD', 'DELETE', 'POST', 'PUT',
+                          'PATCH', 'OPTIONS']
+
+        if post_params and body:
+            raise ApiValueError(
+                "body parameter cannot be used with post_params parameter."
+            )
+
+        post_params = post_params or {}
+        headers = headers or {}
+
+        timeout = None
+        if _request_timeout:
+            if isinstance(_request_timeout, (int, ) if six.PY3 else (int, long)):  # noqa: E501,F821
+                timeout = urllib3.Timeout(total=_request_timeout)
+            elif (isinstance(_request_timeout, tuple) and
+                  len(_request_timeout) == 2):
+                timeout = urllib3.Timeout(
+                    connect=_request_timeout[0], read=_request_timeout[1])
+
+        if 'Content-Type' not in headers:
+            headers['Content-Type'] = 'application/json'
+
+        try:
+            # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`
+            if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:
+                if query_params:
+                    url += '?' + urlencode(query_params)
+                if re.search('json', headers['Content-Type'], re.IGNORECASE):
+                    request_body = None
+                    if body is not None:
+                        request_body = json.dumps(body)
+                    r = self.pool_manager.request(
+                        method, url,
+                        body=request_body,
+                        preload_content=_preload_content,
+                        timeout=timeout,
+                        headers=headers)
+                elif headers['Content-Type'] == 'application/x-www-form-urlencoded':  # noqa: E501
+                    r = self.pool_manager.request(
+                        method, url,
+                        fields=post_params,
+                        encode_multipart=False,
+                        preload_content=_preload_content,
+                        timeout=timeout,
+                        headers=headers)
+                elif headers['Content-Type'] == 'multipart/form-data':
+                    # must del headers['Content-Type'], or the correct
+                    # Content-Type which generated by urllib3 will be
+                    # overwritten.
+                    del headers['Content-Type']
+                    r = self.pool_manager.request(
+                        method, url,
+                        fields=post_params,
+                        encode_multipart=True,
+                        preload_content=_preload_content,
+                        timeout=timeout,
+                        headers=headers)
+                # Pass a `string` parameter directly in the body to support
+                # other content types than Json when `body` argument is
+                # provided in serialized form
+                elif isinstance(body, str) or isinstance(body, bytes):
+                    request_body = body
+                    r = self.pool_manager.request(
+                        method, url,
+                        body=request_body,
+                        preload_content=_preload_content,
+                        timeout=timeout,
+                        headers=headers)
+                else:
+                    # Cannot generate the request from given parameters
+                    msg = """Cannot prepare a request message for provided
+                             arguments. Please check that your arguments match
+                             declared content type."""
+                    raise ApiException(status=0, reason=msg)
+            # For `GET`, `HEAD`
+            else:
+                r = self.pool_manager.request(method, url,
+                                              fields=query_params,
+                                              preload_content=_preload_content,
+                                              timeout=timeout,
+                                              headers=headers)
+        except urllib3.exceptions.SSLError as e:
+            msg = "{0}\n{1}".format(type(e).__name__, str(e))
+            raise ApiException(status=0, reason=msg)
+
+        if _preload_content:
+            r = RESTResponse(r)
+
+
+            # log response body
+            logger.debug("response body: %s", r.data)
+
+        if not 200 <= r.status <= 299:
+            raise ApiException(http_resp=r)
+
+        return r
+
+    def GET(self, url, headers=None, query_params=None, _preload_content=True,
+            _request_timeout=None):
+        return self.request("GET", url,
+                            headers=headers,
+                            _preload_content=_preload_content,
+                            _request_timeout=_request_timeout,
+                            query_params=query_params)
+
+    def HEAD(self, url, headers=None, query_params=None, _preload_content=True,
+             _request_timeout=None):
+        return self.request("HEAD", url,
+                            headers=headers,
+                            _preload_content=_preload_content,
+                            _request_timeout=_request_timeout,
+                            query_params=query_params)
+
+    def OPTIONS(self, url, headers=None, query_params=None, post_params=None,
+                body=None, _preload_content=True, _request_timeout=None):
+        return self.request("OPTIONS", url,
+                            headers=headers,
+                            query_params=query_params,
+                            post_params=post_params,
+                            _preload_content=_preload_content,
+                            _request_timeout=_request_timeout,
+                            body=body)
+
+    def DELETE(self, url, headers=None, query_params=None, body=None,
+               _preload_content=True, _request_timeout=None):
+        return self.request("DELETE", url,
+                            headers=headers,
+                            query_params=query_params,
+                            _preload_content=_preload_content,
+                            _request_timeout=_request_timeout,
+                            body=body)
+
+    def POST(self, url, headers=None, query_params=None, post_params=None,
+             body=None, _preload_content=True, _request_timeout=None):
+        return self.request("POST", url,
+                            headers=headers,
+                            query_params=query_params,
+                            post_params=post_params,
+                            _preload_content=_preload_content,
+                            _request_timeout=_request_timeout,
+                            body=body)
+
+    def PUT(self, url, headers=None, query_params=None, post_params=None,
+            body=None, _preload_content=True, _request_timeout=None):
+        return self.request("PUT", url,
+                            headers=headers,
+                            query_params=query_params,
+                            post_params=post_params,
+                            _preload_content=_preload_content,
+                            _request_timeout=_request_timeout,
+                            body=body)
+
+    def PATCH(self, url, headers=None, query_params=None, post_params=None,
+              body=None, _preload_content=True, _request_timeout=None):
+        return self.request("PATCH", url,
+                            headers=headers,
+                            query_params=query_params,
+                            post_params=post_params,
+                            _preload_content=_preload_content,
+                            _request_timeout=_request_timeout,
                             body=body)
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/tcp/tcp_keep_alive_probes.py` & `finbourne-access-sdk-0.0.815/finbourne_access/tcp/tcp_keep_alive_probes.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,108 +1,108 @@
-from urllib3 import HTTPSConnectionPool, HTTPConnectionPool, PoolManager, ProxyManager
-import socket
-import sys
-
-# The content to send on Mac OS in the TCP Keep Alive probe
-TCP_KEEPALIVE = 0x10
-# The maximum time to keep the connection idle before sending probes
-TCP_KEEP_IDLE = 60
-# The interval between probes
-TCP_KEEPALIVE_INTERVAL = 60
-# The maximum number of failed probes before terminating the connection
-TCP_KEEP_CNT = 3
-
-
-class TCPKeepAliveValidationMethods:
-    """
-    This class contains a single method whose sole purpose is to set up TCP Keep Alive probes on the socket for a
-    connection. This is necessary for long running requests which will be silently terminated by the AWS Network Load
-    Balancer which kills a connection if it is idle for more then 350 seconds.
-    """
-    @staticmethod
-    def adjust_connection_socket(conn, protocol: str = "https"):
-        """
-        Adjusts the socket settings so that the client sends a TCP keep alive probe over the connection.
-
-        :param conn: The connection to update the socket settings for
-        :param str protocol: The protocol of the connection
-
-        :return: None
-        """
-
-        if protocol == "http":
-            # It isn't clear how to set this up over HTTP, it seems to differ from HTTPs
-            return
-
-        # TCP Keep Alive Probes for different platforms
-        platform = sys.platform
-        # TCP Keep Alive Probes for Linux
-        if platform == 'linux' and hasattr(socket, "TCP_KEEPIDLE") and hasattr(socket, "TCP_KEEPINTVL") and hasattr(socket, "TCP_KEEPCNT"):
-            # Temporarily commented out due to issues running on JupyterHub
-            # conn.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, TCP_KEEP_IDLE)
-            # conn.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPINTVL, TCP_KEEPALIVE_INTERVAL)
-            # conn.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPCNT, TCP_KEEP_CNT)
-            pass
-
-        # TCP Keep Alive Probes for Windows OS
-        elif platform == 'win32' and hasattr(socket, "SIO_KEEPALIVE_VALS"):
-            conn.sock.ioctl(socket.SIO_KEEPALIVE_VALS, (1, TCP_KEEP_IDLE * 1000, TCP_KEEPALIVE_INTERVAL * 1000))
-
-        # TCP Keep Alive Probes for Mac OS
-        elif platform == 'darwin':
-            conn.sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
-            conn.sock.setsockopt(socket.IPPROTO_TCP, TCP_KEEPALIVE, TCP_KEEPALIVE_INTERVAL)
-
-
-class TCPKeepAliveHTTPSConnectionPool(HTTPSConnectionPool):
-    """
-    This class overrides the _validate_conn method in the HTTPSConnectionPool class. This is the entry point to use
-    for modifying the socket as it is called after the socket is created and before the request is made.
-    """
-    def _validate_conn(self, conn):
-        """
-        Called right before a request is made, after the socket is created.
-        """
-        # Call the method on the base class
-        super()._validate_conn(conn)
-
-        # Set up TCP Keep Alive probes, this is the only line added to this function
-        TCPKeepAliveValidationMethods.adjust_connection_socket(conn, "https")
-
-
-class TCPKeepAliveHTTPConnectionPool(HTTPConnectionPool):
-    """
-    This class overrides the _validate_conn method in the HTTPSConnectionPool class. This is the entry point to use
-    for modifying the socket as it is called after the socket is created and before the request is made.
-
-    In the base class this method is passed completely.
-    """
-
-    def _validate_conn(self, conn):
-        """
-        Called right before a request is made, after the socket is created.
-        """
-        # Call the method on the base class
-        super()._validate_conn(conn)
-
-        # Set up TCP Keep Alive probes, this is the only line added to this function
-        TCPKeepAliveValidationMethods.adjust_connection_socket(conn, "http")
-
-
-class TCPKeepAlivePoolManager(PoolManager):
-    """
-    This Pool Manager has only had the pool_classes_by_scheme variable changed. This now points at the TCPKeepAlive
-    connection pools rather than the default connection pools.
-    """
-    def __init__(self, num_pools=10, headers=None, **connection_pool_kw):
-        super().__init__(num_pools=num_pools, headers=headers, **connection_pool_kw)
-        self.pool_classes_by_scheme = {"http": TCPKeepAliveHTTPConnectionPool, "https": TCPKeepAliveHTTPSConnectionPool}
-
-
-class TCPKeepAliveProxyManager(ProxyManager):
-    """
-    This Proxy Manager has only had the pool_classes_by_scheme variable changed. This now points at the TCPKeepAlive
-    connection pools rather than the default connection pools.
-    """
-    def __init__(self, proxy_url, num_pools=10, headers=None, proxy_headers=None, **connection_pool_kw):
-        super().__init__(proxy_url=proxy_url, num_pools=num_pools, headers=headers, proxy_headers=proxy_headers, **connection_pool_kw)
+from urllib3 import HTTPSConnectionPool, HTTPConnectionPool, PoolManager, ProxyManager
+import socket
+import sys
+
+# The content to send on Mac OS in the TCP Keep Alive probe
+TCP_KEEPALIVE = 0x10
+# The maximum time to keep the connection idle before sending probes
+TCP_KEEP_IDLE = 60
+# The interval between probes
+TCP_KEEPALIVE_INTERVAL = 60
+# The maximum number of failed probes before terminating the connection
+TCP_KEEP_CNT = 3
+
+
+class TCPKeepAliveValidationMethods:
+    """
+    This class contains a single method whose sole purpose is to set up TCP Keep Alive probes on the socket for a
+    connection. This is necessary for long running requests which will be silently terminated by the AWS Network Load
+    Balancer which kills a connection if it is idle for more then 350 seconds.
+    """
+    @staticmethod
+    def adjust_connection_socket(conn, protocol: str = "https"):
+        """
+        Adjusts the socket settings so that the client sends a TCP keep alive probe over the connection.
+
+        :param conn: The connection to update the socket settings for
+        :param str protocol: The protocol of the connection
+
+        :return: None
+        """
+
+        if protocol == "http":
+            # It isn't clear how to set this up over HTTP, it seems to differ from HTTPs
+            return
+
+        # TCP Keep Alive Probes for different platforms
+        platform = sys.platform
+        # TCP Keep Alive Probes for Linux
+        if platform == 'linux' and hasattr(socket, "TCP_KEEPIDLE") and hasattr(socket, "TCP_KEEPINTVL") and hasattr(socket, "TCP_KEEPCNT"):
+            # Temporarily commented out due to issues running on JupyterHub
+            # conn.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, TCP_KEEP_IDLE)
+            # conn.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPINTVL, TCP_KEEPALIVE_INTERVAL)
+            # conn.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPCNT, TCP_KEEP_CNT)
+            pass
+
+        # TCP Keep Alive Probes for Windows OS
+        elif platform == 'win32' and hasattr(socket, "SIO_KEEPALIVE_VALS"):
+            conn.sock.ioctl(socket.SIO_KEEPALIVE_VALS, (1, TCP_KEEP_IDLE * 1000, TCP_KEEPALIVE_INTERVAL * 1000))
+
+        # TCP Keep Alive Probes for Mac OS
+        elif platform == 'darwin':
+            conn.sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
+            conn.sock.setsockopt(socket.IPPROTO_TCP, TCP_KEEPALIVE, TCP_KEEPALIVE_INTERVAL)
+
+
+class TCPKeepAliveHTTPSConnectionPool(HTTPSConnectionPool):
+    """
+    This class overrides the _validate_conn method in the HTTPSConnectionPool class. This is the entry point to use
+    for modifying the socket as it is called after the socket is created and before the request is made.
+    """
+    def _validate_conn(self, conn):
+        """
+        Called right before a request is made, after the socket is created.
+        """
+        # Call the method on the base class
+        super()._validate_conn(conn)
+
+        # Set up TCP Keep Alive probes, this is the only line added to this function
+        TCPKeepAliveValidationMethods.adjust_connection_socket(conn, "https")
+
+
+class TCPKeepAliveHTTPConnectionPool(HTTPConnectionPool):
+    """
+    This class overrides the _validate_conn method in the HTTPSConnectionPool class. This is the entry point to use
+    for modifying the socket as it is called after the socket is created and before the request is made.
+
+    In the base class this method is passed completely.
+    """
+
+    def _validate_conn(self, conn):
+        """
+        Called right before a request is made, after the socket is created.
+        """
+        # Call the method on the base class
+        super()._validate_conn(conn)
+
+        # Set up TCP Keep Alive probes, this is the only line added to this function
+        TCPKeepAliveValidationMethods.adjust_connection_socket(conn, "http")
+
+
+class TCPKeepAlivePoolManager(PoolManager):
+    """
+    This Pool Manager has only had the pool_classes_by_scheme variable changed. This now points at the TCPKeepAlive
+    connection pools rather than the default connection pools.
+    """
+    def __init__(self, num_pools=10, headers=None, **connection_pool_kw):
+        super().__init__(num_pools=num_pools, headers=headers, **connection_pool_kw)
+        self.pool_classes_by_scheme = {"http": TCPKeepAliveHTTPConnectionPool, "https": TCPKeepAliveHTTPSConnectionPool}
+
+
+class TCPKeepAliveProxyManager(ProxyManager):
+    """
+    This Proxy Manager has only had the pool_classes_by_scheme variable changed. This now points at the TCPKeepAlive
+    connection pools rather than the default connection pools.
+    """
+    def __init__(self, proxy_url, num_pools=10, headers=None, proxy_headers=None, **connection_pool_kw):
+        super().__init__(proxy_url=proxy_url, num_pools=num_pools, headers=headers, proxy_headers=proxy_headers, **connection_pool_kw)
         self.pool_classes_by_scheme = {"http": TCPKeepAliveHTTPConnectionPool, "https": TCPKeepAliveHTTPSConnectionPool}
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/utilities/__init__.py` & `finbourne-access-sdk-0.0.815/finbourne_access/utilities/__init__.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,7 +1,7 @@
-from finbourne_access.utilities.api_client_builder import ApiClientBuilder
-from finbourne_access.utilities.api_configuration_loader import ApiConfigurationLoader
-from finbourne_access.utilities.refreshing_token import RefreshingToken
-from finbourne_access.utilities.api_client_factory import ApiClientFactory
-from finbourne_access.utilities.finbourne_access_retry import finbourne_accessretry
-from finbourne_access.utilities.proxy_config import ProxyConfig
-from finbourne_access.utilities.api_configuration import ApiConfiguration
+from finbourne_access.utilities.api_client_builder import ApiClientBuilder
+from finbourne_access.utilities.api_configuration_loader import ApiConfigurationLoader
+from finbourne_access.utilities.refreshing_token import RefreshingToken
+from finbourne_access.utilities.api_client_factory import ApiClientFactory
+from finbourne_access.utilities.finbourne_access_retry import finbourne_accessretry
+from finbourne_access.utilities.proxy_config import ProxyConfig
+from finbourne_access.utilities.api_configuration import ApiConfiguration
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/utilities/api_client_builder.py` & `finbourne-access-sdk-0.0.815/finbourne_access/utilities/api_client_builder.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,158 +1,158 @@
-from urllib3 import make_headers
-from urllib.request import pathname2url
-import requests
-
-from finbourne_access import Configuration, ApiClient
-
-from .api_configuration_loader import ApiConfigurationLoader
-from .refreshing_token import RefreshingToken
-
-
-class ApiClientBuilder:
-    """
-    The ApiClientBuilder is responsible for building a finbourne_access.ApiClient. This includes obtaining an access token from
-    Okta or using the provided token.
-
-    Any validation on the inputs required to build a finbourne_access.ApiClient is the responsibility of this ApiClientBuilder.
-    """
-
-    @staticmethod
-    def __check_required_fields(object_to_check, fields):
-        """
-        This function checks that the provided fields on an object are populated with values other than None
-
-        :param object_to_check: The object to check the fields (a.k.a attributes) of
-        :param list[str] fields: The fields to check on the object
-
-        :return: None
-        """
-        # Check for fields which have a value of None
-        missing_fields = [field for field in fields if getattr(object_to_check, field) is None]
-
-        # Raise an error if any fields have a value of None
-        if len(missing_fields) > 0:
-            raise ValueError(
-                f"The fields {str(missing_fields)} on the {object_to_check.__class__.__name__} are set to None, "
-                f"please ensure that you have provided them directly, via a secrets file or environment "
-                f"variables")
-
-    @staticmethod
-    def __generate_access_token(configuration, okta_response_handler):
-        """
-        This function generates an access token by making a call to Okta
-
-        :param ApiConfiguration configuration: The configuration to use
-        :param typing.callable okta_response_handler: An optional function to handle the Okta response
-
-        :return: RefreshingToken api_token: A refreshing API token
-        """
-        # Encode credentials that may contain special characters
-        encoded_password = pathname2url(configuration.password)
-        encoded_client_id = pathname2url(configuration.client_id)
-        encoded_client_secret = pathname2url(configuration.client_secret)
-
-        # Prepare our authentication request
-        token_request_body = f"grant_type=password&username={configuration.username}" \
-            f"&password={encoded_password}&scope=openid client groups offline_access" \
-            f"&client_id={encoded_client_id}&client_secret={encoded_client_secret}"
-
-        headers = {"Accept": "application/json", "Content-Type": "application/x-www-form-urlencoded"}
-
-        # extra request args
-        kwargs = {"headers": headers}
-
-        if configuration.proxy_config is not None:
-            kwargs["proxies"] = configuration.proxy_config.format_proxy_schema()
-
-        # use certificate if supplied
-        if configuration.certificate_filename is not None:
-            kwargs["verify"] = configuration.certificate_filename
-
-        # make request to Okta to get an authentication token
-        okta_response = requests.post(configuration.token_url, data=token_request_body, **kwargs)
-
-        if okta_response_handler is not None:
-            okta_response_handler(okta_response)
-
-        # Ensure that we have a 200 response code
-        if okta_response.status_code != 200:
-            raise ValueError(okta_response.json())
-
-        # convert the json encoded response to be able to extract the token values
-        okta_json = okta_response.json()
-
-        # Retrieve our api token from the authentication response
-        api_token = RefreshingToken(token_url=configuration.token_url,
-                                    client_id=encoded_client_id,
-                                    client_secret=encoded_client_secret,
-                                    initial_access_token=okta_json["access_token"],
-                                    initial_token_expiry=okta_json["expires_in"],
-                                    refresh_token=okta_json["refresh_token"],
-                                    proxies=kwargs.get("proxies", None),
-                                    certificate_filename=kwargs.get("verify", None))
-
-        return api_token
-
-    @classmethod
-    def build(cls, api_secrets_filename=None, okta_response_handler=None, api_configuration=None, token=None):
-        """
-        :param str api_secrets_filename: The full path to the JSON file containing the API credentials and optional proxy details
-        :param typing.callable okta_response_handler: An optional function to handle the Okta response
-        :param finbourne_access.utilities.ApiConfiguration api_configuration: A pre-populated ApiConfiguration
-        :param str token: The pre-populated access token to use instead of asking Okta for a token
-
-        :return: finbourne_access.ApiClient: The configured LUSID ApiClient
-        """
-
-        # Load the configuration
-        configuration = ApiConfigurationLoader.load(api_secrets_filename)
-
-        # If an api_configuration has been provided override the loaded configuration with any properties that it has
-        if api_configuration is not None:
-            for key, value in vars(api_configuration).items():
-                if value is not None:
-                    setattr(configuration, key, value)
-
-        # Use the access token provided if it exists
-        if token is not None:
-            # Check that there is an api_url available
-            cls.__check_required_fields(configuration, ["api_url"])
-            api_token = token
-        # Otherwise generate an access token from Okta and use a RefreshingToken going forward
-        else:
-            # Check that all the required fields for generating a token exist
-            cls.__check_required_fields(configuration, [
-                "api_url",
-                "password",
-                "username",
-                "client_id",
-                "client_secret",
-                "token_url"])
-
-            # Generate an access token
-            api_token = cls.__generate_access_token(
-                configuration=configuration,
-                okta_response_handler=okta_response_handler
-            )
-
-        # Initialise the API client using the token so that it can be included in all future requests
-        config = Configuration()
-        config.access_token = api_token
-        config.host = configuration.api_url
-
-        # Set the certificate from the configuration
-        config.ssl_ca_cert = configuration.certificate_filename
-
-        # Set the proxy for LUSID if needed
-        if configuration.proxy_config is not None:
-            config.proxy = configuration.proxy_config.address
-            if configuration.proxy_config.username is not None and configuration.proxy_config.password is not None:
-                config.proxy_headers = make_headers(
-                    proxy_basic_auth=f"{configuration.proxy_config.username}:{configuration.proxy_config.password}"
-                )
-
-        # Create and return the ApiClient
-        return ApiClient(
-            configuration=config,
-            header_name="X-LUSID-Application" if configuration.app_name is not None else None,
-            header_value=configuration.app_name)
+from urllib3 import make_headers
+from urllib.request import pathname2url
+import requests
+
+from finbourne_access import Configuration, ApiClient
+
+from .api_configuration_loader import ApiConfigurationLoader
+from .refreshing_token import RefreshingToken
+
+
+class ApiClientBuilder:
+    """
+    The ApiClientBuilder is responsible for building a finbourne_access.ApiClient. This includes obtaining an access token from
+    Okta or using the provided token.
+
+    Any validation on the inputs required to build a finbourne_access.ApiClient is the responsibility of this ApiClientBuilder.
+    """
+
+    @staticmethod
+    def __check_required_fields(object_to_check, fields):
+        """
+        This function checks that the provided fields on an object are populated with values other than None
+
+        :param object_to_check: The object to check the fields (a.k.a attributes) of
+        :param list[str] fields: The fields to check on the object
+
+        :return: None
+        """
+        # Check for fields which have a value of None
+        missing_fields = [field for field in fields if getattr(object_to_check, field) is None]
+
+        # Raise an error if any fields have a value of None
+        if len(missing_fields) > 0:
+            raise ValueError(
+                f"The fields {str(missing_fields)} on the {object_to_check.__class__.__name__} are set to None, "
+                f"please ensure that you have provided them directly, via a secrets file or environment "
+                f"variables")
+
+    @staticmethod
+    def __generate_access_token(configuration, okta_response_handler):
+        """
+        This function generates an access token by making a call to Okta
+
+        :param ApiConfiguration configuration: The configuration to use
+        :param typing.callable okta_response_handler: An optional function to handle the Okta response
+
+        :return: RefreshingToken api_token: A refreshing API token
+        """
+        # Encode credentials that may contain special characters
+        encoded_password = pathname2url(configuration.password)
+        encoded_client_id = pathname2url(configuration.client_id)
+        encoded_client_secret = pathname2url(configuration.client_secret)
+
+        # Prepare our authentication request
+        token_request_body = f"grant_type=password&username={configuration.username}" \
+            f"&password={encoded_password}&scope=openid client groups offline_access" \
+            f"&client_id={encoded_client_id}&client_secret={encoded_client_secret}"
+
+        headers = {"Accept": "application/json", "Content-Type": "application/x-www-form-urlencoded"}
+
+        # extra request args
+        kwargs = {"headers": headers}
+
+        if configuration.proxy_config is not None:
+            kwargs["proxies"] = configuration.proxy_config.format_proxy_schema()
+
+        # use certificate if supplied
+        if configuration.certificate_filename is not None:
+            kwargs["verify"] = configuration.certificate_filename
+
+        # make request to Okta to get an authentication token
+        okta_response = requests.post(configuration.token_url, data=token_request_body, **kwargs)
+
+        if okta_response_handler is not None:
+            okta_response_handler(okta_response)
+
+        # Ensure that we have a 200 response code
+        if okta_response.status_code != 200:
+            raise ValueError(okta_response.json())
+
+        # convert the json encoded response to be able to extract the token values
+        okta_json = okta_response.json()
+
+        # Retrieve our api token from the authentication response
+        api_token = RefreshingToken(token_url=configuration.token_url,
+                                    client_id=encoded_client_id,
+                                    client_secret=encoded_client_secret,
+                                    initial_access_token=okta_json["access_token"],
+                                    initial_token_expiry=okta_json["expires_in"],
+                                    refresh_token=okta_json["refresh_token"],
+                                    proxies=kwargs.get("proxies", None),
+                                    certificate_filename=kwargs.get("verify", None))
+
+        return api_token
+
+    @classmethod
+    def build(cls, api_secrets_filename=None, okta_response_handler=None, api_configuration=None, token=None):
+        """
+        :param str api_secrets_filename: The full path to the JSON file containing the API credentials and optional proxy details
+        :param typing.callable okta_response_handler: An optional function to handle the Okta response
+        :param finbourne_access.utilities.ApiConfiguration api_configuration: A pre-populated ApiConfiguration
+        :param str token: The pre-populated access token to use instead of asking Okta for a token
+
+        :return: finbourne_access.ApiClient: The configured LUSID ApiClient
+        """
+
+        # Load the configuration
+        configuration = ApiConfigurationLoader.load(api_secrets_filename)
+
+        # If an api_configuration has been provided override the loaded configuration with any properties that it has
+        if api_configuration is not None:
+            for key, value in vars(api_configuration).items():
+                if value is not None:
+                    setattr(configuration, key, value)
+
+        # Use the access token provided if it exists
+        if token is not None:
+            # Check that there is an access_url available
+            cls.__check_required_fields(configuration, ["access_url"])
+            api_token = token
+        # Otherwise generate an access token from Okta and use a RefreshingToken going forward
+        else:
+            # Check that all the required fields for generating a token exist
+            cls.__check_required_fields(configuration, [
+                "access_url",
+                "password",
+                "username",
+                "client_id",
+                "client_secret",
+                "token_url"])
+
+            # Generate an access token
+            api_token = cls.__generate_access_token(
+                configuration=configuration,
+                okta_response_handler=okta_response_handler
+            )
+
+        # Initialise the API client using the token so that it can be included in all future requests
+        config = Configuration()
+        config.access_token = api_token
+        config.host = configuration.access_url
+
+        # Set the certificate from the configuration
+        config.ssl_ca_cert = configuration.certificate_filename
+
+        # Set the proxy for LUSID if needed
+        if configuration.proxy_config is not None:
+            config.proxy = configuration.proxy_config.address
+            if configuration.proxy_config.username is not None and configuration.proxy_config.password is not None:
+                config.proxy_headers = make_headers(
+                    proxy_basic_auth=f"{configuration.proxy_config.username}:{configuration.proxy_config.password}"
+                )
+
+        # Create and return the ApiClient
+        return ApiClient(
+            configuration=config,
+            header_name="X-LUSID-Application" if configuration.app_name is not None else None,
+            header_value=configuration.app_name)
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/utilities/api_client_factory.py` & `finbourne-access-sdk-0.0.815/finbourne_access/utilities/api_client_factory.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,121 +1,121 @@
-import functools
-import importlib
-import inspect
-
-from finbourne_access import ApiClient
-from finbourne_access.utilities.api_client_builder import ApiClientBuilder
-from finbourne_access.utilities.proxy_config import ProxyConfig
-from finbourne_access.utilities.api_configuration import ApiConfiguration
-from finbourne_access.utilities.finbourne_access_retry import finbourne_accessretry
-
-
-class ApiClientFactory:
-    """
-    The ApiClientFactory is responsible for providing the ability to create any of the LUSID APIs using the provided
-    credentials. It will use the same ApiClient across all of the APIs.
-
-    """
-    def __init__(self, **kwargs):
-        """
-        Iniitalise an ApiClientFactory by passing the token, api_url and app_name, or by
-        passing in the api_secrets_filename
-
-        :param str token: Bearer token used to initialise the API
-        :param str api_secrets_filename: Name of secrets file (including full path)
-        :param str api_url: LUSID API url
-        :param str app_name: Application name (optional)
-        :param str certificate_filename: Name of the certificate file (.pem, .cer or .crt)
-        :param str proxy_url: The url of the proxy to use including the port e.g. http://myproxy.com:8888
-        :param str proxy_username: The username for the proxy to use
-        :param str proxy_password: The password for the proxy to use
-        """
-
-        builder_kwargs = {}
-
-        if "token" in kwargs and str(kwargs["token"]) != "None":
-            # If there is a token use it along with the specified proxy details if specified
-            config = ApiConfiguration(
-                api_url=kwargs.get("api_url", None),
-                certificate_filename=kwargs.get("certificate_filename", None),
-                proxy_config=ProxyConfig(
-                    address=kwargs.get("proxy_url", None),
-                    username=kwargs.get("proxy_username", None),
-                    password=kwargs.get("proxy_password", None),
-                ) if kwargs.get("proxy_url", None) is not None else None,
-                app_name=kwargs.get("app_name", None)
-            )
-
-            builder_kwargs["api_configuration"] = config
-            builder_kwargs["token"] = kwargs["token"]
-
-        # Otherwise use a secrets file if it exists
-        builder_kwargs["api_secrets_filename"] = kwargs.get("api_secrets_filename", None)
-
-        # Call the client builder, this will result in using either a token, secrets file or environment variables
-        self.api_client = ApiClientBuilder.build(**builder_kwargs)
-
-    def build(self, metaclass):
-        """
-        :param type metaclass:  type of the LUSID API to create
-        :return: Initalised LUSID API for the type passed in
-        """
-
-        def get_attribute_impl(source_obj, name):
-            """
-            Implementation of __getattribute__ that adds a decorator that adds a call_info
-            argument to return additional call stats
-            """
-
-            attr = super(metaclass, source_obj).__getattribute__(name)
-
-            @functools.wraps(attr)
-            @finbourne_accessretry
-            def wrapper(*args, **kwargs):
-                def is_http_info_method(m):
-                    return inspect.ismethod(m) and m.__name__.endswith(
-                        "_with_http_info"
-                    )
-
-                if kwargs.get("call_info") is not None:
-                    callback = kwargs.pop("call_info")
-
-                    if not inspect.isfunction(callback):
-                        raise ValueError("call_info value must be a lambda")
-
-                    if is_http_info_method(attr):
-                        result = attr(*args, **kwargs)
-                    else:
-                        #   switch to the '_with_http_info' implementation
-                        func = getattr(source_obj, f"{name}_with_http_info")
-                        result = func(*args, **kwargs)
-
-                    # pass the http info to caller
-                    callback(result[2])
-
-                    # return the dto
-                    return result[0]
-
-                else:
-                    return attr(*args, **kwargs)
-
-            return wrapper if inspect.ismethod(attr) else attr
-
-        def init_impl(dest, src=None):
-            if type(dest) == type(src):
-                dest.__dict__ = src.__dict__
-            elif type(src) == ApiClient:
-                dest.api_client = src
-
-        module = importlib.import_module("finbourne_access.api")
-        api_name = metaclass.__name__
-
-        if not api_name.endswith("Api") or not hasattr(module, api_name):
-            raise TypeError(f"unknown api: {api_name}")
-
-        # create an instance of the api
-        api_impl = getattr(module, api_name)(self.api_client)
-
-        setattr(metaclass, "__getattribute__", get_attribute_impl)
-        setattr(metaclass, "__init__", init_impl)
-
-        return api_impl
+import functools
+import importlib
+import inspect
+
+from finbourne_access import ApiClient
+from finbourne_access.utilities.api_client_builder import ApiClientBuilder
+from finbourne_access.utilities.proxy_config import ProxyConfig
+from finbourne_access.utilities.api_configuration import ApiConfiguration
+from finbourne_access.utilities.finbourne_access_retry import finbourne_accessretry
+
+
+class ApiClientFactory:
+    """
+    The ApiClientFactory is responsible for providing the ability to create any of the LUSID APIs using the provided
+    credentials. It will use the same ApiClient across all of the APIs.
+
+    """
+    def __init__(self, **kwargs):
+        """
+        Iniitalise an ApiClientFactory by passing the token, access_url and app_name, or by
+        passing in the api_secrets_filename
+
+        :param str token: Bearer token used to initialise the API
+        :param str api_secrets_filename: Name of secrets file (including full path)
+        :param str access_url: LUSID API url
+        :param str app_name: Application name (optional)
+        :param str certificate_filename: Name of the certificate file (.pem, .cer or .crt)
+        :param str proxy_url: The url of the proxy to use including the port e.g. http://myproxy.com:8888
+        :param str proxy_username: The username for the proxy to use
+        :param str proxy_password: The password for the proxy to use
+        """
+
+        builder_kwargs = {}
+
+        if "token" in kwargs and str(kwargs["token"]) != "None":
+            # If there is a token use it along with the specified proxy details if specified
+            config = ApiConfiguration(
+                access_url=kwargs.get("access_url", None),
+                certificate_filename=kwargs.get("certificate_filename", None),
+                proxy_config=ProxyConfig(
+                    address=kwargs.get("proxy_url", None),
+                    username=kwargs.get("proxy_username", None),
+                    password=kwargs.get("proxy_password", None),
+                ) if kwargs.get("proxy_url", None) is not None else None,
+                app_name=kwargs.get("app_name", None)
+            )
+
+            builder_kwargs["api_configuration"] = config
+            builder_kwargs["token"] = kwargs["token"]
+
+        # Otherwise use a secrets file if it exists
+        builder_kwargs["api_secrets_filename"] = kwargs.get("api_secrets_filename", None)
+
+        # Call the client builder, this will result in using either a token, secrets file or environment variables
+        self.api_client = ApiClientBuilder.build(**builder_kwargs)
+
+    def build(self, metaclass):
+        """
+        :param type metaclass:  type of the LUSID API to create
+        :return: Initalised LUSID API for the type passed in
+        """
+
+        def get_attribute_impl(source_obj, name):
+            """
+            Implementation of __getattribute__ that adds a decorator that adds a call_info
+            argument to return additional call stats
+            """
+
+            attr = super(metaclass, source_obj).__getattribute__(name)
+
+            @functools.wraps(attr)
+            @finbourne_accessretry
+            def wrapper(*args, **kwargs):
+                def is_http_info_method(m):
+                    return inspect.ismethod(m) and m.__name__.endswith(
+                        "_with_http_info"
+                    )
+
+                if kwargs.get("call_info") is not None:
+                    callback = kwargs.pop("call_info")
+
+                    if not inspect.isfunction(callback):
+                        raise ValueError("call_info value must be a lambda")
+
+                    if is_http_info_method(attr):
+                        result = attr(*args, **kwargs)
+                    else:
+                        #   switch to the '_with_http_info' implementation
+                        func = getattr(source_obj, f"{name}_with_http_info")
+                        result = func(*args, **kwargs)
+
+                    # pass the http info to caller
+                    callback(result[2])
+
+                    # return the dto
+                    return result[0]
+
+                else:
+                    return attr(*args, **kwargs)
+
+            return wrapper if inspect.ismethod(attr) else attr
+
+        def init_impl(dest, src=None):
+            if type(dest) == type(src):
+                dest.__dict__ = src.__dict__
+            elif type(src) == ApiClient:
+                dest.api_client = src
+
+        module = importlib.import_module("finbourne_access.api")
+        api_name = metaclass.__name__
+
+        if not api_name.endswith("Api") or not hasattr(module, api_name):
+            raise TypeError(f"unknown api: {api_name}")
+
+        # create an instance of the api
+        api_impl = getattr(module, api_name)(self.api_client)
+
+        setattr(metaclass, "__getattribute__", get_attribute_impl)
+        setattr(metaclass, "__init__", init_impl)
+
+        return api_impl
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/utilities/api_configuration.py` & `finbourne-access-sdk-0.0.815/finbourne_access/utilities/api_configuration.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,98 +1,98 @@
-class ApiConfiguration:
-
-    def __init__(self, token_url=None, api_url=None, username=None, password=None, client_id=None, client_secret=None,
-                 app_name=None, certificate_filename=None, proxy_config=None):
-        """
-        The configuration required to access LUSID, read more at https://support.finbourne.com/getting-started-with-apis-sdks
-
-        :param str token_url: The token URL of the identity provider
-        :param str api_url: The API URL for the LUSID client
-        :param str username: The username to use
-        :param str password: The password to use
-        :param str client_id: The client id to use
-        :param str client_secret: The client secret to use
-        :param str app_name: The name of the application calling LUSID
-        :param str certificate_filename: Name of the certificate file (.pem, .cer or .crt)
-        :param finbourne_access.utilities.ProxyConfig proxy_config: The proxy configuration to use
-        """
-        self.__token_url = token_url
-        self.__api_url = api_url
-        self.__username = username
-        self.__password = password
-        self.__client_id = client_id
-        self.__client_secret = client_secret
-        self.__app_name = app_name
-        self.__certificate_filename = certificate_filename
-        self.__proxy_config = proxy_config
-
-    @property
-    def token_url(self):
-        return self.__token_url
-
-    @token_url.setter
-    def token_url(self, value):
-        self.__token_url = value
-
-    @property
-    def api_url(self):
-        return self.__api_url
-
-    @api_url.setter
-    def api_url(self, value):
-        self.__api_url = value
-
-    @property
-    def username(self):
-        return self.__username
-
-    @username.setter
-    def username(self, value):
-        self.__username = value
-
-    @property
-    def password(self):
-        return self.__password
-
-    @password.setter
-    def password(self, value):
-        self.__password = value
-
-    @property
-    def client_id(self):
-        return self.__client_id
-
-    @client_id.setter
-    def client_id(self, value):
-        self.__client_id = value
-
-    @property
-    def client_secret(self):
-        return self.__client_secret
-
-    @client_secret.setter
-    def client_secret(self, value):
-        self.__client_secret = value
-
-    @property
-    def app_name(self):
-        return self.__app_name
-
-    @app_name.setter
-    def app_name(self, value):
-        self.__app_name = value
-
-    @property
-    def certificate_filename(self):
-        return self.__certificate_filename
-
-    @certificate_filename.setter
-    def certificate_filename(self, value):
-        self.__certificate_filename = value
-
-    @property
-    def proxy_config(self):
-        return self.__proxy_config
-
-    @proxy_config.setter
-    def proxy_config(self, value):
-        self.__proxy_config = value
+class ApiConfiguration:
+
+    def __init__(self, token_url=None, access_url=None, username=None, password=None, client_id=None, client_secret=None,
+                 app_name=None, certificate_filename=None, proxy_config=None):
+        """
+        The configuration required to access LUSID, read more at https://support.finbourne.com/getting-started-with-apis-sdks
+
+        :param str token_url: The token URL of the identity provider
+        :param str access_url: The API URL for the LUSID client
+        :param str username: The username to use
+        :param str password: The password to use
+        :param str client_id: The client id to use
+        :param str client_secret: The client secret to use
+        :param str app_name: The name of the application calling LUSID
+        :param str certificate_filename: Name of the certificate file (.pem, .cer or .crt)
+        :param finbourne_access.utilities.ProxyConfig proxy_config: The proxy configuration to use
+        """
+        self.__token_url = token_url
+        self.__access_url = access_url
+        self.__username = username
+        self.__password = password
+        self.__client_id = client_id
+        self.__client_secret = client_secret
+        self.__app_name = app_name
+        self.__certificate_filename = certificate_filename
+        self.__proxy_config = proxy_config
+
+    @property
+    def token_url(self):
+        return self.__token_url
+
+    @token_url.setter
+    def token_url(self, value):
+        self.__token_url = value
+
+    @property
+    def access_url(self):
+        return self.__access_url
+
+    @access_url.setter
+    def access_url(self, value):
+        self.__access_url = value
+
+    @property
+    def username(self):
+        return self.__username
+
+    @username.setter
+    def username(self, value):
+        self.__username = value
+
+    @property
+    def password(self):
+        return self.__password
+
+    @password.setter
+    def password(self, value):
+        self.__password = value
+
+    @property
+    def client_id(self):
+        return self.__client_id
+
+    @client_id.setter
+    def client_id(self, value):
+        self.__client_id = value
+
+    @property
+    def client_secret(self):
+        return self.__client_secret
+
+    @client_secret.setter
+    def client_secret(self, value):
+        self.__client_secret = value
+
+    @property
+    def app_name(self):
+        return self.__app_name
+
+    @app_name.setter
+    def app_name(self, value):
+        self.__app_name = value
+
+    @property
+    def certificate_filename(self):
+        return self.__certificate_filename
+
+    @certificate_filename.setter
+    def certificate_filename(self, value):
+        self.__certificate_filename = value
+
+    @property
+    def proxy_config(self):
+        return self.__proxy_config
+
+    @proxy_config.setter
+    def proxy_config(self, value):
+        self.__proxy_config = value
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/utilities/api_configuration_loader.py` & `finbourne-access-sdk-0.0.815/finbourne_access/utilities/api_configuration_loader.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,66 +1,66 @@
-import json
-import os
-from pathlib import Path
-import logging
-
-from finbourne_access.utilities.api_configuration import ApiConfiguration
-from finbourne_access.utilities.proxy_config import ProxyConfig
-
-
-class ApiConfigurationLoader:
-    """
-    The ApiConfigurationLoader is responsible for populating the API and Proxy configuration from a secrets file or
-    environment variables with preference given to the secrets file.
-    """
-    @staticmethod
-    def load(api_secrets_filename=None):
-        """
-        :param str api_secrets_filename: The full path to the JSON file containing the API credentials and optional proxy details
-
-        :return: finbourne_access.utilities.ApiConfiguration: The populated ApiConfiguration
-        """
-        # Get the config keys which contain the mapping between the ApiConfiguration attributes and the variable names
-        # in the secrets.json file and environment variables e.g. token_url is tokenUrl (secrets.json) and
-        # FBN_TOKEN_URL (env variable)
-        with open(Path(__file__).parent.joinpath('config_keys.json')) as json_file:
-            config_keys = json.load(json_file)
-
-        # The secrets file is a nested dictionary, set the names of the top level keys
-        api_config_key = "api"
-        proxy_config_key = "proxy"
-
-        # If there is a secrets file specified and it exists get the details from it
-        if api_secrets_filename is not None and os.path.exists(api_secrets_filename) and os.path.isfile(api_secrets_filename):
-            with open(api_secrets_filename, "r") as secrets:
-                config = json.load(secrets)
-        # If there is a secrets file specified and it does not exist log a warning to indicate that the specified file
-        # could not be found and create an empty config
-        elif api_secrets_filename is not None and (not os.path.exists(api_secrets_filename) or not os.path.isfile(api_secrets_filename)):
-            logging.warning(f"Provided secrets file of {api_secrets_filename} can not be found, please ensure you "
-                             f"have correctly specified the full path to the file or don't provide a secrets file to use "
-                             f"environment variables instead.")
-            config = {}
-        # If no secrets file is specified just create an empty config
-        else:
-            config = {}
-
-        # Populate the values for the api configuration preferring the secrets file over the environment variables
-        populated_api_config_values = {
-            key: config.get(api_config_key, {}).get(value["config"], os.getenv(value["env"], None))
-            for key, value in config_keys.items() if "proxy" not in key
-        }
-
-        # Populate the values for the proxy preferring the secrets file over the environment variables
-        populated_proxy_values = {
-            key.replace("proxy_", ""): config.get(proxy_config_key, {}).get(value["config"], os.getenv(value["env"], None))
-            for key, value in config_keys.items() if "proxy" in key
-        }
-
-        # If the proxy address is missing ensure that no proxy is used in the ApiConfiguration
-        if populated_proxy_values.get("address", None) is None:
-            populated_api_config_values["proxy_config"] = None
-        # Otherwise create a ProxyConfig to use
-        else:
-            populated_api_config_values["proxy_config"] = ProxyConfig(**populated_proxy_values)
-        # Create and return the ApiConfiguration
-        return ApiConfiguration(**populated_api_config_values)
+import json
+import os
+from pathlib import Path
+import logging
+
+from finbourne_access.utilities.api_configuration import ApiConfiguration
+from finbourne_access.utilities.proxy_config import ProxyConfig
+
+
+class ApiConfigurationLoader:
+    """
+    The ApiConfigurationLoader is responsible for populating the API and Proxy configuration from a secrets file or
+    environment variables with preference given to the secrets file.
+    """
+    @staticmethod
+    def load(api_secrets_filename=None):
+        """
+        :param str api_secrets_filename: The full path to the JSON file containing the API credentials and optional proxy details
+
+        :return: finbourne_access.utilities.ApiConfiguration: The populated ApiConfiguration
+        """
+        # Get the config keys which contain the mapping between the ApiConfiguration attributes and the variable names
+        # in the secrets.json file and environment variables e.g. token_url is tokenUrl (secrets.json) and
+        # FBN_TOKEN_URL (env variable)
+        with open(Path(__file__).parent.joinpath('config_keys.json')) as json_file:
+            config_keys = json.load(json_file)
+
+        # The secrets file is a nested dictionary, set the names of the top level keys
+        api_config_key = "api"
+        proxy_config_key = "proxy"
+
+        # If there is a secrets file specified and it exists get the details from it
+        if api_secrets_filename is not None and os.path.exists(api_secrets_filename) and os.path.isfile(api_secrets_filename):
+            with open(api_secrets_filename, "r") as secrets:
+                config = json.load(secrets)
+        # If there is a secrets file specified and it does not exist log a warning to indicate that the specified file
+        # could not be found and create an empty config
+        elif api_secrets_filename is not None and (not os.path.exists(api_secrets_filename) or not os.path.isfile(api_secrets_filename)):
+            logging.warning(f"Provided secrets file of {api_secrets_filename} can not be found, please ensure you "
+                             f"have correctly specified the full path to the file or don't provide a secrets file to use "
+                             f"environment variables instead.")
+            config = {}
+        # If no secrets file is specified just create an empty config
+        else:
+            config = {}
+
+        # Populate the values for the api configuration preferring the secrets file over the environment variables
+        populated_api_config_values = {
+            key: config.get(api_config_key, {}).get(value["config"], os.getenv(value["env"], None))
+            for key, value in config_keys.items() if "proxy" not in key
+        }
+
+        # Populate the values for the proxy preferring the secrets file over the environment variables
+        populated_proxy_values = {
+            key.replace("proxy_", ""): config.get(proxy_config_key, {}).get(value["config"], os.getenv(value["env"], None))
+            for key, value in config_keys.items() if "proxy" in key
+        }
+
+        # If the proxy address is missing ensure that no proxy is used in the ApiConfiguration
+        if populated_proxy_values.get("address", None) is None:
+            populated_api_config_values["proxy_config"] = None
+        # Otherwise create a ProxyConfig to use
+        else:
+            populated_api_config_values["proxy_config"] = ProxyConfig(**populated_proxy_values)
+        # Create and return the ApiConfiguration
+        return ApiConfiguration(**populated_api_config_values)
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/utilities/finbourne_access_retry.py` & `finbourne-access-sdk-0.0.815/finbourne_access/utilities/finbourne_access_retry.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,37 +1,37 @@
-import functools
-from time import sleep
-
-from finbourne_access import ApiException
-
-
-def finbourne_accessretry(fn):
-
-    @functools.wraps(fn)
-    def __retry(*args, **kwargs):
-
-        retries = kwargs.get("finbourne_access_retries", 3)
-        if not isinstance(retries, int):
-            retries = 3
-
-        tries = 0
-        while tries < retries:
-            try:
-                return fn(*args, **kwargs)
-            except ApiException as ex:
-
-                tries += 1
-                retry_after = ex.headers.get("Retry-After")
-
-                # have done max number of retries
-                if tries == retries:
-                    raise
-
-                # try after delay
-                elif retry_after is not None:
-                    sleep(retry_after)
-
-                # no retry header
-                else:
-                    raise
-
-    return __retry
+import functools
+from time import sleep
+
+from finbourne_access import ApiException
+
+
+def finbourne_accessretry(fn):
+
+    @functools.wraps(fn)
+    def __retry(*args, **kwargs):
+
+        retries = kwargs.get("finbourne_access_retries", 3)
+        if not isinstance(retries, int):
+            retries = 3
+
+        tries = 0
+        while tries < retries:
+            try:
+                return fn(*args, **kwargs)
+            except ApiException as ex:
+
+                tries += 1
+                retry_after = ex.headers.get("Retry-After")
+
+                # have done max number of retries
+                if tries == retries:
+                    raise
+
+                # try after delay
+                elif retry_after is not None:
+                    sleep(retry_after)
+
+                # no retry header
+                else:
+                    raise
+
+    return __retry
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/utilities/proxy_config.py` & `finbourne-access-sdk-0.0.815/finbourne_access/utilities/proxy_config.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,54 +1,54 @@
-class ProxyConfig:
-    """
-    This class is used to hold the proxy configuration details
-    """
-
-    def __init__(self, address, username=None, password=None):
-        """
-        :param str address: The address of the proxy including the port e.g. https://myproxy.com:8080
-        :param str username: The username for the proxy
-        :param str password: The password for the proxy
-        """
-        self.address = address
-        self.__username = username
-        self.__password = password
-
-    @property
-    def address(self):
-        return self.__address
-
-    @address.setter
-    def address(self, address):
-
-        if "http://" not in address and "https://" not in address:
-            raise ValueError(f"The provided proxy address of {address} does not contain a protocol, please specify in the full format e.g. http://myproxy.com:8080")
-
-        self.__address = address
-
-    @property
-    def username(self):
-        return self.__username
-
-    @property
-    def password(self):
-        return self.__password
-
-    def format_proxy_schema(self):
-        """
-        Takes the proxy details and converts them into a dictionary format to be used with other libraries e.g. requests
-
-        :return: dict: A dictionary with the http and https proxy details including username and password
-        """
-
-        proxy_url = self.address
-
-        # Only run if there is a username and password
-        if self.username is not None and self.password is not None:
-            index = self.address.index("://")
-
-            proxy_url = f"{self.address[0:index + 3]}{self.username}:{self.password}@{self.address[index + 3:]}"
-
-        return {
-            "http": proxy_url,
-            "https": proxy_url
-        }
+class ProxyConfig:
+    """
+    This class is used to hold the proxy configuration details
+    """
+
+    def __init__(self, address, username=None, password=None):
+        """
+        :param str address: The address of the proxy including the port e.g. https://myproxy.com:8080
+        :param str username: The username for the proxy
+        :param str password: The password for the proxy
+        """
+        self.address = address
+        self.__username = username
+        self.__password = password
+
+    @property
+    def address(self):
+        return self.__address
+
+    @address.setter
+    def address(self, address):
+
+        if "http://" not in address and "https://" not in address:
+            raise ValueError(f"The provided proxy address of {address} does not contain a protocol, please specify in the full format e.g. http://myproxy.com:8080")
+
+        self.__address = address
+
+    @property
+    def username(self):
+        return self.__username
+
+    @property
+    def password(self):
+        return self.__password
+
+    def format_proxy_schema(self):
+        """
+        Takes the proxy details and converts them into a dictionary format to be used with other libraries e.g. requests
+
+        :return: dict: A dictionary with the http and https proxy details including username and password
+        """
+
+        proxy_url = self.address
+
+        # Only run if there is a username and password
+        if self.username is not None and self.password is not None:
+            index = self.address.index("://")
+
+            proxy_url = f"{self.address[0:index + 3]}{self.username}:{self.password}@{self.address[index + 3:]}"
+
+        return {
+            "http": proxy_url,
+            "https": proxy_url
+        }
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access/utilities/refreshing_token.py` & `finbourne-access-sdk-0.0.815/finbourne_access/utilities/refreshing_token.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,75 +1,75 @@
-import requests
-import base64
-
-from datetime import datetime
-from datetime import timedelta
-from collections import UserString
-
-
-class RefreshingToken(UserString):
-
-    def __init__(self, token_url, client_id, client_secret, initial_access_token, initial_token_expiry, refresh_token,
-                 expiry_offset=60, proxies=None, certificate_filename=None):
-        """
-        Implementation of UserString that will automatically refresh the token value upon expiry
-
-        :param str token_url: token refresh url
-        :param str client_id: OpenID Connect Client ID
-        :param str client_secret: OpenID Connect Client Secret
-        :param str initial_access_token: initial access token
-        :param int initial_token_expiry: number of seconds the initial token is valid for before expiring
-        :param str refresh_token: initial refresh token
-        :param int expiry_offset: number of seconds before token expiry to refresh the token
-        :param dict proxies: dictionary containing proxy schemas
-        :param str certifiate_filename: The path to the client side certificate to use
-        """
-
-        token_data = {
-            "expires": datetime.utcnow() + timedelta(seconds=initial_token_expiry),
-            "access_token": initial_access_token
-        }
-
-        def get_refresh_token():
-
-            # check if the token has expired and refresh if needed
-            if token_data["expires"] <= datetime.utcnow():
-
-                encoded_client = base64.b64encode(bytes(f"{client_id}:{client_secret}", 'utf-8'))
-
-                headers = {
-                    "Content-Type": "application/x-www-form-urlencoded",
-                    "Authorization": f"Basic {encoded_client.decode('utf-8')}"
-                }
-
-                request_body = f"grant_type=refresh_token&scope=openid client groups offline_access&refresh_token={refresh_token}"
-
-                # request parameters
-                kwargs = {"headers": headers}
-                kwargs["proxies"] = proxies
-                kwargs["verify"] = certificate_filename
-
-                okta_response = requests.post(token_url, data=request_body, **kwargs)
-
-                if okta_response.status_code != 200:
-                    raise Exception(okta_response.json())
-
-                okta_json = okta_response.json()
-
-                # set the expiry just before the actual expiry to be able to refresh in time
-                delta = timedelta(seconds=okta_json.get("expires_in", 3600) - expiry_offset)
-                token_data["expires"] = datetime.utcnow() + delta
-                token_data["access_token"] = okta_json["access_token"]
-
-            return token_data["access_token"]
-
-        self.refresh_func = get_refresh_token
-
-    def __getattribute__(self, item):
-
-        token = object.__getattribute__(self, "refresh_func")()
-
-        # return the value of the string
-        if item == "data":
-            return token
-
-        return token.__getattribute__(item)
+import requests
+import base64
+
+from datetime import datetime
+from datetime import timedelta
+from collections import UserString
+
+
+class RefreshingToken(UserString):
+
+    def __init__(self, token_url, client_id, client_secret, initial_access_token, initial_token_expiry, refresh_token,
+                 expiry_offset=60, proxies=None, certificate_filename=None):
+        """
+        Implementation of UserString that will automatically refresh the token value upon expiry
+
+        :param str token_url: token refresh url
+        :param str client_id: OpenID Connect Client ID
+        :param str client_secret: OpenID Connect Client Secret
+        :param str initial_access_token: initial access token
+        :param int initial_token_expiry: number of seconds the initial token is valid for before expiring
+        :param str refresh_token: initial refresh token
+        :param int expiry_offset: number of seconds before token expiry to refresh the token
+        :param dict proxies: dictionary containing proxy schemas
+        :param str certifiate_filename: The path to the client side certificate to use
+        """
+
+        token_data = {
+            "expires": datetime.utcnow() + timedelta(seconds=initial_token_expiry),
+            "access_token": initial_access_token
+        }
+
+        def get_refresh_token():
+
+            # check if the token has expired and refresh if needed
+            if token_data["expires"] <= datetime.utcnow():
+
+                encoded_client = base64.b64encode(bytes(f"{client_id}:{client_secret}", 'utf-8'))
+
+                headers = {
+                    "Content-Type": "application/x-www-form-urlencoded",
+                    "Authorization": f"Basic {encoded_client.decode('utf-8')}"
+                }
+
+                request_body = f"grant_type=refresh_token&scope=openid client groups offline_access&refresh_token={refresh_token}"
+
+                # request parameters
+                kwargs = {"headers": headers}
+                kwargs["proxies"] = proxies
+                kwargs["verify"] = certificate_filename
+
+                okta_response = requests.post(token_url, data=request_body, **kwargs)
+
+                if okta_response.status_code != 200:
+                    raise Exception(okta_response.json())
+
+                okta_json = okta_response.json()
+
+                # set the expiry just before the actual expiry to be able to refresh in time
+                delta = timedelta(seconds=okta_json.get("expires_in", 3600) - expiry_offset)
+                token_data["expires"] = datetime.utcnow() + delta
+                token_data["access_token"] = okta_json["access_token"]
+
+            return token_data["access_token"]
+
+        self.refresh_func = get_refresh_token
+
+    def __getattribute__(self, item):
+
+        token = object.__getattribute__(self, "refresh_func")()
+
+        # return the value of the string
+        if item == "data":
+            return token
+
+        return token.__getattribute__(item)
```

### Comparing `finbourne-access-sdk-0.0.616/finbourne_access_sdk.egg-info/SOURCES.txt` & `finbourne-access-sdk-0.0.815/finbourne_access_sdk.egg-info/SOURCES.txt`

 * *Files 3% similar despite different names*

```diff
@@ -1,8 +1,9 @@
 MANIFEST.in
+README.md
 setup.py
 finbourne_access/__init__.py
 finbourne_access/__version__.py
 finbourne_access/api_client.py
 finbourne_access/configuration.py
 finbourne_access/exceptions.py
 finbourne_access/rest.py
@@ -38,14 +39,16 @@
 finbourne_access/models/if_identity_scope_expression.py
 finbourne_access/models/if_request_header_expression.py
 finbourne_access/models/key_value_pair_of_string_to_string.py
 finbourne_access/models/licence_creation_request.py
 finbourne_access/models/licence_selector_definition.py
 finbourne_access/models/licence_update_request.py
 finbourne_access/models/link.py
+finbourne_access/models/lusid_problem_details.py
+finbourne_access/models/lusid_validation_problem_details.py
 finbourne_access/models/match_all_selector_definition.py
 finbourne_access/models/metadata_expression.py
 finbourne_access/models/metadata_selector_definition.py
 finbourne_access/models/non_transitive_supervisor_role_resource.py
 finbourne_access/models/operator.py
 finbourne_access/models/point_in_time_specification.py
 finbourne_access/models/policy_collection_creation_request.py
```

