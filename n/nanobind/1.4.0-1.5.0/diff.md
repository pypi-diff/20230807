# Comparing `tmp/nanobind-1.4.0-py3-none-any.whl.zip` & `tmp/nanobind-1.5.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,39 +1,38 @@
-Zip file size: 179998 bytes, number of entries: 75
--rw-r--r--  2.0 unx      536 b- defN 23-Jun-08 06:57 nanobind/__init__.py
+Zip file size: 177398 bytes, number of entries: 74
+-rw-r--r--  2.0 unx      536 b- defN 23-Aug-07 16:38 nanobind/__init__.py
 -rw-r--r--  2.0 unx      839 b- defN 23-Jun-08 06:57 nanobind/__main__.py
--rw-r--r--  2.0 unx    21457 b- defN 23-Jun-08 06:57 nanobind/cmake/darwin-ld-cpython.sym
+-rw-r--r--  2.0 unx    21536 b- defN 23-Aug-07 14:58 nanobind/cmake/darwin-ld-cpython.sym
 -rw-r--r--  2.0 unx    24614 b- defN 23-Jun-08 06:57 nanobind/cmake/darwin-ld-pypy.sym
--rw-r--r--  2.0 unx    11539 b- defN 23-Jun-08 06:57 nanobind/cmake/nanobind-config.cmake
+-rw-r--r--  2.0 unx    11544 b- defN 23-Aug-07 14:58 nanobind/cmake/nanobind-config.cmake
 -rw-r--r--  2.0 unx    11776 b- defN 23-Jun-08 06:57 nanobind/ext/robin_map/include/tsl/robin_growth_policy.h
 -rw-r--r--  2.0 unx    54550 b- defN 23-Jun-08 06:57 nanobind/ext/robin_map/include/tsl/robin_hash.h
 -rw-r--r--  2.0 unx    28414 b- defN 23-Jun-08 06:57 nanobind/ext/robin_map/include/tsl/robin_map.h
--rw-r--r--  2.0 unx    23593 b- defN 23-Jun-08 06:57 nanobind/ext/robin_map/include/tsl/robin_set.h
 -rw-r--r--  2.0 unx     5601 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/make_iterator.h
--rw-r--r--  2.0 unx     1628 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nanobind.h
+-rw-r--r--  2.0 unx     1628 b- defN 23-Aug-07 16:38 nanobind/include/nanobind/nanobind.h
 -rw-r--r--  2.0 unx     5626 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_accessor.h
--rw-r--r--  2.0 unx     7387 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_attr.h
--rw-r--r--  2.0 unx     5533 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_call.h
--rw-r--r--  2.0 unx    14781 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_cast.h
--rw-r--r--  2.0 unx    23613 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_class.h
+-rw-r--r--  2.0 unx     7399 b- defN 23-Aug-07 14:58 nanobind/include/nanobind/nb_attr.h
+-rw-r--r--  2.0 unx     5471 b- defN 23-Jun-13 22:18 nanobind/include/nanobind/nb_call.h
+-rw-r--r--  2.0 unx    15640 b- defN 23-Aug-07 14:58 nanobind/include/nanobind/nb_cast.h
+-rw-r--r--  2.0 unx    24558 b- defN 23-Aug-07 14:58 nanobind/include/nanobind/nb_class.h
 -rw-r--r--  2.0 unx     5755 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_defs.h
 -rw-r--r--  2.0 unx     4129 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_descr.h
 -rw-r--r--  2.0 unx      666 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_enums.h
--rw-r--r--  2.0 unx     4168 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_error.h
+-rw-r--r--  2.0 unx     5206 b- defN 23-Aug-07 14:58 nanobind/include/nanobind/nb_error.h
 -rw-r--r--  2.0 unx     9769 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_func.h
--rw-r--r--  2.0 unx    18946 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_lib.h
+-rw-r--r--  2.0 unx    20566 b- defN 23-Aug-07 14:58 nanobind/include/nanobind/nb_lib.h
 -rw-r--r--  2.0 unx     1167 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_misc.h
 -rw-r--r--  2.0 unx     1377 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_python.h
 -rw-r--r--  2.0 unx     6653 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_traits.h
 -rw-r--r--  2.0 unx     2468 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_tuple.h
--rw-r--r--  2.0 unx    25243 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/nb_types.h
--rw-r--r--  2.0 unx    13617 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/ndarray.h
+-rw-r--r--  2.0 unx    26673 b- defN 23-Aug-07 14:58 nanobind/include/nanobind/nb_types.h
+-rw-r--r--  2.0 unx    14880 b- defN 23-Jun-14 13:48 nanobind/include/nanobind/ndarray.h
 -rw-r--r--  2.0 unx     7449 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/operators.h
 -rw-r--r--  2.0 unx     2976 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/trampoline.h
--rw-r--r--  2.0 unx    17102 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/eigen/dense.h
+-rw-r--r--  2.0 unx    17071 b- defN 23-Jun-15 19:08 nanobind/include/nanobind/eigen/dense.h
 -rw-r--r--  2.0 unx     6486 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/eigen/sparse.h
 -rw-r--r--  2.0 unx      535 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/array.h
 -rw-r--r--  2.0 unx     5939 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/bind_map.h
 -rw-r--r--  2.0 unx     7420 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/bind_vector.h
 -rw-r--r--  2.0 unx     8675 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/chrono.h
 -rw-r--r--  2.0 unx     2720 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/filesystem.h
 -rw-r--r--  2.0 unx     2478 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/function.h
@@ -54,24 +53,24 @@
 -rw-r--r--  2.0 unx    10571 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/detail/chrono.h
 -rw-r--r--  2.0 unx     1680 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/detail/nb_array.h
 -rw-r--r--  2.0 unx     2655 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/detail/nb_dict.h
 -rw-r--r--  2.0 unx     2132 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/detail/nb_list.h
 -rw-r--r--  2.0 unx     1942 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/detail/nb_set.h
 -rw-r--r--  2.0 unx     3218 b- defN 23-Jun-08 06:57 nanobind/include/nanobind/stl/detail/traits.h
 -rw-r--r--  2.0 unx     4218 b- defN 23-Jun-08 06:57 nanobind/src/buffer.h
--rw-r--r--  2.0 unx    28362 b- defN 23-Jun-08 06:57 nanobind/src/common.cpp
--rw-r--r--  2.0 unx     5624 b- defN 23-Jun-08 06:57 nanobind/src/error.cpp
+-rw-r--r--  2.0 unx    29558 b- defN 23-Aug-07 14:58 nanobind/src/common.cpp
+-rw-r--r--  2.0 unx     8818 b- defN 23-Aug-07 14:58 nanobind/src/error.cpp
 -rw-r--r--  2.0 unx     2538 b- defN 23-Jun-08 06:57 nanobind/src/implicit.cpp
--rw-r--r--  2.0 unx    14696 b- defN 23-Jun-08 06:57 nanobind/src/nb_enum.cpp
--rw-r--r--  2.0 unx    39358 b- defN 23-Jun-08 06:57 nanobind/src/nb_func.cpp
--rw-r--r--  2.0 unx    14972 b- defN 23-Jun-08 06:57 nanobind/src/nb_internals.cpp
--rw-r--r--  2.0 unx     9801 b- defN 23-Jun-08 06:57 nanobind/src/nb_internals.h
--rw-r--r--  2.0 unx    21147 b- defN 23-Jun-08 06:57 nanobind/src/nb_ndarray.cpp
--rw-r--r--  2.0 unx     2348 b- defN 23-Jun-08 06:57 nanobind/src/nb_static_property.cpp
--rw-r--r--  2.0 unx    52719 b- defN 23-Jun-08 06:57 nanobind/src/nb_type.cpp
+-rw-r--r--  2.0 unx    14686 b- defN 23-Jun-10 23:35 nanobind/src/nb_enum.cpp
+-rw-r--r--  2.0 unx    39611 b- defN 23-Aug-07 14:58 nanobind/src/nb_func.cpp
+-rw-r--r--  2.0 unx    14973 b- defN 23-Jun-16 07:17 nanobind/src/nb_internals.cpp
+-rw-r--r--  2.0 unx     9802 b- defN 23-Jun-14 13:48 nanobind/src/nb_internals.h
+-rw-r--r--  2.0 unx    22908 b- defN 23-Jun-14 13:48 nanobind/src/nb_ndarray.cpp
+-rw-r--r--  2.0 unx     1905 b- defN 23-Jun-10 20:56 nanobind/src/nb_static_property.cpp
+-rw-r--r--  2.0 unx    56214 b- defN 23-Aug-07 14:58 nanobind/src/nb_type.cpp
 -rw-r--r--  2.0 unx     5144 b- defN 23-Jun-08 06:57 nanobind/src/trampoline.cpp
--rw-r--r--  2.0 unx     1521 b- defN 23-Jun-08 06:57 nanobind-1.4.0.dist-info/LICENSE
--rw-r--r--  2.0 unx     1406 b- defN 23-Jun-08 06:57 nanobind-1.4.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jun-08 06:57 nanobind-1.4.0.dist-info/WHEEL
--rw-r--r--  2.0 unx        9 b- defN 23-Jun-08 06:57 nanobind-1.4.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     6942 b- defN 23-Jun-08 06:57 nanobind-1.4.0.dist-info/RECORD
-75 files, 657800 bytes uncompressed, 168844 bytes compressed:  74.3%
+-rw-r--r--  2.0 unx     1521 b- defN 23-Aug-07 16:39 nanobind-1.5.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1406 b- defN 23-Aug-07 16:39 nanobind-1.5.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Aug-07 16:39 nanobind-1.5.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        9 b- defN 23-Aug-07 16:39 nanobind-1.5.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     6838 b- defN 23-Aug-07 16:39 nanobind-1.5.0.dist-info/RECORD
+74 files, 650709 bytes uncompressed, 166412 bytes compressed:  74.4%
```

## zipnote {}

```diff
@@ -18,17 +18,14 @@
 
 Filename: nanobind/ext/robin_map/include/tsl/robin_hash.h
 Comment: 
 
 Filename: nanobind/ext/robin_map/include/tsl/robin_map.h
 Comment: 
 
-Filename: nanobind/ext/robin_map/include/tsl/robin_set.h
-Comment: 
-
 Filename: nanobind/include/nanobind/make_iterator.h
 Comment: 
 
 Filename: nanobind/include/nanobind/nanobind.h
 Comment: 
 
 Filename: nanobind/include/nanobind/nb_accessor.h
@@ -204,23 +201,23 @@
 
 Filename: nanobind/src/nb_type.cpp
 Comment: 
 
 Filename: nanobind/src/trampoline.cpp
 Comment: 
 
-Filename: nanobind-1.4.0.dist-info/LICENSE
+Filename: nanobind-1.5.0.dist-info/LICENSE
 Comment: 
 
-Filename: nanobind-1.4.0.dist-info/METADATA
+Filename: nanobind-1.5.0.dist-info/METADATA
 Comment: 
 
-Filename: nanobind-1.4.0.dist-info/WHEEL
+Filename: nanobind-1.5.0.dist-info/WHEEL
 Comment: 
 
-Filename: nanobind-1.4.0.dist-info/top_level.txt
+Filename: nanobind-1.5.0.dist-info/top_level.txt
 Comment: 
 
-Filename: nanobind-1.4.0.dist-info/RECORD
+Filename: nanobind-1.5.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## nanobind/__init__.py

```diff
@@ -8,14 +8,14 @@
     "Return the path to the nanobind include directory"
     return os.path.join(os.path.abspath(os.path.dirname(__file__)), "include")
 
 def cmake_dir() -> str:
     "Return the path to the nanobind CMake module directory."
     return os.path.join(os.path.abspath(os.path.dirname(__file__)), "cmake")
 
-__version__ = "1.4.0"
+__version__ = "1.5.0"
 
 __all__ = (
     "__version__",
     "include_dir",
     "cmake_dir",
 )
```

## nanobind/cmake/darwin-ld-cpython.sym

```diff
@@ -128,14 +128,15 @@
 -U _PyErr_Display
 -U _PyErr_ExceptionMatches
 -U _PyErr_Fetch
 -U _PyErr_Format
 -U _PyErr_FormatV
 -U _PyErr_GetExcInfo
 -U _PyErr_GetHandledException
+-U _PyErr_GetRaisedException
 -U _PyErr_GivenExceptionMatches
 -U _PyErr_NewException
 -U _PyErr_NewExceptionWithDoc
 -U _PyErr_NoMemory
 -U _PyErr_NormalizeException
 -U _PyErr_Occurred
 -U _PyErr_Print
@@ -157,14 +158,15 @@
 -U _PyErr_SetHandledException
 -U _PyErr_SetImportError
 -U _PyErr_SetImportErrorSubclass
 -U _PyErr_SetInterrupt
 -U _PyErr_SetInterruptEx
 -U _PyErr_SetNone
 -U _PyErr_SetObject
+-U _PyErr_SetRaisedException
 -U _PyErr_SetString
 -U _PyErr_SyntaxLocation
 -U _PyErr_SyntaxLocationEx
 -U _PyErr_WarnEx
 -U _PyErr_WarnExplicit
 -U _PyErr_WarnFormat
 -U _PyErr_WriteUnraisable
@@ -871,14 +873,15 @@
 -U __PyTrash_deposit_object
 -U __PyTrash_destroy_chain
 -U __PyTrash_thread_deposit_object
 -U __PyTrash_thread_destroy_chain
 -U __PyWeakref_CallableProxyType
 -U __PyWeakref_ProxyType
 -U __PyWeakref_RefType
+-U __Py_IsFinalizing
 -U __Py_BuildValue_SizeT
 -U __Py_CheckFunctionResult
 -U __Py_CheckRecursionLimit
 -U __Py_CheckRecursiveCall
 -U __Py_Dealloc
 -U __Py_DecRef
 -U __Py_EllipsisObject
```

## nanobind/cmake/nanobind-config.cmake

```diff
@@ -243,15 +243,15 @@
 
 function (nanobind_lto name)
   set_target_properties(${name} PROPERTIES
     INTERPROCEDURAL_OPTIMIZATION_RELEASE ON
     INTERPROCEDURAL_OPTIMIZATION_MINSIZEREL ON)
 endfunction()
 
-function (nanobind_compile_options)
+function (nanobind_compile_options name)
   if (MSVC)
     target_compile_options(${name} PRIVATE /bigobj /MP)
   endif()
 endfunction()
 
 function (nanobind_strip name)
   if (APPLE)
```

## nanobind/include/nanobind/nanobind.h

```diff
@@ -18,15 +18,15 @@
 #  pragma warning(disable: 4702) // unreachable code (e.g. when binding a noreturn function)
    // The next two lines disable warnings that are "just noise" according to Stephan T. Lavavej (a MSFT STL maintainer)
 #  pragma warning(disable: 4275) // non dll-interface class 'std::exception' used as base for dll-interface class [..]
 #  pragma warning(disable: 4251) // [..] needs to have a dll-interface to be used by clients of class [..]
 #endif
 
 #define NB_VERSION_MAJOR 1
-#define NB_VERSION_MINOR 4
+#define NB_VERSION_MINOR 5
 #define NB_VERSION_PATCH 0
 
 // Core C++ headers that nanobind depends on
 #include <cstdint>
 #include <exception>
 #include <stdexcept>
 #include <type_traits>
```

## nanobind/include/nanobind/nb_attr.h

```diff
@@ -59,16 +59,16 @@
 template <typename T> struct intrusive_ptr {
     intrusive_ptr(void (*set_self_py)(T *, PyObject *) noexcept)
         : set_self_py(set_self_py) { }
     void (*set_self_py)(T *, PyObject *) noexcept;
 };
 
 struct type_slots {
-    type_slots (PyType_Slot *value) : value(value) { }
-    PyType_Slot *value;
+    type_slots (const PyType_Slot *value) : value(value) { }
+    const PyType_Slot *value;
 };
 
 struct type_slots_callback {
     using cb_t = void (*)(const detail::type_init_data *t,
                           PyType_Slot *&slots, size_t max_slots) noexcept;
     type_slots_callback(cb_t callback) : callback(callback) { }
     cb_t callback;
```

## nanobind/include/nanobind/nb_call.h

```diff
@@ -69,16 +69,15 @@
         while (PyDict_Next(value.ptr(), &pos, &key, &entry)) {
             Py_INCREF(key); Py_INCREF(entry);
             args[kwargs_offset + nkwargs] = entry;
             NB_TUPLE_SET_ITEM(kwnames, nkwargs++, key);
         }
     } else {
         args[nargs++] =
-            make_caster<T>::from_cpp((forward_t<T>) value,
-                                     detail::infer_policy<T>(policy), nullptr).ptr();
+            make_caster<T>::from_cpp((forward_t<T>) value, policy, nullptr).ptr();
     }
     (void) args; (void) kwnames; (void) nargs;
     (void) nkwargs; (void) kwargs_offset;
 }
 
 #define NB_DO_VECTORCALL()                                                     \
     PyObject *base, **args_p;                                                  \
```

## nanobind/include/nanobind/nb_cast.h

```diff
@@ -243,14 +243,16 @@
 };
 
 template <typename T>
 struct type_caster<T, enable_if_t<std::is_base_of_v<detail::api_tag, T>>> {
 public:
     NB_TYPE_CASTER(T, T::Name)
 
+    type_caster() : value(nullptr, ::nanobind::detail::steal_t()) { }
+
     bool from_python(handle src, uint8_t, cleanup_list *) noexcept {
         if (!isinstance<T>(src))
             return false;
 
         if constexpr (std::is_base_of_v<object, T>)
             value = borrow<T>(src);
         else
@@ -344,14 +346,37 @@
 
 template <typename Type, typename SFINAE>
 struct type_caster : type_caster_base<Type> { };
 
 NAMESPACE_END(detail)
 
 template <typename T, typename Derived>
+bool try_cast(const detail::api<Derived> &value, T &out, bool convert = true) noexcept {
+    using Caster = detail::make_caster<T>;
+    using Output = typename Caster::template Cast<T>;
+
+    static_assert(!std::is_same_v<const char *, T>,
+                  "nanobind::try_cast(): cannot return a reference to a temporary.");
+
+    Caster caster;
+    if (caster.from_python(value.derived().ptr(),
+                           convert ? (uint8_t) detail::cast_flags::convert
+                                   : (uint8_t) 0, nullptr)) {
+        if constexpr (Caster::IsClass)
+            out = caster.operator Output();
+        else
+            out = std::move(caster.operator Output&&());
+
+        return true;
+    }
+
+    return false;
+}
+
+template <typename T, typename Derived>
 T cast(const detail::api<Derived> &value, bool convert = true) {
     if constexpr (std::is_same_v<T, void>) {
         return;
     } else {
         using Caster = detail::make_caster<T>;
         using Output = typename Caster::template Cast<T>;
 
@@ -378,16 +403,16 @@
           #pragma GCC diagnostic pop
         #endif
     }
 }
 
 template <typename T>
 object cast(T &&value, rv_policy policy = rv_policy::automatic_reference) {
-    handle h = detail::make_caster<T>::from_cpp(
-        (detail::forward_t<T>) value, detail::infer_policy<T>(policy), nullptr);
+    handle h = detail::make_caster<T>::from_cpp((detail::forward_t<T>) value,
+                                                policy, nullptr);
     if (!h.is_valid())
         detail::raise_cast_error();
     return steal(h);
 }
 
 template <typename T> object find(const T &value) noexcept {
     return steal(detail::make_caster<T>::from_cpp(value, rv_policy::none, nullptr));
@@ -397,17 +422,17 @@
 tuple make_tuple(Args &&...args) {
     tuple result = steal<tuple>(PyTuple_New((Py_ssize_t) sizeof...(Args)));
 
     size_t nargs = 0;
     PyObject *o = result.ptr();
 
     (NB_TUPLE_SET_ITEM(o, nargs++,
-                      detail::make_caster<Args>::from_cpp(
-                          (detail::forward_t<Args>) args,
-                          detail::infer_policy<Args>(policy), nullptr).ptr()),
+                       detail::make_caster<Args>::from_cpp(
+                           (detail::forward_t<Args>) args, policy, nullptr)
+                           .ptr()),
      ...);
 
     detail::tuple_check(o, sizeof...(Args));
 
     return result;
 }
 
@@ -419,13 +444,13 @@
 detail::accessor<Impl>& detail::accessor<Impl>::operator=(T &&value) {
     object result = cast((detail::forward_t<T>) value);
     Impl::set(m_base, m_key, result.ptr());
     return *this;
 }
 
 template <typename T> void list::append(T &&value) {
-    object o = nanobind::cast(value);
+    object o = nanobind::cast((detail::forward_t<T>) value);
     if (PyList_Append(m_ptr, o.ptr()))
         detail::raise_python_error();
 }
 
 NAMESPACE_END(NB_NAMESPACE)
```

## nanobind/include/nanobind/nb_class.h

```diff
@@ -237,28 +237,56 @@
 // Low level access to nanobind type objects
 inline bool type_check(handle h) { return detail::nb_type_check(h.ptr()); }
 inline size_t type_size(handle h) { return detail::nb_type_size(h.ptr()); }
 inline size_t type_align(handle h) { return detail::nb_type_align(h.ptr()); }
 inline const std::type_info& type_info(handle h) { return *detail::nb_type_info(h.ptr()); }
 template <typename T>
 inline T &type_supplement(handle h) { return *(T *) detail::nb_type_supplement(h.ptr()); }
+inline str type_name(handle h) { return steal<str>(detail::nb_type_name(h.ptr())); };
 
 // Low level access to nanobind instance objects
 inline bool inst_check(handle h) { return type_check(h.type()); }
-inline object inst_alloc(handle h) { return steal(detail::nb_inst_alloc((PyTypeObject *) h.ptr())); }
-inline object inst_wrap(handle h, void *p) { return steal(detail::nb_inst_wrap((PyTypeObject *) h.ptr(), p)); }
+inline str inst_name(handle h) {
+    return steal<str>(detail::nb_inst_name(h.ptr()));
+};
+inline object inst_alloc(handle h) {
+    return steal(detail::nb_inst_alloc((PyTypeObject *) h.ptr()));
+}
+inline object inst_alloc_zero(handle h) {
+    return steal(detail::nb_inst_alloc_zero((PyTypeObject *) h.ptr()));
+}
+inline object inst_take_ownership(handle h, void *p) {
+    return steal(detail::nb_inst_take_ownership((PyTypeObject *) h.ptr(), p));
+}
+inline object inst_reference(handle h, void *p, handle parent = handle()) {
+    return steal(detail::nb_inst_reference((PyTypeObject *) h.ptr(), p, parent.ptr()));
+}
 inline void inst_zero(handle h) { detail::nb_inst_zero(h.ptr()); }
-inline void inst_set_state(handle h, bool ready, bool destruct) { detail::nb_inst_set_state(h.ptr(), ready, destruct); }
-inline std::pair<bool, bool> inst_state(handle h) { return detail::nb_inst_state(h.ptr()); }
+inline void inst_set_state(handle h, bool ready, bool destruct) {
+    detail::nb_inst_set_state(h.ptr(), ready, destruct);
+}
+inline std::pair<bool, bool> inst_state(handle h) {
+    return detail::nb_inst_state(h.ptr());
+}
 inline void inst_mark_ready(handle h) { inst_set_state(h, true, true); }
 inline bool inst_ready(handle h) { return inst_state(h).first; }
 inline void inst_destruct(handle h) { detail::nb_inst_destruct(h.ptr()); }
 inline void inst_copy(handle dst, handle src) { detail::nb_inst_copy(dst.ptr(), src.ptr()); }
 inline void inst_move(handle dst, handle src) { detail::nb_inst_move(dst.ptr(), src.ptr()); }
+inline void inst_replace_copy(handle dst, handle src) { detail::nb_inst_replace_copy(dst.ptr(), src.ptr()); }
+inline void inst_replace_move(handle dst, handle src) { detail::nb_inst_replace_move(dst.ptr(), src.ptr()); }
 template <typename T> T *inst_ptr(handle h) { return (T *) detail::nb_inst_ptr(h.ptr()); }
+inline void *type_get_slot(handle h, int slot_id) {
+#if PY_VERSION_HEX < 0x030A0000
+    return detail::type_get_slot((PyTypeObject *) h.ptr(), slot_id);
+#else
+    return PyType_GetSlot((PyTypeObject *) h.ptr(), slot_id);
+#endif
+}
+
 
 template <typename... Args> struct init {
     template <typename T, typename... Ts> friend class class_;
     NB_INLINE init() {}
 
 private:
     template <typename Class, typename... Extra>
```

## nanobind/include/nanobind/nb_error.h

```diff
@@ -6,30 +6,44 @@
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 
 /// RAII wrapper that temporarily clears any Python error state
+#if PY_VERSION_HEX >= 0x030C0000
+struct error_scope {
+    error_scope() { value = PyErr_GetRaisedException(); }
+    ~error_scope() { PyErr_SetRaisedException(value); }
+private:
+    PyObject *value;
+};
+#else
 struct error_scope {
     error_scope() { PyErr_Fetch(&type, &value, &trace); }
     ~error_scope() { PyErr_Restore(type, value, trace); }
+private:
     PyObject *type, *value, *trace;
 };
+#endif
 
 /// Wraps a Python error state as a C++ exception
 class NB_EXPORT python_error : public std::exception {
 public:
     NB_EXPORT_SHARED python_error();
     NB_EXPORT_SHARED python_error(const python_error &);
     NB_EXPORT_SHARED python_error(python_error &&) noexcept;
     NB_EXPORT_SHARED ~python_error() override;
 
     bool matches(handle exc) const noexcept {
+#if PY_VERSION_HEX < 0x030C0000
         return PyErr_GivenExceptionMatches(m_type, exc.ptr()) != 0;
+#else
+        return PyErr_GivenExceptionMatches(m_value, exc.ptr()) != 0;
+#endif
     }
 
     /// Move the error back into the Python domain. This may only be called
     /// once, and you should not reraise the exception in C++ afterward.
     NB_EXPORT_SHARED void restore() noexcept;
 
     /// Pass the error to Python's `sys.unraisablehook`, which prints
@@ -38,34 +52,50 @@
     /// the error occurred. Like `.restore()`, this consumes the error and
     /// you should not reraise the exception in C++ afterward.
     void discard_as_unraisable(handle context) noexcept {
         restore();
         PyErr_WriteUnraisable(context.ptr());
     }
 
-    handle type() const { return m_type; }
+    void discard_as_unraisable(const char *context) noexcept {
+        object context_s = steal(PyUnicode_FromString(context));
+        discard_as_unraisable(context_s);
+    }
+
     handle value() const { return m_value; }
-    handle trace() const { return m_trace; }
+
+#if PY_VERSION_HEX < 0x030C0000
+    handle type() const { return m_type; }
+    object traceback() const { return steal(m_traceback); }
+#else
+    handle type() const { return value().type(); }
+    object traceback() const { return steal(PyException_GetTraceback(m_value)); }
+#endif
+    [[deprecated]]
+    object trace() const { return traceback(); }
 
     NB_EXPORT_SHARED const char *what() const noexcept override;
 
 private:
+#if PY_VERSION_HEX < 0x030C0000
     mutable PyObject *m_type = nullptr;
     mutable PyObject *m_value = nullptr;
-    mutable PyObject *m_trace = nullptr;
+    mutable PyObject *m_traceback = nullptr;
+#else
+    mutable PyObject *m_value = nullptr;
+#endif
     mutable char *m_what = nullptr;
 };
 
 /// Thrown by nanobind::cast when casting fails
 using cast_error = std::bad_cast;
 
 enum class exception_type {
-    stop_iteration, index_error, key_error, value_error,
-    type_error, buffer_error, import_error, attribute_error,
-    next_overload
+    runtime_error, stop_iteration, index_error, key_error, value_error,
+    type_error, buffer_error, import_error, attribute_error, next_overload
 };
 
 // Base interface used to expose common Python exceptions in C++
 class NB_EXPORT builtin_exception : public std::runtime_error {
 public:
     NB_EXPORT_SHARED builtin_exception(exception_type type, const char *what);
     NB_EXPORT_SHARED builtin_exception(builtin_exception &&) = default;
@@ -112,8 +142,11 @@
                 } catch (T &e) {
                     PyErr_SetString((PyObject *) payload, e.what());
                 }
             }, m_ptr);
     }
 };
 
+NB_CORE void chain_error(handle type, const char *fmt, ...) noexcept;
+[[noreturn]] NB_CORE void raise_from(python_error &e, handle type, const char *fmt, ...);
+
 NAMESPACE_END(NB_NAMESPACE)
```

## nanobind/include/nanobind/nb_lib.h

```diff
@@ -46,35 +46,46 @@
     NB_INLINE PyObject *self() const {
         return m_local[0];
     }
 
     /// Decrease the reference count of all appended objects
     void release() noexcept;
 
+    /// Does the list contain any entries?
+    inline bool used() { return m_size != 1; }
+
 protected:
     /// Out of memory, expand..
     void expand() noexcept;
 
 protected:
     uint32_t m_size;
     uint32_t m_capacity;
     PyObject **m_data;
     PyObject *m_local[Small];
 };
 
 // ========================================================================
 
-/// Raise a std::runtime_error with the given message
+/// Raise a runtime error with the given message
 #if defined(__GNUC__)
     __attribute__((noreturn, __format__ (__printf__, 1, 2)))
 #else
     [[noreturn]]
 #endif
 NB_CORE void raise(const char *fmt, ...);
 
+/// Raise a type error with the given message
+#if defined(__GNUC__)
+    __attribute__((noreturn, __format__ (__printf__, 1, 2)))
+#else
+    [[noreturn]]
+#endif
+NB_CORE void raise_type_error(const char *fmt, ...);
+
 /// Abort the process with a fatal error
 #if defined(__GNUC__)
     __attribute__((noreturn, __format__ (__printf__, 1, 2)))
 #else
     [[noreturn]]
 #endif
 NB_CORE void fail(const char *fmt, ...) noexcept;
@@ -112,17 +123,28 @@
 NB_CORE PyObject *bytes_from_cstr(const char *c);
 
 /// Convert an UTF8 C string + size into a Python byte string
 NB_CORE PyObject *bytes_from_cstr_and_size(const char *c, size_t n);
 
 // ========================================================================
 
-/// Convert a Python object into a Python integer
+/// Convert a Python object into a Python integer object
 NB_CORE PyObject *int_from_obj(PyObject *o);
 
+/// Convert a Python object into a Python floating point object
+NB_CORE PyObject *float_from_obj(PyObject *o);
+
+// ========================================================================
+
+/// Convert a Python object into a Python list
+NB_CORE PyObject *list_from_obj(PyObject *o);
+
+/// Convert a Python object into a Python tuple
+NB_CORE PyObject *tuple_from_obj(PyObject *o);
+
 // ========================================================================
 
 /// Get an object attribute or raise an exception
 NB_CORE PyObject *getattr(PyObject *obj, const char *key);
 NB_CORE PyObject *getattr(PyObject *obj, PyObject *key);
 
 /// Get an object attribute or return a default value (never raises)
@@ -269,14 +291,20 @@
 
 /// Return the size of the type wrapped by the given nanobind type object
 NB_CORE size_t nb_type_size(PyObject *t) noexcept;
 
 /// Return the alignment of the type wrapped by the given nanobind type object
 NB_CORE size_t nb_type_align(PyObject *t) noexcept;
 
+/// Return a unicode string representing the long-form name of the given type
+NB_CORE PyObject *nb_type_name(PyObject *t) noexcept;
+
+/// Return a unicode string representing the long-form name of object's type
+NB_CORE PyObject *nb_inst_name(PyObject *o) noexcept;
+
 /// Return the C++ type_info wrapped by the given nanobind type object
 NB_CORE const std::type_info *nb_type_info(PyObject *t) noexcept;
 
 /// Get a pointer to the instance data of a nanobind instance (nb_inst)
 NB_CORE void *nb_inst_ptr(PyObject *o) noexcept;
 
 /// Check if a Python type object wraps an instance of a specific C++ type
@@ -284,42 +312,46 @@
 
 /// Search for the Python type object associated with a C++ type
 NB_CORE PyObject *nb_type_lookup(const std::type_info *t) noexcept;
 
 /// Allocate an instance of type 't'
 NB_CORE PyObject *nb_inst_alloc(PyTypeObject *t);
 
+/// Allocate an zero-initialized instance of type 't'
+NB_CORE PyObject *nb_inst_alloc_zero(PyTypeObject *t);
+
 /// Allocate an instance of type 't' referencing the existing 'ptr'
-NB_CORE PyObject *nb_inst_wrap(PyTypeObject *t, void *ptr);
+NB_CORE PyObject *nb_inst_reference(PyTypeObject *t, void *ptr,
+                                    PyObject *parent);
+
+/// Allocate an instance of type 't' taking ownership of the existing 'ptr'
+NB_CORE PyObject *nb_inst_take_ownership(PyTypeObject *t, void *ptr);
 
 /// Call the destructor of the given python object
 NB_CORE void nb_inst_destruct(PyObject *o) noexcept;
 
 /// Zero-initialize a POD type and mark it as ready + to be destructed upon GC
 NB_CORE void nb_inst_zero(PyObject *o) noexcept;
 
 /// Copy-construct 'dst' from 'src', mark it as ready and to be destructed (must have the same nb_type)
 NB_CORE void nb_inst_copy(PyObject *dst, const PyObject *src) noexcept;
 
 /// Move-construct 'dst' from 'src', mark it as ready and to be destructed (must have the same nb_type)
 NB_CORE void nb_inst_move(PyObject *dst, const PyObject *src) noexcept;
 
+/// Destruct 'dst', copy-construct 'dst' from 'src', mark ready and retain 'destruct' status (must have the same nb_type)
+NB_CORE void nb_inst_replace_copy(PyObject *dst, const PyObject *src) noexcept;
+
+/// Destruct 'dst', move-construct 'dst' from 'src', mark ready and retain 'destruct' status (must have the same nb_type)
+NB_CORE void nb_inst_replace_move(PyObject *dst, const PyObject *src) noexcept;
+
 /// Check if a particular instance uses a Python-derived type
 NB_CORE bool nb_inst_python_derived(PyObject *o) noexcept;
 
-/**
- * This function can be used to manually set two important flags associated with
- * every nanobind instance (``nb_inst``).
- *
- * 1. 'ready': is the object fully constructed? Otherwise, nanobind will not
- *    allow passing it to a function.
- *
- * 2. 'destruct': Should nanobind call the C++ destructor when the instance
- *    is garbage collected?
- */
+/// Overwrite the instance's ready/destruct flags
 NB_CORE void nb_inst_set_state(PyObject *o, bool ready, bool destruct) noexcept;
 
 /// Query the 'ready' and 'destruct' flags of an instance
 NB_CORE std::pair<bool, bool> nb_inst_state(PyObject *o) noexcept;
 
 // ========================================================================
 
@@ -401,15 +433,18 @@
 NB_CORE dlpack::dltensor *ndarray_inc_ref(ndarray_handle *) noexcept;
 
 /// Decrease the reference count of the given ndarray object
 NB_CORE void ndarray_dec_ref(ndarray_handle *) noexcept;
 
 /// Wrap a ndarray_handle* into a PyCapsule
 NB_CORE PyObject *ndarray_wrap(ndarray_handle *, int framework,
-                               rv_policy policy) noexcept;
+                               rv_policy policy, cleanup_list *cleanup) noexcept;
+
+/// Check if an object is a known ndarray type (NumPy, PyTorch, Tensorflow, JAX)
+NB_CORE bool ndarray_check(PyObject *o) noexcept;
 
 // ========================================================================
 
 /// Print to stdout using Python
 NB_CORE void print(PyObject *file, PyObject *str, PyObject *end);
 
 // ========================================================================
@@ -459,9 +494,13 @@
                            Py_ssize_t &step, size_t &slice_length);
 
 // ========================================================================
 
 NB_CORE PyObject *repr_list(PyObject *o);
 NB_CORE PyObject *repr_map(PyObject *o);
 
+#if PY_VERSION_HEX < 0x030A0000
+NB_CORE void *type_get_slot(PyTypeObject *t, int slot_id);
+#endif
+
 NAMESPACE_END(detail)
 NAMESPACE_END(NB_NAMESPACE)
```

## nanobind/include/nanobind/nb_types.h

```diff
@@ -135,24 +135,26 @@
     NB_DECL_COMP(operator>=)
     NB_DECL_OP_1(operator-)
     NB_DECL_OP_1(operator~)
     NB_DECL_OP_2(operator+)
     NB_DECL_OP_2(operator-)
     NB_DECL_OP_2(operator*)
     NB_DECL_OP_2(operator/)
+    NB_DECL_OP_2(operator%)
     NB_DECL_OP_2(operator|)
     NB_DECL_OP_2(operator&)
     NB_DECL_OP_2(operator^)
     NB_DECL_OP_2(operator<<)
     NB_DECL_OP_2(operator>>)
     NB_DECL_OP_2(floor_div)
     NB_DECL_OP_2_I(operator+=)
     NB_DECL_OP_2_I(operator-=)
     NB_DECL_OP_2_I(operator*=)
     NB_DECL_OP_2_I(operator/=)
+    NB_DECL_OP_2_I(operator%=)
     NB_DECL_OP_2_I(operator|=)
     NB_DECL_OP_2_I(operator&=)
     NB_DECL_OP_2_I(operator^=)
     NB_DECL_OP_2_I(operator<<=)
     NB_DECL_OP_2_I(operator>>=)
 };
 
@@ -169,14 +171,16 @@
     static constexpr auto Name = detail::const_name("object");
 
     handle() = default;
     handle(const handle &) = default;
     handle(handle &&) noexcept = default;
     handle &operator=(const handle &) = default;
     handle &operator=(handle &&) noexcept = default;
+    NB_INLINE handle(std::nullptr_t, detail::steal_t) : m_ptr(nullptr) { }
+    NB_INLINE handle(std::nullptr_t) : m_ptr(nullptr) { }
     NB_INLINE handle(const PyObject *ptr) : m_ptr((PyObject *) ptr) { }
     NB_INLINE handle(const PyTypeObject *ptr) : m_ptr((PyObject *) ptr) { }
 
     const handle& inc_ref() const & noexcept {
 #if defined(NDEBUG) && !defined(Py_LIMITED_API)
         Py_XINCREF(m_ptr);
 #else
@@ -237,14 +241,15 @@
         m_ptr = o.m_ptr;
         o.m_ptr = nullptr;
         temp.dec_ref();
         return *this;
     }
 
     NB_IMPL_OP_2_IO(operator+=)
+    NB_IMPL_OP_2_IO(operator%=)
     NB_IMPL_OP_2_IO(operator-=)
     NB_IMPL_OP_2_IO(operator*=)
     NB_IMPL_OP_2_IO(operator/=)
     NB_IMPL_OP_2_IO(operator|=)
     NB_IMPL_OP_2_IO(operator&=)
     NB_IMPL_OP_2_IO(operator^=)
     NB_IMPL_OP_2_IO(operator<<=)
@@ -355,14 +360,33 @@
         detail::type_caster<T> tc;
         if (!tc.from_python(m_ptr, 0, nullptr))
             throw std::out_of_range("Conversion of nanobind::int_ failed");
         return tc.value;
     }
 };
 
+class float_ : public object {
+    NB_OBJECT_DEFAULT(float_, object, "float", PyFloat_Check)
+
+    explicit float_(handle h)
+        : object(detail::float_from_obj(h.ptr()), detail::steal_t{}) { }
+
+    explicit float_(double value)
+        : object(PyFloat_FromDouble(value), detail::steal_t{}) {
+        if (!m_ptr)
+            detail::raise_python_error();
+    }
+
+#if !defined(Py_LIMITED_API)
+    explicit operator double() const { return PyFloat_AS_DOUBLE(m_ptr); }
+#else
+    explicit operator double() const { return PyFloat_AsDouble(m_ptr); }
+#endif
+};
+
 class str : public object {
     NB_OBJECT_DEFAULT(str, object, "str", PyUnicode_Check)
 
     explicit str(handle h)
         : object(detail::str_from_obj(h.ptr()), detail::steal_t{}) { }
 
     explicit str(const char *s)
@@ -390,15 +414,18 @@
 
     const char *c_str() { return PyBytes_AsString(m_ptr); }
 
     size_t size() const { return (size_t) PyBytes_Size(m_ptr); }
 };
 
 class tuple : public object {
-    NB_OBJECT_DEFAULT(tuple, object, "tuple", PyTuple_Check)
+    NB_OBJECT(tuple, object, "tuple", PyTuple_Check)
+    tuple() : object(PyTuple_New(0), detail::steal_t()) { }
+    explicit tuple(handle h)
+        : object(detail::tuple_from_obj(h.ptr()), detail::steal_t{}) { }
     size_t size() const { return (size_t) NB_TUPLE_GET_SIZE(m_ptr); }
     template <typename T, detail::enable_if_t<std::is_arithmetic_v<T>> = 1>
     detail::accessor<detail::num_item_tuple> operator[](T key) const;
 
 #if !defined(Py_LIMITED_API) && !defined(PYPY_VERSION)
     detail::fast_iterator begin() const;
     detail::fast_iterator end() const;
@@ -408,14 +435,16 @@
 class type_object : public object {
     NB_OBJECT_DEFAULT(type_object, object, "type", PyType_Check)
 };
 
 class list : public object {
     NB_OBJECT(list, object, "list", PyList_Check)
     list() : object(PyList_New(0), detail::steal_t()) { }
+    explicit list(handle h)
+        : object(detail::list_from_obj(h.ptr()), detail::steal_t{}) { }
     size_t size() const { return (size_t) NB_LIST_GET_SIZE(m_ptr); }
 
     template <typename T> void append(T &&value);
 
     template <typename T, detail::enable_if_t<std::is_arithmetic_v<T>> = 1>
     detail::accessor<detail::num_item_list> operator[](T key) const;
 
@@ -562,14 +591,22 @@
     static bool is_ellipsis(PyObject *obj) { return obj == Py_Ellipsis; }
 
 public:
     NB_OBJECT(ellipsis, object, "EllipsisType", is_ellipsis)
     ellipsis() : object(Py_Ellipsis, detail::borrow_t()) {}
 };
 
+class not_implemented : public object {
+    static bool is_not_implemented(PyObject *obj) { return obj == Py_NotImplemented; }
+
+public:
+    NB_OBJECT(not_implemented, object, "NotImplementedType", is_not_implemented)
+    not_implemented() : object(Py_NotImplemented, detail::borrow_t()) {}
+};
+
 class callable : public object {
 public:
     NB_OBJECT(callable, object, "Callable[..., object]", PyCallable_Check)
     using object::object;
 };
 
 template <typename T> class handle_t : public handle {
@@ -697,21 +734,23 @@
 NB_IMPL_COMP(operator>=, Py_GE)
 NB_IMPL_OP_1(operator-,  PyNumber_Negative)
 NB_IMPL_OP_1(operator~,  PyNumber_Invert)
 NB_IMPL_OP_2(operator+,  PyNumber_Add)
 NB_IMPL_OP_2(operator-,  PyNumber_Subtract)
 NB_IMPL_OP_2(operator*,  PyNumber_Multiply)
 NB_IMPL_OP_2(operator/,  PyNumber_TrueDivide)
+NB_IMPL_OP_2(operator%,  PyNumber_Remainder)
 NB_IMPL_OP_2(operator|,  PyNumber_Or)
 NB_IMPL_OP_2(operator&,  PyNumber_And)
 NB_IMPL_OP_2(operator^,  PyNumber_Xor)
 NB_IMPL_OP_2(operator<<, PyNumber_Lshift)
 NB_IMPL_OP_2(operator>>, PyNumber_Rshift)
 NB_IMPL_OP_2(floor_div,  PyNumber_FloorDivide)
 NB_IMPL_OP_2_I(operator+=, PyNumber_InPlaceAdd)
+NB_IMPL_OP_2_I(operator%=, PyNumber_InPlaceRemainder)
 NB_IMPL_OP_2_I(operator-=, PyNumber_InPlaceSubtract)
 NB_IMPL_OP_2_I(operator*=, PyNumber_InPlaceMultiply)
 NB_IMPL_OP_2_I(operator/=, PyNumber_InPlaceTrueDivide)
 NB_IMPL_OP_2_I(operator|=, PyNumber_InPlaceOr)
 NB_IMPL_OP_2_I(operator&=, PyNumber_InPlaceAnd)
 NB_IMPL_OP_2_I(operator^=, PyNumber_InPlaceXor)
 NB_IMPL_OP_2_I(operator<<=,PyNumber_InPlaceLshift)
```

## nanobind/include/nanobind/ndarray.h

```diff
@@ -9,14 +9,15 @@
 
     The API below is based on the DLPack project
     (https://github.com/dmlc/dlpack/blob/main/include/dlpack/dlpack.h)
 */
 #pragma once
 
 #include <nanobind/nanobind.h>
+#include <initializer_list>
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 
 NAMESPACE_BEGIN(device)
 #define NB_DEVICE(enum_name, enum_value)                              \
     struct enum_name {                                                \
         static constexpr auto name = detail::const_name(#enum_name);  \
@@ -73,14 +74,15 @@
 struct c_contig { };
 struct f_contig { };
 struct any_contig { };
 struct numpy { };
 struct tensorflow { };
 struct pytorch { };
 struct jax { };
+struct ro { };
 
 NAMESPACE_BEGIN(detail)
 
 template<typename T> constexpr bool is_ndarray_scalar_v =
 std::is_floating_point_v<T> || std::is_integral_v<T>;
 
 NAMESPACE_END(detail)
@@ -93,15 +95,15 @@
 
     dlpack::dtype result;
 
     if constexpr (std::is_floating_point_v<T>)
         result.code = (uint8_t) dlpack::dtype_code::Float;
     else if constexpr (std::is_signed_v<T>)
         result.code = (uint8_t) dlpack::dtype_code::Int;
-    else if constexpr (std::is_same_v<T, bool>)
+    else if constexpr (std::is_same_v<std::remove_cv_t<T>, bool>)
         result.code = (uint8_t) dlpack::dtype_code::Bool;
     else
         result.code = (uint8_t) dlpack::dtype_code::UInt;
 
     result.bits = sizeof(T) * 8;
     result.lanes = 1;
 
@@ -141,15 +143,15 @@
     static void apply(ndarray_req &tr) {
         tr.dtype = dtype<T>();
         tr.req_dtype = true;
         tr.req_ro = std::is_const_v<T>;
     }
 };
 
-template <typename T> struct ndarray_arg<T, enable_if_t<std::is_integral_v<T> && !std::is_same_v<T, bool>>> {
+template <typename T> struct ndarray_arg<T, enable_if_t<std::is_integral_v<T> && !std::is_same_v<std::remove_cv_t<T>, bool>>> {
     static constexpr size_t size = 0;
 
     static constexpr auto name =
         const_name("dtype=") +
         const_name<std::is_unsigned_v<T>>("u", "") +
         const_name("int") + const_name<sizeof(T) * 8>() +
         const_name<std::is_const_v<T>>(", writable=False", "");
@@ -157,25 +159,35 @@
     static void apply(ndarray_req &tr) {
         tr.dtype = dtype<T>();
         tr.req_dtype = true;
         tr.req_ro = std::is_const_v<T>;
     }
 };
 
-template <typename T> struct ndarray_arg<T, enable_if_t<std::is_same_v<T, bool>>> {
+template <typename T> struct ndarray_arg<T, enable_if_t<std::is_same_v<std::remove_cv_t<T>, bool>>> {
     static constexpr size_t size = 0;
 
     static constexpr auto name =
         const_name("dtype=bool") +
         const_name<std::is_const_v<T>>(", writable=False", "");
 
     static void apply(ndarray_req &tr) {
         tr.dtype = dtype<T>();
         tr.req_dtype = true;
-        tr.req_ro = std::is_const_v<T>;
+        tr.req_ro |= std::is_const_v<T>;
+    }
+};
+
+template<> struct ndarray_arg<ro> {
+    static constexpr size_t size = 0;
+
+    static constexpr auto name = const_name("writable=False");
+
+    static void apply(ndarray_req &tr) {
+        tr.req_ro = true;
     }
 };
 
 template <size_t... Is> struct ndarray_arg<shape<Is...>> {
     static constexpr size_t size = sizeof...(Is);
     static constexpr auto name =
         const_name("shape=(") +
@@ -275,14 +287,33 @@
             int32_t device_id = 0) {
         m_handle = detail::ndarray_create(
             (void *) value, ndim, shape, owner.ptr(), strides, &dtype,
             std::is_const_v<Scalar>, device_type, device_id);
         m_dltensor = *detail::ndarray_inc_ref(m_handle);
     }
 
+    ndarray(std::conditional_t<std::is_const_v<Scalar>, const void *, void *> value,
+            std::initializer_list<size_t> shape,
+            handle owner = nanobind::handle(),
+            std::initializer_list<int64_t> strides = { },
+            dlpack::dtype dtype = nanobind::dtype<Scalar>(),
+            int32_t device_type = device::cpu::value,
+            int32_t device_id = 0) {
+
+        if (strides.size() != 0 && strides.size() != shape.size())
+            detail::fail("ndarray(): shape and strides have incompatible size!");
+
+        m_handle = detail::ndarray_create(
+            (void *) value, shape.size(), shape.begin(), owner.ptr(),
+            (strides.size() == 0) ? nullptr : strides.begin(), &dtype,
+            std::is_const_v<Scalar>, device_type, device_id);
+
+        m_dltensor = *detail::ndarray_inc_ref(m_handle);
+    }
+
     ~ndarray() {
         detail::ndarray_dec_ref(m_handle);
     }
 
     ndarray(const ndarray &t) : m_handle(t.m_handle), m_dltensor(t.m_dltensor) {
         detail::ndarray_inc_ref(m_handle);
     }
@@ -372,14 +403,16 @@
         return (int64_t) m_dltensor.byte_offset + index * sizeof(typename Info::scalar_type);
     }
 
     detail::ndarray_handle *m_handle = nullptr;
     dlpack::dltensor m_dltensor;
 };
 
+inline bool ndarray_check(handle h) { return detail::ndarray_check(h.ptr()); }
+
 NAMESPACE_BEGIN(detail)
 
 template <typename... Args> struct type_caster<ndarray<Args...>> {
     NB_TYPE_CASTER(ndarray<Args...>, Value::Info::name + const_name("[") +
                                         concat_maybe(detail::ndarray_arg<Args>::name...) +
                                         const_name("]"));
 
@@ -391,14 +424,14 @@
         (detail::ndarray_arg<Args>::apply(req), ...);
         value = ndarray<Args...>(ndarray_import(
             src.ptr(), &req, flags & (uint8_t) cast_flags::convert));
         return value.is_valid();
     }
 
     static handle from_cpp(const ndarray<Args...> &tensor, rv_policy policy,
-                           cleanup_list *) noexcept {
-        return ndarray_wrap(tensor.handle(), int(Value::Info::framework), policy);
+                           cleanup_list *cleanup) noexcept {
+        return ndarray_wrap(tensor.handle(), int(Value::Info::framework), policy, cleanup);
     }
 };
 
 NAMESPACE_END(detail)
 NAMESPACE_END(NB_NAMESPACE)
```

## nanobind/include/nanobind/eigen/dense.h

```diff
@@ -193,24 +193,23 @@
         }
 
         object owner;
         if (policy == rv_policy::move) {
             T *temp = new T(std::move(v));
             owner = capsule(temp, [](void *p) noexcept { delete (T *) p; });
             ptr = temp->data();
+            policy = rv_policy::reference;
         } else if (policy == rv_policy::reference_internal) {
             owner = borrow(cleanup->self());
+            policy = rv_policy::reference;
         }
 
-        rv_policy array_rv_policy =
-            policy == rv_policy::move ? rv_policy::reference : policy;
-
         object o = steal(NDArrayCaster::from_cpp(
             NDArray(ptr, ndim_v<T>, shape, owner, strides),
-            array_rv_policy, cleanup));
+            policy, cleanup));
 
         return o.release();
     }
 };
 
 /// Caster for Eigen expression templates
 template <typename T>
```

## nanobind/src/common.cpp

```diff
@@ -9,38 +9,62 @@
 
 #include <nanobind/nanobind.h>
 #include "nb_internals.h"
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
+NB_NOINLINE static builtin_exception
+create_exception(exception_type type, const char *fmt, va_list args_) {
+    char buf[512];
+    va_list args;
+
+    va_copy(args, args_);
+    int size = vsnprintf(buf, sizeof(buf), fmt, args);
+    va_end(args);
+
+    if (size < (int) sizeof(buf)) {
+        return builtin_exception(type, buf);
+    } else {
+        scoped_pymalloc<char> temp(size + 1);
+
+        va_copy(args, args_);
+        vsnprintf(temp.get(), size + 1, fmt, args);
+        va_end(args);
+
+        return builtin_exception(type, temp.get());
+    }
+}
 
 #if defined(__GNUC__)
     __attribute__((noreturn, __format__ (__printf__, 1, 2)))
 #else
     [[noreturn]]
 #endif
 void raise(const char *fmt, ...) {
-    char buf[512];
     va_list args;
-
     va_start(args, fmt);
-    int size = vsnprintf(buf, sizeof(buf), fmt, args);
+    builtin_exception err =
+        create_exception(exception_type::runtime_error, fmt, args);
     va_end(args);
+    throw err;
+}
 
-    if (size < (int) sizeof(buf))
-        throw std::runtime_error(buf);
-
-    scoped_pymalloc<char> temp(size + 1);
-
+#if defined(__GNUC__)
+    __attribute__((noreturn, __format__ (__printf__, 1, 2)))
+#else
+    [[noreturn]]
+#endif
+void raise_type_error(const char *fmt, ...) {
+    va_list args;
     va_start(args, fmt);
-    vsnprintf(temp.get(), size + 1, fmt, args);
+    builtin_exception err =
+        create_exception(exception_type::type_error, fmt, args);
     va_end(args);
-
-    throw std::runtime_error(temp.get());
+    throw err;
 }
 
 /// Abort the process with a fatal error
 #if defined(__GNUC__)
     __attribute__((noreturn, __format__ (__printf__, 1, 2)))
 #else
     [[noreturn]]
@@ -175,15 +199,15 @@
 fail:
     check(false, "nanobind::detail::module_new_submodule(): failed.");
 }
 
 // ========================================================================
 
 size_t obj_len(PyObject *o) {
-    Py_ssize_t res = PyObject_Length(o);
+    Py_ssize_t res = PyObject_Size(o);
     if (res < 0)
         raise_python_error();
     return (size_t) res;
 }
 
 size_t obj_len_hint(PyObject *o) noexcept {
 #if !defined(Py_LIMITED_API)
@@ -191,17 +215,17 @@
     if (res < 0) {
         PyErr_Clear();
         res = 0;
     }
     return (size_t) res;
 #else
     PyTypeObject *tp = Py_TYPE(o);
-    lenfunc l = (lenfunc) PyType_GetSlot(tp, Py_sq_length);
+    lenfunc l = (lenfunc) type_get_slot(tp, Py_sq_length);
     if (!l)
-        l = (lenfunc) PyType_GetSlot(tp, Py_mp_length);
+        l = (lenfunc) type_get_slot(tp, Py_mp_length);
 
     if (l) {
         Py_ssize_t res = l(o);
         if (res < 0) {
             PyErr_Clear();
             res = 0;
         }
@@ -515,14 +539,37 @@
 PyObject *int_from_obj(PyObject *o) {
     PyObject *result = PyNumber_Long(o);
     if (!result)
         raise_python_error();
     return result;
 }
 
+PyObject *float_from_obj(PyObject *o) {
+    PyObject *result = PyNumber_Float(o);
+    if (!result)
+        raise_python_error();
+    return result;
+}
+
+// ========================================================================
+
+PyObject *tuple_from_obj(PyObject *o) {
+    PyObject *result = PySequence_Tuple(o);
+    if (!result)
+        raise_python_error();
+    return result;
+}
+
+PyObject *list_from_obj(PyObject *o) {
+    PyObject *result = PySequence_List(o);
+    if (!result)
+        raise_python_error();
+    return result;
+}
+
 // ========================================================================
 
 PyObject **seq_get(PyObject *seq, size_t *size_out, PyObject **temp_out) noexcept {
     PyObject *temp = nullptr;
     size_t size = 0;
     PyObject **result = nullptr;
```

## nanobind/src/error.cpp

```diff
@@ -4,94 +4,158 @@
     Copyright (c) 2022 Wenzel Jakob
 
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #include <nanobind/nanobind.h>
+#include <cstdarg>
 #include "buffer.h"
 #include "nb_internals.h"
 
 NAMESPACE_BEGIN(NB_NAMESPACE)
 NAMESPACE_BEGIN(detail)
 
 Buffer buf(128);
 
 NAMESPACE_END(detail)
 
+#if PY_VERSION_HEX >= 0x030C0000
 python_error::python_error() {
-    PyErr_Fetch(&m_type, &m_value, &m_trace);
+    m_value = PyErr_GetRaisedException();
+    check(m_value,
+          "nanobind::python_error::python_error(): error indicator unset!");
+}
+
+python_error::~python_error() {
+    if (m_value) {
+        gil_scoped_acquire acq;
+        /* With GIL held */ {
+            // Clear error status in case the following executes Python code
+            error_scope scope;
+            Py_DECREF(m_value);
+        }
+    }
+
+    free(m_what);
+}
+
+python_error::python_error(const python_error &e)
+    : std::exception(e), m_value(e.m_value) {
+    if (m_value) {
+        gil_scoped_acquire acq;
+        Py_INCREF(m_value);
+    }
+    if (e.m_what)
+        m_what = NB_STRDUP(e.m_what);
+}
+
+python_error::python_error(python_error &&e) noexcept
+    : std::exception(e), m_value(e.m_value), m_what(e.m_what) {
+    e.m_value = nullptr;
+    e.m_what = nullptr;
+}
+
+void python_error::restore() noexcept {
+    check(m_value,
+          "nanobind::python_error::restore(): error was already restored!");
+
+    PyErr_SetRaisedException(m_value);
+    m_value = nullptr;
+}
+
+#else /* Exception handling for Python 3.11 and older versions */
+
+python_error::python_error() {
+    PyErr_Fetch(&m_type, &m_value, &m_traceback);
     check(m_type,
           "nanobind::python_error::python_error(): error indicator unset!");
 }
 
 python_error::~python_error() {
-    if (m_type || m_value || m_trace) {
+    if (m_type) {
         gil_scoped_acquire acq;
         /* With GIL held */ {
             // Clear error status in case the following executes Python code
             error_scope scope;
-            Py_XDECREF(m_type);
             Py_XDECREF(m_value);
-            Py_XDECREF(m_trace);
+            Py_XDECREF(m_type);
+            Py_XDECREF(m_traceback);
         }
     }
     free(m_what);
 }
 
 python_error::python_error(const python_error &e)
     : std::exception(e), m_type(e.m_type), m_value(e.m_value),
-      m_trace(e.m_trace) {
-    if (m_type || m_value || m_trace) {
+      m_traceback(e.m_traceback) {
+    if (m_type) {
         gil_scoped_acquire acq;
-        Py_XINCREF(m_type);
+        Py_INCREF(m_type);
         Py_XINCREF(m_value);
-        Py_XINCREF(m_trace);
+        Py_XINCREF(m_traceback);
     }
     if (e.m_what)
         m_what = NB_STRDUP(e.m_what);
 }
 
 python_error::python_error(python_error &&e) noexcept
     : std::exception(e), m_type(e.m_type), m_value(e.m_value),
-      m_trace(e.m_trace), m_what(e.m_what) {
-    e.m_type = e.m_value = e.m_trace = nullptr;
+      m_traceback(e.m_traceback), m_what(e.m_what) {
+    e.m_type = e.m_value = e.m_traceback = nullptr;
     e.m_what = nullptr;
 }
 
+void python_error::restore() noexcept {
+    check(m_type,
+          "nanobind::python_error::restore(): error was already restored!");
+
+    PyErr_Restore(m_type, m_value, m_traceback);
+    m_type = m_value = m_traceback = nullptr;
+}
+
+#endif
+
 const char *python_error::what() const noexcept {
     using detail::buf;
 
     // Return the existing error message if already computed once
     if (m_what)
         return m_what;
 
     gil_scoped_acquire acq;
 
     // Try again with GIL held
     if (m_what)
         return m_what;
 
-    PyErr_NormalizeException(&m_type, &m_value, &m_trace);
+#if PY_VERSION_HEX < 0x030C0000
+    PyErr_NormalizeException(&m_type, &m_value, &m_traceback);
     check(m_type,
-          "nanobind::python_error::what(): PyNormalize_Exception() failed!");
+          "nanobind::python_error::what(): PyErr_NormalizeException() failed!");
 
-    if (m_trace) {
-        if (PyException_SetTraceback(m_value, m_trace) < 0)
+    if (m_traceback) {
+        if (PyException_SetTraceback(m_value, m_traceback) < 0)
             PyErr_Clear();
     }
 
+    handle exc_type = m_type, exc_value = m_value;
+#else
+    handle exc_value = m_value, exc_type = exc_value.type();
+#endif
+    object exc_traceback = traceback();
+
 #if defined(Py_LIMITED_API) || defined(PYPY_VERSION)
     object mod = module_::import_("traceback"),
-           result = mod.attr("format_exception")(handle(m_type), handle(m_value), handle(m_trace));
+           result = mod.attr("format_exception")(exc_type, exc_value, exc_traceback);
     m_what = NB_STRDUP(borrow<str>(str("\n").attr("join")(result)).c_str());
 #else
     buf.clear();
-    if (m_trace) {
-        PyTracebackObject *to = (PyTracebackObject *) m_trace;
+    if (exc_traceback.is_valid()) {
+        PyTracebackObject *to = (PyTracebackObject *) exc_traceback.ptr();
 
         // Get the deepest trace possible
         while (to->tb_next)
             to = to->tb_next;
 
         PyFrameObject *frame = to->tb_frame;
         Py_XINCREF(frame);
@@ -126,36 +190,28 @@
 #if PY_VERSION_HEX >= 0x03090000
             Py_DECREF(f_code);
 #endif
             Py_DECREF(frame);
         }
     }
 
-    if (m_type) {
-        object name = handle(m_type).attr("__name__");
+    if (exc_type.is_valid()) {
+        object name = exc_type.attr("__name__");
         buf.put_dstr(borrow<str>(name).c_str());
         buf.put(": ");
     }
 
-    if (m_value)
+    if (exc_value.is_valid())
         buf.put_dstr(str(m_value).c_str());
     m_what = buf.copy();
 #endif
 
     return m_what;
 }
 
-void python_error::restore() noexcept {
-    check(m_type,
-          "nanobind::python_error::restore(): error was already restored!");
-
-    PyErr_Restore(m_type, m_value, m_trace);
-    m_type = m_value = m_trace = nullptr;
-}
-
 builtin_exception::builtin_exception(exception_type type, const char *what)
     : std::runtime_error(what ? what : ""), m_type(type) { }
 builtin_exception::~builtin_exception() { }
 
 NAMESPACE_BEGIN(detail)
 
 void register_exception_translator(exception_translator t, void *payload) {
@@ -189,8 +245,78 @@
               "already exists!");
 
     setattr(scope, name, result);
     return result.release().ptr();
 }
 
 NAMESPACE_END(detail)
+
+static void chain_error_v(handle type, const char *fmt, va_list args) noexcept {
+#if PY_VERSION_HEX >= 0x030C0000
+    PyObject *value = PyErr_GetRaisedException();
+#else
+    PyObject *tp = nullptr, *value = nullptr, *traceback = nullptr;
+
+    PyErr_Fetch(&tp, &value, &traceback);
+
+    if (tp) {
+        PyErr_NormalizeException(&tp, &value, &traceback);
+        if (traceback) {
+            PyException_SetTraceback(value, traceback);
+            Py_DECREF(traceback);
+        }
+
+        Py_DECREF(tp);
+        tp = traceback = nullptr;
+    }
+#endif
+
+#if !defined(PYPY_VERSION)
+    PyErr_FormatV(type.ptr(), fmt, args);
+#else
+    PyObject *exc_str = PyUnicode_FromFormatV(fmt, args);
+    check(exc_str, "nanobind::detail::raise_from(): PyUnicode_FromFormatV() failed!");
+    PyErr_SetObject(type.ptr(), exc_str);
+    Py_DECREF(exc_str);
+#endif
+
+    if (!value)
+        return;
+
+    PyObject *value_2 = nullptr;
+#if PY_VERSION_HEX >= 0x030C0000
+    value_2 = PyErr_GetRaisedException();
+#else
+    PyErr_Fetch(&tp, &value_2, &traceback);
+    PyErr_NormalizeException(&tp, &value_2, &traceback);
+#endif
+
+    Py_INCREF(value);
+    PyException_SetCause(value_2, value); // steals
+    PyException_SetContext(value_2, value); // steals
+
+#if PY_VERSION_HEX >= 0x030C0000
+    PyErr_SetRaisedException(value_2);
+#else
+    PyErr_Restore(tp, value_2, traceback);
+#endif
+}
+
+void chain_error(handle type, const char *fmt, ...) noexcept {
+    va_list args;
+    va_start(args, fmt);
+    chain_error_v(type, fmt, args);
+    va_end(args);
+}
+
+void raise_from(python_error &e, handle type, const char *fmt, ...) {
+    e.restore();
+
+    va_list args;
+    va_start(args, fmt);
+    chain_error_v(type, fmt, args);
+    va_end(args);
+
+    detail::raise_python_error();
+}
+
 NAMESPACE_END(NB_NAMESPACE)
```

## nanobind/src/nb_enum.cpp

```diff
@@ -340,15 +340,15 @@
     if (doc) {
         doc_obj = PyUnicode_FromString(doc);
     } else {
         doc_obj = Py_None;
         Py_INCREF(Py_None);
     }
 
-    nb_inst *inst = (nb_inst *) inst_new_impl((PyTypeObject *) type, nullptr);
+    nb_inst *inst = (nb_inst *) inst_new_int((PyTypeObject *) type);
 
     if (!doc_obj || !name_obj || !inst)
         goto error;
 
     rec = PyTuple_New(3);
     NB_TUPLE_SET_ITEM(rec, 0, name_obj);
     NB_TUPLE_SET_ITEM(rec, 1, doc_obj);
```

## nanobind/src/nb_func.cpp

```diff
@@ -137,14 +137,15 @@
     { nullptr, nullptr, nullptr, false, false }
 };
 
 static bool set_builtin_exception_status(builtin_exception &e) {
     PyObject *o;
 
     switch (e.type()) {
+        case exception_type::runtime_error: o = PyExc_RuntimeError; break;
         case exception_type::stop_iteration: o = PyExc_StopIteration; break;
         case exception_type::index_error: o = PyExc_IndexError; break;
         case exception_type::key_error: o = PyExc_KeyError; break;
         case exception_type::value_error: o = PyExc_ValueError; break;
         case exception_type::type_error: o = PyExc_TypeError; break;
         case exception_type::buffer_error: o = PyExc_BufferError; break;
         case exception_type::import_error: o = PyExc_ImportError; break;
@@ -176,14 +177,15 @@
     arg_data *args_in = std::launder((arg_data *) f->args);
 
     bool has_scope      = f->flags & (uint32_t) func_flags::has_scope,
          has_name       = f->flags & (uint32_t) func_flags::has_name,
          has_args       = f->flags & (uint32_t) func_flags::has_args,
          has_var_args   = f->flags & (uint32_t) func_flags::has_var_args,
          has_var_kwargs = f->flags & (uint32_t) func_flags::has_var_kwargs,
+         has_doc        = f->flags & (uint32_t) func_flags::has_doc,
          is_implicit    = f->flags & (uint32_t) func_flags::is_implicit,
          is_method      = f->flags & (uint32_t) func_flags::is_method,
          return_ref     = f->flags & (uint32_t) func_flags::return_ref,
          is_constructor = false;
 
     PyObject *name = nullptr;
     PyObject *func_prev = nullptr;
@@ -275,15 +277,16 @@
     // Register the function
     auto [it, success] = internals->funcs.try_emplace(func, nullptr);
     check(success,
           "nanobind::detail::nb_func_new(): internal update failed (2)!");
 
     func_data *fc = nb_func_data(func) + to_copy;
     memcpy(fc, f, sizeof(func_data_prelim<0>));
-
+    if (has_doc && fc->doc[0] == '\n')
+        fc->doc++;
 
     if (is_constructor)
         fc->flags |= (uint32_t) func_flags::is_constructor;
     if (has_args)
         fc->flags |= (uint32_t) func_flags::has_args;
 
     if (!has_name)
@@ -359,18 +362,16 @@
 /// Used by nb_func_vectorcall: generate an error when overload resolution fails
 static NB_NOINLINE PyObject *
 nb_func_error_overload(PyObject *self, PyObject *const *args_in,
                        size_t nargs_in, PyObject *kwargs_in) noexcept {
     const uint32_t count = (uint32_t) Py_SIZE(self);
     func_data *f = nb_func_data(self);
 
-    if (f->flags & (uint32_t) func_flags::is_operator) {
-        Py_INCREF(Py_NotImplemented);
-        return Py_NotImplemented;
-    }
+    if (f->flags & (uint32_t) func_flags::is_operator)
+        return not_implemented().release().ptr();
 
     buf.clear();
     buf.put_dstr(f->name);
     buf.put("(): incompatible function arguments. The following argument types "
             "are supported:\n");
 
     for (uint32_t i = 0; i < count; ++i) {
@@ -670,15 +671,16 @@
             }
         }
     }
 
     error_handler = nb_func_error_overload;
 
 done:
-    cleanup.release();
+    if (NB_UNLIKELY(cleanup.used()))
+        cleanup.release();
 
     if (NB_UNLIKELY(error_handler))
         result = error_handler(self, args_in, nargs_in, kwargs_in);
 
     return result;
 }
 
@@ -770,15 +772,16 @@
             }
         }
     }
 
     error_handler = nb_func_error_overload;
 
 done:
-    cleanup.release();
+    if (NB_UNLIKELY(cleanup.used()))
+        cleanup.release();
 
     if (NB_UNLIKELY(error_handler))
         result = error_handler(self, args_in, nargs_in, kwargs_in);
 
     return result;
 }
```

## nanobind/src/nb_internals.cpp

```diff
@@ -13,15 +13,15 @@
 
 #if defined(__GNUC__) && !defined(__clang__)
 #  pragma GCC diagnostic ignored "-Wmissing-field-initializers"
 #endif
 
 /// Tracks the ABI of nanobind
 #ifndef NB_INTERNALS_VERSION
-#  define NB_INTERNALS_VERSION 9
+#  define NB_INTERNALS_VERSION 10
 #endif
 
 /// On MSVC, debug and release builds are not ABI-compatible!
 #if defined(_MSC_VER) && defined(_DEBUG)
 #  define NB_BUILD_TYPE "_debug"
 #else
 #  define NB_BUILD_TYPE ""
```

## nanobind/src/nb_internals.h

```diff
@@ -46,33 +46,35 @@
 
     /**
      * The variable 'offset' can either encode an offset relative to the
      * nb_inst address that leads to the instance data, or it can encode a
      * relative offset to a pointer that must be dereferenced to get to the
      * instance data. 'direct' is 'true' in the former case.
      */
-    bool direct : 1;
+    uint32_t direct : 1;
 
     /// Is the instance data co-located with the Python object?
-    bool internal : 1;
+    uint32_t internal : 1;
 
     /// Is the instance properly initialized?
-    bool ready : 1;
+    uint32_t ready : 1;
 
     /// Should the destructor be called when this instance is GCed?
-    bool destruct : 1;
+    uint32_t destruct : 1;
 
     /// Should nanobind call 'operator delete' when this instance is GCed?
-    bool cpp_delete : 1;
+    uint32_t cpp_delete : 1;
 
     /// Does this instance hold reference to others? (via internals.keep_alive)
-    bool clear_keep_alive : 1;
+    uint32_t clear_keep_alive : 1;
 
     /// Does this instance use intrusive reference counting?
-    bool intrusive : 1;
+    uint32_t intrusive : 1;
+
+    uint32_t unused: 25;
 };
 
 static_assert(sizeof(nb_inst) == sizeof(PyObject) + sizeof(uint32_t) * 2);
 
 /// Python object representing a bound C++ function
 struct nb_func {
     PyObject_VAR_HEAD
@@ -251,15 +253,16 @@
 
 extern nb_internals *internals;
 extern PyTypeObject *nb_meta_cache;
 
 extern char *type_name(const std::type_info *t);
 
 // Forward declarations
-extern PyObject *inst_new_impl(PyTypeObject *tp, void *value);
+extern PyObject *inst_new_ext(PyTypeObject *tp, void *value);
+extern PyObject *inst_new_int(PyTypeObject *tp);
 extern PyTypeObject *nb_static_property_tp() noexcept;
 
 /// Fetch the nanobind function record from a 'nb_func' instance
 NB_INLINE func_data *nb_func_data(void *o) {
     return (func_data *) (((char *) o) + sizeof(nb_func));
 }
 
@@ -272,18 +275,15 @@
     #if !defined(Py_LIMITED_API)
         return (type_data *) (((char *) o) + sizeof(PyHeapTypeObject));
     #else
         return nb_type_data_static(o);
     #endif
 }
 
-extern PyObject *nb_type_name(PyTypeObject *o) noexcept;
-inline PyObject *nb_inst_name(PyObject *o) noexcept {
-        return nb_type_name(Py_TYPE(o));
-}
+extern PyObject *nb_type_name(PyObject *o) noexcept;
 
 inline void *inst_ptr(nb_inst *self) {
     void *ptr = (void *) ((intptr_t) self + self->offset);
     return self->direct ? ptr : *(void **) ptr;
 }
 
 template <typename T> struct scoped_pymalloc {
```

## nanobind/src/nb_ndarray.cpp

```diff
@@ -20,24 +20,18 @@
     bool free_shape;
     bool free_strides;
     bool call_deleter;
     bool ro;
 };
 
 static void nb_ndarray_dealloc(PyObject *self) {
+    PyTypeObject *tp = Py_TYPE(self);
     ndarray_dec_ref(((nb_ndarray *) self)->th);
-
-    freefunc tp_free;
-#if defined(Py_LIMITED_API)
-    tp_free = (freefunc) PyType_GetSlot(Py_TYPE(self), Py_tp_free);
-#else
-    tp_free = Py_TYPE(self)->tp_free;
-#endif
-
-    tp_free(self);
+    PyObject_Free(self);
+    Py_DECREF(tp);
 }
 
 static int nd_ndarray_tpbuffer(PyObject *exporter, Py_buffer *view, int) {
     nb_ndarray *self = (nb_ndarray *) exporter;
 
     dlpack::dltensor &t = self->th->ndarray->dltensor;
 
@@ -270,14 +264,38 @@
                 mt->deleter(mt);
         } else {
             PyErr_Clear();
         }
     });
 }
 
+bool ndarray_check(PyObject *o) noexcept {
+    PyTypeObject *tp = Py_TYPE(o);
+
+    PyObject *name = nb_type_name((PyObject *) tp);
+    check(name, "Could not obtain type name! (1)");
+
+    const char *tp_name = PyUnicode_AsUTF8AndSize(name, nullptr);
+    check(tp_name, "Could not obtain type name! (2)");
+
+    bool result =
+        // NumPy
+        strcmp(tp_name, "ndarray") == 0 ||
+        // PyTorch
+        strcmp(tp_name, "torch.Tensor") == 0 ||
+        // XLA
+        strcmp(tp_name, "jaxlib.xla_extension.ArrayImpl") == 0 ||
+        // Tensorflow
+        strcmp(tp_name, "tensorflow.python.framework.ops.EagerTensor") == 0;
+
+    Py_DECREF(name);
+    return result;
+}
+
+
 ndarray_handle *ndarray_import(PyObject *o, const ndarray_req *req,
                                bool convert) noexcept {
     object capsule;
     bool is_pycapsule = PyCapsule_CheckExact(o);
 
     // If this is not a capsule, try calling o.__dlpack__()
     if (!is_pycapsule) {
@@ -585,33 +603,67 @@
     if (mt)
         ndarray_dec_ref((ndarray_handle *) mt->manager_ctx);
     else
         PyErr_Clear();
 }
 
 PyObject *ndarray_wrap(ndarray_handle *th, int framework,
-                       rv_policy policy) noexcept {
+                       rv_policy policy, cleanup_list *cleanup) noexcept {
     if (!th)
         return none().release().ptr();
 
-    if (th->self) {
-        Py_INCREF(th->self);
-        return th->self;
+    bool copy;
+    switch (policy) {
+        case rv_policy::reference_internal:
+            if (cleanup && cleanup->self() != th->owner) {
+                if (th->owner) {
+                    PyErr_SetString(PyExc_RuntimeError,
+                                    "nanobind::detail::ndarray_wrap(): "
+                                    "reference_internal policy cannot be "
+                                    "applied (ndarray already has an owner)");
+                    return nullptr;
+                } else {
+                    th->owner = cleanup->self();
+                    Py_INCREF(th->owner);
+                }
+            }
+            [[fallthrough]];
+
+        case rv_policy::automatic:
+            copy = th->owner == nullptr && th->self == nullptr;
+            break;
+
+        case rv_policy::copy:
+        case rv_policy::move:
+            copy = true;
+            break;
+
+        default:
+            copy = false;
+            break;
     }
 
-    bool copy = policy == rv_policy::copy || policy == rv_policy::move;
+    if (!copy) {
+        if (th->self) {
+            Py_INCREF(th->self);
+            return th->self;
+        } else if (policy == rv_policy::none) {
+            return nullptr;
+        }
+    }
 
     if ((ndarray_framework) framework == ndarray_framework::numpy) {
         try {
-            object o = steal(PyType_GenericAlloc(nd_ndarray_tp(), 0));
-            if (!o.is_valid())
+            nb_ndarray *h = PyObject_New(nb_ndarray, nd_ndarray_tp());
+            if (!h)
                 return nullptr;
-            ((nb_ndarray *) o.ptr())->th = th;
+            h->th = th;
             ndarray_inc_ref(th);
 
+            object o = steal((PyObject *) h);
             return module_::import_("numpy")
                 .attr("array")(o, arg("copy") = copy)
                 .release()
                 .ptr();
         } catch (const std::exception &e) {
             PyErr_Format(PyExc_RuntimeError,
                          "nanobind::detail::ndarray_wrap(): could not "
@@ -647,18 +699,23 @@
     } catch (const std::exception &e) {
         PyErr_Format(PyExc_RuntimeError,
                      "nanobind::detail::ndarray_wrap(): could not import ndarray "
                      "framework: %s", e.what());
         return nullptr;
     }
 
-    object o = steal(PyCapsule_New(th->ndarray, "dltensor",
-                                   ndarray_capsule_destructor));
+    object o;
+    if (copy && (ndarray_framework) framework == ndarray_framework::none && th->self) {
+        o = borrow(th->self);
+    } else {
+        o = steal(PyCapsule_New(th->ndarray, "dltensor",
+                                       ndarray_capsule_destructor));
+        ndarray_inc_ref(th);
+    }
 
-       ndarray_inc_ref(th);
 
     if (package.is_valid()) {
         try {
             o = package.attr("from_dlpack")(o);
         } catch (const std::exception &e) {
             PyErr_Format(PyExc_RuntimeError,
                          "nanobind::detail::ndarray_wrap(): could not "
```

## nanobind/src/nb_static_property.cpp

```diff
@@ -19,45 +19,33 @@
     return NB_SLOT(PyProperty_Type, tp_descr_set)(self, cls, value);
 }
 
 PyTypeObject *nb_static_property_tp() noexcept {
     PyTypeObject *tp = internals->nb_static_property;
 
     if (NB_UNLIKELY(!tp)) {
-        PyType_Slot members;
+        PyMemberDef *members;
 
-        #if PY_VERSION_HEX >= 0x030C0000
-            int basicsize = - (int) sizeof(PyObject *),
-                itemsize = 0;
-
-            // See https://github.com/python/cpython/issues/98963
-            PyMemberDef members_def[] = {
-                { "__doc__", T_OBJECT, 0, Py_RELATIVE_OFFSET, nullptr },
-                { nullptr, 0, 0, 0, nullptr }
-            };
-
-            members = { Py_tp_members, members_def };
+        #if defined(Py_LIMITED_API)
+            members = (PyMemberDef *) PyType_GetSlot(&PyProperty_Type, Py_tp_members);
         #else
-            int basicsize = (int) PyProperty_Type.tp_basicsize,
-                itemsize = (int) PyProperty_Type.tp_itemsize;
-
-            members = { Py_tp_members, PyProperty_Type.tp_members };
+            members = PyProperty_Type.tp_members;
         #endif
 
         PyType_Slot slots[] = {
             { Py_tp_base, &PyProperty_Type },
             { Py_tp_descr_get, (void *) nb_static_property_descr_get },
-            members,
+            { Py_tp_members, members },
             { 0, nullptr }
         };
 
         PyType_Spec spec = {
             /* .name = */ "nanobind.nb_static_property",
-            /* .basicsize = */ basicsize,
-            /* .itemsize = */ itemsize,
+            /* .basicsize = */ 0,
+            /* .itemsize = */ 0,
             /* .flags = */ Py_TPFLAGS_DEFAULT,
             /* .slots = */ slots
         };
 
         tp = (PyTypeObject *) PyType_FromSpec(&spec);
         check(tp, "nb_static_property type creation failed!");
```

## nanobind/src/nb_type.cpp

```diff
@@ -43,157 +43,175 @@
 
 static int inst_init(PyObject *self, PyObject *, PyObject *) {
     const type_data *t = nb_type_data(Py_TYPE(self));
     PyErr_Format(PyExc_TypeError, "%s: no constructor defined!", t->name);
     return -1;
 }
 
-/// Allocate memory for a nb_type instance with internal or external storage
-PyObject *inst_new_impl(PyTypeObject *tp, void *value) {
+/// Allocate memory for a nb_type instance with internal storage
+PyObject *inst_new_int(PyTypeObject *tp) {
     bool gc = PyType_HasFeature(tp, Py_TPFLAGS_HAVE_GC);
-    const type_data *t = nb_type_data(tp);
-    size_t align = (size_t) t->align;
 
     nb_inst *self;
+    if (NB_LIKELY(!gc))
+        self = PyObject_New(nb_inst, tp);
+    else
+        self = (nb_inst *) PyType_GenericAlloc(tp, 0);
 
-    if (!gc) {
-        size_t size = sizeof(nb_inst);
-        if (!value) {
-            // Internal storage: space for the object and padding for alignment
-            size += t->size;
-            if (align > sizeof(void *))
-                size += align - sizeof(void *);
-        }
+    if (NB_LIKELY(self)) {
+        const type_data *t = nb_type_data(tp);
+        uint32_t align = (uint32_t) t->align;
+        bool intrusive = t->flags & (uint32_t) type_flags::intrusive_ptr;
+
+        uintptr_t payload = (uintptr_t) (self + 1);
+
+        if (NB_UNLIKELY(align > sizeof(void *)))
+            payload = (payload + align - 1) / align * align;
+
+        self->offset = (int32_t) ((intptr_t) payload - (intptr_t) self);
+        self->direct = 1;
+        self->internal = 1;
+        self->ready = 0;
+        self->destruct = 0;
+        self->cpp_delete = 0;
+        self->clear_keep_alive = 0;
+        self->intrusive = intrusive;
+        self->unused = 0;
+
+        // Update hash table that maps from C++ to Python instance
+        auto [it, success] = internals->inst_c2p.try_emplace((void *) payload, self);
+        check(success, "nanobind::detail::inst_new_int(): unexpected collision!");
+    }
+
+    return (PyObject *) self;
+
+}
 
-        self = (nb_inst *) PyObject_Malloc(size);
+/// Allocate memory for a nb_type instance with external storage
+PyObject *inst_new_ext(PyTypeObject *tp, void *value) {
+    bool gc = PyType_HasFeature(tp, Py_TPFLAGS_HAVE_GC);
+
+    nb_inst *self;
+    if (NB_LIKELY(!gc)) {
+        self = (nb_inst *) PyObject_Malloc(sizeof(nb_inst));
         if (!self)
             return PyErr_NoMemory();
-        memset(self, 0, sizeof(nb_inst));
         PyObject_Init((PyObject *) self, tp);
     } else {
         self = (nb_inst *) PyType_GenericAlloc(tp, 0);
+        if (!self)
+            return nullptr;
     }
 
-    if (!value) {
-        // Compute suitably aligned instance payload pointer
-        uintptr_t payload = (uintptr_t) (self + 1);
-        payload = (payload + align - 1) / align * align;
+    // Compute offset to instance value
+    int32_t offset = (int32_t) ((intptr_t) value - (intptr_t) self);
 
-        // Encode offset to aligned payload
-        self->offset = (int32_t) ((intptr_t) payload - (intptr_t) self);
-        self->direct = true;
-        self->internal = true;
-
-        value = (void *) payload;
-    } else {
-        // Compute offset to instance value
-        int32_t offset = (int32_t) ((intptr_t) value - (intptr_t) self);
-
-        if ((intptr_t) self + offset == (intptr_t) value) {
-            // Offset *is* representable as 32 bit value
-            self->offset = offset;
-            self->direct = true;
-        } else {
-            if (!gc) {
-                // Offset *not* representable, allocate extra memory for a pointer
-                nb_inst *self_2 =
-                    (nb_inst *) PyObject_Realloc(self, sizeof(nb_inst) + sizeof(void *));
-
-                if (!self_2) {
-                    PyObject_Free(self);
-                    return PyErr_NoMemory();
-                }
-
-                self = self_2;
+    bool direct = (intptr_t) self + offset == (intptr_t) value;
+    if (NB_UNLIKELY(!direct)) {
+        // Location is not representable as signed 32 bit offset
+        if (!gc) {
+            /// Allocate memory for an extra pointer
+            nb_inst *self_2 =
+                (nb_inst *) PyObject_Realloc(self, sizeof(nb_inst) + sizeof(void *));
+
+            if (NB_UNLIKELY(!self_2)) {
+                PyObject_Free(self);
+                return PyErr_NoMemory();
             }
 
-            *(void **) (self + 1) = value;
-            self->offset = (int32_t) sizeof(nb_inst);
-            self->direct = false;
+            self = self_2;
         }
 
-        self->internal = false;
+        *(void **) (self + 1) = value;
+        offset = (int32_t) sizeof(nb_inst);
     }
 
-    self->intrusive = t->flags & (uint32_t) type_flags::intrusive_ptr;
+    const type_data *t = nb_type_data(tp);
+    bool intrusive = t->flags & (uint32_t) type_flags::intrusive_ptr;
+
+    self->offset = offset;
+    self->direct = direct;
+    self->internal = 0;
+    self->ready = 0;
+    self->destruct = 0;
+    self->cpp_delete = 0;
+    self->clear_keep_alive = 0;
+    self->intrusive = intrusive;
+    self->unused = 0;
 
     // Update hash table that maps from C++ to Python instance
     auto [it, success] = internals->inst_c2p.try_emplace(value, self);
 
     if (NB_UNLIKELY(!success)) {
         void *entry = it->second;
 
         // Potentially convert the map value into linked list format
         if (!nb_is_seq(entry)) {
             nb_inst_seq *first = (nb_inst_seq *) PyMem_Malloc(sizeof(nb_inst_seq));
-            check(first, "nanobind::detail::inst_new(): list element "
+            check(first, "nanobind::detail::inst_new_ext(): list element "
                          "allocation failed!");
             first->inst = (PyObject *) entry;
             first->next = nullptr;
             entry = it.value() = nb_mark_seq(first);
         }
 
         nb_inst_seq *seq = nb_get_seq(entry);
         while (true) {
             check((nb_inst *) seq->inst != self,
-                  "nanobind::detail::inst_new(): duplicate instance!");
+                  "nanobind::detail::inst_new_ext(): duplicate instance!");
             if (!seq->next)
                 break;
             seq = seq->next;
         }
 
         nb_inst_seq *next = (nb_inst_seq *) PyMem_Malloc(sizeof(nb_inst_seq));
         check(next,
-              "nanobind::detail::inst_new(): list element allocation failed!");
+              "nanobind::detail::inst_new_ext(): list element allocation failed!");
 
         next->inst = (PyObject *) self;
         next->next = nullptr;
         seq->next = next;
     }
 
     return (PyObject *) self;
 }
 
-// Allocate a new instance with co-located storage
-static PyObject *inst_new(PyTypeObject *type, PyObject *, PyObject *) {
-    return inst_new_impl(type, nullptr);
-}
-
 static void inst_dealloc(PyObject *self) {
     PyTypeObject *tp = Py_TYPE(self);
     const type_data *t = nb_type_data(tp);
 
     bool gc = PyType_HasFeature(tp, Py_TPFLAGS_HAVE_GC);
-    if (gc)
+    if (NB_UNLIKELY(gc)) {
         PyObject_GC_UnTrack(self);
 
-    if (t->flags & (uint32_t) type_flags::has_dynamic_attr) {
-        PyObject *&dict = *nb_dict_ptr(self);
-        Py_CLEAR(dict);
+        if (t->flags & (uint32_t) type_flags::has_dynamic_attr) {
+            PyObject *&dict = *nb_dict_ptr(self);
+            Py_CLEAR(dict);
+        }
     }
 
     nb_inst *inst = (nb_inst *) self;
     void *p = inst_ptr(inst);
 
     if (inst->destruct) {
         check(t->flags & (uint32_t) type_flags::is_destructible,
               "nanobind::detail::inst_dealloc(\"%s\"): attempted to call "
               "the destructor of a non-destructible type!", t->name);
         if (t->flags & (uint32_t) type_flags::has_destruct)
             t->destruct(p);
     }
 
     if (inst->cpp_delete) {
-        if (t->align <= (uint32_t) __STDCPP_DEFAULT_NEW_ALIGNMENT__)
+        if (NB_LIKELY(t->align <= (uint32_t) __STDCPP_DEFAULT_NEW_ALIGNMENT__))
             operator delete(p);
         else
             operator delete(p, std::align_val_t(t->align));
     }
 
-    if (inst->clear_keep_alive) {
+    if (NB_UNLIKELY(inst->clear_keep_alive)) {
         nb_ptr_map &keep_alive = internals->keep_alive;
         nb_ptr_map::iterator it = keep_alive.find(self);
         check(it != keep_alive.end(),
               "nanobind::detail::inst_dealloc(\"%s\"): inconsistent "
               "keep_alive information", t->name);
 
         nb_weakref_seq *s = (nb_weakref_seq *) it->second;
@@ -316,15 +334,15 @@
         return rv;
 
     type_data *t = nb_type_data((PyTypeObject *) self);
 
     *t = *t_b;
     t->flags |=  (uint32_t) type_flags::is_python_type;
     t->flags &= ~((uint32_t) type_flags::has_implicit_conversions);
-    PyObject *name = nb_type_name((PyTypeObject *) self);
+    PyObject *name = nb_type_name(self);
     t->name = NB_STRDUP(PyUnicode_AsUTF8AndSize(name, nullptr));
     Py_DECREF(name);
     t->type_py = (PyTypeObject *) self;
     t->implicit = nullptr;
     t->implicit_py = nullptr;
 
     return 0;
@@ -364,40 +382,70 @@
         PyErr_Clear();
     }
 
     return NB_SLOT(PyType_Type, tp_setattro)(obj, name, value);
 }
 
 #if PY_VERSION_HEX < 0x030C0000
-#  if PY_VERSION_HEX < 0x03090000
-#    define Py_bf_getbuffer 1
-#    define Py_bf_releasebuffer 2
-#  endif
 
-template <size_t I1, size_t I2, size_t Offset> uint8_t constexpr Ei() {
+struct nb_slot {
+#if PY_VERSION_HEX < 0x030A0000
+    uint8_t indirect_1;
+    uint8_t indirect_2;
+#endif
+    uint8_t direct;
+};
+
+template <size_t I1, size_t I2, size_t Offset1, size_t Offset2> nb_slot constexpr Ei() {
     // Compile-time check to ensure that indices and alignment match our expectation
-    static_assert(I1 == I2 && (Offset % sizeof(void *)) == 0,
-                  "type_slots: internal error");
-    return (uint8_t) (Offset / sizeof(void *));
-}
+    static_assert(I1 == I2 && (Offset1 % sizeof(void *)) == 0 && (Offset2 % sizeof(void *)) == 0,
+                  "nb_slot construction: internal error");
 
-#define E(i1, p1, p2, name)                                                    \
-    Ei<i1, Py_##p2##_##name, offsetof(PyHeapTypeObject, p1.p2##_##name)>()
+#if PY_VERSION_HEX < 0x030A0000
+    size_t o = 0;
+    switch (Offset1) {
+        case offsetof(PyHeapTypeObject, as_async):    o = offsetof(PyTypeObject, tp_as_async); break;
+        case offsetof(PyHeapTypeObject, as_number):   o = offsetof(PyTypeObject, tp_as_number); break;
+        case offsetof(PyHeapTypeObject, as_mapping):  o = offsetof(PyTypeObject, tp_as_mapping); break;
+        case offsetof(PyHeapTypeObject, as_sequence): o = offsetof(PyTypeObject, tp_as_sequence); break;
+        case offsetof(PyHeapTypeObject, as_buffer):   o = offsetof(PyTypeObject, tp_as_buffer); break;
+        default: break;
+    }
+
+    return {
+        (uint8_t) (o / sizeof(void *)),
+        (uint8_t) ((Offset2 - Offset1) / sizeof(void *)),
+        (uint8_t) (Offset2 / sizeof(void *)),
+    };
+#else
+    return { (uint8_t) (Offset2 / sizeof(void *)) };
+#endif
+}
 
 // Precomputed mapping from type slot ID to an entry in the data structure
-static const uint8_t type_slots[] {
-    E(1, as_buffer, bf, getbuffer),
-    E(2, as_buffer, bf, releasebuffer),
-    E(3, as_mapping, mp, ass_subscript),
-    E(4, as_mapping, mp, length),
-    E(5, as_mapping, mp, subscript),
-    E(6, as_number, nb, absolute),
-    E(7, as_number, nb, add),
-    E(8, as_number, nb, and),
-    E(9, as_number, nb, bool),
+#define E(i1, p1, p2, name)                            \
+    Ei<i1, Py_##p2##_##name,                           \
+       offsetof(PyHeapTypeObject, p1),                 \
+       offsetof(PyHeapTypeObject, p1.p2##_##name)>()
+
+#if PY_VERSION_HEX < 0x03090000
+#  define Py_bf_getbuffer 1
+#  define Py_bf_releasebuffer 2
+#endif
+
+static constexpr nb_slot type_slots[] {
+    E(1,  as_buffer, bf, getbuffer),
+    E(2,  as_buffer, bf, releasebuffer),
+    E(3,  as_mapping, mp, ass_subscript),
+    E(4,  as_mapping, mp, length),
+    E(5,  as_mapping, mp, subscript),
+    E(6,  as_number, nb, absolute),
+    E(7,  as_number, nb, add),
+    E(8,  as_number, nb, and),
+    E(9,  as_number, nb, bool),
     E(10, as_number, nb, divmod),
     E(11, as_number, nb, float),
     E(12, as_number, nb, floor_divide),
     E(13, as_number, nb, index),
     E(14, as_number, nb, inplace_add),
     E(15, as_number, nb, inplace_and),
     E(16, as_number, nb, inplace_floor_divide),
@@ -466,14 +514,29 @@
     E(79, as_async, am, anext),
     E(80, ht_type, tp, finalize),
 #if PY_VERSION_HEX >= 0x030A0000
     E(81, as_async, am, send),
 #endif
 };
 
+#if PY_VERSION_HEX < 0x030A0000
+void *type_get_slot(PyTypeObject *t, int slot_id) {
+    nb_slot slot = type_slots[slot_id - 1];
+
+    if (PyType_HasFeature(t, Py_TPFLAGS_HEAPTYPE)) {
+        return ((void **) t)[slot.direct];
+    } else {
+        if (slot.indirect_1)
+            return ((void ***) t)[slot.indirect_1][slot.indirect_2];
+        else
+            return ((void **) t)[slot.indirect_2];
+    }
+}
+#endif
+
 #endif
 
 static PyObject *nb_type_from_metaclass(PyTypeObject *meta, PyObject *mod,
                                         PyType_Spec *spec) {
 #if PY_VERSION_HEX >= 0x030C0000
     // Life is good, PyType_FromMetaclass() is available
     return PyType_FromMetaclass(meta, mod, spec, nullptr);
@@ -531,16 +594,16 @@
     PyType_Slot *ts = spec->slots;
     bool fail = false;
     while (true) {
         int slot = ts->slot;
 
         if (slot == 0) {
             break;
-        } else if (slot < (int) sizeof(type_slots)) {
-            *(((void **) ht) + type_slots[slot - 1]) = ts->pfunc;
+        } else if (slot * sizeof(nb_slot) < (int) sizeof(type_slots)) {
+            *(((void **) ht) + type_slots[slot - 1].direct) = ts->pfunc;
         } else {
             PyErr_Format(PyExc_RuntimeError,
                          "nb_type_from_metaclass(): unhandled slot %i", slot);
             fail = true;
             break;
         }
         ts++;
@@ -704,20 +767,20 @@
               "nanobind::detail::nb_type_new(\"%s\"): multiple base types "
               "specified!", t->name);
         base = (PyObject *) t->base_py;
         check(nb_type_check(base),
               "nanobind::detail::nb_type_new(\"%s\"): base type is not a "
               "nanobind type!", t->name);
     } else if (has_base) {
-        nb_type_map::iterator it =
+        nb_type_map::iterator it2 =
             internals->type_c2p.find(std::type_index(*t->base));
-        check(it != internals->type_c2p.end(),
+        check(it2 != internals->type_c2p.end(),
                   "nanobind::detail::nb_type_new(\"%s\"): base type \"%s\" not "
                   "known to nanobind!", t->name, type_name(t->base));
-        base = (PyObject *) it->second->type_py;
+        base = (PyObject *) it2->second->type_py;
     }
 
     type_data *tb = nullptr;
     if (base) {
         // Check if the base type already has dynamic attributes
         tb = nb_type_data((PyTypeObject *) base);
         if (tb->flags & (uint32_t) type_flags::has_dynamic_attr)
@@ -727,14 +790,18 @@
            which can arise when extending trampoline base classes */
         size_t base_basicsize = sizeof(nb_inst) + tb->size;
         if (tb->align > ptr_size)
             base_basicsize += tb->align - ptr_size;
         if (base_basicsize > basicsize)
             basicsize = base_basicsize;
     }
+
+    bool base_intrusive_ptr =
+        tb && (tb->flags & (uint32_t) type_flags::intrusive_ptr);
+
     char *name_copy = NB_STRDUP(name.c_str());
 
     constexpr size_t nb_type_max_slots = 10,
                      nb_extra_slots = 80,
                      nb_total_slots = nb_type_max_slots +
                                       nb_extra_slots + 1;
 
@@ -748,15 +815,15 @@
         /* .slots = */ slots
     };
 
     if (base)
         *s++ = { Py_tp_base, (void *) base };
 
     *s++ = { Py_tp_init, (void *) inst_init };
-    *s++ = { Py_tp_new, (void *) inst_new };
+    *s++ = { Py_tp_new, (void *) inst_new_int };
     *s++ = { Py_tp_dealloc, (void *) inst_dealloc };
 
     if (has_doc)
         *s++ = { Py_tp_doc, (void *) t->doc };
 
     if (has_type_slots) {
         size_t num_avail = nb_extra_slots;
@@ -776,18 +843,16 @@
                       "type slots!", t->name);
                 *s++ = t->type_slots[i++];
             }
         }
     }
 
     bool has_traverse = false;
-    for (PyType_Slot *ts = slots; ts != s; ++ts) {
-        if (ts->slot == Py_tp_traverse)
-            has_traverse = true;
-    }
+    for (PyType_Slot *ts = slots; ts != s; ++ts)
+        has_traverse |= ts->slot == Py_tp_traverse;
 
     if (has_dynamic_attr) {
         // realign to sizeof(void*), add one pointer
         basicsize = (basicsize + ptr_size - 1) / ptr_size * ptr_size;
         basicsize += ptr_size;
 
         members[0] = PyMemberDef{ "__dictoffset__", T_PYSSIZET,
@@ -821,16 +886,15 @@
               "failed: %s!", t->name, err.what());
     }
 
     type_data *to = nb_type_data((PyTypeObject *) result);
     *to = *t; // note: slices off _init parts
     to->flags &= ~(uint32_t) type_init_flags::all_init_flags;
 
-    if (!intrusive_ptr && tb &&
-        (tb->flags & (uint32_t) type_flags::intrusive_ptr)) {
+    if (!intrusive_ptr && base_intrusive_ptr) {
         to->flags |= (uint32_t) type_flags::intrusive_ptr;
         to->set_self_py = tb->set_self_py;
     }
 
     if (!has_shared_from_this && tb &&
         (tb->flags & (uint32_t) type_flags::has_shared_from_this)) {
         to->flags |= (uint32_t) type_flags::has_shared_from_this;
@@ -930,17 +994,14 @@
             PyObject *name_py = nb_inst_name(src);
             const char *name = PyUnicode_AsUTF8AndSize(name_py, nullptr);
 #endif
             // Can't use PyErr_Warn*() if conversion failed due to a stack overflow
             fprintf(stderr,
                     "nanobind: implicit conversion from type '%s' to type '%s' "
                     "failed!\n", name, dst_type->name);
-#if defined(_WIN32)
-            fflush(stderr);
-#endif
 
 #if defined(Py_LIMITED_API)
             Py_DECREF(name_py);
 #endif
         }
 
         return false;
@@ -960,40 +1021,39 @@
     const std::type_info *cpp_type_src = nullptr;
     const bool src_is_nb_type = nb_type_check((PyObject *) src_type);
 
     type_data *dst_type = nullptr;
     nb_type_map &type_c2p = internals->type_c2p;
 
     // If 'src' is a nanobind-bound type
-    if (src_is_nb_type) {
+    if (NB_LIKELY(src_is_nb_type)) {
         type_data *t = nb_type_data(src_type);
         cpp_type_src = t->type;
 
         // Check if the source / destination typeid are an exact match
         bool valid = cpp_type == cpp_type_src || *cpp_type == *cpp_type_src;
 
         // If not, look up the Python type and check the inheritance chain
-        if (!valid) {
+        if (NB_UNLIKELY(!valid)) {
             auto it = type_c2p.find(std::type_index(*cpp_type));
             if (it != type_c2p.end()) {
                 dst_type = it->second;
                 valid = PyType_IsSubtype(src_type, dst_type->type_py);
             }
         }
 
         // Success, return the pointer if the instance is correctly initialized
-        if (valid) {
+        if (NB_LIKELY(valid)) {
             nb_inst *inst = (nb_inst *) src;
 
-            if (((flags & (uint8_t) cast_flags::construct) != 0) == inst->ready) {
+            if (NB_UNLIKELY(((flags & (uint8_t) cast_flags::construct) != 0) == (bool) inst->ready)) {
                 PyErr_WarnFormat(
                     PyExc_RuntimeWarning, 1, "nanobind: %s of type '%s'!\n",
                     inst->ready
-                        ? "attempted to initialize an already-initialized "
-                          "instance"
+                        ? "attempted to initialize an already-initialized instance"
                         : "attempted to access an uninitialized instance",
                     t->name);
                 return false;
             }
 
             *out = inst_ptr(inst);
 
@@ -1111,18 +1171,22 @@
     if (rvp == rv_policy::reference_internal && (!cleanup || !cleanup->self()))
         return nullptr;
 
     const bool intrusive = t->flags & (uint32_t) type_flags::intrusive_ptr;
     if (intrusive)
         rvp = rv_policy::take_ownership;
 
-    const bool store_in_obj = rvp == rv_policy::copy || rvp == rv_policy::move;
+    const bool create_new = rvp == rv_policy::copy || rvp == rv_policy::move;
+
+    nb_inst *inst;
+    if (create_new)
+        inst = (nb_inst *) inst_new_int(t->type_py);
+    else
+        inst = (nb_inst *) inst_new_ext(t->type_py, value);
 
-    nb_inst *inst =
-        (nb_inst *) inst_new_impl(t->type_py, store_in_obj ? nullptr : value);
     if (!inst)
         return nullptr;
 
     void *new_value = inst_ptr(inst);
     if (rvp == rv_policy::move) {
         if (t->flags & (uint32_t) type_flags::is_move_constructible) {
             if (t->flags & (uint32_t) type_flags::has_move) {
@@ -1166,15 +1230,15 @@
     // If we can find an existing C++ shared_ptr for this object, and
     // the instance we're creating just holds a pointer, then take out
     // another C++ shared_ptr that shares ownership with the existing
     // one, and tie its lifetime to the Python object. This is the
     // same thing done by the <nanobind/stl/shared_ptr.h> caster when
     // returning shared_ptr<T> to Python explicitly.
     if ((t->flags & (uint32_t) type_flags::has_shared_from_this) &&
-        !store_in_obj && t->keep_shared_from_this_alive((PyObject *) inst))
+        !create_new && t->keep_shared_from_this_alive((PyObject *) inst))
         rvp = rv_policy::reference;
     else if (is_new)
         *is_new = true;
 
     inst->destruct = rvp != rv_policy::reference && rvp != rv_policy::reference_internal;
     inst->cpp_delete = rvp == rv_policy::take_ownership;
     inst->ready = true;
@@ -1363,16 +1427,16 @@
           "nanobind::detail::nb_type_put_unique(type='%s', cpp_delete=%i): "
           "ownership status has become corrupted.",
           type_name(cpp_type), cpp_delete);
 
     nb_inst *inst = (nb_inst *) o;
 
     if (cpp_delete) {
-        check(inst->ready == is_new && inst->destruct == is_new &&
-                  inst->cpp_delete == is_new,
+        check((bool) inst->ready == is_new && (bool) inst->destruct == is_new &&
+                  (bool) inst->cpp_delete == is_new,
               "nanobind::detail::nb_type_put_unique(type='%s', cpp_delete=%i): "
               "unexpected status flags! (ready=%i, destruct=%i, cpp_delete=%i)",
               type_name(cpp_type), cpp_delete, inst->ready, inst->destruct,
               inst->cpp_delete);
 
         inst->ready = inst->destruct = inst->cpp_delete = true;
     } else {
@@ -1483,38 +1547,64 @@
 }
 
 void *nb_type_supplement(PyObject *t) noexcept {
     return nb_type_data((PyTypeObject *) t) + 1;
 }
 
 PyObject *nb_inst_alloc(PyTypeObject *t) {
-    PyObject *result = inst_new_impl(t, nullptr);
+    PyObject *result = inst_new_int(t);
+    if (!result)
+        raise_python_error();
+    return result;
+}
+
+PyObject *nb_inst_reference(PyTypeObject *t, void *ptr, PyObject *parent) {
+    PyObject *result = inst_new_ext(t, ptr);
     if (!result)
         raise_python_error();
+    nb_inst *nbi = (nb_inst *) result;
+    nbi->destruct = nbi->cpp_delete = false;
+    nbi->ready = true;
+    if (parent)
+        keep_alive(result, parent);
     return result;
 }
 
-PyObject *nb_inst_wrap(PyTypeObject *t, void *ptr) {
-    PyObject *result = inst_new_impl(t, ptr);
+PyObject *nb_inst_take_ownership(PyTypeObject *t, void *ptr) {
+    PyObject *result = inst_new_ext(t, ptr);
     if (!result)
         raise_python_error();
+    nb_inst *nbi = (nb_inst *) result;
+    nbi->destruct = nbi->cpp_delete = true;
+    nbi->ready = true;
     return result;
 }
 
 void *nb_inst_ptr(PyObject *o) noexcept {
     return inst_ptr((nb_inst *) o);
 }
 
 void nb_inst_zero(PyObject *o) noexcept {
     nb_inst *nbi = (nb_inst *) o;
-    type_data *t = nb_type_data(Py_TYPE(o));
-    memset(inst_ptr(nbi), 0, t->size);
+    type_data *td = nb_type_data(Py_TYPE(o));
+    memset(inst_ptr(nbi), 0, td->size);
     nbi->ready = nbi->destruct = true;
 }
 
+PyObject *nb_inst_alloc_zero(PyTypeObject *t) {
+    PyObject *result = inst_new_int(t);
+    if (!result)
+        raise_python_error();
+    nb_inst *nbi = (nb_inst *) result;
+    type_data *td = nb_type_data(t);
+    memset(inst_ptr(nbi), 0, td->size);
+    nbi->ready = nbi->destruct = true;
+    return result;
+}
+
 void nb_inst_set_state(PyObject *o, bool ready, bool destruct) noexcept {
     nb_inst *nbi = (nb_inst *) o;
     nbi->ready = ready;
     nbi->destruct = destruct;
     nbi->cpp_delete = destruct && !nbi->internal;
 }
 
@@ -1578,34 +1668,60 @@
         memcpy(dst_data, src_data, t->size);
         memset(src_data, 0, t->size);
     }
 
     nbi->ready = nbi->destruct = true;
 }
 
+void nb_inst_replace_move(PyObject *dst, const PyObject *src) noexcept {
+    nb_inst *nbi = (nb_inst *) dst;
+    bool destruct = nbi->destruct;
+    nbi->destruct = true;
+    nb_inst_destruct(dst);
+    nb_inst_move(dst, src);
+    nbi->destruct = destruct;
+}
+
+void nb_inst_replace_copy(PyObject *dst, const PyObject *src) noexcept {
+    nb_inst *nbi = (nb_inst *) dst;
+    bool destruct = nbi->destruct;
+    nbi->destruct = true;
+    nb_inst_destruct(dst);
+    nb_inst_copy(dst, src);
+    nbi->destruct = destruct;
+}
+
 #if defined(Py_LIMITED_API)
 type_data *nb_type_data_static(PyTypeObject *o) noexcept {
     return (type_data *) PyObject_GetTypeData((PyObject *) o, Py_TYPE((PyObject *) o));
 }
 #endif
 
-/// Fetch the name of an instance as 'char *' (must be deallocated using 'free'!)
-PyObject *nb_type_name(PyTypeObject *tp) noexcept {
-    PyObject *name = PyObject_GetAttrString((PyObject *) tp, "__name__");
-
-    if (PyType_HasFeature(tp, Py_TPFLAGS_HEAPTYPE)) {
-        PyObject *mod      = PyObject_GetAttrString((PyObject *) tp, "__module__"),
-                 *combined = PyUnicode_FromFormat("%U.%U", mod, name);
+PyObject *nb_type_name(PyObject *t) noexcept {
+    error_scope s;
+
+#if PY_VERSION_HEX >= 0x030B0000
+    PyObject *result = PyType_GetName((PyTypeObject *) t);
+#else
+    PyObject *result = PyObject_GetAttrString(t, "__name__");
+#endif
 
+    if (PyType_HasFeature((PyTypeObject *) t, Py_TPFLAGS_HEAPTYPE)) {
+        PyObject *mod = PyObject_GetAttrString(t, "__module__");
+        PyObject *combined = PyUnicode_FromFormat("%U.%U", mod, result);
         Py_DECREF(mod);
-        Py_DECREF(name);
-        name = combined;
+        Py_DECREF(result);
+        result = combined;
     }
 
-    return name;
+    return result;
+}
+
+PyObject *nb_inst_name(PyObject *o) noexcept {
+        return nb_type_name((PyObject *) Py_TYPE(o));
 }
 
 bool nb_inst_python_derived(PyObject *o) noexcept {
     return nb_type_data(Py_TYPE(o))->flags &
            (uint32_t) type_flags::is_python_type;
 }
```

## Comparing `nanobind-1.4.0.dist-info/LICENSE` & `nanobind-1.5.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `nanobind-1.4.0.dist-info/METADATA` & `nanobind-1.5.0.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: nanobind
-Version: 1.4.0
+Version: 1.5.0
 Summary: nanobind: tiny and efficient C++/Python bindings
 Home-page: https://github.com/wjakob/nanobind
 Author: Wenzel Jakob
 Author-email: wenzel.jakob@epfl.ch
 License: BSD
 Description-Content-Type: text/markdown
 License-File: LICENSE
```

## Comparing `nanobind-1.4.0.dist-info/RECORD` & `nanobind-1.5.0.dist-info/RECORD`

 * *Files 12% similar despite different names*

```diff
@@ -1,38 +1,37 @@
-nanobind/__init__.py,sha256=6vAxBQ2awAmp8v7upIOT7twSOuo7iIiD6FOHXBBQ1tg,536
+nanobind/__init__.py,sha256=9UD9oowShNqP8NiqDg5MJK7qTm_ju2baAAfLN0xfG-Y,536
 nanobind/__main__.py,sha256=pOZfAi6HXCHLnzBZ0Ax1jJ-PbFDYJ-XP51yG5AgTmjA,839
-nanobind/cmake/darwin-ld-cpython.sym,sha256=BlvfYcn-_krnQQZ_qF0APuKtsZke8jzoymkpxAK7hF0,21457
+nanobind/cmake/darwin-ld-cpython.sym,sha256=SqcBcfnx_Hmk0GEby7REHxODuuYE_6EeAJAkVpsfckc,21536
 nanobind/cmake/darwin-ld-pypy.sym,sha256=74TMJrfpAYZmXy6_TwCfDpZ6bNBJbegGl3oTR-Vy84Y,24614
-nanobind/cmake/nanobind-config.cmake,sha256=C5ya3hmLVbTR93ILQ9tHFXFyeNOnB76MTrYUTd66how,11539
+nanobind/cmake/nanobind-config.cmake,sha256=vhYZ-putGoW-wiWcYEyDAsUQbPUmNpSHZGfZyZN-Kv4,11544
 nanobind/ext/robin_map/include/tsl/robin_growth_policy.h,sha256=LJaMwboQYidGGoaldoAplZDcslLeT5sP6L8lZghVaDU,11776
 nanobind/ext/robin_map/include/tsl/robin_hash.h,sha256=9jsUsbV085jb736e5Z6MJIYUSvrwBpLYmagPsOTiglc,54550
 nanobind/ext/robin_map/include/tsl/robin_map.h,sha256=WQiZfe4hA3mzQLlJXDZQax0rWjctSnyJnB9jJJgeC6Y,28414
-nanobind/ext/robin_map/include/tsl/robin_set.h,sha256=m5o-74heDBBcvGNsGME8_Y4wiLMO8Ax8t70urBH6srk,23593
 nanobind/include/nanobind/make_iterator.h,sha256=WKcEOQc_L_Mhhk1GgwwvsysUTbSgiBCmDnm0X7K330o,5601
-nanobind/include/nanobind/nanobind.h,sha256=Ses-gspUfpCmJ9dydAC1l4rSO_MPNBT8c_iBMCSE4T8,1628
+nanobind/include/nanobind/nanobind.h,sha256=hbSmKpRjeW0c4yb2DAmnUBJheAMZwttd_vhektG_grg,1628
 nanobind/include/nanobind/nb_accessor.h,sha256=27K0E4cJYSBtD5VVsBtrLCWZTnTXXdr0IwtqLHeQ0aQ,5626
-nanobind/include/nanobind/nb_attr.h,sha256=FX-g3VwLt0DXn7D2YJSixGRPRsUFBgd1fw_OwD0VLW4,7387
-nanobind/include/nanobind/nb_call.h,sha256=kbJ6BL617m44XrkIY7kajFwBw59xcI8KGzGlgGDu0Bc,5533
-nanobind/include/nanobind/nb_cast.h,sha256=MYgPCQ_8wodwYLalnmklaNjnkJZYogL-o3p2BvEOjNI,14781
-nanobind/include/nanobind/nb_class.h,sha256=1EgUhbuz06cPRVYMrqXtWbkrI23u56BTGIf87N6WMXo,23613
+nanobind/include/nanobind/nb_attr.h,sha256=7cxcUxg3EddWZGCnucd6Tm8AoC5rO64w4V-CwjL5B-E,7399
+nanobind/include/nanobind/nb_call.h,sha256=ERAXrFSw4-2HhAiQBEGrWs4jMRWePNwYCyYts3bAS1g,5471
+nanobind/include/nanobind/nb_cast.h,sha256=RMkPjOu5_-ZLNLd2Ej0_JBfrJIqihQ6H_ZBTPJvFZwk,15640
+nanobind/include/nanobind/nb_class.h,sha256=Svp9HUi15kVXv6VhXyss5pPSzEm71uX3y60IJceGZG8,24558
 nanobind/include/nanobind/nb_defs.h,sha256=DIX45ECu-C62S2y4DzuVDS6qUdX6H6E05Omkk0HOb0g,5755
 nanobind/include/nanobind/nb_descr.h,sha256=tX2-_5kHTuIe62iGi0sqn-QehGNYGjcL32OmeWoYY2g,4129
 nanobind/include/nanobind/nb_enums.h,sha256=JSxGC4c2YyN83gmcTVV450KLJX_RTRPAHRPUhxuAvds,666
-nanobind/include/nanobind/nb_error.h,sha256=Akrj5ojzXHFA_EMXAHRhgfEWxINFkMEWzionhR7Rt3k,4168
+nanobind/include/nanobind/nb_error.h,sha256=uYstM0HNpYZ-VvsuJUmZBMspWGGi-ssZ-hNpUQKcoYM,5206
 nanobind/include/nanobind/nb_func.h,sha256=fihjY5ofALSSyFul1XtRkXgfuPqMnAFr05FSjYZS9gQ,9769
-nanobind/include/nanobind/nb_lib.h,sha256=y6dqmfwg0umRvR3D1CrNDXtTNgkHsxMoKpzlRsS8pSg,18946
+nanobind/include/nanobind/nb_lib.h,sha256=2HEh3NzB93yo5C0ZnnXVYi2Cf3G2Ijs_SB5V8senAqk,20566
 nanobind/include/nanobind/nb_misc.h,sha256=D9NdER_kwi7qHGgYtKTsjPKHIkZqcGpqG9wT9XMtT74,1167
 nanobind/include/nanobind/nb_python.h,sha256=tuHjb9Dd4X5MOILJdgOFN_7RBIAAq3Y1bL_-POIRqKU,1377
 nanobind/include/nanobind/nb_traits.h,sha256=NJAmlqi9G5fYtx2HiT0d9mcJpxsZPxDSfYFLvxemc20,6653
 nanobind/include/nanobind/nb_tuple.h,sha256=aqqTm9DkjH_SvDuPLKjU3Ya1lgs_LWyaQMkhTQRZoIc,2468
-nanobind/include/nanobind/nb_types.h,sha256=UKTEgkInNZS_bf4hEHf6UFPSxNGPg00-E0wwkdrON-8,25243
-nanobind/include/nanobind/ndarray.h,sha256=-muLI4YV-Mi5fXaAlW02JqmnRizECYu3ubcCpT55qJM,13617
+nanobind/include/nanobind/nb_types.h,sha256=7-wZiiccmWY1a4zhV6Iv7xZeaPzLzpwtsUCQTRHwbkw,26673
+nanobind/include/nanobind/ndarray.h,sha256=zbAvQBqVsKNSe53bcBUHnd6E6Jw3ElLujmifv2VG9Ls,14880
 nanobind/include/nanobind/operators.h,sha256=jSHKzNE_NDc--E65ycUsU6b0x1O_ThpzzCMV4uv5IE4,7449
 nanobind/include/nanobind/trampoline.h,sha256=Mc81_m_s4pIlZkQEfeVjFfkJ7RZZ1e8T5XOVIPSwmuk,2976
-nanobind/include/nanobind/eigen/dense.h,sha256=mFs5jGmtS7bII-tJvmSwUCDeQvt5xWO8eo5S_-jXZlg,17102
+nanobind/include/nanobind/eigen/dense.h,sha256=Zn4Q_ftFgpzCNMeeihzS7iJU5Zsi_9mKSWKicmhW3y4,17071
 nanobind/include/nanobind/eigen/sparse.h,sha256=M1y9wF0AqVaIXXywzQVFtGZ91t5z8dytv_st5CxBhjg,6486
 nanobind/include/nanobind/stl/array.h,sha256=-jdVTy9gcqjH4kBVWbm52dGecHr90rwkusJX6ucHrII,535
 nanobind/include/nanobind/stl/bind_map.h,sha256=Lk3_TbUkqGiiUC6hQBCDIs26rB98z388FHHYQogktEg,5939
 nanobind/include/nanobind/stl/bind_vector.h,sha256=m8WMOgWlpS2656YnA1MyIDkABfDanXBd7NIQljwvBjU,7420
 nanobind/include/nanobind/stl/chrono.h,sha256=BAAn1ZoY3tJVqzWnIv7tNdd3qpz6NwMsH-XQDACCWyw,8675
 nanobind/include/nanobind/stl/filesystem.h,sha256=MAGHVOW5fq7GP3HwB-UaXDADA1kkPp1Y6JVe55XNFbk,2720
 nanobind/include/nanobind/stl/function.h,sha256=wlfxVQW3_c2KUJI9AFgq1MG9F9tXHJ8ASqjENy7CC3A,2478
@@ -53,23 +52,23 @@
 nanobind/include/nanobind/stl/detail/chrono.h,sha256=bT5XK6rf52kLrrNw9PwvrOsZqsJUEYLWp3lGG3HkCT8,10571
 nanobind/include/nanobind/stl/detail/nb_array.h,sha256=WAZNfoUYHGgDQwE6GJcmJ80zAhBpVX_JG6-EVeWHglo,1680
 nanobind/include/nanobind/stl/detail/nb_dict.h,sha256=SU18AkR6yw_nZGCXkU38f1GtIpXQE4QuuWPaFFQGcFA,2655
 nanobind/include/nanobind/stl/detail/nb_list.h,sha256=6WI8NOXhQRxqyUzr7hFVhUvhOQxmOL0t8TE5tTDOXt4,2132
 nanobind/include/nanobind/stl/detail/nb_set.h,sha256=vEq2LqjblYcgFHoC0VMptmTLq9-fH4SzY2ABNBZRNnM,1942
 nanobind/include/nanobind/stl/detail/traits.h,sha256=Aaa89qY0NJpmbkRzZA8OLLkH3IBZMV1aQ5Y1u9RUoaw,3218
 nanobind/src/buffer.h,sha256=Yk2RUt38GW4uFNAhhdhMbNGfakA0ike3twEzhEuEFDQ,4218
-nanobind/src/common.cpp,sha256=n3idRyUuWCIgQzEUsld5QBRfyvsqcbz3KIzh6Re-UAE,28362
-nanobind/src/error.cpp,sha256=D4F6pAJF5bcqTx6ansIG5E2pQsrWJ-Tp8_0j5XvUZCk,5624
+nanobind/src/common.cpp,sha256=mUd7F9ffEQRvMICZ-cQqvriFOw-MZzyLS2QtBZuT22E,29558
+nanobind/src/error.cpp,sha256=lQwHe_AXSlu9JsIwMiBvi5iP6WCElsAQzasdqWx6I9o,8818
 nanobind/src/implicit.cpp,sha256=snqvYejHIbQazNgLFnszaFz1467P86R6X_caaHxrtwo,2538
-nanobind/src/nb_enum.cpp,sha256=vyQZjNi8o9RcUcFW1mIrFxuJbQQvAbf3-_3W-5thzvk,14696
-nanobind/src/nb_func.cpp,sha256=skUxrLAZ3Syblbf4rJJ5qmrcjqV5KnQ9v2GQ2Wbe2hE,39358
-nanobind/src/nb_internals.cpp,sha256=rnme8IrrDPg77nBrwWF34hZMXMLbdpKiLq_ts1yc880,14972
-nanobind/src/nb_internals.h,sha256=b6dXAuQAaQYJfuMJwbgJBP-ajXR_2XcCT4m-WAAYUsU,9801
-nanobind/src/nb_ndarray.cpp,sha256=6eLbYh4NsBFcKA4ETao9hgIzzemgbFMkAL9RlTrtnio,21147
-nanobind/src/nb_static_property.cpp,sha256=CYmAYN1h9iXrFB7uXX7blMD5Q0doszQ_GuMhYX9SSws,2348
-nanobind/src/nb_type.cpp,sha256=RRPdK_Eyr4L8t0iIPc70dlEozvNTwUyFKFI1-nA4dso,52719
+nanobind/src/nb_enum.cpp,sha256=eT8HQhXQLSDyFxbR6UOml1BlvwrxVW5yb7L6u_5hpAA,14686
+nanobind/src/nb_func.cpp,sha256=z0yHqm9z-iRbDTreZTokv5DfgwEsrfz4Y8gpxAIFU80,39611
+nanobind/src/nb_internals.cpp,sha256=UlfZ_i5TTDWmSMdp21WbWRSD6-8OupkUhZDjZ0eyVi0,14973
+nanobind/src/nb_internals.h,sha256=w7hEGpwh-VzlT8xfoRGHb3n1xHglczYE_WbfJZ1ftBo,9802
+nanobind/src/nb_ndarray.cpp,sha256=MZaRXFAqhh-4STI5LY7meMQioxHpE8190Mq2wdMKwls,22908
+nanobind/src/nb_static_property.cpp,sha256=V0k84IJyAxyZmtTHC4Q6zuyrtfTdKDd4JVdobjUUegM,1905
+nanobind/src/nb_type.cpp,sha256=nZ8fXtxc0Z3-SUmr28WVGyKLlsJSYUfKTh7pOpL4XAM,56214
 nanobind/src/trampoline.cpp,sha256=kLn60AVuvoOALLeI-g6O7zGMk8ud0ZjG4H0gmmsn34A,5144
-nanobind-1.4.0.dist-info/LICENSE,sha256=8wUJGk5XgFhwsheijqSx8WYQ7s6EV9I3D4Iqlpa3WDY,1521
-nanobind-1.4.0.dist-info/METADATA,sha256=WF51CPVEX_SLF4Xpzu96fx2aBauaKHDsp2jL_v3siic,1406
-nanobind-1.4.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-nanobind-1.4.0.dist-info/top_level.txt,sha256=3pRezwhnZCbmPhzcbPKfaw-IRYTQ6WbLWu14UZgONhs,9
-nanobind-1.4.0.dist-info/RECORD,,
+nanobind-1.5.0.dist-info/LICENSE,sha256=8wUJGk5XgFhwsheijqSx8WYQ7s6EV9I3D4Iqlpa3WDY,1521
+nanobind-1.5.0.dist-info/METADATA,sha256=16Bx8f8zZeJM8_20ZlKwLzlQDOuAKHCEPuH9EWb7heA,1406
+nanobind-1.5.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+nanobind-1.5.0.dist-info/top_level.txt,sha256=3pRezwhnZCbmPhzcbPKfaw-IRYTQ6WbLWu14UZgONhs,9
+nanobind-1.5.0.dist-info/RECORD,,
```

