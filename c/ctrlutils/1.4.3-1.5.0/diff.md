# Comparing `tmp/ctrlutils-1.4.3-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip` & `tmp/ctrlutils-1.5.0-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip`

## zipinfo {}

```diff
@@ -1,18 +1,18 @@
-Zip file size: 492311 bytes, number of entries: 16
-drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-26 15:38 ctrlutils.libs/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-26 15:38 ctrlutils-1.4.3.dist-info/
-drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-26 15:38 ctrlutils/
--rw-r--r--  2.0 unx     4111 b- defN 23-Apr-26 15:38 ctrlutils-1.4.3.dist-info/METADATA
--rw-r--r--  2.0 unx       10 b- defN 23-Apr-26 15:38 ctrlutils-1.4.3.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1016 b- defN 23-Apr-26 15:38 ctrlutils-1.4.3.dist-info/RECORD
--rw-r--r--  2.0 unx      148 b- defN 23-Apr-26 15:38 ctrlutils-1.4.3.dist-info/WHEEL
--rw-r--r--  2.0 unx     1071 b- defN 23-Apr-26 15:38 ctrlutils-1.4.3.dist-info/LICENSE
-drwxr-xr-x  2.0 unx        0 b- stor 23-Apr-26 15:38 ctrlutils/eigen/
--rwxr-xr-x  2.0 unx   581656 b- defN 23-Apr-26 15:38 ctrlutils/ctrlutils_eigen.cpython-39-x86_64-linux-gnu.so
--rw-r--r--  2.0 unx     2450 b- defN 23-Apr-26 15:38 ctrlutils/timer.py
--rw-r--r--  2.0 unx      932 b- defN 23-Apr-26 15:38 ctrlutils/numpy.py
--rwxr-xr-x  2.0 unx   712808 b- defN 23-Apr-26 15:38 ctrlutils/ctrlutils.cpython-39-x86_64-linux-gnu.so
--rw-r--r--  2.0 unx      140 b- defN 23-Apr-26 15:38 ctrlutils/__init__.py
--rw-r--r--  2.0 unx     5281 b- defN 23-Apr-26 15:38 ctrlutils/redis.py
--rw-r--r--  2.0 unx       32 b- defN 23-Apr-26 15:38 ctrlutils/eigen/__init__.py
-16 files, 1309655 bytes uncompressed, 490185 bytes compressed:  62.6%
+Zip file size: 492908 bytes, number of entries: 16
+drwxr-xr-x  2.0 unx        0 b- stor 23-Aug-07 03:58 ctrlutils-1.5.0.dist-info/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Aug-07 03:58 ctrlutils/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Aug-07 03:58 ctrlutils.libs/
+-rw-r--r--  2.0 unx     1071 b- defN 23-Aug-07 03:58 ctrlutils-1.5.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx       10 b- defN 23-Aug-07 03:58 ctrlutils-1.5.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1016 b- defN 23-Aug-07 03:58 ctrlutils-1.5.0.dist-info/RECORD
+-rw-r--r--  2.0 unx     4111 b- defN 23-Aug-07 03:58 ctrlutils-1.5.0.dist-info/METADATA
+-rw-r--r--  2.0 unx      148 b- defN 23-Aug-07 03:58 ctrlutils-1.5.0.dist-info/WHEEL
+drwxr-xr-x  2.0 unx        0 b- stor 23-Aug-07 03:58 ctrlutils/eigen/
+-rw-r--r--  2.0 unx      932 b- defN 23-Aug-07 03:58 ctrlutils/numpy.py
+-rwxr-xr-x  2.0 unx   581656 b- defN 23-Aug-07 03:58 ctrlutils/ctrlutils_eigen.cpython-39-x86_64-linux-gnu.so
+-rw-r--r--  2.0 unx     2450 b- defN 23-Aug-07 03:58 ctrlutils/timer.py
+-rw-r--r--  2.0 unx     8227 b- defN 23-Aug-07 03:58 ctrlutils/redis.py
+-rwxr-xr-x  2.0 unx   712808 b- defN 23-Aug-07 03:58 ctrlutils/ctrlutils.cpython-39-x86_64-linux-gnu.so
+-rw-r--r--  2.0 unx      140 b- defN 23-Aug-07 03:58 ctrlutils/__init__.py
+-rw-r--r--  2.0 unx       32 b- defN 23-Aug-07 03:58 ctrlutils/eigen/__init__.py
+16 files, 1312601 bytes uncompressed, 490782 bytes compressed:  62.6%
```

## zipnote {}

```diff
@@ -1,49 +1,49 @@
-Filename: ctrlutils.libs/
+Filename: ctrlutils-1.5.0.dist-info/
 Comment: 
 
-Filename: ctrlutils-1.4.3.dist-info/
+Filename: ctrlutils/
 Comment: 
 
-Filename: ctrlutils/
+Filename: ctrlutils.libs/
 Comment: 
 
-Filename: ctrlutils-1.4.3.dist-info/METADATA
+Filename: ctrlutils-1.5.0.dist-info/LICENSE
 Comment: 
 
-Filename: ctrlutils-1.4.3.dist-info/top_level.txt
+Filename: ctrlutils-1.5.0.dist-info/top_level.txt
 Comment: 
 
-Filename: ctrlutils-1.4.3.dist-info/RECORD
+Filename: ctrlutils-1.5.0.dist-info/RECORD
 Comment: 
 
-Filename: ctrlutils-1.4.3.dist-info/WHEEL
+Filename: ctrlutils-1.5.0.dist-info/METADATA
 Comment: 
 
-Filename: ctrlutils-1.4.3.dist-info/LICENSE
+Filename: ctrlutils-1.5.0.dist-info/WHEEL
 Comment: 
 
 Filename: ctrlutils/eigen/
 Comment: 
 
+Filename: ctrlutils/numpy.py
+Comment: 
+
 Filename: ctrlutils/ctrlutils_eigen.cpython-39-x86_64-linux-gnu.so
 Comment: 
 
 Filename: ctrlutils/timer.py
 Comment: 
 
-Filename: ctrlutils/numpy.py
+Filename: ctrlutils/redis.py
 Comment: 
 
 Filename: ctrlutils/ctrlutils.cpython-39-x86_64-linux-gnu.so
 Comment: 
 
 Filename: ctrlutils/__init__.py
 Comment: 
 
-Filename: ctrlutils/redis.py
-Comment: 
-
 Filename: ctrlutils/eigen/__init__.py
 Comment: 
 
 Zip file comment:
```

## ctrlutils/__init__.py

```diff
@@ -1,7 +1,7 @@
 from .timer import Timer
 from .redis import RedisClient, decode_matlab
 
 from .ctrlutils import *
 from . import eigen
 
-__version__ = "1.4.3"
+__version__ = "1.5.0"
```

## ctrlutils/redis.py

```diff
@@ -3,41 +3,55 @@
 
 Copyright 2021. All Rights Reserved.
 
 Created: May 23, 2021
 Authors: Toki Migimatsu
 """
 
-import typing
+from typing import Optional, Union
 
-import redis
 import numpy as np
+import redis
 
 
-class StringStream:
+class InputStringStream:
     def __init__(self, buffer: bytes):
         self._buffer = buffer
         self._idx = 0
 
-    def getbuffer(self) -> bytes:
+    def peek_remaining(self) -> bytes:
         return self._buffer[self._idx :]
 
     def read(self, num_bytes: int) -> bytes:
         idx_prev = self._idx
         self._idx += num_bytes
         return self._buffer[idx_prev : self._idx]
 
     def read_word(self) -> str:
-        len_word = self.getbuffer().index(b" ")
+        len_word = self.peek_remaining().index(b" ")
         word = self.read(len_word)
         self.read(1)  # Consume space.
         return word.decode("utf8")
 
 
-def decode_matlab(s: typing.Union[str, bytes]) -> np.ndarray:
+class OutputStringStream:
+    def __init__(self, buffer: Optional[list[bytes]] = None) -> None:
+        self._buffer = [] if buffer is None else buffer
+
+    def write(self, b: Union[bytes, str]) -> None:
+        if isinstance(b, str):
+            b = b.encode("utf8")
+        self._buffer.append(b)
+
+    def flush(self) -> bytes:
+        self._buffer = [b"".join(self._buffer)]
+        return self._buffer[0]
+
+
+def decode_matlab(s: Union[str, bytes]) -> np.ndarray:
     if isinstance(s, bytes):
         s = s.decode("utf8")
     s = s.strip()
     tokens = [list(map(float, row.strip().split())) for row in s.split(";")]
     return np.array(tokens).squeeze()
 
 
@@ -46,15 +60,15 @@
         return " ".join(map(str, A.tolist()))
     return "; ".join(" ".join(map(str, row)) for row in A.tolist())
 
 
 def decode_opencv(b: bytes) -> np.ndarray:
     import cv2
 
-    ss = StringStream(b)
+    ss = InputStringStream(b)
 
     mat_type = int(ss.read_word())
     if mat_type in {
         cv2.CV_8UC1,
         cv2.CV_8UC2,
         cv2.CV_8UC3,
         cv2.CV_8UC4,
@@ -64,26 +78,25 @@
         cv2.CV_16UC4,
         cv2.CV_32FC1,
         cv2.CV_32FC2,
         cv2.CV_32FC3,
         cv2.CV_32FC4,
     }:
         size = int(ss.read_word())
-        buffer = np.frombuffer(ss.getbuffer(), dtype=np.uint8)
+        buffer = np.frombuffer(ss.peek_remaining(), dtype=np.uint8)
         img = cv2.imdecode(buffer, cv2.IMREAD_UNCHANGED)
     else:
-        rows = int(ss.read_word())
-        cols = int(ss.read_word())
-        buffer = np.frombuffer(ss.getbuffer(), dtype=np.uint8)
-        img = buffer.reshape((rows, cols))
+        raise ValueError(f"Unsupported image type {mat_type}.")
 
     return img
 
+
 def encode_opencv(img: np.ndarray) -> bytes:
     import cv2
+
     def np_to_cv_type(img: np.ndarray):
         if img.dtype == np.uint8:
             if len(img.shape) == 2 or img.shape[2] == 1:
                 return cv2.CV_8UC1
             elif img.shape[2] == 2:
                 return cv2.CV_8UC2
             elif img.shape[2] == 3:
@@ -104,72 +117,161 @@
                 return cv2.CV_32FC1
             elif img.shape[2] == 2:
                 return cv2.CV_32FC2
             elif img.shape[2] == 3:
                 return cv2.CV_32FC3
             elif img.shape[2] == 4:
                 return cv2.CV_32FC4
-        raise ArgumentError("Unsupported image type {img.dtype}, {img.shape[2]} channels")
+        raise ValueError(
+            f"Unsupported image type {img.dtype}, {img.shape[2] if len(img.shape) > 2 else 1} channels"
+        )
 
-    buffer = []
     type_img = np_to_cv_type(img)
-    buffer.append(f"{type_img} ".encode("utf8"))
 
     if img.dtype in (np.uint8, np.uint16):
-        _, png = cv2.imencode(".png", img)
-        buffer.append(f"{len(png)} ".encode("utf8"))
-        buffer.append(png.tobytes())
+        _, data = cv2.imencode(".png", img)
     elif img.dtype == np.float32:
-        _, exr = cv2.imencode(".exr", img)
-        buffer.append(f"{len(exr)} ".encode("utf8"))
-        buffer.append(exr.tobytes())
-    else:
-        buffer.append(f"{img.shape[0]} {img.shape[1]} ".encode("utf8"))
-        buffer.append(img.tobytes())
+        _, data = cv2.imencode(".exr", img)
+
+    ss = OutputStringStream()
+    ss.write(f"{type_img} {len(data)} ")
+    ss.write(data.tobytes())
+
+    return ss.flush()
+
 
-    return b"".join(buffer)
+def decode_tensor(b: bytes) -> np.ndarray:
+    ss = InputStringStream(b)
+
+    # Parse shape opening delimiter.
+    w = ss.read_word()
+    if w != "(":
+        raise ValueError(f"Expected '(' at index 0 but found {w} instead.")
+
+    # Parse shape.
+    shape = []
+    while True:
+        w = ss.read_word()
+        if w == ")":
+            break
+        shape.append(int(w))
+
+    # Parse dtype
+    dtype = np.dtype(ss.read_word())
+
+    # Parse data.
+    tensor = np.frombuffer(ss.peek_remaining(), dtype=dtype)
+    tensor = tensor.reshape(shape)
+
+    return tensor
+
+
+def encode_tensor(tensor: np.ndarray) -> bytes:
+    ss = OutputStringStream()
+    shape = " ".join(map(str, tensor.shape))
+    dtype = str(tensor.dtype)
+    ss.write(f"( {shape} ) {dtype} ")
+    ss.write(tensor.tobytes())
+    return ss.flush()
 
 
 class RedisClient(redis.Redis):
     def __init__(
         self,
         host: str = "127.0.0.1",
         port: int = 6379,
-        password: typing.Optional[str] = None,
-    ):
+        password: Optional[str] = None,
+    ) -> None:
         super().__init__(host=host, port=port, password=password)
 
-    def pipeline(self, transaction=True, shard_hint=None):
+    def pipeline(self, transaction: bool = True, shard_hint=None) -> "Pipeline":
         return Pipeline(
             self.connection_pool, self.response_callbacks, transaction, shard_hint
         )
 
+    def get(self, key: str, decode: Optional[str] = None) -> str:
+        val = super().get(key)
+        if decode is not None:
+            return val.decode("utf8")
+        return val
+
     def get_image(self, key: str) -> np.ndarray:
         """Gets a cv::Mat image from Redis."""
-        val = self.get(key)
-        return decode_opencv(val)
+        b_val = super().get(key)
+        return decode_opencv(b_val)
 
-    def set_image(self, key: str, val: np.ndarray):
+    def set_image(self, key: str, val: np.ndarray) -> bool:
         """Sets a cv::Mat in Redis."""
-        self.set(key, encode_opencv(val))
+        return self.set(key, encode_opencv(val))
 
     def get_matrix(self, key: str) -> np.ndarray:
         """Gets an Eigen::Matrix or Eigen::Vector from Redis."""
-        val = self.get(key).decode("utf8")
-        return decode_matlab(val)
+        b_val = self.get(key)
+        return decode_matlab(b_val)
 
-    def set_matrix(self, key: str, val: np.ndarray):
+    def set_matrix(self, key: str, val: np.ndarray) -> bool:
         """Sets an Eigen::Matrix or Eigen::Vector in Redis."""
-        self.set(key, encode_matlab(val))
+        return self.set(key, encode_matlab(val))
+
+    def get_tensor(self, key: str) -> np.ndarray:
+        """Gets a np.ndarray from Redis."""
+        b_val = super().get(key)
+        return decode_tensor(b_val)
+
+    def set_tensor(self, key: str, val: np.ndarray) -> bool:
+        """Sets a np.ndarray in Redis."""
+        return self.set(key, encode_tensor(val))
 
 
 class Pipeline(redis.client.Pipeline):
     def __init__(self, connection_pool, response_callbacks, transaction, shard_hint):
         super().__init__(connection_pool, response_callbacks, transaction, shard_hint)
+        self._decode_fns = []
+
+    def get(self, key: str, decode: Optional[str] = None) -> "Pipeline":
+        super().get(key)
+        self._decode_fns.append(None if decode is None else lambda b: b.decode(decode))
+        return self
+
+    def set(self, key: str, val) -> "Pipeline":
+        super().set(key, val)
+        self._decode_fns.append(None)
+        return self
+
+    def get_image(self, key: str) -> "Pipeline":
+        """Gets a cv::Mat from Redis."""
+        super().get(key)
+        self._decode_fns.append(decode_opencv)
+        return self
 
-    def set_image(self, key: str, val: np.ndarray):
+    def set_image(self, key: str, val: np.ndarray) -> "Pipeline":
         """Sets a cv::Mat in Redis."""
-        self.set(key, encode_opencv(val))
+        return self.set(key, encode_opencv(val))
 
-    def set_matrix(self, key: str, val: np.ndarray):
+    def get_matrix(self, key: str) -> "Pipeline":
+        """Gets an Eigen::Matrix or Eigen::Vector from Redis."""
+        super().get(key)
+        self._decode_fns.append(decode_matlab)
+        return self
+
+    def set_matrix(self, key: str, val: np.ndarray) -> "Pipeline":
         """Sets an Eigen::Matrix or Eigen::Vector in Redis."""
-        self.set(key, encode_matlab(val))
+        return self.set(key, encode_matlab(val))
+
+    def get_tensor(self, key: str) -> "Pipeline":
+        """Gets a tensor from Redis."""
+        super().get(key)
+        self._decode_fns.append(decode_tensor)
+        return self
+
+    def set_tensor(self, key: str, val: np.ndarray) -> "Pipeline":
+        """Sets a tensor in Redis."""
+        return self.set(key, encode_tensor(val))
+
+    def execute(self) -> list:
+        responses = super().execute()
+        decoded_responses = [
+            decode_fn(response) if decode_fn is not None else response
+            for response, decode_fn in zip(responses, self._decode_fns)
+        ]
+        self._decode_fns = []
+        return decoded_responses
```

## Comparing `ctrlutils-1.4.3.dist-info/METADATA` & `ctrlutils-1.5.0.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: ctrlutils
-Version: 1.4.3
+Version: 1.5.0
 Summary: Python robot control utils
 Author-email: Toki Migimatsu <takatoki@cs.stanford.edu>
 License: MIT License
         
         Copyright (c) 2019 Toki Migimatsu
         
         Permission is hereby granted, free of charge, to any person obtaining a copy
```

## Comparing `ctrlutils-1.4.3.dist-info/RECORD` & `ctrlutils-1.5.0.dist-info/RECORD`

 * *Files 17% similar despite different names*

```diff
@@ -1,12 +1,12 @@
-ctrlutils-1.4.3.dist-info/METADATA,sha256=HcOsXesEs_5wh-siNRsm7Okf3Tw0NxxQ-WDYbEwfSSk,4111
-ctrlutils-1.4.3.dist-info/top_level.txt,sha256=LsbhAt_KCv5eeJCPrve2wwt7rtLECpctHveACa_U26U,10
-ctrlutils-1.4.3.dist-info/RECORD,,
-ctrlutils-1.4.3.dist-info/WHEEL,sha256=gREe7-l-MJWbGZG46A7WHnwwUSxA3XJYHQvGGLzmBNU,148
-ctrlutils-1.4.3.dist-info/LICENSE,sha256=B1HUZpuAcNS-Wnw5wzwjjpwnGGbDukeRlLp3xV4ohOo,1071
+ctrlutils-1.5.0.dist-info/LICENSE,sha256=B1HUZpuAcNS-Wnw5wzwjjpwnGGbDukeRlLp3xV4ohOo,1071
+ctrlutils-1.5.0.dist-info/top_level.txt,sha256=LsbhAt_KCv5eeJCPrve2wwt7rtLECpctHveACa_U26U,10
+ctrlutils-1.5.0.dist-info/RECORD,,
+ctrlutils-1.5.0.dist-info/METADATA,sha256=Fv2r_lMQD0wultcLBuzMDSkguwgLFF4q3RFjpmg4nv4,4111
+ctrlutils-1.5.0.dist-info/WHEEL,sha256=H5cLyqCStTVt2mWbU9Xk595q1RFUtYlkZE0VExHsBVU,148
+ctrlutils/numpy.py,sha256=MdmNTNrvOks5PKtZwvnqwNJ04PhcHu3x2Fg8PKeeHlg,932
 ctrlutils/ctrlutils_eigen.cpython-39-x86_64-linux-gnu.so,sha256=vTgkb-ZjSS4h7hryGM1T9mXqZWnfJ_xstjeekfxC3-Y,581656
 ctrlutils/timer.py,sha256=Uwvb9rKVA-t1Stzft1UowflGDbWT4bZHYPFw82Twd3Q,2450
-ctrlutils/numpy.py,sha256=MdmNTNrvOks5PKtZwvnqwNJ04PhcHu3x2Fg8PKeeHlg,932
+ctrlutils/redis.py,sha256=_alwcLItIipE7Qdm9-vtzMIlaRDjf_lq5SgAcemvoTA,8227
 ctrlutils/ctrlutils.cpython-39-x86_64-linux-gnu.so,sha256=EuacKZBbINUhWYBqdryOVM6cfKk5q4NNRRQmeLgI5Lw,712808
-ctrlutils/__init__.py,sha256=U3-TBw7rIVSllzTt08CDjhu0_5d8FkM21GA68FtAWvs,140
-ctrlutils/redis.py,sha256=SN88oqFwokOiRbYGA8qwA8wvpYYm2qjcLJ-psk4oe6A,5281
+ctrlutils/__init__.py,sha256=JxO8iBklOf6ZJHQMGiliHQJSq9ztc29u4edDP8W1IK8,140
 ctrlutils/eigen/__init__.py,sha256=ld360uIQ2Tp5mQGPDnC6N-UQtxo9KSQYoNVXnmcak9g,32
```

## Comparing `ctrlutils-1.4.3.dist-info/LICENSE` & `ctrlutils-1.5.0.dist-info/LICENSE`

 * *Files identical despite different names*

